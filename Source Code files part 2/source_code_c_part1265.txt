goto Done;
    }
    wsprintfW(
        pwszData,
        TEXT( "%s%c%s%c" ),
        DNS_BACKUP_LOG_BACK_FILE,
        0,
        g_pwszLogFileName,
        0 );

    //
    //  Open the backup key.
    //

    rc = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                DNS_BACKUP_KEY_NAME,
                0,
                KEY_WRITE,
                &hkey );
    if ( rc != ERROR_SUCCESS )
    {
        DNS_DEBUG( INIT, ( "%s: rc=%lu from RegOpenKey\n", fn, rc ));
        goto Done;
    }

    //
    //  Set our exclusion value.
    //

    rc = RegSetValueExW(
                hkey,
                DNS_BACKUP_VALUE_NAME,
                0,
                REG_MULTI_SZ,
                ( PBYTE ) pwszData,
                cbData );
    if ( rc != ERROR_SUCCESS )
    {
        DNS_DEBUG( INIT, ( "%s: rc=%lu from RegSetValue\n", fn, rc ));
        goto Done;
    }

    //
    //  Cleanup and return
    //

    Done:

    FREE_HEAP( pwszData );
    if ( hkey )
    {
        RegCloseKey( hkey );
    }
    
    DNS_DEBUG( INIT, (
        "%s: rc=%lu writing key\n  HKLM\\%S\n", fn,
        rc,
        DNS_BACKUP_KEY_NAME ));

    return;
}   //  regenerateBackupExclusionKey



DNS_STATUS
Log_InitializeLogging(
    BOOL        fAlreadyLocked
    )
/*++

Routine Description:

    Initialize logging.

    This routine can be called in three scenario:

    1) On server startup
    2) On continuation, from writeAndResetLogBuffer()
    3) From the config module, when the SrvCfg_pwsLogFilePath is changed

Arguments:

    fAlreadyLocked: if FALSE, this function will acquire the log lock
        before touching any globals, and will release the lock before
        returning, if TRUE then the caller already has the lock

Return Value:

    Error code from file open/move operation or ERROR_SUCCESS.

--*/
{
    BOOL            fUnlockOnExit = FALSE;
    DNS_STATUS      status = ERROR_SUCCESS;

    //
    //  On the first call to this function, initialize module globals.
    //

    if ( !fLogCsInit )
    {
        InitializeCriticalSection( &csLogLock );
        fLogCsInit = TRUE;
        LOCK_LOG();
        fUnlockOnExit = TRUE;
    }
    else if ( !fAlreadyLocked )
    {
        LOCK_LOG();
        fUnlockOnExit = TRUE;
    }

    if ( hLogFile )
    {
        CloseHandle( hLogFile );
        hLogFile = NULL;
    }

    //
    //  Move any existing file to backup directory. 
    //

    if ( g_pwszLogFileName )
    {
        if ( MoveFileEx(
                g_pwszLogFileName,
                LOG_FILE_BACKUP_PATH,
                MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED ) == 0 )
        {
            DNS_PRINT((
                "ERROR: failed back up log file %S to %S\n"
                "\tstatus = %d\n",
                g_pwszLogFileName,
                LOG_FILE_BACKUP_PATH,
                GetLastError() ));
            //
            //  Losing the backup file is not life-threatening, so don't bother
            //  to log an event or notify the admin. More hassle than it's worth.
            //
        }
    }
    Timeout_Free( g_pwszLogFileName );
    g_pwszLogFileName = NULL;
    Timeout_Free( g_pwszLogFileDrive );
    g_pwszLogFileDrive = NULL;

    //
    //  Take the SrvCfg input log file path and turn it into a "real"
    //  file path that we can open. Note: we re-massage the log file
    //  every time even if the global file path has not changed. This
    //  is inefficient but it should be performed that often so don't
    //  worry about it.
    //

    massageLogFile( SrvCfg_pwsLogFilePath );

    //
    //  Rewrite log file exclusion key.
    //

    regenerateBackupExclusionKey();

    //
    //  Open log file
    //

    hLogFile = OpenWriteFileEx(
                    g_pwszLogFileName,
                    FALSE           // overwrite
                    );
    if ( !hLogFile )
    {
        status = GetLastError();
        DNS_PRINT((
            "ERROR: failed to open log file %S\n"
            "\tstatus = %d\n",
            g_pwszLogFileName,
            status ));

        //
        //  Why does this function return ERROR_IO_PENDING? Not helpful!
        //  

        if ( status == ERROR_IO_PENDING )
        {
            status = ERROR_FILE_NOT_FOUND;
        }
        goto Cleanup;
    }

    //  set\reset buffer globals

    RtlZeroMemory(
        & LogBuffer,
        sizeof(BUFFER) );

    InitializeFileBuffer(
        & LogBuffer,
        pchLogBuffer,
        LOG_BUFFER_LENGTH,
        hLogFile );

#if 0
    // this doesn't set end of buffer properly
    LogBuffer.pchStart  = pchLogBuffer;
    LogBuffer.cchLength = LOG_BUFFER_LENGTH;

    RESET_BUFFER( &LogBuffer );
#endif

    BytesWrittenToLog = 0;


    //  write basic info
    //
    //  DEVNOTE: could write log encoding message
    //

    if ( SrvCfg_fStarted )
    {
        writeLogBootInfo();
        writeLogWrapInfo();
        writeMessageInfoHeader();
    }
    else
    {
        writeLogBootInfo();
        writeMessageInfoHeader();
    }

    DNS_DEBUG( INIT, (
        "Initialized logging:  level = %p\n"
        "\thandle %p\n",
        SrvCfg_dwLogLevel,
        hLogFile ));

    Cleanup:

    #if DBG
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( INIT, (
            "error %d setting log file to %S\n",
            status,
            SrvCfg_pwsLogFilePath ));
    }
    #endif

    if ( fUnlockOnExit )
    {
        UNLOCK_LOG();
    }
    return status;
}



VOID
Log_Shutdown(
    VOID
    )
/*++

Routine Description:

    Shutdown logging.

    Mostly just get rid of globals, since the heap will soon be destroyed, 
    and if we keep pointers global pointers around they will be invalid.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    //  Final log processing.
    //

    Log_PushToDisk();

    if ( hLogFile )
    {
        CloseHandle( hLogFile );
        hLogFile = NULL;
    }

    //
    //  Cleanup globals.
    //

    g_pwszLogFileName = NULL;
    g_pwszLogFileDrive = NULL;
    g_fLastLogWasDiskFullMsg = FALSE;
}   //  Log_Shutdown



VOID
Log_PushToDisk(
    VOID
    )
/*++

Routine Description:

    Push buffered log data to disk.

    This is simply the safe, locking version of the private
    writeAndResetLogBuffer() routine.
    It is specifically designed to be called at shutdown but can
    be called by any random thread.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if ( !hLogFile )
    {
        return;
    }
    LOCK_LOG();
    writeAndResetLogBuffer();
    UNLOCK_LOG();
}

//
//  End of log.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\nameutil.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    nameutil.h

Abstract:

    Domain Name System (DNS) Server

    Name utility definitions.

Author:

    Jim Gilroy (jamesg)     February 1995

Revision History:

--*/

#ifndef _NAMEUTIL_INCLUDED_
#define _NAMEUTIL_INCLUDED_


//
//  Simple downcase for ASCII
//

#define DOWNCASE_ASCII(ch)      ((ch)+ 0x20)

//  no side effects allowed

#define IS_ASCII_UPPER(ch)      (ch <= 'Z' && ch >= 'A')



//
//  Reading and writing names\strings to file
//

//
//  Character attributes bitfields
//
//  Read
//      - can be read ok (directly)
//      - terminates token
//      - terminates quoted string
//
//  Print
//      - print quoted in token (unquoted string)
//      - print octal in token
//      - print quoted in quoted string
//      - print octal in quoted string
//

#define B_CHAR_NON_RFC          0x0001
#define B_NUMBER                0x0002
#define B_UPPER                 0x0004
#define B_SLASH                 0x0008
#define B_DOT                   0x0010

#define B_READ_TOKEN_STOP       0x0100
#define B_READ_STRING_STOP      0x0200
#define B_READ_WHITESPACE       0x0400

#define B_PRINT_TOKEN_QUOTED    0x1000
#define B_PRINT_TOKEN_OCTAL     0x2000
#define B_PRINT_STRING_QUOTED   0x4000
#define B_PRINT_STRING_OCTAL    0x8000

//
//  Handy combinations
//

//  combined mask to mark characters that stop read for token or string

#define B_READ_STOP             (B_READ_TOKEN_STOP | B_READ_STRING_STOP)

//  mask for chars that need special processing
//  if character doesn't hit mask, then can be skipped without checking
//  for further processing

#define B_READ_MASK             (B_READ_STOP | B_READ_WHITESPACE | B_SLASH)


//  parsing name special chars are slash and dot

#define B_PARSE_NAME_MASK       (B_DOT | B_SLASH)


#define B_PRINT_QUOTED          (B_PRINT_TOKEN_QUOTED | B_PRINT_STRING_QUOTED)
#define B_PRINT_OCTAL           (B_PRINT_TOKEN_OCTAL | B_PRINT_STRING_OCTAL)

#define B_PRINT_TOKEN_MASK      (B_PRINT_TOKEN_QUOTED | B_PRINT_TOKEN_OCTAL)
#define B_PRINT_STRING_MASK     (B_PRINT_STRING_QUOTED | B_PRINT_STRING_OCTAL)

#define B_PRINT_MASK            (B_PRINT_TOKEN_MASK | B_PRINT_STRING_MASK)

//
//  printable characters with no special meaning
//

#define FC_RFC          (0)
#define FC_LOWER        (0)
#define FC_UPPER        (B_UPPER)
#define FC_NUMBER       (0)
#define FC_NON_RFC      (B_CHAR_NON_RFC)

//
//  special chars -- ; ( )
//      - terminates token
//      - does NOT terminate quoted string
//      - print quoted in token
//      - print directly in quoted string
//

#define FC_SPECIAL      (B_READ_TOKEN_STOP | B_PRINT_TOKEN_QUOTED)

//
//  dot
//      - no special read token action
//      - but special meaning in names (label separator)
//      - print quoted in name labels (hence all unquote strings) to avoid being
//          taken as label separator
//      - print directly in quoted string
//

#define FC_DOT          (B_DOT | B_PRINT_TOKEN_QUOTED)

//
//  quote
//      - no read effect in token
//      - terminates quoted string
//      - print quoted always (to avoid being taken as string start\stop)
//

#define FC_QUOTE        (B_READ_STRING_STOP | B_PRINT_QUOTED)

//
//  slash
//      - on read, turns on quote, or turns off if on, no termination effect
//      - print quoted always
//

#define FC_SLASH        (B_SLASH | B_PRINT_QUOTED)

//
//  blank
//      - is whitespace
//      - terminates token
//      - no terminate quoted string
//      - print octal in token
//      - print directly in quoted string
//

#define FC_BLANK        (B_READ_WHITESPACE | B_READ_TOKEN_STOP | B_PRINT_TOKEN_OCTAL)

//
//  tab
//      - is whitespace
//      - terminates token
//      - no terminate quoted string
//      - print octal always
//

#define FC_TAB          (B_READ_WHITESPACE | B_READ_TOKEN_STOP | B_PRINT_OCTAL)

//
//  return
//      - is whitespace
//      - terminates token or string
//      - print octal always
//

#define FC_RETURN       (B_READ_WHITESPACE | B_READ_STOP | B_PRINT_OCTAL)

//
//  newline
//      - unlike return, not whitespace, we use as official EOL token
//      - terminates token or string
//      - print octal always
//

#define FC_NEWLINE      (B_READ_STOP | B_PRINT_OCTAL)

//
//  control chars and other unprintables
//      - no read affect
//      - print octal always
//

#define FC_OCTAL        (B_CHAR_NON_RFC | B_PRINT_OCTAL)

//
//  zero
//      - treat as dot on read (some RPC strings may have NULL terminator)
//      - print octal always
//

#define FC_NULL         (B_DOT | B_CHAR_NON_RFC | B_PRINT_OCTAL)


//
//  treat HIGH (>127) characters as unprintable and
//      print octal equivalents
//

#define FC_HIGH         (FC_OCTAL)





//
//  Character to character type mapping table
//

extern  WORD    DnsFileCharPropertyTable[];


//
//  File name\string read routines
//

VOID
Name_VerifyValidFileCharPropertyTable(
    VOID
    );

//
//  Write name or string to file utils
//
//  Flag indicates slightly differing semantics for special characters
//  for different types of writes.
//
//

#define  FILE_WRITE_NAME_LABEL      (0)
#define  FILE_WRITE_QUOTED_STRING   (1)
#define  FILE_WRITE_DOTTED_NAME     (2)
#define  FILE_WRITE_FILE_NAME       (3)

PCHAR
FASTCALL
File_PlaceStringInFileBuffer(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      DWORD           dwFlag,
    IN      PCHAR           pchString,
    IN      DWORD           dwStringLength
    );

PCHAR
FASTCALL
File_PlaceNodeNameInFileBuffer(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PDB_NODE        pNode,
    IN      PDB_NODE        pNodeStop
    );

PCHAR
File_WriteRawNameToFileBuffer(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PRAW_NAME       pName,
    IN      PZONE_INFO      pZone
    );

#define File_WriteDbaseNameToFileBuffer(a,b,c,d) \
        File_WriteRawNameToFileBuffer(a,b,(c)->RawName,d)

//
//  File read name
//

DNS_STATUS
Name_ConvertFileNameToCountName(
    OUT     PCOUNT_NAME     pCountName,
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength     OPTIONAL
    );

#define Name_ConvertFileNameToDbaseName(a,b,c) \
        Name_ConvertFileNameToCountName((a),(b),(c))

#define Name_ConvertDottedNameToDbaseName(a,b,c) \
        Name_ConvertFileNameToDbaseName((a),(b),(c))


//
//  Name utilites
//

PCHAR
Wire_SkipPacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacketName
    );


//
//  Lookup name utilites (lookname.c)
//

BOOL
Name_ConvertDottedNameToLookupName(
    IN      PCHAR           pchDottedName,
    IN      DWORD           cchDottedNameLength,    OPTIONAL
    OUT     PLOOKUP_NAME    pLookupName
    );

BOOL
Name_AppendLookupName(
    IN OUT  PLOOKUP_NAME    pLookupName,
    IN      PLOOKUP_NAME    pAppendName
    );

DWORD
Name_ConvertLookupNameToDottedName(
    OUT     PCHAR           pchDottedName,
    IN      PLOOKUP_NAME    pLookupName
    );

VOID
Name_WriteLookupNameForNode(
    IN      PDB_NODE        pNode,
    OUT     PLOOKUP_NAME    pLookupName
    );

BOOL
Name_LookupNameToIpAddress(
    IN      PLOOKUP_NAME    pLookupName,
    OUT     PIP_ADDRESS     pIpAddress
    );

BOOL
Name_WriteLookupNameForIpAddress(
    IN      LPSTR           pszIpAddress,
    IN      PLOOKUP_NAME    pLookupName
    );

BOOL
Name_ConvertRawNameToLookupName(
    IN      PCHAR           pchRawName,
    OUT     PLOOKUP_NAME    pLookupName
    );

BOOL
Name_ConvertPacketNameToLookupName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacketName,
    OUT     PLOOKUP_NAME    pLookupName
    );

BOOL
Name_CompareLookupNames(
    IN      PLOOKUP_NAME    pName1,
    IN      PLOOKUP_NAME    pName2
    );


//
//  Name and node signatures (nameutil.c)
//

DWORD
FASTCALL
Name_MakeNodeNameSignature(
    IN OUT  PDB_NODE        pNode
    );

DWORD
FASTCALL
Name_MakeNameSignature(
    IN      PDB_NAME        pName
    );

DWORD
FASTCALL
Name_MakeRawNameSignature(
    IN      PCHAR           pchRawName
    );


//
//  Node to packet writing (nameutil.c)
//

BOOL
FASTCALL
Name_IsNodePacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchName,
    IN      PDB_NODE        pNode
    );

BOOL
FASTCALL
Name_IsRawNamePacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacket,
    IN      PCHAR           pchRawName
    );


PCHAR
FASTCALL
Name_PlaceFullNodeNameInPacket(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PDB_NODE        pnode
    );

PCHAR
FASTCALL
Name_PlaceNodeNameInPacketWithCompressedZone(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PDB_NODE        pnode,
    IN      WORD            wZoneOffset,
    IN      PDB_NODE        pnodeZoneRoot
    );

PCHAR
FASTCALL
Name_PlaceNodeLabelInPacket(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PDB_NODE        pnode,
    IN      WORD            wCompressedDomain
    );

PCHAR
FASTCALL
Name_PlaceLookupNameInPacket(
    IN OUT  PCHAR           pchPacket,
    IN      PCHAR           pchStop,
    IN      PLOOKUP_NAME    pLookupName,
    IN      BOOL            fSkipFirstLabel
    );

PCHAR
FASTCALL
Name_PlaceNodeNameInPacketEx(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN OUT  PCHAR           pch,
    IN      PDB_NODE        pNode,
    IN      BOOL            fUseCompression
    );

#define Name_PlaceNodeNameInPacket(pMsg, pch, pNode) \
        Name_PlaceNodeNameInPacketEx( (pMsg), (pch), (pNode), TRUE )

//
//  Compression read\write (nameutil.c)
//

VOID
FASTCALL
Name_SaveCompressionForLookupName(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN OUT  PLOOKUP_NAME    pLookname,
    IN      PDB_NODE        pNode
    );

VOID
FASTCALL
Name_SaveCompressionWithNode(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacketName,
    IN      PDB_NODE        pNode
    );

PDB_NODE
FASTCALL
Name_CheckCompressionForPacketName(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacketName
    );


//
//  Reverse lookup name utils (nameutil.c)
//

BOOL
Name_GetIpAddressForReverseNode(
    IN      PDB_NODE        pnodeReverse,
    OUT     PIP_ADDRESS     pipAddress,
    OUT     PIP_ADDRESS     pipReverseMask OPTIONAL
    );


//
//  General write node to buffer routine
//

PCHAR
FASTCALL
Name_PlaceNodeNameInBuffer(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PDB_NODE        pNode,
    IN      PDB_NODE        pNodeStop
    );

#define Name_PlaceFullNodeNameInBuffer(a,b,c) \
        Name_PlaceNodeNameInBuffer(a,b,c,NULL )



//
//  RPC buffer routines
//

PCHAR
FASTCALL
Name_PlaceNodeLabelInRpcBuffer(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PDB_NODE        pnode
    );

PCHAR
FASTCALL
Name_PlaceFullNodeNameInRpcBuffer(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PDB_NODE        pnode
    );

//
//  NT4 RPC buffer routines
//

PCHAR
FASTCALL
Name_PlaceReverseNodeNameAsIpAddressInBuffer(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PDB_NODE        pnodeToWrite
    );

PCHAR
FASTCALL
Name_PlaceFullNodeNameInRpcBufferNt4(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PDB_NODE        pNode
    );

PCHAR
FASTCALL
Name_PlaceNodeLabelInRpcBufferNt4(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PDB_NODE        pNode
    );

PCHAR
FASTCALL
Name_PlaceNodeNameInRpcBufferNt4(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PDB_NODE        pnode
    );




//
//  Count name \ Dbase name (name.c)
//

DWORD
Name_SizeofCountName(
    IN      PCOUNT_NAME     pName
    );

#define Name_SizeofDbaseNameFromCountName(pname) \
        Name_SizeofCountName(pname)


VOID
Name_ClearCountName(
    IN      PCOUNT_NAME     pName
    );

PDB_NAME
Name_SkipCountName(
    IN      PCOUNT_NAME     pName
    );

BOOL
Name_IsEqualCountNames(
    IN      PCOUNT_NAME     pName1,
    IN      PCOUNT_NAME     pName2
    );

BOOL
Name_ValidateCountName(
    IN      PCOUNT_NAME     pName
    );

DNS_STATUS
Name_AppendCountName(
    IN OUT  PCOUNT_NAME     pCountName,
    IN      PCOUNT_NAME     pAppendName
    );

DNS_STATUS
Name_CopyCountName(
    OUT     PCOUNT_NAME     pOutName,
    IN      PCOUNT_NAME     pCopyName
    );

//  macro to dbase name routines

#define Name_SizeofDbaseName(a)             Name_SizeofCountName(a)
#define Name_ClearDbaseName(a)              Name_ClearCountName(a)
#define Name_SkipDbaseName(a)               Name_SkipCountName(a)
#define Name_IsEqualDbaseNames(a,b)         Name_IsEqualCountNames(a,b)
#define Name_ValidateDbaseName(a)           Name_ValidateCountName(a)
#define Name_AppendDbaseName(a,b)           Name_AppendCountName(a,b)
#define Name_CopyDbaseName(a,b)             Name_CopyCountName(a,b)

#define Name_CopyCountNameToDbaseName(a,b)  Name_CopyCountName((a),(b))

#define Name_LengthDbaseNameFromCountName(a) \
        Name_SizeofCountName(a)


//
//  From Dotted name
//

PCOUNT_NAME
Name_CreateCountNameFromDottedName(
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength       OPTIONAL
    );

DNS_STATUS
Name_AppendDottedNameToCountName(
    IN OUT  PCOUNT_NAME     pCountName,
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength       OPTIONAL
    );

#define Name_AppendDottedNameToDbaseName(a,b,c) \
        Name_AppendDottedNameToCountName(a,b,c)


//
//  Node to counted name
//

VOID
Name_NodeToCountName(
    OUT     PCOUNT_NAME         pName,
    IN      PDB_NODE            pNode
    );

#define Name_NodeToDbaseName(a,b)   Name_NodeToCountName(a,b)


//
//  Packet name reading utils
//

PCHAR
Name_PacketNameToCountName(
    OUT     PCOUNT_NAME     pCountName,
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacketName,
    IN      PCHAR           pchEnd
    );

#define Name_PacketNameToDbaseName( pResult, pMsg, pName, pchEnd ) \
        Name_PacketNameToCountName( pResult, pMsg, pName, pchEnd )

DWORD
Name_SizeofCountNameForPacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN OUT  PCHAR *         ppchPacketName,
    IN      PCHAR           pchEnd
    );

#define Name_LengthDbaseNameForPacketName(a,b,c) \
        Name_SizeofCountNameForPacketName(a,b,c)

PCOUNT_NAME
Name_CreateCountNameFromPacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacketName
    );

#define Name_CreateDbaseNameFromPacketName(a,b) \
        Name_CreateCountNameFromPacketName(a,b)


//
//  Dbase to packet
//

PCHAR
Name_WriteCountNameToPacketEx(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchCurrent,
    IN      PCOUNT_NAME     pName,
    IN      BOOL            fCompression
    );

#define Name_WriteDbaseNameToPacketEx(m,p,n,f) \
        Name_WriteCountNameToPacketEx(m,p,n,f)

//  version without compression flag

#define Name_WriteDbaseNameToPacket(m,p,n)    \
        Name_WriteCountNameToPacketEx(m,p,n,TRUE)

//
//  Dbase to RPC buffer
//

PCHAR
Name_WriteCountNameToBufferAsDottedName(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PCOUNT_NAME     pName,
    IN      BOOL            fPreserveEmbeddedDots
    );

PCHAR
Name_WriteDbaseNameToRpcBuffer(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PCOUNT_NAME     pName,
    IN      BOOL            fPreserveEmbeddedDots
    );

PCHAR
Name_WriteDbaseNameToRpcBufferNt4(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PCOUNT_NAME     pName
    );

DWORD
Name_ConvertRpcNameToCountName(
    IN      PCOUNT_NAME     pName,
    IN OUT  PDNS_RPC_NAME   pRpcName
    );


#endif  // _NAMEUTIL_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\memory.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    memory.c

Abstract:

    Domain Name System (DNS) Server

    Memory routines for DNS.

Author:

    Jim Gilroy (jamesg)    January 31, 1995

Revision History:

--*/


#include "dnssrv.h"


//
//  Handle to DNS server heap
//

HANDLE  hDnsHeap;

//
//  Allocation failure
//

ULONG   g_AllocFailureCount;
ULONG   g_AllocFailureLogTime;

#define ALLOC_FAILURE_LOG_INTERVAL      (900)       // 15 minutes




//
//  Debug heap routines
//

#if DBG


//
//  Debug memory routines.
//

PVOID
reallocMemory(
    IN OUT  PVOID           pMemory,
    IN      INT             iSize,
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    )
/*++

Routine Description:

    Reallocates memory

Arguments:

    pMemory - ptr to existing memory to reallocated
    iSize   - number of bytes to reallocate

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    //
    //  reallocate memory
    //

    pMemory = HeapDbgRealloc(
                hDnsHeap,
                0,
                pMemory,
                iSize,
                pszFile,
                LineNo
                );
    if ( ! pMemory )
    {
        DNS_PRINT(( "ReAllocation of %d bytes failed\n", iSize ));
        HeapDbgGlobalInfoPrint();

        DNS_LOG_EVENT(
            DNS_EVENT_OUT_OF_MEMORY,
            0,
            NULL,
            NULL,
            0
            );
        FAIL( "ReAllocation" );
        RAISE_EXCEPTION(
            DNS_EXCEPTION_OUT_OF_MEMORY,
            0,
            0,
            NULL );
        return  NULL;
    }

    IF_DEBUG( HEAP2 )
    {
        DNS_PRINT((
            "Reallocating %d bytes at %p to %p.\n"
            "\tin %s line %d\n",
            iSize,
            pMemory,
            (PBYTE)pMemory + iSize,
            pszFile,
            LineNo
            ));
        HeapDbgGlobalInfoPrint();
    }

    //
    //  return ptr to first byte after header
    //

    return pMemory;
}



VOID
freeMemory(
    IN OUT  PVOID           pMemory,
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    )
/*++

Routine Description:

    Frees memory

    Note:  This memory MUST have been allocated by  MEMORY routines.

Arguments:

    pMemory    - ptr to memory to be freed

Return Value:

    None.

--*/
{
    if ( !pMemory )
    {
        return;
    }
    ASSERT( Mem_HeapMemoryValidate(pMemory) );

    IF_DEBUG( HEAP2 )
    {
        DNS_PRINT((
            "Free bytes at %p.\n"
            "\tin %s line %d\n",
            pMemory,
            pszFile,
            LineNo ));
        HeapDbgGlobalInfoPrint();
    }

    //  free the memory

    HeapDbgFree(
        hDnsHeap,
        0,
        pMemory );

    MemoryStats.Memory = gCurrentAlloc;
    STAT_INC( MemoryStats.Free );
}



#else


//
//  Non-Debug DNS heap routines.
//

DWORD   gCurrentAlloc;


PVOID
reallocMemory(
    IN OUT  PVOID           pMemory,
    IN      INT             iSize,
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    )
/*++

Routine Description:

    Reallocates memory

Arguments:

    pMemory - ptr to existing memory to reallocated
    iSize   - number of bytes to reallocate

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    //
    //  reallocate memory
    //

    pMemory = RtlReAllocateHeap( hDnsHeap, 0, pMemory, iSize );
    if ( ! pMemory )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_OUT_OF_MEMORY,
            0,
            NULL,
            NULL,
            GetLastError()
            );
        RAISE_EXCEPTION(
            DNS_EXCEPTION_OUT_OF_MEMORY,
            0,
            0,
            NULL );
    }

    return pMemory;
}



VOID
freeMemory(
    IN OUT  PVOID           pMemory,
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    )
/*++

Routine Description:

    Frees memory.

Arguments:

    pMemory - ptr to memory to be freed

Return Value:

    None.

--*/
{
    if ( !pMemory )
    {
        return;
    }
    RtlFreeHeap( hDnsHeap, 0, pMemory );


    STAT_INC( MemoryStats.Free );
}

#endif  // no-debug



PVOID
allocMemory(
    IN      INT             iSize,
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    )
/*++

Routine Description:

    Allocates memory.

Arguments:

    iSize   - number of bytes to allocate

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    register PVOID  palloc;
    DWORD           failureCount = 0;


    //
    //  allocate memory
    //
    //  operate in loop as we'll wait on the allocation failure case
    //

    do
    {
#if DBG
        palloc = HeapDbgAlloc(
                    hDnsHeap,
                    0,
                    iSize,
                    pszFile,
                    LineNo
                    );
#else
        palloc = RtlAllocateHeap(
                    hDnsHeap,
                    0,
                    iSize );
#endif
        if ( palloc )
        {
            break;
        }

        //
        //  allocation failure
        //      - debug log, but only on first pass
        //      - log event
        //      but only on first pass AND
        //      MUST be sure eventlogging doesn't require allocation or
        //      we can overflow stack in mutual recursion;
        //      (currently event buffer comes from LocalAllow() through
        //      FormatMessage and so is not a problem)
        //

        DNS_PRINT(( "Allocation of %d bytes failed\n", iSize ));

        g_AllocFailureCount++;

        if ( failureCount == 0 )
        {
            HeapDbgGlobalInfoPrint();
            Dbg_Statistics();
            //  ASSERT( FALSE );

            if ( g_AllocFailureLogTime == 0 ||
                g_AllocFailureLogTime + ALLOC_FAILURE_LOG_INTERVAL < DNS_TIME() )
            {
                //  put this before logging to kill off possibility of
                //  mutual recursion stack overflow with event log allocation

                g_AllocFailureLogTime = DNS_TIME();

                DNS_LOG_EVENT(
                    DNS_EVENT_OUT_OF_MEMORY,
                    0,
                    NULL,
                    NULL,
                    GetLastError()
                    );
            }
        }

#if 0
        //  DEVNOTE: RaiseException on memory failure
        //      once have server restart, should raise exception
        //      if
        //          - fail several times \ for a certain time
        //          - DNS server memory is THE problem (is huge)

        RAISE_EXCEPTION(
            DNS_EXCEPTION_OUT_OF_MEMORY,
            0,
            0,
            NULL );
#endif

        //
        //  if shutting down server -- bail!
        //      ExitThread to avoid any possible AV going back up stack

        if ( ! Thread_ServiceCheck() )
        {
            DNS_DEBUG( SHUTDOWN, ( "Terminating recursion timeout thread.\n" ));
            ExitThread( 0 );
        }

        //
        //  otherwise sleep briefly
        //      - start small (100 ms) to allow fast recovery from transient
        //      - but wait with long interval (100s) to avoid CPU load

        if ( failureCount++ < 50 )
        {
            Sleep( 100 );
        }
        else
        {
            Sleep( 100000 );
        }

    }
    while ( 1 );


    IF_DEBUG( HEAP2 )
    {
        DNS_PRINT((
            "Allocating %d bytes at %p to %p\n"
            "\tin %s line %d\n",
            iSize,
            palloc,
            (PBYTE)palloc + iSize,
            pszFile,
            LineNo
            ));
        HeapDbgGlobalInfoPrint();
    }

    //
    //  return ptr to first byte after header
    //

#if DBG
    MemoryStats.Memory = gCurrentAlloc;
#endif
    STAT_INC( MemoryStats.Alloc );

    return  palloc;
}



//
//  Standard record and node allocation
//
//  Almost all RR are the same size in the database -- DWORD of data.
//  This covers A, and all the single indirection records:  NS, PTR, CNAME,
//  etc.
//
//  To make this more efficient, we allocate these standard sized records
//  in larger blocks and keep a free list.
//
//  Advantages:
//      - save space that otherwise goes to heap info in each RR
//      - speedier than going to heap
//
//
//  Standard allocations available of various commonly used sizes.
//  Free list head points at first allocation.
//  First field in each allocation points at next element of free list.
//



//
//  Header on standard allocs
//
//  This preceeds all standard alloc blocks to save allocation info
//  -- size, which list, alloc tag -- outside purview of users memory.
//
//  Since all allocations DWORD aligned, store size with last three bits
//  chopped off.  If the complier's smart enough it doesn't even have to
//  shift -- just mask.
//

typedef struct _DnsMemoryHeader
{
#ifdef _WIN64
    DWORD   Boundary64;
#endif
    UCHAR   Boundary;
    BYTE    Tag;
    WORD    Size;
}
MEMHEAD, *PMEMHEAD;

#define SIZEOF_MEMHEAD      sizeof(MEMHEAD)

//
//  Get memory header ptr from user memory
//

#define RECOVER_MEMHEAD_FROM_USER_MEM(pMem)     ( (PMEMHEAD)(pMem) - 1 )


//
//  Trailer on standard allocs
//

typedef struct _DnsMemoryTrailer
{
    DWORD   Tail;
#ifdef _WIN64
    DWORD   Boundary64;
#endif
}
MEMTAIL, *PMEMTAIL;




//
//  Size field will be overlay of size and standard alloc index
//
//  Since allocs are DWORD aligned, we have two bits, that are essentially
//  unused in size field.  We use these to write index to low 2 bits.
//  The only caveat here is that heap allocations must always be rounded up
//  to nearest DWORD, so that there is no confusion for allocation at
//  boundary of standard allocs and heap (i.e. heap allocs must always have
//  a size greater than max standard alloc, excluding trailing bits)
//
//  We'll do this rounding up in ALL heap allocs effectively leaving
//  heap "index" zero.
//

#define MEM_MAX_SIZE        (0xfffc)

#define MEM_SIZE_MASK       (0xfffc)
#define MEM_INDEX_MASK      (0x0003)

#define RECOVER_MEM_SIZE(pBlock)    ((pBlock->Size) & MEM_SIZE_MASK)

#define RECOVER_MEM_INDEX(pBlock)   ((pBlock->Size) & MEM_INDEX_MASK)

#define HEAP_INDEX                  (0)

//  alloc boundary tags

#define BOUNDARY_64         (0x64646464)
#define BOUNDARY_ACTIVE     (0xbb)
#define BOUNDARY_FREE       (0xee)


//
//  Free list
//
//  Note low 0xff is specifically set to break the RANK field of
//  a record.  With this tag the rank becomes 0xff -- the highest
//  possible rank, yet not a zone rank.  This immediately causes
//  failures.
//

#define FREE_BLOCK_TAG  (0x123456ff)

typedef struct _DnsFreeBlock
{
    MEMHEAD                 MemHead;
    struct _DnsFreeBlock *  pNext;
    DWORD                   FreeTag;
}
FREE_BLOCK, *PFREE_BLOCK;


//
//  Standard allocation lists
//

typedef struct _DnsStandardRecordList
{
    PFREE_BLOCK         pFreeList;
    DWORD               Index;
    DWORD               Size;
    DWORD               AllocBlockCount;
    DWORD               FreeCount;
    DWORD               HeapAllocs;
    DWORD               TotalCount;
    DWORD               UsedCount;
    DWORD               ReturnCount;
    DWORD               Memory;
    CRITICAL_SECTION    Lock;
}
STANDARD_ALLOC_LIST, *PSTANDARD_ALLOC_LIST;

//
//  Handle several different standard sizes
//      A records       -- the 95% case A
//      small names     -- NS, PTR, CNAME possibly MX;  update blocks
//      NODE            -- standard size domain node, some SOA records
//      big NODE        -- large label, almost all SOA
//
//  Note:  these sizes MUST be appropriately aligned for both 32 and
//      64 bit implementations
//
//  Currently
//      RR fixed    = 16 (32bit), 20 (64bit)
//      RR A        = 20 (32bit), 24 (64bit)
//      Update      = 24 (32bit), 40 (64bit)
//      Node        = 64 (32bit), 96 (64bit)
//
//  Sizes:
//      32-bit:     20, 44, 64, 88
//      64-bit:     24, 48, 96, 120
//
//  Sizes with memhead:
//      32-bit:     24, 48, 68, 92
//      64-bit:     32, 56, 104, 128
//
//  Note, there is some unnecessary wastage here for 64-bit.  Should
//  have block starts 64-aligned, BUT instead of wasting the leading DWORD
//  should use it also -- then offset by DWORD only on original alloc.
//  The sizes with MEMHEAD stay the same, but the useful space
//  increases by 4bytes.
//


#define ROUND_PTR(x) (((ULONG)(x) + sizeof(PVOID) - 1) & ~(sizeof(PVOID)-1))

#define SIZE1   ROUND_PTR(SIZEOF_DBASE_RR_FIXED_PART + SIZEOF_IP_ADDRESS)
#define SIZE2   ROUND_PTR(SIZEOF_DBASE_RR_FIXED_PART + 28)
#define SIZE3   ROUND_PTR(sizeof(DB_NODE))
#define SIZE4   ROUND_PTR(sizeof(DB_NODE) + 24)

//  Actual sizes of blocks

#define BLOCKSIZE1  (SIZEOF_MEMHEAD + SIZE1)
#define BLOCKSIZE2  (SIZEOF_MEMHEAD + SIZE2)
#define BLOCKSIZE3  (SIZEOF_MEMHEAD + SIZE3)
#define BLOCKSIZE4  (SIZEOF_MEMHEAD + SIZE4)

C_ASSERT((BLOCKSIZE1 % sizeof(PVOID)) == 0);
C_ASSERT((BLOCKSIZE2 % sizeof(PVOID)) == 0);
C_ASSERT((BLOCKSIZE3 % sizeof(PVOID)) == 0);
C_ASSERT((BLOCKSIZE4 % sizeof(PVOID)) == 0);

#define SIZEOF_MAX_STANDARD_ALLOC   BLOCKSIZE4

//  alloc all sizes in roughly page based clumps

#define PAGE_SIZE   (0x1000)            // 4K

#define COUNT1  (PAGE_SIZE / BLOCKSIZE1)
#define COUNT2  (PAGE_SIZE / BLOCKSIZE2)
#define COUNT3  (PAGE_SIZE / BLOCKSIZE3)
#define COUNT4  (PAGE_SIZE / BLOCKSIZE4)

//
//  Table of standard block info
//

#define MEM_MAX_INDEX           (3)
#define STANDARD_BLOCK_COUNT    (4)

STANDARD_ALLOC_LIST     StandardAllocLists[] =
{
    { NULL, 0,  BLOCKSIZE1, COUNT1, 0,  0,  0,  0,  0,  0 },
    { NULL, 1,  BLOCKSIZE2, COUNT2, 0,  0,  0,  0,  0,  0 },
    { NULL, 2,  BLOCKSIZE3, COUNT3, 0,  0,  0,  0,  0,  0 },
    { NULL, 3,  BLOCKSIZE4, COUNT4, 0,  0,  0,  0,  0,  0 },
};

//
//  Each list individually locked (to minimize contention)
//

#define STANDARD_ALLOC_LOCK(plist)      EnterCriticalSection( &(plist)->Lock );
#define STANDARD_ALLOC_UNLOCK(plist)    LeaveCriticalSection( &(plist)->Lock );


//
//  Stats on tagged allocations
//  Handy to keep ptr into global stats block
//

PMEMTAG_STATS   pTagStats = MemoryStats.MemTags;

//
//  For valid stats, need mem stats lock
//

#define MEM_STATS_LOCK()        GENERAL_SERVER_LOCK()
#define MEM_STATS_UNLOCK()      GENERAL_SERVER_UNLOCK()



#if DBG
BOOL
standardAllocFreeListValidate(
    IN      PSTANDARD_ALLOC_LIST    pList
    );
#else
#define standardAllocFreeListValidate(pList)    (TRUE)
#endif



#if DBG


BOOL
Mem_HeapMemoryValidate(
    IN      PVOID           pMemory
    )
/*++

Routine Description:

    Validate memory as being valid heap memory.

Arguments:

    pMemory -- ptr to heap memory

Return Value:

    TRUE if pMemory could be valid heap memory
    FALSE if pMemory definitely invalid

--*/
{
    PVOID       p;

    if ( (ULONG_PTR)pMemory & (sizeof(PVOID)-1) )
    {
        DNS_PRINT((
            "ERROR:  pMemory %p, not aligned.\n"
            "\tMust be DWORD (Win32) or LONGLONG (Win64) aligned.\n",
            pMemory ));
        return FALSE;
    }

    return TRUE;
}



BOOL
Mem_HeapHeaderValidate(
    IN      PVOID           pMemory
    )
/*++

Routine Description:

    Validate heap headers and trailers.

Arguments:

    pMemory -- ptr to heap memory

Return Value:

    TRUE if headers appear to be valid.

--*/
{
    PVOID       p;

    if ( !Mem_HeapMemoryValidate( pMemory ) )
    {
        return FALSE;
    }

    p = ( PMEMHEAD ) pMemory - 1;
    HeapDbgValidateMemory( p, FALSE );

    return TRUE;
}


#endif



DWORD
Mem_GetTag(
    IN      PVOID           pMem
    )
/*++

Routine Description:

    Get tag associated with memory.

Arguments:

    pMem -- memory block to get tag for

Return Value:

    Tag

--*/
{
    PMEMHEAD    phead;

    phead = RECOVER_MEMHEAD_FROM_USER_MEM(pMem);

    return (DWORD) (phead->Tag);
}



VOID
Mem_ResetTag(
    IN      PVOID           pMem,
    IN      DWORD           Tag
    )
/*++

Routine Description:

    Reset tag associated with a particular memory block.

    Note there is no protection here.  This is only safe
    when block is newly created by calling thread and
    not enlisted in any data structure where other threads
    may have access.

    The purpose of this function is to have a quicky workaround
    for applying detailed source tags to records, without
    changing code which currently creates the record.  Caller
    creates record through normal path where it receives a
    default tag -- then retags using this function.

Arguments:

    pMem -- memory block to reset tag on

    Tag -- new tag for block

Return Value:

    Tag

--*/
{
    PMEMHEAD    phead;
    BYTE        currentTag;
    WORD        size;

    phead = RECOVER_MEMHEAD_FROM_USER_MEM(pMem);

    //
    //  reset tag and tag stats
    //      - decrement count for current tag
    //      - increment count for new tag
    //      - reset tag in block
    //
    //  note:  this function only used for resetting record tags
    //      so expect a record tag
    //

    currentTag = phead->Tag;
    size = RECOVER_MEM_SIZE(phead);

    ASSERT( currentTag >= MEMTAG_RECORD_BASE );
    ASSERT( currentTag <= MEMTAG_NODE_MAX );

    InterlockedDecrement( &MemoryStats.MemTags[ currentTag ].Alloc );
    InterlockedExchangeAdd( &MemoryStats.MemTags[ currentTag ].Memory, -(LONG)size );

    ASSERT( (INT)MemoryStats.MemTags[ currentTag ].Alloc >= 0 );
    ASSERT( (INT)MemoryStats.MemTags[ currentTag ].Memory >= 0 );

    InterlockedIncrement( &MemoryStats.MemTags[ Tag ].Alloc );
    InterlockedExchangeAdd( &MemoryStats.MemTags[ Tag ].Memory, size );

    phead->Tag = (BYTE) Tag;
}



PVOID
setAllocHeader(
    IN      PMEMHEAD        pMem,
    IN      DWORD           Index,
    IN      DWORD           Size,
    IN      DWORD           Tag
    )
/*++

Routine Description:

    Set standard memory header.

Arguments:

Return Value:

    Ptr to memory to return.

--*/
{
    ASSERT( Index <= MEM_MAX_INDEX );
    ASSERT( (Size & MEM_INDEX_MASK) == 0 );

    //  count allocation under its tag

    if ( Tag > MEMTAG_MAX )
    {
        ASSERT( Tag <= MEMTAG_MAX );
        Tag = 0;
    }

    MEM_STATS_LOCK();
    STAT_ADD( MemoryStats.Memory, Size );
    STAT_INC( MemoryStats.Alloc );

    if ( MemoryStats.MemTags[ Tag ].Free > MemoryStats.MemTags[ Tag ].Alloc )
    {
        DNS_PRINT((
            "Tag %d with negative in-use count!\n"
            "\talloc = %d\n"
            "\tfree = %d\n",
            Tag,
            MemoryStats.MemTags[ Tag ].Alloc,
            MemoryStats.MemTags[ Tag ].Free ));
        HARD_ASSERT( FALSE );
    }
    if ( (LONG)MemoryStats.MemTags[ Tag ].Memory < 0 )
    {
        DNS_PRINT((
            "Tag %d with negative memory count = %d!\n",
            Tag,
            (LONG)MemoryStats.MemTags[ Tag ].Memory ));
        HARD_ASSERT( FALSE );
    }

    InterlockedIncrement( &MemoryStats.MemTags[ Tag ].Alloc );
    InterlockedExchangeAdd( &MemoryStats.MemTags[ Tag ].Memory, Size );

    MEM_STATS_UNLOCK();

    ASSERT( (Size & MEM_SIZE_MASK) == Size );

    //  write header
    //
    //  since allocs DWORD aligned, the last two bits can be used to
    //      overlay standard alloc index info to provide check
    //
    //  note that at boundary between standard and heap, heap allocs
    //      must be rounded up to size at least a DWORD greated than
    //      last standard alloc, to avoid confusion
    //

    pMem->Boundary  = BOUNDARY_ACTIVE;
    pMem->Tag       = (UCHAR) Tag;
    pMem->Size      = (WORD) Size | (WORD)(Index);

    DNS_DEBUG( HEAP2, (
        "Mem_Alloc() complete %p, size=%d, tag=%d, index=%d.\n",
        (PCHAR)pMem + SIZEOF_MEMHEAD,
        Size,
        Tag,
        Index ));

    return ( (PCHAR)pMem + SIZEOF_MEMHEAD );
}



BOOL
Mem_VerifyHeapBlock(
    IN      PVOID           pMem,
    IN      DWORD           dwTag,
    IN      DWORD           dwLength
    )
/*++

Routine Description:

    Verify valid alloc header.

Arguments:

    pMem -- memory to validate

    dwTag -- required Tag value

    dwLength -- required Length value;  actually length must be >= to this value

Return Value:

    TRUE -- if pMem is valid DNS server heap block
    FALSE -- on error

--*/
{
    PMEMHEAD    pblock;
    DWORD       tag;
    DWORD       size;

    //  skip NULL ptrs

    if ( !pMem )
    {
        return TRUE;
    }

    //
    //  recover allocation header
    //      - find size of allocated block
    //      - set tag and global stats to track free
    //

    pblock = RECOVER_MEMHEAD_FROM_USER_MEM(pMem);

    HARD_ASSERT( pblock->Boundary != BOUNDARY_FREE );
    HARD_ASSERT( pblock->Boundary == BOUNDARY_ACTIVE );

    tag = pblock->Tag;
    HARD_ASSERT( tag <= MEMTAG_MAX );

    if ( dwTag && dwTag != tag )
    {
        DNS_PRINT((
            "ERROR:  invalid block tag on pMem = %p!\n"
            "\tExpected tag value %d, pMem->Tag = %d\n",
            pMem,
            dwTag,
            tag ));
        ASSERT( FALSE );
        return FALSE;
    }

    //  check desired length fits in this block

    size = RECOVER_MEM_SIZE(pblock);
    size -= SIZEOF_MEMHEAD;

    if ( dwLength && dwLength > size )
    {
        DNS_PRINT((
            "ERROR:  invalid length on pMem = %p!\n"
            "\tExpected length %d > pMem size = %d\n",
            pMem,
            dwLength,
            size ));
        ASSERT( FALSE );
        return FALSE;
    }
    return TRUE;
}



PVOID
Mem_Alloc(
    IN      DWORD           Length,
    IN      DWORD           Tag,
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    )
/*++

Routine Description:

    Get a standard allocation.

    This keeps us from needing to hit heap, for common RR and node operations.
    AND saves overhead of heap fields on each RR.

    As optimization, assuming list locked by caller.

Arguments:

    Length -- length of allocation required.

Return Value:

    Ptr to memory of desired size, if successful.
    NULL on allocation failure.

--*/
{
    PSTANDARD_ALLOC_LIST    plist;
    PFREE_BLOCK     pnew;
    PFREE_BLOCK     pnext;
    PFREE_BLOCK     pnewBlock;
    DWORD           allocSize;
    DWORD           size;
    DWORD           i;

    DNS_DEBUG( HEAP2, (
        "Mem_Alloc( %d, tag=%d, %s line=%d )\n",
        Length,
        Tag,
        pszFile,
        LineNo ));

    //  add header to required length

    Length += SIZEOF_MEMHEAD;

    //
    //  non-standard size -- grab from heap
    //

    if ( Length > SIZEOF_MAX_STANDARD_ALLOC || SrvCfg_fTest7 )
    {
        pnew = allocMemory( (INT)Length, pszFile, LineNo );

        //  set header on new block
        //  then return user portion of block
        //  always report alloc length as nearest DWORD aligned

        if ( Length > MEM_MAX_SIZE )
        {
            Length = MEM_MAX_SIZE;
        }
        else if ( Length & MEM_INDEX_MASK )
        {
            Length &= MEM_SIZE_MASK;
            Length += sizeof(DWORD);
        }
        STAT_INC( MemoryStats.StdToHeapAlloc );
        STAT_ADD( MemoryStats.StdToHeapMemory, Length );

        return  setAllocHeader(
                    (PMEMHEAD) pnew,
                    HEAP_INDEX,
                    Length,
                    Tag );
    }

    //
    //  check all standard sizes
    //  if desired length <= this standard size, then use it
    //

    plist = StandardAllocLists;
    while( 1 )
    {
        if ( Length <= plist->Size )
        {
            break;
        }
        plist++;
    }
    ASSERT( plist->Size >= Length );

    //
    //  found proper list
    //      - take list CS

    STANDARD_ALLOC_LOCK( plist );

    //
    //  no current entries in free list -- allocate another block
    //

    if ( !plist->pFreeList )
    {
        ASSERT( plist->FreeCount == 0 );

        //
        //  free list empty
        //      - grab another page (254 RR * 16bytes);  leaving 32 bytes for
        //          heap info
        //      - add all the RRs to the free list
        //

        size = plist->Size;
        allocSize = size * plist->AllocBlockCount;

        pnew = (PFREE_BLOCK) allocMemory( allocSize, pszFile, LineNo );
        IF_NOMEM( !pnew )
        {
            return( pnew );
        }
        plist->Memory += allocSize;
        plist->HeapAllocs++;
        plist->TotalCount += plist->AllocBlockCount;
        plist->FreeCount += plist->AllocBlockCount;

        //
        //  cut memory into desired blocks and build free list
        //

        pnewBlock = pnew;
        for ( i=0; i<plist->AllocBlockCount-1; i++)
        {
            pnext = (PFREE_BLOCK)( (PBYTE)pnew + size );
            pnew->pNext = pnext;
            pnew->FreeTag = FREE_BLOCK_TAG;
            pnew = pnext;
        }

        //  attach new blocks to list
        //  last new RR points to existing free list (probably NULL)
        //      but not necessarily so since unlocked around alloc

        pnew->FreeTag = FREE_BLOCK_TAG;
        pnew->pNext = plist->pFreeList;
        plist->pFreeList = pnewBlock;
    }

    //
    //  found standard size alloc
    //
    //  take block from front of list
    //      - reset list head to next block
    //      - clear free tag on block
    //      - update counters
    //

    pnew = plist->pFreeList;

    ASSERT( plist->FreeCount );

#if DBG
    if ( !pnew || pnew->FreeTag != FREE_BLOCK_TAG )
    {
        DNS_PRINT((
            "pnew = %p on free list without tag!\n",
            pnew ));
        ASSERT( FALSE );
    }
    pnew->FreeTag = 0;
#endif

    plist->pFreeList = pnew->pNext;
    plist->FreeCount--;
    plist->UsedCount++;

    IF_DEBUG( FREE_LIST )
    {
        ASSERT( standardAllocFreeListValidate(plist) );
    }

    STANDARD_ALLOC_UNLOCK( plist );

    //  set header on new block
    //  then return user portion of block

    pnew = setAllocHeader(
                (PMEMHEAD) pnew,
                plist->Index,
                plist->Size,
                Tag );

    return( pnew );
}



PVOID
Mem_AllocZero(
    IN      DWORD           Length,
    IN      DWORD           Tag,
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    )
/*++

Routine Description:

    Allocates and zeros memory.

Arguments:

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    register PVOID  palloc;

    palloc = Mem_Alloc( Length, Tag, pszFile, LineNo );
    if ( palloc )
    {
        RtlZeroMemory(
            palloc,
            Length );
    }
    return( palloc );
}



PVOID
Mem_Realloc(
    IN OUT  PVOID           pMemory,
    IN      DWORD           Length,
    IN      DWORD           Tag,
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    )
/*++

Routine Description:

    Reallocate.

Arguments:

    pMemory -- existing memory block

    Length -- length of allocation required.

    Tag --

Return Value:

    Ptr to memory of desired size, if successful.
    NULL on allocation failure.

--*/
{
    PMEMHEAD    pblock;
    PMEMHEAD    pnew;
    DWORD       tag;
    DWORD       size;

    //
    //  recover allocation header
    //      - find size of allocated block
    //      - set tag and global stats to track free
    //

    pblock = RECOVER_MEMHEAD_FROM_USER_MEM(pMemory);

    HARD_ASSERT( pblock->Boundary == BOUNDARY_ACTIVE );

    size = RECOVER_MEM_SIZE(pblock);
    ASSERT( size > SIZEOF_MAX_STANDARD_ALLOC );
    ASSERT( Length > size );

    ASSERT( Tag == 0 || Tag == pblock->Tag );
    Tag = pblock->Tag;

    DNS_PRINT((
        "ERROR:  Mem_Realloc() called!\n",
        "\tpMem     = %s\n"
        "\tLength   = %d\n"
        "\tTag      = %d\n"
        "\tFile     = %s\n"
        "\tLine     = %d\n",
        pMemory,
        Length,
        Tag,
        pszFile,
        LineNo ));

    //
    //  realloc
    //
    //  DEVNOTE: need to inc free stats on realloc, otherwise
    //      this throws stats off
    //

    size = Length + sizeof(MEMHEAD);
    pnew = reallocMemory( pblock, size, pszFile, LineNo );
    if ( !pnew )
    {
        return( pnew );
    }
    if ( size > MEM_MAX_SIZE )
    {
        size = MEM_MAX_SIZE;
    }
    else if ( size & MEM_INDEX_MASK )
    {
        size &= MEM_SIZE_MASK;
        size += sizeof(DWORD);
    }

    pnew = setAllocHeader(
                (PMEMHEAD) pnew,
                HEAP_INDEX,
                size,
                Tag );

    return( pnew );
}



VOID
Mem_Free(
    IN OUT  PVOID           pFree,
    IN      DWORD           Length,
    IN      DWORD           Tag,
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    )
/*++

Routine Description:

    Free a standard sized allocation.

    As optimization, assuming list locked by caller.

Arguments:

    pFree -- allocation to free

    Length -- length of this allocation

Return Value:

    TRUE if successful.
    FALSE if not a standard allocation.

--*/
{
    PMEMHEAD                pblock;
    PSTANDARD_ALLOC_LIST    plist;
    DWORD                   tag;
    DWORD                   size;
    INT                     index;

    if ( !pFree )
    {
        return;
    }

    DNS_DEBUG( HEAP2, (
        "Mem_Free( %p, len=%d, tag=%d, %s line=%d )\n",
        pFree,
        Length,
        Tag,
        pszFile,
        LineNo ));
    //
    //  recover allocation header
    //      - find size of allocated block
    //      - set tag and global stats to track free
    //

    pblock = RECOVER_MEMHEAD_FROM_USER_MEM(pFree);

    if ( pblock->Boundary != BOUNDARY_ACTIVE )
    {
        HARD_ASSERT( pblock->Boundary == BOUNDARY_ACTIVE );
        return;
    }

    pblock->Boundary = BOUNDARY_FREE;

    size = RECOVER_MEM_SIZE(pblock);

    tag = pblock->Tag;

    DNS_DEBUG( HEAP2, (
        "Mem_Free( %p -- recovered tag=%d, size=%d )\n",
        pFree,
        tag,
        size ));

    HARD_ASSERT( tag <= MEMTAG_MAX );
    ASSERT( Tag == 0 || tag == Tag );

    MEM_STATS_LOCK();

    InterlockedIncrement( &MemoryStats.MemTags[ tag ].Free );
    InterlockedExchangeAdd( &MemoryStats.MemTags[ tag ].Memory, -(LONG)size );

    if ( MemoryStats.MemTags[ tag ].Free > MemoryStats.MemTags[ tag ].Alloc )
    {
        DNS_PRINT((
            "Tag %d with negative in-use count!\n"
            "\talloc = %d\n"
            "\tfree = %d\n",
            tag,
            MemoryStats.MemTags[ tag ].Alloc,
            MemoryStats.MemTags[ tag ].Free ));
        HARD_ASSERT( FALSE );
    }
    if ( (LONG)MemoryStats.MemTags[ tag ].Memory < 0 )
    {
        DNS_PRINT((
            "Tag %d with negative memory count = %d!\n",
            tag,
            (LONG)MemoryStats.MemTags[ tag ].Memory ));
        HARD_ASSERT( FALSE );
    }

    STAT_INC( MemoryStats.Free );
    STAT_SUB( MemoryStats.Memory, size );
    MEM_STATS_UNLOCK();

    ASSERT( Length == 0 || size == MEM_MAX_SIZE || Length <= size-sizeof(MEMHEAD) );

    //
    //  non-standard size -- free on heap
    //

    if ( size > SIZEOF_MAX_STANDARD_ALLOC || SrvCfg_fTest7 )
    {
        HARD_ASSERT( RECOVER_MEM_INDEX(pblock) == HEAP_INDEX );

        freeMemory( pblock, pszFile, LineNo );

        STAT_INC( MemoryStats.StdToHeapFree );
        STAT_SUB( MemoryStats.StdToHeapMemory, size );
        return;
    }

    //
    //  standard size
    //  find correct standard block list from index in header
    //

    HARD_ASSERT( size >= Length );

    index = (INT) RECOVER_MEM_INDEX( pblock );

    HARD_ASSERT( index <= MEM_MAX_INDEX );

    plist = &StandardAllocLists[index];

    HARD_ASSERT( size == plist->Size );

    //
    //  slap freed block to front of freelist
    //

    STANDARD_ALLOC_LOCK( plist );

    ((PFREE_BLOCK)pblock)->FreeTag = FREE_BLOCK_TAG;
    ((PFREE_BLOCK)pblock)->pNext = plist->pFreeList;

    plist->pFreeList = (PFREE_BLOCK)pblock;
    plist->ReturnCount++;
    plist->FreeCount++;

    IF_DEBUG( FREE_LIST )
    {
        ASSERT( standardAllocFreeListValidate(plist) );
    }
    STANDARD_ALLOC_UNLOCK( plist );
}



BOOL
Mem_IsStandardBlockLength(
    IN      DWORD           Length
    )
/*++

Routine Description:

    Check if length covered by standard block list or heap.

Arguments:

    Length -- length

Return Value:

    TRUE if standard block.
    FALSE otherwise.

--*/
{
    return( Length <= SIZEOF_MAX_STANDARD_ALLOC  &&  !SrvCfg_fTest7 );
}



VOID
Mem_WriteDerivedStats(
    VOID
    )
/*++

Routine Description:

    Derive standard alloc stats.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PSTANDARD_ALLOC_LIST    plist;

    //
    //  non-standard size -- get outstanding count
    //

    MemoryStats.StdToHeapInUse = MemoryStats.StdToHeapAlloc - MemoryStats.StdToHeapFree;

    //
    //  sum standard size counts
    //

    MemoryStats.StdBlockAlloc           = 0;
    MemoryStats.StdBlockMemory          = 0;
    MemoryStats.StdBlockFreeList        = 0;
    MemoryStats.StdBlockUsed            = 0;
    MemoryStats.StdBlockReturn          = 0;
    MemoryStats.StdBlockFreeListMemory  = 0;

    plist = StandardAllocLists;
    do
    {
        MemoryStats.StdBlockAlloc       += plist->TotalCount;
        MemoryStats.StdBlockMemory      += plist->Memory;
        MemoryStats.StdBlockFreeList    += plist->FreeCount;

        MemoryStats.StdBlockUsed        += plist->UsedCount;
        MemoryStats.StdBlockReturn      += plist->ReturnCount;

        MemoryStats.StdBlockFreeListMemory += plist->FreeCount * plist->Size;
        plist++;
    }
    while( plist->Size < SIZEOF_MAX_STANDARD_ALLOC );

    MemoryStats.StdBlockInUse = MemoryStats.StdBlockUsed - MemoryStats.StdBlockReturn;

    //
    //  combined standard system stats
    //

    MemoryStats.StdUsed     = MemoryStats.StdToHeapAlloc + MemoryStats.StdBlockUsed;
    MemoryStats.StdReturn   = MemoryStats.StdToHeapFree + MemoryStats.StdBlockReturn;

    MemoryStats.StdInUse    = MemoryStats.StdUsed - MemoryStats.StdReturn;

    MemoryStats.StdMemory   = MemoryStats.StdToHeapMemory + MemoryStats.StdBlockMemory;
}



BOOL
Mem_IsStandardFreeBlock(
    IN      PVOID           pFree
    )
/*++

Routine Description:

    Validate block is free block.

Arguments:

    pFree -- ptr to free block

Return Value:

    TRUE if free block.
    FALSE otherwise.

--*/
{
    PFREE_BLOCK pblock = (PFREE_BLOCK) ((PCHAR)pFree - sizeof(MEMHEAD));

    return ( ((PFREE_BLOCK)pblock)->FreeTag == FREE_BLOCK_TAG );
}



#if DBG
BOOL
standardAllocFreeListValidate(
    IN      PSTANDARD_ALLOC_LIST    pList
    )
/*++

Routine Description:

    Validate the free list.

    Assumes list locked.

Arguments:

    pList -- standard allocation list

Return Value:

    TRUE if list validates.
    FALSE if error in free list.

--*/
{
    PFREE_BLOCK     pfree;
    DWORD           count;

    //STANDARD_ALLOC_LOCK();

    count = pList->FreeCount;
    pfree = pList->pFreeList;

    DNS_PRINT((
        "Alloc list head = %p, for size %d, Length = %d.\n",
        pfree,
        pList->Size,
        count ));

    while ( pfree )
    {
        count--;
        ASSERT( pfree->FreeTag == FREE_BLOCK_TAG );
        pfree = pfree->pNext;
    }

    if ( count > 0 )
    {
        DNS_PRINT((
            "ERROR:  Free list failure.\n"
            "\tElement count %d at end of list.\n"
            "Terminating element:\n",
            count ));

        ASSERT( FALSE );
        //STANDARD_ALLOC_UNLOCK();
        return FALSE;
    }

    //STANDARD_ALLOC_UNLOCK();
    return TRUE;
}

#endif // DBG




VOID
Mem_HeapInit(
    VOID
    )
/*++

Routine Description:

    Initialize heap.

    MUST call this routine before using memory allocation.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD   heapFlags;
    DWORD   i;

    //
    //  verify blocks properly aligned
    //  32 or 64 bit should be aligned accordingly
    //

    ASSERT( BLOCKSIZE1 % sizeof(PVOID) == 0 );
    ASSERT( BLOCKSIZE2 % sizeof(PVOID) == 0 );
    ASSERT( BLOCKSIZE3 % sizeof(PVOID) == 0 );
    ASSERT( BLOCKSIZE4 % sizeof(PVOID) == 0 );

    //
    //  init tracking globals

    g_AllocFailureCount = 0;
    g_AllocFailureLogTime = 0;

    gCurrentAlloc = 0;

    //
    //  create DNS heap
    //

    heapFlags = HEAP_GROWABLE |
#if DBG
                HEAP_TAIL_CHECKING_ENABLED |
                HEAP_FREE_CHECKING_ENABLED |
#endif
                HEAP_CREATE_ALIGN_16 |
                HEAP_CLASS_1;

    hDnsHeap = RtlCreateHeap(
                    heapFlags,
                    NULL,           // no base specified
                    0,              // default reserve size
                    0,              // default commit size
                    NULL,           // no lock
                    NULL            // no parameters
                    );
    if ( !hDnsHeap )
    {
        return;
    }

#if DBG
    //
    //  debug heap stuff disabled until updated for separate heaps
    //
    //  set for full heap checking?
    //

    IF_DEBUG( HEAP_CHECK )
    {
        HeapDbgInit( DNS_EXCEPTION_OUT_OF_MEMORY, TRUE );
    }
    else
    {
        HeapDbgInit( DNS_EXCEPTION_OUT_OF_MEMORY, FALSE );
    }
#endif

    //
    //  initialize standard alloc lists
    //
    //  note this is static structure, so we can simply do
    //  static init of fixed values -- index, blocksize, etc.
    //  they are unaffected by restart
    //

    for ( i=0;  i<=MEM_MAX_INDEX; i++ )
    {
        PSTANDARD_ALLOC_LIST    plist = &StandardAllocLists[i];

        InitializeCriticalSection( &plist->Lock );

        plist->pFreeList    = NULL;
        plist->FreeCount    = 0;
        plist->HeapAllocs   = 0;
        plist->TotalCount   = 0;
        plist->UsedCount    = 0;
        plist->ReturnCount  = 0;
        plist->Memory       = 0;
    }
}



VOID
Mem_HeapDelete(
    VOID
    )
/*++

Routine Description:

    Delete heap.

    Need this to allow restart.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD   i;

    //
    //  delete process heap
    //  then cleanup CS for individual lists
    //  cleanup of lists is more likely to generate exception
    //  and MUST succeed with heap or we're done
    //

    DNS_DEBUG( ANY, (
        "RtlDestroyHeap() on DNS heap %p\n",
        hDnsHeap ));

    RtlDestroyHeap( hDnsHeap );

    //
    //  delete CS for each standard list
    //

    for ( i=0;  i<=MEM_MAX_INDEX; i++ )
    {
        PSTANDARD_ALLOC_LIST    plist = &StandardAllocLists[i];

        DeleteCriticalSection( &plist->Lock );
    }
}



//
//  This set may be registered with DnsApi.dll to allow interchangeable
//  use of memory.
//
//  These functions simply cover the standard heap functions, eliminating the
//  debug tag, file and line parameters.
//

#define DNSLIB_HEAP_FILE    "DnsLib"
#define DNSLIB_HEAP_LINE    0


PVOID
Mem_DnslibAlloc(
    IN      INT             iSize
    )
{
    return  Mem_Alloc(
                iSize,
                MEMTAG_DNSLIB,
                DNSLIB_HEAP_FILE,
                DNSLIB_HEAP_LINE );
}

PVOID
Mem_DnslibRealloc(
    IN OUT  PVOID           pMemory,
    IN      INT             iSize
    )
{
    return  Mem_Realloc(
                pMemory,
                iSize,
                MEMTAG_DNSLIB,
                DNSLIB_HEAP_FILE,
                DNSLIB_HEAP_LINE );
}


VOID
Mem_DnslibFree(
    IN OUT  PVOID           pMemory
    )
{
    Mem_Free(
        pMemory,
        0,
        MEMTAG_DNSLIB,
        DNSLIB_HEAP_FILE,
        DNSLIB_HEAP_LINE );
}


#if 0
//
//  For bad unknown memory stomping, as a last ditch effort you can sprinkle
//  code with calls to this function to try and narrow down the corruption.
//

int Debug_TestFreeLists( void )
{
    int i;
    for ( i = 0; i < STANDARD_BLOCK_COUNT; ++i )
    {
        standardAllocFreeListValidate( &StandardAllocLists[ i ] );
    }
    return 0;
}
#endif


//
//  End memory.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\memory.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    memory.h

Abstract:

    Domain Name System (DNS) Server

    Memory routines declarations.

Author:

    Jim Gilroy (jamesg)     January 1995

Revision History:

--*/

#ifndef _MEMORY_INCLUDED_
#define _MEMORY_INCLUDED_


//
//  Skippable out-of-memory checks
//

#define IF_NOMEM(a)     if (a)

//#define IF_NOMEM(a)


//
//  Private debug heap routines
//

#include    "heapdbg.h"


//
//  Heap global
//

extern HANDLE  hDnsHeap;

//
//  Heap alloc minimal validity check
//

#ifndef IS_QWORD_ALIGNED
#define IS_QWORD_ALIGNED(p)     ( !((UINT_PTR)(p) & (UINT_PTR)7) )
#endif

#ifdef _WIN64
#define IS_DNS_HEAP_DWORD(p)    ( IS_QWORD_ALIGNED(p) )
#else
#define IS_DNS_HEAP_DWORD(p)    ( IS_DWORD_ALIGNED(p) )
#endif


//
//  DnsLib heap routines
//  Standard looking heap functions that can be registered with DnsLib
//

VOID *
Mem_DnslibAlloc(
    IN      INT             iSize
    );

VOID *
Mem_DnslibRealloc(
    IN OUT  PVOID           pMem,
    IN      INT             iSize
    );

VOID
Mem_DnslibFree(
    IN OUT  PVOID           pFree
    );


//
//  Standard Heap Operations
//

VOID
Mem_HeapInit(
    VOID
    );

VOID
Mem_HeapDelete(
    VOID
    );


#if DBG

BOOL
Mem_HeapMemoryValidate(
    IN      PVOID           pMem
    );

BOOL
Mem_HeapHeaderValidate(
    IN      PVOID           pMemory
    );

#endif

//
//  Heap Routines
//
//  DO NOT directly use these routines.
//
//  Use the covering macros below, which make the correct call for
//  both debug and non-debug situations.
//

PVOID
Mem_Alloc(
    IN      DWORD           Length,
    IN      DWORD           Tag,
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    );

PVOID
Mem_AllocZero(
    IN      DWORD           Length,
    IN      DWORD           Tag,
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    );

VOID *
Mem_Realloc(
    IN OUT  PVOID           pMem,
    IN      DWORD           Length,
    IN      DWORD           Tag,
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    );

VOID
Mem_Free(
    IN OUT  PVOID           pMem,
    IN      DWORD           Length,
    IN      DWORD           Tag,
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    );

#define ALLOCATE_HEAP(size)             Mem_Alloc( size, 0, __FILE__, __LINE__ )
#define ALLOCATE_HEAP_ZERO(size)        Mem_AllocZero( size, 0, __FILE__, __LINE__ )

#define REALLOCATE_HEAP(p,size)         Mem_Realloc( (p), (size), 0, __FILE__, __LINE__ )

#define FREE_HEAP(p)                    Mem_Free( (p), 0, 0, __FILE__, __LINE__ )

//  with tagging

#define ALLOC_TAGHEAP( size, tag )      Mem_Alloc( (size), (tag), __FILE__, __LINE__ )
#define ALLOC_TAGHEAP_ZERO( size, tag)  Mem_AllocZero( (size), (tag), __FILE__, __LINE__ )
#define FREE_TAGHEAP( p, len, tag )     Mem_Free( (p), (len), (tag), __FILE__, __LINE__ )


//
//  Tag manipulation
//

DWORD
Mem_GetTag(
    IN      PVOID           pMem
    );

VOID
Mem_ResetTag(
    IN      PVOID           pMem,
    IN      DWORD           MemTag
    );



//
//  Standard allocations
//

BOOL
Mem_IsStandardBlockLength(
    IN      DWORD           Length
    );

BOOL
Mem_IsStandardFreeBlock(
    IN      PVOID           pFree
    );

BOOL
Mem_VerifyHeapBlock(
    IN      PVOID           pMem,
    IN      DWORD           dwTag,
    IN      DWORD           dwLength
    );

#define IS_ON_FREE_LIST(ptr)    (Mem_IsStandardFreeBlock(ptr))

VOID
Mem_WriteDerivedStats(
    VOID
    );



#endif  //  _MEMORY_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\msginfo.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    msginfo.h

Abstract:

    Message info type.

Author:

    Jim Gilroy (jamesg)     February 1995

Revision History:

    jamesg  Feb 1995    - Direct question pointer
    jamesg  Mar 1995    - Packet protection fields:
                            - BufferLength
                            - AvailLength
                            - pCurrent
                        - Alignment for TCP
    jamesg  May 1995    - Separate into this file.

--*/

#ifndef _DNS_MSGINFO_INC_
#define _DNS_MSGINFO_INC_


//
//  Additional records info
//
//  DEVNOTE-DCR: combine with compression?
//      - advantage, one clear, need to compress additional anyway
//          more efficient if banging on end of both
//      - disadvantage, a bit more complexity in overwriting compression
//          entries if get to the end
//

#define MAX_ADDITIONAL_RECORD_COUNT (50)

typedef struct      //  336 bytes
{
    DWORD       cMaxCount;
    DWORD       cCount;
    DWORD       iIndex;
    DWORD       iRecurseIndex;
    DWORD       dwStateFlags;   //  use DNS_ADDSTATE_XXX constants
    PDB_NAME    pNameArray[ MAX_ADDITIONAL_RECORD_COUNT ];
    WORD        wOffsetArray[ MAX_ADDITIONAL_RECORD_COUNT ];
    WORD        wTypeArray[ MAX_ADDITIONAL_RECORD_COUNT ];
}
ADDITIONAL_INFO, *PADDITIONAL_INFO;

#define INITIALIZE_ADDITIONAL( pMsg ) \
        {                          \
            (pMsg)->Additional.cMaxCount        = MAX_ADDITIONAL_RECORD_COUNT; \
            (pMsg)->Additional.cCount           = 0;   \
            (pMsg)->Additional.iIndex           = 0;   \
            (pMsg)->Additional.iRecurseIndex    = 0;   \
            (pMsg)->Additional.dwStateFlags     = 0;   \
        }

#define HAVE_MORE_ADDITIONAL_RECORDS( pAdd ) \
            ( (pAdd)->cCount > (pAdd)->iIndex )

#define DNS_ADDSTATE_WROTE_A        0x0001
#define DNS_ADDSTATE_ONLY_WANT_A    0x0002

#define DNS_ADDITIONAL_WROTE_A( padd ) \
    ( ( padd )->dwStateFlags & DNS_ADDSTATE_WROTE_A )

#define DNS_ADDITIONAL_ONLY_WANT_A( padd ) \
    ( ( padd )->dwStateFlags & DNS_ADDSTATE_ONLY_WANT_A )

#define DNS_ADDITIONAL_SET_WROTE_A( padd ) \
    ( ( padd )->dwStateFlags |= DNS_ADDSTATE_WROTE_A )

#define DNS_ADDITIONAL_SET_ONLY_WANT_A( padd ) \
    ( ( padd )->dwStateFlags |= DNS_ADDSTATE_ONLY_WANT_A )



//
//  Compression node info
//
//  Each compressed name can be represented by
//      - node compressed (if any)
//      - offset of compression
//      - label length
//      - label depth
//
//  The two label fields enable fast comparison without
//  necessitating actual visit (and accompaning ptr deref)
//  to the offset.
//

#define MAX_COMPRESSION_COUNT (50)

typedef struct      //  362 bytes
{
    DWORD                   cCount;
    WORD                    wLastOffset;
    PDB_NODE                pLastNode;
    PDB_NODE                pNodeArray[ MAX_COMPRESSION_COUNT ];
    WORD                    wOffsetArray[ MAX_COMPRESSION_COUNT ];
    UCHAR                   chDepthArray[ MAX_COMPRESSION_COUNT ];
}
COMPRESSION_INFO, *PCOMPRESSION_INFO;

#define INITIALIZE_COMPRESSION( pMsg )  \
        {                               \
            (pMsg)->Compression.cCount      = 0;    \
            (pMsg)->Compression.pLastNode   = 0;    \
        }


//
//  DNS Server Message Info structure
//
//  This is structure in which requests are held while being
//  processed by the DNS server.
//

typedef struct _DNS_MSGINFO
{
    LIST_ENTRY      ListEntry;          //  for queuing

    //
    //  Basic packet info
    //

    //  8
    PCHAR           pBufferEnd;         //  ptr to byte after buffer
    PBYTE           pCurrent;           //  current location in buffer

    //
    //  When a packet is allocated BufferLength is set to the
    //  usable buffer length but the packet buffer may actually be
    //  larger. This is used in UDP EDNS.
    //
    
    //  16
    DWORD           Tag;
    DWORD           BufferLength;       // usable buffer size
    DWORD           MaxBufferLength;    // total allocated buffer size

    //
    //  Addressing
    //

    //  28
    SOCKET          Socket;
    INT             RemoteAddressLength;

    //  36
    SOCKADDR_IN     RemoteAddress;

    //
    //  Current lookup info
    //

    //  52
    PDB_NODE        pnodeCurrent;       //  current node, may be NULL
    PDB_NODE        pnodeClosest;       //  closest found to current
    PZONE_INFO      pzoneCurrent;
    PDB_NODE        pnodeGlue;          //  effectively node in delegation
    //  68
    PDB_NODE        pnodeDelegation;    //  effectively closest in delegation
    PDB_NODE        pnodeCache;
    PDB_NODE        pnodeCacheClosest;

    //  JJW fix offsets!
    PDB_NODE        pnodeNxt;           //  use this node for DNSSEC NXT

    //  80
    WORD            wTypeCurrent;       //  current type being looked up
    WORD            wOffsetCurrent;

    //  Question node

    //  84
    PDB_NODE        pNodeQuestion;
    PDB_NODE        pNodeQuestionClosest;

    //  92
    PDNS_WIRE_QUESTION  pQuestion;          //  ptr to original question
    WORD                wQuestionType;      //  type in question

    //
    //  Queuing
    //

    WORD            wQueuingXid;        //  match XID to response
    //  100
    DWORD           dwQueryTime;        //  time of original query
    DWORD           dwMsQueryTime;      //  time of query in milliseconds
    DWORD           dwQueuingTime;      //  time queued
    DWORD           dwExpireTime;       //  queue timeout

    //  Opt RR info

    //  116
    struct _DNS_OPTINFO     // size is 12 bytes
    {
        BOOLEAN     fFoundOptInIncomingMsg;
        BOOLEAN     fInsertOptInOutgoingMsg;
        UCHAR       cExtendedRCodeBits;
        UCHAR       cVersion;
        WORD        wUdpPayloadSize;
        WORD        wOptOffset;                 //  0 -> no OPT present
        WORD        wOriginalQueryPayloadSize;  //  0 -> no OPT in client query
        WORD        PadToMakeOptAlignOnDWord;
    } Opt;

    //
    //  Recursion info
    //

    //  132
    struct _DNS_MSGINFO  *  pRecurseMsg;    //  recursion msg info
    PDB_NODE        pnodeRecurseRetry;
    PVOID           pNsList;                //  visited NS list

    //
    //  TCP message reception
    //

    //  144
    PVOID           pConnection;        //  ptr to connection struct
    PCHAR           pchRecv;            //  ptr to next pos in message


    //
    //  Lookup types
    //

    //  152
    DWORD           UnionMarker;

    //  156
    union
    {
        //
        //  Wins / Nbstat stored info during lookup
        //

        struct      //  6 bytes
        {
            PVOID           pWinsRR;
            CHAR            WinsNameBuffer[16];
            UCHAR           cchWinsName;
        }
        Wins;

        //
        //  Nbstat info
        //

        struct      //  20 bytes
        {
            PDB_RECORD      pRR;                    // zone's WINSR record
            PVOID           pNbstat;
            IP_ADDRESS      ipNbstat;
            DWORD           dwNbtInterfaceMask;
            BOOLEAN         fNbstatResponded;       //  response from WINS
        }
        Nbstat;

        //
        //  Xfr
        //

        struct      //  32 bytes
        {
            DWORD           dwMessageNumber;

            DWORD           dwSecondaryVersion;
            DWORD           dwMasterVersion;
            DWORD           dwLastSoaVersion;

            BOOLEAN         fReceivedStartSoa;      // read startup SOA
            BOOLEAN         fBindTransfer;          // transfer to old BIND servers
            BOOLEAN         fMsTransfer;            // transfer to MS server
            BOOLEAN         fLastPassAdd;           // last IXFR pass was add
        }
        Xfr;

        //
        //  Forwarding info
        //

        struct      //  24 bytes
        {
            SOCKET          OriginalSocket;
            IP_ADDRESS      ipOriginal;
            WORD            wOriginalPort;
            WORD            wOriginalXid;
        }
        Forward;
    }
    U;              // 32 bytes

    //
    //  Ptr to internal lookup name
    //

    //  188
    PLOOKUP_NAME    pLooknameQuestion;

    //
    //  Basic packet flags
    //

    //  192
    DWORD           FlagMarker;

    //  196
    BOOLEAN         fDelete;                //  delete after send
    BOOLEAN         fTcp;
    BOOLEAN         fMessageComplete;       //  complete message received
    UCHAR           Section;

    //
    //  Additional processing flag
    //

    //  212
    BOOLEAN         fDoAdditional;

    //
    //  Recursion flags
    //

    //  recursion allowed for packet when recursion desired and not
    //      disabled on server

    //  216
    BOOLEAN         fRecurseIfNecessary;    //  recurse this packet
    BOOLEAN         fRecursePacket;         //  recursion query msg

    //  clear fQuestionRecursed on every new question being looked up
    //      for query (original, CNAME indirection, additional)
    //  set fQuestionRecursed when go out for recursion (or WINS)
    //
    //  clear fQuestionComplete when go out for recursion (or WINS)
    //  set fQuestionComplete when Authoritative answer of recursion;
    //      indicates cut off of further attempts
    //

    //  224
    BOOLEAN         fQuestionRecursed;
    BOOLEAN         fQuestionCompleted;
    BOOLEAN         fRecurseQuestionSent;

    //  completed recursion through list of servers -- waiting for
    //      final timeout

    //  236
    BOOLEAN         fRecurseTimeoutWait;
    INT             nTimeoutCount;          //  total number of timeouts
    CHAR            nForwarder;             //  index of current forwarder

    //
    //  CNAME processing
    //

    //  244
    BOOLEAN         fReplaceCname;          //  replace with CNAME lookup
    UCHAR           cCnameAnswerCount;

    //
    //  Saving compression offsets (may turn off for XFR)
    //

    //  252
    BOOLEAN         fNoCompressionWrite;    // do NOT save offsets for comp.

    //
    //  Wins and Nbstat
    //

    BOOLEAN         fWins;                  //  WINS lookup

    //
    //  Wildcarding
    //

    UCHAR           fQuestionWildcard;

    //
    //  NS List buffer -- not a message
    //      - used to detect on cleanup
    //

    BOOLEAN         fNsList;

    //
    //  Additional records info
    //

    //  268 -- +100 - must add 100 to all following offsets!
    ADDITIONAL_INFO     Additional;

    //
    //  Name compresion info
    //

    //  604
    COMPRESSION_INFO    Compression;

    //
    //  For debug enlist for packet leak tracking
    //

    //  966
#if DBG
    LIST_ENTRY          DbgListEntry;
#endif

#if 0
    //
    //  Parsed RR lists. We use anonymous unions so that in the update
    //  code we can transparently refer to the RR lists by their proper
    //  names. When a message is received and it becomes apparent that
    //  we will want to process it further, we parse it and set the
    //  fRRListsParsed flag. When a change is made to any data in any
    //  of the RR lists, we set the fRRListsDirty flag. Once the dirty
    //  flag is set, the raw message body in MessageBody absolutely
    //  must NOT be read. If this message is sent on the wire, if the
    //  dirty flag is true, the body must be re-written with the
    //  contents of the lists.
    //

    BOOLEAN             fRRListsParsed;
    BOOLEAN             fRRListsDirty;

    union
    {
        PDB_RECORD      pQuestionList;
        PDB_RECORD      pZoneList;
    };
    union
    {
        PDB_RECORD      pAnswerList;
        PDB_RECORD      pPreReqList;
    };
    union
    {
        PDB_RECORD      pAuthList;
        PDB_RECORD      pUpdateList;
    };
    PDB_RECORD          pAdditionalList;
#endif
        
    //
    //  WARNING !
    //
    //  Message length MUST
    //      - be a WORD type
    //      - immediately preceed message itself
    //  for proper send/recv of TCP messages.
    //
    //  Message header (i.e. message itself) MUST be on WORD boundary
    //  so its fields are all WORD aligned.
    //  May be no need to keep it on DWORD boundary, as it has no DWORD
    //  fields.
    //
    //  Since I don't know whether a DNS_HEADER struct will align
    //  itself on a DWORD (but I think it will), force MessageLength
    //  to be the SECOND WORD in a DWORD.
    //

    //  970/966 (debug/retail)
    DWORD           dwForceAlignment;

    //  974/970
    WORD            BytesToReceive;
    WORD            MessageLength;

    //
    //  DNS Message itself
    //

    //  978/974
    DNS_HEADER      Head;       //  12 bytes

    //
    //  Question and RR section
    //
    //  This simply provides some coding simplicity in accessing
    //  this section given MESSAGE_INFO structure.
    //

    //  990/986
    CHAR            MessageBody[1];

}
DNS_MSGINFO, *PDNS_MSGINFO;


//
//  DNS Message Macros
//

#define DNS_HEADER_PTR( pMsg )          ( &(pMsg)->Head )

#define DNSMSG_FLAGS( pMsg )            DNS_HEADER_FLAGS( DNS_HEADER_PTR(pMsg) )

#define DNSMSG_SWAP_COUNT_BYTES( pMsg ) DNS_BYTE_FLIP_HEADER_COUNTS( DNS_HEADER_PTR(pMsg) )

#define DNSMSG_OFFSET( pMsg, p )        ((WORD)((PCHAR)(p) - (PCHAR)DNS_HEADER_PTR(pMsg)))

#define DNSMSG_CURRENT_OFFSET( pMsg )   DNSMSG_OFFSET( (pMsg), (pMsg)->pCurrent )

#define DNSMSG_PTR_FOR_OFFSET( pMsg, wOffset )  \
            ( (PCHAR)DNS_HEADER_PTR(pMsg) + wOffset )

#define DNSMSG_OPT_PTR( pMsg )  \
            ( (PCHAR)DNS_HEADER_PTR(pMsg) + pMsg->Opt.wOptOffset )

#define DNSMSG_END( pMsg )      ( (PCHAR)DNS_HEADER_PTR(pMsg) + (pMsg)->MessageLength )


//
//  Offset to\from name compression
//

#define DNSMSG_QUESTION_NAME_OFFSET         (0x000c)

#define DNSMSG_COMPRESSED_QUESTION_NAME     (0xc00c)

#define OFFSET_FOR_COMPRESSED_NAME( wOffset )   ((WORD)((wOffset) & 0x3fff))

#define COMPRESSED_NAME_FOR_OFFSET( wComp )     ((WORD)((wComp) | 0xc000))


//
//  DnsSec macros
//

#define DNSMSG_INCLUDE_DNSSEC_IN_RESPONSE( _pMsg )                  \
    ( SrvCfg_dwEnableDnsSec == DNS_DNSSEC_ENABLED_ALWAYS ||         \
        SrvCfg_dwEnableDnsSec == DNS_DNSSEC_ENABLED_IF_EDNS &&      \
            ( _pMsg )->Opt.fFoundOptInIncomingMsg )

//
//  Define size of allocations, beyond message buffer itself
//
//      - size of message info struct, outside of header
//      - lookname buffer after message buffer
//
//  Note:  the lookname buffer is placed AFTER the message buffer.
//
//  This allows us to avoid STRICT overwrite checking for small
//  items writing RR to buffer:
//      - compressed name
//      - RR (or Question) struct
//      - IP address (MX preference, SOA fixed fields)
//
//  After RR write, we check whether we are over the end of the buffer
//  and if so, we send and do not use lookup name info again anyway.
//  Cool.
//

#define DNS_MSG_INFO_HEADER_LENGTH  \
            ( sizeof(DNS_MSGINFO) \
            - sizeof(DNS_HEADER) \
            - 1 \
            + sizeof(LOOKUP_NAME) )


//
//  UDP allocation
//      - info struct, max message length, a little padding
//

#define DNSSRV_UDP_PACKET_BUFFER_LENGTH     DNS_RFC_MAX_UDP_PACKET_LENGTH

//#define DNSSRV_UDP_PACKET_BUFFER_LENGTH     (1472)

#define DNS_UDP_ALLOC_LENGTH                        \
            ( DNS_MSG_INFO_HEADER_LENGTH + DNSSRV_UDP_PACKET_BUFFER_LENGTH + 50 )

//
//  DNS TCP allocation.
//
//  Key point, is this is used almost entirely for zone transfer.
//
//      - 16K is maximum compression offset (14bits) so a
//        good default size for sending AXFR packets but BIND9
//        is now going to be sending TCP AXFR packets >16 KB
//
//      - we will continue to write a maximum of 16k on outbound
//        TCP sends so we can take advantage of name compression
//        (why is BIND9 doing this anyways??? - need to research)
//
//  Note:  Critical that packet lengths are DWORD aligned, as
//      lookname buffer follows message at packet length.
//

#define DNS_TCP_DEFAULT_PACKET_LENGTH   ( 0x4000 )      //  16K
#define DNS_TCP_DEFAULT_ALLOC_LENGTH    ( DNS_TCP_DEFAULT_PACKET_LENGTH + \
                                            DNS_MSG_INFO_HEADER_LENGTH )

#define DNS_TCP_MAXIMUM_RECEIVE_LENGTH  ( 0x10000 )     //  64K

//
//  DEVNOTE: should allocate 64K to receive, but limit writes to 16K for
//      compression purposes
//

#define DNS_TCP_REALLOC_PACKET_LENGTH   (0xfffc)
#define DNS_TCP_REALLOC_LENGTH          (0xfffc + \
                                        DNS_MSG_INFO_HEADER_LENGTH)

//
//  Mark boundaries, just to make debugging easier
//

#define PACKET_UNION_MARKER   (0xdcbadbca)

#define PACKET_FLAG_MARKER    (0xf1abf1ab)

//
//  Message tags for debug
//

#define PACKET_TAG_ACTIVE_STANDARD  (0xaaaa1111)
#define PACKET_TAG_ACTIVE_TCP       (0xaaaa2222)
#define PACKET_TAG_FREE_LIST        (0xffffffff)
#define PACKET_TAG_FREE_HEAP        (0xeeeeeeee)

#define SET_PACKET_ACTIVE_UDP(pMsg) ((pMsg)->Tag = PACKET_TAG_ACTIVE_STANDARD)
#define SET_PACKET_ACTIVE_TCP(pMsg) ((pMsg)->Tag = PACKET_TAG_ACTIVE_TCP)
#define SET_PACKET_FREE_LIST(pMsg)  ((pMsg)->Tag = PACKET_TAG_FREE_LIST)
#define SET_PACKET_FREE_HEAP(pMsg)  ((pMsg)->Tag = PACKET_TAG_FREE_HEAP)

#define IS_PACKET_ACTIVE_UDP(pMsg)  ((pMsg)->Tag == PACKET_TAG_ACTIVE_STANDARD)
#define IS_PACKET_ACTIVE_TCP(pMsg)  ((pMsg)->Tag == PACKET_TAG_ACTIVE_TCP)
#define IS_PACKET_FREE_LIST(pMsg)   ((pMsg)->Tag == PACKET_TAG_FREE_LIST)
#define IS_PACKET_FREE_HEAP(pMsg)   ((pMsg)->Tag == PACKET_TAG_FREE_HEAP)


//
//  Message info overlays for zone transfer
//

#define XFR_MESSAGE_NUMBER(pMsg)            ((pMsg)->U.Xfr.dwMessageNumber)

#define IXFR_CLIENT_VERSION(pMsg)           ((pMsg)->U.Xfr.dwSecondaryVersion)
#define IXFR_MASTER_VERSION(pMsg)           ((pMsg)->U.Xfr.dwMasterVersion)
#define IXFR_LAST_SOA_VERSION(pMsg)         ((pMsg)->U.Xfr.dwLastSoaVersion)
#define IXFR_LAST_PASS_ADD(pMsg)            ((pMsg)->U.Xfr.fLastPassAdd)

#define RECEIVED_XFR_STARTUP_SOA(pMsg)      ((pMsg)->U.Xfr.fReceivedStartSoa)
#define XFR_MS_CLIENT(pMsg)                 ((pMsg)->U.Xfr.fMsTransfer)
#define XFR_BIND_CLIENT(pMsg)               ((pMsg)->U.Xfr.fBindTransfer)


//
//  Message remote IP as string
//

#define MSG_IP_STRING( pMsg )   inet_ntoa( (pMsg)->RemoteAddress.sin_addr )


//
//  Query XID space
//
//  The DNS packet is fundamentally broken in requiring processing of
//  name fields to find question or response information.
//
//  To simplify identification of responses, we partition our query XID
//  space.
//
//  WINS XIDs also constrained.
//
//  To operate on the same server as the WINS server, the packets
//  MUST have XIDs that netBT, which recevies the packets, considers
//  to be in the WINS range -- the high bit set (host order).
//
//
//  XID Partion (HOST order)
//
//      WINS query      =>  high bit set
//      recursive query =>  high bit clear, second bit clear
//      zone check      =>  high bit clear, second bit set
//        SOA query     =>  high bit clear, second bit set, third bit set
//        IXFR query    =>  high bit clear, second bit set, third bit clear
//
//  Note that WINS high bit MUST be set in HOST BYTE ORDER.  So we set
//  these XIDS and queue in HOST byte order, then MUST flip bytes before
//  send and after recv before test.
//
//  (We could get around this by simply setting byte flipped high bit
//  0x0080 for WINS and not flipping bytes.   But then we'd have only
//  128 WINS queries before XID wrap.)
//

#define MAKE_WINS_XID( xid )        ( (xid) | 0x8000 )

#define IS_WINS_XID( xid )          ( (xid) & 0x8000 )


#define MAKE_RECURSION_XID( xid )   ( (xid) & 0x3fff )

#define IS_RECURSION_XID( xid )     ( ! ((xid) & 0xc000) )


#define MAKE_SOA_CHECK_XID( xid )   ( ((xid) & 0x1fff) | 0x6000 )

#define IS_SOA_CHECK_XID( xid )     ( ((xid) & 0xe000) == 0x6000 )


#define MAKE_IXFR_XID( xid )        ( ((xid) & 0x1fff) | 0x4000 )

#define IS_IXFR_XID( xid )          ( ((xid) & 0xe000) == 0x4000 )


//
//  For recursion XIDs we attempt to be "effectively random" -- not
//  predictable and hence vulnerable to security attack that requires
//  knowledge of next XID.  Yet use sequential piece to insure no possible
//  reuse in reasonable time even under "bizzaro" conditions.
//
//  To make this less obvious on the wire, put sequential piece on
//  non-hex digit boundary.
//
//  1 = always 1
//  0 = always 0
//  R = Random portion of XID
//  S = Sequential portion of XID
//
//  BIT ---->       151413121110 9 8 7 6 5 4 3 2 1 0
//  SOA CHECK XID    0 1 1 R R S S S S S S S S R R R
//  IXFR XID         0 1 0 R R S S S S S S S S R R R
//  RECURSION XID    0 0 R R R S S S S S S S S R R R
//  WINS XID         1 R R R R S S S S S S S S R R R
//

#define XID_RANDOM_MASK             0xf807  //  1111 1000 0000 0111
#define XID_SEQUENTIAL_MASK         0x07f8  //  0000 0111 1111 1000
#define XID_SEQUENTIAL_SHIFT        ( 3 )

#define XID_SEQUENTIAL_MAKE(Xid)    ( ((Xid) << XID_SEQUENTIAL_SHIFT) & XID_SEQUENTIAL_MASK )

#define XID_RANDOM_MAKE(Xid)        ( (Xid) & XID_RANDOM_MASK )



//
//  Forwarding info save \ restore
//

#define SAVE_FORWARDING_FIELDS(pMsg)    \
{                                       \
    PDNS_MSGINFO  pmsg = (pMsg);        \
    pmsg->U.Forward.OriginalSocket = pmsg->Socket;                        \
    pmsg->U.Forward.ipOriginal     = pmsg->RemoteAddress.sin_addr.s_addr; \
    pmsg->U.Forward.wOriginalPort  = pmsg->RemoteAddress.sin_port;        \
    pmsg->U.Forward.wOriginalXid   = pmsg->Head.Xid;                      \
}

#define RESTORE_FORWARDING_FIELDS(pMsg) \
{                                       \
    PDNS_MSGINFO  pmsg = (pMsg);        \
    pmsg->Socket                        = pmsg->U.Forward.OriginalSocket; \
    pmsg->RemoteAddress.sin_addr.s_addr = pmsg->U.Forward.ipOriginal;     \
    pmsg->RemoteAddress.sin_port        = pmsg->U.Forward.wOriginalPort;  \
    pmsg->Head.Xid                      = pmsg->U.Forward.wOriginalXid;   \
}

#define COPY_FORWARDING_FIELDS(pMsgTarget, pMsgOriginal) \
{                                                                                     \
    pMsgTarget->Socket                        = pMsgOriginal->U.Forward.OriginalSocket; \
    pMsgTarget->RemoteAddress.sin_addr.s_addr = pMsgOriginal->U.Forward.ipOriginal;     \
    pMsgTarget->RemoteAddress.sin_port        = pMsgOriginal->U.Forward.wOriginalPort;  \
    pMsgTarget->Head.Xid                      = pMsgOriginal->U.Forward.wOriginalXid;   \
}


//
//  Query response resets
//      - turn on additional section processing
//      - other values are clear by default
//

#define SET_MESSAGE_FOR_QUERY_RESPONSE( pMsg )  \
    {                                           \
        (pMsg)->fDoAdditional       = TRUE;     \
    }

//
//  Break into pre\post drop pieces.
//
//  If I do the SET_MESSAGE_FOR_UDP_RECV() before dropping packet,
//  on a quiet net the time may be stale, by the time we actually receive
//  a packet.
//  However if wait until after recv(), then WSARecvFrom() failures that are
//  will hit ASSERT()s on free, checking for issues like NO pRecurseMsg and
//  not on queue.
//  To simplify, do everything before drop, then reset time after drop.
//
//  Before Drop
//      -- Nothing necessary, allocator clears all fields
//
//  After Recv
//      -- Set receive time
//

#define SET_MESSAGE_FIELDS_AFTER_RECV( pMsg )   \
        {                                       \
            (pMsg)->dwQueryTime     = DNS_TIME();   \
        }

//
//  This macro returns the number of seconds since this query was 
//  initially received.
//

#define TIME_SINCE_QUERY_RECEIVED( pMsg )   ( DNS_TIME() - ( pMsg )->dwQueryTime )

//
//  This handy after fail to write IXFR in UDP and need answer normally
//

#define RESET_MESSAGE_TO_ORIGINAL_QUERY( pMsg ) \
    {                                           \
        (pMsg)->pCurrent            = (PCHAR)((pMsg)->pQuestion + 1);   \
        (pMsg)->Head.AnswerCount    = 0;        \
        (pMsg)->Compression.cCount  = 0;        \
    }


//
//  Wildcard flag states
//
//  When test wildcard track the result so we don't have to test again before
//  sending NAME_ERROR
//

#define WILDCARD_UNKNOWN            (0)
#define WILDCARD_EXISTS             (0x01)
#define WILDCARD_NOT_AVAILABLE      (0xff)

//  Wildcard check but no write lookup
//  Use when verifying presence of wildcard data for NAME_ERROR \ NO_ERROR
//      determination

#define WILDCARD_CHECK_OFFSET       ((WORD)0xffff)


//
//  RR count reading
//

#define QUESTION_SECTION_INDEX      (0)
#define ANSWER_SECTION_INDEX        (1)
#define AUTHORITY_SECTION_INDEX     (2)
#define ADDITIONAL_SECTION_INDEX    (3)

#define ZONE_SECTION_INDEX          QUESTION_SECTION_INDEX
#define PREREQ_SECTION_INDEX        ANSWER_SECTION_INDEX
#define UPDATE_SECTION_INDEX        AUTHORITY_SECTION_INDEX

#define RR_SECTION_COUNT_HEADER(pHead, section) \
            ( ((PWORD) &pHead->QuestionCount)[section] )

#define RR_SECTION_COUNT(pMsg, section) \
            ( ((PWORD) &pMsg->Head.QuestionCount)[section] )

//
//  RR count writing
//

#define CURRENT_RR_SECTION_COUNT( pMsg )    \
            RR_SECTION_COUNT( pMsg, (pMsg)->Section )


#define SET_TO_WRITE_QUESTION_RECORDS(pMsg) \
            ((pMsg)->Section = QUESTION_SECTION_INDEX)

#define SET_TO_WRITE_ANSWER_RECORDS(pMsg) \
            ((pMsg)->Section = ANSWER_SECTION_INDEX)

#define SET_TO_WRITE_AUTHORITY_RECORDS(pMsg) \
            ((pMsg)->Section = AUTHORITY_SECTION_INDEX)

#define SET_TO_WRITE_ADDITIONAL_RECORDS(pMsg) \
            ((pMsg)->Section = ADDITIONAL_SECTION_INDEX)


#define IS_SET_TO_WRITE_QUESTION_RECORDS(pMsg) \
            ((pMsg)->Section == QUESTION_SECTION_INDEX)

#define IS_SET_TO_WRITE_ANSWER_RECORDS(pMsg) \
            ((pMsg)->Section == ANSWER_SECTION_INDEX)

#define IS_SET_TO_WRITE_AUTHORITY_RECORDS(pMsg) \
            ((pMsg)->Section == AUTHORITY_SECTION_INDEX)

#define IS_SET_TO_WRITE_ADDITIONAL_RECORDS(pMsg) \
            ((pMsg)->Section == ADDITIONAL_SECTION_INDEX)


//
//  Fast AXFR tag
//
//  Alerts MS master that MS secondary, so it can do fast zone transfer.
//

#define DNS_FAST_AXFR_TAG   (0x534d)

#define APPEND_MS_TRANSFER_TAG( pmsg )                                  \
        if ( SrvCfg_fAppendMsTagToXfr )                                 \
        {                                                               \
            *(UNALIGNED WORD *) (pmsg)->pCurrent = DNS_FAST_AXFR_TAG;   \
            (pmsg)->pCurrent += sizeof(WORD);                           \
        }


//
//  Packet reads and writes are unaligned
//

//  Write value to unaligned position in packet

#define WRITE_PACKET_HOST_DWORD(pch, dword)  \
            ( *(UNALIGNED DWORD *)(pch) = htonl(dword) )

#define WRITE_PACKET_NET_DWORD(pch, dword)  \
            ( *(UNALIGNED DWORD *)(pch) = (dword) )

#define WRITE_PACKET_HOST_WORD(pch, word)  \
            ( *(UNALIGNED WORD *)(pch) = htons(word) )

#define WRITE_PACKET_NET_WORD(pch, word)  \
            ( *(UNALIGNED WORD *)(pch) = (word) )

//  Write value and move ptr

#define WRITE_PACKET_HOST_DWORD_MOVEON(pch, dword)  \
            ( WRITE_PACKET_HOST_DWORD(pch, dword), (PCHAR)(pch) += sizeof(DWORD) )

#define WRITE_PACKET_NET_DWORD_MOVEON(pch, dword)  \
            ( WRITE_PACKET_NET_DWORD(pch, dword), (PCHAR)(pch) += sizeof(DWORD) )

#define WRITE_PACKET_HOST_WORD_MOVEON(pch, word)  \
            ( WRITE_PACKET_HOST_WORD(pch, dword), (PCHAR)(pch) += sizeof(WORD) )

#define WRITE_PACKET_NET_WORD_MOVEON(pch, word)  \
            ( WRITE_PACKET_NET_WORD(pch, dword), (PCHAR)(pch) += sizeof(WORD) )


//  Read unaligned value from given position in packet

#define READ_PACKET_HOST_DWORD(pch)  \
            FlipUnalignedDword( pch )

#define READ_PACKET_NET_DWORD(pch)  \
            ( *(UNALIGNED DWORD *)(pch) )

#define READ_PACKET_HOST_WORD(pch)  \
            FlipUnalignedWord( pch )

#define READ_PACKET_NET_WORD(pch)  \
            ( *(UNALIGNED WORD *)(pch) )

//  Read unaligned value and move ptr

#define READ_PACKET_HOST_DWORD_MOVEON(pch)  \
            READ_PACKET_HOST_DWORD( ((PDWORD)pch)++ )

//            ( (dword) = READ_PACKET_HOST_DWORD(pch), (PCHAR)(pch) += sizeof(DWORD) )

#define READ_PACKET_NET_DWORD_MOVEON(pch)  \
            READ_PACKET_NET_DWORD( ((PDWORD)pch)++ )


//            ( (dword) = READ_PACKET_NET_DWORD(pch), (PCHAR)(pch) += sizeof(DWORD) )

#define READ_PACKET_HOST_WORD_MOVEON(pch)  \
            READ_PACKET_HOST_WORD( ((PWORD)pch)++ )

//            ( (word) = READ_PACKET_HOST_WORD(pch), (PCHAR)(pch) += sizeof(WORD) )

#define READ_PACKET_NET_WORD_MOVEON(pch)  \
            READ_PACKET_NET_WORD( ((PWORD)pch)++ )

//            ( (word) = READ_PACKET_NET_WORD(pch), (PCHAR)(pch) += sizeof(WORD) )

#define SET_OPT_BASED_ON_ORIGINAL_QUERY( pMsg ) \
    { \
    pMsg->Opt.fInsertOptInOutgoingMsg = \
        pMsg->Opt.wOriginalQueryPayloadSize != 0; \
    pMsg->Opt.wUdpPayloadSize = pMsg->Opt.wOriginalQueryPayloadSize; \
    }

#define SET_SEND_OPT( pMsg ) \
    pMsg->Opt.fInsertOptInOutgoingMsg = TRUE;

#define CLEAR_SEND_OPT( pMsg ) \
    pMsg->Opt.fInsertOptInOutgoingMsg = FALSE;


#endif  // _DNS_MSGINFO_INC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\name.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    name.c

Abstract:

    Domain Name System (DNS) Server

    Count\dbase name functions.

Author:

    Jim Gilroy (jamesg)     April 1998

Revision History:

--*/


#include "dnssrv.h"



//
//  Basic count name functions
//

DWORD
Name_SizeofCountName(
    IN      PCOUNT_NAME     pName
    )
/*++

Routine Description:

    Get sizeof of count name -- full buffer length.

Arguments:

    pName - count name

Return Value:

    Ptr to next byte after count name.

--*/
{
    return( pName->Length + SIZEOF_COUNT_NAME_FIXED );
}



VOID
Name_ClearCountName(
    IN      PCOUNT_NAME     pName
    )
/*++

Routine Description:

    Clear count name.

    This is equivalent to setting name to root.

Arguments:

    pName - count name

Return Value:

    None.

--*/
{
    pName->Length = 1;
    pName->LabelCount = 0;
    pName->RawName[0] = 0;
}



PDB_NAME
Name_SkipCountName(
    IN      PCOUNT_NAME     pName
    )
/*++

Routine Description:

    Skip to end of count name.

Arguments:

    pName - count name

Return Value:

    Ptr to next byte after count name.

--*/
{
    return( (PDB_NAME) (pName->RawName + pName->Length) );
}



BOOL
Name_IsEqualCountNames(
    IN      PCOUNT_NAME     pName1,
    IN      PCOUNT_NAME     pName2
    )
/*++

Routine Description:

    Get sizeof of count name -- full buffer length.

Arguments:

    pName - count name

Return Value:

    Ptr to next byte after count name.

--*/
{
    if ( pName1->Length != pName2->Length )
    {
        return( FALSE );
    }

    return RtlEqualMemory(
                pName1->RawName,
                pName2->RawName,
                pName1->Length );
}



BOOL
Name_ValidateCountName(
    IN      PCOUNT_NAME     pName
    )
/*++

Routine Description:

    Validate Dbase name.

Arguments:

    pName - count name to validate

Return Value:

    TRUE if valid count name.
    FALSE on error.

--*/
{
    PCHAR   pch;
    PCHAR   pchstop;
    DWORD   labelCount = 0;
    DWORD   labelLength;


    pch = pName->RawName;
    pchstop = pch + pName->Length;

    //
    //  write each label to buffer
    //

    while ( pch < pchstop )
    {
        labelLength = *pch++;

        if ( labelLength == 0 )
        {
            break;
        }
        pch += labelLength;
        labelCount++;
    }

    if ( pch != pchstop )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Invalid name length in validation!!!\n"
            "\tname start = %p\n",
            pName->RawName ));
        ASSERT( FALSE );
        return( FALSE );
    }

    //
    //  DEVNOTE: label count not being set correctly?
    //

    if ( labelCount != pName->LabelCount )
    {
        pName->LabelCount = (UCHAR)labelCount;
        // return( FALSE );
    }

    return( TRUE );
}



DNS_STATUS
Name_CopyCountName(
    OUT     PCOUNT_NAME     pOutName,
    IN      PCOUNT_NAME     pCopyName
    )
/*++

Routine Description:

    Copy counted name.

Arguments:

    pOutName  - count name buffer

    pCopyName   - count name to copy

Return Value:

    ERROR_SUCCESS

--*/
{
    //
    //  copy name
    //      - note no validity check
    //

    RtlCopyMemory(
        pOutName,
        pCopyName,
        pCopyName->Length + SIZEOF_COUNT_NAME_FIXED );

    IF_DEBUG( LOOKUP2 )
    {
        Dbg_CountName(
            "Count name after copy:  ",
            pOutName,
            "\n"
            );
    }
    return( ERROR_SUCCESS );
}



DNS_STATUS
Name_AppendCountName(
    IN OUT  PCOUNT_NAME     pCountName,
    IN      PCOUNT_NAME     pAppendName
    )
/*++

Routine Description:

    Append one counted name to another.

Arguments:

    pCountName  - counted name buffer

    pAppendName - counted name to append

Return Value:

    ERROR_SUCCESS           -- if successful
    DNS_ERROR_INVALID_NAME  -- if name invalid

--*/
{
    DWORD   length;

    IF_DEBUG( LOOKUP2 )
    {
        Dbg_CountName(
            "Appending counted name:  ",
            pAppendName,
            "\n"
            );
        Dbg_CountName(
            "\tto counted name:  ",
            pCountName,
            "\n"
            );
    }

    //
    //  verify valid length
    //

    length = pCountName->Length + pAppendName->Length - 1;
    if ( length > DNS_MAX_NAME_LENGTH )
    {
        return( DNS_ERROR_INVALID_NAME );
    }

    //
    //  add label counts
    //

    pCountName->LabelCount += pAppendName->LabelCount;

    //
    //  copy append name
    //      - note no validity check
    //      - note write over first names terminating NULL
    //

    RtlCopyMemory(
        pCountName->RawName + pCountName->Length - 1,
        pAppendName->RawName,
        pAppendName->Length );

    pCountName->Length = (UCHAR) length;


    IF_DEBUG( LOOKUP2 )
    {
        Dbg_CountName(
            "Count name post-append:  ",
            pCountName,
            "\n"
            );
    }
    return( ERROR_SUCCESS );
}



//
//  From dotted name
//

PCOUNT_NAME
Name_CreateCountNameFromDottedName(
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength     OPTIONAL
    )
/*++

Routine Description:

    Create counted name.

    Note the created name is READ_ONLY it contains ONLY space
    necessary for name.

Arguments:

    pchName     - name to convert, given in human readable (dotted) form.

    cchNameLength - number of chars in dotted name, if zero then
            pchName is assumed to be NULL terminated

Return Value:

    Ptr to counted name.
    NULL on invalid name or alloc error.

--*/
{
    PCOUNT_NAME     pcountName;
    DNS_STATUS      status;

    //
    //  allocate space
    //      - one extra character required for leading label
    //      - one extra character may be required terminating NULL if not
    //          FQDN form
    //

    if ( !cchNameLength )
    {
        if ( pchName )
        {
            cchNameLength = strlen( pchName );
        }
    }
    pcountName = ALLOC_TAGHEAP( (SIZEOF_COUNT_NAME_FIXED + cchNameLength + 2), MEMTAG_NAME );
    IF_NOMEM( !pcountName )
    {
        return( NULL );
    }

    //
    //  DEVNOTE: Using file name routine for dotted name. Need to decide
    //  name validity and format for name input to Zone_Create()
    //      -> UTF8?  file format?
    //

    status = Name_ConvertFileNameToCountName(
                pcountName,
                pchName,
                cchNameLength );

    if ( status != ERROR_INVALID_NAME )
    {
        IF_DEBUG( LOOKUP2 )
        {
            Dbg_CountName(
                "Count converted from file name:  ",
                pcountName,
                "\n"
                );
        }
        return( pcountName );
    }

    FREE_HEAP( pcountName );
    return( NULL );
}



DNS_STATUS
Name_AppendDottedNameToCountName(
    IN OUT  PCOUNT_NAME     pCountName,
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength       OPTIONAL
    )
/*++

Routine Description:

    Append dotted name to count name.

Arguments:

    pCountName  - existing count name to append to

    pchName     - name to convert, given in human readable (dotted) form.

    cchNameLength - number of chars in dotted name, if zero then
            pchName is assumed to be NULL terminated

Return Value:

    Ptr to counted name.
    NULL on invalid name or alloc error.

--*/
{
    DNS_STATUS      status;
    COUNT_NAME      nameAppend;

    //
    //  no-op when no name given
    //

    if ( !pchName )
    {
        return( ERROR_SUCCESS );
    }

    //
    //  build count name for dotted name
    //

    status = Name_ConvertFileNameToCountName(
                & nameAppend,
                pchName,
                cchNameLength );

    if ( status == ERROR_INVALID_NAME )
    {
        DNS_DEBUG( ANY, (
            "Invalid name %.*s not converted to count name!\n",
            cchNameLength,
            pchName ));
        return( status );
    }

    ASSERT( status == DNS_STATUS_FQDN || status == DNS_STATUS_DOTTED_NAME );

    //
    //  append name to existing count name
    //

    return Name_AppendCountName(
                pCountName,
                & nameAppend );
}



//
//  From dbase node
//

VOID
Name_NodeToCountName(
    OUT     PCOUNT_NAME     pName,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Write domain name to packet.

    This writes FULL domain name -- no compression.

Arguments:

    pch - location to write name

    pchStop - ptr to byte after packet buffer

    pNode - node in database of domain name to write

Return Value:

    Ptr to next byte in packet buffer.

--*/
{
    UCHAR   labelLength;
    UCHAR   labelCount = 0;
    PCHAR   pch;

    ASSERT( pNode != NULL );
    ASSERT( pName != NULL );

    //
    //  traverse back up database, writing complete domain name
    //

    pch = pName->RawName;

    while( 1 )
    {
        ASSERT( pNode->cchLabelLength <= 63 );

        labelLength = pNode->cchLabelLength;
        *pch++ = labelLength;

        if ( labelLength == 0 )
        {
            ASSERT( pNode->pParent == NULL );
            break;
        }

        RtlCopyMemory(
            pch,
            pNode->szLabel,
            labelLength );

        pch += labelLength;
        labelCount++;
        pNode = pNode->pParent;
    }

    //  determine full name length

    pName->Length = (UCHAR)(pch - pName->RawName);

    pName->LabelCount = labelCount;

    IF_DEBUG( READ )
    {
        DNS_PRINT((
            "Node %s at %p written to count name\n",
            pNode->szLabel,
            pNode ));
        Dbg_CountName(
            "New count name for node:",
            pName,
            NULL );
    }
}



//
//  Packet read\write
//

PCHAR
Name_PacketNameToCountName(
    OUT     PCOUNT_NAME     pCountName,
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacketName,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Converts packet name to counted name format.

Arguments:

    pCountName  - counted name buffer

    pMsg        - message buffer containing name

    pchPacketName - ptr to name in packet

    pchEnd      - limit on extent of name;
                    - may be message buffer end
                    - message end
                    - packet RR data end

Return Value:

    Ptr to next byte in packet.
    NULL on error.

--*/
{
    PUCHAR  pch;
    PUCHAR  pchnext = NULL;
    UCHAR   ch;
    UCHAR   cch;
    UCHAR   cflag;
    PUCHAR  presult;
    PUCHAR  presultStop;
    UCHAR   labelCount = 0;

    //
    //  set result stop
    //      - if reach stop byte, then invalid name
    //

    presult = pCountName->RawName;
    presultStop = presult + DNS_MAX_NAME_LENGTH;

    pch = pchPacketName;

    //
    //  Loop until end of name
    //

    while ( 1 )
    {
        cch = *pch++;

        //
        //  at root -- finished
        //

        if ( cch == 0 )
        {
            *presult++ = cch;
            break;
        }

        //
        //  regular label
        //      - store ptr and length
        //

        cflag = cch & 0xC0;
        if ( cflag == 0 )
        {
            labelCount++;
            *presult++ = cch;
            if ( presult + cch >= presultStop )
            {
                IF_DEBUG( LOOKUP )
                {
                    Dbg_MessageNameEx(
                        "Packet name exceeding name length:\n",
                        pchPacketName,
                        pMsg,
                        pchEnd,
                        NULL );
                }
                DNS_LOG_EVENT(
                    DNS_EVENT_PACKET_NAME_TOO_LONG,
                    0,
                    NULL,
                    NULL,
                    cch );
                goto InvalidName;
            }

            if ( pch + cch >= pchEnd )
            {
                IF_DEBUG( LOOKUP )
                {
                    DNS_PRINT((
                        "ERROR:  Packet name at %p in message %p\n"
                        "\textends to %p beyond end of packet buffer %p\n",
                        pchPacketName,
                        pMsg,
                        pch,
                        pchEnd ));
                    Dbg_MessageNameEx(
                        "Packet name with invalid name:\n",
                        pchPacketName,
                        pMsg,
                        pchEnd,
                        NULL );
                }
                goto InvalidName;
            }

            //
            //  copy downcasing ASCII upper chars
            //  UTF8 MUST be properly downcased on wire
            //

            while ( cch-- )
            {
                ch = *pch++;
                if ( !IS_ASCII_UPPER(ch) )
                {
                    *presult++ = ch;
                    continue;
                }
                *presult++ = DOWNCASE_ASCII(ch);
                continue;
            }

            ASSERT( presult < presultStop );
            continue;
        }

        //
        //  offset
        //      - calc offset to continuation of name
        //      - verify new offset is BEFORE this packet name
        //          and current position in packet
        //      - continue at new offset
        //

        else if ( cflag == 0xC0 )
        {
            WORD    offset;
            PCHAR   pchoffset;

            offset = (cch ^ 0xC0);
            offset <<= 8;
            offset |= *pch;

            pchoffset = --pch;
            pch = (PCHAR) DNS_HEADER_PTR(pMsg) + offset;

            if ( pch >= pchPacketName || pch >= pchoffset )
            {
                IF_DEBUG( LOOKUP )
                {
                    DNS_PRINT((
                        "ERROR:  Bogus name offset %d, encountered at %p\n"
                        "\tto location %p beyond offset.\n",
                        offset,
                        pchoffset,
                        pch ));

                    Dbg_MessageNameEx(
                        "Packet name with bad offset:\n",
                        pchPacketName,
                        pMsg,
                        pchEnd,
                        NULL );
                }
                DNS_LOG_EVENT(
                    DNS_EVENT_PACKET_NAME_OFFSET_TOO_LONG,
                    0,
                    NULL,
                    NULL,
                    offset );
                goto InvalidName;
            }

            //  on first offset, save ptr to byte following name
            //  parsing continues at this point

            if ( !pchnext )
            {
                pchnext = pchoffset + sizeof(WORD);
            }
            continue;
        }

        else
        {
            IF_DEBUG( LOOKUP )
            {
                DNS_PRINT((
                    "Lookup name conversion failed;  byte %02 at 0x%p\n",
                    cch,
                    pch - 1
                    ));
                Dbg_MessageNameEx(
                    "Failed name",
                    pchPacketName,
                    pMsg,
                    pchEnd,
                    NULL );
            }
            DNS_LOG_EVENT(
                DNS_EVENT_PACKET_NAME_BAD_OFFSET,
                0,
                NULL,
                NULL,
                cch );
            goto InvalidName;
        }
    }

    //  set counted name length

    pCountName->Length = (UCHAR)(presult - pCountName->RawName);
    pCountName->LabelCount = labelCount;

    IF_DEBUG( LOOKUP2 )
    {
        Dbg_RawName(
            "Packet Name",
            pCountName->RawName,
            "\n"
            );
    }

    //  return ptr to byte following name
    //      - if offset in name, this was found above
    //      - otherwise it's byte after terminator

    if ( pchnext )
    {
        return( pchnext );
    }
    return( pch );


InvalidName:

#if 0
    {
        PVOID parg = (PVOID) pMsg->RemoteAddress.sin_addr.s_addr;

        DNS_LOG_EVENT(
            DNS_EVENT_INVALID_PACKET_DOMAIN_NAME,
            1,
            & parg,
            EVENTARG_ALL_IP_ADDRESS,
            0 );
    }
#endif
    return( NULL );
}



DWORD
Name_SizeofCountNameForPacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN OUT  PCHAR *         ppchPacketName,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Determine of database name for a packet name.

Arguments:

    pMsg - ptr to message

    pchPacketName - addr of ptr to name in packet;  on return set to
        point at byte after name

    pchEnd - furthest possible end of name in message
                - end of record data for name in record
                - end of message for name in message

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    PUCHAR  pch;
    PCHAR   pchafterName = 0;
    PCHAR   pchstart;
    PCHAR   pchoffset;
    DWORD   length;
    WORD    offset;
    UCHAR   ch;
    UCHAR   cch;
    UCHAR   cflag;


    pch = *ppchPacketName;
    pchstart = pch;
    length = 1;             // for NULL termination

    //
    //  Set packet end if not explicitly given
    //
    //  DEVNOTE:  should be message end, not buffer end
    //

    if ( !pchEnd )
    {
        pchEnd = pMsg->pBufferEnd;
    }

    //
    //  Loop until end of name
    //

    while ( 1 )
    {
        cch = *pch++;

        //
        //  at root -- finished
        //

        if ( cch == 0 )
        {
            pchafterName = pch;
            break;
        }

        //
        //  regular label
        //      - store ptr and length
        //

        cflag = cch & 0xC0;
        if ( cflag == 0 )
        {
            length += cch + 1;
            pch += cch;

            if ( pch < pchEnd )
            {
                continue;
            }

            IF_DEBUG( LOOKUP )
            {
                DNS_PRINT((
                    "ERROR:  Packet name at %p in message %p\n"
                    "\textends to %p beyond end of data %p\n",
                    pchstart,
                    pMsg,
                    pch,
                    pchEnd ));
                Dbg_MessageNameEx(
                    "Packet name with invalid name:\n",
                    pchstart,
                    pMsg,
                    pchEnd,
                    NULL );
            }
            goto InvalidName;
        }

        //
        //  offset
        //      - calc offset to continuation of name
        //      - verify new offset is BEFORE this packet name
        //          and current position in packet
        //      - continue at new offset
        //

        else if ( cflag == 0xC0 )
        {
            if ( pch >= pchEnd )
            {
                goto InvalidName;
            }

            offset = (cch ^ 0xC0);
            offset <<= 8;
            offset |= *pch;

            pchoffset = --pch;

            pch = (PCHAR) DNS_HEADER_PTR(pMsg) + offset;

            if ( pch < pchstart && pch < pchoffset )
            {
                if ( pchafterName == 0 )
                {
                    ASSERT( pchoffset >= pchstart );
                    pchafterName = pchoffset + sizeof(WORD);
                }
                continue;
            }

            IF_DEBUG( LOOKUP )
            {
                DNS_PRINT((
                    "ERROR:  Bogus name offset %d, encountered at %p\n"
                    "\tto location %p beyond offset.\n",
                    offset,
                    pchoffset,
                    pch ));
                Dbg_MessageNameEx(
                    "Packet name with bad offset:\n",
                    pchstart,
                    pMsg,
                    pchEnd,
                    NULL );
            }
            DNS_LOG_EVENT(
                DNS_EVENT_PACKET_NAME_OFFSET_TOO_LONG,
                0,
                NULL,
                NULL,
                offset );
            goto InvalidName;
        }

        else
        {
            IF_DEBUG( LOOKUP )
            {
                DNS_PRINT((
                    "Lookup name conversion failed;  byte %02 at 0x%p\n",
                    cch,
                    pch - 1
                    ));
                Dbg_MessageNameEx(
                    "Failed name",
                    pchstart,
                    pMsg,
                    pchEnd,
                    NULL );
            }
            DNS_LOG_EVENT(
                DNS_EVENT_PACKET_NAME_BAD_OFFSET,
                0,
                NULL,
                NULL,
                cch );
            goto InvalidName;
        }
    }

    //  total length check

    if ( length > DNS_MAX_NAME_LENGTH )
    {
        goto InvalidName;
    }

    //  return length of entire name including header

    DNS_DEBUG( LOOKUP2, (
        "Raw name length %d for packet name at %p\n",
        length,
        pchstart ));

    ASSERT( pchafterName );
    *ppchPacketName = pchafterName;

    return( length + SIZEOF_COUNT_NAME_FIXED );


InvalidName:

    {
        PVOID parg = (PVOID) (ULONG_PTR) pMsg->RemoteAddress.sin_addr.s_addr;

        DNS_LOG_EVENT(
            DNS_EVENT_INVALID_PACKET_DOMAIN_NAME,
            1,
            & parg,
            EVENTARG_ALL_IP_ADDRESS,
            0 );
    }
    *ppchPacketName = pchstart;
    return ( 0 );
}



PCOUNT_NAME
Name_CreateCountNameFromPacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacketName
    )
/*++

Routine Description:

    Converts packet name to counted name format.

Arguments:

    pchPacketName - ptr to name in packet

    pdnsMsg     - ptr to DNS message header

    pCountName  - counted name buffer

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    COUNT_NAME      tempCountName;
    PCOUNT_NAME     pcountName;
    DWORD           length;

    //
    //  DEVNOTE: later for speed, just do counting on first pass,
    //      then second pass is copy into correct sized buffer
    //

    //
    //  convert from packet to count name
    //

    if ( ! Name_PacketNameToCountName(
                & tempCountName,
                pMsg,
                pchPacketName,
                DNSMSG_END( pMsg )
                ) )
    {
        return( NULL );
    }

    //
    //  create count name with standard alloc functions
    //  most names will be short blobs that fit comfortably in standard RRs
    //

    length = tempCountName.Length + SIZEOF_COUNT_NAME_FIXED;

    pcountName = (PCOUNT_NAME) ALLOC_TAGHEAP( length, MEMTAG_NAME );
    IF_NOMEM( !pcountName )
    {
        return( NULL );
    }

    //
    //  copy count name
    //

    RtlCopyMemory(
        pcountName,
        & tempCountName,
        length );

    return (PDB_NAME) pcountName;
}



//
//  RPC buffer (as dotted)
//

PCHAR
Name_WriteCountNameToBufferAsDottedName(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PCOUNT_NAME     pName,
    IN      BOOL            fPreserveEmbeddedDots
    )
/*++

Routine Description:

    Writes counted name to buffer as dotted name.
    Name is written NULL terminated.
    For RPC write.

Arguments:

    pchBuf - location to write name

    pchBufStop - buffers stop byte (byte after buffer)

    pName - counted name

    fPreserveEmbeddedDots - labels may contain embedded
        dots, if this flag is set these dots will be
        escaped with a backslash in the output buffer.

Return Value:

    Ptr to next byte in buffer where writing would resume
    (i.e. ptr to the terminating NULL)

--*/
{
    PCHAR   pch;
    PCHAR   pread;
    DWORD   labelLength;
    INT     embeddedDots = 0;

    DNS_DEBUG( WRITE, (
        "Name_WriteDbaseNameToBufferAsDottedName()\n" ));

    pch = pchBuf;

    //  ensure adequate length

    if ( pch + pName->Length >= pchBufEnd )
    {
        return( NULL );
    }

    //
    //  write each label to buffer
    //

    pread = pName->RawName;

    while ( labelLength = *pread++ )
    {
        ASSERT( pch + labelLength < pchBufEnd );

        //
        //  The label may contain embedded dots. Optionally replace
        //  "." with "\." so that embedded dot does not look like
        //  a regular label separator.
        //

        if ( fPreserveEmbeddedDots && memchr( pread, '.', labelLength ) )
        {
            PCHAR   pchscan;
            PCHAR   pchscanEnd = pread + labelLength;

            for ( pchscan = pread; pchscan < pchscanEnd; ++pchscan )
            {
                //
                //  The extra backslash char makes the initial buffer length
                //  check unreliable do manual check to make sure there's room
                //  for this char plus backslash.
                //

                if ( pch >= pchBufEnd - 2 )
                {
                    return NULL;
                }

                //
                //  Copy character, escaping with backslash if necessary.
                //

                if ( *pchscan == '.' )
                {
                    *pch++ = '\\';
                    ++embeddedDots;
                }
                *pch++ = *pchscan;
            }
        }
        else
        {
            RtlCopyMemory(
                pch,
                pread,
                labelLength );
            pch += labelLength;
        }

        *pch++ = '.';

        pread += labelLength;
    }

    //  write a terminating NULL

    *pch = 0;

    DNS_DEBUG( RPC, (
        "Wrote name %s (len=%d) into buffer at postion %p.\n",
        pchBuf,
        pch - pchBuf,
        pchBuf ));

    ASSERT( pch - pchBuf == pName->Length + embeddedDots - 1 );

    return( pch );
}


PCHAR
Name_WriteDbaseNameToRpcBuffer(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PCOUNT_NAME     pName,
    IN      BOOL            fPreserveEmbeddedDots
    )
/*++

Routine Description:

    Writes counted name to buffer as dotted name.
    Name is written NULL terminated.
    For RPC write.

Arguments:

    pchBuf - location to write name

    pchBufStop - buffers stop byte (byte after buffer)

    pName - counted name

Return Value:

    Ptr to next byte in buffer where writing would resume
    (i.e. ptr to the terminating NULL)
    NULL if unable to write name to buffer.  SetLastError to ERROR_MORE_DATA

--*/
{
    PCHAR   pch;
    INT     labelLength;    // bytes in current label

    //  first byte contains total name length, skip it

    pch = pchBuf;
    pch++;

    //
    //  write dbase name to buffer
    //

    pch = Name_WriteCountNameToBufferAsDottedName(
            pch,
            pchBufEnd,
            pName,
            fPreserveEmbeddedDots );
    if ( !pch )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }
    ASSERT( pch <= pchBufEnd );

    //
    //  write name length byte
    //      - do NOT count terminating NULL
    //

    ASSERT( *pch == 0 );

    ASSERT( (pch - pchBuf - 1) <= MAXUCHAR );

    *pchBuf = (CHAR)(UCHAR)(pch - pchBuf - 1);

    return( pch );
}


PCHAR
Name_WriteDbaseNameToRpcBufferNt4(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PCOUNT_NAME     pName
    )
/*++

Routine Description:

    Writes counted name to buffer as dotted name.
    Name is written NULL terminated.
    For RPC write.

Arguments:

    pchBuf - location to write name

    pchBufStop - buffers stop byte (byte after buffer)

    pName - counted name

Return Value:

    Ptr to next byte in buffer where writing would resume
    (i.e. ptr to the terminating NULL)
    NULL if unable to write name to buffer.  SetLastError to ERROR_MORE_DATA

--*/
{
    PCHAR   pch;
    INT     labelLength;    // bytes in current label

    //  first byte contains total name length, skip it

    pch = pchBuf;
    pch++;

    //
    //  write dbase name to buffer
    //

    pch = Name_WriteCountNameToBufferAsDottedName(
            pch,
            pchBufEnd,
            pName,
            FALSE );
    if ( !pch )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }
    ASSERT( pch <= pchBufEnd );

    //
    //  write name length byte
    //      - include terminating NULL
    //
    //  note, we're not interested in string length here, just how
    //  much space name took up in buffer
    //

    pch++;

    ASSERT( (pch - pchBuf - 1) <= MAXUCHAR );

    *pchBuf = (CHAR)(UCHAR)(pch - pchBuf - 1);
    return( pch );
}



DWORD
Name_ConvertRpcNameToCountName(
    IN      PCOUNT_NAME     pName,
    IN OUT  PDNS_RPC_NAME   pRpcName
    )
/*++

Routine Description:

    Converts dotted counted name to COUNT_NAME format.
    For read from RPC buffer.

Arguments:

    pchBuf - location to write name

    pchBufStop - buffers stop byte (byte after buffer)

    pName - counted name

Return Value:

    Length of converted name, if successful.
    0 on error.

--*/
{
    DNS_STATUS  status;

    ASSERT( pName );
    ASSERT( pRpcName );

    //
    //  If the length of the RPC name is zero but the first
    //  name character is not zero, an old DNSMGR is trying
    //  to give us a mal-formed empty string.
    //

    if ( pRpcName->cchNameLength == 0 && pRpcName->achName[ 0 ] )
    {
        return( 0 );
    }

    //
    //  Convert the name.
    //

    status = Name_ConvertFileNameToCountName(
                pName,
                pRpcName->achName,
                pRpcName->cchNameLength
                );
    if ( status == ERROR_INVALID_NAME )
    {
        return( 0 );
    }
    return( pName->Length + SIZEOF_COUNT_NAME_FIXED );
}




//
//  Lookup name
//
//  Lookup names are form of name used directly in looking up name in database.
//
//  Lookup names are stored as
//      - count of labels
//      - total name length
//      - list of ptrs to labels
//      - list of label lengths
//
//  Lookup names are assumed to be FQDNs.
//
//  Because of this we make the following implementation simplifications:
//
//      - only store non-zero labels, empty root label is not stored
//          and label ptr and label length list MAY NOT be assumed to
//          be zero terminated
//
//      - total name length is kept as PACKET LENGTH of name;  hence
//          it is sum of individuals labels lengths plus label count
//          (one count byte for each label) PLUS ONE for null terminator;
//          this makes checks of valid name length straightforward
//

#define DOT ('.')


BOOL
Name_ConvertPacketNameToLookupName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacketName,
    OUT     PLOOKUP_NAME    pLookupName
    )
/*++

Routine Description:

    Converts packet name to lookup name format.

Arguments:

    pchPacketName - ptr to name in packet

    pdnsMsg - ptr to DNS message header

    pLookupName - lookup name buffer

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    register PUCHAR pch;
    register UCHAR  cch;
    register UCHAR  cflag;
    PCHAR *         pointers;
    UCHAR *         lengths;
    USHORT          labelCount = 0;
    WORD            totalLength = 0;

    //
    //  Setup ptrs to walk through lookup name
    //

    pointers = pLookupName->pchLabelArray;
    lengths  = pLookupName->cchLabelArray;


    //
    //  Loop until end of name
    //

    pch = pchPacketName;

    while ( 1 )
    {
        cch = *pch++;

        //
        //  at root -- finished
        //

        if ( cch == 0 )
        {
            //  not using explicit termination anymore
            //  if turned back on must change labelCount check below
            //    *lengths = 0;
            //    *pointers = NULL;
            break;
        }

        //
        //  regular label
        //      - store ptr and length
        //

        cflag = cch & 0xC0;

        if ( cflag == 0 )
        {
            //  kick out if pass maximum label count

            if ( labelCount >= DNS_MAX_NAME_LABELS )
            {
                IF_DEBUG( LOOKUP )
                {
                    Dbg_MessageNameEx(
                        "Packet name exceeds max label count:\n",
                        pchPacketName,
                        pMsg,
                        NULL,       // end at message end
                        NULL );
                }
                DNS_LOG_EVENT(
                    DNS_EVENT_PACKET_NAME_TOO_MANY_LABELS,
                    0,
                    NULL,
                    NULL,
                    0 );
                goto InvalidName;
            }

            *lengths++  = cch;
            *pointers++ = pch;
            labelCount++;
            totalLength += cch + 1;
            pch += cch;

            //
            //  DEVNOTE: this should be message end, not buffer end
            //      problem is do we use this routine to look up WRITTEN lookup name?
            //      if so then message length not updated yet
            //
            //  if ( pch >= DNSMSG_END(pMsg) )
            //

            if ( pch >= pMsg->pBufferEnd )
            {
                IF_DEBUG( LOOKUP )
                {
                    DNS_PRINT((
                        "ERROR:  Packet name at %p in message %p\n"
                        "\textends to %p beyond end of packet buffer %p\n",
                        pchPacketName,
                        pMsg,
                        pch,
                        pMsg->pBufferEnd ));
                    Dbg_MessageNameEx(
                        "Packet name with invalid name:\n",
                        pchPacketName,
                        pMsg,
                        NULL,       // end at message end
                        NULL );
                }
                goto InvalidName;
            }
            continue;
        }

        //
        //  offset
        //      - calc offset to continuation of name
        //      - verify new offset is BEFORE this packet name
        //          and current position in packet
        //      - continue at new offset
        //

        else if ( cflag == 0xC0 )
        {
            WORD    offset;
            PCHAR   pchoffset;

            offset = (cch ^ 0xC0);
            offset <<= 8;
            offset |= *pch;

            pchoffset = --pch;
            pch = (PCHAR) DNS_HEADER_PTR(pMsg) + offset;

            if ( pch >= pchPacketName || pch >= pchoffset )
            {
                IF_DEBUG( LOOKUP )
                {
                    DNS_PRINT((
                        "ERROR:  Bogus name offset %d, encountered at %p\n"
                        "\tto location %p beyond offset.\n",
                        offset,
                        pchoffset,
                        pch ));
                    Dbg_MessageNameEx(
                        "Packet name with bad offset:\n",
                        pchPacketName,
                        pMsg,
                        NULL,       // end at message end
                        NULL );
                }
                DNS_LOG_EVENT(
                    DNS_EVENT_PACKET_NAME_OFFSET_TOO_LONG,
                    0,
                    NULL,
                    NULL,
                    offset );
                goto InvalidName;
            }
            continue;
        }

        else
        {
            IF_DEBUG( LOOKUP )
            {
                DNS_PRINT((
                    "Lookup name conversion failed;  byte %02 at 0x%p\n",
                    cch,
                    pch - 1
                    ));
                Dbg_MessageNameEx(
                    "Failed name",
                    pchPacketName,
                    pMsg,
                    NULL,       // end at message end
                    NULL );
            }
            DNS_LOG_EVENT(
                DNS_EVENT_PACKET_NAME_BAD_OFFSET,
                0,
                NULL,
                NULL,
                cch );
            goto InvalidName;
        }
    }

    //
    //  set count in lookup name
    //

    if ( totalLength >= DNS_MAX_NAME_LENGTH )
    {
        IF_DEBUG( LOOKUP )
        {
            Dbg_MessageNameEx(
                "Packet name exceeding name length:\n",
                pchPacketName,
                pMsg,
                NULL,       // end at message end
                NULL );
        }
        DNS_LOG_EVENT(
            DNS_EVENT_PACKET_NAME_TOO_LONG,
            0,
            NULL,
            NULL,
            cch );
        goto InvalidName;
    }

    pLookupName->cLabelCount    = labelCount;
    pLookupName->cchNameLength  = totalLength + 1;

    IF_DEBUG( LOOKUP2 )
    {
        Dbg_LookupName(
            "Packet Name",
            pLookupName
            );
    }
    return ( TRUE );


InvalidName:

    {
        PVOID   parg = (PVOID) (ULONG_PTR) pMsg->RemoteAddress.sin_addr.s_addr;

        DNS_LOG_EVENT(
            DNS_EVENT_INVALID_PACKET_DOMAIN_NAME,
            1,
            & parg,
            EVENTARG_ALL_IP_ADDRESS,
            0 );
    }
    return ( FALSE );
}



BOOL
Name_ConvertRawNameToLookupName(
    IN      PCHAR           pchRawName,
    OUT     PLOOKUP_NAME    pLookupName
    )
/*++

Routine Description:

    Converts packet name to lookup name format.

Arguments:

    pchRawName - ptr to name in packet

    pdnsMsg - ptr to DNS message header

    pLookupName - lookup name buffer

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    register PUCHAR pch;
    register UCHAR  cch;
    register UCHAR  cflag;
    PCHAR *         pointers;
    UCHAR *         lengths;
    USHORT          labelCount = 0;         // count of labels
    WORD            totalLength = 0;

    //
    //  Setup ptrs to walk through lookup name
    //

    pointers = pLookupName->pchLabelArray;
    lengths  = pLookupName->cchLabelArray;

    //
    //  Loop until end of name
    //

    pch = pchRawName;

    while ( 1 )
    {
        cch = *pch++;

        //
        //  at root -- finished
        //

        if ( cch == 0 )
        {
            *lengths = 0;
            *pointers = NULL;
            break;
        }

        //
        //  label, store ptr and length
        //

        if ( labelCount >= DNS_MAX_NAME_LABELS )
        {
            DNS_DEBUG( ANY, (
                "Raw name exceeds label count!\n",
                pchRawName ));
            goto InvalidName;
        }
        *lengths++  = cch;
        *pointers++ = pch;
        labelCount++;
        totalLength = cch + 1;
        pch += cch;
        continue;
    }

    //
    //  set count in lookup name
    //

    if ( totalLength >= DNS_MAX_NAME_LENGTH )
    {
        DNS_DEBUG( ANY, (
            "Raw name too long!\n" ));
        goto InvalidName;
    }

    pLookupName->cLabelCount    = labelCount;
    pLookupName->cchNameLength  = totalLength + 1;

    IF_DEBUG( LOOKUP2 )
    {
        Dbg_LookupName(
            "Packet Name",
            pLookupName
            );
    }
    return( TRUE );


InvalidName:

    IF_DEBUG( ANY )
    {
        Dbg_RawName(
            "Invalid Raw Name",
            pchRawName,
            "\n" );
    }
    return( FALSE );
}




BOOL
Name_CompareLookupNames(
    IN      PLOOKUP_NAME    pName1,
    IN      PLOOKUP_NAME    pName2
    )
/*++

Routine Description:

    Compare two lookup names for equality.

Arguments:

    Lookup names to compare.

Return Value:

    TRUE if equal, else FALSE.

--*/
{
    INT     i;

    ASSERT( pName1 && pName2 );

    if ( pName1->cLabelCount != pName2->cLabelCount ||
         pName1->cchNameLength != pName2->cchNameLength )
    {
        return FALSE;
    }

    for ( i = 0; i < pName1->cLabelCount; ++i )
    {
        UCHAR   len1 = pName1->cchLabelArray[ i ];

        if ( len1 != pName2->cchLabelArray[ i ] ||
             !RtlEqualMemory(
                    pName1->pchLabelArray[ i ], 
                    pName2->pchLabelArray[ i ],
                    len1 ) )
        {
            return FALSE;
        }
    }
    return TRUE;
}   //  Name_CompareLookupNames



BOOL
Name_ConvertDottedNameToLookupName(
    IN      PCHAR           pchDottedName,
    IN      DWORD           cchDottedNameLength,    OPTIONAL
    OUT     PLOOKUP_NAME    pLookupName
    )
/*++

Routine Description:

    Converts dotted name to lookup name format.

Arguments:

    pchDottedName - name to convert, given in human readable (dotted) form.

    cchDottedNameLength - number of chars in dotted name, if zero then
            pchDottedName is assumed to be NULL terminated

    pLookupName - lookup name buffer

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    PCHAR   pch;
    CHAR    ch;
    PCHAR   pchstart;           // ptr to start of label
    PCHAR   pchend;             // ptr to end of name
    PCHAR * pointers;           // ptr into lookup name pointer array
    UCHAR * lengths;            // ptr into lookup name length array
    DWORD   labelCount = 0;     // count of labels
    INT     label_length;       // length of current label
    INT     cchtotal = 0;       // total length of name


    IF_DEBUG( LOOKUP2 )
    {
        if ( cchDottedNameLength )
        {
            DNS_PRINT((
                "Creating lookup name for \"%.*s\"\n",
                cchDottedNameLength,
                pchDottedName
                ));
        }
        else
        {
            DNS_PRINT((
                "Creating lookup name for \"%s\"\n",
                pchDottedName
                ));
        }
    }

    //
    //  Setup ptrs to walk through lookup name
    //

    pointers = pLookupName->pchLabelArray;
    lengths  = pLookupName->cchLabelArray;


    //
    //  Setup start and end ptrs and verify length
    //

    pch = pchDottedName;
    pchstart = pch;
    if ( !cchDottedNameLength )
    {
        cchDottedNameLength = strlen( pch );
    }
    if ( cchDottedNameLength >= DNS_MAX_NAME_LENGTH )
    {
        //  note length can be valid at max length if dot terminated

        if ( cchDottedNameLength > DNS_MAX_NAME_LENGTH
                ||
            pch[cchDottedNameLength-1] != '.' )
        {
            goto InvalidName;
        }
    }
    pchend = pch + cchDottedNameLength;

    //
    //  Loop until end of name
    //

    while ( 1 )
    {
        if ( pch >= pchend )
        {
            ch = 0;
        }
        else
        {
            ch = *pch;
        }

        //
        //  find end of label
        //      - save ptr to start
        //      - save label length
        //

        if ( ch == DOT || ch == 0 )
        {
            //
            //  verify label length
            //

            label_length = (INT)(pch - pchstart);

            if ( label_length > DNS_MAX_LABEL_LENGTH )
            {
                IF_DEBUG( LOOKUP )
                {
                    DNS_PRINT((
                        "Label exceeds 63 byte limit:  %.*s\n",
                        pchend - pchstart,
                        pchstart ));
                }
                goto InvalidName;
            }

            //
            //  test for termination, trailing dot case
            //      ex: "microsoft.com."
            //      ex: "."
            //
            //  zero label length will catch both
            //      - label starting at terminating NULL,
            //      - standalone "." for root domain
            //

            if ( label_length == 0 )
            {
                //
                //  catch bogus entries
                //      ex:  ".blah"
                //      ex:  "blah.."
                //      ex:  "foo..bar"
                //      ex:  ".."
                //
                //  only root domain name, should have label that started
                //      with DOT, and it must immediately terminate
                //

                if ( ch == DOT
                        &&
                     ( labelCount != 0  ||  ++pch < pchend ) )
                {
                    IF_DEBUG( LOOKUP )
                    {
                        DNS_PRINT((
                            "Bogus label:  %.*s\n",
                            pchend - pchstart,
                            pchstart ));
                    }
                    goto InvalidName;
                }
                break;
            }

            if ( ++labelCount > DNS_MAX_NAME_LABELS )
            {
                DNS_PRINT((
                    "Name_ConvertDottedNameToLookupName: "
                    "name has too many labels\n\t%s\n",
                    pchDottedName ));
                goto InvalidName;
            }
            *pointers++ = pchstart;
            *lengths++ = (UCHAR) label_length;

            cchtotal += label_length;
            cchtotal++;

            //
            //  termination, no trailing dot case
            //      ex: "microsoft.com"
            //

            if ( ch == 0 )
            {
                break;
            }

            //
            //  skip dot
            //  save pointer to start of next label
            //

            pchstart = ++pch;      // save ptr to start of next label
            continue;
        }

        pch++;
    }

    //
    //  set counts in lookup name
    //      - total length is one more than sum of label counts and
    //          lengths to allow for 0 termination
    //

    pLookupName->cLabelCount = (USHORT) labelCount;
    pLookupName->cchNameLength = cchtotal + 1;

    ASSERT( pLookupName->cchNameLength <= DNS_MAX_NAME_LENGTH );

    IF_DEBUG( LOOKUP2 )
    {
        DNS_PRINT((
            "Lookup name for %.*s",
            cchDottedNameLength,
            pchDottedName
            ));
        Dbg_LookupName(
            "",
            pLookupName
            );
    }
    return ( TRUE );


InvalidName:

    IF_DEBUG( LOOKUP )
    {
        DNS_PRINT((
            "Failed to create lookup name for %.*s ",
            cchDottedNameLength,
            pchDottedName
            ));
    }
    {
        //
        //  copy name to NULL terminate for logging
        //

        CHAR    szName[ DNS_MAX_NAME_LENGTH+1 ];
        PCHAR   pszName = szName;

        if ( cchDottedNameLength > DNS_MAX_NAME_LENGTH )
        {
            cchDottedNameLength = DNS_MAX_NAME_LENGTH;
        }
        RtlCopyMemory(
            szName,
            pchDottedName,
            cchDottedNameLength
            );
        szName[ cchDottedNameLength ] = 0;

        DNS_LOG_EVENT(
            DNS_EVENT_INVALID_DOTTED_DOMAIN_NAME,
            1,
            &pszName,
            EVENTARG_ALL_UTF8,
            0 );
    }
    return( FALSE );
}



BOOL
Name_AppendLookupName(
    IN OUT  PLOOKUP_NAME    pLookupName,
    IN      PLOOKUP_NAME    pAppendName
    )
/*++

Routine Description:

    Appends domain name at end of another lookup name.

Arguments:

    pLookupName - lookup name buffer

    pAppendName - name to append

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    INT i;
    USHORT countLabels;

    ASSERT( pLookupName && pAppendName );

    //
    //  check total length
    //

    pLookupName->cchNameLength += pAppendName->cchNameLength - 1;

    if ( pLookupName->cchNameLength > DNS_MAX_NAME_LENGTH )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Appended lookup name too long.\n"
            "\tappend name length   = %d\n"
            "\ttotal appended length = %d\n",
            pAppendName->cchNameLength,
            pLookupName->cchNameLength  ));

        pLookupName->cchNameLength -= pAppendName->cchNameLength - 1;
        goto NameError;
    }

    //
    //  check total label count
    //

    countLabels = pLookupName->cLabelCount;

    if ( countLabels + pAppendName->cLabelCount > DNS_MAX_NAME_LABELS )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Appended lookup name too many labels.\n" ));
        goto NameError;
    }

    //
    //  loop until end of appended name
    //

    for ( i = 0;
            i < pAppendName->cLabelCount;
                i++ )
    {
        pLookupName->pchLabelArray[countLabels] = pAppendName->pchLabelArray[i];
        pLookupName->cchLabelArray[countLabels] = pAppendName->cchLabelArray[i];

        //  increment lookup name label count

        countLabels++;
    }

    //  reset lookup name label count

    pLookupName->cLabelCount = countLabels;

    IF_DEBUG( LOOKUP2 )
    {
        Dbg_LookupName(
            "Appended lookup name",
            pLookupName
            );
    }
    return( TRUE );

NameError:

    return( FALSE );
}



DWORD
Name_ConvertLookupNameToDottedName(
    OUT     PCHAR           pchDottedName,
    IN      PLOOKUP_NAME    pLookupName
    )
/*++

Routine Description:

    Converts lookup name to dotted string name.

Arguments:

    pchDottedName - buffer for name MUST be DNS_MAX_NAME_LENGTH long

    pLookupName - lookup name

Return Value:

    Count of characters converted, if successful.
    Zero on error.

--*/
{
    PCHAR   pch = pchDottedName;
    INT     i;
    INT     cchlabel;

    ASSERT( pLookupName && pchDottedName );

    //
    //  check total length
    //

    if ( pLookupName->cchNameLength > DNS_MAX_NAME_LENGTH )
    {
        *pch = '\0';
        goto NameError;
    }

    //
    //  handle special case of root
    //

    *pch = DOT;

    //
    //  loop until end of appended name
    //

    for ( i = 0;
            i < pLookupName->cLabelCount;
                i++ )
    {
        cchlabel = pLookupName->cchLabelArray[i];

        if ( cchlabel > DNS_MAX_LABEL_LENGTH )
        {
            goto NameError;
        }
        RtlCopyMemory(
            pch,
            pLookupName->pchLabelArray[i],
            cchlabel
            );
        pch += cchlabel;
        *pch++ = DOT;
    }

    //  NULL terminate

    *pch = 0;
    return( (DWORD)(pch - pchDottedName) );

NameError:

    DNS_DEBUG( ANY, (
        "ERROR:  Converting lookupname with invalid name or label count.\n" ));
    ASSERT( FALSE );
    return( 0 );
}



VOID
Name_WriteLookupNameForNode(
    IN      PDB_NODE        pNode,
    OUT     PLOOKUP_NAME    pLookupName
    )
/*++

Routine Description:

    Writes lookup name for domain node.

Arguments:

    pNode - node to get name for

    pLookupName - lookup name buffer

Return Value:

    None

--*/
{
    register USHORT i = 0;
    register UCHAR  cchlabelLength = 0;
    INT             cchNameLength = 0;

    ASSERT( pNode != NULL );
    ASSERT( pLookupName != NULL );

    //
    //  traverse back up database, writing complete domain name
    //
    //  note:  not including root node, for current lookup name
    //      implementation, all lookup names are fully qualified;
    //      hence we stop when find zero label length
    //

    cchNameLength = 0;

    while( cchlabelLength = pNode->cchLabelLength )
    {
        ASSERT( cchlabelLength <= 63 );

        pLookupName->pchLabelArray[ i ] = pNode->szLabel;
        pLookupName->cchLabelArray[ i ] = cchlabelLength;

        cchNameLength += cchlabelLength;
        cchNameLength ++;
        i++;

        //
        //  get node's parent
        //

        pNode = pNode->pParent;

        ASSERT( pNode != NULL );
    }

    //
    //  set counts in lookup name
    //

    pLookupName->cLabelCount = i;
    pLookupName->cchNameLength = cchNameLength + 1;
}



//
//  IP to reverse lookup node names.
//

BOOL
Name_LookupNameToIpAddress(
    IN      PLOOKUP_NAME    pLookupName,
    OUT     PIP_ADDRESS     pIpAddress
    )
/*++

Routine Description:

    Convert lookup name (for in-addr.arpa domain) to corresponding
    IP address (in net byte order).

Arguments:

    pLookupName - lookup name buffer

    pIpAddress - addr to write IP address

Return Value:

    TRUE if lookup name is valid IP
    FALSE otherwise

--*/
{
    DWORD   dwByte;
    INT     i;
    UCHAR   cchlabel;
    PUCHAR  pchLabel;

    ASSERT( pIpAddress != NULL );
    ASSERT( pLookupName != NULL );

    //
    //  verify six labels (4 address bytes, and "in-addr.arpa")
    //

    if ( pLookupName->cLabelCount != 6 )
    {
        IF_DEBUG( NBSTAT )
        {
            Dbg_LookupName(
                "Attempt to convert bogus reverse lookup name to IP address.",
                pLookupName );
        }
        return( FALSE );
    }

    //
    //  write each address byte in turn
    //

    *pIpAddress = 0;

    for ( i=0; i<4; i++ )
    {
        cchlabel = pLookupName->cchLabelArray[ i ];
        pchLabel = pLookupName->pchLabelArray[ i ];

        ASSERT( pchLabel );
        ASSERT( cchlabel );

        if ( cchlabel > 3 )
        {
            TEST_ASSERT( FALSE );
            return( FALSE );
        }

        //  create UCHAR for address byte
        //  add in one decimal digit at a time

        dwByte = 0;
        while ( cchlabel-- )
        {
            dwByte *= 10;
            TEST_ASSERT( *pchLabel >= '0');
            TEST_ASSERT( *pchLabel <= '9');
            dwByte += (*pchLabel++) - '0';
        }
        if ( dwByte > 255 )
        {
            TEST_ASSERT( FALSE );
            return( FALSE );
        }

        //  put address byte in IP address
        //      - network byte order

        ((PUCHAR)pIpAddress)[3-i] = (UCHAR) dwByte;
    }

    //
    //  verify in-addr.arpa. domain
    //

    ASSERT( pLookupName->cchLabelArray[ i ] == 7 );
    ASSERT( ! _strnicmp(
                pLookupName->pchLabelArray[ i ],
                "in-addr",
                7 ) );

    return( TRUE );
}



BOOL
Name_WriteLookupNameForIpAddress(
    IN      LPSTR           pszIpAddress,
    IN      PLOOKUP_NAME    pLookupName
    )
/*++

Routine Description:

    Write lookup name for IP address.

Arguments:

    pszIpAddress -- IP address of reverse lookup node desired

    pLookupName -- lookup name to create

Return Value:

    TRUE if successfull.
    FALSE otherwise.

--*/
{
    LOOKUP_NAME looknameArpa;

    IF_DEBUG( LOOKUP2 )
    {
        DNS_PRINT((
            "Getting lookup name for IP addres = %s.\n",
            pszIpAddress ));
    }

    if ( ! Name_ConvertDottedNameToLookupName(
                "in-addr.arpa",
                0,
                & looknameArpa ) )
    {
        ASSERT( FALSE );
        return( FALSE );
    }
    if ( ! Name_ConvertDottedNameToLookupName(
                pszIpAddress,
                0,
                pLookupName ) )
    {
        ASSERT( FALSE );
        return( FALSE );
    }
    if ( ! Name_AppendLookupName(
                pLookupName,
                & looknameArpa ) )
    {
        ASSERT( FALSE );
        return( FALSE );
    }

    return( TRUE );
}


//
//  End of name.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\nameutil.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    nameutil.c

Abstract:

    Domain Name System (DNS) Server

    Name processing utilities.

Author:

    Jim Gilroy (jamesg)     February 1995

Revision History:

--*/


#include "dnssrv.h"



//
//  Node name to packet writing utilities
//

PCHAR
FASTCALL
Name_PlaceFullNodeNameInPacket(
    IN OUT  PCHAR               pch,
    IN      PCHAR               pchStop,
    IN      PDB_NODE            pNode
    )
/*++

Routine Description:

    Write domain name to packet.

    This writes FULL domain name -- no compression.

Arguments:

    pch - location to write name

    pchStop - ptr to byte after packet buffer

    pNode - node in database of domain name to write

Return Value:

    Ptr to next byte in packet buffer.

--*/
{
    INT labelLength;    // bytes in current label

    ASSERT( pNode != NULL );

    //
    //  traverse back up database, writing complete domain name
    //

    do
    {
        ASSERT( pNode->cchLabelLength <= 63 );

        labelLength = pNode->cchLabelLength;

        //
        //  check length
        //      - must handle BYTE length field + length
        //

        if ( pch + labelLength + 1 > pchStop )
        {
            DNS_DEBUG( WRITE, (
                "Truncation writing node (%p) name to message.\n",
                pNode ));
            return( NULL );
        }

        //
        //  write this node's label
        //      - length byte
        //      - return if at root
        //      - otherwise copy label itself
        //

        *pch++ = (UCHAR) labelLength;

        if ( labelLength == 0 )
        {
            return( pch );
        }

        RtlCopyMemory(
            pch,
            pNode->szLabel,
            labelLength
            );
        pch += labelLength;

        //  get parent node

        pNode = pNode->pParent;
    }
    while ( pNode != NULL );

    //
    //  database error, root not properly identified
    //

    DNS_PRINT((
        "ERROR:  writing name to packet.  Bad root name.\n" ));

    ASSERT( FALSE );
    return( NULL );
}



PCHAR
FASTCALL
Name_PlaceNodeLabelInPacket(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PDB_NODE        pNode,
    IN      WORD            wCompressedDomain
    )
/*++

Routine Description:

    Write domain label to packet.

Arguments:

    pch - location to write name

    pchStop - ptr to byte after packet buffer

    pNode - node in database of domain name to write

    wCompressedDomain - compressed domain name

Return Value:

    Ptr to next byte in packet buffer.

--*/
{
    INT labelLength;     // bytes in current label
    INT writtenCount;         // count bytes written

    //
    //  check length
    //

    ASSERT( pNode->cchLabelLength <= 63 );

    labelLength = pNode->cchLabelLength;

    ASSERT( pNode->cchLabelLength > 0 );

    //
    //  check length
    //      - must handle BYTE for length + length + WORD compressed domain
    //

    if ( pch + sizeof(BYTE) + labelLength + sizeof(WORD) > pchStop )
    {
        return( NULL );
    }

    //
    //  this node's label
    //      - length byte
    //      - copy label
    //

    *pch = (UCHAR) labelLength;
    pch++;

    RtlCopyMemory(
        pch,
        pNode->szLabel,
        labelLength );

    pch += labelLength;

    //
    //  write compressed domain name
    //

    * (UNALIGNED WORD *) pch = htons( (WORD)((WORD)0xC000 | wCompressedDomain) );

    return( pch + sizeof(WORD) );
}



PCHAR
FASTCALL
Name_PlaceNodeNameInPacketWithCompressedZone(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PDB_NODE        pNode,
    IN      WORD            wZoneOffset,
    IN      PDB_NODE        pNodeZoneRoot
    )
/*++

Routine Description:

    Write domain name to packet, with compression for zone name.

Arguments:

    pch - location to write name

    pchStop - ptr to byte after packet buffer

    pNode - node in database of domain name to write

    wZoneOffset - offset in packet to compressed zone name

    pNodeZoneRoot - zone root node

Return Value:

    Ptr to next byte in packet buffer.

--*/
{
    INT labelLength;        // bytes in current label
    INT writtenCount = 0;   // count bytes written

    //
    //  traverse back up database, writing domain name
    //      - go through at least once, writing current label
    //

    while ( pNode != pNodeZoneRoot )
    {
        ASSERT( pNode->cchLabelLength <= 63 );

        labelLength = pNode->cchLabelLength;

        //
        //  check length
        //      - must handle BYTE length field + length
        //

        if ( pch + labelLength + sizeof(BYTE) > pchStop )
        {
            return( NULL );
        }

        //
        //  write this node's label
        //      - length byte
        //      - break if at root
        //      - otherwise copy label itself
        //

        *pch = (UCHAR) labelLength;
        pch++;

        if ( labelLength == 0 )
        {
            pNode = NULL;
            break;
        }

        RtlCopyMemory(
            pch,
            pNode->szLabel,
            labelLength );

        pch += labelLength;

        //
        //  get parent node
        //

        pNode = pNode->pParent;
        ASSERT( pNode );
    }

    //
    //  write zone compressed label
    //      - if didn't write all the way to root

    if ( pNode )
    {
        if ( pch + sizeof(WORD) > pchStop )
        {
            return( NULL );
        }
        *(UNALIGNED WORD *)pch = htons( (WORD)((WORD)0xC000 | wZoneOffset) );
        pch += sizeof(WORD);
    }
    return( pch );
}



//
//  Lookup name to packet
//

PCHAR
FASTCALL
Name_PlaceLookupNameInPacket(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PLOOKUP_NAME    pLookupName,
    IN      BOOL            fSkipFirstLabel
    )
/*++

Routine Description:

    Write lookup name to packet.

Arguments:

    pch - location to write name

    pchStop - ptr to byte after packet buffer

    pLookupName -- lookup name to put in packet

    fSkipFirstLabel - flag, TRUE to avoid writing first label;
        used to add domain name (as scope) to WINS lookups

Return Value:

    Number of bytes written.
    Zero on length error.

--*/
{
    INT cchLabel;           // bytes in current label
    INT i;                  // label index
    INT iStart;             // starting name label index

    ASSERT( pch != NULL );
    ASSERT( pLookupName != NULL );
    ASSERT( pLookupName->cchNameLength <= DNS_MAX_NAME_LENGTH );

    //
    //  skip first label?
    //      special case for WINS lookups where domain name used as scope
    //

    iStart = 0;
    if (fSkipFirstLabel )
    {
        iStart = 1;
    }

    //
    //  loop until end of lookup name
    //

    for ( i = iStart;
            i < pLookupName->cLabelCount;
                i++ )
    {
        cchLabel = pLookupName->cchLabelArray[i];

        ASSERT( cchLabel > DNS_MAX_LABEL_LENGTH );

        if ( pch + cchLabel + 1 > pchStop )
        {
            DNS_DEBUG( ANY, ( "Lookupname too long for available packet length.\n" ));
            return( NULL );
        }

        //  write label count

        *pch = (UCHAR) cchLabel;
        pch++;

        //  write label

        RtlCopyMemory(
            pch,
            pLookupName->pchLabelArray[i],
            cchLabel );

        pch += cchLabel;
    }

    //  NULL terminate
    //      - name terminates with zero label count
    //      - packet has space to allow safe write of this byte
    //          without test

    *pch++ = 0;

    return( pch );
}




#if 0
//
//  On second thought name sig idea is goofy --
//  doesn't pay for itself.
//
//  DEVNOTE: So if it's goofy, can we remove this code completely?
//
//  Name signature routines.
//
//  Better signature.
//      Before doing better sig want to nail down pNode
//      downcasing issue so making sig not arduous
//

DWORD
FASTCALL
makeSignatureOnBuffer(
    IN      PCHAR           pchRawName,
    IN      PCHAR           pchNameEnd
    )
/*++

Routine Description:

    Make signature.

    Utility to do final signature writing common to both
    node and raw name signature routines below.

Arguments:

    pchRawName -- ptr to name to make signature for, in buffer
        that can be overwritten

    pchNameEnd -- end of name in buffer, ptr to byte that should
        be terminating NULL, however NULL need not be written
        as this routine writes it here as part of terminating pad

Return Value:

    Signature for name.

--*/
{
    PCHAR       pch;
    DWORD       signature;

    //
    //  signature
    //
    //  name in net format
    //  downcase
    //  sum as DWORD (padding with NULL on last bits)
    //

    //  NULL terminate and pad DWORD
    //
    //  do not need four bytes, as pchNameEnd is not included in the
    //  sig if it is DWORD aligned -- it's zero adds no value to sig

    pch = (PCHAR) pchNameEnd;
    *pch++ = 0;
    *pch++ = 0;
    *pch++ = 0;

    //  downcase
    //      - can skip if know string already cannonical

    _strlwr( pchRawName );

    //  sum into DWORD

    pch = pchRawName;
    signature = 0;

    while ( pch < pchNameEnd )
    {
        signature += *(PDWORD) pch;
        pch += sizeof(DWORD);
    }

    return( signature );
}



DWORD
FASTCALL
Name_MakeNodeNameSignature(
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Make name signature for node.

Arguments:

    pNode -- node to make signature for

Return Value:

    Signature for name of node.

--*/
{
    PDB_NODE    pnodeTemp = pNode;
    PUCHAR      pch;
    UCHAR       labelLength;
    DWORD       signature;
    CHAR        buffer[ DNS_MAX_NAME_LENGTH+50 ];

    ASSERT( pnodeTemp != NULL );

    //
    //  if already have sig -- we're done
    //

    if ( pnodeTemp->dwSignature )
    {
        return( pnodeTemp->dwSignature );
    }

    //
    //  signature
    //
    //  copy name -- in net format to buffer
    //  downcase
    //  sum as DWORD (padding with NULL on last bits)
    //

    pch = buffer;

    while ( pnodeTemp->pParent )
    {
        labelLength = pnodeTemp->cchLabelLength;
        *pch++ = labelLength;
        RtlCopyMemory(
            pch,
            pnodeTemp->szLabel,
            labelLength );

        pch += labelLength;

        pnodeTemp = pnodeTemp->pParent;
    }

    signature = makeSignatureOnBuffer(
                    buffer,
                    pch );

    //  save signature to node

    pNode->dwSignature = signature;

    DNS_DEBUG( WRITE, (
        "Node (%p) signature %lx\n",
        pNode,
        signature ));

    return( signature );
}



DWORD
FASTCALL
Name_MakeRawNameSignature(
    IN      PCHAR           pchRawName
    )
/*++

Routine Description:

    Make raw name signature.

Arguments:

    pchRawName -- ptr to name to make signature for

Return Value:

    Signature for name.

--*/
{
    DWORD       signature;
    DWORD       len;
    CHAR        buffer[ DNS_MAX_NAME_LENGTH+50 ];

    ASSERT( pchRawName != NULL );

    //
    //  signature
    //
    //  copy name -- in net format to buffer
    //  downcase
    //  sum as DWORD (padding with NULL on last bits)
    //

    len = strlen( pchRawName );

    RtlCopyMemory(
        buffer,
        pchRawName,
        len );

    signature = makeSignatureOnBuffer(
                    buffer,
                    buffer + len );

    DNS_DEBUG( WRITE, (
        "Raw name (%p) signature %lx\n",
        pchRawName,
        signature ));

    return( signature );
}



DWORD
FASTCALL
Name_MakeNameSignature(
    IN      PDB_NAME        pName
    )
/*++

Routine Description:

    Make name signature.

Arguments:

    pName -- name to make signature for

Return Value:

    Signature for name.

--*/
{
    return  Name_MakeRawNameSignature( pName->RawName );
}
#endif



//
//  Node name to packet writing utilities
//

BOOL
FASTCALL
Name_IsNodePacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacket,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Check if name in packet matches a given node.

Arguments:

    pMsg -- ptr to message

    pchPacket -- ptr to name in message

    pNode -- node to check if matches name

Return Value:

    TRUE if node matches name.
    FALSE if not a match.

--*/
{
    UCHAR   labelLength;

    DNS_DEBUG( WRITE, (
        "Name_IsNodePacketName( pMsg=%p, ptr=%p, pnode=%p )\n",
        pMsg,
        pchPacket,
        pNode ));

    //
    //  loop back through packet name and up through pNode
    //      - either fail a label match
    //      - or reach root, in which case have compression match
    //

    while( 1 )
    {
        //  grab label length and position pch at label
        //  if encounter offset, drop to actual packet label
        //      and recheck for offset

        while( 1 )
        {
            //  must always be looking BACK in the packet

            if ( pchPacket >= pMsg->pCurrent )
            {
                ASSERT( FALSE );
                return( FALSE );
            }

            labelLength = (UCHAR) *pchPacket++;

            if ( (labelLength & 0xC0) == 0 )
            {
                //  name not offset
                break;
            }
            pchPacket = DNSMSG_PTR_FOR_OFFSET(
                            pMsg,
                            (((WORD)(labelLength&0x3f) << 8) + *pchPacket) );
        }

        if ( pNode->cchLabelLength != labelLength )
        {
            return( FALSE );
        }
        if ( _strnicmp( pchPacket, pNode->szLabel, labelLength ) != 0 )
        {
            return( FALSE );
        }

        //  move to parent node, and continue check

        pNode = pNode->pParent;
        if ( pNode->pParent )
        {
            pchPacket += labelLength;
            continue;
        }

        //  at root node

        break;
    }

    //  at root node
    //      - if packet name at root -- success
    //      - if not -- no match

    ASSERT( pNode->cchLabelLength == 0 );

    return( *pchPacket == 0 );
}



BOOL
FASTCALL
Name_IsRawNamePacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacket,
    IN      PCHAR           pchRawName
    )
/*++

Routine Description:

    Check if name in packet matches a given node.

Arguments:

    pMsg -- ptr to message

    pchPacket -- ptr to name in message

    pchRawName -- ptr to name in raw wire format

Return Value:

    TRUE if node matches name.
    FALSE if not a match.

--*/
{
    UCHAR   labelLength;

    DNS_DEBUG( WRITE, (
        "Name_IsRawNamePacketName( pMsg=%p, ptr=%p, pchRaw=%p )\n",
        pMsg,
        pchPacket,
        pchRawName ));

    //
    //  loop back through packet name and up through pRawName
    //      - either fail a label match
    //      - or reach root, in which case have compression match
    //

    while( 1 )
    {
        //  grab label length and position pch at label
        //  if encounter offset, drop to actual packet label
        //      and recheck for offset

        while( 1 )
        {
            //  protect against out-of-packet access
            //  note:  unlike node checking routine above, can't use pCurrent
            //      as when writing SOA names, may legitimately be checking the
            //      the first name when writing the second

            if ( pchPacket >= pMsg->pBufferEnd )
            {
                ASSERT( FALSE );
                return( FALSE );
            }

            labelLength = *pchPacket++;

            if ( (labelLength & 0xC0) == 0 )
            {
                //  name not offset
                break;
            }
            pchPacket = DNSMSG_PTR_FOR_OFFSET(
                            pMsg,
                            (((WORD)(labelLength&0x3f) << 8) + (UCHAR)*pchPacket) );
        }

        if ( *pchRawName++ != labelLength )
        {
            return( FALSE );
        }

        //  at root -- success
        //      - with test here, we've already verified both at root label

        if ( labelLength == 0 )
        {
            return( TRUE );
        }

        if ( _strnicmp( pchPacket, pchRawName, labelLength ) != 0 )
        {
            return( FALSE );
        }

        //  move to next label, and continue check

        pchRawName += labelLength;
        pchPacket += labelLength;
    }

    ASSERT( FALSE );        // unreachable
}



PCHAR
FASTCALL
Name_PlaceNodeNameInPacketEx(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN OUT  PCHAR           pch,
    IN      PDB_NODE        pNode,
    IN      BOOL            fUseCompression
    )
/*++

Routine Description:

    Write domain name to packet.

Arguments:

    pch - location to write name

    cAvailLength - available length remaining in packet

    pnodeTemp - node in database of domain name to write

Return Value:

    Number of bytes written.
    Zero on length error.

--*/
{
    PDB_NODE    pnodeCheck = pNode;
    INT         labelLength;     // bytes in current label
    INT         i;
    INT         compressCount;
    PDB_NODE *  compressNode;
    PWORD       compressOffset;
    PUCHAR      compressDepth;


    ASSERT( pnodeCheck != NULL );

    //
    //  same as previous node?
    //
    //  this is very frequent case -- special casing here allows
    //  us to throw out code to track this in higher level functions;
    //
    //  implementation note:  it is easier to insure that previous node
    //  is available by having special entry in compression blob, than to
    //  handle in compression array;  (last entry doesn't work, if you want
    //  compression for higher nodes in tree corresponding to a name);
    //  it is also more efficient as we avoid going through array, or even
    //  intializing array lookup
    //

    if ( pMsg->Compression.pLastNode == pNode )
    {
        *(UNALIGNED WORD *)pch = htons( (WORD)((WORD)0xC000
                                            | pMsg->Compression.wLastOffset) );
        pch += sizeof(WORD);

        DNS_DEBUG( WRITE2, (
            "Wrote same-as-previous node (%p) to message %p.\n"
            "\toriginal offset %04x;  compression at %04x\n",
            pNode,
            pMsg,
            pMsg->Compression.wLastOffset,
            pch - sizeof(WORD) ));
        return( pch );
    }

    //
    //  grab compression struct from message
    //

    compressCount   = pMsg->Compression.cCount;
    compressNode    = pMsg->Compression.pNodeArray;
    compressOffset  = pMsg->Compression.wOffsetArray;
    compressDepth   = pMsg->Compression.chDepthArray;

    //  can not be writing first RR and have existing compression list

    ASSERT( pch != pMsg->MessageBody || compressCount == 0 );

    //
    //  traverse back up database, writing complete domain name
    //

    while( 1 )
    {
        //
        //  break from loop when reach root
        //      no need to check or save compression of root
        //

        labelLength = pnodeCheck->cchLabelLength;
        if ( labelLength == 0 )
        {
            ASSERT( !pnodeCheck->pParent );
            *pch++ = 0;      // length byte
            break;
        }

        //
        //  use compression if this node already in packet
        //

        if ( fUseCompression )
        {
            //  check for direct node match
            //      - start check with nodes written before call to function

            i = pMsg->Compression.cCount;

            while( i-- )
            {
                if ( compressNode[i] == pnodeCheck )
                {
                    goto UseCompression;
                }
            }

            //
            //  check all other offsets
            //      - ignore one's with nodes
            //      - first match name depth
            //      - then attempt to match packet name
            //

            i = pMsg->Compression.cCount;

            while( i-- )
            {
                if ( compressNode[i] )
                {
                    continue;
                }
                if ( compressDepth[i] != pnodeCheck->cLabelCount )
                {
                    continue;
                }
                if ( ! Name_IsNodePacketName(
                        pMsg,
                        DNSMSG_PTR_FOR_OFFSET( pMsg, compressOffset[i] ),
                        pnodeCheck ) )
                {
                    continue;
                }

                //  matched name
                goto UseCompression;
            }
        }

        //
        //  check length
        //      - must handle BYTE length field + length
        //

        ASSERT( labelLength <= 63 );

        if ( pch + labelLength + sizeof(BYTE) > pMsg->pBufferEnd )
        {
            DNS_DEBUG( WRITE, (
                "Truncation writing node (%p) name to message.\n",
                pnodeCheck ));
            return( NULL );
        }

        //
        //  save compression for node
        //
        //  DEVNOTE: should have flag to compress ONLY the top node
        //      (as in SOA fields for IXFR) rather than every node
        //      in name
        //
        //  DEVNOTE: also way to compress ONLY domain names -- i.e.
        //      everything BELOW given node
        //      this will be useful during XFR to compress domains but
        //      not individual nodes
        //

        if ( !pMsg->fNoCompressionWrite &&
            compressCount < MAX_COMPRESSION_COUNT )
        {
            compressOffset[compressCount]   = (WORD)DNSMSG_OFFSET(pMsg, pch);
            compressNode[compressCount]     = pnodeCheck;
            compressDepth[compressCount]    = pnodeCheck->cLabelCount;
            compressCount++;
        }

        //
        //  always save last node written
        //  this is the high percentage case (of compressable nodes)
        //      see comment above
        //

        if ( pnodeCheck == pNode )
        {
            pMsg->Compression.pLastNode = pnodeCheck;
            pMsg->Compression.wLastOffset = DNSMSG_OFFSET(pMsg, pch);
        }

        //
        //  write the name
        //      - length
        //      - label
        //      - position current pointer after name
        //

        *pch++ = (UCHAR) labelLength;

        RtlCopyMemory(
            pch,
            pnodeCheck->szLabel,
            labelLength );

        pch += labelLength;

        //
        //  get parent node
        //      - should always have parent as root node kicks us out above
        //

        pnodeCheck = pnodeCheck->pParent;
        ASSERT( pnodeCheck );
    }

    goto Done;


UseCompression:

    //
    //  use existing compression
    //      - verify compressing to PREVIOUS name in packet
    //      - write compression, reset packet ptr
    //

    ASSERT( DNSMSG_OFFSET(pMsg, pch) > (INT)compressOffset[i] );

    *(UNALIGNED WORD *)pch = htons( (WORD)((WORD)0xC000
                                        | compressOffset[i]) );
    pch += sizeof(WORD);

    //  if no node associated with offset -- add it
    //  this speeds reuse of names written by packet RR data;
    //  overwrite,  because if different node exists, better
    //  to have most recent anyway, as another RR write may
    //  immediately follow

    compressNode[i] = pnodeCheck;


Done:

    //  save new compression count to packet

    pMsg->Compression.cCount = compressCount;

    IF_DEBUG( WRITE2 )
    {
        Dbg_Compression( "Compression after writing node:\n", pMsg );
    }
    return( pch );
}



PCHAR
Name_WriteCountNameToPacketEx(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pch,
    IN      PCOUNT_NAME     pName,
    IN      BOOL            fUseCompression
    )
/*++

Routine Description:

    Writes packet name to counted name format.

    Note similarity to routine above.  Only differences are
    name vs. node as sig\label source, and lack of storage
    or "last node" reference.  If changes required here, check
    above routine also.

Arguments:

    pMsg        - ptr to message

    pch         - postion in message to write name

    pName       - dbase name to write

    fUseCompression - TRUE if compression allowed

Return Value:

    Ptr to next position in buffer, if successful.
    NULL on error (truncation).

--*/
{
    PUCHAR      pchlabel;
    INT         labelLength;     // bytes in current label
    UCHAR       labelCount;
    INT         i;
    DWORD       signature;
    INT         compressCount;
    PDB_NODE *  compressNode;
    PWORD       compressOffset;
    PUCHAR      compressDepth;


    ASSERT( pName != NULL );

    //
    //  neither using or saving compression?
    //      => flat write
    //

    if ( !fUseCompression && !pMsg->fNoCompressionWrite )
    {
        PCHAR   pchafterName;

        pchafterName = pch + pName->Length;
        if ( pchafterName > pMsg->pBufferEnd )
        {
            DNS_DEBUG( WRITE, (
                "Truncation writing name (%s) name to message.\n",
                pName ));
            return( NULL );
        }

        RtlCopyMemory(
            pch,
            pName->RawName,
            pName->Length );

        return( pchafterName );
    }

    //
    //  grab compression struct from message
    //

    compressCount   = pMsg->Compression.cCount;
    compressNode    = pMsg->Compression.pNodeArray;
    compressOffset  = pMsg->Compression.wOffsetArray;
    compressDepth   = pMsg->Compression.chDepthArray;

    //  can not be writing first RR and have existing compression list

    ASSERT( pch != pMsg->MessageBody || compressCount == 0 );


    //
    //  traverse back through name a label at a time
    //      - check for compression (if desired)
    //      - write label
    //      - save compression (if desired)
    //

    pchlabel = pName->RawName;
    labelCount = pName->LabelCount;

    while( 1 )
    {
        //
        //  break from loop when reach root
        //      no need to check or save compression of root
        //

        labelLength = (UCHAR) *pchlabel;
        if ( labelLength == 0 )
        {
            *pch++ = 0;      // length byte
            goto Done;
        }

        //
        //  use compression if this node already in packet
        //

        if ( fUseCompression )
        {
            //
            //  check for matching name in compress list
            //      - start check with nodes written before call to function
            //      - check name depth first
            //      - then full name compare
            //

            i = pMsg->Compression.cCount;

            while( i-- )
            {
                if ( compressDepth[i] != labelCount )
                {
                    continue;
                }
                if ( ! Name_IsRawNamePacketName(
                        pMsg,
                        DNSMSG_PTR_FOR_OFFSET( pMsg, compressOffset[i] ),
                        pchlabel ) )
                {
                    continue;
                }

                //  matched name
                goto UseCompression;
            }
        }

        //
        //  check length
        //      - must handle BYTE length field + length
        //

        ASSERT( labelLength <= 63 );

        if ( pch + labelLength + sizeof(BYTE) > pMsg->pBufferEnd )
        {
            DNS_DEBUG( WRITE, (
                "Truncation writing name (%p) to message (%p).\n",
                pName,
                pMsg ));
            return( NULL );
        }

        //
        //  save compression for name
        //
        //  DEVNOTE:  should have flag to compress ONLY the top node
        //      (as in SOA fields for IXFR) rather than every node
        //      in name
        //
        //  DEVNOTE:  also way to compress ONLY domain names -- i.e.
        //      everything BELOW given node
        //      this will be useful during XFR to compress domains but
        //      not individual nodes
        //

        if ( !pMsg->fNoCompressionWrite &&
            compressCount < MAX_COMPRESSION_COUNT )
        {
            compressOffset[compressCount]   = (WORD)DNSMSG_OFFSET(pMsg, pch);
            compressNode[compressCount]     = NULL;
            compressDepth[compressCount]    = labelCount;
            compressCount++;
        }

        //
        //  write the label
        //      - length
        //      - label
        //      - position current pointer after name
        //      - position label pointer at next label
        //

        *pch++ = (UCHAR) labelLength;
        pchlabel++;

        RtlCopyMemory(
            pch,
            pchlabel,
            labelLength );

        pch += labelLength;
        pchlabel += labelLength;

        //  drop label count -- need to compare next label

        labelCount--;
        ASSERT( labelCount >= 0 );
    }

    //  unreachable
    ASSERT( FALSE );


UseCompression:

    //
    //  use existing compression
    //      - verify compressing to PREVIOUS name in packet
    //      - write compression, reset packet ptr
    //

    ASSERT( DNSMSG_OFFSET(pMsg, pch) > (INT)compressOffset[i] );

    *(UNALIGNED WORD *)pch = htons( (WORD)((WORD)0xC000
                                        | compressOffset[i]) );
    pch += sizeof(WORD);


Done:

    //  save new compression count to packet

    pMsg->Compression.cCount = compressCount;

    IF_DEBUG( WRITE2 )
    {
        Dbg_Compression( "Compression after writing name:\n", pMsg );
    }
    return( pch );
}



//
//  Compression utilities
//

VOID
Name_SaveCompressionForLookupName(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN OUT  PLOOKUP_NAME    pLookname,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Save lookup name (for question), to packet.

Arguments:

    pch - location to write name

    pLookname - lookup name for question

    pNode - node for lookup name

Return Value:

    None

--*/
{
    INT         ilabel;
    INT         compressCount;
    UCHAR       labelCount;
    PDB_NODE *  compressNode;
    PWORD       compressOffset;
    PUCHAR      compressDepth;

    ASSERT( pNode != NULL );

    IF_DEBUG( READ )
    {
        Dbg_Compression( "Enter Name_SaveLookupNameCompression():\n", pMsg );
    }

    //
    //  grab compression struct from message
    //

    compressCount   = pMsg->Compression.cCount;
    compressNode    = pMsg->Compression.pNodeArray;
    compressOffset  = pMsg->Compression.wOffsetArray;
    compressDepth   = pMsg->Compression.chDepthArray;

    //
    //  traverse back up database, saving complete domain name
    //

    ilabel = 0;
    labelCount = (UCHAR) pLookname->cLabelCount;

    while ( labelCount )
    {
        ASSERT( pNode );
        ASSERT( (PBYTE)DNS_HEADER_PTR(pMsg) < (pLookname->pchLabelArray[ilabel]) );
        ASSERT( (PBYTE)pMsg->pBufferEnd > (pLookname->pchLabelArray[ilabel]) );

        if ( compressCount >= MAX_COMPRESSION_COUNT )
        {
            Dbg_LookupName(
                "WARNING:  Unable to write compressionn for lookup name",
                pLookname );
            DNS_PRINT((
                "WARNING:  Unable to write compressionn for lookup name"
                "\tcurrent compression count = %d.\n"
                "\tstarting compression count = %d\n",
                compressCount,
                pMsg->Compression.cCount ));
            return;
        }

        //
        //  save compression for this node
        //      - note offset is to one byte less than label ptr to account
        //        for count byte
        //

        compressNode[compressCount] = pNode;
        compressOffset[compressCount] = (WORD)
                DNSMSG_OFFSET( pMsg, (pLookname->pchLabelArray[ilabel] - 1) );
        compressDepth[compressCount] = labelCount--;

        pMsg->Compression.cCount = ++compressCount;

        ilabel++;

        //  get parent node
        //      - should always have parent as root node kicks us out above

        pNode = pNode->pParent;
        ASSERT( pNode );
    }

    //  one leaving should be at root node, which is NOT in lookup name
    //  and which we do not save

    ASSERT( pNode && !pNode->pParent );

    IF_DEBUG( READ )
    {
        Dbg_Compression( "Lookup name compression saved:\n", pMsg );
    }
}



VOID
FASTCALL
Name_SaveCompressionWithNode(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacketName,
    IN      PDB_NODE        pNode       OPTIONAL
    )
/*++

Routine Description:

    Save compression at a node.

    Currently using this routine in reset function, so
    pNode for question may not exist.

Arguments:

    pMsg -- ptr to message

    pchPacketName -- name in packet

    pNode -- node corresponding to packet name

Return Value:

    None

--*/
{
    DWORD   i;
    UCHAR   labelCount;

    ASSERT( pchPacketName );

    //  if compression list full, save node as last ptr as
    //      last node is most commonly compressed name

    i = pMsg->Compression.cCount;
    if ( i >= MAX_COMPRESSION_COUNT )
    {
        ASSERT( i == MAX_COMPRESSION_COUNT );
        i--;
    }

    pMsg->Compression.pNodeArray[i] = pNode;
    pMsg->Compression.wOffsetArray[i] = (WORD) DNSMSG_OFFSET( pMsg, pchPacketName );

    //  name's label count
    //      - if no node, zero
    //
    //  DEVNOTE:  get label count if offset, but no name given
    //      only use of this routine in that manner is on packet reset

    labelCount = 0;
    if ( pNode )
    {
        labelCount = pNode->cLabelCount;
    }
    pMsg->Compression.chDepthArray[i] = labelCount;
    pMsg->Compression.cCount = ++i;

    DNS_DEBUG( DATABASE, (
        "Saving compression to node at %p, offset %x\n",
        pNode,
        (WORD) DNSMSG_OFFSET( pMsg, pchPacketName )
        ));
}



PDB_NODE
FASTCALL
Name_CheckCompressionForPacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacketName
    )
/*++

Routine Description:

    Check name for previously retrieved node in compression table.

Arguments:

    pMsg -- ptr to message

    pchPacketName -- name in packet

Return Value:

    Ptr to node matching packet name -- if found.
    NULL otherwise.

--*/
{
    PDB_NODE    pnode;
    WORD        offset;
    DWORD       i;

    offset = FlipUnalignedWord( pchPacketName );
    if ( (offset & 0xC000) == 0xC000 )
    {
        offset &= 0x4fff;

        //  matching "LastNode"?
        //      - only valid when pLastNode exists

        if ( offset == pMsg->Compression.wLastOffset &&
            pMsg->Compression.pLastNode )
        {
            return( pMsg->Compression.pLastNode );
        }

        //  match any node in compression list

        i = pMsg->Compression.cCount;

        while ( i-- )
        {
            if ( offset == pMsg->Compression.wOffsetArray[i] &&
                (pnode = pMsg->Compression.pNodeArray[i]) )
            {
                return( pnode );
            }
        }
    }
    return( NULL );
}



#if DBG
VOID
Dbg_Compression(
    IN      LPSTR           pszHeader,
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Debug print compression info.

Arguments:

Return Value:

    None

--*/
{
    DWORD       i;
    PDB_NODE    pnode;

    DnsDebugLock();

    if ( pszHeader )
    {
        DnsPrintf( pszHeader );
    }
    DnsPrintf(
        "Compression for packet at %p.\n"
        "\tcount = %d.\n",
        pMsg,
        pMsg->Compression.cCount );

    //
    //  print compression list
    //

    for( i=0;  i < pMsg->Compression.cCount;  i++ )
    {
        pnode = pMsg->Compression.pNodeArray[i];

        DNS_PRINT((
            "\t[%2d] Offset %04x, Depth %d, Node %p (%s)\n",
            i,
            pMsg->Compression.wOffsetArray[i],
            pMsg->Compression.chDepthArray[i],
            pnode,
            pnode ? pnode->szLabel : NULL
            ));
    }

    DnsDebugUnlock();
}

#endif  // DBG



//
//  Reverse lookup node utility
//

BOOL
Name_GetIpAddressForReverseNode(
    IN      PDB_NODE        pNodeReverse,
    OUT     PIP_ADDRESS     pipAddress,
    OUT     PIP_ADDRESS     pipReverseMask OPTIONAL
    )
/*++

Routine Description:

    Build IP address for reverse lookup node.

Arguments:

    pNodeReverse -- node in reverse lookup domain

    pipReverseMask -- addr to write mask for IP address;  this is a mask of
        bits that are significant in the address, useful for reverse lookup
        domain nodes, which will not contain complete IP address

Return Value:

    IP address of reverse lookup node.  For nodes which do not correspond to
        complete address, remaining bits will be zero.
    INADDR_BROADCAST if error.

--*/
{
    PDB_NODE    pnodeLastWrite; // last node written
    IP_ADDRESS  ip = 0;
    IP_ADDRESS  mask = 0;
    ULONG       octet;
    BOOL        retBool = TRUE;

    ASSERT( pNodeReverse != NULL );

    DNS_DEBUG( LOOKUP2, ( "Getting IP for reverse lookup node.\n" ));

    //
    //  verify in reverse lookup domain
    //
    //  note, this verifies at in-addr.arpa or below, special case arpa itself
    //

    if ( ! Dbase_IsNodeInReverseLookupDomain(
                pNodeReverse,
                DATABASE_FOR_CLASS(DNS_RCLASS_INTERNET) ) )
    {
        if ( pNodeReverse == DATABASE_ARPA_NODE )
        {
            goto Done;
        }
        return( FALSE );
    }

    //
    //  write back through nodes until hit in-addr.arpa domain.
    //

    pnodeLastWrite = DATABASE_REVERSE_NODE;

    while( pNodeReverse != pnodeLastWrite )
    {
        //  current ip and mask shift down, write node label to high octet

        mask >>= 8;
        mask |= 0xff000000;

        octet = strtoul( pNodeReverse->szLabel, NULL, 10 );

        if ( octet > 0xff )
        {
            DNS_PRINT((
                "Invalid node label %s in reverse lookup zone!\n",
                pNodeReverse->szLabel ));

            ASSERT( FALSE );
            return( FALSE );
        }
        ip >>= 8;
        ip |= octet << 24;

        //  get parent

        pNodeReverse = pNodeReverse->pParent;
    }

    //
    //  write address and mask, if desired
    //

Done:
    *pipAddress = ip;
    if ( pipReverseMask )
    {
        *pipReverseMask = mask;
    }
    return( retBool );
}



//
//  RPC buffer writing utilities
//

PCHAR
FASTCALL
Name_PlaceNodeNameInBuffer(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PDB_NODE        pNode,
    IN      PDB_NODE        pNodeStop
    )
/*++

Routine Description:

    Write domain name to buffer.

    Note this routine writes a terminating NULL.  Calling routines may eliminate
    it for purposes of creating counted character strings.

Arguments:

    pchBuf - location to write name

    pchBufStop - buffers stop byte (byte after buffer)

    pNode - node in database of domain name to write

    pNodeStop - node to stop writing at;
        OPTIONAL, if not given or not ancestor of pNode then FQDN is
        written to buffer

Return Value:

    Ptr to next byte in buffer where writing would resume
        (i.e. ptr to the terminating NULL)

--*/
{
    PCHAR   pch;
    INT     labelLength;     // bytes in current label

    pch = pchBuf;

    //  minimum length is "." or "@" and terminating NULL

    if ( pch + 1 >= pchBufEnd )
    {
        DNS_DEBUG(ANY, ("Invalid buffer in Name_PlaceNodeNameInBuffer()\n"
                        "\tpch = %p\n\tpchBufEnd = %p\n",
                        pch, pchBufEnd));

        ASSERT(FALSE);
        return( NULL );
    }

    //
    //  traverse back up database, writing complete domain name
    //

    do
    {
        //  break from loop if reach stop node
        //      - remove terminating dot since this is relative name
        //      - if writing stop node (zone root) itself, write '@'

        if ( pNode == pNodeStop )
        {
            if ( pch > pchBuf )
            {
                --pch;
                ASSERT( *pch == '.' );
                break;
            }
            else
            {
                ASSERT( pNodeStop );
                *pch++ = '@';
                break;
            }
        }

        //  check length rr
        //      - must handle length and a BYTE for "."

        labelLength = pNode->cchLabelLength;
        ASSERT( labelLength <= 63 );

        if ( pch + labelLength + 1 > pchBufEnd )
        {
            DNS_DEBUG(ANY, ("Node full name exceeds limit:\n"
                            "\tpch = %p; labelLength = %d; pchBufEnd = %p\n"
                            "\tpNode = %p; pNodeStop = %p\n",
                            pch, labelLength, pchBufEnd, pNode, pNodeStop));
            return( NULL );
        }

        //  break from loop when reach root
        //      - but write "." standalone root

        if ( labelLength == 0 )
        {
            if ( pch == pchBuf )
            {
                *pch++ = '.';
            }
            break;
        }

        //  write the node label
        //  write separating dot

        RtlCopyMemory(
            pch,
            pNode->szLabel,
            labelLength );

        pch += labelLength;
        *pch++ = '.';

        //  move up to parent node
    }
    while ( pNode = pNode->pParent );

    //  root should break loop, not pNode = NULL

    ASSERT( pNode );

    //  write a terminating NULL

    *pch = 0;

    DNS_DEBUG( OFF, (
        "Wrote name %s (len=%d) into buffer at postion %p.\n",
        pchBuf,
        pch - pchBuf,
        pchBuf ));

    return( pch );
}



PCHAR
FASTCALL
Name_PlaceFullNodeNameInRpcBuffer(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Write domain name to RPC buffer.

Arguments:

    pch - location to write name

    pchStop - ptr to byte after RPC buffer

    pNode - node in database of domain name to write

Return Value:

    Ptr to next byte in buffer.
    NULL if out of buffer.  Sets last error to ERROR_MORE_DATA.

--*/
{
    PCHAR   pchstart;       // starting position
    INT     labelLength;    // bytes in current label

    //  first byte contains total name length, skip it

    pchstart = pch;
    pch++;

    //
    //  write full node name to buffer
    //

    pch = Name_PlaceNodeNameInBuffer(
                pch,
                pchStop,
                pNode,
                NULL    // FQDN
                );
    if ( !pch )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }
    ASSERT( pch <= pchStop );

    //
    //  write name length byte
    //      - do NOT count terminating NULL
    //

    ASSERT( *pch == 0 );
    ASSERT( (pch - pchstart - 1) <= MAXUCHAR );

    *pchstart = (CHAR)(UCHAR)(pch - pchstart - 1);

    return( pch );
}



PCHAR
FASTCALL
Name_PlaceNodeLabelInRpcBuffer(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Write domain node label to RPC buffer.

Arguments:

    pch - location to write name

    pchStop - ptr to byte after RPC buffer

    pNode - node in database of domain name to write

Return Value:

    Ptr to next byte in buffer.
    NULL if out of buffer.  Sets last error to ERROR_MORE_DATA.

--*/
{
    PCHAR   pchstart;           // starting position
    INT     labelLength;     // bytes in current label


    DNS_DEBUG( RPC2, ( "Name_PlaceNodeLabelInBuffer.\n" ));

    //
    //  first byte will contain name length, skip it
    //

    pchstart = pch;
    pch++;

    //
    //  writing node's label
    //

    labelLength = pNode->cchLabelLength;
    ASSERT( labelLength <= 63 );

    //
    //  check length
    //      - length byte, label length, terminating NULL
    //

    if ( pch + labelLength + 2 > pchStop )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }

    //
    //  write the name, NULL terminated
    //

    RtlCopyMemory(
        pch,
        pNode->szLabel,
        labelLength );

    pch += labelLength;
    *pch = 0;

    //
    //  write name length byte
    //  do NOT include terminating NULL
    //

    ASSERT( (pch - pchstart - 1) <= MAXUCHAR );
    *pchstart = (CHAR)(UCHAR)(pch - pchstart - 1);

    DNS_DEBUG( RPC2, (
        "Wrote name %s (len=%d) into buffer at postion %p.\n",
        pchstart + 1,
        *pchstart,
        pchstart ));

    return( pch );
}



//
//  File name\string read\write utilies.
//
//  These routines handle the name conversion issues relating to
//  writing names and strings in flat ANSI files
//      -- special file characters
//      -- quoted string
//      -- character quotes for special characters and unprintable chars
//
//  The character to char properties table allows simple mapping of
//  a character to its properties saving us a bunch of compare\branch
//  instructions in parsing file names\strings.
//
//  See nameutil.h for specific properties.
//

WORD    DnsFileCharPropertyTable[] =
{
    //  control chars 0-31 must be octal in all circumstances
    //  end-of-line and tab characters are special

    FC_NULL,                // zero special on read, some RPC strings NULL terminated

    FC_OCTAL,   FC_OCTAL,   FC_OCTAL,   FC_OCTAL,
    FC_OCTAL,   FC_OCTAL,   FC_OCTAL,   FC_OCTAL,

    FC_TAB,                 // tab
    FC_NEWLINE,             // line feed
    FC_OCTAL,
    FC_OCTAL,
    FC_RETURN,              // carriage return
    FC_OCTAL,
    FC_OCTAL,

    FC_OCTAL,   FC_OCTAL,   FC_OCTAL,   FC_OCTAL,
    FC_OCTAL,   FC_OCTAL,   FC_OCTAL,   FC_OCTAL,
    FC_OCTAL,   FC_OCTAL,   FC_OCTAL,   FC_OCTAL,
    FC_OCTAL,   FC_OCTAL,   FC_OCTAL,   FC_OCTAL,

    FC_BLANK,               // blank, special char but needs octal quote

    FC_NON_RFC,             // !
    FC_QUOTE,               // " always must be quoted
    FC_NON_RFC,             // #
    FC_NON_RFC,             // $
    FC_NON_RFC,             // %
    FC_NON_RFC,             // &
    FC_NON_RFC,             // '

    FC_SPECIAL,             // ( datafile line extension
    FC_SPECIAL,             // ) datafile line extension
    FC_NON_RFC,             // *
    FC_NON_RFC,             // +
    FC_NON_RFC,             // ,
    FC_RFC,                 // - RFC for hostname
    FC_DOT,                 // . must quote in names
    FC_NON_RFC,             // /

    // 0 - 9 RFC for hostname

    FC_NUMBER,  FC_NUMBER,  FC_NUMBER,  FC_NUMBER,
    FC_NUMBER,  FC_NUMBER,  FC_NUMBER,  FC_NUMBER,
    FC_NUMBER,  FC_NUMBER,

    FC_NON_RFC,             // :
    FC_SPECIAL,             // ;  datafile comment
    FC_NON_RFC,             // <
    FC_NON_RFC,             // =
    FC_NON_RFC,             // >
    FC_NON_RFC,             // ?
    FC_NON_RFC,             // @

    // A - Z RFC for hostname

    FC_UPPER,   FC_UPPER,   FC_UPPER,   FC_UPPER,
    FC_UPPER,   FC_UPPER,   FC_UPPER,   FC_UPPER,
    FC_UPPER,   FC_UPPER,   FC_UPPER,   FC_UPPER,
    FC_UPPER,   FC_UPPER,   FC_UPPER,   FC_UPPER,
    FC_UPPER,   FC_UPPER,   FC_UPPER,   FC_UPPER,
    FC_UPPER,   FC_UPPER,   FC_UPPER,   FC_UPPER,
    FC_UPPER,   FC_UPPER,

    FC_NON_RFC,             // [
    FC_SLASH,               // \ always must be quoted
    FC_NON_RFC,             // ]
    FC_NON_RFC,             // ^
    FC_NON_RFC,             // _
    FC_NON_RFC,             // `

    // a - z RFC for hostname

    FC_LOWER,   FC_LOWER,   FC_LOWER,   FC_LOWER,
    FC_LOWER,   FC_LOWER,   FC_LOWER,   FC_LOWER,
    FC_LOWER,   FC_LOWER,   FC_LOWER,   FC_LOWER,
    FC_LOWER,   FC_LOWER,   FC_LOWER,   FC_LOWER,
    FC_LOWER,   FC_LOWER,   FC_LOWER,   FC_LOWER,
    FC_LOWER,   FC_LOWER,   FC_LOWER,   FC_LOWER,
    FC_LOWER,   FC_LOWER,

    FC_NON_RFC,             // {
    FC_NON_RFC,             // |
    FC_NON_RFC,             // }
    FC_NON_RFC,             // ~
    FC_OCTAL,               // 0x7f DEL code

    // high chars
    //
    // DEVNOTE: could either be considered printable or octal

    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,

    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,

    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,

    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH,
    FC_HIGH,    FC_HIGH,    FC_HIGH,    FC_HIGH
};



VOID
Name_VerifyValidFileCharPropertyTable(
    VOID
    )
/*++

Routine Description:

    Verify haven't broken lookup table.

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT( DnsFileCharPropertyTable[0]       == FC_NULL      );
    ASSERT( DnsFileCharPropertyTable['\t']    == FC_TAB       );
    ASSERT( DnsFileCharPropertyTable['\n']    == FC_NEWLINE   );
    ASSERT( DnsFileCharPropertyTable['\r']    == FC_RETURN    );
    ASSERT( DnsFileCharPropertyTable[' ']     == FC_BLANK     );
    ASSERT( DnsFileCharPropertyTable['"']     == FC_QUOTE     );
    ASSERT( DnsFileCharPropertyTable['(']     == FC_SPECIAL   );
    ASSERT( DnsFileCharPropertyTable[')']     == FC_SPECIAL   );
    ASSERT( DnsFileCharPropertyTable['-']     == FC_RFC       );
    ASSERT( DnsFileCharPropertyTable['.']     == FC_DOT       );
    ASSERT( DnsFileCharPropertyTable['0']     == FC_NUMBER    );
    ASSERT( DnsFileCharPropertyTable['9']     == FC_NUMBER    );
    ASSERT( DnsFileCharPropertyTable[';']     == FC_SPECIAL   );
    ASSERT( DnsFileCharPropertyTable['A']     == FC_UPPER     );
    ASSERT( DnsFileCharPropertyTable['Z']     == FC_UPPER     );
    ASSERT( DnsFileCharPropertyTable['\\']    == FC_SLASH     );
    ASSERT( DnsFileCharPropertyTable['a']     == FC_RFC       );
    ASSERT( DnsFileCharPropertyTable['z']     == FC_RFC       );
    ASSERT( DnsFileCharPropertyTable[0x7f]    == FC_OCTAL     );
    ASSERT( DnsFileCharPropertyTable[0xff]    == FC_OCTAL     );
};



//
//  File writing utilities
//

PCHAR
FASTCALL
File_PlaceStringInFileBuffer(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      DWORD           dwFlag,
    IN      PCHAR           pchString,
    IN      DWORD           dwStringLength
    )
/*++

Routine Description:

    Write string to file

Arguments:

    pchBuf      - location to write name

    pchBufStop  - buffers stop byte (byte after buffer)

    dwFlag      - flag for type of string write
        FILE_WRITE_NAME_LABEL
        FILE_WRITE_QUOTED_STRING
        FILE_WRITE_DOTTED_NAME
        FILE_WRITE_FILE_NAME

    pchString   - string to write

    dwStringLength - string length

Return Value:

    Ptr to next byte in buffer where writing would resume
    (i.e. ptr to the terminating NULL)
    NULL on out of space error.

    For file names, force quote if name contains a space char.

--*/
{
    PCHAR   pch;
    UCHAR   ch;
    WORD    charType;
    WORD    octalMask;
    WORD    quoteMask;
    WORD    mask;
    BOOL    fForceQuote = FALSE;

    pch = pchBuf;

    //
    //  check buffer length
    //  to avoid a bunch of code, just verify we're ok even with
    //  maximum expansion of all characters ( 4 times, character to octal <\ddd> )
    //

    if ( pch + 4*dwStringLength + 1 >= pchBufEnd )
    {
        return( NULL );
    }

    //
    //  name label
    //      - must quote special chars (ex ();)
    //

    if ( dwFlag == FILE_WRITE_NAME_LABEL )
    {
        octalMask = B_PRINT_TOKEN_OCTAL;
        quoteMask = B_PRINT_TOKEN_QUOTED;
    }

    //
    //  quoted string -- all printable characters (except quoting slash) write
    //

    else if ( dwFlag == FILE_WRITE_QUOTED_STRING )
    {
        octalMask = B_PRINT_STRING_OCTAL;
        quoteMask = B_PRINT_STRING_QUOTED;
        *pch++ = QUOTE_CHAR;
    }

    //
    //  zone and file names in boot file
    //      - unlike name, must print "." directly (not-quoted)
    //      - same octals as in string
    //      - but no quoting of printable characters
    //          this avoids problem of quoting "\" which is valid in file names
    //
    //  note:  obviously these are NOT completely identical to string
    //      in that other special chars (ex.();) are not appropriate
    //      however, this is ONLY for ASCII file write so other chars
    //      should not appear in zone or file names
    //

    else
    {
        ASSERT( dwFlag == FILE_WRITE_FILE_NAME || dwFlag == FILE_WRITE_DOTTED_NAME );

        //
        //  Force quote of file name if it contains a space char.
        //

        if ( dwFlag == FILE_WRITE_FILE_NAME &&
            memchr( pchString, ' ', dwStringLength ) )
        {
            fForceQuote = TRUE;
            *pch++ = QUOTE_CHAR;
        }

        octalMask = B_PRINT_STRING_OCTAL;
        quoteMask = 0;
    }

    mask = octalMask | quoteMask;

    //
    //  check each character, expand where special handling required
    //

    while ( dwStringLength-- )
    {
        ch = (UCHAR) *pchString++;

        charType = DnsFileCharPropertyTable[ ch ];

        //  handle the 99% case first
        //  hopefully minimizing instructions

        if ( ! (charType & mask ) )
        {
            *pch++ = ch;
            continue;
        }

        //  character needs quoting, but is printable

        else if ( charType & quoteMask )
        {
            *pch++ = SLASH_CHAR;
            *pch++ = ch;
            continue;
        }

        //  character not printable (at least in this context), needs octal quote

        else
        {
            ASSERT( charType & octalMask );
            pch += sprintf( pch, "\\%03o", ch );
            continue;
        }
    }

    //  terminate
    //      - quote if quoted string
    //      - NULL on final character for simplicity, string always ready to write

    if ( dwFlag == FILE_WRITE_QUOTED_STRING || fForceQuote )
    {
        *pch++ = QUOTE_CHAR;
    }

    ASSERT( pch < pchBufEnd );
    *pch = 0;

    return( pch );
}



PCHAR
FASTCALL
File_PlaceNodeNameInFileBuffer(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PDB_NODE        pNode,
    IN      PDB_NODE        pNodeStop
    )
/*++

Routine Description:

    Write domain name to buffer.

    Note this routine writes a terminating NULL.  Calling routines may eliminate
    it for purposes of creating counted character strings.

Arguments:

    pchBuf - location to write name

    pchBufStop - buffers stop byte (byte after buffer)

    pNode - node in database of domain name to write

    pNodeStop - node to stop writing at;
        OPTIONAL, if not given or not ancestor of pNode then FQDN is
        written to buffer

Return Value:

    Ptr to next byte in buffer where writing would resume
        (i.e. ptr to the terminating NULL)

--*/
{
    PCHAR   pch;
    INT     labelLength;     // bytes in current label

    pch = pchBuf;

    //  minimum length is "." or "@" and terminating NULL

    if ( pch + 1 >= pchBufEnd )
    {
        return( NULL );
    }

    //
    //  traverse back up database, writing complete domain name
    //

    do
    {
        //  break from loop if reach stop node
        //      - remove terminating dot since this is relative name
        //      - if writing stop node (zone root) itself, write '@'

        if ( pNode == pNodeStop )
        {
            if ( pch > pchBuf )
            {
                --pch;
                ASSERT( *pch == '.' );
                break;
            }
            else
            {
                ASSERT( pNodeStop );
                *pch++ = '@';
                break;
            }
        }

        //  check length rr
        //      - must handle length and a BYTE for "."

        labelLength = pNode->cchLabelLength;
        ASSERT( labelLength <= 63 );

        if ( pch + labelLength + 1 > pchBufEnd )
        {
            return( NULL );
        }

        //  break from loop when reach root
        //      - but write "." standalone root

        if ( labelLength == 0 )
        {
            if ( pch == pchBuf )
            {
                *pch++ = '.';
            }
            break;
        }

        //  write the node label
        //  write separating dot

        pch = File_PlaceStringInFileBuffer(
                pch,
                pchBufEnd,
                FILE_WRITE_NAME_LABEL,
                pNode->szLabel,
                labelLength );
        if ( !pch )
        {
            return( NULL );
        }
        *pch++ = '.';

        //  move up to parent node
    }
    while ( pNode = pNode->pParent );

    //  root should break loop, not pNode = NULL

    ASSERT( pNode );

    //  write a terminating NULL

    *pch = 0;

    DNS_DEBUG( OFF, (
        "Wrote file name %s (len=%d) into buffer at postion %p.\n",
        pchBuf,
        pch - pchBuf,
        pchBuf ));

    return( pch );
}



PCHAR
File_WriteRawNameToFileBuffer(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PRAW_NAME       pName,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write raw name to buffer in file format.

    Note this routine writes a terminating NULL.  Calling routines may eliminate
    it for purposes of creating counted character strings.

Arguments:

    pchBuf - location to write name

    pchBufStop - buffers stop byte (byte after buffer)

    pNode - node in database of domain name to write

    pZone - OPTIONAL, if given name writing stops at zone name

Return Value:

    Ptr to next byte in buffer where writing would resume
        (i.e. ptr to the terminating NULL)

--*/
{
    PCHAR   pch;
    INT     labelLength;     // bytes in current label

    pch = pchBuf;

    //  minimum length is "." or "@" and terminating NULL

    if ( pch + 1 >= pchBufEnd )
    {
        return( NULL );
    }

    //
    //  traverse labels in name until
    //      - reach end (FQDN)
    //      - or reach zone root
    //

    while( 1 )
    {
        labelLength = *pName;

        ASSERT( labelLength <= DNS_MAX_LABEL_LENGTH );

        //
        //  break from loop when reach root
        //      - but write "." standalone root

        if ( labelLength == 0 )
        {
            break;
        }

#if 0
        //
        //  DEVNOTE: for efficiency, check if at zone name and if so
        //              terminate
        //
        //  at zone name check?
        //      - can check count of labels
        //      - remaining length
        //      - or just check
        //

        if ( zoneLabelCount == labelLength )
        {
            Name_CompareRawNames(
                pName,
                pZone->pCountName.RawName );
        }
#endif

        //  write the node label
        //  write separating dot if already wrote previous label

        if ( pch > pchBuf )
        {
            *pch++ = '.';
        }

        pch = File_PlaceStringInFileBuffer(
                pch,
                pchBufEnd,
                FILE_WRITE_NAME_LABEL,
                ++pName,
                labelLength );
        if ( !pch )
        {
            return( NULL );
        }

        pName += labelLength;
    }

    //  write a terminating NULL

    *pch++ = '.';
    *pch = 0;

    DNS_DEBUG( OFF, (
        "Wrote file name %s (len=%d) into buffer at postion %p.\n",
        pchBuf,
        pch - pchBuf,
        pchBuf ));

    return( pch );
}



//
//  File reading utilites
//

PCHAR
extractQuotedChar(
    OUT     PCHAR           pchResult,
    IN      PCHAR           pchIn,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Writes value of quoted char to buffer.

Arguments:

    pchResult   - result buffer

    pchIn       - text to copy

    pchEnd      - end of test

Return Value:

    Ptr to next position in incoming buffer.

--*/
{
    CHAR        ch;
    UCHAR       octalNumber = 0;
    DWORD       countOctal = 0;

    //
    //  protect against writing past end of buffer
    //
    //  two cases:
    //      \<char>             -- value is char
    //      \<octal number>     -- octal value
    //      octal number up to three digits long
    //

    while ( pchIn <= pchEnd )
    {
        ch = *pchIn++;
        if ( ch < '0' || ch > '7' )
        {
            if ( countOctal == 0 )
            {
                goto Done;
            }
            pchIn--;
            break;
        }
        octalNumber <<= 3;
        octalNumber += (ch - '0');
        DNS_DEBUG( LOOKUP2, (
            "Ch = %c;  Octal = %d\n",
            ch, octalNumber ));
        if ( ++countOctal == 3 )
        {
            break;
        }
    }

    ch = (CHAR)octalNumber;

Done:
    *pchResult++ = ch;

    //  return ptr to next input character

    DNS_DEBUG( LOOKUP2, (
        "Quote result %c (%d)\n",
        ch, ch ));

    return( pchIn );
}



PCHAR
File_CopyFileTextData(
    OUT     PCHAR           pchBuffer,
    IN      DWORD           cchBufferLength,
    IN      PCHAR           pchText,
    IN      DWORD           cchLength,          OPTIONAL
    IN      BOOL            fWriteLengthChar
    )
/*++

Routine Description:

    Copies text data into TXT record data form, converting quoted characters.
    
    Jan 2001: This routine has been generalized to decode any string that
    might contain octal escaped characters. At some point in the future this
    function should be renamed for clarity.

Arguments:

    pchResult - result buffer

    cchBufferLength - total usable length of result buffer

    pchText - text to copy

    cchLength - number of chars in text; if zero then pchText is assumed
        to be NULL terminated

    fWriteLengthChar - if TRUE, output buffer will start with single byte
        length character, if FALSE output buffer will be NULL-terminated
        string

Return Value:

    Ptr to next position in result buffer.
    NULL on error.

--*/
{
    PCHAR       pch;
    CHAR        ch;
    PCHAR       pchend;         //  ptr to end of name
    PCHAR       pchoutEnd;      //  ptr to end out output buffer
    PCHAR       presult;
    UCHAR       octalNumber;
    DWORD       countOctal;
    DNS_STATUS  status;

    ASSERT( pchBuffer && cchBufferLength );

    DNS_DEBUG( LOOKUP2, (
        "Building Text data element for \"%.*s\"\n",
        cchLength,
        pchText ));

    //
    //  setup start and end ptrs and verify length
    //

    pch = pchText;
    if ( !cchLength )
    {
        cchLength = strlen( pch );
    }
    ASSERT( cchBufferLength >= cchLength );
    pchend = pch + cchLength;
    pchoutEnd = pchBuffer + cchBufferLength;
    if ( !fWriteLengthChar )
    {
        --pchoutEnd;        //  Save room for terminating NULL.
    }

    //
    //  result buffer, leave space for count character
    //

    presult = pchBuffer;
    if ( fWriteLengthChar )
    {
        presult++;
    }

    //
    //  Loop until end of name
    //

    while ( pch < pchend )
    {
        if ( presult >= pchoutEnd )
        {
            return NULL;
        }
        ch = *pch++;

        //  not quoted, party on

        if ( ch != SLASH_CHAR )
        {
            *presult++ = ch;
            continue;
        }

        //
        //  quoted character
        //      - single quote just get next char
        //      - octal quote read up to three octal characters
        //

        else if ( ch == SLASH_CHAR )
        {
            pch = extractQuotedChar(
                    presult++,
                    pch,
                    pchend );
        }
    }

    //  set count char count

    if ( fWriteLengthChar )
    {
        ASSERT( (presult - pchBuffer - 1) <= MAXUCHAR );
        *(PUCHAR)pchBuffer = (UCHAR)(presult - pchBuffer - 1);
    }
    else
    {
        *presult = '\0';    //  NULL terminate
    }

    return presult;
}



DNS_STATUS
Name_ConvertFileNameToCountName(
    OUT     PCOUNT_NAME     pCountName,
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength     OPTIONAL
    )
/*++

Routine Description:

    Converts file name to counted name format.

    Note, this is currently the general dotted-to-dbase name
    translation routine.  It should be noted that quoted characters
    will be translated to filename specifications.

Arguments:

    pCountName  - count name buffer

    pchName     - name to convert, given in human readable (dotted) form.

    cchNameLength - number of chars in dotted name, if zero then
            pchName is assumed to be NULL terminated

Return Value:

    DNS_STATUS_FQDN             -- if name is FQDN
    DNS_STATUS_DOTTED_NAME      -- for non-FQDN
    DNS_ERROR_INVALID_NAME      -- if name invalid

--*/
{
    PCHAR       pch;
    UCHAR       ch;
    PCHAR       pchstartLabel;           // ptr to start of label
    PCHAR       pchend;             // ptr to end of name
    PCHAR       presult;
    PCHAR       presultLabel;
    PCHAR       presultMax;
    WORD        charType = 0;
    WORD        maskNoCopy;
    WORD        maskDowncase;
    DNS_STATUS  status;
    INT         labelLength;        // length of current label
    UCHAR       labelCount = 0;


    DNS_DEBUG( LOOKUP, (
        "Building count name for \"%.*s\"\n",
        cchNameLength ? cchNameLength : DNS_MAX_NAME_LENGTH,
        pchName
        ));

    //
    //  NULL name
    //

    if ( !pchName )
    {
        ASSERT( cchNameLength == 0 );
        pCountName->Length = 0;
        pCountName->LabelCount = 0;
        pCountName->RawName[0] = 0;
        return( ERROR_SUCCESS );
    }

    //
    //  result buffer, leave space for label
    //

    presultLabel = presult = pCountName->RawName;
    presultMax = presult + DNS_MAX_NAME_LENGTH;
    presult++;

    //
    //  Character selection mask
    //      '\' slash quote
    //      '.' dot label separator are special chars
    //      upper case must be downcased
    //      everything else is copied dumb copy
    //

    maskNoCopy = B_PARSE_NAME_MASK | B_UPPER;
    maskDowncase = B_UPPER;

    //
    //  setup start and end ptrs and verify length
    //

    pchstartLabel = pch = pchName;
    if ( !cchNameLength )
    {
        cchNameLength = strlen( pch );
    }
    pchend = pch + cchNameLength;

    //
    //  Loop until end of name
    //
    //
    //  DEVNOTE:  standard form of DNS names (UTF8 case considerations)
    //      should convert to standard form handling all casing
    //      right here
    //

    while ( 1 )
    {
        //  check for input termination
        //      - setup as dummy label terminator, but ch==0, signals no terminating dot
        //
        //  otherwise get next character

        if ( pch >= pchend )
        {
            ch = 0;
            charType = FC_NULL;
        }
        else
        {
            ch = (UCHAR) *pch++;
            charType = DnsFileCharPropertyTable[ ch ];
        }

        DNS_DEBUG( PARSE2, (
            "Converting ch=%d <%c>.\n"
            "\tcharType = %d\n",
            ch, ch,
            charType ));

        //
        //  DEVNOTE:  detect UTF8 extension chars, and downcase at end
        //
        //      probably best approach is handle regular case, and just
        //      detect high octal, then do full down-casing of utf8
        //      alternatively could catch here, and do char processing
        //      in loop (build UTF8 char -- convert when done, write downcased
        //      UTF8
        //

        //  handle RFC printable characters (the 99% case) first

        if ( ! (charType & maskNoCopy) )
        {
            //  if name exceeds DNS name max => invalid

            if ( presult >= presultMax )
            {
                goto InvalidName;
            }
            *presult++ = ch;
            continue;
        }

        //  downcase upper case
        //      do this here so RR data fields can be compared by simple
        //      memcmp, rather than requiring type specific comparison routines

        if ( charType & maskDowncase )
        {
            //  if name exceeds DNS name max => invalid

            if ( presult >= presultMax )
            {
                goto InvalidName;
            }
            *presult++ = DOWNCASE_ASCII(ch);
            continue;
        }

        //
        //  label terminator
        //      - set length of previous label
        //      - save ptr to this next label
        //      - check for name termination
        //

        if ( charType & B_DOT )
        {
            //  verify label length

            labelLength = (int)(presult - presultLabel - 1);

            if ( labelLength > DNS_MAX_LABEL_LENGTH )
            {
                DNS_DEBUG( LOOKUP, (
                    "Label exceeds 63 byte limit:  %.*s\n",
                    pchend - pchName,
                    pchstartLabel ));
                goto InvalidName;
            }

            //  set label count in result name

            *presultLabel = (CHAR)labelLength;
            presultLabel = presult++;

            //
            //  termination
            //      ex: "microsoft.com."
            //      ex: "microsoft.com"
            //      ex: "."
            //
            //  if no explicit dot termination, then just wrote previous label
            //      => write 0 label
            //  otherwise already wrote 0 label
            //      => done
            //
            //  ch value preserves final character to make relative \ FQDN distinction
            //
            //  note: RPC does send NULL terminated strings with length that includes
            //      the NULL;  however, they will still terminate here as
            //

            if ( pch >= pchend )
            {
                if ( labelLength != 0 )
                {
                    labelCount++;
                    *presultLabel = 0;
                    break;
                }

                //
                //  root (".") name
                //  dec presult, so correct length (1) is written for name
                //      we already wrote zero length label above
                //
                //  note:  RPC can also generate this situation when it includes
                //      NULL termination in length of name
                //      ex.  <8>jamesg.<0>
                //  in this case also, we won't terminate until processing the <0>,
                //  and when we do we'll have already written the zero label above
                //

                presult--;
                ASSERT( (presult == pCountName->RawName + 1)  ||  ch == 0 );
                break;
            }

            //  set up for next label

            if ( labelLength != 0 )
            {
                labelCount++;
                continue;
            }

            //
            //  catch bogus entries
            //      ex:  ".blah"
            //      ex:  "foo..bar"
            //      ex:  "more.."
            //      ex:  ".."
            //
            //  only root domain name, should have label that started
            //      with DOT, and it must immediately terminate
            //

            ASSERT( ch == DOT_CHAR  &&  pch <= pchend );

            DNS_DEBUG( LOOKUP, ( "Bogus double--dot label.\n" ));
            goto InvalidName;
        }

        //  quoted character
        //      - single quote just get next char
        //      - octal quote read up to three octal characters

        else if ( ch == SLASH_CHAR )
        {
            pch = extractQuotedChar(
                    presult++,
                    pch,
                    pchend );
        }

        ELSE_ASSERT_FALSE;
    }

    //
    //  termination
    //  separate status for two cases:
    //      - no trailing dot case (ex: "microsoft.com")
    //      - FQDN
    //

    if ( ch == 0 )
    {
        status = DNS_STATUS_DOTTED_NAME;
    }
    else
    {
        status = DNS_STATUS_FQDN;
    }

    //
    //  DEVNOTE:  standard form of DNS names (UTF8 case considerations)
    //
    //      should convert to standard form handling all casing
    //      right here
    //


    //
    //  set counted name length
    //

    ASSERT( presult > pCountName->RawName );
    ASSERT( *(presult-1) == 0 );

    pCountName->Length = (UCHAR)(presult - pCountName->RawName);
    pCountName->LabelCount = labelCount;

    IF_DEBUG( LOOKUP )
    {
        DnsDbg_Lock();
        Dbg_CountName(
            "Counted name for file name ",
            pCountName,
            NULL );
        DnsPrintf(
            "\tfor file name %.*s"
            "\tName is %s name\n",
            cchNameLength,
            pchName,
            (status == DNS_STATUS_DOTTED_NAME) ? "relative" : "FQDN"
            );
        DnsDbg_Unlock();
    }
    return( status );


InvalidName:

    DNS_DEBUG( LOOKUP, (
        "Failed to create lookup name for %.*s\n",
        cchNameLength,
        pchName
        ));
#if 0
    //  since this routine is general dotted-to-dbase translator,
    //  it should not log error;  this is left to higher level
    //  routines to determine in which cases logging adds value
    {
        //
        //  copy name to NULL terminate for logging
        //

        CHAR    szName[ DNS_MAX_NAME_LENGTH+1 ];
        PCHAR   pszName = szName;

        if ( cchNameLength > DNS_MAX_NAME_LENGTH )
        {
            cchNameLength = DNS_MAX_NAME_LENGTH;
        }
        RtlCopyMemory(
            szName,
            pchName,
            cchNameLength
            );
        szName[ cchNameLength ] = 0;

        DNS_LOG_EVENT(
            DNS_EVENT_INVALID_DOTTED_DOMAIN_NAME,
            1,
            &pszName,
            EVENTARG_ALL_UTF8,
            0 );
    }
#endif

    return( DNS_ERROR_INVALID_NAME );
}



//
//  Wire name
//

PCHAR
Wire_SkipPacketName(
    IN      PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchPacketName
    )
/*++

Routine Description:

    Skips over transport name.

Arguments:

    pchPacketName - ptr to start of name to skip

Return Value:

    Ptr to next
    NULL if no more names

--*/
{
    pchPacketName = Dns_SkipPacketName(
                        pchPacketName,
                        DNSMSG_END( pMsg )
                        );
    if ( !pchPacketName )
    {
        PVOID parg = (PVOID) (ULONG_PTR) pMsg->RemoteAddress.sin_addr.s_addr;

        DNS_LOG_EVENT(
            DNS_EVENT_INVALID_PACKET_DOMAIN_NAME,
            1,
            & parg,
            EVENTARG_ALL_IP_ADDRESS,
            0 );
    }
    return( pchPacketName );
}

//
//  End nameutil.c
//


#if 0
DNS_STATUS
convertFileNameToLookupName(
    OUT     PCOUNT_NAME     pCountName,
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength,    OPTIONAL
    OUT     PLOOKUP_NAME    pLookupName,
    )
/*++

Routine Description:

    Converts file name to lookup name format.

    Note:  this code if based on dotted name to lookup name code in
        lookname.c.  This function handles issue of quoted characters.

Arguments:

    pchName - name to convert, given in human readable (dotted) form.

    cchNameLength - number of chars in dotted name, if zero then
            pchName is assumed to be NULL terminated

    pLookupName - lookup name buffer

Return Value:

    DNS_STATUS_FQDN             -- if name is FQDN
    DNS_STATUS_DOTTED_NAME      -- for non-FQDN
    DNS_ERROR_INVALID_NAME      -- if name invalid

--*/
{
    PCHAR   pch;
    UCHAR   ch;
    PCHAR   pchstart;           // ptr to start of label
    PCHAR   pchend;             // ptr to end of name
    PCHAR   presult;
    PCHAR   presultLabel;
    WORD    charType;
    WORD    maskForSpecialChars;
    UCHAR   octalNumber;
    DWORD   countOctal;
    DNS_STATUS  status;

    PCHAR * pointers;           // ptr into lookup name pointer array
    UCHAR * lengths;            // ptr into lookup name length array
    INT     labelCount = 0;     // count of labels
    INT     labelLength;        // length of current label
    INT     cchtotal = 0;       // total length of name

    IF_DEBUG( LOOKUP2 )
    {
        if ( cchNameLength )
        {
            DNS_PRINT((
                "Creating lookup name for \"%.*s\"\n",
                cchNameLength,
                pchName
                ));
        }
        else
        {
            DNS_PRINT((
                "Creating lookup name for \"%s\"\n",
                pchName
                ));
        }
    }

    //
    //  setup count name
    //

    presult = pCountName->pRawName;

    //
    //  Setup ptrs to walk through lookup name
    //

    if ( pLookupName )
    {
        pointers = pLookupName->pchLabelArray;
        lengths  = pLookupName->cchLabelArray;
    }

    //
    //  Character selection mask
    //      '\' slash quote
    //      '.' dot label separator are special chars
    //      everything else is copied dumb copy
    //

    maskForSpecialChars = B_PARSE_NAME_MASK;

    //
    //  Setup start and end ptrs and verify length
    //

    pch = pchName;
    pchstart = pch;
    if ( !cchNameLength )
    {
        cchNameLength = strlen( pch );
    }

    if ( cchNameLength >= DNS_MAX_NAME_LENGTH )
    {
        //  note length can be valid at max length if dot terminated

        if ( cchNameLength > DNS_MAX_NAME_LENGTH
                ||
            pch[cchNameLength-1] != '.' )
        {
            goto InvalidName;
        }
    }

    pchend = pch + cchNameLength;
    pch = pchstart;

    //
    //  result buffer, leave space for label
    //

    presult = presultLabel = pResultName;
    presult++;

    //
    //  Loop until end of name
    //

    while ( 1 )
    {
        if ( pch >= pchend )
        {
            ch = 0;
            charType = FC_DOT;
        }
        else
        {
            ch = (UCHAR) *pch++;
            charType = DnsFileCharPropertyTable[ ch ];
        }

        //  handle the 99% case first
        //  hopefully minimizing instructions

        if ( ! (charType & maskForSpecialChars) )
        {
            *presult++ = ch;
            continue;
        }

        //
        //  label terminator
        //      - set length of previous label
        //      - save ptr to this next label
        //      - check for name termination
        //

        if ( charType == FC_DOT )
        {
            //  verify label length

            labelLength = presult - presultLabel - 1;

            if ( labelLength > DNS_MAX_LABEL_LENGTH )
            {
                IF_DEBUG( LOOKUP )
                {
                    DNS_PRINT((
                        "Label exceeds 63 byte limit:  %.*s\n",
                        pchend - pchstart,
                        pchstart ));
                }
                goto InvalidName;
            }

            //
            //  test for termination, trailing dot case
            //      ex: "microsoft.com."
            //      ex: "."
            //
            //  zero label length will catch both
            //      - label starting at terminating NULL,
            //      - standalone "." for root domain
            //

            if ( labelLength == 0 )
            {
                //
                //  catch bogus entries
                //      ex:  ".blah"
                //      ex:  "blah.."
                //      ex:  "foo..bar"
                //      ex:  ".."
                //
                //  only root domain name, should have label that started
                //      with DOT, and it must immediately terminate
                //

                if ( ch == DOT_CHAR
                        &&
                     ( labelCount != 0  ||  ++pch < pchend ) )
                {
                    IF_DEBUG( LOOKUP )
                    {
                        DNS_PRINT((
                            "Bogus label:  %.*s\n",
                            pchend - pchstart,
                            pchstart ));
                    }
                    goto InvalidName;
                }
                break;
            }

            //  set label count in result name

            *presultLabel++ = labelLength;

            //  lookup name

            *pointers++ = presultLabel;
            *lengths++ = (UCHAR) labelLength;
            labelCount++;

            cchtotal += labelLength;
            cchtotal++;

            //
            //  if more labels, continue
            //      - reset result ptrs for next label

            if ( pch < pchend )
            {
                presultLabel = presult++;
                continue;
            }

            //
            //  termination
            //  separate status for two cases:
            //      - no trailing dot case (ex: "microsoft.com")
            //      - FQDN
            //

            *presult = 0;
            if ( ch == 0 )
            {
                status = DNS_STATUS_DOTTED_NAME;
                break;
            }
            else
            {
                status = DNS_STATUS_FQDN;
                break;
            }
        }

        //  quoted character
        //      - single quote just get next char
        //      - octal quote read up to three octal characters

        else if ( ch == SLASH_CHAR )
        {
            pch = extractQuotedChar(
                    presult++,
                    pch,
                    pchend );
        }

        ELSE_ASSERT_FALSE;
    }

    //
    //  set counts in lookup name
    //      - total length is one more than sum of label counts and
    //          lengths to allow for 0 termination
    //

    pLookupName->cLabelCount = labelCount;
    pLookupName->cchNameLength = cchtotal + 1;

    ASSERT( pLookupName->cchNameLength <= DNS_MAX_NAME_LENGTH );

    IF_DEBUG( LOOKUP2 )
    {
        DNS_PRINT((
            "Lookup name for %.*s",
            cchNameLength,
            pchName
            ));
        Dbg_LookupName(
            "",
            pLookupName
            );
    }
    return( status );


InvalidName:

    IF_DEBUG( LOOKUP )
    {
        DNS_PRINT((
            "Failed to create lookup name for %.*s ",
            cchNameLength,
            pchName
            ));
    }
    {
        //
        //  copy name to NULL terminate for logging
        //

        CHAR    szName[ DNS_MAX_NAME_LENGTH+1 ];
        PCHAR   pszName = szName;

        if ( cchNameLength > DNS_MAX_NAME_LENGTH )
        {
            cchNameLength = DNS_MAX_NAME_LENGTH;
        }
        RtlCopyMemory(
            szName,
            pchName,
            cchNameLength
            );
        szName[ cchNameLength ] = 0;

        DNS_LOG_EVENT(
            DNS_EVENT_INVALID_DOTTED_DOMAIN_NAME,
            1,
            &pszName,
            EVENTARG_ALL_UTF8,
            0 );
    }
    return( DNS_ERROR_INVALID_NAME );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\nbstat.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    nbstat.c

Abstract:

    Domain Name System (DNS) Server

    Reverse lookups using netBIOS node status.

Author:

    Jim Gilroy (jamesg)         October, 1995

    Borrowed NBT lookup code from David Treadwell's NT winsock.

Revision History:

--*/


#include "dnssrv.h"

//#include "winsockp.h"
#include <nbtioctl.h>
#include <nb30.h>
#include <nspapi.h>
#include <svcguid.h>
//#include "nspmisc.h"


//
//  NBT IOCTL reponse structures
//

typedef struct _DNS_NBT_INFO
{
    IO_STATUS_BLOCK     IoStatus;
    tIPANDNAMEINFO      IpAndNameInfo;
    CHAR                Buffer[2048];
}
DNS_NBT_INFO, *PDNS_NBT_INFO;

typedef struct
{
    ADAPTER_STATUS AdapterInfo;
    NAME_BUFFER    Names[32];
}
tADAPTERSTATUS;

//
//  NBT handles
//
//  On multihomed may have multiple NBT interfaces.  Need handle
//  to each one.
//

DWORD   cNbtInterfaceCount;
PHANDLE pahNbtHandles;

DWORD   dwInterfaceBitmask;

DWORD   dwNbtBufferLength;

//
//  Nbstat thread wait parameters
//
//  Have separate pointer to NBT events in wait array (not separate array)
//  for coding simplicity.
//

DWORD   cEventArrayCount;
PHANDLE phWaitEventArray;
PHANDLE phNbstatEventArray;

//
//  Status code for uncompleted Nbstat queries
//

#define DNS_NBT_NO_STATUS   (0xdddddddd)

//
//  Nbstat global flag
//

BOOL    g_bNbstatInitialized;

//
//  Nbstat queues
//      - public for recv() threads to queue queries to nbstat
//      - private for holding queries during lookup
//

PPACKET_QUEUE   pNbstatQueue;
PPACKET_QUEUE   pNbstatPrivateQueue;


//
//  Nbstat timeout
//

#define NBSTAT_QUERY_HARD_TIMEOUT     (15)          // fifteen seconds
#define NBSTAT_TIMEOUT_ALL_EVENTS (0xffffffff)


//
//  Private protos
//

VOID
FASTCALL
makeNbstatRequestThroughNbt(
    IN OUT  PDNS_MSGINFO    pQuery
    );

VOID
buildNbstatWaitEventArray(
    VOID
    );

VOID
processNbstatResponse(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      DWORD           iEvent
    );

VOID
sendNbstatResponse(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      LPSTR           pszResultName
    );

VOID
cleanupNbstatQuery(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      DWORD           iEvent
    );

VOID
cancelOutstandingNbstatRequests(
    VOID
    );

BOOL
openNbt(
    VOID
    );

VOID
closeNbt(
    VOID
    );

PDNS_NBT_INFO
allocateNbstatBuffer(
    VOID
    );

VOID
freeNbstatBuffer(
    IN      PDNS_NBT_INFO   pBuf
    );



BOOL
FASTCALL
Nbstat_MakeRequest(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Make NetBIOS reverse node status request.

    Called by recv() thread when NBSTAT lookup indicated for query.

Arguments:

    pQuery -- request to use nbstat lookup for

Return Value:

    TRUE -- if successfully made nbstat request
    FALSE -- if failed

--*/
{
    INT             err;
    IP_ADDRESS      ip;
    PDB_RECORD      pnbstatRR;
    NTSTATUS        status;


    ASSERT( pQuery );
    ASSERT( g_bNbstatInitialized );

    IF_DEBUG( NBSTAT )
    {
        Dbg_MessageNameEx(
            "No answer for ",
            pQuery->MessageBody,
            pQuery,
            NULL,       // default end to end of message
            " in database, doing NBSTAT lookup.\n"
            );
    }

    //
    //  get NBSTAT info for this zone
    //      - Nbstat queries ALWAYS for the zone the question name
    //      - possible NBSTAT turned off for this zone
    //

    pQuery->pzoneCurrent = pZone;
    pnbstatRR = pZone->pWinsRR;

    if ( !pnbstatRR )
    {
        DNS_PRINT(( "ERROR:  NBSTAT lookup for zone without NBSTAT RR\n" ));
        TEST_ASSERT( pZone->pWinsRR );
        return( FALSE );
    }
    ASSERT( pnbstatRR->wType == DNS_TYPE_WINSR );
    ASSERT( pnbstatRR->Data.WINSR.dwCacheTimeout );
    ASSERT( pnbstatRR->Data.WINSR.dwLookupTimeout );
    pQuery->U.Nbstat.pRR = pnbstatRR;

    //
    //  Only handle direct lookup (questions)
    //
    //  DCR:  nbstat following CNAME, but only if customer requires
    //      note, fix would require
    //          - IP write to use last name
    //          - node to be for last name
    //          - finish either to skip Send_NameError() or fix it
    //              to handle AnswerCount != 0

    if ( pQuery->Head.AnswerCount != 0 )
    {
        DNS_DEBUG( NBSTAT, (
            "NBSTAT lookup for non-question rejected\n"
            "\tpacket = %p\n",
            pQuery ));
        return( FALSE );
    }

    //
    //  For reverse lookup we send to address indicated by the DNS question
    //  name.
    //
    //  The first 4 labels of the question, are the address bytes in
    //  reverse order.
    //
    //  Example:
    //      question: (2)22(2)80(2)55(3)157(7)in-addr(4)arpa(0)
    //      then send to 157.55.80.22
    //
    //  Reject:
    //      - reverse lookups with less than four octets
    //      - queries for zero or broadcast address
    //
    //  Note:
    //  The rest of the sockaddr (family + port) so we can just
    //  copy the template and change the address.
    //
    //  Also, the netBIOS question name, is the same for all these
    //  reverse queries -- set to specify request for all names.
    //

    if ( ! Name_LookupNameToIpAddress(
                pQuery->pLooknameQuestion,
                &ip ) )
    {
        return( FALSE );
    }
    DNS_DEBUG( NBSTAT, (
        "Nbstat lookup for address %s.\n",
        IP_STRING( ip ) ));

    //
    //  Reject broadcast and zero address queries
    //
    //  Note:  automated broadcast and zero zones should screen these out.
    //

    if ( (ip == INADDR_NONE) || (ip == 0) )
    {
        DNS_PRINT(( "ERROR:  Attempted broadcast or zero address reverse lookup.\n" ));
        return( FALSE );
    }

    //
    //  Queue request to NBSTAT thread
    //

    pQuery->U.Nbstat.ipNbstat = ip;

    PQ_QueuePacketEx(
        pNbstatQueue,
        pQuery,
        FALSE );

    DNS_DEBUG( NBSTAT, (
        "Queued query at %p to NBSTAT thread using event %p.\n",
        pQuery,
        pNbstatQueue->hEvent ));

    STAT_INC( WinsStats.WinsReverseLookups );
    PERF_INC( pcWinsReverseLookupReceived );     // PerfMon hook

    return( TRUE );
}



VOID
FASTCALL
makeNbstatRequestThroughNbt(
    IN OUT  PDNS_MSGINFO    pQuery
    )
/*++

Routine Description:

    Make NetBIOS reverse node status request through NBT.

Arguments:

    pQuery -- request to use nbstat lookup for

Return Value:

    TRUE -- if successfully made nbstat request
    FALSE -- if failed

--*/
{
    INT             err;
    NTSTATUS        status;
    UINT            j;
    ULONG           SizeInput;
    PDNS_NBT_INFO   pnbtInfo;

    ASSERT( pQuery );
    ASSERT( pQuery->pzoneCurrent );
    ASSERT( pQuery->U.Nbstat.pRR );
    ASSERT( g_bNbstatInitialized );
    ASSERT( pQuery->Head.AnswerCount == 0 );


    IF_DEBUG( NBSTAT )
    {
        DNS_PRINT((
            "Making nbstat query through NBT for query at %p.\n",
            pQuery ));
    }

    //
    //  Allocate space for nbstat info
    //      - NBStat events
    //      - NBT IOCTL recieve buffer
    //

    pQuery->U.Nbstat.pNbstat = pnbtInfo = allocateNbstatBuffer();
    if ( !pnbtInfo )
    {
        DNS_PRINT(( "ERROR:  Allocating nbstat block failed.\n" ));
        goto ServerFailure;
    }
    IF_DEBUG( NBSTAT )
    {
        DNS_PRINT((
            "Setup to call nbstat for query %p.  Buffer at %p.\n",
            pQuery,
            pnbtInfo ));
    }

    //
    //  Initialize flags
    //

    pQuery->fDelete = FALSE;
    pQuery->U.Nbstat.fNbstatResponded = FALSE;
    pQuery->U.Nbstat.dwNbtInterfaceMask = 0;

    //
    //  Make the adapter status request on each NBT interface
    //

    for ( j=0; j < cNbtInterfaceCount; j++ )
    {
        tIPANDNAMEINFO * pipnameInfo = &pnbtInfo->IpAndNameInfo;
        ASSERT( pipnameInfo );

        IF_DEBUG( NBSTAT )
        {
            DNS_PRINT((
                "Making nbstat call for query %p, buffer at %p.\n",
                pQuery,
                pnbtInfo ));
        }

        //  init the address info block

        RtlZeroMemory(
            pipnameInfo,
            sizeof(tIPANDNAMEINFO) );

        pipnameInfo->IpAddress = ntohl(pQuery->U.Nbstat.ipNbstat);

        pipnameInfo->NetbiosAddress.Address[0].Address[0].NetbiosName[0] = '*';
        pipnameInfo->NetbiosAddress.TAAddressCount = 1;
        pipnameInfo->NetbiosAddress.Address[0].AddressLength
                                        = sizeof(TDI_ADDRESS_NETBIOS);
        pipnameInfo->NetbiosAddress.Address[0].AddressType
                                        = TDI_ADDRESS_TYPE_NETBIOS;
        pipnameInfo->NetbiosAddress.Address[0].Address[0].NetbiosNameType
                                        = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
        SizeInput = sizeof(tIPANDNAMEINFO);

        //
        //  init the status
        //  status code is initialize to a non-returnable value
        //  a change in this status is how we know NBT IOCTL has
        //  completed for this adapter
        //

        pnbtInfo->IoStatus.Status = DNS_NBT_NO_STATUS;

        //
        //  drop adapter status IOCTL
        //

        status = NtDeviceIoControlFile(
                     pahNbtHandles[j],
                     phNbstatEventArray[j],
                     NULL,
                     NULL,
                     & pnbtInfo->IoStatus,
                     IOCTL_NETBT_ADAPTER_STATUS,
                     pipnameInfo,
                     sizeof(tIPANDNAMEINFO),
                     pnbtInfo->Buffer,
                     sizeof(pnbtInfo->Buffer)
                     );
        if ( status != STATUS_PENDING )
        {
            pnbtInfo->IoStatus.Status = status;

            DNS_PRINT((
                "WARNING:  Nbstat NtDeviceIoControlFile status %p,\n"
                "\tnot STATUS_PENDING\n",
                status
                ));

            //  set bit to indicate this NBT interface responded
            //  if all fail, return FALSE to do SERVER_FAILURE return

            pQuery->U.Nbstat.dwNbtInterfaceMask |= (1 << j);

            if ( pQuery->U.Nbstat.dwNbtInterfaceMask == dwInterfaceBitmask )
            {
                goto ServerFailure;
            }
        }

        //  get block for next adapter

        pnbtInfo++;
    }

    DNS_DEBUG( NBSTAT, (
        "Launched NBSTAT for address %s for query at %p.\n",
        IP_STRING( pQuery->U.Nbstat.ipNbstat ),
        pQuery ));

    //
    //  put query on private nbstat queue during NBT lookup
    //  set expiration timeout based on WINS-R record for zone
    //

    pQuery->dwExpireTime = ((PDB_RECORD)pQuery->U.Nbstat.pRR)
                                    ->Data.WINSR.dwLookupTimeout;
    PQ_QueuePacketWithXid(
        pNbstatPrivateQueue,
        pQuery );
    return;

ServerFailure:

    DNS_DEBUG( ANY, (
        "ERROR:  Failed nbstat lookup for query at %p.\n",
        pQuery ));

    if ( pQuery->U.Nbstat.pNbstat )
    {
        freeNbstatBuffer( pQuery->U.Nbstat.pNbstat );
    }
    pQuery->fDelete = TRUE;
    Reject_Request(
        pQuery,
        DNS_RCODE_SERVER_FAILURE,
        0 );
    return;
}



VOID
processNbstatResponse(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      DWORD           iEvent
    )
/*++

Routine Description:

    Use NBT to do node status query, to resolve host name for IP address.

    This code is lifted directly from winsock project SockNbtResolveAddr(),
    with minor modifications to also extract netBIOS scope.

Arguments:

    pQuery -- query for which nbstat done

    iEvent -- event index which succeeded

Return Value:

    None.

--*/
{
    DWORD       i;          //  name counter
    NTSTATUS    status;
    BOOL        success = FALSE;

    PDNS_NBT_INFO   pnbtInfo;

    tADAPTERSTATUS * pAdapterStatus;
    LONG            cNameCount;             //  count of names in response
    PNAME_BUFFER    pNames;
    PNAME_BUFFER    pNameBest = NULL;       //  best name found so far
    UCHAR           ucNameType;             //  name type <00>, <20>, etc
    BOOLEAN         fFoundServer = FALSE;   //  found server byte

    CHAR            achResultName[ DNS_MAX_NAME_LENGTH ];
    DWORD           dwResultNameLength = DNS_MAX_NAME_LENGTH;


    DNS_DEBUG( NBSTAT, (
        "Nbstat response for query at %p on adapter %d.\n"
        "\tQueried address %s.\n",
        pQuery,
        iEvent,
        IP_STRING(pQuery->U.Nbstat.ipNbstat) ));

    //
    //  Set bit to indicate this NBT interface responded
    //

    i = 1;
    i <<= iEvent;
    pQuery->U.Nbstat.dwNbtInterfaceMask |= i;

    //
    //  If already sent response -- no further action needed
    //

    if ( pQuery->U.Nbstat.fNbstatResponded )
    {
        cleanupNbstatQuery( pQuery, iEvent );
        return;
    }

    //
    //  check response from this NBT adapter
    //

    pnbtInfo = &((PDNS_NBT_INFO)pQuery->U.Nbstat.pNbstat)[iEvent];

    pAdapterStatus = (tADAPTERSTATUS *)pnbtInfo->Buffer;

    if ( !NT_SUCCESS(pnbtInfo->IoStatus.Status)
            ||
        pAdapterStatus->AdapterInfo.name_count == 0 )
    {
        DNS_DEBUG( NBSTAT, (
            "Nbstat response empty or error for query at %p.\n"
            "\tiEvent = %d\n"
            "\tstatus = %p\n"
            "\tname count = %d\n",
            pQuery,
            iEvent,
            pnbtInfo->IoStatus.Status,
            pAdapterStatus->AdapterInfo.name_count ));

        //  if WAIT_TIMEOUT     in main loop, caused us to cancel
        //  then send back SERVER_FAILED when NBT completes the IRP

        if ( pnbtInfo->IoStatus.Status == STATUS_CANCELLED )
        {
            pQuery->U.Nbstat.fNbstatResponded = TRUE;
            Reject_Request( pQuery, DNS_RCODE_SERVER_FAILURE, 0 );
        }
        cleanupNbstatQuery( pQuery, iEvent );
        return;
    }

    pNames = pAdapterStatus->Names;
    cNameCount = pAdapterStatus->AdapterInfo.name_count;

    //
    //  find best name in NBT packet -- write to DNS packet
    //
    //  name priority:
    //      - workstation -- name<00>
    //      - server -- name<20>
    //      - any unique name
    //
    //  toss if no unique names
    //
    //  note:  names are given in ASCII, with blank (0x20) padding on
    //      right
    //

    while( cNameCount-- )
    {
        //  skip group names

        if ( pNames->name_flags & GROUP_NAME )
        {
            pNames++;
            continue;
        }

        //  always take WORKSTATION name
        //  SERVER name better than arbitrary unique name
        //  take any unique name if none found yet

        ucNameType = pNames->name[NCBNAMSZ-1];

        DNS_DEBUG( NBSTAT, (
            "Checking unique nbstat name %.*s<%02x>\n.",
            NCBNAMSZ-1,
            pNames->name,
            ucNameType ));

        if ( ucNameType == NETBIOS_WORKSTATION_BYTE )
        {
            pNameBest = pNames;
            break;
        }
        else if ( ucNameType == NETBIOS_SERVER_BYTE
                &&
                ! fFoundServer )
        {
            fFoundServer = TRUE;
            pNameBest = pNames;
        }
        else if ( !pNameBest )
        {
            pNameBest = pNames;
        }

        //  get next NAME_BUFFER structure

        pNames++;
    }

    //
    //  response but no unique name
    //

    if ( ! pNameBest )
    {
        DNS_DEBUG( NBSTAT, ( "Nbstat response empty or error.\n" ));
        pQuery->U.Nbstat.fNbstatResponded = TRUE;
        Send_NameError( pQuery );
        cleanupNbstatQuery( pQuery, iEvent );
        return;
    }

    //
    //  found a unique name -- use it to respond
    //  copy name until first space or end of name
    //

    for ( i = 0; i < NCBNAMSZ-1 && pNameBest->name[i] != ' '; i++ )
    {
        achResultName[i] = pNameBest->name[i];
    }

    dwResultNameLength = i;
    achResultName[i] = '\0';

    DNS_DEBUG( NBSTAT, (
        "Valid Nbstat name %s <%2x> in adpater status name list,\n"
        "\tquerying for IP address %s, from query at %p.\n",
        achResultName,
        ucNameType,
        IP_STRING(pQuery->U.Nbstat.ipNbstat),
        pQuery ));

    ASSERT( ! pQuery->fDelete );

    pQuery->U.Nbstat.fNbstatResponded = TRUE;
    sendNbstatResponse(
        pQuery,
        achResultName );

    cleanupNbstatQuery( pQuery, iEvent );
}



VOID
sendNbstatResponse(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      LPSTR           pszResultName
    )
/*++

Routine Description:

    Process NBT node status response.

Arguments:

    pQuery -- query matched to WINS response

    pszResultName -- name returned by NBT

Return Value:

    None.

--*/
{
    PDB_RECORD  prr;
    PDB_RECORD  pnbstatRR;
    PDB_NODE    pnode;
    PDB_NODE    pnodeResult;
    DNS_STATUS  status;
    DWORD       lengthResult;
    WCHAR       unicodeBuffer[ MAX_WINS_NAME_LENGTH+1 ];
    CHAR        utf8Buffer[ DNS_MAX_LABEL_LENGTH ];

    ASSERT( pQuery );
    ASSERT( pQuery->pzoneCurrent );
    ASSERT( pQuery->dwQueryTime );


    STAT_INC( WinsStats.WinsReverseResponses );
    PERF_INC( pcWinsReverseResponseSent );       // PerfMon hook

    //
    //  get zone nbstat
    //      - if now off, send name error
    //

    pnbstatRR = pQuery->pzoneCurrent->pWinsRR;
    if ( !pnbstatRR )
    {
        DNS_DEBUG( ANY, (
            "WARNING:  WINSR lookup on zone %s, was discontinued\n"
            "\tafter nbstat lookup for query %p was launched\n",
            pQuery->pzoneCurrent->pszZoneName,
            pQuery ));
        Send_NameError( pQuery );
        return;
    }

    if ( pnbstatRR != pQuery->U.Nbstat.pRR )
    {
        PDB_RECORD  prr = pQuery->U.Nbstat.pRR;

        DNS_DEBUG( ANY, (
            "WARNING:  WINSR lookup on zone %s was changed\n"
            "\tafter nbstat lookup for query %p was launched.\n"
            "\tnew WINSR = %p\n"
            "\told WINSR = %p\n",
            pQuery->pzoneCurrent->pszZoneName,
            pQuery,
            pnbstatRR,
            prr ));

        ASSERT( prr->wType == DNS_TYPE_WINSR );
        //  shouldn't be on free list, should be on timeout free
        //ASSERT( IS_ON_FREE_LIST(prr) );
    }

    //
    //  validate zone WINSR record
    //      - legitimate to be on SLOW_FREE list, if just returned
    //      from context switch to thread that did WINSR update,
    //      but then MUST not be equal to existing zone WINS RR
    //      - not WINSR or in FREE list are code bugs
    //

    while ( pnbstatRR->wType != DNS_TYPE_WINSR ||
                IS_ON_FREE_LIST(pnbstatRR) ||
                IS_SLOW_FREE_RR(pnbstatRR) )
    {
        Dbg_DbaseRecord(
            "BOGUS NBSTAT RR!!!\n",
            pnbstatRR );

        ASSERT( pnbstatRR->wType == DNS_TYPE_WINSR );
        ASSERT( !IS_ON_FREE_LIST(pnbstatRR) );
        ASSERT( !IS_SLOW_FREE_RR(pnbstatRR) || pnbstatRR != pQuery->pzoneCurrent->pWinsRR );

        if ( pnbstatRR != pQuery->pzoneCurrent->pWinsRR )
        {
            pnbstatRR = pQuery->pzoneCurrent->pWinsRR;
            if ( !pnbstatRR )
            {
                Send_NameError( pQuery );
                return;
            }
            DNS_DEBUG( ANY, (
                "WARNING:  WINSR lookup on zone %s was changed during nbstat completion!\n"
                "\tcontinuing with new WINSR = %p\n",
                pQuery->pzoneCurrent->pszZoneName,
                pnbstatRR ));
            continue;
        }
        goto ServerFailure;
    }


    //
    //  create owner node, if doesn't exist
    //

    pnode = pQuery->pnodeCurrent;
    if ( ! pnode )
    {
        pnode = Lookup_ZoneNode(
                    pQuery->pzoneCurrent,
                    (PCHAR) pQuery->MessageBody,
                    pQuery,
                    NULL,               // no lookup name
                    //  pQuery->pLooknameQuestion;
                    LOOKUP_NAME_FQDN,
                    NULL,               // create
                    NULL                // following node ptr
                    );
        if ( ! pnode )
        {
            ASSERT( FALSE );
            goto ServerFailure;
        }
    }
    IF_DEBUG( NBSTAT )
    {
        Dbg_NodeName(
            "NBSTAT adding PTR record to node ",
            pnode,
            "\n" );
    }

    //
    //  convert result name from OEM to UTF8
    //      - no-op if ASCII name
    //      - otherwise go to unicode and come back
    //

    lengthResult = strlen( pszResultName );

    if ( ! Dns_IsStringAsciiEx( pszResultName, lengthResult ) )
    {
        DWORD   unicodeLength;
        DWORD   utf8Length;
        DWORD   i;

        status = RtlOemToUnicodeN(
                    unicodeBuffer,
                    (MAX_WINS_NAME_LENGTH * 2),
                    & unicodeLength,
                    pszResultName,
                    lengthResult );

        if ( status != ERROR_SUCCESS )
        {
            goto ServerFailure;
        }
        unicodeLength = unicodeLength / 2;

        DNS_DEBUG( NBSTAT, (
            "Nbstat response name %s converted to unicode %.*S (count=%d).\n",
            pszResultName,
            unicodeLength,
            unicodeBuffer,
            unicodeLength ));

        //  downcase in unicode to so don't mess it up

        i = CharLowerBuffW( unicodeBuffer, unicodeLength );
        if ( i != unicodeLength )
        {
            ASSERT( FALSE );
            goto ServerFailure;
        }

        utf8Length = DnsUnicodeToUtf8(
                        unicodeBuffer,
                        unicodeLength,
                        utf8Buffer,
                        DNS_MAX_LABEL_LENGTH );
        if ( utf8Length == 0 )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  Converting NBTSTAT name to UTF8.\n" ));
            ASSERT( FALSE );
            goto ServerFailure;
        }

        lengthResult = utf8Length;
        pszResultName = utf8Buffer;

        DNS_DEBUG( NBSTAT, (
            "Nbstat UTF8 result name %.*s (count = %d)\n",
            lengthResult,
            pszResultName,
            lengthResult ));
    }

    //
    //  cache RR in database
    //      - allocate the RR
    //      - fill in PTR record and cache timeout
    //      - rank is authoritative answer
    //

    prr = RR_AllocateEx(
                (WORD)(lengthResult + 1 +
                    Name_SizeofDbaseName( &pnbstatRR->Data.WINSR.nameResultDomain )),
                MEMTAG_RECORD_WINSPTR );

    IF_NOMEM( !prr )
    {
        goto ServerFailure;
    }
    prr->wType = DNS_TYPE_PTR;
    prr->dwTtlSeconds = pnbstatRR->Data.WINSR.dwCacheTimeout + pQuery->dwQueryTime;

    SET_RR_RANK( prr, RANK_CACHE_A_ANSWER );

    //
    //  build resulting PTR name from host name + result domain
    //

    status = Name_ConvertFileNameToCountName(
                & prr->Data.PTR.nameTarget,
                pszResultName,
                lengthResult );
    if ( status == ERROR_INVALID_NAME )
    {
        DNS_PRINT(( "ERROR:  Failed NBSTAT dbase name create!\n" ));
        ASSERT( FALSE );
    }
    status = Name_AppendCountName(
                & prr->Data.PTR.nameTarget,
                & pnbstatRR->Data.WINSR.nameResultDomain );
    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT(( "ERROR:  Failed NBSTAT dbase name append!\n" ));
        ASSERT( FALSE );
    }

    RR_CacheSetAtNode(
        pnode,
        prr,            // first record
        prr,            // last record
        pnbstatRR->Data.WINS.dwCacheTimeout,
        DNS_TIME()      // cache from current time
        );
#if 0
    RR_CacheAtNode(
        pnode,
        prr,
        TRUE    // first RR in set
        );
#endif

    //
    //  write RR to packet
    //
    //  always use compressed name pointing to original question name
    //      (right after header)
    //

    ASSERT( pQuery->wOffsetCurrent == sizeof(DNS_HEADER) );

    if ( ! Wire_AddResourceRecordToMessage(
                pQuery,
                NULL,
                sizeof(DNS_HEADER),     // offset to question name in packet
                prr,
                0 ) )                   // flags
    {
        ASSERT( FALSE );        // should never be out of space in packet
        goto ServerFailure;
    }

    //  set answer count -- should be only answer

    ASSERT( pQuery->Head.AnswerCount == 0 );
    pQuery->Head.AnswerCount++;

    Send_Response( pQuery );
    return;

ServerFailure:

    //
    //  DEVNOTE:  redo NBSTAT query if failure?
    //
    //  but, if couldn't write RR, then this is truly a server failure
    //

    DNS_DEBUG( ANY, (
        "ERROR:  Nbstat response parsing error "
        "-- sending server failure for query at %p.\n",
        pQuery ));

    Reject_Request(
        pQuery,
        DNS_RCODE_SERVER_FAILURE,
        0 );
    return;
}



//
//  Nbstat utilities
//

VOID
cleanupNbstatQuery(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      DWORD           iEvent
    )
/*++

Routine Description:

    Cleanup after NBStat query.

    Close events, free memory.

Arguments:

    pQuery -- query to cleanup

    iEvent -- event for which NBT IOCTL completed

Return Value:

    None.

--*/
{
    PDNS_NBT_INFO   pnbtInfo = pQuery->U.Nbstat.pNbstat;
    UINT            i;

    ASSERT( !pQuery->fDelete );

    //
    //  reset the status on this adapter, if all NBT IOCTLs not complete
    //

    if ( pQuery->U.Nbstat.dwNbtInterfaceMask != dwInterfaceBitmask )
    {
        ASSERT( pQuery->U.Nbstat.dwNbtInterfaceMask < dwInterfaceBitmask );

        //  status code is reset to a non-returnable value
        //  this keeps us from checking this query again when
        //  event for this adapter is signalled again

        pnbtInfo[iEvent].IoStatus.Status = DNS_NBT_NO_STATUS;
        return;
    }

    //
    //  all interfaces have responded -- dequeue
    //

    PQ_YankQueuedPacket(
        pNbstatPrivateQueue,
        pQuery );

    //
    //  query pronounced dead -- if no response to client yet, respond
    //

    if ( ! pQuery->U.Nbstat.fNbstatResponded )
    {
        ASSERT( !pQuery->fDelete );
        pQuery->U.Nbstat.fNbstatResponded = TRUE;
        Send_NameError( pQuery );
    }

    //
    //  cleanup nbstat query
    //      - free nbstat buffer
    //      - free query
    //

    DNS_DEBUG( NBSTAT, (
        "Clearing nbstat query at %p.\n",
        pQuery ));

    freeNbstatBuffer( pnbtInfo );
    Packet_Free( pQuery );
}



VOID
cancelOutstandingNbstatRequests(
    VOID
    )
/*++

Routine Description:

    Cancell outstand NBT requests.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UINT            i;
    IO_STATUS_BLOCK ioStatusBlock;

    //
    //  cancell outstanding I/O requests on each NBT interface
    //

    DNS_DEBUG( NBSTAT, ( "Cancelling outstaning nbstat requests I/O requests.\n" ));

    for ( i = 0; i < cNbtInterfaceCount; i++ )
    {
        NtCancelIoFile(
            pahNbtHandles[i],
            &ioStatusBlock );
    }

    DNS_DEBUG( NBSTAT, ( "NBSTAT:  I/O requests cancelled.\n" ));
}



//
//  NBStat Thread
//

DWORD
NbstatThread(
    IN      LPVOID  Dummy
    )
/*++

Routine Description:

    Nbstat thread.
        - send nbstat queries
        - processes response from NBT
        - timeout queries
        - sends DNS responses

Arguments:

    Dummy

Return Value:

    Exit code.
    Exit from DNS service terminating or error in wait call.

--*/
{
    PDNS_MSGINFO    pquery;
    PDNS_NBT_INFO   pnbtInfo;
    DWORD           waitResult;
    DWORD           waitTimeout;
    INT             ievent;

    //
    //  Wait for the worker thread event to be signalled indicating
    //  that there is work to do, or for the termination event
    //  to be signalled indicating that we should exit.
    //

    while ( TRUE )
    {
        //
        //  wait
        //
        //  - wait event array includes:
        //      - shutdown event
        //      - nbstat queuing event (for new queries)
        //      - nbstat IOCTL response events (for nbstat responses)
        //
        //  - timeout
        //      - INFINITE if no outstanding queries
        //      - otherwise 2 seconds, to catch even shortest timeouts
        //          in reasonable time
        //

        waitTimeout = 2000;

        if ( ! pNbstatPrivateQueue->cLength )
        {
            waitTimeout = INFINITE;
        }

        waitResult = WaitForMultipleObjects(
                            cEventArrayCount,
                            phWaitEventArray,
                            FALSE,              // any event stops wait
                            waitTimeout
                            );

        DNS_DEBUG( NBSTAT, (
            "Nbstat wait completed.\n"
            "\twaitTimeout = %d.\n"
            "\twaitResult = %d.\n"
            "\tevent index  = %d.\n",
            waitTimeout,
            waitResult,
            waitResult - WAIT_OBJECT_0 ));

        //
        //  Check and possibly wait on service status
        //

        if ( fDnsThreadAlert )
        {
            if ( ! Thread_ServiceCheck() )
            {
                IF_DEBUG( SHUTDOWN )
                {
                    DNS_PRINT(( "Terminating Worker thread.\n" ));
                }
                return( 1 );
            }
        }

        //
        //  determine event or timeout
        //

        switch ( waitResult )
        {
        case WAIT_OBJECT_0:

            //
            //  first event is new query on nbstat queue
            //
            //  - send NBSTAT request for new queries
            //  - place on private nbstat queue
            //

            DNS_DEBUG( NBSTAT, (
                "Hit nbstat queuing event.\n"
                "\tNbstat public queue length = %d.\n",
                pNbstatQueue->cLength
                ));

            while ( pquery = PQ_DequeueNextPacket( pNbstatQueue, FALSE ) )
            {
                makeNbstatRequestThroughNbt( pquery );
            }
            break;

        case WAIT_TIMEOUT:
        {
            DWORD   currentTime = GetCurrentTimeInSeconds();
            BOOL    foutstandingQueries = FALSE;

            //
            //  send NAME_ERROR for any timed out queries
            //
            //  also track existence of unresponded, non-timed-out
            //  queries;  if none exist then can cancel NBT i/o to
            //  speed cleanup

            pquery = (PDNS_MSGINFO) pNbstatPrivateQueue->listHead.Flink;

            while ( (PLIST_ENTRY)pquery != &pNbstatPrivateQueue->listHead )
            {
                if ( !pquery->U.Nbstat.fNbstatResponded )
                {
                    if ( pquery->dwExpireTime < currentTime )
                    {
                        pquery->U.Nbstat.fNbstatResponded = TRUE;
                        Send_NameError( pquery );
                    }
                    else
                    {
                        foutstandingQueries = TRUE;
                    }
                }
                //  next query
                pquery = (PDNS_MSGINFO) ((PLIST_ENTRY)pquery)->Flink;
            }

            //
            //  if no outstanding nbstat requests -- cancel to speed cleanup
            //

            if ( ! foutstandingQueries )
            {
                DNS_DEBUG( NBSTAT, (
                    "Cancelling NBT requests.  All queries responded to.\n"
                    "\tqueue length = %d\n",
                    pNbstatPrivateQueue->cLength
                    ));
                cancelOutstandingNbstatRequests();
            }
            break;
        }

        case WAIT_FAILED:

            ASSERT( FALSE );
            break;

#if DBG
        case WAIT_OBJECT_0 + 1:

            //  this is DNS shutdown event, if fired, should have
            //      exited above

            ASSERT( FALSE );
#endif

        default:

            //
            //  NBStat response
            //
            //  event signalled corresponds to an NBT response on a
            //  specific adapter
            //
            //  first reset event so that we are SURE that any completions
            //  after we check a query will be indicated
            //

            ievent = waitResult - WAIT_OBJECT_0 - 2;

            ASSERT( ievent < (INT)cNbtInterfaceCount );
            ResetEvent( phNbstatEventArray[ievent] );

            //
            //  check each outstanding Nbtstat query in the queue for
            //  status of NBT request on adapter corresponding to
            //  the signalled event
            //
            //  if status is NOT equal to status code set before query
            //  then NBT has responded to this query -- process it
            //
            //  note save next query before processing as on response
            //  query may be removed from the queue
            //

            pquery = (PDNS_MSGINFO) pNbstatPrivateQueue->listHead.Flink;

            while ( (PLIST_ENTRY)pquery != &pNbstatPrivateQueue->listHead )
            {
                PDNS_MSGINFO    pthisQuery = pquery;
                pquery = (PDNS_MSGINFO) ((PLIST_ENTRY)pquery)->Flink;

                ASSERT( pthisQuery->U.Nbstat.pNbstat );
                pnbtInfo = &((PDNS_NBT_INFO)pthisQuery->U.Nbstat.pNbstat)[ievent];

                if ( pnbtInfo->IoStatus.Status == DNS_NBT_NO_STATUS )
                {
                    //
                    //  DEVNOTE: if timed out, then we're hosed
                    //

                    continue;
                }
                processNbstatResponse( pthisQuery, ievent );
            }
            break;
        }

        //  loop until service shutdown
    }
}



//
//  Open and close NBT for lookup
//

BOOL
openNbt(
    VOID
    )
/*++

Routine Description:

    Opens NBT handles to use NBT to do reverse lookups.

    This routine is a clone of Dave Treadwell's SockOpenNbt() for winsock.

Arguments:

    None

Globals:

    cNbtInterfaceCount -- set to number of nbt handles
    pahNbtHandles -- created as array of NBT handles

Return Value:

    TRUE, if successful
    FALSE otherwise, unable to open NBT handles.

--*/
{
    DNS_STATUS          status = STATUS_UNSUCCESSFUL;
    HKEY                nbtKey = NULL;
    PWSTR               deviceName = NULL;
    ULONG               deviceNameLength;
    ULONG               type;
    DWORD               interfaceCount;
    PWSTR               pwide;
    IO_STATUS_BLOCK     ioStatusBlock;
    UNICODE_STRING      deviceString;
    OBJECT_ATTRIBUTES   objectAttributes;

    //
    //  First determine whether we actually need to open NBT.
    //

    if ( cNbtInterfaceCount > 0 )
    {
        return TRUE;
    }

    //
    //  First read the registry to obtain the device name of one of
    //  NBT's device exports.
    //

    status = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                L"SYSTEM\\CurrentControlSet\\Services\\NetBT\\Linkage",
                0,
                KEY_READ,
                &nbtKey
                );
    if ( status != NO_ERROR )
    {
        goto Exit;
    }

    //
    //  Determine the size of the device name.  We need this so that we
    //  can allocate enough memory to hold it.
    //

    deviceNameLength = 0;

    status = RegQueryValueExW(
                nbtKey,
                L"Export",
                NULL,
                &type,
                NULL,
                &deviceNameLength
                );
    if ( status != ERROR_MORE_DATA && status != NO_ERROR )
    {
        goto Exit;
    }

    //
    //  Allocate enough memory to hold the mapping.
    //

    deviceName = ALLOC_TAGHEAP( deviceNameLength, MEMTAG_NBSTAT );
    IF_NOMEM( ! deviceName )
    {
        goto Exit;
    }

    //
    //  Get the actual device names from the registry.
    //

    status = RegQueryValueExW(
                nbtKey,
                L"Export",
                NULL,
                &type,
                (PVOID)deviceName,
                &deviceNameLength
                );
    if ( status != NO_ERROR )
    {
        goto Exit;
    }

    //
    //  Count the number of names exported by NetBT.
    //      - need at least one to operate
    //

    interfaceCount = 0;

    for ( pwide = deviceName; *pwide != L'\0'; pwide += wcslen(pwide) + 1 )
    {
        interfaceCount++;
    }
    if ( interfaceCount == 0 )
    {
        DNS_DEBUG( NBSTAT, ( "ERROR:  cNbtInterfaceCount = 0.\n" ));
        goto Exit;
    }
    DNS_DEBUG( NBSTAT, (
        "Nbstat init:  cNbtInterfaceCount = %d.\n",
        interfaceCount ));

    //
    //  Allocate NBT control handle for each interface.
    //

    pahNbtHandles = ALLOC_TAGHEAP_ZERO( (interfaceCount+1)*sizeof(HANDLE), MEMTAG_NBSTAT );
    IF_NOMEM( ! pahNbtHandles )
    {
        goto Exit;
    }

    //
    //  Open NBT control channel for each interface
    //      - keep count only of those actually opened
    //      - log failures
    //      - need at least one to do nbstat lookups
    //

    for ( pwide = deviceName;  *pwide != L'\0';  pwide += wcslen(pwide) + 1 )
    {
        DNS_DEBUG( NBSTAT, (
            "Opening interface %S for NBSTAT\n",
            pwide ));

        RtlInitUnicodeString( &deviceString, pwide );

        InitializeObjectAttributes(
            &objectAttributes,
            &deviceString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL );

        status = NtCreateFile(
                     &pahNbtHandles[ cNbtInterfaceCount ],
                     GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                     &objectAttributes,
                     &ioStatusBlock,
                     NULL,                                     // AllocationSize
                     0L,                                       // FileAttributes
                     FILE_SHARE_READ | FILE_SHARE_WRITE,       // ShareAccess
                     FILE_OPEN_IF,                             // CreateDisposition
                     0,                                        // CreateOptions
                     NULL,
                     0
                     );

        if ( NT_SUCCESS(status) )
        {
            cNbtInterfaceCount++;
            continue;
        }

        //
        //  NDIS WAN "adapters" will routinely fail;  rather than log spurious
        //  failure events, we'll just stop all adapter failure event logging
        //
        //  DEVNOTE:  nbstat failure logging, ignore NDIS WAN links
        //

        else
        {
#if 0
            PCHAR   parg = (PCHAR)pwide;

            DNS_LOG_EVENT_EX(
                DNS_EVENT_NBSTAT_ADAPTER_FAILED,
                1,
                & parg,
                NULL,
                status );
#endif
            DNS_DEBUG( ANY, (
                "ERROR:  Opening NBT for adapter %S failed.\n",
                pwide ));
            continue;
        }
    }

Exit:

    DNS_DEBUG( NBSTAT, (
        "Opened %d adpaters for NBSTAT lookup.\n",
        cNbtInterfaceCount ));

    //  cleanup

    if ( nbtKey )
    {
        RegCloseKey( nbtKey );
    }
    if ( deviceName )
    {
        FREE_HEAP( deviceName );
    }

    //
    //  if any adapters opened -- success
    //
    //  if unsuccessful, close NBT
    //      - note, since we only do this if unable to open any
    //      adapter, closeNbt just becomes memory free
    //

    if ( cNbtInterfaceCount == 0 )
    {
        DNS_PRINT(( "ERROR:  Unable to open NBT.\n\n" ));
        closeNbt();
    }

    return( cNbtInterfaceCount > 0 );
}



VOID
closeNbt(
    VOID
    )
/*++

Routine Description:

    Read, store names of and count of NBT devices.

    This info is stored, so that we can reopen NBT handles, whenever
    we are forced to cancel

Arguments:

    None

Globals:

    cNbtInterfaceCount -- set to number of nbt handles
    pahNbtHandles -- created as array of NBT handles

Return Value:

    None.

--*/
{
    INT i;

    //
    //  close NBT handles
    //

    if ( pahNbtHandles != NULL )
    {
        for ( i=0; pahNbtHandles[i] != NULL; i++ )
        {
            NtClose( pahNbtHandles[i] );
        }
        FREE_HEAP( pahNbtHandles );
    }

    pahNbtHandles = 0;
    cNbtInterfaceCount = 0;
}



//
//  Global Nbstat init and cleanup
//

VOID
Nbstat_StartupInitialize(
    VOID
    )
/*++

Routine Description:

    Startup init of NBSTAT globals -- whether using NBSTAT or not

Arguments:

    None

Globals:

    All NBSTAT globals that can be referenced whether NBSTAT used or
    not, are initialized.

Return Value:

    None.

--*/
{
    g_bNbstatInitialized = FALSE;

    cNbtInterfaceCount = 0;
    dwInterfaceBitmask = 0;
    dwNbtBufferLength = 0;

    pNbstatQueue = NULL;
    pNbstatPrivateQueue = NULL;
}



BOOL
Nbstat_Initialize(
    VOID
    )
/*++

Routine Description:

    Initialize for NBSTAT lookup.

Arguments:

    None

Globals:

    pNbstatQueue -- public nbstat queue for queuing queries for
        nbstat lookup

    pNbstatPrivateQueue -- private queue to hold queries during nbstat
        lookup

    cNbtInterfaceCount -- set to number of nbt handles

    pahNbtHandles -- created as array of NBT handles

Return Value:

    TRUE, if successful
    FALSE otherwise, unable to open NBT handles.

--*/
{
    DWORD  i;

    if ( g_bNbstatInitialized )
    {
        IF_DEBUG( INIT )
        {
            DNS_PRINT(( "Nbstat already initialized.\n" ));
        }
        return( TRUE );
    }

    //
    //  Init globals
    //

    cNbtInterfaceCount = 0;
    dwInterfaceBitmask = 0;
    dwNbtBufferLength = 0;

    //
    //  Open NBT interfaces
    //

    if ( ! openNbt() )
    {
        goto Failed;
    }

    //
    //  create bitmask for all interfaces
    //

    dwInterfaceBitmask = 0;
    for (i=0; i<cNbtInterfaceCount; i++ )
    {
        dwInterfaceBitmask <<= 1;
        dwInterfaceBitmask++;
    }

    //
    //  set nbstat buffer allocation size
    //

    dwNbtBufferLength = cNbtInterfaceCount * sizeof(DNS_NBT_INFO);

    //
    //  Create public and private nbstat queues
    //
    //  recv threads queue packet to nbstat thread via public queue
    //      - set event when queue
    //      - expire packets to prevent queue backup
    //

    pNbstatQueue = PQ_CreatePacketQueue(
                        "Nbstat",
                        QUEUE_SET_EVENT |           // set event when queue packet
                            QUEUE_DISCARD_EXPIRED,  // discard expired packets
                        0 );
    if ( !pNbstatQueue )
    {
        goto Failed;
    }

    pNbstatPrivateQueue = PQ_CreatePacketQueue(
                            "NbstatPrivate",
                            0,              // no queuing flags
                            0 );
    if ( !pNbstatPrivateQueue )
    {
        goto Failed;
    }

    //
    //  create nbstat event array
    //      - includes shutdown and queuing events
    //      along with event for each NBT interface
    //

    cEventArrayCount = cNbtInterfaceCount + 2;

    phWaitEventArray = ALLOC_TAGHEAP( (sizeof(HANDLE) * cEventArrayCount), MEMTAG_NBSTAT );
    IF_NOMEM( !phWaitEventArray )
    {
        DNS_PRINT(( "ERROR:  Failure allocating nbstat event array.\n" ));
        goto Failed;
    }

    phWaitEventArray[0] = pNbstatQueue->hEvent;
    phWaitEventArray[1] = hDnsShutdownEvent;

    //
    //  keep separate ptr to start of Nbstat events for simplicity
    //

    phNbstatEventArray = &phWaitEventArray[2];

    for (i=0; i<cNbtInterfaceCount; i++ )
    {
        HANDLE event = CreateEvent( NULL, TRUE, TRUE, NULL );
        if ( ! event )
        {
            DNS_PRINT(( "ERROR:  unable to create NBSTAT events.\n" ));
            goto Failed;
        }
        phNbstatEventArray[i] = event;
    }

    //
    //  Create nbstat thread
    //

    if ( ! Thread_Create(
                "Nbstat Thread",
                NbstatThread,
                NULL,
                0 ) )
    {
        goto Failed;
    }

    g_bNbstatInitialized = TRUE;
    return TRUE;

Failed:

    DNS_PRINT(( "Nbstat initialization failed.\n" ));

    DNS_LOG_EVENT(
        DNS_EVENT_NBSTAT_INIT_FAILED,
        0,
        NULL,
        NULL,
        0 );
    closeNbt();
    return FALSE;
}



VOID
Nbstat_Shutdown(
    VOID
    )
/*++

Routine Description:

    Shutsdown Nbstat and cleans up.

Arguments:

    None

Globals:

    cNbtInterfaceCount -- set to number of nbt handles
    pahNbtHandles -- created as array of NBT handles

Return Value:

    TRUE, if successful
    FALSE otherwise, unable to open NBT handles.

--*/
{
    if ( ! g_bNbstatInitialized )
    {
        return;
    }

    IF_DEBUG( SHUTDOWN )
    {
        DNS_PRINT(( "Shutting down Nbstat lookup.\n" ));
    }
    g_bNbstatInitialized = FALSE;

    //
    //  cleanup NBSTAT queues
    //

    PQ_CleanupPacketQueueHandles( pNbstatQueue );
    PQ_CleanupPacketQueueHandles( pNbstatPrivateQueue );

#if 0
    //
    //  now as process memory cleanup unnecesary
    //
    //  cancel outstanding events, cleanup nbstat memory
    //

    PQ_WalkPacketQueueWithFunction(
        pNbstatPrivateQueue,
        cleanupNbstatQuery );

    //
    //  cleanup packet queues
    //

    PQ_DeletePacketQueue( pNbstatQueue );
    PQ_DeletePacketQueue( pNbstatPrivateQueue );
#endif

    //
    //  close NBT
    //

    closeNbt();
}



//
//  Nbstat buffer allocation / free list
//
//  Maintain a free list of packets to avoid reallocation to service
//  every query.
//
//  Implement as stack using single linked list.
//  List head points at first nbstat buffer.  First field in each nbstat buffer
//  serves as next ptr.  Last points at NULL.
//

PDNS_NBT_INFO   pNbstatFreeListHead = NULL;

INT cNbstatFreeListCount = 0;

#define NBSTAT_FREE_LIST_LIMIT (30)

#define NBSTAT_ALLOC_LOCK()      // currently only used by nbstat thread
#define NBSTAT_ALLOC_UNLOCK()    // currently only used by nbstat thread



PDNS_NBT_INFO
allocateNbstatBuffer(
    VOID
    )
/*++

Routine Description:

    Allocate an Nbstat buffer.

    Use free list if buffer available, otherwise heap.

Arguments:

    None.

Return Value:

    Ptr to new nbstat buffer info block, if successful.
    NULL otherwise.

--*/
{
    PDNS_NBT_INFO   pbuf;

    NBSTAT_ALLOC_LOCK();

    //
    //  Nbstat nbstat buffer buffer available on free list?
    //

    if ( pNbstatFreeListHead )
    {
        ASSERT( cNbstatFreeListCount != 0 );
        ASSERT( IS_DNS_HEAP_DWORD(pNbstatFreeListHead) );

        pbuf = pNbstatFreeListHead;
        pNbstatFreeListHead = *(PDNS_NBT_INFO *) pbuf;

        cNbstatFreeListCount--;
        NbstatStats.NbstatUsed++;
    }

    //
    //  no packets on free list -- create new
    //      - create nbstat events for buffer
    //

    else
    {
        ASSERT( cNbstatFreeListCount == 0 );

        pbuf = (PDNS_NBT_INFO) ALLOC_TAGHEAP( dwNbtBufferLength, MEMTAG_NBSTAT );
        IF_NOMEM( !pbuf )
        {
            NBSTAT_ALLOC_UNLOCK();
            return( NULL );
        }
        NbstatStats.NbstatAlloc++;
        NbstatStats.NbstatUsed++;
    }

    ASSERT( !cNbstatFreeListCount || pNbstatFreeListHead );
    ASSERT( cNbstatFreeListCount > 0 || ! pNbstatFreeListHead );

    NBSTAT_ALLOC_UNLOCK();

    IF_DEBUG( HEAP )
    {
        DNS_PRINT((
            "Allocating/reusing nbstat buffer at %p.\n"
            "\tFree list count = %d.\n",
            pbuf,
            cNbstatFreeListCount ));
    }
    return( pbuf );
}



VOID
freeNbstatBuffer(
    IN      PDNS_NBT_INFO   pBuf
    )
/*++

Routine Description:

    Free an nbstat buffer.

    Kept on free list up to max number of buffers.

Arguments:

    pBuf -- RR to free.

Return Value:

    None.

--*/
{
    ASSERT( Mem_HeapMemoryValidate(pBuf) );

    NBSTAT_ALLOC_LOCK();

    ASSERT( !cNbstatFreeListCount || pNbstatFreeListHead );
    ASSERT( cNbstatFreeListCount > 0 || ! pNbstatFreeListHead );

    NbstatStats.NbstatReturn++;

    //
    //  free list at limit -- free packet
    //  space on free list -- stick nbstat buffer on front of free list
    //

    if ( cNbstatFreeListCount >= NBSTAT_FREE_LIST_LIMIT )
    {
        FREE_HEAP( pBuf );
        NbstatStats.NbstatFree++;
    }
    else
    {
        * (PDNS_NBT_INFO *) pBuf = pNbstatFreeListHead;
        pNbstatFreeListHead = pBuf;
        cNbstatFreeListCount++;
    }

    NBSTAT_ALLOC_UNLOCK();

    IF_DEBUG( HEAP )
    {
        DNS_PRINT((
            "Returned nbstat buffer at %p.\n"
            "\tFree list count = %d.\n",
            pBuf,
            cNbstatFreeListCount ));
    }
}



VOID
Nbstat_WriteDerivedStats(
    VOID
    )
/*++

Routine Description:

    Write derived statistics.

    Calculate stats dervived from basic Nbstat buffer counters.
    This routine is called prior to stats dump.

    Caller MUST hold stats lock.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    //  outstanding memory
    //

    NbstatStats.NbstatNetAllocs = NbstatStats.NbstatAlloc - NbstatStats.NbstatFree;
    NbstatStats.NbstatMemory = NbstatStats.NbstatNetAllocs * dwNbtBufferLength;
    PERF_SET( pcNbstatMemory , NbstatStats.NbstatMemory );   // PerfMon hook

    //
    //  outstanding nbstat buffers
    //      - free list
    //      - in processing
    //

    NbstatStats.NbstatInFreeList = cNbstatFreeListCount;
    NbstatStats.NbstatInUse = NbstatStats.NbstatUsed - NbstatStats.NbstatReturn;
}

//
//  End of nbstat.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\record.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    record.c

Abstract:

    Domain Name System (DNS) Server

    Routines to handle resource records (RR).

Author:

    Jim Gilroy (jamesg)     March, 1995

Revision History:

--*/


#include "dnssrv.h"



//
//  Resource database size table
//

WORD    RRDatabaseSizeTable[] =
{
    0,                      //  ZERO
    sizeof(IP_ADDRESS),     //  A
    0,                      //  NS
    0,                      //  MD
    0,                      //  MF
    0,                      //  CNAME
    0,                      //  SOA
    0,                      //  MB
    0,                      //  MG
    0,                      //  MR
    0,                      //  NULL
    0,                      //  WKS
    0,                      //  PTR
    0,                      //  HINFO
    0,                      //  MINFO
    0,                      //  MX
    0,                      //  TEXT
    0,                      //  RP
    0,                      //  AFSDB
    0,                      //  X25
    0,                      //  ISDN
    0,                      //  RT
    0,                      //  NSAP
    0,                      //  NSAPPTR
    0,                      //  SIG
    0,                      //  KEY
    0,                      //  PX
    0,                      //  GPOS
    sizeof(IP6_ADDRESS),    //  AAAA
    SIZEOF_LOC_FIXED_DATA,  //  LOC
    0,                      //  NXT
    0,                      //  31
    0,                      //  32
    0,                      //  SRV
    0,                      //  ATMA
    0,                      //  35
    0,                      //  36
    0,                      //  37
    0,                      //  38
    0,                      //  39
    0,                      //  40
    0,                      //  OPT
    0,                      //  42
    0,                      //  43
    0,                      //  44
    0,                      //  45
    0,                      //  46
    0,                      //  47
    0,                      //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as DNSSRV_MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //  MS types
    //  note these follow, but require OFFSET_TO_WINS_RR subtraction
    //  from actual type value

    0,                      //  WINS
    0                       //  NBSTAT
};


//
//  Default SOA values
//

#define DEFAULT_SOA_SERIAL_NO       1
#define DEFAULT_SOA_REFRESH         900     // 15 minutes
#define DEFAULT_SOA_RETRY           600     // ten minutes
#define DEFAULT_SOA_EXPIRE          86400   // one day
#define DEFAULT_SOA_MIN_TTL         3600    // one hour

#define DNS_DEFAULT_SOA_ADMIN_NAME  "hostmaster"


//
//  Record type properties table
//
//  Properties outer subscript:
//      0 - cnameable query type
//      1 - allowed with cname type
//      2 - wildcardable type
//      3 - slow free
//
//
//  CNAME query rule:
//      Everything but ALL, XFR or CNAME queries and any of
//      of the record types that we allow to live at nodes with CNAME
//      ... NS, SOA, SIG, KEY, WINS, WINSR
//
//  Allowed with CNAME rule:
//      Only security types on all records (SIG, KEY) and
//      zone root types (NS, SOA, WINS, WINSR)
//
//  Wildcard rule:
//      Don't wildcard
//          - specific address (A, AAAA, etc.?)
//          - zone root (SOA, NS, WINS, WINSR)
//          - node security records
//      everything else ok.
//      (some mail programs use ALL to query so strangely allow wildcarding ALL)
//
//  Update rule:
//      0 -- query type, no updates
//      1 -- type updateable
//      2 -- type updateable, but requires special handling (NS, SOA, CNAME need flag reset)
//
//  Round robin rule:
//      Jiggle nodes in list after each query to cycle results. By default
//      all types are round-robined, but registry settings can turn off
//      individual types.
//

UCHAR  RecordTypePropertyTable[][5] =
{
//  CNAMEable   at CNAME    wildcard    update      robin
//  ---------   --------    --------    ------      -----
    1,          0,          0,          0,          0,      //  ZERO
    1,          0,          0,          1,          1,      //  A
    0,          1,          0,          2,          1,      //  NS
    1,          0,          1,          1,          1,      //  MD
    1,          0,          1,          1,          1,      //  MF
    0,          0,          0,          2,          1,      //  CNAME
    0,          1,          0,          2,          1,      //  SOA
    1,          0,          1,          1,          1,      //  MB
    1,          0,          1,          1,          1,      //  MG
    1,          0,          1,          1,          1,      //  MR
    1,          0,          1,          1,          1,      //  NULL
    1,          0,          1,          1,          1,      //  WKS
    1,          0,          1,          1,          1,      //  PTR
    1,          0,          1,          1,          1,      //  HINFO
    1,          0,          1,          1,          1,      //  MINFO
    1,          0,          1,          1,          1,      //  MX
    1,          0,          1,          1,          1,      //  TEXT
    1,          0,          1,          1,          1,      //  RP
    1,          0,          1,          1,          1,      //  AFSDB
    1,          0,          1,          1,          1,      //  X25
    1,          0,          1,          1,          1,      //  ISDN
    1,          0,          1,          1,          1,      //  RT
    1,          0,          1,          1,          1,      //  NSAP
    1,          0,          1,          1,          1,      //  NSAPPTR
    0,          1,          0,          0,          1,      //  SIG
    0,          1,          0,          1,          1,      //  KEY
    1,          0,          1,          1,          1,      //  PX
    1,          0,          1,          1,          1,      //  GPOS
    1,          0,          0,          1,          1,      //  AAAA
    1,          0,          1,          1,          1,      //  LOC
    0,          1,          0,          1,          1,      //  NXT
    1,          0,          1,          1,          1,      //  31
    1,          0,          1,          1,          1,      //  32
    1,          0,          1,          1,          1,      //  SRV
    1,          0,          1,          1,          1,      //  ATMA
    1,          0,          1,          1,          1,      //  35
    1,          0,          1,          1,          1,      //  36
    1,          0,          1,          1,          1,      //  37
    1,          0,          1,          1,          1,      //  A6
    1,          0,          1,          1,          1,      //  DNAME
    1,          0,          1,          1,          1,      //  40
    1,          0,          1,          1,          0,      //  OPT
    1,          0,          1,          1,          1,      //  42
    1,          0,          1,          1,          1,      //  43
    1,          0,          1,          1,          1,      //  44
    1,          0,          1,          1,          1,      //  45
    1,          0,          1,          1,          1,      //  46
    1,          0,          1,          1,          1,      //  47
    1,          0,          1,          1,          1,      //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as DNSSRV_MAX_SELF_INDEXED_TYPE defined in record.h
    //         (see note above in record info table)

    //  WINS types

    0,          1,          0,          0,          0,      //  WINS
    0,          1,          0,          0,          0,      //  WINSR

    //  compound query types
    //      - don't follow CNAMEs
    //      - can't exist as records period
    //      - mail box and ALL do follow wildcard
    //      - no updates allowed

    0,          0,          0,          0,          0,      //  DNS_TYPE_TKEY   (249)
    0,          0,          0,          0,          0,      //  DNS_TYPE_TSIG
    0,          0,          0,          0,          0,      //  DNS_TYPE_IXFR
    0,          0,          0,          0,          0,      //  DNS_TYPE_AXFR
    0,          0,          1,          0,          0,      //  DNS_TYPE_MAILB
    0,          0,          1,          0,          0,      //  DNS_TYPE_MAILA
    0,          0,          1,          0,          0,      //  DNS_TYPE_ALL    (255)

    //  terminator element for iteration

    0xff,       0xff,       0xff,       0xff,       0xff
};


//
//  Slow free for NS and SOA
//      - NS just added protection on recurse, delegation walking
//      - SOA as PTR is outstanding
//
//  Note:  if change this to allow substantial SLOW frees, them MUST
//          change timeout thread to run cleanup more frequently
//
//  DEVNOTE:  alternative to RR lock or slow everything on fast thread, IS
//      to actually determine safe frees (XFR tree, COPY_RR, etc.), but
//      ultimately if A records not safe, then must have some faster
//      SLOW_FREE turnaround
//

#define DO_SLOW_FREE_ON_RR(pRR)     ((pRR)->wType == DNS_TYPE_NS || \
                                     (pRR)->wType == DNS_TYPE_SOA)




WORD
FASTCALL
QueryIndexForType(
    IN      WORD    wType
    )
/*++

Routine Description:

    Return index for non-self indexed types.
    Includes both WINS and compound (query only) types.

Arguments:

    wType -- type to index

Return Value:

    Index of type.
    0 for unknown type.

--*/
{
    //  if not self-indexed
    //      - compound (type ALL) next most likely
    //      - then WINS
    //      - unknown gets type zero

    if ( wType > DNSSRV_MAX_SELF_INDEXED_TYPE )
    {
        if ( wType <= DNS_TYPE_ALL )
        {
            if ( wType >= DNS_TYPE_TKEY )
            {
                wType -= DNSSRV_OFFSET_TO_COMPOUND_TYPE_INDEX;
            }
            else    //  unknown type < 255
            {
                wType = 0;
            }
        }
        else if ( wType == DNS_TYPE_WINS || wType == DNS_TYPE_WINSR )
        {
            wType -= DNSSRV_OFFSET_TO_WINS_TYPE_INDEX;
        }
        else    // unknown type > 255
        {
            wType = 0;
        }
    }
    return( wType );
}



WORD
FASTCALL
RR_IndexForType(
    IN      WORD    wType
    )
/*++

Routine Description:

    Return index for non-self indexed RECORD types.
    Same as above except without the query only types.

Arguments:

    wType -- type to index

Return Value:

    Index of type.
    0 for unknown type.

--*/
{
    //  if not self-indexed
    //      - check WINS
    //      - unknown gets type zero

    if ( wType > DNSSRV_MAX_SELF_INDEXED_TYPE )
    {
        if ( wType == DNS_TYPE_WINS || wType == DNS_TYPE_WINSR )
        {
            wType -= DNSSRV_OFFSET_TO_WINS_TYPE_INDEX;
        }
        else    // unknown type
        {
            wType = 0;
        }
    }
    return( wType );
}



#if 0
//  unused
PDB_RECORD
RR_CreateFromWire(
    IN      WORD    wType,
    IN      WORD    wDataLength
    )
/*++

Routine Description:

    Create a resource record based on wire datalength

Arguments:

    wType -- type to write

    wDataLength - wire data length for type;  used if fixed type length
        is not known

Return Value:

    Ptr to new RR, if successful.
    NULL otherwise.

--*/
{
    PDB_RECORD      pRR;
    WORD            index;

    //
    //  create record
    //      - use fixed database record length, if exists
    //      - otherwise use passed length
    //

    index = INDEX_FOR_TYPE(wType);
    if ( index )
    {
        index = RRDatabaseSizeTable[index];
        if ( index )
        {
            wDataLength = index;
        }
    }

    pRR = RR_AllocateEx( wDataLength, 0 );
    if ( !pRR )
    {
        return( NULL );
    }
    pRR->wType = wType;     // set type
    return( pRR );
}



PDB_RECORD
RR_CreateFixedLength(
    IN      WORD    wType
    )
/*++

Routine Description:

    Create record for fixed length type.

Arguments:

    wType -- type to write

Return Value:

    Ptr to new RR, if successful.
    NULL otherwise.

--*/
{
    PDB_RECORD  pRR;
    WORD        index;
    WORD        length;

    //
    //  get fixed database record length, if exists
    //      and create record
    //

    index = INDEX_FOR_TYPE( wType );
    if ( !index )
    {
        return( NULL );
    }
    length = RRDatabaseSizeTable[index];
    if ( !length )
    {
        return( NULL );
    }
    pRR = RR_AllocateEx( length, 0 );
    if ( !pRR )
    {
        return( NULL );
    }
    pRR->wType = wType;     // set type
    return( pRR );
}
#endif      // end unused



PDB_RECORD
RR_Copy(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Flag
    )
/*++

Routine Description:

    Create copy of record.

    Note:  the copy is NOT a valid copy with valid references to data nodes
            it should NOT be enlisted and data references may expire one
            timeout interval past creation, so should be used only during
            single packet manipulation

    Note:  if we want more permanent record, then simply bump reference
            count of nodes referenced, and allow normal cleanup

Arguments:

    pRR - ptr to resource record

    Flag - currently unused;  later may be used to indicate record
        should properly reference desired nodes

Return Value:

    None.

--*/
{
    PDB_RECORD  prr;

    prr = RR_AllocateEx( pRR->wDataLength, MEMTAG_RECORD_COPY );
    IF_NOMEM( !prr )
    {
        return( NULL );
    }

    RtlCopyMemory(
        prr,
        pRR,
        (INT)pRR->wDataLength + SIZEOF_DBASE_RR_FIXED_PART );

    //  reset source tag in record

    prr->pRRNext = NULL;

    return( prr );
}


//
//  Record allocation will use standard alloc lock.
//  This allows us to avoid taking lock twice.
//

#define RR_ALLOC_LOCK()     STANDARD_ALLOC_LOCK()
#define RR_ALLOC_UNLOCK()   STANDARD_ALLOC_UNLOCK()



PDB_RECORD
RR_AllocateEx(
    IN      WORD            wDataLength,
    IN      DWORD           MemTag
    )
/*++

Routine Description:

    Allocate a resource record.

    This keeps us from needing to hit heap, for common RR operations,
    AND saves overhead of heap fields on each RR.

Arguments:

    None.

Return Value:

    Ptr to new RR, if successful.
    NULL otherwise.

--*/
{
    PDB_RECORD  pRR;
    PDB_RECORD  pRRNext;
    DWORD       dwAllocSize;
    INT         i;
    DWORD       length;

    //  some allocs will come down with tag undetermined

    if ( MemTag == 0 )
    {
        MemTag = MEMTAG_RECORD_UNKNOWN;
    }

    //
    //  detemine actual allocation length
    //

    length = wDataLength + SIZEOF_DBASE_RR_FIXED_PART;

    pRR = ALLOC_TAGHEAP( length, MemTag );
    IF_NOMEM( !pRR )
    {
        return( NULL );
    }

    STAT_INC( RecordStats.Used );
    STAT_INC( RecordStats.InUse );
    STAT_ADD( RecordStats.Memory, length );

    //
    //  set basic fields
    //      - clear RR header
    //      - set datalength
    //      - set source tag
    //

    RtlZeroMemory(
        pRR,
        SIZEOF_DBASE_RR_FIXED_PART );

    pRR->wDataLength = wDataLength;

    //  DEVNOTE: track difference between standard and heap allocs

    pRR->Reserved.StandardAlloc = (BYTE) Mem_IsStandardBlockLength(length);

    return( pRR );
}



VOID
RR_Free(
    IN OUT  PDB_RECORD      pRR
    )
/*++

Routine Description:

    Free a record.
    Standard sized RRs are returned to a free list for reuse.
    Non-standard sized RRs are returned to the heap.

Arguments:

    pRR -- RR to free.

Return Value:

    None.

--*/
{
    DWORD   length;

    if ( !pRR )
    {
        return;
    }

    ASSERT( Mem_HeapMemoryValidate(pRR) );

    DNS_DEBUG( UPDATE, (
        "Free RR at %p, memtag = %d\n",
        pRR,
        Mem_GetTag(pRR) ));

    //  special hack to catch bogus record free's
    //  this fires when record that's been queued for slow free, is freed
    //  by someone other than slow free execution routine

    IF_DEBUG( ANY )
    {
        if ( IS_SLOW_FREE_RR(pRR) && !IS_SLOWFREE_RANK(pRR) )
        {
            Dbg_DbaseRecord(
                "Bad invalid free of slow-free record!",
                pRR );
            ASSERT( FALSE );
        }
    }
    //ASSERT( !IS_SLOW_FREE_RR(pRR) || IS_SLOWFREE_RANK(pRR) );

    //
    //  nail down WINS free issues
    //

    IF_DEBUG( WINS )
    {
        if ( IS_WINS_RR(pRR) )
        {
            Dbg_DbaseRecord(
                "WINS record in RR_Free()",
                pRR );
            DNS_PRINT((
                "RR_Free on WINS record at %p\n",
                pRR ));
        }
    }

    //  verify NOT previously freed record
    //  don't want anything in free list twice

    if ( IS_ON_FREE_LIST(pRR) )
    {
        ASSERT( FALSE );
        Dbg_DbaseRecord(
            "ERROR:  RR is previously freed block !!!",
            pRR );
        ASSERT( FALSE );
        return;
    }

    if ( DO_SLOW_FREE_ON_RR(pRR)  &&  !IS_SLOW_FREE_RR(pRR) )
    {
        SET_SLOW_FREE_RR(pRR);
        Timeout_FreeWithFunction( pRR, RR_Free );
        STAT_INC( RecordStats.SlowFreeQueued );
        return;
    }

    //  track RRs returned

    if ( IS_CACHE_RR(pRR) )
    {
        STAT_DEC( RecordStats.CacheCurrent );
        STAT_INC( RecordStats.CacheTimeouts );
    }

    if ( IS_SLOW_FREE_RR(pRR) )
    {
        STAT_INC( RecordStats.SlowFreeFinished );
    }

    //  free
    //
    //  DEVNOTE: could have a check that blob is some type of record
    //

    length = pRR->wDataLength + SIZEOF_DBASE_RR_FIXED_PART;

    HARD_ASSERT( Mem_IsStandardBlockLength(length) == pRR->Reserved.StandardAlloc );

    //FREE_TAGHEAP( pRR, length, MEMTAG_RECORD+pRR->Reserved.Source );
    FREE_TAGHEAP( pRR, length, 0 );

    STAT_INC( RecordStats.Return );
    STAT_DEC( RecordStats.InUse );
    STAT_SUB( RecordStats.Memory, length );
}



BOOL
RR_Validate(
    IN      PDB_RECORD      pRR,
    IN      BOOL            fActive,
    IN      WORD            wType,
    IN      DWORD           dwSource
    )
/*++

Routine Description:

    Validate a record.

Arguments:

    pRR     -- RR to validate

    fActive -- not in free list

    wType   -- of a particular type

    dwSource -- expected source

Return Value:

    TRUE if valid record.
    FALSE on error.

--*/
{
    if ( !pRR )
    {
        ASSERT( FALSE );
        return( FALSE );
    }

    //
    //  Note: Record type validation not actually done,
    //      as this is sometimes called in update code on pAddRR which is
    //      actual enlisted ptr
    //

    //
    //  verify pRR memory
    //      - valid heap
    //      - RECORD tag
    //      - adequate length
    //      - not on free list
    //

    if ( ! Mem_VerifyHeapBlock(
                pRR,
                0,
                //MEMTAG_RECORD + pRR->Reserved.Source,
                pRR->wDataLength + SIZEOF_DBASE_RR_FIXED_PART ) )
    {
        DNS_PRINT((
            "\nERROR:  Record at %p, failed mem check!!!\n",
            pRR ));
        ASSERT( FALSE );
        return( FALSE );
    }

    //
    //  if active, then not on slow free list
    //

    if ( fActive )
    {
        if ( IS_SLOW_FREE_RR(pRR) )
        {
            Dbg_DbaseRecord(
                "Bad invalid free of slow-free record!",
                pRR );
            ASSERT( FALSE );
            return( FALSE );
        }
    }

    //  verify NOT previously freed record
    //  don't want anything in free list twice

    if ( IS_ON_FREE_LIST(pRR) )
    {
        Dbg_DbaseRecord(
            "ERROR:  RR is previously freed block !!!",
            pRR );
        ASSERT( FALSE );
        return( FALSE );
    }

#if 0
    //
    //  source tracking
    //

    if ( dwSource && (dwSource != pRR->Reserved.Source) )
    {
        DNS_PRINT((
            "\nERROR:  Record at %p, failed source (%d) check!!!\n",
            pRR,
            dwSource ));
        ASSERT( FALSE );
        return( FALSE );
    }
#endif

    return( TRUE );
}



VOID
RR_WriteDerivedStats(
    VOID
    )
/*++

Routine Description:

    Write derived statistics.

    Calculate stats dervived from basic record counters.
    This routine is called prior to stats dump.

    Caller MUST hold stats lock.

Arguments:

    None.

Return Value:

    None.

--*/
{
}



ULONGLONG
RR_SetTypeInBitmask(
    IN      ULONGLONG       TypeBitmask,
    IN      WORD            wType
    )
/*++

Routine Description:

    Set bit in bitmask corresponding to type.

Arguments:

    TypeBitmask -- type bitmask

    wType - type

Return Value:

    None

--*/
{
    if ( wType < 63 )
    {
        return( TypeBitmask | ((ULONGLONG)1 << wType) );
    }

    return( TypeBitmask | OTHERTYPE_BITMASK_BIT );
}



RR_GENERIC_DISPATCH_FUNCTION
RR_DispatchFunctionForType(
    IN      RR_GENERIC_DISPATCH_TABLE   pTable,
    IN      WORD                        wType
    )
/*++

Routine Description:

    Generic RR dispatch function finder.

Arguments:

Return Value:

    Ptr to dispatch function.
    NULL when not found and default not available.

--*/
{
    RR_GENERIC_DISPATCH_FUNCTION    pfn;
    WORD                            index;

    //
    //  dispatch RR functions
    //      - find in table
    //      - if NO table entry OR index outside table => use default in index 0
    //

    index = INDEX_FOR_TYPE( wType );
    ASSERT( index <= MAX_RECORD_TYPE_INDEX );

    if ( index )
    {
        pfn = pTable[ index ];
    }
    else
    {
        DNS_DEBUG( READ, (
            "WARNING:  Dispatch of unknown record type %d.\n",
            wType ));
        pfn = NULL;
    }

    if ( !pfn )
    {
        pfn = pTable[0];
    }

    return( pfn );
}



//
//  Create common types
//

PDB_RECORD
RR_CreateARecord(
    IN      IP_ADDRESS      ipAddress,
    IN      DWORD           dwTtl,
    IN      DWORD           MemTag
    )
/*++

Routine Description:

    Create A record.

Arguments:

    ipAddress -- IP address for record

    dwTtl -- TTL to set

Return Value:

    Ptr to new A record -- if successful
    NULL on failure.

--*/
{
    PDB_RECORD  prr;

    //
    //  allocate A record
    //

    prr = RR_AllocateEx( (WORD)SIZEOF_IP_ADDRESS, MemTag );
    IF_NOMEM( !prr )
    {
        return( NULL );
    }

    prr->wType = DNS_TYPE_A;
    prr->dwTtlSeconds = dwTtl;
    prr->dwTimeStamp = 0;
    prr->Data.A.ipAddress = ipAddress;

    return( prr );
}



PDB_RECORD
RR_CreatePtr(
    IN      PDB_NAME        pNameTarget,
    IN      LPSTR           pszTarget,
    IN      WORD            wType,
    IN      DWORD           dwTtl,
    IN      DWORD           MemTag
    )
/*++

Routine Description:

    Create new PTR-compatible record.
    Includes PTR, NS, CNAME or other single indirection types.

    For use in default zone create.

Arguments:

    pszTarget -- target name for record

    wType -- type to create

    dwTtl -- TTL

Return Value:

    Ptr to new SOA record.
    NULL on failure.

--*/
{
    PDB_RECORD      prr;
    DNS_STATUS      status;
    COUNT_NAME      nameTarget;

    DNS_DEBUG( INIT, (
        "RR_CreatePtr()\n"
        "\tpszTarget = %s\n"
        "\twType     = %d\n",
        pszTarget,
        wType ));

    //
    //  create dbase name for host name
    //

    if ( !pNameTarget )
    {
        status = Name_ConvertFileNameToCountName(
                    & nameTarget,
                    pszTarget,
                    0 );
        if ( status == ERROR_INVALID_NAME )
        {
            ASSERT( FALSE );
            return( NULL );
        }
        pNameTarget = &nameTarget;
    }

    //
    //  allocate record
    //

    prr = RR_AllocateEx(
                (WORD) Name_LengthDbaseNameFromCountName(pNameTarget),
                MemTag );
    IF_NOMEM( !prr )
    {
        return( NULL );
    }

    //  set header fields
    //      - zone TTL for all auto-create NS, PTR records

    prr->wType = wType;
    prr->dwTtlSeconds = dwTtl;
    prr->dwTimeStamp = 0;

    SET_ZONE_TTL_RR( prr );

    //  copy in target name

    Name_CopyCountNameToDbaseName(
        & prr->Data.PTR.nameTarget,
        pNameTarget );

    IF_DEBUG( INIT )
    {
        Dbg_DbaseRecord(
            "Self-created PTR compatible record:",
            prr );
    }
    return( prr );
}



PDB_RECORD
RR_CreateSoa(
    IN      PDB_RECORD      pExistingSoa,   OPTIONAL
    IN      PDB_NAME        pNameAdmin,
    IN      LPSTR           pszAdmin
    )
/*++

Routine Description:

    Create new SOA.

    For use in default create
        - default zone create of primary by admin
        - default reverse lookup zones
        - default when missing SOA
    And for use overwriting SOA on DS primary.

Arguments:

    pExistingSoa -- existing SOA to use of numeric values, otherwise, using defaults

    pNameAdmin  -- admin name in database format

    pszAdmin    -- admin name in string format

Return Value:

    Ptr to new SOA record.
    NULL on failure.

--*/
{
    DNS_STATUS      status;
    PDB_NAME        pname;
    DB_NAME         namePrimary;
    DB_NAME         nameAdmin;
    DB_NAME         nameDomain;

    PCHAR           pszserverName;
    INT             serverNameLen;
    INT             adminNameLen;
    PCHAR           pszdomainName;
    INT             domainNameLen;
    PBYTE           precordEnd;
    PDB_RECORD      prr;


    DNS_DEBUG( INIT, (
        "RR_CreateSoa()\n"
        "\tpExistingSoa = %p\n"
        "\tpszAdmin     = %s\n",
        pExistingSoa,
        pszAdmin ));

    IF_DEBUG( INIT )
    {
        Dbg_DbaseRecord(
            "Existing SOA:",
            pExistingSoa );
    }

#if 0
    //  switch to using server DBASE name, converted once on boot
    //
    //  read server's host name into dbase name
    //

    status = Name_ConvertFileNameToCountName(
                & namePrimary,
                SrvCfg_pszServerName,
                0 );
    if ( status == DNS_ERROR_INVALID_NAME )
    {
        ASSERT( FALSE );
        return( NULL );
    }
#endif

    //
    //  admin name
    //      - if given as dbase name, use it
    //      - if given existing SOA, use it
    //      - finally build own
    //          - use <AdminEmailName>.<ServerDomainName>
    //          - default admin name if not given
    //

    if ( pNameAdmin )
    {
        // no-op
    }
    else if ( pExistingSoa )
    {
        pNameAdmin = & pExistingSoa->Data.SOA.namePrimaryServer;
        pNameAdmin = Name_SkipDbaseName( pNameAdmin );
    }
    else
    {
        if ( !pszAdmin )
        {
            pszAdmin = DNS_DEFAULT_SOA_ADMIN_NAME;
        }
        Name_ClearDbaseName( &nameAdmin );

        status = Name_AppendDottedNameToDbaseName(
                    & nameAdmin,
                    pszAdmin,
                    0 );
        if ( status != ERROR_SUCCESS )
        {
            ASSERT( FALSE );
            return( NULL );
        }

        //  append dbase name

        status = Name_AppendDottedNameToDbaseName(
                    & nameAdmin,
                    Dns_GetDomainName( SrvCfg_pszServerName ),
                    0 );
        if ( status != ERROR_SUCCESS )
        {
            ASSERT( FALSE );
            return( NULL );
        }

        pNameAdmin = &nameAdmin;
    }

    //
    //  allocate record
    //      - always AUTO-created
    //

    prr = RR_AllocateEx(
                (WORD) ( SIZEOF_SOA_FIXED_DATA +
                        Name_LengthDbaseNameFromCountName(&g_ServerDbaseName) +
                        Name_LengthDbaseNameFromCountName(pNameAdmin) ),
                MEMTAG_RECORD_AUTO );
    IF_NOMEM( !prr )
    {
        return( NULL );
    }

    //
    //  fixed fields
    //      - copy if previous SOA
    //      - otherwise default
    //

    if ( pExistingSoa )
    {
        prr->Data.SOA.dwSerialNo    = pExistingSoa->Data.SOA.dwSerialNo;
        prr->Data.SOA.dwRefresh     = pExistingSoa->Data.SOA.dwRefresh;
        prr->Data.SOA.dwRetry       = pExistingSoa->Data.SOA.dwRetry;
        prr->Data.SOA.dwExpire      = pExistingSoa->Data.SOA.dwExpire;
        prr->Data.SOA.dwMinimumTtl  = pExistingSoa->Data.SOA.dwMinimumTtl;
    }
    else
    {
        prr->Data.SOA.dwSerialNo    = htonl( DEFAULT_SOA_SERIAL_NO );
        prr->Data.SOA.dwRefresh     = htonl( DEFAULT_SOA_REFRESH );
        prr->Data.SOA.dwRetry       = htonl( DEFAULT_SOA_RETRY );
        prr->Data.SOA.dwExpire      = htonl( DEFAULT_SOA_EXPIRE );
        prr->Data.SOA.dwMinimumTtl  = htonl( DEFAULT_SOA_MIN_TTL );
    }

    //  fill in header
    //      - zone TTL for all auto-created SOAs

    prr->wType = DNS_TYPE_SOA;
    RR_RANK( prr ) = RANK_ZONE;
    prr->dwTtlSeconds = prr->Data.SOA.dwMinimumTtl;
    prr->dwTimeStamp = 0;

    SET_ZONE_TTL_RR( prr );

    //
    //  write names to new record
    //      - primary server name
    //      - zone admin name
    //

    pname = &prr->Data.SOA.namePrimaryServer;

    Name_CopyCountNameToDbaseName(
        pname,
        &g_ServerDbaseName );

    pname = Name_SkipDbaseName( pname );

    Name_CopyCountNameToDbaseName(
        pname,
        pNameAdmin );

    IF_DEBUG( INIT )
    {
        Dbg_DbaseRecord(
            "Self-created SOA:",
            prr );
    }
    return( prr );
}

//
//  End record.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\packet.c ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    packet.c

Abstract:

    Packet management.

Author:

    Jim Gilroy,  November 1996

Revision History:

--*/

#include "dnssrv.h"


//
//  Packet allocation / free list
//
//  Maintain a free list of packets to avoid reallocation to service
//  every query.
//
//  Implement as stack using single linked list.
//  List head points at first message.  First field in each message
//  serves as next ptr.  Last points at NULL.
//

PDNS_MSGINFO        g_pPacketFreeListHead;

INT                 g_PacketFreeListCount;

CRITICAL_SECTION    g_PacketListCs;

#define LOCK_PACKET_LIST()      EnterCriticalSection( &g_PacketListCs );
#define UNLOCK_PACKET_LIST()    LeaveCriticalSection( &g_PacketListCs );

#define PACKET_FREE_LIST_LIMIT  (100)


//  Free message indicator

#ifdef _WIN64
#define FREE_MSG_BLINK          ((PLIST_ENTRY) 0xfeebfeebfeebfeeb)
#else
#define FREE_MSG_BLINK          ((PLIST_ENTRY) 0xfeebfeeb)
#endif

#define SET_FREE_MSG(pmsg)      ((pmsg)->ListEntry.Blink = FREE_MSG_BLINK )
#define IS_FREE_MSG(pmsg)       ((pmsg)->ListEntry.Blink == FREE_MSG_BLINK )



VOID
Packet_ListInitialize(
    VOID
    )
/*++

Routine Description:

    Initialize packet list processing.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //  packet free list

    g_pPacketFreeListHead = NULL;
    g_PacketFreeListCount = 0;

    //  packet list lock

    InitializeCriticalSection( &g_PacketListCs );
}



VOID
Packet_ListShutdown(
    VOID
    )
/*++

Routine Description:

    Cleanup packet list for restart.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DeleteCriticalSection( &g_PacketListCs );
}



BOOL
Packet_ValidateFreeMessageList(
    VOID
    )
/*++

Routine Description:

    Validate free message list.

    Makes sure NO packet in list is active.

Arguments:

    pList -- start ptr of message list

Return Value:

    TRUE if successful.
    FALSE otherwise.

--*/
{
    register PDNS_MSGINFO    pMsg;
    INT                      count = 0;

    //
    //  DEVNOTE: should just use packet queuing routines
    //

    LOCK_PACKET_LIST();

    ASSERT( !g_PacketFreeListCount || g_pPacketFreeListHead );
    ASSERT( g_PacketFreeListCount > 0 || ! g_pPacketFreeListHead );

    pMsg = g_pPacketFreeListHead;

    //
    //  check all packets in free list, make sure none queued
    //
    //      - also count to avoid spin on cyclic list
    //

    while ( pMsg )
    {
        MSG_ASSERT( pMsg, IS_FREE_MSG(pMsg) );
        MSG_ASSERT( pMsg, !IS_MSG_QUEUED(pMsg) );
        MSG_ASSERT( pMsg, pMsg->pRecurseMsg == NULL );
        MSG_ASSERT( pMsg, pMsg->pConnection == NULL );
        MSG_ASSERT( pMsg, (PDNS_MSGINFO)pMsg->ListEntry.Flink != pMsg );
        MSG_ASSERT( pMsg, IS_PACKET_FREE_LIST((PDNS_MSGINFO)pMsg) );

        count++;
        ASSERT ( count <= g_PacketFreeListCount );

        pMsg = (PDNS_MSGINFO) pMsg->ListEntry.Flink;
    }

    UNLOCK_PACKET_LIST();

    return( TRUE );
}



//
//  UDP Messages
//

PDNS_MSGINFO
Packet_AllocateUdpMessage(
    VOID
    )
/*++

Routine Description:

    Allocate a UDP packet.

    Use free list if packet available, otherwise heap.

Arguments:

    None.

Return Value:

    Ptr to new message info block, if successful.
    NULL otherwise.

--*/
{
    PDNS_MSGINFO    pMsg;

    LOCK_PACKET_LIST();

    ASSERT( Packet_ValidateFreeMessageList() );

    //
    //  UDP message buffer available on free list?
    //

    if ( g_pPacketFreeListHead )
    {
        ASSERT( g_PacketFreeListCount != 0 );
        ASSERT( IS_DNS_HEAP_DWORD(g_pPacketFreeListHead) );

        pMsg = g_pPacketFreeListHead;
        g_pPacketFreeListHead = *(PDNS_MSGINFO *) pMsg;

        ASSERT( g_pPacketFreeListHead != pMsg );

        g_PacketFreeListCount--;
        STAT_INC( PacketStats.UdpUsed );

        //
        //  if taking off the list, then MUST not be
        //      - in queue
        //      - attached to another query
        //
        //  note:  queuing time serves as flag for ON or OFF queue
        //  no packet should be freed while on queue
        //

        MSG_ASSERT( pMsg, !IS_MSG_QUEUED(pMsg) );
        MSG_ASSERT( pMsg, pMsg->pRecurseMsg == NULL );
        MSG_ASSERT( pMsg, IS_PACKET_FREE_LIST((PDNS_MSGINFO)pMsg) );

        ASSERT( !g_PacketFreeListCount || g_pPacketFreeListHead );
        ASSERT( g_PacketFreeListCount > 0 || ! g_pPacketFreeListHead );

        UNLOCK_PACKET_LIST();
    }

    //
    //  no packets on free list -- create new
    //      - clear lock before ALLOC, to avoid unnecessary contention
    //      - keep stats in lock, alloc failure is death condition

    else
    {
        ASSERT( g_PacketFreeListCount == 0 );

        // JJW: need to store size here since it's no longer fixed
        STAT_INC( PacketStats.UdpAlloc );
        STAT_INC( PacketStats.UdpUsed );
        UNLOCK_PACKET_LIST();

        // pMsg = ALLOC_TAGHEAP( DNS_UDP_ALLOC_LENGTH, MEMTAG_PACKET_UDP );
        pMsg = ALLOC_TAGHEAP(
            DNS_MSG_INFO_HEADER_LENGTH +
                SrvCfg_dwMaxUdpPacketSize +
                50,
            MEMTAG_PACKET_UDP
            );
        IF_NOMEM( !pMsg )
        {
            return( NULL );
        }

        //  on first allocation clear full info blob, to clear baadfood

        RtlZeroMemory(
            (PCHAR) pMsg,
            sizeof( DNS_MSGINFO )
            );
    }

    //
    //  init message
    //      - clear header fields
    //      - set defaults
    //      - for UDP packets we allow the entire packet to be usable
    //

    Packet_Initialize( pMsg,
        DNSSRV_UDP_PACKET_BUFFER_LENGTH,
        SrvCfg_dwMaxUdpPacketSize );
    pMsg->BufferLength = pMsg->MaxBufferLength;
    pMsg->pBufferEnd = ( PCHAR ) DNS_HEADER_PTR( pMsg ) + pMsg->BufferLength;

    ASSERT( !pMsg->fTcp && pMsg->fDelete );

    SET_PACKET_ACTIVE_UDP( pMsg );

    //  packet tracking
    //  no leaks, don't worry about this

    //Packet_AllocPacketTrack( pMsg );

    DNS_DEBUG( HEAP, (
        "Returning new UDP message at %p.\n"
        "\tFree list count = %d.\n",
        pMsg,
        g_PacketFreeListCount ));

    return( pMsg );
}



VOID
Packet_FreeUdpMessage(
    IN      PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Free a standard sized RR.

Arguments:

    pMsg -- RR to free.

Return Value:

    None.

--*/
{
    ASSERT( Mem_HeapMemoryValidate(pMsg) );

    //
    //  skip over message validation for NS list buffers
    //

    if ( ! pMsg->fNsList )
    {
        //  This assert is no longer valid since EDNS allows larger packets.
        //  Perhaps we should replace this with a UDP/TCP flag check instead?
        //  ASSERT( pMsg->BufferLength == DNSSRV_UDP_PACKET_BUFFER_LENGTH );

        //
        //  if freeing, then MUST not be
        //      - in queue
        //      - attached to another query
        //
        //  note:  queuing time serves as flag for ON or OFF queue
        //  no packet should be freed while on queue
        //
        //  DEVNOTE: possible problem with message free on PnP
        //
        //  seen problems with dual message free on PnP;
        //  attempt to minimize likelyhood, by testing if message alread on free
        //  list;  do before and after lock, so we're likely to catch it
        //  if already enlisted BEFORE it goes out and if just being enlisted we
        //  still catch it
        //

        MSG_ASSERT( pMsg, pMsg != g_pPacketFreeListHead );
        MSG_ASSERT( pMsg, !IS_FREE_MSG(pMsg) );
        if ( IS_FREE_MSG(pMsg) )
        {
            DNS_PRINT(( "ERROR:  freeing FREE message %p!!!\n", pMsg ));
            ASSERT( FALSE );
            return;
        }

        MSG_ASSERT( pMsg, !IS_MSG_QUEUED(pMsg) );
        MSG_ASSERT( pMsg, !pMsg->pRecurseMsg );
        MSG_ASSERT( pMsg, !pMsg->pConnection );
    }

    LOCK_PACKET_LIST();

    //  test already-freed condition inside lock, so we don't miss
    //  case where another thread just freed

    MSG_ASSERT( pMsg, pMsg != g_pPacketFreeListHead );
    MSG_ASSERT( pMsg, !IS_FREE_MSG(pMsg) );
    MSG_ASSERT( pMsg, IS_PACKET_ACTIVE_UDP(pMsg) );

    if ( IS_FREE_MSG(pMsg) )
    {
        DNS_PRINT(( "ERROR:  freeing FREE message %p!!!\n", pMsg ));
        UNLOCK_PACKET_LIST();
        return;
    }

    ASSERT( Packet_ValidateFreeMessageList() );

    //  packet tracking
    //  no leaks -- currently disabled
    //Packet_FreePacketTrack( pMsg );

    //
    //  stats
    //

    STAT_INC( PacketStats.UdpReturn );

    if ( pMsg->fRecursePacket )
    {
        STAT_INC( PacketStats.RecursePacketReturn );
    }
    if ( pMsg->Head.IsResponse )
    {
        STAT_INC( PacketStats.UdpResponseReturn );
    }
    else if ( !pMsg->fNsList )
    {
        STAT_INC( PacketStats.UdpQueryReturn );
    }

    //
    //  free list at limit -- free packet
    //      - clear lock before FREE_HEAP to limit contention
    //

    if ( g_PacketFreeListCount >= PACKET_FREE_LIST_LIMIT )
    {
        STAT_INC( PacketStats.UdpFree );
        UNLOCK_PACKET_LIST();

        DNS_DEBUG( HEAP, (
            "UDP message at %p dumped back to heap.\n"
            "\tFree list count = %d.\n",
            pMsg,
            g_PacketFreeListCount ));

        SET_PACKET_FREE_HEAP( pMsg );
        FREE_HEAP( pMsg );
    }

    //
    //  space on free list -- stick message on front of free list
    //      - makes gives us immediate reuse, limiting paging
    //

    else
    {
        SET_FREE_MSG(pMsg);
        SET_PACKET_FREE_LIST( pMsg );

        * (PDNS_MSGINFO *) pMsg = g_pPacketFreeListHead;
        g_pPacketFreeListHead = pMsg;
        g_PacketFreeListCount++;

        ASSERT( !g_PacketFreeListCount || g_pPacketFreeListHead );
        ASSERT( g_PacketFreeListCount > 0 || ! g_pPacketFreeListHead );

        UNLOCK_PACKET_LIST();

        DNS_DEBUG( HEAP, (
            "Stuck UDP message at %p on free list.\n"
            "\tFree list count = %d.\n",
            pMsg,
            g_PacketFreeListCount ));
    }
}



VOID
Packet_WriteDerivedStats(
    VOID
    )
/*++

Routine Description:

    Write derived statistics.

    Calculate stats dervived from basic UDP message counters.
    This routine is called prior to stats dump.

    Caller MUST hold stats lock.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    //  outstanding memory
    //

    PacketStats.UdpNetAllocs = PacketStats.UdpAlloc - PacketStats.UdpFree;

    PacketStats.UdpMemory = PacketStats.UdpNetAllocs * DNS_UDP_ALLOC_LENGTH;
    PERF_SET( pcUdpMessageMemory , PacketStats.UdpMemory );      // PerfMon hook

    //
    //  outstanding packets
    //

    PacketStats.UdpInFreeList = g_PacketFreeListCount;

    PacketStats.UdpInUse = PacketStats.UdpUsed - PacketStats.UdpReturn;

    PacketStats.UdpPacketsForNsListInUse =
            PacketStats.UdpPacketsForNsListUsed -
            PacketStats.UdpPacketsForNsListReturned;
}   //  Packet_WriteDerivedStats



//
//  TCP message allocation
//

PDNS_MSGINFO
Packet_AllocateTcpMessage(
    IN      DWORD   dwMinBufferLength
    )
/*++

Routine Description:

    Allocate TCP message.

    Set up for default TCP message.

Arguments:

    dwMinBufferLength - minimum buffer length to allocate

Return Value:

    Ptr to message info.

--*/
{
    PDNS_MSGINFO    pmsg;
    DWORD           allocLength;

    DNS_DEBUG( TCP, (
        "Tcp_AllocateMessage(), requesting %d bytes\n",
        dwMinBufferLength ));

    //
    //  Allocate No specified length, allocate default
    //

    if ( !dwMinBufferLength )
    {
        dwMinBufferLength = DNS_TCP_DEFAULT_PACKET_LENGTH;
    }
    allocLength = DNS_MSG_INFO_HEADER_LENGTH + dwMinBufferLength;

    pmsg = ALLOC_TAGHEAP( allocLength, MEMTAG_PACKET_TCP );
    IF_NOMEM( ! pmsg )
    {
        DNS_PRINT((
            "ERROR:  failure to alloc %d byte TCP buffer.\n",
            dwMinBufferLength ));
        return( NULL );
    }

    //
    //  init message
    //      - clear header fields
    //      - set defaults
    //      - set for TCP
    //

    Packet_Initialize( pmsg, dwMinBufferLength, dwMinBufferLength );

    pmsg->fTcp = TRUE;
    SET_PACKET_ACTIVE_TCP( pmsg );

    ASSERT( (PCHAR)pmsg + allocLength > pmsg->pBufferEnd );

    //  packet tracking
    //  no leak so not active
    //Packet_AllocPacketTrack( pmsg );

    //  record stats

    STAT_INC( PacketStats.TcpAlloc );
    STAT_INC( PacketStats.TcpNetAllocs );
    STAT_ADD( PacketStats.TcpMemory, allocLength );
    PERF_ADD( pcTcpMessageMemory, allocLength );

    return( pmsg );
}



PDNS_MSGINFO
Packet_ReallocateTcpMessage(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      DWORD           dwMinBufferLength
    )
/*++

Routine Description:

    Reallocate TCP message.

Arguments:

    pMsg - message info buffer to receive packet

    dwMinBufferLength - minimum buffer length to allocate

Return Value:

    New message buffer.

--*/
{
    PDNS_MSGINFO    pmsgOld = pMsg;
    DWORD           bufferLength;

    ASSERT( pMsg );
    ASSERT( pMsg->fTcp );
    ASSERT( dwMinBufferLength > pMsg->BufferLength );

    //
    //  Determine allocation size,
    //

    bufferLength = DNS_TCP_DEFAULT_ALLOC_LENGTH;

    if ( dwMinBufferLength > DNS_TCP_DEFAULT_PACKET_LENGTH )
    {
        bufferLength = DNS_TCP_REALLOC_LENGTH;
    }

    DNS_DEBUG( TCP, (
        "Tcp_ReallocateMessage(), pMsg at %p\n"
        "\texisting length  = %d.\n"
        "\trequesting       = %d.\n"
        "\tallocating       = %d.\n",
        pMsg,
        pMsg->BufferLength,
        dwMinBufferLength,
        bufferLength ));


    pMsg = REALLOCATE_HEAP(
                pMsg,
                (INT) bufferLength );
    IF_NOMEM( pMsg == NULL )
    {
        DNS_PRINT((
            "ERROR:  failure to realloc %d byte buffer for\n"
            "\texisting message at %p.\n",
            bufferLength,
            pMsg ));

        //  failed reallocing to answer query
        //  if have received message, respond with SERVER_FAILURE
        //  normal timeout cleanup on socket and connection

        if ( ! pmsgOld->pchRecv )
        {
            ASSERT( ! pmsgOld->pConnection );
            ASSERT( pmsgOld->fMessageComplete );
            Reject_Request(
                pmsgOld,
                DNS_RCODE_SERVER_FAILURE,
                0 );
        }

        //  failed getting another message on existing connection
        //      - need to disassociate message and connection
        //      - call deletes everything -- connection, socket, buffer

        else if ( pmsgOld->pConnection )
        {
            ASSERT( ((PDNS_SOCKET)pmsgOld->pConnection)->pMsg
                            == pmsgOld );
            Tcp_ConnectionDeleteForSocket( pmsgOld->Socket, NULL );
        }

        //  failed getting message buffer on first query
        //  so connection does not yet exist
        //  closing socket, dump buffer

        else
        {
            Sock_CloseSocket( pmsgOld->Socket );
            FREE_HEAP( pmsgOld );
        }
        return( NULL );
    }

    //  record stats

    STAT_INC( PacketStats.TcpRealloc );
    STAT_ADD( PacketStats.TcpMemory, (bufferLength - pMsg->BufferLength) );
    PERF_ADD( pcTcpMessageMemory ,
            (bufferLength - pMsg->BufferLength) );      //PerfMon hook

    //  set new buffer (packet) length

    pMsg->BufferLength = bufferLength - DNS_MSG_INFO_HEADER_LENGTH;
    pMsg->pBufferEnd = (PCHAR)DNS_HEADER_PTR(pMsg) + pMsg->BufferLength;
    ASSERT( IS_DWORD_ALIGNED(pMsg->pBufferEnd) );

    //
    //  if new buffer
    //      - reset self-referential pointers
    //      - reset connection info to point at new message buffer
    //

    if ( pMsg != pmsgOld )
    {
        INT_PTR delta = (PCHAR)pMsg - (PCHAR)pmsgOld;

        SET_MESSAGE_FIELDS_AFTER_RECV( pMsg );
        pMsg->pQuestion = (PDNS_QUESTION) ((PCHAR)pMsg->pQuestion + delta);
        pMsg->pCurrent += delta;

        if ( pMsg->pchRecv )
        {
            pMsg->pchRecv += delta;
        }
        if ( pMsg->pConnection )
        {
            Tcp_ConnectionUpdateForPartialMessage( pMsg );
            ASSERT( ((PDNS_SOCKET)pMsg->pConnection)->pMsg == pMsg );
        }
    }

    IF_DEBUG( TCP )
    {
        DNS_PRINT((
            "Reallocated TCP message at %p:\n"
            "\tnew=%p, new length\n"
            "\texisting message at %p.\n",
            pmsgOld,
            pMsg,
            bufferLength ));

        //  existing query reallocated print it out

        if ( ! pMsg->pchRecv )
        {
            Dbg_DnsMessage(
                "New Reallocated query response",
                pMsg );
        }
    }
    return( pMsg );
}



VOID
Packet_FreeTcpMessage(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Free a standard sized RR.

Arguments:

    pMsg -- RR to free.

Return Value:

    None.

--*/
{
    //
    //  Never allocate TCP message of standard size.
    //  UDP messages switched to TCP (TCP cursive queries)
    //      are always flipped back to UDP for free
    //
    //  note, this is NOT necessary, as packets are atomic heap allocations
    //      but it is more efficient
    //

    //
    //  note, there is oddball case where switch message to TCP for recursion
    //      to remote DNS was NOT completed, before original query timed out
    //      of the recursion queue;  packet then freed as TCP
    //

    //ASSERT( pMsg->BufferLength != DNSSRV_UDP_PACKET_BUFFER_LENGTH );

    ASSERT( IS_PACKET_ACTIVE_TCP(pMsg) ||
            IS_PACKET_ACTIVE_UDP(pMsg) );

    if ( pMsg->BufferLength == DNSSRV_UDP_PACKET_BUFFER_LENGTH &&
         IS_PACKET_ACTIVE_UDP(pMsg) )
    {
        DNS_DEBUG( ANY, (
            "UDP Packet %p came down TCP free pipe -- freeing via UDP routine.\n",
            pMsg ));
        Packet_FreeUdpMessage( pMsg );
        return;
    }

    //  verify recursion message cleaned up

    ASSERT( pMsg->pRecurseMsg == NULL );

    //  Queuing time serves as flag for ON or OFF queue
    //  no packet should be freed while on queue

    ASSERT( pMsg->dwQueuingTime == 0 );

    //  record stats

    STAT_INC( PacketStats.TcpFree );
    STAT_DEC( PacketStats.TcpNetAllocs );
    STAT_SUB( PacketStats.TcpMemory, (pMsg->BufferLength + DNS_MSG_INFO_HEADER_LENGTH) );
    PERF_SUB( pcTcpMessageMemory ,
                (pMsg->BufferLength + DNS_MSG_INFO_HEADER_LENGTH) );

    //  packet tracking
    //  no leak -- currently disabled
    //Packet_FreePacketTrack( pMsg );

    SET_PACKET_FREE_HEAP( pMsg );
    FREE_HEAP( pMsg );
}



//
//  Global packet routines -- not UDP or TCP specific.
//
//  This routine is used throughout the rest of the code for freeing
//  packets.  The specific TCP and UDP routines should NEVER be used
//  and hence are not made public.
//

VOID
FASTCALL
Packet_Initialize(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      DWORD           dwUsableBufferLength,
    IN      DWORD           dwMaxBufferLength
    )
/*++

Routine Description:

    Standard initialization on a packet.

    Clear all flag fields, set buffer pointers.

Arguments:

    pMsg -- message to init

Return Value:

    None

--*/
{
    PDNS_MSGINFO    pmsg;

    //
    //  clear header fields
    //      - clear from start all the way to additional blob
    //      - don't clear additional and compression for perf
    //      (a few cleared fields inits them below)
    //

    RtlZeroMemory(
        (PCHAR) pMsg,
        ( (PCHAR)&pMsg->Additional - (PCHAR)pMsg )
        );

    //
    //  set basic packet info
    //

    pMsg->MaxBufferLength   = dwMaxBufferLength;
    pMsg->BufferLength      = dwUsableBufferLength;
    pMsg->pBufferEnd        = (PCHAR)DNS_HEADER_PTR(pMsg) + pMsg->BufferLength;

    //  lookup name will follow packet

    pMsg->pLooknameQuestion = (PLOOKUP_NAME) pMsg->pBufferEnd;

    ASSERT( IS_DWORD_ALIGNED(pMsg->pBufferEnd) );

    //  handy markers for debugging

    pMsg->FlagMarker    = PACKET_FLAG_MARKER;
    pMsg->UnionMarker   = PACKET_UNION_MARKER;

    //  init additional info and compression

    INITIALIZE_ADDITIONAL( pMsg );
    INITIALIZE_COMPRESSION( pMsg );

    //  default to delete on send

    pMsg->fDelete = TRUE;

    //  address length
    //  need to set for both TCP and UDP as TCP response can be flipped
    //      or to UDP to forward to client

    pMsg->RemoteAddressLength = sizeof(SOCKADDR_IN);

    //  packet tracking
    //  no current leaks, so this is off
    //Packet_AllocPacketTrack( pMsg );

    DNS_DEBUG( HEAP, (
        "Initialized new message buffer at %p (usable len=%d, max len=%d).\n",
        pMsg,
        pMsg->BufferLength,
        pMsg->MaxBufferLength ));
}



VOID
Packet_Free(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Free message info structure.

    Includes free of allocated sub-structures.

    This is the global "free a message" routine -- specific TCP \ UDP
    routines should NOT be used.

Arguments:

    pMsg -- message to free

Return Value:

    None.

--*/
{
    PDNS_MSGINFO    precurse;

    //  catch free of queued or freed messages

    MSG_ASSERT( pMsg, pMsg != g_pPacketFreeListHead );
    MSG_ASSERT( pMsg, !IS_FREE_MSG(pMsg) );
    MSG_ASSERT( pMsg, !IS_MSG_QUEUED(pMsg) );

    //
    //  free recursion message?
    //
    //  verify we're freeing original query, not freeing recursive
    //  query, as message it points back to may still be in use
    //
    //  note:  recursion message should always be UDP sized, even if
    //      recursed using TCP connection
    //

    MSG_ASSERT( pMsg, !pMsg->fRecursePacket );

    precurse = pMsg->pRecurseMsg;
    if ( precurse )
    {
        MSG_ASSERT( precurse, precurse != pMsg );
        MSG_ASSERT( precurse, precurse->pRecurseMsg == pMsg );
        MSG_ASSERT( precurse, precurse->fRecursePacket );
        MSG_ASSERT( precurse, ! precurse->pConnection );
#if DBG
        //  break cross-link to allow check if direct use of underlying routines

        pMsg->pRecurseMsg = NULL;
        precurse->pRecurseMsg = NULL;
        precurse->fTcp = FALSE;
        //  EDNS: buffer length is no longer always equal to UDP size!
        //  ASSERT( precurse->BufferLength == DNSSRV_UDP_PACKET_BUFFER_LENGTH );
#endif
        Packet_FreeUdpMessage( precurse );
    }

    //
    //  remote NS list
    //

    if ( pMsg->pNsList )
    {
        Remote_NsListCleanup( pMsg );
        pMsg->pNsList = NULL;
    }

    //
    //  free message itself
    //

    if ( pMsg->fTcp )
    {
        Packet_FreeTcpMessage( pMsg );
    }
    else
    {
        Packet_FreeUdpMessage( pMsg );
    }
}




//
//  Debug packet tracking
//

#if DBG
LIST_ENTRY  PacketTrackListHead;

//  max time processing should take -- 10 minutes

#define MAX_PACKET_PROCESSING_TIME  (600)


DWORD   PacketTrackViolations;
DWORD   PacketTrackListLength;

PDNS_MSGINFO    pLastViolator;



VOID
Packet_InitPacketTrack(
    VOID
    )
/*++

Routine Description:

    Track packets.

Arguments:

    pMsg -- new message

Return Value:

    None.

--*/
{
    InitializeListHead( &PacketTrackListHead );

    PacketTrackViolations = 0;
    PacketTrackListLength = 0;
    pLastViolator = NULL;
}



VOID
Packet_AllocPacketTrack(
    IN      PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Track packets.

Arguments:

    pMsg -- new message

Return Value:

    None.

--*/
{
    //  use UDP message alloc lock

    LOCK_PACKET_LIST();

    //
    //  check list entry
    //

    if ( !IsListEmpty(&PacketTrackListHead) )
    {
        PDNS_MSGINFO    pfront;

        pfront = (PDNS_MSGINFO)
                    ( (PCHAR)pMsg - (PCHAR)&pMsg->DbgListEntry +
                    (PCHAR) PacketTrackListHead.Flink );

        if ( pfront != pLastViolator &&
            pfront->dwQueryTime + MAX_PACKET_PROCESSING_TIME < DNS_TIME() )
        {
            //  DEVNOTE: there's a problem here in that this packet may be 
            //      operational on another thread this could cause 
            //      changes in packet even as print takes place

            IF_DEBUG( OFF )
            {
                Dbg_DnsMessage(
                    "Message exceeded max processing time:",
                    pfront );
                //ASSERT( FALSE );
            }
            IF_DEBUG( ANY )
            {
                DNS_PRINT((
                    "WARNING:  Packet tracking violation %ds on packet %p\n"
                    "\ttotal violations     = %d\n"
                    "\tcurrent list length  = %d\n",
                    MAX_PACKET_PROCESSING_TIME,
                    pfront,
                    PacketTrackViolations,
                    PacketTrackListLength ));
            }
            PacketTrackViolations++;
            pLastViolator = pfront;
        }
    }

    //
    //  queue up new message
    //

    pMsg->dwQueryTime = DNS_TIME();

    RtlZeroMemory(
        & pMsg->Head,
        sizeof( DNS_HEADER ) );

    InsertTailList( &PacketTrackListHead, &pMsg->DbgListEntry );

    PacketTrackListLength++;
    UNLOCK_PACKET_LIST();
}



VOID
Packet_FreePacketTrack(
    IN      PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Track packets.

Arguments:

    pMsg -- freed message

Return Value:

    None.

--*/
{
    LOCK_PACKET_LIST();
    RemoveEntryList( &pMsg->DbgListEntry );
    PacketTrackListLength--;
    UNLOCK_PACKET_LIST();
}
#endif


//
//  End packet.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\packetq.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    packetq.c

Abstract:

    Domain Name System (DNS) Server

    Packet queue routines.

Author:

    Jim Gilroy (jamesg)     August 2, 1995

Revision History:

--*/


#include "dnssrv.h"

//
//  Queuing flag -- for debug
//
//  use queuing time as flag, for ON or OFF the queue
//  only use QUEUED macro where not otherwise setting flag
//

#if DBG
#define SET_MSG_DEQUEUED(pMsg)  ( (pMsg)->dwQueuingTime = 0 )
#define SET_MSG_QUEUED(pMsg)    ( (pMsg)->dwQueuingTime = 1 )

#else   // retail

#define SET_MSG_DEQUEUED(pMsg)
#define SET_MSG_QUEUED(pMsg)
#endif


//
//  Private queues -- extern here for debug purposes
//

extern  PPACKET_QUEUE   g_pWinsQueue;
extern  PPACKET_QUEUE   g_UpdateForwardingQueue;
extern  PPACKET_QUEUE   pNbstatPrivateQueue;


//
//  Implementation note:
//
//  Packets are enqueued at tail.
//
//  For straight in order queuing, this means we dequeue from the front.
//
//  For XID and time stamped packets, this means oldest packets are
//  at front, and XID and times grow toward back of list.  This also means
//  that the timed out packets accumulate at the front of the queue, and
//  searching for new matching responses is best done from the rear
//  of the queue.
//



VOID
PQ_DiscardDuplicatesOfNewPacket(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsgNew,
    IN      BOOL            fAlreadyLocked
    )
/*++

Routine Description:

    Discard duplicate packets on queuing.

    Kills off any duplicate packets in the queue.
    Packets that are dequeued are discarded.

Arguments:

    pQueue -- packet queue to stick packet on

    pMsgNew -- message being queued

    fAlreadyLocked -- TRUE if queue already locked

Return Value:

    None.

--*/
{
    PDNS_MSGINFO    pmsg;

    //  quick escape if queue empty, before locking

    if ( pQueue->cLength == 0 )
    {
        return;
    }

    //
    //  loop through queue and delete any duplicates of packet being queued
    //
    //  note:  if we find one, we're done as any previous queuing should have
    //      squashed any previous duplicate message;
    //      this does allow the queue to have dups, if we requeue a message
    //      without doing this check
    //
    //  DEVNOTE: it would be cool to leave messages ON the queue while
    //      being processed, so that we could do this check and kill all
    //      dups -- especially for update, but also for recursion
    //
    //      however, then we'd need to have an in-use flag, and have
    //      some sort of dequeue on send flag
    //

    if ( !fAlreadyLocked )
    {
        LOCK_QUEUE(pQueue);
    }

    pmsg = (PDNS_MSGINFO) pQueue->listHead.Flink;

    while ( (PLIST_ENTRY)pmsg != &pQueue->listHead )
    {
        if ( pmsg->RemoteAddress.sin_addr.s_addr ==
                                    pMsgNew->RemoteAddress.sin_addr.s_addr &&
            pmsg->RemoteAddress.sin_port == pMsgNew->RemoteAddress.sin_port &&
            pmsg->MessageLength == pMsgNew->MessageLength &&
            RtlEqualMemory(
                & pmsg->Head,
                & pMsgNew->Head,
                pmsg->MessageLength ) )
        {
            pQueue->cDequeued++;
            pQueue->cLength--;

            DNS_DEBUG( UPDATE, (
                "Discarding duplicate of new packet in queue %s.\n"
                "\tremote IP    = %s\n"
                "\tremote port  = %d\n"
                "\tXID          = %d\n",
                pQueue->pszName,
                IP_STRING( pmsg->RemoteAddress.sin_addr.s_addr ),
                pmsg->RemoteAddress.sin_port,
                pmsg->Head.Xid
                ));

            RemoveEntryList( (PLIST_ENTRY)pmsg );
            SET_MSG_DEQUEUED( pmsg );
            Packet_Free( pmsg );
            break;
        }
        pmsg = (PDNS_MSGINFO) ((PLIST_ENTRY)pmsg)->Flink;
        continue;
    }

    if ( !fAlreadyLocked )
    {
        UNLOCK_QUEUE(pQueue);
    }
}



VOID
PQ_DiscardExpiredQueuedPackets(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN      BOOL            fAlreadyLocked
    )
/*++

Routine Description:

    Discard stale packets.

    This utility is designed to be used in both queuing\dequeuing
    operations to suppress growth of a queue (ex. update queue)
    that collects packets for a potentially long interval.
    Assumes we hold lock on given queue.

    Packets that are dequeued are discarded.

Arguments:

    pQueue -- packet queue to stick packet on

    fAlreadyLocked -- TRUE if queue already locked

Return Value:

    None.

--*/
{
    PDNS_MSGINFO    pmsg;
    PDNS_MSGINFO    pmsgNext;
    DWORD           expireTime;

    //  quick escape if queue empty, before locking

    if ( pQueue->cLength == 0 )
    {
        return;
    }

    //  calculate last valid packet time

    expireTime = DNS_TIME() - pQueue->dwDefaultTimeout;

    //
    //  loop through queue and delete all packets which we're queued
    //      before a given time
    //

    if ( !fAlreadyLocked )
    {
        LOCK_QUEUE(pQueue);
    }

    pmsg = (PDNS_MSGINFO) pQueue->listHead.Flink;

    DNS_DEBUG( UPDATE, (
        "Queue %s discard packet check.\n"
        "\tqueue length         = %d\n"
        "\texpire time          = %d\n"
        "\tfirst msg query time = %d\n",
        pQueue->pszName,
        pQueue->cLength,
        expireTime,
        ( (PLIST_ENTRY)pmsg != &pQueue->listHead )
            ? pmsg->dwQueryTime : 0
        ));

    while ( (PLIST_ENTRY)pmsg != &pQueue->listHead )
    {
        //  dump stale packets

        if ( pmsg->dwQueryTime < expireTime )
        {
            pQueue->cDequeued++;
            pQueue->cTimedOut++;
            pQueue->cLength--;

            pmsgNext = (PDNS_MSGINFO) ((PLIST_ENTRY)pmsg)->Flink;
            RemoveEntryList( (PLIST_ENTRY)pmsg );
            SET_MSG_DEQUEUED( pmsg );
            Packet_Free( pmsg );
            pmsg = pmsgNext;
            continue;
        }

        //  packets are queued in order, when reach non-timed-out
        //  packet, we are done

        break;
    }

    if ( !fAlreadyLocked )
    {
        UNLOCK_QUEUE(pQueue);
    }
}



VOID
PQ_QueuePacketToListWithLock(
    IN OUT  PLIST_ENTRY         pList,
    IN OUT  PCRITICAL_SECTION   pLock,
    IN OUT  PDNS_MSGINFO        pMsg
    )
/*++

Routine Description:

    Enqueue packet.

Arguments:

    pList -- list head

    pLock -- ptr to CS to use as lock, this may be borrowed from
                another queue

    pMsg -- packet to enqueue

Return Value:

    None.

--*/
{
    //
    //  insert packet in queue at tail
    //

    EnterCriticalSection( pLock );

    InsertTailList( pList, ( PLIST_ENTRY ) pMsg );

    MSG_ASSERT( pMsg, !IS_MSG_QUEUED(pMsg) );
    SET_MSG_QUEUED(pMsg);

    LeaveCriticalSection( pLock );
}



VOID
PQ_QueuePacket(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Enqueue packet.

Arguments:

    pQueue -- packet queue to stick packet on

    pMsg -- packet to enqueue

Return Value:

    None.

--*/
{
    //
    //  insert packet in queue
    //

    LOCK_QUEUE(pQueue);

    InsertTailList( &pQueue->listHead, ( PLIST_ENTRY ) pMsg );

    pQueue->cQueued++;
    pQueue->cLength++;

    MSG_ASSERT( pMsg, !IS_MSG_QUEUED(pMsg) );
    SET_MSG_QUEUED(pMsg);

    UNLOCK_QUEUE(pQueue);
}



VOID
PQ_QueuePacketSetEvent(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Enqueue packet and set event.

Arguments:

    pQueue -- packet queue to stick packet on

    pMsg -- packet to enqueue

Return Value:

    None.

--*/
{
    //
    //  insert packet in queue
    //

    LOCK_QUEUE(pQueue);

    InsertTailList( &pQueue->listHead, ( PLIST_ENTRY ) pMsg );

    pQueue->cQueued++;
    pQueue->cLength++;

    MSG_ASSERT( pMsg, !IS_MSG_QUEUED(pMsg) );
    SET_MSG_QUEUED(pMsg);

    UNLOCK_QUEUE(pQueue);

    //
    //  set event indicating packet on queue
    //  do this after leaving CS;  this does occasionally
    //  cause unnecessary thread wakeup when queue has just been
    //  emptied, but I think this is less costly then setting
    //  event inside CS, which will often result in having threads
    //  wake, then immediately block on CS
    //

    SetEvent( pQueue->hEvent );
}



VOID
PQ_QueuePacketEx(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      BOOL            fAlreadyLocked
    )
/*++

Routine Description:

    Enqueue packet and set event.
    Packet queue kept sorted by query time.

    This is necessary for update to insure in-order execution of
    updates, even if packets must be requeued.

Arguments:

    pQueue -- packet queue to stick packet on

    pMsg -- packet to enqueue

    fAlreadyLocked -- TRUE if queue already locked by caller

Return Value:

    None.

--*/
{
    if ( !fAlreadyLocked )
    {
        LOCK_QUEUE( pQueue );
    }

    //
    //  scrub queue -- eliminate expired and duplicate packets from queue?
    //      - update queue has these flags set
    //

    if ( pQueue->fDiscardExpiredOnQueuing )
    {
        PQ_DiscardExpiredQueuedPackets(
            pQueue,
            TRUE        // queue already locked
            );
    }
    if ( pQueue->fDiscardDuplicatesOnQueuing )
    {
        PQ_DiscardDuplicatesOfNewPacket(
            pQueue,
            pMsg,
            TRUE        // queue already locked
            );
    }

    DNS_DEBUG( UPDATE, (
        "PQ_QueuePacketEx in queue %s.\n"
        "\tpMsg         = %p\n"
        "\tquery time   = %d\n"
        "\tcurrent time = %d\n",
        pQueue->pszName,
        pMsg,
        pMsg->dwQueryTime,
        DNS_TIME() ));

    //
    //  queuing in query time order?
    //  this option is necessary for update to insure in-order execution
    //      of updates
    //

    if ( pQueue->fQueryTimeOrder )
    {
        PDNS_MSGINFO    pmsgQueued;
        DWORD           queryTime = pMsg->dwQueryTime;

        pmsgQueued = (PDNS_MSGINFO) pQueue->listHead.Blink;

        while ( (PLIST_ENTRY)pmsgQueued != &pQueue->listHead )
        {
            //  if packet is older than ours, stop
            //      correct positions is immediately behind this packet

            if ( pmsgQueued->dwQueryTime <= queryTime )
            {
                break;
            }
            pmsgQueued = (PDNS_MSGINFO) ((PLIST_ENTRY)pmsgQueued)->Blink;
        }

        InsertHeadList( ( PLIST_ENTRY ) pmsgQueued, ( PLIST_ENTRY ) pMsg );
    }

    //  otherwise simple queuing at back

    else
    {
        InsertTailList( &pQueue->listHead, (PLIST_ENTRY)pMsg );
    }

    pQueue->cQueued++;
    pQueue->cLength++;

    MSG_ASSERT( pMsg, !IS_MSG_QUEUED(pMsg) );
    SET_MSG_QUEUED(pMsg);

    if ( !fAlreadyLocked )
    {
        UNLOCK_QUEUE( pQueue );
    }

    //
    //  set event indicating packet on queue
    //  do this after leaving CS;  this does occasionally
    //  cause unnecessary thread wakeup when queue has just been
    //  emptied, but I think this is less costly then setting
    //  event inside CS, which will often result in having threads
    //  wake, then immediately block on CS
    //

    if ( pQueue->hEvent )
    {
        SetEvent( pQueue->hEvent );
    }
}



PDNS_MSGINFO
PQ_DequeueNextPacket(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN      BOOL            fAlreadyLocked
    )
/*++

Routine Description:

    Dequeue next packet from queue.

Arguments:

    pQueue -- packet queue to stick packet on

    fAlreadyLocked -- TRUE if queue already locked by caller

Return Value:

    Ptr to message at head of list.

--*/
{
    PDNS_MSGINFO     pmsg;

    //
    //  grab head packet on queue -- if any
    //

    if ( !fAlreadyLocked )
    {
        LOCK_QUEUE( pQueue );
    }

    pmsg = (PDNS_MSGINFO) pQueue->listHead.Flink;

    if ( (PLIST_ENTRY)pmsg == &pQueue->listHead )
    {
        pmsg = NULL;
    }
    else
    {
        pQueue->cDequeued++;
        pQueue->cLength--;

        RemoveEntryList( (PLIST_ENTRY)pmsg );
        MSG_ASSERT( pmsg, IS_MSG_QUEUED(pmsg) );
        SET_MSG_DEQUEUED(pmsg);
    }

    if ( !fAlreadyLocked )
    {
        UNLOCK_QUEUE( pQueue );
    }

    return( pmsg );
}



VOID
PQ_YankQueuedPacket(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Yank packet from queue.

    By yank, we mean that packet is pulled from queue without any check as
    to whether it is on queue.  Caller must "know" that packet was put on queue
    and has not been dequeued.

Arguments:

    pQueue -- packet queue to remove packet from

    pMsg -- packet to yank from queue

Return Value:

    None.

--*/
{
    LOCK_QUEUE(pQueue);

    RemoveEntryList( &pMsg->ListEntry );

    //  treat as if packet never on queue

    pQueue->cLength--;
    pQueue->cQueued--;

    MSG_ASSERT( pMsg, IS_MSG_QUEUED(pMsg) );
    SET_MSG_DEQUEUED(pMsg);

    UNLOCK_QUEUE(pQueue);
}



//
//  Special XID queuing routines
//

WORD
PQ_QueuePacketWithXid(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Enqueue packet.

Arguments:

    pQueue -- packet queue to stick packet on

    pMsg -- packet to enqueue

    Note:  may set dwExpireTime, to a timeout interval for this packet
    different from default.  If so this timeout will be used.

Return Value:

    XID for packet on the queue.

--*/
{
    DWORD   currentTime;
    WORD    xid;

    //
    //  Place the request on the queue.
    //
    //  MUST do this before send, so packet is guaranteed to be in
    //  queue when get response.
    //
    //  Optionally get XID -- also protected by CS.
    //

    //
    //  set current time \ expire time in packet
    //      - save if FIRST query time for packet
    //

    currentTime = DNS_TIME();

    //  use queuing time as flag for ON or OFF queue
    ASSERT( pMsg->dwQueuingTime == 0 );

    pMsg->dwQueuingTime = currentTime;

    if ( !pMsg->dwQueryTime )
    {
        pMsg->dwQueryTime = currentTime;
    }

    //
    //  if dwExpireTime given, treat it as an override of the default
    //      timeout
    //

    if ( pMsg->dwExpireTime )
    {
        //  track minimum possible timeout in queue, to speed up
        //  finding timed out packets in queue

        if ( pMsg->dwExpireTime < pQueue->dwMinimumTimeout )
        {
            pQueue->dwMinimumTimeout = pMsg->dwExpireTime;
        }
        pMsg->dwExpireTime += currentTime;
    }
    else
    {
        pMsg->dwExpireTime = currentTime + pQueue->dwDefaultTimeout;    //  entry timeout length
    }

    //  Sanity check: expire time less than 5 minutes!
    ASSERT( pMsg->dwExpireTime - currentTime < 300 );

    DNS_DEBUG( MSGTIMEOUT, (
        "queuing msg %p in queue %s(%p) expire %d curr %d (%d)\n",
        pMsg,
        pQueue->pszName,
        pQueue,
        pMsg->dwExpireTime,
        currentTime,
        pMsg->dwExpireTime - currentTime ));

    //
    //  Lock the queue. Do XID generation inside lock because we use the queue's
    //  wXid member as part of the random portion for the new XID.
    //

    LOCK_QUEUE( pQueue );

    //
    //  set XID, if none specified
    //
    //  caller can use this in any fashion, just so consistent between
    //  between sending and what receiver sends to packet matching routine
    //
    //  setting this completely here, so avoid touching query after
    //  queuing, which is invalid if queries are outstanding with
    //  might dequeue the packet
    //

    xid = pMsg->wQueuingXid;

    if ( !xid )
    {
        //  for recursion, generate "apparently random" XID
        //      - random portion from hashing up ptr and time
        //      - sequential portion to insure that XID even under "bizzarro" conditions
        //      does not wrap in reasonable time interval
        //
        //  for WINS, use serial XID
        //
        //  WINS server does a poor job of throwing out old entries, but it does
        //  throw out matching XID from the same IP, so XIDs MUST stay unique for a
        //  relatively long period (up to minutes) of time;  since WINS is more of
        //  an intranet issue, less exposed to security attacks, we can go with
        //  serial XID

        xid = pQueue->wXid++;

        if ( pQueue == g_pRecursionQueue )
        {
            DWORD   randomPart = 
                        ( xid *
                        ( currentTime +
                        ( ( DWORD ) ( ULONG_PTR ) pMsg >> ( xid & 0x7 ) ) ) );

#if 1
            DNS_DEBUG( RECURSE, (
                "RECURSION XID: base=0x%04X now=0x%04X msg=0x%08X tmp=0x%04X\n"
                "RECURSION XID: seq=0x%04X rnd=0x%04X seq+rnd=0x%04X final=0x%04X\n",
                xid,
                currentTime,
                ( DWORD ) ( ULONG_PTR ) pMsg,
                randomPart,
                XID_SEQUENTIAL_MAKE( xid ),
                XID_RANDOM_MAKE( ( WORD ) randomPart ),
                XID_SEQUENTIAL_MAKE( xid ) | XID_RANDOM_MAKE( ( WORD ) randomPart ),
                MAKE_RECURSION_XID( XID_SEQUENTIAL_MAKE( xid ) |
                    XID_RANDOM_MAKE( ( WORD ) randomPart ) ) ));
#endif

            xid = XID_SEQUENTIAL_MAKE( xid ) | XID_RANDOM_MAKE( ( WORD ) randomPart );
            xid = MAKE_RECURSION_XID( xid );
        }
        else if ( pQueue == g_pWinsQueue )
        {
            xid = MAKE_WINS_XID( xid );
        }

#if DBG
        //  other queues which use this function do NOT munge XID

        else if ( pQueue == g_UpdateForwardingQueue )
        {
            MSG_ASSERT( pMsg, pMsg->Head.Opcode == DNS_OPCODE_UPDATE );
        }
        else if ( pQueue == pNbstatPrivateQueue )
        {
            MSG_ASSERT( pMsg, pMsg->U.Nbstat.pNbstat );
        }
        else
        {
            MSG_ASSERT( pMsg, FALSE );
        }
#endif
        pMsg->wQueuingXid = xid;
    }

    #if 0   //  #if DBG
    {
        //
        //  Search the queue for an XID the same as the one we're queuing.
        //  This is expensive so we probably shouldn't do it in retail,
        //  but I'm interested to see if stress will trigger this.
        //
    
        PDNS_MSGINFO    pRover = (PDNS_MSGINFO) pQueue->listHead.Blink;

        while ( ( PLIST_ENTRY ) pRover != &pQueue->listHead )
        {
            ASSERT( pRover->wQueuingXid != pMsg->wQueuingXid );
            pRover = ( PDNS_MSGINFO ) ( ( PLIST_ENTRY ) pRover )->Blink;
        }
    }
    #endif

    //
    //  Insert packet at tail of queue. Dequeue function checks backwards 
    //  from tail so it will checking most recent packets first.
    //

    InsertTailList( &pQueue->listHead, ( PLIST_ENTRY ) pMsg );

    pQueue->cQueued++;
    pQueue->cLength++;

    UNLOCK_QUEUE(pQueue);

    return xid;
}   //  PQ_QueuePacketWithXid



DNS_STATUS
PQ_QueuePacketWithXidAndSend(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Enqueue packet and send.

Arguments:

    pQueue -- packet queue to stick packet on

    pMsg -- packet to enqueue

    Note:  may set dwExpireTime, to a timeout interval for this packet
    different from default.  If so this timeout will be used.

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode from Send_Message() if error.

--*/
{
    DNS_STATUS  status;

    //
    //  Must hold CS around both queuing and send
    //
    //  Packet must be on queue before send, so that quick response is
    //  properly handled.  And must send before releasing CS, so that
    //  packet can NOT be dequeued and deleted (by roque response processing)
    //  before send complete.
    //

    EnterCriticalSection( & pQueue->csQueue );

    //
    //  scrub queue -- eliminate expired and duplicate packets from queue?
    //      - update forwarding queue has these flags set
    //

    if ( pQueue->fDiscardExpiredOnQueuing )
    {
        PQ_DiscardExpiredQueuedPackets(
            pQueue,
            TRUE        // queue already locked
            );
    }
    if ( pQueue->fDiscardDuplicatesOnQueuing )
    {
        PQ_DiscardDuplicatesOfNewPacket(
            pQueue,
            pMsg,
            TRUE        // queue already locked
            );
    }

    pMsg->Head.Xid = PQ_QueuePacketWithXid(
                         pQueue,
                         pMsg );
    DNS_DEBUG( UPDATE, (
        "Queuing message %p and sending.\n"
        "\tqueuing XID = %hx\n"
        "\tqueuing time=%d, expire=%d\n"
        "\tSending msg to NS at %s.\n",
        pMsg,
        pMsg->Head.Xid,
        pMsg->dwQueuingTime,
        pMsg->dwExpireTime,
        IP_STRING( pMsg->RemoteAddress.sin_addr.s_addr ) ));

    pMsg->fDelete = FALSE;

    status = Send_Msg( pMsg );

    //  DEVNOTE:  new new time field?
    //  must reset query time as send resets it with ms time
    //  as part of recursion response time tracking

    pMsg->dwQueryTime = DNS_TIME();

    LeaveCriticalSection( & pQueue->csQueue );

    return( status );
}



PDNS_MSGINFO
PQ_DequeuePacketWithMatchingXid(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN      WORD            wMatchXid
    )
/*++

Routine Description:

    Dequeue packet matching given XID.

Arguments:

    pQueue -- packet queue to remove packet from

    wMatchXid -- XID to match

Return Value:

    Matching packet, if found.
    Otherwise NULL.

--*/
{
    PDNS_MSGINFO    pmsg;

    //
    //  walk backwards through queue looking for packet
    //
    //  we start at back, to check most recent packets first
    //  and avoid build up of timed out packets
    //

    LOCK_QUEUE(pQueue);

    pmsg = (PDNS_MSGINFO) pQueue->listHead.Blink;

    while ( (PLIST_ENTRY)pmsg != &pQueue->listHead )
    {
        //
        //  matching XID ?
        //

        if ( pmsg->wQueuingXid == wMatchXid )
        {
            pQueue->cDequeued++;
            pQueue->cLength--;

            RemoveEntryList( (PLIST_ENTRY)pmsg );
            UNLOCK_QUEUE(pQueue);

            MSG_ASSERT( pmsg, IS_MSG_QUEUED(pmsg) );
            SET_MSG_DEQUEUED(pmsg);
            return( pmsg );
        }

        //  get next packet

        pmsg = (PDNS_MSGINFO) ((PLIST_ENTRY)pmsg)->Blink;
    }

    UNLOCK_QUEUE(pQueue);
    return( NULL );
}



BOOL
PQ_IsQuestionAlreadyQueued(
    IN      PPACKET_QUEUE   pQueue,
    IN      PDNS_MSGINFO    pMsg,
    IN      BOOL            fAlreadyLocked
    )
/*++

Routine Description:

    Checks if the queue already contains a matching question.

    For a query to match all these fields much match:
        XID
        client IP
        client port
        question type
        question name

Arguments:

    pQueue -- packet queue to check

    pMsg -- message to try and match in pQueue

    fAlreadyLocked -- TRUE if queue already locked

Return Value:

    TRUE - a duplicate query to pMsg is in the queue
    FALSE - no duplicate query to pMsg is in the queue

--*/
{
    BOOL            isQueued = FALSE;
    PDNS_MSGINFO    pmsg;

    //  Quick escape.

    if ( !pMsg || !pQueue || pQueue->cLength == 0 )
    {
        goto Done;
    }

    //
    //  Loop through queue and search for match.
    //

    if ( !fAlreadyLocked )
    {
        LOCK_QUEUE( pQueue );
    }

    for ( pmsg = ( PDNS_MSGINFO ) pQueue->listHead.Flink;
          ( PLIST_ENTRY ) pmsg != &pQueue->listHead;
          pmsg = ( PDNS_MSGINFO ) ( ( PLIST_ENTRY ) pmsg )->Flink )
    {
        if ( pmsg->Head.Xid == pMsg->Head.Xid &&
            pmsg->RemoteAddress.sin_addr.s_addr ==
                    pMsg->RemoteAddress.sin_addr.s_addr &&
            pmsg->RemoteAddress.sin_port == pMsg->RemoteAddress.sin_port &&
            pmsg->wQuestionType == pMsg->wQuestionType &&
            Name_CompareLookupNames(
                pmsg->pLooknameQuestion,
                pMsg->pLooknameQuestion ) )
        {
            DNS_DEBUG( RECURSE, (
                "Matched query in %s queue\n"
                "  remote IP    = %s\n"
                "  remote port  = %d\n"
                "  XID          = %X\n",
                pQueue->pszName,
                IP_STRING( pmsg->RemoteAddress.sin_addr.s_addr ),
                pmsg->RemoteAddress.sin_port,
                pmsg->Head.Xid ));
            isQueued = TRUE;
            break;
        }
    }

    if ( !fAlreadyLocked )
    {
        UNLOCK_QUEUE( pQueue );
    }

    Done:

    return isQueued;
}   //  PQ_IsQuestionAlreadyQueued



PDNS_MSGINFO
PQ_DequeueTimedOutPacket(
    IN OUT  PPACKET_QUEUE   pQueue,
    OUT     PDWORD          pdwTimeout
    )
/*++

Routine Description:

    Dequeue next timed out packet on packet queue.

    This function handles the case of a queue, where there are
    multiple possible timeout lengths, and hence may have first
    timed out packet deep in the queue.

Arguments:

    pQueue -- packet queue to remove packet from

    pdwTimeout -- smallest

Return Value:

    Ptr to oldest timed out packet, if any.
    NULL if no timed out packets on queue.

--*/
{
    PDNS_MSGINFO    pmsg;
    DWORD           dwTime;
    DWORD           dwStopTime;
    DWORD           dwTimeout;
    DWORD           dwSmallestTimeout;

    DNS_DEBUG( MSGTIMEOUT, (
        "Find next timeout in packet queue %s (length = %d).\n",
        pQueue->pszName,
        pQueue->cLength ));

    //
    //  next possible timeout -- if packet not found -- is queue
    //      minimum + 1;  this is what timeout would be if packet
    //      was immediately queued with minimum timeout
    //

    dwSmallestTimeout = pQueue->dwMinimumTimeout + 1;

    //
    //  optimize, for nothing in queue
    //

    if ( pQueue->cLength == 0 )
    {
        *pdwTimeout = dwSmallestTimeout;
        return( NULL );
    }

    //
    //  dequeue next timed out entry
    //  check until
    //      - end of queue
    //      - find timed out packet
    //      - determine no more timed out packets can exist
    //
    //  dwStopTime is last possible packet queuing time, for which
    //  minimum timeout could still produce a timeout
    //

    dwTime = GetCurrentTimeInSeconds();
    dwStopTime = dwTime - pQueue->dwMinimumTimeout;

    LOCK_QUEUE(pQueue);

    pmsg = (PDNS_MSGINFO) pQueue->listHead.Flink;

    while ( 1 )
    {
        if ( (PLIST_ENTRY)pmsg == &pQueue->listHead )
        {
            //  hit end of queue

            pmsg = NULL;
            break;
        }

        //  Sanity check: expire time less than 5 minutes!
        ASSERT( dwTime > pmsg->dwExpireTime ||
            pmsg->dwExpireTime - dwTime < 300 );

        //
        //  Fix bug 23177: The test is now "< dwTime", used to be "<=".
        //  With "<=" we could end up waiting for only a small fraction  
        //  of a second. By using "<" we will wait possibly a 
        //  fraction of a second too long, but this is preferable to 
        //  waiting for too short, especially in the case where the timeout 
        //  is one second.
        //

        if ( pmsg->dwExpireTime < dwTime )
        {
            //  timed out packet, cut from list
            //  return 0 timeout

            pQueue->cDequeued++;
            pQueue->cTimedOut++;
            pQueue->cLength--;
            RemoveEntryList( (PLIST_ENTRY)pmsg );
            dwSmallestTimeout = 0;

            MSG_ASSERT( pmsg, IS_MSG_QUEUED(pmsg) );
            SET_MSG_DEQUEUED(pmsg);
            break;
        }

        if ( pmsg->dwQueuingTime > dwStopTime )
        {
            //  packets queued after this one, can NOT possibly be timed out

            pmsg = NULL;
            break;
        }

        //
        //  save smallest message timeout encountered
        //

        dwTimeout = pmsg->dwExpireTime - dwTime;
        if ( dwTimeout < dwSmallestTimeout )
        {
            dwSmallestTimeout = dwTimeout;
        }

        //  next packet

        pmsg = (PDNS_MSGINFO) ((PLIST_ENTRY)pmsg)->Flink;
    }

    UNLOCK_QUEUE(pQueue);

    *pdwTimeout = dwSmallestTimeout;
    return( pmsg );
}



//
//  Special UPDATE queuing routines
//

PDNS_MSGINFO
PQ_DequeueNextPacketOfUnlockedZone(
    IN OUT  PPACKET_QUEUE   pQueue
    )
/*++

Routine Description:

    Dequeue next packet from queue that is for an unlocked zone.

Arguments:

    pQueue -- packet queue to dequeue from

Return Value:

    Ptr to next message dequeued.
    NULL if none in list.

--*/
{
    PDNS_MSGINFO     pmsg;

    //  optimize for nothing queued

    if ( pQueue->cLength == 0 )
    {
        return( NULL );
    }

    //
    //  break datatype slightly to delete old packets;  this has two
    //  benefits
    //      1) slight performance gain staying in queue until find good
    //          packet
    //      2) more important, making sure queue is kept clean even if
    //          zone deleted or removed from updates, other updates
    //          will clean up
    //

    LOCK_QUEUE(pQueue);

    PQ_DiscardExpiredQueuedPackets(
        pQueue,
        TRUE        // queue already locked
        );

    //
    //  loop through queue until find next packet queued for zone
    //

    pmsg = (PDNS_MSGINFO) pQueue->listHead.Flink;

    while ( (PLIST_ENTRY)pmsg != &pQueue->listHead )
    {
        //  ignore packets for locked zones

        ASSERT( pmsg->pzoneCurrent );

        if ( pmsg->pzoneCurrent->fLocked )
        {
            pmsg = (PDNS_MSGINFO) ((PLIST_ENTRY)pmsg)->Flink;
            continue;
        }

        //  unlocked zone, dequeue message

        pQueue->cDequeued++;
        pQueue->cLength--;

        RemoveEntryList( (PLIST_ENTRY)pmsg );
        UNLOCK_QUEUE(pQueue);

        MSG_ASSERT( pmsg, IS_MSG_QUEUED(pmsg) );
        SET_MSG_DEQUEUED(pmsg);
        return( pmsg );
    }

    UNLOCK_QUEUE(pQueue);
    return( NULL );
}



#if 0
PDNS_MSGINFO
PQ_DequeueNextFreshPacketMatchingZone(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Dequeue next packet from queue.

Arguments:

    pQueue -- packet queue to stick packet on

Return Value:

    Ptr to next message for zone.
    NULL if none in list.

--*/
{
    PDNS_MSGINFO     pmsg;

    //  optimize for nothing queued

    if ( pQueue->cLength == 0 )
    {
        return( NULL );
    }

    //
    //  break datatype slightly to delete old packets;  this has two
    //  benefits
    //      1) slight performance gain staying in queue until find good
    //          packet
    //      2) more important, making sure queue is kept clean even if
    //          zone deleted or removed from updates, other updates
    //          will clean up
    //

    LOCK_QUEUE(pQueue);

    PQ_DiscardExpiredQueuedPackets( pQueue );

    //
    //  loop through queue until find next packet queued for zone
    //

    pmsg = (PDNS_MSGINFO) pQueue->listHead.Flink;

    while ( (PLIST_ENTRY)pmsg != &pQueue->listHead )
    {
        //  ignore packets for other zones

        if ( pmsg->pzoneCurrent != pZone )
        {
            pmsg = (PDNS_MSGINFO) ((PLIST_ENTRY)pmsg)->Flink;
            continue;
        }

        //  matching zone, dequeue message

        pQueue->cDequeued++;
        pQueue->cLength--;

        RemoveEntryList( (PLIST_ENTRY)pmsg );
        UNLOCK_QUEUE(pQueue);

        MSG_ASSERT( pmsg, IS_MSG_QUEUED(pmsg) );
        SET_MSG_DEQUEUED(pmsg);
        return( pmsg );
    }

    UNLOCK_QUEUE(pQueue);
    return( NULL );
}
#endif



//
//  Create and delete packet queues
//

PPACKET_QUEUE
PQ_CreatePacketQueue(
    IN      LPSTR           pszQueueName,
    IN      DWORD           dwFlags,
    IN      DWORD           dwDefaultTimeout
    )
/*++

Routine Description:

    Creates a packet queue.

Arguments:

    pszQueueName -- name for queue

    dwFlags -- queue behavior flags
        currently supported:
            QUEUE_SET_EVENT
            QUEUE_DISCARD_EXPIRED
            QUEUE_DISCARD_DUPLICATES
            QUEUE_QUERY_TIME_ORDER

    dwDefaultTimeout -- default timeout on queue

Return Value:

    Ptr to packet queue structure if successful.
    NULL if error.

--*/
{
    PPACKET_QUEUE   pqueue;

    DNS_DEBUG( INIT2, ( "Creating %s packet queue.\n", pszQueueName ));

    //
    //  allocate packet queue structure
    //

    pqueue = ALLOC_TAGHEAP_ZERO( sizeof(PACKET_QUEUE), MEMTAG_SAFE );
    IF_NOMEM( ! pqueue )
    {
        DNS_PRINT((
            "ERROR:  could not allocate memory for packet queue %s.\n",
            pszQueueName ));
        return  NULL;
    }

    //
    //  initialize the list
    //

    InitializeCriticalSection( &pqueue->csQueue );
    InitializeListHead( &pqueue->listHead );

    //
    //  queuing sets event?
    //

    if ( dwFlags & QUEUE_SET_EVENT )
    {
        pqueue->hEvent = CreateEvent(
                            NULL,       //  no security attributes
                            FALSE,      //  auto-reset
                            FALSE,      //  start non-signalled
                            NULL );     //  no name
        if ( ! pqueue->hEvent )
        {
            FREE_HEAP( pqueue );
            return( NULL );
        }
    }

    //
    //  bool queuing behavior flags
    //

    if ( dwFlags & QUEUE_DISCARD_EXPIRED )
    {
        pqueue->fDiscardExpiredOnQueuing = TRUE;
    }
    if ( dwFlags & QUEUE_DISCARD_DUPLICATES )
    {
        pqueue->fDiscardDuplicatesOnQueuing = TRUE;
    }
    if ( dwFlags & QUEUE_QUERY_TIME_ORDER )
    {
        pqueue->fQueryTimeOrder = TRUE;
    }

    //
    //  fill in callers info
    //

    pqueue->pszName = pszQueueName;

    //
    //  timeout constraint
    //
    //  default timeout MUST exist to protect against spinning in
    //  timeout check threads -- which would always find zero time
    //  to next timeout
    //

    if ( dwDefaultTimeout < 1 )
    {
        dwDefaultTimeout = 1;
    }
    pqueue->dwDefaultTimeout = dwDefaultTimeout;

    //  initialize minimum timeout interval at default

    pqueue->dwMinimumTimeout = dwDefaultTimeout;

    //  starting XID

    pqueue->wXid = 1;

    return( pqueue );
}



VOID
PQ_WalkPacketQueueWithFunction(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN      VOID            (*pFunction)( PDNS_MSGINFO )
    )
/*++

Routine Description:

    Walk through packet queue with function.

Arguments:

    pQueue -- packet queue to delete

    pFunction -- function to call on each messag in queue

Return Value:

    None

--*/
{
    PDNS_MSGINFO    pmsg;
    PDNS_MSGINFO    pcheckMsg;

    ASSERT( pQueue );

    //
    //  walk queue
    //

    LOCK_QUEUE(pQueue);

    pmsg = (PDNS_MSGINFO) pQueue->listHead.Flink;

    while ( (PLIST_ENTRY)pmsg != &pQueue->listHead )
    {
        pFunction( pmsg );

        pmsg = (PDNS_MSGINFO) ((PLIST_ENTRY)pmsg)->Flink;
    }
    UNLOCK_QUEUE(pQueue);
}



VOID
PQ_CleanupPacketQueueHandles(
    IN OUT  PPACKET_QUEUE   pQueue
    )
/*++

Routine Description:

    Cleanup handles associated with a packet queue.

    Since server memory can be deleted as a whole, separate
    this function from actually freeing packet queue memory.

Arguments:

    pQueue -- packet queue to delete

Return Value:

    None

--*/
{
    if ( !pQueue )
    {
        DNS_PRINT((
            "CleanupPacketQueueHandles called for non-existant packet queue.\n" ));
        return;
    }

    //
    //  close queuing event
    //

    if ( pQueue->hEvent )
    {
        CloseHandle( pQueue->hEvent );
    }

    //
    //  delete CS
    //

    DeleteCriticalSection( &pQueue->csQueue );

    DNS_DEBUG( SHUTDOWN, (
        "Deleted handles for %s queue.\n",
        pQueue->pszName ));
}



//
//  As own process, no need to free virtual memory on shutdown
//

VOID
PQ_DeletePacketQueue(
    IN OUT  PPACKET_QUEUE   pQueue
    )
/*++

Routine Description:

    Delete the packet queue.

    Call this for packet queues on service shutdown.

    Note that function does not receive actual queue ptr variable.
    If queue ptr is used as flag, caller must NULL flag to indicate
    queue shutdown prior to call or must otherwise insure that no
    other threads will attempt to use queue.

Arguments:

    pQueue -- packet queue to delete

Return Value:

    None

--*/
{
    PDNS_MSGINFO    pmsg;
    PDNS_MSGINFO    pcheckMsg;

    if ( !pQueue )
    {
        DNS_PRINT((
            "DeletePacketQueue called for non-existant packet queue.\n" ));
        return;
    }
    IF_DEBUG( SHUTDOWN )
    {
        DNS_PRINT((
            "Deleting %s queue.\n",
            pQueue->pszName ));
    }

    //
    //  walk queue, delete every packet
    //      - no need to do list entry stuff, cause stay in list until done
    //

    LOCK_QUEUE(pQueue);

    pmsg = (PDNS_MSGINFO) pQueue->listHead.Flink;

    while ( (PLIST_ENTRY)pmsg != &pQueue->listHead )
    {
        pcheckMsg = pmsg;
        pmsg = (PDNS_MSGINFO) ((PLIST_ENTRY)pmsg)->Flink;
        pQueue->cTimedOut++;
        pQueue->cLength--;
        Packet_Free( pcheckMsg );
    }
    UNLOCK_QUEUE(pQueue);

    ASSERT( pQueue->cLength == 0 );
    ASSERT( pQueue->cQueued == pQueue->cDequeued + pQueue->cTimedOut );

    //
    //  delete queue structure itself
    //

    FREE_HEAP( pQueue );
}



BOOL
PQ_ValidatePacketQueue(
    IN OUT  PPACKET_QUEUE   pQueue
    )
/*++

Routine Description:

    Validate packet queue.

Arguments:

    pQueue -- packet queue to stick packet on

Return Value:

    TRUE if queue valid.
    FALSE otherwise.

--*/
{
    register PDNS_MSGINFO   pmsg;
    PDNS_MSGINFO    pmsgBlink;
    DWORD           currentTime;
    DWORD           count = 0;

    //
    //  currently no special ordering, XID, or time checks
    //

    //
    //  walk queue, validate
    //      - packet queued
    //      - queue links valid
    //      - XID for queues with XID range
    //

    EnterCriticalSection( &pQueue->csQueue );

    currentTime = DNS_TIME();
    currentTime++;

    pmsgBlink = (PDNS_MSGINFO) &pQueue->listHead;

    while ( 1 )
    {
        pmsg = (PDNS_MSGINFO) ((PLIST_ENTRY)pmsgBlink)->Flink;

        if ( pmsg == (PDNS_MSGINFO)&pQueue->listHead )
        {
            break;
        }

        MSG_ASSERT( pmsg, IS_MSG_QUEUED(pmsg) );
        MSG_ASSERT( pmsg, pmsg->dwQueuingTime <= currentTime );
        MSG_ASSERT( pmsg, (PDNS_MSGINFO)pmsg->ListEntry.Blink == pmsgBlink );

        //  make link check explicit for retail

        HARD_ASSERT( (PDNS_MSGINFO)pmsg->ListEntry.Blink == pmsgBlink );

        pmsgBlink = pmsg;
        count++;

        ASSERT( count <= pQueue->cQueued );

        //
        //  queue specific:  XID requirement?
        //

        if ( pQueue == g_pWinsQueue )
        {
            MSG_ASSERT( pmsg, IS_WINS_XID(pmsg->wQueuingXid) );
        }
        if ( pQueue == g_pRecursionQueue )
        {
            MSG_ASSERT( pmsg, IS_RECURSION_XID(pmsg->wQueuingXid) );
        }
    }

    LeaveCriticalSection( &pQueue->csQueue );

    return( TRUE );
}



#if 0
PDNS_MSGINFO
PQ_DequeueMatchingPacketFromOrderedXidQueue(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN      WORD            wMatchXid,
    IN      BOOL            fAnswered
    )
/*++

Routine Description:

    Dequeue packet matching given XID.

Arguments:

    pQueue -- packet queue to remove packet from

    wMatchXid -- XID to match

    fAnswered -- response is answer;  for non-WINS queries, just
                    set to TRUE

Return Value:

    Matching packet, if found.
    Otherwise NULL.

--*/
{
    PDNS_MSGINFO    pmsg;
    BOOLEAN         fSeenLargerXid = FALSE;

    //
    //  walk backwards through queue looking for packet
    //
    //  walk only until past desired XID,
    //  note before stopping we must account for XID wrap
    //
    //  we start at back, to check most recent packets first
    //  and avoid build up of timed out packets
    //

    LOCK_QUEUE(pQueue);

    pmsg = (PDNS_MSGINFO) pQueue->listHead.Blink;

    while ( (PLIST_ENTRY)pmsg != &pQueue->listHead )
    {
        //
        //  larger XID
        //      - note, have larger XID

        if ( pmsg->wQueuingXid > wMatchXid )
        {
            fSeenLargerXid = TRUE;
        }

        //
        //  matching XID?
        //

        else if ( pmsg->wQueuingXid == wMatchXid )
        {
#if 0
            //
            //  if NOT answered, and queries to other servers are still
            //  outstanding, then leave on queue
            //

            pmsg->cReferralsOut--;
            if ( ! fAnswered && pmsg->cReferralsOut )
            {
                break;
            }
#endif

            //
            //  have answer, or no responses outstanding, dequeue
            //

            pQueue->cDequeued++;
            pQueue->cLength--;

            RemoveEntryList( (PLIST_ENTRY)pmsg );
            UNLOCK_QUEUE(pQueue);
            return( pmsg );
        }

        //
        //  smaller XID
        //
        //  stop once smaller XID, but only after encountered
        //  response with larger XID, to allow XID wrap
        //

        else if ( fSeenLargerXid )
        {
            break;
        }

        //
        //  next element
        //

        pmsg = (PDNS_MSGINFO) ((PLIST_ENTRY)pmsg)->Blink;
    }

    UNLOCK_QUEUE(pQueue);
    return( NULL );
}
#endif



#if DBG

VOID
Dbg_PacketQueue(
    IN      LPSTR           pszHeader,
    IN OUT  PPACKET_QUEUE   pQueue
    )
/*++

Routine Description:

    Print all queries in packet queue.

Arguments:

    pszHeader -- header to print

    pQueue -- packet queue to delete

Return Value:

    None

--*/
{
    PDNS_MSGINFO    pmsg;
    DWORD           count = 0;

    //
    //  note:  can NOT take debug lock OUTSIDE queue lock, as we'd then
    //      be in possible deadlock, as there are places in the recursion
    //      code (sending packet) where printing done holding queuing
    //      lock (so that packet is known to be valid, not dequeued
    //      and thrown away)
    //  instead take queuing lock on the outside
    //

    LOCK_QUEUE(pQueue);
    DnsDebugLock();
    DnsPrintf(
        "%s\n"
        "Dumping Packet queue %s, count = %d:\n",
        pszHeader ? pszHeader : "",
        pQueue->pszName,
        pQueue->cLength );

    //
    //  walk queue
    //

    pmsg = (PDNS_MSGINFO) pQueue->listHead.Flink;

    while ( (PLIST_ENTRY)pmsg != &pQueue->listHead )
    {
        DNS_PRINT((
            "%s Queue Packet[%d] queuing XID = %x\n",
            pQueue->pszName,
            count,
            pmsg->wQueuingXid
            ));
        Dbg_DnsMessage(
            NULL,
            pmsg );

        count++;
        pmsg = (PDNS_MSGINFO) ((PLIST_ENTRY)pmsg)->Flink;
    }

    ASSERT( count == pQueue->cLength );

    DnsDebugUnlock();
    UNLOCK_QUEUE(pQueue);
}

#endif  // DBG



//
//  End of packetq.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\record.h ===
/*++

Copyright(c) 1995-1999 Microsoft Corporation

Module Name:

    record.h

Abstract:

    Domain Name System(DNS) Server

    Resource record database definitions.

Author:

    Jim Gilroy (jamesg)     June 27, 1995

Revision History:

    jamesg  Mar 1995    --  writing RR from message to database
    jamesg  May 1995    --  HINFO, TXT, WKS, MINFO definitions
                        --  parsing RR types
                        --  support variable sized RR
    jamesg  Jun 1995    --  RR delete
                        --  CAIRO RR
                        --  RR cleanup
                        --  created this file
    jamesg  Dec 1996    --  type indexed dispatch tables

--*/


#ifndef _RECORD_INCLUDED_
#define _RECORD_INCLUDED_



//
//  RR data rank
//
//  Cache data always has low bit set to allow single bit
//  test for all cache data types.
//

#define RANK_ZONE                   (0xf0)
#define RANK_CACHE_A_ANSWER         (0xc1)
#define RANK_NS_GLUE                (0x82)
#define RANK_GLUE                   (0x80)
#define RANK_CACHE_A_AUTHORITY      (0x71)
#define RANK_CACHE_NA_ANSWER        (0x61)
#define RANK_CACHE_A_ADDITIONAL     (0x51)
#define RANK_CACHE_NA_AUTHORITY     (0x41)
#define RANK_CACHE_NA_ADDITIONAL    (0x31)
#define RANK_OUTSIDE_GLUE           (0x20)
#define RANK_ROOT_HINT              (0x08)

#define RANK_CACHE_BIT              (0x01)
#define IS_CACHE_RANK(rank)         ( (rank) & RANK_CACHE_BIT )
#define IS_CACHE_RR(pRR)            ( IS_CACHE_RANK( (pRR)->RecordRank ))


//
//  Hack for debugging slow-free \ double frees
//
#define RANK_SLOWFREE_BIT           (0x04)
#define SET_SLOWFREE_RANK(pRR)      ( (pRR)->RecordRank |= RANK_SLOWFREE_BIT )
#define IS_SLOWFREE_RANK(pRR)       ( (pRR)->RecordRank & RANK_SLOWFREE_BIT )

//
//  Query/Set Rank
//

#define IS_ZONE_RR(pRR)             ( (pRR)->RecordRank == RANK_ZONE )
#define IS_ROOT_HINT_RR(pRR)        ( (pRR)->RecordRank == RANK_ROOT_HINT )
#define IS_CACHE_HINT_RR(pRR)       ( IS_ROOT_HINT_RR(pRR) )
#define IS_GLUE_RR(pRR)             ( (pRR)->RecordRank == RANK_GLUE )
#define IS_OUTSIDE_GLUE_RR(pRR)     ( (pRR)->RecordRank == RANK_OUTSIDE_GLUE )
#define IS_NS_GLUE_RR(pRR)          ( (pRR)->RecordRank == RANK_NS_GLUE )

#define SET_RANK_ZONE(pRR)          ( (pRR)->RecordRank = RANK_ZONE )
#define SET_RANK_NS_GLUE(pRR)       ( (pRR)->RecordRank = RANK_NS_GLUE )
#define SET_RANK_GLUE(pRR)          ( (pRR)->RecordRank = RANK_GLUE )
#define SET_RANK_OUTSIDE_GLUE(pRR)  ( (pRR)->RecordRank = RANK_OUTSIDE_GLUE )
#define SET_RANK_ROOT_HINT(pRR)     ( (pRR)->RecordRank = RANK_ROOT_HINT )

#define RR_RANK(pRR)                ( (pRR)->RecordRank )
#define CLEAR_RR_RANK(pRR)          ( (pRR)->RecordRank = 0 )
#define SET_RR_RANK(pRR, rank)      ( (pRR)->RecordRank = (rank) )

//
//  RR flag properties
//

#define RR_ZERO_TTL         0x0010
#define RR_FIXED_TTL        0x0020
#define RR_ZONE_TTL         0x0040
#define RR_REFERENCE        0x0100      //  references a node
#define RR_SLOW_FREE        0x0200      //  free with timeout

#define RR_VALID            0x1000      //  valid in-use
#define RR_LISTED           0x4000      //  in RR list
#define RR_MATCH            0x8000      //  matched in comparison operation

//
//  Query/Set RR properties
//

#define IS_ZERO_TTL_RR(pRR)     ( (pRR)->wRRFlags & RR_ZERO_TTL )
#define IS_FIXED_TTL_RR(pRR)    ( (pRR)->wRRFlags & RR_FIXED_TTL )
#define IS_ZONE_TTL_RR(pRR)     ( (pRR)->wRRFlags & RR_ZONE_TTL )
#define IS_REFERENCE_RR(pRR)    ( (pRR)->wRRFlags & RR_REFERENCE )
#define IS_SLOW_FREE_RR(pRR)    ( (pRR)->wRRFlags & RR_SLOW_FREE )
#define IS_MATCH_RR(pRR)        ( (pRR)->wRRFlags & RR_MATCH )

#if DBG
#define IS_LISTED_RR(pRR)       ( (pRR)->wRRFlags & RR_LISTED )
#else   // retail:  need some expression when used in ASSERTs even when macroed away
#define IS_LISTED_RR(pRR)       ( TRUE )
#endif

#define SET_FIXED_TTL_RR(pRR)   ( (pRR)->wRRFlags |= RR_FIXED_TTL )
#define SET_ZERO_TTL_RR(pRR)    ( (pRR)->wRRFlags |= RR_ZERO_TTL )
#define SET_ZONE_TTL_RR(pRR)    ( (pRR)->wRRFlags |= RR_ZONE_TTL )
#define SET_REFERENCE_RR(pRR)   ( (pRR)->wRRFlags |= RR_REFERENCE )
#define SET_SLOW_FREE_RR(pRR)   ( (pRR)->wRRFlags |= RR_SLOW_FREE )
#define SET_MATCH_RR(pRR)       ( (pRR)->wRRFlags |= RR_MATCH )
#define SET_LISTED_RR(pRR)      ( (pRR)->wRRFlags |= RR_LISTED )

#define CLEAR_FIXED_TTL_RR(pRR) ( (pRR)->wRRFlags &= ~RR_FIXED_TTL )
#define CLEAR_ZERO_TTL_RR(pRR)  ( (pRR)->wRRFlags &= ~RR_ZERO_TTL )
#define CLEAR_ZONE_TTL_RR(pRR)  ( (pRR)->wRRFlags &= ~RR_ZONE_TTL )
#define CLEAR_REFERENCE_RR(pRR) ( (pRR)->wRRFlags &= ~RR_REFERENCE )
#define CLEAR_MATCH_RR(pRR)     ( (pRR)->wRRFlags &= ~RR_MATCH )
#define CLEAR_LISTED_RR(pRR)    ( (pRR)->wRRFlags &= ~RR_LISTED )

//
//  Reserved flag properties
//

typedef struct _ReservedRecordFlags
{
    BYTE    Source          : 4;
    BYTE    Reserved        : 3;
    BYTE    StandardAlloc   : 1;
}
RECRESVFLAG, *PRECRESVFLAG;

#if 0
#define RR_FILE             (1)     //  source
#define RR_DS               (2)
#define RR_ADMIN            (3)
#define RR_DYNUP            (4)
#define RR_AXFR             (5)
#define RR_IXFR             (6)
#define RR_COPY             (7)
#define RR_CACHE            (8)
#define RR_NO_EXIST         (9)
#define RR_AUTO             (10)
#define RR_SOURCE_MAX       (RR_AUTO)

#define SET_FILE_RR(pRR)        ( (pRR)->Reserved.Source = RR_FILE )
#define SET_DS_RR(pRR)          ( (pRR)->Reserved.Source = RR_DS )
#define SET_ADMIN_RR(pRR)       ( (pRR)->Reserved.Source = RR_ADMIN )
#define SET_DYNUP_RR(pRR)       ( (pRR)->Reserved.Source = RR_DYNUP )
#define SET_AXFR_RR(pRR)        ( (pRR)->Reserved.Source = RR_AXFR )
#define SET_IXFR_RR(pRR)        ( (pRR)->Reserved.Source = RR_IXFR )
#define SET_COPY_RR(pRR)        ( (pRR)->Reserved.Source = RR_COPY )
#define SET_CACHE_RR(pRR)       ( (pRR)->Reserved.Source = RR_CACHE )
#define SET_AUTO_RR(pRR)        ( (pRR)->Reserved.Source = RR_AUTO )
#endif

//
//  Type bitmask
//
//  For some tracking purposes it is nice to know list of types
//  as bitmask (ULONGLONG).
//

#define A_BITMASK_BIT           ((ULONGLONG) 0x0000000000000002)
#define NS_BITMASK_BIT          ((ULONGLONG) 0x0000000000000004)
#define CNAME_BITMASK_BIT       ((ULONGLONG) 0x0000000000000020)
#define SOA_BITMASK_BIT         ((ULONGLONG) 0x0000000000000040)
#define PTR_BITMASK_BIT         ((ULONGLONG) 0x0000000000001000)
#define MX_BITMASK_BIT          ((ULONGLONG) 0x0000000000008000)
#define SRV_BITMASK_BIT         ((ULONGLONG) 0x0000000200000000)
#define OTHERTYPE_BITMASK_BIT   ((ULONGLONG) 0x8000000000000000)

#if 0
#define A_BITMASK_BIT           ((ULONGLONG) 0x00000001)
#define NS_BITMASK_BIT          ((ULONGLONG) 0x00000002)
#define CNAME_BITMASK_BIT       ((ULONGLONG) 0x00000010)
#define SOA_BITMASK_BIT         ((ULONGLONG) 0x00000020)
#define PTR_BITMASK_BIT         ((ULONGLONG) 0x00000800)
#define MX_BITMASK_BIT          ((ULONGLONG) 0x00004000)
#define SRV_BITMASK_BIT         ((ULONGLONG) 0x80000000)
#define OTHERTYPE_BITMASK_BIT   ((ULONGLONG) 0x00000004)    // using MF space
#endif


//
//  Get node referenced by record data
//

#define REF_RAW_NAME( pnode )   ( (PCHAR)&(pnode))

//
//  Resource record list manipulation.
//

#define EMPTY_RR_LIST( pNode )  ( ! pNode->pRRList )

#define FIRST_RR( pNode )       ((PDB_RECORD)pNode->pRRList)

#define NEXT_RR( pRR )          ( (pRR)->pRRNext )

//
//  simple RR list traversal
//
//  use this to get addr of node's RR list ptr, which is then
//  treated as list ptr
//
//  simple detail free traverse then looks like
//
//      pRR = START_RR_TRAVERSE( pNode );
//
//      WHILE_MORE_RR( pRR )
//      {
//          // do stuff
//      }
//

#define START_RR_TRAVERSE(pNode)    ((PDB_RECORD)&pNode->pRRList)

#define WHILE_MORE_RR( pRR )     while( pRR = pRR->pRRNext )


//
//  Resource record database structure
//

//
//  Size of type independent fields -- always present
//
//  WARNING:  MUST! keep this current with changes in header
//

#define SIZEOF_DBASE_RR_FIXED_PART ( \
                sizeof(PVOID) + \
                sizeof(DWORD) + \
                sizeof(WORD)  + \
                sizeof(WORD)  + \
                sizeof(DWORD) + \
                sizeof(DWORD) )

#define SIZEOF_DBASE_A_RECORD   (SIZEOF_DBASE_RR_FIXED_PART \
                                    + sizeof(IP_ADDRESS))

//
//  Minimum record type specific database sizes.
//
//  Fixed field definitions are in dnslib record.h
//

#define MIN_PTR_SIZE        (SIZEOF_DBASE_NAME_FIXED)
#define MIN_MX_SIZE         (sizeof(WORD) + SIZEOF_DBASE_NAME_FIXED)
#define MIN_SOA_SIZE        (SIZEOF_SOA_FIXED_DATA + 2*SIZEOF_DBASE_NAME_FIXED)
#define MIN_MINFO_SIZE      (2 * SIZEOF_DBASE_NAME_FIXED)
#define MIN_SRV_SIZE        (SIZEOF_SRV_FIXED_DATA + SIZEOF_DBASE_NAME_FIXED)

#define MIN_WINS_SIZE       (SIZEOF_WINS_FIXED_DATA + sizeof(DWORD))
#define MIN_NBSTAT_SIZE     (SIZEOF_WINS_FIXED_DATA + SIZEOF_DBASE_NAME_FIXED)


//
//  RR structure
//
//  NOTE:  For efficiency, all these fields should be aligned.
//
//  Class is a property of entire tree (database), so not stored
//  in records.  (Only supportting IN       class currently.)
//
//  Note to speed response all data -- that is not pointer to another
//  DNS node -- is kept in network byte order.
//  In addition, TTL (for non-cached data) is in network byte order.
//

#define DNS_MAX_TYPE_BITMAP_LENGTH      (16)

typedef struct _Dbase_Record
{
    //
    //  Next pointer MUST be at front of structure to allow us
    //  to treat the RR list ptr in the domain NODE, identical
    //  as a regular RR ptr, for purposes of accessing its "next"
    //  ptr.  This allows us to simplify or avoid all the front of
    //  list special cases.
    //

    struct _Dbase_Record *    pRRNext;

    //
    //  Flags -- caching, rank, etc.
    //

    UCHAR           RecordRank;
    RECRESVFLAG     Reserved;
    WORD            wRRFlags;

    WORD            wType;              // in host order
    WORD            wDataLength;

    DWORD           dwTtlSeconds;       // in network order for regular fixed TTL
                                        // in host order, if cached timeout
    DWORD           dwTimeStamp;        // create time stamp (hours)

    //
    //  Data for specific types
    //

    union
    {
        struct
        {
            IP_ADDRESS      ipAddress;
        }
        A;

        struct
        {
            //  Note: this is a QWORD-aligned structure. On ia64 the stuff
            //  before union is currently a pointer and 4 DWORDs, so the
            //  alignment is good. But if we ever change the stuff before
            //  the union the compiler may insert badding to QWORD-align
            //  the union. This will mess with our fixed-constant allocation
            //  stuff, so be careful.
            IP6_ADDRESS     Ip6Addr;
        }
        AAAA;

        struct
        {
            DWORD           dwSerialNo;
            DWORD           dwRefresh;
            DWORD           dwRetry;
            DWORD           dwExpire;
            DWORD           dwMinimumTtl;
            DB_NAME         namePrimaryServer;

            //  ZoneAdmin name immediately follows
            //  DB_NAME         nameZoneAdmin;
        }
        SOA;

        struct
        {
            DB_NAME         nameTarget;
        }
        PTR,
        NS,
        CNAME,
        MB,
        MD,
        MF,
        MG,
        MR;

        struct
        {
            DB_NAME         nameMailbox;

            //  ErrorsMailbox immediately follows
            // DB_NAME         nameErrorsMailbox;
        }
        MINFO,
        RP;

        struct
        {
            WORD            wPreference;
            DB_NAME         nameExchange;
        }
        MX,
        AFSDB,
        RT;

        struct
        {
            BYTE            chData[1];
        }
        HINFO,
        ISDN,
        TXT,
        X25,
        Null;

        struct
        {
            IP_ADDRESS      ipAddress;
            UCHAR           chProtocol;
            BYTE            bBitMask[1];
        }
        WKS;

        struct
        {
            WORD            wTypeCovered;
            BYTE            chAlgorithm;
            BYTE            chLabelCount;
            DWORD           dwOriginalTtl;
            DWORD           dwSigExpiration;
            DWORD           dwSigInception;
            WORD            wKeyTag;
            DB_NAME         nameSigner;
            //  signature data follows signer's name
        }
        SIG;

        struct
        {
            WORD            wFlags;
            BYTE            chProtocol;
            BYTE            chAlgorithm;
            BYTE            Key[1];
        }
        KEY;

        struct
        {
            WORD            wVersion;
            WORD            wSize;
            WORD            wHorPrec;
            WORD            wVerPrec;
            DWORD           dwLatitude;
            DWORD           dwLongitude;
            DWORD           dwAltitude;
        }
        LOC;

        struct
        {
            BYTE            bTypeBitMap[ DNS_MAX_TYPE_BITMAP_LENGTH ];
            DB_NAME         nameNext;
        }
        NXT;

        struct
        {
            WORD            wPriority;
            WORD            wWeight;
            WORD            wPort;
            DB_NAME         nameTarget;
        }
        SRV;

        struct
        {
            UCHAR           chFormat;
            BYTE            bAddress[1];
        }
        ATMA;

        struct
        {
            DWORD           dwTimeSigned;
            DWORD           dwTimeExpire;
            WORD            wSigLength;
            BYTE            bSignature;
            DB_NAME         nameAlgorithm;

            //  Maybe followed in packet by other data
            //  If need to process then move fixed fields ahead of
            //      bSignature

            //  WORD    wError;
            //  WORD    wOtherLen;
            //  BYTE    bOtherData;
        }
        TSIG;

        struct
        {
            WORD            wKeyLength;
            BYTE            bKey[1];
        }
        TKEY;

        //
        //  MS types
        //

        struct
        {
            DWORD           dwMappingFlag;
            DWORD           dwLookupTimeout;
            DWORD           dwCacheTimeout;
            DWORD           cWinsServerCount;
            IP_ADDRESS      aipWinsServers[1];
        }
        WINS;

        struct
        {
            DWORD           dwMappingFlag;
            DWORD           dwLookupTimeout;
            DWORD           dwCacheTimeout;
            DB_NAME         nameResultDomain;
        }
        WINSR;

        //
        //  NoExist is special in that always refers to name above it in tree.
        //      so can still use reference.
        //
        //  DEVNOTE: could switch to just tracking labels above it in tree (safer)
        //

        struct
        {
            PDB_NODE        pnodeZoneRoot;
        }
        NOEXIST;

        struct
        {
            UCHAR           chPrefixBits;
            // AddressSuffix should be SIZEOF_A6_ADDRESS_SUFFIX_LENGTH
            // bytes but that constant is not available in dnsexts
            BYTE            AddressSuffix[ 16 ];
            DB_NAME         namePrefix;
        }
        A6;

        struct
        {
            WORD            wUdpPayloadSize;
            DWORD           dwExtendedFlags;
            // Add array for <attribute,value pairs> here for EDNS1+
        }
        OPT;

    } Data;
}
DB_RECORD, *PDB_RECORD;

typedef const DB_RECORD *PCDB_RECORD;


//
//  Record parsing structure.
//

typedef struct _ParseRecord
{
    //
    //  Next pointer MUST be at front of structure.
    //  Allows list add macros to handle these cleanly and node ptr
    //  to list to be treated as RR.
    //

    struct _ParseRecord *  pNext;

    PCHAR   pchWireRR;
    PCHAR   pchData;

    DWORD   dwTtl;

    WORD    wClass;
    WORD    wType;
    WORD    wDataLength;

    UCHAR   Section;
    UCHAR   SourceTag;
}
PARSE_RECORD, *PPARSE_RECORD;


//
//  DS Record
//

typedef struct _DsRecordFlags
{
    DWORD   Reserved    :   16;
    DWORD   Version     :   8;
    DWORD   Rank        :   8;
}
DS_RECORD_FLAGS, *PDS_RECORD_FLAGS;

#define DS_RECORD_VERSION_RELEASE   (5)

typedef struct _DsRecord
{
    WORD                wDataLength;
    WORD                wType;

    //DWORD               dwFlags;
    BYTE                Version;
    BYTE                Rank;
    WORD                wFlags;

    DWORD               dwSerial;
    DWORD               dwTtlSeconds;
    DWORD               dwReserved;
    DWORD               dwTimeStamp;

    union               _DataUnion
    {
        struct
        {
            LONGLONG        EntombedTime;
        }
        Tombstone;
    }
    Data;
}
DS_RECORD, *PDS_RECORD;

#define SIZEOF_DS_RECORD_HEADER         (6*sizeof(DWORD))



//
//  Resource record type operations (rrecord.c)
//

WORD
FASTCALL
QueryIndexForType(
    IN      WORD            wType
    );

WORD
FASTCALL
RR_IndexForType(
    IN      WORD            wType
    );

BOOL
RR_AllocationInit(
    VOID
    );

PDB_RECORD
RR_CreateFromWire(
    IN      WORD            wType,
    IN      WORD            wDataLength
    );

PDB_RECORD
RR_CreateFixedLength(
    IN      WORD            wType
    );

PDB_RECORD
RR_Copy(
    IN      PDB_RECORD      pSoaRR,
    IN      DWORD           Flag
    );

PDB_RECORD
RR_AllocateEx(
    IN      WORD            wDataLength,
    IN      DWORD           SourceTag
    );

//  backward compatibility

#define RR_Allocate(len)    RR_AllocateEx( len, 0 )

PDB_NODE
RR_DataReference(
    IN OUT  PDB_NODE        pNode
    );

DNS_STATUS
RR_DerefAndFree(
    IN OUT  PDB_RECORD      pRR
    );

VOID
RR_Free(
    IN OUT  PDB_RECORD      pRR
    );

BOOL
RR_Validate(
    IN      PDB_RECORD      pRR,
    IN      BOOL            fActive,
    IN      WORD            wType,
    IN      DWORD           dwSource
    );

#define IS_VALID_RECORD(pRR)    (RR_Validate(pRR,TRUE,0,0))


VOID
RR_WriteDerivedStats(
    VOID
    );

ULONGLONG
RR_SetTypeInBitmask(
    IN OUT  ULONGLONG       TypeBitmask,
    IN      WORD            wType
    );

//
//  Standard type creation (rrecord.c)
//

PDB_RECORD
RR_CreateARecord(
    IN      IP_ADDRESS      ipAddress,
    IN      DWORD           dwTtl,
    IN      DWORD           SourceTag
    );

PDB_RECORD
RR_CreatePtr(
    IN      PDB_NAME        pNameTarget,
    IN      LPSTR           pszTarget,
    IN      WORD            wType,
    IN      DWORD           dwTtl,
    IN      DWORD           SourceTag
    );

PDB_RECORD
RR_CreateSoa(
    IN      PDB_RECORD      pExistingSoa,
    IN      PDB_NAME        pnameAdmin,
    IN      LPSTR           pszAdmin
    );

//
//  Type specific functions
//  From rrflat.c
//

PCHAR
WksFlatWrite(
    IN OUT  PDNS_FLAT_RECORD    pFlatRR,
    IN      PDB_RECORD          pRR,
    IN      PCHAR               pch,
    IN      PCHAR               pchBufEnd
    );

//
//  Name error caching -- Currently using RR of zero type.
//

#define DNS_TYPE_NOEXIST    DNS_TYPE_ZERO


//
//  Resource record dispatch tables
//

typedef DNS_STATUS (* RR_FILE_READ_FUNCTION)();

extern  RR_FILE_READ_FUNCTION   RRFileReadTable[];

typedef PCHAR (* RR_FILE_WRITE_FUNCTION)();

extern  RR_FILE_WRITE_FUNCTION  RRFileWriteTable[];


typedef PDB_RECORD (* RR_WIRE_READ_FUNCTION)();

extern  RR_WIRE_READ_FUNCTION   RRWireReadTable[];

typedef PCHAR (* RR_WIRE_WRITE_FUNCTION)();

extern  RR_WIRE_WRITE_FUNCTION  RRWireWriteTable[];


typedef DNS_STATUS (* RR_FLAT_READ_FUNCTION)();

extern  RR_FLAT_READ_FUNCTION   RRFlatReadTable[];

typedef PCHAR (* RR_FLAT_WRITE_FUNCTION)();

extern  RR_FLAT_WRITE_FUNCTION  RRFlatWriteTable[];


typedef DNS_STATUS (* RR_VALIDATE_FUNCTION)();

extern  RR_VALIDATE_FUNCTION    RecordValidateTable[];


//
//  Generic template for dispatch function lookup
//

typedef VOID (* RR_GENERIC_DISPATCH_FUNCTION)();

typedef RR_GENERIC_DISPATCH_FUNCTION    RR_GENERIC_DISPATCH_TABLE[];

RR_GENERIC_DISPATCH_FUNCTION
RR_DispatchFunctionForType(
    IN      RR_GENERIC_DISPATCH_TABLE   pTable,
    IN      WORD                        wType
    );

//
//  Indexing into dispatch tables or property tables
//
//  Check type against max self indexed type.
//  Offsets to other types:
//      - WINS\WINSR packed in after last self-indexed
//      - then compound query types
//

#define DNSSRV_MAX_SELF_INDEXED_TYPE    (48)

#define DNSSRV_OFFSET_TO_WINS_TYPE_INDEX    \
        (DNS_TYPE_WINS - DNSSRV_MAX_SELF_INDEXED_TYPE - 1)

#define DNSSRV_OFFSET_TO_COMPOUND_TYPE_INDEX    \
        (DNS_TYPE_TKEY - DNSSRV_MAX_SELF_INDEXED_TYPE - 3)

#ifdef  INDEX_FOR_TYPE
#undef  INDEX_FOR_TYPE
#endif

#define INDEX_FOR_TYPE(type)    \
        ( (type <= DNSSRV_MAX_SELF_INDEXED_TYPE)   \
            ? type                          \
            : RR_IndexForType(type) )

#define INDEX_FOR_QUERY_TYPE(type)    \
        ( (type <= DNSSRV_MAX_SELF_INDEXED_TYPE)   \
            ? type                          \
            : QueryIndexForType(type) )



//
//  Type property table property indexes
//

extern  UCHAR  RecordTypePropertyTable[][5];

#define RECORD_PROP_CNAME_QUERY     (0)
#define RECORD_PROP_WITH_CNAME      (1)
#define RECORD_PROP_WILDCARD        (2)
#define RECORD_PROP_UPDATE          (3)
#define RECORD_PROP_ROUND_ROBIN     (4)

#define RECORD_PROP_TERMINATOR      (0xff)


//
//  Updateable type
//
//  DEVNOTE: not using update table
//

#define IS_DYNAMIC_UPDATE_TYPE(wType)   ((wType) < DNS_TYPE_TSIG)

#define IS_SPECIAL_UPDATE_TYPE(wType)   \
        (   (wType) == DNS_TYPE_NS      ||  \
            (wType) == DNS_TYPE_CNAME   ||  \
            (wType) == DNS_TYPE_SOA     )

//
//  Check if type Wildcard applicable
//      - since we MUST always check before sending NAME_ERROR
//      there's no point in not checking all types even those
//      unwildcardable

#define IS_WILDCARD_TYPE(wType)     (TRUE)


//
//  Check if CNAME able type.
//
//  Optimize the property lookups for type A.
//

#define IS_ALLOWED_WITH_CNAME_TYPE(wType) \
            RecordTypePropertyTable       \
                [ INDEX_FOR_QUERY_TYPE(wType) ][ RECORD_PROP_WITH_CNAME ]

//  anything allowed to be at CNAME node -- same as above + CNAME type

#define IS_ALLOWED_AT_CNAME_NODE_TYPE(wType)    \
            ( (wType) == DNS_TYPE_CNAME   ||    \
            RecordTypePropertyTable             \
                [ INDEX_FOR_QUERY_TYPE(wType) ][ RECORD_PROP_WITH_CNAME ] )

//  Follow CNAME on query (optimize for type A)

#define IS_CNAME_REPLACEABLE_TYPE(wType) \
            ( (wType) == DNS_TYPE_A     ||      \
            RecordTypePropertyTable             \
                [ INDEX_FOR_QUERY_TYPE(wType) ][ RECORD_PROP_CNAME_QUERY ] )

//
//  Round-robin types.
//

#define IS_ROUND_ROBIN_TYPE( wType )            \
            ( RecordTypePropertyTable           \
                [ INDEX_FOR_QUERY_TYPE( wType ) ][ RECORD_PROP_ROUND_ROBIN ] )


//
//  Glue types
//

#define IS_GLUE_TYPE(wType)  \
        (   (wType) == DNS_TYPE_A   ||  \
            (wType) == DNS_TYPE_NS  ||  \
            (wType) == DNS_TYPE_AAAA    )

#define IS_ROOT_HINT_TYPE(type)     IS_GLUE_TYPE(type)

#define IS_GLUE_ADDRESS_TYPE(wType)  \
        (   (wType) == DNS_TYPE_A   ||  \
            (wType) == DNS_TYPE_AAAA  )

//
//  Generating additional query types
//

#define IS_NON_ADDITIONAL_GENERATING_TYPE(wType) \
        (   (wType) == DNS_TYPE_A       ||  \
            (wType) == DNS_TYPE_PTR     ||  \
            (wType) == DNS_TYPE_AAAA    )


//
//  Valid authority section types
//

#define IS_AUTHORITY_SECTION_TYPE(wType)    \
        (   (wType) == DNS_TYPE_NS      ||  \
            (wType) == DNS_TYPE_SOA     ||  \
            (wType) == DNS_TYPE_SIG     ||  \
            (wType) == DNS_TYPE_NXT )

//
//  Valid additional section types
//

#define IS_ADDITIONAL_SECTION_TYPE(wType)   \
        (   (wType) == DNS_TYPE_A       ||  \
            (wType) == DNS_TYPE_AAAA    ||  \
            (wType) == DNS_TYPE_KEY     ||  \
            (wType) == DNS_TYPE_SIG     ||  \
            (wType) == DNS_TYPE_OPT )

//
//  Subzone valid types
//      - for load or update
//

#define IS_SUBZONE_TYPE(wType) \
        (   (wType) == DNS_TYPE_A       ||  \
            (wType) == DNS_TYPE_AAAA    ||  \
            (wType) == DNS_TYPE_KEY     ||  \
            (wType) == DNS_TYPE_SIG     )

#define IS_UPDATE_IN_SUBZONE_TYPE(wType) \
        IS_SUBZONE_TYPE(wType)

#define IS_SUBZONE_OR_DELEGATION_TYPE(wType) \
        (   (wType) == DNS_TYPE_NS      ||  \
            (wType) == DNS_TYPE_A       ||  \
            (wType) == DNS_TYPE_AAAA    ||  \
            (wType) == DNS_TYPE_KEY     ||  \
            (wType) == DNS_TYPE_SIG     )

#define IS_UPDATE_AT_DELEGATION_TYPE(wType) \
        IS_SUBZONE_OR_DELEGATION_TYPE(wType)

//
//  DNSSEC type
//

#define IS_DNSSEC_TYPE(wType)               \
        (   (wType) == DNS_TYPE_SIG     ||  \
            (wType) == DNS_TYPE_KEY     ||  \
            (wType) == DNS_TYPE_NXT     )

//
//  Non-scavenging types
//

#define IS_NON_SCAVENGE_TYPE(wType) \
        (   (wType) != DNS_TYPE_A       &&  \
          ( (wType) == DNS_TYPE_NS      ||  \
            (wType) == DNS_TYPE_SOA     ||  \
            IS_WINS_TYPE(wType) ) )


//
//  Check for compound types
//
//  Note when RRs exist with the high byte set, these must be looked
//  at carefully to insure validity.
//

#define IS_COMPOUND_TYPE(wType) \
        ( (wType) >= DNS_TYPE_TKEY && (wType) <= DNS_TYPE_ALL )

#define IS_COMPOUND_TYPE_EXCEPT_ANY(wType) \
        ( (wType) >= DNS_TYPE_TKEY && (wType) <= DNS_TYPE_MAILA )


//
//  WINS record tests
//

#define IS_WINS_RR(pRR)             IS_WINS_TYPE( (pRR)->wType )

#define IS_WINS_RR_LOCAL(pRR)       (!!((pRR)->Data.WINS.dwMappingFlag & DNS_WINS_FLAG_LOCAL))

#define IS_WINS_RR_AND_LOCAL(pRR)   (IS_WINS_RR(pRR) && IS_WINS_RR_LOCAL(pRR))


//
//  Record enumeration flags on RPC calls
//
//  Note, this is not record selection flags, those
//  are in dnsrpc.h.
//

#define ENUM_DOMAIN_ROOT    (0x80000000)
#define ENUM_NAME_FULL      (0x40000000)
#define ENUM_GLUE           (0x20000000)
#define ENUM_FOR_NT4        (0x10000000)


//
//  Limit lookup\caching of CNAME chains
//

#define CNAME_CHAIN_LIMIT (8)

//
//  Quick reverse record property lookup
//

extern DWORD  RecordTypeCombinedPropertyTable[];
#define REVERSE_TABLE   (RecordTypeCombinedPropertyTable)

extern DWORD  RecordTypeReverseCombinedPropertyTable[];
#define REVERSE_COMBINED_DATA   (RecordTypeReverseCombinedPropertyTable)


//
//  Resource record macro
//

#define SIZEOF_COMPRESSED_NAME_AND_DB_RECORD        \
            (sizeof(WORD) + sizeof(DNS_WIRE_RECORD)


//
//  Address record with compressed name
//  An extremely useful special case.
//

#include <packon.h>
typedef struct _DNS_COMPRESSED_A_RECORD
{
    WORD                wCompressedName;
    WORD                wType;
    WORD                wClass;
    DWORD               dwTtl;
    WORD                wDataLength;
    IP_ADDRESS          ipAddress;
}
DNS_COMPRESSED_A_RECORD, *PDNS_COMPRESSED_A_RECORD;
#include <packoff.h>


#define SIZEOF_COMPRESSED_A_RECORD  (sizof(DNS_COMPRESSED_A_RECORD))

#define NET_BYTE_ORDER_A_RECORD_DATA_LENGTH (0x0400)


//
//  Default SOA values
//

#define DEFAULT_SOA_SERIAL_NO       1
#define DEFAULT_SOA_REFRESH         900     // 15 minutes
#define DEFAULT_SOA_RETRY           600     // ten minutes
#define DEFAULT_SOA_EXPIRE          86400   // one day
#define DEFAULT_SOA_MIN_TTL         3600    // one hour

//
//  SOA version retrieval from wire record.
//  Another useful special case.
//

#define SOA_VERSION_OF_PREVIOUS_RECORD( pch ) \
            FlipUnalignedDword((pch) - SIZEOF_SOA_FIXED_DATA)


#endif // _RRECORD_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\packetq.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    packetq.h

Abstract:

    Domain Name System (DNS) Server

    Packet queue definitions.

    Packet queue is used for queuing queries to WINS and other
    name servers.

Author:

    Jim Gilroy (jamesg)     August 21, 1995

Revision History:

--*/


#ifndef _DNS_PACKETQ_INCLUDED_
#define _DNS_PACKETQ_INCLUDED_


//
//  Packet queue structure
//

typedef struct _packet_queue
{
    LIST_ENTRY          listHead;       //  list of messages
    CRITICAL_SECTION    csQueue;        //  protecting CS
    LPSTR               pszName;        //  queue name
    HANDLE              hEvent;         //  event for queue

    //  flags

    BOOL        fQueryTimeOrder;
    BOOL        fDiscardExpiredOnQueuing;
    BOOL        fDiscardDuplicatesOnQueuing;

    //
    //  counters
    //

    DWORD       cLength;
    DWORD       cQueued;
    DWORD       cDequeued;
    DWORD       cTimedOut;

    //
    //  time out
    //

    DWORD       dwDefaultTimeout;       //  def timeout, if dwExpireTime not set
    DWORD       dwMinimumTimeout;       //  minimum timeout packet will have

    WORD        wXid;                   //  XID for referrals
}
PACKET_QUEUE, *PPACKET_QUEUE;


//
//  Queue behavior flags
//

#define QUEUE_SET_EVENT             (0x00000001)
#define QUEUE_DISCARD_EXPIRED       (0x00000002)
#define QUEUE_DISCARD_DUPLICATES    (0x00000004)
#define QUEUE_QUERY_TIME_ORDER      (0x00000008)


//
//  Message queued check
//

#define IS_MSG_QUEUED(pMsg)     ( (pMsg)->dwQueuingTime != 0 )


//
//  Queue validation
//

BOOL
PQ_ValidatePacketQueue(
    IN OUT  PPACKET_QUEUE   pQueue
    );

#define VALIDATE_PACKET_QUEUE(pQueue)   PQ_ValidatePacketQueue(pQueue)


//
//  Queue locking
//

#if DBG
#define LOCK_QUEUE(pQueue)                          \
    {                                               \
        EnterCriticalSection( &pQueue->csQueue );   \
        VALIDATE_PACKET_QUEUE(pQueue);              \
    }

#define UNLOCK_QUEUE(pQueue)                        \
    {                                               \
        VALIDATE_PACKET_QUEUE(pQueue);              \
        LeaveCriticalSection( &pQueue->csQueue );   \
    }

#else
#define LOCK_QUEUE(pQueue)      EnterCriticalSection( &pQueue->csQueue )
#define UNLOCK_QUEUE(pQueue)    LeaveCriticalSection( &pQueue->csQueue )
#endif


PPACKET_QUEUE
PQ_CreatePacketQueue(
    IN      LPSTR           pszQueueName,
    IN      DWORD           dwFlags,
    IN      DWORD           dwDefaultTimeout
    );

VOID
PQ_CleanupPacketQueueHandles(
    IN OUT  PPACKET_QUEUE   pQueue
    );

VOID
PQ_DeletePacketQueue(
    IN OUT  PPACKET_QUEUE   pQueue
    );

VOID
PQ_QueuePacket(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsg
    );

VOID
PQ_QueuePacketSetEvent(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsg
    );

VOID
PQ_QueuePacketEx(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      BOOL            fAlreadyLocked
    );

PDNS_MSGINFO
PQ_DequeueNextPacket(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN      BOOL            fAlreadyLocked
    );

VOID
PQ_YankQueuedPacket(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsg
    );

PDNS_MSGINFO
PQ_DequeueTimedOutPacket(
    IN OUT  PPACKET_QUEUE   pQueue,
    OUT     PDWORD          pdwTimeout
    );

//  Queue cleanup

VOID
PQ_DiscardDuplicatesOfNewPacket(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsgNew,
    IN      BOOL            fAlreadyLocked
    );

VOID
PQ_DiscardExpiredQueuedPackets(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN      BOOL            fAlreadyLocked
    );

//  XID queuing

WORD
PQ_QueuePacketWithXid(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsg
    );

DNS_STATUS
PQ_QueuePacketWithXidAndSend(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN OUT  PDNS_MSGINFO    pMsg
    );

PDNS_MSGINFO
PQ_DequeuePacketWithMatchingXid(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN      WORD            wMatchXid
    );

BOOL
PQ_IsQuestionAlreadyQueued(
    IN      PPACKET_QUEUE   pQueue,
    IN      PDNS_MSGINFO    pMsg,
    IN      BOOL            fAlreadyLocked
    );


//  UPDATE queuing

PDNS_MSGINFO
PQ_DequeueNextPacketOfUnlockedZone(
    IN OUT  PPACKET_QUEUE   pQueue
    );

PDNS_MSGINFO
PQ_DequeueNextFreshPacketMatchingZone(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN      PZONE_INFO      pZone
    );


VOID
PQ_WalkPacketQueueWithFunction(
    IN OUT  PPACKET_QUEUE   pQueue,
    IN      VOID            (*pFunction)( PDNS_MSGINFO  )
    );

#endif  //  _DNS_PACKETQ_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\recurse.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    recurse.h

Abstract:

    Domain Name System (DNS) Server

    Definitions for recursive query processing.

Author:

    Jim Gilroy (jamesg)     August 1995

Revision History:

--*/


#ifndef _DNS_RECURSE_INCLUDED_
#define _DNS_RECURSE_INCLUDED_


//
//  Visited NS list structure
//
//  Info for tracking "visits" (sends to and responses from) remote
//  NS for recursion.
//

//  Size of list in overlay pointed to by packet ptr.

#define MAX_NS_RECURSION_ATTEMPTS       ( 50 )
#define MAX_PACKET_NS_LIST_COUNT        ( MAX_NS_RECURSION_ATTEMPTS )

//  Actual structure size -- large enough to read all the best stuff in
//      any reasonable configuration.  Can be large as will be temp
//      stack memory used just to build list and prioritize.

#define MAX_NS_LIST_COUNT               (50)


//
//  Remote NS IP visit struct
//
//  The Data union replaces overloaded use of Priority for the
//  missing glue node ptr - this caused problem for Win64.
//

typedef struct _DnsVisitIp
{
    PDB_NODE        pNsNode;
    union
    {
        struct
        {
            DWORD           Priority;
            DWORD           SendTime;
        };
        PDB_NODE        pnodeMissingGlueDelegation;
    } Data;
    IP_ADDRESS      IpAddress;
    UCHAR           SendCount;
    UCHAR           Response;
    UCHAR           Reserved2;
    UCHAR           Reserved3;
}
NS_VISIT, *PNS_VISIT;


typedef struct _DnsVisitedNsList
{
    DWORD           Count;
    DWORD           VisitCount;
    DWORD           MaxCount;
    DWORD           ZoneIndex;
    PDB_NODE        pZoneRootCurrent;
    PDB_NODE        pZoneRootResponded;
    PDB_NODE        pNodeMissingGlue;

#if 0
    DWORD           cMissingGlueQueries;
    PDB_NODE        MissingGlueNodes[ MAX_GLUE_CHASING_ATTEMPTS ];
#endif

    NS_VISIT        NsList[ MAX_NS_LIST_COUNT ];
}
NS_VISIT_LIST, *PNS_VISIT_LIST;


//  Overload missing glue delegation on priority field
//  Note:  for Win64 this will also take SendTime field
/*
#define MISSING_GLUE_DELEGATION(pvisit) \
        ( *(PDB_NODE *)(&(pvisit)->Priority) )
*/


//
//  Verify that overlay will work
//
//  NS list currently kept in standard UDP packet buffer.
//

#if DBG
UCHAR   nslistcheckArray[
            DNS_UDP_ALLOC_LENGTH
            + sizeof(NS_VISIT) * (MAX_NS_LIST_COUNT - MAX_NS_RECURSION_ATTEMPTS)
            - sizeof(NS_VISIT_LIST) ];
#endif

//
//  Old overlay in additional section no longer in use.
//

//  DEVNOTE:  more space for overlay in recursion packet after
//      max DNS name + question -- the rest of standard message
//      is unused
//
//  DEVNOTE:  at minimum should add compression count space
//      and make sure NoCompressionWrite on when writing question
//
//  Note, that size of NS_VISIT_LIST in packet is NOT the C-defined
//  structure size, as it contains fewer NS entries.
//  The default size is larger in order to accomodate ALL the available
//  NS.  However if there are many only a reasonable number selected
//  on the basis of priority, will actually be contacted.
//

#if 0
#if DBG
UCHAR   nslistcheckArray[
            sizeof(ADDITIONAL_INFO)
            + sizeof(NS_VISIT) * (MAX_NS_LIST_COUNT - MAX_NS_RECURSION_ATTEMPTS)
            - sizeof(NS_VISIT_LIST) ];
#endif
#endif


//
//  Max sends on single recurse pass
//

#define RECURSE_PASS_MAX_SEND_COUNT     (3)



//
//  Recursion query\response timeouts (kept in ms)
//

//  server responds but after query timed out and retried

#define MAX_RESPONDING_PRIORITY     (DEFAULT_RECURSION_RETRY * 1000)

#define MAX_RECURSE_TIME_MS         (MAX_RECURSION_TIMEOUT * 1000)


//
//  Forwarders state tests
//

#define SET_DONE_FORWARDERS( pQuery )   ((pQuery)->nForwarder = (-1))

#define IS_FORWARDING( pQuery )         ((pQuery)->nForwarder > 0)

#define IS_DONE_FORWARDING( pQuery )    ((pQuery)->nForwarder < 0)


//
//  Macroize some useful tests
//

#define RECURSING_ORIGINAL_QUESTION(pQuery)     \
        ( (pQuery)->Head.AnswerCount == 0 && IS_SET_TO_WRITE_ANSWER_RECORDS(pQuery) )


//
//  Values to identify cache update queries
//      - root NS queries
//      - queries for missing glue
//

#define DNS_CACHE_UPDATE_QUERY_SOCKET   (0xfccccccf)
#define DNS_CACHE_UPDATE_QUERY_IP       (0xff000001)
#define DNS_CACHE_UPDATE_QUERY_XID      (1)

#define IS_CACHE_UPDATE_QUERY( pQuery ) \
                    ( (pQuery)->Socket == DNS_CACHE_UPDATE_QUERY_SOCKET )

#define DNS_INFO_VISIT_SERVER (0x4f000001)

#define SUSPENDED_QUERY( pMsg )     ( (PDNS_MSGINFO)(pMsg)->pchRecv )


//
//  Recursion functions (recurse.c)
//

VOID
FASTCALL
Recurse_Question(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PDB_NODE        pNodeClosest
    );

PDB_NODE
Recurse_CheckForDelegation(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode
    );

VOID
FASTCALL
Recurse_WriteReferral(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PDB_NODE        pNode
    );

VOID
Recurse_ProcessResponse(
    IN OUT  PDNS_MSGINFO    pResponse
    );

DNS_STATUS
Recurse_MarkNodeNsListDirty(
    IN      PDB_NODE        pNode
    );

DNS_STATUS
Recurse_DeleteNodeNsList(
    IN OUT  PDB_NODE        pNode
    );

BOOL
Recurse_SendCacheUpdateQuery(
    IN      PDB_NODE        pNode,
    IN      PDB_NODE        pNodeDelegation,
    IN      WORD            wType,
    IN      PDNS_MSGINFO    pQuerySuspended
    );

VOID
Recurse_ResumeSuspendedQuery(
    IN OUT  PDNS_MSGINFO    pUpdateQuery
    );

VOID
Recurse_SendToDomainForwarder(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PDB_NODE        pZoneRoot
    );


//
//  Global recursion startup and shutdown
//

BOOL
Recurse_InitializeRecursion(
    VOID
    );

VOID
Recurse_CleanupRecursion(
    VOID
    );

//
//  Recursion timeout thread
//

DWORD
Recurse_RecursionTimeoutThread(
    IN      LPVOID Dummy
    );

//
//  Remote DNS server routines (remote.c)
//

VOID
Remote_ListInitialize(
    VOID
    );

VOID
Remote_ListCleanup(
    VOID
    );

VOID
Remote_NsListCreate(
    IN OUT  PDNS_MSGINFO    pQuery
    );

VOID
Remote_NsListCleanup(
    IN OUT  PDNS_MSGINFO    pQuery
    );

VOID
Remote_InitNsList(
    IN OUT  PNS_VISIT_LIST  pNsList
    );

DNS_STATUS
Remote_BuildVisitListForNewZone(
    IN      PDB_NODE        pZoneRoot,
    IN OUT  PDNS_MSGINFO    pQuery
    );

DNS_STATUS
Remote_ChooseSendIp(
    IN OUT  PDNS_MSGINFO    pQuery,
    OUT     PIP_ARRAY       IpArray
    );

VOID
Remote_ForceNsListRebuild(
    IN OUT  PDNS_MSGINFO    pQuery
    );

PDB_NODE
Remote_FindZoneRootOfRespondingNs(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PDNS_MSGINFO    pResponse
    );

VOID
Remote_SetValidResponse(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PDB_NODE        pZoneRoot
    );

VOID
Remote_UpdateResponseTime(
    IN      IP_ADDRESS      IpAddress,
    IN      DWORD           ResponseTime,
    IN      DWORD           Timeout
    );

// Constants used by Remote_QuerySupportedEDnsVersion
// and Remote_SetSupportedEDnsVersion:
#define NO_EDNS_SUPPORT                 ((UCHAR)0xff)
#define UNKNOWN_EDNS_VERSION            ((UCHAR)0xfe)
#define IS_VALID_EDNS_VERSION(_ver)     ( _ver >= 0 && _ver < 6 )

UCHAR 
Remote_QuerySupportedEDnsVersion(
    IN      IP_ADDRESS      IpAddress
    );

VOID
Remote_SetSupportedEDnsVersion(
    IN      IP_ADDRESS      IpAddress,
    IN      UCHAR           EDnsVersion
    );



#endif // _DNS_RECURSE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\recurse.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    recurse.c

Abstract:

    Domain Name System (DNS) Server

    Routines to handle recursive queries.

Author:

    Jim Gilroy (jamesg)     March 1995

Revision History:

    jamesg  Dec 1995    -   Recursion timeout, retry

--*/


#include "dnssrv.h"

#include <limits.h>     // for ULONG_MAX


BOOL    g_fUsingInternetRootServers = FALSE;


//
//  Recursion queue info
//

PPACKET_QUEUE   g_pRecursionQueue;

#define DEFAULT_RECURSION_RETRY     (2)     // 2s before retry query
#define DEFAULT_RECURSION_TIMEOUT   (5)     // 5s before final fail of query


//
//  Root server query
//      - track last time sent and don't try full resend if within 10 minutes
//

DWORD   g_NextRootNsQueryTime = 0;

#define ROOT_NS_QUERY_RETRY_TIME    (600)       // 10 minutes


//
//  Private protos
//

BOOL
initializeQueryForRecursion(
    IN OUT  PDNS_MSGINFO    pQuery
    );

BOOL
initializeQueryToRecurseNewQuestion(
    IN OUT  PDNS_MSGINFO    pQuery
    );

DNS_STATUS
sendRecursiveQuery(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      IP_ADDRESS      ipNameServer,
    IN      DWORD           timeout
    );

VOID
recursionServerFailure(
    IN OUT  PDNS_MSGINFO    pQuery
    );

BOOL
startTcpRecursion(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN OUT  PDNS_MSGINFO    pResponse
    );

VOID
stopTcpRecursion(
    IN OUT  PDNS_MSGINFO    pMsg
    );

VOID
processRootNsQueryResponse(
    IN      PDNS_MSGINFO    pResponse,
    IN OUT  PDNS_MSGINFO    pQuery
    );

VOID
processCacheUpdateQueryResponse(
    IN OUT  PDNS_MSGINFO    pResponse,
    IN OUT  PDNS_MSGINFO    pQuery
    );

VOID
recurseConnectCallback(
    IN OUT  PDNS_MSGINFO    pRecurseMsg,
    IN      BOOL            fConnected
    );



VOID
FASTCALL
Recurse_WriteReferral(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Find and write referral to packet.

Arguments:

    pNode - ptr to node to start looking for referral;  generally
        this would be question node, or closest ancestor of it in database

    pQuery - query we are writing

Return Value:

    None

--*/
{
    register PDB_NODE   pnode;
    PDB_RECORD          prrNs;

    ASSERT( pQuery );

    IF_DEBUG( RECURSE )
    {
        DnsDbg_Lock();
        DNS_PRINT((
            "Recurse_WriteReferral for query at %p.\n",
            pQuery ));
        Dbg_NodeName(
            "Domain name to start iteration from is ",
            pNode,
            "\n" );
        DnsDbg_Unlock();
    }

    STAT_INC( RecurseStats.ReferralPasses );
    ASSERT( IS_SET_TO_WRITE_ANSWER_RECORDS(pQuery) ||
            IS_SET_TO_WRITE_AUTHORITY_RECORDS(pQuery) );

    SET_TO_WRITE_AUTHORITY_RECORDS(pQuery);

    //
    //  find closest zone root with NS
    //
    //  start at incoming node, and walk back up through database until
    //      find a name server, with an address record
    //

    Dbase_LockDatabase();
    SET_NODE_ACCESSED(pNode);
    pnode = pNode;

    while ( pnode != NULL )
    {
        DNS_DEBUG( RECURSE, (
            "Recursion at node label %.*s\n",
            pnode->cchLabelLength,
            pnode->szLabel ));

        //
        //  find "covering" zone root node
        //  switching to delegation if available
        //

        pnode = Recurse_CheckForDelegation(
                    pQuery,
                    pnode );
        if ( !pnode )
        {
            ASSERT( FALSE );
            break;
        }

        //  find name servers for this domain
        //      - if none, break out for next level in tree
        //
        //  protect against no-root server or unable to contact root
        //  if first NS record is ROOT_HINT, then we don't have any valid
        //  delegation information to send on and we're toast, move to parent
        //  which if we're at root, we'll kick out and SERVER_FAIL

        prrNs = RR_FindNextRecord(
                    pnode,
                    DNS_TYPE_NS,
                    NULL,
                    0 );
        if ( !prrNs  ||  IS_ROOT_HINT_RR(prrNs) )
        {
            pnode = pnode->pParent;

            //  if failed to find delegation NS -- bail
            //
            //  note, this can happen when:
            //      1) unable to contact root hints
            //      2) forwarding and have no root hints at all
            //

            if ( !pnode )
            {
                DNS_DEBUG( RECURSE, (
                    "ERROR:  Failed referral for query %p\n"
                    "\tsearched to root node\n",
                    pQuery ));
                break;
            }
            if ( IS_AUTH_NODE(pnode) )
            {
                DNS_DEBUG( RECURSE, (
                    "ERROR:  Failed referral for query %p\n"
                    "\tdelegation below %s in zone %s starting at node %s (%p)\n"
                    "\thas no NS records;  this may be possible as transient.\n",
                    pQuery,
                    pnode,
                    ((PZONE_INFO)pnode->pZone)->pszZoneName,
                    pNode->szLabel,
                    pNode ));
                ASSERT( FALSE );
                break;
            }
            continue;
        }

        Dbase_UnlockDatabase();

        //  have NS records,
        //  write NS and associated A records to the packet
        //
        //  DEVNOTE: zone holding delegation on referral?
        //      do we need to mark referral here and provide zone
        //      holding delegation -- if any?

        Answer_QuestionFromDatabase(
            pQuery,
            pnode,
            0,
            DNS_TYPE_NS );
        return;
    }

    //
    //  No referral name server's found!
    //      - should NEVER happen, as should always have root server
    //
    //  Since we don't track down rootNS records, we won't be
    //      able to refer either;  should launch rootNS query
    //      ??? should have mode where DON'T query root -- sort of no referral mode
    //      in other words server only useful for direct lookup?
    //

    Dbase_UnlockDatabase();

    DNS_DEBUG( ANY, ( "ERROR:  Unable to provide name server for referal.\n" ));

    if ( pQuery->Head.AnswerCount == 0 )
    {
        Reject_Request(
            pQuery,
            DNS_RCODE_SERVER_FAILURE,
            0 );
    }
    else
    {
        Send_QueryResponse( pQuery );
    }
}



BOOL
initializeQueryForRecursion(
    IN OUT  PDNS_MSGINFO    pQuery
    )
/*++

Routine Description:

    Initialize for query recursion.

        - allocating and initializing recursion block
        - allocate additional records block, if necessary

Arguments:

    pQuery -- query to recurse

Return Value:

    TRUE if successfully allocate recursion block.
    FALSE on allocation failure.

--*/
{
    PDNS_MSGINFO    pmsgRecurse;

    //
    //  allocate recursion message
    //

    ASSERT( pQuery->pRecurseMsg == NULL );

    pmsgRecurse = Msg_CreateSendMessage( 0 );
    IF_NOMEM( !pmsgRecurse )
    {
        return( FALSE );
    }

    STAT_INC( RecurseStats.QueriesRecursed );
    PERF_INC( pcRecursiveQueries );          // PerfMon hook
    STAT_INC( PacketStats.RecursePacketUsed );

    ASSERT( pmsgRecurse->fDelete == FALSE );
    ASSERT( pmsgRecurse->fTcp == FALSE );

    //
    //  link recursion message to query and vice versa
    //

    pQuery->pRecurseMsg = pmsgRecurse;
    pmsgRecurse->pRecurseMsg = pQuery;
    pmsgRecurse->fRecursePacket = TRUE;

    //
    //  NS IP visit list setup
    //

    Remote_NsListCreate( pQuery );

    //
    //  clear recursion flags
    //

    pQuery->fQuestionRecursed = FALSE;
    pQuery->fRecurseTimeoutWait = FALSE;
    return( TRUE );
}



BOOL
initializeQueryToRecurseNewQuestion(
    IN OUT  PDNS_MSGINFO    pQuery
    )
/*++

Routine Description:

    Initialize query to recurse new question.

Arguments:

    pQuery -- query to recurse

Return Value:

    TRUE if successfully wrote recursive message.
    FALSE if failure.

--*/
{
    PDNS_MSGINFO    pmsg;

    DNS_DEBUG( RECURSE, (
        "Init query at %p for recursion of new question, type %d.\n"
        "\tanswer count %d.\n"
        "\trecurse message at %p\n",
        pQuery,
        pQuery->wTypeCurrent,
        pQuery->Head.AnswerCount,
        pQuery->pRecurseMsg
        ));

    //
    //  set for new question being recursed
    //      - start at beginning of forwarders list
    //      - set for new query XID, queuing routine does assignment
    //      - reset visited list
    //

    pQuery->fQuestionCompleted = FALSE;
    pQuery->fRecurseQuestionSent = FALSE;
    pQuery->nForwarder = 0;
    pQuery->wQueuingXid = 0;

    Remote_InitNsList( (PNS_VISIT_LIST)pQuery->pNsList );

    //  catch failure to set on any recursive query

    pQuery->pnodeRecurseRetry = NULL;

    //
    //  build actual recursion message
    //      - note message is initialized on initial init for recursion
    //      - always start query with UDP
    //

    pmsg = pQuery->pRecurseMsg;
    ASSERT( pmsg );
    ASSERT( pmsg->fDelete == FALSE );
    ASSERT( pmsg->fTcp == FALSE );
    ASSERT( pmsg->pRecurseMsg == pQuery );
    ASSERT( pmsg->fRecursePacket );

    //
    //  recursing original question
    //      - optimize by just copying original packet
    //      - clear flags we set for response
    //          - response flag
    //          - recursion available
    //      - set pCurrent to get correct message length on send
    //      - need to also copy OPT information
    //

    pmsg->Opt.fInsertOptInOutgoingMsg = pQuery->Opt.fInsertOptInOutgoingMsg;

    if ( RECURSING_ORIGINAL_QUESTION(pQuery) )
    {
        //
        //  Make sure the recurse msg is large enough to hold the query.
        //  This can fail when processing a TCP query that is larger than
        //  the UDP packet size. Could be a malicious attack, or a badly
        //  formatted packet, or some future large query.
        //

        if ( pQuery->MessageLength > pmsg->MaxBufferLength )
        {
            DNS_DEBUG( RECURSE, (
                "attempt to recurse %d byte question with %d byte packet!\n",
                pQuery->MessageLength,
                pmsg->MaxBufferLength ));
            ASSERT( pQuery->MessageLength <= pmsg->MaxBufferLength );
            return FALSE;
        }

        STAT_INC( RecurseStats.OriginalQuestionRecursed );

        RtlCopyMemory(
            (PBYTE) DNS_HEADER_PTR(pmsg),
            (PBYTE) DNS_HEADER_PTR(pQuery),
            pQuery->MessageLength );

        pmsg->MessageLength = pQuery->MessageLength;
        pmsg->pCurrent = DNSMSG_END( pmsg );
        pmsg->Head.RecursionAvailable = 0;
        pmsg->Head.IsResponse = 0;
    }

    //  if recursing, for CNAME or additional info,
    //  then write question from node and type

    else
    {
        ASSERT( pQuery->Head.AnswerCount != 0 || pQuery->Head.NameServerCount != 0 );

        if ( ! Msg_WriteQuestion(
                    pmsg,
                    pQuery->pnodeCurrent,
                    pQuery->wTypeCurrent ))
        {
            ASSERT( FALSE );
            return( FALSE );
        }

        //
        //  By rewriting the question we have removed the OPT, so zero the offset
        //  to the old OPT so we don't try to use it later in Send_Msg().
        //

        if ( pmsg->Opt.wOptOffset )
        {
            pmsg->Opt.wOptOffset = 0;
            ASSERT( pmsg->Head.AdditionalCount > 0 );
            --pmsg->Head.AdditionalCount;
        }

        IF_DEBUG( RECURSE2 )
        {
            DnsDebugLock();
            //  DEVNOTE: don't message with this in debug code,
            //  DEVNOTE: have Dbg_DnsMessage figure out larger or MessageLength
            //              or pCurrent and go out that far

            pQuery->MessageLength = (WORD)DNSMSG_OFFSET( pQuery, pQuery->pCurrent );
            Dbg_DnsMessage(
                "Recursing message for CNAME or additional data",
                pQuery );
            Dbg_NodeName(
                "Recursing for name ",
                pQuery->pnodeCurrent,
                "\n" );
            Dbg_DnsMessage(
                "Recursive query to send",
                pmsg );
            DnsDebugUnlock();
        }
        STAT_INC( RecurseStats.AdditionalRecursed );
    }

    pQuery->fQuestionRecursed = TRUE;
    STAT_INC( RecurseStats.TotalQuestionsRecursed );

    return( TRUE );
}



BOOLEAN
recurseToForwarder(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PIP_ARRAY       aipForwarders,
    IN      BOOL            fSlave,
    IN      DWORD           timeout
    )
/*++

Routine Description:

    Handle all recursion to forwarding servers.

Arguments:

    pQuery -- query needing recursion

    aipForwarders -- array of servers to forward query to

    fSlave -- recursion after forward failure is not allowed

    timeout -- timeout to wait for response

Return Value:

    TRUE, if successful
    FALSE on error or done with forwarders

--*/
{
    IP_ADDRESS  ipForwarder;

    //
    //  verify using forwarders
    //

    if ( ! aipForwarders )
    {
        //  admin may have turned off forwarders, just now,
        //  do regular recursion

        TEST_ASSERT( FALSE );
        return( FALSE );
    }

    //
    //  out of forwarding addresses ?
    //      - if slave DONE -- fail -- set fRecurseTimeoutWait flag so we don't
    //          queue up the query for another try
    //      - else try standard recursion
    //

    if ( (DWORD)pQuery->nForwarder >= aipForwarders->AddrCount )
    {
        if ( fSlave )
        {
            DNS_DEBUG( RECURSE, ( "Slave timeout of packet %p.\n", pQuery ));
            pQuery->fRecurseTimeoutWait = TRUE;
            recursionServerFailure( pQuery );
            return( TRUE );
        }
        else
        {
            DNS_DEBUG( RECURSE, ( "End of forwarders on packet %p.\n", pQuery ));
            SET_DONE_FORWARDERS( pQuery );
            return( FALSE );
        }
    }

    //
    //  send packet to next forwarder in list
    //      - inc forwarder index
    //

    ipForwarder = aipForwarders->AddrArray[ pQuery->nForwarder ];
    pQuery->nForwarder++;

    //
    //  set explicit expiration timeout
    //
    //  forwarders timeout (a local LAN timeout) is likely less than
    //  default timeout for recursion queue (a reasonable Internet timeout)
    //

    DNS_DEBUG( RECURSE, (
        "Recursing query at %p to forwarders name server at %s.\n",
        pQuery,
        IP_STRING(ipForwarder) ));

    STAT_INC( RecurseStats.Forwards );

    sendRecursiveQuery(
        pQuery,
        ipForwarder,
        timeout );

    return( TRUE );
}



DNS_STATUS
/*++

Routine Description:

    This function performs the actual queuing and sending of a query.
    This is the guts of sendRecursiveQuery and can be used by functions
    needing to resend queries without any query processing.

Arguments:

    pQuery - ptr to query

    ipArray - array of IPs (NULL if RemoteAddress already set)

Return Value:

    ERROR_SUCCESS if successfully sent and queued

--*/
queueAndSendRecursiveQuery( 
    IN OUT          PDNS_MSGINFO    pQuery,
    IN OPTIONAL     PIP_ARRAY       ipArray )
{
    PDNS_MSGINFO    psendMsg;

    ASSERT( pQuery );
    psendMsg = pQuery->pRecurseMsg;
    ASSERT( psendMsg );
    ASSERT( psendMsg->pRecurseMsg == pQuery );  // check cross link

    //
    //  Enqueue original query in recursion queue
    //
    //  Note:
    //  Enqueue BEFORE send, so query on queue if another thread gets
    //  response.
    //  After queuing MUST NOT TOUCH pQuery as may be removed from
    //  queue and processed by another thread processing response.
    //

    EnterCriticalSection( & g_pRecursionQueue->csQueue );

    psendMsg->Head.Xid = PQ_QueuePacketWithXid(
                                g_pRecursionQueue,
                                pQuery );
    DNS_DEBUG( RECURSE, (
        "Recursing for queued query at %p\n"
        "\tqueuing XID = %hx\n"
        "\tqueuing time=%d, expire=%d\n"
        "\tSending msg at %p to NS at %s.\n",
        pQuery,
        psendMsg->Head.Xid,
        pQuery->dwQueuingTime,
        pQuery->dwExpireTime,
        psendMsg,
        IP_STRING( psendMsg->RemoteAddress.sin_addr.s_addr ) ));

    MSG_ASSERT( psendMsg, psendMsg->Head.Xid == pQuery->wQueuingXid );
    MSG_ASSERT( psendMsg, psendMsg->fDelete == FALSE );
    MSG_ASSERT( psendMsg, psendMsg->Head.IsResponse == FALSE );
    MSG_ASSERT( psendMsg, psendMsg->Head.RecursionAvailable == FALSE );

    //
    //  If no array, then the send msg must already contain the
    //  destination remote IP address.
    //

    if ( ipArray )
    {
        ASSERT( ( ( PIP_ARRAY ) ipArray )->AddrCount > 0 );

        Send_Multiple(
            psendMsg,
            ipArray,
            & RecurseStats.Sends );
    }
    else
    {
        Send_Msg( psendMsg );
    }

    IF_DEBUG( RECURSE2 )
    {
        Dbg_PacketQueue(
            "Recursion packet queue after recursive send",
            g_pRecursionQueue );
    }
    MSG_ASSERT( psendMsg, psendMsg->fDelete == FALSE );

    LeaveCriticalSection( & g_pRecursionQueue->csQueue );

    return( ERROR_SUCCESS );
} // queueAndSendRecursiveQuery




DNS_STATUS
sendRecursiveQuery(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      IP_ADDRESS      ipNameServer,
    IN      DWORD           timeout
    )
/*++

Routine Description:

    Send recursive query.

Arguments:

    pQuery - ptr to response info

    ipNameServer - IP address of name server to recurse to

    timeout - time to wait for response for, in seconds

Return Value:

    ERROR_SUCCESS if successfully send to remote machine, or
        query is otherwise eaten up and no longer in "control"
        of this thread (ex. missing glue query)
    DNSSRV_ERROR_OUT_OF_IP if no more NS IPs to send to hence
        caller can continue up the tree

--*/
{
    PDNS_MSGINFO    psendMsg;
    SOCKADDR_IN     saNameServer;
    DWORD           dwCurrentTime;

    DNS_DEBUG( RECURSE, (
        "sendRecursiveQuery at %p, to NS at %s (OPT=%s).\n",
        pQuery,
        IP_STRING( ipNameServer ),
        pQuery->Opt.fInsertOptInOutgoingMsg ? "TRUE" : "FALSE" ));

    //  should never send without having saved node to restart NS hunt
    //  unless this is a forwarder zone

    ASSERT( pQuery->pnodeRecurseRetry ||
            ( pQuery->pzoneCurrent &&
            IS_ZONE_FORWARDER( pQuery->pzoneCurrent ) ) );

    //
    //  get message for recursion
    //

    ASSERT( pQuery->pRecurseMsg );
    psendMsg = pQuery->pRecurseMsg;
    ASSERT( psendMsg->pRecurseMsg == pQuery );  // check cross link

    //
    //  set destination
    //      - set to send to NS IP address
    //      - inc queuing count
    //

    psendMsg->RemoteAddress.sin_addr.s_addr = ipNameServer;

    //
    //  repeating previously sent query?
    //

    if ( pQuery->fRecurseQuestionSent )
    {
        STAT_INC( RecurseStats.Retries );
    }
    pQuery->fRecurseQuestionSent = TRUE;

    //
    //  forwarding
    //      - single send to given forwarder
    //      - make a recursive query
    //      - set queuing expiration to forwarders timeout
    //

    if ( IS_FORWARDING( pQuery ) )
    {
        STAT_INC( RecurseStats.Sends );

        psendMsg->Head.RecursionDesired = 1;
        pQuery->dwExpireTime = timeout;

        queueAndSendRecursiveQuery( pQuery, NULL );
    }

    //
    //  not forwarding -- iterative query
    //      - iterative query
    //      - let recursion queue set expiration time
    //      (don't default these, as need to reset when reach end of
    //      forwarders list and switch to regular recursion)
    //
    //      - select "best" remote NS from list
    //      two failure states
    //          ERROR_MISSING_GLUE -- don't send but don't touch query
    //          ERROR_OUT_OF_IP -- don't send, but caller can continue
    //              up tree looking
    //

    else
    {
        DNS_STATUS      status;
        IP_ADDRESS      ipArray[ RECURSE_PASS_MAX_SEND_COUNT + 1 ];
        PIP_ARRAY       pIpArray = NULL;

        if ( ipNameServer == INADDR_NONE || ipNameServer == INADDR_ANY )
        {
            status = Remote_ChooseSendIp(
                        pQuery,
                        ( PIP_ARRAY ) ipArray );
            if ( status != ERROR_SUCCESS )
            {
                if ( status == DNSSRV_ERROR_MISSING_GLUE )
                {
                    status = ERROR_SUCCESS;
                }
                ELSE_ASSERT( status == DNSSRV_ERROR_OUT_OF_IP );
                return( status );
            }
            pIpArray = ( PIP_ARRAY ) ipArray;
        }

        psendMsg->Head.RecursionDesired = 0;
        pQuery->dwExpireTime = 0;

        queueAndSendRecursiveQuery( pQuery, pIpArray );
    }


    return( ERROR_SUCCESS );
}



VOID
recursionServerFailure(
    IN OUT  PDNS_MSGINFO    pQuery
    )
/*++

Routine Description:

    Recursion server failure.

    Send SERVER_FAILURE on recursion failure, but ONLY if question has
    NOT been answered.  If question answered send back.

Arguments:

    pQuery -- query to reply to

Return Value:

    TRUE, if successful
    FALSE on error.

--*/
{
    STAT_INC( RecurseStats.RecursionFailure );

#if DBG
    if( pQuery->Head.QuestionCount != 1 )
    {
        Dbg_DnsMessage(
            "Recursion server failure on message:",
            pQuery );
        ASSERT( pQuery->Head.QuestionCount == 1 );
    }
#endif

    //
    //  if self-generated cache update query
    //

    if ( IS_CACHE_UPDATE_QUERY(pQuery) )
    {
        DNS_DEBUG( RECURSE, (
            "ERROR:  Recursion failure, on cache update query at %p.\n"
            "\tNo valid response from any root servers\n",
            pQuery ));

        STAT_INC( RecurseStats.CacheUpdateFailure );

        if ( SUSPENDED_QUERY(pQuery) )
        {
            Recurse_ResumeSuspendedQuery( pQuery );
        }
        else
        {
            STAT_INC( RecurseStats.CacheUpdateFree );
            Packet_Free( pQuery );
        }
        return;
    }

    //
    //  already answered question
    //  recursion failure looking up additional records?
    //

    if ( pQuery->Head.AnswerCount > 0 )
    {
        DNS_DEBUG( RECURSE, (
            "Recursion failure, on answered query at %p.\n"
            "\tSending response.\n",
            pQuery ));
        ASSERT( pQuery->fDelete );
        STAT_INC( RecurseStats.PartialFailure );
        SET_OPT_BASED_ON_ORIGINAL_QUERY( pQuery );
        Send_Msg( pQuery );
        return;
    }

    //
    //  recursion/referral failure, on original question
    //
    //  if
    //      - have recursed question (have outstanding query)
    //      - NOT already gone through final wait
    //      - NOT past hard timeout
    //
    //  then requeue until final timeout, giving remote DNS a chance
    //  to respond
    //      - set expire time to end of final wait
    //      - set flag to indicate expiration is final expiration
    //

    if ( pQuery->fRecurseTimeoutWait )
    {
        STAT_INC( RecurseStats.FinalTimeoutExpired );
    }

    else if ( pQuery->fRecurseQuestionSent )
    {
        DWORD   deltaTime = DNS_TIME() - pQuery->dwQueryTime;

        if ( deltaTime < SrvCfg_dwRecursionTimeout )
        {
            pQuery->dwExpireTime = SrvCfg_dwRecursionTimeout - deltaTime;
            pQuery->fRecurseTimeoutWait = TRUE;

            PQ_QueuePacketWithXid(
                g_pRecursionQueue,
                pQuery );
            STAT_INC( RecurseStats.FinalTimeoutQueued );
            return;
        }
    }

    //
    //  otherwise failed
    //      - memory allocation failure
    //      - failure to get response to question within final timeout
    //

    DNS_DEBUG( RECURSE, (
        "Recursion failure on query at %p.\n"
        "\tSending SERVER_FAILURE response.\n",
        pQuery ));
    ASSERT( pQuery->fDelete );

    Reject_Request(
        pQuery,
        DNS_RCODE_SERVER_FAILURE,
        0 );
    STAT_INC( RecurseStats.ServerFailure );
}



//
//  Routines to process recursive response
//

VOID
Recurse_ProcessResponse(
    IN OUT  PDNS_MSGINFO    pResponse
    )
/*++

Routine Description:

    Process response from another DNS server.

    Note:  Caller frees pResponse message.

Arguments:

    pResponse - ptr to response info

Return Value:

    TRUE if successful
    FALSE otherwise

--*/
{
    PDNS_MSGINFO    pquery;
    PDNS_MSGINFO    precurseMsg;
    DNS_STATUS      status;

    ASSERT( pResponse != NULL );
    ASSERT( pResponse->Head.IsResponse );

    DNS_DEBUG( RECURSE, (
        "Recurse_ProcessResponse() for packet at %p.\n",
        pResponse ));

    STAT_INC( RecurseStats.Responses );

    //
    //  Locate matching query in recursion queue by XID.
    //

    pquery = PQ_DequeuePacketWithMatchingXid(
                g_pRecursionQueue,
                pResponse->Head.Xid );

    //
    //  no matching query?
    //
    //  this can happen if reponse comes back after timeout, or if when we
    //      send on multiple sockets
    //

    if ( !pquery )
    {
        IF_DEBUG( RECURSE )
        {
            EnterCriticalSection( & g_pRecursionQueue->csQueue );
            DNS_PRINT((
                "No matching recursive query for response at %p -- discarding.\n"
                "\tResponse XID = 0x%04x\n",
                pResponse,
                pResponse->Head.Xid ));
            Dbg_PacketQueue(
                "Recursion packet queue -- no matching response",
                g_pRecursionQueue );
            LeaveCriticalSection( & g_pRecursionQueue->csQueue );
        }
        STAT_INC( RecurseStats.ResponseUnmatched );
        return;
    }

    DNS_DEBUG( RECURSE, (
        "Matched response at %p, to original query at %p.\n",
        pResponse,
        pquery ));

    precurseMsg = pquery->pRecurseMsg;
    if ( !precurseMsg )
    {
        DnsDbg_Lock();
        Dbg_DnsMessage(
            "ERROR:  Queued recursive query without, message info.\n",
            pquery );
        Dbg_DnsMessage(
            "Response packet matched to query.\n",
            pResponse );
        DnsDbg_Unlock();
        ASSERT( FALSE );
        return;
    }

    MSG_ASSERT( pquery, precurseMsg->pRecurseMsg == pquery );
    MSG_ASSERT( pquery, precurseMsg->Head.Xid == pResponse->Head.Xid );

    //
    //  cleanup TCP recursion
    //      - close connection
    //      - reset for UDP is further queries
    //
    //  should NEVER have TCP response when recursion set for UDP;
    //  when reset to UDP, socket is closed and should be impossible
    //  to receive TCP response;  only possiblity is TCP response received
    //  then context switch to recursion timeout thread which shuts down
    //  TCP on recurse message
    //

    if ( precurseMsg->fTcp )
    {
        IF_DEBUG( RECURSE2 )
        if ( pResponse->fTcp )
        {
            STAT_INC( RecurseStats.TcpResponse );
            ASSERT( pResponse->Socket == precurseMsg->Socket );
        }
        else
        {
            DnsDbg_Lock();
            DNS_DEBUG( ANY, (
                "WARNING:  UDP response, on query %p doing TCP recursion!\n"
                "\tquery recursive msg = %p\n",
                pquery,
                precurseMsg ));
            Dbg_DnsMessage(
                "Recurse message set for TCP on UDP response",
                precurseMsg );
            Dbg_DnsMessage(
                "Response message",
                pResponse );
            DnsDbg_Unlock();
        }
        stopTcpRecursion( precurseMsg );
    }

    else if ( pResponse->fTcp )
    {
        DnsDbg_Lock();
        DNS_DEBUG( ANY, (
            "WARNING:  TCP response, on query %p doing UDP recursion!\n"
            "\tquery recursive msg = %p\n"
            "\tThis is possible if gave up on TCP connection and continued\n"
            "\trecursion with UDP\n",
            pquery,
            precurseMsg ));
        Dbg_DnsMessage(
            "Response message:",
            pResponse );
        Dbg_DnsMessage(
            "Recurse message:",
            precurseMsg );
        DnsDbg_Unlock();
    }

    //
    // If we added an OPT RR to the original query that appears to have
    // caused the target server to return failure, we must retry the
    // query without the OPT RR.
    //

    if ( ( pResponse->Head.ResponseCode == DNS_RCODE_FORMERR ||
           pResponse->Head.ResponseCode == DNS_RCODE_NOTIMPL ) &&
         precurseMsg->Opt.wOptOffset )
    {
        DNS_DEBUG( EDNS, (
            "remote server returned error so resend without OPT RR:\n"
            "\toriginal_query=%p recurse_msg=%p remote_rcode=%d remote_ip=%s\n",
            pquery,
            precurseMsg,
            pResponse->Head.ResponseCode,
            IP_STRING( pResponse->RemoteAddress.sin_addr.s_addr ) ));

        ASSERT( precurseMsg->Head.AdditionalCount );

        precurseMsg->pCurrent = DNSMSG_OPT_PTR( precurseMsg );
        precurseMsg->MessageLength =
            ( WORD ) DNSMSG_OFFSET( precurseMsg, precurseMsg->pCurrent );
        --precurseMsg->Head.AdditionalCount;
        precurseMsg->Opt.wOptOffset = 0;
        CLEAR_SEND_OPT( precurseMsg );
        precurseMsg->fDelete = FALSE;
        precurseMsg->Head.IsResponse = 0;

        //
        //  Reset query expire time. It will be set to the proper value
        //  when it is queued.
        // 

        pquery->dwExpireTime = 0;

        //
        //  In case the original query was sent via Send_Multiple,
        //  recopy the response source address to the outbound message.
        //

        precurseMsg->RemoteAddress = pResponse->RemoteAddress;

        queueAndSendRecursiveQuery( pquery, NULL );

        //
        //  Remember that this server does not support EDNS so we can 
        //  avoid unnecessary retries in the future.
        //

        Remote_SetSupportedEDnsVersion(
            pResponse->RemoteAddress.sin_addr.s_addr,
            NO_EDNS_SUPPORT );

        return;
    } // if

    //
    //  Validate the response.
    //

    if ( !Msg_NewValidateResponse( pResponse, precurseMsg, 0, 0 ) )
    {
        STAT_INC( RecurseStats.ResponseMismatched );

        DnsDbg_Lock();
        DNS_DEBUG( ANY, (
            "WARNING: dequeued query is not valid for response\n"
            "\tdequeued query recurse msg %p   response %p\n",
            precurseMsg,
            pResponse ));
        Dbg_DnsMessage(
            "Response received (not valid for query with same XID)",
            pResponse );
        Dbg_DnsMessage(
            "Query recurse msg with XID matching received response",
            precurseMsg );
        DnsDbg_Unlock();
        //  MSG_ASSERT( pquery, FALSE );
        Packet_Free( pquery );
        return;
    }

    //
    //  if self-generated cache update query
    //
    //      - write response into cache
    //      - return when found valid info, or search all NS
    //

    if ( IS_CACHE_UPDATE_QUERY(pquery) )
    {
        ASSERT( pquery->Head.Xid == DNS_CACHE_UPDATE_QUERY_XID );

        if ( SUSPENDED_QUERY(pquery) )
        {
            processCacheUpdateQueryResponse(
                pResponse,
                pquery );
        }
        else
        {
            processRootNsQueryResponse(
                pResponse,
                pquery );
        }
        return;
    }

    //
    //  truncated response
    //
    //  take simple approach here and NEVER cache a truncated response,
    //  go immediately and establish TCP connection
    //
    //  if TCP response has Truncation bit set, then it's a bad packet,
    //  ignore it and restart the recursion on the original query
    //
    //  DEVNOTE: need to be more intelligent on using TCP recursion
    //      if UDP query, should be able to use UDP response --
    //      even if we can't cache it all
    //      cache first -- obeying truncation rules -- then use response
    //      if possible
    //

    if ( pResponse->Head.Truncation )
    {
        //  if UDP response, attempt TCP recursion
        //
        //  note, connection failures are handled through callback
        //  before function return, all we need to do is fail back up
        //  call stack

        if ( !pResponse->fTcp )
        {
            startTcpRecursion(
                pquery,
                pResponse );
            return;
        }

        DnsDbg_Lock();
        DNS_DEBUG( ANY, (
            "ERROR:  TCP response with truncation bit set!!!!\n"
            "\tBAD DNS server -- hope it's not mine.\n",
            pResponse ));
        Dbg_DnsMessage(
            "Response message:",
            pResponse );
        Dbg_DnsMessage(
            "Recurse message:",
            precurseMsg );
        DnsDbg_Unlock();

        ASSERT( !pResponse->fTcp );

        Recurse_Question(
            pquery,
            NULL );
        return;
    }

    //  any response cancels final wait state as may lead to new DNS
    //  servers to recurse to

    pquery->fRecurseTimeoutWait = FALSE;

    //
    //  read packet RR into database
    //

    status = Recurse_CacheMessageResourceRecords( pResponse, pquery );

    //
    //  If we found an OPT in the response, save the remote server's
    //  supported EDNS version.
    //  Note: we could probably accept other RCODEs besides NOERROR.
    //

    if ( pResponse->Opt.fFoundOptInIncomingMsg &&
         pResponse->Head.ResponseCode == DNS_RCODE_NOERROR )
    {
        Remote_SetSupportedEDnsVersion(
            pResponse->RemoteAddress.sin_addr.s_addr,
            pResponse->Opt.cVersion );
    } // if

    //
    //  Make sure OPT flag is turned on for next search iteration.
    // 

    SET_SEND_OPT( pquery );
    SET_SEND_OPT( precurseMsg );

    switch ( status )
    {
    case ERROR_SUCCESS:

        //
        //  recursing original question
        //
        //  respond with response packet?
        //      - if no need to follow CNAME (other return code below)
        //      - if response is answer (not delegation)
        //      - if has required additional data
        //          - forwarding so full recursive response
        //          OR
        //          - query for type A (or other type that doesn't generate
        //          additional records) so no additional records can be
        //          OR
        //          - additional count > authority count; so presumably
        //          already have additional data for at least one answer
        //
        //  otherwise (delegation or potentially incomplete answer)
        //      => continue
        //
        //  Note, the problem to be eliminated by the additional data check:
        //      Across zone MX record
        //          foo.bar MX  10  mail.utexas.edu
        //      Iterative query of zone bar, brings response BUT does NOT include
        //          A record for host.
        //
        //  Now obviously we could try and recontruct packet, and "see" if any
        //  additional data needs to be queried for, but this is extraordinarily
        //  difficult.  Better is to just rebuild packet if we can't establish
        //  existence of data ourselves.  Making all the checks is important because
        //  forwarding packet gives MUCH more reliable response to client and is faster.
        //
        //  DEVNOTE: forward all successful forwarders responses for orig question?
        //      every valid forwarding response for original question should
        //      be forwarderable;  if it's not forwarder failed
        //

        if ( RECURSING_ORIGINAL_QUESTION( pquery ) )
        {
            if ( pResponse->Head.AnswerCount
                    &&
                ( IS_FORWARDING( pquery ) ||
                  IS_NON_ADDITIONAL_GENERATING_TYPE( pquery->wTypeCurrent ) ||
                  pResponse->Head.AdditionalCount > pResponse->Head.NameServerCount )
                    &&
                Send_RecursiveResponseToClient( pquery, pResponse ) )
            {
                break;
            }

            //  response was delegation or could not do direct send of
            //      response (eg. big TCP response to UDP client),
            //      then continue this query

            Answer_ContinueCurrentLookupForQuery( pquery );
            break;
        }

        //
        //  chasing CNAME or Additional data
        //      - on answer or delegation, continue we'll write records to
        //      response or recurse again with info from delegation
        //      - on authoritative empty response, just we write no records
        //      so move on to next query (avoiding possible spin)
        //

        Answer_ContinueCurrentLookupForQuery( pquery );
        break;

    case DNS_INFO_NO_RECORDS:

        //  This is an empty auth response. Send response to client if we 
        //  are working on the original query.

        if ( RECURSING_ORIGINAL_QUESTION( pquery ) &&
            Send_RecursiveResponseToClient( pquery, pResponse ) )
        {
            break;
        }
        STAT_INC( RecurseStats.ContinueNextLookup );
        Answer_ContinueNextLookupForQuery( pquery );
        break;

    case DNS_ERROR_NODE_IS_CNAME:

        //  if answer contains "unchased" cname, must build or own response
        //  and follow CNAME

        Answer_ContinueCurrentLookupForQuery( pquery );
        break;

    case DNS_ERROR_NAME_NOT_IN_ZONE:
    case DNS_ERROR_UNSECURE_PACKET:

        //  if unable to cache a record outside of zone of responding NS
        //  hence MUST continue query, may not send direct response

        Answer_ContinueCurrentLookupForQuery( pquery );
        break;

    case DNS_ERROR_RCODE_NAME_ERROR:
    case DNS_ERROR_RCODE_NXRRSET:

        //  name error or no RR set
        //      - if for original query, send on response
        //      - if chasing CNAME or Additional, then move on to
        //      next query as we can write no records for this query

        if ( RECURSING_ORIGINAL_QUESTION(pquery) &&
            Send_RecursiveResponseToClient( pquery, pResponse ) )
        {
            break;
        }
        else
        {
            STAT_INC( RecurseStats.ContinueNextLookup );
            Answer_ContinueNextLookupForQuery( pquery );
            break;
        }

    case DNS_ERROR_RCODE:
    case DNS_ERROR_BAD_PACKET:
    case DNS_ERROR_INVALID_NAME:
    case DNS_ERROR_CNAME_LOOP:

        //
        //  bad response
        //      - problem with remote server
        //      - busted name, or RR data format error detected
        //      - CNAME given generates loop
        //
        //  continue trying current lookup with other servers
        //

        //
        //  DEVNOTE: message errors could indicate corrupted packet
        //              and be worth redoing query to this NS?  problem
        //              would be termination to avoid loop
        //
        //  DEVNOTE: removing CNAME loop?  if new info is good?
        //
        //      would want to delete entire loop in cache and allow rebuild
        //

        pquery->fQuestionCompleted = FALSE;
        STAT_INC( RecurseStats.ContinueCurrentRecursion );

        Recurse_Question(
            pquery,
            NULL );
        break;

    case DNS_ERROR_RCODE_SERVER_FAILURE:

        //
        //  local server failure to process packet
        //      -- some problem creating nodes or records, (out of memory?)
        //
        //  send server failure message
        //      this frees pquery

        ASSERT( pquery->fDelete );

        Reject_Request(
            pquery,
            DNS_RCODE_SERVER_FAILURE,
            0 );
        break;

    default:

        // must have added new error code to function

        DNS_PRINT((
            "ERROR:  unknown status %p (%d) from CacheMessageResourceRecords()\n",
            status, status ));
        MSG_ASSERT( pquery, FALSE );
        Packet_Free( pquery );
        return;
    }
}



//
//  Initialization and cleanup
//

BOOL
Recurse_InitializeRecursion(
    VOID
    )
/*++

Routine Description:

    Initializes recursion to other DNS servers.

Arguments:

    None

Return Value:

    TRUE, if successful
    FALSE on error.

--*/
{
    //
    //  create recursion queue
    //      - set non-zero timeout\retry
    //      - set timeout to recursion retry timeout
    //      - no event on queuing
    //      - no queuing flags
    //
    //  JENHANCE:  what recursion really needs is XID hash
    //

    if ( SrvCfg_dwRecursionRetry == 0 )
    {
        SrvCfg_dwRecursionRetry = DEFAULT_RECURSION_RETRY;
    }

    ASSERT( SrvCfg_dwRecursionTimeout != 0 );
    if ( SrvCfg_dwRecursionTimeout == 0 )
    {
        SrvCfg_dwRecursionTimeout = DEFAULT_RECURSION_TIMEOUT;
    }

    ASSERT( SrvCfg_dwAdditionalRecursionTimeout != 0 );
    if ( SrvCfg_dwAdditionalRecursionTimeout == 0 )
    {
        SrvCfg_dwAdditionalRecursionTimeout = DEFAULT_RECURSION_TIMEOUT;
    }

    g_pRecursionQueue = PQ_CreatePacketQueue(
                            "Recursion",
                            0,              // no special flags
                            SrvCfg_dwRecursionRetry );
    if ( !g_pRecursionQueue )
    {
        goto RecursionInitFailure;
    }

    //  init root NS query

    g_NextRootNsQueryTime = 0;

    //
    //  init remote list
    //

    Remote_ListInitialize();

    //
    //  create recusion timeout thread
    //

    if ( ! Thread_Create(
                "Recursion Timeout",
                Recurse_RecursionTimeoutThread,
                NULL,
                0 ) )
    {
        goto RecursionInitFailure;
    }

    //
    //  indicate successful initialization
    //
    //  no protection is required on setting this as it is done
    //  only during startup database parsing
    //

    DNS_DEBUG( INIT, ( "Recursion queue at %p.\n", g_pRecursionQueue ));
    return( TRUE );

RecursionInitFailure:

    DNS_LOG_EVENT(
        DNS_EVENT_RECURSION_INIT_FAILED,
        0,
        NULL,
        NULL,
        GetLastError()
        );
    return( FALSE );

}   //  Recurse_InitializeRecursion



VOID
Recurse_CleanupRecursion(
    VOID
    )
/*++

Routine Description:

    Cleanup recursion for restart.

Arguments:

    None

Return Value:

    None

--*/
{
    //  cleanup recursion queue

    PQ_CleanupPacketQueueHandles( g_pRecursionQueue );

    //  cleanup remote list

    Remote_ListCleanup();
}



//
//  TCP Recursion
//

VOID
recurseConnectCallback(
    IN OUT  PDNS_MSGINFO    pRecurseMsg,
    IN      BOOL            fConnected
    )
/*++

Routine Description:

    Callback when TCP forwarding routines complete connect.

    If connected -- send recursive query
    If not -- continue lookup on query

Arguments:

    pRecurseMsg -- recursive message

    fConnected -- connect to remote DNS completed

Return Value:

    None

--*/
{
    PDNS_MSGINFO    pquery;

    ASSERT( pRecurseMsg );
    ASSERT( !pRecurseMsg->pConnection );

    DNS_DEBUG( RECURSE, (
        "recurseConnectCallback( %p )\n"
        "\tremote DNS = %s\n"
        "\tconnect successful = %d\n",
        pRecurseMsg,
        IP_STRING( pRecurseMsg->RemoteAddress.sin_addr.s_addr ),
        fConnected ));

    pquery = pRecurseMsg->pRecurseMsg;

    ASSERT( pquery );
    ASSERT( pquery->fQuestionRecursed == TRUE );

    //
    //  send recursive query
    //
    //  note:  nothing special to setup query, same query as UDP request
    //  to the server -- uses same logic as recursion to a new server
    //
    //  clear pConnection ptr, simply as indication that connection no longer
    //  "owns" this message -- i.e. there's no ptr to message in connection
    //  object AND hence message will no longer be cleaned up by timeouts
    //  from the connection list;  (not sure this is best approach, but it
    //  squares with typical TCP recv -- pConnection set NULL when message
    //  dispatched to normal server processing)
    //

    if ( fConnected )
    {
        ASSERT( pRecurseMsg->fTcp );

        STAT_INC( RecurseStats.TcpQuery );

        sendRecursiveQuery(
            pquery,
            pRecurseMsg->RemoteAddress.sin_addr.s_addr,
            SrvCfg_dwForwardTimeout );
    }

    //
    //  connection failed
    //      continue with this query
    //

    else
    {
        IF_DEBUG( RECURSE )
        {
            Dbg_DnsMessage(
                "Failed TCP connect recursive query",
                pRecurseMsg );
            DNS_PRINT((
                "Rerecursing query %p after failed recursive TCP connect.\n",
                pquery ));
        }
        ASSERT( !pRecurseMsg->fTcp );

        Recurse_Question(
            pquery,
            NULL );
    }
}



BOOL
startTcpRecursion(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN OUT  PDNS_MSGINFO    pResponse
    )
/*++

Routine Description:

    Do TCP recursion for query.

    Send TCP recursive query, for desired query.
    Note:

Arguments:

    pQuery -- query to recurse;  note this routine takes control of pQuery,
        requeuing or ultimately freeing;  caller MUST NOT free

    pResponse -- truncated response from remote DNS, that causes TCP recursion

Return Value:

    TRUE if successfully launch TCP connection.
    FALSE on allocation failure.

--*/
{
    PDNS_MSGINFO    pmsg;
    IP_ADDRESS      ipServer = pResponse->RemoteAddress.sin_addr.s_addr;

    IF_DEBUG( RECURSE )
    {
        DNS_PRINT((
            "Encountered truncated recursive response %p,\n"
            "\tfor query %p.\n"
            "\tTCP recursion to server %s\n",
            pResponse,
            pQuery,
            IP_STRING(ipServer) ));
        Dbg_DnsMessage(
            "Truncated recursive response:",
            pResponse );
    }

    TEST_ASSERT( pResponse->fTcp == FALSE );

    STAT_INC( RecurseStats.TcpTry );

    //
    //  make connection attempt
    //
    //  on failure, the recurseConnectCallback() callback
    //  was called (with fConnected=FALSE);
    //  it will continue Recurse_Question() on query
    //  so we must not touch query -- it may well be long gone
    //  by now;  instead return up call stack to UDP receiver
    //

    return  Tcp_ConnectForForwarding(
                pQuery->pRecurseMsg,
                ipServer,
                recurseConnectCallback );
}



VOID
stopTcpRecursion(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Stop TCP recursion for query.
        - close TCP connection
        - reset recursion info for further queries as UDP

    Note caller does any query continuation logic, which may be
    requerying (from timeout thread) or processing TCP response
    (from worker thread).

Arguments:

    pMsg -- recurse message using TCP

Return Value:

    TRUE if successfully allocate recursion block.
    FALSE on allocation failure.

--*/
{
    DNS_DEBUG( RECURSE, (
        "stopTcpRecursion() for recurse message at %p.\n",
        pMsg ));

    //
    //  delete connection to server
    //
    //  note:  we don't cleanup connection;
    //  TCP thread cleans up connection when connection times out;
    //  if we cleanup, would free message that TCP thread could be
    //  processing right now;
    //
    //  DEVNOTE: TCP connection removal
    //  only interesting thing to do here would be to move up timeout
    //  to now;  however, unless you're going to wake TCP thread, that's
    //  probably useless as next select() wakeup is almost certainly for
    //  this timeout (unless lots of outbound TCP connections)
    //
    //  once completion port, can try closing handle, (but who cleans up
    //  message is still problematic -- another thread could have just
    //  recv'd and be processing message);  key element would be making
    //  sure message complete\non-complete before redropping i/o
    //

    // Tcp_ConnectionDeleteForSocket( pMsg->Socket, NULL );

    ASSERT( pMsg->pRecurseMsg );
    ASSERT( pMsg->fTcp );

    STAT_INC( PrivateStats.TcpDisconnect );

    //
    //  reset for UDP query
    //

    pMsg->pConnection = NULL;
    pMsg->fTcp = FALSE;
    pMsg->Socket = g_UdpSendSocket;
}



//
//  Cache update routines
//

BOOL
Recurse_SendCacheUpdateQuery(
    IN      PDB_NODE        pNode,
    IN      PDB_NODE        pNodeDelegation,
    IN      WORD            wType,
    IN      PDNS_MSGINFO    pQuerySuspended
    )
/*++

Routine Description:

    Send query for desired node and type to update info in cache.

    This is used for for root NS and for finding NS-host glue A records.

Arguments:

    pNode -- node to query at

    wType -- type of query

    pQuerySuspended -- query being suspended while making this query;  NULL if
        no query being suspended

Return Value:

    TRUE -- making query, if pQuerySuspended given it should be suspended
    FALSE -- unable to make query

--*/
{
    PDNS_MSGINFO    pquery;

    DNS_DEBUG( RECURSE, (
        "sendServerCacheUpdateQuery() for node label %s, type %d\n",
        pNode->szLabel,
        wType ));

    //
    //  if in authoritative zone, query pointless
    //

    if ( IS_AUTH_NODE(pNode) )
    {
        DNS_DEBUG( RECURSE, (
            "ERROR:  Recursing for root-NS or glue in authoritative zone.\n" ));
        return( FALSE );
    }

    //
    //  create/clear message info structure
    //

    pquery = Msg_CreateSendMessage( 0 );
    IF_NOMEM( !pquery )
    {
        return( FALSE );
    }

    //  cache update query

    if ( ! Msg_WriteQuestion(
                pquery,
                pNode,
                wType ) )
    {
        DNS_PRINT(( "ERROR:  Unable to write cache update query.\n" ));
    }

    STAT_INC( RecurseStats.CacheUpdateAlloc );

    //
    //  suspended query?
    //      - never send cache update query for another cache update query
    //      - limit total attempts for any given query
    //      both of these are supposed to have been done when verifying whether
    //          node has "chaseable glue"
    //   save off node we are querying so don't query it again for glue
    //

    if ( pQuerySuspended )
    {
        ASSERT( !IS_CACHE_UPDATE_QUERY(pQuerySuspended) );
        STAT_INC( RecurseStats.SuspendedQuery );
    }

    //
    //  only other currently supported type is root-NS query
    //      (see call below)

    ELSE_ASSERT( pNode == DATABASE_CACHE_TREE && wType == DNS_TYPE_NS );


    //
    //  tag query to easily id when response comes back
    //  save info
    //      - need current node to relaunch query if bad response or timeout
    //      - need current type for checking response
    //      - other pquery parameters are NOT needed as we'll never go write
    //          answers for this query
    //

    ASSERT( !pquery->pRecurseMsg );

    pquery->Socket = DNS_CACHE_UPDATE_QUERY_SOCKET;
    pquery->RemoteAddress.sin_addr.s_addr = DNS_CACHE_UPDATE_QUERY_IP;
    pquery->Head.Xid = DNS_CACHE_UPDATE_QUERY_XID;

    SUSPENDED_QUERY( pquery ) = pQuerySuspended;

    pquery->dwQueryTime = DNS_TIME();

    SET_TO_WRITE_ANSWER_RECORDS( pquery );
    pquery->fRecurseIfNecessary = TRUE;
    pquery->wTypeCurrent        = wType;
    pquery->pnodeCurrent        = pNode;
    pquery->pnodeRecurseRetry   = pNode;
    pquery->pnodeDelegation     = pNodeDelegation;

    ASSERT( !pquery->pnodeClosest       &&
            !pquery->pzoneCurrent       &&
            !pquery->pnodeGlue          &&
            !pquery->pnodeCache         &&
            !pquery->pnodeCacheClosest );

    IF_DEBUG( RECURSE2 )
    {
        Dbg_DnsMessage(
            "Server generated query being sent via recursion:",
            pquery );
    }

    Recurse_Question(
        pquery,
        pNode );
    return( TRUE );

}   //  Recurse_SendCacheUpdateQuery



VOID
Recurse_ResumeSuspendedQuery(
    IN OUT  PDNS_MSGINFO    pUpdateQuery
    )
/*++

Routine Description:

    Resume query suspended for cache update query.

Arguments:

    pUpdateQuery -- cache update query

Return Value:

    None.

--*/
{
    DNS_DEBUG( RECURSE, (
        "Recurse_ResumeSuspendedQuery( %p )\n"
        "\tsuspended query %p\n",
        pUpdateQuery,
        SUSPENDED_QUERY(pUpdateQuery) ));

    if ( SUSPENDED_QUERY(pUpdateQuery) )
    {
        STAT_INC( RecurseStats.ResumeSuspendedQuery );

        Recurse_Question(
            SUSPENDED_QUERY( pUpdateQuery ),
            NULL        // resume hunt for NS at same node in tree
            );
    }

    //  only other query type is root NS query

    ELSE_ASSERT( pUpdateQuery->wTypeCurrent == DNS_TYPE_NS &&
                 pUpdateQuery->pnodeCurrent == DATABASE_CACHE_TREE );


    STAT_INC( RecurseStats.CacheUpdateFree );
    Packet_Free( pUpdateQuery );
}



VOID
processCacheUpdateQueryResponse(
    IN OUT  PDNS_MSGINFO    pResponse,
    IN OUT  PDNS_MSGINFO    pQuery
    )
/*++

Routine Description:

    Process response to query made to update cache file entry.

Arguments:

    pResponse - ptr to response info;  caller must free

    pQuery - ptr to cache update query;  query is freed or requeued

Return Value:

    TRUE if successful
    FALSE otherwise

--*/
{
    DNS_STATUS      status;
    PDNS_MSGINFO    pquerySuspended;

    ASSERT( pResponse != NULL );
    ASSERT( pQuery != NULL );

    DNS_DEBUG( RECURSE, ( "processCacheUpdateQueryResponse()\n" ));
    IF_DEBUG( RECURSE2 )
    {
        Dbg_DnsMessage(
            "Cache update query response:",
            pResponse );
    }
    STAT_INC( RecurseStats.CacheUpdateResponse );

    //  recover suspended query (if any)

    pquerySuspended = SUSPENDED_QUERY( pQuery );
    if ( !pquerySuspended )
    {
        //  DEVNOTE: Beta2, tie root NS query in here

        ASSERT( FALSE );
        STAT_INC( RecurseStats.CacheUpdateFree );
        Packet_Free( pQuery );
        return;
    }
    ASSERT( pquerySuspended->fDelete );

    //
    //  read packet RR into database
    //

    status = Recurse_CacheMessageResourceRecords( pResponse, pQuery );

    switch ( status )
    {
    case ERROR_SUCCESS:

        //
        //  two possibilities
        //      - wrote NS A record => resume suspended query
        //      - wrote delegation => continue looking up NS info
        //

        if ( pResponse->Head.AnswerCount )
        {
            //  invalidate any previous NS list info at node we're currently
            //      querying

            Remote_ForceNsListRebuild( pquerySuspended );
            Recurse_ResumeSuspendedQuery( pQuery );
        }
        else
        {
            DNS_DEBUG( RECURSE, (
                "Cache update response at %p provides delegation.\n"
                "\tContinuing recursion of cache update query at %p\n",
                pResponse,
                pQuery ));

            STAT_INC( RecurseStats.CacheUpdateRetry );
            pQuery->fQuestionCompleted = FALSE;
            Recurse_Question(
                pQuery,
                pQuery->pnodeCurrent );
        }
        break;

    case DNS_INFO_NO_RECORDS:

        //  Empty authoritative response => resume suspended query

        DNS_DEBUG( RECURSE, (
            "Cache update response at %p was empty auth response.\n"
            "\tResuming suspended query at %p\n",
            pResponse,
            pquerySuspended ));
        Remote_ForceNsListRebuild( pquerySuspended );
        Recurse_ResumeSuspendedQuery( pQuery );
        break;

    case DNS_ERROR_RCODE_NAME_ERROR:
    case DNS_ERROR_CNAME_LOOP:

        //  failed to get useful response
        //  continue suspended query hopefully, there's another NS that
        //  we can track down

        DNS_DEBUG( RECURSE, (
            "Cache update response at %p useless, no further attempt will\n"
            "\tbe made to update info for this name server.\n"
            "\tResuming suspended query at %p\n",
            pResponse,
            pquerySuspended ));

        Recurse_ResumeSuspendedQuery( pQuery );
        break;

    case DNS_ERROR_RCODE:
    case DNS_ERROR_BAD_PACKET:
    case DNS_ERROR_INVALID_NAME:

        //  bad response
        //      - problem with remote server
        //      - busted name, or RR data format error detected
        //  continue attempt to update cache with other servers

        DNS_DEBUG( RECURSE, (
            "Cache update response at %p bad or invalid.\n"
            "\tContinuing recursion of cache update query at %p\n",
            "\tResuming suspended query at %p\n",
            pResponse,
            pQuery ));

        STAT_INC( RecurseStats.CacheUpdateRetry );
        Recurse_Question(
            pQuery,
            NULL );
        break;

    case DNS_ERROR_RCODE_SERVER_FAILURE:
    default:

        //  local server failure to process packet
        //      -- some problem creating nodes or records, (out of memory?)
        //
        //  send server failure message
        //      this frees suspended query

        DNS_DEBUG( RECURSE, (
            "Server failure on cache update response at %p\n", pQuery ));

        Recurse_ResumeSuspendedQuery( pQuery );
        break;
    }
}



//
//  Cache update -- root-NS query
//

VOID
sendRootNsQuery(
    VOID
    )
/*++

Routine Description:

    Send query for root NS.

Arguments:

    None

Return Value:

    None.

--*/
{
    //
    //  if recently queried, don't requery
    //

    if ( g_NextRootNsQueryTime >= DNS_TIME() )
    {
        DNS_DEBUG( RECURSE, (
            "sendRootNsQuery() -- skipping\n"
            "\tg_NextRootNsQueryTime = %d\n"
            "\tDNS_TIME = %d\n",
            g_NextRootNsQueryTime,
            DNS_TIME() ));
        return;
    }

    DNS_DEBUG( RECURSE, ( "sendRootNsQuery()\n" ));

    g_NextRootNsQueryTime = DNS_TIME() + ROOT_NS_QUERY_RETRY_TIME;
    STAT_INC( RecurseStats.RootNsQuery );

    //
    //  call cache update query
    //      - query database root
    //      - for NS
    //

    Recurse_SendCacheUpdateQuery(
        DATABASE_CACHE_TREE,
        NULL,               // no delegation
        DNS_TYPE_NS,
        NULL                // no suspended query
        );
}



VOID
processRootNsQueryResponse(
    PDNS_MSGINFO    pResponse,
    PDNS_MSGINFO    pQuery
    )
/*++

Routine Description:

    Process response to query made to update cache file entry.

Arguments:

    pResponse - ptr to response info;  caller must free

    pQuery - ptr to cache update query;  query is freed or requeued

Return Value:

    TRUE if successful
    FALSE otherwise

--*/
{
    DNS_STATUS  status;

    ASSERT( pResponse != NULL );
    ASSERT( pQuery != NULL );

    DNS_DEBUG( RECURSE, ( "processRootNsQueryResponse()\n" ));
    IF_DEBUG( RECURSE2 )
    {
        Dbg_DnsMessage(
            "Root NS query response:",
            pResponse );
    }

    STAT_INC( RecurseStats.RootNsResponse );

    //
    //  read packet RR into database
    //

    status = Recurse_CacheMessageResourceRecords( pResponse, pQuery );

    //
    //  if successfully read records, and server if authoritative,
    //      then we are done
    //
    //  DEVNOTE: write back cache file or at least mark dirty
    //

    if ( status == ERROR_SUCCESS
            &&
        ( pResponse->Head.Authoritative
            ||
          IS_FORWARDING(pQuery) ) )
    {
        DNS_DEBUG( RECURSE, (
            "Successfully wrote root NS query response at %p.\n",
            pResponse ));
        IF_DEBUG( RECURSE2 )
        {
            Dbg_DnsMessage(
                "Root NS query now being freed:",
                pQuery );
        }

        STAT_INC( RecurseStats.CacheUpdateFree );
        Packet_Free( pQuery );
        return;
    }

    //
    //  any failure processing packet, or non-authoritative response
    //      keep trying servers, possibly using any information cached
    //      from this packet
    //
    //  note query freed on successful termination (above block) or
    //      out of NS, recursionServerFailure()
    //

    else
    {
        DNS_DEBUG( RECURSE, (
            "Root NS query caching failure %p or non-authoritative response at %p.\n",
            status,
            pResponse ));
        STAT_INC( RecurseStats.CacheUpdateRetry );
        Recurse_Question(
            pQuery,
            NULL );
        return;
    }
}



//
//  Recursion timeout thread
//

DWORD
Recurse_RecursionTimeoutThread(
    IN      LPVOID      Dummy
    )
/*++

Routine Description:

    Thread to retry timed out requests on the recursion queue.

Arguments:

    Dummy - unused

Return Value:

    Exit code.
    Exit from DNS service terminating or error in wait call.

--*/
{
    PDNS_MSGINFO    pquery;                     // timed out query
    DWORD           err;
    DWORD           timeout;                    // next timeout
    DWORD           timeoutWins = ULONG_MAX;    // next WINS timeout

    //
    //  this thread keeps current time which allows all other
    //  threads to skip the system call
    //

    UPDATE_DNS_TIME();

    DNS_DEBUG( RECURSE, (
        "Starting recursion timeout thread at %d.\n",
        DNS_TIME() ));

    //
    //  loop until service exit
    //
    //  execute this loop whenever a packet on the queue times out
    //      or
    //  once every timeout interval to check on the arrival of new
    //      packets in the queue
    //

    while ( TRUE )
    {
        //  Check and possibly wait on service status
        //  doing this at top of loop, so we hold off any processing
        //  until zones are loaded

        if ( ! Thread_ServiceCheck() )
        {
            DNS_DEBUG( SHUTDOWN, ( "Terminating recursion timeout thread.\n" ));
            return( 1 );
        }

        UPDATE_DNS_TIME();

        //
        //  Verify \ fix UDP receive
        //

        UDP_RECEIVE_CHECK();

        //
        //  Timed out recursion queries?
        //      - find original query and retry with next server
        //        OR
        //      - get interval to next possible timeout
        //

        while ( pquery = PQ_DequeueTimedOutPacket(
                            g_pRecursionQueue,
                            & timeout ) )
        {
            DNS_DEBUG( RECURSE, (
                "Recursion timeout of query at %p (total time %d)\n",
                pquery,
                TIME_SINCE_QUERY_RECEIVED( pquery ) ));

            MSG_ASSERT( pquery, pquery->pRecurseMsg );
            MSG_ASSERT( pquery, pquery->fQuestionRecursed );
            MSG_ASSERT( pquery, pquery->fRecurseQuestionSent );

            STAT_INC( RecurseStats.PacketTimeout );
            PERF_INC( pcRecursiveTimeOut );          // PerfMon hook

            ++pquery->nTimeoutCount;

            #if 1
            {
                //
                //  We must record that the remote server timed out!
                //  JJW: can't do it this way - we have no way to know who the
                //  frig timed out? what if we did a multiple send - we don't
                //  know which server to kill... but it's okay - it's enough
                //  that we don't ever improve a timed out server's priority - 
                //  that will keep it from being used often
                //

                PNS_VISIT_LIST  pvisitList = ( PNS_VISIT_LIST )( pquery->pNsList );
                PNS_VISIT       pvisitLast;

                //  ASSERT( pvisitList->VisitCount > 0 );

                if ( pvisitList && pvisitList->VisitCount > 0 )
                {
                    pvisitLast =
                        &pvisitList->NsList[ pvisitList->VisitCount - 1 ];
                    Remote_UpdateResponseTime(
                        pvisitLast->IpAddress,
                        0,                          //  response time in usecs
                        TIME_SINCE_QUERY_RECEIVED( pquery ) );  //  timeout
                }
            }
            #endif

            //
            //  timeout of FINAL recursion wait => send SERVER_FAILURE
            //

            if ( pquery->fRecurseTimeoutWait )
            {
                recursionServerFailure( pquery );
                continue;
            }

            //
            //  cleanup TCP recursion
            //      - close connection
            //      - reset for UDP is further queries
            //

            if ( pquery->pRecurseMsg->fTcp )
            {
                stopTcpRecursion( pquery->pRecurseMsg );
            }

            //
            //  If are recursing for additional RRs and this query has
            //  been in progress for a significant amount of time, return
            //  what we've got to the client now.
            //

            if ( IS_SET_TO_WRITE_ADDITIONAL_RECORDS( pquery ) &&
                TIME_SINCE_QUERY_RECEIVED( pquery ) >
                    SrvCfg_dwAdditionalRecursionTimeout )
            {
                DNS_DEBUG( RECURSE, (
                    "Query %p was received %d seconds ago and is still "
                    "chasing additional data\n"
                    "\tsending current result to client now (max is %d seconds)\n",
                    pquery,
                    TIME_SINCE_QUERY_RECEIVED( pquery ),
                    SrvCfg_dwAdditionalRecursionTimeout ));

                pquery->MessageLength = DNSMSG_CURRENT_OFFSET( pquery );

                //
                //  We may be unable to send the response to the client if
                //  there is an issue with EDNS packet sizes. If the client's
                //  advertised packet size is smaller than the size of answer 
                //  we've accumulated, we need to regenerate the answer so that 
                //  it can be sent to the client.
                //

                if ( !Send_RecursiveResponseToClient( pquery, pquery ) )
                {
                    Answer_ContinueCurrentLookupForQuery( pquery );
                }
                continue;
            }

            //
            //  resend to next NS or forwarder
            //

            Recurse_Question(
                pquery,
                NULL );
        }

        //  Recursion timeout may have taken up some cycles,
        //  so reset timer

        UPDATE_DNS_TIME();

        DNS_DEBUG( OFF, (
            "RTT after r-queue before WINS at %d.\n",
            DNS_TIME() ));


        //
        //  Timed out WINS packet?
        //      - dequeue timed out packets
        //      - continue WINS lookup if more WINS servers
        //      - otherwise continue lookup on query
        //          - NAME_ERROR if lookup for original question
        //      OR
        //      - get interval to next possible timeout
        //

        if ( SrvCfg_fWinsInitialized )
        {
            while ( pquery = PQ_DequeueTimedOutPacket(
                                g_pWinsQueue,
                                & timeoutWins ) )
            {
                DNS_DEBUG( WINS, (
                    "WINS queue timeout of query at %p.\n",
                    pquery ));
                ASSERT( pquery->fWins );
                ASSERT( pquery->fQuestionRecursed );

                if ( ! Wins_MakeWinsRequest(
                            pquery,
                            NULL,
                            0,
                            NULL ) )
                {
                    Answer_ContinueNextLookupForQuery( pquery );
                }
            }
        }

        //
        //  Verify \ fix UDP receive
        //

        UDP_RECEIVE_CHECK();

        //
        //  If no more timed out queries -- WAIT
        //
        //  Always wait for 1 second.  This is a typical retry time
        //  for the recursion and WINS queues.
        //
        //  This is simpler than using time to next packet timeout.
        //  And if, traffic is so slow, that we are waking up
        //  unnecessarily, then the wasted cycles aren't an issue anyway.
        //

        err = WaitForSingleObject(
                    hDnsShutdownEvent,  // service shutdown
                    1000                // 1 second
                    );

    }   //  loop back to get next timeout
}



VOID
FASTCALL
Recurse_Question(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Do recursive lookup on query.

    This is main (re)entry point into recusive lookup.

Arguments:

    pQuery  - query to recurse

    pNode   - node to start recursive search at
        should be closest node in tree to name of query;
        if not given defaults to pQuery->pnodeRecurseRetry which is last zone root
        at which previous recursion is done;
        note that this generally SHOULD be given;  it is only appropriate to restart
        at previous recusion when timed out or otherwise received useless response
        from previous recursive query;  if receive data, even if delegation, then
        need to restart at node closest to question

Return Value:

    None

--*/
{
    PDB_NODE        pnodePrevious = NULL;
    IP_ADDRESS      ipNs;
    DNS_STATUS      status;
    PDB_NODE        pnodeMissingGlue = NULL;
    PDB_NODE        pnewNode;
    BOOL            movedNodeToNotAuthZoneRoot = FALSE;

    ASSERT( pQuery );

    DNS_DEBUG( RECURSE, (
        "Recurse_Question() query=%p node=%s.\n",
        pQuery,
        pNode ? pNode->szLabel : NULL ));


    //
    //  if passed final message timeout -- kill message
    //
    //  need this to slam the door on situation where message is
    //  repeatedly kept alive by responses, but never successfully
    //  completed;  with TCP recursion, it's become even more likely
    //  to run past final timeout and risk referencing nodes that
    //  have been cleaned up by XFR recv
    //

    if ( pQuery->dwQueryTime + SrvCfg_dwRecursionTimeout < DNS_TIME() )
    {
        DNS_DEBUG( RECURSE, (
            "Recurse_RecurseQuery() immediate final timeout of query=%p\n",
            pQuery ));
        goto Failed;
    }

    //
    //  find node to start or resume looking for name servers at
    //

    if ( !pNode )
    {
        pNode = pQuery->pnodeRecurseRetry;
        if ( !pNode )
        {
            ASSERT( FALSE );
            goto Failed;
        }
    }

#if 0
    //
    //  in local. domain
    //      - if so, ignore and continue if getting additional data
    //      - no-response (cleanup) if original question
    //
    //  .local check only interesting if cache NODE and NO DELEGATION available
    //

    if ( !pQuery->pnodeDelegation &&
         IS_CACHE_TREE_NODE(pNode) &&
         Dbase_IsNodeInSubtree( pNode, g_pCacheLocalNode ) )
    {
        if ( RECURSING_ORIGINAL_QUESTION(pQuery) )
        {
            DNS_DEBUG( RECURSE, (
                "WARNING:  Query %p for local. domain deleted without answer!\n",
                pQuery ));
            goto Failed;
        }
        else
        {
            DNS_DEBUG( RECURSE, (
                "Skipping local. domain recursion for query %p.\n"
                "\tRecursion not for question, moving to next lookup.\n",
                pQuery ));
            Answer_ContinueNextLookupForQuery( pQuery );
            return;
        }
    }
#endif

    //
    //  Write a referral? Special case for stub zone: always write referral
    //  for iterative queries.
    //

    if ( !pQuery->fRecurseIfNecessary )
    {
        Recurse_WriteReferral( pQuery, pNode );
        return;
    }

    IF_DEBUG( RECURSE )
    {
        DnsDbg_Lock();
        DNS_PRINT((
            "Recurse_Question() for query at %p.\n",
            pQuery ));
        Dbg_NodeName(
            "Domain name to start iteration from is ",
            pNode,
            "\n" );
        DnsDbg_Unlock();
    }

    STAT_INC( RecurseStats.LookupPasses );

    //
    //  set up for recursion
    //
    //  single label recursion check?
    //      - not doing single label recursion AND
    //      - original question AND
    //      - single label
    //      => quit SERVER_FAILURE
    //      note RecursionSent flag must be FALSE to otherwise will
    //      wait before sending SERVER_FAILURE
    //

    if ( !pQuery->pRecurseMsg )
    {
        if ( ! SrvCfg_fRecurseSingleLabel &&
             pQuery->pLooknameQuestion->cLabelCount <= 1 &&
             ! IS_CACHE_UPDATE_QUERY(pQuery) &&
             RECURSING_ORIGINAL_QUESTION(pQuery) &&
             ( pQuery->wQuestionType != DNS_TYPE_NS &&
               pQuery->wQuestionType != DNS_TYPE_SOA ) )
        {
            DNS_DEBUG( RECURSE, (
                "Failed recurse single label check on pMsg=%p\n",
                pQuery ));
            pQuery->fRecurseQuestionSent = FALSE;
            goto Failed;
        }

        if ( !initializeQueryForRecursion( pQuery ) )
        {
            goto Failed;
        }
    }

    //
    //  first time through for current question ?
    //  i.e. NOT repeating previous recursion to new NS
    //      - reset flags
    //      - write new question to recurse message
    //

    if ( !pQuery->fQuestionRecursed )
    {
        if ( ! initializeQueryToRecurseNewQuestion( pQuery ) )
        {
            goto Failed;
        }
    }

    //
    //  Activate EDNS since we're recursing the query to another server.
    //

    pQuery->Opt.fInsertOptInOutgoingMsg = ( BOOLEAN ) SrvCfg_dwEnableEDnsProbes;
    if ( pQuery->pRecurseMsg )
    {
        pQuery->pRecurseMsg->Opt.fInsertOptInOutgoingMsg =
            ( BOOLEAN ) SrvCfg_dwEnableEDnsProbes;
    }

    //
    //  Is this a forward zone? If so, forward to next forwarder.
    //  When forwarders have been exhausted, set the retry node to one of:
    //  a) a delegation for the name, if one exists, or
    //  b) the cache root to force recursion to the root servers.
    //

    if ( pQuery->pnodeRecurseRetry
        && pQuery->pnodeRecurseRetry->pZone )
    {
        PZONE_INFO  pZone =
            ( PZONE_INFO ) pQuery->pnodeRecurseRetry->pZone;

        if ( IS_ZONE_FORWARDER( pZone ) &&
            !IS_DONE_FORWARDING( pQuery ) )
        {
            if ( recurseToForwarder(
                    pQuery,
                    pZone->aipMasters,
                    pZone->fForwarderSlave,
                    pZone->dwForwarderTimeout ) )
            {
                return;
            }

            //
            //  The forwarder failed. Search for a non-forwarder node in
            //  the database (probably a delegation). If no node is found
            //  recurse to the root servers.
            //

            pNode = Lookup_NodeForPacket(
                            pQuery,
                            pQuery->MessageBody,
                            LOOKUP_IGNORE_FORWARDER );
            if ( !pNode )
            {
                pNode = pQuery->pnodeDelegation ?
                    pQuery->pnodeDelegation :
                    DATABASE_CACHE_TREE;
            }
            pQuery->pnodeRecurseRetry = pNode;
        }
    }

    //
    //  using server level FORWARDERS ?
    //      - first save node to retry at if exhaust forwarders
    //      - get next forwarders address
    //      - set forwarders timeout
    //      - make recursive query
    //
    //  if we've hit a stub zone, do not recurse to server level forwarders
    //
    //  if query in delegated subzone, only use forwarders if explicitly
    //      set to forward delegations, otherwise directly recurse
    //
    //  if out of forwarders, continue with normal recursion
    //      or if slave, stop
    //

    if ( !( pQuery->pzoneCurrent && IS_ZONE_NOTAUTH( pQuery->pzoneCurrent ) ) &&
        SrvCfg_aipForwarders &&
        ! IS_DONE_FORWARDING( pQuery ) &&
        ( !pQuery->pnodeDelegation || SrvCfg_fForwardDelegations ) )
    {
        pQuery->pnodeRecurseRetry = pNode;
        if ( recurseToForwarder(
                pQuery,
                SrvCfg_aipForwarders,
                SrvCfg_fSlave,
                SrvCfg_dwForwardTimeout ) )
        {
            return;
        }
    }

    //  MUST leave with pRecurseMsg and pVisitedNs set

    ASSERT( pQuery->pNsList && pQuery->pRecurseMsg );

    //
    //  find name server to answer query
    //
    //  start at incoming node, and walk back up through database until
    //      find a zone root with uncontacted servers
    //
    //  DEVNOTE:  incoming node MUST have been accessed in last time interval,
    //      so -- since travelling UP the tree -- no need to explicitly lock?
    //
    //  DEVNOTE: when do NODE locking, then should lock for EACH node in
    //      each time through in loop (or at least where takes out pNsList
    //      then uses it (as this is kept at node)
    //

    //Dbase_LockDatabase();

    ASSERT( IS_NODE_RECENTLY_ACCESSED( pNode ) ||
            pNode == DATABASE_ROOT_NODE ||
            pNode == DATABASE_CACHE_TREE );
    SET_NODE_ACCESSED( pNode );

    while ( 1 )
    {
        //
        //  bail if
        //      - recurse fails at root
        //      - recurse fails at delegation

        if ( pnodePrevious )
        {
            pNode = pnodePrevious->pParent;
            if ( !pNode )
            {
                DNS_DEBUG( RECURSE, (
                    "Stopping recursion for query %p, searched up to root domain.\n",
                    pQuery ));
                break;
            }
            if ( IS_AUTH_NODE(pNode) )
            {
                DNS_DEBUG( RECURSE, (
                    "Stopping recursion for query %p.\n"
                    "\tFailed recurse at delegation %p (l=%s)\n"
                    "\tbacked into zone %s\n",
                    pQuery,
                    pnodePrevious,
                    pnodePrevious->szLabel,
                    ((PZONE_INFO)pNode->pZone)->pszZoneName ));

                ASSERT( pQuery->pRecurseMsg );
                STAT_INC( RecurseStats.FailureReachAuthority );
                break;
            }
        }

        DNS_DEBUG( RECURSE2, (
            "Recursion at node label %.*s\n",
            pNode->cchLabelLength,
            pNode->szLabel ));

        //
        //  find "covering" zone root node
        //  switching to delegation if available
        //

        pNode = Recurse_CheckForDelegation(
                    pQuery,
                    pNode );
        if ( !pNode )
        {
            ASSERT( FALSE );
            break;
        }

        //
        //  Not-auth zone. If we've ended up at a cache node with fewer labels
        //  than the root of the not-auth zone or if the current node is already
        //  the not-auth zone root, perform special handling as required.
        //
        //  Take a local copy of the zone root in case the zone expires and the
        //  tree node is swapped out. We can still use the tree for this query
        //  but we don't want to pick up the swapped-in NULL tree.
        //
        //  This can only be done once per Recurse_Question call.
        //

        if ( !movedNodeToNotAuthZoneRoot &&
            pQuery->pzoneCurrent &&
            IS_ZONE_NOTAUTH( pQuery->pzoneCurrent ) &&
            ( pNode->pZone == pQuery->pzoneCurrent ||
                IS_CACHE_TREE_NODE( pNode ) ) &&
            pNode->cLabelCount <= pQuery->pzoneCurrent->cZoneNameLabelCount &&
            ( pnewNode = pQuery->pzoneCurrent->pZoneRoot ) != NULL )
        {
            DNS_DEBUG( RECURSE, (
                "not-auth zone: moving current node from cache tree to zone root \"%.*s\"\n",
                pnewNode->cchLabelLength,
                pnewNode->szLabel ));

            pNode = pnewNode;
            movedNodeToNotAuthZoneRoot = TRUE;

            //
            //  Special handling for forward zones: no need to build visit 
            //  list, just send to forwarders. For stub zones we continue 
            //  on to build visit list and recurse to stub masters.
            //

            if ( IS_ZONE_FORWARDER( pQuery->pzoneCurrent ) )
            {
                DNS_DEBUG( LOOKUP, (
                    "Hit forwarding zone %s\n",
                    pQuery->pzoneCurrent->pszZoneName ));

                Recurse_SendToDomainForwarder( pQuery, pNode );
                return;
            }
        }

        pnodePrevious = pNode;

        ASSERT(
            !IS_CACHE_TREE_NODE( pNode ) ||
            pNode->pChildren ||
            IS_NODE_RECENTLY_ACCESSED( pNode ) );
        SET_NODE_ACCESSED(pNode);

        //
        //  Find name servers for this domain.
        //      - get domain resource records
        //      - find NS records
        //      - find corresponding A (address) records
        //
        //  If recursion is not desired, build response of NS and corresponding
        //  address records.
        //
        //  If recursion, launch query to these name server(s), making
        //  original query.
        //

        DNS_DEBUG( RECURSE2, (
            "Recursion up to zone root with label <%.*s>\n",
            pNode->cchLabelLength,
            pNode->szLabel ));

        #if 0
        //
        //  If we are about recurse to Internet root servers, screen 
        //  question name against a list of names we know the Internet root 
        //  servers can't answer.
        //

        if ( !pNode->pParent &&
            IS_CACHE_TREE_NODE( pNode ) &&
            g_fUsingInternetRootServers &&
            SrvCfg_dwRecurseToInetRootMask != 0 )
        {
        }
        #endif

        //
        //  find name servers IPs for this domain
        //      - if none, break out for next level in tree
        //

        status = Remote_BuildVisitListForNewZone(
                    pNode,
                    pQuery );

        switch ( status )
        {

        case ERROR_SUCCESS:
            //  drop down to send recursive query
            break;

        case ERROR_NO_DATA:

            DNS_DEBUG( RECURSE, (
                "No NS-IP data at zone root %p (l=%s) for query %p\n"
                "\tcontinuing up tree.\n",
                pNode,
                pNode->szLabel,
                pQuery ));
            continue;

        case DNSSRV_ERROR_ONLY_ROOT_HINTS:

            DNS_DEBUG( RECURSE, (
                "Reached root-hint NS recursing query %p, without response\n"
                "\tsending root NS query.\n",
                pQuery ));

            sendRootNsQuery();
            //  drop down to send recursive query
            break;

        case DNSSRV_ERROR_ZONE_ALREADY_RESPONDED:

            DNS_DEBUG( RECURSE, (
                "ERROR:  Query %p recursed back to domain (label %s) from which NS\n"
                "\thas already responded.\n"
                "\tThis should happen only if subzone NS are down or unreachable.\n",
                pQuery,
                *pNode->szLabel ? pNode->szLabel : ".(root)" ));
            STAT_INC( RecurseStats.FailureReachPreviousResponse );
            goto Failed;

        default:

            HARD_ASSERT( FALSE );
            goto Failed;
        }

        pQuery->pnodeRecurseRetry = pNode;


        //
        //  if successful building NS list, then send
        //      ERROR_SUCCESS indicates pQuery no longer owned by this
        //          thread (sent, missing glue query, etc.)
        //      ERROR_OUT_OF_IP indicates no more unsent IP
        //          try moving up the tree
        //

        status = sendRecursiveQuery(
                    pQuery,
                    0,              // no specified IP, send from remote list
                    SrvCfg_dwForwardTimeout );
        if ( status == ERROR_SUCCESS )
        {
            return;
        }

        ASSERT( status == DNSSRV_ERROR_OUT_OF_IP )

        DNS_DEBUG( RECURSE, (
            "No unvisited IP addresses at node %s\n"
            "\tcontinuing recursion up DNS tree\n",
            pNode->szLabel ));

        continue;

    }   // while(1)

Failed:

    //Dbase_UnlockDatabase();
    STAT_INC( RecurseStats.RecursePassFailure );
    PERF_INC( pcRecursiveQueryFailure );

    recursionServerFailure( pQuery );
}



VOID
FASTCALL
Recurse_SendToDomainForwarder(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PDB_NODE        pZoneRoot
    )
/*++

Routine Description:

    This function sends a query to a domain forwarding server, and
    sets up the query so additional forwarding servers can be used
    if the first server times out.

Arguments:

    pQuery - query to foward

    pZone - the forwarding zone

Return Value:

    None

--*/
{
    PZONE_INFO      pZone;

    ASSERT( pQuery );
    ASSERT( pZoneRoot );
    ASSERT( pZoneRoot->pZone );

    DNS_DEBUG( RECURSE, (
        "Recurse_SendToDomainForwarder() query=%p\n  pZoneRoot=%p pZone=%p\n",
        pQuery,
        pZoneRoot,
        pZoneRoot ? pZoneRoot->pZone : NULL ));

    if ( !pZoneRoot || !pZoneRoot->pZone )
    {
        goto Failed;
    }

    pZone = ( PZONE_INFO ) pZoneRoot->pZone;

    //
    //  if passed final message timeout -- kill message
    //

    if ( pQuery->dwQueryTime + pZone->dwForwarderTimeout < DNS_TIME() )
    {
        DNS_DEBUG( RECURSE, (
            "Recurse_SendToDomainForwarder() immediate final timeout of query=%p\n",
            pQuery ));
        goto Failed;
    }

    // JJW: Inc stats? (see Recurse_Question)

    if ( !pQuery->pRecurseMsg )
    {
        if ( !initializeQueryForRecursion( pQuery ) )
        {
            goto Failed;
        }
    }

    //
    //  first time through for current question ?
    //  i.e. NOT repeating previous recursion to new NS
    //      - reset flags
    //      - write new question to recurse message
    //

    if ( !pQuery->fQuestionRecursed )
    {
        if ( ! initializeQueryToRecurseNewQuestion( pQuery ) )
        {
            goto Failed;
        }
    }

    //
    //  Set the recurse node so if a forwarder times out we can get
    //  back to the current zone to try the next configured forwarder.
    //

    // JJW: which to set?
    pQuery->pnodeRecurseRetry =
        pQuery->pRecurseMsg->pnodeRecurseRetry =
        pZoneRoot;
    
    //
    //  Turn on EDNS in the query
    //

    SET_SEND_OPT( pQuery->pRecurseMsg );

    //
    //  Send to the forwarders for this zone.
    //

    if ( pZone->aipMasters &&
        !IS_DONE_FORWARDING( pQuery ) )
    {
        if ( recurseToForwarder(
                pQuery,
                pZone->aipMasters,
                pZone->fForwarderSlave,
                pZone->dwForwarderTimeout ) )
        {
            return;
        }
    }

Failed:

    // JJW: inc stats? (see Recurse_Question)

    recursionServerFailure( pQuery );
}



PDB_NODE
Recurse_CheckForDelegation(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Find node for recursion\referral.

    Finds closest of cache ZONE_ROOT node and delegation (if any).
    If cache ZONE_ROOT and delegation at same name, then uses delegation.

Arguments:

    pMsg - query we are writing

    pNode - ptr to node to start looking for referral;  generally
        this would be question node, or closest ancestor of it in database

Return Value:

    Ptr to closest\best zone root node, to use for referral.
    NULL if no data whatsoever -- even for zone root.

--*/
{
    PDB_NODE    pnode;
    PDB_NODE    pnodeDelegation;

    ASSERT( pMsg );

    IF_DEBUG( RECURSE )
    {
        DnsDbg_Lock();
        DNS_PRINT((
            "Recurse_CheckForDelegation() query at %p.\n",
            pMsg ));
        Dbg_NodeName(
            "Domain name to start iteration from is ",
            pNode,
            "\n" );
        IF_DEBUG( RECURSE2 )
        {
            Dbg_DbaseNode(
                "Node to start iteration from is ",
                pNode );
        }
        DnsDbg_Unlock();
    }

    //
    //  find closest zone root to node
    //      - if cache node, may zip up to cache root node
    //

    pnode = pNode;
    while ( !IS_ZONE_ROOT(pnode) )
    {
        if ( !pnode->pParent )
        {
            //  see note in rrlist.c RR_ListResetNodeFlags()
            //ASSERT( FALSE );
            SET_ZONE_ROOT( pnode );
            break;
        }
        pnode = pnode->pParent;
    }

    //
    //  if no delegation -- just use cache node
    //

    pnodeDelegation = pMsg->pnodeDelegation;
    if ( !pnodeDelegation )
    {
        DNS_DEBUG( RECURSE, (
            "No delegation recurse\\refer to node %p.\n",
            pnode ));
        return( pnode );
    }

    //
    //  if node is delegation, use it
    //

    ASSERT( IS_NODE_RECENTLY_ACCESSED( pnodeDelegation ) );

    if ( pNode == pnodeDelegation ||
        pnode == pnodeDelegation ||
        pNode == pMsg->pnodeGlue )
    {
        DNS_DEBUG( RECURSE, (
            "Node %p is delegation, use it.\n",
            pnode ));
        return( pnode );
    }

    //
    //  find actual delegation
    //      - note:  could fail in transient, when absorb delegation
    //

    ASSERT( IS_SUBZONE_NODE(pnodeDelegation) );

    while ( IS_GLUE_NODE(pnodeDelegation) )
    {
        pnodeDelegation = pnodeDelegation->pParent;
    }
    ASSERT( IS_DELEGATION_NODE(pnodeDelegation) );

    //
    //  if delegation at label count greater (deeper) than cache node -- use it
    //  otherwise use cache node
    //

    if ( pnodeDelegation->cLabelCount >= pnode->cLabelCount )
    {
        DNS_DEBUG( RECURSE, (
            "Delegation node %p (lc=%d) is as deep at cache node %p (lc=%d)\n"
            "\tswitching to delegation node\n",
            pnodeDelegation, pnodeDelegation->cLabelCount,
            pnode, pnode->cLabelCount
            ));
        pnode = pnodeDelegation;
    }

    return( pnode );
}

//
//  End of recurse.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\registry.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    registry.c

Abstract:

    Domain Name System (DNS) Server

    DNS registry operations.

Author:

    Jim Gilroy (jamesg)     September, 1995

Revision History:

--*/


#include "dnssrv.h"
#include "sdutl.h"


#define MAX_MIGRATION_ZONE_COUNT    200


//
//  DNS registry handles
//

HKEY    hkeyDns;
HKEY    hkeyParameters;
HKEY    hKeyZones;
HKEY    hKeyCache;


//
//  DNS registry class
//

#define DNS_REGISTRY_CLASS          TEXT("DnsRegistryClass")
#define DNS_REGISTRY_CLASS_SIZE     sizeof(DNS_REGISTRY_CLASS)

#define DNS_REGISTRY_CLASS_WIDE         NULL
#define DNS_REGISTRY_CLASS_SIZE_WIDE    NULL


//
//  DNS registry constants
//

#define DNS_BASE_CCS    TEXT( "SYSTEM\\CurrentControlSet\\Services\\DNS" )
#define DNS_BASE_SW     TEXT( "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\DNS Server" )

#define DNS_REGKEY_ROOT         ( DNS_BASE_CCS )
#define DNS_REGKEY_PARAMETERS   ( DNS_BASE_CCS  TEXT( "\\Parameters" ) )
#define DNS_REGKEY_ZONES_CCS    ( DNS_BASE_CCS  TEXT( "\\Zones" ) )
#define DNS_REGKEY_ZONES_SW     ( DNS_BASE_SW   TEXT( "\\Zones" ) )

#define DNS_REGKEY_ZONES() \
    ( g_ZonesRegistrySource == DNS_REGSOURCE_SW ? \
        DNS_REGKEY_ZONES_SW : DNS_REGKEY_ZONES_CCS )

#define DBG_REG_SOURCE_STRING( x ) \
    ( ( x ) == DNS_REGSOURCE_SW ? "Software" : "CurrentControlSet" )

#define DNS_ZONES_KEY_MOVED_MSG     ( TEXT( "moved to HKLM\\" ) DNS_BASE_SW )


//
//  DNS Registry global
//
//  Indicates when writing parameters back to registry.  This should
//  be TRUE in all cases, except when booting from registry itself.
//

BOOL    g_bRegistryWriteBack = TRUE;
DWORD   g_ZonesRegistrySource = 0;      // DNS_REGSOURCE_XXX constant



//
//  Registry utils
//

DWORD
Reg_LengthOfMultiSzW(
    IN      PWSTR           pwMultiSz
    )
/*++

Routine Description:

    Determine length (in bytes) of REG_MULTI_SZ string.

Arguments:

    pwMultiSz -- MULTI_SZ string to get length of

Return Value:

    Length in bytes of MULTI_SZ string.
    Length includes terminating 00 and is suitable for use with registry call.

--*/
{
    PWCHAR  pwch = pwMultiSz;
    WCHAR   wch;
    WCHAR   wchPrev = 1;

    //
    //  loop until 00 termination
    //

    while ( 1 )
    {
        wch = *pwch++;
        if ( wch != 0 )
        {
            wchPrev = wch;
            continue;
        }

        //  zero character
        //  if previous char zero, then terminate

        if ( wchPrev != 0 )
        {
            wchPrev = wch;
            continue;
        }
        break;
    }

    return( (DWORD)(pwch - pwMultiSz) * 2 );
}



BOOLEAN
Reg_KeyHasSubKeys(
    WCHAR *     pwsKeyName )
/*++

Routine Description:

    Returns TRUE if the specified key has children keys.

Arguments:

    pwsKeyName: name of key to check for subkeys

Return Value:

    TRUE if the key has subkeys exists.

--*/
{
    BOOLEAN     fHasKids = FALSE;
    HKEY        hKey = NULL;
    TCHAR       szKeyName[ 512 ];
    DWORD       dwKeyNameLen = sizeof( szKeyName ) / sizeof( TCHAR );

    ASSERT( pwsKeyName );

    RegOpenKeyW( HKEY_LOCAL_MACHINE, pwsKeyName, &hKey );
    if ( !hKey )
    {
        goto Done;
    }
    fHasKids = RegEnumKeyEx(
                    hKey,
                    0,
                    szKeyName,
                    &dwKeyNameLen,
                    0,
                    NULL,
                    0,
                    NULL ) == ERROR_SUCCESS;

    Done:
    if ( hKey )
    {
        RegCloseKey( hKey );
    }
    return fHasKids;
} // Reg_KeyHasSubKeys



//
//  DNS server specific registry functions
//

VOID
Reg_Init(
    VOID
    )
/*++

Routine Description:

    Call this function during initialization before any other registry
    calls are made.

    This function determines where the zones currently live in the
    registry (under CCS or under Software) and sets a global flag.

    In Whistler, if the zones are in CCS (because the system was upgraded
    to Whistler from W2K) we will force a zone migration to SW the first time
    a new zone is created. See zonelist.c, Zone_ListMigrateZones().

Arguments:

    None.

Return Value:

    None.

--*/
{
    DBG_FN( "Reg_Init" )

    HKEY        hKey = NULL;
    DNS_STATUS  status;
    BOOLEAN     fZonesInCCS, fZonesInSW;

    DNS_DEBUG( REGISTRY, (
        "%s: start\n", fn ));

    //
    //  Search the registry to determine where the zones live.
    //

    fZonesInCCS = Reg_KeyHasSubKeys( DNS_REGKEY_ZONES_CCS );
    fZonesInSW = Reg_KeyHasSubKeys( DNS_REGKEY_ZONES_SW );

    //
    //  If there are no zones assume this is a fresh install. Write the 
    //  "zones moved" marker to CCS so that admins will be able to find
    //  their zones in the new registry location under the Software key.
    //

    if ( !fZonesInCCS && !fZonesInSW )
    {
        Reg_WriteZonesMovedMarker();
        DNS_DEBUG( REGISTRY, (
            "%s: no zones found - writing \"zones moved\" marker\n", fn ));
    }

    //
    //  Handle error case where zones appear to exist in both places.
    //

    if ( fZonesInCCS && fZonesInSW )
    {
        //  ASSERT( !( fZonesInCCS && fZonesInSW ) );
        DNS_DEBUG( ANY, (
            "%s: zones found in both CurrentControlSet and Software!\n", fn ));
        g_ZonesRegistrySource = DNS_REGSOURCE_SW;
    }
    else
    {
        g_ZonesRegistrySource =
            fZonesInCCS ? DNS_REGSOURCE_CCS : DNS_REGSOURCE_SW;
    }

    //
    //  Done - the zones reg source global now contains the correct reg source
    //  to use when loading the zones from the registry.
    //

    if ( hKey )
    {
        RegCloseKey( hKey );
    }

    DNS_DEBUG( REGISTRY, (
        "%s: finished - zones are in %s\n", fn,
        DBG_REG_SOURCE_STRING( g_ZonesRegistrySource ) ));
}   //  Reg_Init



DWORD
Reg_GetZonesSource(
    VOID
    )
/*++

Routine Description:

    Retrieves the current registry source for zones.

Arguments:

    None.

Return Value:

    DNS_REGSOURCE_XXX constant.

--*/
{
    DNS_DEBUG( REGISTRY, (
        "Reg_GetZonesSource: current source is %s\n",
        DBG_REG_SOURCE_STRING( g_ZonesRegistrySource ) ));

    return g_ZonesRegistrySource;
}   //  Reg_GetZonesSource



DWORD
Reg_SetZonesSource(
    DWORD       newSource       // one of DNS_REGSOURCE_XXX
    )
/*++

Routine Description:

    Sets the registry source for zones.

Arguments:

    The new registry source for zones (DNS_REGSOURCE_XXX constant).

Return Value:

    The old registry source for zones (DNS_REGSOURCE_XXX constant).

--*/
{
    DWORD   oldSource = g_ZonesRegistrySource;

    ASSERT( oldSource == DNS_REGSOURCE_CCS || oldSource == DNS_REGSOURCE_SW );
    ASSERT( newSource == DNS_REGSOURCE_CCS || newSource == DNS_REGSOURCE_SW );

    g_ZonesRegistrySource = newSource;

    DNS_DEBUG( REGISTRY, (
        "Reg_SetZonesSource: switching from %s to %s\n",
        DBG_REG_SOURCE_STRING( oldSource ),
        DBG_REG_SOURCE_STRING( g_ZonesRegistrySource ) ));

    return oldSource;
}   //  Reg_SetZonesSource



VOID
Reg_WriteZonesMovedMarker(
    VOID
    )
/*++

Routine Description:

    After successful zone migration from CurrentControlSet to Software,
    call this function to write a note for the administrator in CCS\Zones
    to redirect him to the new zones key.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD   oldSource = Reg_SetZonesSource( DNS_REGSOURCE_CCS );

    HKEY    hZonesKey = Reg_OpenZones();

    if ( hZonesKey )
    {
        Reg_SetValue(
            hZonesKey,
            NULL,
            NULL,           // default value for key
            DNS_REG_WSZ,    // write this as a unicode string
            DNS_ZONES_KEY_MOVED_MSG,
            0 );
        RegCloseKey( hZonesKey );
    }
    else
    {
        DNS_DEBUG( REGISTRY, (
            "Reg_WriteZonesMovedMarker: failed to open CCS zones key\n" ));
    }

    Reg_SetZonesSource( oldSource );
}   //  Reg_WriteZonesMovedMarker



HKEY
Reg_OpenRoot(
   VOID
    )
/*++

Routine Description:

    Open or create DNS root key.

Arguments:

    None.

Return Value:

    DNS parameters registry key, if successful.
    NULL otherwise.

--*/
{
    DNS_STATUS  status;
    HKEY        hkeyParam;
    DWORD       disposition;

    //
    //  open DNS parameters key
    //

    status = RegCreateKeyExW(
                HKEY_LOCAL_MACHINE,
                DNS_REGKEY_ROOT,
                0,
                DNS_REGISTRY_CLASS,         // DNS class
                REG_OPTION_NON_VOLATILE,    // permanent storage
                KEY_ALL_ACCESS,             // all access
                NULL,                       // standard security
                &hkeyParam,
                &disposition );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( REGISTRY, (
            "ERROR:  RegCreateKeyExW() failed for opening DNS root key\n"
            "\tstatus = %d.\n",
            status ));

        DNS_LOG_EVENT(
            DNS_EVENT_REGISTRY_OPEN_FAILED,
            0,
            NULL,
            NULL,
            status );
        SetLastError( status );
        return( NULL );
    }
    return( hkeyParam );
}


HKEY
Reg_OpenParameters(
    VOID
    )
/*++

Routine Description:

    Open or create DNS parameters key.

Arguments:

    None.

Return Value:

    DNS parameters registry key, if successful.
    NULL otherwise.

--*/
{
    DNS_STATUS  status;
    HKEY        hkeyParam;
    DWORD       disposition;

    //
    //  open DNS parameters key
    //

    status = RegCreateKeyExW(
                HKEY_LOCAL_MACHINE,
                DNS_REGKEY_PARAMETERS,
                0,
                DNS_REGISTRY_CLASS,         // DNS class
                REG_OPTION_NON_VOLATILE,    // permanent storage
                KEY_ALL_ACCESS,             // all access
                NULL,                       // standard security
                &hkeyParam,
                &disposition );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( REGISTRY, (
            "ERROR:  RegCreateKeyExW() failed for opening parameters key\n"
            "\tstatus = %d.\n",
            status ));

        DNS_LOG_EVENT(
            DNS_EVENT_REGISTRY_OPEN_FAILED,
            0,
            NULL,
            NULL,
            status );
        return( NULL );
    }
    return( hkeyParam );
}



HKEY
Reg_OpenZones(
    VOID
    )
/*++

Routine Description:

    Open or create DNS "Zones" key.

Arguments:

    None.

Return Value:

    DNS zones registry key, if successful.
    NULL otherwise.

--*/
{
    DNS_STATUS  status;
    HKEY        hkeyZones;
    DWORD       disposition;

    //
    //  open DNS zones key
    //

    status = RegCreateKeyExW(
                HKEY_LOCAL_MACHINE,
                DNS_REGKEY_ZONES(),
                0,
                DNS_REGISTRY_CLASS,         // DNS class
                REG_OPTION_NON_VOLATILE,    // permanent storage
                KEY_ALL_ACCESS,             // all access
                NULL,                       // standard security
                &hkeyZones,
                &disposition );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( REGISTRY, (
            "ERROR:  RegCreateKeyEx() failed for opening zones key\n"
            "\tstatus = %d (under %s).\n",
            status,
            DBG_REG_SOURCE_STRING( g_ZonesRegistrySource ) ));

        DNS_LOG_EVENT(
            DNS_EVENT_REGISTRY_OPEN_FAILED,
            0,
            NULL,
            NULL,
            status );
        return( NULL );
    }
    return( hkeyZones );
}



DNS_STATUS
Reg_EnumZones(
    IN OUT  PHKEY           phZonesKey,
    IN      DWORD           dwZoneIndex,
    OUT     PHKEY           phkeyThisZone,
    OUT     PWCHAR          pwZoneNameBuf
    )
/*++

Routine Description:

    Enumerate next zone.

Arguments:

    phZonesKey -- addr of Zones HKEY;  if hKey is zero, function opens
        Zones hKey and returns it in this value;  caller has responsibility
        to close Zones hKey after

    dwZoneIndex -- index of zone to enumerate;  zero on first call,
        increment for each subsequent call

    phkeyThisZone -- addr to set to zone HKEY

    pwZoneNameBuf -- buffer to receive zone name;  MUST be at least
        size of DNS_MAX_NAME_LENGTH

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    HKEY        hkeyZones;
    HKEY        hkeyThisZone;
    DNS_STATUS  status;
    DWORD       bufLength = DNS_MAX_NAME_LENGTH;

    ASSERT( phZonesKey != NULL );
    ASSERT( pwZoneNameBuf != NULL );
    ASSERT( phkeyThisZone != NULL );

    DNS_DEBUG( REGISTRY, (
        "Reg_EnumZones() with index = %d\n"
        "\tZonesKey = %p\n",
        dwZoneIndex,
        *phZonesKey ));

    //
    //  get zones key
    //

    hkeyZones = *phZonesKey;

    if ( ! hkeyZones )
    {
        hkeyZones = Reg_OpenZones();
        if ( !hkeyZones )
        {
            return( ERROR_OPEN_FAILED );
        }
        *phZonesKey = hkeyZones;
    }

    //
    //  enum indexed zone
    //

    status = RegEnumKeyEx(
                hkeyZones,
                dwZoneIndex,
                pwZoneNameBuf,
                & bufLength,
                NULL,
                NULL,
                NULL,
                NULL
                );

    DNS_DEBUG( REGISTRY, (
        "RegEnumKeyEx %d returned %d\n", dwZoneIndex, status ));

    if ( status != ERROR_SUCCESS )
    {
        IF_DEBUG( ANY )
        {
            if ( status != ERROR_NO_MORE_ITEMS )
            {
                DNS_PRINT((
                    "ERROR:  RegEnumKeyEx failed for opening zone[%d] key\n"
                    "\tstatus = %d.\n",
                    dwZoneIndex,
                    status ));
            }
        }
        return( status );
    }
    DNS_DEBUG( REGISTRY, (
        "Reg_EnumZones() enumerated zone %S\n",
        pwZoneNameBuf ));

    //
    //  open zone key, if desired
    //

    if ( phkeyThisZone )
    {
        *phkeyThisZone = Reg_OpenZone( pwZoneNameBuf, hkeyZones );
        if ( ! *phkeyThisZone )
        {
            return( ERROR_OPEN_FAILED );
        }
    }

    return( ERROR_SUCCESS );
}



HKEY
Reg_OpenZone(
    IN      PWSTR           pwsZoneName,
    IN      HKEY            hZonesKey       OPTIONAL
    )
/*++

Routine Description:

    Open or create a DNS zone key.

Arguments:

    pwsZoneName -- name of zone

    hZonesKey -- Zones key if already opened

Return Value:

    Zone's registry key, if successful.
    NULL otherwise.

--*/
{
    HKEY        hkeyThisZone = NULL;
    BOOL        fopenedZonesKey = FALSE;
    DNS_STATUS  status;
    DWORD       disposition;

    //
    //  error if called with zone with no name (i.e. cache)
    //

    if ( !pwsZoneName )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Reg_OpenZone() called with NULL name!\n" ));
        ASSERT( FALSE );
        return( NULL );
    }

    //
    //  open DNS zone key
    //

    if ( !hZonesKey )
    {
        hZonesKey = Reg_OpenZones();
        if ( !hZonesKey )
        {
            return( NULL );
        }
        fopenedZonesKey = TRUE;
    }

    //
    //  open/create zone key
    //

    status = RegCreateKeyEx(
                hZonesKey,
                pwsZoneName,
                0,
                DNS_REGISTRY_CLASS,         // DNS class
                REG_OPTION_NON_VOLATILE,    // permanent storage
                KEY_ALL_ACCESS,             // all access
                NULL,                       // standard security
                &hkeyThisZone,
                &disposition );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( REGISTRY, (
            "ERROR:  RegCreateKeyEx failed for opening zone %S\n"
            "\tstatus = %d.\n",
            pwsZoneName,
            status ));

        DNS_LOG_EVENT(
            DNS_EVENT_REGISTRY_OPEN_FAILED,
            0,
            NULL,
            NULL,
            status );
    }

    //  if had to open Zones key, close it

    if ( fopenedZonesKey )
    {
        RegCloseKey( hZonesKey );
    }

    return( hkeyThisZone );
}



VOID
Reg_DeleteZone(
    IN      PWSTR           pwsZoneName
    )
/*++

Routine Description:

    Delete a DNS zone key.

Arguments:

    pwsZoneName -- zone name

Return Value:

    None

--*/
{
    HKEY    hkeyZones;

    //  open DNS Zones key

    hkeyZones = Reg_OpenZones();
    if ( !hkeyZones )
    {
        return;
    }

    //  delete desired zone

    RegDeleteKey(
       hkeyZones,
       pwsZoneName );

    //  close Zones key

    RegCloseKey( hkeyZones );
    return;
}



DWORD
Reg_DeleteAllZones(
    VOID
    )
/*++

Routine Description:

    Delete the DNS zones key.

    When booting from boot file, this allows us to start with
    fresh zone set which will contain ONLY what is CURRENTLY in
    boot file.

Arguments:

    None

Return Value:

    None

--*/
{
    DNS_STATUS  status =
        Reg_DeleteKeySubtree( HKEY_LOCAL_MACHINE, DNS_REGKEY_ZONES() );

    DNS_DEBUG( REGISTRY, (
        "Reg_DeleteAllZones: Reg_DeleteKeySubtree() status = %d.\n",
        status ));
    return status;
}



//
//  General DNS registry value manipulation routines
//

DNS_STATUS
Reg_SetValue(
    IN      HKEY            hKey,           OPTIONAL
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      LPSTR           pszValueName,
    IN      DWORD           dwType,
    IN      PVOID           pData,
    IN      DWORD           cbData
    )
/*++

Routine Description:

    Write a value to DNS registry.

Arguments:

    hKey            --  open handle to registry key to read

    pZone           --  ptr to zone, required if hKey NOT given

    pszValueName    --  value name (null for default value of key)

    dwType          --  registry data type

    pData           --  data to write

    cbData          --  count of data bytes

Return Value:

    ERROR_SUCCESS, if successful,
    ERROR_OPEN_FAILED, if could not open key
    Error code on failure

--*/
{
    BOOL        fneedClose = FALSE;
    DNS_STATUS  status;
    PWSTR       punicodeValue = NULL;
    DWORD       registryType;

    //
    //  if no key
    //      - open DNS zone key if zone name given
    //      - otherwise open DNS parameters key
    //

    if ( !hKey )
    {
        if ( pZone )
        {
            hKey = Reg_OpenZone( pZone->pwsZoneName, NULL );
        }
        else
        {
            hKey = Reg_OpenParameters();
        }
        if ( !hKey )
        {
            return( ERROR_OPEN_FAILED );
        }
        fneedClose = TRUE;
    }

    //
    //  determine if need unicode read
    //
    //  general paradigm
    //      - keep in ANSI where possible, simply to avoid having to keep
    //          UNICODE property (reg value) names
    //      - IP strings work better with ANSI read anyway
    //      - file name strings must be handled in unicode as if write as
    //          UTF8, they'll be messed up
    //
    //  DEVNOTE: unicode registry info
    //      table in unicodeRegValue() is kinda lame
    //      alternatives:
    //          1) all unicode, keep unicode value names, convert IP back
    //          2) dwType expanded to carry (need to lookup unicode) info
    //              - with table OR
    //              - with direct conversion OR
    //              - requiring use of unicode valuename
    //          also allows us to have type that means (convert result back
    //          to UTF8)
    //

    if ( DNS_REG_TYPE_UNICODE(dwType) )
    {
        DWORD   registryType = REG_TYPE_FROM_DNS_REGTYPE( dwType );

        DNS_DEBUG( REGISTRY, (
            "Writing unicode regkey %S  regtype = %p.\n",
            pszValueName,
            dwType ));

        //
        //  convert UTF8 string to unicode?
        //

        if ( DNS_REG_UTF8 == dwType )
        {
            pData = Dns_StringCopyAllocate(
                        pData,
                        0,
                        DnsCharSetUtf8,
                        DnsCharSetUnicode );
            if ( !pData )
            {
                status = ERROR_INVALID_PARAMETER;
                goto Done;
            }
            cbData = 0;
        }

        //  if string type with no length -- get it

        if ( cbData == 0 &&
             (  registryType==REG_SZ ||
                registryType==REG_EXPAND_SZ ) )
        {
            cbData = (wcslen(pData) + 1) * 2;
        }

        status = RegSetValueExW(
                    hKey,
                    (PWSTR) pszValueName,   //  unicode reg value name
                    0,                      //  reserved
                    registryType,           //  real registry type
                    (PBYTE) pData,          //  data
                    cbData );               //  data length

        //  free allocated memory

        if ( DNS_REG_UTF8 == dwType )
        {
            FREE_HEAP(pData);
        }
    }
    else
    {
        if ( cbData == 0 && dwType == REG_SZ )
        {
            cbData = strlen( pData );
        }
        status = RegSetValueExA(
                    hKey,
                    pszValueName,
                    0,              //  reserved
                    dwType,         //  registry type
                    (PBYTE) pData,  //  data
                    cbData );       //  data length
    }

Done:

    if ( status != ERROR_SUCCESS )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_REGISTRY_WRITE_FAILED,
            0,
            NULL,
            NULL,
            status );

        DNS_DEBUG( REGISTRY, (
            "ERROR:  RegSetValueEx failed for value %s\n",
            pszValueName ));
    }
    else
    {
        DNS_DEBUG( REGISTRY, (
            "Wrote registry value %s, type = %d, length = %d.\n",
            pszValueName,
            dwType,
            cbData ));
    }

    //
    //  if opened key, close it
    //

    if ( fneedClose )
    {
        RegCloseKey( hKey );
    }
    return( status );
}


DNS_STATUS
Reg_SetDwordValue(
    IN      HKEY            hKey,           OPTIONAL
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      LPSTR           pszValueName,
    IN      DWORD           dwValue
    )
/*++

Routine Description:

    Write a DWORD value to DNS registry.

    Only purpose is to elminate some arguments to Reg_SetValue() along
    with the need to pass ptr to DWORD value rather than value itself.
    Saves little pieces of code sprinkled around for a very small perf
    penalty.

Arguments:

    hKey            --  open handle to regkey

    pZone           --  ptr to zone, required if hKey NOT given;

    pszValueName    --  value name

    dwValue         --  DWORD value to write

Return Value:

    ERROR_SUCCESS, if successful,
    ERROR_OPEN_FAILED, if could not open key
    Error code on failure

--*/
{
    DWORD   tempDword = dwValue;

    return  Reg_SetValue(
                hKey,
                pZone,
                pszValueName,
                REG_DWORD,
                & tempDword,
                sizeof(DWORD) );
}



DNS_STATUS
Reg_SetIpArray(
    IN      HKEY            hKey,           OPTIONAL
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      LPSTR           pszValueName,
    IN      PIP_ARRAY       pIpArray
    )
/*++

Routine Description:

    Read an IP array from the registry.

    Caller responsible for freeing allocated memory.

Arguments:

    hKey            --  open handle to regkey to write

    pZone           --  ptr to zone, required if hKey NOT given

    pszValueName    --  value name

    pIpArray        --  IP array to write to registry

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DWORD       dataLength;
    PIP_ARRAY   pipArray = NULL;
    LPSTR       pszstringArray;
    DNS_STATUS  status;

    //
    //  if NO IP array, delete registry value
    //

    if ( !pIpArray )
    {
        return  Reg_DeleteValue(
                    hKey,
                    pZone,
                    pszValueName );
    }

    //
    //  convert IP array to string (space separated)
    //

    pszstringArray = Dns_CreateMultiIpStringFromIpArray(
                        pIpArray,
                        0 );
    if ( !pszstringArray )
    {
        DNS_PRINT((
            "ERROR:  failed conversion to string of IP array at %p\n",
            pIpArray ));
        ASSERT( FALSE );
        return( DNS_ERROR_NO_MEMORY );
    }

    //
    //  write back multi-IP string to registry
    //

    DNS_DEBUG( REGISTRY, (
        "Writing back string IP array for registry value %s\n"
        "\tstring IP array = %s\n",
        pszValueName,
        pszstringArray ));

    status = Reg_SetValue(
                hKey,
                pZone,
                pszValueName,
                REG_SZ,
                pszstringArray,
                strlen( pszstringArray ) + 1 );

    FREE_TAGHEAP( pszstringArray, 0, MEMTAG_DNSLIB );

    return( status );
}



DNS_STATUS
Reg_DeleteValue(
    IN      HKEY            hKey,           OPTIONAL
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      LPSTR           pszValueName
    )
/*++

Routine Description:

    Write a value to DNS registry.

Arguments:

    hKey            --  open handle to regkey to delete

    pZone           --  ptr to zone, required if hKey NOT given

    pszValueName    --  value name

Return Value:

    ERROR_SUCCESS, if successful,
    status code on failure

--*/
{
    BOOL        fneedClose = FALSE;
    DNS_STATUS  status;

    //
    //  if no key
    //      - open DNS zone key if zone name given
    //      - otherwise open DNS parameters key
    //

    if ( !hKey )
    {
        if ( pZone )
        {
            hKey = Reg_OpenZone( pZone->pwsZoneName, NULL );
        }
        else
        {
            hKey = Reg_OpenParameters();
        }
        if ( !hKey )
        {
            return( FALSE );
        }
        fneedClose = TRUE;
    }

    //
    //  delete desired key or value
    //

    status = RegDeleteValueA(
                hKey,
                pszValueName );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( REGISTRY, (
            "WARNING:  RegDeleteValue failed for value %s\n",
            pszValueName ));

        if ( status == ERROR_FILE_NOT_FOUND )
        {
            status = ERROR_SUCCESS;
        }
#if 0
        //
        //  DEVNOTE-LOG: do not want to log if status is not finding value
        //

        DNS_LOG_EVENT(
            DNS_EVENT_REGISTRY_DELETE_FAILED,
            0,
            NULL,
            NULL,
            status );
#endif
    }

    //
    //  if opened key, close it
    //

    if ( fneedClose )
    {
        RegCloseKey( hKey );
    }
    return( status );
}



DNS_STATUS
Reg_GetValue(
    IN      HKEY            hKey,           OPTIONAL
    IN      PZONE_INFO      pZone,
    IN      LPSTR           pszValueName,
    IN      DWORD           dwExpectedType, OPTIONAL
    IN      PVOID           pData,
    IN      PDWORD          pcbData
    )
/*++

Routine Description:

    Read a DNS registry value.

Arguments:

    hKey            --  open handle to registry key to read

    pZone           --  ptr to zone, required if hKey NOT given

    pszValueName    --  value name

    dwExpectedType  --  registry data type;  if given it is checked against
                        type found

    pData       --  ptr to buffer for data

    pcbData     --  buffer for count of data bytes;  on return contains the
                    length of the data item;
                    may be NULL ONLY if dwExpectedType is REG_DWORD

Return Value:

    ERROR_SUCCESS, if successful,
    ERROR_MORE_DATA, if buffer to small
    ERROR_INVALID_DATATYPE, if value datatype does not match expected type
    ERROR_OPEN_FAILED, if could not open key
    status code on failure

--*/
{
    BOOL        fneedClose = FALSE;
    DWORD       regtype;
    DNS_STATUS  status;
    DWORD       dataLength;

    DNS_DEBUG( REGISTRY, (
        "Reg_GetValue( z=%S value=%s, pdata=%p ).\n",
        pZone ? pZone->pwsZoneName : NULL,
        pszValueName,
        pData ));

    //
    //  handle datalength field for DWORD queries
    //

    if ( !pcbData )
    {
        if ( dwExpectedType == REG_DWORD )
        {
            dataLength = sizeof(DWORD);
            pcbData = &dataLength;
        }
        else
        {
            ASSERT( FALSE );
            return( ERROR_INVALID_PARAMETER );
        }
    }

    //
    //  if no key
    //      - open DNS zone key if zone name given
    //      - otherwise open DNS parameters key
    //

    if ( !hKey )
    {
        if ( pZone )
        {
            hKey = Reg_OpenZone( pZone->pwsZoneName, NULL );
        }
        else
        {
            hKey = Reg_OpenParameters();
        }
        if ( !hKey )
        {
            return( ERROR_OPEN_FAILED );
        }
        fneedClose = TRUE;
    }

    //
    //  determine if need unicode read
    //
    //  general paradigm
    //      - keep in ANSI where possible, simply to avoid having to keep
    //          UNICODE property (reg value) names
    //      - IP strings work better with ANSI read anyway
    //      - file name strings must be handled in unicode as if write as
    //          UTF8, they'll be messed up
    //

    if ( DNS_REG_TYPE_UNICODE(dwExpectedType) )
    {
        DNS_DEBUG( REGISTRY, (
            "Reading unicode regkey %S  exptype = %p.\n",
            pszValueName,
            dwExpectedType ));

        dwExpectedType = REG_TYPE_FROM_DNS_REGTYPE( dwExpectedType );

        status = RegQueryValueExW(
                    hKey,
                    (PWSTR) pszValueName,
                    0,              //  reserved
                    & regtype,
                    (PBYTE) pData,  //  data
                    pcbData );      //  data length
    }
    else
    {
        status = RegQueryValueExA(
                    hKey,
                    pszValueName,
                    0,              //  reserved
                    & regtype,
                    (PBYTE) pData,  //  data
                    pcbData );      //  data length
    }

    if ( status != ERROR_SUCCESS )
    {
        IF_DEBUG( REGISTRY )
        {
            if ( status == ERROR_FILE_NOT_FOUND )
            {
                DNS_PRINT((
                    "Reg value %s does not exist\n",
                    pszValueName ));
            }
            else
            {
                DNS_PRINT((
                    "RegQueryValueEx() failed for value %s\n"
                    "\tstatus   = %p\n"
                    "\tkey      = %p\n"
                    "\tzone     = %S\n"
                    "\ttype exp = %d\n"
                    "\tpData    = %p\n"
                    "\tdatalen  = %d\n",
                    pszValueName,
                    status,
                    hKey,
                    pZone ? pZone->pwsZoneName : NULL,
                    dwExpectedType,
                    pData,
                    *pcbData ));
            }
        }
        goto ReadFailed;
    }

    //
    //  verify proper type, if given
    //      - make allowance for EXPAND_SZ requested, but REG_SZ in registry
    //

    else if ( dwExpectedType )
    {
        if ( dwExpectedType != regtype &&
            !(dwExpectedType == REG_EXPAND_SZ && regtype == REG_SZ ) )
        {
            status = ERROR_INVALID_DATATYPE;
            DNS_PRINT((
                "ERROR:  RegQueryValueEx for value %s returned unexpected type %d\n"
                "\texpecting %d\n",
                pszValueName,
                regtype,
                dwExpectedType ));
            goto ReadFailed;
        }
    }


ReadFailed:

    //
    //  if opened key, close it
    //

    if ( fneedClose )
    {
        RegCloseKey( hKey );
    }

    //
    //  DEVNOTE-LOG: log read failures only when MUST exist
    //
#if 0

    if ( status != ERROR_SUCCESS && status != ERROR_FILE_NOT_FOUND )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_REGISTRY_READ_FAILED,
            0,
            NULL,
            NULL,
            status );
    }
#endif

    return( status );
}



PBYTE
Reg_GetValueAllocate(
    IN      HKEY            hKey,           OPTIONAL
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      LPSTR           pszValueName,
    IN      DWORD           dwExpectedType, OPTIONAL
    IN      PDWORD          pdwLength       OPTIONAL
    )
/*++

Routine Description:

    Read a DNS registry value.

    Caller responsible for freeing allocated memory.

Arguments:

    hKey            --  open handle to registry key to read

    pZone           --  ptr to zone, required if hKey NOT given

    pszValueName    --  value name

    dwExpectedType  --  registry data type;  if given it is checked against
                        type found

    pdwLength       -- address to receive allocation length

Return Value:

    Ptr to allocated buffer for value, if successful.
    NULL on error.

--*/
{
    PBYTE       pdata;
    DWORD       dataLength = 0;
    DNS_STATUS  status;
    PBYTE       putf8;

    //
    //  call to get data length
    //

    status = Reg_GetValue(
                hKey,
                pZone,
                pszValueName,
                dwExpectedType,
                NULL,
                & dataLength );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( REGISTRY, (
            "Failed to get datalength for value %s\n",
            pszValueName ));
        return( NULL );
    }
    DNS_DEBUG( REGISTRY, (
        "Fetching %d byte item at registry value %s.\n",
        dataLength,
        pszValueName ));

    //
    //  allocate desired buffer length
    //

    pdata = (PBYTE) ALLOC_TAGHEAP( dataLength, MEMTAG_REGISTRY );
    IF_NOMEM( !pdata )
    {
        return( NULL );
    }

    //
    //  get actual registry data
    //

    status = Reg_GetValue(
                hKey,
                pZone,
                pszValueName,
                dwExpectedType,
                pdata,
                & dataLength );

    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT((
            "ERROR:  Failure to get data for value %s\n",
            pszValueName ));

        FREE_HEAP( pdata );
        return( NULL );
    }

    //
    //  convert unicode string to UTF8?
    //

    if ( DNS_REG_UTF8 == dwExpectedType )
    {
        DNS_DEBUG( REGISTRY, (
            "Registry unicode string %S, to convert back to UTF8.\n",
            pdata ));

        putf8 = Dns_StringCopyAllocate(
                    pdata,
                    0,
                    DnsCharSetUnicode,
                    DnsCharSetUtf8 );

        //  dump unicode string and use UTF8

        FREE_HEAP( pdata );
        pdata = putf8;

        if ( !pdata )
        {
            return( NULL );
        }
        if ( pdwLength )
        {
            dataLength = strlen( pdata ) + 1;
        }
    }

    if ( pdwLength )
    {
        *pdwLength = dataLength;
    }

    Mem_VerifyHeapBlock( pdata, 0, 0 );

    return( pdata );
}



PIP_ARRAY
Reg_GetIpArray(
    IN      HKEY            hKey,           OPTIONAL
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      LPSTR           pszValueName
    )
/*++

Routine Description:

    Read an IP array from the registry.

    Caller responsible for freeing allocated memory.

Arguments:

    hKey            --  open handle to regkey to read

    pZone           --  ptr to zone, required if hKey NOT given;

    pszValueName    --  value name

Return Value:

    Ptr to IP_ARRAY allocated, if successful.
    NULL on error.

--*/
{
    DWORD       dataLength;
    PIP_ARRAY   pipArray = NULL;
    LPSTR       pszstringArray;
    DNS_STATUS  status;

    //
    //  retrieve IP array as string
    //

    pszstringArray = Reg_GetValueAllocate(
                        hKey,
                        pZone,
                        pszValueName,
                        REG_SZ,
                        &dataLength
                        );
    if ( pszstringArray )
    {
        DNS_DEBUG( REGISTRY, (
            "Found string IP array for registry value %s.\n"
            "\tstring = %s\n",
            pszValueName,
            pszstringArray ));

        status = Dns_CreateIpArrayFromMultiIpString(
                    pszstringArray,
                    & pipArray );

        if ( status == ERROR_SUCCESS )
        {
            goto Done;
        }

        DNS_DEBUG( REGISTRY, (
            "ERROR:  string IP array %s is INVALID!\n",
            pszstringArray ));
        goto Invalid;
    }

    //
    //  registry does NOT have string IP array, try binary format
    //

    pipArray = (PIP_ARRAY) Reg_GetValueAllocate(
                                hKey,
                                pZone,
                                pszValueName,
                                REG_BINARY,
                                &dataLength
                                );
    //  validity check

    if ( pipArray )
    {
        if ( dataLength % sizeof(DWORD) != 0    ||
            dataLength != Dns_SizeofIpArray(pipArray) )
        {
            goto Invalid;
        }
    }

Done:

    //  return valid IP array or NULL if reg value did not exist

    FREE_HEAP( pszstringArray );

    Mem_VerifyHeapBlock( pipArray, 0, 0 );

    return( pipArray );

Invalid:

    {
        PVOID   argArray[2];
        BYTE    argTypeArray[2];

        DNS_PRINT((
            "ERROR:  invalid IP_ARRAY read from registry.\n"
            "\tkey=%p, zone=%S, value=%s.\n",
            hKey,
            pZone ? pZone->pwsZoneName : NULL,
            pszValueName ));

        if ( pZone )
        {
            argTypeArray[0] = EVENTARG_UNICODE;
            argTypeArray[1] = EVENTARG_UTF8;

            argArray[0] = pZone->pwsZoneName;
            argArray[1] = pszValueName;

            DNS_LOG_EVENT(
                DNS_EVENT_INVALID_REGISTRY_ZONE_DATA,
                2,
                argArray,
                argTypeArray,
                0 );
        }
        else
        {
            argArray[0] = pszValueName;

            DNS_LOG_EVENT(
                DNS_EVENT_INVALID_REGISTRY_PARAM,
                1,
                argArray,
                EVENTARG_ALL_UTF8,
                0 );
        }
    }
    FREE_HEAP( pszstringArray );
    FREE_HEAP( pipArray );
    return( NULL );
}



DNS_STATUS
Reg_ReadDwordValue(
    IN      HKEY            hKey,
    IN      PWSTR           pwsZoneName,    OPTIONAL
    IN      LPSTR           pszValueName,
    IN      BOOL            bByteResult,
    OUT     PVOID           pResult
    )
/*++

Routine Description:

    Read standard DWORD value from registry into memory location.

    This is just a wrapped to eliminate duplicate registry setup
    and debug info, for call that is used repeatedly in code.

Arguments:

    hKey            --  open handle to regkey to read

    pZone           --  ptr to zone, required if hKey NOT given;

    pszValueName    --  value name

    bByteResult     --  treat result as BYTE sized

    pResult         --  ptr to result memory location

Return Value:

    ERROR_SUCCESS on successful read.
    ErrorCode on failure.

--*/
{
    DNS_STATUS  status;
    DWORD       regValue;
    DWORD       regSize = sizeof(DWORD);

    //
    //  make DWORD get call
    //

    status = Reg_GetValue(
                hKey,
                NULL,
                pszValueName,
                REG_DWORD,
                & regValue,
                & regSize );

    if ( status == ERROR_SUCCESS )
    {
        DNS_DEBUG( INIT, (
            "Read zone %S %s value = %d\n",
            pwsZoneName ? pwsZoneName : NULL,
            pszValueName,
            regValue ));

        ASSERT( regSize == sizeof(DWORD) );

        if ( bByteResult )
        {
            * (PBYTE)pResult = (UCHAR) regValue;
        }
        else
        {
            * (PDWORD)pResult = regValue;
        }
    }
    return( status );
}



//
//  Basic DNS independent registry operations
//

LPSTR
Reg_AllocateExpandedString_A(
    IN      LPSTR           pszString
    )
/*++

Routine Description:

    Create expanded REG_EXPAND_SZ type string.

    Caller responsible for freeing allocated memory.

Arguments:

    pszString --    string to expand

Return Value:

    Ptr to allocated buffer for value, if successful.
    NULL on error.

--*/
{
    LPSTR   pszexpanded;
    DWORD   dataLength = 0;

    //
    //  if NULL, return NULL
    //

    if ( ! pszString )
    {
        return( NULL );
    }

    //
    //  determine expanded length and allocate, then do actual expansion
    //

    dataLength = ExpandEnvironmentStringsA(
                        pszString,
                        NULL,
                        0 );
    if ( dataLength == 0 )
    {
        DNS_DEBUG( REGISTRY, (
            "ERROR:  ExpandEnvironmentStrings() failed getting length of %s.\n",
            pszString ));
        return( NULL );
    }

    pszexpanded = (PBYTE) ALLOC_TAGHEAP( dataLength, MEMTAG_REGISTRY );
    IF_NOMEM( !pszexpanded )
    {
        return( NULL );
    }

    if ( ! ExpandEnvironmentStringsA(
                        pszString,
                        pszexpanded,
                        dataLength ) )
    {
        return( NULL );
    }
    return( pszexpanded );
}



PWSTR
Reg_AllocateExpandedString_W(
    IN      PWSTR           pwsString
    )
/*++

Routine Description:

    Create expanded REG_EXPAND_SZ type string.

    Caller responsible for freeing allocated memory.

Arguments:

    pwsString --    string to expand

Return Value:

    Ptr to allocated buffer for value, if successful.
    NULL on error.

--*/
{
    PWSTR   pexpanded;
    DWORD   dataLength = 0;

    //
    //  if NULL, return NULL
    //

    if ( ! pwsString )
    {
        return( NULL );
    }

    //
    //  determine expanded length and allocate, then do actual expansion
    //

    dataLength = ExpandEnvironmentStringsW(
                        pwsString,
                        NULL,
                        0 );
    if ( dataLength == 0 )
    {
        DNS_DEBUG( REGISTRY, (
            "ERROR:  ExpandEnvironmentStrings() failed getting length of %S.\n",
            pwsString ));
        return( NULL );
    }

    pexpanded = ( PWSTR ) ALLOC_TAGHEAP(
                    dataLength * sizeof( WCHAR ),
                    MEMTAG_REGISTRY );
    IF_NOMEM( !pexpanded )
    {
        return( NULL );
    }

    if ( ! ExpandEnvironmentStringsW(
                        pwsString,
                        pexpanded,
                        dataLength ) )
    {
        return( NULL );
    }
    return( pexpanded );
}



DNS_STATUS
Reg_DeleteKeySubtree(
    IN      HKEY            hKey,
    IN      PWSTR           pwsKeyName      OPTIONAL
    )
/*++

Routine Description:

    Delete key, including subtree.

    RegDeleteKey is broken in NT and does NOT have a mode for
    deleting entire subtree.  This handles that.

Arguments:

    hKey -- desired key, or higher level key

    pwsKeyName -- key name, relative to hKey given;  NULL if hKey is
        desired delete key

Return Value:

    ERROR_SUCCESS if successful
    Error status code on failure

--*/
{
    HKEY        hkeyOpened = NULL;
    DNS_STATUS  status;
    DWORD       index = 0;
    DWORD       bufLength;
    WCHAR       subkeyNameBuffer[ MAX_PATH + 1 ];

    DNS_DEBUG( REGISTRY, (
        "Reg_DeleteKeySubtree %S\n",
        pwsKeyName ));

    //
    //  delete the key
    //      - if works, we're done
    //

    status = RegDeleteKeyW(
                hKey,
                pwsKeyName
                );
    if ( status == ERROR_SUCCESS )
    {
        DNS_DEBUG( REGISTRY, (
            "Successfully deleted key %S from parent key %p.\n",
            pwsKeyName,
            hKey ));
        return( status );
    }

    //
    //  need to open and delete subkeys
    //      - if don't have handle to delete key, open it
    //

    if ( pwsKeyName )
    {
        status = RegOpenKeyW(
                    hKey,
                    pwsKeyName,
                    & hkeyOpened );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( REGISTRY, (
                "ERROR:  unable to open key %S from parent key %p.\n"
                "\tstatus = %d.\n",
                pwsKeyName,
                hKey,
                status ));
            return( status );
        }
        hKey = hkeyOpened;
    }

    //
    //  enum and delete subkeys
    //      - index is always zero if delete successful
    //

    index = 0;

    while ( 1 )
    {
        bufLength = sizeof( subkeyNameBuffer ) / sizeof( WCHAR );

        status = RegEnumKeyEx(
                    hKey,
                    index,
                    subkeyNameBuffer,
                    & bufLength,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

        //  recurse to delete enumerated key

        if ( status == ERROR_SUCCESS )
        {
            status = Reg_DeleteKeySubtree(
                        hKey,
                        subkeyNameBuffer
                        );
            if ( status == ERROR_SUCCESS )
            {
                continue;
            }
            break;
        }

        //  finished enumeration

        else if ( status == ERROR_NO_MORE_ITEMS )
        {
            status = ERROR_SUCCESS;
            break;
        }

        //  enumeration error

        DNS_PRINT((
            "ERROR:  RegEnumKeyEx failed for opening [%d] key\n"
            "\tstatus = %d.\n",
            index,
            status ));
        break;
    }

    //  if opened key at this level, close it

    if ( hkeyOpened )
    {
        RegCloseKey( hkeyOpened );
    }

    //
    //  retry delete of top level key
    //

    status = RegDeleteKeyW(
                hKey,
                pwsKeyName
                );
    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT((
            "ERROR:  Unable to delete key %S even after deleting subtree.\n",
            pwsKeyName
            ));
    }
    return( status );
}



DNS_STATUS
Reg_ModifyMultiszString(
    IN      HKEY    hkey,           OPTIONAL
    IN      LPSTR   pszValueName,
    IN      LPSTR   pszString,
    IN      DWORD   fAdd
    )
/*++

Routine Description:

    Modify a REG_MULTI_SZ value.
    Adds or deletes a string from multi-string value.

Arguments:

    hKey            --  open handle to registry key

    pszValueName    --  value name

    pszString       --  string to add \ delete from value

    fAdd            --  TRUE to add string to value;  FALSE to delete

Return Value:

    ERROR_SUCCESS, if successful,

--*/
{
    BOOL        fneedClose = FALSE;
    DWORD       regtype;
    DNS_STATUS  status;
    DWORD       dataLength;

    DNS_DEBUG( REGISTRY, (
        "RegModifyMultiszString()\n"
        "value name = %s\n"
        "string     = %s\n"
        "fAdd       = %d\n",
        pszValueName,
        pszString,
        fAdd ));

#if 0
    strings = Reg_GetValueAllocate(
                hkey,
                NULL,
                pszValueName,
                REG_MULTI_SZ,
                & length );

    //
    //  loop through strings until find desired string
    //

    fend = TRUE;

    while ( 1 )
    {
        if ( *pch == 0 )
        {
            if ( fend )
            {
                break;
            }
            fend = TRUE;
            pch++;
            continue;
        }

        if ( ! _stricmp( pch, pszString )
        {


        }
    }

    //
    //  string not found
    //      - if deleting, we're done
    //      - if adding, append desired string on end

    if ( !fAdd )
    {
        return( ERROR_SUCCESS );
    }

    {
        newLength = length + strlen( pszString ) + 1;
        pnewStrings = ALLOC_TAGHEAP( newLength, MEMTAG_REGISTRY );
        IF_NOMEM( pnewStrings )
        {
            return( DNS_ERROR_NO_MEMORY );
        }
        RtlCopyMemory(
            pnewStrings,
            strings,
            length );

        RtlCopyMemory(
            &pnewStrings[ length-1 ];
            pszString,
            newLength - length );

        pnewStrings[ newLength ] = 0;

        status = Reg_SetValue(
                    hkey,
                    NULL,
                    pszValueName,
                    REG_MULTI_SZ,
                    pnewStrings,
                    newLength );

    }

    newLength = length + strlen( pszString ) + 1;
    pnewStrings = ALLOC_TAGHEAP( newLength, MEMTAG_REGISTRY );
    IF_NOMEM( pnewStrings )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    RtlCopyMemory(
        pnewStrings,
        strings,
        length );

    RtlCopyMemory(
        &pnewStrings[ length-1 ];
        pszString,
        newLength - length );

    pnewStrings[ newLength ] = 0;

    status = Reg_SetValue(
                hkey,
                NULL,
                pszValueName,
                REG_MULTI_SZ,
                pnewStrings,
                newLength );
#endif

    return( ERROR_SUCCESS );
}



DNS_STATUS
Reg_AddPrinicipalSecurity(
    IN      HKEY    hkey,
    IN      LPTSTR  pwsUser,
    IN      DWORD   dwAccessFlags       OPTIONAL
    )
/*++

Routine Description:

    Extend DNs registry service point access to contain given hkey SD + pwsUser
    security principal RW access.

Arguments:

    hKey            --  open handle to registry key

    pwsUser         --  user to add access to key

    dwAccessFlags   --  additional acccess flags such as:
                        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
Return Value:

    ERROR_SUCCESS, if successful,

--*/
{

    DNS_STATUS  status = ERROR_SUCCESS;
    BOOL        bstatus = FALSE;
    BOOL        bDefaulted = FALSE;
    PSECURITY_DESCRIPTOR pOldSd = NULL;
    PSECURITY_DESCRIPTOR pNewSd = NULL;
    DWORD cbSd = 0;
    PSID pUser = NULL, pGroup = NULL;

    DNS_DEBUG( REGISTRY, (
        "Call Reg_AddPrinicipalSecurity(%p, %S)\n",
        hkey, pwsUser));

    //
    //  parameter sanity.
    //

    if ( !hkey || !pwsUser )
    {
        DNS_DEBUG( REGISTRY, (
            "Error: Invalid key specified to Reg_SetSecurity\n"));
        ASSERT (hkey);
        ASSERT (pwsUser);
        return ERROR_INVALID_PARAMETER;
    }

    //
    //  Get SD length to allocate
    //

    status = RegGetKeySecurity( hkey,
                                OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION |
                                DACL_SECURITY_INFORMATION,
                                NULL,
                                &cbSd );
    if ( ERROR_INSUFFICIENT_BUFFER != status )
    {
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: failed to get key security\n",
            status ));
        ASSERT (FALSE);
        return status;
    }

    ASSERT ( cbSd > 0 );

    //
    //  Get current security descriptor
    //

    pOldSd = ALLOCATE_HEAP( cbSd );
    if ( !pOldSd )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Cleanup;
    }

    status = RegGetKeySecurity( hkey,
                                OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION |
                                DACL_SECURITY_INFORMATION,
                                pOldSd,
                                &cbSd );

    if ( ERROR_SUCCESS != status )
    {
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: failed to get key security (2).\n",
            status ));
        ASSERT (FALSE);
        goto Cleanup;
    }

    //
    //  Extract SD user/group SIDS.
    //

    bstatus = GetSecurityDescriptorOwner( pOldSd,
                                          &pUser,
                                          &bDefaulted );
    if ( !bstatus )
    {
        status = GetLastError();
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: failed to get SD user.\n",
            status ));
        ASSERT (FALSE);
        goto Cleanup;
    }

    ASSERT (pUser);

    bstatus = GetSecurityDescriptorGroup( pOldSd,
                                          &pGroup,
                                          &bDefaulted );
    if ( !bstatus )
    {
        status = GetLastError();
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: failed to get SD group.\n",
            status ));
        ASSERT (FALSE);
        goto Cleanup;
    }

    ASSERT (pGroup);

    //
    //  Create new SD
    //

    status = SD_AddPrincipalToSD(
                    pwsUser,
                    pOldSd,
                    & pNewSd,
                    GENERIC_ALL |
                    STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL,
                    dwAccessFlags,
                    pUser,
                    pGroup,
                    FALSE );

    if ( ERROR_SUCCESS != status )
    {
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: failed to add principal to SD.\n",
            status ));
        ASSERT( FALSE );
        goto Cleanup;
    }

    status = RegSetKeySecurity( hkey,
                                DACL_SECURITY_INFORMATION,
                                pNewSd );


    if ( ERROR_SUCCESS != status )
    {
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: failed to write new SD to registry.\n",
            status ));
        ASSERT( FALSE );
        goto Cleanup;
    }

    //
    //  Cleanup and return
    //

    Cleanup:

    if ( pOldSd )
    {
        FREE_HEAP( pOldSd );
    }

    if ( pNewSd )
    {
        FREE_HEAP( pNewSd );
    }

    DNS_DEBUG( REGISTRY, (
        "Exit <%lu> Reg_AddPrinicipalSecurity\n",
        status ));
    return status;
}


DNS_STATUS
Reg_ExtendRootAccess(
    VOID
    )
/*++

Routine Description:

    Modifies DNS root regkey to contain DnsAdmins & whoever we like
    (nobody else at the moment)

Arguments:

    None.

Return Value:

    ERROR_SUCCESS, if successful,

--*/
{

    HKEY hkey;
    DNS_STATUS status = ERROR_SUCCESS;

    DNS_DEBUG( REGISTRY, (
        "Call  Reg_ExtendRootAccess\n"
        ));

    DNS_DEBUG( REGISTRY, (
        "Modifying DNS root key security\n"
        ));
    hkey = Reg_OpenRoot();

    if ( !hkey )
    {
        status = GetLastError();
        ASSERT ( ERROR_SUCCESS != status );
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: Reg_OpenRoot failed.\n",
            status ));
        goto Cleanup;
    }

    status = Reg_AddPrinicipalSecurity(hkey,
                                       SZ_DNS_ADMIN_GROUP_W,
                                       0        // can't use CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
                                       );
    if ( ERROR_SUCCESS != status )
    {
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: Reg_AddPrincipalSecurity failed.\n",
            status ));
        goto Cleanup;
    }
    RegCloseKey(hkey);
    hkey = NULL;

    //
    //  DEVNOTE: Is this necessary at all? I use inheritance, but it seems
    //      that the registry doesn't modify existing keys but only apply
    //      to new ones. Seems to be necessary now.
    //
    DNS_DEBUG( REGISTRY, (
        "Modifying DNS Parameters key security\n"
        ));
    hkey = Reg_OpenParameters();

    if ( !hkey )
    {
        status = GetLastError();
        ASSERT ( ERROR_SUCCESS != status );
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: Reg_OpenRoot failed.\n",
            status ));
        goto Cleanup;
    }

    status = Reg_AddPrinicipalSecurity(hkey,
                                       SZ_DNS_ADMIN_GROUP_W,
                                       0);
    if ( ERROR_SUCCESS != status )
    {
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: Reg_AddPrincipalSecurity failed.\n",
            status ));
        goto Cleanup;
    }
    RegCloseKey(hkey);



    //
    // set zones security w/ inheritance for sub containers.
    //
    status = Reg_ExtendZonesAccess();
    if ( ERROR_SUCCESS != status )
    {
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: cannot extend zones security\n",
            status ));
        ASSERT ( FALSE );
        goto Cleanup;
    }


Cleanup:


    if ( hkey )
    {
        RegCloseKey(hkey);
    }

    DNS_DEBUG( REGISTRY, (
        "Exit <%lu> Reg_ExtendRootAccess\n",
        status ));

    return status;
}


DNS_STATUS
Reg_ExtendZonesAccess(
    VOID
    )
/*++

Routine Description:

    Modifies DNS root regkey to contain DnsAdmins & whoever we like
    (nobody else at the moment)

Arguments:

    None.

Return Value:

    ERROR_SUCCESS, if successful,

--*/
{

    HKEY hkey;
    DNS_STATUS status = ERROR_SUCCESS;

    DNS_DEBUG( REGISTRY, (
        "Call  Reg_ExtendZonesAccess\n"
        ));

    DNS_DEBUG( REGISTRY, (
        "Modifying DNS Zones key security\n"
        ));
    hkey = Reg_OpenZones();

    if ( !hkey )
    {
        status = GetLastError();
        ASSERT ( ERROR_SUCCESS != status );
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: Reg_OpenRoot failed.\n",
            status ));
        goto Cleanup;
    }

    status = Reg_AddPrinicipalSecurity(hkey,
                                       SZ_DNS_ADMIN_GROUP_W,
                                       CONTAINER_INHERIT_ACE |
                                       OBJECT_INHERIT_ACE);
    if ( ERROR_SUCCESS != status )
    {
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: Reg_AddPrincipalSecurity failed.\n",
            status ));
        goto Cleanup;
    }

    //
    //  DEVNOTE-WORKAROUND: For some reason, if zone was just created, admin has
    //  only RO access but requires full access. So we add it here manually.
    //

    status = Reg_AddPrinicipalSecurity(hkey,
                                       L"Administrators",
                                       CONTAINER_INHERIT_ACE |
                                       OBJECT_INHERIT_ACE);
    if ( ERROR_SUCCESS != status )
    {
        DNS_DEBUG( REGISTRY, (
            "Error <%lu>: Reg_AddPrincipalSecurity failed for administrators.\n",
            status ));
        goto Cleanup;
    }
    RegCloseKey(hkey);
    hkey = NULL;


Cleanup:

    if ( hkey )
    {
        RegCloseKey(hkey);
    }

    DNS_DEBUG( REGISTRY, (
        "Exit <%lu> Reg_ExtendZonesAccess\n",
        status ));

    return status;
}

//
//  End of registry.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\registry.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    registry.h

Abstract:

    Domain Name System (DNS) Server

    DNS Registry definitions.

Author:

    Jim Gilroy (jamesg)     September 1995

Revision History:

--*/

#ifndef _DNS_REGISTRY_INCLUDED_
#define _DNS_REGISTRY_INCLUDED_


//
//  Registry types
//
//  There are a few types of objects DNS reads\writes from registry:
//      DWORDS
//      IP arrays (stored as strings)
//      file (or directory) names
//      DNS names (meaning UTF8 string)
//
//  The registry API insist on distorting UTF8 data if written\read through
//  ANSI API.  Essentially they try for "best ANSI" match, rather than just
//  returning the binary data.  This requires that anything that can contain
//  extended characters MUST be written\read in unicode.
//
//  However, DNS property types are in ANSI.  And IP strings reads are easiest
//  to handle if kept in ANSI for simply processing to\from IP array.
//
//  Furthermore, we need a way to specify final type (UTF8 or unicode) of
//  string data.  General paradigm is to keep file name data in unicode for
//  use by system, but DNS name data converted to UTF8 for use by database.
//

#define DNS_REG_SZ_ANSI         (REG_SZ)
#define DNS_REG_EXPAND_WSZ      (0xf0000000 | REG_EXPAND_SZ)
#define DNS_REG_WSZ             (0xf0000000 | REG_SZ)
#define DNS_REG_UTF8            (0xff000000 | REG_SZ)

#define DNS_REG_TYPE_UNICODE( type )        ( (type) & 0xf0000000 )

#define REG_TYPE_FROM_DNS_REGTYPE( type )   ( (type) & 0x0000ffff )


//
//  Unicode versions of regkeys that require unicode read\write
//

#define DNS_REGKEY_ZONE_FILE_PRIVATE            ((LPSTR)TEXT(DNS_REGKEY_ZONE_FILE))
#define DNS_REGKEY_DATABASE_DIRECTORY_PRIVATE   ((LPSTR)TEXT(DNS_REGKEY_DATABASE_DIRECTORY))
#define DNS_REGKEY_ROOT_HINTS_FILE_PRIVATE      ((LPSTR)TEXT(DNS_REGKEY_ROOT_HINTS_FILE))
#define DNS_REGKEY_LOG_FILE_PATH_PRIVATE        ((LPSTR)TEXT(DNS_REGKEY_LOG_FILE_PATH))
#define DNS_REGKEY_BOOT_FILENAME_PRIVATE        ((LPSTR)TEXT(DNS_REGKEY_BOOT_FILENAME))
#define DNS_REGKEY_NO_ROUND_ROBIN_PRIVATE       ((LPSTR)TEXT(DNS_REGKEY_NO_ROUND_ROBIN))
#define DNS_REGKEY_ZONE_BREAK_ON_NAME_UPDATE_PRIVATE    ((LPSTR)TEXT(DNS_REGKEY_ZONE_BREAK_ON_NAME_UPDATE))
//
//  DNS Registry global
//
//  Indicates when writing parameters back to registry.  This should
//  be TRUE in all cases, except when booting from registry itself.
//

extern BOOL g_bRegistryWriteBack;


//
//  DNS registry key names
//
//  Note, exposed server\zone property names are given in DNS RPC header
//  (dnsrpc.h).  These property names are the registry key names.
//

//  Name for cache file zone

#define DNS_REGKEY_CACHE_ZONE               "CacheFile"

//
//  Private zone regkeys
//

//  DC Promo transitional zones

#define DNS_REGKEY_ZONE_DCPROMO_CONVERT     "DcPromoConvert"

//  Retired zone key for delete only

#define DNS_REGKEY_ZONE_USE_DBASE           "UseDatabase"

//  For versioning DS integrated zones

#define DNS_REGKEY_ZONE_VERSION             "SoaVersion"


//
//  Basic DNS registry operations (registry.c)
//

#define DNS_REGSOURCE_CCS       0       //  CurrentControlSet
#define DNS_REGSOURCE_SW        1       //  Software

VOID
Reg_Init(
    VOID
    );

DWORD
Reg_GetZonesSource(
    VOID                        // returns one of DNS_REGSOURCE_XXX
    );

DWORD
Reg_SetZonesSource(
    DWORD       newSource       // one of DNS_REGSOURCE_XXX
    );

VOID
Reg_WriteZonesMovedMarker(
    VOID
    );

HKEY
Reg_OpenRoot(
    VOID
    );

HKEY
Reg_OpenParameters(
    VOID
    );

HKEY
Reg_OpenZones(
    VOID
    );

DNS_STATUS
Reg_EnumZones(
    IN OUT  PHKEY           phkeyZones,
    IN      DWORD           dwZoneIndex,
    OUT     PHKEY           phkeyZone,
    OUT     PWCHAR          pwchZoneNameBuf
    );

HKEY
Reg_OpenZone(
    IN      PWSTR           pwszZoneName,
    IN      HKEY            hZonesKey       OPTIONAL
    );

VOID
Reg_DeleteZone(
    IN      PWSTR           pwszZoneName
    );

DWORD
Reg_DeleteAllZones(
    VOID
    );

//
//  Registry write calls
//

DNS_STATUS
Reg_SetValue(
    IN      HKEY            hkey,           OPTIONAL
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      LPSTR           pszValueName,
    IN      DWORD           dwType,
    IN      PVOID           pData,
    IN      DWORD           cbData
    );

DNS_STATUS
Reg_SetDwordValue(
    IN      HKEY            hkey,           OPTIONAL
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      LPSTR           pszValueName,
    IN      DWORD           dwValue
    );

DNS_STATUS
Reg_SetIpArray(
    IN      HKEY            hKey,           OPTIONAL
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      LPSTR           pszValueName,
    IN      PIP_ARRAY       pIpArray
    );

DNS_STATUS
Reg_DeleteValue(
    IN      HKEY            hkey,           OPTIONAL
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      LPSTR           pszValueName
    );

DNS_STATUS
Reg_DeleteKeySubtree(
    IN      HKEY            hKey,
    IN      PWSTR           pwsKeyName      OPTIONAL
    );

//
//  Registry read calls
//

DNS_STATUS
Reg_GetValue(
    IN      HKEY            hkey,           OPTIONAL
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      LPSTR           pszValueName,
    IN      DWORD           dwExpectedType, OPTIONAL
    IN      PVOID           pData,
    IN      PDWORD          pcbData
    );

PBYTE
Reg_GetValueAllocate(
    IN      HKEY            hkey,           OPTIONAL
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      LPSTR           pszValueName,
    IN      DWORD           dwExpectedType, OPTIONAL
    IN      PDWORD          pdwLength       OPTIONAL
    );

PIP_ARRAY
Reg_GetIpArray(
    IN      HKEY            hkey,           OPTIONAL
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      LPSTR           pszValueName
    );

DNS_STATUS
Reg_ReadDwordValue(
    IN      HKEY            hKey,
    IN      PWSTR           pwsZoneName,    OPTIONAL
    IN      LPSTR           pszValueName,
    IN      BOOL            bByteResult,
    OUT     PVOID           pResult
    );


//  define for backward compatibility

#define Reg_GetIpArrayValueAllocate(a,b,c) \
        Reg_GetIpArray(a,b,c)

DNS_STATUS
Reg_ModifyMultiszString(
    IN      HKEY            hkey,           OPTIONAL
    IN      LPSTR           pszValueName,
    IN      LPSTR           pszString,
    IN      DWORD           fAdd
    );

DNS_STATUS
Reg_AddPrinicipalSecurity(
    IN      HKEY            hkey,
    IN      LPTSTR          pwsUser,
    IN      DWORD           dwAccessFlags   OPTIONAL
    );

LPSTR
Reg_AllocateExpandedString_A(
    IN      LPSTR           pszString
    );

PWSTR
Reg_AllocateExpandedString_W(
    IN      PWSTR           pwsString
    );

DNS_STATUS
Reg_ExtendRootAccess(
    VOID
    );

DNS_STATUS
Reg_ExtendZonesAccess(
    VOID
    );

#endif //   _DNS_REGISTRY_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\rescodes.h ===
/*++

Copyright(c) 1995-1999 Microsoft Corporation

Module Name:

    rescodes.h

Abstract:

    Domain Name System (DNS) Server

    Definitions for resources from dnssrv.rc

Author:



Revision History:

--*/


#ifndef _RESCODES_INCLUDED
#define _RESCODES_INCLUDED


//
// String Resources defined in dnssrv.rc
//

#define ID_ADMIN_GROUP_DESCRIPTION      0x0000C002
#define ID_PROXY_GROUP_DESCRIPTION      0x0000C004


#endif

//
// end of rescodes.h
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\remote.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    remote.c

Abstract:

    Domain Name System (DNS) Server

    Remote server tracking.

Author:

    Jim Gilroy (jamesg)     November 29, 1998

Revision History:

--*/


#include "dnssrv.h"

#include <stddef.h> // intptr_t


//
//  Visit NS list
//
//  Zone root node info is overloaded into NS-IP entries of
//  visit list.
//

#define NS_LIST_ZONE_ROOT_PRIORITY          (0)
#define NS_LIST_ZONE_ROOT_SEND_COUNT        (0)

//
//  Special visit list priorities
//
//  New priority set so we try unknown server if lowest is larger than this value.
//  This ensures that we will try local lan servers, and not get pulled into using
//  available but remote server.  Yet it keeps us preferentially going to quickly
//  responding DNS server connected to local LAN.
//

#define NEW_IP_PRIORITY             (50)
#define MAX_FAST_SERVER_PRIORITY    (100)

#define NO_RESPONSE_PRIORITY        (0x7ffffff7)
#define MISSING_GLUE_PRIORITY       (0xffff8888)


//
//  Special visit list "IP" for denoting special entries
//

//  empty "missing-glue" IP

#define IP_MISSING_GLUE             (0xffffffff)

//  zone root node entry in list

#define IP_ZONE_ROOT_NODE           (0x7fffffff)


//
//  Max sends to any IP
//

#define RECURSE_IP_SEND_MAX         (2)

//
//  Count of visit IPs for zone
//

#define ZONE_VISIT_NS_COUNT(pvisit) ((UCHAR)(pvisit)->Priority)

//
//  Random seed - no protection necessary
//

ULONG       g_RandomSeed = 0;



//
//  Remote server status tracking.
//
//  Purpose of this module is to allow DNS server to track
//  the status of remote servers in order to choose the best
//  one for recursing a query.
//
//  The definition of "best" basically boils down to responds fastest.
//
//  To some extent the defintion of "best" may be dependent on what
//  data -- what zone -- is being queried for.  But since we deal here
//  with iterative queries to other servers, there should be no delay
//  even when response is not authoritative.
//
//  Specific data sets may be stored at nodes -- example, all the NS\IP
//  available at delegation point -- this module deals only with the
//  global tracking of remote server response.
//
//
//  Implementation:
//
//  1) Independent memory blob for each remote server's data
//  2) Access through hash table with buckets.
//
//
//  EDNS tracking:
//  This module now also tracks the EDNS versions supported by remote
//  servers. This allows us to not continually retry EDNS communication
//  with remotes. However, once per day (by default) we will purge our
//  knowledge of the remote's EDNS support in case it has changed. We
//  do this by keeping track of the last time we set the EDNS version of
//  the server and dumping this knowledge if the time period has elapsed.
// 


//
//  Remote server data
//

typedef struct _RemoteServer
{
    struct _RemoteServer *  pNext;
    IP_ADDRESS              IpAddress;
    DWORD                   LastAccess;
    DWORD                   AverageResponse;
    DWORD                   BestResponse;
    UCHAR                   ResponseCount;
    UCHAR                   TimeoutCount;
    UCHAR                   EDnsVersion;
    DWORD                   LastTimeEDnsVersionSet;
}
REMOTE_SRV, *PREMOTE_SRV;


//
//  Hash table
//

#define REMOTE_ARRAY_SIZE   (256)

PREMOTE_SRV         RemoteHash[ REMOTE_ARRAY_SIZE ];

CRITICAL_SECTION    csRemoteLock;

#define LOCK_REMOTE()      EnterCriticalSection( &csRemoteLock );
#define UNLOCK_REMOTE()    LeaveCriticalSection( &csRemoteLock );



//
//  Private remote functions
//

PREMOTE_SRV
Remote_FindOrCreate(
    IN      IP_ADDRESS      IpAddress,
    IN      BOOL            fCreate,
    IN      BOOL            fLocked
    )
/*++

Routine Description:

    Find or create remote blob.

Arguments:

    IpAddress -- IP to find

    fCreate   -- TRUE to create if not found

    fLocked   -- TRUE if remote list already locked

Return Value:

    Ptr to remote struct.

--*/
{
    PREMOTE_SRV premote;
    PREMOTE_SRV pback;

    DNS_DEBUG( REMOTE, (
        "Remote_FindOrCreate( %p )\n",
        IpAddress ));

    if ( ! fLocked )
    {
        LOCK_REMOTE();
    }

    //
    //  hash on last IP octect (most random)
    //      - note IP in net byte order so low octect is in high memory
    //

    pback = (PREMOTE_SRV) &RemoteHash[ (IpAddress >> 24) ];

    while( premote = pback->pNext )
    {
        if ( premote->IpAddress < IpAddress )
        {
            pback = premote;
            continue;
        }
        else if ( premote->IpAddress == IpAddress )
        {
            goto Done;
        }

        if ( fCreate )
        {
            break;
        }
        else
        {
            premote = NULL;
            goto Done;
        }
    }

    //
    //  not in list -- allocate and enlist
    //

    premote = ALLOC_TAGHEAP_ZERO( sizeof(REMOTE_SRV), MEMTAG_REMOTE );
    IF_NOMEM( !premote )
    {
        goto Done;
    }
    premote->IpAddress = IpAddress;

    premote->pNext = pback->pNext;
    pback->pNext = premote;


Done:

    if ( ! fLocked )
    {
        UNLOCK_REMOTE();
    }
    return( premote );
}



VOID
Remote_UpdateResponseTime(
    IN      IP_ADDRESS      IpAddress,
    IN      DWORD           ResponseTime,
    IN      DWORD           Timeout
    )
/*++

Routine Description:

    Update timeoutFind or create remote blob.

    DEVNOTE-DCR: 455666 - use sliding average?

Arguments:

    IpAddress -- IP to find

    ResponseTime -- response time (ms)

    Timeout -- if no response, timeout in seconds

Return Value:

    None

--*/
{
    PREMOTE_SRV premote;
    PREMOTE_SRV pback;

    DNS_DEBUG( REMOTE, (
        "Remote_UpdateResponseTime( %s )\n"
        "\tresp time = %d\n"
        "\ttimeout   = %d\n",
        IP_STRING(IpAddress),
        ResponseTime,
        Timeout ));

    //
    //  find remote entry
    //

    LOCK_REMOTE();

    premote = Remote_FindOrCreate(
                    IpAddress,
                    TRUE,       //  create
                    TRUE );     //  already locked
    IF_NOMEM( !premote )
    {
        goto Done;
    }

    //
    //  reset response time or timeout
    //
    //  Best scoring:
    //      - keep fastest to give "idea" of best we can expect for working
    //      back in
    //
    //      then as time goes by "score" of timeouts drops, until brought
    //      back down below score of non-timeout but higher servers,
    //      however drop must depend not just on time but on low score
    //      so that quickly retry if very big spread (ms vs. secs) but
    //      don't retry on small spread
    //
    //  Never record a BestResponse of zero - if zero set it to one instead
    //  so we can easily distinguish a fast server from an untried server.
    //

    premote->LastAccess = DNS_TIME();

    if ( Timeout )
    {
        ASSERT( ResponseTime == 0 );

        premote->TimeoutCount++;
        premote->BestResponse = NO_RESPONSE_PRIORITY;
    }
    else
    {
        if ( !ResponseTime )
        {
            ResponseTime = 1;
        }
        premote->ResponseCount++;
        if ( !premote->BestResponse || ResponseTime < premote->BestResponse )
        {
            premote->BestResponse = ResponseTime;
        }
    }

    premote->AverageResponse =
        ( ResponseTime + premote->AverageResponse ) / 2;

Done:

    UNLOCK_REMOTE();
}



UCHAR 
Remote_QuerySupportedEDnsVersion(
    IN      IP_ADDRESS      IpAddress
    )
/*++

Routine Description:

    Queries the remote server list for EDNS version supported by
    a particular server.

Arguments:

    IpAddress -- IP to find

Return Value:

    UNKNOWN_EDNS_VERSION if we do not know what version of EDNS is
        supported by the remote, or
    NO_EDNS_SUPPORT if the remote does not support any version of EDNS, or
    the EDNS version supported (0, 1, 2, etc.)

--*/
{
    PREMOTE_SRV     premote;
    UCHAR           ednsVersion = UNKNOWN_EDNS_VERSION;

    //
    //  find remote entry
    //

    LOCK_REMOTE();

    premote = Remote_FindOrCreate(
        IpAddress,
        TRUE,       // create
        TRUE );     // already locked
    IF_NOMEM( !premote )
    {
        goto Done;
    }

    //
    //  Figure out what we know about this remote's EDNS support. If the info
    //  has not been set or has expired, return UNKNOWN_EDNS_VERSION.
    //

    if ( premote->LastTimeEDnsVersionSet == 0 ||
         DNS_TIME() - premote->LastTimeEDnsVersionSet > SrvCfg_dwEDnsCacheTimeout )
    {
        ednsVersion = UNKNOWN_EDNS_VERSION;
    } // if
    else
    {
        ednsVersion = premote->EDnsVersion;
    } // else

Done:

    UNLOCK_REMOTE();

    DNS_DEBUG( EDNS, (
        "Remote_QuerySupportedEDnsVersion( %s ) = %d\n",
        IP_STRING( IpAddress ),
        ( int ) ednsVersion ));

    return ednsVersion;
} // Remote_QuerySupportedEDnsVersion



VOID
Remote_SetSupportedEDnsVersion(
    IN      IP_ADDRESS      IpAddress,
    IN      UCHAR           EDnsVersion
    )
/*++

Routine Description:

    Sets the EDNS version supported by a particular remote server.

Arguments:

    IpAddress -- IP of remote server
    EDnsVersion -- EDNS version supported by this remote

Return Value:

    None.

--*/
{
    PREMOTE_SRV     premote;

    DNS_DEBUG( EDNS, (
        "Remote_SetSupportedEDnsVersion( %s, %d )\n",
        IP_STRING( IpAddress ),
        ( int ) EDnsVersion ));

    //  sanity check the version value
    ASSERT( IS_VALID_EDNS_VERSION( EDnsVersion ) ||
            EDnsVersion == NO_EDNS_SUPPORT );

    //
    //  find remote entry
    //

    LOCK_REMOTE();

    premote = Remote_FindOrCreate(
        IpAddress,
        TRUE,       // create
        TRUE );     // already locked
    IF_NOMEM( !premote )
    {
        goto Done;
    }

    //
    //  Set the remote's supported EDNS version and update the timestamp.
    //

    premote->EDnsVersion = EDnsVersion;
    premote->LastTimeEDnsVersionSet = DNS_TIME();

Done:

    UNLOCK_REMOTE();

    return;
} // Remote_SetSupportedEDnsVersion



VOID
Remote_ListInitialize(
    VOID
    )
/*++

Routine Description:

    Initialize remote list.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    //  Initialize lock
    //
    //  DEVNOTE: Minor leak: should skip CS reinit on restart
    //

    InitializeCriticalSection( &csRemoteLock );

    //
    //  Zero hash
    //

    RtlZeroMemory(
        RemoteHash,
        sizeof(RemoteHash) );
}



VOID
Remote_ListCleanup(
    VOID
    )
/*++

Routine Description:

    Initialize remote list.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //  cleanup remote list lock

    DeleteCriticalSection( &csRemoteLock );
}



//
//  Applied remote list routines
//
//  Building recursion visit lists
//

DWORD
rankIpRelativeToIpAddressArray(
    IN OUT  IP_ADDRESS      IpArray[],
    IN      DWORD           dwCount,
    IN      IP_ADDRESS      RemoteIp
    )
/*++

Routine Description:

    Ranks remote IP relative to best match IP in IP array.

Arguments:

    IpArray -- IP array to match against

    dwCount -- count in IP array

    RemoteIp -- IP to rank

Return Value:

    Rank of IP relative to array on 0-4 scale:
        Zero -- IP has nothing to do with array.
        ...
        Four -- IP matches through last octet an is likely quite "cheap" to access.

--*/
{
    IP_ADDRESS  ip;
    DWORD       remoteNetMask;
    DWORD       mismatch;
    DWORD       i;
    DWORD       rank;
    DWORD       bestRank = 0;


    DNS_DEBUG( RECURSE, (
        "Rank IP %p relative to %d count IP array at %p\n",
        RemoteIp,
        dwCount,
        IpArray ));

    //
    //  determine remote IP mask
    //

    remoteNetMask = Dns_GetNetworkMask( RemoteIp );

    for ( i=0; i<dwCount; i++ )
    {
        ip = IpArray[i];

        mismatch = ( ip ^ RemoteIp );

        //
        //  determine octect of mismatch
        //      - if match through last octect, just return (we're done)
        //      - if match no octects, useless IP, continue
        //

        if ( (mismatch & 0xff000000) == mismatch )
        {
            bestRank = 4;
            break;
        }
        else if ( (mismatch & 0xffff0000) == mismatch )
        {
            rank = 2;
        }
        else if ( (mismatch & 0xffffff00) == mismatch )
        {
            rank = 1;
        }
        else    // nothing matching at all, this IP worthless
        {
            continue;
        }

        //
        //  give additional bonus for being within IP network
        //
        //  when match through 2 octets or 3 octets whether you
        //  are class A, B or C makes a difference;  although
        //  may have multiple nets in a organization (ex. MS and 157.5x)
        //  generally being inside a network tells you something --
        //  outside may tell you nothing
        //

        if ( (mismatch & remoteNetMask) == 0 )
        {
            rank += 1;
        }

        if ( rank > bestRank )
        {
            bestRank = rank;
        }
    }

    DNS_DEBUG( RECURSE, (
        "Remote IP %s -- best rank = %d\n",
        IP_STRING(RemoteIp),
        bestRank ));

    return( bestRank );
}



VOID
Remote_NsListCreate(
    IN OUT  PDNS_MSGINFO    pQuery
    )
/*++

Routine Description:

    Setup NS list buffer.
    Note:  does not initialize.

    DEVNOTE-DCR: 455669 - could improve NS list implementation

Arguments:

    pQuery -- ptr to original query

Return Value:

    None.

--*/
{
    ASSERT( pQuery->pNsList == NULL );

    if ( !pQuery->pNsList )
    {
        pQuery->pNsList = Packet_AllocateUdpMessage();
        STAT_INC( PacketStats.UdpPacketsForNsListUsed );
    }
}



VOID
Remote_NsListCleanup(
    IN OUT  PDNS_MSGINFO    pQuery
    )
/*++

Routine Description:

    Cleanup NS list buffer.

Arguments:

    pQuery -- ptr to original query

Return Value:

    None.

--*/
{
    register PDNS_MSGINFO   pmsg = (PDNS_MSGINFO) pQuery->pNsList;

    //  see note above
    //  if switch to using memory in pRecurseMsg, then this routine
    //      can become no-op

    if ( pmsg )
    {
        //  for debug need to mark these, so none of the checks on
        //  returning messages or in free list messages are performed

        pmsg->fNsList = TRUE;
#if DBG
        pmsg->pRecurseMsg = NULL;
        pmsg->pConnection = NULL;
        pmsg->dwQueuingTime = 0;
#endif

        //  while used as remote, message is clear

        SET_PACKET_ACTIVE_UDP( pmsg );
        Packet_FreeUdpMessage( pmsg );
        pQuery->pNsList = NULL;
        STAT_INC( PacketStats.UdpPacketsForNsListReturned );
    }
}



VOID
Remote_InitNsList(
    IN OUT  PNS_VISIT_LIST  pNsList
    )
/*++

Routine Description:

    Initialize NS list.

Arguments:

    pNsList -- NS list to prioritize

Return Value:

    None.

--*/
{
    ASSERT( pNsList );

    //  clear header portion of NS list

    RtlZeroMemory(
        pNsList,
        (PBYTE)pNsList->NsList - (PBYTE)pNsList );
}



VOID
Remote_SetNsListPriorities(
    IN OUT  PNS_VISIT_LIST  pNsList
    )
/*++

Routine Description:

    Set priorities for IP in NS list.

    DEVNOTE-DCR: 455669 - improve remote NS list implementation

Arguments:

    pNsList -- NS list to prioritize

Return Value:

    Ptr to remote struct.

--*/
{
    PREMOTE_SRV premote;
    DWORD       i;

    DNS_DEBUG( REMOTE, (
        "Remote_SetNsListPriorities( %p )\n",
        pNsList ));

    LOCK_REMOTE();

    //
    //  for each IP in NS list, get remote priority
    //
    //  currently base priority solely on fastest response
    //  -- closest best box
    //

    for ( i=0; i<pNsList->Count; i++ )
    {
        IP_ADDRESS  ip = pNsList->NsList[i].IpAddress;
        DWORD       priority = NEW_IP_PRIORITY;
        BOOL        fneverVisited = TRUE;

        if ( ip == IP_MISSING_GLUE )
        {
            continue;
        }

        premote = Remote_FindOrCreate(
                    ip,
                    FALSE,      //  do not create
                    TRUE );     //  remote list locked
        if ( premote )
        {
            //
            //  If this remote's BestResponse is currently zero, then
            //  we have never tried it. Set it's BestResponse to 
            //  NEW_IP_PRIORITY - this initially qualifies the server
            //  as "fast".
            //

            if ( premote->BestResponse == 0 )
            {
                premote->BestResponse = NEW_IP_PRIORITY;
            }
            else
            {
                fneverVisited = FALSE;
            }

            priority = premote->BestResponse;
        }

        //  if unvisited IP, adjust priority based on match with
        //  DNS server IPs, so that we try the closest NS first

        if ( fneverVisited && g_BoundAddrs )
        {
            DWORD delta = rankIpRelativeToIpAddressArray(
                                g_BoundAddrs->AddrArray,
                                g_BoundAddrs->AddrCount,
                                ip );

            priority = ( delta >= priority ) ?
                            1 :
                            priority - delta;
        }

        DNS_DEBUG( REMOTE, (
            "Remote_SetNsListPriorities() ip=%s best=%d newpri=%d\n",
            IP_STRING( ip ),
            premote ? premote->BestResponse : 999999,       //  silly...
            priority));

        pNsList->NsList[i].Data.Priority = priority;
    }

    UNLOCK_REMOTE();
}



DNS_STATUS
Remote_BuildNsListForNode(
    IN      PDB_NODE        pNode,
    OUT     PNS_VISIT_LIST  pNsList,
    IN      DWORD           dwQueryTime
    )
/*++

Routine Description:

    Get NS list for a node, building one if necessary.

Arguments:

    pNode   -- node containing NS records

    pNsList -- ptr to NS list struct to fill in

    dwQueryTime -- query time to use when deciding if resource records
        found in the cache should be deleted, or use zero to if timeout
        checking on resource records is not required

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_NO_DATA if no NS found for node.

--*/
{
    PDB_RECORD      prrNS = NULL;
    PDB_RECORD      prrA;
    PDB_NODE        pnodeNS;
    PDB_NODE        pnodeDelegation;
    IP_ADDRESS      ipNs;
    BOOL            foundIp;
    DNS_STATUS      status = ERROR_SUCCESS;
    PNS_VISIT       pvisit;
    PNS_VISIT       pvisitEnd;
    DWORD           size;

    //
    //  list should be locked by caller
    //

    ASSERT_LOCK_NODE( pNode );

    SET_NODE_ACCESSED(pNode);

    DNS_DEBUG( RECURSE2, (
        "buildNsListForNode( %p ) (l=%s)\n"
        "\tat %p\n",
        pNode,
        pNode->szLabel,
        pNsList ));

#if DBG
    //  if debug, clear header so we can do use list debug prints
    //  without blowing up

    Remote_InitNsList( pNsList );
#endif

    //
    //  build NS list
    //      - read all NS records
    //      - at each NS read all A records, each becoming entry in NS list
    //      - missing glue NS hosts get special missing glue IP
    //      - use pvisit ptr to step through NS list
    //      - save end ptr to check stop
    //

    pvisit = pNsList->NsList;
    pvisitEnd = pvisit + MAX_NS_LIST_COUNT;

    while( 1 )
    {
        prrNS = RR_FindNextRecord(
                    pNode,
                    DNS_TYPE_NS,
                    prrNS,
                    dwQueryTime );

        if ( !prrNS )
        {
            IF_DEBUG( RECURSE )
            {
                Dbg_NodeName(
                    "No more name servers for domain ",
                    pNode,
                    "\n" );
            }
            break;
        }

        //
        //  only root-hints available?
        //      - if already read cache data -- done
        //      if using root-hints flag
        //
        //  DEVNOTE: add root-hints to list?  exclude?
        //      - if add root hints need to check that not duplicate nodes
        //      - need to rank test on IPs below also
        //

        if ( !pNode->pParent  &&
            pvisit == pNsList->NsList &&
            IS_ROOT_HINT_RR( prrNS ) )
        {
            DNS_DEBUG( RECURSE, (
                "Recursed to root and using root hints -- set for root-hint query.\n" ));
            status = DNSSRV_ERROR_ONLY_ROOT_HINTS;
        }

        //
        //  get NS node
        //
        //  currently force creation of node to handle the missing
        //  glue case;  note, that this will NOT force creation of
        //  NS record in authoritative zone;  but this is ok, because
        //  we don't WANT to chase glue there -- except it possibly
        //  could have been useful in WINS zone ...
        //
        //  note:  don't have good way to index, and don't save names in
        //      IP list, so forced to create node
        //
        //  DEVNOTE: do not force create of NS-host
        //      - ideally do NOT force NS-host create (just set flag)
        //      - then if NO contact go back for missing GLUE pass and force create
        //
        //  if lookup at delegation, will also accept OUTSIDE zone records in the
        //  zone containing the delegation
        //

        pnodeNS = Lookup_NsHostNode(
                    & prrNS->Data.NS.nameTarget,
                    LOOKUP_CACHE_CREATE,
                    pNode->pZone,           // zone of delegation (if delegation)
                    & pnodeDelegation );
        if ( !pnodeNS )
        {
            continue;
        }
        IF_DEBUG( RECURSE )
        {
            Dbg_NodeName(
                "Found a NS for domain ",
                pNode,
                " => " );
            Dbg_NodeName(
                NULL,
                pnodeNS,
                "\n" );
        }

        //
        //  find IP addresses for current NS host
        //
        //  need to hold lock on node while get IP from A record
        //  otherwise we'd have to protect A record with timeout free
        //
        //  Note: global-lock, so no need to node lock
        //
        //  DEVNOTE: Rank test IPs \ otherwise get duplicate IP
        //      - if add root hints need to check that not duplicate nodes
        //      - need to rank test on IPs below also
        //   need to either remove root hints from list OR
        //   stop on new rank OR
        //   check previous IPs for same node on new rank
        //      to avoid duplicate IP
        //

        prrA = NULL;
        ipNs = 0;
        foundIp = FALSE;

        while ( 1 )
        {
            prrA = RR_FindNextRecord(
                        pnodeNS,
                        DNS_TYPE_A,
                        prrA,
                        0 );
            if ( prrA )
            {
                ipNs = prrA->Data.A.ipAddress;
                if ( ipNs != 0 && ipNs != INADDR_BROADCAST )
                {
                    pvisit->pNsNode         = pnodeNS;
                    pvisit->IpAddress       = ipNs;
                    pvisit->Data.Priority   = 0;
                    pvisit->Data.SendTime   = 0;
                    pvisit++;
                    foundIp = TRUE;

                    if ( pvisit >= pvisitEnd )
                    {
                        goto EntryEnd;
                    }
                    continue;
                }
                else
                {
                    DNS_PRINT((
                        "Bad cached IP address (%p) at node %s\n",
                        ipNs,
                        pnodeNS->szLabel ));
                    foundIp = FALSE;
                    continue;
                }
            }

            //
            //  no more addresses for host
            //      - if found at least one, then done
            //      - if none, then write "missing-glue" entry for NS host,
            //      but only if outside zone;  NS pointing inside a zone
            //      with empty A-list is useless
            //

            if ( foundIp )
            {
                DNS_DEBUG( RECURSE, ( "\tOut of A records for NS.\n" ));
                break;
            }

            if ( IS_AUTH_NODE(pnodeNS) )
            {
                DNS_DEBUG( ANY, (
                    "WARNING:  NO A records for NS %p with label %s inside ZONE!\n"
                    "\tSince inside ZONE missing glue lookup is useless!\n",
                    pnodeNS,
                    pnodeNS->szLabel ));

                //  DEVNOTE-LOG: log event here if first time through
                //      could have bit on node, that essentially says
                //      "logged something about this node, don't do it again"

                break;
            }

            DNS_DEBUG( RECURSE, (
                "WARNING:  NO A records for NS %p with label %s!\n",
                pnodeNS,
                pnodeNS->szLabel ));

            pvisit->pNsNode     = pnodeNS;
            pvisit->IpAddress   = IP_MISSING_GLUE;
            pvisit->Data.pnodeMissingGlueDelegation = pnodeDelegation;
            pvisit++;
            if ( pvisit >= pvisitEnd )
            {
                goto EntryEnd;
            }
            break;

        }   //  Loop through addresses for name server

    }   //  Loop through name servers for this node


EntryEnd:

    //  determine count

    pNsList->Count = ( DWORD )( pvisit - pNsList->NsList );

    if ( pNsList->Count == 0 )
    {
        DNS_DEBUG( RECURSE, ( "No NS records at %s.\n", pNode->szLabel ));
        ASSERT( prrNS == NULL );

        return ERROR_NO_DATA;
    }

    //
    //  set priorities IP in NS list
    //

    Remote_SetNsListPriorities( pNsList );

    IF_DEBUG( REMOTE )
    {
        Dbg_NsList(
            "NsList leaving BuildNsListForNode()",
            pNsList );
    }
    ASSERT( status == ERROR_SUCCESS ||
            status == DNSSRV_ERROR_ONLY_ROOT_HINTS );

    return( status );
}



DNS_STATUS
Remote_BuildVisitListForNewZone(
    IN      PDB_NODE        pZoneRoot,
    IN OUT  PDNS_MSGINFO    pQuery
    )
/*++

Routine Description:

    Build visit list for zone root.

    IA64: ivisit must either be signed or the length of the machine word because
    it can be zero when we execute "&pvisitList->NsList[ivisit-1]". If ivisit is
    unsigned or smaller than the machine word (it was originally a DWORD), there
    will be sign extension problems.

Arguments:

    pZoneRoot -- zone root node containing NS records

    pQuery  -- query being recursed

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    int             ivisit;     // IA64 quirk, see above
    DWORD           lastVisitCount;
    PNS_VISIT       pvisit;
    PNS_VISIT_LIST  pvisitList;
    NS_VISIT_LIST   nslist;
    ULONG           random;

    enum
    {
        DNS_WANT_BEST_PRIORITY,
        DNS_WANT_ANY_FAST_SERVER,
        DNS_WANT_SLOW_SERVER
    }               wantServer;


#if 0
    //  note:  Eyal changed to directly lock node;  not yet sure why
    //
    //  list should be locked by caller
    //

    ASSERT_LOCK_NODE( pZoneRoot );
#endif

    DUMMY_LOCK_RR_LIST(pZoneRoot);

    SET_NODE_ACCESSED(pZoneRoot);

    DNS_DEBUG( REMOTE, (
        "Remote_BuildVisitListForNewZone( %p ) (l=%s)\n"
        "\tquery at %p\n",
        pZoneRoot,
        pZoneRoot->szLabel,
        pQuery ));

    pvisitList = pQuery->pNsList;

    //
    //  check if already got response from this zone?
    //
    //  this can happen when get referral to child zone, which either
    //      - does not respond (or bad response)
    //      - is bad delegation and does not agree it's authoritative
    //  this can send us back up to higher zone which we've already contacted
    //
    //  the idea here is to allow recurse up the tree (from zone) to allow
    //  for case of stale timed out data, but not to start looping because
    //  of misconfigured delegations
    //

    if ( pZoneRoot == pvisitList->pZoneRootResponded )
    {
        DNS_DEBUG( REMOTE, (
            "Refuse to build NS list for previously responding zone!\n"
            "\tpQuery       = %p\n"
            "\tpZoneRoot    = %p\n",
            pQuery,
            pZoneRoot ));

        return DNSSRV_ERROR_ZONE_ALREADY_RESPONDED;
    }

    //
    //  if already built NS list at this zone -- no action
    //

    if ( pZoneRoot == pvisitList->pZoneRootCurrent )
    {
        DNS_DEBUG( REMOTE, (
            "Zone root %p same as current, no NS list rebuild for query %p.\n"
            "\tpQuery = %p\n",
            pQuery,
            pZoneRoot ));

        return ERROR_SUCCESS;
    }

    //
    //   Lock the node we're working on.
    //      - all exit paths through jump to Done to unlock
    //

    LOCK_NODE( pZoneRoot );

    //
    //  build list of NS for node
    //

    status = Remote_BuildNsListForNode(
                pZoneRoot,
                & nslist,
                pQuery->dwQueryTime );

    if ( status != ERROR_SUCCESS &&
         status != DNSSRV_ERROR_ONLY_ROOT_HINTS )
    {
        goto Done;
    }
    ASSERT( nslist.Count != 0 );

#if 0
    //
    //  copy missing glue -- if any
    //

    RtlCopyMemory(
        & pvisitList->CountMissingGlue,
        & nslist.CountMissingGlue,
        SIZEOF_MISSING_GLUE_ARRAY_COPY );

#endif

    //
    //  copy "best" NS IPs to query's visit list
    //
    //      - clear any previously unvisited IPs
    //

#if 0
    //  not sure it is necessary to walk list
    //  should be able to start at last visited index

    for ( i=0; i<pvisitList->Count; i++ )
    {
        pvisit = pvisitList->NsList[i];

        if ( pvisit->IpAddress == IP_ZONE_ROOT_NODE )
        {
            continue;
        }
        if ( pvisit->SendCount > 0 )
        {
            continue;
        }
        break;
    }
#endif

    //
    //  walk backwards from last visit
    //  whack off any missing glue IPs or completely empty zone root nodes
    //      -- unnecessary to keep them around

    ivisit = pvisitList->VisitCount;
    pvisit = &pvisitList->NsList[ivisit-1];

    while ( ivisit )
    {
        if ( pvisit->IpAddress == IP_MISSING_GLUE ||
             pvisit->IpAddress == IP_ZONE_ROOT_NODE )
        {
            ivisit--;
            pvisit--;
            continue;
        }
        ASSERT( pvisit->SendCount > 0 );
        break;
    }

    DNS_DEBUG( REMOTE2, (
        "starting visit list build at visit count = %d\n",
        ivisit ));

    //  write zone root node entry

    lastVisitCount = ivisit;
    pvisitList->ZoneIndex = ivisit;
    pvisitList->VisitCount = ++ivisit;
    pvisitList->pZoneRootCurrent = pZoneRoot;

    pvisit++;
    pvisit->pNsNode         = pZoneRoot;
    pvisit->IpAddress       = IP_ZONE_ROOT_NODE;
    pvisit->Data.Priority   = NS_LIST_ZONE_ROOT_PRIORITY;
    pvisit->Data.SendTime   = 0;
    pvisit->SendCount       = NS_LIST_ZONE_ROOT_SEND_COUNT;
    pvisit++;

    //
    //  Fill visit list with best priority IPs available at this zone
    //  root. It's important to do some load balancing here so we don't
    //  always hit the same NS when multiple remote authoritative NS are
    //  available. Before starting iterate-and-copy, randomly decide
    //  what kind of server we want to stick in the first slot. Very
    //  infrequently stick a randomly selected timed out server in the
    //  first slot, in case it is now reachable.
    //
    //  DEVNOTE: Currently sending to slow server 1 time in 10000. It
    //  might be better to do an actual time-based measurement and send
    //  to a timed-out server once per hour instead. It could even be
    //  a global (across zones). The problem with 1:10000 is that on a
    //  busy server it might be too often and on a quiet server it might
    //  not be often enough.
    //

    ++g_RandomSeed;
    random = RtlRandom( &g_RandomSeed );
    wantServer =
        ( random > ULONG_MAX / 10000 ) ?
            DNS_WANT_ANY_FAST_SERVER :
            DNS_WANT_SLOW_SERVER;

    while( ivisit < MAX_PACKET_NS_LIST_COUNT )
    {
        PNS_VISIT   pavailNs = nslist.NsList;
        PNS_VISIT   pnextDesiredNs = NULL;
        DWORD       bestPriority = MAXDWORD;
        DWORD       availCount = nslist.Count;
        DWORD       sendCount;
        DWORD       i;
        IP_ADDRESS  ip;

        //
        //  Note: server arrays are CHARs to save stack space. Since
        //  the values will be indexes, as long as MAX_NS_LIST_COUNT
        //  is less than 255 this is okay. 
        //

        INT         slowServers = 0;
        INT         fastServers = 0;
        UCHAR       slowServerArray[ MAX_NS_LIST_COUNT ];
        UCHAR       fastServerArray[ MAX_NS_LIST_COUNT ];

        if ( availCount == 0 )
        {
            break;
        }

        //
        //  Scan through the list, dropping indexes of remaining NS into 
        //  slow/fast arrays.
        //  find best IP -- special case missing glue, it's priority field
        //      is no longer accurate

        i = 0;
        while ( availCount-- )
        {
            register    DWORD   priority;

            //
            //  Keep track of the best priority server.
            //

            if ( pavailNs->IpAddress == IP_MISSING_GLUE )
            {
                priority = MISSING_GLUE_PRIORITY;
            }
            else
            {
                priority = pavailNs->Data.Priority;
            }

            if ( priority < bestPriority )
            {
                bestPriority = priority;
                pnextDesiredNs = pavailNs;
            }

            //
            //  Optionally categorize this server as slow/fast. Servers
            //  that are missing glue or are otherwise not easily sendable
            //  are ignored.
            //

            if ( wantServer != DNS_WANT_BEST_PRIORITY &&
                pavailNs->IpAddress != IP_MISSING_GLUE &&
                pavailNs->IpAddress != IP_ZONE_ROOT_NODE )
            {
                if ( pavailNs->Data.Priority > MAX_FAST_SERVER_PRIORITY )
                {
                    slowServerArray[ slowServers++ ] = ( UCHAR ) i;
                }
                else
                {
                    fastServerArray[ fastServers++ ] = ( UCHAR ) i;
                }
            }
            ++i;
            pavailNs++;
        }

        //
        //  pnextDesiredNs is now pointing to the NS with best priority
        //  but will override this selection if indicated by wantServer
        //  However, if we did not find any valid slow or fast 
        //  servers then we will have to stick with the current
        //  value of pnextDesiredNs. The scenario where this may happen
        //  is when all NS are MISSING_GLUE.
        //

        if ( wantServer != DNS_WANT_BEST_PRIORITY &&
            ( slowServers || fastServers ) )
        {
            //
            //  There is no guarantee that we have servers of the desired
            //  type. Example: we want a slow server but all servers are
            //  fast. In this case, switch wantServer to match the available
            //  servers.
            //

            if ( !slowServers && wantServer == DNS_WANT_SLOW_SERVER )
            {
                wantServer = DNS_WANT_ANY_FAST_SERVER;
            }
            else if ( !fastServers && wantServer != DNS_WANT_SLOW_SERVER )
            {
                wantServer = DNS_WANT_SLOW_SERVER;
            }

            //
            //  Randomly select next lucky winner.
            //

            ASSERT(
                wantServer == DNS_WANT_SLOW_SERVER && slowServers ||
                wantServer != DNS_WANT_SLOW_SERVER && fastServers );

            pnextDesiredNs =
                &nslist.NsList[
                    wantServer == DNS_WANT_SLOW_SERVER && slowServers ?
                        slowServerArray[ random % slowServers ] :
                        fastServerArray[ random % fastServers ] ];

            //
            //  For all server positions except the first position,
            //  we will take the best priority. This gives us a certain
            //  amount of load balancing while keeping server selection
            //  for the remaining servers in the list fast and simple.
            //

            wantServer = DNS_WANT_BEST_PRIORITY;
        }

        ASSERT( pnextDesiredNs );

        //
        //  check if this IP already visited
        //      (this will frequently happen when server auth for child and
        //      parent zones -- ex. microsoft.com and dns.microsoft.com)
        //
        //  note:  we also use this in the way we handle missing glue
        //      which is currently to rebuild whole NS list which
        //      inherently means we must pick up previous send IPs
        //

        ip = pnextDesiredNs->IpAddress;
        sendCount = 0;

        for( i = 1; i < lastVisitCount; ++i )
        {
            if ( ip == pvisitList->NsList[ i ].IpAddress )
            {
                sendCount = pvisitList->NsList[ i ].SendCount;
                ASSERT( ip != IP_MISSING_GLUE );
                ASSERT( ip != IP_ZONE_ROOT_NODE );
                break;
            }
        }

        //
        //  skip useless IPs
        //      - responded or reached retry limit

        if ( sendCount &&
            ( sendCount >= RECURSE_IP_SEND_MAX ||
            pvisitList->NsList[i].Response ) )
        {
            DNS_DEBUG( REMOTE, (
                "IP %s responded or maxed out on previous pass for query %p.\n"
                "\tdo not include in this zone's pass.\n",
                IP_STRING( ip ),
                pQuery ));
        }

        //
        //  copy best avail NS to query's NS list
        //
        //  note:  could mem-clear entire NS list, then no need to
        //      zero count fields as will never be set even on
        //      unvisited NS that we may be overwriting
        //
        //  DEVNOTE: It is imperative to keep Priority and SendTime
        //      in sync since in IA64 these two fields combine to hold
        //      the delegation node pointer - see the macro
        //      MISSING_GLUE_DELEGATION in recurse.h

        else
        {
            pvisit->pNsNode     = pnextDesiredNs->pNsNode;
            pvisit->IpAddress   = ip;
            pvisit->Data        = pnextDesiredNs->Data;
            pvisit->SendCount   = (UCHAR) sendCount;
            pvisit->Response    = 0;
            pvisit++;
            ivisit++;
        }

        //  whack best NS in avail list, so not tested again on later pass
        //      simply overwrite with last entry and shrink avail list count

        nslist.Count--;
        pavailNs = &nslist.NsList[ nslist.Count ];

        pnextDesiredNs->pNsNode       = pavailNs->pNsNode;
        pnextDesiredNs->IpAddress     = pavailNs->IpAddress;
        pnextDesiredNs->Data          = pavailNs->Data;
    }

    //
    //  reset query's NS list count
    //

    pvisitList->Count = ivisit;

    DNS_DEBUG( REMOTE, (
        "Leaving Remote_BuildVisitListForNewZone()\n"
        "\tquery = %p, NS count = %d\n",
        pQuery,
        ivisit ));
    IF_DEBUG( REMOTE )
    {
        Dbg_NsList(
            "Visit list after rebuild",
            pvisitList );
    }

Done:

    UNLOCK_NODE ( pZoneRoot );
    return( status );
}



VOID
recordVisitIp(
    IN OUT  PNS_VISIT       pVisit,
    IN OUT  PIP_ARRAY       IpArray
    )
/*++

Routine Description:

    Record IP as visited:
        - set fields in it's NS_VISIT struct
        - save IP to array

Arguments:

    pVisit -- ptr to visit NS IP struct

    IpArray -- IP array to hold IPs to send to;  must contain space for
        at least RECURSE_PASS_MAX_SEND_COUNT elements

Return Value:

    None.

--*/
{
    ASSERT( pVisit->IpAddress != IP_ZONE_ROOT_NODE );
    ASSERT( pVisit->IpAddress != IP_MISSING_GLUE );

    pVisit->SendCount++;

    IpArray->AddrArray[ IpArray->AddrCount++ ] = pVisit->IpAddress;
}




DNS_STATUS
Remote_ChooseSendIp(
    IN OUT  PDNS_MSGINFO    pQuery,
    OUT     PIP_ARRAY       IpArray
    )
/*++

Routine Description:

    Determine IPs in visit list to make next send to.

Arguments:

    pQuery - ptr to query message

    IpArray - IP array to hold IPs to send to;  must contain space for
        at least RECURSE_PASS_MAX_SEND_COUNT elements

Return Value:

    ERROR_SUCCESS if successful.
    DNSSRV_ERROR_OUT_OF_IP if no IP to go to on this zone.
    DNSSRV_ERROR_MISSING_GLUE if
        - query suspended to chase glue OR if query was cache update query
        and we've now reverted to original;  in either case caller does not
        send and does not touch pQuery any more

--*/
{
    PNS_VISIT_LIST  pvisitList = ( PNS_VISIT_LIST ) pQuery->pNsList;
    PNS_VISIT       pvisitNext;
    PNS_VISIT       pvisitResend;
    PNS_VISIT       pvisitRetryLast;
    PNS_VISIT       pvisitEnd;
    PNS_VISIT       pvisitZone;
    PDB_NODE        pnodeMissingGlue;
    DWORD           sendCount;
    DWORD           sendTime;
    int             visitCount;     // IA64: must be signed!
    DWORD           priorityNext;


    DNS_DEBUG( REMOTE, (
        "Remote_ChooseSendIp( q=%p, iparray=%p )\n",
        pQuery,
        IpArray ));

    IF_DEBUG( REMOTE2 )
    {
        Dbg_NsList(
            "NS list entering choose IP",
            pvisitList );
    }
    ASSERT( pvisitList->Count > 0 );
    ASSERT( pvisitList->VisitCount > 0 );
    ASSERT( pvisitList->pZoneRootCurrent );

    //
    //  setup
    //      - clear IP array
    //      - find zone entry in list
    //      - find last visited entry in list
    //

    IpArray->AddrCount = 0;

    pvisitZone = &pvisitList->NsList[ pvisitList->ZoneIndex ];
    pvisitEnd  = &pvisitList->NsList[ pvisitList->Count ];

    visitCount = pvisitList->VisitCount;

    pvisitRetryLast = pvisitNext = &pvisitList->NsList[ visitCount - 1 ];

    //
    //  determine send count
    //      - based on number of passes through this zone's NS
    //      currently
    //          - 1,2 passes => 1 send
    //          - 3,4 passes => 2 sends
    //          - otherwise 3 sends
    //      - can not be greater than total IPs available in zone
    //

    sendCount = pvisitZone->SendCount;

    if ( sendCount < 2 )
    {
        sendCount = 1;
    }
    else if ( sendCount < 4 )
    {
        sendCount = 2;
    }
    else
    {
        sendCount = 3;
    }

#if 0
    //  code below effectively limits send count, as break
    //      out when push through end limit of list
    if ( sendCount > ZONE_VISIT_NS_COUNT(pvisitZone) )
    {
        sendCount = ZONE_VISIT_NS_COUNT(pvisitZone);
    }
#endif

    //
    //  save query time -- in milliseconds
    //
    //  DEVNOTE: query time
    //
    //  currently reading query time (in ms) in recursion function so
    //  we can associate time directly with IPs we send to;
    //  however, that has problem in that we are reading time outside
    //  of recursion queue lock -- which may force us to wait
    //  potentially lots of ms for service (depends on recursion
    //  thread cleanup activity)

    sendTime = GetCurrentTimeInMilliSeconds();

    //
    //  loop until found desired number of send IPs
    //
    //      - always send to new IP (if available)
    //      - for multiple sends
    //          -- another NEW IP
    //              OR
    //             previous IP if
    //                  - only sent once and
    //                  - "good" IP and
    //                  - better than next new IP
    //
    //

    while ( sendCount )
    {
        pvisitNext++;
        priorityNext = NO_RESPONSE_PRIORITY;

        if ( pvisitNext < pvisitEnd )
        {
            ASSERT( pvisitNext->IpAddress != IP_ZONE_ROOT_NODE );

            //
            //  skip previously visited (in another zone's pass)
            //  these IPs should not have been touched on this zone's pass
            //  but may have been sent to on previous zone's pass and
            //  not responded, in which case send count was picked up
            //
            //  if we skip an IP sent to from a previous zone's pass,
            //  then must include it in the retry processing;
            //  othwerwise, a zone that contains entirely IPs that were
            //  previously sent to, would never retry any of them

            if ( pvisitNext->SendCount )
            {
                ASSERT( pvisitList->ZoneIndex != ( DWORD ) -1 );
                visitCount++;
                ASSERT( visitCount == (int)(pvisitNext - &pvisitList->NsList[0] + 1));
                pvisitRetryLast = pvisitNext;
                continue;
            }

            //
            //  The NS list is pre-ordered, so send to the next IP unless it
            //  appears to be tremendously slow, in which case we may do 
            //  re-sends before coming back to the slow server. BUT - always
            //  use the first NS in the list, since this will have been set
            //  up for us by Remote_BuildVisitListForNewZone. Occasionally the
            //  first server will be a timed out server, which we should test
            //  to see if it has come back up.
            //  

            if ( IpArray->AddrCount == 0 ||
                pvisitNext->Data.Priority <= MAX_FAST_SERVER_PRIORITY )
            {
                if ( pvisitNext->IpAddress == IP_MISSING_GLUE )
                {
                    pnodeMissingGlue = pvisitNext->pNsNode;
                    if ( IS_NOEXIST_NODE( pnodeMissingGlue ) )
                    {
                        DNS_DEBUG( RECURSE, (
                            "Missing glue node %p already has cached name error.\n",
                            pnodeMissingGlue ));
                        visitCount++;
                        continue;
                    }
                    goto MissingGlue;
                }
                recordVisitIp( pvisitNext, IpArray );
                pvisitNext->Data.SendTime = sendTime;
                visitCount++;
                ASSERT( visitCount == (int)(pvisitNext - &pvisitList->NsList[0] + 1));
                sendCount--;
                continue;
            }

            //  if not "great" IP, and have already made one send to new IP
            //      then drop down to check for better resends
            //      require resend IP to be four times as good as this one
            //      otherwise, we'll do the send to this one after retry check

            else
            {
                priorityNext = pvisitNext->Data.Priority / 4;
                if ( priorityNext > NO_RESPONSE_PRIORITY )
                {
                    priorityNext = NO_RESPONSE_PRIORITY;
                }
            }
        }

        //
        //  resend to previous NS IPs ?
        //      - should have made at least one previous send to fall here
        //      unless
        //          - no IP entries for the zone (all the IPs were retried
        //          through MAX_RETRY in previous zones) OR
        //          - first zone IP was previously sent to OR
        //          - first (and hence all) entries are missing glue
        //
        //

        ASSERT( ( pvisitList->ZoneIndex+1 < pvisitList->VisitCount &&
                    pvisitZone->SendCount > 0 )
                || (pvisitZone+1) >= pvisitEnd
                || (pvisitZone+1)->SendCount != 0
                || (pvisitZone+1)->IpAddress == IP_MISSING_GLUE );

        pvisitResend = pvisitZone;

        //
        //  resend to IP if
        //      - hasn't responded (could SERVER_FAILURE or do sideways delegation)
        //      - hasn't maxed out sends
        //      - not missing glue
        //        (note: missing glue priority no longer accurate)
        //      - lower priority then possible next send
        //

        while ( ++pvisitResend <= pvisitRetryLast )
        {
            if ( pvisitResend->Response != 0 ||
                pvisitResend->SendCount > RECURSE_IP_SEND_MAX ||
                pvisitResend->IpAddress == IP_MISSING_GLUE )
            {
                continue;
            }
            if ( pvisitResend->Data.Priority < priorityNext )
            {
                recordVisitIp( pvisitResend, IpArray );
                sendCount--;
                if ( sendCount )
                {
                    continue;
                }
                break;
            }
        }

        //  found "better" resend IPs, for remaining sends => done
        //  drop visit count as we didn't actually use visit to last IP

        if ( pvisitResend <= pvisitRetryLast )
        {
            break;
        }

        //  if did NOT find a "better" resend candidate, then use next IP

        if ( priorityNext < NO_RESPONSE_PRIORITY )
        {
            ASSERT( pvisitNext < pvisitEnd );
            recordVisitIp( pvisitNext, IpArray );
            visitCount++;
            ASSERT( visitCount == (int)(pvisitNext - &pvisitList->NsList[0] + 1));
            sendCount--;
            continue;
        }

        //  not enough valid resends to fill send count

        DNS_DEBUG( REMOTE, ( "No more RESENDs and no next visit IP!\n" ));
        break;
    }

    pvisitList->VisitCount = visitCount;

    pvisitZone->SendCount++;

    //
    //  done
    //

    DNS_DEBUG( REMOTE, (
        "Leaving Remote_ChooseSendIp()\n"
        "\tdoing %d sends\n",
        IpArray->AddrCount
        ));
    IF_DEBUG( REMOTE2 )
    {
        Dbg_NsList(
            "NS list leaving Remote_ChooseSendIp()",
            pvisitList );
    }
    if ( IpArray->AddrCount > 0 )
    {
        //pQuery->dwMsQueryTime = sendTime;
        return( ERROR_SUCCESS );
    }
    else
    {
        return( DNSSRV_ERROR_OUT_OF_IP );
    }


MissingGlue:

    //
    //  have missing glue - chase it
    //      - but do NOT chase missing glue on missing glue query
    //      note, can still respond with the same error code, which
    //      basically means -- don't send AND don't touch this query
    //

    if ( IS_CACHE_UPDATE_QUERY(pQuery) )
    {
        DNS_DEBUG( REMOTE, (
            "Missing glue, on cache update query (%p)\n"
            "\tterminating cache update query.\n",
            pQuery ));
        Recurse_ResumeSuspendedQuery( pQuery );
        return( DNSSRV_ERROR_MISSING_GLUE );
    }

    pvisitNext->SendCount = 1;
    pnodeMissingGlue = pvisitNext->pNsNode;
    SET_NODE_ACCESSED( pnodeMissingGlue );

    pvisitList->pNodeMissingGlue = pnodeMissingGlue;
    pvisitList->VisitCount = visitCount;

    DNS_DEBUG( RECURSE, (
        "Found NS (%p %s) with missing glue.\n"
        "\tRecursing query %p at zone node %s\n",
        pnodeMissingGlue, pnodeMissingGlue->szLabel,
        pQuery,
        pvisitZone->pNsNode->szLabel
        ));

    if ( Recurse_SendCacheUpdateQuery(
            pnodeMissingGlue,
            pvisitNext->Data.pnodeMissingGlueDelegation,
            DNS_TYPE_A,
            pQuery ) )
    {
        return( DNSSRV_ERROR_MISSING_GLUE );
    }
    else
    {
        ASSERT( FALSE );
        return( DNSSRV_ERROR_OUT_OF_IP );
    }
}



VOID
Remote_ForceNsListRebuild(
    IN OUT  PDNS_MSGINFO    pQuery
    )
/*++

Routine Description:

    Force rebuild of NS IP list for query.

Arguments:

    pQuery - ptr to query message

Return Value:

    None

--*/
{
    DNS_DEBUG( REMOTE, (
        "Remote_ForceNsListRebuild( q=%p )\n",
        pQuery ));

    //
    //  DEVNOTE: single fix up of missing glue node
    //
    //      ideally we'd just rebuild A record for missing glue node here
    //      a couple issues
    //          1) need to separate out A record query routines
    //          2) can get multiple A records, yet only have ONE entry
    //          with bogus missing glue;  if more missing glue records follow
    //          must either just overwrite (not-unreasonable) or push down
    //
    //      alternatively, the better approach might be to do full rebuild
    //      but just do a better job with the already VISITED list, so don't
    //      waste as much space
    //

    ASSERT( (PNS_VISIT_LIST)pQuery->pNsList );

    ((PNS_VISIT_LIST)pQuery->pNsList)->pZoneRootCurrent = NULL;
}




PDB_NODE
Remote_FindZoneRootOfRespondingNs(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PDNS_MSGINFO    pResponse
    )
/*++

Routine Description:

    Find zone root node of responding name server.

    Updates remote IP info, and query's visited list.

Arguments:

    pQuery - ptr to query message

    pResponse - response message

Return Value:

    Ptr to node, if found.
    NULL if IP NOT in responding list.

--*/
{
    PNS_VISIT_LIST  pvisitList;
    PNS_VISIT       pvisit;
    PDB_NODE        pnodeZoneRoot = NULL;
    PDB_NODE        pnodeNs = NULL;
    IP_ADDRESS      responseIp;
    DWORD           j;
    DWORD           timeDelta = MAX_FAST_SERVER_PRIORITY * 3;   // default


    ASSERT( pQuery && pQuery->pNsList );
    ASSERT( !IS_FORWARDING(pQuery) );

    //  responding DNS server

    responseIp = pResponse->RemoteAddress.sin_addr.s_addr;

    DNS_DEBUG( REMOTE, (
        "Remote_FindZoneRootOfRespondingNs()\n"
        "\tpQuery       %p\n"
        "\tpResponse    %p\n"
        "\tIP Resp      %s\n",
        pQuery,
        pResponse,
        IP_STRING( responseIp ) ));

    //
    //  loop through visited NS IPs until find match
    //
    //      - save zone root node of responding NS
    //      - mark all IP from responding NS as responded
    //      (barring bad IP data) querying them will give us
    //      same response
    //      - get first query time to this IP, use to reset
    //      priority
    //

    pvisitList = ( PNS_VISIT_LIST ) pQuery->pNsList;
    pvisit = &pvisitList->NsList[ 0 ];
    --pvisit;

    j = pvisitList->VisitCount;
    while( j-- )
    {
        pvisit++;

        if ( pvisit->IpAddress == IP_ZONE_ROOT_NODE )
        {
            pnodeZoneRoot = pvisit->pNsNode;
            continue;
        }

        //  match IP
        //      - note response received
        //      - calculate response time for updating remote

        if ( !pnodeNs )
        {
            if ( pvisit->IpAddress == responseIp )
            {
                pnodeNs = pvisit->pNsNode;
                pvisit->Response = TRUE;

                //  do we want to take space for send time?
                //  alternative is simply record last send time AND flag
                //  what iteration first send was on for each IP

                timeDelta = pResponse->dwMsQueryTime - pvisit->Data.SendTime;
                DNS_DEBUG( REMOTE, (
                    "Remote_FindZoneRootOfRespondingNs()\n"
                    "\tquery time %08X - send time %08X = delta %08X\n",
                    pResponse->dwMsQueryTime,
                    pvisit->Data.SendTime,
                    timeDelta ));
                ASSERT( ( LONG ) timeDelta >= 0 );
            }
            continue;
        }

        //  already found IP match -- then mark all other IP
        //      for this node as responded

        else if ( pvisit->pNsNode == pnodeNs )
        {
            pvisit->Response = TRUE;
            continue;
        }
        else
        {
            break;
        }
    }

    //  not found ?

    if ( !pnodeNs )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  Response from NS at %s, NOT in visited NS list\n"
            "\tof query (%p)\n",
            IP_STRING( responseIp ),
            pQuery ));
        TEST_ASSERT( FALSE );
        return( NULL );
    }
    ASSERT( pnodeZoneRoot );

    //
    //  reset priority of remote server
    //

    Remote_UpdateResponseTime(
        responseIp,
        timeDelta,          //  response time in milliseconds
        0 );                //  timeout

    DNS_DEBUG( REMOTE, (
        "Response (%p) for query (%p) from %s\n"
        "\tresp. zoneroot   = %s (%p)\n"
        "\tresp. time       = %d (ms)\n"
        "\tresp. time delta = %d (ms)\n",
        pQuery,
        pResponse,
        IP_STRING( responseIp ),
        pnodeZoneRoot->szLabel,
        pnodeZoneRoot,
        pResponse->dwMsQueryTime,
        timeDelta ));

    IF_DEBUG( REMOTE2 )
    {
        Dbg_NsList(
            "NS list after markup for responding NS",
            pvisitList );
    }
    return pnodeZoneRoot;
}



VOID
Remote_SetValidResponse(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN      PDB_NODE        pZoneRoot
    )
/*++

Routine Description:

    Save zone root of successfully responding NS.

    This is essentially corrolary of above function.  It merely
    digs out zone root that responded.  This function saves this
    zone root as officially "responded".

Arguments:

    pQuery - ptr to query message

    pZoneRoot - zone root of responding NS

Return Value:

    None

--*/
{
    //
    //  have a valid response from NS for given zone root
    //
    //  this is called when parsing\caching function determines that
    //  we have valid response:
    //      - answer (inc. name error, empty-auth)
    //      - referral to other NS
    //  in this case there's not point in ever requerying NS at this zone
    //  (or above)
    //

    DNS_DEBUG( REMOTE, (
        "Remote_SetValidResponse( q=%p, node=%p )\n",
        pQuery,
        pZoneRoot ));

    ASSERT( (PNS_VISIT_LIST)pQuery->pNsList );

    ((PNS_VISIT_LIST)pQuery->pNsList)->pZoneRootResponded = pZoneRoot;
}



#if DBG
VOID
Dbg_NsList(
    IN      LPSTR           pszHeader,
    IN      PNS_VISIT_LIST  pNsList
    )
/*++

Routine Description:

    Debug print NS list.

Arguments:

    pszHeader -- header to print

    pNsList -- NS list

Return Value:

    None

--*/
{
    PNS_VISIT   pvisit;
    DWORD       count;

    DnsDebugLock();

    if ( !pszHeader )
    {
        pszHeader = "NS List";
    }

    DnsPrintf(
        "%s:\n"
        "\tCount                = %d\n"
        "\tVisitCount           = %d\n"
        "\tZoneIndex            = %d\n"
        "\tZone root current    = %s (%p)\n"
        "\tZone root responded  = %s (%p)\n",
        pszHeader,
        pNsList->Count,
        pNsList->VisitCount,
        pNsList->ZoneIndex,
        pNsList->pZoneRootCurrent
            ?   pNsList->pZoneRootCurrent->szLabel
            :   "none",
        pNsList->pZoneRootCurrent,
        pNsList->pZoneRootResponded
            ?   pNsList->pZoneRootResponded->szLabel
            :   "none",
        pNsList->pZoneRootResponded );

    DnsPrintf(
        "List:\n"
        "\tIP               Priority  Sends  SendTime    Response  Node\n"
        "\t--               --------  -----  --------    --------  ----\n" );

    pvisit = &pNsList->NsList[0];
    count = pNsList->Count;

    while( count-- )
    {
        DnsPrintf(
            "\t%-15s %10d   %3d   %10d    %3d     %s\n",
            IP_STRING( pvisit->IpAddress ),
            pvisit->Data.Priority,
            pvisit->SendCount,
            pvisit->Data.SendTime,
            pvisit->Response,
            pvisit->pNsNode
                ?   pvisit->pNsNode->szLabel
                :   "NULL" );

        pvisit++;
    }

    DnsDebugUnlock();
}
#endif

//
//  End of remote.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\rpc.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    rpc.c

Abstract:

    Domain Name System (DNS) Server

    RPC intialization, shutdown and utility routines.

    Actual RPC callable routines are in the modules for their functional
    area.

Author:

    Jim Gilroy (jamesg)     September, 1995

Revision History:

--*/


#include <rpc.h>
#include "dnssrv.h"
#include "rpcdce.h"
#include "secobj.h"
#include "sdutl.h"

#undef UNICODE


//
//  RPC globals
//

BOOL    g_bRpcInitialized = FALSE;

PSECURITY_DESCRIPTOR g_pRpcSecurityDescriptor;



#define AUTO_BIND



DNS_STATUS
Rpc_Initialize(
    VOID
    )
/*++

Routine Description:

    Initialize server side RPC.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
    RPC_STATUS  status;
    BOOL        buseTcpip = FALSE;
    BOOL        bstatus;
    DWORD       len;


    DNS_DEBUG( RPC, (
        "Rpc_Initialize( %p ).\n",
        SrvCfg_dwRpcProtocol ));

    //
    //  RPC disabled?
    //

    if ( ! SrvCfg_dwRpcProtocol )
    {
        DNS_PRINT(( "RPC disabled -- running without RPC.\n" ));
        return( ERROR_SUCCESS );
    }

#if 0
    //
    //  no RPC if test application
    //

    if ( fServiceStartedFromConsole )
    {
        return( ERROR_SUCCESS );
    }
#endif

    //
    //  Create security for RPC API
    //

    status = NetpCreateWellKnownSids( NULL );
    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT(( "ERROR:  Creating well known SIDs.\n" ));
        return( status );
    }

    status = RpcUtil_CreateSecurityObjects();
    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT(( "ERROR:  Creating DNS security object.\n" ));
        #if !DBG
        return( status );   //  DBG - allow to continue
        #endif
    }


    //
    //  build security descriptor
    //
    //  security is
    //      - owner LocalSystem
    //      - read access for Everyone
    //


    g_pRpcSecurityDescriptor = NULL;

    //
    //  RCP over TCP/IP
    //

    if( SrvCfg_dwRpcProtocol & DNS_RPC_USE_TCPIP )
    {
#ifdef AUTO_BIND

        RPC_BINDING_VECTOR * bindingVector;

        status = RpcServerUseProtseqA(
                        "ncacn_ip_tcp",                 // protocol string.
                        RPC_C_PROTSEQ_MAX_REQS_DEFAULT, // max concurrent calls
                        g_pRpcSecurityDescriptor
                        //NULL                          // security (see #301918)
                        );

        if ( status != RPC_S_OK )
        {
            DNS_DEBUG( INIT, (
                "ERROR:  RpcServerUseProtseq() for TCP/IP failed.]n"
                "\tstatus = %d 0x%08lx.\n",
                status, status ));
            return( status );
        }

        status = RpcServerInqBindings( &bindingVector );

        if ( status != RPC_S_OK )
        {
            DNS_DEBUG( INIT, (
                "ERROR:  RpcServerInqBindings failed.\n"
                "\tstatus = %d 0x%08lx.\n",
                status, status ));
            return( status );
        }

        //
        //  register interface(s)
        //  since only one DNS server on a host can use
        //      RpcEpRegister() rather than RpcEpRegisterNoReplace()
        //

        status = RpcEpRegisterA(
                    DnsServer_ServerIfHandle,
                    bindingVector,
                    NULL,
                    "" );
        if ( status != RPC_S_OK )
        {
            DNS_DEBUG( INIT, (
                "ERROR:  RpcEpRegisterNoReplace() failed.]n"
                "\tstatus = %d %p.\n",
                status, status ));
            return( status );
        }

        //
        //  free binding vector
        //

        status = RpcBindingVectorFree( &bindingVector );
        ASSERT( status == RPC_S_OK );
        status = RPC_S_OK;

#else  // not AUTO_BIND
        status = RpcServerUseProtseqEpA(
                        "ncacn_ip_tcp",                 // protocol string.
                        RPC_C_PROTSEQ_MAX_REQS_DEFAULT, // maximum concurrent calls
                        DNS_RPC_SERVER_PORT_A,          // endpoint
                        g_pRpcSecurityDescriptor );           // security

        if ( status != RPC_S_OK )
        {
            DNS_DEBUG( INIT, (
                "ERROR:  RpcServerUseProtseqEp() for TCP/IP failed.]n"
                "\tstatus = %d 0x%08lx.\n",
                status, status ));
            return( status );
        }

#endif // AUTO_BIND

        buseTcpip = TRUE;
    }

    //
    //  RPC over named pipes
    //
    //  Named pipes RPC has a bug, don't use security descriptor with NULL DACL
    //  Just send NULL.
    //

    if ( SrvCfg_dwRpcProtocol & DNS_RPC_USE_NAMED_PIPE )
    {
        status = RpcServerUseProtseqEpA(
                        "ncacn_np",                     // protocol string.
                        RPC_C_PROTSEQ_MAX_REQS_DEFAULT, // maximum concurrent calls
                        DNS_RPC_NAMED_PIPE_A,           // endpoint
                        g_pRpcSecurityDescriptor
//                        NULL                            // security
                        );

        //  duplicate endpoint is ok

        if ( status == RPC_S_DUPLICATE_ENDPOINT )
        {
            status = RPC_S_OK;
        }
        if ( status != RPC_S_OK )
        {
            DNS_DEBUG( INIT, (
                "ERROR:  RpcServerUseProtseqEp() for named pipe failed.]n"
                "\tstatus = %d 0x%08lx.\n",
                status,
                status ));
            return( status );
        }
    }

    //
    //  RPC over LPC
    //
    //  Need LPC
    //
    //  1. performance.
    //  2. due to a bug in the security checking when rpc is made from
    //      one local system process to another local system process using
    //      other protocols.
    //

    if( SrvCfg_dwRpcProtocol & DNS_RPC_USE_LPC )
    {
        status = RpcServerUseProtseqEpA(
                        "ncalrpc",                      // protocol string.
                        RPC_C_PROTSEQ_MAX_REQS_DEFAULT, // maximum concurrent calls
                        DNS_RPC_LPC_EP_A,               // endpoint
                        g_pRpcSecurityDescriptor );           // security

        //  duplicate endpoint is ok

        if ( status == RPC_S_DUPLICATE_ENDPOINT )
        {
            status = RPC_S_OK;
        }
        if ( status != RPC_S_OK )
        {
            DNS_DEBUG( INIT, (
                "ERROR:  RpcServerUseProtseqEp() for LPC failed.]n"
                "\tstatus = %d 0x%08lx.\n",
                status, status ));
            return( status );
        }
    }

    //
    //  register DNS RPC interface(s)
    //

    status = RpcServerRegisterIf(
                DnsServer_ServerIfHandle,
                0,
                0);
    if ( status != RPC_S_OK )
    {
        DNS_DEBUG( INIT, (
            "ERROR:  RpcServerRegisterIf() failed.]n"
            "\tstatus = %d 0x%08lx.\n",
            status, status ));
        return(status);
    }

    //
    //  for TCP/IP setup authentication
    //

    if ( buseTcpip )
    {
        status = RpcServerRegisterAuthInfoA(
                    DNS_RPC_SECURITY,           // app name to security provider.
                    DNS_RPC_SECURITY_AUTH_ID,   // Auth package ID.
                    NULL,                       // Encryption function handle.
                    NULL );                     // argment pointer to Encrypt function.
        if ( status != RPC_S_OK )
        {
            DNS_DEBUG( INIT, (
                "ERROR:  RpcServerRegisterAuthInfo() failed.]n"
                "\tstatus = %d 0x%08lx.\n",
                status, status ));
            return( status );
        }
    }

    //
    //  Listen on RPC
    //

    status = RpcServerListen(
                1,                              // min threads
                RPC_C_PROTSEQ_MAX_REQS_DEFAULT, // max concurrent calls
                TRUE );                         // return on completion

    if ( status != RPC_S_OK )
    {
        DNS_PRINT((
            "ERROR:  RpcServerListen() failed\n"
            "\tstatus = %d 0x%p\n",
            status, status ));
        return( status );
    }

    g_bRpcInitialized = TRUE;
    return( status );

}   //  Rpc_Initialize



VOID
Rpc_Shutdown(
    VOID
    )
/*++

Routine Description:

    Shutdown RPC on the server.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD   status;
    RPC_BINDING_VECTOR * bindingVector = NULL;

    DNS_DEBUG( RPC, ( "Rpc_Shutdown().\n" ));

    if( ! g_bRpcInitialized )
    {
        DNS_DEBUG( RPC, (
            "RPC not active, no shutdown necessary.\n" ));
        return;
    }

    //
    //  stop server listen
    //  then wait for all RPC threads to go away
    //

    status = RpcMgmtStopServerListening(
                NULL        // this app
                );
    if ( status == RPC_S_OK )
    {
        status = RpcMgmtWaitServerListen();
    }

    //
    //  unbind / unregister endpoints
    //

    status = RpcServerInqBindings( &bindingVector );
    ASSERT( status == RPC_S_OK );

    if ( status == RPC_S_OK )
    {
        status = RpcEpUnregister(
                    DnsServer_ServerIfHandle,
                    bindingVector,
                    NULL );               // Uuid vector.
#if DBG
        if ( status != RPC_S_OK )
        {
            DNS_PRINT((
                "ERROR:  RpcEpUnregister, status = %d.\n", status ));
        }
#endif
    }

    //
    //  free binding vector
    //

    if ( bindingVector )
    {
        status = RpcBindingVectorFree( &bindingVector );
        ASSERT( status == RPC_S_OK );
    }

    //
    //  wait for all calls to complete
    //

    status = RpcServerUnregisterIf(
                DnsServer_ServerIfHandle,
                0,
                TRUE );
    ASSERT( status == ERROR_SUCCESS );

    g_bRpcInitialized = FALSE;

    DNS_DEBUG( RPC, (
        "RPC shutdown completed.\n" ));
}



//
//  RPC allocate and free routines
//

PVOID
MIDL_user_allocate(
    IN      size_t          cBytes
    )
/*++

Routine Description:

    Allocate memory for use in RPC
        - used by server RPC stubs to unpack arguments
        - used by DNS RPC functions to allocate memory to send to client

Arguments:

    cBytes -- count of bytes to allocate

Return Value:

    Ptr to allocated memory, if successful.
    NULL on allocation failure.

--*/
{
    PVOID   pMem;

    pMem = ALLOC_TAGHEAP( cBytes, MEMTAG_RPC );

    DNS_DEBUG( RPC, (
        "RPC allocation of %d bytes at %p.\n",
        cBytes,
        pMem ));

    return( pMem );
}



PVOID
MIDL_user_allocate_zero(
    IN      size_t          cBytes
    )
/*++

Routine Description:

    Allocate zeroed memory for use in RPC
        - used by DNS RPC functions to allocate memory to send to client

Arguments:

    cBytes -- count of bytes to allocate

Return Value:

    Ptr to allocated memory, if successful.
    NULL on allocation failure.

--*/
{
    PVOID   pMem;

    pMem = MIDL_user_allocate( cBytes );
    if ( !pMem )
    {
        return pMem;
    }

    //  zero

    RtlZeroMemory(
        pMem,
        cBytes );

    return( pMem );
}



VOID
MIDL_user_free(
    IN OUT  PVOID           pMem
    )
/*++

Routine Description:

    Free memory used in RPC
        - used by server RPC stubs to free memory sent back to client
        - used by DNS RPC functions when freeing sub-structures in RPC buffers

Arguments:

    pMem -- memory to free

Return Value:

    None

--*/
{
    DNS_DEBUG( RPC, (
        "Free RPC allocation at %p.\n",
        pMem ));

    //  allocation passed to RPC might have had another source
    //FREE_TAGHEAP( pMem, 0, MEMTAG_RPC );

    FREE_TAGHEAP( pMem, 0, 0 );
}



//
//  RPC buffer writing utilities
//
//  These are used to write allocated substructures -- IP arrays and
//  strings -- to RPC buffer.
//

BOOL
RpcUtil_CopyIpArrayToRpcBuffer(
    IN OUT  PIP_ARRAY *     paipRpcIpArray,
    IN      PIP_ARRAY       aipLocalIpArray
    )
/*++

Routine Description:

    Copy local IP Array to RPC buffer.

Arguments:

    paipRpcIpArray -- address in RPC buffer to place IP array;  may or may
        not have existing IP array

    aipLocalIpArray -- local IP array

Return Value:

    TRUE if successful.
    FALSE on memory allocation failure.

--*/
{
    if ( *paipRpcIpArray )
    {
        MIDL_user_free( *paipRpcIpArray );
        *paipRpcIpArray = NULL;
    }
    if ( aipLocalIpArray )
    {
        *paipRpcIpArray = Dns_CreateIpArrayCopy( aipLocalIpArray );

        if ( ! *paipRpcIpArray )
        {
            return( FALSE );
        }
    }
    return( TRUE );
}



BOOL
RpcUtil_CopyStringToRpcBuffer(
    IN OUT  LPSTR *         ppszRpcString,
    IN      LPSTR           pszLocalString
    )
/*++

Routine Description:

    Copy local string to RPC buffer.

Arguments:

    ppszRpcString -- address in RPC buffer to place string;  may or may
        not have existing string

    pszLocalString -- local string

Return Value:

    TRUE if successful.
    FALSE on memory allocation failure.

--*/
{
    if ( *ppszRpcString )
    {
        MIDL_user_free( *ppszRpcString );
        *ppszRpcString = NULL;
    }
    if ( pszLocalString )
    {
        *ppszRpcString = Dns_CreateStringCopy( pszLocalString, 0 );
        if ( ! *ppszRpcString )
        {
            return( FALSE );
        }
    }
    return( TRUE );
}



BOOL
RpcUtil_CopyStringToRpcBufferEx(
    IN OUT  LPSTR *         ppszRpcString,
    IN      LPSTR           pszLocalString,
    IN      BOOL            fUnicodeIn,
    IN      BOOL            fUnicodeOut
    )
/*++

Routine Description:

    Copy local string to RPC buffer.

Arguments:

    ppszRpcString -- address in RPC buffer to place string;  may or may
        not have existing string

    pszLocalString -- local string

Return Value:

    TRUE if successful.
    FALSE on memory allocation failure.

--*/
{
    if ( *ppszRpcString )
    {
        MIDL_user_free( *ppszRpcString );
        *ppszRpcString = NULL;
    }
    if ( pszLocalString )
    {
        *ppszRpcString = Dns_StringCopyAllocate(
                            pszLocalString,
                            0,
                            fUnicodeIn ? DnsCharSetUnicode : DnsCharSetUtf8,
                            fUnicodeOut ? DnsCharSetUnicode : DnsCharSetUtf8
                            );
        if ( ! *ppszRpcString )
        {
            return( FALSE );
        }
    }
    return( TRUE );
}



//
//  Access control for RPC API
//

//
//  Access control globals
//

PSECURITY_DESCRIPTOR    g_GlobalSecurityDescriptor;

GENERIC_MAPPING g_GlobalSecurityInfoMapping =
{
    STANDARD_RIGHTS_READ,       // generic read access
    STANDARD_RIGHTS_WRITE,      // generic write
    STANDARD_RIGHTS_EXECUTE,    // generic execute
    DNS_ALL_ACCESS              // generic all
};

//#define DNS_SERVICE_OBJECT_NAME     TEXT("dns_Server")
#define DNS_SERVICE_OBJECT_NAME     TEXT("DnsServer")


DNS_STATUS
RpcUtil_CreateSecurityObjects(
    VOID
    )
/*++

Routine Description:

    Add security ACEs to DNS security descriptor.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    NTSTATUS status;

    //
    //  Create ACE data for the DACL.
    //
    //  Note, ordering matters!   When access is checked it is checked
    //  by moving down the list until access is granted or denied.
    //
    //  Admin -- all access
    //  SysOps and AcctOps -- DNS admin access
    //  Everyone -- view access only
    //

    ACE_DATA AceData[] =
    {
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0, GENERIC_ALL, &AliasAdminsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0, DNS_ALL_ACCESS, &AliasSystemOpsSid},

        //{ACCESS_ALLOWED_ACE_TYPE, 0, 0, DNS_ADMIN_ACCESS, &AliasAccountOpsSid},
        //{ACCESS_ALLOWED_ACE_TYPE, 0, 0, DNS_VIEW_ACCESS, &AliasAccountOpsSid},
        //{ACCESS_ALLOWED_ACE_TYPE, 0, 0, DNS_VIEW_ACCESS, &AliasSystemOpsSid},
    };

    //
    //  Create the security descriptor
    //

    status = NetpCreateSecurityObject(
               AceData,
               sizeof(AceData)/sizeof(AceData[0]),
               LocalSystemSid,
               LocalSystemSid,
               &g_GlobalSecurityInfoMapping,
               &g_GlobalSecurityDescriptor );

    return( RtlNtStatusToDosError( status ) );
}



DNS_STATUS
RpcUtil_ApiAccessCheck(
    IN      ACCESS_MASK     DesiredAccess
    )
/*++

Routine Description:

    Check caller for desired access needed for the calling API.
    NOTE: Skipping test if we're ds integrated. Will use
    Granular access check.

Arguments:

    DesiredAccess - required access to call the API.

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_ACCESS_DENIED if access not allowed.

--*/
{
    DNS_STATUS  status;

    DNS_DEBUG( RPC, (
        "Call: RpcUtil_ApiAccessCheck\n" ));

    status = NetpAccessCheckAndAudit(
                DNS_SERVICE_NAME,                   // Subsystem name
                DNS_SERVICE_OBJECT_NAME,            // Object typedef name
                g_GlobalSecurityDescriptor,         // Security descriptor
                DesiredAccess,                      // Desired access
                &g_GlobalSecurityInfoMapping );     // Generic mapping

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( RPC, (
            "ACCESS DENIED (%lu): RpcUtil_ApiAccessCheck\n",
             status ));
        status = ERROR_ACCESS_DENIED;
    }

#if DBG
    //
    //  DBG: if not running as a service this will always fail.
    //

    if ( status == ERROR_ACCESS_DENIED && !g_RunAsService )
    {
        DNS_DEBUG( RPC, (
            "RpcUtil_ApiAccessCheck: granting access even though check failed\n",
             status ));
        status = ERROR_SUCCESS;
    }
#endif

    DNS_DEBUG( RPC, (
        "Exit (%lu): RpcUtil_ApiAccessCheck\n",
         status ));

    return( status );
}



DNS_STATUS
RpcUtil_CheckAdminPrivilege(
    IN      PZONE_INFO      pZone,
    IN      DWORD           dwPrivilege
    )
/*++

Routine Description:

    Check for that caller has desired privilege.
    Precondition: Post RpcImpersonation!! Getting thread token.

Arguments:

    pZone -- Zone if specific zone action, NULL for server actions.

    dwPrivilege -- desired action (PRIVILEGE_XXX constant from dnsprocs.h)

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_ACCESS_DENIED if access not allowed.
    other NTSTATUS error code if API call failure

--*/
{
    HANDLE                  htoken = NULL;
    BOOL                    bstatus;
    DWORD                   status = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR    psecurityDescriptor = NULL;
    // AccessCheck Parameter
    DWORD                   desiredAccess;
    GENERIC_MAPPING         genericMapping;
    PRIVILEGE_SET           privilegeSet;
    DWORD                   privilegeSetLength;
    DWORD                   grantedAccess;

    //
    //  get SD for zone (if exists)
    //  otherwise default server SD
    //

    if ( pZone  &&  pZone->pSD )
    {
        psecurityDescriptor = pZone->pSD;
    }
    else if ( g_pServerObjectSD )
    {
        psecurityDescriptor = g_pServerObjectSD;
    }

    DNS_DEBUG( RPC, (
        "CheckAdminPrivilege( zone=%s, priv=%p ) against SD %p\n",
        pZone ? pZone->pszZoneName : "NONE",
        dwPrivilege,
        psecurityDescriptor ));

    //
    //  if no SD from DS -- then signal for old security check
    //
    //  DEVNOTE-DCR: 455822 - old/new access?
    //

    if ( !psecurityDescriptor )
    {
        DNS_DEBUG( RPC, (
            "No DS security check -- fail over to old RPC security.\n" ));
        return( DNSSRV_STATUS_DS_UNAVAILABLE );
    }

    //
    // Second level access check. See if client in DnsAdmins group
    // 1. get thread token (must be an impersonating thread).
    // 2. See if user has RW privilage in the zone or on the server SD
    //

    bstatus = OpenThreadToken(
                    GetCurrentThread(),
                    TOKEN_QUERY,
                    TRUE,
                    &htoken );
    if ( !bstatus )
    {
        status = GetLastError();
        DNS_DEBUG( RPC, (
            "\nERROR <%lu>: failed to open thread token!\n",
             status ));
        ASSERT( FALSE );
        goto Failed;
    }

    #if DBG
    {
        PSID                    pSid = NULL;

        if ( Dbg_GetUserSidForToken( htoken, &pSid ) )
        {
            DNS_DEBUG( RPC, (
                "CheckAdminPrivilege: impersonating: %S\n",
                Dbg_DumpSid( pSid ) ));
            Dbg_FreeUserSid( &pSid );
        }
        else
        {
            DNS_DEBUG( RPC, (
                "CheckAdminPrivilege: GetUserSidForToken failed\n" ));
        }
    }
    #endif

    //  validate SD

    if ( !IsValidSecurityDescriptor(psecurityDescriptor) )
    {
        status = GetLastError();
        DNS_DEBUG( RPC, (
            "Error <%lu>: Invalid security descriptor\n",
            status));
        ASSERT( status != ERROR_SUCCESS );
        goto Failed;
    }

    //
    //  access check against SD
    //
    //      - generic mapping that corresponds to DS objects
    //      - support READ or WRITE access levels
    //

    //  generic mapping for DS objects

    genericMapping.GenericRead      = DNS_DS_GENERIC_READ;
    genericMapping.GenericWrite     = DNS_DS_GENERIC_WRITE;
    genericMapping.GenericExecute   = DNS_DS_GENERIC_EXECUTE;
    genericMapping.GenericAll       = DNS_DS_GENERIC_ALL;

    if ( PRIVILEGE_READ == dwPrivilege )
    {
        desiredAccess = GENERIC_READ;
        // desiredAccess = GENERIC_READ | GENERIC_WRITE;
    }
    else
    {
        desiredAccess = GENERIC_READ | GENERIC_WRITE;
    }

    DNS_DEBUG( RPC, (
        "desiredAccess before MapGenericMask() = %p\n",
        desiredAccess ));

    MapGenericMask(
        & desiredAccess,
        & genericMapping );

    DNS_DEBUG( RPC, (
        "desiredAccess after MapGenericMask() = %p\n",
        desiredAccess ));

    privilegeSetLength = sizeof(privilegeSet);

    //
    //  do access check
    //

    bstatus = AccessCheck(
                    psecurityDescriptor,
                    htoken,
                    desiredAccess,
                    & genericMapping,
                    & privilegeSet,
                    & privilegeSetLength,
                    & grantedAccess,
                    & status );
    if ( !bstatus )
    {
        status = GetLastError();
        DNS_DEBUG( RPC, (
            "Error <%lu>: AccessCheck Failed\n",
            status));
        ASSERT( status != ERROR_SUCCESS );
        goto Failed;
    }

    if ( !status )
    {
        DNS_DEBUG( RPC, (
            "Warning:  Client DENIED by AccessCheck\n"
            "\trequested access = %p\n",
            desiredAccess ));
        status = ERROR_ACCESS_DENIED;
        goto Failed;
    }

    DNS_DEBUG( RPC, (
        "RPC Client GRANTED access by AccessCheck\n" ));
    CloseHandle( htoken );
    return( ERROR_SUCCESS );

Failed:

    if ( status == ERROR_SUCCESS )
    {
        status = ERROR_ACCESS_DENIED;
    }
    if ( htoken )
    {
        CloseHandle( htoken );
    }
    return( status );
}



DNS_STATUS
RpcUtil_SessionSecurityInit(
    IN      LPCSTR          pszZoneName,
    IN      DWORD           dwPrivilege,
    IN      DWORD           dwFlag,
    OUT     PBOOL           pfImpersonating,
    OUT     PZONE_INFO *    ppZone
    )
/*++

Routine Description:

    RPC security init and check for session.

    Impersonate client and check for that caller has desired privilege.

Arguments:

    pZone -- Zone if specific zone action, NULL for server actions.

    dwPrivilege -- desired action

    dwFlag -- flag for action to control special zones (cache, root hints);
        currently unused

    pfImpersonating -- ptr to receive impersonating flag

    ppZone -- resulting zone


Return Value:

    ERROR_SUCCESS if successful.
    ERROR_ACCESS_DENIED if access not allowed.
    other NTSTATUS error code if API call failure

--*/
{
    PZONE_INFO  pzone = NULL;
    DNS_STATUS  status;
    BOOL        bimpersonating = FALSE;

    DNS_DEBUG( RPC, (
        "RpcUtil_SessionSecurityInit()\n"
        "\tzone name = %s\n"
        "\tprivilege = %p\n",
        pszZoneName,
        dwPrivilege ));


    //
    //  if zone given -- find it
    //
    //  psuedo-zones
    //      - root-hints
    //      - cache
    //      - multi-zone
    //  require server level security for desired access
    //

    if ( pszZoneName )
    {
        pzone = Zone_FindZoneByName( (LPSTR)pszZoneName );

        if ( !pzone )
        {
            if ( strcmp( pszZoneName, DNS_ZONE_ROOT_HINTS ) == 0 )
            {
                if ( dwFlag & RPC_INIT_FIND_ALL_ZONES )
                {
                    pzone = g_pRootHintsZone;
                }
            }
            else if ( strcmp( pszZoneName, DNS_ZONE_CACHE ) == 0 )
            {
                if ( dwFlag & RPC_INIT_FIND_ALL_ZONES )
                {
                    pzone = g_pCacheZone;
                }
            }
            else if ( Zone_GetFilterForMultiZoneName( (LPSTR)pszZoneName ) )
            {
                // no-op -- if have filter, then valid multizone lookup
            }
            else    // just bad zone name
            {
                DNS_DEBUG( RPC, (
                    "ERROR:  zone name %s does not match real or pseudo zones!\n",
                    pszZoneName ));
                status =  DNS_ERROR_ZONE_DOES_NOT_EXIST;
                goto Cleanup;
            }
        }
    }

    //
    //  impersonate -- currently do for all calls
    //
    //  not strictly necessary for calls which don't write to DS and
    //  which use Net API authentication, but better to just always do
    //  this
    //
    //  DEVNOTE: if always impersonate can eliminate bImpersonate flag
    //      and always revert on cleanup
    //

    bimpersonating = RpcUtil_SwitchSecurityContext( RPC_CLIENT_CONTEXT );


    //
    //  check with new granular access
    //  if check fails -- still try NT4 administrator-has-access
    //
    //  some issue about whether Admin should OVERRIDE or whether
    //  granular access ought to be able to defeat admin;  i think
    //  the former is fine, we just need to get the story out
    //

    //
    //  if DS backed -- check granular access
    //
    //  DEVNOTE: fix to make single access check for all
    //

    if ( g_pDefaultServerSD )
    {
        status = RpcUtil_CheckAdminPrivilege(
                    pzone,
                    dwPrivilege );
    }
    else
    {
        status = RpcUtil_ApiAccessCheck( DNS_ADMIN_ACCESS );
    }


Cleanup:

    //  revert to self on failure

    if ( status != ERROR_SUCCESS  &&  bimpersonating )
    {
        bimpersonating = RpcUtil_SwitchSecurityContext( RPC_SERVER_CONTEXT );
    }

    //
    //  return zone and impersonation flag
    //
    //  DEVNOTE: currently do NOT return multizone
    //      must lookup again
    //          - this is superior to returning bogus zone to folks
    //          - better would be to have interface include multizone return
    //

    if ( ppZone )
    {
        *ppZone = pzone;
    }
    if ( pfImpersonating )
    {
        *pfImpersonating = bimpersonating;
    }

    DNS_DEBUG( RPC, (
        "Exit (%lu): RpcUtil_SessionSecurityInit\n",
        status ));

    return( status );
}



DNS_STATUS
RpcUtil_SessionComplete(
    VOID
    )
/*++

Routine Description:

    Cleanup for ending RPC call.
    Do revert to self, if impersonating.

Arguments:

    None

Return Value:

    None

--*/
{

    //
    //  revert to self
    //

    RpcUtil_SwitchSecurityContext ( RPC_SERVER_CONTEXT );

    return( ERROR_SUCCESS );
}

BOOL
RpcUtil_SwitchSecurityContext(
    IN  BOOL    bClientContext
    )
/*++

Routine Description:

    Shells on RPC impersonation api's.
    Provides single entry point access to changing rpc impersonation state.


Arguments:

   bClientContext -- does caller request to switch to client or server context

Return Value:

    resulting state : impersonated or not

--*/
{

    DWORD status;
    BOOL bRpcImpersonated;      // note: all code paths set a value.

    if ( !bClientContext )
    {
        //
        // We're in impersonation context & reverting to self
        //
        status = RpcRevertToSelf();
        if ( status != RPC_S_OK )
        {
           DNS_DEBUG( ANY, ("Error <%lu>: RpcRevertToSelf Failed\n", status ));
           ASSERT ( FALSE );

           //
           //  DEVNOTE: we're assuming that if the revert to self is a noop (we're self),
           //  then we'll get back an OK & only if we actually failed to revert from
           //  client context, we get an error. Thus,  we'll set the flag to TRUE
           //

           bRpcImpersonated = TRUE;
           goto Cleanup;
        }
        bRpcImpersonated = FALSE;
    }
    else
    {
        //
        // We're in server context & would like to impersonate.
        //
        //
        //  impersonate -- currently do for all calls
        //
        //  not strictly necessary for calls which don't write to DS and
        //  which use Net API authentication, but better to just always do
        //  this
        //

        status = RpcImpersonateClient( 0 );
        if ( status != RPC_S_OK )
        {
            DNS_DEBUG( RPC, (
                "Error <%lu>: RpcImpersonateClient Failed\n",
                status ));
            ASSERT (FALSE);

            //
            // DEVNOTE: We assume that an impersonated thread calling this we'll end up
            // w/ a noop & return success. Thus we get here only if we attempt to
            // impersonate from server context & we failed, thus we're not impersonating
            // & the flag is FALSE.
            //

            bRpcImpersonated = FALSE;
            goto Cleanup;
        }
        bRpcImpersonated = TRUE;
    }

Cleanup:

    return( bRpcImpersonated );
}


//
//  End rpc.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\rpccall.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    rpccall.c

Abstract:

    Domain Name System (DNS) Server

    General RPC routines.
    These remote routines provide general query \ operation
    to server.  Dispatch tables below dispatch to routines to
    handle specific operation \ query.

Author:

    Jim Gilroy (jamesg)     April, 1997

Revision History:

--*/


#include "dnssrv.h"
#include "sdutl.h"


//
//  Server operations
//

DNS_STATUS
Rpc_Restart(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

#if DBG
DNS_STATUS
Rpc_DebugBreak(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ClearDebugLog(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_RootBreak(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );
#endif

DNS_STATUS
Rpc_ClearCache(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_WriteRootHints(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_WriteDirtyZones(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ClearStatistics(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetServerDwordProperty(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetServerStringProperty(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetServerIPArrayProperty(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetLogFilterListProperty(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetForwarders(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetListenAddresses(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_CreateZone(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_EnlistDirectoryPartition(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_DeleteCacheNode(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeid,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_DeleteCacheRecordSet(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_StartScavenging(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_AbortScavenging(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

//
//  Zone operations
//

DNS_STATUS
Rpc_WriteAndNotifyZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ReloadZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_RefreshSecondaryZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ExpireSecondaryZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_DeleteZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_RenameZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ExportZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_DeleteZoneFromDs(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_UpdateZoneFromDs(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_PauseZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResumeZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_LockZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetZoneTypeEx(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetZoneType(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ChangeZoneDirectoryPartition(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetZoneDatabase(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetZoneMasters(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetZoneSecondaries(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetZoneScavengeServers(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetZoneAllowAutoNS(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetZoneStringProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ResetZoneDwordProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_DeleteZoneNode(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeid,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_DeleteRecordSet(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    );

DNS_STATUS
Rpc_ForceAgingOnNode(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeid,
    IN      PVOID       pData
    );


//
//  Server queries
//

DNS_STATUS
Rpc_GetServerInfo(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppData
    );

DNS_STATUS
Rpc_QueryServerDwordProperty(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppData
    );

DNS_STATUS
Rpc_QueryServerStringProperty(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppData
    );

DNS_STATUS
Rpc_QueryServerIPArrayProperty(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppData
    );

//
//  Zone queries
//

DNS_STATUS
Rpc_GetZoneInfo(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppData
    );

DNS_STATUS
Rpc_GetZone(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppData
    );

DNS_STATUS
Rpc_QueryZoneDwordProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppData
    );

DNS_STATUS
Rpc_QueryZoneIPArrayProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppData
    );

DNS_STATUS
Rpc_QueryZoneStringProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppData
    );


//
//  Complex in\out operations
//

DNS_STATUS
Rpc_EnumZones(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    );

DNS_STATUS
Rpc_EnumDirectoryPartitions(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    );

DNS_STATUS
Rpc_DirectoryPartitionInfo(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    );

DNS_STATUS
Rpc_GetStatistics(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    );

DNS_STATUS
Rpc_QueryDwordProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    );

DNS_STATUS
Rpc_QueryStringProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    );

DNS_STATUS
Rpc_QueryIPListProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    );



//
//  RPC Dispatch Tables
//
//  NT5+ RPC interface uses fewer more extensible calls.
//  The calls contain string determining the operation or
//  query to perform.  These tables dispatch appropriately.
//
//  This is general dispatch definition so I can write one routine to
//  lookup dispatch functions without typing problems and still
//  get type checking between the actual functions (and prototypes)
//  and the dispatch function definition for the table.
//

typedef DNS_STATUS (* DNS_RPC_DISPATCH_FUNCTION)();

typedef struct _DnsRpcDispatchEntry
{
    LPCSTR                      pszOperation;
    DNS_RPC_DISPATCH_FUNCTION   pfnFunction;
    DWORD                       dwTypeIn;
    DWORD                       dwAccess;
}
DNS_RPC_DISPATCH_ENTRY, *PDNS_RPC_DISPATCH_ENTRY;



//
//  Server operations
//

typedef DNS_STATUS (* RPC_SERVER_OPERATION_FUNCTION)(
                        IN      DWORD       dwClientVersion,
                        IN      LPSTR       pszOperation,
                        IN      DWORD       dwTypeIn,
                        IN      PVOID       pData
                        );
typedef struct _DnsRpcServerOperation
{
    LPCSTR                              pszServerOperationName;
    RPC_SERVER_OPERATION_FUNCTION       pfnServerOperationFunc;
    DWORD                               dwTypeIn;
    DWORD                               dwAccess;
};

struct _DnsRpcServerOperation RpcServerOperationTable[] =
{
    //
    //  Property reset functions
    //

    DNSSRV_OP_RESET_DWORD_PROPERTY                  ,
        Rpc_ResetServerDwordProperty                ,
            DNSSRV_TYPEID_NAME_AND_PARAM            ,
                PRIVILEGE_WRITE                     ,

    //  Operations

    DNSSRV_OP_RESTART                       ,
        Rpc_Restart                         ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

#if DBG
    DNSSRV_OP_DEBUG_BREAK                   ,
        Rpc_DebugBreak                      ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,
    DNSSRV_OP_CLEAR_DEBUG_LOG               ,
        Rpc_ClearDebugLog                   ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,
    DNSSRV_OP_ROOT_BREAK                    ,
        Rpc_RootBreak                       ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,
#endif
    DNSSRV_OP_CLEAR_CACHE                   ,
        Rpc_ClearCache                      ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_ZONE_WRITE_BACK_FILE          ,
        Rpc_WriteRootHints                  ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_WRITE_DIRTY_ZONES             ,
        Rpc_WriteDirtyZones                 ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_CLEAR_STATISTICS              ,
        Rpc_ClearStatistics                 ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_ZONE_CREATE                   ,
        Rpc_CreateZone                      ,
            DNSSRV_TYPEID_ZONE_CREATE       ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_ENLIST_DP                     ,
        Rpc_EnlistDirectoryPartition        ,
            DNSSRV_TYPEID_ENLIST_DP         ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_START_SCAVENGING              ,
        Rpc_StartScavenging                 ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_ABORT_SCAVENGING              ,
        Rpc_AbortScavenging                 ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    //  Server operation as well as zone operation
    //  to accomodate cache zone

    DNSSRV_OP_DELETE_NODE                   ,
        Rpc_DeleteCacheNode                 ,
            DNSSRV_TYPEID_NAME_AND_PARAM    ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_DELETE_RECORD_SET             ,
        Rpc_DeleteCacheRecordSet            ,
            DNSSRV_TYPEID_NAME_AND_PARAM    ,
                PRIVILEGE_WRITE             ,

    //  Complex property reset

    DNS_REGKEY_LISTEN_ADDRESSES             ,
        Rpc_ResetListenAddresses            ,
            DNSSRV_TYPEID_IPARRAY           ,
                PRIVILEGE_WRITE             ,

    DNS_REGKEY_FORWARDERS                   ,
        Rpc_ResetForwarders                 ,
            DNSSRV_TYPEID_FORWARDERS        ,
                PRIVILEGE_WRITE             ,

    DNS_REGKEY_LOG_FILE_PATH                ,
        Rpc_ResetServerStringProperty       ,
            DNSSRV_TYPEID_LPWSTR            ,
                PRIVILEGE_WRITE             ,

    DNS_REGKEY_LOG_IP_FILTER_LIST           ,
        Rpc_ResetServerIPArrayProperty      ,
            DNSSRV_TYPEID_IPARRAY           ,
                PRIVILEGE_WRITE             ,

    DNS_REGKEY_FOREST_DP_BASE_NAME          ,
        Rpc_ResetServerStringProperty       ,
            DNSSRV_TYPEID_LPWSTR            ,
                PRIVILEGE_WRITE             ,

    DNS_REGKEY_DOMAIN_DP_BASE_NAME          ,
        Rpc_ResetServerStringProperty       ,
            DNSSRV_TYPEID_LPWSTR            ,
                PRIVILEGE_WRITE             ,

    //  Debugging aids

    DNS_REGKEY_BREAK_ON_RECV_FROM           ,
        Rpc_ResetServerIPArrayProperty      ,
            DNSSRV_TYPEID_IPARRAY           ,
                PRIVILEGE_WRITE             ,

    DNS_REGKEY_BREAK_ON_UPDATE_FROM         ,
        Rpc_ResetServerIPArrayProperty      ,
            DNSSRV_TYPEID_IPARRAY           ,
                PRIVILEGE_WRITE             ,

    NULL, NULL, 0, 0
};



//
//  Zone operations
//

typedef DNS_STATUS (* RPC_ZONE_OPERATION_FUNCTION)(
                        IN      DWORD       dwClientVersion,
                        IN      PZONE_INFO  pZone,
                        IN      LPSTR       pszOperation,
                        IN      DWORD       dwTypeIn,
                        IN      PVOID       pData
                        );

typedef struct _DnsRpcZoneOperation
{
    LPCSTR                          pszZoneOperationName;
    RPC_ZONE_OPERATION_FUNCTION     pfnZoneOperationFunc;
    DWORD                           dwTypeIn;
    DWORD                           dwAccess;
};

struct _DnsRpcZoneOperation RpcZoneOperationTable[] =
{
    //  Operations

    DNSSRV_OP_ZONE_RELOAD                   ,
        Rpc_ReloadZone                      ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_ZONE_EXPIRE                   ,
        Rpc_ExpireSecondaryZone             ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_ZONE_REFRESH                  ,
        Rpc_RefreshSecondaryZone            ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_ZONE_WRITE_BACK_FILE          ,
        Rpc_WriteAndNotifyZone              ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_ZONE_INCREMENT_VERSION        ,
        Rpc_WriteAndNotifyZone              ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_ZONE_DELETE                   ,
        Rpc_DeleteZone                      ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

#if 1
//
//  This feature has been postponed until post-Whistler
//
    DNSSRV_OP_ZONE_RENAME                   ,
        Rpc_RenameZone                      ,
            DNSSRV_TYPEID_ZONE_RENAME       ,
                PRIVILEGE_WRITE             ,
#endif

    DNSSRV_OP_ZONE_EXPORT                   ,
        Rpc_ExportZone                      ,
            DNSSRV_TYPEID_ZONE_EXPORT       ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_ZONE_PAUSE                    ,
        Rpc_PauseZone                       ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_ZONE_RESUME                   ,
        Rpc_ResumeZone                      ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

#if DBG
    DNSSRV_OP_ZONE_LOCK                     ,
        Rpc_LockZone                        ,
            DNSSRV_TYPEID_NAME_AND_PARAM    ,
                PRIVILEGE_WRITE             ,
#endif

    DNSSRV_OP_ZONE_DELETE_NODE              ,
        Rpc_DeleteZoneNode                  ,
            DNSSRV_TYPEID_NAME_AND_PARAM    ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_DELETE_RECORD_SET             ,
        Rpc_DeleteRecordSet                 ,
            DNSSRV_TYPEID_NAME_AND_PARAM    ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_FORCE_AGING_ON_NODE           ,
        Rpc_ForceAgingOnNode                ,
            DNSSRV_TYPEID_NAME_AND_PARAM    ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_ZONE_DELETE_FROM_DS           ,
        Rpc_DeleteZoneFromDs                ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    DNSSRV_OP_ZONE_UPDATE_FROM_DS           ,
        Rpc_UpdateZoneFromDs                ,
            DNSSRV_TYPEID_NULL              ,
                PRIVILEGE_WRITE             ,

    //  Complex property reset

    DNSSRV_OP_ZONE_TYPE_RESET               ,
        Rpc_ResetZoneTypeEx                 ,
            DNSSRV_TYPEID_ZONE_CREATE       ,
                PRIVILEGE_WRITE             ,

#if 0
    DNS_REGKEY_ZONE_TYPE                    ,
        Rpc_ResetZoneType                   ,
            DNSSRV_TYPEID_ZONE_TYPE_RESET   ,
                PRIVILEGE_WRITE             ,
#endif

    DNSSRV_OP_ZONE_CHANGE_DP                ,
        Rpc_ChangeZoneDirectoryPartition    ,
            DNSSRV_TYPEID_ZONE_CHANGE_DP    ,
                PRIVILEGE_WRITE             ,

    DNS_REGKEY_ZONE_FILE                    ,
        Rpc_ResetZoneDatabase               ,
            DNSSRV_TYPEID_ZONE_DATABASE     ,
                PRIVILEGE_WRITE             ,

    DNS_REGKEY_ZONE_MASTERS                 ,
        Rpc_ResetZoneMasters                ,
            DNSSRV_TYPEID_IPARRAY           ,
                PRIVILEGE_WRITE             ,

    DNS_REGKEY_ZONE_LOCAL_MASTERS           ,
        Rpc_ResetZoneMasters                ,
            DNSSRV_TYPEID_IPARRAY           ,
                PRIVILEGE_WRITE             ,

    DNS_REGKEY_ZONE_SECONDARIES             ,
        Rpc_ResetZoneSecondaries            ,
            DNSSRV_TYPEID_ZONE_SECONDARIES  ,
                PRIVILEGE_WRITE             ,

    DNS_REGKEY_ZONE_SCAVENGE_SERVERS        ,
        Rpc_ResetZoneScavengeServers        ,
            DNSSRV_TYPEID_IPARRAY           ,
                PRIVILEGE_WRITE             ,

    DNS_REGKEY_ZONE_ALLOW_AUTONS            ,
        Rpc_ResetZoneAllowAutoNS            ,
            DNSSRV_TYPEID_IPARRAY           ,
                PRIVILEGE_WRITE             ,

    DNS_REGKEY_ZONE_BREAK_ON_NAME_UPDATE    ,
        Rpc_ResetZoneStringProperty         ,
            DNSSRV_TYPEID_LPWSTR            ,
                PRIVILEGE_WRITE             ,

    //  DWORD property reset

    DNSSRV_OP_RESET_DWORD_PROPERTY          ,
        Rpc_ResetZoneDwordProperty          ,
            DNSSRV_TYPEID_NAME_AND_PARAM    ,
                PRIVILEGE_WRITE             ,

    NULL, NULL, 0, 0
};



//
//  Server queries
//

typedef DNS_STATUS (* RPC_SERVER_QUERY_FUNCTION)(
                        IN      DWORD       dwClientVersion,
                        IN      LPSTR       pszQuery,
                        IN      PDWORD      pdwTypeOut,
                        IN      PVOID *     ppData
                        );

typedef struct _DnsRpcServerQuery
{
    LPCSTR                      pszServerQueryName;
    RPC_SERVER_QUERY_FUNCTION   pfnServerQueryFunc;
    DWORD                       dwTypeIn;
    DWORD                       dwAccess;
};

struct _DnsRpcServerQuery RpcServerQueryTable[] =
{
    //  General queries

    DNSSRV_QUERY_SERVER_INFO            ,
        Rpc_GetServerInfo               ,
            0                           ,
                PRIVILEGE_READ          ,

    DNS_REGKEY_LOG_FILE_PATH            ,
        Rpc_QueryServerStringProperty   ,
            0                           ,
                PRIVILEGE_READ          ,

    DNS_REGKEY_LOG_IP_FILTER_LIST       ,
        Rpc_QueryServerIPArrayProperty  ,
            0                           ,
                PRIVILEGE_READ          ,

    //  Interface setup

    DNS_REGKEY_LISTEN_ADDRESSES         ,
        NULL                            ,   //Rpc_QueryListenAddresses,
            0                           ,
                PRIVILEGE_READ          ,

    DNS_REGKEY_FORWARDERS               ,
        NULL                            ,   //Rpc_QueryForwarders
            0                           ,
                PRIVILEGE_READ          ,

    //  Directory partitions

    DNS_REGKEY_FOREST_DP_BASE_NAME      ,
        Rpc_QueryServerStringProperty   ,
            0                           ,
                PRIVILEGE_READ          ,

    DNS_REGKEY_DOMAIN_DP_BASE_NAME      ,
        Rpc_QueryServerStringProperty   ,
            0                           ,
                PRIVILEGE_READ          ,

    //  Debugging

    DNS_REGKEY_BREAK_ON_RECV_FROM       ,
        Rpc_QueryServerIPArrayProperty  ,
            0                           ,
                PRIVILEGE_READ          ,

    DNS_REGKEY_BREAK_ON_UPDATE_FROM     ,
        Rpc_QueryServerIPArrayProperty  ,
            0                           ,
                PRIVILEGE_READ          ,

    NULL, NULL, 0, 0
};



//
//  Zone queries
//

typedef DNS_STATUS (* RPC_ZONE_QUERY_FUNCTION)(
                        IN      DWORD       dwClientVersion,
                        IN      PZONE_INFO  pZone,
                        IN      LPSTR       pszQuery,
                        IN      PDWORD      pdwTypeOut,
                        IN      PVOID *     ppData
                        );

typedef struct _DnsRpcZoneQuery
{
    LPCSTR                      pszZoneQueryName;
    RPC_ZONE_QUERY_FUNCTION     pfnZoneQueryFunc;
    DWORD                       dwTypeIn;
    DWORD                       dwAccess;
};

struct _DnsRpcZoneQuery RpcZoneQueryTable[] =
{
    //  Property Queries
    //
    //  Note:  elminatated all DWORD property queries here
    //  as dispatch function by default assumes that unmatched
    //  query name => Rpc_QueryZoneDwordProperty
    //

#if 0
    //  If want DWORD queries broken out, they would be like this
    DNS_REGKEY_ZONE_Xxx                     ,
        Rpc_QueryZoneDwordProperty          ,
            0                               ,
                PRIVILEGE_READ              ,
#endif

#if 0
    //  Need special function
    //  DEVNOTE:  not yet implemented

    DNS_REGKEY_ZONE_FILE                    ,
        NULL                                , //Rpc_QueryZoneDatabase,
            0                               ,
                PRIVILEGE_READ              ,

    DNS_REGKEY_ZONE_MASTERS                 ,
        NULL                                , //Rpc_QueryZoneMasters,
            0                               ,
                PRIVILEGE_READ              ,

    DNS_REGKEY_ZONE_LOCAL_MASTERS           ,
        NULL                                , //Rpc_QueryZoneMasters,
            0                               ,
                PRIVILEGE_READ              ,

    DNS_REGKEY_ZONE_SECONDARIES             ,
        NULL                                , //Rpc_QueryZoneSecondaries,
            0                               ,
                PRIVILEGE_READ              ,
#endif

    //  Special queries

    DNSSRV_QUERY_ZONE_HANDLE                ,
        Rpc_QueryZoneDwordProperty          ,
            0                               ,
                PRIVILEGE_READ              ,
    DNSSRV_QUERY_ZONE                       ,
        Rpc_GetZone                         ,
            0                               ,
                PRIVILEGE_READ              ,
    DNSSRV_QUERY_ZONE_INFO                  ,
        Rpc_GetZoneInfo                     ,
            0                               ,
                PRIVILEGE_READ              ,
    DNS_REGKEY_ZONE_ALLOW_AUTONS            ,
        Rpc_QueryZoneIPArrayProperty        ,
            0                               ,
                PRIVILEGE_READ              ,
    DNS_REGKEY_ZONE_MASTERS                 ,
        Rpc_QueryZoneIPArrayProperty        ,
            0                               ,
                PRIVILEGE_READ              ,
    DNS_REGKEY_ZONE_LOCAL_MASTERS           ,
        Rpc_QueryZoneIPArrayProperty        ,
            0                               ,
                PRIVILEGE_READ              ,
    DNS_REGKEY_ZONE_SECONDARIES           ,
        Rpc_QueryZoneIPArrayProperty        ,
            0                               ,
                PRIVILEGE_READ              ,
    DNS_REGKEY_ZONE_NOTIFY_LIST           ,
        Rpc_QueryZoneIPArrayProperty        ,
            0                               ,
                PRIVILEGE_READ              ,
    DNS_REGKEY_ZONE_BREAK_ON_NAME_UPDATE    ,
        Rpc_QueryZoneStringProperty         ,
            0                               ,
                PRIVILEGE_READ              ,

    NULL, NULL, 0, 0
};



//
//  RPC Complex In\Out Operations
//

typedef DNS_STATUS (* RPC_COMPLEX_OPERATION_FUNCTION)(
                        IN      DWORD       dwClientVersion,
                        IN      PZONE_INFO  pZone,
                        IN      LPSTR       pszQuery,
                        IN      DWORD       dwTypeIn,
                        IN      PVOID       pDataIn,
                        IN      PDWORD      pdwTypeOut,
                        IN      PVOID *     ppData
                        );

typedef struct _DnsRpcComplexOperation
{
    LPCSTR                          pszComplexOperationName;
    RPC_COMPLEX_OPERATION_FUNCTION  pfnComplexOperationFunc;
    DWORD                           dwTypeIn;
    DWORD                           dwAccess;
};

struct _DnsRpcComplexOperation  RpcComplexOperationTable[] =
{
    DNSSRV_OP_ENUM_ZONES                    ,
        Rpc_EnumZones                       ,
            DNSSRV_TYPEID_DWORD             ,   // input is filter
                PRIVILEGE_READ              ,

    DNSSRV_OP_ENUM_DPS                      ,
        Rpc_EnumDirectoryPartitions         ,
            DNSSRV_TYPEID_DWORD             ,   // input is unused
                PRIVILEGE_READ              ,

    DNSSRV_OP_DP_INFO                       ,
        Rpc_DirectoryPartitionInfo          ,
            DNSSRV_TYPEID_LPSTR             ,   // input is unused
                PRIVILEGE_READ              ,

    DNSSRV_QUERY_STATISTICS                 ,
        Rpc_GetStatistics                   ,
            DNSSRV_TYPEID_DWORD             ,   // input is filter
                PRIVILEGE_READ              ,

    DNSSRV_QUERY_DWORD_PROPERTY             ,
        Rpc_QueryDwordProperty              ,
            DNSSRV_TYPEID_LPSTR             ,   // input is property name
                PRIVILEGE_READ              ,

#if 0
    DNSSRV_OP_ENUM_RECORDS                  ,
        Rpc_EnumRecords                     ,
            DNSSRV_TYPEID_NAME_AND_PARAM    ,
                PRIVILEGE_READ              ,

#endif

    NULL, NULL, 0, 0
};




//
//  General DNS server API
//

DNS_RPC_DISPATCH_FUNCTION
findMatchingFunction(
    IN      PDNS_RPC_DISPATCH_ENTRY DispatchTable,
    IN      LPCSTR                  pszOperation,
    IN      DWORD                   dwTypeIn
    )
/*++

Routine Description:

    Find RPC dispatch function.

Arguments:

    DispatchTable   -- table to search for named operation

    pszOperation    -- name of operation to find function for

    dwTypeIn        -- type id of incoming data;
        for query functions where no incoming data, use DNSSRV_TYPEID_ANY
        for operation functions which do there own type checking, their
        type id in dispatch table may be set to DNSSRV_TYPEID_ANY

Return Value:

    Pointer to dispatch function, if successful
    NULL if operation not found.

--*/
{
    DWORD   index = 0;
    DWORD   dispatchType;
    LPCSTR  pszopName;

    //
    //  Check parameters.
    //

    if ( !DispatchTable || !pszOperation )
    {
        return NULL;
    }

    //
    //  loop through dispatch table, until find operation or reach end
    //

    while ( pszopName = DispatchTable[index].pszOperation )
    {
        if ( _stricmp( pszopName, pszOperation ) == 0 )
        {
            //  found matching operation
            //      - check type id, if desired
            //      - return pointer to dispatch function

            if ( dwTypeIn != DNSSRV_TYPEID_ANY )
            {
                dispatchType = DispatchTable[index].dwTypeIn;
                if ( dispatchType != dwTypeIn &&
                    dispatchType != DNSSRV_TYPEID_ANY )
                {
                    DNS_DEBUG( RPC, (
                        "ERROR:  RPC type %d != dispatch type %d for routine\n",
                        dwTypeIn,
                        dispatchType ));
                    return( NULL );
                }
            }
            return( DispatchTable[index].pfnFunction );
        }
        index++;
    }

    //  named operation not found

    DNS_DEBUG( RPC, (
        "ERROR:  RPC command %s not found in dispatch table.\n",
        pszOperation ));
    return( NULL );
}



DNS_STATUS
R_DnssrvQuery(
    IN      DNSSRV_RPC_HANDLE   hServer,
    IN      LPCSTR              pszZone,
    IN      LPCSTR              pszQuery,
    OUT     PDWORD              pdwTypeOut,
    OUT     DNSSRV_RPC_UNION *  ppData
    )
/*++

    
Routine Description:

    Legacy version of R_DnssrvQuery - no client version argument.

Arguments:

    See R_DnssrvQuery2

Return Value:

    See R_DnssrvQuery2

--*/
{
    DNS_STATUS      status;
    
    DNS_DEBUG( RPC, (
        "R_DnssrvQuery() - non-versioned legacy call\n" ));

    status = R_DnssrvQuery2(
                    DNS_RPC_W2K_CLIENT_VERSION,
                    0,
                    hServer,
                    pszZone,
                    pszQuery,
                    pdwTypeOut,
                    ppData );
    return status;
}   //  R_DnssrvQuery



DNS_STATUS
R_DnssrvQuery2(
    IN      DWORD               dwClientVersion,
    IN      DWORD               dwSettingFlags,
    IN      DNSSRV_RPC_HANDLE   hServer,
    IN      LPCSTR              pszZone,
    IN      LPCSTR              pszQuery,
    OUT     PDWORD              pdwTypeOut,
    OUT     DNSSRV_RPC_UNION *  ppData
    )
/*++

Routine Description:

    Get a blob of data.

Arguments:

    Server      -- server string handle
    pszZone     -- zone name;  NULL if server property
    pszQuery    -- name of data item to retrieve
    dwTypeIn    -- addr to set with switch indicating data type
    ppData      -- addr to set with data answering query

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PZONE_INFO  pzone;
    DNS_STATUS  status = ERROR_SUCCESS;
    BOOL        bstatus;

    DNS_DEBUG( RPC, (
        "R_DnssrvQuery2():\n"
        "\tdwClientVersion  = 0x%X\n"
        "\tpszZone          = %s\n"
        "\tpszQuery         = %s\n"
        "\tpdwTypeOut       = %p\n"
        "\tppData           = %p\n",
        dwClientVersion,
        pszZone,
        pszQuery,
        pdwTypeOut,
        ppData ));


    //  RPC must supply return PTR regardless of what client does
    //      (i think)

    ASSERT( ppData && pdwTypeOut );

    //  set return PTRs for error case
    //  this may be unnecessary if RPC always inits to zero

    *(PVOID *)ppData = NULL;
    *pdwTypeOut = DNSSRV_TYPEID_NULL;

    //
    //  access check
    //

    status = RpcUtil_SessionSecurityInit(
                pszZone,
                PRIVILEGE_READ,
                0,                  // no flag
                NULL,
                & pzone );

    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    //
    //  Switch back to server context. We do all RPC operations in the
    //  server context. If we don't, we can get weird results as our
    //  interpretation of AD security doesn't always match the "true"
    //  AD security settings.
    //

    bstatus = RpcUtil_SwitchSecurityContext( RPC_SERVER_CONTEXT );
    ASSERT( bstatus == ERROR_SUCCESS );

    //
    //  server info, dispatch
    //
    //  DEVNOTE: fail into DWORD or other property from SrvCfg table
    //      alternatively expose another query param so folks can do
    //          - QueryServerDword
    //          - RefreshInterval
    //

    if ( ! pzone )
    {
        RPC_SERVER_QUERY_FUNCTION  function;

        function = (RPC_SERVER_QUERY_FUNCTION)
                        findMatchingFunction(
                            (PDNS_RPC_DISPATCH_ENTRY) RpcServerQueryTable,
                            pszQuery,
                            (DWORD) DNSSRV_TYPEID_ANY );
        if ( !function )
        {
            function = Rpc_QueryServerDwordProperty;
        }

        status = (*function)(
                    dwClientVersion,
                    (LPSTR) pszQuery,
                    pdwTypeOut,
                    (PVOID*) ppData );
    }

    //
    //  zone info query -- find zone, then dispatch query
    //
    //  note, if query function NOT found, then assume query for DWORD
    //  zone property;  this keeps us from having to maintain lookup
    //  in two places (zone query table above, as well as DWORD query
    //  function)
    //

    else
    {
        RPC_ZONE_QUERY_FUNCTION  function;

        function = (RPC_ZONE_QUERY_FUNCTION)
                        findMatchingFunction(
                            (PDNS_RPC_DISPATCH_ENTRY) RpcZoneQueryTable,
                            pszQuery,
                            (DWORD) DNSSRV_TYPEID_ANY );
        if ( !function )
        {
            function = Rpc_QueryZoneDwordProperty;

            //status = ERROR_INVALID_PARAMETER;
            //goto Cleanup;
        }

        status = (*function)(
                    dwClientVersion,
                    pzone,
                    (LPSTR) pszQuery,
                    pdwTypeOut,
                    (PVOID*) ppData );
    }

//Cleanup:

    RpcUtil_SessionComplete();

    return status;
}



DNS_STATUS
R_DnssrvOperation(
    IN      DNSSRV_RPC_HANDLE   hServer,
    IN      LPCSTR              pszZone,
    IN      DWORD               dwContext,
    IN      LPCSTR              pszOperation,
    IN      DWORD               dwTypeIn,
    IN      DNSSRV_RPC_UNION    pData
    )
/*++

    
Routine Description:

    Legacy version of R_DnssrvOperation - no client version argument.

Arguments:

    See R_DnssrvOperation2

Return Value:

    See R_DnssrvOperation2

--*/
{
    DNS_STATUS      status;
    
    DNS_DEBUG( RPC, (
        "R_DnssrvOperation() - non-versioned legacy call\n" ));

    status = R_DnssrvOperation2(
                    DNS_RPC_W2K_CLIENT_VERSION,
                    0,
                    hServer,
                    pszZone,
                    dwContext,
                    pszOperation,
                    dwTypeIn,
                    pData );
    return status;
}   //  R_DnssrvOperation



DNS_STATUS
R_DnssrvOperation2(
    IN      DWORD               dwClientVersion,
    IN      DWORD               dwSettingFlags,
    IN      DNSSRV_RPC_HANDLE   hServer,
    IN      LPCSTR              pszZone,
    IN      DWORD               dwContext,
    IN      LPCSTR              pszOperation,
    IN      DWORD               dwTypeIn,
    IN      DNSSRV_RPC_UNION    pData
    )
/*++

Routine Description:

    Perform operation.

Arguments:

    Server          -- server string handle
    pszZone         -- zone name;  NULL if server operation
    dwContext       -- additional context;
                        currently only supported context is multizone selection
    pszOperation    -- operation to perfrom
    dwTypeIn        -- switch indicating data type
    pData           -- ptr to block of data for operation

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DBG_FN( "R_DnssrvOperation2" )

    PZONE_INFO          pzone;
    DNS_STATUS          status;
    BOOL                bstatus;
    BOOL                bimpersonating = FALSE;
    DNSSRV_RPC_UNION    pdataCopy = pData;
    DWORD               dwflag = 0;

    DNS_DEBUG( RPC, (
        "%s:\n"
        "\tdwClientVersion  = 0x%X\n"
        "\tpszZone          = %s\n"
        "\tdwContext        = %p\n"
        "\tpszOperation     = %s\n"
        "\tdwTypeIn         = %d\n"
        "\tpData            = %p\n",
        fn,
        dwClientVersion,
        pszZone,
        dwContext,
        pszOperation,
        dwTypeIn,
        pData ));

    //
    //  Access check. Depending on the operation, we may allow the
    //  cache zone to be specifed as the target.
    //

    if ( pszOperation &&
        _stricmp( pszOperation, DNSSRV_OP_ZONE_EXPORT ) == 0 )
    {
        dwflag = RPC_INIT_FIND_ALL_ZONES;
    }

    status = RpcUtil_SessionSecurityInit(
                pszZone,
                PRIVILEGE_WRITE,
                dwflag,
                NULL,
                & pzone );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( RPC, (
            "%s: security failure - returning 0x%08X\n", fn, status ));
        return( status );
    }

    //
    //  Revert-to-self so that registry ops don't fail.
    //
    //  DP support: We do all DP operations while impersonating
    //  the administrator. The crossRef objects which must be
    //  modified or created are locked down and will require
    //  credentials with significant rights.
    //

    if ( _stricmp( pszOperation, DNSSRV_OP_ENLIST_DP ) == 0 )
    {
        bimpersonating = TRUE;
    }
    else
    {
        bstatus = RpcUtil_SwitchSecurityContext( RPC_SERVER_CONTEXT );
        ASSERT( bstatus == ERROR_SUCCESS );
    }

    //
    //  This request may be from a downlevel client. If so, the RPC data 
    //  structure will need to be converted to the current version.
    //

    status = DnsRpc_ConvertToCurrent( &dwTypeIn, &pdataCopy.Null );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( RPC, (
            "unable to convert structure to current version error %d\n",
            status ));
        ASSERT( status == ERROR_SUCCESS );
        goto Cleanup;
    }

    //
    //  zone operation
    //      - find operation function
    //      - no zone operations on AutoCreated zones
    //

    if ( pzone )
    {
        RPC_ZONE_OPERATION_FUNCTION  function;

        function = (RPC_ZONE_OPERATION_FUNCTION)
                        findMatchingFunction(
                            (PDNS_RPC_DISPATCH_ENTRY) RpcZoneOperationTable,
                            pszOperation,
                            dwTypeIn );
        if ( !function )
        {
            status =  ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        //  if auto-created, no valid operations

        if ( pzone->fAutoCreated )
        {
            status =  DNS_ERROR_INVALID_ZONE_TYPE;
            goto Cleanup;
        }

        status = (*function)(
                    dwClientVersion,
                    pzone,
                    (LPSTR) pszOperation,
                    dwTypeIn,
                    (PVOID) pdataCopy.Null );
    }

    //
    //  multizone operation
    //      - apply operation to all zones
    //      - save status of any failure
    //
    //  note, test must include check for multizones, because there
    //  are a couple other psuedo zone operations that fall through
    //  to server dispatch table
    //

    else if ( pszZone &&
                ( dwContext ||
                ( dwContext = Zone_GetFilterForMultiZoneName( (LPSTR)pszZone ) ) ) )
    {
        RPC_ZONE_OPERATION_FUNCTION function;
        DNS_STATUS                  tempStatus = ERROR_SUCCESS;

        function = (RPC_ZONE_OPERATION_FUNCTION)
                        findMatchingFunction(
                            (PDNS_RPC_DISPATCH_ENTRY) RpcZoneOperationTable,
                            pszOperation,
                            dwTypeIn );
        if ( !function )
        {
            status =  ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        pzone = NULL;

        while ( pzone = Zone_ListGetNextZoneMatchingFilter(
                                pzone,
                                dwContext ) )
        {
            tempStatus = (*function)(
                            dwClientVersion,
                            pzone,
                            (LPSTR) pszOperation,
                            dwTypeIn,
                            (PVOID) pdataCopy.Null );

            if ( tempStatus > status )
            {
                status = tempStatus;
            }
        }
    }

    //
    //  server operation, dispatch
    //

    else
    {
        RPC_SERVER_OPERATION_FUNCTION  function;

        ASSERT (!pzone);
        function = (RPC_SERVER_OPERATION_FUNCTION)
                        findMatchingFunction(
                            (PDNS_RPC_DISPATCH_ENTRY) RpcServerOperationTable,
                            pszOperation,
                            dwTypeIn );
        if ( !function )
        {
            status = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        status = (*function)(
                    dwClientVersion,
                    (LPSTR) pszOperation,
                    dwTypeIn,
                    (PVOID) pdataCopy.Null );
    }


Cleanup:

    RpcUtil_SessionComplete();

    if ( bimpersonating )
    {
        bstatus = RpcUtil_SwitchSecurityContext ( RPC_SERVER_CONTEXT );
        ASSERT( bstatus == ERROR_SUCCESS );
    }

    DNS_DEBUG( RPC, (
        "%s: returning 0x%08X\n", fn, status ));
    return status;
}



//
//  General RPC function shared between server\zone
//


DNS_STATUS
R_DnssrvComplexOperation(
    IN      DNSSRV_RPC_HANDLE   hServer,
    IN      LPCSTR              pszZone,
    IN      LPCSTR              pszOperation,
    IN      DWORD               dwTypeIn,
    IN      DNSSRV_RPC_UNION    pDataIn,
    OUT     PDWORD              pdwTypeOut,
    OUT     DNSSRV_RPC_UNION *  ppDataOut
    )
/*++

    
Routine Description:

    Legacy version of R_DnssrvComplexOperation - no client version argument.

Arguments:

    See R_DnssrvComplexOperation

Return Value:

    See R_DnssrvComplexOperation

--*/
{
    DNS_STATUS      status;
    
    DNS_DEBUG( RPC, (
        "R_DnssrvComplexOperation() - non-versioned legacy call\n" ));

    status = R_DnssrvComplexOperation2(
                    DNS_RPC_W2K_CLIENT_VERSION,
                    0,
                    hServer,
                    pszZone,
                    pszOperation,
                    dwTypeIn,
                    pDataIn,
                    pdwTypeOut,
                    ppDataOut );
    return status;
}   //  R_DnssrvComplexOperation



DNS_STATUS
R_DnssrvComplexOperation2(
    IN      DWORD               dwClientVersion,
    IN      DWORD               dwSettingFlags,
    IN      DNSSRV_RPC_HANDLE   hServer,
    IN      LPCSTR              pszZone,
    IN      LPCSTR              pszOperation,
    IN      DWORD               dwTypeIn,
    IN      DNSSRV_RPC_UNION    pDataIn,
    OUT     PDWORD              pdwTypeOut,
    OUT     DNSSRV_RPC_UNION *  ppDataOut
    )
/*++

Routine Description:

    Perform complex in\out operation.

Arguments:

    Server          -- server string handle
    pszZone         -- zone name;  NULL if server operation
    pszOperation    -- operation to perfrom
    dwTypeIn        -- switch indicating data type
    pDataIn         -- ptr to block of data for operation
    pdwTypeOut      -- addr to set with switch indicating data type
    ppDataOut       -- addr to set with data answering query

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    RPC_COMPLEX_OPERATION_FUNCTION  function;
    PZONE_INFO  pzone = NULL;
    DNS_STATUS  status;
    BOOL        bstatus;


    DNS_DEBUG( RPC, (
        "R_DnssrvComplexOperation2():\n"
        "\tdwClientVersion  = 0x%08X\n"
        "\tpszZone          = %s\n"
        "\tpszOperation     = %s\n"
        "\tdwTypeIn         = %d\n"
        "\tpDataIn          = %p\n"
        "\tpdwTypeOut       = %p\n"
        "\tppData           = %p\n",
        dwClientVersion,
        pszZone,
        pszOperation,
        dwTypeIn,
        pDataIn,
        pdwTypeOut,
        ppDataOut ));

    //  RPC must supply return PTR regardless of what client does
    //      (i think)

    ASSERT( ppDataOut && pdwTypeOut );

    //  set return PTRs for error case
    //  this may be unnecessary if RPC always inits to zero

    *(PVOID *)ppDataOut = NULL;
    *pdwTypeOut = DNSSRV_TYPEID_NULL;


    //
    //  access check
    //
    //  currently every complex operation supported
    //  is essentially a READ;  may change in which case
    //  need to read and use specific operations required access
    //

    status = RpcUtil_SessionSecurityInit(
                pszZone,
                PRIVILEGE_READ,
                0,                  // no flag
                NULL,
                & pzone );

    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    //
    //  revert-to-self so that registry ops don't fail
    //

    bstatus = RpcUtil_SwitchSecurityContext( RPC_SERVER_CONTEXT );
    ASSERT( !bstatus );

    function = (RPC_COMPLEX_OPERATION_FUNCTION)
                    findMatchingFunction(
                        (PDNS_RPC_DISPATCH_ENTRY) RpcComplexOperationTable,
                        pszOperation,
                        dwTypeIn );
    if ( !function )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    status = (*function)(
                dwClientVersion,
                pzone,
                (LPSTR) pszOperation,
                dwTypeIn,
                (PVOID) pDataIn.Null,
                pdwTypeOut,
                (PVOID) ppDataOut );

Cleanup:

    RpcUtil_SessionComplete( );

    return ( status );
}



DNS_STATUS
Rpc_QueryDwordProperty(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    )
/*++

Routine Description:

    Query server\zone DWORD property.

    Note this is a ComplexOperation in RPC dispatch sense.

Arguments:

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    ASSERT( dwTypeIn == DNSSRV_TYPEID_LPSTR );
    ASSERT( pDataIn != NULL );
    ASSERT( ppDataOut && pdwTypeOut );

    //  if zone dispatch to zone property routine

    if ( pZone )
    {
        return  Rpc_QueryZoneDwordProperty(
                    dwClientVersion,
                    pZone,
                    (LPSTR) pDataIn,    // property name
                    pdwTypeOut,
                    ppDataOut );
    }

    //  otherwise, treat as server property

    return  Rpc_QueryServerDwordProperty(
                dwClientVersion,
                (LPSTR) pDataIn,    // property name
                pdwTypeOut,
                ppDataOut );
}


//
//  End of rpccall.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\rpcw2k.h ===
/*++

Copyright(c) 1995-1999 Microsoft Corporation

Module Name:

    w2krpc.h

Abstract:

    Domain Name System (DNS) Server

    Protypes for functions w2krpc.c

Author:

    Jeff Westhead (jwesth)      October, 2000

Revision History:

--*/


#ifndef _W2KRPC_H_INCLUDED_
#define _W2KRPC_H_INCLUDED_


DNS_STATUS
W2KRpc_GetServerInfo(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeId,
    OUT     PVOID *     ppData
    );

DNS_STATUS
W2KRpc_GetZoneInfo(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeId,
    OUT     PVOID *     ppData
    );

DNS_STATUS
W2KRpc_EnumZones(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    );


#endif  //  _W2KRPC_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\rrcache.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    rrcache.c

Abstract:

    Domain Name System (DNS) Server

    Write packet resource records to database.

Author:

    Jim Gilroy (jamesg)     March, 1995

Revision History:

    jamesg  Jun 1995    --  extended routine to write to separate
                            database for zone transfer
    jamesg  Jul 1995    --  moved to this file for easier access
    jamesg  Jul 1997    --  data ranking, cache pollution

--*/


#include "dnssrv.h"


//
//  Rank for cached RRs
//      - row is section index
//      - column is authoritative (1) or non-authoritative (0)
//

UCHAR   CachingRankArray[4][2] =
{
    0,                          0,
    RANK_CACHE_NA_ANSWER,       RANK_CACHE_A_ANSWER,
    RANK_CACHE_NA_AUTHORITY,    RANK_CACHE_A_AUTHORITY,
    RANK_CACHE_NA_ADDITIONAL,   RANK_CACHE_A_ADDITIONAL
};

#define CacheRankForSection( iSection, fAuthoritative ) \
        ( CachingRankArray[ iSection ][ fAuthoritative ] )


//
//  Flag to indicate name error caching has already been done
//

#define NAME_ERROR_ALREADY_CACHED (2)


//  Internet Root NS domain - used to determine if caching Internet NS

#define g_cchInternetRootNsDomain   18

UCHAR g_InternetRootNsDomain[] =
{
    0x0C, 'r', 'o', 'o', 't', '-', 's', 'e', 'r', 'v', 'e', 'r', 's',
    0x03, 'n', 'e', 't', 0x00
};

extern DWORD g_fUsingInternetRootServers;



VOID
testCacheSize(
    VOID
    )
/*++

Routine Description:

    Tests current cache size. If cache exceeds desired limit,
    set cache enforcement event.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DBG_FN( "testCacheSize" )

    DWORD       cacheLimitInBytes = SrvCfg_dwMaxCacheSize;

    //
    //  Is cache over the limit?
    //

    if ( cacheLimitInBytes == DNS_SERVER_UNLIMITED_CACHE_SIZE ||
        DNS_SERVER_CURRENT_CACHE_BYTES < cacheLimitInBytes )
    {
        return;
    }

    //
    //  Cache is over limit!
    //

    STAT_INC( CacheStats.CacheExceededLimitChecks );

    DNS_DEBUG( ANY, (
        "%s: cache is over limit: current %ld max %ld (bytes)\n"
        "\tthis has happened %ld times\n", fn,
        DNS_SERVER_CURRENT_CACHE_BYTES,
        cacheLimitInBytes,
        CacheStats.CacheExceededLimitChecks ));

    SetEvent( hDnsCacheLimitEvent );
}   //  testCacheSize



//
//  Message processing error routines
//

VOID
Wire_ServerFailureProcessingPacket(
    IN      PDNS_MSGINFO    pMsg,
    IN      DWORD           dwEvent
    )
/*++

Routine Description:

    Server failure encountered processing a packet.

Arguments:

    pMsg - message being processed

    dwEvent - additional event message detail

Return Value:

    None.

--*/
{
    LPSTR   pszserverIp = inet_ntoa( pMsg->RemoteAddress.sin_addr );

    DNS_LOG_EVENT(
        DNS_EVENT_SERVER_FAILURE_PROCESSING_PACKET,
        1,
        & pszserverIp,
        EVENTARG_ALL_UTF8,
        0 );

    DNS_PRINT((
        "Server failure processing packet from DNS server %s\n"
        "\tUnable to allocate RR\n",
        pszserverIp ));

    ASSERT( FALSE );
}



VOID
Wire_PacketError(
    IN      PDNS_MSGINFO    pMsg,
    IN      DWORD           dwEvent
    )
/*++

Routine Description:

    Bad packet encountered from remote DNS server.

Arguments:

    pMsg - message being processed

    dwEvent - additional event message detail

Return Value:

    None.

--*/
{
    LPSTR   pszserverIp = inet_ntoa( pMsg->RemoteAddress.sin_addr );

    DNS_LOG_EVENT(
        DNS_EVENT_BAD_PACKET_LENGTH,
        1,
        & pszserverIp,
        EVENTARG_ALL_UTF8,
        0 );

    IF_DEBUG( ANY )
    {
        DnsDebugLock();
        DNS_PRINT((
            "Packet error in packet from DNS server %s.\n"
            "Packet parsing leads beyond length of packet.  Discarding packet.\n",
            pszserverIp
            ));
        Dbg_DnsMessage(
            "Server packet with name error:",
             pMsg );
        DnsDebugUnlock();
    }
}



VOID
Wire_PacketNameError(
    IN      PDNS_MSGINFO    pMsg,
    IN      DWORD           dwEvent,
    IN      WORD            wOffset
    )
/*++

Routine Description:

    Bad packet encountered from remote DNS server.

Arguments:

    pMsg - message being processed

    dwEvent - additional event message detail

Return Value:

    None.

--*/
{
    LPSTR   pszserverIp = inet_ntoa( pMsg->RemoteAddress.sin_addr );

    DNS_LOG_EVENT(
        DNS_EVENT_INVALID_PACKET_DOMAIN_NAME,
        1,
        & pszserverIp,
        EVENTARG_ALL_UTF8,
        0 );

    IF_DEBUG( ANY )
    {
        DnsDebugLock();
        DNS_PRINT((
            "Name error in packet from DNS server %s, discarding packet.\n",
            pszserverIp
            ));
        DNS_PRINT((
            "Name error in packet at offset = %d (%0x04hx)\n",
            wOffset, wOffset
            ));
        Dbg_DnsMessage(
            "Server packet with name error:",
            pMsg
            );
        DnsDebugUnlock();
    }
}



DNS_STATUS
Xfr_ReadXfrMesssageToDatabase(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Process response from another DNS server.

    This writes RR in message to database.  For zone transfer messages
    written to temporary database for new zone.   For referrals, or
    caching of server generated responses (WINS, CAIRO, etc.) records
    are cached in directly in database, with caching TTLs.

Arguments:

    pMsg - ptr to response info

    pdbZoneXfr - temporary zone transfer database;  NULL for referral

    ppZoneRoot - addr of ptr to root of new zone;  ptr set to NULL on
                    first call and is set to first node written;  then
                    this value should be returned in subsequent calls

Return Value:

    Zero if successful
    Otherwise error code.

--*/
{
    register PCHAR      pchdata;
    PCHAR               pchname;
    PCHAR               pchnextName;
    PDNS_WIRE_RECORD    pwireRR;
    PDB_RECORD          prr = NULL;
    PDB_NODE            pnode;
    INT                 crecordsTotal;
    INT                 countRecords;
    WORD                type;
    WORD                wlength;
    WORD                index;
    PCHAR               pchpacketEnd;
    PCHAR               pszserverIp;
    DNS_STATUS          status;
    PARSE_RECORD        parseRR;

    //
    //  never have any AXFR RCODE except success
    //

    if ( pMsg->Head.ResponseCode != DNS_RCODE_NO_ERROR )
    {
        return( DNS_ERROR_RCODE );
    }

    //
    //  total resource records in response
    //
    //  no records
    //      -> if name error continue, to get name and cache NAME_ERROR
    //      -> otherwise return no
    //
    //  for stub zones, additional and/or NS RRs are processed
    //

    crecordsTotal = pMsg->Head.AnswerCount;

    if ( IS_ZONE_STUB( pZone ) )
    {
        crecordsTotal += pMsg->Head.AdditionalCount + pMsg->Head.NameServerCount;
    }
    else if ( pMsg->Head.AdditionalCount || pMsg->Head.NameServerCount )
    {
        DNS_PRINT((
            "ERROR:  AXFR packet with additional or authority records!\n" ));
        goto PacketError;
    }
    DNS_DEBUG( ZONEXFR2, (
        "AXFR Message at %p contains %d resource records.\n",
        pMsg,
        crecordsTotal ));

    //
    //  write responses into database
    //
    //  loop through all resource records
    //      - skip question
    //      - write other RRs to database
    //

    pchpacketEnd = DNSMSG_END(pMsg);
    pchnextName = pMsg->MessageBody;

    for ( countRecords = 0;
            countRecords < (crecordsTotal + pMsg->Head.QuestionCount);
              countRecords ++ )
    {
        //  clear prr -- makes it easy to determine when needs free

        prr = NULL;

        //  get ptr to next RR name
        //      - insure we stay within message

        pchname = pchnextName;
        if ( pchname >= pchpacketEnd )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  bad packet, at end of packet length with"
                "more records to process\n"
                "\tpacket length = %ld\n"
                "\tcurrent offset = %ld\n",
                pMsg->MessageLength,
                DNSMSG_OFFSET( pMsg, pchdata )
                ));
            goto PacketError;
        }

        //  skip RR name, get struct

        IF_DEBUG( READ2 )
        {
            Dbg_MessageName(
                "Record name ",
                pchname,
                pMsg );
        }
        pchdata = Wire_SkipPacketName( pMsg, pchname );
        if ( ! pchdata )
        {
            goto PacketNameError;
        }

        //
        //  skip question
        //
        //  DEVNOTE: could match AXFR question name with zone root
        //

        if ( countRecords < pMsg->Head.QuestionCount )
        {
            if ( pchdata > pchpacketEnd - sizeof(DNS_QUESTION) )
            {
                DNS_DEBUG( ANY, (
                    "ERROR:  bad packet, not enough space remaining for"
                    "Question structure.\n"
                    "\tTerminating caching from packet.\n"
                    ));
                goto PacketError;
            }
            pchnextName = pchdata + sizeof( DNS_QUESTION );
            continue;
        }

        //
        //  create new node in load database
        //

        pnode = Lookup_ZoneNode(
                    pZone,
                    pchname,
                    pMsg,
                    NULL,       // no lookup name
                    LOOKUP_LOAD | LOOKUP_NAME_FQDN,
                    NULL,       // create mode
                    NULL        // following node ptr
                    );
        if ( !pnode )
        {
            DNS_DEBUG( ANY, (
               "ERROR:  PacketNameError in Xfr_ReadXfrMesssageToDatabase()\n"
               "\tpacket = %p\n"
               "\toffending name at %p\n",
               pMsg,
               pchname ));
            ASSERT( FALSE );
            goto PacketNameError;
        }

        //
        //  extract RR info, type, datalength
        //      - verify RR within message
        //

        pchnextName = Wire_ParseWireRecord(
                        pchdata,
                        pchpacketEnd,
                        TRUE,           // class IN required
                        & parseRR
                        );
        if ( !pchnextName )
        {
            DNS_PRINT(( "ERROR:  bad RR in AXFR packet.\n" ));
            //status = DNS_RCODE_FORMAT_ERROR;
            goto PacketError;
        }

        //
        //  zone transfer first/last zone SOA record matching
        //      - first RR is SOA, save root node
        //      - if have root node, check for matching last node of zone
        //          transfer
        //

        if ( !IS_ZONE_STUB( pZone ) )
        {
            if ( !RECEIVED_XFR_STARTUP_SOA(pMsg) )
            {
                if ( parseRR.wType != DNS_TYPE_SOA )
                {
                    DNS_PRINT(( "ERROR:  first AXFR record is NOT SOA!!!\n" ));
                    goto PacketError;
                }
                RECEIVED_XFR_STARTUP_SOA(pMsg) = TRUE;
            }
            else if ( pnode == pZone->pLoadZoneRoot )
            {
                //  when again receive SOA for zone root -- we're done

                if ( parseRR.wType == DNS_TYPE_SOA )
                {
                    return( DNSSRV_STATUS_AXFR_COMPLETE );
                }
            }
        }

        //
        //  dispatch RR create function for desired type
        //      - special types (SOA, NS) need node info, write it to packet
        //      - all unknown types get flat data copy
        //

        pMsg->pnodeCurrent = pnode;

        prr = Wire_CreateRecordFromWire(
                    pMsg,
                    & parseRR,
                    parseRR.pchData,
                    MEMTAG_RECORD_AXFR
                    );
        if ( !prr )
        {
            //
            //  DEVNOTE: Should have some way to distiguish bad record, from
            //      unknown type, etc.

            //
            //  DEVNOTE-LOG: log record creation failure
            //

            DNS_PRINT((
                "ERROR:  failed record create in AXFR !!!\n" ));
            continue;
        }

        //
        //  zone transfer -- add RR to temp database
        //
        //      - RR rank set in RR_AddToNode()
        //
        //  note:  not setting RR flags to indicate fixed or default TTL;
        //  since we are secondary, SOA won't change, until new transfer
        //  and can write back TTL based on whether matches SOA default;
        //  this is only broken when secondary promoted to primary,
        //  then SOA changed -- not worth worrying about
        //

        status = RR_AddToNode(
                    pZone,
                    pnode,
                    prr
                    );
        if ( status != ERROR_SUCCESS )
        {
            PCHAR   pszargs[3];
            CHAR    sznodeName[ DNS_MAX_NAME_BUFFER_LENGTH ];

            RR_Free( prr );
            prr = NULL;

            Name_PlaceFullNodeNameInBuffer(
                sznodeName,
                sznodeName + DNS_MAX_NAME_BUFFER_LENGTH,
                pnode );

            pszargs[0] = pZone->pszZoneName;
            pszargs[1] = inet_ntoa( pMsg->RemoteAddress.sin_addr );
            pszargs[2] = sznodeName;

            DNS_PRINT((
                "ERROR:  Adding record during AXFR recv\n"
                "\tzone= %s\n"
                "\tat node %s\n"
                "\tmaster = %s\n"
                "\tRR_AddToNode status = %p\n",
                pZone->pszZoneName,
                pszargs[2],
                pszargs[1],
                status ));

            switch ( status )
            {
            case DNS_ERROR_RECORD_ALREADY_EXISTS:
                continue;

            case DNS_ERROR_NODE_IS_CNAME:
                DNS_LOG_EVENT(
                    DNS_EVENT_XFR_ADD_RR_AT_CNAME,
                    3,
                    pszargs,
                    EVENTARG_ALL_UTF8,
                    0 );
                continue;

            case DNS_ERROR_CNAME_COLLISION:
                DNS_LOG_EVENT(
                    DNS_EVENT_XFR_CNAME_NOT_ALONE,
                    3,
                    pszargs,
                    EVENTARG_ALL_UTF8,
                    0 );
                continue;

            case DNS_ERROR_CNAME_LOOP:
                DNS_LOG_EVENT(
                    DNS_EVENT_XFR_CNAME_LOOP,
                    3,
                    pszargs,
                    EVENTARG_ALL_UTF8,
                    0 );
                continue;

            default:
                DNS_PRINT((
                    "ERROR:  UNKNOWN status %p from RR_Add.\n",
                    status ));
                ASSERT( FALSE );
                goto ServerFailure;
            }
            continue;
        }

    }   // loop through RRs

    return( ERROR_SUCCESS );


PacketNameError:

    Wire_PacketNameError( pMsg, 0, (WORD)(pchdata - (PCHAR)&pMsg->Head) );
    status = DNS_ERROR_INVALID_NAME;
    goto ErrorCleanup;

PacketError:

    Wire_PacketError( pMsg, 0 );
    status = DNS_ERROR_BAD_PACKET;
    goto ErrorCleanup;

ServerFailure:

    Wire_ServerFailureProcessingPacket( pMsg, 0 );
    status = DNS_ERROR_RCODE_SERVER_FAILURE;
    goto ErrorCleanup;

ErrorCleanup:

    if ( prr )
    {
        RR_Free( prr );
    }
    return( status );
}



//
//  End rrcache.c
//



DNS_STATUS
Xfr_ParseIxfrResponse(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN OUT  PUPDATE_LIST    pPassUpdateList
    )
/*++

Routine Description:

    Process response from another DNS server.

    This writes RR in message to database.  For zone transfer messages
    written to temporary database for new zone.   For referrals, or
    caching of server generated responses (WINS, CAIRO, etc.) records
    are cached in directly in database, with caching TTLs.

Arguments:

    pMsg - ptr to response info

    pUpdateList - update list to receive IXFR changes

    pPassUpdateList - update list for this pass only


    fFirst - TRUE for first message of transfer;  FALSE otherwise

Return Value:

    ERROR_SUCCESS if message successfully parsed but IXFR not complete.
    DNSSRV_STATUS_AXFR_COMPLETE if IXFR complete.
    DNSSRV_STATUS_NEED_AXFR if response is need AXFR response.
    DNSSRV_STATUS_AXFR_IN_IXFR if response is full AXFR.

    DNSSRV_STATUS_IXFR_UNSUPPORTED if master does not seem to support IXFR.
    DNS_ERROR_RCODE for other RCODE error.
    DNS_ERROR_INVALID_NAME bad name in packet
    DNS_ERROR_BAD_PACKET bad packet

--*/
{
    register PCHAR      pchdata;
    PCHAR               pchname;
    PCHAR               pchnextName;
    PCHAR               pchpacketEnd;
    PDB_RECORD          prr = NULL;
    PDB_NODE            pnode;
    INT                 crecordsTotal;
    INT                 countRecords;
    PCHAR               pszserverIp;
    DNS_STATUS          status;
    DWORD               soaVersion;
    DWORD               version = 0;
    BOOL                fadd;
    BOOL                fdone = FALSE;
    PARSE_RECORD        parseRR;


    DNS_DEBUG( XFR, (
        "ParseIxfrResponse at at %p.\n",
        pMsg ));

    //
    //  RCODE should always be success
    //
    //  if FORMAT_ERROR or NOT_IMPLEMENTED, on first packet, then
    //      master doesn't understand IXFR
    //

    if ( pMsg->Head.ResponseCode != DNS_RCODE_NO_ERROR )
    {
        if ( XFR_MESSAGE_NUMBER(pMsg) == 1 &&
            ( pMsg->Head.ResponseCode == DNS_RCODE_FORMAT_ERROR ||
              pMsg->Head.ResponseCode == DNS_RCODE_NOT_IMPLEMENTED ) )
        {
            return( DNSSRV_STATUS_IXFR_UNSUPPORTED );
        }
        return( DNS_ERROR_RCODE );
    }

    //  total resource records in response
    //      - no records => error
    //      - authority records or additional records => error
    //
    //  DEVNOTE: will security add additional records to IXFR\AXFR?

    crecordsTotal = pMsg->Head.AnswerCount;

    if ( crecordsTotal == 0  ||
        pMsg->Head.AdditionalCount || pMsg->Head.NameServerCount )
    {
        DNS_PRINT((
            "ERROR:  IXFR packet with additional or authority records!\n" ));
        goto PacketError;
    }

    DNS_DEBUG( ZONEXFR2, (
        "IXFR Message at %p contains %d resource records.\n",
        pMsg,
        crecordsTotal ));

    //
    //  recover IXFR add\delete section info of previous message
    //

    if ( XFR_MESSAGE_NUMBER(pMsg) > 1 )
    {
        version = IXFR_LAST_SOA_VERSION(pMsg);
        fadd = IXFR_LAST_PASS_ADD(pMsg);

        ASSERT( pMsg->fTcp );
        ASSERT( RECEIVED_XFR_STARTUP_SOA(pMsg) );
        ASSERT( version != 0 );
    }

    //
    //  single SOA in first packet?
    //
    //  note, for TCP we need to get out here, because BIND will still
    //  send one RR per packet if doing AXFR in IXFR;  if we
    //  fall through and hence don't detect that we don't have IXFR until
    //  the second message, then we won't have the first message around
    //  to send to AXFR processing
    //

    else if ( pMsg->Head.AnswerCount == 1 )
    {
        if ( !pMsg->fTcp )
        {
            DNS_DEBUG( ZONEXFR, (
                "UDP IXFR packet %p contains single SOA -- need TCP.\n",
                pMsg ));
            return( DNSSRV_STATUS_NEED_AXFR );
        }
        else
        {
            DNS_DEBUG( ZONEXFR, (
                "TCP IXFR packet %p contains no second SOA -- BIND AXFR in IXFR?\n",
                pMsg ));
            return( DNSSRV_STATUS_AXFR_IN_IXFR );
        }
    }

    //
    //  write responses into database
    //
    //  loop through all resource records
    //      - skip question
    //      - write other RRs to database
    //

    pchpacketEnd = DNSMSG_END(pMsg);
    pchnextName = pMsg->MessageBody;

    for ( countRecords = 0;
            countRecords < (crecordsTotal + pMsg->Head.QuestionCount);
              countRecords ++ )
    {
        //  clear prr -- makes it easy to determine when needs free

        prr = NULL;

        //  get ptr to next RR name
        //      - insure we stay within message

        pchname = pchnextName;
        if ( pchname >= pchpacketEnd )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  bad packet, at end of packet length with"
                "more records to process\n"
                "\tpacket length = %ld\n"
                "\tcurrent offset = %ld\n",
                pMsg->MessageLength,
                DNSMSG_OFFSET( pMsg, pchdata )
                ));
            goto PacketError;
        }

        //  skip RR name, get struct

        IF_DEBUG( READ2 )
        {
            Dbg_MessageName(
                "Record name ",
                pchname,
                pMsg );
        }
        pchdata = Wire_SkipPacketName( pMsg, pchname );
        if ( ! pchdata )
        {
            goto PacketNameError;
        }

        //
        //  read question name -- must be zone root
        //  note this also has the affect of "seeding" packet
        //  compression information with zone root, which speeds later
        //  lookups
        //

        if ( countRecords < pMsg->Head.QuestionCount )
        {
            PDB_NODE    pclosestNode;

            pnode = Lookup_ZoneNode(
                        pMsg->pzoneCurrent,
                        pchname,
                        pMsg,
                        NULL,           // no lookup name
                        0,              // no flag
                        & pclosestNode, // find node
                        NULL            // following node ptr
                        );
            if ( !pnode  ||  pnode != pMsg->pzoneCurrent->pZoneRoot )
            {
                CLIENT_ASSERT( FALSE );
                goto PacketNameError;
            }
            if ( pchdata > pchpacketEnd - sizeof(DNS_QUESTION) )
            {
                DNS_DEBUG( ANY, (
                    "ERROR:  bad packet, not enough space remaining for"
                    "Question structure.\n"
                    "\tTerminating caching from packet.\n"
                    ));
                goto PacketError;
            }
            pchnextName = pchdata + sizeof( DNS_QUESTION );
            continue;
        }

        //
        //  extract and validate RR info
        //      - type
        //      - datalength
        //      - get RR data ptr
        //  save ptr to next RR name
        //

        pchnextName = Wire_ParseWireRecord(
                            pchdata,
                            pchpacketEnd,
                            TRUE,           // class IN only
                            & parseRR );
        if ( !pchnextName )
        {
            CLIENT_ASSERT( FALSE );
            goto PacketError;
        }
        pchdata += sizeof(DNS_WIRE_RECORD);

        //
        //  check SOA records
        //      - pull out version of SOA
        //
        //  1) first SOA record gives new (master) version
        //  2) second is client request version
        //  3) remaining indicate boundaries between add and delete sections
        //      - at end of add pass, version matches previous
        //          => switch to delete
        //          => when matches master version => exit
        //      - at end of delete pass, get version of delete pass
        //          => switch to add pass
        //  note on final SOA we skip end of version processing so we can
        //  build database record for final SOA and include it in last update
        //

        if ( parseRR.wType == DNS_TYPE_SOA )
        {
            soaVersion = SOA_VERSION_OF_PREVIOUS_RECORD( pchnextName );

            if ( version )
            {
                if ( fadd )
                {
                    if ( soaVersion != version )
                    {
                        CLIENT_ASSERT( FALSE );
                        goto PacketError;
                    }
                    if ( soaVersion == IXFR_MASTER_VERSION(pMsg) )
                    {
                        fdone = TRUE;
                        goto RecordCreate;      // skip end of pass processing
                    }
                    fadd = FALSE;
                    continue;
                }
                else    // end of delete pass
                {
                    if ( soaVersion <= version )
                    {
                        CLIENT_ASSERT( FALSE );
                        goto PacketError;
                    }
                    fadd = TRUE;
                    version = soaVersion;
                }

                //  append update list for this pass, to IXFR master

                Up_AppendUpdateList(
                        pUpdateList,
                        pPassUpdateList,
                        version             // set to new version
                        );
                Up_InitUpdateList( pPassUpdateList );
            }

            //  first SOA?  --  master version

            else if ( !IXFR_MASTER_VERSION(pMsg) )
            {
                IXFR_MASTER_VERSION(pMsg) = soaVersion;
                continue;
            }

            //  second SOA  -- client request version

            else if ( soaVersion <= IXFR_CLIENT_VERSION(pMsg) )
            {
                version = soaVersion;
                fadd = FALSE;
                RECEIVED_XFR_STARTUP_SOA(pMsg) = TRUE;
                continue;
            }
            else
            {
                CLIENT_ASSERT( FALSE );
                goto PacketError;
            }
        }

        //
        //  if not SOA, make sure we have received first two SOA records
        //  (master version and client version);
        //
        //  if receive record after single SOA, then this is really an AXFR
        //      => return and fall through to AXFR processing
        //

        else if ( !RECEIVED_XFR_STARTUP_SOA(pMsg) )
        {
            if ( IXFR_MASTER_VERSION(pMsg) )
            {
                DNS_DEBUG( ZONEXFR, (
                    "IXFR packet %p contains no second SOA -- AXFR in IXFR.\n",
                    pMsg ));
                return( DNSSRV_STATUS_AXFR_IN_IXFR );
            }
            //  if haven't received any SOA, then bum packet
            CLIENT_ASSERT( FALSE );
            goto PacketError;
        }

RecordCreate:

        //
        //  find\create node
        //
        //  DEVNOTE: Optimization don't create node for delete records case
        //      but note that this would prevent follow through transfer.
        //

        pnode = Lookup_ZoneNode(
                    pMsg->pzoneCurrent,
                    pchname,
                    pMsg,
                    NULL,           // no lookup name
                    0,              // no flag
                    NULL,           // create mode
                    NULL            // following node ptr
                    );
        if ( !pnode )
        {
            goto PacketNameError;
        }

        //
        //  build database record
        //

        prr = Wire_CreateRecordFromWire(
                pMsg,
                & parseRR,
                pchdata,
                MEMTAG_RECORD_IXFR
                );
        if ( !prr )
        {
            goto PacketError;
        }

        //
        //  put new record in update list add\delete pass
        //

        Up_CreateAppendUpdate(
                pPassUpdateList,
                pnode,
                (fadd) ? prr : NULL,
                0,
                (fadd) ? NULL : prr
                );

    }   // loop through RRs

    //
    //  done?
    //      if done append last add list, we hold off doing this
    //      when detect final SOA, because we go on to build a dbase RR
    //      for the final SOA and include it as part of the final update
    //

    if ( fdone )
    {
        ASSERT( prr->wType == DNS_TYPE_SOA );
        ASSERT( ntohl(prr->Data.SOA.dwSerialNo) == IXFR_MASTER_VERSION(pMsg) );

        Up_AppendUpdateList(
                pUpdateList,
                pPassUpdateList,
                0                   // no need to set version
                );
        Up_InitUpdateList( pPassUpdateList );
        return( DNSSRV_STATUS_AXFR_COMPLETE );
    }

    //
    //  TCP IXFR with multiple messages
    //      - save current version section info
    //      - ERROR_SUCCESS to indicate successful UN-completed IXFR
    //

    if ( pMsg->fTcp )
    {
        IXFR_LAST_SOA_VERSION(pMsg) = version;
        IXFR_LAST_PASS_ADD(pMsg) = (BOOLEAN) fadd;

        DNS_DEBUG( XFR, (
            "Parsed IXFR TCP message #%d at %p\n"
            "\tsaved fAdd = %d\n"
            "\tsaved version = %d\n",
            XFR_MESSAGE_NUMBER(pMsg),
            pMsg,
            fadd,
            version
            ));
        return( ERROR_SUCCESS );
    }

    //
    //  successfully parsed all records if completed loop
    //      so any remaining pRR is in pPassUpdateList
    //      make sure we don't clean it up if encounter error

    prr = NULL;

    //
    //  UDP IXFR where master could NOT fit all the records in response
    //      will have single SOA corresponding to new version
    //

    if ( pMsg->Head.AnswerCount == 1 )
    {
        ASSERT( !RECEIVED_XFR_STARTUP_SOA(pMsg) );
        ASSERT( IXFR_MASTER_VERSION(pMsg) );

        return( DNSSRV_STATUS_NEED_AXFR );
    }
    else
    {
        PCHAR   pszargs[2];

        pszargs[0] = pMsg->pzoneCurrent->pszZoneName;
        pszargs[1] = inet_ntoa( pMsg->RemoteAddress.sin_addr );

        DNS_PRINT((
            "ERROR:  incomplete UDP IXFR packet at %p\n"
            "\tfrom server %s\n"
            "\tfor zone %s\n",
            pMsg,
            pszargs[1],
            pszargs[0] ));

        DNS_LOG_EVENT(
            DNS_EVENT_IXFR_BAD_RESPONSE,
            2,
            pszargs,
            EVENTARG_ALL_UTF8,
            0 );
        goto PacketError;
    }

PacketNameError:

    Wire_PacketNameError( pMsg, 0, (WORD)(pchdata - (PCHAR)&pMsg->Head) );
    status = DNS_ERROR_INVALID_NAME;
    goto ErrorCleanup;

PacketError:

    Wire_PacketError( pMsg, 0 );
    status = DNS_ERROR_BAD_PACKET;
    goto ErrorCleanup;

ErrorCleanup:

    if ( prr )
    {
        RR_Free( prr );
    }
    return( status );
}




DNS_STATUS
Recurse_CacheMessageResourceRecords(
    IN      PDNS_MSGINFO    pMsg,
    IN OUT  PDNS_MSGINFO    pQuery
    )
/*++

Routine Description:

    Process and cache response from another DNS server.
    This writes RR in message to database.

Arguments:


    pMsg - ptr to response message info

    pQuery - ptr to original query message info

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_RCODE_NAME_ERROR if name error.
    DNS_ERROR_NAME_NOT_IN_ZONE if unable to cache record outside NS zone.
    DNS_INFO_NO_RECORDS if this is an empty auth response.
    Error code on bad packet failure or other RCODE responses.

--*/
{
    #define             DNS_SECONDS_BETWEEN_CACHE_TESTS     30

    register PCHAR      pch;
    PCHAR               pchnextName;
    PCHAR               pchcurrentName;
    PDB_RECORD          prr = NULL;
    PDB_NODE            pnode = NULL;
    PDB_NODE            pnodePrevious = NULL;
    PDB_NODE            pnodeQueried;
    WORD                type;
    WORD                typePrevious = 0;
    WORD                offset;
    WORD                offsetPrevious = 0;
    DWORD               ttlForSet = SrvCfg_dwMaxCacheTtl;
    DWORD               ttlTemp;
    PDB_NODE            pnodeQuestion = NULL;
    PCHAR               pchpacketEnd;
    PCHAR               pszserverIp;
    BOOL                fnameError = FALSE;
    BOOL                fignoreRecord = FALSE;
    BOOL                fnoforwardResponse = FALSE;
    BOOL                fanswered = FALSE;
    BOOL                forwardTruncatedResponse = FALSE;
    DNS_STATUS          status;
    INT                 sectionIndex;
    WORD                countSectionRR;
    UCHAR               rank;
    DNS_LIST            listRR;
    DWORD               i;
    PARSE_RECORD        parseRR;
    BOOL                fisEmptyAuthResponse = FALSE;
    INT                 authSectionSoaCount = 0;
    static DWORD        lastCacheCheckTime = 0;

    DNS_DEBUG( READ2, (
        "Recurse_CacheMessageResourceRecords()\n"
        "\tresponse = %p\n"
        "\tquery    = %p, query time = %p\n",
        pMsg,
        pQuery,
        pQuery->dwQueryTime ));

    //
    //  Test current cache size - only perform test every X seconds.
    //

    if ( DNS_TIME() - lastCacheCheckTime > DNS_SECONDS_BETWEEN_CACHE_TESTS )
    {
        testCacheSize();
        lastCacheCheckTime = DNS_TIME();
    }

    //
    //  authoritative response
    //      - ends queries for THIS question
    //      (may continue following CNAME, but this question is settled)
    //

    if ( pMsg->Head.Authoritative )
    {
        pQuery->fQuestionCompleted = TRUE;
        STAT_INC( RecurseStats.ResponseAuthoritative );
    }
    else
    {
        STAT_INC( RecurseStats.ResponseNotAuth );
    }

    //
    //  forwarding response
    //      - any valid forwarders response ends queries on this question
    //      - no checking RRs against server queried when forwarding
    //      as forwarder has that info and must do checks
    //
    //  catch non-recursive forwarder
    //      however, forward can forward response from remote DNS
    //      without RA or RD flags set, so before must screen out other
    //      valid responses (answer, AUTH, NXDOMAIN) and only catch
    //      when getting a delegation instead of ANSWER
    //
    //  DEVNOTE: should have packet categorization below, so don't repeat
    //      test here
    //

    if ( IS_FORWARDING(pQuery) )
    {
        pnodeQueried = NULL;
        STAT_INC( RecurseStats.ResponseFromForwarder );

        if ( pQuery->Head.RecursionDesired )
        {
            if ( pMsg->Head.RecursionAvailable )
            {
                pQuery->fQuestionCompleted = TRUE;
            }
            else if ( pMsg->Head.AnswerCount == 0   &&
                      ! pMsg->Head.Authoritative    &&
                      pMsg->Head.ResponseCode != DNS_RCODE_NXDOMAIN )
            {
                PVOID parg = (PVOID) (ULONG_PTR) pMsg->RemoteAddress.sin_addr.s_addr;

                DNS_LOG_EVENT(
                    DNS_EVENT_NON_RECURSIVE_FORWARDER,
                    1,
                    & parg,
                    EVENTARG_ALL_IP_ADDRESS,
                    0 );
            }
        }
    }

    //
    //  non-forwarding -- secure responses
    //
    //      - determine zone root of responding server
    //          can then verify validity of RRs returned
    //      - any valid authorititative response ends queries on THIS question
    //

    //if ( !IS_FORWARDING(pQuery) )
    else
    {
        pnodeQueried = Remote_FindZoneRootOfRespondingNs(
                            pQuery,
                            pMsg );
        if ( !pnodeQueried )
        {
            if ( SrvCfg_fSecureResponses )
            {
                STAT_INC( RecurseStats.ResponseUnsecure );
                return( DNS_ERROR_UNSECURE_PACKET );
            }
        }
    }

    //
    //  check for errors before we even bother
    //
    //  NAME_ERROR is special case
    //      - if SOA returned, set flag to allow negative caching
    //

    if ( pMsg->Head.ResponseCode != DNS_RCODE_NO_ERROR )
    {
        if ( pMsg->Head.ResponseCode != DNS_RCODE_NAME_ERROR )
        {
            STAT_INC( RecurseStats.ResponseRcode );
            return( DNS_ERROR_RCODE );
        }

        STAT_INC( RecurseStats.ResponseNameError );
        fnameError = TRUE;
    }

    //
    //  answer? empty? delegation?
    //
    //  DEVNOTE: is BIND going to start sending non-auth empties with SOA?
    //
    //  DEVNOTE: nice to detect empties:  two issues
    //  DEVNOTE: NT4 non-auth empty forwards will cause problems
    //  DEVNOTE: out of zone SOA additional data could cause security rejection
    //      of additional, so we didn't do direct forward, then we wouldn't
    //      be able to write empty from cache, and if we did we wouldn't
    //      be setting authority flag or rewriting SOA
    //
    //  Note, if we can detect empty, just turning on fQuestionCompleted flag
    //  will cause correct behavior (no write, no recurse).  If sent on for
    //  current lookup.
    //

    else if ( pMsg->Head.AnswerCount )
    {
        pQuery->fQuestionCompleted = TRUE;
        STAT_INC( RecurseStats.ResponseAnswer );
    }
    else if ( !pMsg->Head.NameServerCount )
    {
        //
        //  completely empty non-auth response (probably from NT4 DNS)
        //      - if forwarding just forward to client
        //      - otherwise treat as bad packet (without logging) and
        //          let recursion eventually track down AUTH server and
        //          get proper AUTH response
        //

        DNS_DEBUG( RECURSE, (
            "WARNING: non-authoritative empty response at %p\n"
            "\t -- probably forward from my DNS.\n",
            pMsg ));

        if ( IS_FORWARDING(pQuery) )
        {
            return( DNS_ERROR_RCODE_NXRRSET );
        }
        else
        {
            return( DNS_ERROR_BAD_PACKET );
        }
    }

    //
    //  write responses into database
    //
    //  loop through all resource records
    //      - skip question
    //      - write other RRs to database
    //

    INITIALIZE_COMPRESSION(pMsg);

    pchpacketEnd = DNSMSG_END(pMsg);
    pchnextName = pMsg->MessageBody;

    sectionIndex = QUESTION_SECTION_INDEX;
    countSectionRR = pMsg->Head.QuestionCount;
    DNS_LIST_STRUCT_INIT( listRR );

    //
    //  Resource record loop.
    //

    while( 1 )
    {
        BOOL        fcachingRootNs = FALSE;

        //
        //  new section?
        //      - commit any outstanding RR sets

        if ( countSectionRR == 0 )
        {
            if ( !IS_DNS_LIST_STRUCT_EMPTY(listRR) )
            {
                ASSERT( pnodePrevious );
                RR_CacheSetAtNode(
                    pnodePrevious,
                    listRR.pFirst,
                    listRR.pLast,
                    ttlForSet,
                    pQuery->dwQueryTime );
                DNS_LIST_STRUCT_INIT( listRR );
                ttlForSet = SrvCfg_dwMaxCacheTtl;
            }

            if ( sectionIndex == ADDITIONAL_SECTION_INDEX )
            {
                break;
            }

            //  new section info

            sectionIndex++;
            countSectionRR = RR_SECTION_COUNT( pMsg, sectionIndex );
            if ( countSectionRR == 0 )
            {
                continue;
            }
            rank = CacheRankForSection( sectionIndex, pMsg->Head.Authoritative );
        }

        //  clear prr -- makes it easy to determine when needs free

        countSectionRR--;
        prr = NULL;

        //
        //  get RR owner name
        //      - insure we stay within message
        //

        pchcurrentName = pchnextName;

        pnode = Lookup_CreateCacheNodeFromPacketName(
                    pMsg,
                    pchpacketEnd,
                    & pchnextName );
        if ( !pnode )
        {
            //  if question name is invalid name generating name error
            //  make sure name error gets returned to client

            if ( sectionIndex == QUESTION_SECTION_INDEX )
            {
                if ( fnameError )
                {
                    DNS_DEBUG( READ, (
                        "Name error on invalid name.\n",
                        pMsg ));
                    return( DNS_ERROR_RCODE_NAME_ERROR );
                }
            }
            goto PacketNameError;
        }
        pch = pchnextName;

        //
        //  new node?
        //      - save offset to avoid unnecessary lookup of same name for next RR
        //      - ignore RR if
        //      1) in authoritative zone
        //          OR
        //      2) not in subtree of zone root of NS responding to query
        //          (the "cache-pollution" fix)
        //      then set zero timeout on ignore node
        //

        if ( pnode != pnodePrevious )
        {
            fignoreRecord = FALSE;

#if 0
            //  DEVNOTE: cached data for AUTH nodes
            //
            //  some way of denying access to bogus data -- but not necessarily
            //      tossing packet
            //      -- can keep packet if matches zone data
            //      -- can still cache other data

            //
            //  DEVOTE: need to flag responses with data in auth zones
            //      they MUST not be passed on to client?
            //

            if ( pnode->pZone )
            {
                IF_DEBUG( ANY )
                {
                    Dbg_NodeName(
                        "Packet contains RR for authoritative zone node: ",
                        pnode,
                        "\n\t-- ignoring RR." );
                }
                fignoreRecord = TRUE;
            }
#endif

            //
            //  secure responses
            //      - currently only secure responses
            //
            //  DEVNOTE: secure responses when queried delegation
            //      - need to either
            //      - save cache node corresponding to query (rather
            //          than just delegation
            //      - do absolute name hierarchial compare here
            //          (this is not really very hard)
            //

            if ( SrvCfg_fSecureResponses &&
                pnodeQueried &&
                IS_CACHE_TREE_NODE(pnodeQueried) &&
                ! Dbase_IsNodeInSubtree( pnode, pnodeQueried ) )
            {
                DNS_DEBUG( ANY, (
                    "Node (label %s) not in subtree of zone root (label %s)\n"
                    "\tof NS queried %s.\n"
                    "\tIgnoring RR at offset %x (section=%d) in packet %p\n",
                    pnode->szLabel,
                    pnodeQueried->szLabel,
                    inet_ntoa(pMsg->RemoteAddress.sin_addr),
                    offsetPrevious,
                    sectionIndex,
                    pMsg ));
                fignoreRecord = TRUE;
            }

            if ( fignoreRecord )
            {
                Timeout_SetTimeoutOnNode( pnode );
            }
        }

        //  may not be necessary as RR create now independent of node

        pMsg->pnodeCurrent = pnode;


        //
        //  question section
        //  if name error (NXDOMAIN) then create question node for
        //  name error caching
        //

        if ( sectionIndex == QUESTION_SECTION_INDEX )
        {
            pchnextName += sizeof( DNS_QUESTION );
            if ( pchnextName > pchpacketEnd )
            {
                DNS_DEBUG( ANY, (
                    "ERROR:  bad packet, not enough space remaining for"
                    "Question structure.\n"
                    "\tTerminating caching from packet.\n"
                    ));
                goto PacketError;
            }

            //  grab question type, (we special case SOA queries in name error caching)

            pMsg->wQuestionType = FlipUnalignedWord( pch );

#if 0
            //  currently creating node for all names, only benefit to special
            //  casing question would be for referral packets (no answer), where
            //  referral might not generate name error cached response

            if ( fnameError )
            {
                pnodeQuestion = Dbase_CreatePacketName(
                                    DNS_RCLASS_INTERNET,
                                    pMsg,
                                    pch );
                if ( !pnodeQuestion )
                {
                    goto PacketNameError;
                }
            }
#endif
            pnodeQuestion = pnode;
            pnodePrevious = pnode;

            //  DEVNOTE:  could do query question matching here
            //      i'm going to concentrate the fix on requiring data to be under
            //      the zone of the NS we queried

            //  reject packet if question node triggered "ignore" condition
            //      1) in authoriative zone => never should have queried so
            //      this is probably a bogus question or mismatched response
            //      2) outside zone we queried => never should have queried

            if ( fignoreRecord )
            {
                IF_DEBUG( ANY )
                {
                    DnsDebugLock();
                    DNS_PRINT((
                        "ERROR:  Ignoring question node (label %s) of response!\n",
                        pnode->szLabel ));
                    Dbg_DnsMessage(
                        "Ignored question node response:",
                        pMsg );
                    Dbg_DnsMessage(
                        "Ignored question node original query:",
                        pQuery );
                    DnsDebugUnlock();
                }
                goto InvalidDataError;
            }
            continue;
        }

        //
        //  extract RR info
        //      - type
        //      - datalength
        //      - get RR data ptr
        //  save ptr to next RR name
        //

        pchnextName = Wire_ParseWireRecord(
                        pch,
                        pchpacketEnd,
                        TRUE,           // class IN required
                        & parseRR
                        );
        if ( !pchnextName )
        {
            DNS_PRINT(( "ERROR:  bad RR in response packet.\n" ));
            MSG_ASSERT( pMsg, FALSE );
            //status = DNS_RCODE_FORMAT_ERROR;
            goto PacketError;
        }
        type = parseRR.wType;

        //
        //  Are we caching an NS record for the root?
        //

        if ( type == DNS_TYPE_NS &&
            pnode->pParent == NULL )
        {
            fcachingRootNs = TRUE;
        }

        //
        //  answer section
        //

        if ( sectionIndex == ANSWER_SECTION_INDEX )
        {
            //  type checking -- must match
            //  DEVNOTE: could have strict CNAME checking, but doesn't buy much
            //      data integrity
            //
            //  DEVNOTE: type table should handle these checks
            //

            if ( type == pQuery->wTypeCurrent )
            {
                fanswered = TRUE;
            }
            else if (   type == DNS_TYPE_CNAME ||
                        type == DNS_TYPE_SIG )
            {
            }
            else if (   pQuery->wTypeCurrent == DNS_TYPE_ALL ||
                        pQuery->wTypeCurrent == DNS_TYPE_MAILB ||
                        pQuery->wTypeCurrent == DNS_TYPE_MAILA )
            {
                fanswered = TRUE;
            }
            else
            {
                DNS_DEBUG( ANY, (
                    "PACKERR:  Answer type %d does not match question type %d,\n"
                    "\tnor is possible answer for this question.\n"
                    "\tTossing response packet %p for orginal query at %p\n",
                    type,
                    pQuery->wTypeCurrent,
                    pMsg,
                    pQuery ));
                goto InvalidDataError;
            }
        }

        //
        //  authority section
        //      - NS or SOA only
        //      - screen out records for info outside subtree for NS queried
        //      (note server can legitimately pass on higher level server info
        //      it could even be authoritative for the root, but not the zone
        //      queried)
        //
        //  DEVNOTE-LOG: log warning bad type in authority
        //

        else if ( sectionIndex == AUTHORITY_SECTION_INDEX )
        {
            if ( !IS_AUTHORITY_SECTION_TYPE(type) )
            {
                DNS_DEBUG( ANY, (
                    "ERROR:  record type %d in authority section of response msg %p\n",
                    type,
                    pMsg ));
                fignoreRecord = TRUE;
            }

            //  if have valid authority record, should never be recursing up to
            //  (asking query of NS at) this NS's zone root node again
            //  valid response is either
            //      - SOA to cache name error at authoritative response
            //      - NS accompanying answers
            //      - NS referral to lower level zone (and node)
            //
            //  unfortunately, people out in Internet land apparently have
            //  sideways delegations where NS refers to another
            //  example:
            //      in com zone
            //      uclick.com. NS  ns.uclick.com.
            //      uclick.com. NS  ns1.isp.com.
            //      but on isp's box, some sort of stub to real NS
            //      uclick.com. NS  ns.uclick.com.
            //
            //  so the referral is sideways, and you MUST keep checking unless also an
            //  authoritative response
            //  so we limit setting valid response to when we actually know we have
            //  an answer (authoritative or answer) OR when we cleared have delegated
            //  to subzone
            //
            //  DEVNOTE: intelligent limit on tree walk
            //      we still aren't catching the case where we are delegating BACK UP
            //      the tree to a node we previously touched
            //      ideally we'd have a delegation wizard to check when question not
            //      answered
            //

            else
            {
                if ( pnodeQueried && !fignoreRecord )
                {
                    if ( pQuery->fQuestionCompleted ||
                        ( Dbase_IsNodeInSubtree( pnode, pnodeQueried ) &&
                            pnode != pnodeQueried ) )
                    {
                        DNS_DEBUG( RECURSE, (
                            "Valid authority record read from reponse %p.\n"
                            "\tsetting response node to %p (label %s)\n",
                            pMsg,
                            pnodeQueried,
                            pnodeQueried->szLabel ));

                        Remote_SetValidResponse(
                            pQuery,
                            pnodeQueried );
                    }
                }

                if ( type == DNS_TYPE_SOA )
                {
                    ++authSectionSoaCount;
                }
            }
        }

        //
        //  additional section
        //      - A, AAAA, SIG, KEY only
        //      - screen out records for info outside subtree for NS queried
        //
        //  DEVNOTE-LOG: log warning bad type in additional
        //
        //  DEVNOTE: additional screening problematic
        //      unlike authority it is reasonable to have random stuff
        //

        else
        {
            ASSERT( sectionIndex == ADDITIONAL_SECTION_INDEX );
            if ( ! IS_ADDITIONAL_SECTION_TYPE(type) )
            {
                DNS_DEBUG( ANY, (
                    "ERROR:  record type %d in additional section of response msg %p\n",
                    type,
                    pMsg ));
                fignoreRecord = TRUE;
            }

            //  authoritative empty response?
            //  if killing A record for primary server, then
            //      and send packet, just stripped of offending record
            //
            //  for delegations and answered queries there is no problem with
            //  just caching the "legal" info in the packet and continuing, only
            //  the auth-empty response causes problems, because we don't have
            //  a way to properly cache the "NXRRSET"

            if ( fignoreRecord &&
                    pMsg->Head.AnswerCount == 0 &&
                    pMsg->Head.Authoritative &&
                    ! fnoforwardResponse )
            {
                DNS_DEBUG( READ, (
                    "Killing Additional section ignore record in authoritative empty response\n"
                    "\tGenerally this is primary server A record\n"
                    ));

                pMsg->MessageLength = DNSMSG_OFFSET( pMsg, pchcurrentName );

                pMsg->Head.AdditionalCount -= (countSectionRR + 1);

                countSectionRR = 0;     // stop further processing
                forwardTruncatedResponse = TRUE;
            }
        }

        //
        //  new RR set?
        //

        if ( ! IS_DNS_LIST_STRUCT_EMPTY(listRR)
                &&
            (type != typePrevious || pnode != pnodePrevious) )
        {
            RR_CacheSetAtNode(
                pnodePrevious,
                listRR.pFirst,
                listRR.pLast,
                ttlForSet,
                pQuery->dwQueryTime
                );
            DNS_LIST_STRUCT_INIT( listRR );
            ttlForSet = SrvCfg_dwMaxCacheTtl;
        }

        //  reset previous to this record

        typePrevious = type;
        pnodePrevious = pnode;

        //
        //  ignoring this record?
        //

        if ( fignoreRecord )
        {
            fnoforwardResponse = TRUE;
            IF_DEBUG( READ )
            {
                DnsDbg_Lock();
                DnsDbg_PacketRecord(
                    "WARNING:  Ignored packet record RR ",
                    (PDNS_WIRE_RECORD) parseRR.pchWireRR,
                    DNS_HEADER_PTR(pMsg),
                    DNSMSG_END(pMsg) );

                if ( pnodeQueried )
                {
                    Dbg_NodeName(
                        "Queried NS at node ",
                        pnodeQueried,
                        "\n" );
                }
                else
                {
                    DnsPrintf( "\tNo NS queried node\n" );
                }
                Dbg_NodeName(
                    "Node for record being ignored ",
                    pnode,
                    "\n" );
                DnsDbg_Unlock();
            }
            continue;
        }
        if ( type == DNS_TYPE_WINS || type == DNS_TYPE_WINSR )
        {
            DNS_DEBUG( READ, (
                "Ignoring WINS\\WINSR record parsing packet at %p\n",
                pMsg ));
            continue;
        }
        if ( type == DNS_TYPE_OPT )
        {
            DNS_DEBUG( READ, (
                "Ignoring OPT record parsing packet at %p\n",
                pMsg ));
            pMsg->pCurrent = pchcurrentName;    // back up to start of RR
            Answer_ParseAndStripOpt( pMsg );
            continue;
        }

        //
        //  create database record
        //

        prr = Wire_CreateRecordFromWire(
                    pMsg,
                    & parseRR,
                    parseRR.pchData,
                    MEMTAG_RECORD_CACHE
                    );
        if ( !prr )
        {
            //
            //  DEVNOTE: should have some way to distiguish bad record, from
            //              unknown type, etc.
            //
            //  DEVNOTE: should fail on legitimate FORMERR (ex. bad name)
            //
            //  DEVNOTE-LOG: log record creation failure
            //

            DNS_PRINT((
                "ERROR:  failed record create in response!!!\n" ));

            MSG_ASSERT( pMsg, FALSE );
            goto PacketError;
        }

        //
        //  cache record
        //      TTL -- saved as absolute timeout (host byte order)
        //
        //  node and type matching determine if this is FIRST RR in set
        //  or part of continuing RR set
        //

        SET_RR_RANK( prr, rank );

        INLINE_DWORD_FLIP( parseRR.dwTtl, parseRR.dwTtl );

        if ( parseRR.dwTtl < ttlForSet )
        {
            ttlForSet = parseRR.dwTtl;
        }
        DNS_LIST_STRUCT_ADD( listRR, prr );

        //
        //  cache name error
        //  only records in packet should be
        //      - question (already skipped)
        //      - and SOA in authority section
        //      - and possibly A record for SOA primary in additional section
        //
        //  save node to pnodeCurrent, to allow inclusion of SOA response
        //

        if ( fnameError )
        {
            if ( type == DNS_TYPE_SOA &&
                fnameError != NAME_ERROR_ALREADY_CACHED )
            {
                DNS_DEBUG( READ, (
                    "Caching SOA name error for response at %p.\n",
                    pMsg ));
                RR_CacheNameError(
                    pnodeQuestion,
                    pMsg->wQuestionType,
                    pMsg->dwQueryTime,
                    pMsg->Head.Authoritative,
                    pnode,
                    ntohl(prr->Data.SOA.dwMinimumTtl) );

                fnameError = NAME_ERROR_ALREADY_CACHED;
                continue;
            }
            else
            {
                /*
                ASSERT( sectionIndex == ADDITIONAL_SECTION_INDEX
                    || (sectionIndex == AUTHORITY_SECTION_INDEX && type == DNS_TYPE_NS) );
                */

                //
                //  DEVNOTE: catch bogus NAME_ERROR packet?  enforce above ASSERT
                //      and if fails drop to bad packet
                //

                RR_Free( prr );
                return( DNS_ERROR_RCODE_NAME_ERROR );
            }
        }

        //
        //  Check if we are caching an Internet root nameserver. Assume an
        //  NS is an Internet root server if has three name components and 
        //  ends with root-servers.net.
        //

        if ( fcachingRootNs &&
            !g_fUsingInternetRootServers &&
            prr->Data.NS.nameTarget.LabelCount == 3 &&
            prr->Data.NS.nameTarget.Length > g_cchInternetRootNsDomain + 1 &&
            RtlEqualMemory(
                prr->Data.NS.nameTarget.RawName +
                    * ( PUCHAR ) prr->Data.NS.nameTarget.RawName + 1,
                g_InternetRootNsDomain,
                g_cchInternetRootNsDomain ) )
        {
            g_fUsingInternetRootServers = TRUE;
            IF_DEBUG( READ )
            {
                Dbg_DnsMessage(
                    "Found INET root NS while caching this msg",
                    pMsg );
            }
        }
    }   // loop through RRs

    //
    //  Empty auth response: this in an empty auth response if:
    //      - rcode is NO_ERROR, and
    //      - there are zero answer RRs, and
    //      - there is at least one SOA in the auth section
    //

    if ( pMsg->Head.ResponseCode == DNS_RCODE_NO_ERROR &&
        !pMsg->Head.AnswerCount &&
        authSectionSoaCount )
    {
        fisEmptyAuthResponse = TRUE;
    }

    //
    //  All response RRs should now be in database and we've set various
    //  flags to tell us what kind of response we are dealing with.
    //  Decide what to return to caller and perform final processing.
    //

    //
    //  name error
    //  if no-SOA, then didn't cache above
    //  cache name error here with brief timeout to kill off retries
    //
    //  set queries current node to point at name error node;  this allows
    //  SendNameError() function to locate and write cached SOA, with
    //  correct TTL for this node
    //

    if ( fnameError )
    {
        if ( fnameError != NAME_ERROR_ALREADY_CACHED )
        {
            DNS_DEBUG( READ, (
                "Caching non-SOA name error for response at %p.\n",
                pMsg ));
            RR_CacheNameError(
                pnodeQuestion,
                pMsg->wQuestionType,
                pMsg->dwQueryTime,
                pMsg->Head.Authoritative,
                NULL,
                0 );
        }
        pQuery->pnodeCurrent = pnodeQuestion;
        return DNS_ERROR_RCODE_NAME_ERROR;
    }

    //
    //  Empty auth response.
    //

    if ( fisEmptyAuthResponse )
    {
        pQuery->fQuestionCompleted = TRUE;
        STAT_INC( RecurseStats.ResponseEmpty );
        return DNS_INFO_NO_RECORDS;
    }
    else if ( !pMsg->Head.AnswerCount && pMsg->Head.NameServerCount )
    {
        //  Statistics: count delegation responses.
        STAT_INC( RecurseStats.ResponseDelegation );
    }

    //
    //  data outside domain of responding NS makes response unforwardable
    //      - we'll have to write our response from cache and possibly
    //      follow up with another query to replace lost data
    //
    //      - for case of authoritative-empty response, need to go ahead
    //      and send packet, just stripped of offending record
    //

    if ( fnoforwardResponse )
    {
        if ( !forwardTruncatedResponse )
        {
            STAT_INC( RecurseStats.ResponseNonZoneData );
            return( DNS_ERROR_NAME_NOT_IN_ZONE );
        }

        DNS_DEBUG( READ, (
            "Returning truncated auth-empty response %p\n", pMsg ));
        return( ERROR_SUCCESS );
    }

    //
    //  check if need to chase CNAME
    //      - if no "answers" to question type
    //      - then only CNAMEs (bogus answers cause invalid packet error)
    //  then must write records from cache and continue query at CNAME
    //

    if ( pMsg->Head.AnswerCount && !fanswered )
    {
        return( DNS_ERROR_NODE_IS_CNAME );
    }

    return( ERROR_SUCCESS );

    //
    //  Failure conditions.
    //

    InvalidDataError:
    PacketNameError:

    Wire_PacketNameError( pMsg, 0, (WORD)(pch - (PCHAR)&pMsg->Head) );
    status = DNS_ERROR_INVALID_NAME;
    goto ErrorCleanup;

    //  InvalidTypeError:
    PacketError:

    Wire_PacketError( pMsg, 0 );
    status = DNS_ERROR_BAD_PACKET;
    goto ErrorCleanup;

    #if 0
    ServerFailure:
    Wire_ServerFailureProcessingPacket( pMsg, 0 );
    status = DNS_ERROR_RCODE_SERVER_FAILURE;
    goto ErrorCleanup;
    #endif

    ErrorCleanup:

    //  free record
    //  put timeouts on any nodes created

    //
    //  DEVNOTE: leak here of stuff in listRR, if bad record
    //      shouldn't happen on InvalidZone failure, as it takes a new
    //      node to trigger InvalidZone and this would also commit list
    //

    if ( prr )
    {
        RR_Free( prr );
    }
    if ( pnode )
    {
        Timeout_SetTimeoutOnNode( pnode );
    }
    if ( pnodePrevious )
    {
        Timeout_SetTimeoutOnNode( pnodePrevious );
    }
    STAT_INC( RecurseStats.ResponseBadPacket );
    return( status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\rpcw2k.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    w2krpc.c

Abstract:

    Domain Name System (DNS) Server

    Frozen RPC routines for answering queries from W2K clients.

Author:

    Jeff Westhead (jwesth)      October, 2000

Revision History:

--*/


#include "dnssrv.h"


#define MAX_RPC_ZONE_COUNT_DEFAULT  (0x10000)   //  copied from zonerpc.c


//
//  Internal functions
//



VOID
freeRpcServerInfoW2K(
    IN OUT  PDNS_RPC_SERVER_INFO_W2K    pServerInfo
    )
/*++

Routine Description:

    Deep free of DNS_RPC_SERVER_INFO structure.

Arguments:

    None

Return Value:

    None

--*/
{
    if ( !pServerInfo )
    {
        return;
    }

    //
    //  free substructures
    //      - server name
    //      - server IP address array
    //      - listen address array
    //      - forwarders array
    //  then server info itself
    //

    if ( pServerInfo->pszServerName )
    {
        MIDL_user_free( pServerInfo->pszServerName );
    }
    if ( pServerInfo->aipServerAddrs )
    {
        MIDL_user_free( pServerInfo->aipServerAddrs );
    }
    if ( pServerInfo->aipListenAddrs )
    {
        MIDL_user_free( pServerInfo->aipListenAddrs );
    }
    if ( pServerInfo->aipForwarders )
    {
        MIDL_user_free( pServerInfo->aipForwarders );
    }
    if ( pServerInfo->pszDsContainer )
    {
        MIDL_user_free( pServerInfo->pszDsContainer );
    }
    MIDL_user_free( pServerInfo );
}



VOID
freeRpcZoneInfoW2K(
    IN OUT  PDNS_RPC_ZONE_INFO_W2K      pZoneInfo
    )
/*++

Routine Description:

    Deep free of DNS_RPC_ZONE_INFO structure.

Arguments:

    None

Return Value:

    None

--*/
{
    if ( !pZoneInfo )
    {
        return;
    }

    //
    //  free substructures
    //      - name string
    //      - data file string
    //      - secondary IP array
    //      - WINS server array
    //  then zone info itself
    //

    MIDL_user_free( pZoneInfo->pszZoneName );
    MIDL_user_free( pZoneInfo->pszDataFile );
    MIDL_user_free( pZoneInfo->aipMasters );
    MIDL_user_free( pZoneInfo->aipSecondaries );
    MIDL_user_free( pZoneInfo->aipNotify );
    MIDL_user_free( pZoneInfo->aipScavengeServers );
    MIDL_user_free( pZoneInfo );
}



PDNS_RPC_ZONE_INFO_W2K
allocateRpcZoneInfoW2K(
    IN      PZONE_INFO  pZone
    )
/*++

Routine Description:

    Create RPC zone info to return to admin client.

Arguments:

    pZone -- zone

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDNS_RPC_ZONE_INFO_W2K      pzoneInfo;

    pzoneInfo = MIDL_user_allocate_zero( sizeof(DNS_RPC_ZONE_INFO_W2K) );
    if ( !pzoneInfo )
    {
        goto done_failed;
    }

    //
    //  fill in fixed fields
    //

    pzoneInfo->dwZoneType           = pZone->fZoneType;
    pzoneInfo->fReverse             = pZone->fReverse;
    pzoneInfo->fAutoCreated         = pZone->fAutoCreated;
    pzoneInfo->fAllowUpdate         = pZone->fAllowUpdate;
    pzoneInfo->fUseDatabase         = pZone->fDsIntegrated;
    pzoneInfo->fSecureSecondaries   = pZone->fSecureSecondaries;
    pzoneInfo->fNotifyLevel         = pZone->fNotifyLevel;

    pzoneInfo->fPaused              = IS_ZONE_PAUSED(pZone);
    pzoneInfo->fShutdown            = IS_ZONE_SHUTDOWN(pZone);
    pzoneInfo->fUseWins             = IS_ZONE_WINS(pZone);
    pzoneInfo->fUseNbstat           = IS_ZONE_NBSTAT(pZone);

    pzoneInfo->fAging               = pZone->bAging;
    pzoneInfo->dwNoRefreshInterval  = pZone->dwNoRefreshInterval;
    pzoneInfo->dwRefreshInterval    = pZone->dwRefreshInterval;
    pzoneInfo->dwAvailForScavengeTime =
                    pZone->dwAgingEnabledTime + pZone->dwRefreshInterval;

    //
    //  fill in zone name
    //

    if ( ! RpcUtil_CopyStringToRpcBuffer(
                &pzoneInfo->pszZoneName,
                pZone->pszZoneName ) )
    {
        goto done_failed;
    }

    //
    //  database filename
    //

#ifdef FILE_KEPT_WIDE
    if ( ! RpcUtil_CopyStringToRpcBufferEx(
                &pzoneInfo->pszDataFile,
                pZone->pszDataFile,
                TRUE,       // unicode in
                FALSE       // UTF8 out
                ) )
    {
        goto done_failed;
    }
#else
    if ( ! RpcUtil_CopyStringToRpcBuffer(
                &pzoneInfo->pszDataFile,
                pZone->pszDataFile ) )
    {
        goto done_failed;
    }
#endif

    //
    //  master list
    //

    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pzoneInfo->aipMasters,
                pZone->aipMasters ) )
    {
        goto done_failed;
    }

    //
    //  secondary and notify lists
    //

    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pzoneInfo->aipSecondaries,
                pZone->aipSecondaries ) )
    {
        goto done_failed;
    }
    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pzoneInfo->aipNotify,
                pZone->aipNotify ) )
    {
        goto done_failed;
    }

    //
    //  scavenging servers
    //

    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pzoneInfo->aipScavengeServers,
                pZone->aipScavengeServers ) )
    {
        goto done_failed;
    }

    IF_DEBUG( RPC )
    {
        DnsDbg_RpcZoneInfo_W2K(
            "RPC zone info leaving allocateRpcZoneInfo():\n",
            pzoneInfo );
    }
    return( pzoneInfo );

done_failed:

    //  free newly allocated info block

    freeRpcZoneInfoW2K( pzoneInfo );
    return( NULL );
}



PDNS_RPC_ZONE_W2K
allocateRpcZoneW2K(
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Allocate \ create RPC zone struct for zone.

Arguments:

    pZone -- zone to create RPC zone struct for

Return Value:

    RPC zone struct.
    NULL on allocation failure.

--*/
{
    PDNS_RPC_ZONE_W2K       prpcZone;

    DNS_DEBUG( RPC2, ("allocateRpcZoneW2K( %s )\n", pZone->pszZoneName ));

    //  allocate and attach zone

    prpcZone = (PDNS_RPC_ZONE_W2K) MIDL_user_allocate( sizeof(DNS_RPC_ZONE_W2K) );
    if ( !prpcZone )
    {
        return( NULL );
    }

    //  copy zone name

    prpcZone->pszZoneName = Dns_StringCopyAllocate_W(
                                    pZone->pwsZoneName,
                                    0 );
    if ( !prpcZone->pszZoneName )
    {
        MIDL_user_free( prpcZone );
        return( NULL );
    }

    //  set type and flags

    prpcZone->ZoneType = (UCHAR) pZone->fZoneType;
    prpcZone->Version  = DNS_RPC_VERSION;

    *(PDWORD) &prpcZone->Flags = 0;

    if ( pZone->fPaused )
    {
        prpcZone->Flags.Paused = TRUE;
    }
    if ( pZone->fShutdown )
    {
        prpcZone->Flags.Shutdown = TRUE;
    }
    if ( pZone->fReverse )
    {
        prpcZone->Flags.Reverse = TRUE;
    }
    if ( pZone->fAutoCreated )
    {
        prpcZone->Flags.AutoCreated = TRUE;
    }
    if ( pZone->fDsIntegrated )
    {
        prpcZone->Flags.DsIntegrated = TRUE;
    }
    if ( pZone->bAging )
    {
        prpcZone->Flags.Aging = TRUE;
    }

    //  two bits reserved for update

    prpcZone->Flags.Update = pZone->fAllowUpdate;


    IF_DEBUG( RPC2 )
    {
        DnsDbg_RpcZone_W2K(
            "New zone for RPC: ",
            prpcZone );
    }
    return( prpcZone );
}   //  allocateRpcZoneW2K



VOID
freeZoneListW2K(
    IN OUT  PDNS_RPC_ZONE_LIST_W2K      pZoneList
    )
/*++

Routine Description:

    Deep free of list of DNS_RPC_ZONE structures.

Arguments:

    pZoneList -- ptr RPC_ZONE_LIST structure to free

Return Value:

    None

--*/
{
    DWORD               i;
    PDNS_RPC_ZONE_W2K   pzone;

    for( i=0; i< pZoneList->dwZoneCount; i++ )
    {
        //  zone name is only sub-structure

        pzone = pZoneList->ZoneArray[i];
        MIDL_user_free( pzone->pszZoneName );
        MIDL_user_free( pzone );
    }

    MIDL_user_free( pZoneList );
}   //  freeZoneListW2K


//
//  External functions
//



DNS_STATUS
W2KRpc_GetServerInfo(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeId,
    OUT     PVOID *     ppData
    )
/*++

Routine Description:

    Get server info.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDNS_RPC_SERVER_INFO_W2K    pinfo;

    DNS_DEBUG( RPC, (
        "W2KRpc_GetServerInfo( dwClientVersion=0x%lX)\n",
        dwClientVersion ));

    //
    //  allocate server info buffer
    //

    pinfo = MIDL_user_allocate_zero( sizeof(DNS_RPC_SERVER_INFO_W2K) );
    if ( !pinfo )
    {
        DNS_PRINT(( "ERROR:  unable to allocate SERVER_INFO block.\n" ));
        goto DoneFailed;
    }

    //
    //  fill in fixed fields
    //

    pinfo->dwVersion                = SrvCfg_dwVersion;
    pinfo->dwRpcProtocol            = SrvCfg_dwRpcProtocol;
    pinfo->dwLogLevel               = SrvCfg_dwLogLevel;
    pinfo->dwDebugLevel             = SrvCfg_dwDebugLevel;
    pinfo->dwNameCheckFlag          = SrvCfg_dwNameCheckFlag;
    pinfo->cAddressAnswerLimit      = SrvCfg_cAddressAnswerLimit;
    pinfo->dwRecursionRetry         = SrvCfg_dwRecursionRetry;
    pinfo->dwRecursionTimeout       = SrvCfg_dwRecursionTimeout;
    pinfo->dwForwardTimeout         = SrvCfg_dwForwardTimeout;
    pinfo->dwMaxCacheTtl            = SrvCfg_dwMaxCacheTtl;
    pinfo->dwDsPollingInterval      = SrvCfg_dwDsPollingInterval;
    pinfo->dwScavengingInterval     = SrvCfg_dwScavengingInterval;
    pinfo->dwDefaultRefreshInterval     = SrvCfg_dwDefaultRefreshInterval;
    pinfo->dwDefaultNoRefreshInterval   = SrvCfg_dwDefaultNoRefreshInterval;

    //  boolean flags

    pinfo->fBootMethod              = (BOOLEAN) SrvCfg_fBootMethod;
    pinfo->fAdminConfigured         = (BOOLEAN) SrvCfg_fAdminConfigured;
    pinfo->fAllowUpdate             = (BOOLEAN) SrvCfg_fAllowUpdate;
    pinfo->fAutoReverseZones        = (BOOLEAN) ! SrvCfg_fNoAutoReverseZones;
    pinfo->fAutoCacheUpdate         = (BOOLEAN) SrvCfg_fAutoCacheUpdate;

    pinfo->fSlave                   = (BOOLEAN) SrvCfg_fSlave;
    pinfo->fForwardDelegations      = (BOOLEAN) SrvCfg_fForwardDelegations;
    pinfo->fNoRecursion             = (BOOLEAN) SrvCfg_fNoRecursion;
    pinfo->fSecureResponses         = (BOOLEAN) SrvCfg_fSecureResponses;
    pinfo->fRoundRobin              = (BOOLEAN) SrvCfg_fRoundRobin;
    pinfo->fLocalNetPriority        = (BOOLEAN) SrvCfg_fLocalNetPriority;
    pinfo->fBindSecondaries         = (BOOLEAN) SrvCfg_fBindSecondaries;
    pinfo->fWriteAuthorityNs        = (BOOLEAN) SrvCfg_fWriteAuthorityNs;

    pinfo->fStrictFileParsing       = (BOOLEAN) SrvCfg_fStrictFileParsing;
    pinfo->fLooseWildcarding        = (BOOLEAN) SrvCfg_fLooseWildcarding;
    pinfo->fDefaultAgingState       = (BOOLEAN) SrvCfg_fDefaultAgingState;


    //  DS available

    //pinfo->fDsAvailable = SrvCfg_fDsAvailable;
    pinfo->fDsAvailable     = (BOOLEAN) Ds_IsDsServer();

#if DBG
    //  if Test5 set, fake DS available
    //  this is debug only for easy failure testing

    if ( SrvCfg_fTest8 )
    {
        pinfo->fDsAvailable = TRUE;
    }
#endif

    //
    //  server name
    //

    if ( ! RpcUtil_CopyStringToRpcBuffer(
                &pinfo->pszServerName,
                SrvCfg_pszServerName ) )
    {
        DNS_PRINT(( "ERROR:  unable to copy SrvCfg_pszServerName.\n" ));
        goto DoneFailed;
    }

    //
    //  path to DNS container in DS
    //  unicode since Marco will build unicode LDAP paths
    //

    if ( g_pwszDnsContainerDN )
    {
        pinfo->pszDsContainer = (LPWSTR) Dns_StringCopyAllocate(
                                            (LPSTR) g_pwszDnsContainerDN,
                                            0,
                                            DnsCharSetUnicode,   // unicode in
                                            DnsCharSetUnicode    // unicode out
                                            );
        if ( ! pinfo->pszDsContainer )
        {
            DNS_PRINT(( "ERROR:  unable to copy g_pszDsDnsContainer.\n" ));
            goto DoneFailed;
        }
    }

    //
    //  server IP address list
    //  listening IP address list
    //

    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pinfo->aipServerAddrs,
                g_ServerAddrs ) )
    {
        goto DoneFailed;
    }

    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pinfo->aipListenAddrs,
                SrvCfg_aipListenAddrs ) )
    {
        goto DoneFailed;
    }

    //
    //  Forwarders list
    //

    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pinfo->aipForwarders,
                SrvCfg_aipForwarders ) )
    {
        goto DoneFailed;
    }

    //
    //  set ptr
    //

    *(PDNS_RPC_SERVER_INFO_W2K *)ppData = pinfo;
    *pdwTypeId = DNSSRV_TYPEID_SERVER_INFO_W2K;

    IF_DEBUG( RPC )
    {
        DnsDbg_RpcServerInfo_W2K(
            "GetServerInfo return block",
            pinfo );
    }
    return( ERROR_SUCCESS );

DoneFailed:

    //  free newly allocated info block

    if ( pinfo )
    {
        freeRpcServerInfoW2K( pinfo );
    }
    return( DNS_ERROR_NO_MEMORY );
}


DNS_STATUS
W2KRpc_GetZoneInfo(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeId,
    OUT     PVOID *     ppData
    )
/*++

Routine Description:

    Get zone info.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDNS_RPC_ZONE_INFO_W2K      pinfo;

    DNS_DEBUG( RPC, (
        "W2KRpc_GetZoneInfo()\n"
        "  client ver       = 0x%08lX"
        "  zone name        = %s\n",
        dwClientVersion,
        pZone->pszZoneName ));

    //
    //  allocate\create zone info
    //

    pinfo = allocateRpcZoneInfoW2K( pZone );
    if ( !pinfo )
    {
        DNS_PRINT(( "ERROR: unable to allocate DNS_RPC_ZONE_INFO block.\n" ));
        goto DoneFailed;
    }

    //  set return ptrs

    *(PDNS_RPC_ZONE_INFO_W2K *)ppData = pinfo;
    *pdwTypeId = DNSSRV_TYPEID_ZONE_INFO_W2K;

    IF_DEBUG( RPC )
    {
        DnsDbg_RpcZoneInfo_W2K(
            "GetZoneInfo return block (W2K)",
            pinfo );
    }
    return( ERROR_SUCCESS );

DoneFailed:

    //  free newly allocated info block

    return( DNS_ERROR_NO_MEMORY );
}



DNS_STATUS
W2KRpc_EnumZones(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    )
/*++

Routine Description:

    Enumerate zones.

    Note this is a ComplexOperation in RPC dispatch sense.

Arguments:

    None

Return Value:

    None

--*/
{
    PZONE_INFO              pzone = NULL;
    DWORD                   count = 0;
    PDNS_RPC_ZONE_W2K       prpcZone;
    DNS_STATUS              status;
    PDNS_RPC_ZONE_LIST_W2K  pzoneList;

    DNS_DEBUG( RPC, (
        "W2KRpc_EnumZones():\n"
        "\tFilter = %08lx\n",
        (ULONG_PTR) pDataIn ));

    //
    //  allocate zone enumeration block
    //  by default allocate space for 64k zones, if go over this we do
    //  a huge reallocation
    //

    pzoneList = (PDNS_RPC_ZONE_LIST_W2K)
                    MIDL_user_allocate(
                        sizeof(DNS_RPC_ZONE_LIST_W2K) +
                        sizeof(PDNS_RPC_ZONE_W2K) * MAX_RPC_ZONE_COUNT_DEFAULT );
    IF_NOMEM( !pzoneList )
    {
        return( DNS_ERROR_NO_MEMORY );
    }

    //
    //  add all zones that pass filter
    //

    while ( pzone = Zone_ListGetNextZoneMatchingFilter( pzone, (DWORD)(ULONG_PTR)pDataIn ) )
    {
        //  create RPC zone struct for zone
        //  add to list, keep count

        prpcZone = allocateRpcZoneW2K( pzone );
        IF_NOMEM( !prpcZone )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Failed;
        }
        pzoneList->ZoneArray[count] = prpcZone;
        count++;

        //  check against max count
        //
        //  DEVNOTE: reallocate if more than 64K zones

        if ( count >= MAX_RPC_ZONE_COUNT_DEFAULT )
        {
            break;
        }
    }

    //  set return count
    //  set returned type
    //  return enumeration

    pzoneList->dwZoneCount = count;

    *( PDNS_RPC_ZONE_LIST_W2K * ) ppDataOut = pzoneList;
    *pdwTypeOut = DNSSRV_TYPEID_ZONE_LIST_W2K;

    IF_DEBUG( RPC )
    {
        DnsDbg_RpcZoneList_W2K(
            "Leaving W2KRpc_EnumZones() zone list sent:",
            pzoneList );
    }
    return( ERROR_SUCCESS );

Failed:

    DNS_PRINT((
        "W2KRpc_EnumZones(): failed\n"
        "\tstatus       = %p\n",
        status ));

    pzoneList->dwZoneCount = count;
    freeZoneListW2K( pzoneList );
    return( status );
}   //  W2KRpc_EnumZones


//
//  End of w2krpc.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\rrds.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    rrds.c

Abstract:

    Domain Name System (DNS) Server

    Routines to read and write records from DS.

Author:

    Jim Gilroy (jamesg)     March 1997

Revision History:

--*/


#include "dnssrv.h"



//
//  Record validation routines.
//

DNS_STATUS
AValidate(
    IN      PDB_RECORD      pRR,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Validate SRV record.

Arguments:

    pRR - ptr to database record

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //  data length check

    if ( wDataLength != SIZEOF_IP_ADDRESS )
    {
        return( DNS_ERROR_INVALID_DATA );
    }
    return( ERROR_SUCCESS );
}



DNS_STATUS
AaaaValidate(
    IN      PDB_RECORD      pRR,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Validate SRV record.

Arguments:

    pRR - ptr to database record

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //  data length check

    if ( wDataLength != sizeof(IP6_ADDRESS) )
    {
        return( DNS_ERROR_INVALID_DATA );
    }
    return( ERROR_SUCCESS );
}



DNS_STATUS
PtrValidate(
    IN      PDB_RECORD      pRR,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Validate SRV record.

Arguments:

    pRR - ptr to database record

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //  data length check
    //      - must be at least one

    if ( wDataLength < MIN_PTR_SIZE )
    {
        return( DNS_ERROR_INVALID_DATA );
    }

    //  PTR target host

    if ( !Name_ValidateDbaseName( &pRR->Data.PTR.nameTarget ) )
    {
        return( DNS_ERROR_INVALID_NAME );
    }
    return( ERROR_SUCCESS );
}



DNS_STATUS
SoaValidate(
    IN      PDB_RECORD      pRR,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Validate SOA record.

Arguments:

    pRR - ptr to database record

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_NAME    pname;

    //  data length check
    //      - must be at least one

    if ( wDataLength < MIN_SOA_SIZE )
    {
        DNS_DEBUG( ANY, ( "Validation of SOA failed -- invalid size!\n" ));
        return( DNS_ERROR_INVALID_DATA );
    }

    //  primary server
    //  zone admin

    pname = &pRR->Data.SOA.namePrimaryServer;
    if ( !Name_ValidateDbaseName( pname ) )
    {
        DNS_DEBUG( ANY, ( "Validation of SOA failed -- invalid primary!\n" ));
        return( DNS_ERROR_INVALID_NAME );
    }

    pname = (PDB_NAME) Name_SkipDbaseName( pname );
    if ( !Name_ValidateDbaseName( pname ) )
    {
        DNS_DEBUG( ANY, ( "Validation of SOA failed -- invalid admin name!\n" ));
        return( DNS_ERROR_INVALID_NAME );
    }

    return( ERROR_SUCCESS );
}



DNS_STATUS
MinfoValidate(
    IN      PDB_RECORD      pRR,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Validate MINFO or RP record.

Arguments:

    pRR - ptr to database record

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_NAME    pname;

    //  data length check
    //      - must be at least one

    if ( wDataLength < MIN_MINFO_SIZE )
    {
        return( DNS_ERROR_INVALID_DATA );
    }

    //  mailbox
    //  errors mailbox

    pname = &pRR->Data.MINFO.nameMailbox;
    if ( !Name_ValidateDbaseName( pname ) )
    {
        return( DNS_ERROR_INVALID_NAME );
    }

    pname = (PDB_NAME) Name_SkipDbaseName( pname );
    if ( !Name_ValidateDbaseName( pname ) )
    {
        return( DNS_ERROR_INVALID_NAME );
    }

    return( ERROR_SUCCESS );
}



DNS_STATUS
MxValidate(
    IN      PDB_RECORD      pRR,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Validate SRV record.

Arguments:

    pRR - ptr to database record

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //  data length check
    //      - must be at least one

    if ( wDataLength < MIN_MX_SIZE )
    {
        return( DNS_ERROR_INVALID_DATA );
    }

    //  MX exhange

    if ( !Name_ValidateDbaseName( &pRR->Data.MX.nameExchange ) )
    {
        return( DNS_ERROR_INVALID_NAME );
    }
    return( ERROR_SUCCESS );
}



DNS_STATUS
SrvValidate(
    IN      PDB_RECORD      pRR,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Validate SRV record.

Arguments:

    pRR - ptr to database record

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //  data length check
    //      - must be at least one

    if ( wDataLength < MIN_SRV_SIZE )
    {
        return( DNS_ERROR_INVALID_DATA );
    }

    //  SRV target host

    if ( !Name_ValidateDbaseName( & pRR->Data.SRV.nameTarget ) )
    {
        return( DNS_ERROR_INVALID_NAME );
    }
    return( ERROR_SUCCESS );
}



DNS_STATUS
WinsValidate(
    IN      PDB_RECORD      pRR,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Validate WINS record.

Arguments:

    pRR - ptr to database record

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //  data length check

    if ( wDataLength < MIN_WINS_SIZE  ||
        wDataLength != SIZEOF_WINS_FIXED_DATA
                + (pRR->Data.WINS.cWinsServerCount * sizeof(IP_ADDRESS)) )
    {
        return( DNS_ERROR_INVALID_DATA );
    }

    //  validity check flag?

    return( ERROR_SUCCESS );
}



DNS_STATUS
NbstatValidate(
    IN      PDB_RECORD      pRR,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Validate WINSR record.

Arguments:

    pRR - ptr to database record

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //  data length check
    //      - must be at least one

    if ( wDataLength < MIN_NBSTAT_SIZE )
    {
        return( DNS_ERROR_INVALID_DATA );
    }

    //  DEVNOTE: validity check flag

    //
    //  NBSTAT domain
    //

    if ( !Name_ValidateDbaseName( & pRR->Data.WINSR.nameResultDomain ) )
    {
        return( DNS_ERROR_INVALID_NAME );
    }
    return( ERROR_SUCCESS );
}



DNS_STATUS
UnknownValidate(
    IN      PDB_RECORD      pRR,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Validate unknown record.

Arguments:

    pRR - ptr to database record

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //  no knowledge about record so -- success

    DNS_DEBUG( DS, (
        "WARNING:  Validating record of unknown type %d\n",
        pRR->wType ));

    return( ERROR_SUCCESS );
}



DNS_STATUS
TxtValidate(
    IN      PDB_RECORD      pRR,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Validate TXT type record.

Arguments:

    pRR - ptr to database record

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //
    //  DEVNOTE: TEXT types validation.
    //

    return( ERROR_SUCCESS );
}



//
//  Record validation routines
//  Use these after read from DS.
//

RR_VALIDATE_FUNCTION  RecordValidateTable[] =
{
    UnknownValidate,    //  ZERO

    AValidate,          //  A
    PtrValidate,        //  NS
    PtrValidate,        //  MD
    PtrValidate,        //  MF
    PtrValidate,        //  CNAME
    SoaValidate,        //  SOA
    PtrValidate,        //  MB
    PtrValidate,        //  MG
    PtrValidate,        //  MR
    NULL,               //  NULL
    NULL,               //  WKS
    PtrValidate,        //  PTR
    TxtValidate,        //  HINFO
    MinfoValidate,      //  MINFO
    MxValidate,         //  MX
    TxtValidate,        //  TXT
    MinfoValidate,      //  RP
    MxValidate,         //  AFSDB
    TxtValidate,        //  X25
    TxtValidate,        //  ISDN
    MxValidate,         //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    NULL,               //  SIG
    NULL,               //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    AaaaValidate,       //  AAAA
    NULL,               //  LOC
    NULL,               //  NXT
    NULL,               //  31
    NULL,               //  32
    SrvValidate,        //  SRV
    NULL,               //  ATMA
    //AtmaValidate,       //  ATMA
    NULL,               //  35
    NULL,               //  36
    NULL,               //  37
    NULL,               //  38
    NULL,               //  39
    NULL,               //  40
    NULL,               //  OPT
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //  note these follow, but require OFFSET_TO_WINS_RR subtraction
    //  from actual type value

    WinsValidate,       //  WINS
    NbstatValidate      //  WINSR
};



PDB_RECORD
Ds_CreateRecordFromDsRecord(
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pNodeOwner,
    IN      PDS_RECORD      pDsRecord
    )
/*++

Routine Description:

    Create resource record from DS data.

Arguments:

    pZone       -- zone context, used to lookup non-FQDN names

    pNodeOwner  -- RR owner node

    pDsRecord   -- DS record

Return Value:

    Ptr to new record -- if successful
    NULL on error, error status from GetLastError().

--*/
{
    RR_VALIDATE_FUNCTION    pvalidateFunction;
    PDB_RECORD      prr;
    DNS_STATUS      status = ERROR_SUCCESS;
    WORD            type;
    WORD            dataLength;
    UCHAR           version;


    ASSERT( pNodeOwner && pZone && pDsRecord );

    version = pDsRecord->Version;
    if ( version != DS_NT5_RECORD_VERSION )
    {
        return( NULL );
    }

    type= pDsRecord->wType;
    dataLength= pDsRecord->wDataLength;

    IF_DEBUG( DS2 )
    {
        DNS_PRINT((
            "Creating RR type %s (%d) from DS record.\n",
            DnsRecordStringForType( type ),
            type ));
        Dbg_DsRecord(
            "Record from DS being loaded",
            pDsRecord );
    }

    //
    //  allocate record
    //

    prr = RR_AllocateEx( dataLength, MEMTAG_RECORD_DS );
    IF_NOMEM( !prr )
    {
        ASSERT( FALSE );
        return( NULL );
    }

    //
    //  fix up header
    //

    prr->wType          = type;
    prr->wDataLength    = dataLength;
    prr->dwTtlSeconds   = pDsRecord->dwTtlSeconds;
    prr->dwTimeStamp    = pDsRecord->dwTimeStamp;

    //
    //  copy record data
    //

    RtlCopyMemory(
        & prr->Data,
        & pDsRecord->Data,
        dataLength );

    //
    //  dispatch to validate record
    //

    pvalidateFunction = (RR_VALIDATE_FUNCTION)
                        RR_DispatchFunctionForType(
                            RecordValidateTable,
                            type );
    if ( !pvalidateFunction )
    {
        ASSERT( FALSE );
        status = DNS_ERROR_RCODE_SERVER_FAILURE;
        goto Failed;
    }

    status = pvalidateFunction( prr, dataLength );

    if ( status != ERROR_SUCCESS )
    {
        if ( status == DNS_INFO_ADDED_LOCAL_WINS )
        {
            goto FailedOk;
        }
        DNS_PRINT((
            "ERROR:  RecordValidateRoutine failure for record type %d.\n\n\n",
            type ));
        goto Failed;
    }

    //
    //  outside zone check
    //
    //  note:  RANK reset in RR_AddToNode() or RR_AddUpdateToNode() functions
    //
    //  note rank setting here isn't good enough anyway because do not
    //  know final status of node;  example adding delegation NS takes
    //  place INSIDE the zone when we first do it;  only on ADD does
    //  the node become desired delegation node
    //
    //  only sure way of catching all outside zone data is to do a check
    //  post-load;  then we can catch ALL records outside the zone and verify
    //  that they correspond to NS hosts in the zone and are of the proper type;
    //  this is tedious and unnecessary as random outside the zone data has
    //  no effect and will not be written on file write back
    //

    if ( IS_ZONE_CACHE(pZone) )
    {
        SET_RANK_ROOT_HINT(prr);
    }
    else
    {
        UCHAR rank = RANK_ZONE;

        if ( !IS_AUTH_NODE(pNodeOwner) )
        {
            DNS_DEBUG( DS2, (
                "Read DS node outside zone %s (%p).\n"
                "\tzone root        = %p\n"
                "\tRR type          = %d\n"
                "\tnode ptr         = %p\n"
                "\tnode zone ptr    = %p\n",
                pZone->pszZoneName,
                pZone,
                pZone->pZoneRoot,
                type,
                pNodeOwner,
                pNodeOwner->pZone ));

            if ( type == DNS_TYPE_NS )
            {
                if ( !IS_DELEGATION_NODE(pNodeOwner) )
                {
                    DNS_PRINT(( "NS node outside zone -- ignoring.\n" ));
                    status = DNS_ERROR_INVALID_NAME;
                    goto IgnoreableError;
                }
                rank = RANK_NS_GLUE;
            }
            else if ( IS_SUBZONE_TYPE(type) )
            {
                //  see note in dfread about outside zone data

                rank = RANK_GLUE;
            }
            else
            {
                DNS_PRINT(( "Record node outside zone -- ignoring.\n" ));
                status = DNS_ERROR_INVALID_NAME;
                goto IgnoreableError;
            }
        }
        SET_RR_RANK( prr, rank );
    }

#if 0

Success:

    //
    //  save as example of how we'd handle DS versioning
    //  currently only one DS version -- no need to save
    //
    //  return new record
    //  set zone version to highest record version
    //

    if ( pZone->ucDsRecordVersion < version )
    {
        DNS_DEBUG( DS, (
            "DS Zone %s, reset from DS version %d to %d\n",
            pZone->pszZoneName,
            pZone->ucDsRecordVersion,
            version ));
        pZone->ucDsRecordVersion = version;
    }
#endif

    return( prr );


IgnoreableError:

    //  DEVNOTE-LOG: log when record outside zone and not proper glue
    //      note this can happen if zone boundaries change
    //
    //  DEVNOTE: eliminate outside zone data from DS?
    //
    //  DEVNOTE: include type in logging

Failed:

    {
        PCHAR   pszargs[2];
        CHAR    sznodeName[ DNS_MAX_NAME_BUFFER_LENGTH ];

        Name_PlaceFullNodeNameInBuffer(
            sznodeName,
            sznodeName + DNS_MAX_NAME_BUFFER_LENGTH,
            pNodeOwner );

        pszargs[0] = sznodeName;
        pszargs[1] = pZone->pszZoneName;

        DNS_LOG_EVENT(
            DNS_EVENT_DS_RECORD_LOAD_FAILED,
            2,
            pszargs,
            EVENTARG_ALL_UTF8,
            status );
    }
    if ( prr )
    {
        RR_Free( prr );
    }

FailedOk:

    SetLastError( status );
    return( NULL );
}


//
//  End rrds.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\rrfile.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    rrfile.c

Abstract:

    Domain Name System (DNS) Server

    Routines to write resource records to database file.

Author:

    Jim Gilroy (jamesg)     August 25, 1995

Revision History:

--*/


#include "dnssrv.h"


#define DNSSEC_ERROR_NOSTRING       (-1)
#define DNSSEC_BAD_TIME             (-1)



//
//  Read records from file routines
//

DNS_STATUS
AFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process A record.

Arguments:

    pRR - ptr to database record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD  prr;

    //
    //  A <IP address string>
    //

    if ( Argc != 1 )
    {
        return ( Argc > 1 )
                ? DNSSRV_ERROR_EXCESS_TOKEN
                : DNSSRV_ERROR_MISSING_TOKEN;
    }
    prr = RR_Allocate( (WORD)SIZEOF_IP_ADDRESS );
    IF_NOMEM( !prr )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    pParseInfo->pRR = prr;

    if ( ! File_ParseIpAddress(
                & prr->Data.A.ipAddress,
                Argv,
                pParseInfo
                ) )
    {
        return( DNSSRV_PARSING_ERROR );
    }

    return( ERROR_SUCCESS );
}



DNS_STATUS
PtrFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process PTR compatible record.
    Includes: PTR, NS, CNAME, MB, MR, MG, MD, MF

Arguments:

    pRR - ptr to database record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr = NULL;
    COUNT_NAME      countName;
    DNS_STATUS      status;

    PZONE_INFO  pzone;
    PDB_NODE    pnodeOwner;

    //
    //  PTR <DNS name>
    //

    if ( Argc != 1 )
    {
        return ( Argc > 1 )
                ? DNSSRV_ERROR_EXCESS_TOKEN
                : DNSSRV_ERROR_MISSING_TOKEN;
    }

    status = File_ReadCountNameFromToken(
                & countName,
                pParseInfo,
                &Argv[0] );
    if ( status != ERROR_SUCCESS )
    {
        return( DNSSRV_PARSING_ERROR );
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD) Name_LengthDbaseNameFromCountName(&countName) );
    IF_NOMEM( !prr )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    pParseInfo->pRR = prr;

    //
    //  write target name
    //

    Name_CopyCountNameToDbaseName(
        & prr->Data.PTR.nameTarget,
        & countName );

    return( ERROR_SUCCESS );
}



DNS_STATUS
SoaFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process SOA RR.

Arguments:

    pRR - ptr to database record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PZONE_INFO      pzone = pParseInfo->pZone;
    INT             i;
    PDWORD          pdword;     // ptr to next numeric SOA field
    DNS_STATUS      status;
    COUNT_NAME      countNamePrimary;
    COUNT_NAME      countNameAdmin;
    PDB_RECORD      prr;
    PDB_NAME        pname;

    //
    //  check SOA validity
    //      - first record in zone file
    //      - attached to zone root

    if ( pParseInfo->fParsedSoa  ||
            ( pzone->pZoneRoot != pParseInfo->pnodeOwner &&
            pzone->pLoadZoneRoot != pParseInfo->pnodeOwner ) )
    {
        File_LogFileParsingError(
            DNS_EVENT_INVALID_SOA_RECORD,
            pParseInfo,
            NULL );
        return( DNSSRV_PARSING_ERROR );
    }
    if ( Argc != 7 )
    {
        return ( Argc > 7 )
                ? DNSSRV_ERROR_EXCESS_TOKEN
                : DNSSRV_ERROR_MISSING_TOKEN;
    }

    //
    //  create primary name server
    //

    status = File_ReadCountNameFromToken(
                & countNamePrimary,
                pParseInfo,
                &Argv[0] );
    if ( status != ERROR_SUCCESS )
    {
        return( DNSSRV_PARSING_ERROR );
    }
    NEXT_TOKEN( Argc, Argv );

    //  create zone admin name

    status = File_ReadCountNameFromToken(
                & countNameAdmin,
                pParseInfo,
                &Argv[0] );
    if ( status != ERROR_SUCCESS )
    {
        return( DNSSRV_PARSING_ERROR );
    }
    NEXT_TOKEN( Argc, Argv );

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD) ( SIZEOF_SOA_FIXED_DATA +
                                Name_LengthDbaseNameFromCountName(&countNamePrimary) +
                                Name_LengthDbaseNameFromCountName(&countNameAdmin) ) );
    IF_NOMEM( !prr )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    pParseInfo->pRR = prr;

    //
    //  convert numeric fields
    //      - store in netorder for fast access to wire
    //

    pdword = & prr->Data.SOA.dwSerialNo;

    while( Argc )
    {
        if ( ! File_ParseDwordToken(
                    pdword,
                    Argv,
                    pParseInfo ) )
        {
            return( DNSSRV_PARSING_ERROR );
        }
        *pdword = htonl( *pdword );
        pdword++;
        NEXT_TOKEN( Argc, Argv );
    }

    //
    //  write names
    //      - primary server name
    //      - zone admin name
    //

    pname = &prr->Data.SOA.namePrimaryServer;

    Name_CopyCountNameToDbaseName(
        pname,
        & countNamePrimary );

    pname = (PDB_NAME) Name_SkipDbaseName( pname );

    Name_CopyCountNameToDbaseName(
        pname,
        & countNameAdmin );

    //
    //  update parse info to indicate successful SOA load
    //

    pParseInfo->fParsedSoa = TRUE;
    pParseInfo->dwTtlDirective =
        pParseInfo->dwDefaultTtl =
        prr->Data.SOA.dwMinimumTtl;

    return( ERROR_SUCCESS );
}



DNS_STATUS
MxFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process MX compatible RR.

Arguments:

    pRR - ptr to database record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;
    DWORD           dwtemp;
    COUNT_NAME      countName;
    DNS_STATUS      status;

    //
    //  MX  <preference> <exchange DNS name>
    //

    if ( Argc != 2 )
    {
        return ( Argc > 2 )
                ? DNSSRV_ERROR_EXCESS_TOKEN
                : DNSSRV_ERROR_MISSING_TOKEN;
    }

    //
    //  MX preference
    //  RT preference
    //  AFSDB subtype
    //

    if ( ! File_ParseDwordToken(
                & dwtemp,
                Argv,
                pParseInfo ) )
    {
        return( DNSSRV_PARSING_ERROR );
    }
    if ( dwtemp > 0xffff )
    {
        File_LogFileParsingError(
            DNS_EVENT_INVALID_PREFERENCE,
            pParseInfo,
            Argv );
        pParseInfo->fErrorCode = DNSSRV_ERROR_INVALID_TOKEN;
        pParseInfo->fErrorEventLogged = TRUE;
        return( DNSSRV_PARSING_ERROR );
    }
    NEXT_TOKEN( Argc, Argv );

    //
    //  MX mail exchange
    //  RT intermediate exchange
    //  AFSDB hostname
    //      - do this first to determine record length
    //

    status = File_ReadCountNameFromToken(
                & countName,
                pParseInfo,
                &Argv[0] );
    if ( status != ERROR_SUCCESS )
    {
        return( DNSSRV_PARSING_ERROR );
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD)(SIZEOF_MX_FIXED_DATA +
                            Name_LengthDbaseNameFromCountName(&countName)) );
    IF_NOMEM( !prr )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    pParseInfo->pRR = prr;

    //  set preference

    prr->Data.MX.wPreference = htons( (WORD)dwtemp );

    //
    //  MX mail exchange
    //  RT intermediate exchange
    //  AFSDB hostname
    //

    Name_CopyCountNameToDbaseName(
        & prr->Data.MX.nameExchange,
        & countName );

    return( ERROR_SUCCESS );
}



DNS_STATUS
TxtFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process Text (TXT) RR.

Arguments:

    pRR - NULL ptr to database record, since this record type has variable
        length, this routine allocates its own record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD  prr;
    PCHAR       pch;
    DWORD       cch;
    DWORD       index;
    DWORD       dataLength = 0;
    DWORD       minTokenCount = 1;
    DWORD       maxTokenCount;

    DNS_DEBUG( PARSE2, (
        "TxtFileRead() type=%d, argc=%d\n",
        pParseInfo->wType,
        Argc ));

    //
    //  verify correct number of strings for type
    //

    if ( ! Dns_IsStringCountValidForTextType(
                pParseInfo->wType,
                (WORD)Argc ) )
    {
        //  DEVNOTE: nice to be more specific here
        return( DNSSRV_ERROR_INVALID_TOKEN );
        //return( DNSSRV_ERROR_MISSING_TOKEN );
        //return( DNSSRV_ERROR_EXCESS_TOKEN );
    }

    //  sum text string length
    //
    //  note:  we won't bother to catch space errors here, as quote expansion
    //      may reduce length;
    //      just don't worry about wasting space in allocation

    for ( index=0; index<Argc; index++ )
    {
        cch = Argv[index].cchLength;
#if 0
        if ( cch > DNS_MAX_TEXT_STRING_LENGTH )
        {
            File_LogFileParsingError(
                DNS_EVENT_TEXT_STRING_TOO_LONG,
                pParseInfo,
                & Argv[index] );
            return( DNSSRV_PARSING_ERROR );
        }
#endif
        dataLength += cch;
        dataLength++;
    }
#if 0
    if ( dataLength > MAXWORD )
    {
        File_LogFileParsingError(
            DNS_EVENT_TEXT_STRING_TOO_LONG,
            pParseInfo,
            Argv );
        return( DNSSRV_PARSING_ERROR );
    }
#endif

    //
    //  allocate
    //

    prr = RR_Allocate( (WORD)dataLength );
    IF_NOMEM( !prr )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    pParseInfo->pRR = prr;

    //  fill in text data
    //      need to special case zero length strings as
    //      cch=zero will cause pchToken to be taken as SZ string

    pch = prr->Data.TXT.chData;

    while( Argc )
    {
        cch = Argv->cchLength;
        if ( cch == 0 )
        {
            *pch++ = 0;
        }
        else
        {
            pch = File_CopyFileTextData(
                    pch,
                    dataLength,
                    Argv->pchToken,
                    cch,
                    TRUE );
            if ( !pch )
            {
                File_LogFileParsingError(
                    DNS_EVENT_TEXT_STRING_TOO_LONG,
                    pParseInfo,
                    Argv );
                return( DNSSRV_PARSING_ERROR );
            }
        }
        NEXT_TOKEN( Argc, Argv );
    }

    //  set text length

    dataLength = (DWORD) (pch - prr->Data.TXT.chData);
    if ( dataLength > MAXWORD )
    {
        File_LogFileParsingError(
            DNS_EVENT_TEXT_STRING_TOO_LONG,
            pParseInfo,
            Argv );
        return( DNSSRV_PARSING_ERROR );
    }
    prr->wDataLength = (WORD) dataLength;

    return( ERROR_SUCCESS );
}



DNS_STATUS
MinfoFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process MINFO or RP record.

Arguments:

    pRR - ptr to database record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS      status;
    COUNT_NAME      countNameMailbox;
    COUNT_NAME      countNameErrors;
    PDB_RECORD      prr;
    PDB_NAME        pname;

    //
    //  MINFO <responsible mailbox> <errors to mailbox>
    //

    if ( Argc != 2 )
    {
        return ( Argc > 2 )
                ? DNSSRV_ERROR_EXCESS_TOKEN
                : DNSSRV_ERROR_MISSING_TOKEN;
    }

    //  create mailbox

    status = File_ReadCountNameFromToken(
                & countNameMailbox,
                pParseInfo,
                &Argv[0] );
    if ( status != ERROR_SUCCESS )
    {
        return( DNSSRV_PARSING_ERROR );
    }
    NEXT_TOKEN( Argc, Argv );

    //  create errors to mailbox

    status = File_ReadCountNameFromToken(
                & countNameErrors,
                pParseInfo,
                &Argv[0] );
    if ( status != ERROR_SUCCESS )
    {
        return( DNSSRV_PARSING_ERROR );
    }
    NEXT_TOKEN( Argc, Argv );

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD) ( Name_LengthDbaseNameFromCountName(&countNameMailbox) +
                                Name_LengthDbaseNameFromCountName(&countNameErrors) ) );
    IF_NOMEM( !prr )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    pParseInfo->pRR = prr;

    //
    //  write names
    //

    pname = &prr->Data.MINFO.nameMailbox;

    Name_CopyCountNameToDbaseName(
        pname,
        & countNameMailbox );

    pname = (PDB_NAME) Name_SkipDbaseName( pname );

    Name_CopyCountNameToDbaseName(
        pname,
        & countNameErrors );

    return( ERROR_SUCCESS );
}



DNS_STATUS
WksBuildRecord(
    OUT     PDB_RECORD *    ppRR,
    IN      IP_ADDRESS      ipAddress,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Build WKS record.
    This does WKS building common to file and RPC loading.

Arguments:

    ppRR -- existing RR being built

    ipAddress -- IP of machine WKS is for

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PDB_RECORD          prr;
    DWORD               i;
    DWORD               portDword;
    WORD                port;
    UCHAR               bit;
    WORD                maxPort = 0;
    WORD                wbitmaskLength;
    PBYTE               bitmaskBytes;
    WORD                portArray[ MAX_TOKENS ];
    CHAR                szNameBuffer[ DNS_MAX_NAME_LENGTH ];
    PCHAR               pszNameBuffer = szNameBuffer;
    struct servent *    pServent;
    struct protoent *   pProtoent;

    ASSERT( Argc <= MAX_TOKENS );

    //
    //  find protocol
    //

    if ( ! File_MakeTokenString(
                pszNameBuffer,
                Argv,
                pParseInfo ) )
    {
        return( DNSSRV_ERROR_INVALID_TOKEN );
    }
    pProtoent = getprotobyname( pszNameBuffer );

    if ( ! pProtoent || pProtoent->p_proto >= MAXUCHAR )
    {
        File_LogFileParsingError(
            DNS_EVENT_UNKNOWN_PROTOCOL,
            pParseInfo,
            Argv );
        return( DNSSRV_ERROR_INVALID_TOKEN );
    }

    //
    //  get port for each service
    //      - if digit, then use port number
    //      - if not digit, then service name
    //      - save max port for determining RR length
    //

    for ( i=1; i<Argc; i++ )
    {
        if ( File_ParseDwordToken(
                    & portDword,
                    & Argv[i],
                    NULL ) )
        {
            if ( portDword > MAXWORD )
            {
                return( DNSSRV_ERROR_INVALID_TOKEN );
            }
            port = (WORD) portDword;
        }
        else
        {
            if ( ! File_MakeTokenString(
                        pszNameBuffer,
                        & Argv[i],
                        pParseInfo ) )
            {
                return( DNSSRV_ERROR_INVALID_TOKEN );
            }
            pServent = getservbyname(
                            pszNameBuffer,
                            pProtoent->p_name );
            if ( ! pServent )
            {
                File_LogFileParsingError(
                    DNS_EVENT_UNKNOWN_SERVICE,
                    pParseInfo,
                    & Argv[i] );
                return( DNSSRV_ERROR_INVALID_TOKEN );
            }
            port = ntohs( pServent->s_port );
        }

        portArray[ i ] = port;
        if ( port > maxPort )
        {
            maxPort = port;
        }
    }

    //
    //  allocate required length
    //      - fixed length, plus bitmask covering max port
    //

    wbitmaskLength = maxPort/8 + 1;

    prr = RR_Allocate(
                (WORD)(SIZEOF_WKS_FIXED_DATA + wbitmaskLength) );
    IF_NOMEM( !prr )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    pParseInfo->pRR = prr;

    //
    //  copy fixed fields -- IP and protocol
    //

    prr->Data.WKS.ipAddress = ipAddress;
    prr->Data.WKS.chProtocol = (UCHAR) pProtoent->p_proto;

    //
    //  build bitmask from port array
    //      - clear port array first
    //
    //  note that bitmask is just flat run of bits
    //  hence lowest port in byte, corresponds to highest bit
    //  highest port in byte, corresponds to lowest bit and
    //  requires no shift
    //

    bitmaskBytes = prr->Data.WKS.bBitMask;

    RtlZeroMemory(
        bitmaskBytes,
        wbitmaskLength );

    for ( i=1; i<Argc; i++ )
    {
        port = portArray[ i ];
        bit  = port & 0x7;      // mod 8
        port = port >> 3;       // divide by 8
        bitmaskBytes[ port ] |= 1 << (7-bit);
    }

    //  return ptr to new WKS record

    *ppRR = prr;

    return( ERROR_SUCCESS );
}



DNS_STATUS
WksFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process WKS record.

Arguments:

    pRR - NULL ptr to database record, since this record type has variable
        length, this routine allocates its own record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    IP_ADDRESS  ip;
    DNS_STATUS  status;

    //
    //  WKS <IP address> <protocol> [<services> ...]
    //
    //  - allow no services, some customer has this
    //

    if ( Argc < 2 )
    {
        return  DNSSRV_ERROR_MISSING_TOKEN;
    }

    //  parse IP address string

    if ( ! File_ParseIpAddress(
                & ip,
                Argv,
                pParseInfo
                ) )
    {
        return( DNSSRV_PARSING_ERROR );
    }

    //  parse protocol and services and build WKS record

    status = WksBuildRecord(
                &pRR,
                ip,
                --Argc,
                ++Argv,
                pParseInfo );

    //  return record ptr through parse info

    pParseInfo->pRR = pRR;
    return( status );
}



DNS_STATUS
AaaaFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process AAAA record.

Arguments:

    pRR - ptr to database record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD  prr;

    //
    //  AAAA <IPv6 address string>
    //

    if ( Argc != 1 )
    {
        return ( Argc > 1 )
                ? DNSSRV_ERROR_EXCESS_TOKEN
                : DNSSRV_ERROR_MISSING_TOKEN;
    }

    prr = RR_Allocate( (WORD)sizeof(IP6_ADDRESS) );
    IF_NOMEM( !prr )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    pParseInfo->pRR = prr;

    if ( ! DnsIpv6StringToAddress(
                &prr->Data.AAAA.Ip6Addr,
                Argv->pchToken,
                Argv->cchLength
                ) )
    {
        File_LogFileParsingError(
            DNS_EVENT_INVALID_IPV6_ADDRESS,
            pParseInfo,
            Argv );
        pParseInfo->fErrorCode = DNSSRV_ERROR_INVALID_TOKEN;
        pParseInfo->fErrorEventLogged = TRUE;
        return( DNSSRV_PARSING_ERROR );
    }
    return( ERROR_SUCCESS );
}



DNS_STATUS
SrvFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process SRV compatible RR.

Arguments:

    pRR - ptr to database record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DWORD           dwtemp;
    PWORD           pword;
    PDB_RECORD      prr = NULL;
    COUNT_NAME      countName;
    DNS_STATUS      status;

    //
    //  SRV  <priority> <weight> <port> <target hostname>
    //

    if ( Argc != 4 )
    {
        return ( Argc > 4 )
                ? DNSSRV_ERROR_EXCESS_TOKEN
                : DNSSRV_ERROR_MISSING_TOKEN;
    }

    //
    //  SRV target host
    //      - do this first to determine record length
    //

    status = File_ReadCountNameFromToken(
                & countName,
                pParseInfo,
                &Argv[3] );
    if ( status != ERROR_SUCCESS )
    {
        return( DNSSRV_PARSING_ERROR );
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD)(SIZEOF_SRV_FIXED_DATA +
                            Name_LengthDbaseNameFromCountName(&countName)) );
    IF_NOMEM( !prr )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    pParseInfo->pRR = prr;

    //
    //  read SRV integers -- priority, weight, port
    //

    pword = &prr->Data.SRV.wPriority;

    while( Argc > 1 )
    {
        if ( ! File_ParseDwordToken(
                    & dwtemp,
                    Argv,
                    pParseInfo ) )
        {
            goto ParsingError;
        }
        if ( dwtemp > MAXWORD )
        {
            goto ParsingError;
        }
        *pword = htons( (WORD)dwtemp );
        pword++;
        NEXT_TOKEN( Argc, Argv );
    }

    //
    //  copy SRV target host
    //

    Name_CopyCountNameToDbaseName(
        & prr->Data.SRV.nameTarget,
        & countName );

    return( ERROR_SUCCESS );

ParsingError:

    pParseInfo->fErrorCode = DNSSRV_ERROR_INVALID_TOKEN;
    return( DNSSRV_PARSING_ERROR );
}



DNS_STATUS
AtmaFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process ATMA record.

Arguments:

    pRR - ptr to database record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD  prr;
    DWORD       length;
    BYTE        addrBuffer[ DNS_ATMA_MAX_RECORD_LENGTH ];
    DNS_STATUS  status;

    //
    //  ATMA <ATM address in either AESA or E164 format>
    //

    if ( Argc != 1 )
    {
        return ( Argc > 1 )
                ? DNSSRV_ERROR_EXCESS_TOKEN
                : DNSSRV_ERROR_MISSING_TOKEN;
    }

    length = DNS_ATMA_MAX_RECORD_LENGTH;

    status = Dns_AtmaStringToAddress(
                addrBuffer,
                & length,
                Argv->pchToken,
                Argv->cchLength
                );
    if ( status != ERROR_SUCCESS )
    {
#if 0
        File_LogFileParsingError(
            DNS_EVENT_INVALID_IPV6_ADDRESS,
            pParseInfo,
            Argv );
        pParseInfo->fErrorCode = DNSSRV_ERROR_INVALID_TOKEN;
        pParseInfo->fErrorEventLogged = TRUE;
#endif
        return( DNSSRV_PARSING_ERROR );
    }

    prr = RR_Allocate( (WORD)length );
    IF_NOMEM( !prr )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    pParseInfo->pRR = prr;

    //
    //  copy ATMA data to record
    //

    RtlCopyMemory(
        & prr->Data.ATMA,
        addrBuffer,
        length );

    return( ERROR_SUCCESS );
}



DWORD
ParseWinsFixedFields(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Parse fixed fields for WINS or WINS-R records.

Arguments:

    pRR - ptr to database record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    Argc remaining.
    (-1) on parsing error.

--*/
{
    DWORD   flag;
    TOKEN   token;

    //
    //  fixed fields [LOCAL] [SCOPE] [L<lookup>] [C<cache>]
    //      - default for lookup timeout is initialized by caller
    //

    pRR->Data.WINS.dwMappingFlag = 0;
    pRR->Data.WINS.dwCacheTimeout = WINS_DEFAULT_TTL;

    //  check for WINS flag

    while ( Argc )
    {
        flag = Dns_WinsRecordFlagForString(
                    Argv->pchToken,
                    Argv->cchLength );

        if ( flag == DNS_WINS_FLAG_ERROR )
        {
            break;
        }
        NEXT_TOKEN( Argc, Argv );
        pRR->Data.WINS.dwMappingFlag |= flag;
    }

    //  lookup timeout

    if ( Argc && Argv->pchToken[0] == 'L' )
    {
        MAKE_TOKEN( &token, Argv->pchToken+1, Argv->cchLength-1 );

        if ( ! File_ParseDwordToken(
                    & pRR->Data.WINS.dwLookupTimeout,
                    & token,
                    pParseInfo ) )
        {
            return( (DWORD)-1 );
        }
        NEXT_TOKEN( Argc, Argv );
    }

    //  cache timeout

    if ( Argc && Argv->pchToken[0] == 'C' )
    {
        MAKE_TOKEN( &token, Argv->pchToken+1, Argv->cchLength-1 );

        if ( ! File_ParseDwordToken(
                    & pRR->Data.WINS.dwCacheTimeout,
                    & token,
                    pParseInfo ) )
        {
            return( (DWORD)-1 );
        }
        NEXT_TOKEN( Argc, Argv );
    }

    return( Argc );
}



DNS_STATUS
WinsFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process WINS record.

Arguments:

    pRR - NULL ptr to database record, since this record type has variable
        length, this routine allocates its own record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;
    COUNT_NAME      countName;
    DB_RECORD       record;
    DWORD           argcFixed;
    DWORD           i = 0;

    //
    //  WINS [LOCAL] [L<lookup>] [C<cache>] <WINS IP> [<WINS IP>...]
    //

    //
    //  parse fixed fields into temp stack record
    //      - set default lookup timeout which is different for WINS \ WINSR
    //      - then reset Argv ptrs to account fixed fields parsed

    argcFixed = Argc;
    record.Data.WINS.dwLookupTimeout =  WINS_DEFAULT_LOOKUP_TIMEOUT;

    Argc = ParseWinsFixedFields(
                & record,
                Argc,
                Argv,
                pParseInfo );
    if ( Argc == 0 || Argc == (DWORD)(-1) )
    {
        File_LogFileParsingError(
            DNS_EVENT_INVALID_WINS_RECORD,
            pParseInfo,
            NULL );
        return DNSSRV_ERROR_MISSING_TOKEN;
    }
    if ( argcFixed -= Argc )
    {
        Argv += argcFixed;
    }

    //  allocate

    prr = RR_Allocate( (WORD)(SIZEOF_WINS_FIXED_DATA + (Argc * sizeof(DWORD))) );
    IF_NOMEM( !prr )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    pParseInfo->pRR = prr;
    prr->wType = DNS_TYPE_WINS;

    //  copy fixed fields

    RtlCopyMemory(
        & prr->Data,
        & record.Data,
        SIZEOF_WINS_FIXED_DATA );

    //  read in WINS IP addresses

    prr->Data.WINS.cWinsServerCount = Argc;

    for( i=0; i<Argc; i++ )
    {
        if ( ! File_ParseIpAddress(
                    & prr->Data.WINS.aipWinsServers[i],
                    Argv,
                    pParseInfo ) )
        {
            return( DNSSRV_PARSING_ERROR );
        }
        Argv++;
    }

    return( ERROR_SUCCESS );
}



DNS_STATUS
NbstatFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process WINS-R (nbstat) record.

Arguments:

    pRR - ptr to database record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;
    DB_RECORD       record;
    DWORD           argcFixed;
    COUNT_NAME      countName;
    DNS_STATUS      status;

    //
    //  WINSR [LOCAL] [SCOPE] [L<lookup>] [C<cache>] <landing domain>
    //

    //
    //  parse fixed fields into temp stack record
    //      - set default lookup timeout which is different for WINS \ WINSR
    //      - then reset Argv ptrs to account fixed fields parsed

    argcFixed = Argc;
    record.Data.WINS.dwLookupTimeout = NBSTAT_DEFAULT_LOOKUP_TIMEOUT;

    Argc = ParseWinsFixedFields(
                & record,
                Argc,
                Argv,
                pParseInfo );
    if ( Argc == 0 || Argc == (DWORD)(-1) )
    {
        File_LogFileParsingError(
            DNS_EVENT_INVALID_NBSTAT_RECORD,
            pParseInfo,
            NULL );
        return DNSSRV_ERROR_MISSING_TOKEN;
    }
    if ( argcFixed -= Argc )
    {
        Argv += argcFixed;
    }

    //
    //  WINSR result domain
    //      - do this first to determine record length
    //

    status = File_ReadCountNameFromToken(
                & countName,
                pParseInfo,
                &Argv[0] );
    if ( status != ERROR_SUCCESS )
    {
        return( DNSSRV_PARSING_ERROR );
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD)(SIZEOF_WINS_FIXED_DATA +
                            Name_LengthDbaseNameFromCountName(&countName)) );
    IF_NOMEM( !prr )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    pParseInfo->pRR = prr;
    prr->wType = DNS_TYPE_WINSR;

    //  copy fixed fields

    RtlCopyMemory(
        &prr->Data,
        &record.Data,
        SIZEOF_WINS_FIXED_DATA );

    //
    //  write WINSR result domain
    //

    Name_CopyCountNameToDbaseName(
        & prr->Data.WINSR.nameResultDomain,
        & countName );

    return( status );
}



DNS_STATUS
buildKeyOrSignatureFromTokens(
    OUT     PBYTE           pKey,
    IN OUT  PDWORD          pKeyLength,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv
    )
/*++

Routine Description:

    Build a key or signature from a set of tokens representing the
    actual key or signature in base64 notation.

Arguments:

    pKey        - ptr to buffer for key

    pKeyLength  - ptr to DWORD with max key length

    Argc        - token count

    Argv        - tokens

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DWORD   len;
    DWORD   stringLength = 0;
    UCHAR   stringKey[ DNS_MAX_KEY_STRING_LENGTH + 1 ];
    PUCHAR  pstringKey = stringKey;

    //
    //  There must be key tokens.
    //

    if ( Argc < 1 )
    {
        return DNSSRV_ERROR_MISSING_TOKEN;
    }

    //
    //  Collect argcs into a single key string.
    //

    while( Argc-- )
    {
        len = Argv->cchLength;
        stringLength += len;
        if ( stringLength > DNS_MAX_KEY_STRING_LENGTH )
        {
            return DNSSRV_ERROR_EXCESS_TOKEN;
        }
        RtlCopyMemory(
            pstringKey,
            Argv->pchToken,
            len );
        pstringKey += len;
        ++Argv;
    }

    stringKey[ stringLength ] = '\0';   // NULL terminate the string

    //
    //  Convert the key string from base64 character representation (RFC2045,
    //  also reproduced in part in Appendix A of RFC2535) to actual binary key.
    //

    return Dns_SecurityBase64StringToKey(
                pKey,
                pKeyLength,
                stringKey,
                stringLength );
}



DNS_STATUS
KeyFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process KEY record - DNSSEC RFC2535 section 3

Arguments:

    pRR - ptr to database record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    WORD        flag = 0;
    UCHAR       protocol;
    UCHAR       algorithm;
    BOOL        foundFlag = FALSE;
    DWORD       dwTemp;
    DWORD       keyLength;
    UCHAR       key[ DNS_MAX_KEY_LENGTH ];

    //
    //  KEY  <flags> <protocol> <algorithm> <key bytes>
    //

    if ( Argc < 3 )
    {
        status = DNSSRV_ERROR_MISSING_TOKEN;
        goto Cleanup;
    }

    //
    //  Flags may be either set of mnemonics or unsigned integer.
    //  Loop converting tokens as mnemonics until failure, if none
    //  none converted then flag must be unsigned integer.
    //

    while ( Argc > 2 )
    {
        WORD    thisFlag;

        thisFlag = Dns_KeyRecordFlagForString(
                        Argv->pchToken,
                        Argv->cchLength );
        if ( thisFlag == ( WORD ) DNSSEC_ERROR_NOSTRING )
        {
            break;
        }
        flag |= thisFlag;
        foundFlag = TRUE;
        NEXT_TOKEN( Argc, Argv );
    }

    //
    //  If no matching mnemonics, try reading flag as integer value.
    //

    if ( !foundFlag )
    {
        if ( !File_ParseDwordToken(
                &dwTemp,
                Argv,
                pParseInfo ) ||
            dwTemp > MAXWORD )
        {
            status = DNSSRV_PARSING_ERROR;
            goto Cleanup;
        }
        flag = ( WORD ) dwTemp;
        NEXT_TOKEN( Argc, Argv );
    }

    //
    //  Protocol may also be mnemonic or integer. Try parsing mnemonic but
    //  if that fails read as integer.
    //

    protocol = Dns_KeyRecordProtocolForString(
                    Argv->pchToken,
                    Argv->cchLength );
    if ( protocol == ( UCHAR ) DNSSEC_ERROR_NOSTRING )
    {
        if ( !File_ParseDwordToken(
                &dwTemp,
                Argv,
                pParseInfo ) ||
            dwTemp > MAXUCHAR )
        {
            status = DNSSRV_PARSING_ERROR;
            goto Cleanup;
        }
        protocol = ( UCHAR ) dwTemp;
    }
    NEXT_TOKEN( Argc, Argv );

    //
    //  Algorithm may also be mnemonic or integer. Try parsing mnemonic but
    //  if that fails read as integer.
    //

    algorithm = Dns_SecurityAlgorithmForString(
                    Argv->pchToken,
                    Argv->cchLength );
    if ( algorithm == ( UCHAR ) DNSSEC_ERROR_NOSTRING )
    {
        if ( !File_ParseDwordToken(
                &dwTemp,
                Argv,
                pParseInfo ) ||
            dwTemp > MAXUCHAR )
        {
            status = DNSSRV_PARSING_ERROR;
            goto Cleanup;
        }
        algorithm = ( UCHAR ) dwTemp;
    }
    NEXT_TOKEN( Argc, Argv );

    //
    //  Parse the key tokens into a binary key.
    //

    status = buildKeyOrSignatureFromTokens(
                key,
                &keyLength,
                Argc,
                Argv );
    if ( status != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    //
    //  Allocate the RR with enough space to hold the binary key.
    //

    pRR = RR_Allocate( ( WORD )( SIZEOF_KEY_FIXED_DATA + keyLength ) );
    IF_NOMEM( !pRR )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Cleanup;
    }
    pParseInfo->pRR = pRR;

    //
    //  Copy parsed values into RR data fields.
    //

    pRR->Data.KEY.wFlags        = htons( flag );
    pRR->Data.KEY.chProtocol    = protocol;
    pRR->Data.KEY.chAlgorithm   = algorithm;

    RtlCopyMemory(
        pRR->Data.KEY.Key,
        key,
        keyLength );

    //
    //  Final processing, cleanup, and return.
    //

    Cleanup:

    if ( status == DNSSRV_PARSING_ERROR )
    {
        pParseInfo->fErrorCode = DNSSRV_ERROR_INVALID_TOKEN;
    }

    return status;
} // KeyFileRead



DNS_STATUS
SigFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process SIG record - DNSSEC RFC2535 section 4

Arguments:

    pRR - ptr to database record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    WORD        typeCovered;
    WORD        keyTag;
    DWORD       originalTtl;
    DWORD       sigExpiration;
    DWORD       sigInception;
    DWORD       dwTemp;
    COUNT_NAME  signersCountName;
    DWORD       sigLength;
    UCHAR       sig[ DNS_MAX_KEY_LENGTH ];
    UCHAR       algorithm;
    UCHAR       labelCount;

    //
    //  SIG format: <type covered> <algorithm> <original TTL> 
    //      <signature expiration> <signature inception>
    //      <key tag> <signer's name> <signature in base64 form>
    //

    if ( Argc < 8 )
    {
        status = DNSSRV_ERROR_MISSING_TOKEN;
        goto Cleanup;
    }


    //
    //  Type covered is single type in either mnemonic or integer form.
    //  Try parsing mnemonic but if that fails read as integer.
    //

    typeCovered = Dns_RecordTypeForName(
                    Argv->pchToken,
                    Argv->cchLength );
    if ( typeCovered == ( WORD ) DNSSEC_ERROR_NOSTRING )
    {
        if ( !File_ParseDwordToken(
               &dwTemp,
               Argv,
               pParseInfo ) ||
            dwTemp > MAXWORD )
        {
            status = DNSSRV_PARSING_ERROR;
            goto Cleanup;
        }
        typeCovered = ( WORD ) dwTemp;
    }
    NEXT_TOKEN( Argc, Argv );

    //
    //  Algorithm may also be mnemonic or integer. Try parsing mnemonic but
    //  if that fails read as integer.
    //

    algorithm = Dns_SecurityAlgorithmForString(
                    Argv->pchToken,
                    Argv->cchLength );
    if ( algorithm == ( UCHAR ) DNSSEC_ERROR_NOSTRING )
    {
        if ( !File_ParseDwordToken(
               &dwTemp,
               Argv,
               pParseInfo ) ||
            dwTemp > MAXUCHAR )
        {
            status = DNSSRV_PARSING_ERROR;
            goto Cleanup;
        }
        algorithm = ( UCHAR ) dwTemp;
    }
    NEXT_TOKEN( Argc, Argv );

    // 
    //  Label count is an unsigned integer value.
    //
    
    if ( !File_ParseDwordToken(
            &dwTemp,
            Argv,
            pParseInfo ) )
    {
        status = DNSSRV_PARSING_ERROR;
        goto Cleanup;
    }
    labelCount = ( UCHAR ) dwTemp > 127 ? 127 : ( UCHAR ) dwTemp;
    NEXT_TOKEN( Argc, Argv );

    // 
    //  Original TTL is an unsigned integer value.
    //
    
    if ( !File_ParseDwordToken(
            &dwTemp,
            Argv,
            pParseInfo ) )
    {
        status = DNSSRV_PARSING_ERROR;
        goto Cleanup;
    }
    originalTtl = ( DWORD ) dwTemp;
    NEXT_TOKEN( Argc, Argv );

    //
    //  Signature expiration and inceptions times are string values
    //  in YYYYMMDDHHMMSS format.
    //

    sigExpiration = ( DWORD ) Dns_ParseSigTime(
                                Argv->pchToken,
                                Argv->cchLength );
    NEXT_TOKEN( Argc, Argv );

    sigInception = ( DWORD ) Dns_ParseSigTime(
                                Argv->pchToken,
                                Argv->cchLength );
    NEXT_TOKEN( Argc, Argv );

    // 
    //  Key tag is an unsigned integer value.
    //
    
    if ( !File_ParseDwordToken(
            &dwTemp,
            Argv,
            pParseInfo ) ||
        dwTemp > MAXWORD )
    {
        status = DNSSRV_PARSING_ERROR;
        goto Cleanup;
    }
    keyTag = ( WORD ) dwTemp;
    NEXT_TOKEN( Argc, Argv );

    //
    //  Signer's name is a regular DNS domain name which may be
    //  compressed in the usual fashion.
    //

    status = File_ReadCountNameFromToken(
                &signersCountName,
                pParseInfo,
                Argv );
    if ( status != ERROR_SUCCESS )
    {
        status = DNSSRV_PARSING_ERROR;
        goto Cleanup;
    }
    NEXT_TOKEN( Argc, Argv );

    //
    //  Signature is a base64 representation. Parse it into a binary
    //  string.
    //

    status = buildKeyOrSignatureFromTokens(
                sig,
                &sigLength,
                Argc,
                Argv );
    if ( status != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    //
    //  Allocate the RR with enough space to hold the binary signature.
    //  Note that since we have two variable length elements (sig and
    //  signer's name), we must include one of them in it's entirety.
    //  So the signer's name element is always allocated to it's maximum
    //  size and the sig is allowed to "float" at the end of the struct.
    //

    pRR = RR_Allocate( ( WORD )(
                SIZEOF_SIG_FIXED_DATA +
                Name_LengthDbaseNameFromCountName( &signersCountName ) +
                sigLength ) );
    IF_NOMEM( !pRR )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Cleanup;
    }
    pParseInfo->pRR = pRR;

    //
    //  Copy parsed values into RR data fields.
    //

    Name_CopyCountNameToDbaseName(
        &pRR->Data.SIG.nameSigner,
        &signersCountName );

    pRR->Data.SIG.wTypeCovered      = htons( typeCovered );
    pRR->Data.SIG.chAlgorithm       = algorithm;
    pRR->Data.SIG.chLabelCount      = labelCount;
    pRR->Data.SIG.dwOriginalTtl     = htonl( originalTtl );
    pRR->Data.SIG.dwSigExpiration   = htonl( sigExpiration );
    pRR->Data.SIG.dwSigInception    = htonl( sigInception );
    pRR->Data.SIG.wKeyTag           = htons( keyTag );

    RtlCopyMemory(
        ( PBYTE ) &pRR->Data.SIG.nameSigner +
            DBASE_NAME_SIZE( &pRR->Data.SIG.nameSigner ),
        sig,
        sigLength );

    //
    //  Final processing, cleanup, and return.
    //

    Cleanup:

    if ( status == DNSSRV_PARSING_ERROR )
    {
        pParseInfo->fErrorCode = DNSSRV_ERROR_INVALID_TOKEN;
    }
    return status;
} // SigFileRead



DNS_STATUS
NxtFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process NXT record - DNSSEC RFC2535

    Note: we always copy the maximum bitmap to the RR. It's not that
    big, and if we have to add types later it saves us from having to
    reallocate the RR.

Arguments:

    pRR - ptr to database record

    Argc - RR data token count

    Argv - array of RR data tokens

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    DWORD       dwTemp;
    BOOL        foundType = FALSE;
    COUNT_NAME  nextCountName;
    UCHAR       typeBitmap[ DNS_MAX_TYPE_BITMAP_LENGTH ] = { 0 };

    //
    //  NXT  <next domain name> <type bit map>
    //

    if ( Argc < 2 )
    {
        status = DNSSRV_ERROR_MISSING_TOKEN;
        goto Cleanup;
    }

    //
    //  Next domain name is a regular DNS domain name which may be
    //  compressed in the usual fashion.
    //

    status = File_ReadCountNameFromToken(
                &nextCountName,
                pParseInfo,
                Argv );
    if ( status != ERROR_SUCCESS )
    {
        status = DNSSRV_PARSING_ERROR;
        goto Cleanup;
    }
    NEXT_TOKEN( Argc, Argv );

    //
    //  Type bit map is an unsigned int or series of type mnemonics.
    //

    while ( Argc )
    {
        WORD    wType;

        wType = Dns_RecordTypeForName(
                Argv->pchToken,
                Argv->cchLength );
        if ( wType == ( WORD ) DNSSEC_ERROR_NOSTRING )
        {
            break;
        }
        typeBitmap[ wType / 8 ] |= 1 << wType % 8;
        foundType = TRUE;
        NEXT_TOKEN( Argc, Argv );
    }

    if ( !foundType )
    {
        if ( !File_ParseDwordToken(
                &dwTemp,
                Argv,
                pParseInfo ) ||
            dwTemp > MAXDWORD )
        {
            status = DNSSRV_PARSING_ERROR;
            goto Cleanup;
        }
        * ( DWORD * ) &typeBitmap = dwTemp;
        NEXT_TOKEN( Argc, Argv );
    }

    //
    //  Allocate the RR with enough space to hold the type bitmap and
    //  the signer's name.
    //


    pRR = RR_Allocate( ( WORD )(
                SIZEOF_NXT_FIXED_DATA +
                DNS_MAX_TYPE_BITMAP_LENGTH +
                Name_LengthDbaseNameFromCountName( &nextCountName ) ) );
    IF_NOMEM( !pRR )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Cleanup;
    }
    pParseInfo->pRR = pRR;

    //
    //  Copy parsed values into RR data fields.
    //

    RtlCopyMemory(
        pRR->Data.NXT.bTypeBitMap,
        typeBitmap,
        DNS_MAX_TYPE_BITMAP_LENGTH );

    Name_CopyCountNameToDbaseName(
        &pRR->Data.NXT.nameNext,
        &nextCountName );

    //
    //  Final processing, cleanup, and return.
    //

    Cleanup:

    if ( status == DNSSRV_PARSING_ERROR )
    {
        pParseInfo->fErrorCode = DNSSRV_ERROR_INVALID_TOKEN;
    }

    return status;
} // NxtFileRead



//
//  Read RR from file functions
//

RR_FILE_READ_FUNCTION   RRFileReadTable[] =
{
    NULL,               //  ZERO -- no default for unknown types

    AFileRead,          //  A
    PtrFileRead,        //  NS
    PtrFileRead,        //  MD
    PtrFileRead,        //  MF
    PtrFileRead,        //  CNAME
    SoaFileRead,        //  SOA
    PtrFileRead,        //  MB
    PtrFileRead,        //  MG
    PtrFileRead,        //  MR
    NULL,               //  NULL
    WksFileRead,        //  WKS
    PtrFileRead,        //  PTR
    TxtFileRead,        //  HINFO
    MinfoFileRead,      //  MINFO
    MxFileRead,         //  MX
    TxtFileRead,        //  TXT
    MinfoFileRead,      //  RP
    MxFileRead,         //  AFSDB
    TxtFileRead,        //  X25
    TxtFileRead,        //  ISDN
    MxFileRead,         //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    SigFileRead,        //  SIG
    KeyFileRead,        //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    AaaaFileRead,       //  AAAA
    NULL,               //  LOC
    NxtFileRead,        //  NXT
    NULL,               //  31
    NULL,               //  32
    SrvFileRead,        //  SRV
    AtmaFileRead,       //  ATMA
    NULL,               //  35
    NULL,               //  36
    NULL,               //  37
    NULL,               //  38
    NULL,               //  39
    NULL,               //  40
    NULL,               //  OPT
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //  note these follow, but require OFFSET_TO_WINS_RR subtraction
    //  from actual type value

    WinsFileRead,       //  WINS
    NbstatFileRead      //  WINS-R
};


//
//  End of rrfile.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\rrflat.c ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    rrflat.c

Abstract:

    Domain Name System (DNS) Server

    Routines to read flat DNS records, used by admin RPC and DS,
    into database.

Author:

    Jim Gilroy (jamesg)     Decemeber 1996

Revision History:

--*/


#include "dnssrv.h"




//
//  Utils for building records from RPC buffer.
//

DNS_STATUS
tokenizeCountedStringsInBuffer(
    IN      PDNS_RPC_STRING pString,
    IN      WORD            wLength,
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Parse buffer with data in counted string format into tokens.

    Primary purpose is to tokenize any RPC buffers with all the data in
    this format, to allow processing by standard file load functions.

Arguments:

    pString - ptr to first counted string in buffer

    wLength - length of buffer to tokenize

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PCHAR   pch;
    DWORD   tokenLength;
    PCHAR   pchend = (PCHAR)pString + wLength;
    DWORD   argc = 0;
    PTOKEN  argv = pParseInfo->Argv;

    DNS_DEBUG( RPC2, (
        "Tokenizing counted string buffer:\n"
        "\tlength   = %d\n"
        "\tstart    = %p\n"
        "\tstop     = %p\n"
        "\tfirst strlen = %d\n"
        "\tfirst string = %.*s\n",
        wLength,
        pString,
        pchend,
        pString->cchNameLength,
        pString->cchNameLength,
        pString->achName ));

    //
    //  tokenize all counted strings within specified length
    //

    while ( (PBYTE)pString < pchend )
    {
        if ( argc >= MAX_TOKENS )
        {
            return DNS_ERROR_INVALID_DATA;
        }
        
        //  catches string extending beyond boundary or record,
        //  hence catches any possibility of overwrite

        tokenLength = pString->cchNameLength;
        pch = (PCHAR)pString + tokenLength;
        if ( pch >= pchend )
        {
            return DNS_ERROR_INVALID_DATA;
        }

        //  correct token length if last char NULL termination
        //      special case NULL string

        if ( *pch == 0 && tokenLength != 0 )
        {
            tokenLength--;
        }

        //  save this token

        argv[argc].pchToken = (PCHAR) pString->achName;
        argv[argc].cchLength = tokenLength;
        argc++;

        DNS_DEBUG( RPC2, (
            "Tokenized RPC string len=%d <%.*s>\n",
            tokenLength,
            tokenLength,
            (PCHAR) pString->achName ));

        //  next string
        //      -- pch sitting on last char in previous string

        pString = (PDNS_RPC_STRING) ++pch;
    }

    pParseInfo->Argc = argc;

#if DBG
    IF_DEBUG( RPC2 )
    {
        DWORD i;

        DnsPrintf(
            "Tokenized %d strings in RPC buffer\n",
            argc );

        for( i=0; i<argc; i++ )
        {
            DnsPrintf(
                "\ttoken[%d] = %.*s (len=%d)\n",
                i,
                argv[i].cchLength,
                argv[i].pchToken,
                argv[i].cchLength );
        }
    }
#endif

    return( ERROR_SUCCESS );
}




//
//  Type specific functions for building RR from RPC buffer
//

DNS_STATUS
AFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Process A record.

Arguments:

    pRR - ptr to database record

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD  prr;

    //  validate record length

    if ( pRecord->wDataLength != sizeof(IP_ADDRESS) )
    {
        return( DNS_ERROR_RECORD_FORMAT );
    }

    //  allocate record

    prr = RR_Allocate( SIZEOF_IP_ADDRESS );
    IF_NOMEM( !prr )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    pParseInfo->pRR = prr;

    //  copy IP address

    prr->Data.A.ipAddress = pRecord->Data.A.ipAddress;

    return( ERROR_SUCCESS );
}



DNS_STATUS
PtrFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Process PTR compatible record.
    Includes: PTR, NS, CNAME, MB, MR, MG, MD, MF

Arguments:

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;
    PDNS_RPC_NAME   prpcName;
    DWORD           status;
    DWORD           length;
    COUNT_NAME      nameTarget;

    //
    //  all these types are indirection to another database node
    //      named in plookName1
    //

    prpcName = & pRecord->Data.PTR.nameNode;
    if ( ! DNS_IS_NAME_IN_RECORD(pRecord, prpcName) )
    {
        return( DNS_ERROR_RECORD_FORMAT );
    }

    length = Name_ConvertRpcNameToCountName(
                    & nameTarget,
                    prpcName );
    if ( ! length )
    {
        return( DNS_ERROR_RECORD_FORMAT );
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD)length );
    IF_NOMEM( !prr )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    pParseInfo->pRR = prr;

    //
    //  copy in name
    //

    status = Name_CopyCountNameToDbaseName(
                    & prr->Data.PTR.nameTarget,
                    & nameTarget );

    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    return( ERROR_SUCCESS );
}



DNS_STATUS
MxFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Process MX compatible RR.

Arguments:

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;
    PDNS_RPC_NAME   prpcName;
    DWORD           status;
    DWORD           length;
    COUNT_NAME      nameExchange;

    //
    //  MX mail exchange
    //  RT intermediate exchange
    //  AFSDB hostname
    //

    prpcName = & pRecord->Data.MX.nameExchange;
    if ( ! DNS_IS_NAME_IN_RECORD(pRecord, prpcName) )
    {
        return( DNS_ERROR_RECORD_FORMAT );
    }

    length = Name_ConvertRpcNameToCountName(
                    & nameExchange,
                    prpcName );
    if ( ! length )
    {
        return( DNS_ERROR_RECORD_FORMAT );
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD)(SIZEOF_MX_FIXED_DATA + length) );
    IF_NOMEM( !prr )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    pParseInfo->pRR = prr;

    //
    //  copy fixed field
    //  MX preference
    //  RT preference
    //  AFSDB subtype
    //

    prr->Data.MX.wPreference = htons( pRecord->Data.MX.wPreference );

    //
    //  copy in name
    //

    status = Name_CopyCountNameToDbaseName(
                    & prr->Data.MX.nameExchange,
                    & nameExchange );

    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    return( ERROR_SUCCESS );
}



DNS_STATUS
SoaFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Process SOA RR.

Arguments:

    pRR - ptr to database record

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;
    PDNS_RPC_NAME   prpcName;
    DWORD           status;
    COUNT_NAME      namePrimary;
    COUNT_NAME      nameAdmin;
    DWORD           length1;
    DWORD           length2;
    PDB_NAME        pname;

    //
    //  Primary name server
    //

    prpcName = &pRecord->Data.SOA.namePrimaryServer;

    if ( ! DNS_IS_NAME_IN_RECORD(pRecord, prpcName) )
    {
        return( DNS_ERROR_RECORD_FORMAT );
    }
    length1 = Name_ConvertRpcNameToCountName(
                    & namePrimary,
                    prpcName );
    if ( ! length1 )
    {
        return( DNS_ERROR_RECORD_FORMAT );
    }

    //
    //  Zone admin
    //

    prpcName = DNS_GET_NEXT_NAME( prpcName );
    if ( ! DNS_IS_NAME_IN_RECORD(pRecord, prpcName) )
    {
        status = DNS_ERROR_RECORD_FORMAT;
    }
    length2 = Name_ConvertRpcNameToCountName(
                    & nameAdmin,
                    prpcName );
    if ( ! length2 )
    {
        return( DNS_ERROR_RECORD_FORMAT );
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD)(SIZEOF_SOA_FIXED_DATA + length1 + length2) );
    IF_NOMEM( !prr )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    pParseInfo->pRR = prr;

    //
    //  copy / byte swap fixed SOA fields back into net order
    //

    prr->Data.SOA.dwSerialNo    = htonl( pRecord->Data.SOA.dwSerialNo );
    prr->Data.SOA.dwRefresh     = htonl( pRecord->Data.SOA.dwRefresh );
    prr->Data.SOA.dwRetry       = htonl( pRecord->Data.SOA.dwRetry );
    prr->Data.SOA.dwExpire      = htonl( pRecord->Data.SOA.dwExpire );
    prr->Data.SOA.dwMinimumTtl  = htonl( pRecord->Data.SOA.dwMinimumTtl );

    //
    //  copy in names
    //

    pname = &prr->Data.SOA.namePrimaryServer;

    Name_CopyCountNameToDbaseName(
        pname,
        & namePrimary );

    pname = (PDB_NAME) Name_SkipDbaseName( pname );

    Name_CopyCountNameToDbaseName(
        pname,
        & nameAdmin );

    return( ERROR_SUCCESS );
}



DNS_STATUS
KeyFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Process KEY RR.

Arguments:

    pRR - ptr to database record

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;

    prr = RR_Allocate( pRecord->wDataLength );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;

    prr->Data.KEY.wFlags        = htons( pRecord->Data.KEY.wFlags );
    prr->Data.KEY.chProtocol    = pRecord->Data.KEY.chProtocol;
    prr->Data.KEY.chAlgorithm   = pRecord->Data.KEY.chAlgorithm;

    RtlCopyMemory(
        prr->Data.KEY.Key,
        pRecord->Data.Key.bKey,
        pRecord->wDataLength -
            ( pRecord->Data.Key.bKey - ( PBYTE ) &pRecord->Data ) );

    return ERROR_SUCCESS;
}   //  KeyFlatRead



DNS_STATUS
SigFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Process SIG RR.

Arguments:

    pRR - ptr to database record

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;
    PDNS_RPC_NAME   prpcName;
    DWORD           nameLength;
    DWORD           sigLength;
    COUNT_NAME      nameSigner;
    PBYTE           pSigSrc;
    PBYTE           pSigDest;

    prpcName = &pRecord->Data.SIG.nameSigner;
    if ( !DNS_IS_NAME_IN_RECORD( pRecord, prpcName ) ||
        ( nameLength = Name_ConvertRpcNameToCountName(
                            &nameSigner,
                            prpcName ) ) == 0 )
    {
        return DNS_ERROR_RECORD_FORMAT;
    }

    pSigSrc = ( PBYTE ) DNS_GET_NEXT_NAME( prpcName );
    sigLength = ( DWORD )
        ( pRecord->wDataLength - ( pSigSrc - ( PBYTE ) &pRecord->Data ) );

    prr = RR_Allocate( ( WORD ) (
                SIZEOF_SIG_FIXED_DATA +
                nameLength +
                sigLength ) );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;

    prr->Data.SIG.wTypeCovered      = htons( pRecord->Data.SIG.wTypeCovered );
    prr->Data.SIG.chAlgorithm       = pRecord->Data.SIG.chAlgorithm;
    prr->Data.SIG.chLabelCount      = pRecord->Data.SIG.chLabelCount;
    prr->Data.SIG.dwOriginalTtl     = htonl( pRecord->Data.SIG.dwOriginalTtl );
    prr->Data.SIG.dwSigExpiration   = htonl( pRecord->Data.SIG.dwSigExpiration );
    prr->Data.SIG.dwSigInception    = htonl( pRecord->Data.SIG.dwSigInception );
    prr->Data.SIG.wKeyTag           = htons( pRecord->Data.SIG.wKeyTag );

    Name_CopyCountNameToDbaseName(
        &prr->Data.SIG.nameSigner,
        &nameSigner );
    pSigDest = ( PBYTE ) &prr->Data.SIG.nameSigner +
                DBASE_NAME_SIZE( &prr->Data.SIG.nameSigner );

    RtlCopyMemory( pSigDest, pSigSrc, sigLength );

    return ERROR_SUCCESS;
}   //  SigFlatRead



DNS_STATUS
NxtFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Process NXT RR.

Arguments:

    pRR - ptr to database record

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS      rc = ERROR_SUCCESS;
    PDB_RECORD      prr = NULL;
    PDNS_RPC_NAME   prpcName;
    DWORD           nameLength;
    COUNT_NAME      nameNext;
    INT             typeIdx;
    WORD            numTypeWords = pRecord->Data.Nxt.wNumTypeWords;

    ASSERT( numTypeWords > 0 && numTypeWords < 33 );

    //
    //  Copy out the next name.
    //
    
    prpcName = ( PDNS_RPC_NAME ) (
        ( PBYTE ) &pRecord->Data +
        ( numTypeWords + 1 ) * sizeof( WORD ) );
    if ( !DNS_IS_NAME_IN_RECORD( pRecord, prpcName ) ||
        ( nameLength = Name_ConvertRpcNameToCountName(
                            &nameNext,
                            prpcName ) ) == 0 )
    {
        rc = DNS_ERROR_RECORD_FORMAT;
        goto Failure;
    }

    //
    //  Allocate the RR.
    //

    prr = RR_Allocate( ( WORD ) ( DNS_MAX_TYPE_BITMAP_LENGTH + nameLength ) );
    IF_NOMEM( !prr )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    pParseInfo->pRR = prr;

    Name_CopyCountNameToDbaseName(
        &prr->Data.NXT.nameNext,
        &nameNext );

    //
    //  Handle the array of types covered.
    //  

    RtlZeroMemory(
        prr->Data.NXT.bTypeBitMap,
        sizeof( prr->Data.NXT.bTypeBitMap ) );

    //
    //  Loop through the type WORDs, turning on the appropriate bit
    //  in the type bitmap array. Some types are not allowed, such as
    //  the compound types (eg. MAILA), the transfer types (eg. AXFR), 
    //  and the WINS types.
    //

    for ( typeIdx = 0; typeIdx < numTypeWords; ++typeIdx )
    {
        WORD    wType = pRecord->Data.Nxt.wTypeWords[ typeIdx ];

        if ( wType > DNS_MAX_TYPE_BITMAP_LENGTH * 8 )
        {
            DNS_DEBUG( RPC, (
                "NxtFlatRead: rejecting NXT RR with type out of range (%d)\n",
                ( int ) wType ));
            rc = DNS_ERROR_RECORD_FORMAT;
            goto Failure;
        }
        prr->Data.NXT.bTypeBitMap[ wType / 8 ] |= 1 << wType % 8;
    }

    return ERROR_SUCCESS;

    Failure:

    if ( prr )
    {
        RR_Free( prr );
    }
    return rc;
}   //  NxtFlatRead



DNS_STATUS
TxtFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Process Text (TXT) RR.

Arguments:

    pRR - NULL ptr to database record, since this record type has variable
        length, this routine allocates its own record

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DWORD           status;

    IF_DEBUG( RPC2 )
    {
        DNS_PRINT((
            "Building string record:\n"
            "\ttype         = 0x%x\n"
            "\tpRecord dlen = %d\n"
            "\tpRecord data = %p\n",
            pRecord->wType,
            pRecord->wDataLength,
            &pRecord->Data ));
    }

    //
    //  tokenize record data in buffer
    //

    status = tokenizeCountedStringsInBuffer(
                & pRecord->Data.Txt.stringData,
                pRecord->wDataLength,
                pParseInfo );
    if ( status != ERROR_SUCCESS )
    {
        return(  status );
    }

    #if 0
    //
    //  This code triggered bug 53180 to be filed - removing it since 
    //  hopefully Marco's bug has long since vanished into pre-history.
    //

    //  protect against last TXT string empty
    //  this is an admin tool bug, which Marco probably doesn't
    //      have time to fix;  can still intentionally send
    //      last string empty by sending another bogus string

    if ( pRecord->wType == DNS_TYPE_TEXT &&
        pParseInfo->Argc > 1 &&
        pParseInfo->Argv[ (pParseInfo->Argc)-1 ].cchLength == 0 )
    {
        DNS_DEBUG( RPC, (
            "WARNING:  Last string in TXT RPC record is empty string.\n"
            "\tassuming this admin tool error and removing from list.\n"
            ));
        pParseInfo->Argc--;
    }
    #endif

    //
    //  give tokens to file load routine to
    //      - it allocates record and returns it in pParseInfo
    //

    status = TxtFileRead(
                NULL,
                pParseInfo->Argc,
                pParseInfo->Argv,
                pParseInfo );

    ASSERT( pParseInfo->pRR || status != ERROR_SUCCESS );

    return( status );
}



DNS_STATUS
MinfoFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Process MINFO or RP record.

Arguments:

    pRR - ptr to database record

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;
    PDNS_RPC_NAME   prpcName;
    DWORD           status;
    COUNT_NAME      name1;
    COUNT_NAME      name2;
    DWORD           length1;
    DWORD           length2;
    PDB_NAME        pname;

    //
    //  MINFO   <responsible mailbox> <errors to mailbox>
    //  RP      <responsible mailbox> <text location>
    //

    prpcName = &pRecord->Data.MINFO.nameMailBox;

    if ( ! DNS_IS_NAME_IN_RECORD(pRecord, prpcName) )
    {
        return( DNS_ERROR_RECORD_FORMAT );
    }
    length1 = Name_ConvertRpcNameToCountName(
                    & name1,
                    prpcName );
    if ( ! length1 )
    {
        return( DNS_ERROR_RECORD_FORMAT );
    }

    //  second name

    prpcName = DNS_GET_NEXT_NAME( prpcName );
    if ( ! DNS_IS_NAME_IN_RECORD(pRecord, prpcName) )
    {
        status = DNS_ERROR_RECORD_FORMAT;
    }
    length2 = Name_ConvertRpcNameToCountName(
                    & name2,
                    prpcName );
    if ( ! length2 )
    {
        return( DNS_ERROR_RECORD_FORMAT );
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD)(length1 + length2) );
    IF_NOMEM( !prr )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    pParseInfo->pRR = prr;

    //
    //  copy in names
    //

    pname = &prr->Data.MINFO.nameMailbox;

    Name_CopyCountNameToDbaseName(
        pname,
        & name1 );

    pname = (PDB_NAME) Name_SkipDbaseName( pname );

    Name_CopyCountNameToDbaseName(
        pname,
        & name2 );

    return( ERROR_SUCCESS );
}



DNS_STATUS
WksFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Process WKS record.

Arguments:

    pRR - NULL ptr to database record, since this record type has variable
        length, this routine allocates its own record

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;
    PCHAR           pch;
    PCHAR           pchstop;
    PCHAR           pszservice;
    UCHAR           ch;
    WORD            port;
    WORD            maxPort = 0;
    USHORT          byte;
    UCHAR           bit;
    PDNS_RPC_STRING pstring;
    BYTE            bitmaskBytes[ WKS_MAX_BITMASK_LENGTH ];
    WORD            wbitmaskLength;
    CHAR            szservice[ MAX_PATH ];

    struct servent * pServent;
    struct protoent * pProtoent;


    //
    //  get protocol name -- need for services lookup
    //

    pProtoent = getprotobynumber( (INT)pRecord->Data.WKS.chProtocol );
    if ( ! pProtoent )
    {
        return( DNS_ERROR_INVALID_DATA );
    }

    //
    //  generate bitmask from string of space separated services
    //

    pstring = (PDNS_RPC_STRING) pRecord->Data.WKS.bBitMask;
    // pstring = pRecord->Data.WKS.stringServices;

    if ( ! DNS_IS_NAME_IN_RECORD(pRecord, pstring) )
    {
        return( DNS_ERROR_RECORD_FORMAT );
    }
    pch = pstring->achName;
    pchstop = pch + pstring->cchNameLength;

    DNS_DEBUG( RPC2, (
        "WKS services string %.*s (len=%d)\n",
        pstring->cchNameLength,
        pch,
        pstring->cchNameLength ));

    //  clear bit mask

    RtlZeroMemory(
        bitmaskBytes,
        WKS_MAX_BITMASK_LENGTH );

    //
    //  run through service name list, find port for each service
    //

    while ( pch < pchstop )
    {
        //  strip any leading white space

        if ( *pch == ' ' )
        {
            pch++;
            continue;
        }
        if ( *pch == 0 )
        {
            ASSERT( pch+1 == pchstop );
            break;
        }

        //  found service name start
        //      - if space terminated make NULL terminated

        pszservice = szservice;

        while ( pch < pchstop )
        {
            ch = *pch++;
            if ( ch == 0 )
            {
                break;
            }
            if ( ch == ' ' )
            {
                break;
            }
            *pszservice++ = ch;
        }
        *pszservice = 0;

        //
        //  get port
        //      - verify port supported
        //      - save max port for determining RR length
        //

        pServent = getservbyname(
                        szservice,
                        pProtoent->p_name );
        if ( ! pServent )
        {
            DNS_DEBUG( INIT, (
                "ERROR:  bogus WKS service %s\n",
                szservice ));
            return( DNS_ERROR_INVALID_DATA );
        }
        port = ntohs( pServent->s_port );

        if ( port > WKS_MAX_PORT )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  Encountered well known service (%s) with port (%d) > %d.\n"
                "Need new WKS parsing code to support this port.\n",
                pszservice,
                port,
                WKS_MAX_PORT
                ));
            return( DNS_ERROR_INVALID_DATA );
        }
        else if ( port > maxPort )
        {
            maxPort = port;
        }

        //
        //  set port bit in mask
        //
        //  note that bitmask is just flat run of bits
        //  hence lowest port in byte, corresponds to highest bit
        //  highest port in byte, corresponds to lowest bit and
        //  requires no shift

        byte = port / 8;
        bit  = port % 8;

        bitmaskBytes[ byte ] |=  1 << (7-bit);
    }

    //  if no services, return error

    if ( maxPort == 0 )
    {
        return( DNS_ERROR_INVALID_DATA );
    }

    //
    //  build the RR
    //      - calculate required data length
    //      - allocate and clear data area
    //

    wbitmaskLength = maxPort/8 + 1;

    //  allocate database record

    prr = RR_Allocate( (WORD)(SIZEOF_WKS_FIXED_DATA + wbitmaskLength) );
    IF_NOMEM( !prr )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    pParseInfo->pRR = prr;
    prr->wType = DNS_TYPE_WKS;

    //  server IP address

    prr->Data.WKS.ipAddress = pRecord->Data.WKS.ipAddress;

    //  set protocol

    prr->Data.WKS.chProtocol = (UCHAR) pProtoent->p_proto;

    //  copy bitmask, only through max port's byte

    RtlCopyMemory(
        prr->Data.WKS.bBitMask,
        bitmaskBytes,
        wbitmaskLength );

    return( ERROR_SUCCESS );
}



DNS_STATUS
AaaaFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Process AAAA record.

Arguments:

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;

    //
    //  AAAA in standard wire format
    //

    if ( pRecord->wDataLength != sizeof(IP6_ADDRESS) )
    {
        return( DNS_ERROR_RECORD_FORMAT );
    }

    //  allocate record

    prr = RR_Allocate( sizeof(IP6_ADDRESS) );
    IF_NOMEM( !prr )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    pParseInfo->pRR = prr;

    RtlCopyMemory(
        & prr->Data.AAAA.Ip6Addr,
        & pRecord->Data.AAAA.ipv6Address,
        sizeof(IP6_ADDRESS) );

    return( ERROR_SUCCESS );
}



DNS_STATUS
SrvFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Process SRV compatible RR.

Arguments:

    pRR - ptr to database record

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;
    PDNS_RPC_NAME   prpcName;
    DWORD           status;
    DWORD           length;
    COUNT_NAME      nameTarget;

    //
    //  SRV target host
    //

    prpcName = & pRecord->Data.SRV.nameTarget;
    if ( ! DNS_IS_NAME_IN_RECORD(pRecord, prpcName) )
    {
        return( DNS_ERROR_RECORD_FORMAT );
    }

    length = Name_ConvertRpcNameToCountName(
                    & nameTarget,
                    prpcName );
    if ( ! length )
    {
        return( DNS_ERROR_RECORD_FORMAT );
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD)(SIZEOF_SRV_FIXED_DATA + length) );
    IF_NOMEM( !prr )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    pParseInfo->pRR = prr;

    //
    //  copy fixed fields
    //

    prr->Data.SRV.wPriority = htons( pRecord->Data.SRV.wPriority );
    prr->Data.SRV.wWeight   = htons( pRecord->Data.SRV.wWeight );
    prr->Data.SRV.wPort     = htons( pRecord->Data.SRV.wPort );

    //
    //  copy in name
    //

    Name_CopyCountNameToDbaseName(
            & prr->Data.SRV.nameTarget,
            & nameTarget );

    return( ERROR_SUCCESS );
}



DNS_STATUS
AtmaFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Process ATMA record.

Arguments:

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;

    //
    //  ATMA comes in standard wire format
    //
    //  DEVNOTE: should validate allowable IDs and
    //      length (40 hex, 20 bytes) for AESA type
    //

    //  allocate record

    prr = RR_Allocate( pRecord->wDataLength );
    IF_NOMEM( !prr )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    pParseInfo->pRR = prr;

    RtlCopyMemory(
        & prr->Data,
        & pRecord->Data,
        pRecord->wDataLength );

    return( ERROR_SUCCESS );
}



DNS_STATUS
WinsFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Read WINS record from RPC buffer.

Arguments:

    pRR -- NULL ptr to database record, since this record type has variable
        length, this routine allocates its own record

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDB_RECORD  prr;
    WORD        wdataLength;
    DWORD       status;

    //
    //  determine data length
    //  note:  should be able to just use RPC record datalength, BUT
    //  it is sometimes incorrect;  calculate from WINS server count,
    //  then verify within buffer
    //

    wdataLength = (WORD)(SIZEOF_WINS_FIXED_DATA +
                    pRecord->Data.WINS.cWinsServerCount * sizeof(IP_ADDRESS));

    if ( wdataLength > pRecord->wDataLength )
    {
        return( DNS_ERROR_INVALID_DATA );
    }

    //  allocate database record

    prr = RR_Allocate( wdataLength );
    IF_NOMEM( !prr )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    pParseInfo->pRR = prr;
    ASSERT( prr->wDataLength == wdataLength );
    prr->wType = DNS_TYPE_WINS;

    //
    //  copy data -- RPC record is direct copy of database record
    //

    RtlCopyMemory(
        & prr->Data.WINS,
        & pRecord->Data.WINS,
        wdataLength );

    return( ERROR_SUCCESS );
}



DNS_STATUS
NbstatFlatRead(
    IN      PDNS_FLAT_RECORD    pRecord,
    IN OUT  PPARSE_INFO         pParseInfo
    )
/*++

Routine Description:

    Read WINS-R record from RPC buffer.

Arguments:

    prr -- ptr to database record

    pRecord -- RPC record buffer

    pParseInfo - ptr to parsing info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDB_RECORD      prr;
    PDNS_RPC_NAME   prpcName;
    DWORD           status;
    DWORD           length;
    COUNT_NAME      nameResultDomain;

    //
    //  WINS-R landing domain
    //

    prpcName = &pRecord->Data.WINSR.nameResultDomain;

    if ( ! DNS_IS_NAME_IN_RECORD(pRecord, prpcName) )
    {
        return( DNS_ERROR_RECORD_FORMAT );
    }
    if ( prpcName->cchNameLength == 0 )
    {
        return( DNS_ERROR_INVALID_DATA );
    }
    IF_DEBUG( RPC )
    {
        DNS_PRINT((
            "WINS-R creation.\n"
            "\tresult domain name = %.*s\n"
            "\tname len = %d\n",
            prpcName->cchNameLength,
            prpcName->achName,
            prpcName->cchNameLength ));
    }

    length = Name_ConvertRpcNameToCountName(
                    & nameResultDomain,
                    prpcName );
    if ( ! length )
    {
        return( DNS_ERROR_RECORD_FORMAT );
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD)(SIZEOF_NBSTAT_FIXED_DATA + length) );
    IF_NOMEM( !prr )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    pParseInfo->pRR = prr;

    //
    //  copy WINS-R record fixed fields -- RPC record format is identical
    //

    if ( pRecord->wDataLength < SIZEOF_NBSTAT_FIXED_DATA + sizeof(DNS_RPC_NAME) )
    {
        return( DNS_ERROR_INVALID_DATA );
    }
    RtlCopyMemory(
        & prr->Data.WINSR,
        & pRecord->Data.WINSR,
        SIZEOF_WINS_FIXED_DATA );

    //
    //  copy in name
    //

    Name_CopyCountNameToDbaseName(
           & prr->Data.WINSR.nameResultDomain,
           & nameResultDomain );

    return( ERROR_SUCCESS );
}



//
//  Read RR from RPC buffer functions
//

RR_FLAT_READ_FUNCTION   RRFlatReadTable[] =
{
    NULL,               //  ZERO

    AFlatRead,          //  A
    PtrFlatRead,        //  NS
    PtrFlatRead,        //  MD
    PtrFlatRead,        //  MF
    PtrFlatRead,        //  CNAME
    SoaFlatRead,        //  SOA
    PtrFlatRead,        //  MB
    PtrFlatRead,        //  MG
    PtrFlatRead,        //  MR
    NULL,               //  NULL
    WksFlatRead,        //  WKS
    PtrFlatRead,        //  PTR
    TxtFlatRead,        //  HINFO
    MinfoFlatRead,      //  MINFO
    MxFlatRead,         //  MX
    TxtFlatRead,        //  TXT
    MinfoFlatRead,      //  RP
    MxFlatRead,         //  AFSDB
    TxtFlatRead,        //  X25
    TxtFlatRead,        //  ISDN
    MxFlatRead,         //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    SigFlatRead,        //  SIG
    KeyFlatRead,        //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    AaaaFlatRead,       //  AAAA
    NULL,               //  LOC
    NxtFlatRead,        //  NXT
    NULL,               //  31
    NULL,               //  32
    SrvFlatRead,        //  SRV
    AtmaFlatRead,       //  ATMA
    NULL,               //  35
    NULL,               //  36
    NULL,               //  37
    NULL,               //  38
    NULL,               //  39
    NULL,               //  40
    NULL,               //  OPT
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //  note these follow, but require OFFSET_TO_WINS_RR subtraction
    //  from actual type value

    WinsFlatRead,       //  WINS
    NbstatFlatRead      //  WINSR
};



DNS_STATUS
Flat_RecordRead(
    IN      PZONE_INFO          pZone,      OPTIONAL
    IN      PDB_NODE            pNode,
    IN      PDNS_RPC_RECORD     pFlatRR,
    OUT     PDB_RECORD *        ppResultRR
    )
/*++

Routine Description:

    Create resource record from data.

Arguments:

    pZone       -- zone context, used to lookup non-FQDN names
    pNode       -- owner node
    pFlatRR     -- RR information
    ppResultRR  -- addr to receive ptr to created RR

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDB_RECORD      prr = NULL;
    DNS_STATUS      status = ERROR_SUCCESS;
    WORD            type;
    PARSE_INFO      parseInfo;
    PPARSE_INFO     pparseInfo = &parseInfo;
    RR_FLAT_READ_FUNCTION   preadFunction;

    //
    //  verification
    //

    if ( !pFlatRR )
    {
        ASSERT( FALSE );
        return( DNS_ERROR_INVALID_DATA );
    }

    //
    //  create resource record (RR) to link to node
    //
    //      - pFlatRR->wDataLength contains length for non-standard types
    //      - must flip TTL to store in net byte order
    //

    type= pFlatRR->wType;

    DNS_DEBUG( RPC, (
        "Building RR type %s (%d) from RPC buffer.\n"
        "\twith flags = %p\n",
        DnsRecordStringForType( type ),
        type,
        pFlatRR->dwFlags
        ));

    //
    //  dispatching load function for desired type
    //
    //  - save type for potential use by type's routine
    //  - save ptr to RR, so can restore from this location
    //  regardless of whether created here or in type's routine
    //

    pparseInfo->pRR = NULL;
    pparseInfo->wType = type;
    pparseInfo->pnodeOwner = pNode;
    pparseInfo->pZone = NULL;
    pparseInfo->dwAppendFlag = 0;

    preadFunction = (RR_FLAT_READ_FUNCTION)
                        RR_DispatchFunctionForType(
                            (RR_GENERIC_DISPATCH_FUNCTION *) RRFlatReadTable,
                            type );
    if ( !preadFunction )
    {
        DNS_PRINT((
            "ERROR:  Attempt to build unsupported RR type %d in RPC buffer.\n",
            type ));
        status = DNS_ERROR_UNKNOWN_RECORD_TYPE;
        ASSERT( FALSE );
        goto Failed;
    }

    status = preadFunction(
                pFlatRR,
                pparseInfo );

    //
    //  make status check -- saves status checks in case blocks
    //      - special case adding local WINS record
    //      - handle to local WINS record not necessary

    if ( status != ERROR_SUCCESS )
    {
        if ( status == DNS_INFO_ADDED_LOCAL_WINS )
        {
            prr = pparseInfo->pRR;
            status = ERROR_SUCCESS;
            goto Done;
        }
        DNS_PRINT((
            "ERROR:  DnsRpcRead routine failure %p (%d) for record type %d.\n\n\n",
            status, status,
            type ));
        goto Failed;
    }

    //
    //  recover ptr to type -- may have been created inside type routine
    //      for non-fixed-length types
    //

    prr = pparseInfo->pRR;
    prr->wType = pparseInfo->wType;

    Mem_ResetTag( prr, MEMTAG_RECORD_ADMIN );

    //
    //  set TTL
    //      - to explicit value, if given
    //      - otherwise to default value for zone
    //
    //  do this here, so SOA record gets default TTL that it contains
    //

    prr->dwTtlSeconds = htonl( pFlatRR->dwTtlSeconds );

    prr->dwTimeStamp = pFlatRR->dwTimeStamp;

    if ( pZone && !IS_ZONE_CACHE(pZone) )
    {
        if ( (pFlatRR->dwFlags & DNS_RPC_RECORD_FLAG_DEFAULT_TTL)
                ||
            pZone->dwDefaultTtlHostOrder == pFlatRR->dwTtlSeconds )
        {
            prr->dwTtlSeconds = pZone->dwDefaultTtl;
            SET_ZONE_TTL_RR(prr);
        }
    }

    goto Done;

Failed:

    if ( prr )
    {
        RR_Free( prr );
    }
    prr = NULL;

Done:

    if ( ppResultRR )
    {
        *ppResultRR = prr;
    }
    return( status );
}



DNS_STATUS
Flat_BuildRecordFromFlatBufferAndEnlist(
    IN      PZONE_INFO          pZone,      OPTIONAL
    IN      PDB_NODE            pNode,
    IN      PDNS_RPC_RECORD     pFlatRR,
    OUT     PDB_RECORD *        ppResultRR  OPTIONAL
    )
/*++

Routine Description:

    Create resource record from data.

Arguments:

    pZone       -- zone context, used to lookup non-FQDN names
    pNode  -- RR owner node
    pnameOwner  -- RR owner, in DNS_RPC_NAME format
    pFlatRR     -- RR information
    ppResultRR  -- addr to receive ptr to created RR

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDB_RECORD      prr = NULL;
    PDNS_RPC_NAME   pname;
    DNS_STATUS      status = ERROR_SUCCESS;

    DNS_DEBUG( RPC2, (
        "Flat_BuildRecordFromFlatBufferAndEnlist for pFlatRR at %p\n",
        pFlatRR ));

    //
    //  verification
    //

    if ( !pNode )
    {
        ASSERT( FALSE );
        return( DNS_ERROR_INVALID_NAME );
    }

    //
    //  build RPC record into real record
    //

    IF_DEBUG( RPC )
    {
        Dbg_NodeName(
            "\tBuild record from RPC at node ",
            pNode,
            "\n" );
    }
    status = Flat_RecordRead(
                pZone,
                pNode,
                pFlatRR,
                & prr );
    if ( status != ERROR_SUCCESS )
    {
        goto Failed;
    }
    ASSERT( prr );

    //
    //  add resource record to node's RR list
    //

    status = RR_AddToNode(
                pZone,
                pNode,
                prr
                );
    if ( status != ERROR_SUCCESS )
    {
        goto Failed;
    }
    IF_DEBUG( RPC2 )
    {
        Dbg_DbaseNode(
           "Node after Admin create of new record\n",
           pNode );
    }

    //
    //  set ptr to resulting
    //

    if ( ppResultRR )
    {
        *ppResultRR = prr;
    }
    return( status );

Failed:

    if ( prr )
    {
        RR_Free( prr );
    }
    if ( ppResultRR )
    {
        *ppResultRR = NULL;
    }
    return( status );
}



DNS_STATUS
Flat_CreatePtrRecordFromDottedName(
    IN      PZONE_INFO      pZone,          OPTIONAL
    IN      PDB_NODE        pNode,
    IN      LPSTR           pszDottedName,
    IN      WORD            wType,
    OUT     PDB_RECORD *    ppResultRR      OPTIONAL
    )
/*++

Routine Description:

    Create PTR (or other single indirection record) at node
    dotted name.

Arguments:

    pZone -- zone to create NS record for

    pNode -- node to host record

    pszDottedName -- name record points to

    ppResultRR -- resulting record

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PDNS_RPC_RECORD precord;
    PDNS_RPC_NAME   pname;
    INT             nameLength;
    PBYTE           precordEnd;
    CHAR            chBuffer[ 700 ];    // big enough for record with max name

    DNS_DEBUG( INIT, (
        "Flat_CreatePtrRecordFromDottedName()\n"
        "\tpszDottedName = %s\n",
        pszDottedName ));

    //
    //  create PTR record
    //

    precord = (PDNS_RPC_RECORD) chBuffer;

    RtlZeroMemory(
        precord,
        SIZEOF_FLAT_RECORD_HEADER );

    precord->wType = wType;
    precord->dwFlags = DNS_RPC_FLAG_RECORD_DEFAULT_TTL;

    //  write name as record data

    pname = &precord->Data.PTR.nameNode;

    nameLength = strlen( pszDottedName );

    RtlCopyMemory(
        pname->achName,
        pszDottedName,
        nameLength );

    pname->cchNameLength = (UCHAR) nameLength;

    //  fill in record datalength

    precordEnd = pname->achName + nameLength;
    precord->wDataLength = (WORD) (precordEnd - (PBYTE)&precord->Data);

    //
    //  add record to database
    //

    status = Flat_BuildRecordFromFlatBufferAndEnlist(
                pZone,
                pNode,
                precord,
                ppResultRR
                );
    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT((
            "ERROR: creating new PTR from dotted name %s.\n"
            "\tstatus = %p (%d).\n",
            pszDottedName,
            status, status ));
    }
    return( status );
}



//
//  Flat write section
//
//  Type specific functions for writing flat records.
//

PCHAR
AFlatWrite(
    IN OUT  PDNS_FLAT_RECORD    pFlatRR,
    IN      PDB_RECORD          pRR,
    IN      PCHAR               pch,
    IN      PCHAR               pchBufEnd
    )
/*++

Routine Description:

    Process A record.

Arguments:

    pFlatRR - flat record being written

    pRR - ptr to database record

    pch - position in flat buffer to write data

    pchBufEnd - end of flat buffer

Return Value:

    Ptr to next position in buffer.
    NULL on error.

--*/
{
    if ( pch + SIZEOF_IP_ADDRESS > pchBufEnd )
    {
        return( NULL );
    }
    *(PDWORD)pch = pRR->Data.A.ipAddress;

    return( pch + sizeof(IP_ADDRESS) );
}



PCHAR
PtrFlatWrite(
    IN OUT  PDNS_FLAT_RECORD    pFlatRR,
    IN      PDB_RECORD          pRR,
    IN      PCHAR               pch,
    IN      PCHAR               pchBufEnd
    )
/*++

Routine Description:

    Process PTR compatible record.
    Includes: PTR, NS, CNAME, MB, MR, MG, MD, MF

Arguments:

    pFlatRR - flat record being written

    pRR - ptr to database record

    pch - position in flat buffer to write data

    pchBufEnd - end of flat buffer

Return Value:

    Ptr to next position in buffer.
    NULL on error.

--*/
{
    //
    //  all these RR are single indirection RR
    //

    pch = Name_WriteDbaseNameToRpcBuffer(
            pch,
            pchBufEnd,
            & pRR->Data.PTR.nameTarget,
            FALSE );

    return( pch );
}



PCHAR
SoaFlatWrite(
    IN OUT  PDNS_FLAT_RECORD    pFlatRR,
    IN      PDB_RECORD          pRR,
    IN      PCHAR               pch,
    IN      PCHAR               pchBufEnd
    )
/*++

Routine Description:

    Write SOA compatible record to flat buffer.
    Includes:  SOA, MINFO, RP.

Arguments:

    pFlatRR - flat record being written

    pRR - ptr to database record

    pch - position in flat buffer to write data

    pchBufEnd - end of flat buffer

Return Value:

    Ptr to next position in buffer.
    NULL on error.

--*/
{
    PDB_NAME    pname;

    //
    //  copy / byte swap SOA fixed fields
    //      - dwSerialNo
    //      - dwRefresh
    //      - dwRetry
    //      - dwExpire
    //      - dwMinimumTtl

    if ( pRR->wType == DNS_TYPE_SOA )
    {
        if ( pchBufEnd - pch < SIZEOF_SOA_FIXED_DATA )
        {
            return( NULL );
        }
        pFlatRR->Data.SOA.dwSerialNo    = htonl( pRR->Data.SOA.dwSerialNo );
        pFlatRR->Data.SOA.dwRefresh     = htonl( pRR->Data.SOA.dwRefresh );
        pFlatRR->Data.SOA.dwRetry       = htonl( pRR->Data.SOA.dwRetry );
        pFlatRR->Data.SOA.dwExpire      = htonl( pRR->Data.SOA.dwExpire );
        pFlatRR->Data.SOA.dwMinimumTtl  = htonl( pRR->Data.SOA.dwMinimumTtl );
        pch += SIZEOF_SOA_FIXED_DATA;
    }

    //  SOA name server

    pname = &pRR->Data.SOA.namePrimaryServer;

    pch = Name_WriteDbaseNameToRpcBuffer(
            pch,
            pchBufEnd,
            pname,
            FALSE );
    if ( !pch )
    {
        return NULL;
    }

    //  Zone admin

    pname = Name_SkipDbaseName( pname );

    pch = Name_WriteDbaseNameToRpcBuffer(
            pch,
            pchBufEnd,
            pname,
            TRUE );

    return( pch );
}



PCHAR
KeyFlatWrite(
    IN OUT  PDNS_FLAT_RECORD    pFlatRR,
    IN      PDB_RECORD          pRR,
    IN      PCHAR               pch,
    IN      PCHAR               pchBufEnd
    )
/*++

Routine Description:

    Write key record to flat buffer.

Arguments:

    pFlatRR - flat record being written

    pRR - ptr to database record

    pch - position in flat buffer to write data

    pchBufEnd - end of flat buffer

Return Value:

    Ptr to next position in buffer.
    NULL on error.

--*/
{
    if ( pchBufEnd - pch < pRR->wDataLength )
    {
        return NULL;
    }

    pFlatRR->Data.KEY.wFlags        = htons( pRR->Data.KEY.wFlags );
    pFlatRR->Data.KEY.chProtocol    = pRR->Data.KEY.chProtocol;
    pFlatRR->Data.KEY.chAlgorithm   = pRR->Data.KEY.chAlgorithm;

    RtlCopyMemory(
        pFlatRR->Data.KEY.bKey,
        &pRR->Data.KEY.Key,
        pRR->wDataLength - SIZEOF_KEY_FIXED_DATA );

    pch += pRR->wDataLength;

    return pch;
}   //  KeyFlatWrite



PCHAR
SigFlatWrite(
    IN OUT  PDNS_FLAT_RECORD    pFlatRR,
    IN      PDB_RECORD          pRR,
    IN      PCHAR               pch,
    IN      PCHAR               pchBufEnd
    )
/*++

Routine Description:

    Write sig record to flat buffer.

Arguments:

    pFlatRR - flat record being written

    pRR - ptr to database record

    pch - position in flat buffer to write data

    pchBufEnd - end of flat buffer

Return Value:

    Ptr to next position in buffer.
    NULL on error.

--*/
{
    int         sigLength;

    if ( pchBufEnd - pch < SIZEOF_SIG_FIXED_DATA )
    {
        return NULL;
    }
    pFlatRR->Data.SIG.wTypeCovered      = htons( pRR->Data.SIG.wTypeCovered );
    pFlatRR->Data.SIG.chAlgorithm       = pRR->Data.SIG.chAlgorithm;
    pFlatRR->Data.SIG.chLabelCount      = pRR->Data.SIG.chLabelCount;
    pFlatRR->Data.SIG.dwOriginalTtl     = htonl( pRR->Data.SIG.dwOriginalTtl );
    pFlatRR->Data.SIG.dwSigExpiration   = htonl( pRR->Data.SIG.dwSigExpiration );
    pFlatRR->Data.SIG.dwSigInception    = htonl( pRR->Data.SIG.dwSigInception );
    pFlatRR->Data.SIG.wKeyTag           = htons( pRR->Data.SIG.wKeyTag );
    pch += SIZEOF_SIG_FIXED_DATA;

    pch = Name_WriteDbaseNameToRpcBuffer(
            pch,
            pchBufEnd,
            &pRR->Data.SIG.nameSigner,
            FALSE );
    if ( !pch )
    {
        return NULL;
    }

    sigLength = pRR->wDataLength -
                SIZEOF_SIG_FIXED_DATA - 
                DBASE_NAME_SIZE( &pRR->Data.SIG.nameSigner );
    ASSERT( sigLength > 0 );

    if ( pchBufEnd - pch < sigLength )
    {
        return NULL;
    }
    RtlCopyMemory(
        pch,
        ( PBYTE ) &pRR->Data.SIG.nameSigner +
            DBASE_NAME_SIZE( &pRR->Data.SIG.nameSigner ),
        sigLength );
    pch += sigLength;

    return pch;
}   //  SigFlatWrite



PCHAR
NxtFlatWrite(
    IN OUT  PDNS_FLAT_RECORD    pFlatRR,
    IN      PDB_RECORD          pRR,
    IN      PCHAR               pch,
    IN      PCHAR               pchBufEnd
    )
/*++

Routine Description:

    Write NXT record to flat buffer.

Arguments:

    pFlatRR - flat record being written

    pRR - ptr to database record

    pch - position in flat buffer to write data

    pchBufEnd - end of flat buffer

Return Value:

    Ptr to next position in buffer.
    NULL on error.

--*/
{
    INT         byteIdx;
    INT         bitIdx;
    PWORD       pWordCount = ( PWORD ) pch;

    //
    //  Write word count followed by word array.
    //

    *pWordCount = 0;
    pch += sizeof( WORD );
    for ( byteIdx = 0; byteIdx < DNS_MAX_TYPE_BITMAP_LENGTH; ++byteIdx )
    {
        for ( bitIdx = ( byteIdx ? 0 : 1 ); bitIdx < 8; ++bitIdx )
        {
            PCHAR   pszType;

            if ( !( pRR->Data.NXT.bTypeBitMap[ byteIdx ] &
                    ( 1 << bitIdx ) ) )
            {
                continue;   // Bit value is zero - do not write string.
            }
            if ( pchBufEnd - pch < sizeof( WORD ) )
            {
                return NULL;
            }
            * ( WORD * ) pch = byteIdx * 8 + bitIdx;
            pch += sizeof( WORD );
            ++( *pWordCount );
        } 
    }

    //
    //  Write next name.
    //

    pch = Name_WriteDbaseNameToRpcBuffer(
            pch,
            pchBufEnd,
            &pRR->Data.NXT.nameNext,
            FALSE );
    if ( !pch )
    {
        return NULL;
    }

    return pch;
}   //  NxtFlatWrite



PCHAR
MinfoFlatWrite(
    IN OUT  PDNS_FLAT_RECORD    pFlatRR,
    IN      PDB_RECORD          pRR,
    IN      PCHAR               pch,
    IN      PCHAR               pchBufEnd
    )
/*++

Routine Description:

    Write MINFO compatible record to flat buffer.
    Includes:  MINFO, RP.

Arguments:

    pFlatRR - flat record being written

    pRR - ptr to database record

    pch - position in flat buffer to write data

    pchBufEnd - end of flat buffer

Return Value:

    Ptr to next position in buffer.
    NULL on error.

--*/
{
    PDB_NAME    pname;

    //  mailbox

    pname = &pRR->Data.MINFO.nameMailbox;

    pch = Name_WriteDbaseNameToRpcBuffer(
            pch,
            pchBufEnd,
            pname,
            FALSE );

    //  errors mailbox

    pname = Name_SkipDbaseName( pname );

    pch = Name_WriteDbaseNameToRpcBuffer(
            pch,
            pchBufEnd,
            pname,
            FALSE );

    return( pch );
}



PCHAR
MxFlatWrite(
    IN OUT  PDNS_FLAT_RECORD    pFlatRR,
    IN      PDB_RECORD          pRR,
    IN      PCHAR               pch,
    IN      PCHAR               pchBufEnd
    )
/*++

Routine Description:

    Write MX compatible record to flat buffer.
    Includes: MX, RT, AFSDB

Arguments:

    pFlatRR - flat record being written

    pRR - ptr to database record

    pch - position in flat buffer to write data

    pchBufEnd - end of flat buffer

Return Value:

    Ptr to next position in buffer.
    NULL on error.

--*/
{
    //
    //  MX preference value
    //  RT preference
    //  AFSDB subtype
    //

    if ( pchBufEnd - pch < sizeof(WORD) )
    {
        return( NULL );
    }
    *(WORD *) pch = ntohs( pRR->Data.MX.wPreference );
    pch += sizeof( WORD );

    //
    //  MX exchange
    //  RT exchange
    //  AFSDB hostname
    //

    pch = Name_WriteDbaseNameToRpcBuffer(
            pch,
            pchBufEnd,
            & pRR->Data.MX.nameExchange,
            FALSE );

    return( pch );
}



PCHAR
FlatFlatWrite(
    IN OUT  PDNS_FLAT_RECORD    pFlatRR,
    IN      PDB_RECORD          pRR,
    IN      PCHAR               pch,
    IN      PCHAR               pchBufEnd
    )
/*++

Routine Description:

    Write flat compatible record to flat buffer.
    These records have exactly the same database and flat record
    format so need only mem copy.

    Includes: TXT, HINFO, ISDN, X25, AAAA, WINS

Arguments:

    pFlatRR - flat record being written

    pRR - ptr to database record

    pch - position in flat buffer to write data

    pchBufEnd - end of flat buffer

Return Value:

    Ptr to next position in buffer.
    NULL on error.

--*/
{
    if ( pchBufEnd - pch < pRR->wDataLength )
    {
        return( NULL );
    }

    RtlCopyMemory(
        pch,
        & pRR->Data,
        pRR->wDataLength );

    pch += pRR->wDataLength;
    return( pch );
}



PCHAR
WksFlatWrite(
    IN OUT  PDNS_FLAT_RECORD    pFlatRR,
    IN      PDB_RECORD          pRR,
    IN      PCHAR               pch,
    IN      PCHAR               pchBufEnd
    )
/*++

Routine Description:

    Write WKS record to flat buffer.

Arguments:

    pFlatRR - flat record being written

    pRR - ptr to database record

    pch - position in flat buffer to write data

    pchBufEnd - end of flat buffer

Return Value:

    Ptr to next position in buffer.
    NULL on error.

--*/
{
    PDNS_RPC_NAME   pstringServices;
    INT             i;
    USHORT          port;
    UCHAR           bBitmask;
    struct servent * pServent;
    struct protoent * pProtoent;


    //  server address

    if ( pch + SIZEOF_WKS_FIXED_DATA > pchBufEnd )
    {
        return( NULL );
    }
    *(DWORD *)pch = pRR->Data.WKS.ipAddress;
    pch += SIZEOF_IP_ADDRESS;

    //  protocol

    *pch = pRR->Data.WKS.chProtocol;
    pch++;

    pProtoent = getprotobynumber( (INT) pRR->Data.WKS.chProtocol );
    if ( ! pProtoent )
    {
        DNS_PRINT((
            "ERROR:  Unable to find protocol %d, writing WKS record.\n",
            (INT) pRR->Data.WKS.chProtocol
            ));
        pServent = NULL;
    }

    //
    //  services
    //
    //  find each bit set in bitmask, lookup and write service
    //  corresponding to that port
    //
    //  note, that since that port zero is the front of port bitmask,
    //  lowest ports are the highest bits in each byte
    //

    pstringServices = (PDNS_RPC_STRING) pch;

    for ( i = 0;
            i < (INT)(pRR->wDataLength - SIZEOF_WKS_FIXED_DATA);
                i++ )
    {
        bBitmask = (UCHAR) pRR->Data.WKS.bBitMask[i];

        port = i * 8;

        //  write service name for each bit set in byte
        //      - get out as soon byte is empty of ports
        //      - terminate each name with blank (until last)

        while ( bBitmask )
        {
            if ( bBitmask & 0x80 )
            {
                if ( pProtoent )
                {
                    pServent = getservbyport(
                                    (INT) htons(port),
                                    pProtoent->p_name );
                }
                if ( pServent )
                {
                    INT copyCount = strlen(pServent->s_name);

                    pch++;
                    if ( pchBufEnd - pch <= copyCount+1 )
                    {
                        return( NULL );
                    }
                    RtlCopyMemory(
                        pch,
                        pServent->s_name,
                        copyCount );
                    pch += copyCount;
                    *pch = ' ';
                }

                //  failed to find service name -- write port as integer
                //  note max 5 chars in WORD base 10, so that's our
                //      out of buffer test

                else
                {
                    DNS_PRINT((
                        "ERROR:  in WKS write.\n"
                        "\tUnable to find service for port %d, protocol %s.\n",
                        port,
                        pProtoent->p_name ));

                    if ( pchBufEnd - pch <= 6 )
                    {
                        return( NULL );
                    }
                    pch += sprintf( pch, "%u ", port );
                }
            }
            port++;             // next service port
            bBitmask <<= 1;     // shift mask up to read next port
        }
    }

    //  NULL terminate services string and write byte count

    *pch++ = 0;
    pstringServices->cchNameLength = (UCHAR) (pch - pstringServices->achName);

    //  return next position in buffer

    return( pch );
}



PCHAR
SrvFlatWrite(
    IN OUT  PDNS_FLAT_RECORD    pFlatRR,
    IN      PDB_RECORD          pRR,
    IN      PCHAR               pch,
    IN      PCHAR               pchBufEnd
    )
/*++

Routine Description:

    Write SRV record to flat buffer.

Arguments:

    pFlatRR - flat record being written

    pRR - ptr to database record

    pch - position in flat buffer to write data

    pchBufEnd - end of flat buffer

Return Value:

    Ptr to next position in buffer.
    NULL on error.

--*/
{
    //
    //  SRV fixed fields -- priority, weight, port
    //

    if ( pchBufEnd - pch < 3*sizeof(WORD) )
    {
        return( NULL );
    }
    *(WORD *) pch = ntohs( pRR->Data.SRV.wPriority );
    pch += sizeof( WORD );
    *(WORD *) pch = ntohs( pRR->Data.SRV.wWeight );
    pch += sizeof( WORD );
    *(WORD *) pch = ntohs( pRR->Data.SRV.wPort );
    pch += sizeof( WORD );

    //
    //  SRV target host
    //

    pch = Name_WriteDbaseNameToRpcBuffer(
            pch,
            pchBufEnd,
            & pRR->Data.SRV.nameTarget,
            FALSE );

    return( pch );
}



PCHAR
NbstatFlatWrite(
    IN OUT  PDNS_FLAT_RECORD    pFlatRR,
    IN      PDB_RECORD          pRR,
    IN      PCHAR               pch,
    IN      PCHAR               pchBufEnd
    )
/*++

Routine Description:

    Write WINSR record to flat buffer.

Arguments:

    pFlatRR - flat record being written

    pRR - ptr to database record

    pch - position in flat buffer to write data

    pchBufEnd - end of flat buffer

Return Value:

    Ptr to next position in buffer.
    NULL on error.

--*/
{
    //
    //  NBSTAT flags
    //      - note these are stored in HOST order for easy use
    //

    if ( pchBufEnd - pch < SIZEOF_NBSTAT_FIXED_DATA )
    {
        return( NULL );
    }
    *(DWORD *) pch = pRR->Data.WINSR.dwMappingFlag;
    pch += sizeof( DWORD );
    *(DWORD *) pch = pRR->Data.WINSR.dwLookupTimeout;
    pch += sizeof( DWORD );
    *(DWORD *) pch = pRR->Data.WINSR.dwCacheTimeout;
    pch += sizeof( DWORD );

    //
    //  NBSTAT domain
    //

    pch = Name_WriteDbaseNameToRpcBuffer(
            pch,
            pchBufEnd,
            & pRR->Data.WINSR.nameResultDomain,
            FALSE );

    return( pch );
}



//
//  Write RR to flat buffer functions
//

RR_FLAT_WRITE_FUNCTION  RRFlatWriteTable[] =
{
    FlatFlatWrite,      //  ZERO -- default for unknown types is flat write

    AFlatWrite,         //  A
    PtrFlatWrite,       //  NS
    PtrFlatWrite,       //  MD
    PtrFlatWrite,       //  MF
    PtrFlatWrite,       //  CNAME
    SoaFlatWrite,       //  SOA
    PtrFlatWrite,       //  MB
    PtrFlatWrite,       //  MG
    PtrFlatWrite,       //  MR
    NULL,               //  NULL
    WksFlatWrite,       //  WKS
    PtrFlatWrite,       //  PTR
    FlatFlatWrite,      //  HINFO
    MinfoFlatWrite,     //  MINFO
    MxFlatWrite,        //  MX
    FlatFlatWrite,      //  TXT
    MinfoFlatWrite,     //  RP
    MxFlatWrite,        //  AFSDB
    FlatFlatWrite,      //  X25
    FlatFlatWrite,      //  ISDN
    MxFlatWrite,        //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    SigFlatWrite,       //  SIG
    KeyFlatWrite,       //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    FlatFlatWrite,      //  AAAA
    FlatFlatWrite,      //  LOC
    NxtFlatWrite,       //  NXT
    NULL,               //  31
    NULL,               //  32
    SrvFlatWrite,       //  SRV
    FlatFlatWrite,      //  ATMA
    NULL,               //  35
    NULL,               //  36
    NULL,               //  37
    NULL,               //  38
    NULL,               //  39
    NULL,               //  40
    NULL,               //  OPT
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //  note these follow, but require OFFSET_TO_WINS_RR subtraction
    //  from actual type value

    FlatFlatWrite,      //  WINS
    NbstatFlatWrite     //  WINSR
};




DNS_STATUS
Flat_WriteRecordToBuffer(
    IN OUT  PBUFFER         pBuffer,
    IN      PDNS_RPC_NODE   pRpcNode,
    IN      PDB_RECORD      pRR,
    IN      PDB_NODE        pNode,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Add resource record to flat (RPC or DS) buffer.

Arguments:

    ppCurrent - addr of current ptr in buffer

    pchBufEnd - ptr to byte after buffer

    pRpcNode - ptr to record name for this buffer

    pRR - database RR information to include in answer

    pNode - database node this record belongs to

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_MORE_DATA if out of space in buffer.
    Error code on failure.

--*/
{
    PDNS_RPC_RECORD pflatRR;
    PCHAR           pch = pBuffer->pchCurrent;
    PCHAR           pbufEnd = pBuffer->pchEnd;
    DWORD           ttl;
    DWORD           currentTime;
    DNS_STATUS      status;
    RR_FLAT_WRITE_FUNCTION  pwriteFunction;

    ASSERT( IS_DWORD_ALIGNED(pch) );
    ASSERT( pRR != NULL );
    pflatRR = (PDNS_RPC_RECORD) pch;

    DNS_DEBUG( RPC, (
        "Flat_WriteRecordToBuffer().\n"
        "\tWriting RR at %p to buffer at %p, with buffer end at %p.\n"
        "\tBuffer node at %p\n"
        "\tFlags = %p\n",
        pRR,
        pflatRR,
        pbufEnd,
        pRpcNode,
        dwFlag ));

    //
    //  last error will be set on failure for out-of-buffer condition
    //  clear last error now, so any error is valid
    //

    SetLastError( ERROR_SUCCESS );

    //  verify record size not messed up

    ASSERT( SIZEOF_DNS_RPC_RECORD_HEADER ==
                        ((PBYTE)&pflatRR->Data - (PBYTE)pflatRR) );

    //
    //  fill RR structure
    //      - set ptr
    //      - set type and class
    //      - set datalength once we're finished
    //

    if ( pbufEnd - (PCHAR)pflatRR < SIZEOF_DNS_RPC_RECORD_HEADER )
    {
        goto MoreData;
    }
    pflatRR->wType          = pRR->wType;
    pflatRR->dwFlags        = RR_RANK(pRR);
    pflatRR->dwSerial       = 0;
    pflatRR->dwTimeStamp    = pRR->dwTimeStamp;
    pflatRR->dwReserved     = 0;

    //
    //  Zone root record ?
    //

    if ( IS_ZONE_ROOT(pNode) )
    {
        pflatRR->dwFlags |= DNS_RPC_FLAG_ZONE_ROOT;
        if ( IS_AUTH_ZONE_ROOT(pNode) )
        {
            pflatRR->dwFlags |= DNS_RPC_FLAG_AUTH_ZONE_ROOT;
        }
    }

    //
    //  TTL
    //      - cache data TTL is in form of timeout time
    //      - regular authoritative data TTL is STATIC TTL in net byte order
    //

    ttl = pRR->dwTtlSeconds;

    if ( IS_CACHE_RR(pRR) )
    {
        currentTime = DNS_TIME();
        if ( ttl < currentTime )
        {
            DNS_DEBUG( RPC, (
                "Dropping timed out record at %p from flat write.\n"
                "\trecord ttl = %d, current time = %d\n",
                pRR,
                ttl,
                currentTime ));
            //return( DNS_ERROR_RECORD_TIMED_OUT );
            return( ERROR_SUCCESS );
        }
        pflatRR->dwTtlSeconds = ttl - currentTime;
        pflatRR->dwFlags |= DNS_RPC_RECORD_FLAG_CACHE_DATA;
    }
    else
    {
        pflatRR->dwTtlSeconds = ntohl( ttl );
    }

    //
    //  write RR data
    //

    pch = (PCHAR) &pflatRR->Data;

    DNS_DEBUG( RPC2, (
        "Wrote record header at %p.\n"
        "\tStarting data write at %p.\n"
        "\t%d bytes available.\n",
        pflatRR,
        pch,
        pbufEnd - pch ));


    pwriteFunction = (RR_FLAT_WRITE_FUNCTION)
                        RR_DispatchFunctionForType(
                            (RR_GENERIC_DISPATCH_FUNCTION *) RRFlatWriteTable,
                            pRR->wType );
    if ( !pwriteFunction )
    {
        ASSERT( FALSE );
        return( ERROR_INVALID_PARAMETER );
    }
    pch = pwriteFunction(
                pflatRR,
                pRR,
                pch,
                pbufEnd );
    if ( !pch )
    {
        DNS_DEBUG( RPC, (
            "WARNING:  RRFlatWrite routine failure for record type %d,\n"
            "\tassuming out of buffer space\n",
            pRR->wType ));
        goto MoreData;
    }

    //
    //  write record length
    //

    ASSERT( pch > (PCHAR)&pflatRR->Data );

    pflatRR->wDataLength = (WORD) (pch - (PCHAR)&pflatRR->Data);

    //  successful => increment count of RR attached to name

    if ( pRpcNode )
    {
        pRpcNode->wRecordCount++;
    }

    //
    //  reset current ptr for next record
    //      - DWORD align
    //

    pch = (PCHAR) DNS_NEXT_DWORD_PTR(pch);
    ASSERT( pch && IS_DWORD_ALIGNED(pch) );
    pBuffer->pchCurrent = pch;

    IF_DEBUG( RPC2 )
    {
        DnsDbg_RpcRecord(
            "RPC record written to buffer",
            pflatRR );
        DNS_PRINT((
            "Wrote RR at %p to buffer at position %p.\n"
            "\tNew pCurrent = %p\n",
            pRR,
            pflatRR,
            pch ));
    }
    return( ERROR_SUCCESS );


MoreData:

    //
    //  error writing record to buffer
    //      - default assumption is out of space
    //      - in any case leave ppCurrent unchanged so can resume write
    //

    status = GetLastError();

    if ( status == ERROR_SUCCESS )
    {
        status = ERROR_MORE_DATA;
    }

    if ( status == ERROR_MORE_DATA )
    {
        DNS_DEBUG( RPC, (
            "INFO:  Unable to write RR at %p to buffer -- out of space.\n"
            "\tpchCurrent   %p\n"
            "\tpbufEnd    %p\n",
            pRR,
            pch,
            pbufEnd ));
    }
    else
    {
        DNS_DEBUG( ANY, (
            "ERROR:  %d (%p) writing RR at %p to buffer.\n"
            "\tpchCurrent   %p\n"
            "\tpbufEnd    %p\n",
            pRR,
            pch,
            pbufEnd ));
    }

    return( status );
}

//
//  End rrflat.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\rrlist.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    rrlist.c

Abstract:

    Domain Name System (DNS) Server

    Routines to handle resource records (RR) lists.

Author:

    Jim Gilroy (jamesg)     March, 1995

Revision History:

    jamesg      1997    --  update RR list routines
                            name error caching
                            CNAME BIND compatibility

--*/


#include "dnssrv.h"


//
//  Name error caching time
//      - max value controlled by SrvCfg_dwMaxNegativeCacheTtl
//      - min value of a minute
//

#define MIN_NAME_ERROR_TTL      (60)

//
//  Dummy refresh time that means force refresh
//

#define FORCE_REFRESH_DUMMY_TIME    (MAXDWORD)



//
//  Private protos
//

VOID
deleteCachedRecordsForUpdate(
    IN OUT  PDB_NODE        pNode
    );

DNS_STATUS
FASTCALL
checkCnameConditions(
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pRR,
    IN      WORD            wType
    );

VOID
RR_ListResetNodeFlags(
    IN OUT  PDB_NODE        pNode
    );



PDB_RECORD
RR_FindNextRecord(
    IN      PDB_NODE        pNode,
    IN      WORD            wType,
    IN      PDB_RECORD      pRecord,
    IN      DWORD           dwQueryTime
    )
/*++

Routine Description:

    Gets next resource record in a domain node that matches a given type.

    JJW: NEW!!! This function can be used to retrieve records from the
    cache that are expired. So when a cache record is found, if it is timed
    out we must delete it and NOT return it as a match.

Arguments:

    pNode - ptr to node to find record at

    wType - type of record to find;  type ALL to just get next record in list

    pRecord - ptr to previous record;  NULL to start at beginning of list.

    dwQueryTime - query time: used to determine if the found record is
        timed out OR use 0 to indicate that no RR timeout checking should be
        performed

Return Value:

    Ptr to RR if found.
    NULL if no more RR of desired type.

--*/
{
    DBG_FN( "RR_FindNextRecord" )

    BOOL    fdeleteRequired = FALSE;

    ASSERT( pNode != NULL );

    IF_DEBUG( LOOKUP2 )
    {
        DNS_PRINT((
            "Looking for RR type %d, at node, query time %d",
            wType,
            dwQueryTime ));
        Dbg_NodeName(
            NULL,
            (PDB_NODE) pNode,
            "\n" );
        DNS_PRINT((
            "\tPrevious RR ptr = %p.\n",
            pRecord ));
    }

    LOCK_READ_RR_LIST(pNode);

    //
    //  cached name error node
    //

    if ( IS_NOEXIST_NODE(pNode) )
    {
        goto NotFound;
    }

    //
    //  Set query time argument to zero if the node is not in the cache
    //  or should not be checked for timeout to simply timeout test later.
    //

    if ( dwQueryTime && !IS_CACHE_TREE_NODE( pNode ) )
    {
        dwQueryTime = 0;
    }

    //
    //  if previous RR, start after it
    //  otherwise start at head of node's RR list
    //

    if ( !pRecord )
    {
        pRecord = START_RR_TRAVERSE(pNode);
    }

    //
    //  traverse list, until find next record of desired type
    //

    while ( pRecord = NEXT_RR(pRecord) )
    {
        //  found matching record?

        if ( wType == pRecord->wType
                ||
             wType == DNS_TYPE_ALL
                ||
             ( wType == DNS_TYPE_MAILB && DnsIsAMailboxType( pRecord->wType ) ) )
        {
            //
            //  Is the found record timed out?
            //

            if ( dwQueryTime &&
                pRecord->dwTtlSeconds &&
                RR_PacketTtlForCachedRecord(
                            pRecord,
                            dwQueryTime ) == -1 )
            {
                fdeleteRequired = TRUE;
                DNS_DEBUG( LOOKUP2, (
                    "%s: encountered timed out record %p in node %p",
                    fn, pRecord, pNode ));
                continue;
            }

            goto Found;
        }

        //  past matching records?

        if ( wType < pRecord->wType )
        {
            goto NotFound;
        }
    }

NotFound:

    pRecord = NULL;

Found:

    if ( fdeleteRequired )
    {
        DNS_DEBUG( LOOKUP2, (
            "%s: deleting timed out RRs node %p", fn, pNode ));
        RR_ListTimeout( pNode );
    }

    UNLOCK_READ_RR_LIST(pNode);
    return( pRecord );
}



DWORD
RR_ListCountRecords(
    IN      PDB_NODE        pNode,
    IN      WORD            wType,
    IN      BOOL            fLocked
    )
/*++

Routine Description:

    Counts records of desired type

Arguments:

    pNode - ptr to node to find record at

    wType - type of record to find;  type ALL to just get next record in list

    fLocked - already locked

Return Value:

    Count of records of desired type.

--*/
{
    PDB_RECORD  prr;
    DWORD       count = 0;
    WORD        type;

    ASSERT( pNode != NULL );

    DNS_DEBUG( LOOKUP, (
        "RR_ListCountRecords( %s, type=%d, lock=%d )\n",
        pNode->szLabel,
        wType,
        fLocked ));

    if ( !fLocked )
    {
        LOCK_READ_RR_LIST(pNode);
    }

    //
    //  cached name error node
    //

    if ( IS_NOEXIST_NODE(pNode) )
    {
        goto Done;
    }

    //
    //  traverse list, counting records
    //

    for ( prr = FIRST_RR(pNode);
          prr != NULL;
          prr = NEXT_RR(prr) )
    {
        //  ignore cached records

        if ( IS_CACHE_RR(prr) )
        {
            continue;
        }
        type = prr->wType;

        //  found matching record?

        if ( wType == DNS_TYPE_ALL  ||  wType == type )
        {
            count++;
            continue;
        }

        //  not yet to matching type?

        else if ( wType < type )
        {
            continue;
        }

        //  past matching type

        break;
    }

Done:

    if ( !fLocked )
    {
        UNLOCK_READ_RR_LIST(pNode);
    }
    return( count );
}



DWORD
RR_FindRank(
    IN      PDB_NODE        pNode,
    IN      WORD            wType
    )
/*++

Routine Description:

    Gets rank (highest rank) for record type at node.

    Useful for comparing cache node to zone delegation\glue nodes.

Arguments:

    pNode - ptr to node

    wType - type of record to check

Return Value:

    Rank of record data of desired type at node.
    Zero if no records of desired type.

--*/
{
    PDB_RECORD  prr;
    DWORD       rank = 0;

    ASSERT( pNode != NULL );

    DNS_DEBUG( LOOKUP2, (
        "RR_FindRank() %p (l=%s), type = %d\n",
        pNode,
        pNode->szLabel,
        wType ));

    LOCK_READ_RR_LIST(pNode);

    //
    //  cached name error node
    //

    if ( IS_NOEXIST_NODE(pNode) )
    {
        goto Done;
    }

    //
    //  traverse list, until find next record of desired type
    //

    prr = START_RR_TRAVERSE(pNode);

    while ( prr = NEXT_RR(prr) )
    {
        if ( wType == prr->wType )
        {
            rank = RR_RANK(prr);
            break;
        }
    }

Done:

    UNLOCK_READ_RR_LIST(pNode);
    return( rank );
}



#if DBG
BOOL
RR_ListVerify(
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Verify that node's RR list is valid.

    Asserts if RR list is invalid.

Arguments:

    pNode -- ptr to node

Return Value:

    TRUE -- if RR list valid
    FALSE -- otherwise

--*/
{
    PDB_RECORD  prr;
    WORD        type;
    WORD        previousType;
    UCHAR       rank;
    UCHAR       previousRank;
    BOOL        foundCname = FALSE;
    BOOL        foundNs = FALSE;
    BOOL        foundSoa = FALSE;

    ASSERT( pNode != NULL );

    //
    //  cached name error
    //      - only issue is valid timeout
    //

    LOCK_READ_RR_LIST(pNode);

    if ( IS_NOEXIST_NODE(pNode) )
    {
        ASSERT( pNode->pRRList );
        UNLOCK_READ_RR_LIST(pNode);
        return TRUE;
    }

#if 0
    //  for some reason this is broken on deleted nodes
    //  not necessary doing to track another bug
    //
    //  AUTH zone root check
    //

    if ( IS_AUTH_ZONE_ROOT(pNode) )
    {
        ASSERT( IS_AUTH_NODE(pNode) );
        ASSERT( IS_ZONE_ROOT(pNode) );
        ASSERT( pNode->pZone );
        ASSERT( ((PZONE_INFO)pNode->pZone)->pZoneRoot == pNode ||
                ((PZONE_INFO)pNode->pZone)->pLoadZoneRoot == pNode ||
                IS_TNODE(pNode) );
    }
#endif

    //
    //  walk to end of list, check
    //      - list termination
    //      - types in correct (increasing) order
    //

    prr = FIRST_RR( pNode );
    previousType = 0;

    while ( prr != NULL )
    {
        //  validity check

        if ( !RR_Validate(
                prr,
                TRUE,   // active
                0,      // no required type
                0       // no required source
                ) )
        {
            ASSERT( FALSE );
            UNLOCK_READ_RR_LIST(pNode);
            return( FALSE );
        }

        //  type ordering check

        type = prr->wType;
        ASSERT( type && type >= previousType );

        //  rank ordering check

        rank = RR_RANK(prr);
        if ( type == previousType )
        {
            ASSERT( rank <= previousRank );
        }

        ASSERT( prr->wDataLength );

        //
        //  CNAME check
        //      - CNAME records ONLY found AT CNAME node
        //      - if CNAME node ONLY certain types may be present

        if ( type == DNS_TYPE_CNAME )
        {
            ASSERT( IS_CNAME_NODE(pNode) );
            foundCname = TRUE;
        }
        else if ( IS_CNAME_NODE(pNode) )
        {
            ASSERT( IS_ALLOWED_WITH_CNAME_TYPE(type) );
        }

        //
        //  NS-SOA root check
        //

        if ( type == DNS_TYPE_NS )
        {
            ASSERT( IS_ZONE_ROOT(pNode) );
            foundNs = TRUE;
        }
        else if ( type == DNS_TYPE_SOA )
        {
            foundSoa = TRUE;
            ASSERT( IS_ZONE_ROOT(pNode) );
            ASSERT( IS_AUTH_ZONE_ROOT(pNode) || !IS_ZONE_TREE_NODE(pNode) );
        }

        //  next record

        prr = prr->pRRNext;
        previousType = type;
        previousRank = rank;
    }

    //
    //  flag checks
    //      - CNAME record at CNAME node
    //      - NS or SOA at zone root
    //      - SOA at authoritative zone root (which also must be zone root)
    //

    if ( IS_CNAME_NODE(pNode) )
    {
        ASSERT( foundCname );
    }

#if 0
    //  can't do these checks on zone while loading, since
    //  zone root has no SOA when we start load
    if ( IS_AUTH_ZONE_ROOT(pNode) )
    {
        ASSERT( foundSoa );
        ASSERT( IS_ZONE_ROOT(pNode) );
    }
    if ( IS_ZONE_ROOT(pNode) )
    {
        ASSERT( foundNs || foundSoa );
    }
#endif

    UNLOCK_READ_RR_LIST(pNode);

    return( TRUE );
}



BOOL
RR_ListVerifyDetached(
    IN      PDB_RECORD      pRR,
    IN      WORD            wType,
    IN      DWORD           dwSource
    )
/*++

Routine Description:

    Verify that RR list is valid.

    This is for detached list -- as in updates.

Arguments:

    pRR -- ptr to head of RR list

    wType -- records in list must be this type

    dwSource -- records must be from this source

Return Value:

    TRUE -- if RR list valid
    FALSE -- otherwise

--*/
{
    WORD        type;
    WORD        previousType = 0;
    UCHAR       rank;
    UCHAR       previousRank;


    while ( pRR != NULL )
    {
        //  validity check

        if ( !RR_Validate(
                pRR,
                TRUE,       // active
                wType,      // required type (if any)
                dwSource    // required source (if any)
                ) )
        {
            ASSERT( FALSE );
            return( FALSE );
        }

        //  type ordering check

        type = pRR->wType;
        ASSERT( type && type >= previousType );

        //  rank ordering check

        rank = RR_RANK(pRR);
        if ( type == previousType )
        {
            ASSERT( rank <= previousRank );
        }

        //  next record

        pRR = pRR->pRRNext;
        previousType = type;
        previousRank = rank;
    }

    return( TRUE );
}
#endif



//
//  Name error caching \ NOEXIST nodes
//

VOID
RR_CacheNameError(
    IN OUT  PDB_NODE        pNode,
    IN      WORD            wQuestionType,
    IN      DWORD           dwQueryTime,
    IN      BOOL            fAuthoritative,
    IN      PDB_NODE        pZoneRoot,      OPTIONAL
    IN      DWORD           dwCacheTtl      OPTIONAL
    )
/*++

Routine Description:

    Cache name error at node.

Arguments:

    pNode -- ptr to node with name error

    dwQueryTime -- time of query

    fAuthoritative -- authoritative response?

    pZoneRoot -- zone root node where SOA will be cached

    dwCacheTtl -- caching TTL, from SOA returned with name error;  if not given
        will cache for short time only to eliminate repeat queries

Return Value:

    None

--*/
{
    PDB_RECORD  prr;

    //
    //  NAME_ERROR response packets without a question never get a node
    //  created in caller, protect against them
    //

    if ( pNode == NULL )
    {
        DNS_PRINT((
            "ERROR:  received NAME_ERROR response without question section\n" ));
        return;
    }

    DNS_DEBUG( READ2, (
        "RR_CacheNameError at %p (l=%s)\n"
        "\ttype     = %d\n"
        "\ttime     = %d\n"
        "\tauth     = %d\n"
        "\tzoneRoot = %p\n"
        "\tTTL      = %d\n",
        pNode, pNode->szLabel,
        wQuestionType,
        dwQueryTime,
        fAuthoritative,
        pZoneRoot,
        dwCacheTtl
        ));

    //
    //  set NAME_ERROR TTL
    //  - even if no TTL available still cache for a minute to avoid looking up
    //  client retries
    //  - when query was for SOA, also limit to minimum since this is often the
    //  result of a FAZ query and name may quickly be updated
    //
    //  - limit to maximum of 15 minutes
    //

    if ( !dwCacheTtl || wQuestionType == DNS_TYPE_SOA )
    {
        dwCacheTtl = MIN_NAME_ERROR_TTL;
    }
    else if ( dwCacheTtl > SrvCfg_dwMaxNegativeCacheTtl )
    {
        dwCacheTtl = SrvCfg_dwMaxNegativeCacheTtl;
    }
    if ( dwCacheTtl > SrvCfg_dwMaxCacheTtl )
    {
        dwCacheTtl = SrvCfg_dwMaxCacheTtl;
    }

    //
    //  existing records?
    //
    //  if authoritative node, timeout records (WINS or NBSTAT)
    //  but can't cache NAME_ERROR if existing records
    //
    //  non-authoritative, delete existing records
    //
    //  DEVNOTE: should NAME_ERROR delete GLUE A records?
    //

    LOCK_WRITE_RR_LIST(pNode);

    if ( pNode->pRRList )
    {
        if ( IS_NOEXIST_NODE(pNode) )
        {
            RR_ListFree( pNode->pRRList );
            pNode->pRRList = NULL;
        }
        else if ( IS_ZONE_TREE_NODE(pNode) )
        {
            RR_ListTimeout( pNode );
            if ( pNode->pRRList )
            {
                goto Unlock;
            }
        }
        else
        {
            RR_ListDelete( pNode );
        }
    }

    ASSERT( pNode->pRRList == NULL );

    //
    //  set NAME_ERROR with timeout
    //  cached name error will use standard RR with fields
    //      - wType => 0
    //      - wDataLength => 4
    //      - dwTtl => standard caching TTL
    //      - Data => zoneroot node (to find cached SOA)
    //
    //  reference zone root node so not deleted out from under this
    //      record

    SET_NOEXIST_NODE( pNode );

    Timeout_SetTimeoutOnNodeEx(
        pNode,
        dwCacheTtl,
        TIMEOUT_NODE_LOCKED
        );

    prr = RR_AllocateEx( sizeof(PDB_NODE), MEMTAG_RECORD_NOEXIST );
    IF_NOMEM( !prr )
    {
        goto Unlock;
    }
    prr->wType = DNS_TYPE_NOEXIST;
    prr->Data.NOEXIST.pnodeZoneRoot = pZoneRoot;
    prr->dwTtlSeconds = dwCacheTtl + dwQueryTime;

    SET_RR_RANK(
        prr,
        (fAuthoritative ? RANK_CACHE_A_ANSWER : RANK_CACHE_NA_ANSWER) );

    pNode->pRRList = prr;

    if ( pZoneRoot )
    {
        NTree_ReferenceNode( pZoneRoot );
    }

    IF_DEBUG( READ2 )
    {
        Dbg_DbaseNode(
            "Domain node after NXDOMAIN caching:\n",
            pNode );
    }

Unlock:

    //  note:  currently don't need to set timeout on any failure
    //      cases, as only case is zone node with existing data
    //      which obviously doesn't require timeout

    UNLOCK_WRITE_RR_LIST(pNode);
}



BOOL
RR_CheckNameErrorTimeout(
    IN OUT  PDB_NODE        pNode,
    IN      BOOL            fForceRemove,
    OUT     PDWORD          pdwTtl,         OPTIONAL
    OUT     PDB_NODE *      ppSoaNode       OPTIONAL
    )
/*++

Routine Description:

    Check cached name error timeout on node.
    Cleanup if timed out.

    Optionally return caching TTL and SOA node.

Arguments:

    pNode -- ptr to node containing RR list

    fForceRemove - TRUE if remove any existing timeout

    pdwTtl -- caching TTL

    ppSoaNode -- zone node containing SOA

    Note:  pdwTtl and ppSoaNode are OPTIONAL;  but must request but if requested
        MUST request both

Return Value:

    TRUE if cached name error exists.
    FALSE if does not or has timed out.

--*/
{
    PDB_RECORD      prr;
    DWORD           ttl;
    DWORD           dwCurrentTime;
    DWORD           dwTimeAdjust = g_dwCacheLimitCurrentTimeAdjustment;

    DNS_DEBUG( DATABASE, (
        "RR_CheckNameErrorTimeout( label=%s, force=%d )\n",
        pNode,
        fForceRemove ));

    LOCK_WRITE_RR_LIST(pNode);
    RR_ListVerify( pNode );

    //
    //  Cache limit enforcement: if we're calling this function in
    //  the context of trying to shrink the cache, then depending
    //  on the current aggression level we may cut RRs that are not
    //  yet fully expired.
    //

    dwCurrentTime = DNS_TIME() + dwTimeAdjust;

    //
    //  if no longer cached name error -- done
    //

    prr = pNode->pRRList;

    if ( !IS_NOEXIST_NODE(pNode) )
    {
        ASSERT( !prr || prr->wType != DNS_TYPE_NOEXIST );
        prr = NULL;
        goto Unlock;
    }

    //
    //  should have valid NOEXIST record
    //

    if ( !prr || prr->wType != DNS_TYPE_NOEXIST )
    {
        DNS_PRINT(( "ERROR:  messed up cached NAME_ERROR at node %p\n", pNode ));
        ASSERT( FALSE );
        CLEAR_NOEXIST_NODE( pNode );
        prr = NULL;
        goto Unlock;
    }

    //
    //  if forcing removal, or if name error timed out, delete from node
    //

    ttl = prr->dwTtlSeconds - dwCurrentTime;

    if ( fForceRemove ||
        dwTimeAdjust == DNS_CACHE_LIMIT_DISCARD_ALL ||
        ( LONG ) ttl < 0 )
    {
        pNode->pRRList = NULL;
        CLEAR_NOEXIST_NODE( pNode );
        ++g_dwCacheFreeCount;
        RR_Free( prr );
        prr = NULL;
        goto Unlock;
    }

    //
    //  if requested return cached name error info
    //

    if ( pdwTtl )
    {
        *pdwTtl = ttl;
        if ( ppSoaNode )
        {
            *ppSoaNode = prr->Data.NOEXIST.pnodeZoneRoot;
        }
        DNS_DEBUG( LOOKUP2, (
            "NameError cached TTL = %d\n", ttl ));
    }


Unlock:

    UNLOCK_WRITE_RR_LIST( pNode );
    return( prr!=NULL );
}



//
//  Caching \ timeout
//

BOOL
RR_CacheSetAtNode(
    IN OUT  PDB_NODE        pNode,
    IN OUT  PDB_RECORD      pFirstRR,
    IN OUT  PDB_RECORD      pLastRR,
    IN      DWORD           dwTtl,
    IN      DWORD           dwQueryTime
    )
/*++

Routine Description:

    Cache a RR set at node in database.

Arguments:

    pNode -- ptr to node to add resource record to

    pFirstRR -- first resource record to add

    pLastRR -- last resource record to add

    dwTtl -- TTL for record set

    dwQueryTime -- time we queried remote, allows us to determine TTL timeout

Return Value:

    TRUE -- if successful
    FALSE -- otherwise;  records are deleted

--*/
{
    PDB_RECORD      pcurRR;
    PDB_RECORD      pprevRR;
    PDB_RECORD      prr;
    PDB_RECORD      prrTestPrevious;
    PDB_RECORD      prrTest;
    WORD            type;
    UCHAR           rank;

    ASSERT( pNode != NULL && pFirstRR != NULL && pLastRR != NULL );
    ASSERT( RR_RANK(pFirstRR) != 0  &&
            IS_CACHE_RR(pFirstRR) );

    type = pFirstRR->wType;
    rank = RR_RANK(pFirstRR);

    DNS_DEBUG( READ2, (
        "Caching RR at node (label=%s)\n"
        "\ttype %d, rank %x, TTL = %d, query time = %d\n",
        pNode->szLabel,
        type,
        rank,
        dwTtl,
        dwQueryTime ));

    LOCK_WRITE_RR_LIST(pNode);

    IF_DEBUG( READ )
    {
        RR_ListVerify( pNode );
    }

    //
    //  clear cached NAME_ERROR
    //

    if ( IS_NOEXIST_NODE(pNode) )
    {
        RR_RemoveCachedNameError(pNode);
    }

    //
    //  check CNAME node special case
    //

    if ( IS_CNAME_NODE(pNode) || type == DNS_TYPE_CNAME )
    {
        DNS_STATUS status;
        status = checkCnameConditions(
                    pNode,
                    pFirstRR,
                    type );
        if ( status != ERROR_SUCCESS )
        {
            goto Failed;
        }
    }

    //
    //  traverse RR list
    //

    pcurRR = START_RR_TRAVERSE( pNode );

    while ( pprevRR = pcurRR, pcurRR = pcurRR->pRRNext )
    {
        //  continue until reach new type
        //  break when past new type

        if ( type != pcurRR->wType )
        {
            if ( type > pcurRR->wType )
            {
                continue;
            }
            break;
        }

        //  found record of desired type
        //
        //  => do NOT cache if records of higher rank
        //  => eliminate any CACHED records of lower rank
        //
        //  This can happen if an update JUST added the RR.

        if ( rank < RR_RANK(pcurRR) )
        {
            DNS_DEBUG( READ, (
                "Failed to cache RR at node %p.\n"
                "\tExisting record %p of same type with superior rank %d\n",
                pNode,
                pcurRR,
                RR_RANK(pcurRR) ));
            goto Failed;
        }

        //  delete any previously cached records of this type
        //      - delete previously cached records of this type
        //      - deletes cached records of same OR inferior rank
        //
        //  note that we use main loop here, we essentially cut current
        //  and delete it, resetting current to previous so we pick up
        //  next record after pcurRR next time through the loop

        if ( IS_CACHE_RR(pcurRR) )
        {
            pprevRR->pRRNext = pcurRR->pRRNext;
            RR_Free( pcurRR );
            pcurRR = pprevRR;
            continue;
        }

        //  break when reach record of lower rank (glue, root hint)
        //  all cached records were deleted by previous passes

#if DBG
        if ( rank > RR_RANK(pcurRR) )
        {
            IF_DEBUG( READ2 )
            {
                Dbg_DbaseRecord(
                    "Inferior RR in list after cached records cleared.\n",
                    pcurRR );
            }
            ASSERT( !IS_CACHE_RR(pcurRR) && IS_ROOT_HINT_TYPE(type) );
        }
#endif
        break;
    }

    //
    //  kill off duplicates and set TTL
    //
    //  TTL for cached record is time when record will timeout =>
    //      (query time + TTL)
    //  needed to have both times passed so we can determine zero TTLs
    //
    //  need to kill duplicates as NS queries, can generate responses that
    //  have identical Answer and Authority sections and if single RR, then
    //  can have duplicate RRs in Additional section for same node and type
    //

    dwQueryTime += dwTtl;

    prr = pFirstRR;
    do
    {
        prrTestPrevious = prr;
        while ( prrTest = NEXT_RR(prrTestPrevious) )
        {
            //  check for duplicate record
            //      - ignore TTL in check

            if ( !RR_Compare( prr, prrTest, FALSE, FALSE ) )
            {
                prrTestPrevious = prrTest;
                continue;
            }

            //  duplicate record
            //      - hack it out and toss it
            //      - if duplicate is last RR, reset pLastRR

            DNS_DEBUG( READ, (
                "Duplicate record %p in caching RR set.\n"
                "\tremoving record from cached set.\n",
                prrTest ));

            prrTestPrevious->pRRNext = prrTest->pRRNext;
            RR_Free( prrTest );

            if ( prrTestPrevious->pRRNext == NULL )
            {
                pLastRR = prrTestPrevious;
                break;
            }
        }

        ASSERT( prr->wType == type && RR_RANK(prr) == rank );

        prr->dwTtlSeconds = dwQueryTime;
        if ( dwTtl == 0 )
        {
            SET_ZERO_TTL_RR( prr );
        }

        STAT_INC( RecordStats.CacheCurrent );
        STAT_INC( RecordStats.CacheTotal );

    }
    while( prr = NEXT_RR(prr) );

    //
    //  put RR set between pprevRR and pcurRR
    //

    pprevRR->pRRNext = pFirstRR;
    pLastRR->pRRNext = pcurRR;

    //
    //  put node in timeout list
    //

    Timeout_SetTimeoutOnNodeEx(
        pNode,
        dwTtl,
        TIMEOUT_NODE_LOCKED
        );

    DNS_DEBUG( READ, (
        "Cached (type %d) (rank %x) (ttl=%d) (timeout=%d) records at node (label=%s)\n",
        type,
        rank,
        dwTtl,
        dwQueryTime,
        pNode->szLabel ));
    IF_DEBUG( READ2 )
    {
        Dbg_DbaseNode(
            "Domain node after caching RRs\n",
            pNode );
    }

    //
    //  reset node properties
    //      - flags, authority, NS-list

    RR_ListResetNodeFlags( pNode );

    RR_ListVerify( pNode );

    UNLOCK_WRITE_RR_LIST(pNode);
    return( TRUE );

Failed:

    //  put node in timeout list anyway

    Timeout_SetTimeoutOnNodeEx(
        pNode,
        0,          // put in next timeout bin for immediate cleanup
        TIMEOUT_NODE_LOCKED
        );

    //  delete new RR set

    UNLOCK_WRITE_RR_LIST(pNode);

    DNS_DEBUG( READ, (
        "Unable to cache RR set (t=%d, r=%x) at node (%s).\n"
        "\tdeleting new RR set.\n",
        type,
        rank,
        pNode->szLabel ));

    RR_ListFree( pFirstRR );

    return( FALSE );
}



VOID
RR_ListTimeout(
    IN OUT  PDB_NODE        pNode
    )
/*++

Routine Description:

    Delete timed out RR in node's RR list.

    This function also may use globals set by the enforceCacheLimit
    function to throw out nodes that are not fully timed out.

Arguments:

    pNode -- ptr to node containing RR list

Return Value:

    None

--*/
{
    PDB_RECORD      prr;
    PDB_RECORD      pprevRR;
    WORD            wtypeDelete = 0;
    DWORD           dwTimeAdjust = g_dwCacheLimitCurrentTimeAdjustment;

    RR_ListVerify( pNode );

    DNS_DEBUG( DATABASE, (
        "Timeout delete of RR list for node at %p.\n"
        "\tref count = %d\n",
        pNode,
        pNode->cReferenceCount
        ));

    LOCK_WRITE_RR_LIST(pNode);

    //
    //  check cached NAME_ERROR node
    //      => reset if timed out
    //

    if ( IS_NOEXIST_NODE(pNode) )
    {
        if ( RR_CheckNameErrorTimeout(pNode, FALSE, NULL, NULL) )
        {
            goto Unlock;
        }
    }

    //
    //  traverse node's RR list check each RR for timeout
    //      => delete if timed out
    //

    pprevRR = START_RR_TRAVERSE( pNode );

    while ( prr = pprevRR->pRRNext )
    {
        ASSERT( IS_DNS_HEAP_DWORD(prr) );

        //
        //  delete only if
        //      - cached node
        //      - cached TTL has expired
        //

        if ( IS_CACHE_RR( prr ) && 
            ( dwTimeAdjust == DNS_CACHE_LIMIT_DISCARD_ALL ||
                prr->dwTtlSeconds < DNS_TIME() + dwTimeAdjust ) )
        {
            //  first cut RR from list (set previous next ptr to next)

            pprevRR->pRRNext = prr->pRRNext;
            wtypeDelete = prr->wType;

            ++g_dwCacheFreeCount;

            RR_Free( prr );
            continue;
        }

        //
        //  not deleting -- setup to check next record
        //
        //  RR sets (same type) MUST be deleted in their entirety
        //  so no delete MUST be new type from any previous delete
        //  unless this is NOT cache data (case of delegation where
        //  both cache and load data is at node)
        //

        ASSERT( prr->wType != wtypeDelete || !IS_CACHE_RR(prr) );
        pprevRR = prr;
    }

    //  reset node properties
    //      - flags, authority, NS-list

    if ( wtypeDelete != 0 )
    {
        RR_ListResetNodeFlags( pNode );
    }

Unlock:

    RR_ListVerify( pNode );
    UNLOCK_WRITE_RR_LIST(pNode);
}




//
//  Delete functions
//

DNS_STATUS
RR_DeleteMatchingRecordFromNode(
    IN OUT  PDB_NODE        pNode,
    IN OUT  PDB_RECORD      pRR
    )
/*++

Routine Description:

    Delete a known record from node.

    Note this is used by RPC functions so there is no guarantee that
    the record actually exists.

    Unlike matching handle function below, this function doesn't require
    that this be an authoritative zone or provide for update functionality,
    and it actually DELETEs the record.

Arguments:

    pNode - node owning RR

    pRR - ptr to resource record

Return Value:

    ERROR_SUCCESS if record found and deleted.
    DNS_ERROR_RECORD_DOES_NOT_EXIST otherwise.

--*/
{
    PDB_RECORD  pcurrent;
    PDB_RECORD  pback;

    DNS_DEBUG( UPDATE, (
        "RR_DeleteMatchingRecordFromNode()\n"
        "\tpnode = %p\n"
        "\thandle to delete = %p\n",
        pNode,
        pRR ));

    LOCK_WRITE_RR_LIST(pNode);
    RR_ListVerify( pNode );

    if ( IS_NOEXIST_NODE(pNode) )
    {
        UNLOCK_WRITE_RR_LIST(pNode);
        return( DNS_ERROR_RECORD_DOES_NOT_EXIST );
    }

    //
    //  traverse list
    //      - find\remove RR matching data
    //

    pcurrent = START_RR_TRAVERSE(pNode);

    while ( pback = pcurrent, pcurrent = pcurrent->pRRNext )
    {
        ASSERT( IS_DNS_HEAP_DWORD(pcurrent) );

        if ( pcurrent == pRR )
        {
            pback->pRRNext = pcurrent->pRRNext;
            goto Free;
        }
    }

    //  if RR not found in list, bogus call

    ASSERT( pcurrent == NULL );
    UNLOCK_WRITE_RR_LIST(pNode);
    return( DNS_ERROR_RECORD_DOES_NOT_EXIST );

Free:

    //
    //  reset node properties
    //      - flags, authority, NS-list

    RR_ListResetNodeFlags( pNode );

    //  if root hint, mark cache zone dirty

    if ( IS_ROOT_HINT_RR(pRR) )
    {
        if ( g_pCacheZone )
        {
            g_pCacheZone->fDirty = TRUE;
        }
        ELSE_IF_DEBUG( ANY )
        {
            DNS_PRINT(( "ERROR:  deleting root hint RR with NO cache zone!\n" ));
            Dbg_DbaseRecord(
                "Root hint record being deleted without cache zone\n",
                pRR );
        }
    }

    //  prr is now cut out of the RR list and node flags updated

    RR_ListVerify( pNode );
    UNLOCK_WRITE_RR_LIST(pNode);

    RR_Free( pRR );

    return( ERROR_SUCCESS );
}



VOID
RR_ListDelete(
    IN OUT  PDB_NODE        pNode
    )
/*++

Routine Description:

    Delete node's RR list.

Arguments:

    pNode -- ptr to node containing RR list

Return Value:

    None

--*/
{
    PDB_RECORD  prr;

    DNS_DEBUG( DATABASE, (
        "RR list delete of node at %p.\n"
        "\tref count = %d\n",
        pNode,
        pNode->cReferenceCount ));

    LOCK_WRITE_RR_LIST(pNode);

    RR_ListVerify( pNode );

    //
    //  check cached NAME_ERROR node
    //      - reset if timed out
    //

    if ( IS_SELECT_NODE(pNode) )
    {
        UNLOCK_WRITE_RR_LIST(pNode);
        return;
    }
    if ( IS_NOEXIST_NODE(pNode) )
    {
        RR_RemoveCachedNameError(pNode);
        UNLOCK_WRITE_RR_LIST(pNode);
        return;
    }

    //
    //  cut node's RR list
    //      - will delete after releasing lock for perf
    //

    prr = pNode->pRRList;
    pNode->pRRList = NULL;

    //
    //  reset node properties
    //      - flags, authority, NS-list

    RR_ListResetNodeFlags( pNode );

    RR_ListVerify( pNode );

    UNLOCK_WRITE_RR_LIST(pNode);

    //
    //  free RR list
    //

    RR_ListFree( prr );
}



//
//  Dynamic update RR list routines
//

BOOL
RR_ListIsMatchingType(
    IN      PDB_NODE        pNode,
    IN      WORD            wType
    )
/*++

Routine Description:

    Does node's RR list contain desired type.

    For use by UPDATE preconditions.
    Note:  no locking as assuming database locked for UPDATE.

Arguments:

    pNode -- ptr to node

    wType -- desired type

Return Value:

    None

--*/
{
    PDB_RECORD  prr;
    BOOL        result;

    if ( !pNode )
    {
        return( FALSE );
    }

    result = FALSE;

    LOCK_WRITE_RR_LIST(pNode);

    //  delete cached data

    deleteCachedRecordsForUpdate( pNode );

    //
    //  if no data -> FALSE
    //  if ANY type -> TRUE
    //

    if ( !pNode->pRRList )
    {
        goto Done;
    }
    else if ( wType == DNS_TYPE_ALL )
    {
        result = TRUE;
        goto Done;
    }

    //
    //  traverse list, find matching type
    //      - ignore cached records in check
    //

    prr = START_RR_TRAVERSE( pNode );

    while ( prr = prr->pRRNext )
    {
        //  past matching records? -- no match

        if ( wType < prr->wType )
        {
            break;
        }
        if ( wType == prr->wType && !IS_CACHE_RR(prr) )
        {
            result = TRUE;
            break;
        }
        continue;
    }

    //  out of RRs -- no match

Done:

    UNLOCK_WRITE_RR_LIST(pNode);
    return( result );
}



BOOL
RR_ListIsMatchingSet(
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pCheckRRList,
    IN      BOOL            bForceRefresh
    )
/*++

Routine Description:

    Check for matching RR set at node.

    Essentially for update preconditions checking.

Arguments:

    pNode -- ptr to node to add resource record to

    pRRList -- RR set to match with existing

    bForceRefresh -- force aging refresh

Return Value:

    TRUE if match
    FALSE on error

--*/
{
    PDB_RECORD      prr;
    PDB_RECORD      prrSetStart = NULL;
    PDB_RECORD      prrSetEnd = NULL;
    PDB_RECORD      prrSetEndNext;
    WORD            type;
    DWORD           result = RRLIST_NO_MATCH;

    ASSERT( pNode != NULL );
    ASSERT( pCheckRRList != NULL );


    LOCK_WRITE_RR_LIST(pNode);

    //  delete cached data
    //  if no data left -> no match

    deleteCachedRecordsForUpdate( pNode );
    if ( !pNode->pRRList )
    {
        goto NoMatch;
    }

    //
    //  find start and end of RR existing RR set
    //

    type = pCheckRRList->wType;
    prr = START_RR_TRAVERSE( pNode );

    while ( prr = NEXT_RR(prr) )
    {
        if ( prr->wType == type )
        {
            prrSetEnd = prr;
            if ( !prrSetStart )
            {
                prrSetStart = prr;
            }
            continue;
        }
        if ( prr->wType < type )
        {
            continue;
        }
        break;
    }

    //
    //  truncated RR list at end of set so that we can call RR_ListCompare()
    //      - first need to save pNextRR of last RR in set
    //

    if ( !prrSetStart )
    {
        goto NoMatch;
    }
    ASSERT( prrSetEnd );
    prrSetEndNext = NEXT_RR( prrSetEnd );
    NEXT_RR( prrSetEnd ) = NULL;


    //
    //  compare RR set
    //      - ignore TTL and refresh time in compare
    //      - force refresh if flag set
    //

    result = RR_ListCompare(
                prrSetStart,
                pCheckRRList,
                FALSE,              // ignore TTL
                FALSE,              // ignore refresh time
                bForceRefresh
                    ? FORCE_REFRESH_DUMMY_TIME
                    : 0
                );

    //  restore rest of list to node's RR list

    NEXT_RR( prrSetEnd ) = prrSetEndNext;

NoMatch:

    UNLOCK_WRITE_RR_LIST(pNode);
    return( result == RRLIST_MATCH );
}



BOOL
RR_ListIsMatchingList(
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pRRList,
    IN      BOOL            fCheckTtl,
    IN      BOOL            fCheckTimestamp
    )
/*++

Routine Description:

    Check for record list exact match to nodes.

Arguments:

    pNode -- ptr to node to add resource record to

    pRRList -- RR set to match with existing

    fCheckTtl -- TRUE to use TTL in comparision;  FALSE otherwise

    fTimestamp -- TRUE to use Timestamp in comparision;  FALSE otherwise

Return Value:

    TRUE if match
    FALSE on error

--*/
{
    DWORD   result;

    ASSERT( pNode != NULL );

    LOCK_WRITE_RR_LIST(pNode);

    //  delete cached data
    //  if no data left -> no match

    deleteCachedRecordsForUpdate( pNode );

    //
    //  compare RR set
    //      - ignore TTL in compare
    //

    result = RR_ListCompare(
                pNode->pRRList,
                pRRList,
                fCheckTtl,
                fCheckTimestamp,
                0                       // no refresh time checking
                );

    UNLOCK_WRITE_RR_LIST(pNode);

    return( result == RRLIST_MATCH );
}



DWORD
RR_ListCheckIfNodeNeedsRefresh(
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pRRList,
    IN      DWORD           dwRefreshTime
    )
/*++

Routine Description:

    Check for record list exact match to nodes.

Arguments:

    pNode -- ptr to node to add resource record to

    pRRList -- RR set to match with existing

    dwRefreshTime -- refresh time for zone
        see RR_ListCompare() for detailed description of return codes

Return Value:

    RRLIST_MATCH            -- matches completely
    RRLIST_AGING_REFRESH    -- matches, but aging requires refresh
    RRLIST_AGING_OFF        -- matches, but aging turning off on a record
    RRLIST_AGING_ON         -- matches, but aging turning on on a record
    RRLIST_NO_MATCH         -- no match, record is different

--*/
{
    DWORD   result;

    ASSERT( pNode != NULL );

    LOCK_WRITE_RR_LIST(pNode);

    //  delete cached data
    //  if no data left -> no match

    deleteCachedRecordsForUpdate( pNode );

    //
    //  compare RR set
    //

    result = RR_ListCompare(
                pNode->pRRList,
                pRRList,
                TRUE,               //  include TTL in compare
                FALSE,              //  Refresh time NOT part of RR compare
                dwRefreshTime
                );

    UNLOCK_WRITE_RR_LIST(pNode);
    return( result );
}



VOID
RR_ListResetNodeFlags(
    IN OUT  PDB_NODE        pNode
    )
/*++

Routine Description:

    Reset node flags after UPDATE add or delete.

Arguments:

    pNode -- ptr to node

Return Value:

    None

--*/
{
    PDB_RECORD  prr;
    WORD        type;
    DWORD       mask;
    BOOL        foundNs = FALSE;

    DNS_DEBUG( UPDATE, (
        "RR_ListResetNodeFlags( %p, %s )\n"
        "\tcurrent flags = 0x%04x\n",
        pNode, pNode->szLabel,
        pNode->wNodeFlags ));

    ASSERT( IS_LOCKED_NODE(pNode) );


    //
    //  DEVNOTE: issue clearly ZONE_ROOT flag at top of cache
    //      currently we mark top of cache tree as ZONE_ROOT;
    //      if never cache NS records, and get a response at zone
    //      root (for any type), we'd end up running through this
    //      function with no NS records in the list and hence clear
    //      the ZONE_ROOT flag;   not sure if this merits any
    //      special casing as i haven't seen any effect of this
    //      accepting hitting ASSERT() in recurse.c
    //      Rec_CheckForDelegation() (currently line 2732);  i'm
    //      simply removing the ASSERT() there as the safer solution
    //

    //
    //  clear current mask of ZONE_ROOT and CNAME flags
    //

    mask = (DWORD)pNode->wNodeFlags & ~( NODE_ZONE_ROOT | NODE_CNAME );

    //
    //  check all records, set mask if find NS, SOA or CNAME
    //      - re-rank new delegation NS records
    //      they can be miss marked on full list replace from DS poll
    //

    prr = START_RR_TRAVERSE(pNode);

    while ( prr = prr->pRRNext )
    {
        type = prr->wType;

        if ( type == DNS_TYPE_NS )
        {
            foundNs = TRUE;
            mask |= NODE_ZONE_ROOT;

            //  if node is NOT auth zone root, then NS are delegation RRs

            if ( IS_ZONE_TREE_NODE(pNode) && !(mask & NODE_AUTH_ZONE_ROOT) )
            {
                SET_RANK_NS_GLUE(prr);
            }
        }
        else if ( type == DNS_TYPE_SOA )
        {
            ASSERT( !IS_ZONE_TREE_NODE(pNode) || IS_AUTH_ZONE_ROOT(pNode) );
            mask |= NODE_ZONE_ROOT;
        }
        else if ( type == DNS_TYPE_CNAME )
        {
            mask |= NODE_CNAME;
        }
    }

    //  reset node's mask

    pNode->wNodeFlags = (WORD) mask;

    //
    //  set authority if delegation
    //  clear authority if lost delegation
    //

    if ( !IS_AUTH_ZONE_ROOT(pNode) )
    {
        if ( foundNs )
        {
            if ( IS_AUTH_NODE(pNode) )
            {
                SET_DELEGATION_NODE(pNode);
            }
            //Rec_MarkNodeNsListDirty( pNode );
        }
        else
        {
            if ( IS_DELEGATION_NODE(pNode) )
            {
                SET_AUTH_NODE(pNode);
            }
            //Rec_DeleteNodeNsList( pNode );
        }
    }
}



DNS_STATUS
RR_ListDeleteMatchingRecordHandle(
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pRR,
    IN OUT  PUPDATE_LIST    pUpdateList     OPTIONAL
    )
/*++

Routine Description:

    Delete record matching given record from RR list.

    For use by NT4 admin update, where passed a handle to the actual
    record.

Arguments:

    pNode -- ptr to node

    pRR -- ptr to record to delete

    pUpdateList -- update list if deleting in zone

Return Value:

    None

--*/
{
    PDB_RECORD  pcurrent;
    PDB_RECORD  pback;
    WORD        type;
    BOOL        ffoundNs = FALSE;
    DNS_STATUS  status;

    DNS_DEBUG( UPDATE, (
        "RR_ListDeleteMatchingRecordHandle()\n"
        "\tpnode = %p\n"
        "\thandle to delete = %p\n",
        pNode,
        pRR ));

    LOCK_WRITE_RR_LIST(pNode);
    RR_ListVerify( pNode );

    //  delete cached data
    //  if no data left -> no record deleted

    deleteCachedRecordsForUpdate( pNode );
    if ( !pNode->pRRList )
    {
        goto NoMatch;
    }

    //
    //  traverse list
    //      - find\remove RR matching data
    //      - or reach end
    //

    pcurrent = START_RR_TRAVERSE(pNode);

    while ( pback = pcurrent, pcurrent = pcurrent->pRRNext )
    {
        ASSERT( IS_DNS_HEAP_DWORD(pcurrent) );

        //  no match, continue
        //  if pass NS record, then can delete NS record no matter
        //  what value it has

        if ( pcurrent != pRR )
        {
            if ( pcurrent->wType == DNS_TYPE_NS )
            {
                ffoundNs = TRUE;
            }
            continue;
        }

        //  found matching record -- cut
        //  however, don't delete SOA or last NS record from zone root

        type = pcurrent->wType;

        if ( type == DNS_TYPE_SOA )
        {
            DNS_DEBUG( UPDATE, ( "\tRefusing SOA record delete.\n" ));
            ASSERT( IS_AUTH_ZONE_ROOT(pNode) );
            status = DNS_ERROR_SOA_DELETE_INVALID;
            goto Failed;
        }

        //  don't delete last NS from zone root
        //  however do allow delete of last NS from delegation and reset zone
        //      root flag -- delegation is history

        if ( type == DNS_TYPE_NS &&
            ! ffoundNs &&
            ( !pcurrent->pRRNext || pcurrent->pRRNext->wType != DNS_TYPE_NS ) )
        {
            if ( IS_AUTH_ZONE_ROOT(pNode) )
            {
                DNS_DEBUG( UPDATE, ( "\tRefusing delete of last NS record.\n" ));
                status = DNS_ERROR_SOA_DELETE_INVALID;
                goto Failed;
            }
            CLEAR_ZONE_ROOT(pNode);
        }

        pback->pRRNext = pcurrent->pRRNext;
        pcurrent->pRRNext = NULL;

        //  reset node properties
        //      - flags, authority, NS-list

        RR_ListResetNodeFlags( pNode );

        RR_ListVerify( pNode );
        UNLOCK_WRITE_RR_LIST(pNode);

        //
        //  if update, save delete record and its type
        //  otherwise, delete it
        //
        //  DEVNOTE: fix to use direct delete type

        if ( pUpdateList )
        {
            PUPDATE pupdate;
            pupdate = Up_CreateAppendUpdate(
                            pUpdateList,
                            pNode,
                            NULL,       // no add
                            type,       // delete type
                            pcurrent    // delete record
                            );
            IF_NOMEM( !pupdate )
            {
                return( DNS_ERROR_NO_MEMORY );
            }
            pUpdateList->iNetRecords--;
        }
        else
        {
            RR_Free( pcurrent );
        }
        return( ERROR_SUCCESS );
    }

NoMatch:

    DNS_DEBUG( UPDATE, (
        "No matching RR to UPDATE delete record\n" ));
    status = DNS_ERROR_RECORD_DOES_NOT_EXIST;

Failed:

    UNLOCK_WRITE_RR_LIST(pNode);
    return( status );
}



PDB_RECORD
RR_UpdateDeleteMatchingRecord(
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Delete record matching given record from RR list.

    For use by UPDATE.

Arguments:

    pNode -- ptr to node

    pRR   -- temp RR to delete matching records for

Return Value:

    Record matching desired record, if exists.
    NULL if not found.

--*/
{
    PDB_RECORD  pcurrent;
    PDB_RECORD  pback;
    WORD        type = pRR->wType;
    WORD        dataLength = pRR->wDataLength;

    IF_DEBUG( UPDATE )
    {
        DnsDebugLock();
        DNS_PRINT((
            "RR_UpdateDeleteMatchingRecord()\n"
            "\tpnode = %p\n",
            pNode ));
        Dbg_DbaseRecord(
            "RR_UpdateDeleteMatchingRecord()",
            pRR );
        DnsDebugUnlock();
    }

    LOCK_WRITE_RR_LIST(pNode);
    RR_ListVerify( pNode );

    //  delete cached data
    //  if no data left -> no record deleted

    deleteCachedRecordsForUpdate( pNode );
    if ( !pNode->pRRList )
    {
        UNLOCK_WRITE_RR_LIST(pNode);
        return( NULL );
    }

    //
    //  traverse list
    //      - find\remove RR matching data
    //      - or reach end
    //

    pcurrent = START_RR_TRAVERSE(pNode);

    while ( pback = pcurrent, pcurrent = pcurrent->pRRNext )
    {
        ASSERT( IS_DNS_HEAP_DWORD(pcurrent) );

        //  past matching records? -- stop
        //  before -- continue

        if ( type < pcurrent->wType )
        {
            break;
        }
        if ( type > pcurrent->wType )
        {
            continue;
        }

        //  match datalength, then data
        //  if no match set flag to indicate already checked record of
        //  desired type;  need this for NS

        if ( dataLength != pcurrent->wDataLength ||
             ! RtlEqualMemory(
                    & pRR->Data,
                    & pcurrent->Data,
                    dataLength ) )
        {
            DNS_DEBUG( UPDATE, (
                "\tMatched delete record type, failed data match\n" ));
            IF_DEBUG( UPDATE )
            {
                Dbg_DbaseRecord(
                    "no-match record",
                    pcurrent );
            }
            continue;
        }

        //
        //  exact match -- cut
        //
        //  special processing for
        //      - SOA (no delete)
        //      - NS (allow removal of last NS?)
        //

        if ( type != DNS_TYPE_A )
        {
            if ( type == DNS_TYPE_SOA )
            {
                if ( IS_AUTH_ZONE_ROOT(pNode) )
                {
                    DNS_DEBUG( UPDATE, ( "Failed SOA record delete.\n" ));
                    break;
                }
                //  if have SOA, better have been in zone at root
                ASSERT( FALSE );
            }

        }   //  end special types

        //  cut the record

        pback->pRRNext = pcurrent->pRRNext;
        pcurrent->pRRNext = NULL;

        DNS_DEBUG( UPDATE, (
            "Update matched and deleted record (%p type=%d) from node (%s)\n",
            pcurrent,
            type,
            pNode->szLabel ));
        goto Done;
    }

    DNS_DEBUG( UPDATE, (
        "Failed to match update delete record (type=%d) at node (%s)\n",
        type,
        pNode->szLabel ));

    UNLOCK_WRITE_RR_LIST(pNode);
    return( NULL );

Done:

    //
    //  reset node properties
    //      - flags, authority, NS-list

    RR_ListResetNodeFlags( pNode );

    RR_ListVerify( pNode );
    UNLOCK_WRITE_RR_LIST(pNode);
    return( pcurrent );
}



PDB_RECORD
RR_UpdateDeleteType(
    IN      PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN      WORD            wDeleteType,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Delete and return records matching a given type.

    For use by UPDATE.

Arguments:

    pNode -- ptr to node

    wDeleteType -- type to delete or type ANY

    dwFlag -- flag on update

Return Value:

    List of records deleted.
    NULL if no records deleted.

--*/
{
    PDB_RECORD  pcurrent;
    WORD        typeCurrent;
    PDB_RECORD  pdelete = NULL;
    PDB_RECORD  pdeleteLast;
    PDB_RECORD  pbeforeDelete;

    ASSERT( !IS_COMPOUND_TYPE_EXCEPT_ANY(wDeleteType) );

    LOCK_WRITE_RR_LIST(pNode);
    RR_ListVerify( pNode );

    //
    //  for zone update, clear cached data
    //
    //  this routine also called from Rpc_DeleteRecordSet() and
    //  obviously must skip cache record delete for cache data
    //

    if ( pZone )
    {
        deleteCachedRecordsForUpdate(pNode);
    }

    //
    //  regular type -- traverse list
    //      - find\remove RR matching data
    //      - or reach end
    //      - can NOT delete SOA or all NS at zone root
    //      the SOA restriction we always enforce,
    //      the NS restriction we limit to actual dynamic update packet
    //

    if ( wDeleteType != DNS_TYPE_ALL )
    {
        if ( IS_AUTH_ZONE_ROOT(pNode) )
        {
            if ( wDeleteType == DNS_TYPE_SOA
                ||
               ( wDeleteType == DNS_TYPE_NS && (dwFlag & DNSUPDATE_PACKET) ) )
            {
                goto NotFound;
            }
#if 0
            if ( IS_WINS_TYPE( wDeleteType )
            {
                Wins_StopZoneWinsLookup( pZone );
            }
#endif
        }

        pcurrent = START_RR_TRAVERSE(pNode);
        pbeforeDelete = pcurrent;

        while ( pcurrent = pcurrent->pRRNext )
        {
            ASSERT( IS_DNS_HEAP_DWORD(pcurrent) );

            typeCurrent = pcurrent->wType;

            //  found delete type
            //      - save ptr to first record

            if ( typeCurrent == wDeleteType )
            {
                if ( !pdelete )
                {
                    pdelete = pcurrent;
                }
                pdeleteLast = pcurrent;
                continue;
            }

            //  before matching records -- continue

            if ( typeCurrent < wDeleteType )
            {
                pbeforeDelete = pcurrent;
                continue;
            }
            break;      //  past matching records -- stop
        }

        if ( pdelete )
        {
            DNS_DEBUG( UPDATE, (
                "Deleted record(s) type=%d at node %p.\n",
                wDeleteType,
                pNode ));

            pdeleteLast->pRRNext = NULL;        // NULL terminate delete list
            ASSERT( pbeforeDelete );
            pbeforeDelete->pRRNext = pcurrent;  // patch up RR list
        }
    }

    //
    //  type all
    //

    else
    {
        //
        //  if NOT at zone root, just cut out entire list
        //
        //  clear forced ENUM of node:  deleting all records is the
        //  way admin can do subtree delete, so should not force enumeration
        //  after delete;  (enum may still occur because of children that
        //  need enumeration)
        //

        if ( !IS_AUTH_ZONE_ROOT(pNode) )
        {
            pdelete = pNode->pRRList;
            pNode->pRRList = NULL;
            CLEAR_ENUM_NODE( pNode );
        }

        //
        //  if at zone root, must traverse to avoid deleting SOA or NS
        //

        //  DEVNOTE: this should be common code with replace function
        //      either just call it if type ALL
        //      or just here when need to fix up zone root
        //
        //  DEVNOTE: both should save\require SOA and NS of THIS server
        //

        else
        {
            PDB_RECORD      psaveLast;

            psaveLast = START_RR_TRAVERSE(pNode);
            pcurrent = psaveLast;

            while ( pcurrent = pcurrent->pRRNext )
            {
                ASSERT( IS_DNS_HEAP_DWORD(pcurrent) );

                typeCurrent = pcurrent->wType;

                if ( typeCurrent == DNS_TYPE_SOA
                    || typeCurrent == DNS_TYPE_NS )
                {
                    psaveLast->pRRNext = pcurrent;
                    psaveLast = pcurrent;
                    continue;
                }

                if ( !pdelete )
                {
                    pdelete = pcurrent;
                }
                else
                {
                    pdeleteLast->pRRNext = pcurrent;
                }
                pdeleteLast = pcurrent;
            }

            //  make sure delete list and saved list NULL terminated

            if ( pdelete )
            {
                pdeleteLast->pRRNext = NULL;
                psaveLast->pRRNext = NULL;
            }
        }
    }

    //
    //  successful delete
    //
    //  reset node properties
    //      - flags, authority, NS-list

    if ( pdelete )
    {
        RR_ListResetNodeFlags( pNode );
    }

NotFound:

    RR_ListVerify( pNode );

    UNLOCK_WRITE_RR_LIST(pNode);

    IF_DEBUG( UPDATE )
    {
        DnsDebugLock();
        DNS_PRINT((
            "Node of delete of type = %d.\n"
            "\treturn pdelete = %p\n",
            wDeleteType,
            pdelete ));
        Dbg_DbaseNode(
            "Node after type delete:\n",
            pNode );
        DnsDebugUnlock();
    }
    return( pdelete );
}



PDB_RECORD
RR_UpdateScavenge(
    IN      PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Delete expired records.
    For use by UPDATE.

Arguments:

    pZone -- zone being updated

    pNode -- ptr to node

    dwFlag -- flag on update

Return Value:

    List of expired records deleted.
    NULL if no records deleted.

--*/
{
    PDB_RECORD  prr;
    PDB_RECORD  pback;
    PDB_RECORD  pdeleteFirst = NULL;
    PDB_RECORD  pdeleteLast;
    DWORD       expireTime;


    //
    //  get expire time for zone
    //

    expireTime = AGING_ZONE_EXPIRE_TIME(pZone);

    DNS_DEBUG( UPDATE, (
        "RR_UpdateScavenge( %s, expire=%d )\n",
        pNode->szLabel,
        expireTime ));

    //
    //  search list and scavenge any dead entries
    //

    LOCK_WRITE_RR_LIST(pNode);
    RR_ListVerify( pNode );

    //  for zone update, clear cached data

    if ( pZone )
    {
        deleteCachedRecordsForUpdate(pNode);
    }

    prr = START_RR_TRAVERSE(pNode);

    while ( pback = prr, prr = NEXT_RR(pback) )
    {
        //  if non-aging or not expired, continue

        if ( !AGING_IS_RR_EXPIRED( prr, expireTime ) )
        {
            continue;
        }

        //  non-scavenging type

        if ( IS_NON_SCAVENGE_TYPE( prr->wType ) )
        {
            continue;
        }

        //  cut scavenged record from list

        pback->pRRNext = prr->pRRNext;
        prr->pRRNext = NULL;

        if ( !pdeleteFirst )
        {
            pdeleteFirst = prr;
        }
        else
        {
            pdeleteLast->pRRNext = prr;
        }
        pdeleteLast = prr;

        //  set so pback will be the same the next time through

        prr = pback;
    }

    //  if deleted records, must reset flags

    if ( pdeleteFirst )
    {
        RR_ListResetNodeFlags( pNode );
    }

    UNLOCK_WRITE_RR_LIST(pNode);

    DNS_DEBUG( UPDATE, (
        "Leave RR_UpdateScavenge( %s )\n"
        "\tscavenged record = %s\n",
        pNode->szLabel,
        pdeleteFirst ? "TRUE" : "FALSE" ));

    return  pdeleteFirst;
}



DWORD
RR_UpdateForceAging(
    IN      PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Force aging on records in list.

Arguments:

    pZone -- zone being updated

    pNode -- ptr to node

    dwFlag -- flag on update

Return Value:

    Count of records for which aging turned on.

--*/
{
    PDB_RECORD  prr;
    DWORD       count = 0;

    DNS_DEBUG( UPDATE, (
        "RR_UpdateForceAging( %s )\n",
        pNode->szLabel ));

    //
    //  search list and force aging
    //

    LOCK_WRITE_RR_LIST(pNode);

    //  for zone update, clear cached data

    if ( pZone )
    {
        deleteCachedRecordsForUpdate(pNode);
    }

    prr = START_RR_TRAVERSE(pNode);

    while ( prr = NEXT_RR(prr) )
    {
        //  if already aging or non-scavenge type continue

        if ( prr->dwTimeStamp != 0  ||
            IS_NON_SCAVENGE_TYPE( prr->wType ) )
        {
            continue;
        }

        //  otherwise turn aging on

        prr->dwTimeStamp = g_CurrentTimeHours;
        count++;
    }

    UNLOCK_WRITE_RR_LIST(pNode);

    DNS_DEBUG( UPDATE, (
        "Leave RR_UpdateForceAging( %s )\n"
        "\tturned on %d records\n",
        pNode->szLabel,
        count ));

    return  count;
}



//
//  Add RR to node (load and update)
//

DNS_STATUS
RR_AddToNode(
    IN      PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN OUT  PDB_RECORD      pRR
    )
/*++

Routine Description:

    Add a resource record to node in database.

Arguments:

    pNode -- ptr to node to add resource record to

    pRR -- resource record to add

Return Value:

    ERROR_SUCCESS -- if successful
    DNS_ERROR_RECORD_ALREADY_EXISTS -- if new record is duplicate
    ErrorCode for CNAME error

--*/
{
    PDB_RECORD      pcurRR;
    PDB_RECORD      pprevRR;
    WORD            type;
    UCHAR           rank;
    DNS_STATUS      status;

    ASSERT( pNode != NULL );
    ASSERT( pRR != NULL );

    //  indicate cache zone with NULL ptr

    if ( pZone && IS_ZONE_CACHE(pZone) )
    {
        pZone = NULL;
    }

    type = pRR->wType;

    LOCK_WRITE_RR_LIST(pNode);
    RR_ListVerify( pNode );

    //
    //  clear cached NAME_ERROR
    //

    if ( IS_NOEXIST_NODE(pNode) )
    {
        RR_RemoveCachedNameError(pNode);
    }

    //
    //  check CNAME node special case
    //

    if ( IS_CNAME_NODE(pNode) || type == DNS_TYPE_CNAME )
    {
        status = checkCnameConditions(
                    pNode,
                    pRR,
                    type );
        if ( status != ERROR_SUCCESS )
        {
            goto Done;
        }
    }

    //
    //  enforce RR node restrictions
    //      SOA, WINS, WINSR only at authoritative zone roots
    //      NS at zone root or delegation
    //
    //  DEVNOTE: could screen out non-NS and glue types for cache zone
    //
    //  note, we are setting node flags here, essentially assuming that
    //  below here the ONLY FAILURES are duplicates
    //

    if ( type != DNS_TYPE_A && pZone )
    {
        //
        //  adding NS record, outside root == adding delegation
        //
        //  if this is newly created node, clean out zone properties
        //  which otherwise are inherited during creation from
        //  node's parent
        //
        //  should ONLY be relevant for receiving delegation during XFR
        //

        if ( type == DNS_TYPE_NS )
        {
            if ( !IS_AUTH_ZONE_ROOT(pNode) )
            {
                //  no delegation can be added UNDER a delegation

                if ( !IS_ZONE_ROOT(pNode) && !IS_AUTH_NODE(pNode) )
                {
                    DNS_DEBUG( UPDATE, (
                        "WARNING:  attempt to add NS at node %p inside delegation or\n"
                        "\toutside zone.\n",
                        pNode ));
                    status = DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT;
                    goto Done;
                }

                //  create delegation

                SET_ZONE_ROOT( pNode );
                SET_DELEGATION_NODE( pNode );
            }
        }

        //
        //  adding CNAME, set CNAME node
        //

        else if ( type == DNS_TYPE_CNAME )
        {
            SET_CNAME_NODE( pNode );
        }

        //  SOA only at zone root
        //
        //      DEVNOTE: should we always be dirty here?
        //

        else if ( type == DNS_TYPE_SOA )
        {
            if ( ! IS_AUTH_ZONE_ROOT(pNode) )
            {
                status = DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT;
                goto Done;
            }
        }

        //
        //  WINS record
        //      - catch bogus placement
        //      - catch when LOCAL WINS does not get added to list (for secondary)

        else if ( IS_WINS_TYPE(type) )
        {
            status = Wins_RecordCheck(
                        pZone,
                        pNode,
                        pRR
                        );
            if ( status != ERROR_SUCCESS )
            {
                if ( status == DNS_INFO_ADDED_LOCAL_WINS )
                {
                    status = ERROR_SUCCESS;
                }
                goto Done;
            }
        }
    }

    //
    //  set RANK
    //      - mark glue records as glue
    //      - mark root hints as root hints
    //
    //  note doing this after type NS check, so it can mark node as delegation
    //      before set NS as glue
    //
    //  DEVNOTE: note:  duplicate RANK setting code with file and DS read
    //      see dfread.c and rrds.c for explanation of issues
    //

    if ( pZone )
    {
        if ( pRR->dwTtlSeconds == pZone->dwDefaultTtl )
        {
            SET_ZONE_TTL_RR(pRR);
        }
        rank = RANK_ZONE;
        if ( !IS_AUTH_NODE(pNode) )
        {
            rank = RANK_GLUE;
            if ( type == DNS_TYPE_NS )
            {
                rank = RANK_NS_GLUE;
            }
        }
    }

    //
    //  mark cache hints
    //      - no TTL (they never hit the wire, they don't time out)
    //

    else  // add to cache can only be root hints
    {
        rank = RANK_ROOT_HINT;
        pRR->dwTtlSeconds = 0;

        if ( type == DNS_TYPE_NS )
        {
            SET_ZONE_ROOT( pNode );
        }
    }

    RR_RANK(pRR) = rank;
    ASSERT( rank != 0  &&  !IS_CACHE_RR(pRR) );


    //
    //  traverse list, until find first resource record of higher type
    //

    pcurRR = START_RR_TRAVERSE( pNode );

    while ( pprevRR = pcurRR, pcurRR = pprevRR->pRRNext )
    {
        //  continue until reach new type
        //  break when past new type

        if ( type != pcurRR->wType )
        {
            if ( type > pcurRR->wType )
            {
                continue;
            }
            break;
        }

        //  found desired type
        //  continue past records higher rank
        //  break when reach inferior data
        //
        //  Note: with DNSSEC, we may have ZONE rank SIG and NXT 
        //  records with GLUE rank records.

        if ( rank != RR_RANK(pcurRR) )
        {
            ASSERT( IS_CACHE_RR(pcurRR) ||
                    type == DNS_TYPE_A ||
                    type == DNS_TYPE_NS ||
                    type == DNS_TYPE_SIG ||
                    type == DNS_TYPE_NXT );
            if ( rank < RR_RANK(pcurRR) )
            {
                continue;
            }
            break;
        }

        //
        //  check for duplicate record
        //      - ignore TTL in check
        //

        if ( RR_Compare( pRR, pcurRR, FALSE, FALSE ) )
        {
            status = DNS_ERROR_RECORD_ALREADY_EXISTS;
            goto Done;
        }

        //  only one SOA

        if ( type == DNS_TYPE_SOA )
        {
            DNS_PRINT((
                "ERROR:  existing SOA on SOA load at node %s\n"
                "\tpZone    = %p\n"
                "\tpNode    = %p\n"
                "\tcur RR   = %p\n"
                "\tnew RR   = %p\n",
                pNode->szLabel,
                pZone,
                pNode,
                pcurRR,
                pRR ));

            ASSERT( FALSE );
            status = DNS_ERROR_RECORD_ALREADY_EXISTS;
            goto Done;
        }
    }

    //
    //  If this is a DNSSEC record, set the zone's DNSSEC flag.
    //

    if ( IS_DNSSEC_TYPE( type ) && pZone )
    {
        pZone->bContainsDnsSecRecords = TRUE;
    }
    //
    //  put in RR between pprevRR and pcurRR
    //

    pRR->pRRNext = pcurRR;
    pprevRR->pRRNext = pRR;

    RR_ListVerify( pNode );

    UNLOCK_WRITE_RR_LIST(pNode);
    return( ERROR_SUCCESS );

Done:

    DNS_DEBUG( LOOKUP, (
        "RR_AddToNode() no add.\n"
        "\tstatus   = %d (%p)\n"
        "\tpZone    = %p\n"
        "\tpNode    = %p\n"
        "\tpRR      = %p (type %d)\n",
        status, status,
        pZone,
        pNode,
        pRR, pRR->wType
        ));

    UNLOCK_WRITE_RR_LIST(pNode);
    return( status );
}



DNS_STATUS
RR_UpdateAdd(
    IN      PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN OUT  PDB_RECORD      pRR,
    IN OUT  PUPDATE         pUpdate,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Add an update resource record to node in database.

Arguments:

    pNode -- ptr to node to add resource record to

    pRR -- resource record to add

    pUpdate -- update for add;

    dwFlag -- type of update, from packet, admin, DS

Return Value:

    ERROR_SUCCESS -- if successful
    DNS_ERROR_RECORD_ALREADY_EXISTS -- if new record is duplicate
    DNS_ERROR_RCODE_REFUSED -- if dynamic update not allowed for this record
    ErrorCode for invalid update
        - CNAME error
        - SOA, NS, WINS outside zone root etc.

--*/
{
    PDB_RECORD  pcurRR;
    PDB_RECORD  pprevRR;
    WORD        type;
    UCHAR       rank;
    DNS_STATUS  status;

    ASSERT( pZone && pNode && pRR && pUpdate );

    type = pRR->wType;
    rank = RR_RANK(pRR);

    DNS_DEBUG( UPDATE, (
        "RR_UpdateAdd( z=%s, n=%s, pRR=%p )\n",
        pZone ? pZone->pszZoneName : "null",
        pNode->szLabel,
        pRR ));

    LOCK_WRITE_RR_LIST(pNode);
    RR_ListVerify( pNode );

    //
    //  clear cached data
    //

    deleteCachedRecordsForUpdate(pNode);

    //
    //  check CNAME node special case
    //

    if ( IS_CNAME_NODE(pNode) || type == DNS_TYPE_CNAME )
    {
        status = checkCnameConditions(
                    pNode,
                    pRR,
                    type );
        if ( status != ERROR_SUCCESS )
        {
            if ( dwFlag & DNSUPDATE_PACKET )
            {
                if ( type == DNS_TYPE_CNAME &&
                    SrvCfg_fSilentlyIgnoreCNameUpdateConflict )
                {
                    DNS_DEBUG( UPDATE, (
                        "Silently ignoring CNAME update conflict for node %s\n"
                        "\tin zone %s\n",
                        pNode->szLabel,
                        pZone->pszZoneName ));
                    status = ERROR_SUCCESS;;
                }
                else
                {
                    DNS_DEBUG( UPDATE, (
                        "Update CNAME conflict at node %s -- returning YXRRSET.\n"
                        "\tEither update type %d is CNAME or node is CNAME\n"
                        "\tand are updating with non-CNAME compatible type.\n",
                        pNode->szLabel,
                        type ));
                    ASSERT( DNS_ERROR_CNAME_COLLISION || DNS_ERROR_NODE_IS_CNAME );
                    status = DNS_ERROR_RCODE_YXRRSET;
                }
            }
            goto NoAdd;
        }
    }

    //
    //  enforce RR node restrictions
    //      SOA, WINS, WINSR only at authoritative zone roots
    //      NS at zone root or delegation
    //

    if ( type != DNS_TYPE_A )
    {
        //
        //  NS records only at zone root
        //
        //  adding NS record, outside root => adding delegation
        //      - clean out zone ptr
        //      - set ZONE_ROOT flag
        //
        //  new delegations can come from
        //      - admin
        //      - IXFR
        //      - by policy, dynamic update delegation
        //
        //  DEVNOTE: perhaps need server flag to allow
        //              perhaps check should be on non-secure update zone
        //
        //  DEVNOTE: set\or check RR_RANK to NS_GLUE if doing delegation NS
        //              this may be handled properly by the node write routines
        //
        //      may have to do general case on glue here to handle XFR
        //      (or later UPDATE) where delegation change comes in rendering
        //      previous records haven't
        //      this becomes less important with separate zones where no confusion
        //      about
        //

        if ( type == DNS_TYPE_NS )
        {
            if ( !IS_AUTH_ZONE_ROOT(pNode) )
            {
                //  no delegation can be added UNDER a delegation

                if ( !IS_ZONE_ROOT(pNode) && !IS_AUTH_NODE(pNode) )
                {
                    DNS_DEBUG( UPDATE, (
                        "WARNING:  attempt to add NS at node %p inside delegation or\n"
                        "\toutside zone.\n",
                        pNode ));
                    status = DNS_ERROR_INVALID_TYPE;
                    goto NoAdd;
                }

                //  by policy may exclude dynamic update of delegation

                if ( (dwFlag & DNSUPDATE_PACKET) &&
                     ( SrvCfg_fNoUpdateDelegations ||
                       (SrvCfg_dwUpdateOptions & UPDATE_NO_DELEGATION_NS) ) )
                {
                    status = DNS_ERROR_RCODE_REFUSED;
                    goto NoAdd;
                }

                //  create delegation

                SET_ZONE_ROOT( pNode );
                SET_DELEGATION_NODE( pNode );
            }

            //  root NS
            //      - by policy may exclude root-NS updates

            else if ( dwFlag & DNSUPDATE_PACKET &&
                      (SrvCfg_dwUpdateOptions & UPDATE_NO_ROOT_NS) )
            {
                status = DNS_ERROR_RCODE_REFUSED;
                goto NoAdd;
            }
        }

        //  SOA only at zone root
        //      - by policy may exclude SOA dynamic update

        else if ( type == DNS_TYPE_SOA )
        {
            if ( !IS_AUTH_ZONE_ROOT(pNode) )
            {
                status = DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT;
                goto NoAdd;
            }
            if ( dwFlag & DNSUPDATE_PACKET &&
                 (SrvCfg_dwUpdateOptions & UPDATE_NO_SOA) )
            {
                status = DNS_ERROR_RCODE_REFUSED;
                goto NoAdd;
            }
        }

        //
        //  WINS record
        //      - catch bogus placement
        //      - catch when LOCAL WINS does not get added to list (for secondary)
        //      pRR is saved in zone but removed from update list
        //

        else if ( IS_WINS_TYPE(type) )
        {
            status = Wins_RecordCheck(
                        pZone,
                        pNode,
                        pRR
                        );
            if ( status != ERROR_SUCCESS )
            {
                if ( status == DNS_INFO_ADDED_LOCAL_WINS )
                {
                    pRR = NULL;
                    status = ERROR_SUCCESS;
                }
                goto NoAdd;
            }
            pZone->fRootDirty = TRUE;
        }

    }   // non-A types

    //
    //  mark glue records as glue
    //  mark root hints as root hints
    //
    //  DEVNOTE: probably shouldn't even bother with rank inside zone
    //      when compare to cache data just use zone positional info
    //

    if ( pZone )
    {
        if ( pRR->dwTtlSeconds == pZone->dwDefaultTtl )
        {
            SET_ZONE_TTL_RR(pRR);
        }
        rank = RANK_ZONE;

        //  sub-zone \ delegation updates
        //      - mark RR with appropriate glue rank
        //      - allow NS only at delegation
        //      - validity check other records
        //      (A, AAAA, SIG, KEY, etc. allowed)

        if ( !IS_AUTH_NODE(pNode) )
        {
            if ( type == DNS_TYPE_NS )
            {
                rank = RANK_NS_GLUE;
                if ( !IS_ZONE_ROOT(pNode) )
                {
                    status = DNS_ERROR_INVALID_TYPE;
                    goto NoAdd;
                }
            }
            else
            {
                rank = RANK_GLUE;
                if ( ! IS_UPDATE_IN_SUBZONE_TYPE(type) )
                {
                    status = DNS_ERROR_INVALID_TYPE;
                    goto NoAdd;
                }
            }
        }
    }

    RR_RANK(pRR) = rank;
    ASSERT( rank != 0  &&  !IS_CACHE_RR(pRR) );


    //
    //  traverse list, until find first resource record of higher type
    //

    pcurRR = START_RR_TRAVERSE( pNode );

    while ( pprevRR = pcurRR, pcurRR = pprevRR->pRRNext )
    {
        //  continue until reach new type
        //  break when past new type

        if ( type != pcurRR->wType )
        {
            if ( type > pcurRR->wType )
            {
                continue;
            }
            break;
        }

        //  delete any cached records of desired type
        //      - eliminate WINS \ WINS-R cached records before add update

        if ( IS_CACHE_RR( pcurRR ) )
        {
            pprevRR->pRRNext = pcurRR->pRRNext;

            DNS_DEBUG( UPDATE, (
                "Deleting cached RR at %p in preparation for update.\n",
                pcurRR ));

            RR_Free( pcurRR );
            pcurRR = pprevRR;
            continue;
        }

        //  found desired type
        //  continue past records higher rank
        //  break when reach inferior data
        //      - only A and NS should have cached data of same type updating

        if ( rank != RR_RANK(pcurRR) )
        {
            if ( rank < RR_RANK(pcurRR) )
            {
                ASSERT( type == DNS_TYPE_A || type == DNS_TYPE_NS );
                continue;
            }
            break;
        }

        //
        //  check for duplicates
        //      - do not include TTL in comparison
        //

        if ( RR_Compare( pRR, pcurRR, FALSE, FALSE ) )
        {
            //
            //  record is duplicate
            //
            //  TTL change, do simple overwrite
            //

            if ( pRR->dwTtlSeconds != pcurRR->dwTtlSeconds )
            {
                goto Overwrite;
            }

            //
            //  now duplicate record for all DNS-RFC data
            //      => update will be no-op
            //      => but may still have aging change
            //
            //  pick up aging info from update RR
            //  EXCEPT when have non-aging record and
            //      are not explicitly turning aging ON
            //      via ADMIN update
            //
            //  note, contrary to the belief of some confused developers
            //  and PMs, we do NOT suppress refresh changes here because
            //  we WANT to move the record's time stamps forward if we
            //  end up doing a write for any reason;
            //  if we suppress the new timestamp then we will later have
            //  to do additional writes for the records we suppressed here;
            //  the classic example of this is precon RRs followed by
            //  update;  we WANT to refresh the precon RRs when we execute
            //  the update, otherwise EACH AND EVERY RR in the set would
            //  generate a DS write when it's individual refresh came due
            //
            //  so the general paradigm is always keep track of any touch
            //  to the record;  then we'll specifically check for the need
            //  for DS write on the node's entire RR list, and IF we write
            //  we'll always write the list with the LATEST timestamps
            //

            status = DNS_ERROR_RECORD_ALREADY_EXISTS;

            if ( pcurRR->dwTimeStamp != 0 ||
                ( (dwFlag & DNSUPDATE_ADMIN) && (dwFlag & DNSUPDATE_AGING_ON) ) )
            {
                //  if making an explicit AGING ON\OFF change, then
                //  suppress ALREADY_EXISTS error code for admin updates
                //  as this code is reported back to DNS manager
                //
                //  note, test is just whether aging OFF before or after,
                //  because OFF before AND after, is ruled out by above test

                if ( (dwFlag & DNSUPDATE_ADMIN)
                        &&
                    (pcurRR->dwTimeStamp == 0 || pRR->dwTimeStamp == 0) )
                {
                    status = ERROR_SUCCESS;
                }

                pcurRR->dwTimeStamp = pRR->dwTimeStamp;
            }

            goto NoAdd;
        }

        //
        //  overwrite type?
        //
        //  for some types:  SOA, CNAME, WINS, WINSR
        //  "add" is always a replace, there is no possibility of
        //  having multiple records even if delete operation was
        //  not specified
        //      - cut existing and replace
        //

        switch( type )
        {

        case DNS_TYPE_CNAME:
        case DNS_TYPE_WINS:
        case DNS_TYPE_WINSR:

            //  no-op always overwrite CNAME or WINS

            goto Overwrite;

        case DNS_TYPE_SOA:
        {
            //
            //  for UPDATE protocol must increase serial number over current
            //      - if not ignore SOA
            //  mark root dirty for zone SOA update on completion
            //      - do not install it here as may later have rollback on failure
            //          issues (ex:  scriptable admin with multiple updates)
            //

            if ( dwFlag & DNSUPDATE_PACKET )
            {
                DWORD       diffSerial;

                ASSERT( pZone && pZone->pSoaRR );

                diffSerial = htonl( pRR->Data.SOA.dwSerialNo ) -
                                htonl( pcurRR->Data.SOA.dwSerialNo );

                if ( diffSerial == 0 || diffSerial > (DWORD)MAXLONG )
                {
                    DNS_DEBUG( UPDATE, (
                        "WARNING:  Ignoring SOA update with bad serial.\n" ));
                    status = DNS_ERROR_SOA_DELETE_INVALID;
                    goto NoAdd;
                }
            }
            pZone->fDirty = TRUE;
            pZone->fRootDirty = TRUE;
            goto Overwrite;
        }

        default:

            //  NOT overwrite type -- continue checking with next record

            continue;

        }   // end switch on overwrite types
    }

    //
    //  found correct location
    //  put in RR between pprevRR and pcurRR
    //  increment update record count
    //  reset flags if picked up NS or CNAME record
    //

    pRR->pRRNext = pcurRR;
    pprevRR->pRRNext = pRR;

    pUpdate->pAddRR = pRR;

    //
    //  reset node properties
    //      - flags, authority (if delegation), NS list
    //

    RR_ListResetNodeFlags( pNode );

    RR_ListVerify( pNode );
    UNLOCK_WRITE_RR_LIST(pNode);

    DNS_DEBUG( UPDATE, (
        "RR_UpdateAdd() ADDED UPDATE RR.\n" ));
    return( ERROR_SUCCESS );


Overwrite:

    //
    //  overwrite type or TTL change on duplicate data
    //
    //  if aging disabled, packet update should NOT override
    //
    //  DEVNOTE: non-duplicate data (TTL ok) should not preserve zero timestamp
    //

    if ( pcurRR->dwTimeStamp == 0
            &&
        (dwFlag & DNSUPDATE_PACKET) )
    {
        DNS_DEBUG( AGING, (
            "Aging: Applied disabled RR Timestamp field.\n",
            pcurRR ));
        pRR->dwTimeStamp = 0;
    }

    //  replace old with new
    //      - cut existing and replace with new RR
    //      - add delete RR to update
    //      - update has no net record count effect

    pprevRR->pRRNext = pRR;
    pRR->pRRNext = pcurRR->pRRNext;
    pcurRR->pRRNext = NULL;

    pUpdate->pDeleteRR = pcurRR;
    pUpdate->pAddRR = pRR;

    RR_ListVerify( pNode );
    UNLOCK_WRITE_RR_LIST(pNode);

    DNS_DEBUG( UPDATE, (
        "RR_UpdateAdd() REPLACED existing RR %p with UPDATE RR.\n",
        pcurRR ));
    return( ERROR_SUCCESS );

NoAdd:

    UNLOCK_WRITE_RR_LIST(pNode);
    DNS_DEBUG( UPDATE, (
        "RR_UpdateAdd() -- IGNORING UPDATE add.\n",
        "\tstatus = %p (%d)\n",
        status, status ));

    //
    //  free record
    //      - NULL out add in passed in update
    //      or
    //      - whack newly created update from list and free
    //

    RR_Free( pRR );
    pUpdate->pAddRR = NULL;

    //  mark update as rejected
    //      - this keeps "empty update" check ASSERT from firing

    pUpdate->wDeleteType = UPDATE_OP_REJECTED;

    //  clear ALREADY_EXISTS error, accept for admin
    //  for everyone else this is not an error

    if ( status == DNS_ERROR_RECORD_ALREADY_EXISTS  &&
         !(dwFlag & DNSUPDATE_ADMIN) )
    {
        status = ERROR_SUCCESS;
    }

    return( status );
}



PDB_RECORD
RR_ReplaceSet(
    IN      PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pRR,
    IN      DWORD           Flag
    )
/*++

Routine Description:

    Replace record set.
    For use by UPDATE.

Arguments:

    pZone -- ptr to zone info

    pNode -- ptr to node

    pRR -- replacement record set

    Flag --

Return Value:

    Ptr to replaced record set.

--*/
{
    PDB_RECORD  pcurrent;
    WORD        replaceType;
    WORD        typeCurrent;
    PDB_RECORD  pbeforeDelete;
    PDB_RECORD  pdelete = NULL;
    PDB_RECORD  pdeleteLast = NULL;
    PDB_RECORD  preplaceLast;
    UCHAR       rank;
    DWORD       ttl;

    DNS_DEBUG( UPDATE, (
        "RR_ReplaceSet( %s, pZone=%p, pRR=%p, Flag=%d )\n",
        pNode->szLabel,
        pZone,
        pRR,
        Flag ));

    LOCK_WRITE_RR_LIST(pNode);
    RR_ListVerify( pNode );

    //
    //  clear cached data
    //

    deleteCachedRecordsForUpdate(pNode);

    //
    //  find end of replace list
    //      - validate common type
    //      - set RR rank
    //      - set zone TTL
    //

    replaceType = pRR->wType;
    ASSERT( !IS_COMPOUND_TYPE_EXCEPT_ANY(replaceType) );

    rank = RANK_ROOT_HINT;
    ttl = 0;
    if ( pZone )
    {
        ttl = pZone->dwDefaultTtl;

        rank = RANK_ZONE;
        if ( !IS_AUTH_NODE(pNode) )
        {
            rank = RANK_GLUE;
            if ( replaceType == DNS_TYPE_NS )
            {
                rank = RANK_NS_GLUE;
            }
        }
    }

    pcurrent = pRR;
    do
    {
        ASSERT( pcurrent->wType == replaceType );

        RR_RANK( pcurrent ) = rank;
        pcurrent->dwTtlSeconds = ttl;
        SET_ZONE_TTL_RR( pcurrent );

        preplaceLast = pcurrent;
    }
    while( pcurrent = pcurrent->pRRNext );

    //
    //  find records of replacement type
    //      - cut them from list
    //      - patch new ones in
    //

    pcurrent = START_RR_TRAVERSE(pNode);
    pbeforeDelete = pcurrent;

    while ( pcurrent = pcurrent->pRRNext )
    {
        ASSERT( IS_VALID_RECORD(pRR) );

        typeCurrent = pcurrent->wType;

        //  found delete type
        //      - save ptr to first record

        if ( typeCurrent == replaceType )
        {
            if ( !pdelete )
            {
                pdelete = pcurrent;
            }
            pdeleteLast = pcurrent;
            continue;
        }

        //  before matching records -- continue

        if ( typeCurrent < replaceType )
        {
            pbeforeDelete = pcurrent;
            continue;
        }
        break;      //  past matching records -- stop
    }

    //
    //  have isolated type records
    //      pbeforeDelete   -- ptr to record (or node ptr) before type
    //      pdelete         -- first record of replace type
    //      pdeleteLast     -- last record of replace type
    //      pcurrent        -- record after replace set
    //
    //  splice in new RR set
    //  NULL terminate old set (if any)
    //

    pbeforeDelete->pRRNext = pRR;
    preplaceLast->pRRNext = pcurrent;

    if ( pdeleteLast )
    {
        pdeleteLast->pRRNext = NULL;
    }

    //
    //  reset node properties
    //      - flags, authority (if delegation), NS list
    //

    RR_ListResetNodeFlags( pNode );

    RR_ListVerify( pNode );
    UNLOCK_WRITE_RR_LIST(pNode);

    IF_DEBUG( UPDATE )
    {
        DnsDebugLock();
        DNS_PRINT((
            "Node after replace of type = %d.\n",
            replaceType ));
        Dbg_DbaseNode(
            "Node after type delete:\n",
            pNode );
        DnsDebugUnlock();
    }

    return( pdelete );
}



#if 0
//  unused


DNS_STATUS
RR_VerifyUpdate(
    IN OUT  PDB_NODE        pNode,
    IN OUT  PDB_RECORD      pRR,
    IN OUT  PUPDATE         pUpdate
    )
/*++

Routine Description:

    Verify proposed update is valid for this node.

    The idea here is to catch updates that we will NOT be able to do
    to avoid roll back.  Currently doing silent ignore.

Arguments:

    pNode -- ptr to node to add resource record to

    pRR -- resource record to add

    pUpdate -- update for add

Return Value:

    ERROR_SUCCESS -- if successful
    ErrorCode for CNAME error

--*/
{
    PDB_RECORD  pcurRR;
    PDB_RECORD  pprevRR;
    WORD        type;
    DNS_STATUS  status = ERROR_SUCCESS;

    ASSERT( pNode != NULL );
    ASSERT( pRR != NULL );

    type = pRR->wType;

    LOCK_WRITE_RR_LIST(pNode);
    RR_ListVerify( pNode );

    //
    //  clear cached data
    //

    deleteCachedRecordsForUpdate(pNode);

    pprevRR = START_RR_TRAVERSE( pNode );
    pcurRR = NEXT_RR( pprevRR );

    //
    //  CNAME node special case
    //

    if ( IS_CNAME_NODE(pNode) )
    {
        if ( !IS_ALLOWED_AT_CNAME_NODE_TYPE(type) )
        {
            status = DNS_ERROR_CNAME_COLLISION;
            goto Done;
        }
    }

    //
    //  SOA only at zone root
    //

    if ( type == DNS_TYPE_SOA )
    {
        if ( ! IS_AUTH_ZONE_ROOT(pNode) )
        {
            status = DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT;
            goto Done;
        }
    }

Done:
    UNLOCK_WRITE_RR_LIST(pNode);
    return( ERROR_SUCCESS );
}
#endif



//
//  Miscellaneous RR list related routines.
//

//
//  DEVNOTE: cname loop check needs work -- should be in the context of a zone
//

BOOL
FASTCALL
checkForCnameLoop(
    IN      PDB_NODE        pNodeNew,
    IN      PDB_NODE        pNodeCheck,
    IN      DWORD           cChainLength
    )
/*++

Routine Description:

    Test for new CNAME node being part of CNAME loop.

    This handles multiple CNAMEs at node

Arguments:

    pNodeNew -- original node adding CNAME, hence the node to look for to
        verify a loop

    pNodeCheck -- node in CNAME chain to check this call

    cChainLength -- chain length at this call;  call with 0

Return Value:

    TRUE if CNAME loop.
    FALSE otherwise.

--*/
{
#ifdef NEWDNS
    return( FALSE );

#else
    PDB_NODE        pnode;
    PDB_RECORD      prr;
    DWORD           currentTime = 0;
    BOOL            foundCname = FALSE;

    //
    //  loop until find end of CNAME chain
    //      or
    //  detect a loop
    //
    //  note, we only bother to check for our node being in the loop,
    //      any pre-existing loop should have been caught when it
    //      was made;  but provide count to avoid spin
    //

    LOCK_WRITE_RR_LIST(pNodeCheck);

    //
    //  if adding self-referential CNAME RR, catch right away
    //

    if ( pNodeNew == pNodeCheck )
    {
        pnode = pNodeNew;
        goto CnameLoop;
    }

    //
    //  regular node -- no loop
    //

    if ( ! IS_CNAME_NODE(pNodeCheck) )
    {
        UNLOCK_WRITE_RR_LIST(pNodeCheck);
        return( FALSE );
    }

    //
    //  check all CNAMEs to see if they point back to start node
    //

    prr = START_RR_TRAVERSE( pNodeCheck );

    while ( prr = NEXT_RR(prr) )
    {
        if ( prr->wType != DNS_TYPE_CNAME )
        {
            if ( !IS_ALLOWED_WITH_CNAME_TYPE(prr->wType) )
            {
                ASSERT( FALSE );
            }
            continue;
        }
        foundCname = TRUE;

        //  if cached node, check timeout
        //      but not for the new node itself

        if ( IS_CACHE_RR(prr) && pNodeCheck != pNodeNew )
        {
            if ( !currentTime )
            {
                currentTime = GetCurrentTimeInSeconds();
            }
            if ( prr->dwTtlSeconds < currentTime )
            {
                RR_ListTimeout(pNodeCheck);
                ASSERT( pNodeCheck->pRRList == NULL );
                break;
            }
        }

        //
        //  RR points at new node -- CNAME loop?
        //

        pnode = Lookup_FindDbaseName( pRR->Data.CNAME.nameTarget );
        if ( pnode == pNodeNew )
        {
            //  peramanent record or cycle within new node
            //      => report CNAME loop error

            if ( pNodeCheck == pNodeNew || !IS_CACHE_RR(prr) )
            {
                goto CnameLoop;
            }

            //  if cached record -- break loop here

            RR_ListDelete( pNodeCheck );
            ASSERT( pNodeCheck->pRRList == NULL );
            break;
        }

        //
        //  recurse to continue loop check with CNAME nodes
        //

        if ( cChainLength >= CNAME_CHAIN_LIMIT )
        {
            goto CnameLoop;
        }
        if ( checkForCnameLoop( pNodeNew, pnode, ++cChainLength ) )
        {
            goto CnameLoop;
        }
    }

    //  drops here if no CNAME loop
    //      - if no CNAME at node, clear flag

    if ( ! foundCname )
    {
        DNS_PRINT((
            "ERROR:  node %s at %p with bogus CNAME flag.\n",
            pNodeCheck->szLabel,
            pNodeCheck ));
        ASSERT( FALSE );
        CLEAR_CNAME_NODE( pNodeCheck );
    }
    UNLOCK_WRITE_RR_LIST(pNodeCheck);
    return( FALSE );

CnameLoop:

    //
    //  detected CNAME LOOP
    //
    //  log message, given new node trying to add,
    //  and this link in loop (recursion adds all the
    //  links in the loop)
    //
    {
        PCHAR   pszArgs[3];
        CHAR    szLoadNode [ DNS_MAX_NAME_BUFFER_LENGTH ];
        CHAR    szAliasNode[ DNS_MAX_NAME_BUFFER_LENGTH ];
        CHAR    szCnameNode[ DNS_MAX_NAME_BUFFER_LENGTH ];

        Name_PlaceFullNodeNameInRpcBuffer(
            szLoadNode,
            szLoadNode + sizeof(szLoadNode),
            pNodeNew );

        Name_PlaceFullNodeNameInRpcBuffer(
            szAliasNode,
            szAliasNode + sizeof(szAliasNode),
            pNodeCheck );

        Name_PlaceFullNodeNameInRpcBuffer(
            szCnameNode,
            szCnameNode + sizeof(szCnameNode),
            pnode );

        pszArgs[0] = szLoadNode + 1;
        pszArgs[1] = szAliasNode + 1;
        pszArgs[2] = szCnameNode + 1;

        DNS_LOG_EVENT(
            DNS_EVENT_CNAME_LOOP_LINK,
            3,
            pszArgs,
            EVENTARG_ALL_UTF8,
            0 );

    }
    UNLOCK_WRITE_RR_LIST(pNodeCheck);
    return( TRUE );
#endif
}



DNS_STATUS
FASTCALL
cleanRecordListForNewCname(
    IN OUT  PDB_NODE        pNode
    )
/*++

Routine Description:

    Delete cached records incompatible with CNAME.

    Assumes:  RR list or node already locked.

Arguments:

    pNode -- ptr to node

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_CNAME_COLLISION.

--*/
{
    PDB_RECORD  pcurRR;
    PDB_RECORD  pprevRR;
    WORD        typeCurrent;

    ASSERT( IS_LOCKED_NODE(pNode) );

    pprevRR = START_RR_TRAVERSE(pNode);

    while ( pcurRR = pprevRR->pRRNext )
    {
        typeCurrent = pcurRR->wType;

        if ( IS_ALLOWED_WITH_CNAME_TYPE(typeCurrent) )
        {
            pprevRR = pcurRR;
            continue;
        }

        //  if incompatible, cached RR -- cut out and delete

        if ( IS_CACHE_RR( pcurRR ) )
        {
            DNS_DEBUG( READ, (
                "Deleting cached RR %p type %d at node %p\n"
                "\tto add new CNAME RR\n",
                pcurRR,
                typeCurrent,
                pNode ));
            pprevRR->pRRNext = pcurRR->pRRNext;
            RR_Free( pcurRR );
            continue;
        }

        //  if incompatible, non-cached type -- error

        Dbg_DbaseNode(
            "ERROR:  Attempt to add CNAME to node with incompatible record.\n",
            pNode );
        return  DNS_ERROR_CNAME_COLLISION;
    }

    return  ERROR_SUCCESS;
}



DNS_STATUS
FASTCALL
checkCnameConditions(
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pRR,
    IN      WORD            wType
    )
/*++

Routine Description:

    Check CNAME conditions on adding node to database.

    Conditions:
        - only CNAME data at a node
        - no CNAME loops

    Assumes:  RR list or node already locked.

Arguments:

    pNode -- ptr to node to add resource record to

    pRR -- resource record to add

    wType -- record type

Return Value:

    ERROR_SUCCESS -- if successful
    DNS_ERROR_NODE_IS_CNAME -- if adding non-CNAME data a CNAME node
    DNS_ERROR_CNAME_COLLISION -- if adding CNAME at non-CNAME node
    DNS_ERROR_CNAME_LOOP -- if causing CNAME loop

--*/
{
    ASSERT( pNode && pRR );

    ASSERT( IS_LOCKED_NODE(pNode) );

    //
    //  CNAME node -- no non-CNAME data
    //      - allow some types with CNAME
    //      - protect against condition where left stray flag set
    //          (should never happen)
    //      - dump cached data
    //

    if ( IS_CNAME_NODE(pNode) && wType != DNS_TYPE_CNAME )
    {
        if ( IS_ALLOWED_WITH_CNAME_TYPE(wType) )
        {
            DNS_DEBUG( READ, (
                "Writing new type %d to existing CNAME node %p\n",
                wType,
                pNode ));
            return( ERROR_SUCCESS );
        }
        if ( !pNode->pRRList )
        {
            Dbg_DbaseNode(
                "ERROR:  Node with CNAME flag and no data.\n",
                pNode );
            ASSERT( FALSE );
            CLEAR_CNAME_NODE( pNode );
            return( ERROR_SUCCESS );
        }
        if ( IS_CACHE_TREE_NODE(pNode) )
        {
            Dbg_DbaseNode(
                "WARNING:  clearing existing cached CNAME node to create non-CNAME ",
                pNode );
            RR_ListDelete( pNode );
            CLEAR_CNAME_NODE( pNode );
            return( ERROR_SUCCESS );
        }

        IF_DEBUG( READ )
        {
            Dbg_DbaseNode(
                "ERROR:  Attempt to add record to CNAME node.\n",
                pNode );
        }
        return( DNS_ERROR_NODE_IS_CNAME );
    }

    //
    //  add CNAME type
    //  if non-CNAME node becoming CNAME must not have incompatible RRs
    //  delete any cached incompatible RRs, if incompatible static RRs
    //  (zone data or glue) then error
    //

    ASSERT( wType == DNS_TYPE_CNAME );

    if ( !IS_CNAME_NODE(pNode) )
    {
        if ( pNode->pRRList )
        {
            DNS_STATUS  status = cleanRecordListForNewCname( pNode );
            if ( status != ERROR_SUCCESS )
            {
                return status;
            }
        }
    }

    //
    //  CNAME loop check
    //

#ifndef NEWDNS
    if ( checkForCnameLoop(
            pNode,
            Lookup_FindDbaseName( pRR->Data.CNAME.nameTarget ),
            0 ) )
    {
        Dbg_DbaseNode(
            "ERROR:  Detected CNAME loop adding record at node ",
            pNode );
        if ( !pNode->pRRList )
        {
            CLEAR_CNAME_NODE( pNode );
        }
        return( DNS_ERROR_CNAME_LOOP );
    }
#endif

    return( ERROR_SUCCESS );
}



VOID
deleteCachedRecordsForUpdate(
    IN OUT  PDB_NODE    pNode
    )
/*++

Routine Description:

    Delete's cached records prior to update operation.

    This is for use by UPDATE operations, hence assumes authoritative
    node and looking only for WINS \ WINSR data.
    Note:  no locking as assuming database locked for UPDATE.

Arguments:

    pNode -- ptr to node

Return Value:

    None

--*/
{
    PDB_RECORD  prr;
    PDB_RECORD  pback;
    PZONE_INFO  pzone = pNode->pZone;

    ASSERT( IS_LOCKED_NODE(pNode) );

    //
    //  if name error on node, eliminate it
    //

    if ( IS_NOEXIST_NODE(pNode) )
    {
        RR_RemoveCachedNameError(pNode);
        return;
    }

    //
    //  delete any cached lookups
    //      - only need to check if in WINS or WINSR zone
    //
    //  DEVNOTE: this changes if allow delegation updates
    //

    if ( ! pzone ||
        ! pzone->pWinsRR ||
        ( !pzone->fReverse && pNode->pParent != pzone->pZoneRoot ) )
    {
        return;
    }

    //  purge RR list of any cached records

    prr = START_RR_TRAVERSE( pNode );

    while ( pback = prr, prr = prr->pRRNext )
    {
        if ( IS_CACHE_RR(prr) )
        {
            pback->pRRNext = prr->pRRNext;
            RR_Free( prr );
            prr = pback;
        }
    }
}


#if 0
//
//  Non-recursive version
//
BOOL
FASTCALL
checkForCnameLoop(
    IN      PDB_NODE        pNodeNew,
    IN      PDB_NODE        pNodeCname
    )
/*++

Routine Description:

    Test for new CNAME node being part of CNAME loop.

    MUST hold database lock while check loop.
    This handles multiple CNAMEs at node

Arguments:

    pNodeNew -- original node adding CNAME, hence the node to look for to
        verify a loop

    pNodeCname -- CNAME (targer to CNAME record)

Return Value:

    TRUE if CNAME loop.
    FALSE otherwise.

--*/
{
    PDB_NODE        pnodeNextCname;
    PDB_RECORD      prr;
    DWORD           countCnames;
    BOOL            foundCname;

    //
    //  loop until find end of CNAME chain
    //      or
    //  detect a loop
    //
    //  note, we only bother to check for our node being in the loop,
    //      any pre-existing loop should have been caught when it
    //      was made;  but provide count to avoid spin
    //

    countCnames = 0;

    while( countCnames < CNAME_CHAIN_LIMIT )
    {
        LOCK_WRITE_RR_LIST(pNodeCname);

        //  regular node -- no loop

        if ( ! IS_CNAME_NODE(pNodeCname) )
        {
            UNLOCK_WRITE_RR_LIST(pNodeCname);
            return( FALSE );
        }

        //  look through records for CNAME

        pnodeNextCname = NULL;
        foundCname = FALSE;

        prr = START_RR_TRAVERSE( pNodeCname );

        while ( prr = NEXT_RR(prr) )
        {
            if ( prr->wType != DNS_TYPE_CNAME )
            {
                if ( !IS_ALLOWED_WITH_CNAME_TYPE(prr->wType) )
                {
                    ASSERT( FALSE );
                }
                continue;
            }
            foundCname = TRUE;

            //  if cached node, check timeout
            //      but not for the new node itself

            if ( IS_CACHE_RR(prr) && pNodeCname != pNodeNew )
            {
                if ( prr->dwTtlSeconds < DNS_TIME() )
                {
                    RR_ListTimeout(pNodeCname);
                    ASSERT( pNodeCname->pRRList == NULL );
                    break;
                }
            }

            //
            //  RR points at new node -- CNAME loop
            //      - if cyclic within new record => report loop
            //      - permanent record => report loop
            //      - if cached record => delete record to break loop
            //

            pnodeNextCname = Lookup_FindDbaseName( prr->Data.CNAME.nameTarget );
            if ( pnodeNextCname == pNodeNew )
            {
                if ( pNodeCname == pNodeNew || !IS_CACHE_RR(prr) || IS_ZONE_TREE_NODE(pNodeCname) )
                {
                    goto CnameLoop;
                }
                RR_ListDelete( pNodeCname );
                ASSERT( pNodeCname->pRRList == NULL );
                pnodeNextCname = NULL;
                break;
            }
        }

        //  drops here if CNAME at node did NOT from loop
        //      - if no CNAME at node, clear bogus flag

        if ( ! foundCname )
        {
            DNS_PRINT((
                "ERROR:  node %s at %p with bogus CNAME flag.\n",
                pNodeCname->szLabel,
                pNodeCname ));
            ASSERT( FALSE );
            CLEAR_CNAME_NODE( pNodeCname );
        }
        UNLOCK_WRITE_RR_LIST(pNodeCname);

        if ( !pnodeNextCname )
        {
            return( FALSE );
        }

        pNodeCname = pnodeNextCname;
        countCnames++;
    }

    //  drops here if exceeds CNAME chain limit

CnameLoop:

    //
    //  detected CNAME LOOP
    //
    //  log message, given new node trying to add,
    //  and this link in loop (recursion adds all the
    //  links in the loop)
    //
    {
        PCHAR   pszArgs[3];
        CHAR    szLoadNode [ DNS_MAX_NAME_BUFFER_LENGTH ];
        CHAR    szAliasNode[ DNS_MAX_NAME_BUFFER_LENGTH ];
        CHAR    szCnameNode[ DNS_MAX_NAME_BUFFER_LENGTH ];

        Name_PlaceFullNodeNameInRpcBuffer(
            szLoadNode,
            szLoadNode + sizeof(szLoadNode),
            pNodeNew );

        Name_PlaceFullNodeNameInRpcBuffer(
            szAliasNode,
            szAliasNode + sizeof(szAliasNode),
            pNodeCname );

        Name_PlaceFullNodeNameInRpcBuffer(
            szCnameNode,
            szCnameNode + sizeof(szCnameNode),
            pnode );

        pszArgs[0] = szLoadNode + 1;
        pszArgs[1] = szAliasNode + 1;
        pszArgs[2] = szCnameNode + 1;

        DNS_LOG_EVENT(
            DNS_EVENT_CNAME_LOOP_LINK,
            3,
            pszArgs,
            EVENTARG_ALL_UTF8,
            0 );

    }
    UNLOCK_WRITE_RR_LIST(pNodeCname);
    return( TRUE );
}

#endif


BOOL
RR_ListExtractInfo(
    IN      PDB_RECORD      pNewList,
    IN      BOOL            fZoneRoot,
    OUT     PBOOL           pfNs,
    OUT     PBOOL           pfCname,
    OUT     PBOOL           pfSoa
    )
/*++

Routine Description:

    Investigate new RR list for various conditions.

Arguments:

    pNewList -- new RR list

    fZoneRoot -- root of zone being updated;  for this case avoid delete
        of SOA and NS records;  do not generally do this as want to allow
        delete for delegations

    pfCname -- ptr to recv

Return Value:

    TRUE if successfull.
    FALSE on error.

--*/
{
    PDB_RECORD  prr;
    WORD        typeCurrent;

    *pfSoa = FALSE;
    *pfNs = FALSE;
    *pfCname = FALSE;

    //
    //  set bit for each record in mask
    //

    prr = pNewList;

    while ( prr )
    {
        ASSERT( IS_DNS_HEAP_DWORD(prr) );

        typeCurrent = prr->wType;

#if 0
        //  bitmask setting
        //  other possiblity is UCHAR array of types

        //  screen dual SOA

        if ( typeCurrent == DNS_TYPE_SOA &&
                SOA_BIT_SET(mask) )
        {
            return( -1 );
        }

        //  DEVNOTE:  screen dual CNAME?

        if ( typeCurrent < 32 )
        {
            mask |= (1 << (typeCurrent-1) );
        }
#endif

        //  NS

        if ( typeCurrent == DNS_TYPE_NS )
        {
            *pfNs = TRUE;
        }

        //  CNAME
        //      -- we won't screen dual

        if ( typeCurrent == DNS_TYPE_CNAME )
        {
#if 0
            if ( *pfCname )
            {
                return( FALSE );
            }
#endif
            *pfCname = TRUE;
        }

        //  SOA -- screen dual

        if ( typeCurrent == DNS_TYPE_SOA )
        {
            if ( *pfSoa )
            {
                return( FALSE );
            }
            *pfSoa = TRUE;
        }

        prr = NEXT_RR(prr);
    }

    return( TRUE );
}



DNS_STATUS
RR_ListReplace(
    IN OUT  PUPDATE         pUpdate,
    IN OUT  PDB_NODE        pNode,
    IN      PDB_RECORD      pNewList,
    OUT     PDB_RECORD *    ppDelete
    )
/*++

Routine Description:

    Replace record list.

Arguments:

    pUpdate -- update being executed

    pNode -- ptr to node

    pNewList -- new RR list

    ppDelete -- addr to recv ptr to deleted list

Return Value:

    List of records deleted.
    NULL if no records deleted.

--*/
{
    PDB_RECORD  pdelete = NULL;
    BOOL        bNs = FALSE;
    BOOL        bCname = FALSE;
    BOOL        bSoa = FALSE;
    BOOL        bzoneRoot = FALSE;
    PDB_RECORD  pcurrent;
    WORD        typeCurrent;
    PZONE_INFO  pZone;

    DNS_DEBUG( UPDATE, (
        "Enter RR_ListReplace()\n"
        "\tpnode = %p (%s)\n",
        pNode,
        pNode->szLabel ));

    pZone = pNode->pZone;

    //
    //  DEVNOTE: generally RR replace needs to be smarter
    //      - replace ANYTHING
    //      - reset
    //      - if busted because of zone fix with old records
    //          (retrieve SOA if missing, retrieve first\last NS if missing)


    //  authoritative zone root?

    bzoneRoot = IS_AUTH_ZONE_ROOT( pNode );

    //
    //  if replace RR set, get its info
    //

    if ( pNewList )
    {
        if ( ! RR_ListExtractInfo(
                    pNewList,
                    bzoneRoot,
                    & bNs,
                    & bCname,
                    & bSoa ) )
        {
            goto BadData;
        }
        if ( bSoa && !bzoneRoot )
        {
            goto BadData;
        }
    }

    LOCK_WRITE_RR_LIST(pNode);
    RR_ListVerify( pNode );

    //
    //  clear cached data
    //

    deleteCachedRecordsForUpdate(pNode);

    //
    //  if not zone root, just hack out and replace
    //  or if replacement has valid SOA and NS
    //      => hack out and replace, then can still
    //
    //  Note: with DCR 37323 (conditional disable of auto creation of
    //  local NS records) it is possible to get into a situation
    //  where the zone has no NS RRs. This is currently only possible
    //  for DS integrated zones. Example: the admin sets the set of
    //  servers allowed to create local NS records to contain only
    //  IP addresses that aren't DNS servers with a DS integrated
    //  copy of this zone. In that case, the zone would have no NS
    //  records on any server.
    //

    if ( !bzoneRoot ||
         ( pNewList && bSoa &&
            ( bNs || IS_ZONE_DSINTEGRATED( pZone ) ) ) ||
         ( bzoneRoot && !pZone ) )
    {
        pdelete = pNode->pRRList;
        pNode->pRRList = pNewList;
    }

    //
    //  delete all non-SOA, non-NS records
    //

    else
    {
        ASSERT( FALSE );
        UNLOCK_WRITE_RR_LIST(pNode);
        goto BadData;

#if 0
        //  DEVNOTE: interesting robustness fix
        //      - merge in missing SOA, NS

        //  DEVNOTE: generic list operators not in context of node
        //      - remove type
        //      - remove types?  (use mask technology???)
        //      - stick record in correct place
        //      - replace records of type (for dynamic update NS)

        PDB_RECORD      psaveLast;

        psaveLast = START_RR_TRAVERSE(pNode);
        pcurrent = psaveLast;

        while ( pcurrent = pcurrent->pRRNext )
        {
            ASSERT( IS_DNS_HEAP_DWORD(pcurrent) );

            typeCurrent = pcurrent->wType;

            if ( typeCurrent == DNS_TYPE_SOA
                || typeCurrent == DNS_TYPE_NS )
            {
                psaveLast->pRRNext = pcurrent;
                psaveLast = pcurrent;
                continue;
            }

            if ( !pdelete )
            {
                pdelete = pcurrent;
            }
            else
            {
                pdeleteLast->pRRNext = pcurrent;
            }
            pdeleteLast = pcurrent;
        }

        //  make sure delete list and saved list NULL terminated

        if ( pdelete )
        {
            pdeleteLast->pRRNext = NULL;
            psaveLast->pRRNext = NULL;
        }

        //  add new records into list
#endif
    }

    //  reset node's flags

    RR_ListResetNodeFlags( pNode );

    UNLOCK_WRITE_RR_LIST(pNode);

    //  return list cut from node

    *ppDelete = pdelete;

    DNS_DEBUG( UPDATE, (
        "Leaving RR_ListReplace()\n"
        "\tpnode = %p (%s)\n"
        "\tstatus = %p\n",
        pNode,
        pNode->szLabel,
        ERROR_SUCCESS ));

    return( ERROR_SUCCESS );


BadData:

    //
    //  if "hard" update (DS poll or IXFR)
    //  then we need to do our best to make this work
    //

    DNS_DEBUG( ANY, (
        "ERROR:  bogus replace update!\n"
        "\tpnode        = %p (%s)\n"
        "\ttemp node    = %d\n",
        pNode,
        pNode->szLabel,
        IS_TNODE(pNode) ));

    if ( IS_TNODE(pNode) )
    {
        return( ERROR_INVALID_DATA );
    }

    DNS_DEBUG( ANY, (
        "ERROR:  bogus replace update on real node!\n"
        "\tpnode    = %p (%s)\n"
        "\tbNs      = %d\n"
        "\tbSoa     = %d\n"
        "\tbCname   = %d\n"
        "\tzoneRoot = %d\n",
        pNode,
        pNode->szLabel,
        bNs,
        bSoa,
        bCname,
        bzoneRoot ));
    ASSERT( FALSE );

    //
    //  DEVNOTE: should fix up
    //
    //  temp hack, just leave old list and dump new
    //
    //  make update a no-op so it will be eliminated from
    //      calling list
    //

    if ( pUpdate )
    {
        RR_ListFree( pNewList );
        pUpdate->pAddRR = NULL;
        pUpdate->pDeleteRR = NULL;
    }
    *ppDelete = NULL;

    return( ERROR_INVALID_DATA );
}



PDB_RECORD
RR_ListInsertInOrder(
    IN OUT  PDB_RECORD      pFirstRR,
    IN      PDB_RECORD      pNewRR
    )
/*++

Routine Description:

    Insert record in record list -- in type order.

Arguments:

    pFirstRR -- ptr to head of list to insert into

    pNewRR -- ptr to RR to insert in list

Return Value:

    New head of list -- either pFirstRR, or pNewRR if lowest type record.

--*/
{
    PDB_RECORD  prr;
    PDB_RECORD  prev;
    WORD        type;

    type = pNewRR->wType;

    prr = pFirstRR;
    prev = NULL;

    while ( prr )
    {
        if ( prr->wType > type )
        {
            break;
        }
        prev = prr;
        prr = NEXT_RR(prr);
    }

    //  found location
    //      prr -- record to immediately follow pNewRR (maybe NULL)
    //      prev -- record before pNewRR;  if NULL then pNewRR should
    //          be new front of list

    NEXT_RR(pNewRR) = prr;
    if ( prev )
    {
        NEXT_RR(prev) = pNewRR;
        return( pFirstRR );
    }
    else
    {
        return( pNewRR );
    }
}



PDB_RECORD
RR_ListForNodeCopy(
    IN      PDB_NODE        pNode,
    IN      DWORD           Flag
    )
/*++

Routine Description:

    Copy record list of node.

Arguments:

    pNode - ptr to node to find record at

    Flag  - flags on copy
                RRCOPY_EXCLUDE_CACHE_DATA   - exclude cached data

Return Value:

    Ptr to RR if found.
    NULL if no more RR of desired type.

--*/
{
    PDB_RECORD  prr;

    LOCK_WRITE_RR_LIST(pNode);

    //
    //  cached name error node
    //

    if ( IS_NOEXIST_NODE(pNode) )
    {
        prr = NULL;
    }
    else
    {
        prr = RR_ListCopy( pNode->pRRList, Flag );
    }

    UNLOCK_WRITE_RR_LIST(pNode);
    return( prr );
}



PDB_RECORD
RR_ListCopy(
    IN      PDB_RECORD      pRR,
    IN      DWORD           Flag
    )
/*++

Routine Description:

    Copy record list.

Arguments:

    pRR     - start of record list to copy

    Flag    - flags on copy
        RRCOPY_EXCLUDE_CACHE_DATA   - exclude cached data

Return Value:

    Ptr to RR list copy.

--*/
{
    PDB_RECORD  pnew;
    DNS_LIST    newRecordList;

    DNS_LIST_INIT( &newRecordList );

    //
    //  traverse list, copying each record
    //      - exclude cache records (if desired)
    //

    while ( pRR )
    {
        if ( (Flag & RRCOPY_EXCLUDE_CACHED_DATA) && IS_CACHE_RR(pRR) )
        {
            pRR = NEXT_RR(pRR);
            continue;
        }

        pnew = RR_Copy( pRR, 0 );
        if ( !pnew )
        {
            ASSERT( FALSE );
            pRR = NEXT_RR(pRR);
            continue;
        }
        ASSERT( pnew->pRRNext == NULL );

        DNS_LIST_ADD( &newRecordList, pnew );
        pRR = NEXT_RR(pRR);
    }

    return( (PDB_RECORD)newRecordList.pFirst );
}



//
//  Record \ Record Set \ Record List comparisons
//

BOOL
FASTCALL
RR_Compare(
    IN      PDB_RECORD      pRR1,
    IN      PDB_RECORD      pRR2,
    IN      BOOL            fCheckTtl,
    IN      BOOL            fCheckTimestamp
    )
/*++

Routine Description:

    Compare two RRs

Arguments:

    pRR1    -- first RR to compare

    pRR2    -- second RR to compare

    fCheckTtl -- TRUE to include TTL in check, FALSE otherwise

    fCheckTimestamp -- TRUE to include Timestamp in check, FALSE otherwise

Return Value:

    TRUE if match
    FALSE if no match

--*/
{
    WORD    type;

    //
    //  check for duplicate record
    //      - same record type
    //      - same data length
    //      - byte compare of data
    //  if fCheckTtl
    //      - compare ttl
    //  if fCheckTimestamp
    //      - compare Timestamp
    //
    //  for perf, we do check on first DWORD of data first, this
    //  fails quickly for almost all non-duplicates
    //
    //  note the reason for the ordering is that when we turn on case
    //  preservation in RR name data, we'll have a situation where
    //  memcmp and first DWORD compare can fail ... yet, the 95% A record
    //  case can still be dispatched without calling memcmp()
    //

    if ( !pRR1 || !pRR2
            ||
        (type = pRR1->wType) != pRR2->wType
            ||
        pRR1->wDataLength != pRR2->wDataLength )
    {
        return( FALSE );
    }

    //
    //  optimize type A
    //

    if ( type == DNS_TYPE_A
            &&
        pRR1->Data.A.ipAddress != pRR2->Data.A.ipAddress )
    {
        return( FALSE );
    }

    //
    //  special checks
    //

    if ( fCheckTtl  &&  pRR1->dwTtlSeconds != pRR2->dwTtlSeconds )
    {
        return( FALSE );
    }
    if ( fCheckTimestamp  &&  pRR1->dwTimeStamp != pRR2->dwTimeStamp )
    {
        return( FALSE );
    }

    //
    //  optimize type A again -- we're done
    //      no need for memory compare
    //

    if ( type == DNS_TYPE_A )
    {
        return( TRUE );
    }

    //
    //  full data compare
    //
    //  DEVNOTE: case sensitivity will require additional comparison routines
    //      here for types with names in RR data
    //

    if ( RtlEqualMemory(
            & pRR1->Data,
            & pRR2->Data,
            pRR1->wDataLength ) )
    {
        return( TRUE );
    }

    return( FALSE );
}



DWORD
RR_ListCompare(
    IN      PDB_RECORD      pNodeRRList,
    IN      PDB_RECORD      pCheckRRList,
    //IN      PDB_RECORD      pNodeRRListStop,
    IN      BOOL            fCheckTtl,
    IN      BOOL            fCheckTimeStamp,
    IN      DWORD           dwRefreshTime           OPTIONAL
    )
/*++

Routine Description:

    Compare two RR lists.

Arguments:

    pNodeRRList -- RR list

    pCheckRRList -- another RR List

    fCheckTtl -- include TTL in record compare

    fCheckTimeStamp -- include time stamp in compare

    dwRefreshTime -- refresh time for zone, OPTIONAL

        If given then node's records (pNodeRRList) checked if refresh required.
        Note that this option makes pNodeRRList and pCheckRRList non-symmetric.
        It's purpose is to determine when aging refresh requires a DS write.

        Refresh is required when
            A) one of pNodeRRList's records has aging on and requires a refresh
            B) aging ON on pNodeRRList record, but OFF on check
            C) aging OFF on pNodeRRList record, but ON on check

        Note, the three cases are broken out purely for statistics tracking
        when actually doing DS write.  (Breaking them out is cheap.)

Return Value:

    RRLIST_MATCH            -- matches completely
    RRLIST_AGING_REFRESH    -- matches, but aging requires refresh
    RRLIST_AGING_OFF        -- matches, but aging turning off on a record
    RRLIST_AGING_ON         -- matches, but aging turning on on a record
    RRLIST_NO_MATCH         -- no match, record is different

--*/
{
    DWORD           result = RRLIST_MATCH;
    PDB_RECORD      prr1;
    PDB_RECORD      prr2;
    DWORD           count1 = 0;
    DWORD           count2 = 0;
    BOOL            ffound;

    //
    //  verify existing RR counts are equal
    //

    prr1 = pNodeRRList;
    while ( prr1 )
    {
        count1++;
        prr1 = NEXT_RR(prr1);
    }

    prr2 = pCheckRRList;
    while ( prr2 )
    {
        count2++;
        CLEAR_MATCH_RR(prr2);
        prr2 = NEXT_RR(prr2);
    }

    if ( count1 != count2 )
    {
        DNS_DEBUG( UPDATE, (
            "RR_ListCompare() failed, list1 and list2 have different lengths (%d,%d).\n",
            count1,
            count2 ));
        return( RRLIST_NO_MATCH );
    }

    //
    //  verify RRs compare
    //  as we match RR from list 1, mark RR in list2 so it can not be used twice
    //      this is faster, and prevents false positive when list1 is actually
    //      a subset of list2 with duplicates making it the same length
    //

    for ( prr1 = pNodeRRList;
          prr1 != NULL;
          prr1 = NEXT_RR(prr1) )
    {
        ffound = FALSE;

        prr2 = pCheckRRList;
        while ( prr2 )
        {
            if ( IS_MATCH_RR(prr2) ||
                ! RR_Compare(prr1, prr2, fCheckTtl, fCheckTimeStamp) )
            {
                prr2 = NEXT_RR(prr2);
                continue;
            }

            ffound = TRUE;
            SET_MATCH_RR( prr2 );
            break;
        }

        if ( !ffound )
        {
            DNS_DEBUG( UPDATE, (
                "RR_ListCompare() failed, pRR %p in list 1 unmatched.\n",
                prr1 ));
            return( RRLIST_NO_MATCH );
        }

        //  no refresh action -- continue

        if ( dwRefreshTime == 0 )
        {
            continue;
        }

        //
        //  force refresh
        //      (-1) as refresh indicates FORCE refresh on records
        //

        if ( dwRefreshTime == FORCE_REFRESH_DUMMY_TIME )
        {
            if ( prr1->dwTimeStamp != 0 )
            {
                prr1->dwTimeStamp = g_CurrentTimeHours;
            }
        }

        //
        //  check refresh only if requested
        //  two cases
        //
        //  1) RR is aging
        //      => refresh if past refresh time
        //      => refresh if check RR has aging OFF
        //
        //  2) RR is not aging (RefreshTime is zero)
        //      => only need refresh if check RR has aging ON
        //
        //  note, we save the "highest ranking" refresh result
        //  rank is
        //      MATCH
        //      REFRESH
        //      AGING_ON
        //      AGING_OFF
        //      NO_MATCH
        //  the idea here if that caller may choose to react differently
        //  to different kinds of matching "failures"
        //
        //  currently, non-scavenging DS zones will not write simple
        //  refreshes, but will write aging being explicitly turned OFF
        //

        else if ( prr1->dwTimeStamp != prr2->dwTimeStamp )
        {
            DWORD   refreshResult = RRLIST_MATCH;

            if ( prr1->dwTimeStamp != 0 )
            {
                if ( prr2->dwTimeStamp == 0 )
                {
                    refreshResult = RRLIST_AGING_OFF;
                }
                else if ( prr1->dwTimeStamp < dwRefreshTime )
                {
                    refreshResult = RRLIST_AGING_REFRESH;
                }
            }
            else if ( prr2->dwTimeStamp != 0 )
            {
                refreshResult = RRLIST_AGING_ON;
            }

            if ( refreshResult > result )
            {
                result = refreshResult;
            }
        }
    }

    //  verify every record in check list was matched

    prr2 = pCheckRRList;
    while ( prr2 )
    {
        if ( IS_MATCH_RR(prr2) )
        {
            CLEAR_MATCH_RR(prr2);
            prr2 = NEXT_RR(prr2);
            continue;
        }

        DNS_DEBUG( UPDATE, (
            "RR_ListCompare() failed, pRR %p in list 2 unmatched.\n"
            "\tlist1 was subset of list2\n",
            prr2 ));

        return( RRLIST_NO_MATCH );
    }

    return( result );
}



BOOL
RR_IsRecordInRRList(
    IN      PDB_RECORD      pRRList,
    IN      PDB_RECORD      pRR,
    IN      BOOL            fCheckTtl,
    IN      BOOL            fCheckTimestamp
    )
/*++

Routine Description:

    Compare two RRs

Arguments:

    pRRList -- RR list to find record in;  if active list, must be locked

    pRR     -- record to find in list

    fCheckTtl -- TRUE to include TTL in check, FALSE otherwise

    fCheckTimestamp -- TRUE to include aging Timestamp in check, FALSE otherwise

Return Value:

    TRUE if pRR is in list
    FALSE if no match

--*/
{
    PDB_RECORD      pcheckRR;
    WORD            type;
    BOOL            bresult = FALSE;

    //
    //  check all records in list
    //      - if pRR found => TRUE
    //      - otherwise => FALSE
    //

    type = pRR->wType;

    for ( pcheckRR = pRRList;
          pcheckRR != NULL;
          pcheckRR = NEXT_RR(pcheckRR) )
    {
        if ( pcheckRR->wType == type )
        {
            bresult = RR_Compare(
                        pRR,
                        pcheckRR,
                        fCheckTtl,
                        fCheckTimestamp
                        );
            if ( bresult )
            {
                break;
            }
            continue;
        }
        if ( pcheckRR->wType < type )
        {
            continue;
        }
        break;
    }

    DNS_DEBUG( UPDATE, (
        "RR_IsRecordInList() returns %d\n",
        bresult ));

    return( bresult );
}



PDB_RECORD
FASTCALL
RR_RemoveRecordFromRRList(
    IN OUT  PDB_RECORD *    ppRRList,
    IN      PDB_RECORD      pRR,
    IN      BOOL            fCheckTtl,
    IN      BOOL            fCheckTimestamp
    )
/*++

Routine Description:

    Removes the matching RR from the list and returns a ptr to it. The caller
    is responsible for freeing or otherwise dealing with the RR.

Arguments:

    pRRList -- RR list to find record in;  if active list, must be locked

    pRR     -- record to find in list

    fCheckTtl -- TRUE to include TTL in check, FALSE otherwise

    fCheckTimestamp -- TRUE to include aging Timestamp in check, FALSE otherwise

Return Value:

    Pointer to matching record (which has been removed from list) or
    NULL if no match.

--*/
{
    PDB_RECORD      pMatchRR = NULL;
    PDB_RECORD      pCheckRR;
    PDB_RECORD      pPrevRR = NULL;
    WORD            type = pRR->wType;

    for ( pCheckRR = *ppRRList;
          pCheckRR != NULL;
          pPrevRR = pCheckRR, pCheckRR = NEXT_RR( pCheckRR ) )
    {
        if ( pCheckRR->wType == type )
        {
            if ( RR_Compare(
                    pRR,
                    pCheckRR,
                    fCheckTtl,
                    fCheckTimestamp ) )
            {
                //  Found it! Remove it from the list.

                pMatchRR = pCheckRR;
                if ( pPrevRR )
                {
                    pPrevRR->pRRNext = pMatchRR->pRRNext;   //  not head element
                }
                else
                {
                    *ppRRList = pMatchRR->pRRNext;      //  removing list head
                }
                pMatchRR->pRRNext = NULL;
                break;
            }
            continue;
        }
        if ( pCheckRR->wType < type )
        {
            continue;
        }
        break;
    }

    DNS_DEBUG( UPDATE, (
        "RR_RemoveRecordFromRRList() returns %p\n",
        pMatchRR ));
    return pMatchRR;
}   //  RR_RemoveRecordFromRRList



//
//  Record \ Record List free routines
//

DWORD
RR_ListFree(
    IN OUT  PDB_RECORD      pRRList
    )
/*++

Routine Description:

    Free records in RR list.
    Records are unassociated with any node.

Arguments:

    pRRList -- ptr to first record in list to free

Return Value:

    Count of records freed.

--*/
{
    register    PDB_RECORD  prr = pRRList;
    register    PDB_RECORD  pnextRR;
    DWORD       count = 0;

    while ( prr )
    {
        count++;

        pnextRR = prr->pRRNext;
        RR_Free( prr );
        prr = pnextRR;
    }

    return( count );
}

//
//  End rrlist.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\rrfunc.h ===
/*++

Copyright(c) 1996-1999 Microsoft Corporation

Module Name:

    rrfunc.h

Abstract:

    Domain Name System (DNS) Server

    Resource record function headers.

    Used separate file as record.h contains record type definition
    required by other headers and loaded early.  These prototypes
    may contain other types and hence should be defined later.

Author:

    Jim Gilroy      Decemeber 1996

Revision History:

--*/


#ifndef _RRFUNC_INCLUDED_
#define _RRFUNC_INCLUDED_


//
//  Record type specific helper utilities
//

DNS_STATUS
WksBuildRecord(
    OUT     PDB_RECORD *    ppRR,
    IN      IP_ADDRESS      ipAddress,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    );



//
//  Read records from file (rrload.c)
//

DNS_STATUS
AFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
NsFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
PtrFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
SoaFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
MxFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
MinfoFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
TxtFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
WksFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
AaaaFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
SrvFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
WinsFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
NbstatFileRead(
    IN OUT  PDB_RECORD      pRR,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    );



//
//  Read records from wire (rrwire.c)
//

PDB_RECORD
AWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    );

PDB_RECORD
CopyWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    );

PDB_RECORD
PtrWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    );

PDB_RECORD
MxWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    );

PDB_RECORD
SoaWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    );

PDB_RECORD
MinfoWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    );

PDB_RECORD
SrvWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    );

PDB_RECORD
WinsWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    );

PDB_RECORD
NbstatWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    );




//
//  Read records from RPC buffer (rradmin.c)
//

DNS_STATUS
ARpcRead(
    IN OUT  PDB_RECORD      pRR,
    IN      PDNS_RPC_RECORD pRecord,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
NsRpcRead(
    IN OUT  PDB_RECORD      pRR,
    IN      PDNS_RPC_RECORD pRecord,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
PtrRpcRead(
    IN OUT  PDB_RECORD      pRR,
    IN      PDNS_RPC_RECORD pRecord,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
SoaRpcRead(
    IN OUT  PDB_RECORD      pRR,
    IN      PDNS_RPC_RECORD pRecord,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
MxRpcRead(
    IN OUT  PDB_RECORD      pRR,
    IN      PDNS_RPC_RECORD pRecord,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
MinfoRpcRead(
    IN OUT  PDB_RECORD      pRR,
    IN      PDNS_RPC_RECORD pRecord,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
TxtRpcRead(
    IN OUT  PDB_RECORD      pRR,
    IN      PDNS_RPC_RECORD pRecord,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
WksRpcRead(
    IN OUT  PDB_RECORD      pRR,
    IN      PDNS_RPC_RECORD pRecord,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
AaaaRpcRead(
    IN OUT  PDB_RECORD      pRR,
    IN      PDNS_RPC_RECORD pRecord,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
SrvRpcRead(
    IN OUT  PDB_RECORD      pRR,
    IN      PDNS_RPC_RECORD pRecord,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
WinsRpcRead(
    IN OUT  PDB_RECORD      pRR,
    IN      PDNS_RPC_RECORD pRecord,
    IN OUT  PPARSE_INFO     pParseInfo
    );

DNS_STATUS
NbstatRpcRead(
    IN OUT  PDB_RECORD      pRR,
    IN      PDNS_RPC_RECORD pRecord,
    IN OUT  PPARSE_INFO     pParseInfo
    );



#endif // _RRFUNC_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\rrpacket.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    rrpacket.c

Abstract:

    Domain Name System (DNS) Server

    Routines to _write resource records to packet.

Author:

    Jim Gilroy (jamesg)     March, 1995

Revision History:

    jamesg  Jul 1995    --  Move these routines to this file
                        --  Round robining RRs
    jamesg  May 1997    --  Covert to dispatch table

--*/


#include "dnssrv.h"

//
//  MAX IPs that we'll handle, by default, when writing.
//
//  If need more than this need to realloc.
//

#define DEFAULT_MAX_IP_WRITE_COUNT  (1000)



VOID
prioritizeIpAddressArray(
    IN OUT  IP_ADDRESS      IpArray[],
    IN      DWORD           dwCount,
    IN      IP_ADDRESS      RemoteIp
    );



//
//  Write-to-wire routines for specific types
//

PCHAR
AWireWrite(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write A record wire format into database record.

Arguments:

    pMsg - message being read

    pchData - ptr to RR data field

    pRR - ptr to database record

Return Value:

    Ptr to next byte in packet after RR written.
    NULL on error.

--*/
{
    * (UNALIGNED DWORD *)pchData = pRR->Data.A.ipAddress;
    pchData += SIZEOF_IP_ADDRESS;

    //  clear WINS lookup flag when A record written

    pMsg->fWins = FALSE;
    return( pchData );
}



PCHAR
CopyWireWrite(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write to wire all types for which the database format is
    identical to the wire format (no indirection).

    Types included:
        HINFO
        ISDN
        X25
        WKS
        TXT
        NULL
        AAAA
        KEY

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

Return Value:

    Ptr to next byte in packet after RR written.
    NULL on error.

--*/
{
    //  all these RR types, have no indirection
    //  bytes stored exactly as bits on the wire

    if ( pMsg->pBufferEnd - pchData < pRR->wDataLength )
    {
        DNS_DEBUG( WRITE, (
            "Truncation on wire write of flat record %p\n"
            "\tpacket buf end = %p\n"
            "\tpacket RR data = %p\n"
            "\tRR datalength  = %d\n",
            pRR,
            pMsg->pBufferEnd,
            pchData,
            pRR->wDataLength ));
        return( NULL );
    }
    RtlCopyMemory(
        pchData,
        &pRR->Data.TXT,
        pRR->wDataLength
        );
    pchData += pRR->wDataLength;
    return( pchData );
}



PCHAR
NsWireWrite(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write NS record to wire.

    Handles all single indirection types that require additional
    data processing:
        NS, CNAME, MB, MD, MF

    CNAME does NOT write have additional section processing during
    CNAME query, but uses additional info to store next node in CNAME
    trail.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

Return Value:

    Ptr to next byte in packet after RR written.
    NULL on error.

--*/
{
    PCHAR   pchname;

    //  write target name to packet

    pchname = pchData;
    pchData = Name_WriteDbaseNameToPacket(
                pMsg,
                pchData,
                & pRR->Data.PTR.nameTarget );

    //
    //  save additional data
    //      - except for explicit CNAME query
    //

    if ( pMsg->fDoAdditional  &&
        ( pRR->wType != DNS_TYPE_CNAME || pMsg->wQuestionType != DNS_TYPE_CNAME ) )
    {
        Wire_SaveAdditionalInfo(
            pMsg,
            pchname,
            & pRR->Data.PTR.nameTarget,
            DNS_TYPE_A );
    }
    return( pchData );
}



PCHAR
PtrWireWrite(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write PTR compatible record to wire.

    Handles all single indirection records which DO NOT
    cause additional section processing.

    Includes: PTR, MR, MG

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

Return Value:

    Ptr to next byte in packet after RR written.
    NULL on error.

--*/
{
    pchData = Name_WriteDbaseNameToPacket(
                pMsg,
                pchData,
                & pRR->Data.PTR.nameTarget );

    return( pchData );
}



PCHAR
MxWireWrite(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write MX compatible record to wire.
    Includes: MX, RT, AFSDB

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

Return Value:

    Ptr to next byte in packet after RR written.
    NULL on error.

--*/
{
    PCHAR   pchname;

    //
    //  MX preference value
    //  RT preference
    //  AFSDB subtype
    //
    //  - extra space in buffer so need not test adding preference
    //      value

    * (UNALIGNED WORD *) pchData = pRR->Data.MX.wPreference;
    pchData += sizeof( WORD );

    //
    //  MX exchange
    //  RT exchange
    //  AFSDB hostname
    //

    pchname = pchData;
    pchData = Name_WriteDbaseNameToPacket(
                pMsg,
                pchData,
                & pRR->Data.MX.nameExchange );

    //
    //  DEVNOTE: RT supposed to additional ISDN and X25 also
    //

    if ( pMsg->fDoAdditional )
    {
        Wire_SaveAdditionalInfo(
            pMsg,
            pchname,
            & pRR->Data.MX.nameExchange,
            DNS_TYPE_A );
    }
    return( pchData );
}



PCHAR
SoaWireWrite(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write SOA record to wire.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

Return Value:

    Ptr to next byte in packet after RR written.
    NULL on error.

--*/
{
    PDB_NAME    pname;
    PCHAR       pchname;

    //  SOA primary name server

    pname = &pRR->Data.SOA.namePrimaryServer;
    pchname = pchData;

    pchData = Name_WriteDbaseNameToPacket(
                pMsg,
                pchData,
                pname );
    if ( !pchData )
    {
        return( NULL );
    }

    //  SOA zone admin

    pname = Name_SkipDbaseName( pname );

    pchData = Name_WriteDbaseNameToPacket(
                pMsg,
                pchData,
                pname );
    if ( !pchData )
    {
        return( NULL );
    }

    //
    //  copy SOA fixed fields
    //      - dwSerialNo
    //      - dwRefresh
    //      - dwRetry
    //      - dwExpire
    //      - dwMinimumTtl

    RtlCopyMemory(
        pchData,
        & pRR->Data.SOA.dwSerialNo,
        SIZEOF_SOA_FIXED_DATA );

    pchData += SIZEOF_SOA_FIXED_DATA;

    //
    //  additional processing, ONLY when writing direct response for SOA
    //      - not when written to authoritity section
    //
    //  DEVNOTE: should we figure this out here?
    //

    if ( pMsg->fDoAdditional &&
        pMsg->wQuestionType == DNS_TYPE_SOA )
    {
        Wire_SaveAdditionalInfo(
            pMsg,
            pchname,
            & pRR->Data.SOA.namePrimaryServer,
            DNS_TYPE_A );
    }
    return( pchData );
}



PCHAR
MinfoWireWrite(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write MINFO and RP records to wire.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

Return Value:

    Ptr to next byte in packet after RR written.
    NULL on error.

--*/
{
    PDB_NAME    pname;

    //  MINFO responsible mailbox
    //  RP responsible person mailbox

    pname = &pRR->Data.MINFO.nameMailbox;

    pchData = Name_WriteDbaseNameToPacket(
                pMsg,
                pchData,
                pname );
    if ( !pchData )
    {
        return( NULL );
    }

    //  MINFO errors to mailbox
    //  RP text RR location

    pname = Name_SkipDbaseName( pname );

    return  Name_WriteDbaseNameToPacket(
                pMsg,
                pchData,
                pname );
}



PCHAR
SrvWireWrite(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write SRV record to wire.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

Return Value:

    Ptr to next byte in packet after RR written.
    NULL on error.

--*/
{
    PDB_NAME    pname;
    PCHAR       pchname;

    //
    //  SRV <priority> <weight> <port> <target host>
    //

    * (UNALIGNED WORD *) pchData = pRR->Data.SRV.wPriority;
    pchData += sizeof( WORD );
    * (UNALIGNED WORD *) pchData = pRR->Data.SRV.wWeight;
    pchData += sizeof( WORD );
    * (UNALIGNED WORD *) pchData = pRR->Data.SRV.wPort;
    pchData += sizeof( WORD );

    //
    //  write target host
    //  - save for additional section
    //  - except when target is root node to give no-service-exists response
    //

    pname = & pRR->Data.SRV.nameTarget;

    if ( IS_ROOT_NAME(pname) )
    {
        *pchData++ = 0;
    }
    else
    {
        pchname = pchData;
        pchData = Name_WriteDbaseNameToPacketEx(
                    pMsg,
                    pchData,
                    pname,
                    FALSE       // no compression
                    );
        if ( pMsg->fDoAdditional )
        {
            Wire_SaveAdditionalInfo(
                pMsg,
                pchname,
                pname,
                DNS_TYPE_A );
        }
    }
    return( pchData );
}



PCHAR
NbstatWireWrite(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write WINS-R record to wire.

Arguments:

    pMsg - message being read

    pchData - ptr to RR data field

    pRR - ptr to database record

Return Value:

    Ptr to next byte in packet after RR written.
    NULL on error.

--*/
{
    ASSERT( pRR->wDataLength >= MIN_NBSTAT_SIZE );

    //
    //  NBSTAT fixed fields
    //      - flags
    //      - lookup timeout
    //      - cache timeout
    //  note these are stored in HOST order for easy use
    //

    * (UNALIGNED DWORD *) pchData = htonl( pRR->Data.WINSR.dwMappingFlag );
    pchData += sizeof( DWORD );
    * (UNALIGNED DWORD *) pchData = htonl( pRR->Data.WINSR.dwLookupTimeout );
    pchData += sizeof( DWORD );
    * (UNALIGNED DWORD *) pchData = htonl( pRR->Data.WINSR.dwCacheTimeout );
    pchData += sizeof( DWORD );

    //  NBSTAT domain

    pchData = Name_WriteDbaseNameToPacketEx(
                pMsg,
                pchData,
                & pRR->Data.WINSR.nameResultDomain,
                FALSE       // no compression
                );
    return( pchData );
}



PCHAR
WinsWireWrite(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write WINS-R record to wire.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

Return Value:

    Ptr to next byte in packet after RR written.
    NULL on error.

--*/
{
    DWORD   lengthServerArray;

    ASSERT( pRR->wDataLength >= MIN_WINS_SIZE );

    //
    //  WINS fixed fields
    //      - flags
    //      - lookup timeout
    //      - cache timeout
    //      - server count
    //  note these are stored in HOST order for easy use
    //

    * (UNALIGNED DWORD *) pchData = htonl( pRR->Data.WINS.dwMappingFlag );
    pchData += sizeof( DWORD );
    * (UNALIGNED DWORD *) pchData = htonl( pRR->Data.WINS.dwLookupTimeout );
    pchData += sizeof( DWORD );
    * (UNALIGNED DWORD *) pchData = htonl( pRR->Data.WINS.dwCacheTimeout );
    pchData += sizeof( DWORD );
    * (UNALIGNED DWORD *) pchData = htonl( pRR->Data.WINS.cWinsServerCount );
    pchData += sizeof( DWORD );

    //
    //  WINS server addresses are already in network order, just copy
    //

    lengthServerArray = pRR->wDataLength - SIZEOF_WINS_FIXED_DATA;

    ASSERT( lengthServerArray ==
            pRR->Data.WINS.cWinsServerCount * sizeof(IP_ADDRESS) );

    RtlCopyMemory(
        pchData,
        pRR->Data.WINS.aipWinsServers,
        lengthServerArray
        );
    pchData += lengthServerArray;
    return( pchData );
}



PCHAR
OptWireWrite(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write OPT resource record to wire.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

Return Value:

    Ptr to next byte in packet after RR written.
    NULL on error.

--*/
{
    return( pchData );
} // OptWireWrite



PCHAR
SigWireWrite(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write SIG resource record to wire - DNSSEC RFC 2535

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

Return Value:

    Ptr to next byte in packet after RR written.
    NULL on error.

--*/
{
    int     sigLength;

    //
    //  Copy fixed fields.
    //

    if ( pMsg->pBufferEnd - pchData < SIZEOF_SIG_FIXED_DATA )
    {
        return NULL;
    }

    RtlCopyMemory(
        pchData,
        &pRR->Data.SIG,
        SIZEOF_SIG_FIXED_DATA
        );
    pchData += SIZEOF_SIG_FIXED_DATA;

    //
    //  Write signer's name.
    //

    pchData = Name_WriteDbaseNameToPacket(
                pMsg,
                pchData,
                &pRR->Data.SIG.nameSigner );
    if ( !pchData )
    {
        goto Cleanup;
    }

    //
    //  Write binary signature blob.
    //

    sigLength = pRR->wDataLength -
                SIZEOF_SIG_FIXED_DATA -
                DBASE_NAME_SIZE( &pRR->Data.SIG.nameSigner );
    if ( pMsg->pBufferEnd - pchData < sigLength )
    {
        return NULL;
    }

    RtlCopyMemory(
        pchData,
        ( PBYTE ) &pRR->Data.SIG.nameSigner +
            DBASE_NAME_SIZE( &pRR->Data.SIG.nameSigner ),
        sigLength );
    pchData += sigLength;

    Cleanup:

    return pchData;
} // SigWireWrite



PCHAR
NxtWireWrite(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      PDB_RECORD      pRR
    )
/*++

Routine Description:

    Write NXT resource record to wire - DNSSEC RFC 2535

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

Return Value:

    Ptr to next byte in packet after RR written.
    NULL on error.

--*/
{
    //
    //  Write next name.
    //

    pchData = Name_WriteDbaseNameToPacket(
                pMsg,
                pchData,
                &pRR->Data.NXT.nameNext );
    if ( !pchData )
    {
        goto Cleanup;
    }

    //
    //  Write type bit map. For simplicity we will write the
    //  entire 16 bytes, but we could write less if there are
    //  zeros in the high bits.
    //

    if ( pMsg->pBufferEnd - pchData < DNS_MAX_TYPE_BITMAP_LENGTH )
    {
        return NULL;
    }

    RtlCopyMemory(
        pchData,
        pRR->Data.NXT.bTypeBitMap,
        DNS_MAX_TYPE_BITMAP_LENGTH );
    pchData += DNS_MAX_TYPE_BITMAP_LENGTH;

    Cleanup:

    return pchData;
} // NxtWireWrite



//
//  Write RR to wire functions
//

RR_WIRE_WRITE_FUNCTION   RRWireWriteTable[] =
{
    CopyWireWrite,      //  ZERO -- default for unspecified types

    AWireWrite,         //  A
    NsWireWrite,        //  NS
    NsWireWrite,        //  MD
    NsWireWrite,        //  MF
    NsWireWrite,        //  CNAME
    SoaWireWrite,       //  SOA
    NsWireWrite,        //  MB
    PtrWireWrite,       //  MG
    PtrWireWrite,       //  MR
    CopyWireWrite,      //  NULL
    CopyWireWrite,      //  WKS
    PtrWireWrite,       //  PTR
    CopyWireWrite,      //  HINFO
    MinfoWireWrite,     //  MINFO
    MxWireWrite,        //  MX
    CopyWireWrite,      //  TXT
    MinfoWireWrite,     //  RP
    MxWireWrite,        //  AFSDB
    CopyWireWrite,      //  X25
    CopyWireWrite,      //  ISDN
    MxWireWrite,        //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    SigWireWrite,       //  SIG
    CopyWireWrite,      //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    CopyWireWrite,      //  AAAA
    NULL,               //  LOC
    NxtWireWrite,       //  NXT
    NULL,               //  31
    NULL,               //  32
    SrvWireWrite,       //  SRV
    CopyWireWrite,      //  ATMA
    NULL,               //  35
    NULL,               //  36
    NULL,               //  37
    NULL,               //  38
    NULL,               //  39
    NULL,               //  40
    OptWireWrite,       //  OPT
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //  note these follow, but require OFFSET_TO_WINS_RR subtraction
    //  from actual type value

    WinsWireWrite,       //  WINS
    NbstatWireWrite      //  WINS-R
};



//
//  General write to wire routines
//

BOOL
Wire_AddResourceRecordToMessage(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode,              OPTIONAL
    IN      WORD            wNameOffset,        OPTIONAL
    IN      PDB_RECORD      pRR,
    IN      DWORD           flags
    )
/*++

Routine Description:

    Add resource record to DNS packet in the transport format.

    Note:  MUST be holding RR list lock during this function call to
            insure that record remains valid during write.

Arguments:

    pchMsgInfo - Info for message to write to.

    pNode - The "owner" node of this resource record.

    wNameOffset - Offset to name to write instead of node name

    pRR - The RR information to include in answer.

    flags - Flags to modify write operation.

Return Value:

    TRUE if successful.
    FALSE if unable to write:
        timed out, cache file record, out of space in packet, etc

--*/
{
    register PCHAR          pch = pMsg->pCurrent;
    PCHAR                   pchstop = pMsg->pBufferEnd;
    PCHAR                   pchdata;
    PDNS_WIRE_RECORD        pwireRR;
    DWORD                   ttl;
    DWORD                   queryTime;
    WORD                    netType;
    RR_WIRE_WRITE_FUNCTION  pwriteFunction;
    INT                     bufferAdjustmentForOPT = 0;
    BOOL                    rc = TRUE;

    ASSERT( pRR != NULL );

#if DBG
    pchdata = NULL;
#endif

    DNS_DEBUG( WRITE2, (
        "Writing RR (t=%d) (r=%d) at %p to location %p.\n"
        "\tNode ptr = %p\n"
        "\twNameOffset = 0x%04hx\n"
        "\tAvailLength = %d\n",
        pRR->wType,
        RR_RANK(pRR),
        pRR,
        pch,
        pNode,
        wNameOffset,
        pchstop - pch ));

    //
    //  cache hint?
    //  cache hints from cache file are NEVER sent in response
    //

    if ( IS_ROOT_HINT_RR(pRR) )
    {
        rc = FALSE;
        goto Done;
    }

    //
    //  Need to reserve space in buffer for OPT?
    //

    if ( pMsg->Opt.fInsertOptInOutgoingMsg && pRR->wType != DNS_TYPE_OPT )
    {
        pMsg->pBufferEnd -= DNS_MINIMIMUM_OPT_RR_SIZE;
        bufferAdjustmentForOPT = DNS_MINIMIMUM_OPT_RR_SIZE;
        DNS_DEBUG( WRITE2, (
            "adjusted buffer end by %d bytes to reserve space for OPT\n",
            bufferAdjustmentForOPT ));
    }

    //
    //  writing from node name -- for zone transfer
    //

    if ( pNode )
    {
        pch = Name_PlaceNodeNameInPacket(
                pMsg,
                pch,
                pNode
                );
        if ( !pch )
        {
            goto Truncate;
        }
    }

    //
    //  write ONLY compressed name -- normal response case
    //
    //  DEVNOTE: cleanup when fixed (?)

    else
    {
#if DBG
        HARD_ASSERT( wNameOffset );
#else
        if ( !wNameOffset )
        {
            goto Truncate;
        }
#endif
        //  compression should always be BACK ptr

        ASSERT( OFFSET_FOR_COMPRESSED_NAME(wNameOffset) < DNSMSG_OFFSET(pMsg, pch) );

        INLINE_WRITE_FLIPPED_WORD( pch, COMPRESSED_NAME_FOR_OFFSET(wNameOffset) );
        pch += sizeof( WORD );
    }

    //
    //  fill RR structure
    //      - extra space for RR header in packet buffer so no need to test
    //      - set datalength once we're finished
    //

    pwireRR = (PDNS_WIRE_RECORD) pch;

    INLINE_WRITE_FLIPPED_WORD( &pwireRR->RecordType, pRR->wType );
    WRITE_UNALIGNED_WORD( &pwireRR->RecordClass, DNS_RCLASS_INTERNET );

    //
    //  TTL
    //      - cache data TTL is in form of timeout time
    //      - regular authoritative data TTL is STATIC TTL in net byte order
    //

    if ( IS_CACHE_RR(pRR) )
    {
        ttl = RR_PacketTtlForCachedRecord( pRR, pMsg->dwQueryTime );
        if ( ttl == (-1) )
        {
            rc = FALSE;
            goto Done;
        }
    }
    else
    {
        ttl = pRR->dwTtlSeconds;
    }
    WRITE_UNALIGNED_DWORD( &pwireRR->TimeToLive, ttl );

    //
    //  save ptr to RR data, so can calculate data length
    //

    pch = pchdata = (PCHAR)( pwireRR + 1 );

    //
    //  write RR data
    //

    pwriteFunction = (RR_WIRE_WRITE_FUNCTION)
                        RR_DispatchFunctionForType(
                            (RR_GENERIC_DISPATCH_FUNCTION *) RRWireWriteTable,
                            pRR->wType );
    if ( !pwriteFunction )
    {
        ASSERT( FALSE );
        goto Truncate;
    }
    pch = pwriteFunction(
                pMsg,
                pchdata,
                pRR );

    //
    //  verify within packet
    //
    //  pch is NULL, if name writing exceeds packet length
    //

    if ( pch==NULL  ||  pch > pchstop )
    {
        DNS_PRINT((
            "ERROR:  DnsWireWrite routine failure for record type %d.\n\n\n",
            pRR->wType ));
        goto Truncate;
    }

    //
    //  If necessary, add a KEY entry to the additional data.
    //
    //  We do not have the node name in DB form at this point so pass NULL.
    //

    if ( flags & DNSSEC_INCLUDE_KEY )
    {
        Wire_SaveAdditionalInfo(
            pMsg,
            DNSMSG_PTR_FOR_OFFSET( pMsg, wNameOffset ),
            NULL,   // no DB name available
            DNS_TYPE_KEY );
    }

    //
    //  write RR data length
    //

    //  ASSERT( pch > pchdata );  isn't it legal to have zero length RDATA???
    ASSERT( pch >= pchdata );
    INLINE_WRITE_FLIPPED_WORD( &pwireRR->DataLength, (WORD)(pch - pchdata) );

    //
    //  reset message info
    //

    pMsg->pCurrent = pch;

    DNS_DEBUG( WRITE2, (
        "Wrote RR at %p to msg info at %p.\n"
        "\tNew avail length = %d\n"
        "\tNew pCurrent = %p\n",
        pRR,
        pMsg,
        pMsg->pBufferEnd - pch,
        pch ));

Done:

    pMsg->pBufferEnd += bufferAdjustmentForOPT;
    return rc;

Truncate:

    pMsg->pBufferEnd += bufferAdjustmentForOPT;

    //
    //  Set truncation bit
    //
    //  Assume all failures sent here are length problems
    //
    //     only Name_PlaceNodeNameInPacket() has other
    //     source of error and this would be a corrupt database
    //

    pMsg->Head.Truncation = 1;

    DNS_DEBUG( WRITE, (
        "Failed to write RR at %p to msg at %p.\n"
        "\tpCurrent         = %p\n"
        "\tBuffer Length    = %d\n"
        "\tBuffer End       = %p\n"
        "\tpch Final        = %p\n"
        "\tpchdata          = %p\n",
        pRR,
        pMsg,
        pMsg->pCurrent,
        pMsg->BufferLength,
        pMsg->pBufferEnd,
        pch,
        pchdata ));

    return FALSE;
}



WORD
Wire_WriteRecordsAtNodeToMessage(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode,
    IN      WORD            wType,
    IN      WORD            wNameOffset     OPTIONAL,
    IN      DWORD           flags
    )
/*++

Routine Description:

    Write all matching RRs at node to packet.

    Also resets fWins flag in packet, if WINS lookup is indicated.

Arguments:

    pMsg - message to write to.

    pNode - node being looked up

    wType - type being looked up

    wNameOffset - offset to previous name in packet, to write as compressed
                    RR name, instead of writing node name

    flags - control specifics of records written

Return Value:

    Count of resource records written.

--*/
{
    PDB_RECORD  prr;
    PDB_RECORD  pprevRRWritten;
    WORD        countRR = 0;        // count of records written
    PDB_NODE    pnodeUseName;
    WORD        startOffset = 0;    // init for ppc compiler
    BOOL        fdelete = FALSE;    // timed out record found
    UCHAR       rank;
    UCHAR       foundRank = 0;
    DWORD       rrWriteFlags = flags & 0xF; // first nibble flags by default
    BOOL        fIncludeSig;
    BOOL        fIsCompoundQuery;
    BOOL        fIsMailbQuery;
    BOOL        fIncludeDnsSecInResponse;
    WORD        wDesiredSigType;
    WORD        wMaxSigScanType;

    PDB_RECORD  prrLastMatch = NULL;
    PDB_RECORD  prrBeforeMatch;

    //
    //  cached name error node
    //

    LOCK_RR_LIST(pNode);
    if ( IS_NOEXIST_NODE(pNode) )
    {
        UNLOCK_RR_LIST(pNode);
        return( 0 );
    }

#if DBG
    //  Verify handling CNAME issue properly

    TEST_ASSERT( !IS_CNAME_NODE(pNode) ||
                wType == DNS_TYPE_CNAME ||
                wType == DNS_TYPE_ALL ||
                IS_ALLOWED_WITH_CNAME_TYPE(wType) );
#endif


    //
    //  type ALL
    //      - do NOT write records if non-authoritative and have NOT
    //          gotten recursive answer
    //      - allowing additional record processing
    //      - do allow WINS lookup,
    //          but disallow the case where looking up at CNAME
    //

    pMsg->fWins = FALSE;
    if ( wType == DNS_TYPE_ALL )
    {
        if ( !IS_AUTH_NODE(pNode) && !pMsg->fQuestionCompleted )
        {
            UNLOCK_RR_LIST(pNode);
            return( 0 );
        }

        //  Note:  can't find explicit RFC reference for avoiding Additional
        //      on type ALL queries;  and Malaysian registrar apparently uses
        //      type ALL instead of NS in verifying delegations
        //
        //pMsg->fDoAdditional = FALSE;

        pMsg->fWins = (BOOLEAN) (SrvCfg_fWinsInitialized && !IS_CNAME_NODE(pNode));
    }

    //
    //  determine RR owner name format
    //      => if compression, do not use node name
    //      => no compression,
    //          - use node name
    //          - save pCurrent to determine later compression

    if ( wNameOffset )
    {
        pnodeUseName = NULL;
    }
    else
    {
        pnodeUseName = pNode;
        startOffset = DNSMSG_OFFSET( pMsg, pMsg->pCurrent );
    }

    //
    //  According to RFC 2535 secions 4.1.8, SIGs are not to be included
    //  in ANY queries. Note: BIND apparently does not respect this.
    //

    if ( wType == DNS_TYPE_ALL )
    {
        rrWriteFlags &= ~DNSSEC_ALLOW_INCLUDE_SIG;
    }

    //
    //  RR prescan to determine if KEY RR is present at this name.
    //
    //  Set the KEY flag bit if and only if:
    //      1) there is a KEY at this name
    //      2) the type of query requires inclusions of KEYs as add data
    //      3) this query is doing additional data
    //
    //  DEVNOTE: there are priority rules for inclusion of KEYs which we are
    //  not yet implementing: see RFC 2535 section 3.5
    //
    //  DEVNOTE: we really should just have a flag on the node that says
    //  whether or not there is a key!
    //

    fIncludeDnsSecInResponse = DNSMSG_INCLUDE_DNSSEC_IN_RESPONSE( pMsg );

    if ( flags & DNSSEC_ALLOW_INCLUDE_KEY &&
        fIncludeDnsSecInResponse &&
        pMsg->fDoAdditional &&
        ( wType == DNS_TYPE_SOA || wType == DNS_TYPE_NS ||
          wType == DNS_TYPE_A || wType == DNS_TYPE_AAAA ) )
    {
        prr = START_RR_TRAVERSE(pNode);

        while ( prr = NEXT_RR(prr) )
        {
            if ( prr->wType == DNS_TYPE_KEY )
            {
                rrWriteFlags |= DNSSEC_INCLUDE_KEY;
                break;
            }
        }
    }

    //
    //  Set some locals to simplify/optimize decisions in the loop below.
    //

    #define DNS_BOGUS_SIG_TYPE  0xEFBE
    
    fIncludeSig = fIncludeDnsSecInResponse;
    wDesiredSigType = fIncludeSig ? htons( wType ) : DNS_BOGUS_SIG_TYPE;
    fIsMailbQuery = wType == DNS_TYPE_MAILB;
    fIsCompoundQuery = wType == DNS_TYPE_ALL || fIsMailbQuery || fIncludeSig;
    wMaxSigScanType =
        ( fIncludeSig && DNS_TYPE_SIG > wType ) ?
            DNS_TYPE_SIG : wType;

    //
    //  Loop through records at node, writing appropriate ones
    //

    pprevRRWritten = NULL;

    prr = START_RR_TRAVERSE( pNode );
    prrBeforeMatch = prr;

    while ( prr = NEXT_RR( prr ) )
    {
        BOOL        bAddedRRs;

        //  
        //  There are two tricky compound queries.
        //  1) MAILB - include all mailbox types (possibly obsolete).
        //  2) SIG - include appropriate SIG RR for non-compound queries.
        //
        //  First test: if the RR type equals the query type, include the RR.
        //

        if ( prr->wType != wType )
        {
            //
            //  For round robin we need ptr to the RR before the first match.
            //

            if ( prr->wType < wType )
            {
                prrBeforeMatch = prr;
            }

            //
            //  Loop termination test: terminate if we're past the query type 
            //  and we don't need to pick up any other RRs for a compound query.
            //  If we're not past the query type but this is not a compound
            //  query, we can skip this RR.
            //
        
            if ( !fIsCompoundQuery )
            {
                if ( prr->wType > wType )
                {
                    break;
                }
                continue;
            }
            
            if ( wType == DNS_TYPE_ALL )
            {
                //
                //  Conditionally exclude specific RR types from TYPE_ALL queries.
                //

                if ( prr->wType == DNS_TYPE_SIG && !fIncludeSig )
                {
                    continue;
                }
                //  Drop through and include this RR.
            }

            //
            //  If this is a MAILB query, skip non-mail RR types. If we're 
            //  past the final mailbox type we can terminate. NOTE: I'm not
            //  handling SIGs properly for MAILB queries. Unless someone
            //  complains it's not worth the extra work - MAILB is an
            //  experimental, obsolete type anyways. The problem is that
            //  currently we only need to include ONE supplementary SIG
            //  RR in the answer. To include more than one requires us to
            //  track a list of types
            //

            else if ( fIsMailbQuery )
            {
                if ( prr->wType > DNS_TYPE_MR )
                {
                    break;
                }
                if ( !DnsIsAMailboxType( prr->wType ) )
                {
                    continue;
                }
                //  Drop through and include this RR.
            }

            //
            //  If we're past both the SIG type and the query type we can quit.
            //  If this RR is a SIG of the wrong type, skip this RR. 
            //

            else 
            {
                if ( prr->wType > wMaxSigScanType )
                {
                    break;
                }
                if ( prr->wType != DNS_TYPE_SIG ||
                    prr->Data.SIG.wTypeCovered != wDesiredSigType )
                {
                    continue;
                }
                //  Drop through and include this RR.
            }
        }

        //
        //  This RR is a match and so may be included in the response.
        //
        //  if already have data, then do NOT use data of lower rank (eg. glue)
        //  CACHE_HINT data NEVER goes on to the wire
        //

        rank = RR_RANK( prr );
        if ( foundRank != rank )
        {
            if ( foundRank )
            {
                ASSERT( rank < foundRank );
                if ( countRR == 0 )
                {
                    prrBeforeMatch = prr;
                }
                continue;
            }
            if ( rank == RANK_ROOT_HINT )
            {
                if ( countRR == 0 )
                {
                    prrBeforeMatch = prr;
                }
                prrBeforeMatch = prr;
                continue;
            }
            foundRank = rank;
        }
        ASSERT( !IS_ROOT_HINT_RR(prr) );

        //
        //  skip all CACHED records when any are timed out
        //
        //  DEVNOTE: could combine with rank test
        //      foundRank == rank && IS_CACHE_RANK(rank) and fdelete
        //

        if ( fdelete && IS_CACHE_RR(prr) )
        {
            foundRank = 0;
            if ( countRR == 0 )
            {
                prrBeforeMatch = prr;
            }
            continue;
        }

        bAddedRRs = Wire_AddResourceRecordToMessage(
                        pMsg,
                        pnodeUseName,
                        wNameOffset,
                        prr,
                        rrWriteFlags );
        rrWriteFlags &= ~DNSSEC_INCLUDE_KEY; // Only call once with this flag

        if ( !bAddedRRs )
        {
            //
            //  When packet is full break out.
            //  DNSSEC special case: if there is not enough space to write
            //  out the SIG for an RRset in the additional section, we
            //  should quit but we should not set the truncation bit.
            //

            if ( pMsg->Head.Truncation == TRUE )
            {
                if ( IS_SET_TO_WRITE_ADDITIONAL_RECORDS( pMsg ) &&
                    prr->wType == DNS_TYPE_SIG )
                {
                    pMsg->Head.Truncation = FALSE;
                }
                break;
            }

            //  otherwise, we've hit timed out record
            //      - continue processing, but set flag to delete node

            fdelete = TRUE;
            foundRank = 0;
            continue;
        }

        //  wrote record
        //      - inc count
        //      - if first RR, setup to compress name of any following RR

        if ( prr->wType == wType )
        {
            prrLastMatch = prr;
        }
        countRR++;
        if ( ! wNameOffset )
        {
            pnodeUseName = NULL;
            wNameOffset = startOffset;
        }
    }

    //
    //  Round robin: juggle list
    //      - cut the first match from the list
    //      - first match's new next ptr is last match's current next ptr
    //      - last match's next ptr is first match
    //

    if ( !IS_COMPOUND_TYPE( wType ) &&
        countRR > 1 &&     //  can be >1 if additional RRs written!
        prrLastMatch &&
        prrBeforeMatch &&
        SrvCfg_fRoundRobin &&
        IS_ROUND_ROBIN_TYPE( wType ) &&
        NEXT_RR( prrBeforeMatch ) != prrLastMatch )
    {
        PDB_RECORD      prrFirstMatch = prrBeforeMatch->pRRNext;
        
        ASSERT( prrFirstMatch != NULL );

        prrBeforeMatch->pRRNext = prrFirstMatch->pRRNext;
        prrFirstMatch->pRRNext = prrLastMatch->pRRNext;
        prrLastMatch->pRRNext = prrFirstMatch;
    }

    //
    //  If found timed out record, cleanse list of timed out records
    //

    if ( fdelete )
    {
        RR_ListTimeout( pNode );
    }

    UNLOCK_RR_LIST(pNode);

    //
    //  set count of RR processed
    //  return count to caller
    //

    CURRENT_RR_SECTION_COUNT( pMsg ) += countRR;

    return  countRR;
}



VOID
Wire_SaveAdditionalInfo(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchName,
    IN      PDB_NAME        pName,
    IN      WORD            wType
    )
/*++

Routine Description:

    Save additional info when writing record.

Arguments:

    pMsg - message

    pchName - ptr to byte in packet where additional name written

    pName - database name written, useful as follow this reference

    wType - type of additional processing;

Return Value:

    None.

--*/
{
    PADDITIONAL_INFO    padditional;
    DWORD               countAdditional;

    ASSERT( pMsg->fDoAdditional );

    DNS_DEBUG( WRITE2, (
        "Enter Wire_SaveAdditionalInfo()\n" ));

    //
    //  test should be done by caller, but for safety protect
    //

    if ( !pMsg->fDoAdditional )
    {
        return;
    }

    //
    //  verify space in additional array
    //

    padditional = &pMsg->Additional;
    countAdditional = padditional->cCount;

    if ( countAdditional >= padditional->cMaxCount )
    {
        ASSERT( countAdditional == padditional->cMaxCount );
        DNS_DEBUG( WRITE, (
            "WARNING:  out of additional record space processing\n"
            "\tpacket at %p\n",
            pMsg ));
        return;
    }

    //
    //  save additional data
    //      - node
    //      - offset in packet
    //
    //  DEVNOTE: need type field in additional data?
    //      - when do additional processing that requires security
    //
    //  DEVNOTE: should either change type on additional ptr
    //      OR
    //      combine with compression and understand cast
    //

    padditional->pNameArray[ countAdditional ]   = pName;
    padditional->wOffsetArray[ countAdditional ] = DNSMSG_OFFSET( pMsg, pchName );
    padditional->wTypeArray[ countAdditional ]   = wType;

    padditional->cCount = ++countAdditional;
    return;
}



PDB_NODE
Wire_GetNextAdditionalSectionNode(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Get next additional section node.

Arguments:

    pMsg -- ptr to query

Return Value:

    Ptr to next additional node -- if found.
    NULL otherwise.

--*/
{
    PADDITIONAL_INFO    padditional;
    DWORD               i;
    WORD                offset;
    PDB_NODE            pnode;

    DNS_DEBUG( LOOKUP, (
        "Wire_GetNextAdditionalSectionNode( %p )\n",
        pMsg ));

    //
    //  additional records to write?
    //
    //  note:  currently ALL additional records are A records
    //          if this changes would need to keep array of
    //          additional record type also
    //

    padditional = &pMsg->Additional;

    while( HAVE_MORE_ADDITIONAL_RECORDS(padditional) )
    {
        pMsg->wTypeCurrent = DNS_TYPE_A;

        i = padditional->iIndex++;
        offset = padditional->wOffsetArray[i];

        ASSERT( 0 < offset && offset < MAXWORD );
        ASSERT( DNSMSG_PTR_FOR_OFFSET(pMsg, offset) < pMsg->pCurrent );

        pnode = Lookup_NodeForPacket(
                    pMsg,
                    DNSMSG_PTR_FOR_OFFSET( pMsg, offset ),
                    0       // no flags
                    );
        if ( !pnode )
        {
            DNS_DEBUG( LOOKUP, (
                "Unable to find node for additional data in pMsg %p\n"
                "\tadditional index = %d\n",
                pMsg,
                i ));
            continue;
        }
        pMsg->wOffsetCurrent = offset;

        pMsg->fQuestionRecursed = FALSE;
        pMsg->fQuestionCompleted = FALSE;
        SET_TO_WRITE_ADDITIONAL_RECORDS(pMsg);

        return( pnode );
    }

    return( NULL );
}




//
//  Query for type A is the common special case
//

WORD
Wire_WriteAddressRecords(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PDB_NODE        pNode,
    IN      WORD            wNameOffset
    )
/*++

Routine Description:

    Write A records at node to packet.

    This is only for answering question where node already has packet
    offset.   This is fine, because we're only interested in this
    for question answer and additional data, which both have existing
    offsets.

Arguments:

    pMsg - msg to write to

    pNode - ptr to node to write A records of

    wNameOffset - offset to node name in packet;  NOT optional

Return Value:

    Count of records written.
    Zero if no valid records available.

--*/
{
    register    PDB_RECORD                  prr;
    register    PDNS_COMPRESSED_A_RECORD    pCAR;

    PDB_RECORD      prrLastA = NULL;    // init for PPC comp
    PDB_RECORD      prrBeforeA;

    PCHAR       pchstop;
    DWORD       minTtl = MAXDWORD;
    DWORD       ttl;
    DWORD       tempTtl;
    WORD        countWritten;
    WORD        foundCount = 0;
    INT         fdelete = FALSE;
    BOOL        fcontinueAfterLimit = FALSE;
    UCHAR       foundRank = 0;
    UCHAR       rank;
    IP_ADDRESS  ip;
    IP_ADDRESS  writeIpArray[ DEFAULT_MAX_IP_WRITE_COUNT ];
    INT         bufferAdjustmentForOPT = 0;


    ASSERT( pNode != NULL );
    ASSERT( wNameOffset );

    IF_DEBUG( WRITE2 )
    {
        Dbg_NodeName(
            "Writing A records at node ",
            (PDB_NODE) pNode,
            "\n"
            );
    }

    //
    //  get message info
    //      - flip question name, and insure proper compression flag
    //

    pCAR = (PDNS_COMPRESSED_A_RECORD) pMsg->pCurrent;

    wNameOffset = htons( COMPRESSED_NAME_FOR_OFFSET(wNameOffset) );

    //
    //  set WINS flag -- cleared if A records written
    //

    pMsg->fWins = (BOOLEAN) SrvCfg_fWinsInitialized;


    //
    //  walk RR list -- write A records
    //

    LOCK_RR_LIST(pNode);
    if ( IS_NOEXIST_NODE(pNode) )
    {
        UNLOCK_RR_LIST(pNode);
        return( 0 );
    }

    //
    //  Need to reserve space in buffer for OPT?
    //

    if ( pMsg->Opt.fInsertOptInOutgoingMsg )
    {
        bufferAdjustmentForOPT = DNS_MINIMIMUM_OPT_RR_SIZE;
        pMsg->pBufferEnd -= bufferAdjustmentForOPT;
        DNS_DEBUG( WRITE2, (
            "adjusted buffer end by %d bytes to reserve space for OPT\n",
            bufferAdjustmentForOPT ));
    }
    pchstop = pMsg->pBufferEnd;

    prr = START_RR_TRAVERSE( pNode );
    prrBeforeA = prr;

    while( prr = prr->pRRNext )
    {
        DNS_DEBUG( OFF, (
            "Checking record of type %d for address record.\n",
            prr->wType ));

        //
        //  skip RR before A, break after A
        //      - save ptr to RR just before first A for round robining
        //

        if ( prr->wType != DNS_TYPE_A )
        {
            if ( prr->wType > DNS_TYPE_A )
            {
                break;
            }
            prrBeforeA = prr;
            continue;
        }

        //
        //  fast path for single A RR
        //      - get rid of all the tests and special cases
        //

        if ( !prrLastA
            &&
            ( !prr->pRRNext || prr->pRRNext->wType != DNS_TYPE_A ) )
        {
            //  cache hint never hits wire

            if ( IS_ROOT_HINT_RR(prr) )
            {
                break;
            }

            //  out of space in packet? --
            //      - set truncation flag

            if ( pchstop - (PCHAR)pCAR < sizeof(DNS_COMPRESSED_A_RECORD) )
            {
                pMsg->Head.Truncation = TRUE;
                break;
            }

            //
            //  TTL
            //      - cache data TTL is in form of timeout time
            //      - regular authoritative data TTL is STATIC TTL in net byte order
            //

            if ( IS_CACHE_RR(prr) )
            {
                ttl = RR_PacketTtlForCachedRecord( prr, pMsg->dwQueryTime );
                if ( ttl == (-1) )
                {
                    fdelete = TRUE;
                    break;
                }
            }
            else
            {
                ttl = prr->dwTtlSeconds;
            }

            //
            //  write record
            //      - compressed name
            //      - type
            //      - class
            //      - TTL
            //      - data length
            //      - data (IP address)

            *(UNALIGNED  WORD *) &pCAR->wCompressedName = wNameOffset;
            *(UNALIGNED  WORD *) &pCAR->wType = (WORD) DNS_RTYPE_A;
            *(UNALIGNED  WORD *) &pCAR->wClass = (WORD) DNS_RCLASS_INTERNET;
            *(UNALIGNED DWORD *) &pCAR->dwTtl = ttl;
            *(UNALIGNED  WORD *) &pCAR->wDataLength
                                        = NET_BYTE_ORDER_A_RECORD_DATA_LENGTH;
            *(UNALIGNED DWORD *) &pCAR->ipAddress = prr->Data.A.ipAddress;

            countWritten = 1;
            pCAR++;
            goto Done;
        }

        //
        //  if already have data, then do NOT use data of lower rank
        //      - cache hints
        //      - glue
        //
        //  ROOT_HINT data NEVER goes on to the wire
        //

        rank = RR_RANK(prr);
        if ( foundRank != rank )
        {
            if ( foundRank )
            {
                ASSERT( rank < foundRank );
                break;
            }
            if ( rank == RANK_ROOT_HINT )
            {
                break;
            }
            foundRank = rank;
        }
        ASSERT( !IS_ROOT_HINT_RR(prr) );

        //
        //  skip all CACHED records when any are timed out
        //
        //  DEVNOTE: could combine with rank test
        //      foundRank == rank && IS_CACHE_RANK(rank) and fdelete
        //

        if ( fdelete && IS_CACHE_RR(prr) )
        {
            foundRank = 0;
            continue;
        }

        //
        //  stop reading records?
        //      - reach hard limit in array OR
        //      - NOT doing local net priority, and at AddressAnswerLimit
        //
        //  continue through A records after reaching limit?
        //  so that the round robining continues correctly;
        //  note this is done in main loop AFTER check for mixed cached
        //  and static data, so we specifically do NOT mix the data
        //  when round robining
        //

        prrLastA = prr;

        if ( fcontinueAfterLimit )
        {
            continue;
        }
        if ( foundCount >= DEFAULT_MAX_IP_WRITE_COUNT
            ||
            ( !SrvCfg_fLocalNetPriority &&
            SrvCfg_cAddressAnswerLimit &&
            foundCount >= SrvCfg_cAddressAnswerLimit ) )
        {
            if ( SrvCfg_fRoundRobin )
            {
                fcontinueAfterLimit = TRUE;
                continue;
            }
            break;
        }

        //
        //  determine TTL
        //      - cache data TTL is in form of timeout time;  every record
        //      is guaranteed to have minimum TTL, so only need check first one
        //
        //      - regular authoritative data TTL is STATIC TTL, records may
        //      have differing TTL for admin convenience, but always send
        //      minimum TTL of RR set
        //
        //  note do this test before writting anything, as need to catch
        //  timed out case and quit
        //

        if ( IS_CACHE_RR(prr) )
        {
            if ( foundCount == 0 )
            {
                ttl = RR_PacketTtlForCachedRecord( prr, pMsg->dwQueryTime );
                if ( ttl == (-1) )
                {
                    fdelete = TRUE;
                    break;
                }
            }
        }
        else
        {
            INLINE_DWORD_FLIP( tempTtl, (prr->dwTtlSeconds) );
            if ( tempTtl < minTtl )
            {
                minTtl = tempTtl;
                ttl = prr->dwTtlSeconds;
            }
        }

        //  save address

        writeIpArray[ foundCount++ ] = prr->Data.A.ipAddress;
    }

    //
    //  prioritize address for local net
    //

    if ( SrvCfg_fLocalNetPriority )
    {
        prioritizeIpAddressArray(
            writeIpArray,
            foundCount,
            pMsg->RemoteAddress.sin_addr.s_addr );
    }

    //
    //  write records
    //
    //  limit write if AddressAnswerLimit
    //  may have actually read more records than AddressAnswerLimit
    //  if LocalNetPriority, to make sure best record included, but
    //  we now limit the write to only the best records
    //
    //  DEVNOTE: should also skip downgrade on smart "length-aware" clients
    //

    if ( SrvCfg_cAddressAnswerLimit &&
        SrvCfg_cAddressAnswerLimit < foundCount &&
        !pMsg->fTcp )
    {
        ASSERT( SrvCfg_fLocalNetPriority );
        foundCount = (WORD)SrvCfg_cAddressAnswerLimit;
    }

    for( countWritten=0; countWritten<foundCount; countWritten++ )
    {
        //
        //  out of space in packet?
        //
        //      - set truncation flag (unless specially configured not to)
        //      - only "repeal" truncation for answers
        //      for additional data, the truncation flag will terminate the
        //      record writing loop and the flag will be reset in the
        //      calling routine (answer.c)
        //

        if ( pchstop - (PCHAR)pCAR < sizeof(DNS_COMPRESSED_A_RECORD) )
        {
            if ( ! SrvCfg_cAddressAnswerLimit ||
                ! IS_SET_TO_WRITE_ANSWER_RECORDS(pMsg) ||
                ! countWritten )
            {
                pMsg->Head.Truncation = TRUE;
            }
            break;
        }

        //
        //  write record
        //      - compressed name
        //      - type
        //      - class
        //      - TTL
        //      - data length
        //      - data (IP address)

        ip = writeIpArray[ countWritten ];

        if ( countWritten == 0 )
        {
            *(UNALIGNED  WORD *) &pCAR->wCompressedName = wNameOffset;
            *(UNALIGNED  WORD *) &pCAR->wType = (WORD) DNS_RTYPE_A;
            *(UNALIGNED  WORD *) &pCAR->wClass = (WORD) DNS_RCLASS_INTERNET;
            *(UNALIGNED DWORD *) &pCAR->dwTtl = ttl;
            *(UNALIGNED  WORD *) &pCAR->wDataLength
                                        = NET_BYTE_ORDER_A_RECORD_DATA_LENGTH;
            *(UNALIGNED DWORD *) &pCAR->ipAddress = ip;
        }
        else
        {
            //  if written record before, just copy previous
            //  then write in TTL + IP

            RtlCopyMemory(
                pCAR,
                pMsg->pCurrent,
                sizeof(DNS_COMPRESSED_A_RECORD) - sizeof(IP_ADDRESS) );

            *(UNALIGNED DWORD *) &pCAR->ipAddress = ip;
        }
        pCAR++;
    }

Done:

    //
    //  wrote A records?
    //      - clear WINS flag (if found record, no need)
    //      - update packet position
    //

    if ( countWritten )
    {
        pMsg->fWins = FALSE;
        pMsg->pCurrent = (PCHAR) pCAR;

        //
        //  more than one A -- round robin
        //

        if ( countWritten > 1 &&
            SrvCfg_fRoundRobin &&
            IS_ROUND_ROBIN_TYPE( DNS_TYPE_A ) )
        {
            //  save ptr to first A record

            PDB_RECORD      pfirstRR = prrBeforeA->pRRNext;
            ASSERT( pfirstRR != NULL );

            //  cut first A from list

            prrBeforeA->pRRNext = pfirstRR->pRRNext;

            //  point first A's next ptr at remainder of list

            pfirstRR->pRRNext = prrLastA->pRRNext;

            //  splice first A in at end of A records

            prrLastA->pRRNext = pfirstRR;
        }
    }
    UNLOCK_RR_LIST(pNode);

    //
    //  delete timed out resource records
    //

    if ( fdelete )
    {
        ASSERT( countWritten == 0 );
        RR_ListTimeout( pNode );
    }

    IF_DEBUG( WRITE2 )
    {
        DNS_PRINT((
            "Wrote %d A records %sat node ",
            countWritten,
            ( pMsg->Head.Truncation )
                ?   "and set truncation bit "
                :   ""
            ));

        Dbg_NodeName(
            NULL,
            (PDB_NODE) pNode,
            "\n"
            );
    }

    //
    //  set count of RR processed
    //
    //  return count to caller
    //

    CURRENT_RR_SECTION_COUNT( pMsg ) += countWritten;

    pMsg->pBufferEnd += bufferAdjustmentForOPT;

    return( countWritten );
}



VOID
prioritizeIpAddressArray(
    IN OUT  IP_ADDRESS      IpArray[],
    IN      DWORD           dwCount,
    IN      IP_ADDRESS      RemoteIp
    )
/*++

Routine Description:

    Prioritizes IP array for addresses closest to remote address.

    The LocalNetPriority value is either 1 to specify that
    addresses should be ordered in the best possible match
    or it is a netmask to indicate within what mask the best
    matches should be round-robined.

Arguments:

Return Value:

    None

--*/
{
    DBG_FN( "prioritizeIpAddressArray" )

    IP_ADDRESS  ip;
    DWORD       remoteNetMask;
    DWORD       mismatch;
    DWORD       i;
    DWORD       j;
    DWORD       jprev;
    DWORD       matchCount = 0;
    DWORD       matchCountWithinPriorityNetmask = 0;
    DWORD       mismatchArray[ DEFAULT_MAX_IP_WRITE_COUNT ];
    DWORD       dwpriorityMask = SrvCfg_dwLocalNetPriorityNetMask;

    //
    //  Retrieve corresponding to the client's IP address.
    //  Class A, B, or C, depending on the upper address bits.
    //

    remoteNetMask = Dns_GetNetworkMask( RemoteIp );

    if ( dwpriorityMask == DNS_LOCNETPRI_MASK_CLASS_DEFAULT )
    {
        dwpriorityMask = remoteNetMask;
    }

    IF_DEBUG( WRITE )
    {
        DNS_PRINT((
            "PrioritizeAddressArray\n"
            "    remote IP        = %s\n"
            "    remote net mask  = 0x%08X\n"
            "    priority mask    = 0x%08X\n",
            IP_STRING( RemoteIp ),
            remoteNetMask,
            dwpriorityMask ));
        IF_DEBUG( WRITE2 )
        {
            DnsDbg_IpAddressArray(
                "Host IPs before local net prioritization: ",
                NULL,
                dwCount,
                IpArray );
        }
    }

    //
    //  Loop through each answer IP.
    //

    for ( i = 0; i < dwCount; ++i )
    {
        ip = IpArray[ i ];
        mismatch = ip ^ RemoteIp;

        //
        //  If the nets don't match just continue.
        //

        if ( mismatch & remoteNetMask )
        {
            continue;
        }

        INLINE_DWORD_FLIP( mismatch, mismatch );

        DNS_DEBUG( WRITE2, (
            "found IP %s matching nets with remote IP 0x%08X\n"
            "    mismatch = 0x%08X\n",
            IP_STRING( ip ),
            RemoteIp,
            mismatch ));

        //  matches remote net, put last non-matching entry in its place
        //
        //  then work down matching array, bubbling existing entries up,
        //  until find matching entry with smaller mismatch

        j = matchCount;
        IpArray[ i ] = IpArray[ j ];

        //
        //  Put addresses into absolute best possible order. Keep count
        //  of how many of these matches are inside the final desired match.
        //

        while ( j )
        {
            jprev = j--;
            if ( mismatchArray[ j ] < mismatch )
            {
                ++j;
                break;
            }
            mismatchArray[ jprev ] = mismatchArray[ j ];
            IpArray[ jprev ] = IpArray[ j ];
        }

        IpArray[ j ] = ip;
        mismatchArray[ j ] = mismatch;
        ++matchCount;

        if ( mismatch <= dwpriorityMask )
        {
            ++matchCountWithinPriorityNetmask;
        }

        IF_DEBUG( WRITE2 )
        {
            DnsDbg_DwordArray(
                "Matching IP mis-match list after insert:",
                NULL,
                matchCount,
                mismatchArray );
        }
    }

    //
    //  Round-robin is tricky with LNP enabled. The problem is
    //  that the swapping of matching addresses into the start
    //  of the array leaves us with the original address ordering
    //  whenever the original IP answer list started with all
    //  non-matching addresses. To combat this, round-robin
    //  the matching addresses by a pseudo-random factor.
    //
    //  However, we do this swapping for matching addresses that
    //  matched within the priority netmask. This keeps those
    //  addresses at the top of the list.
    //

    if ( dwpriorityMask != DNS_LOCNETPRI_MASK_BEST_MATCH &&
        matchCountWithinPriorityNetmask &&
        ( i = DNS_TIME() % matchCountWithinPriorityNetmask ) > 0 )
    {
        #define     DNS_MAX_LNP_RR_CHUNK    32

        IP_ADDRESS tempArray[ DNS_MAX_LNP_RR_CHUNK ];

        DNS_DEBUG( WRITE, (
            "%s: round robin top %d addresses within priority netmask\n",
            fn, matchCountWithinPriorityNetmask ));

        IF_DEBUG( WRITE2 )
        {
            DnsDbg_IpAddressArray(
                "Host IPs before priority netmask round robin: ",
                NULL,
                dwCount,
                IpArray );
        }

        //
        //  Limit the shift factor i so that it is smaller than
        //  the temp buffer size.
        //

        while ( i > DNS_MAX_LNP_RR_CHUNK )
        {
            i /= 2;
        }

        DNS_DEBUG( WRITE, ( "%s: shift factor is %d\n", fn, i ));

        //
        //  Round-robin by copying a chunk of addresses to the
        //  temp buffer, then copy the remaining addresses to the
        //  top of the IP array, then copy of the temp buffer to
        //  the bottom of the IP array.
        //

        RtlCopyMemory(
            tempArray,
            IpArray,
            sizeof( IP_ADDRESS ) * i );
        RtlCopyMemory(
            IpArray,
            IpArray + i,
            sizeof( IP_ADDRESS ) * ( matchCountWithinPriorityNetmask - i ) );
        RtlCopyMemory(
            IpArray + ( matchCountWithinPriorityNetmask - i ),
            tempArray, 
            sizeof( IP_ADDRESS ) * i );
    }

    IF_DEBUG( WRITE2 )
    {
        DnsDbg_IpAddressArray(
            "Host IPs after local net prioritization: ",
            NULL,
            dwCount,
            IpArray );
    }
}



DWORD
FASTCALL
RR_PacketTtlForCachedRecord(
    IN      PDB_RECORD      pRR,
    IN      DWORD           dwQueryTime
    )
/*++

Routine Description:

    Determine TTL to write for cached record.

Arguments:

    pRR - record being written to packet

    dwQueryTime - time of original query

Return Value:

    TTL if successful.
    (-1) if record timed out.

--*/
{
    DWORD   ttl;

    //
    //  cache TTL given in terms of machine time in seconds
    //

    ttl = pRR->dwTtlSeconds;

    if ( ttl < dwQueryTime )
    {
        DNS_DEBUG( WRITE, (
            "Encountered timed out RR (t=%d) (r=%d) (ttl=%d) at %p.\n"
            "\tWriting packet with query time %d\n"
            "\tStopping packet write.\n",
            pRR->wType,
            RR_RANK(pRR),
            pRR->dwTtlSeconds,
            pRR,
            dwQueryTime ));
        return( (DWORD) -1 );        // RR has timed out
    }

    if ( !IS_ZERO_TTL_RR(pRR) )
    {
        ttl = ttl - DNS_TIME();
        if ( (INT)ttl > 0 )
        {
            INLINE_DWORD_FLIP( ttl, ttl );
        }
        else
        {
            DNS_DEBUG( WRITE, (
                "Encountered RR (t=%d) (r=%d) (ttl=%d) at %p.\n"
                "\twhich timed out since query time %d\n"
                "\tWriting RR to packet with zero TTL.\n",
                pRR->wType,
                RR_RANK(pRR),
                pRR->dwTtlSeconds,
                pRR,
                dwQueryTime ));
            ttl = 0;
        }
    }
    else
    {
        ttl = 0;
    }
    return( ttl );
}

//
//  End of rrpacket.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\scm.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    scm.c

Abstract:

    Domain Name System (DNS) Server

    Interfaces for interacting with the Services Control Manager APIs

Author:

    Eyal Schwartz (eyals)   1/7/1999

Revision History:

    EyalS   1/18/99
        Unused-- all references to this file's functions are commented out.
                 left for future use.


--*/


#include "dnssrv.h"


SC_HANDLE   g_hScmDns = NULL;

DWORD
scm_Initialize(
    VOID
    )
/*++

Routine Description:

    Initializes linkage to the scm manager.
      - open scm manager handle
      - open service handle & place in global

Arguments:

    none.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

Remarks:
    - note that we don't realy need a shutdown at the moment.

--*/
{

    SC_HANDLE hScMgr;
    DWORD status = ERROR_SUCCESS;

    DNS_DEBUG ( SCM, (
        "Call: scm_initialize()\n"
        ));

    //
    // Unused at the moment
    //
    ASSERT ( FALSE );

    if ( g_hScmDns )
    {
        //
        // We've had an open handle. Close & re-open
        //

        CloseServiceHandle ( g_hScmDns );
        g_hScmDns = NULL;
    }

    DNS_DEBUG ( SCM, (
        "Opening SCM manager handle\n" ));

    hScMgr = OpenSCManagerA(
                 NULL,
                 NULL,
                 GENERIC_READ
                 );
    if ( NULL == hScMgr )
    {
        status = GetLastError();
        DNS_DEBUG (  SCM, (
            "Error <%lu>: cannot open SCM\n",
            status ));
        status = status == ERROR_SUCCESS ? ERROR_INVALID_PARAMETER : status;
        goto Cleanup;
    }

    DNS_DEBUG ( SCM, (
        "Opening SCM DNS Service handle\n" ));

    g_hScmDns = OpenServiceA(
                    hScMgr,
                    "Dns",
                    SERVICE_ALL_ACCESS );
    if ( NULL == hScMgr )
    {
        status = GetLastError();
        DNS_DEBUG (  SCM, (
            "Error <%lu>: cannot open SCM Dns Service\n",
            status ));
        status = (status == ERROR_SUCCESS) ?
                                ERROR_INVALID_PARAMETER :
                                status;
        goto Cleanup;
    }



Cleanup:

    DNS_DEBUG ( SCM, (
        "Exit <%lu>: scm_initialize()\n",
        status ));

    if ( hScMgr )
    {
        //
        // close scm handle regardless.
        //
        CloseServiceHandle ( hScMgr );
    }

    if ( ERROR_SUCCESS != status )
    {
        DNS_DEBUG ( SCM, (
            "Failure: cleaning handles()\n",
            status ));
        if ( g_hScmDns )
        {
            CloseServiceHandle ( g_hScmDns );
            g_hScmDns = NULL;
        }

    }
    DNS_DEBUG ( SCM, (
        "Exit <%lu>: scm_initialize()\n",
        status ));


    return status;
}



DWORD
scm_AdjustSecurity(
    IN      PSECURITY_DESCRIPTOR    pNewSd
    )
/*++

Routine Description:

    Modifies the security on the DNS service to include
    our DnsAdministrators

Arguments:

    none.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

Remarks:
    Note that this changes the SERVICE security, not the regkey access rights.

--*/
{
    DWORD status = ERROR_SUCCESS;
    BOOL  bstatus;

    DNS_DEBUG ( SCM, (
        "Call: scm_AdjustSecurity()\n"
        ));

    //
    // Unused at the moment
    //
    ASSERT ( FALSE );

    ASSERT ( pNewSd );

    if ( !g_hScmDns )
    {
        //
        // We're not ready to get called
        //
        DNS_DEBUG( SCM, (
            "Error: cannot adjust scm security. g_hScmDns == NULL.\n"
            ));
        status = ERROR_INVALID_PARAMETER;
        ASSERT ( FALSE );
        goto Cleanup;
    }

    //
    // Use scm to set new security on DNS registry point.
    //
    bstatus = SetServiceObjectSecurity (
                  g_hScmDns,
                  DACL_SECURITY_INFORMATION,
                  pNewSd );

    if ( !bstatus )
    {
        status = GetLastError();
        DNS_DEBUG( SCM, (
            "Error <%lu>: Failed to extend dns registry security\n",
            status ));
        status = (status == ERROR_SUCCESS) ?
                               ERROR_INVALID_PARAMETER :
                               status;
        goto Cleanup;
    }


Cleanup:

    DNS_DEBUG ( SCM, (
        "Exit <%lu>: scm_AdjustSecurity()\n",
        status ));

    return status;
}


//
//  End of scm.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\rrrpc.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    rrrpc.c

Abstract:

    Domain Name System (DNS) Server

    Resource record RPC routines.

Author:

    Jim Gilroy (jamesg)     November 1995

Revision History:

--*/


#include "dnssrv.h"
#include "limits.h"

//
//  Minimum emumeration buffer length
//

#define MIN_ENUM_BUFFER_LENGTH 1024

//
//  Protect the end of the buffer
//

#define ENUMERATION_ALLOC_SIZE      (0x00040000)    // 256K

#define ENUM_BUFFER_PROTECT_LENGTH  16


//
//  Data selection macros
//

#define IS_NOENUM_NODE(p)       ( IS_SELECT_NODE(p) )

#define VIEW_AUTHORITY(flag)    (flag & DNS_RPC_VIEW_AUTHORITY_DATA)
#define VIEW_CACHE(flag)        (flag & DNS_RPC_VIEW_CACHE_DATA)
#define VIEW_GLUE(flag)         (flag & DNS_RPC_VIEW_GLUE_DATA)
#define VIEW_ROOT_HINT(flag)    (flag & DNS_RPC_VIEW_ROOT_HINT_DATA)
#define VIEW_ADDITIONAL(flag)   (flag & DNS_RPC_VIEW_ADDITIONAL_DATA)

//
//  Additional data viewing
//      - currently NS only (for root hints or glue)
//      - currently fixed limit at 100 nodes
//

#define IS_VIEW_ADDITIONAL_RECORD(prr)  ((prr)->wType == DNS_TYPE_NS)

#define VIEW_ADDITIONAL_LIMIT           (100)


//
//  Private protos
//

BOOL
ignoreNodeInEnumeration(
    IN      PDB_NODE        pNode
    );

DNS_STATUS
addNodeToRpcBuffer(
    IN OUT  PBUFFER         pBuffer,
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pNode,
    IN      WORD            wRecordType,
    IN      DWORD           dwSelectFlag,
    IN      DWORD           dwEnumFlag
    );

PCHAR
writeStringToRpcBuffer(
    IN OUT  PCHAR           pchBuf,
    IN      PCHAR           pchBufEnd,
    IN      PCHAR           pchString,
    IN      DWORD           cchStringLength OPTIONAL
    );

DNS_STATUS
Dead_UpdateResourceRecordTtl(
    IN      PDB_NODE        pNode,
    IN OUT  PDB_RECORD      pRRUpdate,
    IN      DWORD           dwNewTtl
    );

DNS_STATUS
locateAndAccessCheckZoneNode(
    IN      LPSTR           pszZoneName,
    IN      LPSTR           pszNodeName,
    IN      BOOL            fCreate,
    OUT     PZONE_INFO *    ppZone,
    OUT     PDB_NODE *      ppNode
    );

DNS_STATUS
createAssociatedPtrRecord(
    IN      IP_ADDRESS      ipAddress,
    IN OUT  PDB_NODE        pnodeAddress,
    IN      DWORD           dwFlag
    );

DNS_STATUS
deleteAssociatedPtrRecord(
    IN      IP_ADDRESS      ipAddress,
    IN      PDB_NODE        pnodeAddress,
    IN      DWORD           dwFlag
    );

DNS_STATUS
updateWinsRecord(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN OUT  PDB_RECORD      pDeleteRR,
    IN      PDNS_RPC_RECORD pRecord         OPTIONAL
    );



//
//  Record viewing API
//

DNS_STATUS
R_DnssrvEnumRecords(
    IN      DNSSRV_RPC_HANDLE   hServer,
    IN      LPCSTR              pszZoneName,
    IN      LPCSTR              pszNodeName,
    IN      LPCSTR              pszStartChild,
    IN      WORD                wRecordType,
    IN      DWORD               dwSelectFlag,
    IN      LPCSTR              pszFilterStart,
    IN      LPCSTR              pszFilterStop,
    OUT     PDWORD              pdwBufferLength,
    OUT     PBYTE *             ppBuffer
    )
/*++

    
Routine Description:

    Legacy version of R_DnssrvEnumRecords - no client version argument.

Arguments:

    See R_DnssrvEnumRecords2

Return Value:

    See R_DnssrvEnumRecords2

--*/
{
    DNS_STATUS      status;
    
    DNS_DEBUG( RPC, (
        "R_DnssrvEnumRecords() - non-versioned legacy call\n" ));

    status = R_DnssrvEnumRecords2(
                    DNS_RPC_W2K_CLIENT_VERSION,
                    0,
                    hServer,
                    pszZoneName,
                    pszNodeName,
                    pszStartChild,
                    wRecordType,
                    dwSelectFlag,
                    pszFilterStart,
                    pszFilterStop,
                    pdwBufferLength,
                    ppBuffer );
    return status;
}   //  R_DnssrvEnumRecords



DNS_STATUS
DNS_API_FUNCTION
R_DnssrvEnumRecords2(
    IN      DWORD               dwClientVersion,
    IN      DWORD               dwSettingFlags,
    IN      DNSSRV_RPC_HANDLE   hServer,
    IN      LPCSTR              pszZoneName,
    IN      LPCSTR              pszNodeName,
    IN      LPCSTR              pszStartChild,
    IN      WORD                wRecordType,
    IN      DWORD               dwSelectFlag,
    IN      LPCSTR              pszFilterStart,
    IN      LPCSTR              pszFilterStop,
    OUT     PDWORD              pdwBufferLength,
    OUT     PBYTE *             ppBuffer
    )
/*++

Routine Description:

    RPC record enumeration call.

    Enumerate records at node or its children.

Arguments:

    hServer -- server RPC handle

    pszZoneName -- zone name;  includes special zone names
                    (eg. ..RootHints or ..Cache)

    pszNodeName -- node name;  FQDN or relative to root (@ for root)

    pszStartChild -- child to restart enum after ERROR_MORE_DATA condition

    wRecordType -- optional record type filter (default is ALL)

    dwSelectFlag -- flag indicating records to select;
        - node and children
        - only children
        - only node
        - auth data only
        - additional data
        - cache data

    pszFilterStart -- not yet implemented

    pszFilterStop -- not yet implemented

    pdwBufferLength -- addr to receive buffer length

    ppBuffer -- addr to receive buffer

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_MORE_DATA if out of space in buffer.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PZONE_INFO      pzone = NULL;
    PDB_NODE        pnode;
    PDB_NODE        pnodeStartChild = NULL;
    PCHAR           pbuf;
    BUFFER          buffer;


    DNS_DEBUG( RPC, (
        "R_DnssrvEnumRecords2():\n"
        "\tdwClientVersion  = 0x%08X\n"
        "\tpszZoneName      = %s\n"
        "\tpszNodeName      = %s\n"
        "\tpszStartChild    = %s\n"
        "\twRecordType      = %d\n"
        "\tdwSelectFlag     = %p\n"
        "\tpdwBufferLen     = %p\n",
        dwClientVersion,
        pszZoneName,
        pszNodeName,
        pszStartChild,
        wRecordType,
        dwSelectFlag,
        pdwBufferLength ));

    //
    //  access check
    //

    status = RpcUtil_SessionSecurityInit(
                pszZoneName,
                PRIVILEGE_READ,
                RPC_INIT_FIND_ALL_ZONES,    // return cache or root-hints zones
                NULL,
                & pzone );

    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    //
    //  find domain node in desired zone
    //

    pnode = Lookup_FindZoneNodeFromDotted(
                pzone,
                (LPSTR) pszNodeName,
                LOOKUP_FIND_PTR,
                & status );

    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    //
    //  No node? What to do?
    //

    if ( pnode == NULL )
    {
        return ERROR_SUCCESS;
    }

    //
    //  allocate a big buffer, adequate for largest possible record
    //

    pbuf = (PBYTE) MIDL_user_allocate( ENUMERATION_ALLOC_SIZE );
    if ( !pbuf )
    {
        return( DNS_ERROR_NO_MEMORY );
    }

    //  init buffer
    //      - for retail pad with a few bytes on end for safety

    InitializeFileBuffer(
        & buffer,
        pbuf,
#if DBG
        ENUMERATION_ALLOC_SIZE,
#else
        ENUMERATION_ALLOC_SIZE - ENUM_BUFFER_PROTECT_LENGTH,
#endif
        NULL        // no file
        );

#if DBG
    memset(
        buffer.pchEnd - ENUM_BUFFER_PROTECT_LENGTH,
        0xd,                            // write hex d to buffer
        ENUM_BUFFER_PROTECT_LENGTH );
#endif

    //
    //  if starting child node, find it
    //      - if FQDN, lookup in tree
    //      - if single label, find child node
    //

    if ( pszStartChild  &&  *pszStartChild != 0 )
    {
        pnodeStartChild = NTree_FindOrCreateChildNode(
                            pnode,
                            (PCHAR) pszStartChild,
                            (DWORD) strlen( pszStartChild ),
                            0,          //  create flag
                            0,          //  memtag
                            NULL );     //  ptr for following node
        if ( !pnodeStartChild  ||  pnodeStartChild->pParent != pnode )
        {
            status = ERROR_INVALID_PARAMETER;
            goto Done;
        }
    }

    //
    //  use last error to propagate out-of-space condition
    //      so clear error here

    SetLastError( ERROR_SUCCESS );

    //
    //  write node's records
    //  then write all node's children's records
    //

    if ( !pnodeStartChild )
    {
        if ( ! (dwSelectFlag & DNS_RPC_VIEW_ONLY_CHILDREN) )
        {
            status = addNodeToRpcBuffer(
                        & buffer,
                        pzone,
                        pnode,
                        wRecordType,
                        dwSelectFlag,
                        ENUM_DOMAIN_ROOT
                        );
            if ( status != ERROR_SUCCESS )
            {
                goto Done;
            }
        }
        pnodeStartChild = NTree_FirstChild( pnode );
    }

    if ( ! (dwSelectFlag & DNS_RPC_VIEW_NO_CHILDREN) )
    {
        while ( pnodeStartChild )
        {
            status = addNodeToRpcBuffer(
                        & buffer,
                        pzone,
                        pnodeStartChild,
                        wRecordType,
                        dwSelectFlag,
                        0
                        );
            if ( status != ERROR_SUCCESS )
            {
                if ( status == ERROR_MORE_DATA || fDnsServiceExit )
                {
                    break;
                }
            }

            //  get next child

            pnodeStartChild = NTree_NextSiblingWithLocking( pnodeStartChild );
        }
    }

Done:

    //
    //  set buffer length written
    //      - using pdwBufferLength as available length ptr
    //

    *pdwBufferLength = BUFFER_LENGTH_TO_CURRENT( &buffer );
    *ppBuffer = buffer.pchStart;

    DNS_DEBUG( RPC, (
        "Leave R_DnssrvEnumRecords().\n"
        "\tWrote %d byte record buffer at %p:\n"
        "\tstatus = %p.\n",
        *pdwBufferLength,
        *ppBuffer,
        status ));

    IF_DEBUG( RPC2 )
    {
        DnsDbg_RpcRecordsInBuffer(
            "EnumRecords Buffer:\n",
            *pdwBufferLength,
            *ppBuffer );
    }

    RpcUtil_SessionComplete( );

    return( status );
}



//
//  Record viewing utilities
//

BOOL
ignoreNodeInEnumeration(
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Checks if node needs enumeration.

    May call itself recursively to determine need for enumeration.

Arguments:

    pNode -- ptr to node to check for enumeration

Return Value:

    TRUE if node should be enumerated.
    FALSE if node does NOT need enumeration.

--*/
{
    //
    //  records at node -- always enumerate
    //  sticky node -- admin wants enumerated
    //

    if ( IS_NOENUM_NODE(pNode) )
    {
        DNS_DEBUG( RPC, ( "Ignoring node (l=%s) -- NOENUM node.\n", pNode->szLabel ));
        return( TRUE );
    }
    if ( pNode->pRRList && !IS_NOEXIST_NODE(pNode) || IS_ENUM_NODE(pNode) )
    {
        return( FALSE );
    }

    //
    //  no records, not sticky AND no children -- ignore
    //

    if ( ! pNode->pChildren )
    {
        DNS_DEBUG( RPC, (
            "Ignoring node (l=%s) -- no records, no children.\n",
            pNode->szLabel ));
        return( TRUE );
    }

    //
    //  check if children can be ignored
    //  returns FALSE immediately if encounters non-ignoreable node
    //

    else
    {
        PDB_NODE    pchild = NTree_FirstChild( pNode );

        while ( pchild )
        {
            if ( ! ignoreNodeInEnumeration( pchild ) )
            {
                return( FALSE );
            }
            pchild = NTree_NextSiblingWithLocking( pchild );
        }
        return( TRUE );
    }
}



DNS_STATUS
addNodeToRpcBuffer(
    IN OUT  PBUFFER         pBuffer,
    IN      PZONE_INFO      pZone,
    IN      PDB_NODE        pNode,
    IN      WORD            wRecordType,
    IN      DWORD           dwSelectFlag,
    IN      DWORD           dwEnumFlag
    )
/*++

Routine Description:

    Add node's resource records to RPC buffer.

Arguments:

    pBuffer - buffer to write to

    pNode - ptr to node

    wRecordType - record type

    dwSelectFlag - flag indicating records to select

    dwEnumFlag - flag indicating how to enum this node, based on where we
        are in enumeration

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_MORE_DATA if out of space in buffer.
    Error code on failure.

--*/
{
    PDNS_RPC_NODE   prpcNode;
    PCHAR           pch = pBuffer->pchCurrent;
    PCHAR           pbufEnd = pBuffer->pchEnd;
    PDB_RECORD      prr;
    DNS_STATUS      status = ERROR_SUCCESS;
    INT             i;
    INT             countAdditional = 0;
    PDB_NODE        arrayAdditional[ VIEW_ADDITIONAL_LIMIT ];


    prpcNode = (PDNS_RPC_NODE) pch;
    ASSERT( IS_DWORD_ALIGNED(pch) );
    ASSERT( pNode != NULL );

    //  insure node header size is not messed up

    ASSERT( SIZEOF_DNS_RPC_NODE_HEADER
                == ((PBYTE)&prpcNode->dnsNodeName - (PBYTE)prpcNode) );

    //
    //  ignore node?
    //      - no RR data at node
    //      - not "sticky" domain user created
    //      - no children with RR data
    //

    if ( ignoreNodeInEnumeration(pNode) )
    {
        IF_DEBUG( RPC )
        {
            Dbg_DbaseNode(
                "Ignoring RPC enumeration of node",
                pNode );
        }
        return( ERROR_SUCCESS );
    }

    DNS_DEBUG( RPC, (
        "addNodeToRpcBuffer().\n"
        "\tWriting node (label %s) to buffer.\n"
        "\tWriting at %p, with buf end at %p.\n"
        "\tSelect flags = %p\n"
        "\tEnum flags   = %p\n"
        "\tType         = %d\n",
        pNode->szLabel,
        prpcNode,
        pbufEnd,
        dwSelectFlag,
        dwEnumFlag,
        wRecordType ));

    //
    //  fill in node structure
    //      - clear fields that are not definitely set
    //      - set child count
    //      - set length once finished writing name itself
    //      - "sticky" node set flag to alert admin to enumerate
    //      - always enum zone roots (show folder for delegation)
    //      whether there are children or not
    //

    if ( pbufEnd - (PCHAR)prpcNode < SIZEOF_NBSTAT_FIXED_DATA )
    {
        goto NameSpaceError;
    }
    prpcNode->dwFlags = 0;
    prpcNode->wRecordCount = 0;
    prpcNode->dwChildCount = pNode->cChildren;

    if ( prpcNode->dwChildCount == 0 && pNode->pChildren )
    {
        prpcNode->dwChildCount = 1;
        DNS_DEBUG( ANY, (
            "Node %p %s, has child ptr but no child count!\n",
            pNode,
            pNode->szLabel ));
        ASSERT( FALSE );
    }

    if ( IS_ENUM_NODE(pNode) || IS_ZONE_ROOT(pNode) || pNode->pChildren )
    {
        DNS_DEBUG( RPC, (
            "Enum at domain root, setting sticky flag.\n" ));
        prpcNode->dwFlags |= DNS_RPC_FLAG_NODE_STICKY;

        if ( IS_ZONE_ROOT(pNode) )
        {
            prpcNode->dwFlags |= DNS_RPC_FLAG_ZONE_ROOT;

            if ( IS_AUTH_ZONE_ROOT(pNode) )
            {
                prpcNode->dwFlags |= DNS_RPC_FLAG_AUTH_ZONE_ROOT;
            }
            else if ( IS_DELEGATION_NODE(pNode) )
            {
                prpcNode->dwFlags |= DNS_RPC_FLAG_ZONE_DELEGATION;
            }
            ELSE_ASSERT( !pNode->pParent || !IS_ZONE_TREE_NODE(pNode) );
        }
    }

    //
    //  write node name
    //      - note name includes terminating NULL so admin need not
    //      copy from RPC buffer
    //
    //  for domain root write empty name
    //      - clear DOMAIN_ROOT flag for record enumeration
    //      - clear child count (already know it and having it
    //          causes NT4.0 admin to put up another domain
    //      - clear sticky flag
    //

    if ( dwEnumFlag & ENUM_DOMAIN_ROOT )
    {
        pch = Name_PlaceNodeLabelInRpcBuffer(
                    (PCHAR) &prpcNode->dnsNodeName,
                    pbufEnd,
                    DATABASE_ROOT_NODE
                    );
        prpcNode->dwChildCount = 0;
        prpcNode->dwFlags &= ~DNS_RPC_NODE_FLAG_STICKY;
    }
    else if ( dwEnumFlag & ENUM_NAME_FULL )
    {
        pch = Name_PlaceFullNodeNameInRpcBuffer(
                    (PCHAR) &prpcNode->dnsNodeName,
                    pbufEnd,
                    pNode
                    );
    }
    else
    {
        pch = Name_PlaceNodeLabelInRpcBuffer(
                    (PCHAR) &prpcNode->dnsNodeName,
                    pbufEnd,
                    pNode
                    );
    }

    //
    //  if name didn't write to packet, bail
    //      - if no error given, assume out-of-space error
    //

    if ( pch == NULL )
    {
        status = GetLastError();
        if ( status == ERROR_SUCCESS ||
            status == ERROR_MORE_DATA )
        {
            goto NameSpaceError;
        }
        ASSERT( FALSE );
        goto Done;
    }

    //
    //  set node length
    //  round name up to DWORD for record write
    //

    pch = (PCHAR) DNS_NEXT_DWORD_PTR(pch);
    pBuffer->pchCurrent = pch;

    prpcNode->wLength = (WORD)(pch - (PCHAR)prpcNode);

    IF_DEBUG( RPC2 )
    {
        DnsDbg_RpcNode(
            "RPC node (header) written to buffer",
            prpcNode );
    }

    //
    //  do NOT enumerate records at domain when enumerating domain's parent
    //
    //  generally all records at a domain, are enumerated only when domain folder
    //  itself is opened;  note that sticky flag is reset when actually
    //  enumerate the node under its own domain (ENUM_DOMAIN_ROOT flag)
    //
    //  however exeception is when precisely asking about particular node
    //  examples:
    //      - root hints NS host A records
    //      - more generally any additional data
    //

    if ( prpcNode->dwFlags & DNS_RPC_NODE_FLAG_STICKY )
    {
        if ( dwEnumFlag & (ENUM_NAME_FULL | ENUM_DOMAIN_ROOT) )
        {
            DNS_DEBUG( RPC, (
                "Continuing enum of node %s with sticky flag.\n"
                "\tEnum flag = %p\n",
                pNode->szLabel,
                dwEnumFlag ));
        }
        else
        {
            DNS_DEBUG( RPC, ( "Leave addNodeToRpcBuffer() => sticky node\n" ));
            goto Done;
        }
    }
    ASSERT( prpcNode->dwChildCount == 0 || (prpcNode->dwFlags & DNS_RPC_NODE_FLAG_STICKY) );

    //  if no records desired -- only writing name
    //  then we're done

    if ( wRecordType == 0 )
    {
        DNS_DEBUG( RPC, ( "Leave addNodeToRpcBuffer() => zero record type\n" ));
        goto Done;
    }

    //
    //  write resource records at node
    //

    LOCK_READ_RR_LIST(pNode);
    status = ERROR_SUCCESS;

    //  if cached name error, presumably should have no children that aren't
    //  also cached name errors, so should have ignored node

    if ( IS_NOEXIST_NODE(pNode) )
    {
        Dbg_DbaseNode(
            "WARNING:  cached name error at node with NON-ignored children.\n",
            pNode );
        // ASSERT( pNode->cChildren );
        // ASSERT( prpcNode->dwChildCount );

        UNLOCK_READ_RR_LIST(pNode);
        goto Done;
    }

    prr = START_RR_TRAVERSE(pNode);

    while ( prr = NEXT_RR(prr) )
    {
        //  if at delegation (zone root and NOT root of enumeration)
        //  then only show NS records

        if ( IS_DELEGATION_NODE(pNode)  &&
                ! (dwEnumFlag & ENUM_DOMAIN_ROOT) &&
                prr->wType != DNS_TYPE_NS )
        {
            DNS_DEBUG( RPC, (
                "Skipping non-NS record at delegation node %s.\n",
                pNode->szLabel ));
            continue;
        }

        //  screen for data type and RR type

        if ( wRecordType != DNS_TYPE_ALL && wRecordType != prr->wType )
        {
            continue;
        }

        if ( IS_ZONE_RR(prr) )
        {
            if ( ! VIEW_AUTHORITY(dwSelectFlag) )
            {
                continue;
            }
        }
        else if ( IS_CACHE_RR(prr) )
        {
            if ( ! VIEW_CACHE(dwSelectFlag) )
            {
                continue;
            }
        }
        else if ( IS_NS_GLUE_RR(prr) )
        {
            if ( ! VIEW_GLUE(dwSelectFlag) )
            {
                //  allow NS glue enum
                //      - viewing auth data
                //      - glue is for subzone, NOT at zone root

                if ( !pZone ||
                        pNode == pZone->pZoneRoot ||
                        !VIEW_AUTHORITY(dwSelectFlag) )
                {
                    continue;
                }
            }
        }
        else if ( IS_GLUE_RR(prr) )
        {
            if ( ! VIEW_GLUE(dwSelectFlag) )
            {
                continue;
            }
        }
        else if ( IS_ROOT_HINT_RR(prr) )
        {
            if ( ! VIEW_ROOT_HINT(dwSelectFlag) )
            {
                continue;
            }
        }
        else    // what type is this?
        {
            ASSERT( FALSE );
            continue;
        }

        //
        //  do NOT enumerate database WINS RR if it is not the zone's WINS RR
        //      - need this or else end up enumerating two WINS records
        //

        if ( IS_WINS_TYPE(prr->wType) )
        {
            if ( pZone->pWinsRR != prr )
            {
                continue;
            }
        }

        ASSERT( pch && IS_DWORD_ALIGNED(pch) );

        status = Flat_WriteRecordToBuffer(
                    pBuffer,
                    prpcNode,
                    prr,
                    pNode,
                    dwSelectFlag );

        if ( status != ERROR_SUCCESS )
        {
            //  if out of space -- quit
            //  otherwise skip record and continue

            if ( status == ERROR_MORE_DATA )
            {
                UNLOCK_RR_LIST(pNode);
                goto NameSpaceError;
            }
            continue;
        }

        //
        //  additional data?
        //
        //  this is capable of finding addtional data for any PTR type
        //  but only immediate interest if NS glue data
        //
        //  can encapsulate in function if broader use is anticipated
        //  function could do memory alloc\realloc for buffer, so no
        //  limit, and then writing function could cleanup
        //
        //  NS glue lookup
        //  for root NS records:
        //      - zone auth data
        //      - another zone's auth data
        //      - other zone (glue, outside) data
        //
        //  for delegation NS records:
        //      - zone auth data
        //      - zone glue data
        //      - another zone's auth data
        //      - outside zone data
        //
        //  DEVNOTE: root-zone view any different
        //      still want to use\display other zone AUTH data
        //      as we'd certainly use for lookup;   however, don't want to
        //      hide the fact that we don't have it in our root-hints file
        //
        //  DEVNOTE: may need some sort of force writing whenever view
        //      data from another zone, that is NOT in root-hints or
        //      zone view?
        //

        if ( VIEW_ADDITIONAL(dwSelectFlag) &&
            IS_VIEW_ADDITIONAL_RECORD(prr) &&
            countAdditional < VIEW_ADDITIONAL_LIMIT )
        {
            PDB_NODE pnodeGlue;
            PDB_NODE pnodeGlueFromZone = NULL;

            //
            //  first check in zone
            //      - auth node
            //                  => final word, done
            //      - glue node
            //                  => done if delegation
            //                  => check other zones, if zone NS
            //      - outside
            //                  => check other zones
            //
            //  but for root zone, we always take what's here
            //

            pnodeGlue = Lookup_ZoneNode(
                            pZone,
                            prr->Data.NS.nameTarget.RawName,
                            NULL,       // no message
                            NULL,       // no lookup name
                            LOOKUP_FIND | LOOKUP_FQDN,
                            NULL,       // no closest name
                            NULL        // following node ptr
                            );
            if ( pnodeGlue )
            {
                if ( IS_ZONE_ROOTHINTS(pZone) ||
                     IS_AUTH_NODE(pnodeGlue) ||
                     (IS_SUBZONE_NODE(pnodeGlue) && !IS_AUTH_ZONE_ROOT(pNode)) )
                {
                    //  done (see above)
                }
                else
                {
                    pnodeGlueFromZone = pnodeGlue;
                    pnodeGlue = NULL;
                }
            }

            //
            //  check all other zones for authoritative data
            //      - accept NO cache data
            //      - if not authoritative data, use any non-auth data
            //          found by zone lookup above
            //

            if ( !pnodeGlue && !IS_ZONE_ROOTHINTS(pZone) )
            {
                pnodeGlue = Lookup_NsHostNode(
                                & prr->Data.NS.nameTarget,
                                LOOKUP_NO_CACHE_DATA,
                                NULL,   // no favored zone (already did zone lookup)
                                NULL    // no delegated info needed
                                );

                if ( !pnodeGlue ||
                     ! IS_AUTH_NODE(pnodeGlue) )
                {
                     pnodeGlue = pnodeGlueFromZone;
                }
            }

            //  if found anything worthwhile, use it

            if ( pnodeGlue )
            {
                arrayAdditional[ countAdditional ] = pnodeGlue;
                countAdditional++;
            }
        }
    }

    //
    //  DEVNOTE: Admin tool should make direct call to do this
    //
    //  write LOCAL WINS\WINSR record which does not get written from
    //      database;  now only occurs on secondary zone
    //
    //  special case writing WINS records
    //      - in authoritative zone
    //      - at zone root
    //
    //  note:  we do AFTER writing RR, as admin picks LAST WINS
    //          RR received for use in property page
    //

    ASSERT( pch && IS_DWORD_ALIGNED(pch) );

    if ( pZone
            &&  pZone->pZoneRoot == pNode
            &&  IS_ZONE_SECONDARY(pZone)
            &&  pZone->fLocalWins
            &&  (wRecordType == DNS_TYPE_ALL || IS_WINS_TYPE(wRecordType)) )
    {
        //  note eliminating possibility of passing down record that
        //      just disappeared, ie. NULL zone pWinsRR ptr

        prr = pZone->pWinsRR;
        if ( prr )
        {
            status = Flat_WriteRecordToBuffer(
                        pBuffer,
                        prpcNode,
                        prr,
                        pNode,
                        dwSelectFlag );

            ASSERT( status != DNS_ERROR_RECORD_TIMED_OUT );
            ASSERT( IS_DWORD_ALIGNED(pch) );
            if ( status == ERROR_MORE_DATA || pch==NULL )
            {
                UNLOCK_RR_LIST(pNode);
                goto NameSpaceError;
            }
        }
    }

    UNLOCK_READ_RR_LIST(pNode);


    //
    //  write any additional data to buffer
    //

    for ( i=0; i<countAdditional; i++ )
    {
        status = addNodeToRpcBuffer(
                    pBuffer,
                    pZone,
                    arrayAdditional[ i ],
                    DNS_TYPE_A,
                    dwSelectFlag,
                    ENUM_NAME_FULL
                    );
        if ( status != ERROR_SUCCESS )
        {
            //DnsDebugLock();
            DNS_PRINT((
                "ERROR:  enumerating additional data at node"
                "\tstatus = %p\n",
                status ));
            Dbg_NodeName(
                "Failing additional node",
                arrayAdditional[ i ],
                "\n" );
            //DnsDebugUnlock();

            if ( status == ERROR_MORE_DATA )
            {
                goto NameSpaceError;
            }
            continue;
        }
    }

Done:

    //
    //  Done
    //
    //  skip node if
    //      - no records
    //      - no children
    //      - not sticky
    //      - not the node being enumerated
    //
    //  with filter it is possible that terminal node written with
    //  no records;  in that case, and if not sticky, don't reset
    //  position effectively dumping name data
    //

    if ( prpcNode->wRecordCount == 0  &&
         prpcNode->dwChildCount == 0  &&
         ! (prpcNode->dwFlags & DNS_RPC_NODE_FLAG_STICKY) &&
         ! (dwEnumFlag & ENUM_DOMAIN_ROOT) )
    {
        DNS_DEBUG( RPC, (
            "Skipping node %s in RPC enum -- no records, no kids.\n",
            pNode->szLabel ));

        pBuffer->pchCurrent = (PCHAR) prpcNode;
    }

    //  on successful write, indicate node is complete in buffer

    if ( status == ERROR_SUCCESS )
    {
        prpcNode->dwFlags |= DNS_RPC_NODE_FLAG_COMPLETE;

        IF_DEBUG( RPC )
        {
            DnsDbg_RpcNode(
                "Complete RPC node written to buffer",
                prpcNode );
        }
        DNS_DEBUG( RPC2, (
            "Wrote %d RR for %*s into buffer from %p to %p.\n",
            prpcNode->wRecordCount,
            prpcNode->dnsNodeName.cchNameLength,
            prpcNode->dnsNodeName.achName,
            prpcNode,
            pch ));
    }
#if DBG
    else
    {
        IF_DEBUG( RPC )
        {
            DnsDbg_RpcNode(
                "Partial RPC node written to buffer",
                prpcNode );
        }
        DNS_DEBUG( RPC2, (
            "Encountered error %d / 0x%p, writing RR for %*s.\n"
            "\t%d records successfully written in buffer"
            " from %p to %p.\n",
            status,
            status,
            prpcNode->dnsNodeName.cchNameLength,
            prpcNode->dnsNodeName.achName,
            prpcNode->wRecordCount,
            prpcNode,
            pch ));
    }
#endif
    return( status );


NameSpaceError:

    DNS_DEBUG( RPC, (
        "Out of space attempting to write node name to buffer at %p.\n"
        "\tNode label = %s.\n",
        (PCHAR) prpcNode,
        pNode->szLabel ));

    return( ERROR_MORE_DATA );
}



PCHAR
writeStringToRpcBuffer(
    IN OUT  PCHAR   pchBuf,
    IN      PCHAR   pchBufEnd,
    IN      PCHAR   pchString,
    IN      DWORD   cchStringLength OPTIONAL
    )
/*++

Routine Description:

    Write string in RPC buffer format.  This means counted string length
    AND NULL termination.

    Raises DNS_EXCEPTION_NO_PACKET_SPACE, if buffer has insufficient space
    for string.

Arguments:

    cchStringLength -- optional length of string, if NOT given assumes
        NULL terminated string

Return Value:

    Ptr to next byte in buffer.

--*/
{
    if ( ! cchStringLength )
    {
        cchStringLength = strlen( pchString );
    }

    //  check that length may be represented in counted length string

    if ( cchStringLength > 255 )
    {
        DNS_PRINT((
            "ERROR:  string %.*s length = %d exceeds 255 limit!!!\n",
            cchStringLength,
            pchString,
            cchStringLength ));
        ASSERT( FALSE );
        return( NULL );
    }

    //  check for space in buffer

    if ( pchBuf + cchStringLength + 2 > pchBufEnd )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }

    // length in buf with NULL terminator

    *pchBuf++ = (UCHAR) cchStringLength + 1;

    RtlCopyMemory(
        pchBuf,
        pchString,
        cchStringLength );

    pchBuf += cchStringLength;
    *pchBuf = 0;    // NULL terminate

    return( ++pchBuf );
}




//
//  Record management API
//


DNS_STATUS
R_DnssrvUpdateRecord(
    IN      DNSSRV_RPC_HANDLE   hServer,
    IN      LPCSTR              pszZoneName,
    IN      LPCSTR              pszNodeName,
    IN      PDNS_RPC_RECORD     pAddRecord,
    IN      PDNS_RPC_RECORD     pDeleteRecord
    )
/*++

    
Routine Description:

    Legacy version of R_DnssrvUpdateRecord - no client version argument.

Arguments:

    See R_DnssrvUpdateRecord2

Return Value:

    See R_DnssrvUpdateRecord2

--*/
{
    DNS_STATUS      status;
    
    status = R_DnssrvUpdateRecord2(
                    DNS_RPC_W2K_CLIENT_VERSION,
                    0,
                    hServer,
                    pszZoneName,
                    pszNodeName,
                    pAddRecord,
                    pDeleteRecord );
    return status;
}   //  R_DnssrvUpdateRecord


DNS_STATUS
DNS_API_FUNCTION
R_DnssrvUpdateRecord2(
    IN      DWORD               dwClientVersion,
    IN      DWORD               dwSettingFlags,
    IN      DNSSRV_RPC_HANDLE   hServer,
    IN      LPCSTR              pszZoneName,
    IN      LPCSTR              pszNodeName,
    IN      PDNS_RPC_RECORD     pAddRecord,
    IN      PDNS_RPC_RECORD     pDeleteRecord
    )
/*++

Routine Description:

    RPC record update call.

    Update record at zone node.

Arguments:

    hServer -- server RPC handle

    pszZoneName -- zone name;  includes special zone names
                    (eg. ..RootHints or ..Cache)

    pszNodeName -- node name;  FQDN or relative to root (@ for root)

    pAddRecord -- record to add

    pDeleteRecord -- record to delete

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PZONE_INFO      pzone = NULL;
    PDB_NODE        pnode;
    PDB_RECORD      prrAdd = NULL;
    PDB_RECORD      prrDelete = NULL;

    UPDATE_LIST     updateList;
    DWORD           updateFlag;
    PUPDATE         pupdate;
    PDB_RECORD      pdbaseRR;
    BOOL            fupdatePtr;
    IP_ADDRESS      addIp;
    IP_ADDRESS      deleteIp;

    IF_DEBUG( RPC )
    {
        DNS_PRINT((
            "\nR_DnssrvUpdateRecord():\n"
            "\tdwClientVersion  = 0x%08X\n"
            "\tpszZoneName      = %s\n"
            "\tpszNodeName      = %s\n"
            "\tpAddRecord       = %p\n"
            "\tpDeleteRecord    = %p\n",
            dwClientVersion,
            pszZoneName,
            pszNodeName,
            pAddRecord,
            pDeleteRecord ));

        IF_DEBUG( RPC2 )
        {
            DnsDbg_RpcRecord(
                "\tUpdate add record data:\n",
                pAddRecord );
            DnsDbg_RpcRecord(
                "\tUpdate delete record data:\n",
                pDeleteRecord );
        }
    }

    //
    //  access check
    //

    status = RpcUtil_SessionSecurityInit(
                pszZoneName,
                PRIVILEGE_WRITE,
                0,                  // no flag
                NULL,
                & pzone );

    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    //
    //  find domain node in desired zone
    //      - if only delete, then just do find (if no node => success)
    //

    pnode = Lookup_FindZoneNodeFromDotted(
                pzone,
                (LPSTR) pszNodeName,
                (pAddRecord || !pDeleteRecord) ? NULL : LOOKUP_FIND_PTR,
                & status );

    if ( status != ERROR_SUCCESS )
    {
        goto Cleanup;
    }
    if ( !pnode )
    {
        ASSERT( !pAddRecord );
        goto Cleanup;
    }

    //
    //  if NO record specified, then just adding name
    //      - set bit to make sure we show name on later enumerations,
    //        even with no records or children
    //      - however if already an enum node, we return ALREADY_EXIST to help admin
    //          avoid duplicate display
    //

    if ( !pAddRecord && !pDeleteRecord )
    {
        if ( IS_ENUM_NODE(pnode) || IS_ZONE_ROOT(pnode) || pnode->cChildren )
        {
            DNS_DEBUG( RPC, (
                //"Returning ALREADY_EXISTS on domain (%s) create because ...\n"
                "WARNING:  RPC Creation of existing domain (%s):\n"
                "\tenum flag = %d\n"
                "\tzone root = %d\n"
                "\tchildren  = %d\n",
                pnode->szLabel,
                IS_ENUM_NODE(pnode),
                IS_ZONE_ROOT(pnode),
                pnode->cChildren ));
            //status = DNS_ERROR_RECORD_ALREADY_EXISTS;
        }
        SET_ENUM_NODE( pnode );
        status = ERROR_SUCCESS;
        goto Cleanup;
    }

    //
    //  build desired records
    //

    if ( pAddRecord )
    {
        status = Flat_RecordRead(
                    pzone,
                    pnode,
                    pAddRecord,
                    & prrAdd );
        if ( status != ERROR_SUCCESS )
        {
            goto Cleanup;
        }
    }
    if ( pDeleteRecord )
    {
        status = Flat_RecordRead(
                    pzone,
                    pnode,
                    pDeleteRecord,
                    & prrDelete );
        if ( status != ERROR_SUCCESS )
        {
            goto Cleanup;
        }
    }

    //
    //  authoritative zone
    //

    if ( pzone )
    {
        //
        //  special case adding LOCAL WINS to secondary zone
        //
        //  special case WINS records
        //  complicated behavior switching to create / delete /
        //      switch to local differ for primary and secondary
        //
        //  DEVNOTE: need to separate the building from the flag setting
        //              to get this to work;  this should really happen
        //              automatically when WINS added to authoritative zone
        //

        if ( IS_ZONE_SECONDARY( pzone ) && !IS_ZONE_STUB( pzone ) )
        {
            if ( ( pAddRecord  &&  IS_WINS_TYPE(pAddRecord->wType)) ||
                 ( pDeleteRecord  &&  IS_WINS_TYPE(pDeleteRecord->wType)) )
            {
                status = updateWinsRecord(
                            pzone,
                            pnode,
                            NULL,           // no delete record
                            pAddRecord );
                goto Cleanup;
            }
        }

        //  check for primary

        if ( ! IS_ZONE_PRIMARY(pzone) )
        {
            status = DNS_ERROR_INVALID_ZONE_TYPE;
            goto Cleanup;
        }

        //  init update list

        Up_InitUpdateList( &updateList );

        //  indicate admin update

        updateFlag = DNSUPDATE_ADMIN;

        //  if suppressing notify, set flag

        if ( (pAddRecord && (pAddRecord->dwFlags & DNS_RPC_FLAG_SUPPRESS_NOTIFY)) ||
             (pDeleteRecord && (pDeleteRecord->dwFlags & DNS_RPC_FLAG_SUPPRESS_NOTIFY)) )
        {
            updateFlag |= DNSUPDATE_NO_NOTIFY;
        }

        //
        //  build the update -- still need to do it under lock, because
        //      currently routines set flags, etc.
        //
        //  WARNING:  delete MUST go first, otherwise when duplicate data
        //      (TTL change), add will change TTL, but delete will delete record
        //
        //  DEVNOTE: not correct place to build, see above
        //

        if ( prrDelete )
        {
            pupdate = Up_CreateAppendUpdate(
                            & updateList,
                            pnode,
                            NULL,
                            0,
                            prrDelete );
            IF_NOMEM( !pupdate )
            {
                status = DNS_ERROR_NO_MEMORY;
                goto Cleanup;
            }
        }
        if ( prrAdd )
        {
            //  set aging
            //      - admin update by default turns aging OFF
            //      - set flag to turn on

            if ( pAddRecord->dwFlags & DNS_RPC_FLAG_AGING_ON )
            {
                updateFlag |= DNSUPDATE_AGING_ON;
            }
            else
            {
                updateFlag |= DNSUPDATE_AGING_OFF;
            }

            if ( pAddRecord->dwFlags & DNS_RPC_FLAG_OPEN_ACL )
            {
                updateFlag |= DNSUPDATE_OPEN_ACL;
            }

            pupdate = Up_CreateAppendUpdate(
                            & updateList,
                            pnode,
                            prrAdd,
                            0,
                            NULL );
            IF_NOMEM( !pupdate )
            {
                status = DNS_ERROR_NO_MEMORY;
                prrDelete = NULL;
                goto Cleanup;
            }
        }

        //
        //  PTR update?  --  save new IP address
        //  grab it here so, we know record still exists -- it could be
        //      deleted by someone else immediately after unlock
        //

        //
        //  always do PTR check on A record delete
        //
        //  currently admin UI has no checkbox for update-PTR on record delete
        //  so we'll just assume it is set;
        //
        //  DEVNOTE: temp hack, PTR flag on delete
        //

        if ( !pAddRecord && pDeleteRecord )
        {
            pDeleteRecord->dwFlags |= DNS_RPC_RECORD_FLAG_CREATE_PTR;
        }

        fupdatePtr = (pAddRecord &&
                        (pAddRecord->dwFlags & DNS_RPC_RECORD_FLAG_CREATE_PTR)) ||
                    (pDeleteRecord &&
                        (pDeleteRecord->dwFlags & DNS_RPC_RECORD_FLAG_CREATE_PTR));
        if ( fupdatePtr )
        {
            addIp = 0;
            deleteIp = 0;

            if ( prrAdd && prrAdd->wType == DNS_TYPE_A )
            {
                addIp = prrAdd->Data.A.ipAddress;
            }
            if ( prrDelete && prrDelete->wType == DNS_TYPE_A )
            {
                deleteIp = prrDelete->Data.A.ipAddress;
            }
        }
        ELSE
        {
            DNS_DEBUG( RPC, (
                "No PTR update for update.\n" ));
        }

        //
        //  execute the update
        //
        //  ExecuteUpdates() cleans up failure case add RRs and
        //  deletes temporary delete RRs.
        //
        //  if ALREADY_EXISTS error, continue with additional records
        //  processing to handle successful delete (which could be separate record)
        //
        //  DEVNOTE: this new Up_ExecuteUpdate() also takes zone lock
        //      ideally this would be fine with a waiting-for-lock on the zone
        //
        //  note:  ExecuteUpdate() unlocks zone in all cases
        //

        prrAdd = NULL;
        prrDelete = NULL;

        status = Up_ExecuteUpdate(
                        pzone,
                        &updateList,
                        updateFlag
                        );

        if ( status != ERROR_SUCCESS  &&
             status != DNS_ERROR_RECORD_ALREADY_EXISTS )
        {
            goto Cleanup;
        }


        IF_DEBUG( RPC )
        {
            Dbg_DbaseNode(
                "\tUpdated node:",
                pnode );
        }

        //
        //  update associate PTR records, if any
        //

        if ( fupdatePtr )
        {
            DNS_STATUS  tempStatus;

            if ( addIp )
            {
                tempStatus = createAssociatedPtrRecord( addIp, pnode, updateFlag );
                if ( tempStatus != ERROR_SUCCESS )
                {
                    status = DNS_WARNING_PTR_CREATE_FAILED;
                }
            }
            if ( deleteIp )
            {
                tempStatus = deleteAssociatedPtrRecord( deleteIp, pnode, updateFlag );
                if ( tempStatus != ERROR_SUCCESS )
                {
                    status = DNS_WARNING_PTR_CREATE_FAILED;
                }
            }
        }
        goto Cleanup;
    }

    //
    //  cache -- delete's only, no adding to cache
    //
    //  DEVNOTE: cache deletes -- either bogus, or delete's ALL records of type
    //
    //  DEVNOTE: make sure aren't deleting root hint data
    //      need delete function with Rank parameter\flag
    //

    else if ( pszZoneName && strcmp(pszZoneName, DNS_ZONE_CACHE) == 0 )
    {
        if ( prrAdd )
        {
            status = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        if ( prrDelete )
        {
            pdbaseRR = RR_UpdateDeleteMatchingRecord(
                            pnode,
                            prrDelete );
            if ( pdbaseRR )
            {
                DNS_DEBUG( RPC, (
                    "Non-zone update delete record found = %p\n",
                    pdbaseRR ));

                if ( !IS_CACHE_RR(pdbaseRR) )
                {
                    MARK_ROOT_HINTS_DIRTY();
                }
                RR_Free( pdbaseRR );
            }
        }
    }

    //
    //  root hints
    //
    //  note: if successful prrAdd IS the database record, NULL
    //      ptr to avoid free
    //

    //  DEVNOTE: treat NULL as root hints, until marco in ssync
    //      then may want to switch so NULL is cache OR lookup zone
    //

    //else if ( strcmp(pszZoneName, DNS_ZONE_ROOT_HINTS) == 0 )

    else
    {
        if ( prrDelete )
        {
            pdbaseRR = RR_UpdateDeleteMatchingRecord(
                            pnode,
                            prrDelete );
            if ( pdbaseRR )
            {
                DNS_DEBUG( RPC, (
                    "Non-zone update delete record found = %p\n",
                    pdbaseRR ));

                if ( !IS_CACHE_RR(pdbaseRR) )
                {
                    MARK_ROOT_HINTS_DIRTY();
                }
                RR_Free( pdbaseRR );
            }
        }

        if ( pAddRecord )
        {
            status = RR_AddToNode(
                        NULL,
                        pnode,
                        prrAdd
                        );
            if ( status != ERROR_SUCCESS )
            {
                goto Cleanup;
            }
            ASSERT( !IS_CACHE_RR(prrAdd) );
            prrAdd = NULL;
            MARK_ROOT_HINTS_DIRTY();
        }
    }


Cleanup:

    DNS_DEBUG( RPC, (
        "Leaving R_DnssrvUpdateRecord():\n"
        "\tstatus = %p (%d)\n",
        status, status ));

    RR_Free( prrDelete );
    RR_Free( prrAdd );

    RpcUtil_SessionComplete( );

    return( status );
}



DNS_STATUS
Rpc_DeleteZoneNode(
    IN      DWORD           dwClientVersion,
    IN      PZONE_INFO      pZone,
    IN      LPSTR           pszProperty,
    IN      DWORD           dwTypeId,
    IN      PVOID           pData
    )
/*++

Routine Description:

    Delete a name from database.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PDB_NODE        pnode;
    PDB_NODE        pnodeClosest;
    UPDATE_LIST     updateList;
    BOOL            fdeleteSubtree;
    LPSTR           psznodeName;

    ASSERT( dwTypeId == DNSSRV_TYPEID_NAME_AND_PARAM );

    fdeleteSubtree = (BOOL) ((PDNS_RPC_NAME_AND_PARAM)pData)->dwParam;
    psznodeName = ((PDNS_RPC_NAME_AND_PARAM)pData)->pszNodeName;

    DNS_DEBUG( RPC, (
        "\nRpc_DeleteZoneNode():\n"
        "\tpszZoneName      = %s\n"
        "\tpszNodeName      = %s\n"
        "\tfDeleteSubtree   = %d\n",
        pZone ? pZone->pszZoneName : "NULL (cache)",
        psznodeName,
        fdeleteSubtree ));

    //
    //  find node, if doesn't exist -- we're done
    //

    pnode = Lookup_ZoneNodeFromDotted(
                pZone,
                psznodeName,
                0,
                LOOKUP_NAME_FQDN,
                DNS_FIND_LOOKUP_PTR,
                &status );
    if ( !pnode )
    {
        if ( status == DNS_ERROR_NAME_DOES_NOT_EXIST )
        {
            status = ERROR_SUCCESS;
        }
        return( status );
    }

    //
    //  if zone
    //      - can NOT delete zone root
    //      - init\lock zone for update
    //

    if ( pZone )
    {
        if ( pnode == pZone->pZoneRoot )
        {
            status = DNS_ERROR_INVALID_ZONE_OPERATION;
            goto Done;
        }

        //  check for primary

        if ( ! IS_ZONE_PRIMARY(pZone) )
        {
            status = DNS_ERROR_INVALID_ZONE_TYPE;
            goto Done;
        }

        //  init update list

        Up_InitUpdateList( &updateList );

        //  lock out update

        if ( !Zone_LockForAdminUpdate( pZone ) )
        {
            status = DNS_ERROR_ZONE_LOCKED;
            goto Done;
        }

        //
        //  if subtree delete in DS zone -- poll
        //
        //  the reason is unless we have an in-memory node we won't
        //  touch the node to do a delete, so we'll miss recently
        //  replicated in data;  (there's still a replication window
        //  here, for new nodes replicating in after our delete, but
        //  the poll lessens the problem)
        //
        //  of course, ultimately this points out that my flat zone
        //  DS model is non-ideal for this sort of operation, but it's
        //  not a frequent operation, so we can live with it
        //
        //  DEVNOTE: DS update gets post-delete in memory delete?
        //  DEVNOTE:  update should be able to suppress all reads, since
        //      just did poll
        //

        status = Ds_ZonePollAndUpdate(
                    pZone,
                    TRUE        // force polling
                    );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  polling zone %s, before subtree delete!\n",
                pZone->pszZoneName ));
        }

    }

    //
    //  in cache
    //      - node MUST NOT be a zone node or delegation
    //

    ELSE_ASSERT( !IS_ZONE_TREE_NODE(pnode) );

    //
    //  delete the node and optionally subtree
    //  need update list if deleting zone nodes, otherwise not
    //

    if ( RpcUtil_DeleteNodeOrSubtreeForAdmin(
            pnode,
            pZone,
            pZone ? &updateList : NULL,
            fdeleteSubtree
            ) )
    {
        status = ERROR_SUCCESS;
    }
    else
    {
        status = DNS_WARNING_DOMAIN_UNDELETED;
    }

    //
    //  execute the update
    //      - DS write
    //      - memory write
    //      - DS unlock
    //      - don't overwrite UNDELETED warning status
    //
    //  DEVNOTE: flag to suppress DS read?  don't need read if just polled
    //      as all node's get delete;
    //      note:  generally admin node delete's need not read -- just delete node
    //

    if ( pZone )
    {
        DNS_STATUS upStatus;

        upStatus = Up_ExecuteUpdate(
                        pZone,
                        &updateList,
                        DNSUPDATE_ADMIN | DNSUPDATE_ALREADY_LOCKED );
        if ( upStatus != ERROR_SUCCESS )
        {
            status = upStatus;
        }
    }

Done:

    DNS_DEBUG( RPC, (
        "Leaving RpcDeleteNode() delete:\n"
        "\tpsznodeName  = %s\n"
        "\tstatus       = %p\n",
        psznodeName,
        status ));

    return( status );
}



DNS_STATUS
Rpc_DeleteCacheNode(
    IN      DWORD           dwClientVersion,
    IN      LPSTR           pszProperty,
    IN      DWORD           dwTypeId,
    IN      PVOID           pData
    )
/*++

Routine Description:

    Delete a name from the cache.

    This is a stub to Rpc_DeleteZoneNode(), required as RPC server
    operations functions do not have a zone name.
    Unable to dispatch directly from zone operations table without a
    zone name specified, hence having essentially the same function
    in both tables was required.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    return  Rpc_DeleteZoneNode(
                dwClientVersion,
                NULL,       // cache zone
                pszProperty,
                dwTypeId,
                pData );
}



DNS_STATUS
Rpc_DeleteRecordSet(
    IN      DWORD           dwClientVersion,
    IN      PZONE_INFO      pZone,
    IN      LPSTR           pszProperty,
    IN      DWORD           dwTypeId,
    IN      PVOID           pData
    )
/*++

Routine Description:

    Delete a record set from database.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PDB_NODE        pnode;
    PDB_NODE        pnodeClosest;
    UPDATE_LIST     updateList;
    WORD            type;
    LPSTR           psznodeName;

    ASSERT( dwTypeId == DNSSRV_TYPEID_NAME_AND_PARAM );

    type = (WORD) ((PDNS_RPC_NAME_AND_PARAM)pData)->dwParam;
    psznodeName = ((PDNS_RPC_NAME_AND_PARAM)pData)->pszNodeName;

    DNS_DEBUG( RPC, (
        "\nRpc_DeleteRecordSet():\n"
        "\tpszZoneName  = %s\n"
        "\tpszNodeName  = %s\n"
        "\ttype         = %d\n",
        pZone->pszZoneName,
        psznodeName,
        type ));

    //
    //  find node, if doesn't exist -- we're done
    //

    pnode = Lookup_ZoneNodeFromDotted(
                pZone,
                psznodeName,
                0,
                LOOKUP_NAME_FQDN,
                DNS_FIND_LOOKUP_PTR,
                &status );
    if ( !pnode )
    {
        if ( status == DNS_ERROR_NAME_DOES_NOT_EXIST )
        {
            status = ERROR_SUCCESS;
        }
        return( status );
    }

    //
    //  zone
    //      - init\lock zone for update
    //      - setup type delete update
    //      - send update for processing
    //

    if ( pZone )
    {
        //  check for primary

        if ( ! IS_ZONE_PRIMARY(pZone) )
        {
            status = DNS_ERROR_INVALID_ZONE_TYPE;
            goto Done;
        }

        //  init update list

        Up_InitUpdateList( &updateList );

        Up_CreateAppendUpdate(
            &updateList,
            pnode,
            NULL,               //  no add records
            type,               //  delete all records of given type
            NULL                //  no delete records
            );

        status = Up_ExecuteUpdate(
                        pZone,
                        &updateList,
                        DNSUPDATE_ADMIN
                        );
    }

    //
    //  in cache
    //      - node MUST NOT be a zone node or delegation
    //

    else
    {
        PDB_RECORD  prrDeleted;
        DWORD       count;

        ASSERT( !IS_ZONE_TREE_NODE(pnode) );

        prrDeleted = RR_UpdateDeleteType(
                        NULL,
                        pnode,
                        type,
                        0 );

        count = RR_ListFree( prrDeleted );
        status = ERROR_SUCCESS;

        DNS_DEBUG( RPC, (
            "Deleted %d records from cache node %s\n",
            count,
            psznodeName ));
    }

Done:

    DNS_DEBUG( RPC, (
        "Leaving RpcDeleteRecordSet()\n"
        "\tpsznodeName  = %s\n"
        "\tstatus       = %d (%p)\n",
        psznodeName,
        status, status ));

    return( status );
}



DNS_STATUS
Rpc_DeleteCacheRecordSet(
    IN      DWORD           dwClientVersion,
    IN      LPSTR           pszProperty,
    IN      DWORD           dwTypeId,
    IN      PVOID           pData
    )
/*++

Routine Description:

    Delete a record set from the cache.

    This is a stub to Rpc_DeleteRecordSet(), required as RPC server
    operations functions do not have a zone name.
    Unable to dispatch directly from zone operations table without a
    zone name specified, hence having essentially the same function
    in both tables was required.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    return  Rpc_DeleteRecordSet(
                dwClientVersion,
                NULL,       // cache zone
                pszProperty,
                dwTypeId,
                pData );
}



DNS_STATUS
Rpc_ForceAgingOnNode(
    IN      DWORD           dwClientVersion,
    IN      PZONE_INFO      pZone,
    IN      LPSTR           pszProperty,
    IN      DWORD           dwTypeId,
    IN      PVOID           pData
    )
/*++

Routine Description:

    Force aging on zone node or subtree.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    PDB_NODE        pnode;
    BOOL            bageSubtree;
    LPSTR           psznodeName;

    ASSERT( dwTypeId == DNSSRV_TYPEID_NAME_AND_PARAM );

    bageSubtree = (BOOL) ((PDNS_RPC_NAME_AND_PARAM)pData)->dwParam;
    psznodeName = ((PDNS_RPC_NAME_AND_PARAM)pData)->pszNodeName;

    DNS_DEBUG( RPC, (
        "\nRpc_ForceAgingOnZoneNode():\n"
        "\tpszZoneName  = %s\n"
        "\tpszNodeName  = %s\n"
        "\tbSubtree     = %d\n",
        pZone->pszZoneName,
        psznodeName,
        bageSubtree ));

    //
    //  zone op only
    //  only relevant on aging zones
    //

    ASSERT( pZone );
    if ( !pZone->bAging )
    {
        return( DNS_ERROR_INVALID_ZONE_OPERATION );
    }

    //
    //  if node not given -- use zone root
    //  otherwise, find node, if doesn't exist -- we're done
    //

    if ( psznodeName )
    {
        pnode = Lookup_ZoneNodeFromDotted(
                    pZone,
                    psznodeName,
                    0,
                    LOOKUP_NAME_FQDN,
                    DNS_FIND_LOOKUP_PTR,
                    &status );
        if ( !pnode )
        {
            return( status );
        }
    }
    else
    {
        pnode = pZone->pZoneRoot;
    }

    //
    //  make call to age zone
    //

    return  Aging_ForceAgingOnNodeOrSubtree(
                pZone,
                pnode,
                bageSubtree );
}



//
//  Update utilites
//

BOOL
deleteNodeOrSubtreeForAdminPrivate(
    IN OUT  PDB_NODE        pNode,
    IN      BOOL            fDeleteSubtree,
    IN      PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Recursive database walk deleting records from tree.

    MUST lock out timeout thread while using this function.

Arguments:

    pNode -- ptr to root of subtree to delete

    fDeleteSubtree -- deleting entire subtree

    pUpdateList -- update list, if deleting zone nodes

Return Value:

    TRUE if subtree actually deleted.
    FALSE if subtree delete halted by undeletable records.

--*/
{
    BOOL    fSuccess = TRUE;
    BOOL    bAccessed;


    DNS_DEBUG( RPC2, (
        "deleteNodeOrSubtreeForAdminPrivate( %s )",
        pNode->szLabel ));

    //
    //  don't delete authoritative zone roots !
    //      - except current zone root, if doing zone delete
    //
    //  DEVNOTE: delegations on zone delete
    //      -- if going to absorb this territory then should keep delegation
    //          zone root / NS records / GLUE
    //

    if ( IS_AUTH_ZONE_ROOT(pNode) )
    {
        DNS_DEBUG( RPC, (
            "Stopping admin subtree delete, at authoritative zone root",
            "\t%s.\n",
            ((PZONE_INFO)pNode->pZone)->pszZoneName ));
        return( FALSE );
    }

    //
    //  delete children
    //      - if undeletable nodes, set flag but continue delete
    //

    if ( pNode->pChildren  &&  fDeleteSubtree )
    {
        PDB_NODE pchild = NTree_FirstChild( pNode );

        while ( pchild )
        {
            if ( ! deleteNodeOrSubtreeForAdminPrivate(
                            pchild,
                            fDeleteSubtree,
                            pUpdateList ) )
            {
                fSuccess = FALSE;
            }
            pchild = NTree_NextSiblingWithLocking( pchild );
        }
    }

    //
    //  delete this node
    //

    if ( pNode->pRRList )
    {
        //
        //  for update just cut list and add it to update
        //  note, assuming roughly one record per node as typical value
        //

        if ( pUpdateList )
        {
            PUPDATE pupdate;

            pupdate = Up_CreateAppendUpdate(
                            pUpdateList,
                            pNode,
                            NULL,               // no add RR
                            DNS_TYPE_ALL,       // delete type
                            NULL                // no delete RR
                            );
            IF_NOMEM( !pupdate )
            {
                return( DNS_ERROR_NO_MEMORY );
            }

            //  if you could set an "already memory applied" flag
            //  you can execute this RIGHT HERE!
            //  but our paradigm is "build update, then execute intact"
            //
            //  pUpdateList->iNetRecords--;
            //  pNode->pRRList = NULL;
        }

        //
        //  cache delete
        //      - delete RR list at node
        //      - clear node flags
        //
        //  protect against deleting node being accessed, but otherwise clear out
        //  flags:
        //      -> enumeration flag, so empty node no longer shows up on admin
        //      -> wildcard flag (record gone)
        //      -> cname flag (record gone)
        //      -> zone root info (zone gone or would exit above)
        //
        //  do NOT clear flags if no delete node
        //
        //  this insures that NO_DELETE node flag is NOT cleared -- AND
        //  that ZONE_ROOT is never removed from DNS root node
        //
        //  if zone delete -- clear zone flag
        //

        else
        {
            RR_ListDelete( pNode );
            if ( !IS_NODE_NO_DELETE(pNode) )
            {
                CLEAR_EXCEPT_FLAG( pNode, (NODE_NOEXIST | NODE_SELECT | NODE_IN_TIMEOUT) );
            }
        }
    }

    //
    //  clear enum node on all nodes
    //  that way Anand will stop bugging me
    //

    CLEAR_ENUM_NODE( pNode );


    //
    //  return result from child delete
    //
    //  return will be TRUE, except when undeletable records in child nodes
    //

    return( fSuccess );
}



BOOL
RpcUtil_DeleteNodeOrSubtreeForAdmin(
    IN OUT  PDB_NODE        pNode,
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList,    OPTIONAL
    IN      BOOL            fDeleteSubtree
    )
/*++

Routine Description:

    Delete subtree for admin.

    If in zone, zone should be locked during delete.

Arguments:

    pNode -- ptr to root of subtree to delete

    pZone -- zone of deleted records

    pUpdateList -- update list if doing in zone delete

    fDeleteSubtree -- deleting subtree under node

    fDeleteZone -- deleting entire zone

Return Value:

    TRUE (BOOL return required for traversal function).

--*/
{
    ASSERT( !pZone || pZone->fLocked );

    DNS_DEBUG( RPC, (
        "Admin delete of subtree at node %s.\n"
        "\tIn zone          = %s\n"
        "\tSubtree delete   = %d\n",
        pNode->szLabel,
        pZone ? pZone->pszZoneName : NULL,
        fDeleteSubtree ));

    //
    //  call private function which does recursive delete
    //

    return  deleteNodeOrSubtreeForAdminPrivate(
                    pNode,
                    fDeleteSubtree,
                    pUpdateList
                    );
}



DNS_STATUS
createAssociatedPtrRecord(
    IN      IP_ADDRESS      ipAddress,
    IN OUT  PDB_NODE        pHostNode,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Create PTR record for A record being created.

    Assumes database lock is held.

Arguments:

    ipAddress -- to create reverse lookup node for

    pnodePtr -- node PTR will point to

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDB_RECORD      prr = NULL;
    PDB_NODE        pnodeReverse;
    PUPDATE         pupdate;
    PZONE_INFO      pzone;
    UPDATE_LIST     updateList;
    DB_NAME         targetName;
    DWORD           flag;

    DNS_DEBUG( RPC, (
        "createAssociatePtrRecord():\n"
        "\tA node label = %s\n"
        "\tIP = %s\n",
        pHostNode->szLabel,
        IP_STRING( ipAddress ) ));

    //
    //  find zone for reverse (PTR) node
    //  if not authoritative primary -- we're done
    //

    pnodeReverse = Lookup_FindNodeForIpAddress(
                        NULL,
                        ipAddress,
                        LOOKUP_WITHIN_ZONE | LOOKUP_CREATE,
                        NULL                // create
                        );
    if ( !pnodeReverse )
    {
        DNS_DEBUG( RPC, (
            "Associated IP %s, is not within zone.  No creation.\n",
            IP_STRING( ipAddress )
            ));
        return( DNS_ERROR_ZONE_DOES_NOT_EXIST );
    }
    pzone = pnodeReverse->pZone;
    if ( !pzone || !IS_AUTH_NODE(pnodeReverse) || IS_ZONE_SECONDARY(pzone) )
    {
        DNS_DEBUG( RPC, (
            "Associated PTR node not valid for create.\n"
            "\tEither NOT authoritative zone node OR in secondary.\n"
            "\tpnodeReverse = %s (auth=%d)\n"
            "\tpzone        = %s\n",
            pnodeReverse->szLabel,
            pnodeReverse->uchAuthority,
            pzone ? pzone->pszZoneName : NULL ));
        return( DNS_ERROR_ZONE_DOES_NOT_EXIST );
    }

    //  check for primary zone

    if ( ! IS_ZONE_PRIMARY(pzone) )
    {
        return( DNS_ERROR_INVALID_ZONE_TYPE );
    }

    //  init update list

    Up_InitUpdateList( &updateList );

    //
    //  create PTR record and update
    //      - create full dbase name for node
    //      - create PTR
    //

    Name_NodeToDbaseName(
        & targetName,
        pHostNode );

    prr = RR_CreatePtr(
            & targetName,
            NULL,           // no string name
            DNS_TYPE_PTR,
            pzone->dwDefaultTtl,
            MEMTAG_RECORD_ADMIN
            );
    IF_NOMEM( !prr )
    {
        return  DNS_ERROR_NO_MEMORY;
    }

    //
    //  create add update
    //

    pupdate = Up_CreateAppendUpdate(
                    &updateList,
                    pnodeReverse,
                    prr,
                    0,      // no delete type
                    NULL    // no delete record
                    );
    IF_NOMEM( !pupdate )
    {
        RR_Free( prr );
        return  DNS_ERROR_NO_MEMORY;
    }

    //
    //  execute and complete the update
    //

    ASSERT( dwFlag & DNSUPDATE_ADMIN );
    ASSERT( !(dwFlag & DNSUPDATE_ALREADY_LOCKED) );

    return  Up_ExecuteUpdate(
                pzone,
                & updateList,
                dwFlag      // update flag
                );
}



DNS_STATUS
deleteAssociatedPtrRecord(
    IN      IP_ADDRESS      ipAddress,
    IN      PDB_NODE        pHostNode,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Update PTR record.

Arguments:

    pHostNode -- node containing A record

    ipAddress -- address PTR points to

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDB_RECORD      prr = NULL;
    PDB_NODE        pnodeReverse;
    PZONE_INFO      pzone;
    //DNS_STATUS      status;
    UPDATE_LIST     updateList;
    DB_NAME         targetName;
    PUPDATE         pupdate;


    // dwFlags is specified in add, in del it isn't needed at the moment
    // but may in the future (aging issues).
    UNREFERENCED_PARAMETER(dwFlags);
    DNS_DEBUG( RPC, (
        "deleteAssociatedPtrRecord():\n"
        "\tnode label = %s\n"
        "\tIP       = %s\n",
        pHostNode->szLabel,
        IP_STRING( ipAddress ) ));

    //
    //  find reverse lookup node
    //      - if doesn't exist, done
    //      - if not in authoritative primary zone, done
    //

    pnodeReverse = Lookup_FindNodeForIpAddress(
                        NULL,
                        ipAddress,
                        0,                      // flags
                        DNS_FIND_LOOKUP_PTR
                        );
    if ( !pnodeReverse )
    {
        DNS_DEBUG( RPC, ( "Previous associated PTR node not found.\n" ));
        return( ERROR_SUCCESS );
    }
    pzone = (PZONE_INFO) pnodeReverse->pZone;
    if ( !pzone || !IS_AUTH_NODE(pnodeReverse) || IS_ZONE_SECONDARY(pzone) )
    {
        DNS_DEBUG( RPC, (
            "Associated PTR node not valid for delete.\n"
            "\tEither NOT authoritative zone node OR in secondary\n"
            "\tpnodeReverse = %s (auth=%d)\n"
            "\tpzone        = %s\n",
            pnodeReverse->szLabel,
            pnodeReverse->uchAuthority,
            pzone ? pzone->pszZoneName : NULL ));
        return( ERROR_SUCCESS );
    }

    //  check for primary zone

    if ( ! IS_ZONE_PRIMARY(pzone) )
    {
        return( DNS_ERROR_INVALID_ZONE_TYPE );
    }

    //  create update list

    Up_InitUpdateList( &updateList );

    //
    //  create PTR record
    //      - create full dbase name for node
    //      - create PTR
    //      - dummy record so TTL immaterial
    //

    Name_NodeToDbaseName(
        & targetName,
        pHostNode );

    prr = RR_CreatePtr(
            & targetName,
            NULL,           // no string name
            DNS_TYPE_PTR,
            pzone->dwDefaultTtl,
            MEMTAG_RECORD_ADMIN
            );
    IF_NOMEM( !prr )
    {
        return  DNS_ERROR_NO_MEMORY;
    }

    //
    //  create delete update
    //

    pupdate = Up_CreateAppendUpdate(
                    &updateList,
                    pnodeReverse,
                    NULL,           // no add
                    0,
                    prr );
    IF_NOMEM( !pupdate )
    {
        RR_Free( prr );
        return  DNS_ERROR_NO_MEMORY;
    }

    //
    //  execute and complete update
    //      - execute function free's dummy delete RR
    //

    return  Up_ExecuteUpdate(
                pzone,
                & updateList,
                DNSUPDATE_ADMIN
                );
}



//
//  WINS / NBSTAT specific record management
//

DNS_STATUS
updateWinsRecord(
    IN OUT  PZONE_INFO          pZone,
    IN OUT  PDB_NODE            pNode,
    IN OUT  PDB_RECORD          pDeleteRR,
    IN      PDNS_RPC_RECORD     pRecord
    )
{
    DNS_STATUS  status = MAXDWORD;      // init to catch any possible missed assignment
    PDB_RECORD  prr = NULL;
    UPDATE_LIST updateList;
    PUPDATE     pupdate;
    BOOL        fsecondaryLock = FALSE;

    DNS_DEBUG( RPC, (
        "\nupdateWinsRecord():\n"
        "\tpZone            = %p\n"
        "\tpNode            = %p\n"
        "\tpExistingWins    = %p\n"
        "\tpNewRecord       = %p\n",
        pZone,
        pNode,
        pDeleteRR,
        pRecord ));

    //
    //  validate at an authoritative zone root
    //

    if ( !pZone || !pNode || pNode != pZone->pZoneRoot )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    //  primary zone needs to go through update process
    //

    if ( IS_ZONE_PRIMARY(pZone) )
    {
        //  init update list

        Up_InitUpdateList( &updateList );

        //  lock zone

        if ( !Zone_LockForAdminUpdate(pZone) )
        {
            return( DNS_ERROR_ZONE_LOCKED );
        }

        //  add first then delete
        //      - lock database to do updates atomically

        Dbase_LockDatabase();

        //
        //  DEVNOTE: may need type delete for WINS!
        //      otherwise, missed WINS may be in database
        //      after install LOCAL WINS
        //

        if ( pRecord )
        {
            status = Flat_RecordRead(
                        pZone,
                        pNode,
                        pRecord,
                        & prr );
            if ( status != ERROR_SUCCESS )
            {
                goto ZoneUpdateFailed;
            }
            ASSERT( prr );
            if ( !prr )
            {
                goto ZoneUpdateFailed;
            }

            pupdate = Up_CreateAppendUpdate(
                            & updateList,
                            pNode,
                            prr,
                            0,
                            NULL );

            //  update WINS record
            //  never age it
            //
            //  DEVNOTE: not clear why we're doing this

            status = RR_UpdateAdd(
                        pZone,
                        pNode,
                        prr,
                        pupdate,
                        DNSUPDATE_ADMIN | DNSUPDATE_AGING_OFF
                        );
            if ( status != ERROR_SUCCESS )
            {
                goto ZoneUpdateFailed;
            }
        }

        //
        //  delete existing record (NT4)
        //  do not care if doesn't find record as long as able to
        //      handle operation
        //

        if ( pDeleteRR && !prr )
        {
            status = RR_ListDeleteMatchingRecordHandle(
                        pNode,
                        pDeleteRR,
                        &updateList
                        );
            if ( status != ERROR_SUCCESS )
            {
                IF_NOMEM( status == DNS_ERROR_NO_MEMORY )
                {
                    goto ZoneUpdateFailed;
                }
                status = ERROR_SUCCESS;
            }
        }

        //
        //  no record always means remove WINS lookup
        //
        //  this removes LOCAL WINS in all cases, it only removes DATABASE
        //  WINS for primary
        //

        if ( !pRecord )
        {
            Wins_StopZoneWinsLookup( pZone );
            status = ERROR_SUCCESS;
        }

        pZone->fRootDirty = TRUE;
        Dbase_UnlockDatabase();
        status = Up_ExecuteUpdate(
                    pZone,
                    &updateList,
                    DNSUPDATE_ADMIN );

        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( RPC, (
                "Error <%lu>: updateWinsRecord failed update\n",
                status ));
        }
    }

    //
    //  secondary zone
    //
    //  note, can not delete anything from database, let WINS create
    //  routine reset any pointers properly
    //

    else if ( IS_ZONE_SECONDARY(pZone) )
    {
        if ( !Zone_LockForAdminUpdate(pZone) )
        {
            return( DNS_ERROR_ZONE_LOCKED );
        }
        fsecondaryLock = TRUE;

        if ( pRecord )
        {
            //  set as LOCAL as NT4 admin isn't setting flag properly
            //
            //  DEVNOTE: ultimately should reject non-local updates from secondary

            pRecord->Data.WINS.dwMappingFlag |= DNS_WINS_FLAG_LOCAL;

            status = Flat_RecordRead(
                        pZone,
                        pNode,
                        pRecord,
                        & prr );
            if ( status != ERROR_SUCCESS )
            {
                goto Done;
            }
            ASSERT( prr );
            if ( !prr )
            {
                goto Done;
            }

            status = Wins_RecordCheck(
                        pZone,
                        pNode,
                        prr
                        );
            if ( status != DNS_INFO_ADDED_LOCAL_WINS )
            {
                ASSERT( status != ERROR_SUCCESS );
                goto Done;
            }
            Zone_GetZoneInfoFromResourceRecords( pZone );
        }

        //  if no record delete LOCAL WINS

        else
        {
            Wins_StopZoneWinsLookup( pZone );
        }
        status = ERROR_SUCCESS;
    }
    else
    {
        return( ERROR_INVALID_PARAMETER );
    }

Done:

    //  zone is always dirty after this operation, even if secondary

    pZone->fDirty = TRUE;

    if ( fsecondaryLock )
    {
        Zone_UnlockAfterAdminUpdate( pZone );
    }

    DNS_DEBUG( RPC, (
        "Leave updateWinsRecord():\n"
        "\tstatus = %p\n",
        status ));

    return( status );

ZoneUpdateFailed:

    DNS_DEBUG( RPC, (
        "Leave updateWinsRecord():\n"
        "\tstatus = %d (%p)\n",
        status, status ));

    RR_Free( prr );
    Dbase_UnlockDatabase();
    Zone_UnlockAfterAdminUpdate( pZone );
    return status;
}

//
//  End of rrrpc.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\rrwire.c ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    rrwire.c

Abstract:

    Domain Name System (DNS) Server

    Resource record read from wire routines for specific types.

Author:

    Jim Gilroy (jamesg)     Novemeber 1996

Revision History:

--*/


#include "dnssrv.h"
#include <stddef.h>


//
//  DEVNOTE: WireRead flat copy routines (?)
//  DEVNOTE: flat copy of known length routine? (?)
//
//      AAAA and LOC fall into this category
//      FLAT copy from wire BUT must match know length
//
//  Also
//      - plain vanilla flat copy (unknown types)
//      - flat copy and validate (TEXT types)
//          (fixed types could fall here with the validation,
//              catching length issue)
//



PDB_RECORD
AWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Read A record wire format into database record.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    PDB_RECORD  prr;

    if ( wLength != SIZEOF_IP_ADDRESS )
    {
        //return( DNS_ERROR_RCODE_FORMAT_ERROR );
        return( NULL );
    }

    //  allocate record

    prr = RR_Allocate( wLength );
    IF_NOMEM( !prr )
    {
        //return( DNS_ERROR_NO_MEMORY );
        return( NULL );
    }

    prr->Data.A.ipAddress = *(UNALIGNED DWORD *) pchData;
    return( prr );
}


#if 0

PDB_RECORD
AaaaWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Read AAAA record wire format into database record.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    PDB_RECORD  prr;

    if ( wLength != sizeof(IP6_ADDRESS) )
    {
        //return( DNS_ERROR_RCODE_FORMAT_ERROR );
        return( NULL );
    }

    //  allocate record

    prr = RR_Allocate( wLength );
    IF_NOMEM( !prr )
    {
        //return( DNS_ERROR_NO_MEMORY );
        return( NULL );
    }

    RtlCopyMemory(
        & prr->Data.AAAA.ipv6Address,
        pchData,
        wLength );

    return( prr );
}
#endif


#if 0

PDB_RECORD
A6WireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Read A6 record wire format into database record.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    DBG_FN( "A6WireRead" )

    PDB_RECORD      prr;
    PCHAR           pch = pchData;
    PCHAR           pchend = pchData + wLength;
    UCHAR           prefixBits;
    COUNT_NAME      prefixName;

    if ( wLength < 1 )
    {
        // Must have at least 1 octet for prefix length.
        return( NULL );
    }

    // Read the length of the prefix field in bits and skip over
    // the prefix length and address suffix field.

    prefixBits = * ( PUCHAR ) pch;
    pch += sizeof( UCHAR ) +            // length field
           prefixBits / 8 +             // integral bytes of prefix
           ( prefixBits % 8 ) ? 1 : 0;  // one more byte if not integral

    // Read the prefix name.

    pch = Name_PacketNameToCountName(
                & prefixName,
                pMsg,
                pch,
                pchend );
    if ( !pch || pch >= pchend )
    {
        DNS_PRINT(( "%s: "
            "pch = %p\n"
            "pchend = %p\n",
            fn,
            pch,
            pchend ));
        return( NULL );
    }

    //  Allocate record.

    prr = RR_Allocate( ( WORD ) (
                SIZEOF_A6_FIXED_DATA + 
                Name_SizeofDbaseNameFromCountName( & prefixName ) ) );
    IF_NOMEM( !prr )
    {
        return( NULL );
    }

    // Fill out fields in the record.

    prr->Data.A6.chPrefixBits = prefixBits;

    RtlZeroMemory( prr->Data.A6.AddressSuffix,
                   SIZEOF_A6_ADDRESS_SUFFIX_LENGTH );
    RtlCopyMemory(
        prr->Data.A6.AddressSuffix,
        pchData + sizeof( UCHAR ),
        SIZEOF_A6_ADDRESS_SUFFIX_LENGTH );

    Name_CopyCountNameToDbaseName(
        & prr->Data.A6.namePrefix,
        & prefixName );

    return( prr );
} // A6WireRead
#endif



PDB_RECORD
OptWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Read OPT record wire format into database record.

    See RFC2671 for OPT specification.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    DBG_FN( "OptWireRead" )

    PDB_RECORD      prr;

    //  Allocate record.

    prr = RR_Allocate( wLength );
    IF_NOMEM( !prr )
    {
        return( NULL );
    }

    // Fill out fields in the record.

    // JJW: Should payload and extended flags be macros or something?
    //      Since they're only copies there no real need to have
    //      separate members.

    prr->Data.OPT.wUdpPayloadSize = pParsedRR->wClass;
    prr->Data.OPT.dwExtendedFlags = pParsedRR->dwTtl;

    // EDNS1+: parse RDATA into attribute,value pairs here.

    return( prr );
} // OptWireRead



PDB_RECORD
CopyWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Read from wire all types for which the database format is
    identical to the wire format (no indirection).

    Types included:
        HINFO
        ISDN
        X25
        WKS
        TXT
        NULL
        AAAA
        KEY

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    PDB_RECORD  prr;

    //
    //  allocate record
    //

    prr = RR_Allocate( wLength );
    IF_NOMEM( !prr )
    {
        // return( DNS_ERROR_NO_MEMORY );
        return( NULL );
    }

    //
    //  DEVNOTE: should do post build validity check
    //

    RtlCopyMemory(
        & prr->Data.TXT,
        pchData,
        wLength );

    return( prr );
}



PDB_RECORD
PtrWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Process PTR compatible record from wire.
    Includes: PTR, NS, CNAME, MB, MR, MG, MD, MF

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    PDB_RECORD  prr;
    PCHAR       pch;
    PCHAR       pchend = pchData + wLength;
    DNS_STATUS  status;
    DWORD       length;
    COUNT_NAME  nameTarget;

    //
    //  get length of PTR name
    //

    pch = pchData;

    pch = Name_PacketNameToCountName(
                & nameTarget,
                pMsg,
                pch,
                pchend
                );
    if ( pch != pchend )
    {
        //status = DNS_ERROR_INVALID_NAME;
        return( NULL );
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD)  Name_SizeofDbaseNameFromCountName( &nameTarget ) );
    IF_NOMEM( !prr )
    {
        //status = DNS_ERROR_NO_MEMORY;
        return( NULL );
    }

    //
    //  copy in name
    //

    Name_CopyCountNameToDbaseName(
           & prr->Data.PTR.nameTarget,
           & nameTarget );

    return( prr );
}



PDB_RECORD
MxWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Read MX compatible record from wire.
    Includes: MX, RT, AFSDB

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    PDB_RECORD  prr;
    PCHAR       pch;
    PCHAR       pchend = pchData + wLength;
    DNS_STATUS  status;
    DWORD       length;
    COUNT_NAME  nameExchange;

    //
    //  skip fixed data
    //

    pch = pchData;
    pch += SIZEOF_MX_FIXED_DATA;
    if ( pch >= pchend )
    {
        //return( DNS_ERROR_RCODE_FORMAT_ERROR );
        return( NULL );
    }

    //
    //  read name
    //      - MX exchange
    //      - RT exchange
    //      - AFSDB hostname
    //

    pch = Name_PacketNameToCountName(
                & nameExchange,
                pMsg,
                pch,
                pchend
                );
    if ( pch != pchend )
    {
        //status = DNS_ERROR_INVALID_NAME;
        return( NULL );
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD) (
                SIZEOF_MX_FIXED_DATA +
                Name_SizeofDbaseNameFromCountName( &nameExchange ) ) );
    IF_NOMEM( !prr )
    {
        //status = DNS_ERROR_NO_MEMORY;
        return( NULL );
    }

    //
    //  MX preference value
    //  RT preference
    //  AFSDB subtype
    //

    prr->Data.MX.wPreference = *(UNALIGNED WORD *) pchData;

    //
    //  copy in name
    //

    Name_CopyCountNameToDbaseName(
           & prr->Data.MX.nameExchange,
           & nameExchange );

    return( prr );
}



PDB_RECORD
SoaWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Read SOA record from wire.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    PDB_RECORD  prr;
    PCHAR       pch;
    PCHAR       pchend = pchData + wLength;
    DNS_STATUS  status;
    DWORD       length1;
    DWORD       length2;
    PDB_NAME    pname;
    COUNT_NAME  name1;
    COUNT_NAME  name2;

    DNS_PRINT((
        "pchData    = %p; offset %d\n"
        "wLength    = %d\n"
        "pchend     = %p\n"
        "pMsg       = %p\n",
        pchData, DNSMSG_OFFSET( pMsg, pchData ),
        wLength,
        pchend,
        pMsg ));

    //
    //  read SOA names
    //      - primary server
    //      - zone admin
    //

    pch = pchData;

    pch = Name_PacketNameToCountName(
                & name1,
                pMsg,
                pch,
                pchend
                );
    if ( !pch || pch >= pchend )
    {
        //status = DNS_ERROR_INVALID_NAME;
        DNS_PRINT((
            "pch = %p\n"
            "pchend = %p\n",
            pch,
            pchend ));
        return( NULL );
    }

    DNS_PRINT((
        "after first name:  pch = %p; offset from pchData %d\n"
        "pchend = %p\n",
        pch, pch-pchData,
        pchend ));

    pch = Name_PacketNameToCountName(
                & name2,
                pMsg,
                pch,
                pchend
                );
    if ( pch+SIZEOF_SOA_FIXED_DATA != pchend )
    {
        //status = DNS_ERROR_INVALID_NAME;
        DNS_PRINT((
            "pch = %p\n"
            "pchend = %p\n",
            pch,
            pchend ));
        return( NULL );
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD) (
                SIZEOF_SOA_FIXED_DATA +
                Name_SizeofDbaseNameFromCountName( &name1 ) +
                Name_SizeofDbaseNameFromCountName( &name2 ) ) );
    IF_NOMEM( !prr )
    {
        //status = DNS_ERROR_NO_MEMORY;
        return( NULL );
    }

    //
    //  copy SOA fixed fields following names
    //      - dwSerialNo
    //      - dwRefresh
    //      - dwRetry
    //      - dwExpire
    //      - dwMinimumTtl
    //

    RtlCopyMemory(
        & prr->Data.SOA.dwSerialNo,
        pch,
        SIZEOF_SOA_FIXED_DATA );

    //
    //  copy in names
    //

    pname = &prr->Data.SOA.namePrimaryServer;

    Name_CopyCountNameToDbaseName(
        pname,
        & name1 );

    pname = (PDB_NAME) Name_SkipDbaseName( pname );

    Name_CopyCountNameToDbaseName(
        pname,
        & name2 );

    return( prr );
}



PDB_RECORD
MinfoWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Read MINFO and RP records from wire.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    PDB_RECORD  prr;
    PCHAR       pch;
    PCHAR       pchend = pchData + wLength;
    DNS_STATUS  status;
    DWORD       length1;
    DWORD       length2;
    PDB_NAME    pname;
    COUNT_NAME  name1;
    COUNT_NAME  name2;

    //
    //  get length of MINFO names
    //

    pch = pchData;

    pch = Name_PacketNameToCountName(
                & name1,
                pMsg,
                pch,
                pchend
                );
    if ( !pch || pch >= pchend )
    {
        //status = DNS_ERROR_INVALID_NAME;
        return( NULL );
    }

    pch = Name_PacketNameToCountName(
                & name2,
                pMsg,
                pch,
                pchend
                );
    if ( pch != pchend )
    {
        //status = DNS_ERROR_INVALID_NAME;
        return( NULL );
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD) (
                Name_SizeofDbaseNameFromCountName( &name1 ) +
                Name_SizeofDbaseNameFromCountName( &name2 ) ) );
    IF_NOMEM( !prr )
    {
        //status = DNS_ERROR_NO_MEMORY;
        return( NULL );
    }

    //
    //  copy in names
    //

    pname = &prr->Data.MINFO.nameMailbox;

    Name_CopyCountNameToDbaseName(
        pname,
        & name1 );

    pname = (PDB_NAME) Name_SkipDbaseName( pname );

    Name_CopyCountNameToDbaseName(
        pname,
        & name2 );

    return( prr );
}



PDB_RECORD
SrvWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Read SRV record from wire.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    PDB_RECORD  prr;
    PCHAR       pch;
    PCHAR       pchend = pchData + wLength;
    DNS_STATUS  status;
    DWORD       length;
    COUNT_NAME  nameTarget;

    //
    //  skip fixed data and get length of SRV target name
    //

    pch = pchData;
    pch += SIZEOF_SRV_FIXED_DATA;
    if ( pch >= pchend )
    {
        return( NULL );
    }

    //
    //  read SRV target host name
    //

    pch = Name_PacketNameToCountName(
                & nameTarget,
                pMsg,
                pch,
                pchend
                );
    if ( pch != pchend )
    {
        //status = DNS_ERROR_INVALID_NAME;
        return( NULL );
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD) (
                SIZEOF_SRV_FIXED_DATA +
                Name_SizeofDbaseNameFromCountName( &nameTarget ) ) );
    IF_NOMEM( !prr )
    {
        //status = DNS_ERROR_NO_MEMORY;
        return( NULL );
    }

    //
    //  SRV fixed values
    //

    pch = pchData;
    prr->Data.SRV.wPriority = *(UNALIGNED WORD *) pch;
    pch += sizeof( WORD );
    prr->Data.SRV.wWeight = *(UNALIGNED WORD *) pch;
    pch += sizeof( WORD );
    prr->Data.SRV.wPort = *(UNALIGNED WORD *) pch;
    pch += sizeof( WORD );

    //
    //  copy in name
    //

    Name_CopyCountNameToDbaseName(
           & prr->Data.SRV.nameTarget,
           & nameTarget );

    return( prr );
}



PDB_RECORD
WinsWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Read WINS-R record from wire.

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    PDB_RECORD  prr;

    //
    //  allocate record -- record is flat copy
    //

    if ( wLength < MIN_WINS_SIZE )
    {
        // DNS_ERROR_RCODE_FORMAT_ERROR
        return( NULL );
    }
    prr = RR_Allocate( wLength );
    IF_NOMEM( !prr )
    {
        //status = DNS_ERROR_NO_MEMORY;
        return( NULL );
    }

    //
    //  WINS database and wire formats identical EXCEPT that
    //  WINS info is repeatedly used, so violate convention
    //  slightly and keep fixed fields in HOST order
    //

    RtlCopyMemory(
        & prr->Data.WINS,
        pchData,
        wLength );

    //  flip fixed fields

    prr->Data.WINS.dwMappingFlag    = ntohl( prr->Data.WINS.dwMappingFlag );
    prr->Data.WINS.dwLookupTimeout  = ntohl( prr->Data.WINS.dwLookupTimeout );
    prr->Data.WINS.dwCacheTimeout   = ntohl( prr->Data.WINS.dwCacheTimeout );
    prr->Data.WINS.cWinsServerCount = ntohl( prr->Data.WINS.cWinsServerCount );

    //  sanity check length
    //      - the first check is to guard against a specifically manufactured
    //      packet with a VERY large cWinsServerCount which DWORD wraps in
    //      the multipication and validates against the length

    if ( wLength < prr->Data.WINS.cWinsServerCount ||
         wLength != SIZEOF_WINS_FIXED_DATA
                    + (prr->Data.WINS.cWinsServerCount * sizeof(IP_ADDRESS)) )
    {
        // DNS_ERROR_RCODE_FORMAT_ERROR
        RR_Free( prr );
        return( NULL );
    }

    return( prr );
}



PDB_RECORD
NbstatWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Read WINS-R record from wire.

Arguments:

    prr - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    PDB_RECORD  prr;
    PCHAR       pch;
    PCHAR       pchend = pchData + wLength;
    DNS_STATUS  status;
    DWORD       length;
    COUNT_NAME  nameResultDomain;

    //
    //  skip fixed data and get length of WINSR result domain
    //

    pch = pchData;
    pch += SIZEOF_NBSTAT_FIXED_DATA;

    if ( pch >= pchend )
    {
        //return( DNS_ERROR_RCODE_FORMAT_ERROR );
        return( NULL );
    }

    //
    //  read result domain name
    //

    pch = Name_PacketNameToCountName(
                & nameResultDomain,
                pMsg,
                pch,
                pchend
                );
    if ( pch != pchend )
    {
        //status = DNS_ERROR_INVALID_NAME;
        return( NULL );
    }

    //
    //  allocate record
    //

    prr = RR_Allocate( (WORD) (
                SIZEOF_NBSTAT_FIXED_DATA +
                Name_SizeofDbaseNameFromCountName( &nameResultDomain ) ) );
    IF_NOMEM( !prr )
    {
        //status = DNS_ERROR_NO_MEMORY;
        return( NULL );
    }

    //
    //  copy fixed fields
    //
    //  NBSTAT from wire is not used until AFTER zone transfer
    //      completes, so no attempt to detect or reset zone params
    //
    //  NBSTAT info is repeatedly used, so violate convention
    //      slightly and keep flags in HOST order
    //

    prr->Data.WINSR.dwMappingFlag = FlipUnalignedDword( pchData );
    pchData += sizeof( DWORD );
    prr->Data.WINSR.dwLookupTimeout = FlipUnalignedDword( pchData );
    pchData += sizeof( DWORD );
    prr->Data.WINSR.dwCacheTimeout = FlipUnalignedDword( pchData );
    pchData += sizeof( DWORD );

    //
    //  copy in name
    //

    Name_CopyCountNameToDbaseName(
           & prr->Data.WINSR.nameResultDomain,
           & nameResultDomain );

    return( prr );
}



PDB_RECORD
SigWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Read SIG record from wire - DNSSEC RFC 2535

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    PDB_RECORD  prr;
    PCHAR       pch;
    PCHAR       pchend = pchData + wLength;
    DNS_STATUS  status;
    intptr_t    sigLength;
    COUNT_NAME  nameSigner;

    //
    //  Skip fixed data.
    //

    pch = pchData + SIZEOF_SIG_FIXED_DATA;
    if ( pch >= pchend )
    {
        return NULL;
    }

    //
    //  Read signer's name. Compute signature length.
    //

    pch = Name_PacketNameToCountName(
                &nameSigner,
                pMsg,
                pch,
                pchend );

    sigLength = pchend - pch;

    //
    //  Allocate the RR. 
    //

    prr = RR_Allocate( ( WORD ) (
                SIZEOF_SIG_FIXED_DATA +
                COUNT_NAME_SIZE( &nameSigner ) +
                sigLength ) );
    IF_NOMEM( !prr )
    {
        return NULL;
    }

    //
    //  Copy fixed values and signer's name.
    //

    RtlCopyMemory(
        &prr->Data.SIG,
        pchData,
        SIZEOF_SIG_FIXED_DATA );

    Name_CopyCountNameToDbaseName(
           &prr->Data.SIG.nameSigner,
           &nameSigner );

    //
    //  Copy signature.
    //

    RtlCopyMemory(
        ( PBYTE ) &prr->Data.SIG.nameSigner +
            DBASE_NAME_SIZE( &prr->Data.SIG.nameSigner ),
        pch,
        sigLength );

    return prr;
} // SigWireRead



PDB_RECORD
NxtWireRead(
    IN OUT  PPARSE_RECORD   pParsedRR,
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PCHAR           pchData,
    IN      WORD            wLength
    )
/*++

Routine Description:

    Read NXT record from wire - DNSSEC RFC 2535

Arguments:

    pRR - ptr to database record

    pMsg - message being read

    pchData - ptr to RR data field

    wLength - length of data field

Return Value:

    Ptr to new record, if successful.
    NULL on failure.

--*/
{
    PDB_RECORD  prr;
    PCHAR       pch;
    PCHAR       pchend = pchData + wLength;
    DNS_STATUS  status;
    DWORD       sigLength;
    COUNT_NAME  nameNext;

    //
    //  Read nextname.
    //

    pch = Name_PacketNameToCountName(
                &nameNext,
                pMsg,
                pchData,
                pchend );

    //
    //  Allocate the RR.
    //

    prr = RR_Allocate( ( WORD ) (
                SIZEOF_NXT_FIXED_DATA +
                DNS_MAX_TYPE_BITMAP_LENGTH +
                Name_LengthDbaseNameFromCountName( &nameNext ) ) );
    IF_NOMEM( !prr )
    {
        return NULL;
    }

    //
    //  Copy NXT data into new RR.
    //

    Name_CopyCountNameToDbaseName(
           &prr->Data.NXT.nameNext,
           &nameNext );

    RtlCopyMemory(
        &prr->Data.NXT.bTypeBitMap,
        pch,
        pchend - pch );

    return prr;
} // NxtWireRead



//
//  Read RR from wire functions
//

RR_WIRE_READ_FUNCTION   RRWireReadTable[] =
{
    CopyWireRead,       //  ZERO -- default for unspecified types

    AWireRead,          //  A
    PtrWireRead,        //  NS
    PtrWireRead,        //  MD
    PtrWireRead,        //  MF
    PtrWireRead,        //  CNAME
    SoaWireRead,        //  SOA
    PtrWireRead,        //  MB
    PtrWireRead,        //  MG
    PtrWireRead,        //  MR
    CopyWireRead,       //  NULL
    CopyWireRead,       //  WKS
    PtrWireRead,        //  PTR
    CopyWireRead,       //  HINFO
    MinfoWireRead,      //  MINFO
    MxWireRead,         //  MX
    CopyWireRead,       //  TXT
    MinfoWireRead,      //  RP
    MxWireRead,         //  AFSDB
    CopyWireRead,       //  X25
    CopyWireRead,       //  ISDN
    MxWireRead,         //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    SigWireRead,        //  SIG
    CopyWireRead,       //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    CopyWireRead,       //  AAAA
    CopyWireRead,       //  LOC
    NxtWireRead,        //  NXT
    NULL,               //  31
    NULL,               //  32
    SrvWireRead,        //  SRV
    CopyWireRead,       //  ATMA
    NULL,               //  35
    NULL,               //  36
    NULL,               //  37
    NULL,               //  38
    NULL,               //  39
    NULL,               //  40
    OptWireRead,        //  OPT
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //  note these follow, but require OFFSET_TO_WINS_RR subtraction
    //  from actual type value

    WinsWireRead,       //  WINS
    NbstatWireRead      //  WINS-R
};




PDB_RECORD
Wire_CreateRecordFromWire(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PPARSE_RECORD   pParsedRR,
    IN      PCHAR           pchData,
    IN      DWORD           MemTag
    )
/*++

Routine Description:

    Create database record from parsed wire record.

    Hides details of lookup table calls.

Arguments:

    pMsg - ptr to response info

    pParsedRR - parsed info from wire record

    pchData - record location (if no pParsedRR)

    MemTag - tag for dbase record to be created


    DEVNOTE: fix this marking so only done on actual attachment, then
                no node required

Return Value:

    Ptr to database record, if successful.
    NULL if bad record.

--*/
{
    RR_WIRE_READ_FUNCTION   preadFunction;
    PDB_RECORD      prr;
    PCHAR           pch;
    //DNS_STATUS  status;
    WORD            index;
    PARSE_RECORD    tempRR;


    DNS_DEBUG( READ2, (
        "Wire_CreateRecordFromWire() data at %p.\n",
        pchData ));

    //
    //  if no temp record, then pchData assumed to be record data
    //

    if ( !pParsedRR )
    {
        pch = Wire_ParseWireRecord(
                    pchData,
                    DNSMSG_END(pMsg),
                    TRUE,               // require class IN
                    & tempRR );
        if ( !pch )
        {
            DNS_PRINT((
                "ERROR:  bad packet record header on msg %p\n", pMsg ));
            CLIENT_ASSERT( FALSE );
            return( NULL );
        }
        pchData += sizeof(DNS_WIRE_RECORD);
        pParsedRR = &tempRR;
    }

    //
    //  dispatch RR create function for desired type
    //      - all unknown types get flat data copy
    //

    preadFunction = (RR_WIRE_READ_FUNCTION)
                        RR_DispatchFunctionForType(
                            (RR_GENERIC_DISPATCH_FUNCTION *) RRWireReadTable,
                            pParsedRR->wType );
    if ( !preadFunction )
    {
        ASSERT( FALSE );
        return( NULL );
    }

    prr = preadFunction(
            pParsedRR,
            pMsg,
            pchData,
            pParsedRR->wDataLength );

    if ( !prr )
    {
        DNS_PRINT((
            "ERROR:  DnsWireRead routine failure for recordpParsedRR->wType %d.\n\n\n",
           pParsedRR->wType ));
        return( NULL );
    }

    //
    //  reset memtag
    //

    Mem_ResetTag( prr, MemTag );

    //
    //  set TTL, leave in net order -- used directly by zone nodes
    //      so this is valid for XFR and UPDATE
    //      must FLIP for caching
    //

    prr->dwTtlSeconds = pParsedRR->dwTtl;

    prr->dwTimeStamp = 0;

    //
    //  type may not be set in routines
    //

    prr->wType = pParsedRR->wType;

    return( prr );

#if 0
    //
    //  DEVNOTE: error logging section???
    //

PacketError:

    pszclientIp = inet_ntoa( pMsg->RemoteAddress.sin_addr );

    DNS_LOG_EVENT(
        DNS_EVENT_BAD_PACKET_LENGTH,
        1,
        & pszclientIp,
        0 );

    IF_DEBUG( ANY )
    {
        DnsDebugLock();
        DNS_PRINT((
            "Packet error in packet from DNS server %s.\n"
            "\tDiscarding packet.\n",
            pszclientIp
            ));
        Dbg_DnsMessage(
            "Server packet with name error:",
             pMsg );
        DnsDebugUnlock();
    }
    if ( pdbaseRR )
    {
        RR_Free( pdbaseRR );
    }
#endif
}



PCHAR
Wire_ParseWireRecord(
    IN      PCHAR           pchWireRR,
    IN      PCHAR           pchStop,
    IN      BOOL            fClassIn,
    OUT     PPARSE_RECORD   pRR
    )
/*++

Routine Description:

    Parse wire record.

    Reads wire record into database format, and skips to next record.

Arguments:

    pWireRR     -- ptr to wire record

    pchStop     -- end of message, for error checking

    pRR         -- database record to receive record info

Return Value:

    Ptr to start of next record (i.e. next record name)
    NULL if record is bogus -- exceeds packet length.

--*/
{
    register PCHAR      pch;
    register WORD       tempWord;

    DNS_DEBUG( READ2, (
        "ParseWireRecord at %p.\n",
        pchWireRR ));

    IF_DEBUG( READ2 )
    {
        DnsDbg_PacketRecord(
            "Resource Record ",
            (PDNS_WIRE_RECORD) pchWireRR,
            NULL,           // no message header ptr available
            pchStop         // message end
            );
    }

    //
    //  make sure wire record safely within packet
    //

    pRR->pchWireRR = pch = (PCHAR) pchWireRR;

    if ( pch + sizeof(DNS_WIRE_RECORD) > pchStop )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  bad packet, not enough space remaining for"
            "RR structure.\n"
            "\tTerminating caching from packet.\n"
            ));
        DNS_DEBUG( ANY, (
            "ERROR:  bad packet!!!\n"
            "\tRR record (%p) extends beyond message stop at %p\n\n",
            pchWireRR,
            pchStop ));
        goto PacketError;
    }

    //
    //  read record fields
    //      - reject any non-Internet class records
    //        EXCEPT if this is an OPT RR, where CLASS is actually 
    //        the sender's UDP payload size
    //
    //  note:  class and TTL left in NET BYTE ORDER
    //          (strictly a perf issue)
    //

    pRR->wType  = READ_PACKET_HOST_WORD_MOVEON( pch );
    tempWord    = READ_PACKET_NET_WORD_MOVEON( pch );
    if ( pRR->wType != DNS_TYPE_OPT &&
        tempWord != DNS_RCLASS_INTERNET && fClassIn )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  bad packet!!!\n"
            "\tRR record (%p) class %x non-Internet.\n\n",
            pchWireRR,
            tempWord ));
        goto PacketError;
    }
    pRR->wClass         = tempWord;

    pRR->dwTtl          = READ_PACKET_NET_DWORD_MOVEON( pch );
    tempWord            = READ_PACKET_HOST_WORD_MOVEON( pch );
    pRR->wDataLength    = tempWord;

    ASSERT( pch == pchWireRR + sizeof(DNS_WIRE_RECORD) );

    //
    //  verify record data withing message
    //

    pRR->pchData = pch;
    pch += tempWord;
    if ( pch > pchStop )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  bad packet!!!\n"
            "\tRR record (%p) data extends beyond message stop at %p\n\n",
            pchWireRR,
            pchStop ));
        goto PacketError;
    }

    return( pch );

PacketError:

    return( NULL );
}


//
//  End rrwire.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\sdutl.cxx ===
/*******************************************************************
*
*    File        : sdutl.cxx
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996-1999
*    Date        : 8/17/1998
*    Description : DNS 'C' Interface to CSecurityDescriptor class
*
*    Revisions   : <date> <name> <description>
*******************************************************************/



#ifndef SDUTL_CXX
#define SDUTL_CXX


//
// These routines are all non-unicode
//
// #ifdef UNICODE
// Jeff W: Making these routines unicode again!!
// #undef UNICODE
// #endif


// include //


#ifdef __cplusplus
extern "C"
{
#endif
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifdef __cplusplus
}
#endif

#include <windows.h>
#include <stdio.h>


extern "C"
{
#pragma warning (disable : 4200)
#include "dnssrv.h"
}
#include <ntseapi.h>
#include <sddl.h>
#include <dns.h>
#include "csd.h"
#include "lmaccess.h"
#include "lmerr.h"
#include "secobj.h"


// defines //
#define SZ_DNS_ADMIN_GROUP              "DnsAdmins"
#define SZ_DNS_ADMIN_GROUP_W            L"DnsAdmins"


#define MEMTAG_SECURITY     MEMTAG_DS_OTHER


#define NT_FROM_HRESULT(x)      ((NTSTATUS)(x))

//
// From CN=Dns-Node,CN=Schema,CN=Configuration,DC=ntdev,DC=microsoft,DC=com
//      defaultSecurityDescriptor attribute
// DEVNOTE: in the future we may wanna read this dynamically
//
// Problems w/ parsing out the SACL. Let's use w/out the SACL for now
// #define DEFAULT_DNS_NODE_SD_STRING "O:COG:CGD:(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;DA)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;ED)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;SY)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;CO)(A;;RPLCLORC;;;WD)S:(AU;SAFA;WDWOSDDTWPCRCCDCSW;;;WD)"
#define DEFAULT_DNS_NODE_SD_STRING_W L"D:(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;DA)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;BA)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;ED)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;SY)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;CO)(A;;RPLCLORC;;;WD)"

// types //


// global variables //



extern "C"
{

// extern: dns variables that are not available as long as we can't include dnssrv.h
//
// security globals from startup at dns.c (from dnssrv.h)
//

extern  PSECURITY_DESCRIPTOR g_pDefaultServerSD;
extern  PSID g_pServerSid;
extern  PSID g_pServerGroupSid;
extern  PSID g_pAuthenticatedUserSid;
extern  PSID g_pDomainAdminsSid;
extern  PSID g_pEnterpriseControllersSid;
extern  PSID g_pLocalSystemSid;
extern  PSID g_pEveryoneSid;
extern  PSID g_pDynuproxSid;
extern  PSID g_pDnsAdminSid;

// defined in ds.c
extern WCHAR  g_wszDomainFlatName[LM20_DNLEN+1];

}


//
//  Security Descriptor utilities
//

extern "C" {



PSECURITY_DESCRIPTOR
makeSecurityDescriptorCopy(
    IN      CSecurityDescriptor     pCSD
    )
{
    DWORD                   lengthSD;
    PSECURITY_DESCRIPTOR    psd;
    DNS_STATUS              status;

    DNS_DEBUG( SD, ( "makeSecurityDescriptorCopy( %p )\n", pCSD ));

    lengthSD = GetSecurityDescriptorLength( PSECURITY_DESCRIPTOR(pCSD) );

    ASSERT(lengthSD);

    psd = (PSECURITY_DESCRIPTOR) ALLOC_TAGHEAP( lengthSD, MEMTAG_SECURITY );
    IF_NOMEM( !psd )
    {
        DNS_DEBUG( SD, ( "no memory for Client SD!\n" ));
        SetLastError( DNS_ERROR_NO_MEMORY );
        return( NULL );
    }

    //
    //  convert to self relative
    //

    status = RtlAbsoluteToSelfRelativeSD(
                    PSECURITY_DESCRIPTOR( pCSD ),
                    psd,
                    &lengthSD
                    );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( SD, ( "cannot create self-relative SD\n" ));
        if ( psd )
        {
            FREE_HEAP( psd );
        }
        SetLastError( status );
        return( NULL );
    }

    return( psd );
}



NTSTATUS
__stdcall
SD_CreateClientSD(
    OUT     PSECURITY_DESCRIPTOR *  ppClientSD,
    IN      PSECURITY_DESCRIPTOR *  pBaseSD,       OPTIONAL
    IN      PSID                    pOwnerSid,
    IN      PSID                    pGroupSid,
    IN      BOOL                    bAllowWorld
    )
/*+++
Function   : SD_CreateClientSD
Description: Create's a client SD to apply to an update
Parameters : ppClientSD: SD generated to return
Return     : success status (ERROR_SUCCESS on success)
Remarks    : Assumes that we're in client context!!
             Caller must free non-NULL *ppClientSD with LocalFree

DEVNOTE: Consider using DNS_ALL_ACCESS instead of STANDARD_RIGHTS_ALL for mask later.

             free with FREE_HEAP
---*/
{
    DWORD   status=0;
    PSID    pUsr=NULL;
    PSID    pGroup=NULL;
    DWORD   lengthSD=0;
    LPTSTR   pwsSD = NULL;
    PSECURITY_DESCRIPTOR psd = NULL;
    CSecurityDescriptor csd;

    DNS_DEBUG( SD, ( "SD_CreateClientSD()\n" ));

    //
    // create SD from given SD
    // if not given use server default SD.
    //

    psd = pBaseSD ? pBaseSD : g_pDefaultServerSD;

    status = csd.Attach(psd);
    if ( FAILED(status) )
    {
        DNS_DEBUG( SD, ( "Failed to initialize from base SD\n" ));
        return( NT_FROM_HRESULT(status) );
    }

    //
    // modify so that:
    // 1) R/W access allowed to:
    //      - client thread Sid
    //      - process Sid
    //
    status = csd.GetThreadSids( &pUsr, &pGroup, TRUE );
    if ( FAILED(status) )
    {
        DNS_DEBUG( SD, ( "Failed to get thread sids\n" ));
        return( NT_FROM_HRESULT(status) );
    }

    //
    //  apply group & user SID to new SD
    //

    status = csd.Allow( pUsr, GENERIC_ALL );
    if ( FAILED(status) )
    {
        DNS_DEBUG( SD, ( "Failed to allow user\n" ));
        goto Cleanup;
    }

    if ( bAllowWorld )
    {
        //
        // Allow authenticated users (that's what world access means for us)
        //
        DNS_DEBUG( SD, ( "allowing authenticated users access!!\n" ));
        status = csd.Allow( g_pAuthenticatedUserSid, GENERIC_ALL );
        if ( FAILED(status) )
        {
            DNS_DEBUG( SD, ( "Failed to allow authenticated users access\n" ));
            goto Cleanup;
        }
    }

    delete pUsr;
    pUsr = NULL;

    delete pGroup;
    pGroup = NULL;


    //
    //  set owner & group
    //

    status = csd.SetOwner(pOwnerSid, FALSE);
    if ( FAILED(status) )
    {
        DNS_DEBUG( SD, ( "Failed set process user \n" ));
        goto Cleanup;
    }

    status = csd.SetGroup(pGroupSid, FALSE);
    if ( FAILED(status) )
    {
        DNS_DEBUG( SD, ( "Failed to set process group \n" ));
        goto Cleanup;
    }

    //
    //  allocate copy
    //

    lengthSD = GetSecurityDescriptorLength( PSECURITY_DESCRIPTOR(csd) );
    ASSERT(lengthSD);

    psd = (PSECURITY_DESCRIPTOR) ALLOC_TAGHEAP( lengthSD, MEMTAG_SECURITY );
    IF_NOMEM( !psd )
    {
        DNS_DEBUG( SD, ( "no memory for Server SD!\n" ));
        status = DNS_ERROR_NO_MEMORY;
        return( NULL );
    }

    //
    //  convert to self relative
    //

    status = RtlAbsoluteToSelfRelativeSD(
                    PSECURITY_DESCRIPTOR( csd ),
                    psd,
                    &lengthSD
                    );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( SD, ( "cannot create self-relative SD\n" ));
        if ( psd )
        {
            FREE_HEAP( psd );
            psd = NULL;
        }
    }

#if 0
    //
    //  make copy
    //

    psd = makeSecurityDescriptorCopy( csd );
    if ( !psd )
    {
        status = GetLastError();
    }
#endif

    *ppClientSD = psd;

#if DBG
    if ( psd )
    {
        pwsSD = csd.GenerateSDString();  // must free w/ pwsSD
        DNS_DEBUG( SD, ( "SD = %S\n", pwsSD ));
        if ( pwsSD )
        {
            LocalFree(pwsSD);
        }
        else
        {
            DNS_DEBUG( SD, ( "Error<%lu>: cannot generate sd string\n", GetLastError() ));
        }
    }
#endif

Cleanup:

    //
    //  clean up memory
    //
    delete pUsr;
    delete pGroup;

    // return
    return (NTSTATUS)status;
}


NTSTATUS
__stdcall
SD_CreateServerSD(
    OUT PSECURITY_DESCRIPTOR *ppServerSD
    )

/*+++
Function   : SD_CreateServerSD
Description: Creates DNS server default SD to apply to an update
             Basically, for reverting to default dnsNode access description
Parameters : ppClientSD: SD generated to return
Return     : success status (ERROR_SUCCESS on success)
Remarks    : see Dns-Node schema definition to see where we took this from
             //Caller must free non-NULL *ppClientSD with LocalFree

             free with FREE_HEAP

---*/
{

    DWORD status=0;
    DWORD lengthSD=0;
    LPTSTR pwsSD = NULL;
    PSECURITY_DESCRIPTOR psd=NULL;
    CSecurityDescriptor csd;

    DNS_DEBUG( SD, ( "Calling SD_CreateServerSD\n" ));

    if (!ppServerSD)
    {
       return ERROR_INVALID_PARAMETER;
    }

    DNS_DEBUG( SD, ( "Building SD...\n" ));
    //
    // create SD from process (DNS context, not client!)
    //
    status = csd.InitializeFromProcessToken();
    if ( FAILED(status) )
    {
        DNS_DEBUG( SD, ( "Failed to initialize from process token\n" ));
        return (NT_FROM_HRESULT(status));
    }

    status = csd.Attach(DEFAULT_DNS_NODE_SD_STRING_W);
    if ( FAILED(status) )
    {
        DNS_DEBUG( SD, ( "Failed to attach from default SD string\n" ));
        return (NT_FROM_HRESULT(status));
    }

    //
    // set owner & group
    //

    status = csd.SetOwner(g_pServerSid, FALSE);
    if ( FAILED(status) )
    {
        DNS_DEBUG( SD, ( "Failed set process user \n" ));
        goto Cleanup;
    }

    status = csd.SetGroup(g_pServerGroupSid, FALSE);
    if ( FAILED(status) )
    {
        DNS_DEBUG( SD, ( "Failed to set process group \n" ));
        goto Cleanup;
    }

    //
    // Add dnsadmins to SD
    //
    //   DEVNOTE: adding generic rights to SD
    //

    status = csd.Allow(
                 SZ_DNS_ADMIN_GROUP_W,
                 STANDARD_RIGHTS_REQUIRED |             // standard rights
                     DNS_DS_GENERIC_ALL,                // all DS object rights
                 CONTAINER_INHERIT_ACE );

    if ( FAILED(status) )
    {
        DNS_DEBUG( SD, ( "Failed to add dnsadmin group to server SD \n" ));
        goto Cleanup;
    }

    //
    //  allocate copy
    //

    lengthSD = GetSecurityDescriptorLength( PSECURITY_DESCRIPTOR(csd) );
    ASSERT(lengthSD);

    psd = (PSECURITY_DESCRIPTOR) ALLOC_TAGHEAP( lengthSD, MEMTAG_SECURITY );
    IF_NOMEM( !psd )
    {
        DNS_DEBUG( SD, ( "no memory for Server SD!\n" ));
        status = DNS_ERROR_NO_MEMORY;
        return( NULL );
    }

    //
    //  convert to self relative
    //

    status = RtlAbsoluteToSelfRelativeSD(
                    PSECURITY_DESCRIPTOR( csd ),
                    psd,
                    &lengthSD
                    );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( SD, ( "cannot create self-relative SD\n" ));
        if ( psd )
        {
            FREE_HEAP( psd );
            psd = NULL;
        }
    }

    *ppServerSD = psd;


#if DBG
    if ( psd )
    {
        pwsSD = csd.GenerateSDString();  // must free w/ pwsSD
        DNS_DEBUG( SD, ( "SD = %s\n", pwsSD ));
        if ( pwsSD )
        {
            LocalFree(pwsSD);
        }
        else
        {
            DNS_DEBUG( SD, ( "Error<%lu>: cannot generate sd string\n", GetLastError() ));
        }
    }
#endif


Cleanup:

    return (NTSTATUS)status;
}






NTSTATUS __stdcall
SD_GetProcessSids(
    OUT PSID *pServerSid,
    OUT PSID *pServerGroupSid
    )
/*+++
Function   : SD_GetProcessSids
Description: allocates & gets server SIDs (owner & group
Parameters : pServerSID: place holder for allocated user SID,
             pServerGroupSID: place holder for allocated group SID
Return     : success code, ERROR_SUCCESS is good
Remarks    : none.
---*/
{


   if (!pServerSid || !pServerGroupSid)
   {
      DNS_DEBUG( SD, ( "Error: invalid parameters\n" ));
      return ERROR_INVALID_PARAMETER;
   }


   return CSecurityDescriptor::GetProcessSids(pServerSid, pServerGroupSid);
}




NTSTATUS __stdcall
SD_GetThreadSids(
    OUT PSID *pClientSid,
    OUT PSID *pClientGroupSid
    )
/*+++
Function   : SD_GetThreadSids
Description: allocates & gets server SIDs (owner & group
Parameters : pServerSID: place holder for allocated user SID,
             pServerGroupSID: place holder for allocated group SID
Return     : success code, ERROR_SUCCESS is good
Remarks    : none.
---*/
{


   if (!pClientSid || !pClientGroupSid)
   {
      DNS_DEBUG( SD, ( "Error: invalid parameters\n" ));
      return ERROR_INVALID_PARAMETER;
   }


   return CSecurityDescriptor::GetThreadSids(pClientSid,
                                             pClientGroupSid,
                                             TRUE);
}



VOID __stdcall
SD_Delete(
    PVOID pVoid
    )
/*+++
Function   : SD_FreeThreadSids
Description: free up given poiner
Parameters : pVoid: memory to free
Return     : success code, ERROR_SUCCESS is good
Remarks    : Basically, we're supplying this to free up memory allocated
             by C++ new allocator.
---*/
{

    ASSERT( pVoid );

    delete pVoid;

}



NTSTATUS __stdcall
SD_AccessCheck(
    PSECURITY_DESCRIPTOR    IN          pSd,
    PSID                    IN          pSid,
    DWORD                   IN          dwMask,
    PBOOL                   IN OUT      pbAccess)
/*+++
Function   : SD_AccessCheck
Description: Our own little access check to see if given Sid contains specified access (given by mask
             for user (specified by sid)
Parameters : pSd: Security Descriptor, self-relative!
             pSid: user id
             dwMask: access desired
             pbAccess: whether access is given
Return     : status: any failure report, ERROR_SUCCESS on success
             pbAccess: result
Remarks    : DEVNOTE: should probably move to CSecurityDescriptr class later?
---*/
{

   NTSTATUS status = ERROR_SUCCESS;
   BOOL     bDACLPresent;
   BOOL     bDefaulted;
   BOOL     bAccess = FALSE;
   PACL     pDACL = NULL;
   ACCESS_ALLOWED_ACE * pACE = NULL;
   INT      i;
   INT      iFound = 0;
   PSID     pTmpSid = NULL;

   //
   // sanity
   //
   if (!pSd ||
      !pSid ||
      !pbAccess)
   {
      return ERROR_INVALID_PARAMETER;
   }


   // get the existing DACL.
   if ( !GetSecurityDescriptorDacl(pSd, &bDACLPresent, &pDACL, &bDefaulted) ||
        !bDACLPresent ||
        !pDACL )
   {
        status = GetLastError();
        if ( status == ERROR_SUCCESS )
        {
            status = ERROR_ACCESS_DENIED;
        }
        DNS_DEBUG( SD, (
            "sdutl error <%lu>: GetSecurityDescriptorDacl failed\n",
            status ));
        goto Cleanup;
   }

   // cycle ACEs & find access-allowed ones.
   for ( i=0; i < pDACL->AceCount; i++ )
   {
      if ( !GetAce(pDACL, i, (void **)&pACE) )
      {
          status = GetLastError();
          DNS_DEBUG( SD, ( "sdutl error <%lu>: GetAce failed\n", status ));
          goto Cleanup;
      }

      if ( pACE->Header.AceType != ACCESS_ALLOWED_ACE_TYPE )
      {
          DNS_DEBUG( SD, ( "sdutl: unknown ACE type = 0x%x\n", pACE->Header.AceType ));
          continue;
      }

      //
      // Ok, found a known type
      //
      iFound++;

      pTmpSid = (PSID)(&pACE->SidStart);


      //
      // Compare to see if there's access match
      //
      //    DEVNOTE:  this seems broken
      //        do we care ONLY that we have "a" bit, or that we've got
      //        all the bits we need -- it should be the later
      //
      //    DEVNOTE:  you never compare to TRUE
      //

      if ( (pACE->Mask & dwMask) == dwMask
                &&
            RtlEqualSid(pTmpSid, pSid) )
      {
            bAccess = TRUE;
            break;
      }
#if 0
      if ((pACE->Mask & dwMask) &&
          TRUE == RtlEqualSid(pTmpSid, pSid))
      {
            bAccess = TRUE;
            break;
      }
#endif


   }

   if (0 == iFound)
   {
      DNS_DEBUG( SD, ( "sdutl: Could not find known ACEs\n" ));
      status = ERROR_INVALID_PARAMETER;
   }
   else
   {
      //
      // return access check
      //
      *pbAccess = bAccess;
   }



Cleanup:


   return status;
}


#if 0
BOOL __stdcall
SD_IsProxyClient(
    HANDLE  IN  token
    )
/*+++
Function   : SD_IsProxyClientAccess
Description: test if client token has proxy group access (is it a member of dynuprox group
Parameters : client token
Return     : failure code, & results in bAccess
Remarks    : none.
---*/
{
   BOOL bstatus = FALSE;
   NTSTATUS status = ERROR_SUCCESS;

   DNS_DEBUG( SD, ( "Call SD_IsProxyClient... \n", status ));
   status = CSecurityDescriptor::IsSidInTokenGroups(token, g_pDynuproxSid, &bstatus);

   if (status != ERROR_SUCCESS)
   {
      DNS_DEBUG( SD, ( "Error <%lu>: failed to verify sid in token groups\n", status ));
      bstatus = FALSE;
      ASSERT(FALSE);
   }
   DNS_DEBUG( SD, ( "\t%s\n", bstatus ? "TRUE" : "FALSE" ));

   return bstatus;
}
#endif


BOOL
__stdcall
SD_IsProxyClient(
    IN      HANDLE          hToken
    )
/*++

Routine Description:

    Check if client token is in DNS proxies (DHCP servers) group.

Arguments:

    hToken -- handle to token of client (impersonated thread token)

Return Value:

    TRUE -- client is member of DNS proxies.
    FALSE -- not member or error

--*/
{
    BOOL    bresult;

    if ( !g_pDynuproxSid )
    {
        ASSERT( FALSE );
        return( FALSE );
    }

    if ( ! CheckTokenMembership(
                hToken,
                g_pDynuproxSid,
                & bresult ) )
    {
        IF_DEBUG( ANY )
        {
            DNS_STATUS status = GetLastError();

            DNS_PRINT((
                "ERROR:  CheckTokenMembership failed:  %d (%p)\n",
                status, status ));
        }
        bresult = FALSE;
    }

    return( bresult );
}


NTSTATUS __stdcall
SD_LoadDnsAdminGroup(
     VOID
     )
/*++

Routine Description (Dns_LoadDnsAdminGroup):

    Read Dns Admin group info & place in global info
    If group does not exist, will create it.


Arguments:

    None.



Return Value:

    Error code. ERROR_SUCCESS on success.

Remarks:
    None.


--*/
{

    PSID pSid = NULL;
    DWORD status;
    BOOL fMissing = FALSE;
    // we're using an arbitrary big constant, could be smaller.
    WCHAR wszBuffer[DNS_MAX_NAME_LENGTH];
    WCHAR wszFullName[DNS_MAX_NAME_LENGTH];
    LOCALGROUP_INFO_1 grpInfo =
    {
        SZ_DNS_ADMIN_GROUP_W,
        wszBuffer
    };

    //
    // Read DnsAdminGroup
    //

    if ( g_pDnsAdminSid )
    {
        DNS_DEBUG( SD, ( "When do we re-load DnsAdmin group? Here.\n" ));
        ASSERT( FALSE );
        delete g_pDnsAdminSid;
        g_pDnsAdminSid = NULL;
    }

    //
    // Used ALL WIDE chars here to avoid completely breaking on non US domains.
    //

    wsprintf(
        wszFullName,
        L"%s\\%s",
        g_wszDomainFlatName,
        SZ_DNS_ADMIN_GROUP_W );

    DNS_DEBUG( SD, (
        "DnsAdmins groups is \"%S\"\n",
        wszFullName ));

    status = CSecurityDescriptor::GetPrincipalSID(
                 wszFullName,
                 &pSid
                 );

    if ( status == ERROR_SUCCESS )
    {
        DNS_DEBUG( SD, ( "Retrieved DnsAdmin group sid\n" ));
        goto Cleanup;
    }

    //
    //  Load Description string
    //

    if ( !Dns_GetResourceString (
              ID_ADMIN_GROUP_DESCRIPTION,
              wszBuffer,
              DNS_MAX_NAME_LENGTH ) )
    {
        DNS_DEBUG( SD, ( "Failed to get Resource string" ));
        ASSERT( FALSE );
        // use something
        wcscpy( wszBuffer, L"Dns Administrators Group" );
    }

    //
    // Didn't find it. Let's try to create it.
    //
    DNS_DEBUG( SD, (
        "Error %lu: cannot get principal sid for DnsAdmins.\n"
        "Trying to add it.\n",
        status ));

    status = NetLocalGroupAdd(
                              NULL,             // local computer
                              1,                // info level
                              (LPBYTE)&grpInfo, // group name & comment
                              NULL);            // index to param err

    if ( NERR_Success != status )
    {
        DNS_DEBUG( SD, (
            "Error %lu: Failed to create DnsAdmin group\n",
            status ));

        //  if going to ASSERT() on status!=SUCCESS below, then do it here
        //      so we can tell at a glance what failed
        ASSERT( FALSE );
        goto Cleanup;
    }
    fMissing = TRUE;

    //
    // Created. Get group sid
    //
    status = CSecurityDescriptor::GetPrincipalSID(
                                        SZ_DNS_ADMIN_GROUP_W,
                                        &pSid );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( SD, (
            "Error %lu: Failed to get DnsAdmin group sid\n",
            status ));
        //  if going to ASSERT() on status!=SUCCESS below, then do it here
        //      so we can tell at a glance what failed
        ASSERT( FALSE );
        goto Cleanup;
    }

    //
    // created & got sid
    //
    DNS_DEBUG( SD, ( "Retrieved DnsAdmin group sid\n" ));


Cleanup:

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( SD, (
            "Error %lu: cannot create group or get sid of Admin group\n",
            status ));
        ASSERT(FALSE);
    }

    else if ( fMissing )
    {
        // success + created a new dns admin group
        status = DNS_ERROR_NAME_DOES_NOT_EXIST;
    }

    g_pDnsAdminSid = pSid;

    return status;
}





BOOL
__stdcall
SD_IsDnsAdminClient(
    IN      HANDLE          hToken
    )
/*+++
Function   : SD_IsDnsAdminClientAccess
Description:
    test if client token has
        dns admin group  OR
        Administrators group
    in its membership list.

Parameters : client token
Return     : failure code, & results in bAccess
Remarks    : none.
---*/
{
    BOOL        bfoundDnsAdmin = FALSE;
    BOOL        bfoundAdmin = FALSE;
    NTSTATUS    status = ERROR_SUCCESS;
    PSID        padminSid = NULL;


    DNS_DEBUG( SD, ( "SD_IsDnsAdminClient()\n" ));

    //
    //  check for DnsAdmin SID
    //

    status = CSecurityDescriptor::IsSidInTokenGroups(
                                        hToken,
                                        g_pDnsAdminSid,
                                        &bfoundDnsAdmin);
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( SD, ( "Error <%lu>: failed to verify sid in token groups\n", status ));
        bfoundDnsAdmin = FALSE;
        ASSERT(FALSE);
    }

    //
    //  read DomainAdmins SID and check it's access
    //

    status = CSecurityDescriptor::GetPrincipalSID(
                                        L"Domain Admins",
                                        &padminSid );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( SD, (
            "Error <%lu>: failed to get Domain Admins' sid\n",
            status ));
        bfoundAdmin = FALSE;
        goto Cleanup;
    }

    status = CSecurityDescriptor::IsSidInTokenGroups(
                    hToken,
                    padminSid,
                    &bfoundAdmin );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( SD, (
            "Error <%lu>: failed to verify sid in token groups\n",
            status ));
        bfoundAdmin = FALSE;
        ASSERT(FALSE);
    }

Cleanup:

    if ( padminSid )
    {
        delete padminSid;
    }
    return( bfoundAdmin || bfoundDnsAdmin );
}



NTSTATUS
__stdcall
SD_AddPrincipalToSD(
    IN       LPTSTR                 pwszName,
    IN       PSECURITY_DESCRIPTOR   pBaseSD,
    OUT      PSECURITY_DESCRIPTOR * ppNewSD,
    IN       DWORD                  AccessMask,
    IN       DWORD                  AceFlags,      OPTIONAL
    IN       PSID                   pOwner,        OPTIONAL
    IN       PSID                   pGroup,        OPTIONAL
    IN       BOOL                   bWhackExistingAce
    )
/*++

Routine Description (SD_AddPrinicipalToSD):

    Add an ace to security descriptor  based on in params

Arguments:

    pwszName:   user's name to add access
    pBaseSD   : SD to apply access
    ppResultSD: new SD
    AccessMask: what access to give user
    AceFlags:   additional flags such as inheritance
    bWhackExistingAce: if TRUE, remove existing ACE before adding new one

Return Value:

    success status

Remarks:
    ppNewSD must be freed w/ LocalFree


--*/
{
    DWORD                   status;
    CSecurityDescriptor     csd;
    PSECURITY_DESCRIPTOR    psd = NULL;
    DWORD                   lengthSD;
    PSID                    pUsrSid = pOwner ? pOwner : g_pServerSid;
    PSID                    pGrpSid = pGroup ? pGroup : g_pServerGroupSid;


    status = csd.Attach( pBaseSD );
    if ( FAILED( status ) )
    {
        DNS_DEBUG( SD, ( "Failed to initialize from base SD\n" ));
        return( NT_FROM_HRESULT(status) );
    }

    //
    //  Conditionally whack any existing ACE from the ACL. If the principal
    //  already has an ACE we want to over-write it.
    //

    if ( bWhackExistingAce )
    {
        csd.Revoke( pwszName );
    }

    status = csd.Allow(
                pwszName,
                AccessMask,
                AceFlags );

    if ( FAILED(status) )
    {
        DNS_DEBUG( SD, ( "Failed to add %S to SD\n", pwszName ));
        goto Cleanup;
    }

    //
    //  set owner & group
    //

    status = csd.SetOwner( pUsrSid, FALSE );
    if ( FAILED(status) )
    {
        DNS_DEBUG( SD, ( "Failed to set SD owner\n" ));
        goto Cleanup;
    }

    status = csd.SetGroup( pGrpSid, FALSE );
    if ( FAILED(status) )
    {
        DNS_DEBUG( SD, ( "Failed to set SD group\n" ));
        goto Cleanup;
    }

    //
    //  allocate copy
    //

    lengthSD = GetSecurityDescriptorLength( PSECURITY_DESCRIPTOR(csd) );
    ASSERT(lengthSD);

    psd = (PSECURITY_DESCRIPTOR) ALLOC_TAGHEAP( lengthSD, MEMTAG_SECURITY );
    IF_NOMEM( !psd )
    {
        DNS_DEBUG( SD, ( "no memory for Server SD!\n" ));
        status = DNS_ERROR_NO_MEMORY;
        return( NULL );
    }

    //
    //  convert to self relative
    //

    status = RtlAbsoluteToSelfRelativeSD(
                    PSECURITY_DESCRIPTOR( csd ),
                    psd,
                    &lengthSD );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( SD, ( "cannot create self-relative SD\n" ));
        if ( psd )
        {
            FREE_HEAP( psd );
            psd = NULL;
        }
    }

    *ppNewSD = psd;

Cleanup:
    return ( NTSTATUS ) status;
}


NTSTATUS
__stdcall
SD_IsImpersonating(
    VOID
    )
/*++

Routine Description:

    Test if current thread is in impersonation context

Arguments:

    None.

Return Value:

    TRUE: Indeed impersonating right now
    FALSE: Not impersonating (process context).

Remarks:

--*/
{
    HANDLE      htoken;
    BOOL        bstatus;
    TOKEN_TYPE  toktype = TokenImpersonation;    // init on the safe side.
    DWORD       length;

    //
    //  get thread token, if not found use process token
    //

    bstatus = OpenThreadToken(
                  GetCurrentThread(),
                  TOKEN_QUERY,
                  TRUE,             // open as self
                  &htoken
                  );
    if ( !bstatus )
    {
        bstatus = OpenProcessToken(
                      GetCurrentProcess(),
                      TOKEN_QUERY,
                      &htoken
                      );
    }
    ASSERT( bstatus );

    //
    //  check if token type is impersonation
    //

    bstatus = GetTokenInformation(
                  htoken,
                  TokenType,
                  (LPVOID)&toktype,
                  sizeof(toktype),
                  &length );

    ASSERT( length == sizeof(toktype) && bstatus );

    CloseHandle( htoken );

    return( toktype == TokenImpersonation );
}


//---------- end of extern "C" -----------
}

#endif

//
//  End of sdutl.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\sdutl.h ===
/*******************************************************************
*
*    File        : sdutl.h
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996-1999
*    Date        : 8/17/1998
*    Description :
*
*    Revisions   : <date> <name> <description>
*******************************************************************/



#ifndef SDUTL_H
#define SDUTL_H



// include //


// defines //

#define SZ_DNS_ADMIN_GROUP              "DnsAdmins"
#define SZ_DNS_ADMIN_GROUP_W            L"DnsAdmins"



// types //


// global variables //



// prototypes //
NTSTATUS __stdcall
SD_CreateClientSD(
    OUT PSECURITY_DESCRIPTOR *ppClientSD,
    IN PSECURITY_DESCRIPTOR *pBaseSD,       OPTIONAL
    IN PSID pOwnerSid,
    IN PSID pGroupSid,
    IN BOOL bAllowWorld
    );

NTSTATUS __stdcall
SD_CreateServerSD(
    OUT PSECURITY_DESCRIPTOR *ppServerSD
    );

NTSTATUS __stdcall
SD_GetProcessSids(
    OUT PSID *pServerSid,
    OUT PSID *pServerGroupSid
    );

NTSTATUS __stdcall
SD_GetThreadSids(
    OUT PSID *pServerSid,
    OUT PSID *pServerGroupSid);

VOID __stdcall
SD_Delete(
    IN  PVOID pVoid );

NTSTATUS __stdcall
SD_AccessCheck(
    IN      PSECURITY_DESCRIPTOR    pSd,
    IN      PSID                    pSid,
    IN      DWORD                   dwMask,
    IN OUT  PBOOL                   pbAccess);

BOOL __stdcall
SD_IsProxyClient(
      IN  HANDLE  token
      );

NTSTATUS __stdcall
SD_LoadDnsAdminGroup(
     VOID
     );

BOOL __stdcall
SD_IsDnsAdminClient(
    IN  HANDLE  token
    );

NTSTATUS __stdcall
SD_AddPrincipalToSD(
    IN       LPTSTR                 pwszName,
    IN       PSECURITY_DESCRIPTOR   pBaseSD,
    OUT      PSECURITY_DESCRIPTOR * ppNewSD,
    IN       DWORD                  AccessMask,
    IN       DWORD                  AceFlags,      OPTIONAL
    IN       PSID                   pOwner,        OPTIONAL
    IN       PSID                   pGroup,        OPTIONAL
    IN       BOOL                   bWhackExistingAce
    );

NTSTATUS __stdcall
SD_IsImpersonating(
    VOID
    );

#endif

/******************* EOF *********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\send.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    send.c

Abstract:

    Domain Name System (DNS) Server

    Send response routines.

Author:

    Jim Gilroy (jamesg)     January 1995

Revision History:

    jamesg  Jan 1995    -   rewrite generic response routine
    jamesg  Mar 1995    -   flip all counts when recieve packet
                            unflip here before send
                        -   Reject_UnflippedRequest()
    jamesg  Jul 1995    -   convert to generic send routine
                            and move to send.c
    jamesg  Sep 1997    -   improve NameError routine to send cached SOA
                            direct recursive response send

--*/


#include "dnssrv.h"


//
//  Retries on TCP  WSAEWOULDBLOCK error
//
//  This can occur on connection to remote that is backed up and not
//  being as serviced as fast as we can send.   XFR sends which involve
//  lots of data being sent fast, and require significant work by
//  receiver (new thread, new database, lots of nodes to build) can
//  presumably back up.  For standard recursive queries, this just
//  indicates a bogus, malperforming remote DNS.
//

#define WOULD_BLOCK_RETRY_DELTA     (1000)      // 1s retry intervals

#define MAX_WOULD_BLOCK_RETRY       (60)        // 60 retrys, then give up


//
//  Bad packet (bad opcode) suppression
//
//  Keeps list of IPs sending bad packets and just starts dropping
//  packets on the floor if they are in this list.
//

#define BAD_SENDER_SUPPRESS_INTERVAL    (60)        // one minute
#define BAD_SENDER_ARRAY_LENGTH         (10)

typedef struct
{
    IP_ADDRESS  IpAddress;
    DWORD       ReleaseTime;
}
BAD_SENDER, *PBAD_SENDER;

BAD_SENDER  BadSenderArray[ BAD_SENDER_ARRAY_LENGTH ];


//
//  Private protos
//

BOOL
checkAndSuppressBadSender(
    IN OUT  PDNS_MSGINFO    pMsg
    );


DNS_STATUS
Send_Msg(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Send a DNS packet.

    This is the generic send routine used for ANY send of a DNS message.

    It assumes nothing about the message type, but does assume:
        - pCurrent points at byte following end of desired data
        - RR count bytes are in HOST byte order

    Depending on flags in the message and the remote destination, an OPT
    RR may be added to the end of the message. If the query has timeout out
    in the past, do not add an OPT, as the timeout may have been caused by
    MS DNS FORMERR suppression. This is a broad measure but it will work.

Arguments:

    pMsg - message info for message to send

Return Value:

    TRUE if successful.
    FALSE on send error.

--*/
{
    INT         err;
    DNS_STATUS  status = ERROR_SUCCESS;
    UCHAR       remoteEDnsVersion = NO_EDNS_SUPPORT;
    BOOL        wantToSendOpt;
    PBYTE       p;
    WORD        wPayload = ( WORD ) SrvCfg_dwMaxUdpPacketSize;

    #if DBG
    //  HeapDbgValidateAllocList();    
    Mem_HeapHeaderValidate( pMsg );    
    #endif
    
    //
    //  Pre-send processing:
    //  If required, insert an OPT RR at the end of the message. This
    //  RR will be the last RR in the additional section. If this query 
    //  already been sent, it may already have an OPT. In this case the
    //  OPT values should be overwritten to ensure they are current, or
    //  the OPT may need to be deleted.
    //

    wantToSendOpt = 
        pMsg->Opt.fInsertOptInOutgoingMsg &&
        pMsg->nTimeoutCount == 0;
    if ( wantToSendOpt )
    {
        //  Do check in two stages to avoid more expensive bits when possible.

        remoteEDnsVersion = Remote_QuerySupportedEDnsVersion(
                                pMsg->RemoteAddress.sin_addr.s_addr );
        if ( remoteEDnsVersion != UNKNOWN_EDNS_VERSION &&
            !IS_VALID_EDNS_VERSION( remoteEDnsVersion ) )
        {
            wantToSendOpt = FALSE;
        }
    }

    DNS_DEBUG( EDNS, (
        "Send_Msg: %p rem=%d insert=%d opt=%d add=%d wantToSend=%d\n",
        pMsg,
        ( int ) remoteEDnsVersion,
        ( int ) pMsg->Opt.fInsertOptInOutgoingMsg,
        ( int ) pMsg->Opt.wOptOffset,
        ( int ) pMsg->Head.AdditionalCount,
        ( int ) wantToSendOpt ));

    if ( pMsg->Opt.wOptOffset )
    {
        if ( wantToSendOpt )
        {
            //  Msg already has OPT. Overwrite OPT values.
            p = DNSMSG_OPT_PTR( pMsg ) + 3;
            INLINE_WRITE_FLIPPED_WORD( p, wPayload );
            p += sizeof( WORD );
            * ( p++ ) = pMsg->Opt.cExtendedRCodeBits;
            * ( p++ ) = 0;                      //  EDNS version
            * ( p++ ) = 0;                      //  ZERO
            * ( p++ ) = 0;                      //  ZERO
            * ( p++ ) = 0;                      //  RDLEN
            * ( p++ ) = 0;                      //  RDLEN
        }
        else
        {
            // Msg has OPT but we don't want to send it. Remove it.
            pMsg->pCurrent = DNSMSG_OPT_PTR( pMsg );
            ASSERT( pMsg->Head.AdditionalCount > 0 );
            --pMsg->Head.AdditionalCount;
            pMsg->Opt.wOptOffset = 0;
        }
    }
    else
    {
        if ( wantToSendOpt )
        {
            //  Msg has no OPT - add one.

            DB_RECORD   rr;

            pMsg->Opt.wOptOffset = DNSMSG_CURRENT_OFFSET( pMsg );
            p = pMsg->pCurrent;
            RtlZeroMemory( &rr, sizeof( rr ) );
            rr.wType = DNS_TYPE_OPT;
            if ( Wire_AddResourceRecordToMessage(
                    pMsg,
                    DATABASE_ROOT_NODE,     // this gives us the empty name
                    0,                      // name offset
                    &rr,
                    0 ) )
            {
                ++pMsg->Head.AdditionalCount;
            } // if

            p += 3;
            INLINE_WRITE_FLIPPED_WORD( p, wPayload );
            p += sizeof( WORD );
            * ( p++ ) = pMsg->Opt.cExtendedRCodeBits;
            * ( p++ ) = 0;                      //  EDNS version
            * ( p++ ) = 0;                      //  ZERO
            * ( p++ ) = 0;                      //  ZERO
            * ( p++ ) = 0;                      //  RDLEN
            * ( p++ ) = 0;                      //  RDLEN

            //  Should have advanced p all the way through the RR added above.
            ASSERT( p == pMsg->pCurrent );
        }
        //  else Msg has no OPT and we don't want to send one - do nothing.
    }

    //
    //  set for send
    //      - message length
    //      - flip header bytes to net order
    //
    //  log if desired
    //

    pMsg->Head.Reserved = 0;
    pMsg->MessageLength = (WORD)DNSMSG_OFFSET( pMsg, pMsg->pCurrent );

    DNS_LOG_MESSAGE_SEND( pMsg );
    IF_DEBUG( SEND )
    {
        Dbg_DnsMessage(
            "Sending packet",
            pMsg );
    }

    DNSMSG_SWAP_COUNT_BYTES( pMsg );

    //
    //  TCP message, send until all info transmitted
    //

    if ( pMsg->fTcp )
    {
        WORD    wLength;
        PCHAR   pSend;

        //
        //  Clear Truncation bit. Even if the message is genuinely
        //  truncated (if the RRSet is >64K) we don't want to send
        //  a TCP packet with TC set. We could consider logging at
        //  error at this point.
        //

        pMsg->Head.Truncation = 0;

        //
        //  TCP message always begins with bytes being sent
        //
        //      - send length = message length plus two byte size
        //      - flip bytes in message length
        //      - send starting at message length
        //

        wLength = pMsg->MessageLength + sizeof( wLength );

        INLINE_WORD_FLIP( pMsg->MessageLength, pMsg->MessageLength );

        pSend = (PCHAR) & pMsg->MessageLength;

        while ( wLength )
        {
            err = send(
                    pMsg->Socket,
                    pSend,
                    (INT)wLength,
                    0 );

            if ( err == 0 || err == SOCKET_ERROR )
            {
                //
                //  first check for shutdown -- socket close may cause error
                //      - return cleanly to allow thread shutdown
                //

                if ( fDnsServiceExit )
                {
                    goto Done;
                }
                err = GetLastError();

                //
                //  WSAESHUTDOWN is ok, client got timed out connection and
                //      closed
                //
                //  WSAENOTSOCK may also occur if FIN recv'd and connection
                //      closed by TCP receive thread before the send
                //

                if ( err == WSAESHUTDOWN )
                {
                    DNS_DEBUG( ANY, (
                        "WARNING:  send() failed on shutdown TCP socket %d.\n"
                        "\tpMsgInfo at %p\n",
                        pMsg->Socket,
                        pMsg ));
                }
                else if ( err == WSAENOTSOCK )
                {
                    DNS_DEBUG( ANY, (
                        "ERROR:  send() on closed TCP socket %d.\n"
                        "\tpMsgInfo at %p\n",
                        pMsg->Socket,
                        pMsg ));
                }
                else if ( err == WSAEWOULDBLOCK )
                {
                    DNS_DEBUG( ANY, (
                        "ERROR:  send() WSAEWOULDBLOCK on TCP socket %d.\n"
                        "\tpMsgInfo at %p\n",
                        pMsg->Socket,
                        pMsg ));
                }
                else
                {
#if DBG
                    DNS_LOG_EVENT(
                        DNS_EVENT_SEND_CALL_FAILED,
                        0,
                        NULL,
                        NULL,
                        err );
#endif
                    DNS_DEBUG( ANY, ( "ERROR:  TCP send() failed, err = %d.\n", err ));
                }
                status = err;
                goto Done;
            }
            wLength -= (WORD)err;
            pSend += err;
        }

        //
        //  count responses
        //
        //  update connection timeout
        //

        if ( pMsg->Head.IsResponse )
        {
            STAT_INC( QueryStats.TcpResponses );
            PERF_INC( pcTcpResponseSent );
            PERF_INC( pcTotalResponseSent );
            Tcp_ConnectionUpdateTimeout( pMsg->Socket );
        }
        else
        {
            STAT_INC( QueryStats.TcpQueriesSent );
        }
    }

    //
    //  UDP message
    //

    else
    {
        ASSERT( pMsg->MessageLength <= pMsg->MaxBufferLength );
        ASSERT( pMsg->RemoteAddressLength == sizeof(SOCKADDR_IN) );

        //
        //  protect against self-send
        //
        //  note, I don't believe any protection is needed on accessing
        //  g_ServerAddrs;  it does change, but it changes by simple ptr
        //  replacement, and old copy gets timeout free
        //

        if ( !pMsg->Head.IsResponse &&
             Dns_IsAddressInIpArray(
                    g_ServerAddrs,
                    pMsg->RemoteAddress.sin_addr.s_addr ) &&
             pMsg->RemoteAddress.sin_port == DNS_PORT_NET_ORDER )
        {
            LOOKUP_NAME     lookupName = { 0 };

            BYTE    argTypeArray[] =
                        {
                            EVENTARG_IP_ADDRESS,
                            EVENTARG_LOOKUP_NAME
                        };
            PVOID   argArray[] =
                        {
                            ( PVOID ) ( ULONG_PTR )
                                pMsg->RemoteAddress.sin_addr.s_addr,
                            &lookupName
                        };

            //
            //  If this fails, the lookup name should be zero'ed and
            //  logged as an empty string.
            //

            Name_ConvertPacketNameToLookupName(
                        pMsg,
                        pMsg->MessageBody,
                        &lookupName );

            DNS_PRINT((
                "ERROR:  Self-send to address %s!!!\n",
                IP_STRING(pMsg->RemoteAddress.sin_addr.s_addr) ));

            err = DNS_ERROR_INVALID_IP_ADDRESS;

            Log_Printf(
                "DNS server is sending to itself on IP %s.\r\n"
                "Self send message header follows:\r\n",
                IP_STRING(pMsg->RemoteAddress.sin_addr.s_addr) );

            Log_Message(
                pMsg,
                TRUE,
                TRUE    // force print
                );

            DNS_LOG_EVENT(
                DNS_EVENT_SELF_SEND,
                sizeof( argTypeArray ) / sizeof( argTypeArray[ 0 ] ),
                argArray,
                argTypeArray,
                err );

            status = err;
            goto Done;
        }

        //
        //  Set truncation bit. Is this the right place to do this, or
        //  will it already be set?
        //

        if ( pMsg->MessageLength >
            ( pMsg->Opt.wUdpPayloadSize > 0 ?
                pMsg->Opt.wUdpPayloadSize :
                DNS_RFC_MAX_UDP_PACKET_LENGTH ) )
        {
            pMsg->Head.Truncation = 1;
        }

        err = sendto(
                    pMsg->Socket,
                    (PCHAR) DNS_HEADER_PTR(pMsg),
                    pMsg->MessageLength,
                    0,
                    (PSOCKADDR)&pMsg->RemoteAddress,
                    pMsg->RemoteAddressLength
                    );

        if ( err == SOCKET_ERROR )
        {
            //
            //  first check for shutdown -- socket close may cause error
            //      - return cleanly to allow thread shutdown
            //

            if ( fDnsServiceExit )
            {
                goto Done;
            }

            err = GetLastError();
            if ( err == WSAENETUNREACH || err == WSAEHOSTUNREACH )
            {
                DNS_DEBUG( SEND, (
                    "WARNING:  sendto() failed with %d for packet %p\n",
                    err,
                    pMsg ));
            }
            else if ( err == WSAEWOULDBLOCK )
            {
                DNS_DEBUG( ANY, (
                    "WARNING:  sendto() failed with WOULDBLOCK for packet %p\n",
                    pMsg ));
            }
            else
            {
                IF_DEBUG( ANY )
                {
                    DNS_PRINT(( "ERROR:  UDP sendto() failed.\n" ));
                    DnsDbg_SockaddrIn(
                        "sendto() failed sockaddr\n",
                        &pMsg->RemoteAddress,
                        pMsg->RemoteAddressLength );
                    Dbg_DnsMessage(
                        "sendto() failed message",
                        pMsg );
                }
#if DBG
                DNS_LOG_EVENT(
                    DNS_EVENT_SENDTO_CALL_FAILED,
                    0,
                    NULL,
                    NULL,
                    err );
#endif
            }
            status = err;
            goto Done;
        }

        if ( err != pMsg->MessageLength )
        {
            DNS_DEBUG( SEND, (
                "WARNING: sendto() on msg %p returned %d but expected %d\n"
                "\nGetLastError() = %d\n",
                pMsg,
                err,
                pMsg->MessageLength,
                GetLastError() ));
        }
        ASSERT( err == pMsg->MessageLength );

        //
        //  count sends query\response
        //

        if ( pMsg->Head.IsResponse )
        {
            STAT_INC( QueryStats.UdpResponses );
            PERF_INC( pcUdpResponseSent );
            PERF_INC( pcTotalResponseSent );
        }
        else
        {
            STAT_INC( QueryStats.UdpQueriesSent );
        }
    }

Done:

    //
    //  delete query, if desired
    //

    if ( pMsg->fDelete )
    {
        ASSERT( !pMsg->fRecursePacket );
        Packet_Free( pMsg );
    }
    else
    {
        DNSMSG_SWAP_COUNT_BYTES( pMsg );

        DNS_DEBUG( SEND, (
            "No delete after send of message at %p.\n",
            pMsg ));
    }
    return( status );
}




DNS_STATUS
Send_ResponseAndReset(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Send a DNS packet and reset for reuse.

    It assumes nothing about the message type, but does assume:
        - pCurrent points at byte following end of desired data
        - RR count bytes are in HOST byte order

    After send message info reset for reuse:
        - pCurrent reset to point after original question
        - AvailLength reset appropriately
        - RR count bytes returned to HOST byte order

Arguments:

    pMsg - message info for message to send and reuse

Return Value:

    TRUE if send successful.
    FALSE otherwise.

--*/
{
    DNS_STATUS  status;
    DWORD       blockRetry;

    //
    //  set as response and send
    //      - no delete after send

    pMsg->fDelete = FALSE;
    pMsg->Head.IsResponse = TRUE;
    pMsg->Head.RecursionAvailable = SrvCfg_fRecursionAvailable ? TRUE : FALSE;


    //
    //  send -- protecting against WOULDBLOCK error
    //
    //  WOULDBLOCK can occur when remote does not RESET connection
    //  but does not read receive buffer either (ie. not servicing
    //  connection);
    //  XFR sends which involve lots of data being sent fast, and
    //  require significant work by receiver (new thread, new database,
    //  lots of nodes to build) can presumably back up.  For standard
    //  recursive queries, this just indicates a bogus, malperforming
    //  remote DNS.
    //
    //  retry once a second up to 60 seconds then bail;
    //

    blockRetry = 0;
    do
    {
        status = Send_Msg( pMsg );
        if ( status != WSAEWOULDBLOCK )
        {
            break;
        }

        Sleep( WOULD_BLOCK_RETRY_DELTA );
        blockRetry++;
    }
    while ( blockRetry < MAX_WOULD_BLOCK_RETRY );

    //
    //  reset
    //      - point again immediately after question or after header
    //          if no question
    //      - reset available length
    //      - clear response counts
    //      - clear turncation
    //      - reset compression table
    //          - zero if no question
    //          - one (to include question) if question
    //          (this helps in XFR where zone is question)
    //
    //  note that Authority and ResponseCode are unchanged
    //

    INITIALIZE_COMPRESSION( pMsg );

    if ( pMsg->Head.QuestionCount )
    {
        pMsg->pCurrent = (PCHAR)(pMsg->pQuestion + 1);

        //  note this routine works even if pnode is NULL

        Name_SaveCompressionWithNode(
            pMsg,
            pMsg->MessageBody,
            pMsg->pNodeQuestion );
    }
    else
    {
        pMsg->pCurrent = pMsg->MessageBody;
    }

    pMsg->Head.AnswerCount = 0;
    pMsg->Head.NameServerCount = 0;
    pMsg->Head.AdditionalCount = 0;
    pMsg->Head.Truncation = 0;

    return( status );
}



VOID
Send_Multiple(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      PIP_ARRAY       aipSendAddrs,
    IN OUT  PDWORD          pdwStatCount    OPTIONAL
    )
/*++

Routine Description:

    Send a DNS packet to multiple destinations.

    Assumes packet is in same state as normal send
        - host order count and XID
        - pCurrent pointing at byte after desired data

Arguments:

    pMsg - message info for message to send and reuse

    aipSendAddrs - IP array of addrs to send to

    pdwStatCount - addr of stat to update with number of sends

Return Value:

    None.

--*/
{
    DWORD   i;
    BOOLEAN fDelete;

    //
    //  save delete for after sends
    //

    fDelete = pMsg->fDelete;
    pMsg->fDelete = FALSE;

    //
    //  send the to each address specified in IP array
    //

    if ( aipSendAddrs )
    {
        for ( i=0; i < aipSendAddrs->AddrCount; i++ )
        {
            pMsg->RemoteAddress.sin_addr.s_addr = aipSendAddrs->AddrArray[i];
            Send_Msg( pMsg );
        }

        //  stats update

        if ( pdwStatCount )
        {
            *pdwStatCount += aipSendAddrs->AddrCount;
        }
    }

    if ( fDelete )
    {
        Packet_Free( pMsg );
    }
}



VOID
setResponseCode(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      WORD            ResponseCode
    )
/*++

Routine Description:

    Sets the ResponseCode in the message. If the ResponseCode is bigger
    than 4 bits, we must include an OPT in the response. With EDNS0, the
    ResponseCode can be up to 12 bits long.

Arguments:

    pMsg -- query to set ResponseCode in 

    ResponseCode -- failure response code

Return Value:

    None.

--*/
{
    if ( ResponseCode > DNS_RCODE_MAX )
    {
        pMsg->Opt.fInsertOptInOutgoingMsg = TRUE;
        pMsg->Opt.wUdpPayloadSize = ( WORD ) SrvCfg_dwMaxUdpPacketSize;
        pMsg->Opt.cVersion = 0;     // max version supported by server
        pMsg->Opt.cExtendedRCodeBits = ( ResponseCode >> 4 ) & 0xFF;
    }
    pMsg->Head.ResponseCode = ( BYTE ) ( ResponseCode & 0xF );
}



VOID
Reject_UnflippedRequest(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      WORD            ResponseCode,
    IN      DWORD           Flags
    )
/*++

Routine Description:

    Send failure response to query with unflipped bytes.

Arguments:

    pMsg -- query to respond to;  its memory is freed

    ResponseCode -- failure response code

    Flags -- flags modify way rejection is handled (DNS_REJECT_XXX)

Return Value:

    None.

--*/
{
    //
    //  flip header count bytes
    //      - they are flipped in Send_Response()
    //

    DNSMSG_SWAP_COUNT_BYTES( pMsg );
    Reject_Request( pMsg, ResponseCode, Flags );
    return;

}  // Reject_UnflippedRequest



VOID
Reject_Request(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      WORD            ResponseCode,
    IN      DWORD           Flags
    )
/*++

Routine Description:

    Send failure response to query.

Arguments:

    pMsg -- query to respond to;  its memory is freed

    ResponseCode -- failure response code

    Flags -- flags modify way rejection is handled (DNS_REJECT_XXX)

Return Value:

    None.

--*/
{
    DNS_DEBUG( RECV, ( "Rejecting packet at %p.\n", pMsg ));

    //
    //  clear any packet building we did
    //
    //  DEVNOTE: make packet building clear a macro, and use only when needed
    //      problem rejecting responses from other name servers that have
    //      these fields filled
    //

    pMsg->pCurrent = DNSMSG_END(pMsg);
    pMsg->Head.AnswerCount = 0;
    pMsg->Head.NameServerCount = 0;
    pMsg->Head.AdditionalCount = 0;

    //
    //  set up the error response code in the DNS header.
    //

    pMsg->Head.IsResponse = TRUE;
    setResponseCode( pMsg, ResponseCode );

    //
    //  check if suppressing response
    //

    if ( !( Flags & DNS_REJECT_DO_NOT_SUPPRESS ) &&
        checkAndSuppressBadSender(pMsg) )
    {
        return;
    }

    //
    //  Add rejection stats
    //
    //  DEVOTE: add PERF_INC( ... ) ? Add counters specific for rejection?
    // (see bug 292709 for this stat)
    //
    Stats_updateErrorStats ( (DWORD)ResponseCode );

    //
    //  UDP messages should all be set to delete
    //      => unless static buffer
    //      => unless nbstat
    //      => unless IXFR
    //  TCP messages are sometimes kept around for connection info
    //

    ASSERT( pMsg->fDelete ||
            pMsg->fTcp ||
            pMsg->U.Nbstat.pNbstat ||
            pMsg->wQuestionType == DNS_TYPE_IXFR ||
            ResponseCode == DNS_RCODE_SERVER_FAILURE );

    SET_OPT_BASED_ON_ORIGINAL_QUERY( pMsg );

    Send_Msg( pMsg );
} // Reject_Request



VOID
Reject_RequestIntact(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      WORD            ResponseCode,
    IN      DWORD           Flags
    )
/*++

Routine Description:

    Send failure response to request.

    Unlike Reject_Request(), this routine sends back entire
    packet, unchanged accept for header flags.
    This is necessary for messages like UPDATE, where sender
    may have RRs outside of question section.

Arguments:

    pMsg -- query to respond to;  its memory is freed

    ResponseCode -- failure response code

    Flags -- flags modify way rejection is handled (DNS_REJECT_XXX)

Return Value:

    None.

--*/
{
    DNS_DEBUG( RECV, ("Rejecting packet at %p.\n", pMsg ));

    //
    //  set pCurrent so send entire length
    //

    pMsg->pCurrent = DNSMSG_END(pMsg);

    //
    //  Set up the error response code in the DNS header. 
    //

    pMsg->Head.IsResponse = TRUE;
    setResponseCode( pMsg, ResponseCode );

    //
    //  check if suppressing response
    //

    if ( !( Flags & DNS_REJECT_DO_NOT_SUPPRESS ) &&
        checkAndSuppressBadSender(pMsg) )
    {
        return;
    }

    //
    //  Add rejection stats
    //
    //  DEVNOTE: add PERF_INC( ... ) ? Add counters specific for rejection?
    // (see bug 292709 for this stat)
    //
    Stats_updateErrorStats ( (DWORD)ResponseCode );


    //
    //  UDP messages should all be set to delete
    //      => unless static buffer
    //      => unless nbstat
    //      => unless IXFR
    //  TCP messages are sometimes kept around for connection info
    //

    ASSERT( pMsg->fDelete ||
            pMsg->fTcp ||
            pMsg->U.Nbstat.pNbstat ||
            pMsg->wQuestionType == DNS_TYPE_IXFR ||
            ResponseCode == DNS_RCODE_SERVER_FAILURE );

    Send_Msg( pMsg );
} // Reject_RequestIntact



VOID
Send_NameError(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Send NAME_ERROR response to query.
    First writes zone SOA, if authoritative response.

Arguments:

    pMsg -- query to respond to;  its memory is freed

Return Value:

    None.

--*/
{
    PZONE_INFO  pzone;
    PDB_NODE    pnode;
    PDB_NODE    pnodeSoa;
    PDB_RECORD  prr;
    DWORD       ttl = MAXDWORD;
    PDWORD      pminTtl;

    DNS_DEBUG( RECV, ( "Send_NameError( %p ).\n", pMsg ));

    //
    //  clear any packet building we did
    //
    //  DEVNOTE:  make packet building clear a macro, and use only when needed
    //      problem rejecting responses from other name servers that have
    //      these fields filled
    //

    //  note:  the Win95 NBT resolver is broken and sends packets that
    //      exceed the length of the actual DNS message;  i'm guessing
    //      that this is because it allocates a buffer based on a 16 byte
    //      netBIOS name + DNS domain and sends the whole thing regardless
    //      of how big the name actually was
    //      => bottom line, can't use this check
    //  MSG_ASSERT( pMsg, pMsg->pCurrent == DNSMSG_END(pMsg) );

    MSG_ASSERT( pMsg, pMsg->pCurrent > (PCHAR)DNS_HEADER_PTR(pMsg) );
    MSG_ASSERT( pMsg, pMsg->pCurrent < pMsg->pBufferEnd );
    MSG_ASSERT( pMsg, (PCHAR)(pMsg->pQuestion + 1) == pMsg->pCurrent );
    MSG_ASSERT( pMsg, pMsg->Head.AnswerCount == 0 );
    MSG_ASSERT( pMsg, pMsg->Head.NameServerCount == 0 );
    MSG_ASSERT( pMsg, pMsg->Head.AdditionalCount == 0 );

    //
    //  set up the error response code in the DNS header.
    //

    pMsg->Head.IsResponse = TRUE;
    pMsg->Head.ResponseCode = DNS_RCODE_NAME_ERROR;

    pzone = pMsg->pzoneCurrent;
    pnode = pMsg->pnodeCurrent;

    IF_DEBUG( LOOKUP )
    {
        DNS_PRINT((
            "Name error node = %p, zone = %p\n",
            pnode, pzone ));
        Dbg_DbaseNode( "NameError node:", pnode );
    }

    //
    //  authoritative zone
    //
    //  make determination on NAME_ERROR \ AUTH_EMPTY
    //  based on whether
    //      - pnode directly has other data
    //      - zone is set for WINS\WINSR lookup and didn't do lookup
    //      - wildcard data exists
    //
    //  also, for SOA query (possible FAZ for update), save additional data
    //  and attempt additional data lookup before final send
    //
    //  JDEVNOTE: if NAME_ERROR at end of CNAME chain, then pNodeQuestion is out
    //      - no longer reliable indicator
    //

    if ( pzone && !IS_ZONE_NOTAUTH( pzone ) )
    {
        ASSERT(
            IS_ZONE_FORWARDER( pzone ) ||
            IS_ZONE_STUB( pzone ) ||
            pMsg->Head.Authoritative );
        ASSERT( pMsg->pNodeQuestionClosest->pZone );
        ASSERT( !pnode || pnode == pMsg->pNodeQuestionClosest );
        ASSERT( pMsg->pNodeQuestionClosest->pZone == pzone );

        //
        //  WINS or WINSR zone
        //
        //  if WINS cache time less than SOA TTL, use it instead
        //
        //  do NOT send NAME_ERROR if
        //      - in WINS zone
        //      - query is for name that would have WINS lookup
        //      - never looked up the WINS type (so WINS\WINSR lookup could succeed)
        //      - no cached NAME_ERROR
        //
        //  note: that for WINS lookup to succeed, must be only one level below
        //      zone root;  must screen out both nodes that are found, and names
        //      that are NOT found, that are more than one level below zone root
        //
        //      example:
        //          zone    foo.bar
        //          query   sammy.dev.foo.bar
        //          closest foo.bar
        //

        prr = pzone->pWinsRR;
        if ( prr )
        {
            if ( pzone->dwDefaultTtlHostOrder > prr->Data.WINS.dwCacheTimeout )
            {
                ttl = prr->Data.WINS.dwCacheTimeout;
            }

            if ( !pzone->fReverse )  // WINS zone
            {
                if ( pMsg->wQuestionType != DNS_TYPE_A &&
                    pMsg->wQuestionType != DNS_TYPE_ALL &&
                    ( (!pnode &&
                        pMsg->pnodeClosest == pzone->pZoneRoot &&
                        pMsg->pLooknameQuestion->cLabelCount ==
                            pzone->cZoneNameLabelCount + 1 )
                    || (pnode &&
                        !IS_NOEXIST_NODE(pnode) &&
                        pnode->pParent == pzone->pZoneRoot) ) )
                {
                    pMsg->Head.ResponseCode = DNS_RCODE_NO_ERROR;
                }
            }
            else    // WINSR zone
            {
                if ( pMsg->wQuestionType != DNS_TYPE_PTR &&
                    pMsg->wQuestionType != DNS_TYPE_ALL &&
                    ( !pnode || !IS_NOEXIST_NODE(pnode) ) )
                {
                    pMsg->Head.ResponseCode = DNS_RCODE_NO_ERROR;
                }
            }
        }

        //
        //  Authoritative Empty Response?
        //

        if ( pnode && !EMPTY_RR_LIST( pnode ) && !IS_NOEXIST_NODE( pnode ) )
        {
            DNS_DEBUG( LOOKUP, (
                "empty auth: node %p rrlist %p noexist %d\n",
                pnode,
                pnode->pRRList,
                IS_NOEXIST_NODE( pnode ) ));
            pMsg->Head.ResponseCode = DNS_RCODE_NO_ERROR;
        }

        //
        //  Check if wildcard for another type
        //      - if exists then NO_ERROR response
        //

        else if ( pMsg->fQuestionWildcard == WILDCARD_UNKNOWN )
        {
            if ( Answer_QuestionWithWildcard(
                    pMsg,
                    pMsg->pNodeQuestionClosest,
                    DNS_TYPE_ALL,
                    WILDCARD_CHECK_OFFSET ) )
            {
                DNS_DEBUG( LOOKUP, (
                    "Wildcard flag EXISTS, switching to NO_ERROR response for %p\n",
                    pMsg ));
                pMsg->Head.ResponseCode = DNS_RCODE_NO_ERROR;
            }
            ELSE_ASSERT( pMsg->fQuestionWildcard == WILDCARD_NOT_AVAILABLE );
        }

        else if ( pMsg->fQuestionWildcard == WILDCARD_EXISTS )
        {
            DNS_DEBUG( LOOKUP, (
                "Wildcard flag EXISTS, switching to NO_ERROR response for %p\n",
                pMsg ));
            pMsg->Head.ResponseCode = DNS_RCODE_NO_ERROR;
        }
        ELSE_ASSERT( pMsg->fQuestionWildcard == WILDCARD_NOT_AVAILABLE );

#if 0
        //  this looses utility because of two issues
        //      1) can't tell client from DNS server using forwarder
        //      2) client cache can use this for hints
        //  best to simply always send SOA

        //
        //  if direct lookup from client, no need to include SOA, just NAME_ERROR
        //

        if ( pMsg->Head.RecursionDesired &&
                pMsg->wQuestionType != DNS_TYPE_SOA &&
                ! SrvCfg_fWriteAuthority &&
                pMsg->Head.ResponseCode )
        {
            ASSERT( pMsg->Head.ResponseCode == DNS_RCODE_NAME_ERROR );
            goto Send;
        }
#endif

        //  writing name error, using SOA at zone root

        pnodeSoa = pzone->pZoneRoot;

        //  SOA query?
        //      - save primary name additional data to speed FAZ query

        if ( pMsg->wQuestionType == DNS_TYPE_SOA )
        {
            pMsg->fDoAdditional = TRUE;
        }
    }

    //
    //  if non-authoritative and name error for original question
    //      - if know zone, attempt SOA write, otherwise send
    //      - note under lock as grabbing record
    //      - note that we assume name error determination already made,
    //      if has timed out since, we just send without SOA and TTL
    //

    else if ( pnode &&
            IS_NOEXIST_NODE( pnode ) &&
            IS_SET_TO_WRITE_ANSWER_RECORDS( pMsg ) &&
            CURRENT_RR_SECTION_COUNT( pMsg ) == 0 )
    {
        if ( ! RR_CheckNameErrorTimeout(
                    pnode,
                    FALSE,      // don't remove
                    & ttl,
                    & pnodeSoa ) )
        {
            goto Send;
        }
        if ( !pnodeSoa )
        {
            goto Send;
        }
    }

    //  no zone SOA available, just send NAME_ERROR

    else
    {
        goto Send;
    }

    SET_TO_WRITE_AUTHORITY_RECORDS(pMsg);

    //
    //  Try to write an NXT record to the packet. For name error, we must
    //  have found the NXT node during the packet lookup. For empty auth
    //  responses the NXT is the one for the lookup node.
    //

    if ( DNSMSG_INCLUDE_DNSSEC_IN_RESPONSE( pMsg ) )
    {
        PDB_NODE    pnode;
        
        pnode = pMsg->Head.ResponseCode == DNS_RCODE_NO_ERROR ?
                    pMsg->pnodeCurrent :
                    pMsg->pnodeNxt;
        if ( pnode )
        {
            Wire_WriteRecordsAtNodeToMessage(
                    pMsg,
                    pnode,
                    DNS_TYPE_NXT,
                    0,
                    DNSSEC_ALLOW_INCLUDE_ALL );
        }
    }

    //
    //  write SOA to authority section
    //      - don't worry about failure or truncation -- if fails, just send
    //      - overwrite minTTL field if smaller timeout appropriate
    //

    if ( ! Wire_WriteRecordsAtNodeToMessage(
                pMsg,
                pnodeSoa,
                DNS_TYPE_SOA,
                0,
                DNSSEC_ALLOW_INCLUDE_ALL ) )
    {
        goto Send;
    }

    if ( ttl != MAXDWORD )
    {
        pminTtl = (PDWORD)(pMsg->pCurrent - sizeof(DWORD));
        INLINE_DWORD_FLIP( ttl, ttl );
        * (UNALIGNED DWORD *) pminTtl = ttl;
    }

    //
    //  SOA query?
    //      - write primary name additional data to speed FAZ query
    //

    if ( pMsg->wQuestionType == DNS_TYPE_SOA && pzone )
    {
        DNS_DEBUG( LOOKUP, (
            "Break from Send_NameError() to write SOA additional data; pmsg = %p.\n",
            pMsg ));

        Answer_ContinueNextLookupForQuery( pMsg );
        return;
    }

Send:

    Stats_updateErrorStats( DNS_RCODE_NAME_ERROR );

    //
    //  UDP messages should all be set to delete
    //      => unless nbstat
    //  TCP messages are sometimes kept around for connection info
    //

    ASSERT( pMsg->fDelete || pMsg->fTcp || pMsg->U.Nbstat.pNbstat );

    Send_Msg( pMsg );
}   //  Send_NameError



BOOL
Send_RecursiveResponseToClient(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN OUT  PDNS_MSGINFO    pResponse
    )
/*++

Routine Description:

    Send recursive response back to original client.

Arguments:

    pQuery -- original query

    pResponse -- response from remote DNS

Return Value:

    None.

--*/
{
    BOOLEAN fresponseTcp;

    DNS_DEBUG( SEND, (
        "Responding to query %p with recursive response %p.\n",
        pQuery,
        pResponse ));

    //
    //  check for TCP\UDP mismatch between query and response
    //  make sure we can do the right thing
    //  if TCP response, then make sure it fits within UDP query
    //  if UDP response, make sure don't have truncation bit set
    //
    //  DEVNOTE: fix truncation reset when do TCP recursion
    //              (then we shouldn't fall here with TCP query and truncated
    //              response, we should have recursed with TCP)
    //

    fresponseTcp = pResponse->fTcp;

    if ( fresponseTcp != pQuery->fTcp )
    {
        if ( !fresponseTcp )
        {
            pResponse->Head.Truncation = FALSE;
        }
        else    // TCP response
        {
            if ( pResponse->MessageLength > DNSSRV_UDP_PACKET_BUFFER_LENGTH )
            {
                return( FALSE );
            }
            pResponse->Head.Truncation = TRUE;
        }
        pResponse->fTcp = !fresponseTcp;
    }

    //
    //  EDNS
    //
    //  If the response is larger than the maximum standard UDP packet and
    //  less than the EDNS payload size specified in the query, we must
    //  cache the response and regenerate an answer packet from the
    //  database. We also must allow for a minimum length OPT to be
    //  appended to the response.
    //
    //  Turn on the response's OPT include flag if the query included an OPT.
    //

    if ( pResponse->MessageLength > DNS_RFC_MAX_UDP_PACKET_LENGTH &&
        ( pQuery->Opt.wOriginalQueryPayloadSize == 0 ||
            pResponse->MessageLength + DNS_MINIMIMUM_OPT_RR_SIZE >
                pQuery->Opt.wOriginalQueryPayloadSize ) )
    {
        return FALSE;
    }
    pResponse->Opt.wOriginalQueryPayloadSize =
        pQuery->Opt.wOriginalQueryPayloadSize;
    SET_OPT_BASED_ON_ORIGINAL_QUERY( pResponse );

    //
    //  setup response with query info
    //      - original XID
    //      - socket and address
    //      - set response for no delete on send (all responses are
    //      cleaned up in Answer_ProcessMessage() in answer.c)
    //      - set pCurrent to end of message (Send_Msg() uses to determine
    //      message length)
    //

    pResponse->Head.Xid = pQuery->Head.Xid;
    pResponse->Socket   = pQuery->Socket;
    pResponse->RemoteAddress.sin_addr.s_addr = pQuery->RemoteAddress.sin_addr.s_addr;
    pResponse->RemoteAddress.sin_port = pQuery->RemoteAddress.sin_port;

    pResponse->fDelete  = FALSE;
    pResponse->pCurrent = DNSMSG_END(pResponse);

    //
    //  send response
    //  restore pResponse TCP flag, strictly for packet counting purposes when
    //      packet is freed
    //  delete original query
    //

    Send_Msg( pResponse );

    pResponse->fTcp = fresponseTcp;
    STAT_INC( RecurseStats.SendResponseDirect );

    Packet_Free( pQuery );

    return( TRUE );
}   //  Send_RecursiveResponseToClient



VOID
Send_QueryResponse(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Send response to query.

    Main routine for sending response when all lookup exhausted.
    Its main purpose is to determine if need NameError, AuthEmpty or
        ServerFailure when no lookup has succeeded.

Arguments:

    pMsg -- query to respond to;  its memory is freed

Return Value:

    None.

--*/
{
    DNS_DEBUG( LOOKUP, (
        "Send_QueryResponse( %p ).\n",
        pMsg ));

    //
    //  free query after response
    //

    pMsg->fDelete = TRUE;
    pMsg->Head.IsResponse = TRUE;

    //
    //  question answered ?
    //      or referral
    //      or SOA for AUTH empty response
    //

    SET_OPT_BASED_ON_ORIGINAL_QUERY( pMsg );

    if ( pMsg->Head.AnswerCount != 0 || pMsg->Head.NameServerCount != 0 )
    {
        Send_Msg( pMsg );
        return;
    }

    //
    //  question not answered
    //      hence current name is question name
    //
    //  Send_NameError() makes NAME_ERROR \ AUTH_EMPTY determination
    //  based on whether other data may be available for other types from
    //      - WINS\WINSR
    //      - wildcard
    //
    //  note:  we need the WRITING_ANSWER check because it's possible to have
    //      a case where we are attempting to writing referral, but the NS
    //      records go away at delegation or at root node;  don't want to
    //      send NAME_ERROR, just bail out
    //

    if ( pMsg->Head.Authoritative &&
         IS_SET_TO_WRITE_ANSWER_RECORDS(pMsg) )
    {
        //  this path should only be for question node found

        ASSERT( pMsg->pNodeQuestionClosest->pZone == pMsg->pzoneCurrent );

        Send_NameError( pMsg );
        return;
    }

    //
    //  not authoritative and unable to come up with answer OR referral
    //
    //  DEVNOTE: should we give referrral if recurse failure?
    //      may have some merit for forwarding
    //

    Reject_Request(
        pMsg,
        DNS_RCODE_SERVER_FAILURE,
        0 );
    return;
}



VOID
Send_ForwardResponseAsReply(
    IN OUT  PDNS_MSGINFO    pResponse,
    IN      PDNS_MSGINFO    pQuery
    )
/*++

Routine Description:

    Set response for reply to original query.

Arguments:

    pResponse - ptr to response from remote server

    pQuery - ptr to original query

Return Value:

    None

--*/
{
    DNS_DEBUG( SEND, (
        "Forwarding response %p to query %p\n"
        "\tback to original client at %s.\n",
        pResponse,
        pQuery,
        IP_STRING(pQuery->U.Forward.ipOriginal) ));

    COPY_FORWARDING_FIELDS( pResponse, pQuery );

    //  responses are freed by response dispatching block (answer.c)

    pResponse->fDelete = FALSE;
    pResponse->pCurrent = DNSMSG_END( pResponse );

    Send_Msg( pResponse );
}



VOID
Send_InitBadSenderSuppression(
    VOID
    )
/*++

Routine Description:

    Init bad sender suppression.

Arguments:

    None

Return Value:

    None.

--*/
{
    RtlZeroMemory(
        BadSenderArray,
        (BAD_SENDER_ARRAY_LENGTH * sizeof(BAD_SENDER)) );
}



BOOL
checkAndSuppressBadSender(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Check for bad packet response suppression.

    If from recent "bad IP", then suppress response
    and if pMsg->fDelete flag is set free the packet memory.
    The semantics of this function in the TRUE case are
    identical to Send_Msg without the send, so on TRUE return
    the caller can treat as if it used Send_Msg().

Arguments:

    pMsg -- query being responded to

Return Value:

    TRUE if message suppressed;  caller should not send the response.
    FALSE if message not sent;  caller should send.

--*/
{
    DWORD   i;
    DWORD   ip = pMsg->RemoteAddress.sin_addr.s_addr;
    DWORD   entryTime;
    DWORD   useIndex = MAXDWORD;
    DWORD   oldestEntryTime = MAXDWORD;
    DWORD   nowTime = DNS_TIME();

    DNS_DEBUG( RECV, ( "checkAndSuppressBadSender( %p )\n", pMsg ));

    //
    //  ignore suppression for regression test runs
    //

    if ( SrvCfg_dwEnableSendErrSuppression )
    {
        return( FALSE );
    }

    //
    //  check if suppressable RCODE
    //      - FORMERR
    //      - NOTIMPL
    //  are suppressable;  the others convery real info
    //
    //  however, DEVNOTE: since we're using NOTIMPL on dynamic update, for
    //      zone's without update, we won't suppress if this is
    //      clearly a dynamic update packet

    if ( pMsg->Head.ResponseCode != DNS_RCODE_FORMERR
            &&
        (   pMsg->Head.ResponseCode != DNS_RCODE_NOTIMPL ||
            pMsg->Head.Opcode == DNS_OPCODE_UPDATE ) )
    {
        return( FALSE );
    }

    //
    //  find if suppressing response for IP
    //
    //  why no locking?
    //  the worse case that no locking does here is that we
    //  inadvertantly allow a send that we'd like to suppress
    //  (i.e. someone else writes their IP in on top of ours
    //  and so we go through this again and don't find
    //
    //  optimizations would be a count to track suppressions,
    //  allowing
    //

    for ( i=0; i<BAD_SENDER_ARRAY_LENGTH; i++ )
    {
        entryTime = BadSenderArray[i].ReleaseTime;

        if ( ip == BadSenderArray[i].IpAddress )
        {
            if ( nowTime < entryTime )
            {
                goto Suppress;
            }
            useIndex = i;
            break;
        }

        //  otherwise find oldest suppression entry to grab
        //  in case don't match our own IP

        else if ( entryTime < oldestEntryTime )
        {
            useIndex = i;
            oldestEntryTime = entryTime;
        }
    }

    //  set entry to suppress any further bad packets from this IP
    //  ReleaseTime will be when suppression stops

    if ( useIndex != MAXDWORD )
    {
        BadSenderArray[useIndex].IpAddress = ip;
        BadSenderArray[useIndex].ReleaseTime = nowTime + BAD_SENDER_SUPPRESS_INTERVAL;
    }
    return( FALSE );


Suppress:

    //
    //  if suppressing and message set for delete -- free the memory
    //  this keeps us completely analogous to Send_Msg() except for
    //  hitting the wire
    //

    DNS_DEBUG( RECV, (
        "Suppressing error (%d) send on ( %p )\n",
        pMsg->Head.ResponseCode,
        pMsg ));

    if ( pMsg->fDelete )
    {
        Packet_Free( pMsg );
    }
    return( TRUE );
}


//
//  End of send.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\security.c ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

    security.c

Abstract:

    Domain Name System (DNS) Server

    Security utilities.

Author:

    Jim Gilroy (jamesg)     October, 1999

Revision History:

--*/


#include "dnssrv.h"


//
//  Security globals
//

PSECURITY_DESCRIPTOR    g_pDefaultServerSD;
PSECURITY_DESCRIPTOR    g_pServerObjectSD;
PSID                    g_pServerSid;
PSID                    g_pServerGroupSid;
PSID                    g_pDnsAdminSid;
PSID                    g_pAuthenticatedUserSid;
PSID                    g_pEnterpriseControllersSid;
PSID                    g_pLocalSystemSid;
PSID                    g_pEveryoneSid;
PSID                    g_pDynuproxSid;
PSID                    g_pAdminSid;



DNS_STATUS
Security_Initialize(
    VOID
    )
/*++

Routine Description:

    Initialize security.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    DNS_DEBUG( DS, ( "Security_Initialize()\n" ));

    //  clear security globals
    //  need to do this in case of server restart

    g_pDefaultServerSD          = NULL;
    g_pServerObjectSD           = NULL;
    g_pServerSid                = NULL;
    g_pServerGroupSid           = NULL;
    g_pDnsAdminSid              = NULL;
    g_pAuthenticatedUserSid     = NULL;
    g_pEnterpriseControllersSid = NULL;
    g_pLocalSystemSid           = NULL;
    g_pEveryoneSid              = NULL;
    g_pAdminSid                 = NULL;
    g_pDynuproxSid              = NULL;

    //
    //  create standard SIDs
    //

    Security_CreateStandardSids();

    return ERROR_SUCCESS;
}



DNS_STATUS
Security_CreateStandardSids(
    VOID
    )
/*++

Routine Description:

    Create standard SIDs.

    These SIDs are used to create several different security descriptors
    so we just create them and leave them around for later use.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    DNS_STATUS                  status;
    DNS_STATUS                  finalStatus = ERROR_SUCCESS;
    SID_IDENTIFIER_AUTHORITY    ntAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    worldSidAuthority =  SECURITY_WORLD_SID_AUTHORITY;


    DNS_DEBUG( DS, ( "Security_CreateStandardSids()\n" ));

    //
    //  create standard SIDs
    //

    //
    //  Authenticated-user SID
    //

    if ( !g_pAuthenticatedUserSid )
    {
        status = RtlAllocateAndInitializeSid(
                        &ntAuthority,
                        1,
                        SECURITY_AUTHENTICATED_USER_RID,
                        0, 0, 0, 0, 0, 0, 0,
                        & g_pAuthenticatedUserSid
                        );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR <%lu>: Cannot create Authenticated Users SID\n",
                status ));
            finalStatus = status;
        }
    }

    //
    //  Enterprise controllers SID
    //

    if ( !g_pEnterpriseControllersSid )
    {
        status = RtlAllocateAndInitializeSid(
                        &ntAuthority,
                        1,
                        SECURITY_ENTERPRISE_CONTROLLERS_RID,
                        0, 0, 0, 0, 0, 0, 0,
                        &g_pEnterpriseControllersSid
                        );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR: <%lu>: Cannot create Enterprise Admins SID\n",
                status));
            finalStatus = status;
        }
    }

    //
    //  Local System SID
    //

    if ( !g_pLocalSystemSid )
    {
        status = RtlAllocateAndInitializeSid(
                        &ntAuthority,
                        1,
                        SECURITY_LOCAL_SYSTEM_RID,
                        0, 0, 0, 0, 0, 0, 0,
                        &g_pLocalSystemSid
                        );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR: <%lu>: Cannot create Local System SID\n",
                status));
            finalStatus = status;
        }
    }

    //
    //  Admin SID
    //

    if ( !g_pAdminSid )
    {
        status = RtlAllocateAndInitializeSid(
                        &ntAuthority,
                        2,
                        SECURITY_BUILTIN_DOMAIN_RID,
                        DOMAIN_ALIAS_RID_ADMINS,
                        0, 0, 0, 0, 0, 0,
                        &g_pAdminSid
                        );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR: <%lu>: Cannot create Enterprise Admins SID\n",
                status));
            finalStatus = status;
        }
    }

    //
    //  Everyone SID
    //

    if ( !g_pEveryoneSid )
    {
        status = RtlAllocateAndInitializeSid(
                         &worldSidAuthority,
                         1,
                         SECURITY_WORLD_RID,
                         0, 0, 0, 0, 0, 0, 0,
                         &g_pEveryoneSid
                         );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR <%lu>: Cannot create Everyone SID\n",
                status ));
            finalStatus = status;
        }
    }

    return finalStatus;
}

//
//  End security.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\socket.h ===
/*++

Copyright(c) 1995-1999 Microsoft Corporation

Module Name:

    socket.h

Abstract:

    Domain Name System (DNS) Server

    Socket related definitions.

Author:

    Jim Gilroy (jamesg)     June 20, 1995

Revision History:

--*/


#ifndef _DNS_SOCKET_INCLUDED_
#define _DNS_SOCKET_INCLUDED_


//
//  Server name in DBASE format
//

extern  DB_NAME  g_ServerDbaseName;

//
//  UDP completion port
//

extern  HANDLE  g_hUdpCompletionPort;

//
//  Socket globals
//

#define DNS_INVALID_SOCKET  (0)
#define DNS_INVALID_IP      ((IP_ADDRESS)(-1))

extern  PIP_ARRAY   g_ServerAddrs;
extern  PIP_ARRAY   g_BoundAddrs;

extern  FD_SET  g_fdsListenTcp;

extern  SOCKET  g_UdpSendSocket;

extern  WORD    g_SendBindingPort;

//  TCP select wakeup to allow server to add connections it initiates
//      to select() FD_SET

extern  SOCKET  g_TcpSelectWakeupSocket;
extern  BOOL    g_bTcpSelectWoken;


//
//  TCP client connection
//

typedef VOID (* CONNECT_CALLBACK)( PDNS_MSGINFO, BOOL );

//
//  Socket list
//
//  Keep list of ALL active sockets, so we can cleanly insure that
//  they are all closed on shutdown.
//
//  I/O completion returns ptr to context.
//      - MUST include the Overlapped struct as it must stay valid
//      during i/o operation
//      - include WsaBuf, Flags, BytesRecv since they are all dropped
//      down with WSARecvFrom and thus properly should be associated
//      with the socket and not on the thread's stack
//
//  Easiest approach was to combine the i/o completion context with
//  this other socket information.  Cleanup is easier when sockets
//  added and deleted.  Also leverages socket list, to search through
//  and restart recv() when get a recv() failure.
//

typedef struct _DnsSocket
{
    LIST_ENTRY      List;
    SOCKET          Socket;
    HANDLE          hPort;
    // 16

    IP_ADDRESS      ipAddr;
    INT             SockType;
    WORD            Port;

    BOOL            fListen;
    // 32

    DWORD           State;
    BOOLEAN         fRecvPending;
    BOOLEAN         fRetry;
    BOOLEAN         fPad1;
    BOOLEAN         fPad2;

    //  recv context

    DWORD           BytesRecvd;
    DWORD           RecvfromFlags;

    //  48
    PDNS_MSGINFO    pMsg;

    //  TCP connection context

    CONNECT_CALLBACK pCallback;         //  callback on connection failure
    DWORD           dwTimeout;          //  timeout until connection closed
    IP_ADDRESS      ipRemote;

    OVERLAPPED      Overlapped;
    WSABUF          WsaBuf;
}
DNS_SOCKET, *PDNS_SOCKET;


//
//  Socket context states
//

#define SOCKSTATE_UDP_RECV_DOWN         (1)
#define SOCKSTATE_UDP_COMPLETED         (2)
#define SOCKSTATE_UDP_RECV_ERROR        (3)
#define SOCKSTATE_UDP_GQCS_ERROR        (4)

#define SOCKSTATE_TCP_LISTEN            (16)
#define SOCKSTATE_TCP_ACCEPTING         (17)
#define SOCKSTATE_TCP_RECV_DOWN         (18)
#define SOCKSTATE_TCP_RECV_INDICATED    (19)
#define SOCKSTATE_TCP_RECV_FIN          (20)

#define SOCKSTATE_TCP_CONNECT_ATTEMPT   (32)
#define SOCKSTATE_TCP_CONNECT_COMPLETE  (33)
#define SOCKSTATE_TCP_CONNECT_FAILURE   (34)

#define SOCKSTATE_DEAD                  (0xffffffff)

//
//  Flag to indicate need to retry receives on UDP sockets
//

extern  BOOL    g_fUdpSocketsDirty;

//
//  Wrap UDP check and retry in macro
//  This takes away unnecessary function call in the 99.999% case
//

#define UDP_RECEIVE_CHECK() \
            if ( SrvCfg_dwQuietRecvLogInterval ) \
            {                           \
                Udp_RecvCheck();        \
            }                           \
            if ( g_fUdpSocketsDirty )   \
            {                           \
                Sock_StartReceiveOnUdpSockets(); \
            }

//
//  Select wakeup socket
//      -- needed by tcpsrv, to avoid attempting recv() from socket
//

extern SOCKET  socketTcpSelectWakeup;

extern BOOL    gbTcpSelectWoken;

//
//  Connect attempt (to remote DNS)
//

#define DNS_TCP_CONNECT_ATTEMPT_TIMEOUT (5)     // 5 seconds


//
//  Net order loopback address
//

#define NET_ORDER_LOOPBACK      (0x0100007f)


//
//  TCP connection list (tcpcon.c)
//

BOOL
Tcp_ConnectionListFdSet(
    IN OUT  fd_set *        pReadFdSet,
    IN OUT  fd_set *        pWriteFdSet,
    IN OUT  fd_set *        pExceptFdSet,
    IN      DWORD           dwLastSelectTime
    );

BOOL
Tcp_ConnectionCreate(
    IN      SOCKET              Socket,
    IN      CONNECT_CALLBACK    pCallbackFunction,
    IN OUT  PDNS_MSGINFO        pMsg        OPTIONAL
    );

VOID
Tcp_ConnectionListReread(
    VOID
    );

BOOL
Tcp_ConnectionCreateForRecursion(
    IN      PDNS_MSGINFO    pRecurseMsg,
    IN      SOCKET          Socket
    );

VOID
Tcp_ConnectionDeleteForSocket(
    IN      SOCKET          Socket,
    IN      PDNS_MSGINFO    pMsg        OPTIONAL
    );

PDNS_MSGINFO
Tcp_ConnectionMessageFindOrCreate(
    IN      SOCKET          Socket
    );

VOID
Tcp_ConnectionUpdateTimeout(
    IN      SOCKET          Socket
    );

VOID
Tcp_ConnectionUpdateForCompleteMessage(
    IN      PDNS_MSGINFO    pMsg
    );

VOID
Tcp_ConnectionUpdateForPartialMessage(
    IN      PDNS_MSGINFO    pMsg
    );

VOID
Tcp_ConnectionListInitialize(
    VOID
    );

VOID
Tcp_ConnectionListShutdown(
    VOID
    );

VOID
Tcp_CloseAllConnectionSockets(
    VOID
    );


//
//  TCP Forwarding\Recursion
//

BOOL
Tcp_ConnectForForwarding(
    IN OUT  PDNS_MSGINFO        pMsg,
    IN      IP_ADDRESS          ipServer,
    IN      CONNECT_CALLBACK    ConnectFailureCallback
    );

VOID
Tcp_ConnectionCompletion(
    IN      SOCKET          Socket
    );

VOID
Tcp_CleanupFailedConnectAttempt(
    IN      SOCKET          Socket
    );


#endif // _TCPCON_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\socket.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    socket.c

Abstract:

    Domain Name System (DNS) Server

    Listening socket setup.

Author:

    Jim Gilroy (jamesg)     November, 1995

Revision History:

--*/


#include "dnssrv.h"


//
//  Winsock version
//

#ifdef DNS_WINSOCK1
#define DNS_WINSOCK_VERSION (0x0101)    //  Winsock 1.1
#else
#define DNS_WINSOCK_VERSION (0x0002)    //  Winsock 2.0
#endif


//
//  Server name in DBASE format
//

DB_NAME  g_ServerDbaseName;

//
//  Backlog on listen, before dropping
//

#define LISTEN_BACKLOG 20

//
//  Default allocation for socket list
//

#define DEFAULT_SOCKET_ARRAY_COUNT (30)

//
//  Hostents only return 35 IP addresses.  If hostent contains
//  35, we do NOT know if more exist.
//

#define HOSTENT_MAX_IP_COUNT    (35)

//
//  Count number of listen sockets == number of interfaces.
//
//  Warn user when use is excessive.
//  Use smaller recv buffer size when socket count gets larger.
//

INT     g_UdpBoundSocketCount;

#define MANY_IP_WARNING_COUNT       (10)
#define SMALL_BUFFER_SOCKET_COUNT   (3)

//
//  Socket receive buffers
//  If only a few sockets, we can increase the default buffer size
//  substaintially to avoid dropping packets.  If many sockets must
//  leave buffer at default.
//

#define UDP_MAX_RECV_BUFFER_SIZE    (0x10000)  // 64k max buffer

DWORD   g_UdpRecvBufferSize;

//
//  TCP send buffer size
//      - strictly informational
//

DWORD   g_SendBufferSize;

//
//  Socket list
//
//  Keep list of ALL active sockets, so we can cleanly insure that
//  they are all closed on shutdown.
//

#define DNS_SOCKLIST_UNINITIALIZED  (0x80000000)

INT                 g_SocketListCount;
LIST_ENTRY          g_SocketList;
CRITICAL_SECTION    g_SocketListCs;

#define LOCK_SOCKET_LIST()      EnterCriticalSection( &g_SocketListCs )
#define UNLOCK_SOCKET_LIST()    LeaveCriticalSection( &g_SocketListCs )


//
//  Combined socket-list and debug print lock
//
//  To avoid deadlock, during Dbg_SocketList() print, MUST take socket list
//  lock OUTSIDE of debug print lock.   This is because Dbg_SocketList() will
//  do printing while holding the socket list lock.
//
//  So if Dbg_SocketList will be wrapped with other prints in a lock, use
//  the combined lock below to take the locks in the correct order.
//

#define LOCK_SOCKET_LIST_DEBUG()        { LOCK_SOCKET_LIST();  Dbg_Lock(); }
#define UNLOCK_SOCKET_LIST_DEBUG()      { UNLOCK_SOCKET_LIST();  Dbg_Unlock(); }


//
//  Flag to indicate need to retry receives on UDP sockets
//

BOOL    g_fUdpSocketsDirty;


//
//  Server IP addresses
//      ServerAddrs -- all IPs on the box
//      BoundAddrs -- the IPs we are or should be listening on
//          (intersection of server addresses and listen addresses)
//

PIP_ARRAY   g_ServerAddrs = NULL;

PIP_ARRAY   g_BoundAddrs = NULL;

//
//  UDP send socket
//
//  For multi-homed DNS server, there is a problem with sending server
//  server initiated queries (recursion, SOA, NOTIFY), on a socket
//  that is EXPLICITLY BOUND to a particular IP address.  The stack will
//  put that address as the IP source address -- regardless of interface
//  chosen to reach remote server.  And the remote server may not have
//  a have a route back to the source address given.
//
//  To solve this problem, we keep a separate global UDP send socket,
//  that -- at least for multi-homed servers -- is bound to INADDR_ANY.
//  For single IP address servers, this can be the same as a listening
//  socket.
//
//  Keep another variable to indicate if the UDP send socket is bound
//  to INADDR_ANY.  This enables us to determine whether need new UDP
//  send socket or need to close old socket, when a PnP event or listen
//  list change occurs.
//

SOCKET  g_UdpSendSocket;
SOCKET  g_UdpZeroBoundSocket;

//
//  Non-DNS port operation
//
//  To allow admins to firewall off the DNS port (53), there is a
//  registry parameter to force send sockets to be bound to another
//  port.
//  Init value to unused (for DNS) port to distinguish from values in use.
//

WORD    g_SendBindingPort;


//
//  TCP send sockets
//
//  A similar, but less serious problem exists for TCP sends for
//  zone transfers.  If we are multi-homed and only listening on a
//  subset of the machines addresses, then connecting with a socket
//  bound to INADDR_ANY, will not necessarily result in a connection
//  from one of the DNS interfaces.  If the receiving DNS server
//  requires a connection from one of those addresses (secondary security)
//  then it will fail.
//
//  Our solution to this is to use the IP address of the socket that
//  received the SOA query response.  This eliminates the need to
//  determine safe, reachable bind() address.  We are always using a
//  valid address on the machine that is also an address that the primary
//  DNS can respond to.
//


//
//  TCP listen-on-all socket (bound to INADDR_ANY)
//
//  Since TCP is connection oriented, no need to explicitly bind()
//  TCP sockets in order to satisfy client that it is talking to the
//  correct address.
//  Hence only need to explictly bind TCP listening sockets when server
//  is operating on only a subset of the total addresses.  Otherwise
//  can bind to single INADDR_ANY socket.  Keep a global to this listen-on-all
//  socket so we can take the appropriate action when PnP event or listen
//  list change, changes the appropriate use.
//

SOCKET  g_TcpZeroBoundSocket;


//
//  Listening fd_set
//

FD_SET  g_fdsListenTcp;


//
//  Private protos
//

DNS_STATUS
openListeningSockets(
    VOID
    );

DNS_STATUS
Sock_CreateSocketsForIpArray(
    IN      PIP_ARRAY       pIpArray,
    IN      INT             SockType,
    IN      WORD            Port,
    IN      DWORD           Flags
    );

DNS_STATUS
Sock_ResetBoundSocketsToMatchIpArray(
    IN      PIP_ARRAY       pIpArray,
    IN      INT             SockType,
    IN      WORD            Port,
    IN      DWORD           Flags,
    IN      BOOL            fCloseZeroBound
    );

DNS_STATUS
Sock_CloseSocketsListeningOnUnusedAddrs(
    IN      PIP_ARRAY       pIpArray,
    IN      INT             iSockType,
    IN      BOOL            fIncludeZeroBound,
    IN      BOOL            fIncludeLoopback
    );

SOCKET
Sock_GetAssociatedSocket(
    IN      IP_ADDRESS      ipAddr,
    IN      INT             SockType
    );


//  DEVNOTE: move to DNS lib

LPSTR
Dns_GetLocalDnsName(
    VOID
    );



DNS_STATUS
Sock_ReadAndOpenListeningSockets(
    VOID
    )
/*++

Routine Description:

    Read listen address list and open listening sockets.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS  status;
    DWORD       length;
    DWORD       countIp;
    INT         i;
    BOOLEAN     fregistryListen;
    WSADATA     wsaData;
    PCHAR       pszhostFqdn;
    struct hostent * phostent;
    CHAR        szhostName[ DNS_MAX_NAME_BUFFER_LENGTH ];
    PIP_ADDRESS pIpAddresses = NULL;


    DNS_DEBUG( SOCKET, ( "\nSock_ReadAndOpenListeningSockets()\n" ));

    //
    //  init socket globals
    //
    //  see descriptions at top;
    //  we re-init here to allow for server restart
    //

    g_hUdpCompletionPort = INVALID_HANDLE_VALUE;

    g_UdpBoundSocketCount = 0;

    g_UdpRecvBufferSize = 0;

    g_SendBufferSize = 0;

    g_SocketListCount = DNS_SOCKLIST_UNINITIALIZED;

    g_fUdpSocketsDirty = FALSE;

    g_ServerAddrs = NULL;
    g_BoundAddrs = NULL;

    g_UdpSendSocket = 0;
    g_UdpZeroBoundSocket = 0;
    g_SendBindingPort = 1;
    g_TcpZeroBoundSocket = 0;

    //
    //  init socket list
    //

    InitializeCriticalSection( &g_SocketListCs );
    InitializeListHead( &g_SocketList );
    g_SocketListCount = 0;

    //
    //  create UDP i/o completion port
    //

    g_hUdpCompletionPort = CreateIoCompletionPort(
                                INVALID_HANDLE_VALUE,
                                NULL,
                                0,
                                0 );
    if ( !g_hUdpCompletionPort )
    {
        ASSERT( FALSE );
        return( FALSE );
    }
    DNS_DEBUG( SOCKET, (
        "Created UDP i/o completion port %p\n",
        g_hUdpCompletionPort ));

    //
    //  start winsock
    //

    status = WSAStartup( DNS_WINSOCK_VERSION, &wsaData );
    if ( status == SOCKET_ERROR )
    {
        status = WSAGetLastError();
        DNS_PRINT(( "ERROR:  WSAStartup failure %d.\n", status ));
        return( status );
    }

    //
    //  read server host name
    //
    //  check if change from previous hostname, if not
    //  then NULL out previous field which serves as flag for
    //  need to upgrade default records (ex. SOA primary DNS)
    //

    SrvCfg_pszServerName = Dns_GetLocalDnsName();

    if ( !SrvCfg_pszServerName )
    {
        DNS_PRINT(( "ERROR:  no server name return!!!\n" ));
        SrvCfg_pszServerName = "FixMe";
    }

    else if ( SrvCfg_pszPreviousServerName &&
        strcmp( SrvCfg_pszPreviousServerName, SrvCfg_pszServerName ) == 0 )
    {
        DNS_DEBUG( INIT, (
            "Previous server name <%s>, same as current <%s>\n",
            SrvCfg_pszPreviousServerName,
            SrvCfg_pszServerName ) );

        FREE_HEAP( SrvCfg_pszPreviousServerName );
        SrvCfg_pszPreviousServerName = NULL;
    }

    //
    //  DEVNOTE: temp hack while GetComputerNameEx is confused
    //

    {
        INT lastIndex = strlen( SrvCfg_pszServerName ) - 1;

        DNS_DEBUG( INIT, (
            "Server name <%s>, lastIndex = %d\n",
            SrvCfg_pszServerName,
            lastIndex ));

        if ( lastIndex &&
            SrvCfg_pszServerName[ lastIndex ] == '.' &&
            SrvCfg_pszServerName[ lastIndex-1 ] == '.' )
        {
            SrvCfg_pszServerName[ lastIndex ] = 0;
        }
    }

    //  save server name as DBASE name

    status = Name_ConvertFileNameToCountName(
                & g_ServerDbaseName,
                SrvCfg_pszServerName,
                0 );
    if ( status == DNS_ERROR_INVALID_NAME )
    {
        ASSERT( FALSE );
        return( status );
    }

    //  warn when using single label name

    if ( g_ServerDbaseName.LabelCount <= 1 )
    {
         DNS_LOG_EVENT(
            DNS_EVENT_SINGLE_LABEL_HOSTNAME,
            0,
            NULL,
            NULL,
            0 );
    }

    //
    //  get all IP addresses on server
    //      - get count of IP addresses
    //      - copy them to IP address array buffer
    //
    //  first try new enumeration, then fail over to gethostbyname()
    //  hostent, which has 35 IP limitation
    //

    g_ServerAddrs = Dns_GetLocalIpAddressArray();
    if ( ! g_ServerAddrs )
    {
        return( DNS_ERROR_NO_MEMORY );
    }

#if 0
    //
    //  DEVNOTE: give some thougth to failover from Dns_GetLocalIp...
    //
    if ( !g_ServerAddrs || g_ServerAddrs->AddrCount == 0 )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  retrieving local IP address list.\n"
            "\tNow parsing hostent address list.\n" ));
        if ( g_ServerAddrs )
        {
            FREE_HEAP( g_ServerAddrs );
        }
        i = 0;
        while ( phostent->h_addr_list[i] != NULL )
        {
            i++;
        }
        countIp = (DWORD) i;
        if ( countIp == 0 )
        {
            ASSERT( FALSE );
            return( WSANO_DATA );
        }

        g_ServerAddrs = Dns_CreateIpArray( countIp );
        if ( ! g_ServerAddrs )
        {
            return( DNS_ERROR_NO_MEMORY );
        }
        for (i=0; i<(INT)countIp; i++)
        {
            g_ServerAddrs->AddrArray[i] =
                *(PIP_ADDRESS) phostent->h_addr_list[i];
        }
    }
#endif

    IF_DEBUG( INIT )
    {
        DnsDbg_IpArray(
            "Server addresses:\n",
            NULL,
            g_ServerAddrs );
    }

    //
    //  check admin configured IP addresses from registry
    //

    if ( SrvCfg_aipListenAddrs )
    {
        IF_DEBUG( INIT )
        {
            DnsDbg_IpArray(
                "Listen IP addresses from registry\n",
                NULL,
                SrvCfg_aipListenAddrs );
        }
        Dns_RemoveZerosFromIpArray( SrvCfg_aipListenAddrs );
        IF_DEBUG( INIT )
        {
            DnsDbg_IpArray(
                "After NULLs deleted\n",
                NULL,
                SrvCfg_aipListenAddrs );
        }
        fregistryListen = TRUE;

        //
        //  get array of addresses that are in listen list AND
        //      available on the machines
        //

        status = Dns_IntersectionOfIpArrays(
                     g_ServerAddrs,
                     SrvCfg_aipListenAddrs,
                     &g_BoundAddrs
                     );
        if( status != ERROR_SUCCESS )
        {
            return (status);
        }

        IF_DEBUG( SOCKET )
        {
            DnsDbg_IpArray(
                "Bound IP addresses:\n",
                NULL,
                g_BoundAddrs );
        }

        //
        //  if ListenAddress list was busted or out of date, may not
        //  have intersection between bindings and listen list
        //

        if ( g_BoundAddrs->AddrCount == 0 )
        {
            IF_DEBUG( ANY )
            {
                DNS_PRINT((
                    "ERROR:  Listen Address list contains no valid entries.\n" ));
                DnsDbg_IpArray(
                    "Listen IP addresses from registry\n",
                    NULL,
                    SrvCfg_aipListenAddrs );
            }

            FREE_HEAP( g_BoundAddrs );
            g_BoundAddrs = Dns_CreateIpArrayCopy( g_ServerAddrs );
            IF_NOMEM( ! g_BoundAddrs )
            {
                return( DNS_ERROR_NO_MEMORY );
            }

            FREE_HEAP( SrvCfg_aipListenAddrs );
            SrvCfg_aipListenAddrs = NULL;
            fregistryListen = FALSE;

            Reg_DeleteValue(
                NULL,
                NULL,
                DNS_REGKEY_LISTEN_ADDRESSES );

            DNS_LOG_EVENT(
                DNS_EVENT_INVALID_LISTEN_ADDRESSES,
                0,
                NULL,
                NULL,
                0 );
        }

        //
        //  log a warning, if listen list contains addresses not on machine
        //

        else if ( g_BoundAddrs->AddrCount
                    < SrvCfg_aipListenAddrs->AddrCount )
        {
            DNS_LOG_EVENT(
                DNS_EVENT_UPDATE_LISTEN_ADDRESSES,
                0,
                NULL,
                NULL,
                0 );
        }

        Dns_RemoveZerosFromIpArray( g_BoundAddrs );
    }

    //
    //  no explicit listen addresses, use ALL server addresses
    //
    //  log warning if hostent list was completely full, because in this
    //  case we may have dropped addresses that user wanted to have server
    //  respond to
    //
    //  screen out zero IPs -- unconnected RAS adapters show up as
    //  zero IPs in list
    //

    else
    {
        g_BoundAddrs = Dns_CreateIpArrayCopy( g_ServerAddrs );
        IF_NOMEM( ! g_BoundAddrs )
        {
            return( DNS_ERROR_NO_MEMORY );
        }
#if 0
        Dns_CleanIpArray(
            g_BoundAddrs,
            SrvCfg_fListenOnAutonet
                ?   DNS_IPARRAY_CLEAN_ZERO
                :   (DNS_IPARRAY_CLEAN_ZERO | DNS_IPARRAY_CLEAN_AUTONET)
            );
#endif
        Dns_RemoveZerosFromIpArray( g_BoundAddrs );
        IF_DEBUG( INIT )
        {
            DnsDbg_IpArray(
                "After Eliminating NULLs we are listening on:\n",
                NULL,
                g_BoundAddrs );
        }
        fregistryListen = FALSE;
    }

    //
    //  Setup connection list
    //

    Tcp_ConnectionListInitialize();

    //
    //  open listening sockets
    //

    FD_ZERO( &g_fdsListenTcp );         // zero listening FD_SETS

    status = openListeningSockets();

    IF_DEBUG( INIT )
    {
        DnsDbg_IpArray(
            "Server IP addresses:\n",
            NULL,
            g_ServerAddrs );
        DnsDbg_IpArray(
            "Bound IP addresses:\n",
            NULL,
            g_BoundAddrs );
    }
    return( status );
}



DNS_STATUS
Sock_ChangeServerIpBindings(
    VOID
    )
/*++

Routine Description:

    Change IP interface bindings of DNS server.

    May be called due to
        - PnP event (service controller sends PARAMCHANGE)
        - listen list is altered by admin

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_INVALID_IP_ADDRESS if listen change and no valid listening addrs.
    Error code on failure.

--*/
{
    DWORD           countIp;
    PIP_ARRAY       machineAddrs = NULL;
    PIP_ARRAY       newBoundAddrs = NULL;
    DWORD           status;
    BOOL            bpnpChange = FALSE;

    //
    //  log PnP event
    //

    Log_Printf( "PnP Event:  rechecking server bindings.\r\n" );

    //
    // Use Glenn's API, Dns_GetIpAddressList to get the new list of
    // IP Addresses. Note that this function is usable only if the caching
    // resolver is running. Also this function will be called only if the
    // caching resolver is running. So we're ok
    //
    //
    //  DEVNOTE: again this is broken, unable to keep running with no IP interfaces
    //

    machineAddrs = Dns_GetLocalIpAddressArray();
    if ( !machineAddrs )
    {
        ASSERT( FALSE );
        status = DNS_ERROR_NO_MEMORY;
        goto Exit;
    }
    ASSERT_IF_HUGE_ARRAY( machineAddrs );

    IF_DEBUG( SOCKET )
    {
        LOCK_SOCKET_LIST_DEBUG();
        DNS_PRINT(( "Sock_ChangeServerIpBindings()\n" ));
        Dbg_SocketList( "Socket list before change:" );
        DnsDbg_IpArray(
            "New machine Addrs:\n",
            NULL,
            machineAddrs );
        UNLOCK_SOCKET_LIST_DEBUG();
    }

    Config_UpdateLock();

    //
    //  specific listen addresses
    //      - either listen address or machine addresss may be new
    //      - compute intersection of listen and machine addresses,
    //      then diff with what is currently bound to DNS server to figure
    //      out what should be started
    //

    if ( SrvCfg_aipListenAddrs )
    {
        status = Dns_IntersectionOfIpArrays(
                     machineAddrs,
                     SrvCfg_aipListenAddrs,
                     & newBoundAddrs
                     );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT(( "DnsIntersectionofIpArrays failed with %p\n", status ));
            goto Exit;
        }
        ASSERT_IF_HUGE_ARRAY( newBoundAddrs );

        //  check that have an intersection, if entering new addresses from admin

        if ( newBoundAddrs->AddrCount == 0 && SrvCfg_fListenAddrsStale )
        {
            status = DNS_ERROR_INVALID_IP_ADDRESS;
            goto Exit;
        }
    }

    //  no listening addrs, then will bind to all addrs
    //
    //  screen out zero IPs -- unconnected RAS adapters show up as
    //  zero IPs in list

    else
    {
        newBoundAddrs = Dns_CreateIpArrayCopy( machineAddrs );
        IF_NOMEM( !newBoundAddrs )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Exit;
        }
#if 0
        Dns_CleanIpArray(
            newBoundAddrs,
            SrvCfg_fListenOnAutonet
                ?   DNS_IPARRAY_CLEAN_ZERO
                :   (DNS_IPARRAY_CLEAN_ZERO | DNS_IPARRAY_CLEAN_AUTONET)
            );
#endif
        Dns_RemoveZerosFromIpArray( newBoundAddrs );
    }
    IF_DEBUG( SOCKET )
    {
        DnsDbg_IpArray(
            "New binding addrs:\n",
            NULL,
            newBoundAddrs );
    }

    //
    //  detect if actual PnP change
    //
    //  socket code figures differences directly in socket lists,
    //  which is more robust if a socket is lost;
    //
    //  however for determining if change has actually occured --
    //  for purposes of rebuilding default records (below), want
    //  to know if actual change
    //

    if ( ! Dns_AreIpArraysEqual( newBoundAddrs, g_BoundAddrs ) )
    {
        DNS_DEBUG( PNP, (
            "New binding list after PnP, different from previous.\n" ));
        bpnpChange = TRUE;
    }

    //  no protection required here
    //      - timeout free keeps other users happy
    //      - only doing this on SC thread, so no race

    Timeout_Free( g_ServerAddrs );
    g_ServerAddrs = machineAddrs;
    machineAddrs = NULL;        // skip free

    Timeout_Free( g_BoundAddrs );
    g_BoundAddrs = newBoundAddrs;
    newBoundAddrs = NULL;       // skip free

    //
    //  open sockets for the newly arrived folks and closesockets for those
    //  guys who have left the building
    //
    //  DEVNOTE: PnP clean up;  when open listen socket, assoc. completion port
    //

    status = openListeningSockets();
    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT(( "openListeningSockets failed with %d %p\n", status, status ));
        goto Exit;
    }

    status = Sock_StartReceiveOnUdpSockets();

Exit:

    ASSERT_IF_HUGE_ARRAY( SrvCfg_aipListenAddrs );
    ASSERT_IF_HUGE_ARRAY( g_ServerAddrs );
    ASSERT_IF_HUGE_ARRAY( g_BoundAddrs  );

    IF_DEBUG( SOCKET )
    {
        LOCK_SOCKET_LIST_DEBUG();
        DNS_PRINT(( "Leaving Sock_ChangeServerIpBindings()\n" ));
        Dbg_SocketList( "Socket list after PnP:" );
        DnsDbg_IpArray(
            "New bound addrs:\n",
            NULL,
            g_BoundAddrs );
        UNLOCK_SOCKET_LIST_DEBUG();
    }

    Config_UpdateUnlock();

    //  free IP arrays in error path

    if ( machineAddrs )
    {
        FREE_HEAP( machineAddrs );
    }
    if ( newBoundAddrs )
    {
        FREE_HEAP( newBoundAddrs );
    }

    //
    //  update auto-configured records for local DNS registration
    //
    //  note:  there's a problem with PnP activity causing DNS client
    //  to do delete update to remove DNS server's own address;
    //  to protect against this we'll redo the auto-config, even if
    //  we detect no change;  except we'll protect against needlessly
    //  do
    //

#if 0
    if ( bpnpChange || g_LastAutoConfig + PNP_AUTO_CONFIG_WAIT_INTERVAL < DNS_TIME() )
    {
        Zone_UpdateOwnRecords( TRUE );
    }
#endif

    //  just do it every time for robustness sake

    Zone_UpdateOwnRecords( TRUE );

    return( status );
}



DNS_STATUS
openListeningSockets(
    VOID
    )
/*++

Routine Description:

    Open listen sockets on addresses specified.

Arguments:

    None.

Globals:

    Read access to server IP addr list globals:
        g_BoundAddrs
        SrvCfg_aipListenAddrs
        g_ServerAddrs

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    SOCKET      s;
    IP_ADDRESS  ip;
    SOCKET      previousUdpZeroSocket;
    BOOL        fneedSendSocket = FALSE;
    BOOL        flistenOnAll;
    WORD        bindPort = htons( ( WORD ) SrvCfg_dwSendPort );
    DWORD       status;
    DWORD       flags;
    DWORD       sockCreateflags = DNSSOCK_LISTEN | DNSSOCK_REUSEADDR;

    if ( bindPort == DNS_PORT_NET_ORDER )
    {
        sockCreateflags |= DNSSOCK_NOEXCLUSIVE;
    }

    //
    //  implemenation note
    //
    //  note, i've reworked this code so that all the socket closure (and removal)
    //  is done at the end;  i believe it is now in a state where we'll always
    //  have a valid socket
    //

    LOCK_SOCKET_LIST();

    ASSERT( g_BoundAddrs );

    ASSERT( !SrvCfg_aipListenAddrs ||
        (SrvCfg_aipListenAddrs->AddrCount >= g_BoundAddrs->AddrCount) );

    ASSERT( g_ServerAddrs->AddrCount >= g_BoundAddrs->AddrCount );

    //
    //  determine if currently using all interfaces
    //  if no listen list, then obviously listening on all
    //  if listen list, then must verify that all addresses certainly
    //
    //  DEVNOTE: assumes ServerAddresses contains no dups
    //

    flistenOnAll = ! SrvCfg_aipListenAddrs;
    if ( !flistenOnAll )
    {
        flistenOnAll = ( g_ServerAddrs->AddrCount == g_BoundAddrs->AddrCount );
    }

    //
    //  UDP sockets
    //
    //  to make sure we return to client with source IP the same as IP
    //  the client sent to, UDP listen sockets are ALWAYS bound to specific
    //  IP addresses
    //
    //  set UDP receive buffer size
    //  if small number of sockets, use large receive buffer
    //  if many sockets, this is too expensive, so we use default
    //  variable itself serves as the flag
    //

    if ( g_BoundAddrs->AddrCount <= 3 )
    {
        g_UdpRecvBufferSize = UDP_MAX_RECV_BUFFER_SIZE;
    }
    else if ( g_BoundAddrs->AddrCount > MANY_IP_WARNING_COUNT )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_MANY_IP_INTERFACES,
            0,
            NULL,
            NULL,
            0 );
    }

    //
    //  open\close bound UDP sockets to match current bound addrs
    //
    //  If the BindPort is set to the DNS port, we cannot use exclusive
    //  socket mode because we will need to open multiple sockets on this
    //  port!
    //

    flags = DNSSOCK_REUSEADDR | DNSSOCK_LISTEN;
    if ( bindPort == DNS_PORT_NET_ORDER )
    {
        flags |= DNSSOCK_NOEXCLUSIVE;
    }
    status = Sock_ResetBoundSocketsToMatchIpArray(
                g_BoundAddrs,
                SOCK_DGRAM,
                DNS_PORT_NET_ORDER,
                flags,
                FALSE               // do not close zero-bound, handled below
                );
#if DBG
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "ERROR:  creating UDP listen sockets %p (%d)\n",
            status, status ));
    }
#endif

    //  may run with no interfaces now for PnP

    if ( g_UdpBoundSocketCount == 0 )
    {
        DNS_PRINT(( "WARNING:  no UDP listen sockets!!!\n" ));
        ASSERT( g_BoundAddrs->AddrCount == 0 );

        Log_Printf( "WARNING:  NO UDP listen sockets!\r\n" );
    }

    //
    //  send sockets:
    //      -- determine UDP send socket
    //      -- determine TCP send socket port binding
    //
    //  four basic cases:
    //
    //  0) not sending on port-53
    //  in this case must have separate send socket
    //
    //  1) single socket for DNS
    //  in this case just use it, all DNS traffic
    //
    //  2) all IP interfaces used by DNS
    //  in this case, use INADDR_ANY socket;  stack selects best
    //  interface, but since DNS will be listening on whatever it
    //  selects, we're ok
    //
    //  3) multiple IPs, some not used
    //  in this case, use first interface;  we'll be broken in the case
    //  of disjoint nets, but there's nothing we can do about it anyway
    //
    //  Note:  DisjointNets "fix" is only guaranteed to work in case #2.
    //  In case #3 there may be a problem depending on the whether the IP
    //  the stack selects is used by the DNS server.  However, for backward
    //  compatibility, we'll at least TRY the INADDR_ANY socket when
    //  DisjointNets is setup -- in some cases it will suffice.
    //
    //
    //  non-DNS port binding
    //
    //  some folks who wish to firewall off DNS queries, will
    //  want to do sends on non-DNS port (non-53);
    //  this UDP socket must be added to listen list in order to receive
    //  responses, but it will use the same binding address as selected
    //  by the three cases above;  currently just using INADDR_ANY in all
    //  cases
    //
    //  DEVNOTE: need to handle no active interfaces when load case
    //
    //  DEVNOTE: better solution:  always go INADDR_ANY to send, screen out queries
    //              on that socket accepting only sends
    //
    //  DEVNOTE: probably best to default to opening non-53 send socket, only
    //              do 53 when forced
    //

    //  backward compatibility

    fneedSendSocket = TRUE;

    //  if binding port is DNS port, then need special handling
    //      - if single interface, just use it -- no send socket necessary
    //      - if listening on all interfaces -- build ANY_ADDR socket
    //      - if not listening on some interfaces (refused port 53 bind)
    //

    if ( bindPort == DNS_PORT_NET_ORDER )
    {
        if ( g_UdpBoundSocketCount == 1 )
        {
            //  only listening on one socket, so just use it for send

            fneedSendSocket = FALSE;
        }
        else if ( !flistenOnAll )
        {
            //  multi-homed and not using all interfaces;  to protect against
            //  disjoint nets the safest course is to go off port 53

            bindPort = 0;
            DNS_LOG_EVENT(
                DNS_EVENT_NON_DNS_PORT,
                0,
                NULL,
                NULL,
                0 );

        }
    }

    //
    //  UDP send socket uses first listen socket
    //      - this is "listening-on-one-socket" case above
    //      - note, may have multiple IP in g_BoundAddrs, but have failed
    //      to bind to all but one (perhaps NOT the first one);  in that case
    //      just build non-53 send socket
    //
    //  DEVNOTE: or create zero-bound non-listening send socket
    //      - desired IPs have sockets that get packets that match them
    //      - small tcp/ip recv buffer gets filled, but never recv
    //          so quickly just drop on floor
    //

    previousUdpZeroSocket = g_UdpZeroBoundSocket;

    if ( !fneedSendSocket )
    {
        ip = g_BoundAddrs->AddrArray[0];

        s = Sock_GetAssociatedSocket( ip, SOCK_DGRAM );
        if ( s != DNS_INVALID_SOCKET )
        {
            g_UdpSendSocket = s;
            g_UdpZeroBoundSocket = 0;
        }
        else
        {
            DNS_DEBUG( ANY, (
                "ERROR:  No UDP socket on bound IP %s"
                "\tcan NOT use as send socket, building separate send socket.\n",
                IP_STRING( ip ) ));
            bindPort = 0;
            fneedSendSocket = TRUE;
        }
    }

    //
    //  need INADDR_ANY UDP send socket
    //
    //  if previous zero bound UDP send socket exists, we can use it
    //  as long as we haven't done a port switch (to or from non-53)
    //
    //  non-53 bound socket must listen to recv() responses
    //  53 send socket only exists when already listening on all IP interfaces
    //      sockets, so no need to listen on it
    //
    //  DEVNOTE: allow for port 53 usage of disjoint send by screening response
    //              then

    if ( fneedSendSocket && bindPort != g_SendBindingPort )
    {
        s = Sock_CreateSocket(
                    SOCK_DGRAM,
                    INADDR_ANY,     // not bound to interface
                    bindPort,
                    sockCreateflags );
        if ( s == DNS_INVALID_SOCKET )
        {
            status = WSAGetLastError();
            DNS_PRINT((
                "ERROR:  Failed to open UDP send socket.\n"
                "\tport = %hx\n",
                bindPort ));
            status = ERROR_INVALID_HANDLE;
            goto Failed;
        }
        g_UdpSendSocket = s;
        g_SendBindingPort = bindPort;
        g_UdpZeroBoundSocket = s;
    }

    //
    //  close any previous unbound UDP send socket
    //  can happen when
    //      - no longer using unbound send socket
    //      - switch to or from using non-53 port
    //
    //  UDP send socket which was listen socket need not be closed;  it was
    //  either already closed OR is still in use
    //

    if ( previousUdpZeroSocket &&
        previousUdpZeroSocket != g_UdpSendSocket )
    {
        Sock_CloseSocket( previousUdpZeroSocket );
    }

    //
    //  TCP sockets -- two main cases
    //
    //  1) listening on ALL
    //      - use single INADDR_ANY bound socket
    //      (this saves non-paged pool and instructions during recvs())
    //      - close any previous individually bound sockets
    //      - then create single listen socket
    //
    //  2) listen on individual sockets
    //      - close any listen on all socket
    //      - close any sockets on remove addrs (like UDP case)
    //      - open sockets on new addrs (like UDP)
    //
    //  Note, reuseaddr used with all listening sockets, simply to avoid
    //  failure when attempt to create new socket, right after close of
    //  previous listen socket.  Winsock (or the stack) may not be cleaned
    //  up enough to allow the create to succeed.
    //

    if ( flistenOnAll )
    {
        Sock_CloseSocketsListeningOnUnusedAddrs(
                NULL,           // remove all bound TCP sockets
                SOCK_STREAM,
                FALSE,          // don't remove zero bound (if exists)
                FALSE           // don't close loopback -- though don't need it
                );

        if ( !g_TcpZeroBoundSocket )
        {
            s = Sock_CreateSocket(
                    SOCK_STREAM,
                    0,
                    DNS_PORT_NET_ORDER,
                    sockCreateflags
                    );
            if ( s == DNS_INVALID_SOCKET )
            {
                DNS_PRINT(( "ERROR:  unable to create zero-bound TCP socket!\n" ));
                goto Failed;
            }
            ASSERT( g_TcpZeroBoundSocket == s );
        }
    }

    //
    //  listening on individual interfaces
    //
    //  handle like UDP:
    //      - close sockets for IP not currently in Bound list
    //      - create sockets for bound IP, that do not currently exist
    //

    else
    {
        status = Sock_ResetBoundSocketsToMatchIpArray(
                    g_BoundAddrs,
                    SOCK_STREAM,
                    DNS_PORT_NET_ORDER,
                    DNSSOCK_REUSEADDR | DNSSOCK_LISTEN,
                    TRUE                // close zero-bound also
                    );
    }

#if 0
    //
    //  listening on individual interfaces
    //
    //  two cases:
    //      1) currently have zero bound
    //          - kill all TCP listens and rebuild
    //          - rebuild entire bound list
    //
    //      2) currently mixed socket list
    //          - kill only remove sockets
    //          - rebuild new addrs list
    //

    else if ( g_TcpZeroBoundSocket )   // listen on individual addresses
    {

        //  remove zero bound socket
        //      -- just remove all TCP listens for robustness

        Sock_CloseSocketsListeningOnAddrs(
                NULL,
                SOCK_STREAM,
                TRUE                //  and remove zero bound socket
                );

        ASSERT( g_TcpZeroBoundSocket == 0 );

        //  open socket on all bound interfaces

        Sock_CreateSocketsForIpArray(
            g_BoundAddrs,
            SOCK_STREAM,
            DNS_PORT_NET_ORDER,
            sockCreateflags
            );
    }

    else    // no zero bound socket
    {
        if ( pRemoveAddrs )
        {
            Sock_CloseSocketsListeningOnAddrs(
                    pRemoveAddrs,       //  remove retiring addresses
                    SOCK_STREAM,
                    TRUE                //  and remove zero bound socket
                    );
        }
        ASSERT( g_TcpZeroBoundSocket == 0 );

        //  open new interfaces

        Sock_CreateSocketsForIpArray(
            pAddAddrs,
            SOCK_STREAM,
            DNS_PORT_NET_ORDER,
            sockCreateflags
            );
    }
#endif

    status = ERROR_SUCCESS;

Failed:

    IF_DEBUG( SOCKET )
    {
        LOCK_SOCKET_LIST_DEBUG();
        Dbg_SocketList( "Socket list after openListeningSockets():" );
        DNS_PRINT((
            "\tSendBindingPort = %hx\n",
            ntohs( g_SendBindingPort ) ));
        DnsDbg_FdSet(
            "TCP Listen fd_set:",
            & g_fdsListenTcp );
        UNLOCK_SOCKET_LIST_DEBUG();
    }

    //
    //  wake TCP select() to rebuild array
    //  even if failure need to try to run with what we have
    //

    UNLOCK_SOCKET_LIST();

    Tcp_ConnectionListReread();

    return( status );

}   //  openListeningSockets



//
//  Socket creation functions.
//

SOCKET
Sock_CreateSocket(
    IN      INT         SockType,
    IN      IP_ADDRESS  ipAddress,
    IN      WORD        Port,
    IN      DWORD       Flags
    )
/*++

Routine Description:

    Create socket.

Arguments:

    SockType -- SOCK_DGRAM or SOCK_STREAM

    ipAddress -- IP address to listen on (net byte order)

    Port -- desired port in net order
                - DNS_PORT_NET_ORDER for DNS listen sockets
                - 0 for any port

    fReUseAddr -- TRUE if reuseaddr

    fListen -- TRUE if listen socket

Return Value:

    Socket if successful.
    DNS_INVALID_SOCKET otherwise.

--*/
{
    SOCKADDR_IN sockaddrIn;
    SOCKET      s;
    INT         err;
    INT         bindCount = 0;

    //
    //  create socket
    //      - for winsock 2.0, UDP sockets must be overlapped
    //

    if ( SockType == SOCK_DGRAM )
    {
        s = WSASocket(
                AF_INET,
                SockType,
                IPPROTO_UDP,
                NULL,       // no protocol info
                0,          // no group
                WSA_FLAG_OVERLAPPED );
        if ( s == INVALID_SOCKET )
        {
            DNS_LOG_EVENT(
                DNS_EVENT_CANNOT_CREATE_UDP_SOCKET,
                0,
                NULL,
                NULL,
                GetLastError() );
            goto Failed;
        }
    }
    else
    {
        s = socket( AF_INET, SockType, 0 );
        if ( s == INVALID_SOCKET )
        {
            DNS_LOG_EVENT(
                DNS_EVENT_CANNOT_CREATE_TCP_SOCKET,
                0,
                NULL,
                NULL,
                GetLastError() );
            goto Failed;
        }
#if DBG
        if ( ! g_SendBufferSize )
        {
            DWORD   optionLength = sizeof(DWORD);

            getsockopt( s, SOL_SOCKET, SO_SNDBUF, (PCHAR)&g_SendBufferSize, &optionLength );
            DNS_DEBUG( ANY, (
                "TCP send buffer length = %d\n",
                g_SendBufferSize ));
        }
#endif
    }
    ASSERT( s != 0 && s != INVALID_SOCKET );

    //
    //  set socket to reuse address
    //

#if 0
    if ( Flags & DNSSOCK_REUSEADDR )
    {
        BOOL   optval = 1;

        err = setsockopt(
                s,
                SOL_SOCKET,
                SO_REUSEADDR,
                (char *) &optval,
                sizeof(BOOL) );
        if ( err )
        {
            ASSERT( err == SOCKET_ERROR );
            DNS_DEBUG( INIT, (
                "ERROR:  setsockopt(%d, REUSEADDR) failed.\n"
                "\twith error = %d.\n",
                s,
                GetLastError() ));
            //goto Failed;
        }
    }
#endif

#if 1
    //
    //  grab exclusive ownership of this socket
    //      - prevents ordinary user from using
    //

    if ( Port != 0 &&
         SockType == SOCK_DGRAM &&
         !( Flags & DNSSOCK_NOEXCLUSIVE ) )
    {
        DWORD   optval = 1;

        err = setsockopt(
                s,
                SOL_SOCKET,
                SO_EXCLUSIVEADDRUSE,
                (char *) &optval,
                sizeof( DWORD ) );
        if ( err )
        {
            ASSERT( err == SOCKET_ERROR );
            DNS_DEBUG( INIT, (
                "ERROR:  setsockopt(%d, EXCLUSIVEADDRUSE) failed.\n"
                "\twith error = %d.\n",
                s,
                GetLastError() ));
        }
    }
#endif

    //
    //  bind socket
    //
    //  do in loop and attempt re-binding with REUSEADDR if first bind()
    //      fails with ADDRINUSE

    RtlZeroMemory( &sockaddrIn, sizeof(sockaddrIn) );
    sockaddrIn.sin_family = AF_INET;
    sockaddrIn.sin_port = Port;
    sockaddrIn.sin_addr.s_addr = ipAddress;

    while ( 1 )
    {
        LPSTR  pszIp;

        err = bind( s, (PSOCKADDR)&sockaddrIn, sizeof(sockaddrIn) );
        if ( err == 0 )
        {
            break;
        }
        err = (INT) GetLastError();

        pszIp = inet_ntoa( sockaddrIn.sin_addr );

        DNS_DEBUG( INIT, (
            "Failed to bind() socket %d, to port %d, address %s.\n"
            "\terror = %d.\n",
            s,
            ntohs(Port),
            pszIp,
            err ));

        //
        //  If the bind fails with error WSAEADDRINUSE, try clearing
        //  SO_EXCLUSIVEADDRUSE and setting SO_REUSEADDR. Not that these
        //  two options are mutually exclusive, so if EXCL is set it is
        //  not possible to set REUSE.
        //

        if ( bindCount == 0  &&  err == WSAEADDRINUSE )
        {
            BOOL    optval = 0;
            INT     terr;

            terr = setsockopt(
                    s,
                    SOL_SOCKET,
                    SO_EXCLUSIVEADDRUSE,
                    (char *) &optval,
                    sizeof(BOOL) );
            DNS_DEBUG( INIT, (
                "setsockopt(%d, EXCLUSIVEADDRUSE, %d) %s\n"
                "\twith error = %d.\n",
                s,
                optval,
                terr == 0 ? "succeeded" : "failed",
                GetLastError() ));

            optval = 1;
            terr = setsockopt(
                    s,
                    SOL_SOCKET,
                    SO_REUSEADDR,
                    (char *) &optval,
                    sizeof(BOOL) );
            if ( terr == 0 )
            {
                DNS_DEBUG( INIT, (
                    "Attempt rebind on socket %d with REUSEADDR.\n",
                    s ));
                bindCount++;
                continue;
            }
            DNS_DEBUG( INIT, (
                "ERROR:  setsockopt(%d, REUSEADDR, %d) failed.\n"
                "\twith error = %d.\n",
                s,
                optval,
                GetLastError() ));
        }

        //  log bind failure

        if ( SockType == SOCK_DGRAM )
        {
            DNS_LOG_EVENT(
                DNS_EVENT_CANNOT_BIND_UDP_SOCKET,
                1,
                & pszIp,
                EVENTARG_ALL_UTF8,
                err );
        }
        else
        {
            DNS_LOG_EVENT(
                DNS_EVENT_CANNOT_BIND_TCP_SOCKET,
                1,
                & pszIp,
                EVENTARG_ALL_UTF8,
                err );
        }
        goto Failed;
    }

    //
    //  set as non-blocking?
    //
    //  this makes all accept()ed sockets non-blocking
    //

    if ( ! (Flags & DNSSOCK_BLOCKING) )
    {
        err = TRUE;
        ioctlsocket( s, FIONBIO, &err );
    }

    //
    //  listen on socket?
    //      - set actual listen for TCP
    //      - configure recv buffer size for UDP
    //
    //  if only a receiving interfaces (only a few UDP listen sockets),
    //  then set a 64K recv buffer per socket;
    //  this allows us to queue up roughly 1000 typical UDP messages
    //  if lots of sockets this is too expensive so stay with default 8K
    //

    if ( Flags & DNSSOCK_LISTEN )
    {
        if ( SockType == SOCK_STREAM )
        {
            err = listen( s, LISTEN_BACKLOG );
            if ( err == SOCKET_ERROR )
            {
                PVOID parg = (PVOID)(ULONG_PTR)ipAddress;

                err = GetLastError();
                Sock_CloseSocket( s );

                DNS_LOG_EVENT(
                    DNS_EVENT_CANNOT_LISTEN_TCP_SOCKET,
                    1,
                    & parg,
                    EVENTARG_ALL_IP_ADDRESS,
                    err );
                goto Failed;
            }
        }
        else if ( g_UdpRecvBufferSize )
        {
            if ( setsockopt(
                    s,
                    SOL_SOCKET,
                    SO_RCVBUF,
                    (PCHAR) &g_UdpRecvBufferSize,
                    sizeof(INT) ) )
            {
                DNS_PRINT((
                    "ERROR:  %d setting larger socket recv buffer on socket %d.\n",
                    WSAGetLastError(),
                    s ));
            }
        }
    }

    //
    //  add to socket to socket list
    //

    if ( ! (Flags & DNSSOCK_NO_ENLIST) )
    {
        Sock_EnlistSocket( s, SockType, ipAddress, Port, (DNSSOCK_LISTEN & Flags) );
    }

    DNS_DEBUG( SOCKET, (
        "Created socket %d, of type %d, for address %s, port %d.\n"
        "\tlisten = %d, reuse = %d, blocking = %d, exclusive = %d\n",
        s,
        SockType,
        inet_ntoa( sockaddrIn.sin_addr ),
        ntohs(Port),
        (DNSSOCK_LISTEN & Flags),
        (DNSSOCK_REUSEADDR & Flags),
        (DNSSOCK_BLOCKING & Flags),
        !(DNSSOCK_NOEXCLUSIVE & Flags)
        ));

    return s;

Failed:

    //
    //  DEVNOTE: different event for runtime socket create failure?
    //

    DNS_DEBUG( SOCKET, (
        "ERROR:  Unable to create socket of type %d, for address %s, port %d.\n"
        "\tlisten = %d, reuse = %d, blocking = %d\n",
        SockType,
        IP_STRING( ipAddress ),
        ntohs(Port),
        (DNSSOCK_LISTEN & Flags),
        (DNSSOCK_REUSEADDR & Flags),
        (DNSSOCK_BLOCKING & Flags)
        ));
    {
        PVOID parg = (PVOID) (ULONG_PTR) ipAddress;

        DNS_LOG_EVENT(
            DNS_EVENT_OPEN_SOCKET_FOR_ADDRESS,
            1,
            & parg,
            EVENTARG_ALL_IP_ADDRESS,
            0 );
    }

    if ( s != 0  &&  s != INVALID_SOCKET )
    {
        closesocket( s );
    }
    return( DNS_INVALID_SOCKET );
}



DNS_STATUS
Sock_CreateSocketsForIpArray(
    IN      PIP_ARRAY       pIpArray,
    IN      INT             SockType,
    IN      WORD            Port,
    IN      DWORD           Flags
    )
/*++

Routine Description:

    Create sockets for all values in IP array.

Arguments:

    pIpArray    -- IP array

    SockType    -- SOCK_DGRAM or SOCK_STREAM

    ipAddress   -- IP address to listen on (net byte order)

    Port        -- desired port in net order
                    - DNS_PORT_NET_ORDER for DNS listen sockets
                    - 0 for any port

    fReUseAddr  -- TRUE if reuseaddr

    fListen     -- TRUE if listen socket

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_INVALID_HANDLE if unable to create one or more sockets.

--*/
{
    SOCKET      s;
    DWORD       i;
    DNS_STATUS  status = ERROR_SUCCESS;

    //
    //  loop through IP array creating socket on each address
    //

    for ( i=0; i<pIpArray->AddrCount; i++ )
    {
        s = Sock_CreateSocket(
                SockType,
                pIpArray->AddrArray[i],
                Port,
                Flags );

        if ( s == DNS_INVALID_SOCKET )
        {
            status = GetLastError();
            continue;
        }
    }
    return( status );
}



//
//  Socket list functions.
//
//  Maintain a list of sockets and their associated information.
//  This serves several functions:
//      - simple to close sockets on shutdown
//      - can determine IP binding from socket
//      - can find \ bind to completetion port
//

VOID
Sock_EnlistSocket(
    IN      SOCKET      Socket,
    IN      INT         SockType,
    IN      IP_ADDRESS  ipAddr,
    IN      WORD        Port,
    IN      BOOL        fListen
    )
/*++

Routine Description:

    Adds socket to dns socket list.

Arguments:

    socket -- socket to add

Return Value:

    None.

--*/
{
    PDNS_SOCKET pentry;
    INT         err;
    HANDLE      hport;

    //
    //  never add sockets after shutdown -- just kill 'em off
    //

    DNS_DEBUG( SOCKET, (
        "Enlisting socket %d type %d with ipaddr %s\n",
        Socket, SockType, IP_STRING(ipAddr) ));
    IF_DEBUG( SOCKET )
    {
        Dbg_SocketList( "Socket list before enlist:" );
    }

    if ( fDnsServiceExit )
    {
        DNS_DEBUG( SHUTDOWN, (
            "Attempt to add socket %d to list after shutdown.\n"
            "\tclosing socket instead.\n",
            socket ));
        closesocket( Socket );
        return;
    }

    //
    //  stick socket on socket list
    //

    pentry = (PDNS_SOCKET) ALLOC_TAGHEAP_ZERO( sizeof(DNS_SOCKET), MEMTAG_SOCKET );
    IF_NOMEM( !pentry )
    {
        goto Leave;
    }
    pentry->Socket   = Socket;
    pentry->SockType = SockType;
    pentry->ipAddr   = ipAddr;
    pentry->Port     = Port;
    pentry->fListen  = fListen;

    LOCK_SOCKET_LIST();

    InsertTailList( &g_SocketList, (PLIST_ENTRY)pentry );
    g_SocketListCount++;

    //  listen socket

    if ( fListen )
    {
        if ( SockType == SOCK_DGRAM )
        {
            if ( ipAddr != 0 )
            {
                g_UdpBoundSocketCount++;
            }
            pentry->Overlapped.Offset = 0;
            pentry->Overlapped.OffsetHigh = 0;
            pentry->Overlapped.hEvent = NULL;

            hport = CreateIoCompletionPort(
                        (HANDLE) Socket,
                        g_hUdpCompletionPort,
                        (UINT_PTR) pentry,
                        0       // threads matched to system processors
                        );
            if ( !hport )
            {
                DNS_PRINT(( "ERROR: in CreateIoCompletionPort\n" ));
                ASSERT( FALSE );
                goto Unlock;
            }
            ASSERT( hport == g_hUdpCompletionPort );
        }
        else
        {
            ASSERT( SockType == SOCK_STREAM );

            FD_SET( Socket, &g_fdsListenTcp );
            if ( ipAddr == INADDR_ANY )
            {
                g_TcpZeroBoundSocket = Socket;
            }
        }
    }

Unlock:

    UNLOCK_SOCKET_LIST();

Leave:

    DNS_DEBUG( SOCKET, (
        "\nEnlisted socket %d type %d for IP %s\n",
        Socket,
        SockType,
        IP_STRING(ipAddr) ));
    IF_DEBUG( SOCKET )
    {
        Dbg_SocketList( "Socket list after enlist:" );
    }
    return;
}



VOID
Sock_CloseSocket(
    IN      SOCKET      Socket
    )
/*++

Routine Description:

    Closes socket in socket list.

Arguments:

    socket -- socket to close

Return Value:

    None.

--*/
{
    PDNS_SOCKET pentry;
    INT         err;

    DNS_DEBUG( TCP, (
        "Closing socket %d and removing from list.\n",
        Socket ));

    //
    //  find socket in socket list
    //      - remove if in TCP listen list
    //      - dequeue and free
    //      - dec socket count
    //

    LOCK_SOCKET_LIST();

    for ( pentry = (PDNS_SOCKET) g_SocketList.Flink;
          pentry != (PDNS_SOCKET) &g_SocketList;
          pentry = (PDNS_SOCKET) pentry->List.Flink )
    {
        if ( pentry->Socket == Socket )
        {
            RemoveEntryList( (PLIST_ENTRY)pentry );

            if ( pentry->SockType == SOCK_STREAM &&
                 pentry->fListen )
            {
                FD_CLR( Socket, &g_fdsListenTcp );
            }
            Timeout_Free( pentry );
            g_SocketListCount--;
            break;
        }
    }
    UNLOCK_SOCKET_LIST();

    //
    //  close it down
    //      - do this whether we found it or not
    //

    err = closesocket( Socket );

    IF_DEBUG( ANY )
    {
        if ( pentry == (PDNS_SOCKET) &g_SocketList )
        {
            DNS_PRINT((
                "ERROR:  closed socket %d, not found in socket list.\n",
                Socket ));
        }

        DNS_DEBUG( TCP, (
            "Closed socket %d -- error %d.\n",
            Socket,
            err ? WSAGetLastError() : 0 ));

        if ( err )
        {
            DNS_PRINT((
                "WARNING:  closesocket( %d ) error %d\n"
                "\tsocket was %s socket list.\n",
                Socket,
                WSAGetLastError(),
                ( pentry == (PDNS_SOCKET) &g_SocketList ) ? "in" : "NOT in"
                ));
        }
    }
}



PDNS_SOCKET
sockFindDnsSocketForIpAddr(
    IN      IP_ADDRESS      ipAddr,
    IN      INT             iSockType
    )
/*++

Routine Description:

    Gets the socket info for a given ipaddress and type.
    Only interested in DNS port sockets.

Arguments:

    ipAddr -- IP address of socket entry to find

    iSockType -- type of socket desired

Return Value:

    Ptr to DNS_SOCKET struct matching IP and type.
    NULL if not found.

--*/
{
    PDNS_SOCKET     pentry;

    LOCK_SOCKET_LIST();

    for ( pentry = (PDNS_SOCKET) g_SocketList.Flink;
          pentry != (PDNS_SOCKET) &g_SocketList;
          pentry = (PDNS_SOCKET) pentry->List.Flink )
    {
        if ( pentry->ipAddr == ipAddr  &&
             pentry->SockType == iSockType &&
             pentry->Port == DNS_PORT_NET_ORDER )
        {
            goto Done;
        }
    }
    pentry = NULL;

Done:

    UNLOCK_SOCKET_LIST();
    return( pentry );
}



SOCKET
Sock_GetAssociatedSocket(
    IN      IP_ADDRESS      ipAddr,
    IN      INT             iSockType
    )
/*++

Routine Description:

    Gets the socket associated with a certain IP Address.
    This is the socket bound to the DNS port.

Arguments:

    ipAddr -- IP address of socket entry to find

    iSockType -- type of socket desired

Return Value:

    Socket, if socket found.
    Otherwise DNS_INVALID_SOCKET.

--*/
{
    PDNS_SOCKET     pentry;
    SOCKET          socket = 0;

    pentry = sockFindDnsSocketForIpAddr( ipAddr, iSockType );
    if ( pentry )
    {
        socket = pentry->Socket;
    }
    return( socket );
}



IP_ADDRESS
Sock_GetAssociatedIpAddr(
    IN      SOCKET      Socket
    )
/*++

Routine Description:

    Gets the ipaddress associated with a certain socket

Arguments:

    Socket -- associated with an ipAddr

Return Value:

    IP address socket is bound to.
    (-1) if not found in list.
    Zero when socket was bound to any address.

--*/
{
    PDNS_SOCKET     pentry;
    IP_ADDRESS      ipAddr = DNS_INVALID_IP;

    LOCK_SOCKET_LIST();

    for ( pentry = (PDNS_SOCKET) g_SocketList.Flink;
          pentry != (PDNS_SOCKET) &g_SocketList;
          pentry = (PDNS_SOCKET) pentry->List.Flink )
    {
        if ( pentry->Socket == Socket )
        {
            ipAddr = pentry->ipAddr;
            break;
        }
    }

    UNLOCK_SOCKET_LIST();
    return( ipAddr );
}




DNS_STATUS
Sock_StartReceiveOnUdpSockets(
    VOID
    )
/*++

Routine Description:

    Start receiving on any new sockets.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    PDNS_SOCKET   pentry;
    DWORD         status;
    DWORD         failedCount = 0;

    DNS_DEBUG( SOCKET, (
        "StartReceiveOnUdpSockets()\n" ));

    STAT_INC( PrivateStats.UdpRestartRecvOnSockets );
#if DBG
    if ( g_fUdpSocketsDirty )
    {
        Dbg_SocketList( "Socket list entering StartReceiveOnUdpSockets()" );
    }
#endif
    if ( SrvCfg_fTest1 )
    {
        Log_Printf( "Start listen on UDP sockets!\r\n" );
    }

    //
    //  go through list of UDP sockets
    //  enable receive on those listening sockets without a pending receive
    //      - hPort serves as a flag indicating socket has pending recv
    //      - note:  zeroing retry, as when we are rebuilding here because of
    //      lots of WSAECONNRESET failures, don't want to reset and then have
    //      the a failure on first recv (quite likely if we got here in the
    //      first place) send us back here immediately
    //

    LOCK_SOCKET_LIST();

    for ( pentry = (PDNS_SOCKET) g_SocketList.Flink;
          pentry != (PDNS_SOCKET) &g_SocketList;
          pentry = (PDNS_SOCKET) pentry->List.Flink )
    {
        if ( pentry->SockType == SOCK_DGRAM  &&
                pentry->fListen  &&
                pentry->hPort == 0 )
        {
            pentry->hPort = g_hUdpCompletionPort;
            pentry->fRetry = 0;
            if ( SrvCfg_fTest1 )
            {
                Log_Printf(
                    "(Re)start listen on UDP socket %d\r\n",
                    pentry->Socket );
            }
            Udp_DropReceive( pentry );
            if ( pentry->hPort == 0 )
            {
                Log_SocketFailure(
                    "Start UDP listen failed!",
                    pentry,
                    0 );
                failedCount++;
            }
        }
    }

    //  all UDP listen sockets successfully listening?

    if ( failedCount == 0 )
    {
        g_fUdpSocketsDirty = FALSE;
    }
    else
    {
        LOCK_SOCKET_LIST_DEBUG();
        DNS_DEBUG( ANY, (
            "ERROR:  StartReceiveOnUdpSockets() failed!\n"
            "\tfailedCount = %d.\n",
            failedCount ));
        Dbg_SocketList( "Socket list after StartReceiveOnUdpSockets()" );
        ASSERT( g_fUdpSocketsDirty );
        UNLOCK_SOCKET_LIST_DEBUG();
    }

    UNLOCK_SOCKET_LIST();

    IF_DEBUG( SOCKET )
    {
        Dbg_SocketList( "Socket list after StartReceiveOnUdpSockets()" );
    }
    return( ERROR_SUCCESS );
}



VOID
Sock_IndicateUdpRecvFailure(
    IN OUT  PDNS_SOCKET     pContext,
    IN      DNS_STATUS      Status
    )
/*++

Routine Description:

    Set a given socket\context to indicate failure of recv()

Arguments:

    pConext -- socket context

Return Value:

    None

--*/
{
    PDNS_SOCKET   pentry;
    DWORD         status;
    DWORD         finalStatus = ERROR_SUCCESS;

    DNS_DEBUG( ANY, (
        "ERROR:  Sock_IndicateUdpRecvFailure(), context = %p\n",
        pContext ));

    Log_SocketFailure(
        "ERROR:  RecvFrom() failed causing listen shutdown!",
        pContext,
        Status );

    //
    //  set flag under lock, so can't override reinitialization
    //

    STAT_INC( PrivateStats.UdpIndicateRecvFailures );
    LOCK_SOCKET_LIST();

    //  reset recv context to indicate error

    if ( pContext )
    {
        pContext->hPort = (HANDLE)NULL;
    }

    //  when flag set, reinitialization of uninitialized sockets will
    //      be done after timeout

    g_fUdpSocketsDirty = TRUE;

    UNLOCK_SOCKET_LIST();
}



VOID
Sock_CloseAllSockets(
    )
/*++

Routine Description:

    Close all outstanding sockets.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PDNS_SOCKET  pentry;
    SOCKET  s;
    INT     err;

    ASSERT( fDnsServiceExit );
    if ( g_SocketListCount == DNS_SOCKLIST_UNINITIALIZED )
    {
        return;
    }

    //
    //  close ALL outstanding sockets
    //

    IF_DEBUG( SHUTDOWN )
    {
        Dbg_SocketList( "Closing all sockets at shutdown:" );
    }

    LOCK_SOCKET_LIST();

    while ( !IsListEmpty(&g_SocketList) )
    {
        pentry = (PDNS_SOCKET) RemoveHeadList( &g_SocketList );
        g_SocketListCount--;

        s = pentry->Socket;
        err = closesocket( s );

        IF_DEBUG( SHUTDOWN )
        {
            DNS_PRINT((
                "Closing socket %d -- error %d.\n",
                s,
                err ? WSAGetLastError() : 0 ));
            DnsDebugFlush();
        }
        ASSERT( !err );

        Timeout_Free( pentry );
    }

    UNLOCK_SOCKET_LIST();
}


#if DBG

VOID
Dbg_SocketContext(
    IN      LPSTR           pszHeader,
    IN      PDNS_SOCKET     pContext
    )
{
    DnsPrintf(
        "%s\n"
        "\tptr          = %p\n"
        "\tsocket       = %d (%c)\n"
        "\tIP           = %s\n"
        "\tport         = %d\n"
        "\tstate        = %d\n"
        "\tlisten       = %d\n"
        "\thPort        = %d\n"
        "\tpCallback    = %p\n"
        "\tdwTimeout    = %d\n"
        "\tWsaBuf       = %p (length=%d)\n",
        pszHeader ? pszHeader : "DNS Socket Context:",
        pContext,
        pContext->Socket,
        (pContext->SockType == SOCK_DGRAM) ? 'U' : 'T',
        IP_STRING(pContext->ipAddr),
        ntohs( pContext->Port ),
        pContext->State,
        pContext->fListen,
        pContext->hPort,
        pContext->pCallback,
        pContext->dwTimeout,
        pContext->WsaBuf.buf,
        pContext->WsaBuf.len );
}



VOID
Dbg_SocketList(
    IN      LPSTR   pszHeader
    )
{
    PDNS_SOCKET   pentry;

    LOCK_SOCKET_LIST();

    Dbg_Lock();

    DnsPrintf(
        "%s\n"
        "\tSocket count     = %d\n"
        "\tTCP listen count = %d\n"
        "\tTCP zero socket  = %d\n"
        "\tUDP bound count  = %d\n"
        "\tUDP zero socket  = %d\n"
        "\tUDP send socket  = %d\n"
        "\tsock\ttype\t      IP       \tport\tlisten\thPort\n"
        "\t----\t----\t---------------\t----\t------\t-----\n",
        pszHeader ? pszHeader : "Socket List:",
        g_SocketListCount,
        g_fdsListenTcp.fd_count,
        g_TcpZeroBoundSocket,
        g_UdpBoundSocketCount,
        g_UdpZeroBoundSocket,
        g_UdpSendSocket
        );

    for ( pentry = (PDNS_SOCKET) g_SocketList.Flink;
          pentry != (PDNS_SOCKET) &g_SocketList;
          pentry = (PDNS_SOCKET) pentry->List.Flink )
    {
        ASSERT( pentry );
        DnsPrintf(
            "\t%4d\t%c\t%15s\t%4d\t%d\t%d\n",
            pentry->Socket,
            (pentry->SockType == SOCK_DGRAM) ? 'U' : 'T',
            IP_STRING(pentry->ipAddr),
            ntohs( pentry->Port ),
            pentry->fListen,
            pentry->hPort
            );

    }
    Dbg_Unlock();

    UNLOCK_SOCKET_LIST();
}
#endif

//
//  End socket.c
//



LPSTR
Dns_GetLocalDnsName(
    VOID
    )
/*++

Routine Description:

    Get DNS name of local machine.

    Name is returned in UTF8

Arguments:

    None

Return Value:

    Ptr to machines DNS name -- caller must free.
    NULL on error.

--*/
{
    DNS_STATUS      status;
    DWORD           length;
    DWORD           countIp;
    INT             i;
    PCHAR           pszname;
    DWORD           size;
    PCHAR           pszhostFqdn;
    struct hostent * phostent;
    ANSI_STRING     ansiString;
    UNICODE_STRING  unicodeString;
    CHAR            szhostName[ DNS_MAX_NAME_BUFFER_LENGTH ];
    WCHAR           wszhostName[ DNS_MAX_NAME_BUFFER_LENGTH ];


    DNSDBG( SOCKET, (
        "Dns_GetLocalDnsName()\n" ));

    //
    //  get local machines FQDN (in unicode)
    //  if fails settle for host name
    //

    size = DNS_MAX_NAME_BUFFER_LENGTH;

    if ( ! GetComputerNameExW(
                ComputerNameDnsFullyQualified,
                wszhostName,
                &size
                ) )
    {
        status = GetLastError();
        DNS_PRINT((
            "ERROR:  GetComputerNameExW() failed!\n"
            "\tGetLastError = %d (%p)\n",
            status, status ));

        // reset size back to max buffer length
        size = DNS_MAX_NAME_BUFFER_LENGTH;

        if ( ! GetComputerNameExW(
                    ComputerNameDnsHostname,
                    wszhostName,
                    &size
                    ) )
        {
            status = GetLastError();
            DNS_PRINT((
                "ERROR:  GetComputerNameExW() failed -- NO HOSTNAME!\n"
                "\tGetLastError = %d (%p)\n",
                status, status ));
            ASSERT( FALSE );
            return( NULL );
        }
    }

    DNSDBG( SOCKET, (
        "GetComputerNameEx() FQDN = <%S>\n"
        "\tsize = %d\n",
        wszhostName,
        size ));

    pszname = Dns_NameCopyAllocate(
                (PCHAR) wszhostName,
                size,
                DnsCharSetUnicode,   // unicode in
                DnsCharSetUtf8       // UTF8 out
                );
    if ( !pszname )
    {
        ASSERT( FALSE );
        return( NULL );
    }

    DNSDBG( SOCKET, (
        "GetComputerNameEx() FQDN UTF8 = <%s>\n",
        pszname ));
    return( pszname );

    //
    //  read server host name
    //

    if ( gethostname( szhostName, DNS_MAX_NAME_LENGTH ) )
    {
        status = WSAGetLastError();
        DNS_PRINT(( "ERROR:  gethostname() failure %d.\n", status ));
        return( NULL );
    }
    DNS_DEBUG( INIT, ( "DNS server hostname = %s\n", szhostName ));

    //  return hostname if that's all user wants
#if 0
    if ( )
    {
        pszname = Dns_CreateStringCopy( szhostName, 0 );
        if ( ! pszname )
        {
            SetLastError( DNS_ERROR_NO_MEMORY );
            return( NULL );
        }
        return( pszname );
    }
#endif

    //
    //  get server's hostent
    //      - contains alias list, use for server FQDN
    //      - contains IP address list
    //

    phostent = gethostbyname( szhostName );
    if ( ! phostent )
    {
        DNS_PRINT(( "ERROR:  gethostbyname() failure %d.\n", status ));
        return( NULL );
    }

    //
    //  find server FQDN
    //      - if none available, use plain hostname

    DNSDBG( SOCKET, ( "Parsing hostent alias list.\n" ));

    i = -1;
    pszhostFqdn = phostent->h_name;

    while ( pszhostFqdn )
    {
        DNSDBG( SOCKET, (
            "Host alias[%d] = %s.\n",
            i,
            pszhostFqdn ));

        if ( strchr( pszhostFqdn, '.' ) )
        {
            break;
        }
        pszhostFqdn = phostent->h_aliases[++i];
    }
    if ( !pszhostFqdn )
    {
        pszhostFqdn = szhostName;
    }

    DNSDBG( SOCKET, (
        "ANSI local FQDN = %s.\n",
        pszhostFqdn ));

    //
    //  convert from ANSI to unicode, then over to UTF8
    //      - note, unicode string lengths in bytes NOT wchar count
    //

    RtlInitAnsiString(
        & ansiString,
        pszhostFqdn
        );

    unicodeString.Length = 0;
    unicodeString.MaximumLength = DNS_MAX_NAME_BUFFER_LENGTH*2 - 2;
    unicodeString.Buffer = wszhostName;

    status = RtlAnsiStringToUnicodeString(
                & unicodeString,
                & ansiString,
                FALSE           // no allocation
                );

    DNSDBG( SOCKET, (
        "Unicode local FQDN = %S.\n",
        unicodeString.Buffer ));

    pszname = Dns_NameCopyAllocate(
                    (PCHAR) unicodeString.Buffer,
                    (unicodeString.Length / 2),
                    DnsCharSetUnicode,   // unicode in
                    DnsCharSetUtf8       // UTF8 out
                    );

    DNSDBG( SOCKET, (
        "UTF8 local FQDN = %s.\n",
        pszname ));

#if 0
    pszname = Dns_CreateStringCopy( pszhostFqdn, 0 );
    if ( ! pszname )
    {
        SetLastError( DNS_ERROR_NO_MEMORY );
        return( NULL );
    }
#endif

    //
    //  DEVNOTE: to provide UTF8 need to take to unicode and back to UTF8
    //

    return( pszname );
}




DNS_STATUS
Sock_CloseSocketsListeningOnUnusedAddrs(
    IN      PIP_ARRAY       pIpArray,
    IN      INT             iSockType,
    IN      BOOL            fIncludeZeroBound,
    IN      BOOL            fIncludeLoopback
    )
/*++

Routine Description:

    Close listening sockets not in current listen IP array.

Arguments:

    pIpArray    -- array of IP addresses to listen on

    iSockType   -- socket type to close up on

    fIncludeZeroBound   -- close zero

    fIncludeLoopback    -- close loopback

Return Value:

    None.

--*/
{
    PDNS_SOCKET   pentry;
    PDNS_SOCKET   prevEntry;
    SOCKET        socket;
    IP_ADDRESS    ip;


    LOCK_SOCKET_LIST();

    for ( pentry = (PDNS_SOCKET) g_SocketList.Flink;
          pentry != (PDNS_SOCKET) &g_SocketList;
          pentry = (PDNS_SOCKET) pentry->List.Flink )
    {
        DNS_DEBUG( PNP, (
            "Checking socket %d for closure\n",
            pentry->Socket ));

        if ( !pentry->fListen   ||
            ( iSockType && pentry->SockType != iSockType ) )
        {
            continue;
        }

        //
        //  ignore sockets
        //      - in passed in array (IPs still listening on)
        //      - INADDR_ANY (unless explictly configured to do so)
        //      - loopback (as we'll just have to rebind it anyway)
        //

        ip = pentry->ipAddr;
        if ( ip == 0 )
        {
            if ( !fIncludeZeroBound )
            {
                continue;
            }
        }
        else if ( ip == NET_ORDER_LOOPBACK )
        {
            if ( !fIncludeLoopback )
            {
                continue;
            }
        }
        else if ( pIpArray && Dns_IsAddressInIpArray( pIpArray, ip ) )
        {
            continue;
        }

        socket = pentry->Socket;
        if ( pentry->SockType == SOCK_STREAM )
        {
            FD_CLR( socket, &g_fdsListenTcp );
            if ( ip == 0 )
            {
                g_TcpZeroBoundSocket = 0;
            }
        }
        else
        {
            g_UdpBoundSocketCount--;
            ASSERT( (INT)g_UdpBoundSocketCount >= 0 );
        }

        //  DEVNOTE: who cleans up message?
        //      problem because can easily have active message
        //      even message being processed associated with context
        //
        //      could NULL pMsg in context when take off with it
        //      but still window when just woke on valid socket, right
        //      before this close -- don't want to have to run through
        //      lock
        //
        //  close socket
        //      - remove from list
        //      - mark dead
        //      - close
        //
        //  marking dead before and after close because want to have marked
        //  when close wakes other threads, BUT mark before close might be
        //  immediately overwritten by new WSARecvFrom() that just happens
        //  to be occuring on another thread;
        //  still tricky window through this, Sock_CleanupDeadSocket() finally
        //  handles the message cleanup atomically and insures the context rests
        //  in peace as DEAD
        //

        prevEntry = (PDNS_SOCKET) pentry->List.Blink;
        RemoveEntryList( (PLIST_ENTRY)pentry );
        g_SocketListCount--;

        ASSERT( (INT)g_SocketListCount >= 0 );
        pentry->State = SOCKSTATE_DEAD;
        closesocket( socket );
        pentry->State = SOCKSTATE_DEAD;

        Timeout_Free( pentry );

        DNS_DEBUG( ANY, (
            "closed listening socket %d for IP %s ptr %p\n",
            socket,
            IP_STRING( ip ),
            pentry ));

        pentry = prevEntry;
    }

    UNLOCK_SOCKET_LIST();
    return( ERROR_SUCCESS );
}



DNS_STATUS
Sock_ResetBoundSocketsToMatchIpArray(
    IN      PIP_ARRAY       pIpArray,
    IN      INT             SockType,
    IN      WORD            Port,
    IN      DWORD           Flags,
    IN      BOOL            fCloseZeroBound
    )
/*++

Routine Description:

    Create sockets for all values in IP array.

Arguments:

    pIpArray    -- IP array

    SockType    -- SOCK_DGRAM or SOCK_STREAM

    Port        -- desired port in net order
                    - DNS_PORT_NET_ORDER for DNS listen sockets
                    - 0 for any port

    Flags       -- flags to Sock_CreateSocket() call

    fCloseZeroBound -- close zero bound socket

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_INVALID_HANDLE if unable to create one or more sockets.

--*/
{
    SOCKET      s;
    DWORD       i;
    DNS_STATUS  status;
    PDNS_SOCKET psock;
    IP_ADDRESS  ip;

    DNS_DEBUG( SOCKET, (
        "Sock_ResetBoundSocketsToMatchIpArray()\n"
        "\tIP array = %p (count = %d)\n"
        "\ttype     = %d\n"
        "\tport     = %hx\n"
        "\tflags    = %d\n",
        pIpArray,
        pIpArray->AddrCount,
        SockType,
        Port,
        Flags ));

    //
    //  close sockets for unused addresses
    //

    status = Sock_CloseSocketsListeningOnUnusedAddrs(
                pIpArray,
                SockType,
                fCloseZeroBound,    // zero-bound close?
                FALSE               // not closing loopback
                );

    //
    //  loop through IP array creating socket on each address
    //
    //  note:  assuming here that sockFindDnsSocketForIpAddr()
    //      only matches DNS port sockets;  and that we are only
    //      interested in DNS port;  if port can very need to add
    //      param to sockFindDnsSocketForIpAddr()
    //

    ASSERT( Port == DNS_PORT_NET_ORDER );

    for ( i=0; i<pIpArray->AddrCount; i++ )
    {
        ip = pIpArray->AddrArray[i];

        DNS_DEBUG( SOCKET, (
            "\tchecking if binding for (type=%d) already exists for %s\n",
            SockType,
            IP_STRING(ip) ));

        psock = sockFindDnsSocketForIpAddr(
                    ip,
                    SockType );
        if ( psock )
        {
            DNS_DEBUG( SOCKET, (
                "\tsocket (type=%d) already exists for %s -- skip create.\n",
                SockType,
                IP_STRING(ip) ));
            continue;
        }

        s = Sock_CreateSocket(
                SockType,
                ip,
                Port,
                Flags );

        if ( s == DNS_INVALID_SOCKET )
        {
            status = GetLastError();
            continue;
        }
    }

    //
    //  special case loopback
    //
    //  DEVNOTE: loopback probably ought to be in calculating machine addrs
    //      this lets admin kill it in listen list -- good?  bad?
    //
    //  note:  finding loopback socket only works by relying on
    //  sockFindDnsSockForIpAddr() to only return DNS port matches;
    //  as there will always by TCP wakeup socket on loopback
    //

    psock = sockFindDnsSocketForIpAddr(
                NET_ORDER_LOOPBACK,
                SockType );
    if ( psock )
    {
        DNS_DEBUG( SOCKET, (
            "Loopback socket (type=%d) already exists for %s\n",
            SockType,
            IP_STRING(ip) ));
        return( status );
    }

    DNS_DEBUG( SOCKET, (
        "Loopback address unbound, bind()ing.\n" ));

    s = Sock_CreateSocket(
            SockType,
            NET_ORDER_LOOPBACK,
            Port,
            Flags );

    if ( s == DNS_INVALID_SOCKET )
    {
        DNS_STATUS tstatus = GetLastError();
        DNS_DEBUG( ANY, (
            "ERROR:  %p (%d), unable to bind() loopback address.\n",
            tstatus, tstatus ));
    }

    DNS_DEBUG( SOCKET, (
        "Leave  Sock_ResetBoundSocketsToMatchIpArray()\n" ));

    return( status );
}



VOID
Sock_CleanupDeadSocketMessage(
    IN OUT  PDNS_SOCKET     pContext
    )
/*++

Routine Description:

    Cleanup dead socket.

Arguments:

    pContext -- context for socket being recieved

Return Value:

    None.

--*/
{
    PDNS_MSGINFO pmsg;

    DNS_DEBUG( ANY, (
        "cleanupDeadThread( %p )\n",
        pContext ));

    ASSERT( pContext->State == SOCKSTATE_DEAD );

    //
    //  insure that pMsg is only cleaned up by one thread;
    //  also insures that socket finally ends up DEAD, and
    //  any threads woken will proceed through this function
    //  and drop the context
    //

    LOCK_SOCKET_LIST();
    pmsg = pContext->pMsg;
    pContext->pMsg = NULL;
    pContext->State = SOCKSTATE_DEAD;
    UNLOCK_SOCKET_LIST();

    if ( pmsg )
    {
        STAT_INC( PrivateStats.UdpSocketPnpDelete );
        Packet_FreeUdpMessage( pmsg );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\srvcfg.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    srvcfg.h

Abstract:

    Domain Name System (DNS) Server

    Server configuration definitions.

Author:

    Jim Gilroy (jamesg)     11-Oct-1995

Revision History:

--*/


#ifndef _DNS_SRVCFG_INCLUDED_
#define _DNS_SRVCFG_INCLUDED_

//
//  Global protection values
//

#define BEFORE_BUF_VALUE    (0xbbbbbbbb)
#define AFTER_BUF_VALUE     (0xaaaaaaaa)

//
//  Server configuration structure
//
//  Implementation note:
//
//  Obviously this flat structure is less friendly debug wise.
//  It's easier if these are just individual globals with symbols.
//  The upside is initialization is much easier -- RtlZeroMemory()
//  which is useful for server restart.
//  Fortunately, all access is macroized.  So changing this to
//  individual globals is possible.
//
//  Win64 -- this is a single instance structure so alignment not
//      really critical
//

typedef struct _SERVER_INFO
{
    DWORD       dwVersion;
    LPSTR       pszServerName;
    LPSTR       pszPreviousServerName;

    //  runtime information

    BOOL        fStarted;
    BOOL        fThreadAlert;
    BOOL        fServiceExit;
    BOOL        fWinsInitialized;
    BOOL        fWarnAdmin;
    DWORD       dwCurrentTime;
    time_t      crtSystemBootTime;      //  CRT time of machine boot
    DWORD       fBootFileDirty;
    BOOL        fDsOpen;
    BOOL        fAdminConfigured;

    //  boot

    DWORD       fEnableRegistryBoot;
    DWORD       fBootMethod;
    DWORD       cDsZones;
    DWORD       fRemoteDs;
    BOOL        bReloadException;

    //  database

    LPWSTR      pwsDatabaseDirectory;
    LPSTR       pszRootHintsFile;
    BOOL        fDsAvailable;

    //  RPC support

    DWORD       dwRpcProtocol;
                               //  IP interfaces
    //  logging

    LPWSTR      pwsLogFilePath;
    PIP_ARRAY   aipLogFilterList;
    DWORD       dwLogLevel;
    DWORD       dwLogFileMaxSize;
    DWORD       dwEventLogLevel;
    DWORD       dwUseSystemEventLog;
    DWORD       dwDebugLevel;

    //  socket config

    PIP_ARRAY   aipListenAddrs;
    PIP_ARRAY   aipPublishAddrs;
    BOOL        fListenAddrsSet;            // used for pnp
    BOOL        fListenAddrsStale;
    BOOL        fDisjointNets;
    BOOL        fNoTcp;
    DWORD       dwSendPort;
    DWORD       dwXfrConnectTimeout;        // connection timeout for dial out

    //  forwarders

    PIP_ARRAY   aipForwarders;
    DWORD       dwForwardTimeout;
    BOOL        fSlave;

    //  recursion

    BOOL        fNoRecursion;
    BOOL        fRecurseSingleLabel;
    BOOL        fRecursionAvailable;
    DWORD       dwRecursionRetry;
    DWORD       dwRecursionTimeout;
    DWORD       dwAdditionalRecursionTimeout;
    DWORD       dwMaxCacheTtl;
    DWORD       dwMaxNegativeCacheTtl;
    BOOL        fSecureResponses;
    BOOL        fForwardDelegations;
    DWORD       dwRecurseToInetRootMask;
    DWORD       dwAutoCreateDelegations;

    //  allow UPDATEs

    BOOL        fAllowUpdate;

//  DEVNOTE:  better to have update property flag
//      perhaps just AllowUpdate gets are range of values
//      record types, delegations, zone root

    DWORD       fNoUpdateDelegations;
    DWORD       dwUpdateOptions;

    //  name validity

    DWORD       dwNameCheckFlag;


    //  timeout cleanup interval

    DWORD       dwCleanupInterval;

    //  DS control

    DWORD       dwDsPollingInterval;
    DWORD       dwDsTombstoneInterval;
    DWORD       dwSyncDsZoneSerial;

    //  automatic configuration

    DWORD       fAutoConfigFileZones;
    BOOL        fPublishAutonet ;
    DWORD       fNoAutoReverseZones;
    DWORD       fAutoCacheUpdate;
    DWORD       fNoAutoNSRecords;

    //  A record processing

    DWORD       fRoundRobin;
    BOOL        fLocalNetPriority;
    DWORD       dwLocalNetPriorityNetMask;
    DWORD       cAddressAnswerLimit;

    //  BIND compatibility and mimicing

    DWORD       fBindSecondaries;
    DWORD       fWriteAuthorityNs;
    DWORD       fStrictFileParsing;
    DWORD       fDeleteOutsideGlue;
    DWORD       fLooseWildcarding;
    DWORD       fWildcardAllTypes;
    DWORD       fAppendMsTagToXfr;

    //  SOA forcing (for DuetscheTelekom)

    DWORD       dwForceSoaSerial;
    DWORD       dwForceSoaMinimumTtl;
    DWORD       dwForceSoaRefresh;
    DWORD       dwForceSoaRetry;
    DWORD       dwForceSoaExpire;
    DWORD       dwForceNsTtl;
    DWORD       dwForceTtl;

    //  UDP 

    DWORD       dwMaxUdpPacketSize;

    //  EDNS

    DWORD       dwEnableEDnsProbes;
    DWORD       dwEnableEDnsReception;
    DWORD       dwEDnsCacheTimeout;

    //  DNSSEC

    DWORD       dwEnableDnsSec;

    DWORD       dwEnableSendErrSuppression;

    //  Scavenging

    DWORD       fScavengingState;
    DWORD       dwScavengingInterval;

    DWORD       fDefaultAgingState;
    DWORD       dwDefaultRefreshInterval;
    DWORD       dwDefaultNoRefreshInterval;

    //  Cache control

    DWORD       dwMaxCacheSize;

    //  Round robin - types that won't be round-robined (default is ALL)

    DWORD       dwNumDoNotRoundRobinTypes;
    PWORD       pwDoNotRoundRobinTypeArray;     //  allocated array

    //  Permanent test flags

    DWORD       dwQuietRecvLogInterval;
    DWORD       dwQuietRecvFaultInterval;

    //  Diretory partitions

    DWORD       dwEnableDp;
    LPSTR       pszDomainDpBaseName;
    LPSTR       pszForestDpBaseName;

    //  Strict RFC compliance flags

    BOOL        fSilentlyIgnoreCNameUpdateConflict;

    //  Debugging aids

    PIP_ARRAY   aipUpdateBreakList;
    PIP_ARRAY   aipRecvBreakList;
    DWORD       dwBreakOnAscFailure;

    //  Reusable test flags

    DWORD       fTest1;
    DWORD       fTest2;
    DWORD       fTest3;
    DWORD       fTest4;
    DWORD       fTest5;
    DWORD       fTest6;
    DWORD       fTest7;
    DWORD       fTest8;
    DWORD       fTest9;
}
SERVER_INFO, *PSERVER_INFO;


//
//  Server configuration global
//

extern  SERVER_INFO     SrvInfo;


//
//  Macros to hide storage implementation
//

//  Runtime Info

#define SrvCfg_fStarted                     ( SrvInfo.fStarted )
#define SrvCfg_fThreadAlert                 ( SrvInfo.fThreadAlert )
#define SrvCfg_fServiceExit                 ( SrvInfo.fServiceExit )
#define SrvCfg_fWinsInitialized             ( SrvInfo.fWinsInitialized )
#define SrvCfg_fBootFileDirty               ( SrvInfo.fBootFileDirty )
#define SrvInfo_dwCurrentTime               ( SrvInfo.dwCurrentTime )
#define SrvInfo_crtSystemBootTime           ( SrvInfo.crtSystemBootTime )
#define SrvInfo_fWarnAdmin                  ( SrvInfo.fWarnAdmin )

//  Configuration Info

#define SrvCfg_dwVersion                    ( SrvInfo.dwVersion )
#define SrvCfg_pszServerName                ( SrvInfo.pszServerName )
#define SrvCfg_pszPreviousServerName        ( SrvInfo.pszPreviousServerName )
#define SrvCfg_fEnableRegistryBoot          ( SrvInfo.fEnableRegistryBoot )
#define SrvCfg_fBootMethod                  ( SrvInfo.fBootMethod )
#define SrvCfg_fAdminConfigured             ( SrvInfo.fAdminConfigured )
#define SrvCfg_fRemoteDs                    ( SrvInfo.fRemoteDs )
#define SrvCfg_bReloadException             ( SrvInfo.bReloadException )
#define SrvCfg_cDsZones                     ( SrvInfo.cDsZones )
#define SrvCfg_fDsAvailable                 ( SrvInfo.fDsAvailable )
#define SrvCfg_pwsDatabaseDirectory         ( SrvInfo.pwsDatabaseDirectory )
#define SrvCfg_pszRootHintsFile             ( SrvInfo.pszRootHintsFile )
#define SrvCfg_dwRpcProtocol                ( SrvInfo.dwRpcProtocol )

#define SrvCfg_dwLogLevel                   ( SrvInfo.dwLogLevel )
#define SrvCfg_dwLogFileMaxSize             ( SrvInfo.dwLogFileMaxSize )
#define SrvCfg_pwsLogFilePath               ( SrvInfo.pwsLogFilePath )
#define SrvCfg_aipLogFilterList             ( SrvInfo.aipLogFilterList )
#define SrvCfg_dwEventLogLevel              ( SrvInfo.dwEventLogLevel )
#define SrvCfg_dwUseSystemEventLog          ( SrvInfo.dwUseSystemEventLog )
#define SrvCfg_dwDebugLevel                 ( SrvInfo.dwDebugLevel )

#define SrvCfg_aipServerAddrs               ( SrvInfo.aipServerAddrs )
#define SrvCfg_aipBoundAddrs                ( SrvInfo.aipBoundAddrs )
#define SrvCfg_aipListenAddrs               ( SrvInfo.aipListenAddrs )
#define SrvCfg_aipPublishAddrs              ( SrvInfo.aipPublishAddrs )
#define SrvCfg_fListenAddrsSet              ( SrvInfo.fListenAddrsSet )
#define SrvCfg_fListenAddrsStale            ( SrvInfo.fListenAddrsStale )
#define SrvCfg_fDisjointNets                ( SrvInfo.fDisjointNets )
#define SrvCfg_fNoTcp                       ( SrvInfo.fNoTcp )
#define SrvCfg_dwSendPort                   ( SrvInfo.dwSendPort )

#define SrvCfg_aipForwarders                ( SrvInfo.aipForwarders )
#define SrvCfg_dwForwardTimeout             ( SrvInfo.dwForwardTimeout )
#define SrvCfg_fSlave                       ( SrvInfo.fSlave )
#define SrvCfg_fNoRecursion                 ( SrvInfo.fNoRecursion )
#define SrvCfg_fRecurseSingleLabel          ( SrvInfo.fRecurseSingleLabel )
#define SrvCfg_fRecursionAvailable          ( SrvInfo.fRecursionAvailable )
#define SrvCfg_dwRecursionRetry             ( SrvInfo.dwRecursionRetry )
#define SrvCfg_dwRecursionTimeout           ( SrvInfo.dwRecursionTimeout )
#define SrvCfg_dwAdditionalRecursionTimeout ( SrvInfo.dwAdditionalRecursionTimeout )
#define SrvCfg_dwXfrConnectTimeout          ( SrvInfo.dwXfrConnectTimeout )
#define SrvCfg_dwMaxCacheTtl                ( SrvInfo.dwMaxCacheTtl )
#define SrvCfg_dwMaxNegativeCacheTtl        ( SrvInfo.dwMaxNegativeCacheTtl)
#define SrvCfg_fSecureResponses             ( SrvInfo.fSecureResponses )
#define SrvCfg_fForwardDelegations          ( SrvInfo.fForwardDelegations )
#define SrvCfg_dwRecurseToInetRootMask      ( SrvInfo.dwRecurseToInetRootMask )
#define SrvCfg_dwAutoCreateDelegations      ( SrvInfo.dwAutoCreateDelegations )

#define SrvCfg_fRoundRobin                  ( SrvInfo.fRoundRobin )
#define SrvCfg_fLocalNetPriority            ( SrvInfo.fLocalNetPriority )
#define SrvCfg_dwLocalNetPriorityNetMask    ( SrvInfo.dwLocalNetPriorityNetMask )
#define SrvCfg_cAddressAnswerLimit          ( SrvInfo.cAddressAnswerLimit )
#define SrvCfg_fBindSecondaries             ( SrvInfo.fBindSecondaries )
#define SrvCfg_fWriteAuthorityNs            ( SrvInfo.fWriteAuthorityNs )
#define SrvCfg_fWriteAuthority              ( SrvInfo.fWriteAuthorityNs )
#define SrvCfg_fStrictFileParsing           ( SrvInfo.fStrictFileParsing )
#define SrvCfg_fDeleteOutsideGlue           ( SrvInfo.fDeleteOutsideGlue )
#define SrvCfg_fLooseWildcarding            ( SrvInfo.fLooseWildcarding )
#define SrvCfg_fAppendMsTagToXfr            ( SrvInfo.fAppendMsTagToXfr )

#define SrvCfg_fAllowUpdate                 ( SrvInfo.fAllowUpdate )
#define SrvCfg_dwUpdateOptions              ( SrvInfo.dwUpdateOptions)
#define SrvCfg_fNoUpdateDelegations         ( SrvInfo.fNoUpdateDelegations )
#define SrvCfg_dwNameCheckFlag              ( SrvInfo.dwNameCheckFlag )
#define SrvCfg_dwCleanupInterval            ( SrvInfo.dwCleanupInterval )

#define SrvCfg_fAutoConfigFileZones         ( SrvInfo.fAutoConfigFileZones )
#define SrvCfg_fPublishAutonet              ( SrvInfo.fPublishAutonet )
#define SrvCfg_fNoAutoReverseZones          ( SrvInfo.fNoAutoReverseZones )
#define SrvCfg_fAutoCacheUpdate             ( SrvInfo.fAutoCacheUpdate )
#define SrvCfg_fNoAutoNSRecords             ( SrvInfo.fNoAutoNSRecords )

#define SrvCfg_dwSyncDsZoneSerial           ( SrvInfo.dwSyncDsZoneSerial)
#define SrvCfg_dwDsPollingInterval          ( SrvInfo.dwDsPollingInterval )
#define SrvCfg_dwDsTombstoneInterval        ( SrvInfo.dwDsTombstoneInterval )

#define SrvCfg_dwScavengingInterval         ( SrvInfo.dwScavengingInterval )
#define SrvCfg_fDefaultAgingState           ( SrvInfo.fDefaultAgingState)
#define SrvCfg_dwDefaultRefreshInterval     ( SrvInfo.dwDefaultRefreshInterval )
#define SrvCfg_dwDefaultNoRefreshInterval   ( SrvInfo.dwDefaultNoRefreshInterval )

#define SrvCfg_dwMaxCacheSize               ( SrvInfo.dwMaxCacheSize )

#define SrvCfg_dwForceSoaSerial             ( SrvInfo.dwForceSoaSerial )
#define SrvCfg_dwForceSoaMinimumTtl         ( SrvInfo.dwForceSoaMinimumTtl )
#define SrvCfg_dwForceSoaRefresh            ( SrvInfo.dwForceSoaRefresh )
#define SrvCfg_dwForceSoaRetry              ( SrvInfo.dwForceSoaRetry )
#define SrvCfg_dwForceSoaExpire             ( SrvInfo.dwForceSoaExpire )
#define SrvCfg_dwForceNsTtl                 ( SrvInfo.dwForceNsTtl )
#define SrvCfg_dwForceTtl                   ( SrvInfo.dwForceTtl )

#define SrvCfg_dwMaxUdpPacketSize           ( SrvInfo.dwMaxUdpPacketSize )

#define SrvCfg_dwEDnsCacheTimeout           ( SrvInfo.dwEDnsCacheTimeout )
#define SrvCfg_dwEnableEDnsProbes           ( SrvInfo.dwEnableEDnsProbes )
#define SrvCfg_dwEnableEDnsReception        ( SrvInfo.dwEnableEDnsReception )

#define SrvCfg_dwEnableDnsSec               ( SrvInfo.dwEnableDnsSec )

#define SrvCfg_dwEnableSendErrSuppression   ( SrvInfo.dwEnableSendErrSuppression )

#define SrvCfg_dwNumDoNotRoundRobinTypes    ( SrvInfo.dwNumDoNotRoundRobinTypes )
#define SrvCfg_pwDoNotRoundRobinTypeArray   ( SrvInfo.pwDoNotRoundRobinTypeArray )


//
//  Globals to tweak behavior during testing
//

#define DNS_REGKEY_QUIET_RECV_LOG_INTERVAL      "QuietRecvLogInterval"
#define DNS_REGKEY_QUIET_RECV_FAULT_INTERVAL    "QuietRecvFaultInterval"

#define SrvCfg_dwQuietRecvLogInterval       ( SrvInfo.dwQuietRecvLogInterval )
#define SrvCfg_dwQuietRecvFaultInterval     ( SrvInfo.dwQuietRecvFaultInterval )


//
//  Directory partitions
//

#define SrvCfg_dwEnableDp               ( SrvInfo.dwEnableDp )
#define SrvCfg_pszDomainDpBaseName      ( SrvInfo.pszDomainDpBaseName )
#define SrvCfg_pszForestDpBaseName      ( SrvInfo.pszForestDpBaseName )

//
//  String RFC compliance flags
//

#define SrvCfg_fSilentlyIgnoreCNameUpdateConflict  ( SrvInfo.fSilentlyIgnoreCNameUpdateConflict)


//
//  Debugging aids
//

#define SrvCfg_dwBreakOnAscFailure          ( SrvInfo.dwBreakOnAscFailure )
#define SrvCfg_aipUpdateBreakList           ( SrvInfo.aipUpdateBreakList )
#define SrvCfg_aipRecvBreakList             ( SrvInfo.aipRecvBreakList )

//
//  Reusable test flags
//

#define DNS_REGKEY_TEST1                    "Test1"
#define DNS_REGKEY_TEST2                    "Test2"
#define DNS_REGKEY_TEST3                    "Test3"
#define DNS_REGKEY_TEST4                    "Test4"
#define DNS_REGKEY_TEST5                    "Test5"
#define DNS_REGKEY_TEST6                    "Test6"
#define DNS_REGKEY_TEST7                    "Test7"
#define DNS_REGKEY_TEST8                    "Test8"
#define DNS_REGKEY_TEST9                    "Test9"

#define SrvCfg_fTest1                       ( SrvInfo.fTest1 )
#define SrvCfg_fTest2                       ( SrvInfo.fTest2 )
#define SrvCfg_fTest3                       ( SrvInfo.fTest3 )
#define SrvCfg_fTest4                       ( SrvInfo.fTest4 )
#define SrvCfg_fTest5                       ( SrvInfo.fTest5 )
#define SrvCfg_fTest6                       ( SrvInfo.fTest6 )
#define SrvCfg_fTest7                       ( SrvInfo.fTest7 )
#define SrvCfg_fTest8                       ( SrvInfo.fTest8 )
#define SrvCfg_fTest9                       ( SrvInfo.fTest9 )

//
//  Current test flag owners
//
//  Test1 --
//  Test2 --
//  Test3 -- turn off bad IP suppression
//  Test4 --
//  Test5 --
//  Test6 -- set SecBigTimeSkew
//  Test7 -- memory (small allocs)
//  Test8 -- always indicate DS available
//  Test9 -- RPC old SD used as global SD;  allow zone checks
//


//
//  Auto-config file zones
//

#define ZONE_AUTO_CONFIG_NONE                   (0)
#define ZONE_AUTO_CONFIG_UPDATE                 (0x00000001)
#define ZONE_AUTO_CONFIG_STATIC                 (0x00000002)
#define ZONE_AUTO_CONFIG_ALL                    (0x00000003)

#define DNS_DEFAULT_AUTO_CONFIG_FILE_ZONES      (ZONE_AUTO_CONFIG_UPDATE)

//
//  DS zone serial sync
//

#define ZONE_SERIAL_SYNC_OFF                    (0)
#define ZONE_SERIAL_SYNC_SHUTDOWN               (1)
#define ZONE_SERIAL_SYNC_XFR                    (2)
#define ZONE_SERIAL_SYNC_VIEW                   (3)
#define ZONE_SERIAL_SYNC_READ                   (4)

#define DNS_DEFAULT_SYNC_DS_ZONE_SERIAL         (ZONE_SERIAL_SYNC_SHUTDOWN)

//
//  Update options (bitmask)
//
//  Defaults:
//  - non-secure -> no NS or SOA or server host
//  - secure -> no NS or SOA at root;
//      allow delegations and server host updates
//

#define UPDATE_ANY                              (0)
#define UPDATE_NO_SOA                           (0x00000001)
#define UPDATE_NO_ROOT_NS                       (0x00000002)
#define UPDATE_NO_DELEGATION_NS                 (0x00000004)
#define UPDATE_NO_SERVER_HOST                   (0x00000008)
#define UPDATE_SECURE_NO_SOA                    (0x00000100)
#define UPDATE_SECURE_NO_ROOT_NS                (0x00000200)
#define UPDATE_SECURE_NO_DELEGATION_NS          (0x00000400)
#define UPDATE_SECURE_NO_SERVER_HOST            (0x00000800)

#define UPDATE_NO_DS_PEERS                      (0x01000000)
#define UPDATE_OFF                              (0x80000000)

#define DNS_DEFAULT_UPDATE_OPTIONS              (0x0000030f)

//
//  Publishing autonet addresses
//

#define DNS_REGKEY_PUBLISH_AUTONET              "PublishAutonet"
#define DNS_DEFAULT_PUBLISH_AUTONET             (FALSE)


//
//  Server configuration locking
//
//  DEVNOTE:  need to do something here to insure integrity
//              when mutliple writers, perhaps just use zone list cs
//

#define Config_UpdateLock()
#define Config_UpdateUnlock()


//
//  On fresh installs EnableRegistryBoot is not set either way.
//  Default fBootMethod to this flag to determine if in this state.
//

#define DNS_FRESH_INSTALL_BOOT_REGISTRY_FLAG    ((DWORD)(-1))

//
//  DS state unknown on startuap
//  Can not just do immediate ldap_open() because DS can
//  take a long time after boot to load -- much longer than DNS server
//

#define DS_STATE_UNKNOWN                        ((DWORD)(-1))


#define DNS_REG_IPARRAY     0x00010000  // Bogus type for DNS_PROPERTY_VALUE

typedef struct
{
    DWORD           dwPropertyType;     // REG_DWORD or one of DNS_REG_XXX
    union
    {
        DWORD       dwValue;
        LPSTR       pszValue;
        LPWSTR      pwszValue;
        PIP_ARRAY   pipValue;
    };
} DNS_PROPERTY_VALUE, *PDNS_PROPERTY_VALUE;


BOOL
Config_Initialize(
    VOID
    );

DNS_STATUS
Config_ResetProperty(
    IN      LPSTR                   pszPropertyName,
    IN      PDNS_PROPERTY_VALUE     pPropValue
    );

VOID
Config_PostLoadReconfiguration(
    VOID
    );

//
//  Create non-local IP array
//

PIP_ARRAY
Config_ValidateAndCopyNonLocalIpArray(
    IN      PIP_ARRAY       pipArray
    );

//
//  Set server's IP address interfaces
//

DNS_STATUS
Config_SetListenAddresses(
    IN      DWORD           cListenAddrs,
    IN      PIP_ADDRESS     aipListenAddrs
    );

//
//  Forwarders configuration
//

DNS_STATUS
Config_SetupForwarders(
    IN      PIP_ARRAY       aipForwarders,
    IN      DWORD           dwForwardTimeout,
    IN      BOOL            fSlave
    );

DNS_STATUS
Config_ReadForwarders(
    VOID
    );

//
//  Boot info update
//

VOID
Config_UpdateBootInfo(
    VOID
    );

//
//  File Directory
//

DNS_STATUS
Config_ReadDatabaseDirectory(
    IN      PCHAR           pchDirectory,       OPTIONAL
    IN      DWORD           cchDirectoryNameLength
    );


//
//  Time keeping
//

#define DNS_TIME()  ( SrvInfo_dwCurrentTime )

#define DNS_STARTUP_TIME()  (( SrvInfo_dwCurrentTime )       \
                                ? SrvInfo_dwCurrentTime      \
                                : GetCurrentTimeInSeconds() )

#define UPDATE_DNS_TIME()   ( DNS_TIME() = Dns_GetCurrentTimeInSeconds() )

#define DNS_TIME_TO_CRT_TIME( dnsTime )     ( SrvInfo_crtSystemBootTime + dnsTime )


#endif //   _DNS_SRVCFG_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\srvcfg.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    srvcfg.c

Abstract:

    Domain Name System (DNS) Server

    Server configuration.

Author:

    Jim Gilroy (jamesg)     October, 1995

Revision History:

--*/


#include "dnssrv.h"

#include "ntverp.h"


//
//  Server configuration global
//

SERVER_INFO  SrvInfo;

//
//  Server versions
//

#if 1

#define DNSSRV_MAJOR_VERSION    VER_PRODUCTMAJORVERSION
#define DNSSRV_MINOR_VERSION    VER_PRODUCTMINORVERSION

#define DNSSRV_SP_VERSION       VER_PRODUCTBUILD

#else

#define DNSSRV_MAJOR_VERSION    (5)         //  NT 5 (Windows 2000, Whistler)
#define DNSSRV_MINOR_VERSION    (1)         //  .0 is Windows 2000, .1 is Whistler

#define DNSSRV_SP_VERSION       (2246)      //  use build number for now
//#define DNSSRV_SP_VERSION       (0x0)      //  FINAL

#endif


//
//  Private server configuration (not in dnsrpc.h)
//

#define DNS_REGKEY_REMOTE_DS                ("RemoteDs")

#define DNS_REGKEY_PREVIOUS_SERVER_NAME     "PreviousLocalHostname"
#define DNS_REGKEY_PREVIOUS_SERVER_NAME_PRIVATE \
        (LPSTR)TEXT(DNS_REGKEY_PREVIOUS_SERVER_NAME)

#define DNS_REGKEY_FORCE_SOA_SERIAL         ("ForceSoaSerial")
#define DNS_REGKEY_FORCE_SOA_MINIMUM_TTL    ("ForceSoaMinimumTtl")
#define DNS_REGKEY_FORCE_SOA_REFRESH        ("ForceSoaRefresh")
#define DNS_REGKEY_FORCE_SOA_RETRY          ("ForceSoaRetry")
#define DNS_REGKEY_FORCE_SOA_EXPIRE         ("ForceSoaExpire")
#define DNS_REGKEY_FORCE_NS_TTL             ("ForceNsTtl")
#define DNS_REGKEY_FORCE_TTL                ("ForceTtl")

//
//  EDNS
//

#define DNS_REGKEY_ENABLE_EDNS_RECEPTION    ("EnableEDnsReception")

#define DNS_REGKEY_RELOAD_EXCEPTION         ("ReloadException")
#define DNS_REGKEY_SYNC_DS_ZONE_SERIAL      ("SyncDsZoneSerial")

//  Address answer limit (for protecting against WIN95 resolver bug)
//  is constrained to reasonable range

#define MIN_ADDRESS_ANSWER_LIMIT    (5)
#define MAX_ADDRESS_ANSWER_LIMIT    (28)

//  Max Udp Packet size - must be between RFC minimum and "sane" maximum

#define MIN_UDP_PACKET_SIZE         (DNS_RFC_MAX_UDP_PACKET_LENGTH)
#define MAX_UDP_PACKET_SIZE         (16384)

#define MIN_EDNS_CACHE_TIMEOUT      (60*60)         // one hour
#define MAX_EDNS_CACHE_TIMEOUT      (60*60*24*182)  // 6 months (182 days)

//  Recursion timeout
//  Must be limited to reasonable values for proper recursion functioning

#define MAX_RECURSION_TIMEOUT       (120)       // max two minutes
#define MIN_RECURSION_TIMEOUT       (3)         // min three seconds

//  Cache control - sizes in kilobytes

#define MIN_MAX_CACHE_SIZE          (500)       //  min value for MaxCacheSize

//  Reloading exceptions
//  By default reload retail, but let debug crash

#if DBG
#define DNS_DEFAULT_RELOAD_EXCEPTION    (0)
#else
#define DNS_DEFAULT_RELOAD_EXCEPTION    (1)
#endif


//
//  For specialized property management functions,
//  these flags indicate no need to write property or
//  save it to registry.
//

#define PROPERTY_NOWRITE            (0x00000001)
#define PROPERTY_NOSAVE             (0x00000002)
#define PROPERTY_FORCEWRITE         (0x00000004)
#define PROPERTY_UPDATE_BOOTFILE    (0x00000008)
#define PROPERTY_NODEFAULT          (0x00000010)

#define PROPERTY_ERROR              (0x80000000)


//
//  Special property management functions
//

typedef DNS_STATUS (* DWORD_PROPERTY_SET_FUNCTION) (
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetEnableRegistryBoot(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetBootMethod(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetAddressAnswerLimit(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetLogFilePath(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetLogLevel(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetLogIPFilterList(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetBreakOnUpdateFromList(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetBreakOnRecvFromList(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetMaxUdpPacketSize(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetEDnsCacheTimeout(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetMaxCacheSize(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetRecursionTimeout(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetAdditionalRecursionTimeout(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

#if DBG
DNS_STATUS
cfg_SetDebugLevel(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );
#else
#define cfg_SetDebugLevel     NULL
#endif

DNS_STATUS
cfg_SetNoRecursion(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetScavengingInterval(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetDoNotRoundRobinTypes(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetForestDpBaseName(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

DNS_STATUS
cfg_SetDomainDpBaseName(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    );

//
//  Server properties
//
//  Server properties are accessed through this table.
//  The name is used for remote access and is the name of the regvalue
//  storing the property.  All these registry values are attempted to be
//  loaded on boot.
//
//  For DWORD properties, the table also gives pointer into the SrvCfg
//  structure for the property and a default value that is used when
//  -- as is usually the case -- the property is NOT found in the registry.
//

typedef struct _ServerProperty
{
    LPSTR                           pszPropertyName;
    PDWORD                          pDword;
    DWORD                           dwDefault;
    DWORD_PROPERTY_SET_FUNCTION     pFunction;
}
SERVER_PROPERTY;

SERVER_PROPERTY ServerPropertyTable[] =
{
    DNS_REGKEY_BOOT_REGISTRY                        ,
        &SrvCfg_fEnableRegistryBoot                 ,
            DNS_FRESH_INSTALL_BOOT_REGISTRY_FLAG    ,
                cfg_SetEnableRegistryBoot           ,

    DNS_REGKEY_BOOT_METHOD                          ,
        &SrvCfg_fBootMethod                         ,
            BOOT_METHOD_UNINITIALIZED               ,
                cfg_SetBootMethod                   ,

    DNS_REGKEY_ADMIN_CONFIGURED                     ,
        &SrvCfg_fAdminConfigured                    ,
            0                                       ,
                NULL                                ,

    DNS_REGKEY_RELOAD_EXCEPTION                     ,
        &SrvCfg_bReloadException                    ,
            DNS_DEFAULT_RELOAD_EXCEPTION            ,
                NULL                                ,

    DNS_REGKEY_RPC_PROTOCOL                         ,
        &SrvCfg_dwRpcProtocol                       ,
            DNS_DEFAULT_RPC_PROTOCOL                ,
                NULL                                ,

    //  Addressing \ Connection

    DNS_REGKEY_LISTEN_ADDRESSES                     ,
        NULL                                        ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_SEND_PORT                            ,
        &SrvCfg_dwSendPort                          ,
            DNS_DEFAULT_SEND_PORT                   ,
                NULL                                ,
    DNS_REGKEY_DISJOINT_NETS                        ,
        &SrvCfg_fDisjointNets                       ,
            DNS_DEFAULT_DISJOINT_NETS               ,
                NULL                                ,
    DNS_REGKEY_NO_TCP                               ,
        &SrvCfg_fNoTcp                              ,
            DNS_DEFAULT_NO_TCP                      ,
                NULL                                ,
    DNS_REGKEY_XFR_CONNECT_TIMEOUT                  ,
        &SrvCfg_dwXfrConnectTimeout                 ,
            DNS_DEFAULT_XFR_CONNECT_TIMEOUT         ,
                NULL                                ,
#if 0
    DNS_REGKEY_LISTEN_ON_AUTONET                    ,
        &SrvCfg_fListenOnAutonet                    ,
            DNS_DEFAULT_LISTEN_ON_AUTONET           ,
                NULL                                ,
#endif

    //  Logging

    DNS_REGKEY_EVENTLOG_LEVEL                       ,
        &SrvCfg_dwEventLogLevel                     ,
           DNS_DEFAULT_EVENTLOG_LEVEL               ,
                NULL                                ,
    DNS_REGKEY_USE_SYSTEM_EVENTLOG                  ,
        &SrvCfg_dwUseSystemEventLog                 ,
           DNS_DEFAULT_USE_SYSTEM_EVENTLOG          ,
                NULL                                ,
    DNS_REGKEY_LOG_LEVEL                            ,
        &SrvCfg_dwLogLevel                          ,
           DNS_DEFAULT_LOG_LEVEL                    ,
                cfg_SetLogLevel                     ,
    DNS_REGKEY_LOG_FILE_MAX_SIZE                    ,
        &SrvCfg_dwLogFileMaxSize                    ,
           DNS_DEFAULT_LOG_FILE_MAX_SIZE            ,
                NULL                                ,
    DNS_REGKEY_LOG_FILE_PATH                        ,
        NULL                                        ,
            0                                       ,
                cfg_SetLogFilePath                  ,
    DNS_REGKEY_LOG_IP_FILTER_LIST                   ,
        NULL                                        ,
            0                                       ,
                cfg_SetLogIPFilterList              ,
    DNS_REGKEY_DEBUG_LEVEL                          ,
        &SrvCfg_dwDebugLevel                        ,
            DNS_DEFAULT_DEBUG_LEVEL                 ,
                cfg_SetDebugLevel                   ,


    //  Recursion \ forwarding

#if 0
    DNS_REGKEY_RECURSION                            ,
        &SrvCfg_fRecursion                          ,
            DNS_DEFAULT_RECURSION                   ,
                NULL                                ,
#endif
    DNS_REGKEY_NO_RECURSION                         ,
        &SrvCfg_fNoRecursion                        ,
            DNS_DEFAULT_NO_RECURSION                ,
                cfg_SetNoRecursion                  ,
    DNS_REGKEY_RECURSE_SINGLE_LABEL                 ,
        &SrvCfg_fRecurseSingleLabel                 ,
            DNS_DEFAULT_RECURSE_SINGLE_LABEL        ,
                NULL                                ,
    DNS_REGKEY_MAX_CACHE_TTL                        ,
        &SrvCfg_dwMaxCacheTtl                       ,
            DNS_DEFAULT_MAX_CACHE_TTL               ,
                NULL                                ,
    DNS_REGKEY_MAX_NEGATIVE_CACHE_TTL               ,
        &SrvCfg_dwMaxNegativeCacheTtl               ,
            DNS_DEFAULT_MAX_NEGATIVE_CACHE_TTL      ,
                NULL                                ,
    DNS_REGKEY_SECURE_RESPONSES                     ,
        &SrvCfg_fSecureResponses                    ,
            DNS_DEFAULT_SECURE_RESPONSES            ,
                NULL                                ,
    DNS_REGKEY_RECURSION_RETRY                      ,
        &SrvCfg_dwRecursionRetry                    ,
            DNS_DEFAULT_RECURSION_RETRY             ,
                NULL                                ,
    DNS_REGKEY_RECURSION_TIMEOUT                    ,
        &SrvCfg_dwRecursionTimeout                  ,
            DNS_DEFAULT_RECURSION_TIMEOUT           ,
                cfg_SetRecursionTimeout             ,
    DNS_REGKEY_ADDITIONAL_RECURSION_TIMEOUT         ,
        &SrvCfg_dwAdditionalRecursionTimeout        ,
            DNS_DEFAULT_ADDITIONAL_RECURSION_TIMEOUT,
                cfg_SetAdditionalRecursionTimeout   ,
    DNS_REGKEY_FORWARDERS                           ,
        NULL                                        ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_FORWARD_TIMEOUT                      ,
        &SrvCfg_dwForwardTimeout                    ,
            DNS_DEFAULT_FORWARD_TIMEOUT             ,
                NULL                                ,
    DNS_REGKEY_SLAVE                                ,
        &SrvCfg_fSlave                              ,
            DNS_DEFAULT_SLAVE                       ,
                NULL                                ,
    DNS_REGKEY_FORWARD_DELEGATIONS                  ,
        &SrvCfg_fForwardDelegations                 ,
            DNS_DEFAULT_FORWARD_DELEGATIONS         ,
                NULL                                ,
    DNS_REGKEY_INET_RECURSE_TO_ROOT_MASK            ,
        &SrvCfg_dwRecurseToInetRootMask             ,
            DNS_DEFAULT_INET_RECURSE_TO_ROOT_MASK   ,
                NULL                                ,
    DNS_REGKEY_AUTO_CREATE_DELEGATIONS              ,
        &SrvCfg_dwAutoCreateDelegations             ,
            DNS_DEFAULT_AUTO_CREATION_DELEGATIONS   ,
                NULL                                ,

    //  Question\response config

    DNS_REGKEY_ROUND_ROBIN                          ,
        &SrvCfg_fRoundRobin                         ,
            DNS_DEFAULT_ROUND_ROBIN                 ,
                NULL                                ,
    DNS_REGKEY_LOCAL_NET_PRIORITY                   ,
        &SrvCfg_fLocalNetPriority                   ,
            DNS_DEFAULT_LOCAL_NET_PRIORITY          ,
                NULL                                ,
    DNS_REGKEY_LOCAL_NET_PRIORITY_NETMASK           ,
        &SrvCfg_dwLocalNetPriorityNetMask           ,
            DNS_DEFAULT_LOCAL_NET_PRIORITY_NETMASK  ,
                NULL                                ,
    DNS_REGKEY_ADDRESS_ANSWER_LIMIT                 ,
        &SrvCfg_cAddressAnswerLimit                 ,
            DNS_DEFAULT_ADDRESS_ANSWER_LIMIT        ,
                cfg_SetAddressAnswerLimit           ,

    DNS_REGKEY_NAME_CHECK_FLAG                      ,
        &SrvCfg_dwNameCheckFlag                     ,
            DNS_DEFAULT_NAME_CHECK_FLAG             ,
                NULL                                ,
#if 0
    //  may want to just ALWAYS do this
    DNS_REGKEY_CASE_PRESERVATION                    ,
        &SrvCfg_fCasePreservation                   ,
            DNS_DEFAULT_CASE_PRESERVATION           ,
                NULL                                ,
#endif

    DNS_REGKEY_WRITE_AUTHORITY_NS                   ,
        &SrvCfg_fWriteAuthorityNs                   ,
            DNS_DEFAULT_WRITE_AUTHORITY_NS          ,
                NULL                                ,

    DNS_REGKEY_LOOSE_WILDCARDING                    ,
        &SrvCfg_fLooseWildcarding                   ,
            DNS_DEFAULT_LOOSE_WILDCARDING           ,
                NULL                                ,
    DNS_REGKEY_BIND_SECONDARIES                     ,
        &SrvCfg_fBindSecondaries                    ,
            DNS_DEFAULT_BIND_SECONDARIES            ,
                NULL                                ,

    DNS_REGKEY_APPEND_MS_XFR_TAG                    ,
        &SrvCfg_fAppendMsTagToXfr                   ,
            DNS_DEFAULT_APPEND_MS_XFR_TAG           ,
                NULL                                ,

    //
    //  Update, DS, autoconfig management
    //

    DNS_REGKEY_ALLOW_UPDATE                         ,
        &SrvCfg_fAllowUpdate                        ,
            DNS_DEFAULT_ALLOW_UPDATE                ,
                NULL                                ,

//  DEVNOTE:  better to have update property flag
//      perhaps just AllowUpdate gets are range of values
//      record types, delegations, zone root

    DNS_REGKEY_NO_UPDATE_DELEGATIONS                ,
        &SrvCfg_fNoUpdateDelegations                ,
            DNS_DEFAULT_NO_UPDATE_DELEGATIONS       ,
                NULL                                ,
    DNS_REGKEY_UPDATE_OPTIONS                       ,
        &SrvCfg_dwUpdateOptions                     ,
            DNS_DEFAULT_UPDATE_OPTIONS              ,
                NULL                                ,

    DNS_REGKEY_REMOTE_DS                            ,
        &SrvCfg_fRemoteDs                           ,
            0                                       ,
                NULL                                ,

    //  Auto config

    DNS_REGKEY_AUTO_CONFIG_FILE_ZONES               ,
        &SrvCfg_fAutoConfigFileZones                ,
            DNS_DEFAULT_AUTO_CONFIG_FILE_ZONES      ,
                NULL                                ,
    DNS_REGKEY_PUBLISH_AUTONET                      ,
        &SrvCfg_fPublishAutonet                     ,
            DNS_DEFAULT_PUBLISH_AUTONET             ,
                NULL                                ,
    DNS_REGKEY_NO_AUTO_REVERSE_ZONES                ,
        &SrvCfg_fNoAutoReverseZones                 ,
            DNS_DEFAULT_NO_AUTO_REVERSE_ZONES       ,
                NULL                                ,
    DNS_REGKEY_AUTO_CACHE_UPDATE                    ,
        &SrvCfg_fAutoCacheUpdate                    ,
            DNS_DEFAULT_AUTO_CACHE_UPDATE           ,
                NULL                                ,
    DNS_REGKEY_DISABLE_AUTONS                       ,
        &SrvCfg_fNoAutoNSRecords                    ,
            DNS_DEFAULT_DISABLE_AUTO_NS_RECORDS     ,
                NULL                                ,

    //  Data integrity

    DNS_REGKEY_STRICT_FILE_PARSING                  ,
        &SrvCfg_fStrictFileParsing                  ,
            DNS_DEFAULT_STRICT_FILE_PARSING         ,
                NULL                                ,
    DNS_REGKEY_DELETE_OUTSIDE_GLUE                  ,
        &SrvCfg_fDeleteOutsideGlue                  ,
            DNS_DEFAULT_DELETE_OUTSIDE_GLUE         ,
                NULL                                ,

    //  DS config

    DNS_REGKEY_DS_POLLING_INTERVAL                  ,
        &SrvCfg_dwDsPollingInterval                 ,
            DNS_DEFAULT_DS_POLLING_INTERVAL         ,
                NULL                                ,
    DNS_REGKEY_DS_TOMBSTONE_INTERVAL                ,
        &SrvCfg_dwDsTombstoneInterval               ,
            DNS_DEFAULT_DS_TOMBSTONE_INTERVAL       ,
                NULL                                ,
    DNS_REGKEY_SYNC_DS_ZONE_SERIAL                  ,
        &SrvCfg_dwSyncDsZoneSerial                  ,
            DNS_DEFAULT_SYNC_DS_ZONE_SERIAL         ,
                NULL                                ,

    //  Aging \ Scavenging

    DNS_REGKEY_SCAVENGING_INTERVAL                  ,
        &SrvCfg_dwScavengingInterval                ,
            DNS_DEFAULT_SCAVENGING_INTERVAL         ,
                cfg_SetScavengingInterval           ,
    DNS_REGKEY_DEFAULT_AGING_STATE                  ,
        &SrvCfg_fDefaultAgingState                  ,
            DNS_DEFAULT_AGING_STATE                 ,
                NULL                                ,
    DNS_REGKEY_DEFAULT_REFRESH_INTERVAL             ,
        &SrvCfg_dwDefaultRefreshInterval            ,
            DNS_DEFAULT_REFRESH_INTERVAL            ,
                NULL                                ,
    DNS_REGKEY_DEFAULT_NOREFRESH_INTERVAL           ,
        &SrvCfg_dwDefaultNoRefreshInterval          ,
            DNS_DEFAULT_NOREFRESH_INTERVAL          ,
                NULL                                ,

    //  Cache control

    DNS_REGKEY_MAX_CACHE_SIZE                       ,
        &SrvCfg_dwMaxCacheSize                      ,
            DNS_SERVER_UNLIMITED_CACHE_SIZE         ,
                cfg_SetMaxCacheSize                 ,

    //  SOA overrides

    DNS_REGKEY_FORCE_SOA_SERIAL                     ,
        &SrvCfg_dwForceSoaSerial                    ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_FORCE_SOA_MINIMUM_TTL                ,
        &SrvCfg_dwForceSoaMinimumTtl                ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_FORCE_SOA_REFRESH                    ,
        &SrvCfg_dwForceSoaRefresh                   ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_FORCE_SOA_RETRY                      ,
        &SrvCfg_dwForceSoaRetry                     ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_FORCE_SOA_EXPIRE                     ,
        &SrvCfg_dwForceSoaExpire                    ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_FORCE_NS_TTL                         ,
        &SrvCfg_dwForceNsTtl                        ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_FORCE_TTL                            ,
        &SrvCfg_dwForceTtl                          ,
            0                                       ,
                NULL                                ,

    //  EDNS

    DNS_REGKEY_MAX_UDP_PACKET_SIZE                  ,
        &SrvCfg_dwMaxUdpPacketSize                  ,
            1280                                    ,   //  DNS_RFC_MAX_UDP_PACKET_LENGTH
                cfg_SetMaxUdpPacketSize             ,
    DNS_REGKEY_ENABLE_EDNS_RECEPTION                ,
        &SrvCfg_dwEnableEDnsReception               ,
            1                                       ,
                NULL                                ,
    DNS_REGKEY_ENABLE_EDNS                          ,
        &SrvCfg_dwEnableEDnsProbes                  ,
            1                                       ,
                NULL                                ,
    DNS_REGKEY_EDNS_CACHE_TIMEOUT                   ,
        &SrvCfg_dwEDnsCacheTimeout                  ,
            (24*60*60) /* one day */                ,
                cfg_SetEDnsCacheTimeout             ,

    //  DNSSEC

    DNS_REGKEY_ENABLE_DNSSEC                        ,
        &SrvCfg_dwEnableDnsSec                      ,
            DNS_DNSSEC_ENABLE_DEFAULT               ,
                NULL                                ,

    DNS_REGKEY_ENABLE_SENDERR_SUPPRESSION           ,
        &SrvCfg_dwEnableSendErrSuppression          ,
            1                                       ,
                NULL                                ,

    //  Test flags

    DNS_REGKEY_TEST1                                ,
        &SrvCfg_fTest1                              ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_TEST2                                ,
        &SrvCfg_fTest2                              ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_TEST3                                ,
        &SrvCfg_fTest3                              ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_TEST4                                ,
        &SrvCfg_fTest4                              ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_TEST5                                ,
        &SrvCfg_fTest5                              ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_TEST6                                ,
        &SrvCfg_fTest6                              ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_TEST7                                ,
        &SrvCfg_fTest7                              ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_TEST8                                ,
        &SrvCfg_fTest8                              ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_TEST9                                ,
        &SrvCfg_fTest9                              ,
            0                                       ,
                NULL                                ,

    //  Fixed test flags

    DNS_REGKEY_QUIET_RECV_LOG_INTERVAL              ,
        &SrvCfg_dwQuietRecvLogInterval              ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_QUIET_RECV_FAULT_INTERVAL            ,
        &SrvCfg_dwQuietRecvFaultInterval            ,
            0                                       ,
                NULL                                ,

    //  Round robin

    DNS_REGKEY_NO_ROUND_ROBIN                       ,
        NULL                                        ,
            0                                       ,
                NULL                                ,

    //  Directory partition support

    DNS_REGKEY_ENABLE_DP                            ,
        &SrvCfg_dwEnableDp                          ,
            1                                       ,
                NULL                                ,
    DNS_REGKEY_FOREST_DP_BASE_NAME                  ,
        NULL                                        ,
            0                                       ,
                cfg_SetForestDpBaseName             ,
    DNS_REGKEY_DOMAIN_DP_BASE_NAME                  ,
        NULL                                        ,
            0                                       ,
                cfg_SetDomainDpBaseName             ,

    DNS_REGKEY_SILENT_IGNORE_CNAME_UPDATE_CONFLICT  ,
        &SrvCfg_fSilentlyIgnoreCNameUpdateConflict  ,
            0                                       ,
                NULL                                ,

    //  Debugging

    DNS_REGKEY_BREAK_ON_ASC_FAILURE                 ,
        &SrvCfg_dwBreakOnAscFailure                 ,
            0                                       ,
                NULL                                ,
    DNS_REGKEY_BREAK_ON_UPDATE_FROM                 ,
        NULL                                        ,
            0                                       ,
                cfg_SetBreakOnUpdateFromList        ,
    DNS_REGKEY_BREAK_ON_RECV_FROM                   ,
        NULL                                        ,
            0                                       ,
                cfg_SetBreakOnRecvFromList          ,

    NULL, NULL, 0, NULL
};

//
//  Value to indicate property not in table or index not in table.
//

#define BAD_PROPERTY_INDEX  ((DWORD)(-1))



DNS_STATUS
loadDwordPropertyByIndex(
    IN      DWORD           PropertyIndex,
    IN      DWORD           Flag
    )
/*++

Routine Description:

    Load DWORD server property from registry.

Arguments:

    PropertyIndex -- ID of server property

    Flag -- flags for function,
        PROPERTY_NODEFAULT  -- if do not want to write default of property

Return Value:

    ERROR_SUCCESS
    ErrorCode for registry failure.
    BAD_PROPERTY_INDEX to indicate index at end of property table.

--*/
{
    DWORD                           value;
    DWORD                           status;
    DWORD                           fread = FALSE;
    DWORD                           len = sizeof(DWORD);
    PDWORD                          pvalueProperty;
    LPSTR                           nameProperty;
    DWORD_PROPERTY_SET_FUNCTION     pfunction;
    DNS_PROPERTY_VALUE              dnsPropertyValue;


    //
    //  check for end of property list
    //

    nameProperty = ServerPropertyTable[ PropertyIndex ].pszPropertyName;
    if ( !nameProperty )
    {
        return( BAD_PROPERTY_INDEX );
    }

    //
    //  verify valid DWORD server property
    //  and get pointer to DWORD property's position in SrvCfg block
    //

    pvalueProperty = ServerPropertyTable[ PropertyIndex ].pDword;
    if ( !pvalueProperty )
    {
        return( ERROR_SUCCESS );
    }

    //
    //  read DWORD server property from registry
    //  or get default value from table
    //
    //  implementation note:
    //      could enum registry values, however would still need to
    //      write defaults, AND dispatch function calls where required
    //      (hence maintain info on whether value read) so considering
    //      this is only called on start, it's good
    //

    len = sizeof(DWORD);

    status = Reg_GetValue(
                NULL,
                NULL,
                nameProperty,
                REG_DWORD,
                (PBYTE) & value,
                &len );

    if ( status == ERROR_SUCCESS )
    {
        DNS_DEBUG( INIT, (
            "Opened <%s> key.\n"
            "\tvalue = %d.\n",
            nameProperty,
            value ));
        fread = TRUE;
    }
    else
    {
        value = ServerPropertyTable[ PropertyIndex ].dwDefault;
        DNS_DEBUG( INIT, (
            "Defaulted server property <%s>.\n"
            "\tvalue = %d.\n",
            nameProperty,
            value ));
    }

    //
    //  if NO default, then leave here when not read from registry
    //

    if ( !fread  &&  (Flag & PROPERTY_NODEFAULT) )
    {
        return( ERROR_SUCCESS );
    }

    //
    //  special processing function for this property?
    //

    status = ERROR_SUCCESS;

    pfunction = ServerPropertyTable[ PropertyIndex ].pFunction;
    if ( pfunction )
    {
        dnsPropertyValue.dwPropertyType = REG_DWORD;
        dnsPropertyValue.dwValue = value;
        status = (*pfunction) (
                    &dnsPropertyValue,
                    PropertyIndex,
                    TRUE,               //  at server load
                    (BOOL)(fread)       //  registry read?
                    );
    }

    //
    //  write property to server config block
    //  note:  we allow function to write itself or choose not to write
    //

    if ( !(status & PROPERTY_NOWRITE) )
    {
        *pvalueProperty = value;
    }

    //
    //  save property to registry, if function demands write back
    //

    if ( status & PROPERTY_FORCEWRITE )
    {
        status = Reg_SetDwordValue(
                    NULL,
                    NULL,
                    nameProperty,
                    value );

        DNS_DEBUG( INIT, (
            "Writing server DWORD property <%s> to registry.\n"
            "\tvalue = %d\n"
            "\tstatus = %p\n",
            nameProperty,
            value,
            status ));
        return( status );
    }

    return( ERROR_SUCCESS );
}



DWORD
findIndexForPropertyName(
    IN      LPSTR           pszName
    )
/*++

Routine Description:

    Retrieve index of server property desired.

Arguments:

    pszName - name property desired

Return Value:

    Index of property name.
    Otherwise BAD_PROPERTY_INDEX.

--*/
{
    INT     i = 0;
    PCHAR   propertyString;

    if ( strlen( pszName ) == 0 )
    {
        return BAD_PROPERTY_INDEX;
    }

    //
    //  Check properties in table for name match
    //

    while ( propertyString = ServerPropertyTable[ i ].pszPropertyName )
    {
        if ( _stricmp( pszName, propertyString ) == 0 )
        {
            return i;
        }
        i++;
    }
    return BAD_PROPERTY_INDEX;
}



DNS_STATUS
loadDwordPropertyByName(
    IN      LPSTR           pszProperty,
    OUT     PDWORD          pdwPropertyValue
    )
/*++

Routine Description:

    Load DWORD server property from registry.

Arguments:

    pszProperty -- name of property

    pdwPropertyValue -- addr to receive DWORD value of property

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PROPERTY if not known DWORD property.

--*/
{
    DWORD       index;
    PDWORD      pvalue;
    DNS_STATUS  status;

    //  get index for property

    index = findIndexForPropertyName( pszProperty );
    if ( index == BAD_PROPERTY_INDEX )
    {
        return( DNS_ERROR_INVALID_PROPERTY );
    }

    //  verify DWORD property

    pvalue = ServerPropertyTable[index].pDword;
    if ( !pvalue )
    {
        return( DNS_ERROR_INVALID_PROPERTY );
    }

    //  load property

    status = loadDwordPropertyByIndex( index, 0 );
    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    //  return property value

    *pdwPropertyValue = *pvalue;

    return( ERROR_SUCCESS );
}



DNS_STATUS
loadAllDwordProperties(
    IN      DWORD   Flag
    )
/*++

Routine Description:

    Load DWORD server property from registry.

Arguments:

    PropertyIndex -- ID of server property

    Flag -- flags for function,
        PROPERTY_NODEFAULT  -- if do not want to write default of property

Return Value:

    ERROR_SUCCESS
    ErrorCode for registry failure.
    BAD_PROPERTY_INDEX to indicate index at end of property table.

--*/
{
    DWORD       iprop = 0;
    DNS_STATUS  status;

    while( 1 )
    {
        status = loadDwordPropertyByIndex( iprop, Flag );
        if ( status == BAD_PROPERTY_INDEX )
        {
            break;
        }
        iprop++;
    }

    return( status );
}



BOOL
Config_Initialize(
    VOID
    )
/*++

Routine Description:

    Initialize server configuration.

Arguments:

    None.

Return Value:

    TRUE if successful.
    FALSE if registry error.

--*/
{
    DWORD               iprop;
    DWORD               version;
    DNS_STATUS          status;
    PWSTR               pwsz;
    DNS_PROPERTY_VALUE  propValue;
    DWORD               index;

    //
    //  clear server configuration
    //

    RtlZeroMemory(
        &SrvInfo,
        sizeof(SERVER_INFO) );

    UPDATE_DNS_TIME();      //  current time is a member of SrvInfo

    //
    //  Calculate the system boot time in CRT terms so we can convert
    //  DNS_TIME into CRT time. Note that the calculated boot time
    //  will be WRONG if the DNS server is restarted after the
    //  tick count has wrapped (at 49.7 days). But this is okay
    //  because the DNS_TIME will also be wrong so the time conversion
    //  will still work.
    //

    SrvInfo_crtSystemBootTime = time( NULL ) - DNS_TIME();

    //
    //  get DNS server version
    //      - SP version is high word
    //      - minor version is high byte of low word
    //      - major version is low byte of low word
    //

    version = DNSSRV_SP_VERSION;
    version <<= 8;
    version |= DNSSRV_MINOR_VERSION;
    version <<= 8;
    version |= DNSSRV_MAJOR_VERSION;
    SrvCfg_dwVersion = version;

    //  DS available on this box

    SrvCfg_fDsAvailable = Ds_IsDsServer();

    //
    //  read \ default DWORD server properties
    //

    g_bRegistryWriteBack = FALSE;
    loadAllDwordProperties( 0 );
    g_bRegistryWriteBack = TRUE;

    //
    //  other server properties
    //      - listen addresses
    //      - publish addresses
    //      - forwarders
    //      - database directory
    //      - previous server name
    //      - log file name


    SrvCfg_aipListenAddrs = Reg_GetIpArray(
                                NULL,
                                NULL,
                                DNS_REGKEY_LISTEN_ADDRESSES );

    SrvCfg_aipPublishAddrs = Reg_GetIpArray(
                                NULL,
                                NULL,
                                DNS_REGKEY_PUBLISH_ADDRESSES );

    //
    //  forwarders read skipped for FILE boot, as it is boot file property
    //

    if ( SrvCfg_fBootMethod != BOOT_METHOD_FILE )
    {
        Config_ReadForwarders();
    }

    //
    //  read directory
    //      - if bootfile has directory directive it can overwrite
    //

    Config_ReadDatabaseDirectory( NULL, 0 );

    //
    //  Read log file path from the registry.
    //

    SrvCfg_pwsLogFilePath = (PWSTR) Reg_GetValueAllocate(
                                        NULL,
                                        NULL,
                                        DNS_REGKEY_LOG_FILE_PATH_PRIVATE,
                                        DNS_REG_WSZ,
                                        NULL );
    DNS_DEBUG( INIT, (
        "Default log file path %S.\n",
        SrvCfg_pwsLogFilePath ));

    //
    //  Read log filter IP list from the registry.
    //

    SrvCfg_aipLogFilterList = Reg_GetIpArray(
                                    NULL,
                                    NULL,
                                    DNS_REGKEY_LOG_IP_FILTER_LIST );
    IF_DEBUG( INIT )
    {
        DnsDbg_IpArray(
            "LogIPFilterList from registry: ",
            NULL,
            SrvCfg_aipLogFilterList );
    }

    //
    //  Read list of types not round robined from registry.
    //

    index = findIndexForPropertyName( DNS_REGKEY_NO_ROUND_ROBIN );
    if ( index != BAD_PROPERTY_INDEX )
    {
        pwsz = ( PWSTR ) Reg_GetValueAllocate(
                            NULL,
                            NULL,
                            DNS_REGKEY_NO_ROUND_ROBIN_PRIVATE,
                            DNS_REG_WSZ,
                            NULL );
        DNS_DEBUG( INIT, (
            "will not round robin: %S\n",
            pwsz ? pwsz : L"NULL" ));
        if ( pwsz )
        {
            propValue.dwPropertyType = DNS_REG_WSZ;
            propValue.pwszValue = pwsz;
            cfg_SetDoNotRoundRobinTypes(
                &propValue,
                index,
                TRUE,
                TRUE );
            FREE_HEAP( pwsz );
        }
    }

    //
    //  Read directory partition settings from registry.
    //

    SrvCfg_pszDomainDpBaseName = ( PSTR ) Reg_GetValueAllocate(
                                        NULL,
                                        NULL,
                                        DNS_REGKEY_DOMAIN_DP_BASE_NAME,
                                        DNS_REG_UTF8,
                                        NULL );
    if ( !SrvCfg_pszDomainDpBaseName )
    {
        SrvCfg_pszDomainDpBaseName = 
            Dns_StringCopyAllocate_A( DNS_DEFAULT_DOMAIN_DP_BASE, 0 );
    }

    SrvCfg_pszForestDpBaseName = ( PSTR ) Reg_GetValueAllocate(
                                        NULL,
                                        NULL,
                                        DNS_REGKEY_FOREST_DP_BASE_NAME,
                                        DNS_REG_UTF8,
                                        NULL );
    if ( !SrvCfg_pszForestDpBaseName )
    {
        SrvCfg_pszForestDpBaseName = 
            Dns_StringCopyAllocate_A( DNS_DEFAULT_FOREST_DP_BASE, 0 );
    }

    //
    //  read previous server name from registry
    //
    //  DEVNOTE: currently this is ANSI only, extended will get bogus name
    //

    SrvCfg_pszPreviousServerName = Reg_GetValueAllocate(
                                        NULL,
                                        NULL,
                                        DNS_REGKEY_PREVIOUS_SERVER_NAME_PRIVATE,
                                        DNS_REG_UTF8,
                                        NULL );
    DNS_DEBUG( INIT, (
        "Previous DNS server host name %s.\n",
        SrvCfg_pszPreviousServerName
        ));

    return( TRUE );
}



DNS_STATUS
Config_ResetProperty(
    IN      LPSTR                   pszPropertyName,
    IN      PDNS_PROPERTY_VALUE     pPropValue
    )
/*++

Routine Description:

    Reset server property from registry. 

Arguments:

    pszPropertyName -- property name

    pPropValue -- property type and value 

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DWORD                           status = ERROR_SUCCESS;
    DWORD                           index;
    DWORD                           currentValue;
    PDWORD                          pvalueProperty;
    DWORD_PROPERTY_SET_FUNCTION     pSetFunction;

    //
    //  Get index for property.
    //

    index = findIndexForPropertyName( pszPropertyName );
    if ( index == BAD_PROPERTY_INDEX )
    {
        DNS_PRINT((
            "ERROR: property name %s, not found\n",
            pszPropertyName ));
        return DNS_ERROR_INVALID_PROPERTY;
    }

    //
    //  Verify the incoming type matches the server property table type.
    //

    if ( pPropValue->dwPropertyType == REG_DWORD &&
            ServerPropertyTable[ index ].pDword == NULL ||
        pPropValue->dwPropertyType != REG_DWORD &&
            ServerPropertyTable[ index ].pDword != NULL )
    {
        DNS_PRINT((
            "ERROR: property %s set type %d does not match property table\n",
            pszPropertyName,
            pPropValue->dwPropertyType ));
        return DNS_ERROR_INVALID_PROPERTY;
    }

    //
    //  Call the special processing function for this value (if there is one).
    //

    pSetFunction = ServerPropertyTable[ index ].pFunction;
    if ( pSetFunction )
    {
        status = ( *pSetFunction ) (
                    pPropValue,
                    index,
                    FALSE,      // reset
                    FALSE );    // not registry read
        if ( status == PROPERTY_ERROR )
        {
            status = GetLastError();
            ASSERT( status != ERROR_SUCCESS );
            return status;
        }
    }

    //
    //  For DWORD properties, write the property value to server config 
    //  block unless the special processing function told us not to.
    //

    if ( pPropValue->dwPropertyType == REG_DWORD &&
        !( status & PROPERTY_NOWRITE ) )
    {
        *ServerPropertyTable[ index ].pDword = ( DWORD ) pPropValue->dwValue;
    }

    //
    //  If booting from boot file, some properties need to cause
    //  a boot info update.
    //

    if ( SrvCfg_fBootMethod == BOOT_METHOD_FILE &&
        status & PROPERTY_UPDATE_BOOTFILE )
    {
        Config_UpdateBootInfo();
    }

    //
    //  Save the property to registry, unless the special processing
    //  function told us not to. Note, we write back even if no changes
    //  are made. This may overwrite any manual changes made while the
    //  server is running.
    //

    if ( status & PROPERTY_NOSAVE )
    {
        return ERROR_SUCCESS;
    }

    switch ( pPropValue->dwPropertyType )
    {
        case REG_DWORD:
            status = Reg_SetDwordValue(
                        NULL,
                        NULL,
                        pszPropertyName,
                        pPropValue->dwValue );
            DNS_DEBUG( INIT, (
                "wrote server DWORD property %s to registry, status %p\n"
                "\tvalue = %d\n",
                pszPropertyName,
                status,
                pPropValue->dwValue ));
            break;

        case DNS_REG_WSZ:
        {
            LPWSTR      pwszPropertyName;

            pwszPropertyName = Dns_StringCopyAllocate(
                                    pszPropertyName,
                                    0,
                                    DnsCharSetUtf8,
                                    DnsCharSetUnicode );
            status = Reg_SetValue(
                        NULL,
                        NULL,
                        ( LPSTR ) pwszPropertyName,
                        DNS_REG_WSZ,
                        pPropValue->pwszValue ? pPropValue->pwszValue : L"",
                        0 );                // length
            FREE_HEAP( pwszPropertyName );
            DNS_DEBUG( INIT, (
                "wrote server WSZ property %s to registry, status %p\n"
                "\tvalue = %S\n",
                pszPropertyName,
                status,
                pPropValue->pwszValue ));
            break;
        }

        case DNS_REG_IPARRAY:
            status = Reg_SetIpArray(
                        NULL,
                        NULL,
                        pszPropertyName,
                        pPropValue->pipValue );
            DNS_DEBUG( INIT, (
                "wrote server IpArray property %s to registry, status %p, value %p\n",
                pszPropertyName,
                status,
                pPropValue->pipValue ));
            IF_DEBUG( INIT )
            {
                DnsDbg_IpArray(
                    "Config_ResetProperty",
                    NULL,
                    pPropValue->pipValue );
            }
            break;

        default:
            ASSERT( FALSE );
            DNS_DEBUG( INIT, (
                "ERROR: unsupported property type %d for property name %s\n",
                pPropValue->dwPropertyType,
                pszPropertyName ));
            break;
    }

    return( status );
}



//
//  NT5+ RPC Query server property
//

DNS_STATUS
Rpc_QueryServerDwordProperty(
    IN      DWORD           dwClientVersion,
    IN      LPSTR           pszQuery,
    OUT     PDWORD          pdwTypeId,
    OUT     PVOID *         ppData
    )
/*++

Routine Description:

    Query DWORD server property.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DWORD   index;
    PDWORD  pvalue;

    DNS_DEBUG( RPC, (
        "Rpc_QueryServerDwordProperty( %s )\n",
        pszQuery ));

    //  find server property index, then grab its value

    index = findIndexForPropertyName( (LPSTR)pszQuery );
    if ( index == BAD_PROPERTY_INDEX )
    {
        DNS_PRINT((
            "ERROR:  Unknown server property %s.\n",
            pszQuery ));
        return( DNS_ERROR_INVALID_PROPERTY );
    }

    //  get ptr to its value, then read value

    pvalue = ServerPropertyTable[ index ].pDword;
    if ( !pvalue )
    {
        DNS_PRINT((
            "ERROR:  Property %s, has no address in property table\n",
            pszQuery ));
        return( DNS_ERROR_INVALID_PROPERTY );
    }

    *(PDWORD)ppData = *pvalue;
    *pdwTypeId = DNSSRV_TYPEID_DWORD;
    return( ERROR_SUCCESS );
}



//
//  NT5+ RPC Query server property
//

DNS_STATUS
Rpc_QueryServerStringProperty(
    IN      DWORD           dwClientVersion,
    IN      LPSTR           pszQuery,
    OUT     PDWORD          pdwTypeId,
    OUT     PVOID *         ppData
    )
/*++

Routine Description:

    Query string server property.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DWORD   index;
    LPWSTR  pwszValue = NULL;

    DNS_DEBUG( RPC, (
        "Rpc_QueryServerStringProperty( %s )\n",
        pszQuery ));

    //  find server property index, to check that the property exists at all

    index = findIndexForPropertyName( ( LPSTR ) pszQuery );
    if ( index == BAD_PROPERTY_INDEX )
    {
        DNS_PRINT((
            "ERROR: unknown server property %s\n",
            pszQuery ));
        return DNS_ERROR_INVALID_PROPERTY;
    }

    if ( ServerPropertyTable[ index ].pDword )
    {
        DNS_PRINT((
            "ERROR: string query for dword property %s\n",
            pszQuery ));
        return DNS_ERROR_INVALID_PROPERTY;
    }

    //  This part is currently manual.

    *pdwTypeId = DNSSRV_TYPEID_LPWSTR;
    if ( _stricmp( pszQuery, DNS_REGKEY_LOG_FILE_PATH ) == 0 )
    {
        pwszValue = SrvCfg_pwsLogFilePath;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_FOREST_DP_BASE_NAME ) == 0 )
    {
        pwszValue = ( LPWSTR ) SrvCfg_pszForestDpBaseName;
        *pdwTypeId = DNSSRV_TYPEID_LPSTR;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_DOMAIN_DP_BASE_NAME ) == 0 )
    {
        pwszValue = ( LPWSTR ) SrvCfg_pszDomainDpBaseName;
        *pdwTypeId = DNSSRV_TYPEID_LPSTR;
    }
    else
    {
        DNS_PRINT((
            "ERROR: string query for non-string property %s\n",
            pszQuery ));
        return DNS_ERROR_INVALID_PROPERTY;
    }

    if ( *pdwTypeId == DNSSRV_TYPEID_LPWSTR )
    {
        * ( LPWSTR * ) ppData = pwszValue ?
            Dns_StringCopyAllocate_W( pwszValue, 0 ) :
            NULL;
    }
    else
    {
        * ( LPSTR * ) ppData = ( LPSTR ) pwszValue ?
            Dns_StringCopyAllocate_A( ( LPSTR ) pwszValue, 0 ) :
            NULL;
    }
    return ERROR_SUCCESS;
}   //  Rpc_QueryServerStringProperty



//
//  NT5+ RPC Query server property
//

DNS_STATUS
Rpc_QueryServerIPArrayProperty(
    IN      DWORD           dwClientVersion,
    IN      LPSTR           pszQuery,
    OUT     PDWORD          pdwTypeId,
    OUT     PVOID *         ppData
    )
/*++

Routine Description:

    Query IP list server property.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DWORD       index;
    PIP_ARRAY   pipValue = NULL;

    DNS_DEBUG( RPC, (
        "Rpc_QueryServerIPArrayProperty( %s )\n",
        pszQuery ));

    //  find server property index, to check that the property exists at all

    index = findIndexForPropertyName( ( LPSTR ) pszQuery );
    if ( index == BAD_PROPERTY_INDEX )
    {
        DNS_PRINT((
            "ERROR: unknown server property %s\n",
            pszQuery ));
        return DNS_ERROR_INVALID_PROPERTY;
    }

    if ( ServerPropertyTable[ index ].pDword )
    {
        DNS_PRINT((
            "ERROR: IP list query for dword property %s\n",
            pszQuery ));
        return DNS_ERROR_INVALID_PROPERTY;
    }

    //  This part is currently manual.

    if ( _stricmp( pszQuery, DNS_REGKEY_LOG_IP_FILTER_LIST ) == 0 )
    {
        pipValue = SrvCfg_aipLogFilterList;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_BREAK_ON_RECV_FROM ) == 0 )
    {
        pipValue = SrvCfg_aipRecvBreakList;
    }
    else if ( _stricmp( pszQuery, DNS_REGKEY_BREAK_ON_UPDATE_FROM ) == 0 )
    {
        pipValue = SrvCfg_aipUpdateBreakList;
    }
    else
    {
        DNS_PRINT((
            "ERROR: IP list query for non-IP list property %s\n",
            pszQuery ));
        return DNS_ERROR_INVALID_PROPERTY;
    }

    * ( PIP_ARRAY * ) ppData = pipValue ?
        Dns_CreateIpArrayCopy( pipValue ) :
        NULL;
    *pdwTypeId = DNSSRV_TYPEID_IPARRAY;
    return ERROR_SUCCESS;
}   //  Rpc_QueryServerIPArrayProperty



//
//  Public configuration functions
//

PIP_ARRAY
Config_ValidateAndCopyNonLocalIpArray(
    IN      PIP_ARRAY       pipArray
    )
/*++

Routine Description:

    Validate and make copy of IP array for non-local IPs.

    Validation includes verifying that no local addresses
    are included.

Arguments:

    pipArray -- IP array to validate

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PIP_ARRAY   pnewArray = NULL;
    PIP_ARRAY   pintersectArray = NULL;

    //
    //  validate array
    //      - ok to specify no secondaries
    //

    if ( !pipArray )
    {
        return( NULL );
    }

    //  check for bogus addresses

    if ( ! Dns_ValidateIpAddressArray(
                pipArray->AddrArray,
                pipArray->AddrCount,
                0 ) )
    {
        //return( DNS_ERROR_INVALID_IP_ADDRESS );
        return( NULL );
    }

    //
    //  screen out loopback
    //

    Dns_DeleteIpFromIpArray(
        pipArray,
        NET_ORDER_LOOPBACK );

    //
    //  verify no intersection with local IPs
    //      - intersection indicates failure
    //      - but just return scrubbed IP array
    //

    Dns_DiffOfIpArrays(
        pipArray,           // target
        g_ServerAddrs,      // server's addresses
        & pnewArray,        // only in target but not server
        NULL,               // in server, not target -- don't care
        & pintersectArray   // intersection
        );

    IF_NOMEM( !pintersectArray || !pnewArray )
    {
        FREE_HEAP( pintersectArray );
        FREE_HEAP( pnewArray );
        return( NULL );
    }

    if ( pintersectArray->AddrCount )
    {
        DNS_PRINT((
            "ERROR: invalid addresses specified to IP array.\n" ));
    }

    FREE_HEAP( pintersectArray );

    return( pnewArray );
}



DNS_STATUS
Config_SetListenAddresses(
    IN      DWORD           cListenAddrs,
    IN      PIP_ADDRESS     aipListenAddrs
    )
/*++

Routine Description:

    Setup server's IP address interfaces.

Arguments:

    cListenAddrs    -- count of listening address
    aipListenAddrs  -- list of forwarders IP addresses

Return Value:

    ERROR_SUCCESS if successful.
   Error code on failure.

--*/
{
    DNS_STATUS  status;
    PIP_ARRAY   oldListenAddrs;
    PIP_ARRAY   newListenAddrs;
    DWORD       i;

    //
    //  if no list, then removing listen constraint
    //

    if ( cListenAddrs == 0 || !aipListenAddrs )
    {
        ASSERT( cListenAddrs == 0 && !aipListenAddrs );
        cListenAddrs = 0;
        newListenAddrs = NULL;
    }

    //
    //  Screen IP addresses
    //

    if ( RpcUtil_ScreenIps( 
                cListenAddrs,
                aipListenAddrs,
                DNS_IP_ALLOW_SELF,
                NULL ) != ERROR_SUCCESS )
    {
        return DNS_ERROR_INVALID_IP_ADDRESS;
    }

    //
    //  if given list, validate and build new listen array
    //

    else
    {
        if ( ! Dns_ValidateIpAddressArray(
                    aipListenAddrs,
                    cListenAddrs,
                    0 ) )
        {
            return( DNS_ERROR_INVALID_IP_ADDRESS );
        }

        newListenAddrs = Dns_BuildIpArray(
                            cListenAddrs,
                            aipListenAddrs );
        if ( ! newListenAddrs )
        {
            return( DNS_ERROR_NO_MEMORY );
        }
        ASSERT_IF_HUGE_ARRAY( newListenAddrs );
    }

    //
    //  clear fields, delete old list
    //

    Config_UpdateLock();

    oldListenAddrs = SrvCfg_aipListenAddrs;
    SrvCfg_fListenAddrsStale = TRUE;
    SrvCfg_aipListenAddrs = newListenAddrs;

    //
    //  intimate dynamic changes to our centralized pnp handler
    //      - if fails, back out change
    //

    status = Sock_ChangeServerIpBindings();
    if ( status != ERROR_SUCCESS )
    {
        SrvCfg_aipListenAddrs = oldListenAddrs;
        oldListenAddrs =  newListenAddrs;       // for FREE below
    }

    //
    //  set registry values
    //
    //  note:  if no listen addresses, then we just delete them
    //      all and clear registry entry, on next service boot, we'll
    //      get default behavior of using all addresses
    //

    else if ( g_bRegistryWriteBack )
    {
        status = Reg_SetIpArray(
                    NULL,
                    NULL,
                    DNS_REGKEY_LISTEN_ADDRESSES,
                    SrvCfg_aipListenAddrs );
    }

    SrvCfg_fListenAddrsStale = FALSE;
    Config_UpdateUnlock();
    Timeout_Free( oldListenAddrs );

    IF_DEBUG( RPC )
    {
        DnsDbg_IpArray(
            "Config_SetListenAddresses().\n",
            "SrvCfg listen IP address list",
            SrvCfg_aipListenAddrs );
    }
    return( status );
}



DNS_STATUS
Config_SetupForwarders(
    IN      PIP_ARRAY       aipForwarders,
    IN      DWORD           dwForwardTimeout,
    IN      BOOL            fSlave
    )
/*++

Routine Description:

    Setup forwarding servers

Arguments:

    cForwarders         -- count of forwarders server
    pIpForwarders       -- list of forwarders IP addresses
    dwForwardTimeout    -- timeout on a forwarding
    fSlave              -- server is slave to forwarders servers

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    DWORD       dwFlag;
    DWORD       i;
    PIP_ARRAY   forwardersArray = NULL;

    //
    //  Screen IP addresses
    //

    if ( aipForwarders &&
        RpcUtil_ScreenIps( 
                aipForwarders->AddrCount,
                aipForwarders->AddrArray,
                0,
                NULL ) != ERROR_SUCCESS )
    {
        return DNS_ERROR_INVALID_IP_ADDRESS;
    }

    //
    //  check and copy forwarders addresses
    //      - valid
    //      - not pointing at this server
    //
    //  no forwarders turns forwarding off
    //

    if ( aipForwarders && aipForwarders->AddrCount )
    {
        forwardersArray = Config_ValidateAndCopyNonLocalIpArray( aipForwarders );
        if ( !forwardersArray )
        {
            return( DNS_ERROR_INVALID_IP_ADDRESS );
        }
    }

    //
    //  reset forwarding info
    //      - timeout and slave first so set before we come on-line
    //      with new forwarders
    //      - timeout delete any old forwarders
    //

    Config_UpdateLock();

    if ( dwForwardTimeout == 0 )
    {
        dwForwardTimeout = DNS_DEFAULT_FORWARD_TIMEOUT;
    }
    SrvCfg_dwForwardTimeout = dwForwardTimeout;

    SrvCfg_fSlave = fSlave;

    Timeout_Free( SrvCfg_aipForwarders );
    SrvCfg_aipForwarders = forwardersArray;

    DNS_DEBUG( INIT, (
        "Set forwarders:\n"
        "\taipForwarders    = %p\n"
        "\tdwTimeout        = %d\n"
        "\tfSlave           = %d\n",
        SrvCfg_aipForwarders,
        SrvCfg_dwForwardTimeout,
        SrvCfg_fSlave ));

    //
    //  set registry values
    //

    if ( g_bRegistryWriteBack )
    {
        if ( forwardersArray )
        {
            Reg_SetIpArray(
                NULL,
                NULL,
                DNS_REGKEY_FORWARDERS,
                SrvCfg_aipForwarders );

            Reg_SetDwordValue(
                NULL,
                NULL,
                DNS_REGKEY_FORWARD_TIMEOUT,
                dwForwardTimeout );

            Reg_SetDwordValue(
                NULL,
                NULL,
                DNS_REGKEY_SLAVE,
                (DWORD) fSlave );
        }
        else
        {
            Reg_DeleteValue(
                NULL,
                NULL,
                DNS_REGKEY_FORWARDERS );

            Reg_DeleteValue(
                NULL,
                NULL,
                DNS_REGKEY_FORWARD_TIMEOUT );

            Reg_DeleteValue(
                NULL,
                NULL,
                DNS_REGKEY_SLAVE );
        }
    }

    Config_UpdateUnlock();
    return( status );
}



DNS_STATUS
Config_ReadForwarders(
    VOID
    )
/*++

Routine Description:

    Read forwarders from registry.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS  status;

    //
    //  read forwarders array from registry
    //

    SrvCfg_aipForwarders = (PIP_ARRAY) Reg_GetIpArray(
                                            NULL,
                                            NULL,
                                            DNS_REGKEY_FORWARDERS );
    if ( !SrvCfg_aipForwarders )
    {
        DNS_DEBUG( INIT, ( "No forwarders found in in registry.\n" ));
        return( ERROR_SUCCESS );
    }
    IF_DEBUG( INIT )
    {
        DnsDbg_IpArray(
            "Forwarders from registry\n",
            NULL,
            SrvCfg_aipForwarders );
    }

    //
    //  forwarding timeout and slave status already read in reading
    //  server DWORD properties
    //
    //  simply confirm sane values
    //

    if ( SrvCfg_dwForwardTimeout == 0 )
    {
        SrvCfg_dwForwardTimeout = DNS_DEFAULT_FORWARD_TIMEOUT;
    }
    return( ERROR_SUCCESS );

#if 0
Failed:

    DNS_LOG_EVENT(
        DNS_EVENT_INVALID_REGISTRY_FORWARDERS,
        0,
        NULL,
        NULL,
        0 );

    DNS_PRINT(( "ERROR:  Reading forwarders info from registry.\n" ));

    return( status );
#endif
}



VOID
Config_UpdateBootInfo(
    VOID
    )
/*++

Routine Description:

    Update boot info.
    Call whenever admin makes change that affects boot file info (new zone,
        change zone type, forwarders, etc.)

Arguments:

    None

Return Value:

    None.

--*/
{
    //  if booted from boot file (or reset to do so)
    //  write back boot file

    if ( SrvCfg_fBootMethod == BOOT_METHOD_FILE )
    {
        SrvCfg_fBootFileDirty = TRUE;
        File_WriteBootFile();
        return;
    }

    //  for registry boot, no need to write, as info is written to registry
    //      incrementally
    //
    //  however, if in freshly installed state, switch to full DS-registry boot

    if ( SrvCfg_fBootMethod == BOOT_METHOD_UNINITIALIZED )
    {
        DNS_PROPERTY_VALUE  prop = { REG_DWORD, BOOT_METHOD_DIRECTORY };

        Config_ResetProperty(
            DNS_REGKEY_BOOT_METHOD,
            &prop );
        return;
    }
}



VOID
Config_PostLoadReconfiguration(
    VOID
    )
/*++

Routine Description:

    Post-load configuration work.

Arguments:

    None

Return Value:

    None.

--*/
{
    //
    //  after load, save current DNS server host name as previous name
    //
    //  note, this is not done until after load, so that load failure
    //  does not stop result in partial replacement
    //

    //  DEVNOTE: if want to skip write, then need another global
    //      - can skip only if the same as previous
    //      SrvCfg_pszPreviousServerName == NULL doesn't cut it for
    //      case where this was NULL on start

    Reg_SetValue(
        NULL,
        NULL,
        DNS_REGKEY_PREVIOUS_SERVER_NAME_PRIVATE,
        DNS_REG_UTF8,
        SrvCfg_pszServerName,
        0 );
}



DNS_STATUS
Config_ReadDatabaseDirectory(
    IN      PCHAR           pchDirectory,       OPTIONAL
    IN      DWORD           cchDirectoryNameLength
    )
/*++

Routine Description:

    Get database directory from registry or use default name.

Arguments:

    pchDirectory -- ptr to directory name;
        OPTIONAL  read from registry or defaulted if not given

    cchDirectoryNameLength -- name length, required if name not NULL terminatated

Return Value:

    ERROR_SUCCESS if successful.
    Error code on error.

--*/
{
    PWSTR   pdirectory = NULL;
    PWSTR   pdirectoryUnexpanded;
    WCHAR   tempBuffer[ MAX_PATH ];
    DWORD   lengthDir = 0;

    //
    //  once per customer
    //  this simplifies code for file boot case;  may call when encounter
    //  directory directive, then always call again to setup before zone load
    //

    if ( SrvCfg_pwsDatabaseDirectory )
    {
        DNS_DEBUG( INIT, (
            "Directory already initialized to %S\n",
            SrvCfg_pwsDatabaseDirectory ));

        return( ERROR_SUCCESS );
    }

    //
    //  init globals for "unable to create" case
    //

    g_pFileDirectoryAppend = NULL;
    g_pFileBackupDirectoryAppend = NULL;

    //
    //  name from boot file?
    //
    //  DEVNOTE: error\event on bogus directory name
    //      - non-existence
    //      - bad length
    //

    if ( pchDirectory )
    {
        pdirectory = Dns_StringCopyAllocate(
                            pchDirectory,
                            cchDirectoryNameLength,
                            DnsCharSetAnsi,             // ANSI in
                            DnsCharSetUnicode           // unicode out
                            );
    }

    //
    //  check registry
    //

    else
    {
        pdirectoryUnexpanded = (PWSTR) Reg_GetValueAllocate(
                                            NULL,
                                            NULL,
                                            DNS_REGKEY_DATABASE_DIRECTORY_PRIVATE,
                                            DNS_REG_EXPAND_WSZ,
                                            NULL );
        if ( pdirectoryUnexpanded )
        {
            pdirectory = Reg_AllocateExpandedString_W( pdirectoryUnexpanded );
            FREE_HEAP( pdirectoryUnexpanded );
        }
    }

    //
    //  read in specific directory name
    //

    if ( pdirectory )
    {
        lengthDir = wcslen( pdirectory );
        if ( lengthDir >= MAX_PATH-20 )
        {
            //  DEVNOTE-LOG: log event!
            //      note we only get here if configured to do so

            DNS_PRINT(( "ERROR:  invalid directory length!\n" ));
            FREE_HEAP( pdirectory );
            pdirectory = NULL;
        }

        //  try create here and if fail (excluding already-exists)
        //      then continue
    }

    //
    //  if no specified name use default name
    //

    if ( ! pdirectory )
    {
        pdirectory = Dns_StringCopyAllocate_W(
                            DNS_DATABASE_DIRECTORY,
                            0 );
        IF_NOMEM( !pdirectory )
        {
            ASSERT( FALSE );
            return( DNS_ERROR_NO_MEMORY );
        }
        lengthDir = wcslen( pdirectory );

        DNS_DEBUG( INIT, (
            "Database directory not in registry, using default: %S\n",
            pdirectory ));

        DNS_DEBUG( INIT, (
            "Database directory %S\n"
            "\tstrlen = %d\n"
            "\tsizeof = %d\n",
            pdirectory,
            lengthDir,
            sizeof( DNS_DATABASE_DIRECTORY )
            ));
    }

    DNS_DEBUG( INIT, (
        "Database directory %S\n",
        pdirectory ));

    SrvCfg_pwsDatabaseDirectory = pdirectory;


    //
    //  create database directory
    //
    //  DEVNOTE: catch appropriate ALREADY_EXISTS error and fix
    //

    if ( ! CreateDirectory(
                pdirectory,
                NULL ) )
    {
        DNS_STATUS status = GetLastError();

        DNS_PRINT((
            "ERROR:  creating directory %S\n"
            "\tstatus = %d (%p)\n",
            pdirectory,
            status, status ));
        //return( status );
    }

    //
    //  create "appendable" names to avoid doing work at runtime
    //      - "dns\"         for directory
    //      - "dns\backup\"  for backup
    //

    g_FileDirectoryAppendLength = lengthDir + 1;

    wcscpy( tempBuffer, pdirectory );
    tempBuffer[ lengthDir ] = L'\\';
    tempBuffer[ g_FileDirectoryAppendLength ] = 0;

    g_pFileDirectoryAppend = Dns_StringCopyAllocate_W(
                                    tempBuffer,
                                    g_FileDirectoryAppendLength );
    IF_NOMEM( !g_pFileDirectoryAppend )
    {
        return( DNS_ERROR_NO_MEMORY );
    }


    //
    //  create backup directory
    //      - note string already has forward separators "\backup"
    //

    g_FileBackupDirectoryAppendLength = lengthDir + wcslen(DNS_DATABASE_BACKUP_SUBDIR) + 1;
    //g_FileBackupDirectoryAppendLength = lengthDir + sizeof(DNS_DATABASE_BACKUP_SUBDIR);

    if ( g_FileBackupDirectoryAppendLength >= MAX_PATH-20 )
    {
        DNS_PRINT(( "ERROR:  backup directory path exceeds MAX_PATH!\n" ));
        goto Done;
    }

    wcscpy( tempBuffer, pdirectory );
    wcscat( tempBuffer, DNS_DATABASE_BACKUP_SUBDIR );

    //  create the backup directory

    if ( ! CreateDirectory(
                tempBuffer,
                NULL ) )
    {
        DNS_STATUS status = GetLastError();

        DNS_PRINT((
            "ERROR:  creating backup directory %S\n"
            "\tstatus = %d (%p)\n",
            tempBuffer,
            status, status ));
    }
    tempBuffer[ g_FileBackupDirectoryAppendLength-1 ] = L'\\';
    tempBuffer[ g_FileBackupDirectoryAppendLength ] = 0;

    g_pFileBackupDirectoryAppend = Dns_StringCopyAllocate_W(
                                        tempBuffer,
                                        g_FileBackupDirectoryAppendLength );
    IF_NOMEM( !g_pFileDirectoryAppend )
    {
        return( DNS_ERROR_NO_MEMORY );
    }

Done:

    DNS_DEBUG( INIT, (
        "Database directory %S\n"
        "\tappend directory %S\n"
        "\tbackup directory %S\n",
        SrvCfg_pwsDatabaseDirectory,
        g_pFileDirectoryAppend,
        g_pFileBackupDirectoryAppend
        ));

    return( ERROR_SUCCESS );
}


#if 0

//
//  Obsolete code, keeping around in case flexibility becomes an issue:
//      - boot file always named "boot"
//      - directory always SystemRoot\system32\dns
//


LPSTR
Config_GetBootFileName(
    VOID
    )
/*++

Routine Description:

    Get boot file name.

    User must free filename string returned.

Arguments:

    None

Return Value:

    Ptr to name of boot file, if successful.
    NULL on error.

--*/
{
    LPSTR   pszBootFile;
    LPSTR   pszBootFileUnexpanded;

    //
    //  check registry
    //

    pszBootFileUnexpanded = Reg_GetValueAllocate(
                                NULL,
                                NULL,
                                DNS_REGKEY_BOOT_FILENAME_PRIVATE,
                                DNS_REG_EXPAND_WSZ,
                                NULL );

    pszBootFile = Reg_ExpandAndAllocatedString(
                        pszBootFileUnexpanded );

    //
    //  if no registry name use default name
    //

    if ( ! pszBootFile )
    {
        pszBootFile = DnsCreateStringCopy(
                            DEFAULT_PATH_TO_BOOT_FILE,
                            0 );
        IF_DEBUG( INIT )
        {
            DNS_PRINT((
                "Boot file not in registry, using default: %s\n",
                pszBootFile ));
        }
    }

    if ( pszBootFileUnexpanded )
    {
        FREE_HEAP( pszBootFileUnexpanded );
    }

    if ( !pszBootFile )
    {
        PVOID parg = TEXT("boot file");

        DNS_LOG_EVENT(
            DNS_EVENT_COULD_NOT_INITIALIZE,
            1,
            & parg,
            NULL,
            0 );

        DNS_DEBUG( INIT, (
            "Could not locate or create boot file name.\n" ));
    }

    return( pszBootFile );
}
#endif



//
//  Server configuration setup functions
//

DNS_STATUS
cfg_SetBootMethod(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Set boot method -- boot file or registry.

Arguments:

    fBootMethod -- boot from registry

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCES, if successful.
    Combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    DWORD       previousBootMethod;
    DNS_STATUS  status = ERROR_SUCCESS;

    ASSERT( pValue->dwPropertyType == REG_DWORD );

    //
    //  on load, no action
    //

    if ( bLoad )
    {
        return( ERROR_SUCCESS );
    }

    //
    //  no action if boot method already same as desired
    //

    if ( SrvCfg_fBootMethod == pValue->dwValue )
    {
        return( ERROR_SUCCESS );
    }

    //
    //  switch to DS-registry boot
    //      - open DS (if on DC)
    //      - if using cache file, write it to directory, but ONLY
    //      if actually have some data;  otherwise ignore
    //

    if ( pValue->dwValue == BOOT_METHOD_DIRECTORY )
    {
        DNS_STATUS  status;

        status = Ds_OpenServer( 0 );
        if ( status == ERROR_SUCCESS )
        {
            if ( g_pCacheZone )
            {
                Ds_WriteZoneToDs(
                    g_pCacheZone,
                    0       // if already exists, leave it
                    );
            }
        }
        ELSE
        {
            DNS_DEBUG ( DS, (
               "Warning <%lu>: set default method to DS on non DSDC.\n",
               status ));
        }
    }

    //
    //  can not have DS zones when booting from file
    //
    //  DEVNOTE-LOG: log EVENT for no-switch to boot file if using DS
    //      must explain way to switch:  all zones out of DS
    //      reboot server, fix
    //

    if ( pValue->dwValue==BOOT_METHOD_FILE  &&  Zone_DoesDsIntegratedZoneExist() )
    {
        SetLastError( DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE );
        return( PROPERTY_ERROR );
    }

    //
    //  set boot method global
    //

    previousBootMethod = SrvCfg_fBootMethod;
    SrvCfg_fBootMethod = pValue->dwValue;

    //
    //  if leaving DS, make sure not-dependent on DS backed root-hints
    //      - force write of root hints
    //
    //  DEVNOTE: forcing root-hints write back?
    //      note:  currently forcing root hint write back
    //      want to make sure we're not whacking an existing cache.dns
    //      when we have less reliable (or perhaps NO) data
    //

    if ( previousBootMethod == BOOT_METHOD_DIRECTORY ||
         (  previousBootMethod == BOOT_METHOD_REGISTRY &&
            pValue->dwValue == BOOT_METHOD_FILE ) )
    {
        ASSERT( pValue->dwValue != BOOT_METHOD_DIRECTORY );

        if ( g_pCacheZone )
        {
            g_pCacheZone->fDsIntegrated = FALSE;

            status = Zone_WriteBackRootHints( TRUE );
            if ( status != ERROR_SUCCESS )
            {
                //
                // DEVNOTE-LOG: Need to report event.
                // write debug, but leave as non-dsintegrated since this is where we are.
                //
                DNS_DEBUG( INIT, (
                    "Error <%lu>: Failed to write back root hints because there's no cache zone.\n",
                    status ));
            }
        }
    }

    //
    //  switching back to boot file
    //      - write boot file for current registry info
    //      - if previously uninitialized boot method, then we've just
    //          successfully read a boot file and booted, no write back
    //          if necessary
    //
    //  DEVNOTE: stay registry boot, if can't write boot file
    //      - time delay here, make sure locking adequate so not overwriting
    //      successful action with failure
    //

    if ( pValue->dwValue == BOOT_METHOD_FILE )
    {
        if ( previousBootMethod != BOOT_METHOD_UNINITIALIZED )
        {
            File_WriteBootFile();

            DeleteFile( DNS_BOOT_FILE_MESSAGE_PATH );

            DNS_LOG_EVENT(
                DNS_EVENT_SWITCH_TO_BOOTFILE,
                0,
                NULL,
                NULL,
                0 );
        }
    }

    //
    //  if switching from boot file
    //      - rename the boot file to avoid confusion
    //

    else if ( previousBootMethod == BOOT_METHOD_FILE )
    {
        HANDLE  hfileBoot;
#if 0
        Reg_DeleteValue(
            NULL,
            NULL,
            DNS_REGKEY_BOOT_FILENAME );
#endif
        MoveFileEx(
            DNS_BOOT_FILE_PATH,
            DNS_BOOT_FILE_LAST_BACKUP,
            MOVEFILE_REPLACE_EXISTING
            );

        hfileBoot = OpenWriteFileEx(
                        DNS_BOOT_FILE_MESSAGE_PATH,
                        FALSE       // overwrite
                        );
        if ( hfileBoot )
        {
            WriteMessageToFile(
                hfileBoot,
                DNS_BOOTFILE_BACKUP_MESSAGE );
            CloseHandle( hfileBoot );
        }
    }

    return( ERROR_SUCCESS );
}



DNS_STATUS
cfg_SetEnableRegistryBoot(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Set boot method -- having read EnableRegistryBoot key.

    This is for backward compatibility to NT4.
    New BootMethod key is set.
    Old EnableRegistryBoot key is deleted.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCES, if successful.
    Combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    DNS_STATUS  status;

    ASSERT( pValue->dwPropertyType == REG_DWORD );

    //
    //  on reset, no action
    //  if not in registry, no action boot method defaults itself
    //

    if ( !bLoad || !bRegistry )
    {
        return( PROPERTY_NOSAVE );
    }

    //
    //  on load, map EnableRegistryBoot, to new BootMethod key
    //

    if ( !pValue->dwValue )
    {
        //  file boot

        SrvCfg_fBootMethod = BOOT_METHOD_FILE;
    }

    else if ( pValue->dwValue == DNS_FRESH_INSTALL_BOOT_REGISTRY_FLAG )
    {
        //  key was NOT present (or in some default new install state)

        SrvCfg_fBootMethod = BOOT_METHOD_UNINITIALIZED;
    }

    else
    {
        SrvCfg_fBootMethod = BOOT_METHOD_REGISTRY;
    }

    status = Reg_SetDwordValue(
                NULL,
                NULL,
                DNS_REGKEY_BOOT_METHOD,
                SrvCfg_fBootMethod );

    if ( status != ERROR_SUCCESS )
    {
        SetLastError( status );
        return  PROPERTY_ERROR;
    }

    //  delete old EnableRegistryBoot key
    //      and return NOSAVE so no creation of new one

    Reg_DeleteValue(
        NULL,
        NULL,
        DNS_REGKEY_BOOT_REGISTRY );

    return( PROPERTY_NOSAVE );
}



DNS_STATUS
cfg_SetAddressAnswerLimit(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Limit AddressAnswerLimit value to appropriate value.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    ASSERT( pValue->dwPropertyType == REG_DWORD );

    //
    //  limit to 5 < ? < 28
    //
    //  28 limit imposed by broken Win95 resolver,
    //  5 sees like a reasonable lower limit -- providing server-down
    //  redundancy without too much wasted bandwidth
    //

    if ( pValue->dwValue > 0 )
    {
        if ( pValue->dwValue < MIN_ADDRESS_ANSWER_LIMIT )
        {
            pValue->dwValue = MIN_ADDRESS_ANSWER_LIMIT;
        }
        else if ( pValue->dwValue > MAX_ADDRESS_ANSWER_LIMIT )
        {
            pValue->dwValue = MAX_ADDRESS_ANSWER_LIMIT;
        }
    }

    //
    //  set value ourselves, as may be different from input
    //

    SrvCfg_cAddressAnswerLimit = pValue->dwValue;

    return( PROPERTY_NOWRITE );
}



DNS_STATUS
cfg_SetLogFilePath(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Set the log file path and trigger the log module to open the new file.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    LPWSTR      pwszOldLogFilePath = SrvCfg_pwsLogFilePath;
    DNS_STATUS  status;

    ASSERT( pValue->dwPropertyType == DNS_REG_WSZ );

    SrvCfg_pwsLogFilePath =
        pValue->pwszValue ?
            Dns_StringCopyAllocate_W( pValue->pwszValue, 0 ) :
            NULL;

    status = Log_InitializeLogging( FALSE );
    
    Timeout_Free( pwszOldLogFilePath );

    if ( status != ERROR_SUCCESS )
    {
        SetLastError( status );
        status = PROPERTY_ERROR;
    }
    return status;
}   //  cfg_SetLogFilePath



DNS_STATUS
cfg_SetLogLevel(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Set the log level for debug logging. If the flags specified are
    non-zero but do not result in any logging return
    DNS_ERROR_NO_PACKET. This is to prevent admins from mistakenly
    setting log settings that will result in no actual packets
    being logged.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    DWORD       dwValue = pValue->dwValue;

    ASSERT( pValue->dwPropertyType == REG_DWORD );

    //
    //  Verify that if any log bits are on that the bits will result in
    //  at least some logging.
    //

    if ( ( dwValue & DNS_LOG_LEVEL_ALL_PACKETS ) && (

        //  Must choose at least one of send and receive.
        ( ( dwValue & DNS_LOG_LEVEL_SEND ) == 0 &&
            ( dwValue & DNS_LOG_LEVEL_RECV ) == 0 ) ||

        //  Must choose at least one protocol.
        ( ( dwValue & DNS_LOG_LEVEL_TCP ) == 0 &&
            ( dwValue & DNS_LOG_LEVEL_UDP ) == 0 ) ||

        //  Must choose at least one packet content category.
        ( ( dwValue & DNS_LOG_LEVEL_QUERY ) == 0 &&
            ( dwValue & DNS_LOG_LEVEL_NOTIFY ) == 0 &&
            ( dwValue & DNS_LOG_LEVEL_UPDATE ) == 0 ) ||

        //  Must choose at least one of request/response.
        ( ( dwValue & DNS_LOG_LEVEL_QUESTIONS ) == 0 &&
            ( dwValue & DNS_LOG_LEVEL_ANSWERS ) == 0 ) ) )
    {
        SetLastError( DNS_ERROR_INVALID_DATA );
        return PROPERTY_ERROR;
    }

    SrvCfg_dwLogLevel = dwValue;

    return ERROR_SUCCESS;
}   //  cfg_SetLogLevel



DNS_STATUS
cfg_SetLogIPFilterList(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Set the log file IP filter list. 

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    PIP_ARRAY       pipOldIPArray = SrvCfg_aipLogFilterList;

    ASSERT( pValue->dwPropertyType == DNS_REG_IPARRAY );

    SrvCfg_aipLogFilterList = Dns_CreateIpArrayCopy( pValue->pipValue );

    Timeout_Free( pipOldIPArray );

    return ERROR_SUCCESS;
}   //  cfg_SetLogIPFilterList



DNS_STATUS
cfg_SetForestDpBaseName(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Set forest directory partition base name.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;

    ASSERT( pValue->dwPropertyType == DNS_REG_UTF8 );

    if ( pValue->pwszValue )
    {
        LPSTR       psz;

        psz = Dns_StringCopyAllocate_A( pValue->pszValue, 0 );
        if ( psz )
        {
            Timeout_Free( SrvCfg_pszForestDpBaseName );
            SrvCfg_pszForestDpBaseName = psz;
        }
        else
        {
            SetLastError( DNS_ERROR_NO_MEMORY );
            status = PROPERTY_ERROR;
        }
    }
    else
    {
        Timeout_Free( SrvCfg_pszForestDpBaseName );
        SrvCfg_pszForestDpBaseName = NULL;
    }

    return status;
}   //  cfg_SetForestDpBaseName



DNS_STATUS
cfg_SetDomainDpBaseName(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Set domain directory partition base name.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;

    ASSERT( pValue->dwPropertyType == DNS_REG_UTF8 );

    if ( pValue->pwszValue )
    {
        LPSTR       psz;

        psz = Dns_StringCopyAllocate_A( pValue->pszValue, 0 );
        if ( psz )
        {
            Timeout_Free( SrvCfg_pszDomainDpBaseName );
            SrvCfg_pszDomainDpBaseName = psz;
        }
        else
        {
            SetLastError( DNS_ERROR_NO_MEMORY );
            status = PROPERTY_ERROR;
        }
    }
    else
    {
        Timeout_Free( SrvCfg_pszDomainDpBaseName );
        SrvCfg_pszDomainDpBaseName = NULL;
    }

    return status;
}   //  cfg_SetDomainDpBaseName



DNS_STATUS
cfg_SetBreakOnUpdateFromList(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Set the update break list of IPs. We will execute a hard breakpoint when
    an update is received from one of these IPs.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    PIP_ARRAY       pipOldIPArray = SrvCfg_aipUpdateBreakList;

    ASSERT( pValue->dwPropertyType == DNS_REG_IPARRAY );

    SrvCfg_aipUpdateBreakList = Dns_CreateIpArrayCopy( pValue->pipValue );

    Timeout_Free( pipOldIPArray );

    return ERROR_SUCCESS;
}   //  cfg_SetBreakOnUpdateFromList



DNS_STATUS
cfg_SetBreakOnRecvFromList(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Set the recevie break list of IPs. We will execute a hard breakpoint when
    a packet is received from one of these IPs.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    PIP_ARRAY       pipOldIPArray = SrvCfg_aipRecvBreakList;

    ASSERT( pValue->dwPropertyType == DNS_REG_IPARRAY );

    SrvCfg_aipRecvBreakList = Dns_CreateIpArrayCopy( pValue->pipValue );

    Timeout_Free( pipOldIPArray );

    return ERROR_SUCCESS;
}   //  cfg_SetBreakOnRecvFromList



DNS_STATUS
cfg_SetMaxUdpPacketSize(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Limit MaxUdpPacketSize to appropriate range of values.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    ASSERT( pValue->dwPropertyType == REG_DWORD );

    //
    //  limit to MIN_UDP_PACKET_SIZE < ? < MAX_UDP_PACKET_SIZE
    //

    if ( pValue->dwValue < MIN_UDP_PACKET_SIZE )
    {
        pValue->dwValue = MIN_UDP_PACKET_SIZE;
    } // if
    else if ( pValue->dwValue > MAX_UDP_PACKET_SIZE )
    {
        pValue->dwValue = MAX_UDP_PACKET_SIZE;
    } // else if

    //
    //  set value ourselves, as may be different from input
    //

    SrvCfg_dwMaxUdpPacketSize = pValue->dwValue;

    return( PROPERTY_NOWRITE );
} // cfg_SetMaxUdpPacketSize



DNS_STATUS
cfg_SetEDnsCacheTimeout(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Limit EDnsCacheTimeout to appropriate range of values.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    ASSERT( pValue->dwPropertyType == REG_DWORD );

    //
    //  limit to MIN_EDNS_CACHE_TIMEOUT < ? < MAX_EDNS_CACHE_TIMEOUT
    //

    if ( pValue->dwValue > 0 )
    {
        if ( pValue->dwValue < MIN_EDNS_CACHE_TIMEOUT )
        {
            pValue->dwValue = MIN_EDNS_CACHE_TIMEOUT;
        } // if
        else if ( pValue->dwValue > MAX_EDNS_CACHE_TIMEOUT )
        {
            pValue->dwValue = MAX_EDNS_CACHE_TIMEOUT;
        } // else if
    } // if

    //
    //  set value ourselves, as may be different from input
    //

    SrvCfg_dwEDnsCacheTimeout = pValue->dwValue;

    return( PROPERTY_NOWRITE );
} // cfg_SetEDnsCacheTimeout



DNS_STATUS
cfg_SetMaxCacheSize(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Limit MaxCacheSize to appropriate value.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    ASSERT( pValue->dwPropertyType == REG_DWORD );

    if ( pValue->dwValue < MIN_MAX_CACHE_SIZE )
    {
        pValue->dwValue = MIN_MAX_CACHE_SIZE;
    }

    SrvCfg_dwMaxCacheSize = pValue->dwValue;

    return PROPERTY_NOWRITE;
}   //  cfg_SetMaxCacheSize



DNS_STATUS
cfg_SetRecursionTimeout(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Limit SrvCfg_dwRecursionTimeout value to appropriate value.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    ASSERT( pValue->dwPropertyType == REG_DWORD );

    //
    //  recursion timeout MUST be reasonable value for proper
    //      operation
    //
    //  if zero, never launch recursion
    //  if too big, keep lots of packets around
    //

    if ( pValue->dwValue > MAX_RECURSION_TIMEOUT )
    {
        pValue->dwValue = MAX_RECURSION_TIMEOUT;
    }
    else if ( pValue->dwValue < MIN_RECURSION_TIMEOUT )
    {
        pValue->dwValue = MIN_RECURSION_TIMEOUT;
    }

    SrvCfg_dwRecursionTimeout = pValue->dwValue;

    return( PROPERTY_NOWRITE );
}



DNS_STATUS
cfg_SetAdditionalRecursionTimeout(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Limit SrvCfg_dwAdditionalRecursionTimeout value to appropriate value.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    ASSERT( pValue->dwPropertyType == REG_DWORD );

    if ( pValue->dwValue > MAX_RECURSION_TIMEOUT )
    {
        pValue->dwValue = MAX_RECURSION_TIMEOUT;
    }
    else if ( pValue->dwValue < MIN_RECURSION_TIMEOUT )
    {
        pValue->dwValue = MIN_RECURSION_TIMEOUT;
    }

    SrvCfg_dwAdditionalRecursionTimeout = pValue->dwValue;

    return( PROPERTY_NOWRITE );
}   //  cfg_SetAdditionalRecursionTimeout



#if DBG
DNS_STATUS
cfg_SetDebugLevel(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Set\reset actual debug flag, turning on debugging as necessary.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    ASSERT( pValue->dwPropertyType == REG_DWORD );

    //  actual debug flag is separate global, so that we can
    //  debug this code on load
    //  reset if
    //      - NOT startup or
    //      - no current debug flag
    //
    //  in effect give the file flag an override of registry value

    if ( !bLoad || DnsSrvDebugFlag==0 )
    {
        //  If dnslib logging is not yet turned on, start it up
        //  with minimal debug flags.

        if ( ( !pDnsDebugFlag || *pDnsDebugFlag == 0 ) && pValue->dwValue )
        {
            Dns_StartDebug(
                0x1000000D,
                NULL,
                NULL,
                DNS_DEBUG_FILENAME,
                DNS_SERVER_DEBUG_LOG_WRAP
                );
        }

        //  Set server debug log level.

        DNS_PRINT(( "DebugFlag reset to %p\n", pValue->dwValue ));
        DnsSrvDebugFlag = pValue->dwValue;

        return( ERROR_SUCCESS );
    }

    //
    //  if loading and already have DebugFlag, then write
    //  its value to SrvCfg value so that it is visible to admin
    //

    else
    {
        SrvCfg_dwDebugLevel = DnsSrvDebugFlag;
        return( PROPERTY_NOWRITE );
    }
}
#endif



DNS_STATUS
cfg_SetNoRecursion(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Set\reset fRecursionAvailable flag based on
    value of NoRecursion property.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    PROPERTY_UPDATE_BOOTFILE -- boot file must be rewritten when this changes

--*/
{
    ASSERT( pValue->dwPropertyType == REG_DWORD );

    SrvCfg_fRecursionAvailable = !pValue->dwValue;

    return( PROPERTY_UPDATE_BOOTFILE );
}



DNS_STATUS
cfg_SetScavengingInterval(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Limit scavenging interval value to appropriate value.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    //
    //  on load, no other action
    //

    if ( bLoad )
    {
        return( ERROR_SUCCESS );
    }

    //
    //  runtime -- reset scavenge timer for new interval
    //      - not forcing scavenge now
    //      - need to set interval so it's picked up in timer reset
    //

    SrvCfg_dwScavengingInterval = pValue->dwValue;
    Scavenge_TimeReset();

    return( ERROR_SUCCESS );
}



DNS_STATUS
cfg_SetDoNotRoundRobinTypes(
    IN      PDNS_PROPERTY_VALUE     pValue,
    IN      DWORD                   dwIndex,
    IN      BOOL                    bLoad,
    IN      BOOL                    bRegistry
    )
/*++

Routine Description:

    Set types that will not be round robined. By default all types
    are RRed. The types are delivered in a WSTR.

    DEVNOTE: I have not yet implemented this setting via RPC since
    an array of words isn't easily added as a new setting. My thought
    is to add it as a simple WSTR setting and have the server do the
    parsing.

Arguments:

    pValue -- the new type and value to set

    dwIndex -- index into property table

    bLoad -- TRUE on server load, FALSE on property reset

    bRegistry -- value read from the registry

Return Value:

    ERROR_SUCCESS or combination of PROPERTY_NOWRITE and PROPERTY_NOSAVE to
    indicate appropriate post processing.

--*/
{
    LPSTR   pszTypeString = NULL;
    INT     iTypeCount = 0;
    PWORD   pwTypeArray = NULL;
    INT     idx;

    ASSERT( pValue );
    ASSERT( pValue->pwszValue );
    ASSERT( pValue->dwPropertyType == DNS_REG_WSZ );

    if ( !pValue ||
        pValue->dwPropertyType != DNS_REG_WSZ ||
        !pValue->pwszValue )
    {
        goto Cleanup;
    }

    //
    //  Allocate a UTF8 copy of the type string for dnslib routine.
    //

    pszTypeString = Dns_StringCopyAllocate(
                            ( PCHAR ) pValue->pwszValue,
                            0,
                            DnsCharSetUnicode,
                            DnsCharSetUtf8 );
    if ( !pszTypeString )
    {
        goto Cleanup;
    }

    //
    //  Parse the type string into a type array.
    //

    if ( Dns_CreateTypeArrayFromMultiTypeString(
                pszTypeString,
                &iTypeCount,
                &pwTypeArray ) != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    //
    //  Reset the default value for all types to the default, then
    //  reset the specified types to zero.
    //  DEVNOTE: possible thread-safe issue here but no possibility
    //  of disastrous outcome (ie. no possible AV).
    //

    for ( idx = 0;
        RecordTypePropertyTable[ idx ][ RECORD_PROP_ROUND_ROBIN ] !=
            RECORD_PROP_TERMINATOR;
        ++idx ) 
    {
        RecordTypePropertyTable[ idx ][ RECORD_PROP_ROUND_ROBIN ] = 1;
    }

    for ( idx = 0; idx < iTypeCount; ++idx ) 
    {
        INT     iPropIndex = INDEX_FOR_QUERY_TYPE( pwTypeArray[ idx ] );

        if ( iPropIndex != 0 )
        {
            RecordTypePropertyTable
                [ iPropIndex ][ RECORD_PROP_ROUND_ROBIN ] = 0;
        }
    }

    //
    //  Save the new array in the global SrvCfg - this will only be
    //  used if the "DoNotRoundTobin" type list is queried through RPC.
    //

    SrvCfg_dwNumDoNotRoundRobinTypes = 0;       //  MT protection
    Timeout_Free( SrvCfg_pwDoNotRoundRobinTypeArray );
    SrvCfg_pwDoNotRoundRobinTypeArray = pwTypeArray;
    SrvCfg_dwNumDoNotRoundRobinTypes = iTypeCount;
    pwTypeArray = NULL;                         //  So we don't free below

    //
    //  Free allocated stuff and return.
    //

    Cleanup:

    if ( pszTypeString )
    {
        FREE_HEAP( pszTypeString );
    }
    if ( pwTypeArray )
    {
        FREE_HEAP( pwTypeArray );
    }

    return ERROR_SUCCESS;
}




#if DBG
DWORD
SrvCfg_UpdateDnsTime(
    IN      LPSTR           pszFile,
    IN      INT             LineNo
    )
/*++

Routine Description:

Arguments:

    pszFile         -- name of file logging the event
    LineNo          -- line number of call to event logging

Return Value:

    New DNS time.

--*/
{
    DNS_TIME() = Dns_GetCurrentTimeInSeconds();

    DNS_DEBUG( TIMEOUT, (
        "DNS_TIME() = %d  ... set in file %s, line %d\n",
        DNS_TIME(),
        pszFile,
        LineNo
        ));

    return( DNS_TIME() );
}

#endif

//
//  End srvcfg.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\srvrpc.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    srvrpc.c

Abstract:

    Domain Name System (DNS) Server

    Server configuration RPC API.

Author:

    Jim Gilroy (jamesg)     October, 1995

Revision History:

--*/


#include "dnssrv.h"

#include "rpcw2k.h"     //  downlevel Windows 2000 RPC functions



//
//  RPC utilities
//

VOID
freeRpcServerInfo(
    IN OUT  PDNS_RPC_SERVER_INFO    pServerInfo
    )
/*++

Routine Description:

    Deep free of DNS_RPC_SERVER_INFO structure.

Arguments:

    None

Return Value:

    None

--*/
{
    if ( !pServerInfo )
    {
        return;
    }

    //
    //  free substructures
    //      - server name
    //      - server IP address array
    //      - listen address array
    //      - forwarders array
    //  then server info itself
    //

    if ( pServerInfo->pszServerName )
    {
        MIDL_user_free( pServerInfo->pszServerName );
    }
    if ( pServerInfo->aipServerAddrs )
    {
        MIDL_user_free( pServerInfo->aipServerAddrs );
    }
    if ( pServerInfo->aipListenAddrs )
    {
        MIDL_user_free( pServerInfo->aipListenAddrs );
    }
    if ( pServerInfo->aipForwarders )
    {
        MIDL_user_free( pServerInfo->aipForwarders );
    }
    if ( pServerInfo->aipLogFilter )
    {
        MIDL_user_free( pServerInfo->aipLogFilter );
    }
    if ( pServerInfo->pwszLogFilePath )
    {
        MIDL_user_free( pServerInfo->pwszLogFilePath );
    }
    if ( pServerInfo->pszDsContainer )
    {
        MIDL_user_free( pServerInfo->pszDsContainer );
    }
    if ( pServerInfo->pszDomainName )
    {
        MIDL_user_free( pServerInfo->pszDomainName );
    }
    if ( pServerInfo->pszForestName )
    {
        MIDL_user_free( pServerInfo->pszForestName );
    }
    if ( pServerInfo->pszDomainDirectoryPartition )
    {
        MIDL_user_free( pServerInfo->pszDomainDirectoryPartition );
    }
    if ( pServerInfo->pszForestDirectoryPartition )
    {
        MIDL_user_free( pServerInfo->pszForestDirectoryPartition );
    }
    MIDL_user_free( pServerInfo );
}



//
//  NT5 RPC Server Operations
//

DNS_STATUS
RpcUtil_ScreenIps(
    IN      DWORD           cIpAddrs,
    IN      PIP_ADDRESS     pIpAddrs,
    IN      DWORD           dwFlags,
    OUT     DWORD *         pdwErrorIp      OPTIONAL
    )
/*++

Routine Description:

    Screen a list of IP addresses for use by the server.
    The basic rules are that the IP list cannot contain:
        - server's own IP addresses
        - loopback addresses
        - multicast addresses
        - broadcast addresses

Arguments:

    cIpAddrs - IP address count

    pIpAddrs - pointer to array of cIpAddrs IP addresses

    dwFlags - modify rules with DNS_IP_XXX flags - pass zero for the
        most restrictive set of rules

        DNS_IP_ALLOW_LOOPBACK -- loopback address is allowed

        DNS_IP_ALLOW_SELF_BOUND -- this machine's own IP addresses
            are allowed but only if they are currently bound for DNS

        DNS_IP_ALLOW_SELF_ANY -- any of this machine's own IP addresses
            are allowed (bound for DNS and not bound for DNS)

    pdwErrorIp - optional - set to index of first invalid IP
        in the array or -1 if there are no invalid IPs

Return Value:

    ERROR_SUCCESS -- IP list contains no unwanted IP addresses
    DNS_ERROR_INVALID_IP_ADDRESS -- IP list contains one or more invalid IPs

--*/
{
    DBG_FN( "RpcUtil_ScreenIps" )

    DNS_STATUS      status = ERROR_SUCCESS;
    DWORD           i = -1;

    if ( !cIpAddrs || !pIpAddrs )
    {
        goto Done;
    }

    #define BAD_IP();   status = DNS_ERROR_INVALID_IP_ADDRESS; break;

    for ( i = 0; i < cIpAddrs; ++i )
    {
        DWORD       ip = pIpAddrs[ i ];
        DWORD       j;

        //
        //  These IPs are never allowable.
        //

        if ( ip == ntohl( INADDR_ANY ) ||
            ip == ntohl( INADDR_NONE ) ||
            ip == ntohl( INADDR_BROADCAST ) ||
            IN_MULTICAST( htonl( ip ) ) )
        {
            BAD_IP();
        }

        //
        //  These IPs may be allowable if flags are set.
        //

        if ( ip == ntohl( INADDR_LOOPBACK ) &&
            !( dwFlags & DNS_IP_ALLOW_LOOPBACK ) )
        {
            BAD_IP();
        }

        if ( g_ServerAddrs && !( dwFlags & DNS_IP_ALLOW_SELF ) )
        {
            for ( j = 0; j < g_ServerAddrs->AddrCount; ++j )
            {
                if ( ip == g_ServerAddrs->AddrArray[ j ] )
                {
                    BAD_IP();
                }
            }
            if ( status != ERROR_SUCCESS )
            {
                break;
            }
        }
    }

    Done:

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( RPC, (
            "%s: invalid IP index %d %s with flags %08X\n", fn,
            i,
            IP_STRING( pIpAddrs[ i ] ),
            dwFlags ));
    }

    if ( pdwErrorIp )
    {
        *pdwErrorIp = status == ERROR_SUCCESS ? -1 : i;
    }

    return status;
}   //  RpcUtil_ScreenIps



DNS_STATUS
Rpc_Restart(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Dump server's cache.

Arguments:

Return Value:

    None.

--*/
{
    ASSERT( dwTypeId == DNSSRV_TYPEID_NULL );
    ASSERT( !pData );

    DNS_DEBUG( RPC, ( "Rpc_Restart()\n" ));

    //
    //  restart by notifying server exactly as if caught
    //      exception on thread
    //

    Service_IndicateRestart();

    return( ERROR_SUCCESS );
}



#if DBG

DWORD
WINAPI
ThreadDebugBreak(
    IN      LPVOID          lpVoid
    )
/*++

Routine Description:

   Declare debugbreak function

Arguments:

Return Value:

    None.

--*/
{
   DNS_DEBUG( RPC, ( "Calling DebugBreak()...\n" ));
   DebugBreak();
   return  ERROR_SUCCESS;
}


DNS_STATUS
Rpc_DebugBreak(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Fork a dns thread & break into the debugger

Arguments:

Return Value:

    None.

--*/
{
    ASSERT( dwTypeId == DNSSRV_TYPEID_NULL );
    ASSERT( !pData );

    DNS_DEBUG( RPC, ( "Rpc_DnsDebugBreak()\n" ));

    if( !Thread_Create("ThreadDebugBreak", ThreadDebugBreak, NULL, 0) )
    {
        return GetLastError();
    }

    return ERROR_SUCCESS;
}


DNS_STATUS
Rpc_ClearDebugLog(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Clear the debug log - simulate hitting the max debug log file size.

    This is handy if you want to start a fresh log file so you don't have
    to wade through reams of stuff to get to what you're interested in.

Arguments:

Return Value:

    None.

--*/
{
    ASSERT( dwTypeId == DNSSRV_TYPEID_NULL );
    ASSERT( !pData );

    DNS_DEBUG( RPC, ( "Rpc_ClearDebugLog()\n" ));
    
    DnsDbg_WrapLogFile();

    return ERROR_SUCCESS;
}



DNS_STATUS
Rpc_RootBreak(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Break root to test AV protection.

Arguments:

Return Value:

    None.

--*/
{
    ASSERT( dwTypeId == DNSSRV_TYPEID_NULL );
    ASSERT( !pData );

    DNS_DEBUG( RPC, ( "Rpc_RootBreak()\n" ));

    DATABASE_ROOT_NODE->pZone = (PVOID)(7);

    return ERROR_SUCCESS;
}
#endif



DNS_STATUS
Rpc_WriteRootHints(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Write root-hints back to file or DS.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    ASSERT( dwTypeId == DNSSRV_TYPEID_NULL );
    ASSERT( !pData );

    DNS_DEBUG( RPC, ( "Rpc_WriteRootHints()\n" ));

    return  Zone_WriteBackRootHints(
                FALSE       // don't write if not dirty
                );
}



DNS_STATUS
Rpc_ClearCache(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Dump server's cache.

Arguments:

Return Value:

    None.

--*/
{
    ASSERT( dwTypeId == DNSSRV_TYPEID_NULL );
    ASSERT( !pData );

    DNS_DEBUG( RPC, ( "Rpc_ClearCache()\n" ));

    if ( !g_pCacheZone || g_pCacheZone->pLoadTreeRoot )
    {
        return( DNS_ERROR_ZONE_LOCKED );
    }
    if ( !Zone_LockForAdminUpdate(g_pCacheZone) )
    {
        return( DNS_ERROR_ZONE_LOCKED );
    }

    return  Zone_LoadRootHints();
}



DNS_STATUS
Rpc_ResetServerDwordProperty(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset DWORD server property.

Arguments:

Return Value:

    None.

--*/
{
    DNS_PROPERTY_VALUE prop =
    {
        REG_DWORD,
        ( ( PDNS_RPC_NAME_AND_PARAM ) pData )->dwParam
    };

    //
    //  Some properties are not dynamic, but allow them to change in
    //  checked builds for test convenience. But if test shoots themself
    //  in the foot (eg. if you enlarge the UdpPacketSize and don't
    //  restart, the server will start corrupting memory) - no whining!
    //


    ASSERT( dwTypeId == DNSSRV_TYPEID_NAME_AND_PARAM );
    ASSERT( pData );

    DNS_DEBUG( RPC, (
        "Rpc_ResetDwordProperty( %s, val=%d (%p) )\n",
        ((PDNS_RPC_NAME_AND_PARAM)pData)->pszNodeName,
        ((PDNS_RPC_NAME_AND_PARAM)pData)->dwParam,
        ((PDNS_RPC_NAME_AND_PARAM)pData)->dwParam
        ));

#ifndef DBG
    if ( strcmp(
            ( ( PDNS_RPC_NAME_AND_PARAM ) pData )->pszNodeName,
            DNS_REGKEY_MAX_UDP_PACKET_SIZE ) == 0 )
    {
        return DNS_ERROR_INVALID_PROPERTY;
    }
#endif

    return Config_ResetProperty(
                ((PDNS_RPC_NAME_AND_PARAM)pData)->pszNodeName,
                &prop );
}




DNS_STATUS
Rpc_ResetServerStringProperty(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset string server property.

    The string property value is Unicode string.

Arguments:

Return Value:

    None.

--*/
{
    DNS_PROPERTY_VALUE prop = { DNS_REG_WSZ, 0 };

    ASSERT( dwTypeId == DNSSRV_TYPEID_LPWSTR );

    DNS_DEBUG( RPC, (
        "Rpc_ResetServerStringProperty( %s, val=\"%S\" )\n",
        pszProperty,
        ( LPWSTR ) pData ));

    prop.pwszValue = ( LPWSTR ) pData;
    return Config_ResetProperty( pszProperty, &prop );
}   //  Rpc_ResetServerStringProperty



DNS_STATUS
Rpc_ResetServerIPArrayProperty(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset IP List server property.

Arguments:

Return Value:

    None.

--*/
{
    DNS_PROPERTY_VALUE prop = { DNS_REG_IPARRAY, 0 };

    ASSERT( dwTypeId == DNSSRV_TYPEID_IPARRAY );

    DNS_DEBUG( RPC, (
        "Rpc_ResetServerIPArrayProperty( %s, iplist=%p )\n",
        pszProperty,
        pData ));

    prop.pipValue = ( PIP_ARRAY ) pData;
    return Config_ResetProperty( pszProperty, &prop );
}   //  Rpc_ResetServerIPArrayProperty



DNS_STATUS
Rpc_ResetForwarders(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset forwarders.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS  status;

    DNS_DEBUG( RPC, ( "Rpc_ResetForwarders()\n" ));

    //  unpack and set forwarders

    status = Config_SetupForwarders(
                ((PDNS_RPC_FORWARDERS)pData)->aipForwarders,
                ((PDNS_RPC_FORWARDERS)pData)->dwForwardTimeout,
                ((PDNS_RPC_FORWARDERS)pData)->fSlave );

    if ( status == ERROR_SUCCESS )
    {
        Config_UpdateBootInfo();
    }
    return( status );
}



DNS_STATUS
Rpc_ResetListenAddresses(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Reset forwarders.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS  status;
    PIP_ARRAY   pipArray = (PIP_ARRAY)pData;

    DNS_DEBUG( RPC, ( "Rpc_ResetListenAddresses()\n" ));

    //  unpack and set forwarders

    return  Config_SetListenAddresses(
                pipArray ? pipArray->AddrCount : 0,
                pipArray ? pipArray->AddrArray : NULL );
}



DNS_STATUS
Rpc_StartScavenging(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Launches the scavenging thread (admin initiated scavenging)

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_STATUS status;

    DNS_DEBUG( RPC, ( "Rpc_StartScavenging()\n" ));

    //  reset scavenging timer
    //      TRUE forces scavenge now

    status = Scavenge_CheckForAndStart( TRUE );

    return status;
}



DNS_STATUS
Rpc_AbortScavenging(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszProperty,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Launches the scavenging thread (admin initiated scavenging)

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    DNS_DEBUG( RPC, ( "Rpc_AbortScavenging()\n" ));

    Scavenge_Abort();

    return ERROR_SUCCESS;
}



//
//  NT5+ RPC Server query API
//

DNS_STATUS
Rpc_GetServerInfo(
    IN      DWORD       dwClientVersion,
    IN      LPSTR       pszQuery,
    OUT     PDWORD      pdwTypeId,
    OUT     PVOID *     ppData
    )
/*++

Routine Description:

    Get server info.

Arguments:

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    PDNS_RPC_SERVER_INFO    pinfo;
    CHAR                    szfqdn[ DNS_MAX_NAME_LENGTH + 1 ];

    DNS_DEBUG( RPC, (
        "Rpc_GetServerInfo( dwClientVersion=0x%lX)\n",
        dwClientVersion ));

    if ( dwClientVersion == DNS_RPC_W2K_CLIENT_VERSION )
    {
        return W2KRpc_GetServerInfo(
                    dwClientVersion,
                    pszQuery,
                    pdwTypeId,
                    ppData );
    }

    //
    //  allocate server info buffer
    //

    pinfo = MIDL_user_allocate_zero( sizeof(DNS_RPC_SERVER_INFO) );
    if ( !pinfo )
    {
        DNS_PRINT(( "ERROR:  unable to allocate SERVER_INFO block.\n" ));
        goto DoneFailed;
    }

    //
    //  fill in fixed fields
    //

    pinfo->dwVersion                = SrvCfg_dwVersion;
    pinfo->dwRpcProtocol            = SrvCfg_dwRpcProtocol;
    pinfo->dwLogLevel               = SrvCfg_dwLogLevel;
    pinfo->dwDebugLevel             = SrvCfg_dwDebugLevel;
    pinfo->dwEventLogLevel          = SrvCfg_dwEventLogLevel;
    pinfo->dwLogFileMaxSize         = SrvCfg_dwLogFileMaxSize;
    pinfo->dwAdForestVersion        = g_dwAdForestVersion;
    pinfo->dwAdDomainVersion        = g_dwAdDomainVersion;
    pinfo->dwAdDsaVersion           = g_dwAdDsaVersion;
    pinfo->dwNameCheckFlag          = SrvCfg_dwNameCheckFlag;
    pinfo->cAddressAnswerLimit      = SrvCfg_cAddressAnswerLimit;
    pinfo->dwRecursionRetry         = SrvCfg_dwRecursionRetry;
    pinfo->dwRecursionTimeout       = SrvCfg_dwRecursionTimeout;
    pinfo->dwForwardTimeout         = SrvCfg_dwForwardTimeout;
    pinfo->dwMaxCacheTtl            = SrvCfg_dwMaxCacheTtl;
    pinfo->dwDsPollingInterval      = SrvCfg_dwDsPollingInterval;
    pinfo->dwScavengingInterval     = SrvCfg_dwScavengingInterval;
    pinfo->dwDefaultRefreshInterval     = SrvCfg_dwDefaultRefreshInterval;
    pinfo->dwDefaultNoRefreshInterval   = SrvCfg_dwDefaultNoRefreshInterval;

    if ( g_LastScavengeTime  )
    {
        pinfo->dwLastScavengeTime   = ( DWORD ) DNS_TIME_TO_CRT_TIME( g_LastScavengeTime );
    }

    //  boolean flags

    pinfo->fBootMethod              = (BOOLEAN) SrvCfg_fBootMethod;
    pinfo->fAdminConfigured         = (BOOLEAN) SrvCfg_fAdminConfigured;
    pinfo->fAllowUpdate             = (BOOLEAN) SrvCfg_fAllowUpdate;
    pinfo->fAutoReverseZones        = (BOOLEAN) ! SrvCfg_fNoAutoReverseZones;
    pinfo->fAutoCacheUpdate         = (BOOLEAN) SrvCfg_fAutoCacheUpdate;

    pinfo->fSlave                   = (BOOLEAN) SrvCfg_fSlave;
    pinfo->fForwardDelegations      = (BOOLEAN) SrvCfg_fForwardDelegations;
    pinfo->fNoRecursion             = (BOOLEAN) SrvCfg_fNoRecursion;
    pinfo->fSecureResponses         = (BOOLEAN) SrvCfg_fSecureResponses;
    pinfo->fRoundRobin              = (BOOLEAN) SrvCfg_fRoundRobin;
    pinfo->fLocalNetPriority        = (BOOLEAN) SrvCfg_fLocalNetPriority;
    pinfo->fBindSecondaries         = (BOOLEAN) SrvCfg_fBindSecondaries;
    pinfo->fWriteAuthorityNs        = (BOOLEAN) SrvCfg_fWriteAuthorityNs;

    pinfo->fStrictFileParsing       = (BOOLEAN) SrvCfg_fStrictFileParsing;
    pinfo->fLooseWildcarding        = (BOOLEAN) SrvCfg_fLooseWildcarding;
    pinfo->fDefaultAgingState       = (BOOLEAN) SrvCfg_fDefaultAgingState;


    //  DS available

    //pinfo->fDsAvailable = SrvCfg_fDsAvailable;
    pinfo->fDsAvailable     = (BOOLEAN) Ds_IsDsServer();

#if DBG
    //  if Test5 set, fake DS available
    //  this is debug only for easy failure testing

    if ( SrvCfg_fTest8 )
    {
        pinfo->fDsAvailable = TRUE;
    }
#endif

    //
    //  server name
    //

    if ( ! RpcUtil_CopyStringToRpcBuffer(
                &pinfo->pszServerName,
                SrvCfg_pszServerName ) )
    {
        DNS_PRINT(( "ERROR:  unable to copy SrvCfg_pszServerName.\n" ));
        goto DoneFailed;
    }

    //
    //  path to DNS container in DS
    //  unicode since Marco will build unicode LDAP paths
    //

    if ( g_pwszDnsContainerDN )
    {
        pinfo->pszDsContainer = (LPWSTR) Dns_StringCopyAllocate(
                                            (LPSTR) g_pwszDnsContainerDN,
                                            0,
                                            DnsCharSetUnicode,   // unicode in
                                            DnsCharSetUnicode    // unicode out
                                            );
        if ( ! pinfo->pszDsContainer )
        {
            DNS_PRINT(( "ERROR:  unable to copy g_pszDsDnsContainer.\n" ));
            goto DoneFailed;
        }
    }

    //
    //  server IP address list
    //  listening IP address list
    //

    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pinfo->aipServerAddrs,
                g_ServerAddrs ) )
    {
        goto DoneFailed;
    }

    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pinfo->aipListenAddrs,
                SrvCfg_aipListenAddrs ) )
    {
        goto DoneFailed;
    }

    //
    //  Forwarders list
    //

    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pinfo->aipForwarders,
                SrvCfg_aipForwarders ) )
    {
        goto DoneFailed;
    }

    //
    //  Logging
    //

    if ( ! RpcUtil_CopyIpArrayToRpcBuffer(
                &pinfo->aipLogFilter,
                SrvCfg_aipLogFilterList ) )
    {
        goto DoneFailed;
    }

    if ( SrvCfg_pwsLogFilePath )
    {
        pinfo->pwszLogFilePath =
            Dns_StringCopyAllocate_W(
                SrvCfg_pwsLogFilePath,
                0 );
        if ( !pinfo->pwszLogFilePath )
        {
            goto DoneFailed;
        }
    }

    //
    //  Directory partition stuff
    //

    if ( g_pszForestDefaultDpFqdn )
    {
        pinfo->pszDomainDirectoryPartition =
            Dns_StringCopyAllocate_A( g_pszDomainDefaultDpFqdn, 0 );
    }

    if ( g_pszForestDefaultDpFqdn )
    {
        pinfo->pszForestDirectoryPartition =
            Dns_StringCopyAllocate_A( g_pszForestDefaultDpFqdn, 0 );
    }

    if ( DSEAttributes[ I_DSE_DEF_NC ].pszAttrVal )
    {
        Ds_ConvertDnToFqdn( 
            DSEAttributes[ I_DSE_DEF_NC ].pszAttrVal,
            szfqdn );
        pinfo->pszDomainName = Dns_StringCopyAllocate_A( szfqdn, 0 );
    }

    if ( DSEAttributes[ I_DSE_ROOTDMN_NC ].pszAttrVal )
    {
        Ds_ConvertDnToFqdn( 
            DSEAttributes[ I_DSE_ROOTDMN_NC ].pszAttrVal,
            szfqdn );
        pinfo->pszForestName = Dns_StringCopyAllocate_A( szfqdn, 0 );
    }

    //
    //  set ptr
    //

    pinfo->dwRpcStuctureVersion = DNS_RPC_SERVER_INFO_VER;
    *(PDNS_RPC_SERVER_INFO *)ppData = pinfo;
    *pdwTypeId = DNSSRV_TYPEID_SERVER_INFO;

    IF_DEBUG( RPC )
    {
        DnsDbg_RpcServerInfo(
            "GetServerInfo return block",
            pinfo );
    }
    return( ERROR_SUCCESS );

DoneFailed:

    //  free newly allocated info block

    if ( pinfo )
    {
        freeRpcServerInfo( pinfo );
    }
    return( DNS_ERROR_NO_MEMORY );
}


//
//  End of srvrpc.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\stats.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    stats.c

Abstract:

    Domain Name System (DNS) Server

    Statics processing.

Author:

    Jim Gilroy (jamesg)  August 1995

Revision History:

--*/


#include "dnssrv.h"

//  Perfmon support

#include <winperf.h>

#include "datadns.h"           // perfmon header
#include "perfutil.h"
#include "perfconfig.h"

#include <loadperf.h>

#include <stdio.h>
#include <ctype.h>


//
//  Statistics globals
//

DWORD   beforeStats = BEFORE_BUF_VALUE;

DNSSRV_TIME_STATS           TimeStats;
DNSSRV_QUERY_STATS          QueryStats;
DNSSRV_QUERY2_STATS         Query2Stats;
DNSSRV_RECURSE_STATS        RecurseStats;
DNSSRV_MASTER_STATS         MasterStats;
DNSSRV_SECONDARY_STATS      SecondaryStats;
DNSSRV_WINS_STATS           WinsStats;
DNSSRV_UPDATE_STATS         WireUpdateStats;
DNSSRV_UPDATE_STATS         NonWireUpdateStats;
DNSSRV_SKWANSEC_STATS       SkwansecStats;
DNSSRV_DS_STATS             DsStats;
DNSSRV_MEMORY_STATS         MemoryStats;
DNSSRV_TIMEOUT_STATS        TimeoutStats;
DNSSRV_DBASE_STATS          DbaseStats;
DNSSRV_RECORD_STATS         RecordStats;
DNSSRV_PACKET_STATS         PacketStats;
DNSSRV_NBSTAT_STATS         NbstatStats;
DNSSRV_PRIVATE_STATS        PrivateStats;
DNSSRV_ERROR_STATS          ErrorStats;
DNSSRV_CACHE_STATS          CacheStats;

DWORD   afterStats = AFTER_BUF_VALUE;


//
//  Stats table
//
//  This simple lets us handle all the logic in loop
//  through various stat types.
//

DWORD   beforeStatsTable = BEFORE_BUF_VALUE;

struct StatsTableEntry StatsTable[] =
{
    DNSSRV_STATID_TIME,
        FALSE,
            sizeof(DNSSRV_TIME_STATS),
                & TimeStats,

    DNSSRV_STATID_QUERY,
        TRUE,
            sizeof(DNSSRV_QUERY_STATS),
                & QueryStats,

    DNSSRV_STATID_QUERY2,
        TRUE,
            sizeof(DNSSRV_QUERY2_STATS),
                & Query2Stats,

    DNSSRV_STATID_RECURSE,
        TRUE,
            sizeof(DNSSRV_RECURSE_STATS),
                & RecurseStats,

    DNSSRV_STATID_MASTER,
        TRUE,
            sizeof(DNSSRV_MASTER_STATS),
                & MasterStats,

    DNSSRV_STATID_SECONDARY,
        TRUE,
            sizeof(DNSSRV_SECONDARY_STATS),
                & SecondaryStats,

    DNSSRV_STATID_WINS,
        TRUE,
            sizeof(DNSSRV_WINS_STATS),
                & WinsStats,

    DNSSRV_STATID_WIRE_UPDATE,
        TRUE,
            sizeof(DNSSRV_UPDATE_STATS),
                & WireUpdateStats,

    DNSSRV_STATID_NONWIRE_UPDATE,
        TRUE,
            sizeof(DNSSRV_UPDATE_STATS),
                & NonWireUpdateStats,

    DNSSRV_STATID_SKWANSEC,
        TRUE,
            sizeof(DNSSRV_SKWANSEC_STATS),
                & SkwansecStats,

    DNSSRV_STATID_DS,
        TRUE,
            sizeof(DNSSRV_DS_STATS),
                & DsStats,

    DNSSRV_STATID_MEMORY,
        FALSE,
            sizeof(DNSSRV_MEMORY_STATS),
                & MemoryStats,

    DNSSRV_STATID_TIMEOUT,
        FALSE,
            sizeof(DNSSRV_TIMEOUT_STATS),
                & TimeoutStats,

    DNSSRV_STATID_DBASE,
        FALSE,
            sizeof(DNSSRV_DBASE_STATS),
                & DbaseStats,

    DNSSRV_STATID_RECORD,
        FALSE,
            sizeof(DNSSRV_RECORD_STATS),
                & RecordStats,

    DNSSRV_STATID_PACKET,
        FALSE,
            sizeof(DNSSRV_PACKET_STATS),
                & PacketStats,

    DNSSRV_STATID_NBSTAT,
        FALSE,
            sizeof(DNSSRV_NBSTAT_STATS),
                & NbstatStats,

    DNSSRV_STATID_ERRORS,
        FALSE,
            sizeof(DNSSRV_ERROR_STATS),
                & ErrorStats,

    DNSSRV_STATID_CACHE,
        FALSE,
            sizeof(DNSSRV_CACHE_STATS),
                & CacheStats,

    DNSSRV_STATID_PRIVATE,
        FALSE,
            sizeof(DNSSRV_PRIVATE_STATS),
                & PrivateStats,

    0, 0, 0, NULL   // termination
};
DWORD   afterStatsTable = AFTER_BUF_VALUE;


//
//  Private protos
//

VOID
perfmonCounterBlockInit(
    VOID
    );




VOID
Stats_Initialize(
    VOID
    )
/*++

Routine Description:

    Initialize DNS statistics.

Arguments:

    None

Return Value:

    None.

--*/
{
    PDNSSRV_STATS   pstat;
    DWORD           i;
    WORD            length;
    DNS_SYSTEMTIME  timeSystem;
    DWORD           secondsTime;


    //
    //  initialize all stat buffers
    //

    i = 0;
    while( pstat = (PDNSSRV_STATS) StatsTable[i].pStats )
    {
        pstat->Header.StatId    = StatsTable[i].Id;
        pstat->Header.fClear    = StatsTable[i].fClear;
        pstat->Header.fReserved = 0;

        length = StatsTable[i].wLength - sizeof(DNSSRV_STAT_HEADER);
        pstat->Header.wLength   = length;

        RtlZeroMemory(
            pstat->Buffer,
            length
            );
        i++;
    }

    //
    //  save server start time
    //  this is also time of last clear
    //

    secondsTime = GetCurrentTimeInSeconds();
    TimeStats.ServerStartTimeSeconds    = secondsTime;
    TimeStats.LastClearTimeSeconds      = secondsTime;

    GetSystemTime( (PSYSTEMTIME)&timeSystem );
    TimeStats.ServerStartTime   = timeSystem;
    TimeStats.LastClearTime     = timeSystem;

    //
    //  init perfmon block
    //

    perfmonCounterBlockInit();
}



VOID
deriveSkwansecStats(
    VOID
    )
/*++

Routine Description:

    Write SkwanSec stats to stats buffer.

Arguments:

    None

Return Value:

    None.

--*/
{
    //  security context caching stuff

    SkwansecStats.SecContextCreate              =   SecContextCreate;
    SkwansecStats.SecContextFree                =   SecContextFree;
    SkwansecStats.SecContextQueue               =   SecContextQueue;
    SkwansecStats.SecContextQueueInNego         =   SecContextQueueInNego;
    SkwansecStats.SecContextDequeue             =   SecContextDequeue;
    SkwansecStats.SecContextTimeout             =   SecContextTimeout;

    SkwansecStats.SecContextQueueNegoComplete   =
                SkwansecStats.SecContextQueue - SkwansecStats.SecContextQueueInNego;
    SkwansecStats.SecContextQueueLength         =
                SkwansecStats.SecContextQueue -
                SkwansecStats.SecContextDequeue -
                SkwansecStats.SecContextTimeout;

    //  security packet info alloc\free

    SkwansecStats.SecPackAlloc                  =   SecPackAlloc;
    SkwansecStats.SecPackFree                   =   SecPackFree;

    //  TKEY and TSIG handling

    SkwansecStats.SecTkeyInvalid                =   SecTkeyInvalid;
    SkwansecStats.SecTkeyBadTime                =   SecTkeyBadTime;
    SkwansecStats.SecTsigFormerr                =   SecTsigFormerr;
    SkwansecStats.SecTsigEcho                   =   SecTsigEcho;
    SkwansecStats.SecTsigBadKey                 =   SecTsigBadKey;
    SkwansecStats.SecTsigVerifySuccess          =   SecTsigVerifySuccess;
    SkwansecStats.SecTsigVerifyFailed           =   SecTsigVerifyFailed;

    //  Temp hacks in private stats

    PrivateStats.SecTsigVerifyOldSig            =   SecTsigVerifyOldSig;
    PrivateStats.SecTsigVerifyOldFailed         =   SecTsigVerifyOldFailed;
    PrivateStats.SecBigTimeSkewBypass           =   SecBigTimeSkewBypass;
}



VOID
deriveAndTimeSetStats(
    VOID
    )
/*++

Routine Description:

    Get copy of current statistics.

Arguments:

    None

Return Value:

    None.

--*/
{
    DWORD   secondsTime;

    //Stats_Lock();

    //
    //  some statistics are derived
    //

    NTree_WriteDerivedStats();
    RR_WriteDerivedStats();
    Packet_WriteDerivedStats();
    Nbstat_WriteDerivedStats();
    Up_WriteDerivedUpdateStats();
    Mem_WriteDerivedStats();
    deriveSkwansecStats();

    //
    //  time delta
    //

    secondsTime = GetCurrentTimeInSeconds();
    TimeStats.SecondsSinceLastClear = secondsTime - TimeStats.LastClearTimeSeconds;
    TimeStats.SecondsSinceServerStart = secondsTime - TimeStats.ServerStartTimeSeconds;

    //Stats_Unlock();
}



VOID
Stats_Clear(
    VOID
    )
/*++

Routine Description:

    Clear statistics.

Arguments:

    None

Return Value:

    None.

--*/
{
    PDNSSRV_STATS   pstat;
    DNS_SYSTEMTIME  timeSystem;
    DWORD           timeSeconds;
    DWORD           i;

    GetSystemTime( (PSYSTEMTIME)&timeSystem );
    timeSeconds = GetCurrentTimeInSeconds();

    //Stats_Lock();

    //
    //  clear query and response stats
    //  database stats unaffected
    //

    i = 0;
    while( pstat = (PDNSSRV_STAT) StatsTable[i].pStats )
    {
        i++;
        if ( pstat->Header.fClear )
        {
            RtlZeroMemory(
                pstat->Buffer,
                pstat->Header.wLength
                );
        }
    }

    //  save time of last clear

    TimeStats.LastClearTime = timeSystem;
    TimeStats.LastClearTimeSeconds = timeSeconds;

    //Stats_Unlock();

}   // Stats_Clear



#if DBG
VOID
Dbg_Statistics(
    VOID
    )
{
    DWORD           i;
    PDNSSRV_STAT    pstat;

    //
    //  print all available stats
    //

    DnsDebugLock();
    DnsPrintf( "DNS Server Statistics:\n" );

    i = 0;
    while ( pstat = (PDNSSRV_STAT) StatsTable[i++].pStats )
    {
        DnsDbg_RpcSingleStat(
            NULL,
            pstat );
    }
    DnsDebugUnlock();
}
#endif  // DBG



//
//  Statistics RPC utilities.
//

DNS_STATUS
Rpc_GetStatistics(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      LPSTR       pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    )
/*++

Routine Description:

    Get server statistics.
    Note this is a ComplexOperation in RPC dispatch sense.

Arguments:

Return Value:

    None

--*/
{
    DWORD           filter = (DWORD)(ULONG_PTR) pDataIn;
    DWORD           i;
    DWORD           length;
    PDNSSRV_STAT    pstat;
    PCHAR           pch;
    PDNS_RPC_BUFFER pbuf;

    DNS_DEBUG( RPC, (
        "RpcGetStatistics():\n"
        "\tFilter = %p\n",
        filter ));

    //
    //  determine necessary space, and allocate
    //

    length = 0;
    i = 0;

    while ( pstat = (PDNSSRV_STAT)StatsTable[i].pStats )
    {
        if ( filter & pstat->Header.StatId )
        {
            length += TOTAL_STAT_LENGTH(pstat);
        }
        i++;
    }

    pbuf = (PDNS_RPC_BUFFER) MIDL_user_allocate( length + sizeof(DNS_RPC_BUFFER) );
    IF_NOMEM( !pbuf )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    pbuf->dwLength = length;
    pch = pbuf->Buffer;

    //
    //  derive stats and copy desired stats to buffer
    //

    deriveAndTimeSetStats();

    i = 0;
    while ( pstat = (PDNSSRV_STAT)StatsTable[i].pStats )
    {
        if ( filter & pstat->Header.StatId )
        {
            length = TOTAL_STAT_LENGTH(pstat);

            RtlCopyMemory(
                pch,
                (PCHAR) pstat,
                length );

            pch += length;
        }
        i++;
    }

    *(PDNS_RPC_BUFFER *)ppDataOut = pbuf;
    *pdwTypeOut = DNSSRV_TYPEID_BUFFER;

    IF_DEBUG( RPC )
    {
        DnsDbg_RpcStatsBuffer(
            "Leaving R_DnsGetStatistics():",
            pbuf );
    }
    return( ERROR_SUCCESS );
}



DNS_STATUS
Rpc_ClearStatistics(
    IN      DWORD       dwClientVersion,
    IN      PZONE_INFO  pZone,
    IN      DWORD       dwSize,
    IN      PVOID       pData
    )
/*++

Routine Description:

    Clear statistics info.

Arguments:

    Server -- server string handle

Return Value:

    ERROR_SUCCESS -- if successful
    Error code on failure.

--*/
{
    Stats_Clear();
    return( ERROR_SUCCESS );
}



//
//  PerfMon Support
//

//
//  PerfMon counters
//

volatile unsigned long * pcTotalQueryReceived;
volatile unsigned long * pcUdpQueryReceived;
volatile unsigned long * pcTcpQueryReceived;
volatile unsigned long * pcTotalResponseSent;
volatile unsigned long * pcUdpResponseSent;
volatile unsigned long * pcTcpResponseSent;
volatile unsigned long * pcRecursiveQueries;
volatile unsigned long * pcRecursiveTimeOut;
volatile unsigned long * pcRecursiveQueryFailure;
volatile unsigned long * pcNotifySent;
volatile unsigned long * pcZoneTransferRequestReceived;
volatile unsigned long * pcZoneTransferSuccess;
volatile unsigned long * pcZoneTransferFailure;
volatile unsigned long * pcAxfrRequestReceived;
volatile unsigned long * pcAxfrSuccessSent;
volatile unsigned long * pcIxfrRequestReceived;
volatile unsigned long * pcIxfrSuccessSent;
volatile unsigned long * pcNotifyReceived;
volatile unsigned long * pcZoneTransferSoaRequestSent;
volatile unsigned long * pcAxfrRequestSent;
volatile unsigned long * pcAxfrResponseReceived;
volatile unsigned long * pcAxfrSuccessReceived;
volatile unsigned long * pcIxfrRequestSent;
volatile unsigned long * pcIxfrResponseReceived;
volatile unsigned long * pcIxfrSuccessReceived;
volatile unsigned long * pcIxfrUdpSuccessReceived;
volatile unsigned long * pcIxfrTcpSuccessReceived;
volatile unsigned long * pcWinsLookupReceived;
volatile unsigned long * pcWinsResponseSent;
volatile unsigned long * pcWinsReverseLookupReceived;
volatile unsigned long * pcWinsReverseResponseSent;
volatile unsigned long * pcDynamicUpdateReceived;
volatile unsigned long * pcDynamicUpdateNoOp;
volatile unsigned long * pcDynamicUpdateWriteToDB;
volatile unsigned long * pcDynamicUpdateRejected;
volatile unsigned long * pcDynamicUpdateTimeOut;
volatile unsigned long * pcDynamicUpdateQueued;
volatile unsigned long * pcSecureUpdateReceived;
volatile unsigned long * pcSecureUpdateFailure;
volatile unsigned long * pcDatabaseNodeMemory;
volatile unsigned long * pcRecordFlowMemory;
volatile unsigned long * pcCachingMemory;
volatile unsigned long * pcUdpMessageMemory;
volatile unsigned long * pcTcpMessageMemory;
volatile unsigned long * pcNbstatMemory;

//
//  Dummy counter to point counter pointers at if unable to open counter block
//

unsigned long DummyCounter;


//
//  Configuration utils
//

DWORD
perfmonGetParam(
    IN      LPTSTR          pszParameter,
    OUT     PVOID           pValue,
    IN      DWORD           dwSize
    )
{
    DWORD   status;
    DWORD   regType;
    HKEY    hkey;

    DNS_DEBUG( INIT, (
        "perfmonGetParam() ** attempt to read [%s] \"%S\" param\n",
        DNS_CONFIG_SECTION,
        pszParameter ));

    status = RegOpenKey(
                HKEY_LOCAL_MACHINE,
                TEXT(DNS_CONFIG_SECTION),
                &hkey
                );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( INIT, (
            "Error <%lu>: Cannot open key %S\n",
            status,
            TEXT(DNS_CONFIG_SECTION) ));
        return status;
    }

    status = RegQueryValueEx(
                 hkey,
                 pszParameter,
                 NULL,
                 &regType,
                 (LPBYTE) pValue,
                 &dwSize
                 );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( INIT, (
            " ** [%s] \"%S\" param not found. Status = %lu\n",
            DNS_CONFIG_SECTION,
            pszParameter,
            status ));
    }
    else if ( regType == REG_SZ )
    {
        DNS_DEBUG( INIT, (
            " ** [%s] \"%S\" param = \"%S\"\n",
            DNS_CONFIG_SECTION,
            pszParameter,
            (LPTSTR) pValue ));
    }
    else
    {
        DNS_DEBUG( INIT, (
            " ** [%s] \"%S\" param = \"0x%x\"\n",
            DNS_CONFIG_SECTION,
            pszParameter,
            *(PDWORD) pValue ));
    }

    RegCloseKey( hkey );

    return status;
}


DWORD
perfmonSetParam(
    IN      LPTSTR          pszParameter,
    IN      DWORD           regType,
    OUT     PVOID           pValue,
    IN      DWORD           dwSize
    )
{
    DWORD   status;
    HKEY    hkey;

    DNS_DEBUG( INIT, (
        "perfmonSetParam() ** attempt to write [%s] \"%s\" param\n",
        DNS_CONFIG_SECTION,
        pszParameter ));

    status = RegOpenKey(
                HKEY_LOCAL_MACHINE,
                TEXT(DNS_CONFIG_SECTION),
                &hkey
                );

    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    status = RegSetValueEx(
                hkey,
                pszParameter,
                0,
                regType,
                (LPBYTE) pValue,
                dwSize );

    RegCloseKey( hkey );

    return status;
}


DWORD
reloadPerformanceCounters(
    VOID
    )
/*++

Routine Description:

    This routine sets up the performance counters for the ds

    See instructions for adding new counters in perfdsa\datadsa.h

Parameters:

    None.

Return Values:

    0 if succesful; winerror otherwise

--*/
{
    DWORD   status;
    DWORD   IgnoreError;
    WCHAR   IniFilePath[2*MAX_PATH];
    WCHAR   SystemDirectory[MAX_PATH+1];
    DWORD   PerfCounterVersion = 0;


    //
    //  DEVNOTE: should check if perf counters there
    //      if NOT then reload
    //

    if ( ! GetSystemDirectoryW(
                SystemDirectory,
                sizeof(SystemDirectory)/sizeof(SystemDirectory[0])))
    {
        return GetLastError();
    }

    wcscpy( IniFilePath, L"lodctr " );
    wcscat( IniFilePath, SystemDirectory );
    wcscat( IniFilePath, L"\\dnsperf.ini" );

    // Get version in registry.  If non-existent, use zero

    status = perfmonGetParam(
                    TEXT(PERF_COUNTER_VERSION),
                    &PerfCounterVersion,
                    sizeof(DWORD)
                    );

    // version param not found, set it:

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( INIT, (
            "Get Version param failed! Set param here.\n"
            "PerfCounterVersion = %d\n",
            PerfCounterVersion ));

        PerfCounterVersion = DNS_PERFORMANCE_COUNTER_VERSION;

        status = perfmonSetParam(
                        TEXT(PERF_COUNTER_VERSION),
                        REG_DWORD,
                        &PerfCounterVersion,
                        sizeof(DWORD)
                        );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( INIT, (
                "Set 'Performance Counter Version' failed: %d\n",
                status ));
        }
    }
    else
    {
        // If version is not up to date, unload counters and update version
        if ( PerfCounterVersion != DNS_PERFORMANCE_COUNTER_VERSION )
        {
            __try
            {
                //status = UnloadPerfCounterTextStringsW( L"unlodctr DNS", TRUE );
                status = (DWORD)UnloadPerfCounterTextStringsW( TEXT("unlodctr DNS"), TRUE );
            }
            __except( EXCEPTION_EXECUTE_HANDLER )
            {
                status = RtlNtStatusToDosError( GetExceptionCode() );
            }

            if (status == ERROR_SUCCESS)
            {
                DNS_DEBUG( ANY, (
                    "System has old DNS performance counter version %d: "
                    "reloading performance counters.\n",
                    PerfCounterVersion ));

                PerfCounterVersion = DNS_PERFORMANCE_COUNTER_VERSION;
                status = perfmonSetParam(
                                TEXT(PERF_COUNTER_VERSION),
                                REG_DWORD,
                                &PerfCounterVersion,
                                sizeof(DWORD)
                                );
                if ( status != ERROR_SUCCESS )
                {
                    DNS_DEBUG( ANY, (
                        "Set 'Performance Counter Version' failed: %d, (%p)\n",
                        status, status ));
                }

            }
            else
            {
                DNS_DEBUG( ANY, (
                    "Can't update perf counters: Unload failed %d (%p)\n",
                    status, status ));
            }
        }
    }

    __try
    {
        status = (DWORD)LoadPerfCounterTextStringsW( IniFilePath, TRUE );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        status = RtlNtStatusToDosError( GetExceptionCode() );
    }

    return status;
}


/** PerfInit
 *
 *  Initialize PerfMon extension support.  This consists of allocating a
 *  block of shared memory and initializing a bunch of global pointers to
 *  point into the block.
 *
 */

VOID
perfmonCounterBlockInit(
    VOID
    )
/*++

Routine Description:

    Initialize perfmon counter block.

    Allocate a block of shared memory to hold counters, then init
    our internal pointer counters to point to correct locations in this block.

    See instructions for adding new counters in perfdns\datadns.h

Parameters:

    None.

Return Values:

    None.

--*/
{
    HANDLE          hMappedObject;
    unsigned long * pCounterBlock;
    int     err = 0;

    DNS_STATUS              status;
    SECURITY_ATTRIBUTES     secAttr;
    PSECURITY_ATTRIBUTES    psecAttr = NULL;
    PSECURITY_DESCRIPTOR    psd = NULL;
    DWORD                   maskArray[ 3 ] = { 0 };
    PSID                    sidArray[ 3 ] = { 0 };

    //
    //  create security on perfmon mapped file
    //
    //  security will be AuthenticatedUsers get to read
    //

    maskArray[ 0 ] = GENERIC_READ;
    sidArray[ 0 ] = g_pAuthenticatedUserSid;
    maskArray[ 1 ] = GENERIC_ALL;
    sidArray[ 1 ] = g_pLocalSystemSid;

    status = Dns_CreateSecurityDescriptor(
                & psd,
                2,              //  number of ACEs
                sidArray,
                maskArray );

    if ( status == ERROR_SUCCESS )
    {
        secAttr.lpSecurityDescriptor = psd;
        secAttr.bInheritHandle = FALSE;
        secAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
        psecAttr = &secAttr;
    }
    ELSE
    {
        DNS_DEBUG( ANY, (
            "ERROR:  <%d> failed SD create for perfmon memory!\n",
            status ));
    }

    pCounterBlock = NULL;
    /*
     *  create named section for the performance data
     */
    hMappedObject = CreateFileMapping(
                        INVALID_HANDLE_VALUE,
                        psecAttr,
                        PAGE_READWRITE,
                        0,
                        4096,
                        DNS_PERF_COUNTER_BLOCK
                        );
    if (hMappedObject == NULL)
    {
        /* Hmm.  Maybe PerfMon has already created the block? */
        hMappedObject = OpenFileMapping(
                            FILE_MAP_WRITE,
                            FALSE,
                            DNS_PERF_COUNTER_BLOCK);
        #if DBG
        if ( hMappedObject == NULL )
        {
            DNS_DEBUG( ANY, (
                "ERROR: perfmon object already created but error %d while opening\n",
                GetLastError() ));
        }
        #endif
    }

    if (hMappedObject)
    {
        /* Mapped object created okay
         *
         * map the section and assign the counter block pointer
         * to this section of memory
         */
        pCounterBlock = (unsigned long *) MapViewOfFile(hMappedObject,
                                                        FILE_MAP_ALL_ACCESS,
                                                        0,
                                                        0,
                                                        0);
        if (pCounterBlock == NULL) {
            //LogUnhandledError(GetLastError());
            /* Failed to Map View of file */
        }
    }

    // TODO: this code assumes that all counters are sizeof LONG.  The pointer
    // should be built from a base using the NUM_xxx offsets in datadns.h

    //
    //  DEVNOTE: just overlay a structure and set offsets
    //
    //  DEVNOTE: could also let all PERF_INC, DEC operate through struct element
    //      ex. pPerfBlob->UdpRecv though this is slightly more expensive;
    //

    if (pCounterBlock)
    {
        pcTotalQueryReceived    = pCounterBlock + 1 +
                (TOTALQUERYRECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcUdpQueryReceived    = pCounterBlock + 1 +
                (UDPQUERYRECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcTcpQueryReceived    = pCounterBlock + 1 +
                (TCPQUERYRECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcTotalResponseSent    = pCounterBlock + 1 +
                (TOTALRESPONSESENT_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcUdpResponseSent    = pCounterBlock + 1 +
                (UDPRESPONSESENT_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcTcpResponseSent    = pCounterBlock + 1 +
                (TCPRESPONSESENT_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcRecursiveQueries    = pCounterBlock + 1 +
                (RECURSIVEQUERIES_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcRecursiveTimeOut    = pCounterBlock + 1 +
                (RECURSIVETIMEOUT_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcRecursiveQueryFailure = pCounterBlock + 1 +
                (RECURSIVEQUERYFAILURE_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcNotifySent    = pCounterBlock + 1 +
                (NOTIFYSENT_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcZoneTransferRequestReceived    = pCounterBlock + 1 +
                (ZONETRANSFERREQUESTRECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcZoneTransferSuccess    = pCounterBlock + 1 +
                (ZONETRANSFERSUCCESS_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcZoneTransferFailure    = pCounterBlock + 1 +
                (ZONETRANSFERFAILURE_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcAxfrRequestReceived    = pCounterBlock + 1 +
                (AXFRREQUESTRECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcAxfrSuccessSent    = pCounterBlock + 1 +
                (AXFRSUCCESSSENT_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcIxfrRequestReceived    = pCounterBlock + 1 +
                (IXFRREQUESTRECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcIxfrSuccessSent   = pCounterBlock + 1 +
                ( IXFRSUCCESSSENT_OFFSET- TOTALQUERYRECEIVED_OFFSET)/4;
        pcNotifyReceived   = pCounterBlock + 1 +
                (NOTIFYRECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcZoneTransferSoaRequestSent   = pCounterBlock + 1 +
                (ZONETRANSFERSOAREQUESTSENT_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcAxfrRequestSent   = pCounterBlock + 1 +
                (AXFRREQUESTSENT_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcAxfrResponseReceived   = pCounterBlock + 1 +
                (AXFRRESPONSERECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcAxfrSuccessReceived   = pCounterBlock + 1 +
                (AXFRSUCCESSRECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcIxfrRequestSent   = pCounterBlock + 1 +
                (IXFRREQUESTSENT_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcIxfrResponseReceived   = pCounterBlock + 1 +
                (IXFRRESPONSERECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcIxfrSuccessReceived   = pCounterBlock + 1 +
                (IXFRSUCCESSRECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcIxfrUdpSuccessReceived   = pCounterBlock + 1 +
                (IXFRUDPSUCCESSRECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcIxfrTcpSuccessReceived   = pCounterBlock + 1 +
                (IXFRTCPSUCCESSRECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcWinsLookupReceived   = pCounterBlock + 1 +
                (WINSLOOKUPRECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcWinsResponseSent   = pCounterBlock + 1 +
                (WINSRESPONSESENT_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcWinsReverseLookupReceived   = pCounterBlock + 1 +
                (WINSREVERSELOOKUPRECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcWinsReverseResponseSent   = pCounterBlock + 1 +
                (WINSREVERSERESPONSESENT_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcDynamicUpdateReceived   = pCounterBlock + 1 +
                (DYNAMICUPDATERECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcDynamicUpdateNoOp   = pCounterBlock + 1 +
                (DYNAMICUPDATENOOP_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcDynamicUpdateWriteToDB   = pCounterBlock + 1 +
                (DYNAMICUPDATEWRITETODB_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcDynamicUpdateRejected   = pCounterBlock + 1 +
                (DYNAMICUPDATEREJECTED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcDynamicUpdateTimeOut   = pCounterBlock + 1 +
                (DYNAMICUPDATETIMEOUT_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcDynamicUpdateQueued   = pCounterBlock + 1 +
                (DYNAMICUPDATEQUEUED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcSecureUpdateReceived   = pCounterBlock + 1 +
                (SECUREUPDATERECEIVED_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcSecureUpdateFailure   = pCounterBlock + 1 +
                (SECUREUPDATEFAILURE_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcDatabaseNodeMemory   = pCounterBlock + 1 +
                (DATABASENODEMEMORY_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcRecordFlowMemory   = pCounterBlock + 1 +
                (RECORDFLOWMEMORY_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcCachingMemory   = pCounterBlock + 1 +
                (CACHINGMEMORY_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcUdpMessageMemory   = pCounterBlock + 1 +
                (UDPMESSAGEMEMORY_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcTcpMessageMemory   = pCounterBlock + 1 +
                (TCPMESSAGEMEMORY_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;
        pcNbstatMemory   = pCounterBlock + 1 +
                (NBSTATMEMORY_OFFSET - TOTALQUERYRECEIVED_OFFSET)/4;


        // SANITY CHECK (RsRaghav) - we seem to have allocated this magic(?) 4096
        // and keep adding counters. Please update the assert below with the highest
        // counter added to the perf block.

        //ASSERT(((TCPCLICONN/2) * sizeof(unsigned long)) <= 4096);
        ASSERT(((pcNbstatMemory-pCounterBlock+1) * sizeof(unsigned long)) <= 4096);

        memset(pCounterBlock, 0, 4096);
    }

    //  failed to allocate shared memory for counters
    //  init all pointers to point at DummyCounter -- just dumping data

    else
    {
        pcTotalQueryReceived =  pcUdpQueryReceived =  pcTcpQueryReceived =
            pcTotalResponseSent =  pcUdpResponseSent =  pcTcpResponseSent =
            pcRecursiveQueries =  pcRecursiveTimeOut =  pcRecursiveQueryFailure =
            pcNotifySent =  pcZoneTransferRequestReceived =  pcZoneTransferSuccess =
            pcZoneTransferFailure =  pcAxfrRequestReceived =  pcAxfrSuccessSent =
            pcIxfrRequestReceived =  pcIxfrSuccessSent =  pcNotifyReceived =
            pcZoneTransferSoaRequestSent =  pcAxfrRequestSent =
            pcAxfrResponseReceived =  pcAxfrSuccessReceived =  pcIxfrRequestSent =
            pcIxfrResponseReceived =  pcIxfrSuccessReceived =
            pcIxfrUdpSuccessReceived =  pcIxfrTcpSuccessReceived =
            pcWinsLookupReceived =  pcWinsResponseSent =
            pcWinsReverseLookupReceived =  pcWinsReverseResponseSent =
            pcDynamicUpdateReceived =  pcDynamicUpdateNoOp =
            pcDynamicUpdateWriteToDB =  pcDynamicUpdateRejected =
            pcDynamicUpdateTimeOut =  pcDynamicUpdateQueued =
            pcSecureUpdateReceived =  pcSecureUpdateFailure =
            pcDatabaseNodeMemory =  pcRecordFlowMemory =  pcCachingMemory =
            pcUdpMessageMemory =  pcTcpMessageMemory =  pcNbstatMemory =
         &DummyCounter;
    }

    // Reload the perfmon counter. Done here to ensure DNS counter gets
    // reloaded after an upgrade. If the counter is
    // already loaded, this is a no-op

    //err = reloadPerformanceCounters();

    if ( err == ERROR_SUCCESS )
    {
        DNS_DEBUG( INIT, ("DNS Perfmon Counters loaded\n" ));
    }
    else if ( err == ERROR_ALREADY_EXISTS )
    {
        DNS_DEBUG( INIT, ("DNS Perfmon Counter is already loaded\n" ));
    }
    else
    {
        DNS_DEBUG( INIT, (
            "ERROR:  Problem loading DNS perfmon counter %d (%p)!\n",
            err, err ));
    }

    //
    //  free security descriptor
    //

    FREE_HEAP( psd );
}


VOID
Stats_updateErrorStats(
    IN  DWORD   dwErr
    )
/*++

Routine Description:

    Increment corresponding stats on given error code
Arguments:

    dwErr: Error code.


Return Value:


--*/
{

    switch ( dwErr )
    {
        case DNS_RCODE_NOERROR:
            STAT_INC( ErrorStats.NoError );
            break;
        case DNS_RCODE_FORMERR:
            STAT_INC( ErrorStats.FormError );
            break;
        case DNS_RCODE_SERVFAIL:
            STAT_INC( ErrorStats.ServFail );
            break;
        case DNS_RCODE_NXDOMAIN:
            STAT_INC( ErrorStats.NxDomain );
            break;
        case DNS_RCODE_NOTIMPL:
            STAT_INC( ErrorStats.NotImpl );
            break;
        case DNS_RCODE_REFUSED:
            STAT_INC( ErrorStats.Refused );
            break;
        case DNS_RCODE_YXDOMAIN:
            STAT_INC( ErrorStats.YxDomain );
            break;
        case DNS_RCODE_YXRRSET:
            STAT_INC( ErrorStats.YxRRSet );
            break;
        case DNS_RCODE_NXRRSET:
            STAT_INC( ErrorStats.NxRRSet );
            break;
        case DNS_RCODE_NOTAUTH:
            STAT_INC( ErrorStats.NotAuth );
            break;
        case DNS_RCODE_NOTZONE:
            STAT_INC( ErrorStats.NotZone );
            break;
        case DNS_RCODE_MAX:
            STAT_INC( ErrorStats.Max );
            break;
        case DNS_RCODE_BADSIG:
            STAT_INC( ErrorStats.BadSig );
            break;
        case DNS_RCODE_BADKEY:
            STAT_INC( ErrorStats.BadKey );
            break;
        case DNS_RCODE_BADTIME:
            STAT_INC( ErrorStats.BadTime );
            break;
        default:
            STAT_INC( ErrorStats.UnknownError );
    }
}


VOID
Stat_IncrementQuery2Stats(
    IN      WORD            wType
    )
/*++

Routine Description:

    This routine implements the appropriate breakout counter in
    the Query2Stats structure given wType.

Arguments:

    wType: type of query

Return Value:


--*/
{
    switch ( wType )
    {
        case DNS_TYPE_A:
            STAT_INC( Query2Stats.TypeA );              break;
        case DNS_TYPE_NS:
            STAT_INC( Query2Stats.TypeNs );             break;
        case DNS_TYPE_SOA:
            STAT_INC( Query2Stats.TypeSoa );            break;
        case DNS_TYPE_MX:
            STAT_INC( Query2Stats.TypeMx );             break;
        case DNS_TYPE_PTR:
            STAT_INC( Query2Stats.TypePtr );            break;
        case DNS_TYPE_ALL:
            STAT_INC( Query2Stats.TypeAll );            break;
        case DNS_TYPE_AXFR:
            STAT_INC( Query2Stats.TypeAxfr );           break;
        case DNS_TYPE_IXFR:
            STAT_INC( Query2Stats.TypeIxfr );           break;
        default:
            STAT_INC( Query2Stats.TypeOther );          break;
    }
}   //  Stat_IncrementQuery2Stats

//
//  End stats.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\stats.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    stats.h

Abstract:

    Domain Name System (DNS) Server

    DNS statistics header.

Author:

    Jim Gilroy (jamesg)  August 1995

Revision History:

--*/


#ifndef _DNS_STATS_INCLUDED_
#define _DNS_STATS_INCLUDED_



#if 1
#define STAT_INC( stat )            InterlockedIncrement( &( stat ) )
#define STAT_DEC( stat )            InterlockedDecrement( &( stat ) )
#define STAT_ADD( stat, delta )     InterlockedExchangeAdd( &( stat ), ( delta ) )
#define STAT_SUB( stat, delta )     InterlockedExchangeAdd( &( stat ), -( LONG )( delta ) )
#else
#define STAT_INC( stat )            ( (stat)++ )
#define STAT_DEC( stat )            ( (stat)-- )
#define STAT_ADD( stat, count )     ( (stat) += count )
#define STAT_SUB( stat, count )     ( (stat) -= count )
#endif

//
//  Server statistics globals
//

extern  DNSSRV_TIME_STATS           TimeStats;
extern  DNSSRV_QUERY_STATS          QueryStats;
extern  DNSSRV_RECURSE_STATS        RecurseStats;
extern  DNSSRV_WINS_STATS           WinsStats;
extern  DNSSRV_UPDATE_STATS         WireUpdateStats;
extern  DNSSRV_UPDATE_STATS         NonWireUpdateStats;
extern  DNSSRV_DS_STATS             DsStats;
extern  DNSSRV_DBASE_STATS          DbaseStats;
extern  DNSSRV_RECORD_STATS         RecordStats;
extern  DNSSRV_PACKET_STATS         PacketStats;
extern  DNSSRV_NBSTAT_STATS         NbstatStats;
extern  DNSSRV_TIMEOUT_STATS        TimeoutStats;
extern  DNSSRV_QUERY2_STATS         Query2Stats;
extern  DNSSRV_MASTER_STATS         MasterStats;
extern  DNSSRV_SECONDARY_STATS      SecondaryStats;
extern  DNSSRV_MEMORY_STATS         MemoryStats;
extern  DNSSRV_PRIVATE_STATS        PrivateStats;
extern  DNSSRV_ERROR_STATS          ErrorStats;
extern  DNSSRV_CACHE_STATS          CacheStats;

#if 0
extern  DNSSRV_DEBUG_STATS          DebugStats;
#endif

//
//  Statistics routines
//

VOID
Stats_Initialize(
    VOID
    );

VOID
Stats_Clear(
    VOID
    );

VOID
Stats_CopyUpdate(
    OUT     PDNSSRV_STATS   pStats
    );

VOID
Stats_updateErrorStats(
    IN      DWORD           dwErr
    );

VOID
Stat_IncrementQuery2Stats(
    IN      WORD            wType
    );

//
//  Perfmon initialization
//

VOID
Stats_InitializePerfmon(
    VOID
    );


//
//  Stat table entry structure
//

struct StatsTableEntry
{
    DWORD       Id;
    BOOLEAN     fClear;
    WORD        wLength;
    PVOID       pStats;
};


#endif  // _DNS_STATS_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\tcpcon.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

Module Name:

    tcpcon.h

Abstract:

    Domain Name System (DNS) Server

    TCP Connection list definitions.

    DNS server must allow clients to send multiple messages on a connection.
    These are definitions which allow server to maintain list of client
    connections which it holds open for a limited timeout.

Author:

    Jim Gilroy (jamesg)     June 20, 1995

Revision History:

--*/


#ifndef _TCPCON_INCLUDED_
#define _TCPCON_INCLUDED_

//
//  TCP client connection
//

typedef struct
{
    LIST_ENTRY  ListEntry;

    SOCKET      Socket;         //  connection socket
    DWORD       dwTimeout;      //  timeout until connection closed

    PDNS_MSGINFO    pMsg;       //  partially received message on connection
}
TCP_CONNECTION, *PTCP_CONNECTION;

//
//  Select wakeup socket
//      -- needed by tcpsrv, to avoid attempting recv() from socket
//

extern SOCKET  socketTcpSelectWakeup;

extern BOOL    gbTcpSelectWoken;


//
//  TCP connection list (tcpcon.c)
//

VOID
dns_TcpConnectionListFdSet(
    IN OUT  fd_set *    pFdSet,
    IN      DWORD       dwLastSelectTime
    );

BOOL
dns_TcpConnectionCreate(
    IN      SOCKET              Socket,
    IN      BOOL                fTimeout,
    IN OUT  PDNS_MSGINFO    pMsg        OPTIONAL
    );

VOID
dns_TcpConnectionListReread(
    VOID
    );

BOOL
dns_TcpConnectionCreateForRecursion(
    IN      SOCKET  Socket
    );

VOID
dns_TcpConnectionDeleteForSocket(
    IN      SOCKET  Socket
    );

PDNS_MSGINFO
dns_TcpConnectionMessageFindOrCreate(
    IN      SOCKET  Socket
    );

VOID
dns_TcpConnectionUpdateTimeout(
    IN      SOCKET  Socket
    );

VOID
dns_TcpConnectionUpdateForCompleteMessage(
    IN      PDNS_MSGINFO    pMsg
    );

VOID
dns_TcpConnectionUpdateForPartialMessage(
    IN      PDNS_MSGINFO    pMsg
    );

VOID
dns_TcpConnectionListInitialize(
    VOID
    );

VOID
dns_TcpConnectionListDelete(
    VOID
    );

#endif // _TCPCON_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\tcpsrv.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    tcpsrv.c

Abstract:

    Domain Name System (DNS) Server

    Handles TCP server side connections.

Author:

    Jim Gilroy      June 1995

Revision History:

    jamesg  Nov 1995    -   insertion of client side connections
    jamesg  Jan 1997    -   select() failure protection
                            bad TCP packet protection / cleanup

--*/

#include "dnssrv.h"


//
//  FD_SETs
//      - read for listen and recv
//      - write for connection completion
//      - except for connection failure
//

FD_SET fdsReadTcp;
FD_SET fdsWriteTcp;
FD_SET fdsExceptTcp;

//  Connect timeout

#define TCP_CONNECT_TIMEOUT     (5)     // five seconds

//  Max retries on select() failure before logging error and whacking sockets

#define SELECT_RETRY_LIMIT      (20)


//
//  Initial length for recv()s
//  Specify length that includes header gives us cut at info
//  we can use to throw aways packets and close connections before
//  wasting too many cycles
//

#define INITIAL_RECV_LENGTH (sizeof(WORD) + sizeof(DNS_HEADER))



//
//  Private protos
//

VOID
Tcp_AcceptRequest(
    IN       SOCKET     sListenSocket
    );



BOOL
Tcp_Receiver(
    VOID
    )
/*++

Routine Description:

    Receiving thread routine.  Loops waiting on sockets, recieving DNS
    requests and queuing requests to worker threads.

Arguments:

    TcpListener - TCP listening socket

Return Value:

    TRUE on normal service shutdown
    FALSE on socket error

--*/
{
    SOCKET          socket;
    BOOL            fconnecting;
    INT             err;
    INT             count;
    INT             selectFailCount = 0;
    INT             i;
    DWORD           lastSelectTime = DNS_TIME();
    PDNS_MSGINFO    pmsg;
    struct timeval  timeout;

    DNS_DEBUG( INIT, ( "Entering TCP receiver loop.\n" ));

    //  set connect timeout

    //timeout.tv_sec = TCP_CONNECT_TIMEOUT;
    timeout.tv_sec = SrvCfg_dwXfrConnectTimeout;

    //
    //  Loop receiving
    //      - incoming TCP connection attempts
    //      - TCP messages to connected sockets
    //

    //
    //  DEVNOTE:  replace select() with winsock2 recvfrom
    //              - handle termination with event or
    //                close socket handles to terminate recvfrom
    //

    while ( TRUE )
    {
        //
        //  Check for service pause or shutdown.
        //

        if ( !Thread_ServiceCheck() )
        {
            DNS_DEBUG( TCP, ( "Terminating TCP receiver thread.\n" ));
            return( 1 );
        }

        //
        //  setup select FD_SET
        //      - copy of listening socket list
        //      - then add current connection sockets
        //      - and current connection attempt sockets
        //

        RtlCopyMemory(
            & fdsReadTcp,
            & g_fdsListenTcp,
            sizeof( FD_SET ) );

        fconnecting = Tcp_ConnectionListFdSet(
                        & fdsReadTcp,
                        & fdsWriteTcp,
                        & fdsExceptTcp,
                        lastSelectTime );

        //
        //  Wait for DNS request or shutdown.
        //

        if ( fconnecting )
        {
            IF_DEBUG( TCP )
            {
                DnsPrint_Lock();
                DNS_PRINT((
                    "Entering select with connect timeout %d\n",
                    timeout.tv_sec ));
                DnsDbg_FdSet(
                    "TCP select() read fd_set:",
                    & fdsReadTcp );
                DnsDbg_FdSet(
                    "TCP select() write fd_set:",
                    & fdsWriteTcp );
                DnsDbg_FdSet(
                    "TCP select() except fd_set:",
                    & fdsExceptTcp );
                DnsPrint_Unlock();
            }
            count = select( 0, &fdsReadTcp, &fdsWriteTcp, &fdsExceptTcp, &timeout );

            //
            //  if timeout, then rebuild list
            //

            if ( count == 0 )
            {
                lastSelectTime = DNS_TIME();
                DNS_DEBUG( TCP, (
                    "TCP select timeout -- timing out failed connection attempts!\n" ));
                continue;
            }

            ASSERT( count == SOCKET_ERROR ||
                    count == (INT)fdsReadTcp.fd_count +
                                (INT)fdsWriteTcp.fd_count +
                                (INT)fdsExceptTcp.fd_count );

        }
        else
        {
            IF_DEBUG( TCP )
            {
                DnsDbg_FdSet(
                    "TCP select() fd_set:",
                    & fdsReadTcp );
            }
            count = select( 0, &fdsReadTcp, NULL, NULL, NULL );

            ASSERT( count == SOCKET_ERROR ||
                    count == (INT)fdsReadTcp.fd_count );
        }

        lastSelectTime = DNS_TIME();
        DNS_DEBUG( TCP, (
            "TCP select fired at (%d), count = %d.\n",
            lastSelectTime,
            count ));

        //
        //  Check and possibly wait on service status
        //
        //  Check before socket error check, as service termination
        //  will cause WINS socket closure.
        //

        if ( fDnsThreadAlert )
        {
            if ( ! Thread_ServiceCheck() )
            {
                DNS_DEBUG( TCP, ( "Terminating TCP receiver thread.\n" ));
                return( 1 );
            }
        }

        //
        //  If select() wakeup to add new socket -- do it.
        //

        if ( g_bTcpSelectWoken )
        {
            DNS_DEBUG( TCP, (
                "TCP select()==%lx woken by wakeup socket = %lx.\n",
                count,
                g_TcpSelectWakeupSocket ));
            continue;
        }

        if ( count == SOCKET_ERROR )
        {
            err = WSAGetLastError();
            DNS_DEBUG( ANY, (
                "ERROR:  TCP receiver select() failed\n"
                "\tGetLastError = 0x%08lx.\n"
                "\tfailure retry count = %d\n",
                err,
                selectFailCount ));

            selectFailCount++;

            //
            //  possible failure from connection socket being closed
            //      after copied to fd_set
            //  just continue and give fd_set rebuild a chance to clear
            //      the condition

            if ( selectFailCount < SELECT_RETRY_LIMIT )
            {
                continue;
            }

            //
            //  we are in a select() spin
            //      - log the first time through only
            //
            //  then delete last connection
            //      - find last socket, ignoring wakeup socket on the end
            //      - make sure socket NOT listen socket
            //      - delete connection for socket
            //      - retry select()
            //
            //  DEVNOTE: check list and eliminate bad sockets
            //

            if ( selectFailCount == SELECT_RETRY_LIMIT )
            {
                DNS_LOG_EVENT(
                    DNS_EVENT_SELECT_CALL_FAILED,
                    0,
                    NULL,
                    NULL,
                    err );
            }

            socket = fdsReadTcp.fd_array[ fdsReadTcp.fd_count-2 ];
            if ( !FD_ISSET( socket, &g_fdsListenTcp ) )
            {
                Tcp_ConnectionDeleteForSocket( socket, NULL );
            }

            DNS_DEBUG( ANY, (
                "Retry TCP select after %d failures at time=%d.\n"
                "\teliminating socket %d for retry!\n",
                selectFailCount,
                DNS_TIME(),
                socket ));
            continue;
        }

        //  successful select, reset select retry count

        selectFailCount = 0;

        //
        //  Connections completed or rejected
        //      - socket in Write fd_set, indicates successful connection,
        //          send recursive query
        //      - socket in Except fd_set, indicates failure,
        //          continue processing this query
        //

        if ( fconnecting )
        {
            for( i=0; i<(INT)fdsWriteTcp.fd_count; i++ )
            {
                socket = fdsWriteTcp.fd_array[i];
                count--;
                Tcp_ConnectionCompletion( socket );
            }

            for( i=0; i<(INT)fdsExceptTcp.fd_count; i++ )
            {
                socket = fdsExceptTcp.fd_array[i];
                count--;
                Tcp_CleanupFailedConnectAttempt( socket );
            }
        }

        //
        //  Recv DNS messages on TCP listening sockets
        //      - remaining indications must be in Read fd_set
        //

        ASSERT( count == (INT)fdsReadTcp.fd_count );

        //  don't trust winsock guys

        count = (INT)fdsReadTcp.fd_count;

        while( count-- )
        {
            socket = fdsReadTcp.fd_array[count];

            //  protect against wakeup flag not being set
            //  if wakeup socket signalled, set flag so wakeup processing is done

            if ( socket == g_TcpSelectWakeupSocket )
            {
                DNS_PRINT((
                    "Wakeup socket %d in selected fd_set but flag not set!\n"
                    "\tThis can happen if two wakeups done while TCP thread\n"
                    "\tis reading out the wakeup socket.\n"
                    "\tWe'll just re-read before next select.\n",
                    socket ));
                g_bTcpSelectWoken = TRUE;
                continue;
            }

            //
            //  new connection request ?
            //      - check socket against listening sockets
            //

            if ( FD_ISSET( socket, &g_fdsListenTcp ) )
            {
                Tcp_AcceptRequest( socket );
                continue;
            }

            //
            //  receive message on EXISTING connection
            //
            //  more of existing message
            //      OR
            //  allocate new message buffer for connection
            //

            pmsg = Tcp_ConnectionMessageFindOrCreate( socket );
            if ( !pmsg )
            {
                DNS_DEBUG( TCP, (
                    "WARNING:  no connection found for non-listening socket %d.\n"
                    "\tthis is possible when socket is terminated through PnP.\n",
                    socket ));
                continue;
            }

            //
            //  receive message -- ignore socket
            //      - message error
            //      - FIN
            //      - message not complete

            pmsg = Tcp_ReceiveMessage( pmsg );

            if ( !pmsg || !pmsg->fMessageComplete )
            {
                continue;
            }

            //
            //  count query reception
            //

            if ( pmsg->Head.IsResponse )
            {
                STAT_INC( QueryStats.TcpResponsesReceived );
            }
            else
            {
                STAT_INC( QueryStats.TcpQueries );
            }

            //
            //  queue query to worker thread
            //

            Answer_ProcessMessage( pmsg );

        }   //  end loop through fdsReadTcp set sockets

    }   //  main receive loop

} // Tcp_Receiver



VOID
Tcp_AcceptRequest(
    IN      SOCKET  sListenSocket
    )
/*++

Routine Description:

    Accept and queue request on TCP socket.

    May fail on socket error or request info memory allocation error.

Arguments:

    sListenSocket - TCP listening socket

Return Value:

    None.

--*/
{
    PDNS_MSGINFO    pmsg;
    SOCKET          socket;
    SOCKADDR_IN     sockaddr;
    INT             sockaddrLength;

    //
    //  accept the client connection
    //

    sockaddrLength = sizeof( SOCKADDR_IN );

    socket = accept(
                sListenSocket,
                ( PSOCKADDR )&sockaddr,
                &sockaddrLength
                );
    if ( socket == INVALID_SOCKET )
    {
        DWORD err = GetLastError();

        if ( fDnsServiceExit )
        {
            DNS_DEBUG( SHUTDOWN, (
                "TCP thread encounter service shutdown on accept().\n" ));
            return;
        }
        if ( err == WSAEWOULDBLOCK )
        {
            DNS_DEBUG( RECV, (
                "WARNING:  accept() failed WSAEWOULDBLOCK on socket %d.\n",
                sListenSocket ));
            return;
        }
        DNS_LOG_EVENT(
            DNS_EVENT_ACCEPT_CALL_FAILED,
            0,
            NULL,
            NULL,
            err );
        DNS_DEBUG( ANY, (
            "ERROR:  accept() failed on socket %d.\n"
            "\tGetLastError = 0x%08lx.\n",
            sListenSocket,
            err ));
        return;
    }

    DNS_DEBUG( TCP, (
        "\nAccepting new connection on socket = %d\n"
        "\tfrom client at %s.\n",
        socket,
        inet_ntoa( sockaddr.sin_addr )
        ));

    //
    //  count TCP connections and query reception
    //

    STAT_INC( QueryStats.TcpClientConnections );

    //  currently counting queries in RecieveTcpMessage()
    //  STAT_INC( QueryStats.TcpQueriesReceived );

    //
    //  allocate message info buffer
    //

    pmsg = Packet_AllocateTcpMessage( 0 );
    IF_NOMEM( !pmsg )
    {
        //
        //  DEVNOTE: need TCP allocation failure recv(), response routine
        //

        DNS_PRINT(( "ERROR:  TCP allocation failure.\n" ));
        closesocket( socket );
        return;
    }

    //
    //  save client info to message info
    //

    RtlCopyMemory(
        &pmsg->RemoteAddress,
        &sockaddr,
        sizeof( SOCKADDR_IN )
        );
    pmsg->RemoteAddressLength = sizeof( SOCKADDR_IN );
    pmsg->Socket = socket;

    //
    //  create connection info
    //

    Tcp_ConnectionCreate(
        socket,
        NULL,       // no callback, as not connecting
        pmsg );

    //
    //  receive request on new socket
    //      - on failure it will close socket
    //

    pmsg = Tcp_ReceiveMessage( pmsg );
    if ( !pmsg )
    {
        return;
    }

    //
    //  Message complete -- process message.
    //

    if ( pmsg->fMessageComplete )
    {
        if ( pmsg->Head.IsResponse )
        {
            STAT_INC( QueryStats.TcpResponsesReceived );
        }
        else
        {
            STAT_INC( QueryStats.TcpQueries );
            PERF_INC( pcTcpQueryReceived );
            PERF_INC( pcTotalQueryReceived );
        }
        Answer_ProcessMessage( pmsg );
    }
    return;
}



PDNS_MSGINFO
Tcp_ReceiveMessage(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Receive TCP DNS message.

Arguments:

    pMsg - message info buffer to receive packet;  must contain connected
            TCP socket

Return Value:

    pMsg info of result
        - may be reallocated
        - may be NULL on FIN or ERROR

--*/
{
    PCHAR   pchrecv;        // ptr to recv location
    INT     recvLength;     // length left to recv()
    SOCKET  socket;
    INT     err;
    WORD    messageLength;


    ASSERT( pMsg );
    ASSERT( pMsg->Socket );

    socket = pMsg->Socket;

    //
    //  Receive the message
    //
    //  Receive up to message length minus previous receive total.
    //

    DNS_DEBUG( TCP, (
        "Receiving message on socket %d.\n"
        "\tMessage info at %p.\n"
        "\tBytes left to receive = %d\n",
        socket,
        pMsg,
        pMsg->BytesToReceive
        ));

    //
    //  new message -- set to receive message length and message header
    //      - reusing buffer
    //      - new buffer
    //
    //  otherwise continuing receive of message
    //

    if ( !pMsg->pchRecv )
    {
        pchrecv = (PCHAR) &pMsg->MessageLength;
        recvLength = INITIAL_RECV_LENGTH;
        pMsg->MessageLength = 0;
    }
    else
    {
        pchrecv = (PCHAR) pMsg->pchRecv;
        recvLength = (INT) pMsg->BytesToReceive;
    }

    ASSERT( recvLength );
    pMsg->fMessageComplete = FALSE;

    //
    //  receive the message
    //
    //  we only receive data for this message, as another could
    //  immediately follow on VC (esp. for AXFR)
    //

    while ( 1 )
    {
        err = recv(
                socket,
                pchrecv,
                recvLength,
                0 );

        //
        //  done? -- FIN or error
        //

        if ( err <= 0 )
        {
            if ( err == 0 )
            {
                goto FinReceived;
            }
            ASSERT( err == SOCKET_ERROR );
            goto SockError;
        }
        DNS_DEBUG( TCP, (
            "\nRecv'd %d bytes on TCP socket %d\n",
            err,
            socket ));

        //
        //  update buffer params
        //

        recvLength -= err;
        pchrecv += err;

        ASSERT( recvLength >= 0 );

        //
        //  received
        //      - entire message or
        //      - message length + header
        //

        if ( recvLength == 0 )
        {
            //  done receiving message?

            if ( pchrecv > (PCHAR)&pMsg->MessageLength + INITIAL_RECV_LENGTH )
            {
                break;
            }

            //
            //  recv'd initial length (message length + header)
            //  setup to recv() rest of message
            //      - byte flip length and header
            //      - continue reception with this length
            //

            ASSERT( pchrecv == pMsg->MessageBody );

            DNSMSG_SWAP_COUNT_BYTES( pMsg );
            messageLength = pMsg->MessageLength;
            pMsg->MessageLength = messageLength = ntohs( messageLength );
            if ( messageLength < sizeof(DNS_HEADER) )
            {
                DNS_DEBUG( RECV, (
                    "ERROR:  Received TCP message with bad message"
                    " length %d.\n",
                    messageLength ));
                goto BadTcpMessage;
            }
            recvLength = messageLength - sizeof(DNS_HEADER);

            DNS_DEBUG( TCP, (
                "Received TCP message length %d, on socket %d,\n"
                "\tfor msg at %p.\n",
                messageLength,
                socket,
                pMsg ));

            //
            //  DEVNOTE:  sanity checks on TCP recv
            //      - if fail, log and kill VC
            //

            //
            //  continue recving valid message
            //  realloc, if existing message too small
            //  and not recving static buffer
            //

            if ( messageLength <= pMsg->BufferLength )
            {
                continue;
            }
            goto CloseConnection;
#if 0
            pMsg = Tcp_ReallocateMessage( pMsg, messageLength );
            if ( !pMsg )
            {
                return( NULL );
            }
#endif
        }
    }

    //
    //  Message received
    //      - recv ptr serves as flag, clear to start new message on reuse
    //      - set fields for recv (recv time)
    //      - log message (if desired)
    //      note:  header field flip was done above
    //

    pMsg->fMessageComplete = TRUE;
    pMsg->pchRecv = NULL;

    SET_MESSAGE_FIELDS_AFTER_RECV( pMsg );

    DNS_LOG_MESSAGE_RECV( pMsg );

    IF_DEBUG( RECV )
    {
        Dbg_DnsMessage(
            "Received TCP packet",
            pMsg );
    }

    //
    //  Reset connection info
    //      - clear pMsg from connection info
    //      - reset connection timeout
    //

    if ( pMsg->pConnection )
    {
        Tcp_ConnectionUpdateForCompleteMessage( pMsg );
    }

    return( pMsg );


SockError:

    //
    //  WSAEWOULD block is NORMAL return for message not fully recv'd.
    //      - save state of message reception
    //
    //  We use non-blocking sockets, so bad client (that fails to complete
    //  message) doesn't hang TCP receiver.
    //

    err = GetLastError();

    if ( err == WSAEWOULDBLOCK )
    {
        pMsg->pchRecv = pchrecv;
        pMsg->BytesToReceive = (WORD) recvLength;

        DNS_DEBUG( TCP, (
            "Leave ReceiveTcpMessage() after WSAEWOULDBLOCK.\n"
            "\tSocket=%d, Msg=%p, Connection=%p\n"
            "\tBytes left to receive = %d\n",
            socket,
            pMsg,
            pMsg->pConnection,
            pMsg->BytesToReceive
            ));

        if ( pMsg->pConnection )
        {
            Tcp_ConnectionUpdateForPartialMessage( pMsg );
        }
        return( pMsg );
    }

    //  service exit?

    if ( fDnsServiceExit )
    {
        DNS_DEBUG( SHUTDOWN, ( "TCP thread shutdown on recv() of msg.\n" ));
        return( NULL );
    }

    //
    //  cancelled connection
    //
    //  if at beginning of message (set to recv message length)
    //  then this error is not out of line
    //      - remote RESET
    //      - we shutdown(2) on AXFR thread while already indicated
    //      select() on this thread for more remote data or even FIN
    //

    if ( pchrecv == (PCHAR) &pMsg->MessageLength
            &&
          ( err == WSAESHUTDOWN ||
            err == WSAECONNABORTED ||
            err == WSAECONNRESET ) )
    {
        DNS_DEBUG( TCP, (
            "WARNING:  Recv RESET (%d) on socket %d\n",
            err,
            socket ));
        goto CloseConnection;
    }

    DNS_LOG_EVENT(
        DNS_EVENT_RECV_CALL_FAILED,
        0,
        NULL,
        NULL,
        err );

    DNS_DEBUG( ANY, (
        "ERROR:  recv() of TCP message failed.\n"
        "\t%d bytes recvd\n"
        "\t%d bytes left\n"
        "\tGetLastError = 0x%08lx.\n",
        pchrecv - (PCHAR)&pMsg->MessageLength,
        recvLength,
        err ));

    goto CloseConnection;


FinReceived:

    //
    //  valid FIN -- if recv'd between messages (before message length)
    //

    DNS_DEBUG( TCP, (
        "Recv TCP FIN (0 bytes) on socket %d\n",
        socket,
        recvLength ));

    if ( pMsg->MessageLength == 0  &&  pchrecv == (PCHAR)&pMsg->MessageLength )
    {
        ASSERT( recvLength == INITIAL_RECV_LENGTH );
        goto CloseConnection;
    }

    //
    //  FIN during message -- invalid message
    //      - don't bother to respond
    //      - note that if decide to respond, need to make sure that
    //      we know whether or not message length has yet been flipped
    //      not, worth making this check for bogus case like this
    //      so nixing response
    //

#if 0
    if ( ! pMsg->Head.IsResponse
            && pMsg->MessageLength > sizeof(DNS_HEADER) )
    {
        pMsg->fDelete = FALSE;
        Reject_UnflippedRequest(
            pMsg,
            DNS_RCODE_FORMAT_ERROR );
    }
#endif

    DNS_DEBUG( ANY, (
        "ERROR:  TCP message received has incorrect length.\n"
        "\t%d bytes left when recv'd FIN.\n",
        recvLength ));
    //goto BadTcpMessage;


BadTcpMessage:
    {
        PVOID parg = (PVOID) (ULONG_PTR) pMsg->RemoteAddress.sin_addr.s_addr;

        DNS_LOG_EVENT(
            DNS_EVENT_BAD_TCP_MESSAGE,
            1,
            & parg,
            EVENTARG_ALL_IP_ADDRESS,
            0 );
        //goto CloseConnection;
    }

CloseConnection:

    //
    //  close connection
    //
    //  if in connection list, cut from connection list
    //  otherwise just close
    //

    Tcp_ConnectionDeleteForSocket( socket, pMsg );
    return( NULL );
}



//
//  End of tcpsrv.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\tcpcon.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    tcpcon.c

Abstract:

    Domain Name System (DNS) Server

    TCP connection list routines.  Manages list of current TCP client
    connections to the DNS server.

Author:

    Jim Gilroy (jamesg) June 20, 1995

Revision History:

--*/


#include "dnssrv.h"


//
//  DEVNOTE: fd_set limits???
//

//
//  Implementation note:
//
//  TCP connection structures are NOT FULLY thread safe.
//
//  The list is protected for insertion and deletion.
//  The routines that operate on TCP connection structures -- associating
//  messages and timeouts with the connections -- are NOT protected and
//  are assumed to be called ONLY FROM TCP RECIEVE thread.
//


//
//  TCP client connection list.
//

BOOL        mg_TcpConnectionListInitialized;

LIST_ENTRY  mg_TcpConnectionList;

CRITICAL_SECTION    mg_TcpConnectionListCS;

#define LOCK_TCPCON_LIST()     EnterCriticalSection( &mg_TcpConnectionListCS )
#define UNLOCK_TCPCON_LIST()   LeaveCriticalSection( &mg_TcpConnectionListCS )


//
//  Timeout
//      - in-bound connections killed after one minute of no action
//      - out-bound given 15s for query\response
//

#define DNS_TCP_CONNECTION_TIMEOUT      (60)

#define TCP_QUERY_TIMEOUT               (15)

#define DNSCON_NO_TIMEOUT               (MAXULONG)


//
//  Wakeup socket included in TCP select()
//
//  Allows us to enter new connections (for TCP recursion)
//  into connection list.
//  Flag to indicate need for new wakeup socket.
//

SOCKET  g_TcpSelectWakeupSocket;

BOOL    g_bTcpSelectWoken;

SOCKADDR_IN     wakeupSockaddr;




//
//  Connection list utils
//

PDNS_SOCKET
Tcp_ConnectionFindForSocket(
    IN      SOCKET          Socket
    )
/*++

Routine Description:

    Find TCP connection for socket.

Arguments:

    Socket -- socket to find connection for

Return Value:

    Ptr to connection, if found.
    NULL otherwise.

--*/
{
    PDNS_SOCKET pcon;

    //
    //  loop through all active TCP connections checking for socket
    //

    LOCK_TCPCON_LIST();

    pcon = (PDNS_SOCKET) mg_TcpConnectionList.Flink;

    while ( (PLIST_ENTRY)pcon != &mg_TcpConnectionList )
    {
        if ( pcon->Socket == Socket )
        {
            UNLOCK_TCPCON_LIST();
            return pcon;
        }
        pcon = (PDNS_SOCKET) pcon->List.Flink;
    }
    UNLOCK_TCPCON_LIST();
    return NULL;
}



VOID
tcpConnectionDelete(
    IN OUT  PDNS_SOCKET     pTcpCon,
    IN OUT  PLIST_ENTRY     pCallbackList
    )
/*++

Routine Description:

    Delete TCP connection.
        - close the socket
        - remove connection from list
        - free the memory
        - free the message info (if any)

    However if connection requires callback, the connection blob is not
    freed, but returned to caller for callback completion.

Arguments:

    pTcpCon -- connection to delete

Return Value:

    NULL completely deleted.
    Ptr to connection, if requires callback cleanup.

--*/
{
    ASSERT( !pTcpCon->pCallback || pTcpCon->pMsg );

    //
    //  delete connection
    //    - remove connection from list
    //    - close the socket
    //    - free the memory
    //
    //  closing after removal so new socket with same handle can not
    //      be in list
    //

    DNS_DEBUG( TCP, (
        "Closing TCP client connection (%p) socket %d.\n",
        pTcpCon,
        pTcpCon->Socket ));

    //
    //  hold lock until connection out of list
    //      AND
    //  references to it in message are eliminated
    //
    //  delete message, EXCEPT when connecting, those message are
    //      recursive queries that are resent
    //

    LOCK_TCPCON_LIST();
    RemoveEntryList( &pTcpCon->List );
    UNLOCK_TCPCON_LIST();

    closesocket( pTcpCon->Socket );

    if ( pTcpCon->pMsg )
    {
        PDNS_MSGINFO  pmsg = pTcpCon->pMsg;

        if ( !pTcpCon->pCallback )
        {
            DNS_DEBUG( TCP, (
                "WARNING:  connection timeout for socket with EXISTING message.\n"
                "\tSocket = %d.\n"
                "\tDeleting associated message at %p.\n"
                "\tMessage is %scomplete.\n",
                pTcpCon->Socket,
                pmsg,
                pmsg->fMessageComplete ? "IN" : "" ));

            ASSERT( pmsg->pConnection == pTcpCon );
            ASSERT( pmsg->Socket == pTcpCon->Socket );
#if DBG
            // free routine will ASSERT no outstanding connection
            pmsg->pConnection = NULL;
#endif
            Packet_Free( pmsg );
        }

        else
        {
            DNS_DEBUG( TCP, (
                "Deleting callback connection %p, with pMsg %p\n",
                pTcpCon,
                pmsg ));

            InsertTailList( pCallbackList, (PLIST_ENTRY)pTcpCon );
            return;
        }
    }

    FREE_TAGHEAP( pTcpCon, 0, MEMTAG_CONNECTION );
}



VOID
callbackConnectFailureList(
    IN      PLIST_ENTRY     pCallbackList
    )
/*++

Routine Description:

    Cleanup list of TCP connection failures.
        - connection (socket) closed
        - pMsg cleared from connection, and returned to UDP
        - callback function called

    Need list, as may be several when do a timeout.

Arguments:

    pCallbackList -- list of connection callbacks

Return Value:

    TRUE if successfully allocate recursion block.
    FALSE on allocation failure.

--*/
{
    PDNS_SOCKET         pcon;
    PDNS_SOCKET         pconNext;
    PDNS_MSGINFO        pmsg;
    CONNECT_CALLBACK    pcallback;

    //  DEVNOTE: missing failure stat


    DNS_DEBUG( TCP, ( "tcpConnectFailureCallback()\n" ));

    pconNext = (PDNS_SOCKET) pCallbackList->Flink;

    while ( (pcon = pconNext) && pcon != (PDNS_SOCKET)pCallbackList )
    {
        DNS_DEBUG( TCP, (
            "Connect failure callback (pcon=%p, sock=%d, pmsg=%p)\n",
            pcon,
            pcon->Socket,
            pcon->pMsg
            ));

        pconNext = (PDNS_SOCKET) pcon->List.Flink;

        //  extract connection info

        pcallback = pcon->pCallback;
        ASSERT( pcallback );

        pmsg = pcon->pMsg;
        ASSERT( pmsg && pmsg->fTcp );

        //
        //  clear TCP info from message
        //  dispatch to connect callback with failed indication
        //

        pmsg->pConnection = NULL;
        pmsg->fTcp = FALSE;
        pmsg->Socket = g_UdpSendSocket;

        (pcallback)( pmsg, FALSE );

        //  delete connection block

        FREE_TAGHEAP( pcon, 0, MEMTAG_CONNECTION );
    }
}



//
//  Public TCP connection list routines
//

BOOL
Tcp_ConnectionListFdSet(
    IN OUT  fd_set *        pReadFdSet,
    IN OUT  fd_set *        pWriteFdSet,
    IN OUT  fd_set *        pExceptFdSet,
    IN      DWORD           dwLastSelectTime
    )
/*++

Routine Description:

    Add TCP connection list sockets to fd_set.
    Timeout connections that were already past timeout at last select.

Arguments:

    None.

Return Value:

    TRUE if connecting socket
    FALSE otherwise

--*/
{
    PDNS_SOCKET pcon;
    PDNS_SOCKET pconNext;
    BOOL        fconnecting = FALSE;
    LIST_ENTRY  callbackList;

    //  init callback failure list

    InitializeListHead( &callbackList );

    //
    //  empty wakeups
    //
    //  need to do this BEFORE build list, so that any wakeup requested
    //  while we build list will be processed on the next cycle
    //

    if ( g_bTcpSelectWoken )
    {
        DWORD   buf;
        INT     err;

        g_bTcpSelectWoken = FALSE;
        while( 1 )
        {
            err = recvfrom(
                        g_TcpSelectWakeupSocket,
                        (PBYTE) &buf,
                        sizeof(DWORD),
                        0,
                        NULL,
                        0 );
            if ( err > 0 )
            {
                DNS_DEBUG( TCP, (
                    "Received %d bytes (bufval=%p) on wakeup socket.\n",
                    err,
                    buf ));
                continue;
            }

            err = WSAGetLastError();
            if ( err != WSAEWOULDBLOCK )
            {
                DNS_PRINT((
                    "ERROR:  error %d other than WOULDBLOCK on wakeup socket\n",
                    err ));
                ASSERT( fDnsServiceExit );      // will fail WSAENOTSOCK on shutdown
            }
            break;
        }
    }

    //
    //  DEVNOTE: reaching FD_SETSIZE
    //
    //      should have own TCP starting value
    //      at minimum check and log when reached limit, perhaps
    //          dump longest waiting connection
    //      alternatively, realloc when overflow
    //

    //
    //  loop through all active TCP connections
    //

    LOCK_TCPCON_LIST();

    pconNext = (PDNS_SOCKET) mg_TcpConnectionList.Flink;

    while ( (PLIST_ENTRY)pconNext != &mg_TcpConnectionList )
    {
        //  get next here, since connection may be deleted

        pcon = pconNext;
        pconNext = (PDNS_SOCKET) pconNext->List.Flink;

        //
        //  timeout reached
        //

        if ( dwLastSelectTime > pcon->dwTimeout )
        {
            DNS_DEBUG( TCP, (
                "Timing out connection on TCP socket %d.\n",
                pcon->Socket ));

            tcpConnectionDelete( pcon, &callbackList );
            continue;
        }

        //
        //  socket is connecting to remote DNS
        //      - add to Write and Except FD_SETs
        //      - clear them if this is first connector
        //

        if ( pcon->pCallback )
        {
            DNS_DEBUG( TCP, (
                "Add TCP connect attempt on socket %d to connect fd_sets.\n"
                "\tconnect block = %p\n",
                pcon->Socket,
                pcon ));

            if ( !fconnecting )
            {
                FD_ZERO( pWriteFdSet );
                FD_ZERO( pExceptFdSet );
            }
            fconnecting = TRUE;

            if ( pWriteFdSet->fd_count < FD_SETSIZE )
            {
                FD_SET( pcon->Socket, pWriteFdSet );
                FD_SET( pcon->Socket, pExceptFdSet );
                continue;
            }
        }

        //
        //  add socket to read fd_set
        //      - check that don't overflow fd_set, always leaving space
        //      in fd_set for wakeup socket
        //

        else if ( pReadFdSet->fd_count < FD_SETSIZE-1 )
        {
            FD_SET( pcon->Socket, pReadFdSet );
            continue;
        }

        //
        //  out of space in fd_set
        //
        //  DEVNOTE-LOG: log dropping connection
        //

        DNS_DEBUG( ANY, (
            "ERROR:  TCP FD_SET overflow.\n"
            "\tdeleting connection on TCP socket %d.\n",
            pcon->Socket ));

        tcpConnectionDelete( pcon, &callbackList );
    }

    //
    //  add select() wakeup socket to fd_set
    //

    FD_SET( g_TcpSelectWakeupSocket, pReadFdSet );

    UNLOCK_TCPCON_LIST();

    //
    //  cleanup any timedout (or dropped) connect attempt failures
    //

    callbackConnectFailureList( &callbackList );

    //  return value indicates whether connecting sockets
    //  at in Write and Except fd_sets

    return( fconnecting );
}



BOOL
Tcp_ConnectionCreate(
    IN      SOCKET              Socket,
    IN      CONNECT_CALLBACK    pCallback,  OPTIONAL
    IN OUT  PDNS_MSGINFO        pMsg
    )
/*++

Routine Description:

    Create entry in connection list for new connection.

    Note:  this routine is NOT truly multi-thread safe.  It assumes
    only ONE thread will own socket at a particular time.  It does
    NOT check whether socket is already in list, while holding CS.

Arguments:

    Socket - socket for new connection.

    pCallback - connecting failed callback

    pMsg - message currently servicing connection

Return Value:

    None

--*/
{
    register PDNS_SOCKET    pcon;
    DWORD   timeout;

    //
    //  create connection struct
    //

    pcon = ALLOC_TAGHEAP_ZERO( sizeof(DNS_SOCKET), MEMTAG_CONNECTION );
    IF_NOMEM( ! pcon )
    {
        return( FALSE );
    }

    //
    //  set values
    //      - socket
    //      - remote IP
    //      - message ptr
    //      - timeout

    pcon->pCallback = pCallback;
    pcon->Socket    = Socket;
    pcon->pMsg      = pMsg;
    pcon->ipRemote  = pMsg->RemoteAddress.sin_addr.s_addr;

    timeout = DNS_TCP_CONNECTION_TIMEOUT;
    if ( pCallback )
    {
        timeout = SrvCfg_dwXfrConnectTimeout;
    }
    pcon->dwTimeout = DNS_TIME() + timeout;

    //
    //  alert message that it is connected
    //  indicate that message is incomplete
    //

    if ( pMsg )
    {
        pMsg->pConnection = pcon;
        pMsg->fMessageComplete = FALSE;
    }

    IF_DEBUG( TCP )
    {
        Dbg_SocketContext(
            "TCP Connection Create",
            pcon );
    }

    //
    //  insert connection
    //      - front of list, so socket ends up at front of fd_set
    //        which is important until have guaranteed inclusion in
    //        read fd_set
    //
    //  if connect attempt, then wake TCP select() to force rebuild
    //      of lists
    //

    LOCK_TCPCON_LIST();

    InsertHeadList( &mg_TcpConnectionList, (PLIST_ENTRY)pcon );

    if ( pCallback )
    {
        Tcp_ConnectionListReread();
    }
    UNLOCK_TCPCON_LIST();
    return( TRUE );
}



VOID
Tcp_ConnectionListReread(
    VOID
    )
/*++

Routine Description:

    Force rebuild of connection list by waking socket.

Arguments:

    None

Return Value:

    None

--*/
{
    DNS_DEBUG( TCP, ( "Waking TCP select().\n" ));

    //
    //  send to wakeup socket triggering TCP select()
    //  protect with CS, so that we protect the g_bTcpSelectWoken flag
    //      otherwise TCP thread could have just built its list and then
    //      set the flag FALSE, immediately after we read it as TRUE
    //  alternative is to ALWAYS send which is more expensive
    //

    LOCK_TCPCON_LIST();

    if ( ! g_bTcpSelectWoken )
    {
        DWORD   buf;
        INT     err;

        g_bTcpSelectWoken = TRUE;
        err = sendto(
                    g_TcpSelectWakeupSocket,
                    (PBYTE) &buf,
                    sizeof(DWORD),
                    0,
                    (PSOCKADDR) &wakeupSockaddr,
                    sizeof(SOCKADDR_IN) );
        if ( err < 0 )
        {
            err = WSAGetLastError();
            if ( err != WSAEWOULDBLOCK )
            {
                DNS_PRINT((
                    "ERROR:  error %d other than WOULDBLOCK on wakeup socket send.\n",
                    err ));
                ASSERT( FALSE );
            }
        }
    }

    UNLOCK_TCPCON_LIST();
}



VOID
Tcp_ConnectionDeleteForSocket(
    IN      SOCKET          Socket,
    IN      PDNS_MSGINFO    pMsg        OPTIONAL
    )
/*++

Routine Description:

    Delete TCP connection.
        - close the socket
        - remove connection from list
        - free the memory

Arguments:

    Socket -- socket to delete connection for

    pMsg -- message associated with connection, if known

Return Value:

    None

--*/
{
    PDNS_SOCKET     pcon;
    PDNS_MSGINFO    pfreeMsg = NULL;
    LIST_ENTRY      callbackList;

    //  init callback failure list

    InitializeListHead( &callbackList );

    //
    //  find connection for socket
    //

    LOCK_TCPCON_LIST();

    pcon = Tcp_ConnectionFindForSocket( Socket );
    if ( !pcon )
    {
        DNS_DEBUG( TCP, (
            "WARNING:  Socket NOT FOUND in TCP client connection list.\n"
            "\tClosing socket %d.\n",
            Socket ));

        Sock_CloseSocket( Socket );
        if ( pMsg )
        {
            Packet_Free( pMsg );
        }
        UNLOCK_TCPCON_LIST();
        return;
    }

    //
    //  delete TCP connection blob
    //

    ASSERT( !pMsg || pMsg->Socket == Socket );

    ASSERT( !pMsg || pcon->pMsg == pMsg );
    ASSERT( !pMsg || pMsg->pConnection == pcon );

    if ( pMsg && pMsg != pcon->pMsg )
    {
        DNS_PRINT((
            "ERROR:  Freeing pMsg=%p, not associated with connection %p\n",
            pMsg,
            pcon ));

        pfreeMsg = pMsg;
        ASSERT( FALSE );
    }

    //  delete connection, close socket

    tcpConnectionDelete( pcon, &callbackList );

    UNLOCK_TCPCON_LIST();

    //  callback with failure

    callbackConnectFailureList( &callbackList );

    //  free standalone message

    if ( pfreeMsg )
    {
        Packet_Free( pfreeMsg );
    }
}



PDNS_MSGINFO
Tcp_ConnectionMessageFindOrCreate(
    IN      SOCKET          Socket
    )
/*++

Routine Description:

    Find message associated with TCP connection.

    If existing message -- return it.
    If NO existing message -- allocate new message.

Arguments:

    Socket -- socket to find connection for

Return Value:

    Ptr to connection, if found.
    NULL otherwise.

--*/
{
    PDNS_SOCKET     pcon;
    PDNS_MSGINFO    pmsg;

    //
    //  find connection for this socket
    //

    pcon = Tcp_ConnectionFindForSocket( Socket );
    if ( !pcon )
    {
        DNS_PRINT((
            "WARNING:  tcpConnectionFindForSocket( %d ).\n"
            "\tNO connection for this socket.\n"
            "\tThis may happen when closing listening socket.\n",
            Socket ));

        //
        //  DEVNOTE: not sure this is correct approach,
        //      ideally we'd detect whether this was previously closed
        //      listening socket and only close when it was not
        //
        // Sock_CloseSocket( Socket );

        return( NULL );
    }

    //
    //  verify this is connected socket -- connection callback should be gone
    //
    //  really want the check, because MUST not allow pMsg on callback to be
    //      interpreted as RECEIVE message;  if there's a window on connection
    //      completion and callback MUST find it
    //
    //  a window could well exist if remote DNS SENDS a packet on connection before
    //  even getting query -- need to make sure handle connection response first
    //  cleaning callback, before handling incoming, in case socket is in both
    //  FD_SETs
    //

    if ( pcon->pCallback )
    {
        DNS_PRINT((
            "ERROR:  attempting to recv() on connecting socket %d\n"
            "\tpContext = %p\n",
            Socket,
            pcon ));
        ASSERT( FALSE );
        return NULL;
    }

    //
    //  found connection for socket, update timeout
    //

    if ( pcon->dwTimeout != DNSCON_NO_TIMEOUT )
    {
        pcon->dwTimeout = DNS_TIME() + DNS_TCP_CONNECTION_TIMEOUT;
    }

    //
    //  message exists?
    //

    pmsg = pcon->pMsg;
    if ( pmsg )
    {
        ASSERT( pmsg->Socket == Socket );
        ASSERT( pmsg->pConnection == pcon );
        ASSERT( ! pmsg->fMessageComplete );
        return( pmsg );
    }

    //
    //  no current message
    //      - allocate new one (default size)
    //      - set to this socket
    //      - attach it to connection
    //

    pmsg = Packet_AllocateTcpMessage( 0 );
    IF_NOMEM( !pmsg )
    {
        DNS_PRINT((
            "ERROR:  Allocating TCP message for socket %d.\n"
            "\tDeleting TCP connection at %p.\n",
            Socket,
            pcon ));
        ASSERT( FALSE );
        tcpConnectionDelete( pcon, NULL );
        return( NULL );
    }

    pmsg->pConnection = pcon;
    pmsg->Socket = Socket;
    pmsg->RemoteAddress.sin_addr.s_addr = pcon->ipRemote;

    pcon->pMsg = pmsg;

    return( pmsg );
}



VOID
Tcp_ConnectionUpdateTimeout(
    IN      SOCKET          Socket
    )
/*++

Routine Description:

    Reset timeout on TCP connection.

Arguments:

    Socket -- socket to reset timeout on

Return Value:

    None

--*/
{
    PDNS_SOCKET pcon;

    //
    //  find connection for socket and update timeout (if necessary)
    //

    LOCK_TCPCON_LIST();

    pcon = Tcp_ConnectionFindForSocket( Socket );
    if ( pcon )
    {
        if ( pcon->dwTimeout < DNSCON_NO_TIMEOUT )
        {
            pcon->dwTimeout = DNS_TIME() + DNS_TCP_CONNECTION_TIMEOUT;
        }
    }
    else
    {
        //  socket not found in connection list
        //
        //  although unlikely this is possible, if the TCP recv thread recv()s
        //  a FIN and closes the connection between the send() and the
        //  call to the update connection routine

        DNS_DEBUG( TCP, (
            "WARNING:  Attempt to update socket %d, not in connection list.\n",
            Socket ));
    }

    UNLOCK_TCPCON_LIST();
}



VOID
Tcp_ConnectionUpdateForCompleteMessage(
    IN      PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Reset connection to point at correct socket, on realloc.

        - clear message info from connection info
        - reset timeout on TCP connection

Arguments:

    pMsg -- message received on connection

Return Value:

    None

--*/
{
    PDNS_SOCKET pcon;

    //
    //  hold lock with clear so that connection can not be deleted out from under us
    //

    LOCK_TCPCON_LIST();
    pcon = (PDNS_SOCKET)pMsg->pConnection;
    ASSERT( pcon );
    ASSERT( pcon->Socket == pMsg->Socket );

    DNS_DEBUG( TCP, (
        "Clearing reference to pmsg at %p, in TCP connection at %p."
        "\tfor socket %d.\n",
        pMsg,
        pcon,
        pcon->Socket ));

    pcon->pMsg = NULL;
    pcon->dwTimeout = DNS_TIME() + DNS_TCP_CONNECTION_TIMEOUT;
    pMsg->pConnection = NULL;
    UNLOCK_TCPCON_LIST();
}



VOID
Tcp_ConnectionUpdateForPartialMessage(
    IN      PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Reset connection info for completed message.

        - clear message info from connection info
        - reset timeout on TCP connection

Arguments:

    pMsg -- message partially received on connection

Return Value:

    None

--*/
{
    PDNS_SOCKET pcon;

    //
    //  hold lock while update so that connection can not be deleted out from under us
    //

    LOCK_TCPCON_LIST();
    pcon = (PDNS_SOCKET)pMsg->pConnection;
    ASSERT( pcon );
    ASSERT( pcon->Socket == pMsg->Socket );

    pcon->pMsg = pMsg;
    UNLOCK_TCPCON_LIST();
}



//
//  Init and shutdown
//

VOID
Tcp_ConnectionListInitialize(
    VOID
    )
/*++

Routine Description:

    Initialize connection list.

Arguments:

    None.

Return Value:

    None

--*/
{
    DWORD   nonBlocking = TRUE;
    INT     size;

    InitializeListHead( &mg_TcpConnectionList );

    RtlInitializeCriticalSection( &mg_TcpConnectionListCS );

    mg_TcpConnectionListInitialized = TRUE;

    //
    //  create wakeup socket on loopback address, any port
    //

    g_bTcpSelectWoken = TRUE;

    g_TcpSelectWakeupSocket = Sock_CreateSocket(
                                SOCK_DGRAM,
                                NET_ORDER_LOOPBACK,
                                0,      // any port
                                0       // no flags
                                );

    if ( g_TcpSelectWakeupSocket == DNS_INVALID_SOCKET )
    {
        DNS_PRINT(( "ERROR:  Failed to create wakeup socket!!!\n" ));
        ASSERT( FALSE );
        return;
    }
    DNS_DEBUG( TCP, (
        "Created wakeup socket = %d\n",
        g_TcpSelectWakeupSocket ));

    ioctlsocket( g_TcpSelectWakeupSocket, FIONBIO, &nonBlocking );

    //
    //  save wakeup sockaddr to send wakeups to
    //

    size = sizeof(SOCKADDR);

    getsockname(
        g_TcpSelectWakeupSocket,
        (PSOCKADDR) &wakeupSockaddr,
        & size );
}



VOID
Tcp_ConnectionListShutdown(
    VOID
    )
/*++

Routine Description:

    Cleanup connection list.
        - close connection list sockets
        - delete CS

Arguments:

    None.

Return Value:

    Ptr to connection, if found.
    NULL otherwise.

--*/
{
    PDNS_SOCKET  pentry;
    SOCKET  s;
    INT     err;

    ASSERT( fDnsServiceExit );
    if ( !mg_TcpConnectionListInitialized )
    {
        return;
    }

    //
    //  close ALL outstanding sockets
    //

    LOCK_TCPCON_LIST();

    while ( !IsListEmpty(&mg_TcpConnectionList) )
    {
        pentry = (PDNS_SOCKET) RemoveHeadList( &mg_TcpConnectionList );

        s = pentry->Socket;
        err = closesocket( s );

        IF_DEBUG( SHUTDOWN )
        {
            DNS_PRINT((
                "Closing TCP connection socket %d -- error %d.\n",
                s,
                err ? WSAGetLastError() : 0 ));
            DnsDebugFlush();
        }
        ASSERT( !err );

        //Timeout_Free( pentry );
    }

    UNLOCK_TCPCON_LIST();

    //  delete list CS

    RtlDeleteCriticalSection( &mg_TcpConnectionListCS );
}


#if 0
//
//  Remote server could conceivable send two messages in response
//  (a bug), and so we shouldn't depend on connection NOT being in
//  the process of receiving another message on a given socket.
//


VOID
Tcp_ConnectionVerifyClearForSocket(
    VOID
    )
/*++

Routine Description:

    Verify that TCP connection for socket is NOT pointing at any
    message buffer.

Arguments:

    Socket -- socket connection is on

Return Value:

    None.  ASSERT()s on failure.

--*/
{
    PDNS_SOCKET pcon;

    pcon = Tcp_ConnectionFindForSocket( Socket );

    DNS_PRINT((
        "WARNING:  no TCP connection exists for socket %d\n",
        Socket ));

    ASSERT( pcon->pMsg == NULL );
}
#endif



//
//  TCP connect routines
//
//  Outbound TCP connections, used by
//      - recursion
//      - update forwarding
//

BOOL
Tcp_ConnectForForwarding(
    IN OUT  PDNS_MSGINFO        pMsg,
    IN      IP_ADDRESS          ipServer,
    IN      CONNECT_CALLBACK    ConnectCallback
    )
/*++

Routine Description:

    Initiate TCP connection for forwarding.

Arguments:

    pMsg -- message to forward
        - for recursion this is pRecurseMsg
        - for update forwarding the update message itself

    ipServer -- remote DNS to connect to

    ConnectCallback -- callback function on connect failure

Return Value:

    TRUE if successfully allocate recursion block.
    FALSE on allocation failure.

--*/
{
    IF_DEBUG( TCP )
    {
        Dbg_DnsMessage(
            "Attempting TCP forwarding on message:",
            pMsg );
    }

    //
    //  connect to server
    //
    //  if fail, just continue with next server
    //

    if ( ! Msg_MakeTcpConnection(
                pMsg,
                ipServer,
                0,                      // no bind() address
                DNSSOCK_NO_ENLIST       // do NOT put the socket in the socket list
                ) )
    {
        goto Failed;
    }

    ASSERT( pMsg->Socket != g_UdpSendSocket );
    ASSERT( pMsg->Socket != DNS_INVALID_SOCKET );
    ASSERT( pMsg->fTcp );

    //
    //  if successful, add socket to TCP connection list so we can
    //      receive responses
    //
    //      - on failure close connection socket

    if ( ! Tcp_ConnectionCreate(
                pMsg->Socket,
                ConnectCallback,
                pMsg ) )
    {
        //  only failure is allocation failure
        Sock_CloseSocket( pMsg->Socket );
        goto Failed;
    }
    return( TRUE );

Failed:

    //  on failure, clear socket and TCP fields
    //  simply execute the connect callback function with failure,
    //      this avoids duplicating the failure path code

    DNS_DEBUG( ANY, (
        "Failed to create TCP connection to server %s\n"
        "\tfor forwarding %p.\n",
        IP_STRING(ipServer),
        pMsg ));

    ASSERT( FALSE );
    pMsg->fTcp = FALSE;
    pMsg->Socket = g_UdpSendSocket;

    ConnectCallback(
        pMsg,
        FALSE       // connect failed
        );
    return( FALSE );
}



VOID
Tcp_ConnectionCompletion(
    IN      SOCKET          Socket
    )
/*++

Routine Description:

    Send recursive query after successful TCP connection.

Arguments:

    Socket -- socket connect failure occured on.

Return Value:

    TRUE if successfully allocate recursion block.
    FALSE on allocation failure.

--*/
{
    PDNS_SOCKET         pcon;
    PDNS_MSGINFO        pmsg;
    CONNECT_CALLBACK    pcallback;

    DNS_DEBUG( TCP, (
        "Tcp_ConnectionCompletion( sock=%d )\n",
        Socket ));

    STAT_INC( RecurseStats.TcpConnect );

    //
    //  find connection for socket
    //

    LOCK_TCPCON_LIST();

    pcon = Tcp_ConnectionFindForSocket( Socket );
    if ( !pcon )
    {
        ASSERT( FALSE );
        UNLOCK_TCPCON_LIST();
        return;
    }

    //  extract callback function and message

    pcallback = pcon->pCallback;
    ASSERT( pcallback );

    pmsg = pcon->pMsg;
    ASSERT( pmsg->fTcp );
    ASSERT( pcon->ipRemote );
    ASSERT( pcon->ipRemote == pmsg->RemoteAddress.sin_addr.s_addr );

    //  update callback
    //      - clear callback to indicate connected
    //      - clear msg, as this is NOT recv message
    //      - update timeout to allow callback function to launch query

    pcon->pCallback = NULL;
    pcon->pMsg = NULL;
    pcon->dwTimeout = DNS_TIME() + TCP_QUERY_TIMEOUT;

    UNLOCK_TCPCON_LIST();

    //
    //  callback with success
    //

    pmsg->pConnection = NULL;

    (pcallback)( pmsg, TRUE );
}



VOID
Tcp_CleanupFailedConnectAttempt(
    IN      SOCKET          Socket
    )
/*++

Routine Description:

    Cleanup TCP connection failure, and continue normal query.

Arguments:

    Socket -- socket connect failure occured on.

Return Value:

    TRUE if successfully allocate recursion block.
    FALSE on allocation failure.

--*/
{
    PDNS_SOCKET         pcon;
    PDNS_MSGINFO        pmsg;
    PDNS_MSGINFO        pmsgQuery;
    CONNECT_CALLBACK    pcallback;
    LIST_ENTRY          callbackList;


    DNS_DEBUG( TCP, (
        "Tcp_CleanupFailedConnectAttempt( sock=%d )\n",
        Socket ));


    //  init callback failure list

    InitializeListHead( &callbackList );

    //
    //  find connection for socket
    //

    LOCK_TCPCON_LIST();

    pcon = Tcp_ConnectionFindForSocket( Socket );
    if ( !pcon )
    {
        DNS_PRINT((
            "ERROR:  socket %d not in connection list!!!\n",
            Socket ));
        ASSERT( FALSE );
        UNLOCK_TCPCON_LIST();
        return;
    }

    //  close connection
    //  connection block will be put on callback list

    ASSERT( pcon->pCallback );
    ASSERT( pcon->pMsg );
    tcpConnectionDelete( pcon, &callbackList );

    UNLOCK_TCPCON_LIST();

    //  callback with failure

    callbackConnectFailureList( &callbackList );
}



#if 0
//
//  Unable to do any sort of TCP connect attempt or connection
//  cancellation from other threads, as have no idea if TCP thread
//  is currently servicing this connection blob -- receiving on socket
//  or processing message
//

VOID
Tcp_StopTcpForwarding(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Stop TCP recursion for query.
        - close TCP connection
        - reset recursion info for further queries as UDP

    Note caller does any query continuation logic, which may be
    requerying (from timeout thread) or processing TCP response
    (from worker thread).

Arguments:

    pMsg -- recurse message using TCP

Return Value:

    TRUE if successfully allocate recursion block.
    FALSE on allocation failure.

--*/
{
    DNS_DEBUG( RECURSE, (
        "Tcp_StopTcpRecursion() for recurse message at %p.\n",
        pMsg ));

    //
    //  delete connection to server
    //

    ASSERT( pMsg->pRecurseMsg );
    ASSERT( pMsg->fTcp );

    STAT_INC( PrivateStats.TcpDisconnect );
    Tcp_ConnectionDeleteForSocket( pMsg->Socket, pMsg );

    //
    //  reset for UDP query
    //

    pMsg->pConnection = NULL;
    pMsg->fTcp = FALSE;
    pMsg->Socket = g_UdpSendSocket;
}
#endif


//
//  End of tcpcon.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\timeout.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    timeout.h

Abstract:

    Domain Name System (DNS) Server

    Timeout system definitions.

Author:

    Jim Gilroy (jamesg)     February 1995

Revision History:

--*/

#ifndef _TIMEOUT_INCLUDED_
#define _TIMEOUT_INCLUDED_


//
//  Timeout node ptr array type
//
//  These are big enough so list processing is minimized, but are allocated and
//  deallocated as move through bins, so generally will not use up too much
//  memory.  And they are small enough that the total usage is reasonably
//  tailored to the actually outstanding timeouts to be done.
//
//  These structures will be overlayed in standard dbase nodes.
//

#define TIMEOUT_BIN_COUNT       (256)
#define MAX_ALLOWED_BIN_OFFSET  (253)

#define MAX_TIMEOUT_NODES       (64)

typedef struct _DnsTimeoutArray
{
    struct _DnsTimeoutArray *   pNext;
    DWORD                       Count;
    PDB_NODE                    pNode[ MAX_TIMEOUT_NODES ];
}
TIMEOUT_ARRAY, *PTIMEOUT_ARRAY;


#endif  // _TIMEOUT_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\thread.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    thread.c

Abstract:

    Domain Name System (DNS) Server

    DNS thread management.

    Need to maintain a list of thread handles so we can wait on these
    handles to insure all threads terminate at shutdown.

Author:

    Jim Gilroy (jamesg)     September 1995

Revision History:

--*/


#include "dnssrv.h"


//
//  Thread arrays
//
//  Need to store thread handles for main thread to wait on at
//  service shutdown.
//
//  Need to store thread ids so that dynamic threads (zone transfer)
//  can reliably find their own handle and close it when they terminate.
//

#define DNS_MAX_THREAD_COUNT    (120)

DWORD   g_ThreadCount;

CRITICAL_SECTION    csThreadList;

HANDLE  g_ThreadHandleArray[ DNS_MAX_THREAD_COUNT ];
DWORD   g_ThreadIdArray[ DNS_MAX_THREAD_COUNT ];
LPSTR   g_ThreadTitleArray[ DNS_MAX_THREAD_COUNT ];

//
//  Limit XFR receive threads -- building database can produce quite a bit
//      of lock contention
//

#define XFR_THREAD_COUNT_LIMIT      ((g_ProcessorCount*2) + 3)

DWORD   g_XfrThreadCount;


//
//  Thread timeout on shutdown
//      - if debug set longer timeout to allow for printing

#if DBG
#define THREAD_TERMINATION_WAIT         30000   // give them 30 seconds
#define THREAD_DEBUG_TERMINATION_WAIT   1000    // one sec to find offender
#else
#define THREAD_TERMINATION_WAIT         10000   // give them 10 seconds
#endif


//
//  Private protos
//

#if DBG
VOID
Dbg_ThreadHandleArray(
    VOID
    );

VOID
Dbg_Thread(
    IN      LPSTR   pszHeader,
    IN      DWORD   iThread
    );
#else

#define Dbg_Thread(a,b)
#define Dbg_ThreadHandleArray()

#endif


typedef struct  _DnsThreadStartContext
{
    LPTHREAD_START_ROUTINE      Function;
    LPVOID                      Parameter;
}
THREAD_START_CONTEXT, *PTHREAD_START_CONTEXT;



DWORD
threadTopFunction(
    IN      PTHREAD_START_CONTEXT   pvThreadContext
    )
/*++

Routine Description:

    Top level function of new DNS thread.

    This function provides a single location for handling thread exception
    handling code.  All DNS thread start under this function.

Arguments:

    pvThreadContext -- context of thread being created;  contains ptr to actual
        functional top routine of thread and its parameter

Return Value:

    Return from actual thread function.
    Zero on exception.

--*/
{
    LPTHREAD_START_ROUTINE  function;
    LPVOID                  param;

    //
    //  execute thread function with param
    //      - free context block
    //

    try
    {
        function = pvThreadContext->Function;
        param = pvThreadContext->Parameter;

        DNS_DEBUG( INIT, (
            "NEW THREAD:\n"
            "\tfunction     = %p\n"
            "\tparameter    = %p\n",
            function,
            param ));

        FREE_HEAP( pvThreadContext );

        return (* function)( param );
    }

    except( TOP_LEVEL_EXCEPTION_TEST() )
    {
        DNS_DEBUG( ANY, (
            "EXCEPTION: %p (%d) on thread\n",
            GetExceptionCode(),
            GetExceptionCode() ));

        //TOP_LEVEL_EXCEPTION_BODY();
        Service_IndicateException();
    }
    return 0;
}



HANDLE
Thread_Create(
    IN      LPSTR                   pszThreadTitle,
    IN      LPTHREAD_START_ROUTINE  lpStartAddr,
    IN      LPVOID                  lpThreadParam,
    IN      DWORD                   dwFailureEvent  OPTIONAL
    )
/*++

Routine Description:

    Creates DNS threads.

Arguments:

    pszThreadTitle -- title of this thread

    lpStartAddr -- thread start routine

    lpThreadParam -- startup parameter

    dwFailureEvent -- event to log on failure

Return Value:

    Thread handle, if successful
    NULL if unable to create thread

--*/
{
    HANDLE  threadHandle;
    DWORD   threadId;
    PTHREAD_START_CONTEXT pthreadStartContext;

    DNS_DEBUG( INIT, ( "Creating thread %s.\n", pszThreadTitle ));

    //
    //  initialize if first thread
    //

    if ( g_ThreadCount == 0 )
    {
        g_XfrThreadCount = 0;
        InitializeCriticalSection( &csThreadList );
    }

    //
    //  verify validity of another thread
    //

    if ( g_ThreadCount >= DNS_MAX_THREAD_COUNT )
    {
        DNS_PRINT(( "WARNING:  Thread handle array maximum exceeded.\n" ));
        Dbg_ThreadHandleArray();
        return( (HANDLE)NULL );
    }

    if ( lpStartAddr == Xfr_ReceiveThread &&
        g_XfrThreadCount > XFR_THREAD_COUNT_LIMIT )
    {
        DNS_DEBUG( ANY, (
            "WARNING: JJW suppressed XFR receive thread create - %d threads outstanding\n",
            g_XfrThreadCount ));
        return( (HANDLE)NULL );
    }

    //
    //  create thread context to pass to startup routine
    //

    pthreadStartContext = (PTHREAD_START_CONTEXT) ALLOC_TAGHEAP(
                                                        sizeof(THREAD_START_CONTEXT),
                                                        MEMTAG_THREAD );
    IF_NOMEM( !pthreadStartContext )
    {
        return( (HANDLE)NULL );
    }
    pthreadStartContext->Function = lpStartAddr;
    pthreadStartContext->Parameter = lpThreadParam;

    //
    //  create thread
    //
    //  note, we do this withing critical section, so that we can
    //  wait on CS when thread terminates, and we are guaranteed that
    //  it has been added to the list
    //

    EnterCriticalSection( &csThreadList );

    threadHandle = CreateThread(
                        NULL,           // security attributes
                        0,              // init stack size (process default)
                        threadTopFunction,
                        pthreadStartContext,
                        0,              // creation flags
                        &threadId
                        );

    if ( threadHandle == NULL )
    {
        LeaveCriticalSection( &csThreadList );

        if ( ! dwFailureEvent )
        {
            dwFailureEvent = DNS_EVENT_CANNOT_CREATE_THREAD;
        }
        DNS_LOG_EVENT(
            dwFailureEvent,
            0,
            NULL,
            NULL,
            GetLastError()
            );
        return( NULL );
    }

    //
    //  created thread, add info to list, inc thread count
    //

    g_ThreadHandleArray[ g_ThreadCount ]  = threadHandle;
    g_ThreadIdArray    [ g_ThreadCount ]  = threadId;
    g_ThreadTitleArray [ g_ThreadCount ]  = pszThreadTitle;

    IF_DEBUG( INIT )
    {
        Dbg_Thread(
            "Created new thread ",
            g_ThreadCount );
    }

    g_ThreadCount++;
    if ( lpStartAddr == Xfr_ReceiveThread )
    {
        g_XfrThreadCount++;
    }
    LeaveCriticalSection( &csThreadList );

    return( threadHandle );
}



VOID
Thread_Close(
    IN      BOOL            fXfrRecv
    )
/*++

Routine Description:

    Close handle for current thread.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD   threadId;
    DWORD   i;

    //  get current thread id

    threadId = GetCurrentThreadId();

    //
    //  find thread id in thread array
    //      - close thread handle
    //      - replace thread info, with info at top of arrays
    //

    EnterCriticalSection( &csThreadList );

    for ( i = 0; i < g_ThreadCount; i++ )
    {
        if ( threadId == g_ThreadIdArray[i] )
        {
            IF_DEBUG( SHUTDOWN )
            {
                Dbg_Thread( "Closing thread ", i );
            }
            CloseHandle( g_ThreadHandleArray[i] );

            --g_ThreadCount;
            g_ThreadTitleArray[i]  = g_ThreadTitleArray[g_ThreadCount];
            g_ThreadHandleArray[i] = g_ThreadHandleArray[g_ThreadCount];
            g_ThreadIdArray[i]     = g_ThreadIdArray[g_ThreadCount];

            goto Unlock;
        }
    }

    //
    //  somethings broken
    //

    DNS_PRINT((
        "ERROR:  Attempt to close unknown thread id %d.\n"
        "\tNot in thread handle array.\n",
        threadId ));

    Dbg_ThreadHandleArray();
    ASSERT( FALSE );

Unlock:

    //
    //  track count of outstand XFR receive threads
    //

    if ( fXfrRecv )
    {
        g_XfrThreadCount--;
    }
    LeaveCriticalSection( &csThreadList );
}



VOID
Thread_ShutdownWait(
    VOID
    )
/*++

Routine Description:

    Wait for all DNS threads to shutdown.

Arguments:

    None.

Return Value:

    None.

--*/
{
    INT     err;
    DWORD   i;

    //
    //  Wait on outstanding thread handles.
    //

    IF_DEBUG( INIT )
    {
        DNS_PRINT(( "Thread shutdown wait.\n" ));
        Dbg_ThreadHandleArray();
    }

    if ( g_ThreadCount > 0 )
    {
        err = WaitForMultipleObjects(
                    g_ThreadCount,
                    g_ThreadHandleArray,
                    TRUE,                       // wait for all
                    THREAD_TERMINATION_WAIT     // but don't allow hang
                    );
        IF_DEBUG( SHUTDOWN )
        {
            DNS_PRINT((
                "Thread shutdown wait completed, return = %lx\n",
                err ));
        }

        //
        //  if wait fails, find hanging thread and KILL IT
        //

        if ( err == WAIT_TIMEOUT )
        {
            DNS_PRINT(( "ERROR:  Shutdown thread handle wait failed.\n" ));

            Dbg_ThreadHandleArray();

            //
            //  Try each thread to find hanging thread. There should be
            //  no worker threads still alive. If any have hung we need
            //  to figure out why and fix the problem.
            //

            ASSERT( g_ThreadCount == 0 );

            for ( i = 0; i < g_ThreadCount; i++ )
            {
                err = WaitForSingleObject(
                        g_ThreadHandleArray[i],
                        0 );
                if ( err == WAIT_TIMEOUT )
                {
                    DNS_PRINT((
                        "ERROR: thread %d did not terminate\n",
                        g_ThreadIdArray[ i ] ));

                    //
                    //  It's dangerous to call TerminateThread. If the 
                    //  server routinely hits this condition, we need to 
                    //  figure out why threads are failing to terminate 
                    //  themselves.
                    //
                    //  TerminateThread( g_ThreadHandleArray[i], 1 );
                }
            }
        }

        //
        //  Close all the worker thread handles.
        //

        for ( i = 0; i < g_ThreadCount; i++ )
        {
            err = CloseHandle( g_ThreadHandleArray[i] );
#if DBG
            if ( !err )
            {
                DNS_PRINT((
                    "ERROR:  error %d closing thread handle %p.\n",
                    g_ThreadHandleArray[i],
                    err ));
            }
#endif
        }
    }
}   //  Thread_ShutdownWait



LPSTR
Thread_DescrpitionMatchingId(
    IN      DWORD           ThreadId
    )
/*++

Routine Description:

    Debug print title of thread matching given thread ID.

Arguments:

    ThreadId -- ID of desired thread.

Return Value:

    None.

--*/
{
    LPSTR   pszthreadName = NULL;
    DWORD   i;

    //
    //  get title of matching thread id
    //      - since all names are static in DNS.exe binary
    //      they can be returned outside of thread list CS, even
    //      though mapping with ID may no longer be valid
    //

    EnterCriticalSection( &csThreadList );
    for ( i=0; i<g_ThreadCount; i++ )
    {
        if ( ThreadId == g_ThreadIdArray[i] )
        {
            pszthreadName = g_ThreadTitleArray[i];
            break;
        }
    }
    LeaveCriticalSection( &csThreadList );

    return( pszthreadName );
}



#if DBG

VOID
Dbg_ThreadHandleArray(
    VOID
    )
/*++

Routine Description:

    Debug print DNS thread handle array.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD i;

    //
    //  Print handles and descriptions of all threads.
    //

    DnsDebugLock();

    DnsPrintf(
        "\nThread handle array (%d active threads):\n",
        g_ThreadCount );

    for ( i=0; i<g_ThreadCount; i++ )
    {
        Dbg_Thread( NULL, i );
    }
    DnsDebugUnlock();
}



VOID
Dbg_Thread(
    IN      LPSTR       pszHeader,
    IN      DWORD       iThread
    )
/*++

Routine Description:

    Debug print DNS thread.

Arguments:

    pThread -- ptr to DNS thread.

Return Value:

    None.

--*/
{
    DnsPrintf(
        "%s%s:\n"
        "\thandle = %p.\n"
        "\tid = %d.\n",
        pszHeader ? pszHeader : "",
        g_ThreadTitleArray[iThread],
        g_ThreadHandleArray[iThread],
        g_ThreadIdArray[iThread]
        );
}



VOID
Dbg_ThreadDescrpitionMatchingId(
    IN      DWORD   ThreadId
    )
/*++

Routine Description:

    Debug print title of thread matching given thread ID.

Arguments:

    ThreadId -- ID of desired thread.

Return Value:

    None.

--*/
{
    LPSTR   pszthreadName;

    pszthreadName = Thread_DescrpitionMatchingId( ThreadId );

    if ( pszthreadName )
    {
        DnsPrintf(
            "Thread %s matches thread ID %d\n",
            pszthreadName,
            ThreadId );
    }
    else
    {
        DnsPrintf(
            "Thread ID %d not found in thread handle array.\n",
            ThreadId );
    }

#if 0
    //
    //  print title of thread matching thread ID
    //

    EnterCriticalSection( &csThreadList );
    for ( i=0; i<g_ThreadCount; i++ )
    {
        if ( ThreadId == g_ThreadIdArray[i] )
        {
            DnsPrintf(
                "Thread %s matches thread ID %d\n",
                g_ThreadTitleArray[i],
                ThreadId );

            LeaveCriticalSection( &csThreadList );
            return;
        }
    }
    LeaveCriticalSection( &csThreadList );

    DnsPrintf(
        "Thread ID %d not found in thread handle array.\n",
        ThreadId );
#endif
}

#endif  // DBG




//
//  Service control utility for DNS threads
//

BOOL
Thread_ServiceCheck(
    VOID
    )
/*++

Routine Description:

    Wrap up all service checking functions for use by worker threads.

Arguments:

    None.

Return Value:

    TRUE if service continues.
    FALSE for service exit.

--*/
{
    DWORD   err;

    #if DBG
    if ( !g_RunAsService )
    {
        return TRUE;
    }
    #endif

    //
    //  Implementation note:
    //
    //  Checking for pause first.
    //  Service termination sets the pause event to free paused threads.
    //
    //  1)  Can use pause event to hold new worker threads during
    //  startup.  Then if initialization fails, immediately fall into
    //  shutdown without touching, perhaps broken, data structures.
    //
    //  2)  We can shutdown from paused state, without releasing threads
    //  for another thread processing cycle.
    //

    //
    //  Service is paused?  ->  wait for it to become unpaused.
    //

    if ( DnsServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING ||
        DnsServiceStatus.dwCurrentState == SERVICE_PAUSED ||
        DnsServiceStatus.dwCurrentState == SERVICE_START_PENDING )
    {
        DWORD   err;

        err = WaitForSingleObject(
                    hDnsContinueEvent,
                    INFINITE );

        ASSERT( err != WAIT_FAILED || fDnsServiceExit );
    }

    //
    //  Service termination?  ->  exit
    //

    if ( fDnsServiceExit )
    {
        return( FALSE );
    }

    return( TRUE );
}



//
//  Cheap, low-use critical section routines.
//
//  These allow flag to do work of CS, by piggy backing on
//  single general purpose CS, without requiring it to be held
//  for entire CS.
//

BOOL
Thread_TestFlagAndSet(
    IN OUT  PBOOL           pFlag
    )
/*++

Routine Description:

    Test flag and set if currently clear.

Arguments:

    pFlag -- ptr to BOOL variable

Return Value:

    TRUE if flag was clear -- flag is now set.
    FALSE if flag already set.

--*/
{
    BOOL    result = FALSE;

    GENERAL_SERVER_LOCK()

    if ( ! *pFlag )
    {
        result = TRUE;
        *pFlag = TRUE;
    }

    GENERAL_SERVER_UNLOCK()
    return( result );
}


VOID
Thread_ClearFlag(
    IN OUT  PBOOL           pFlag
    )
/*++

Routine Description:

    Clear flag (assumes flag is currently set).

Arguments:

    pFlag -- ptr to BOOL variable

Return Value:

    None

--*/
{
    GENERAL_SERVER_LOCK()
    *pFlag = FALSE;
    GENERAL_SERVER_UNLOCK()
}

//
//  End thread.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\timeout.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    timeout.c

Abstract:

    Domain Name System (DNS) Server

    Timeout thread routines.

Author:

    Jim Gilroy (jamesg)     September 1997

Revision History:

--*/


#include "dnssrv.h"

//
//  Timeout implementation
//
//  There are two basic approaches to handling node timeout:
//      1) walk the database every so often and time nodes out
//      2) keep list of nodes to be timed out at particular times
//
//  To avoid the expense of timeout walk on large database i'm doing option #2.
//  This is more expensive in terms of memory, but much cheaper in terms of
//  performance.
//
//  However, rather than a simple list of nodes and timeouts,
//  my timeout structure will consist of
//      1) a static ptr array for 256 time interval bins
//      2) an index to current bin (bin for current time interval)
//      3) for each bin a structure that is essentially an array of node ptrs
//          to be timed out in the interval corresponding to the bin
//      4) a field in each node giving index of the bin that is the furthest
//          off timeout on that node
//
//  This structure gives us several advantages over a simple list:
//
//  1) Less memory
//      Beyond overhead, just single ptr on node timeout.  Time is known from
//      the bin.
//
//  2) No list traversal to setup timeout
//      Just stick node ptr on end of array to setup timeout.  Do not need to
//      find its position in the list.
//
//  3) Suppress unnecessary timeout caching
//      When a RR is cached with a given timeout, we calculate the bin index
//      corresponding to that timeout.  If it is a bin that is "further away",
//      than the current timeout bin index on the node, we add the node ptr to
//      the timeout array for that bin, reset the node's bin index to it and
//      bump the node's reference count.  In this way we avoid keeping timeout
//      node ptrs for unnecessary short timeouts or repeated timeouts at the
//      same value.
//


//
//  Timeout bins
//
//  Current bin is bin corresponding to current time.
//      - this is origin for calculating cache timeouts
//  Check bin trails current by 2, so that there is always an interval
//      before delete
//      - safe for access, safe for zero TTL
//      - no sense cleaning up, if we will definitely requery\recache at node
//  Last bin trails check by one
//      - this is simply as-far-away-as-possible bin


PTIMEOUT_ARRAY   TimeoutBinArray[ TIMEOUT_BIN_COUNT ];

UCHAR   CurrentTimeoutBin;
UCHAR   CheckTimeoutBin;

CRITICAL_SECTION    csTimeoutLock;

#define LOCK_TIMEOUT()      EnterCriticalSection( &csTimeoutLock );
#define UNLOCK_TIMEOUT()    LeaveCriticalSection( &csTimeoutLock );


//
//  Time for each bin
//
//  Time delayed free's are protected.
//  This time should be longer (by short protect interval) than max
//  time queries are kept around for, so all queries referencing
//  object being freed, are dead by the time object is deleted.
//  Note, existing zone dumped by XFR can not be deleted until this
//  interval has passed.  So important to keep this reasonable.
//

#if DBG
#define TIMEOUT_INTERVAL    (300)
#define TIMEOUT_FREE_DELAY  (90)
#else
#define TIMEOUT_INTERVAL    (300)       //  5 minute retail
#define TIMEOUT_FREE_DELAY  (90)
#endif

#define TIMEOUT_MAX_TIME    (TIMEOUT_BIN_COUNT * TIMEOUT_INTERVAL)

DWORD   TimeoutBaseTime;
DWORD   TimeoutInterval;


//
//  Delayed timeout structure
//

typedef struct _DnsDelayedFree
{
    struct _DnsDelayedFree *    pNext;
    PVOID                       pItem;
    VOID                        (*pFreeFunction)( PVOID );
    LPSTR                       pszFile;
    DWORD                       Tag;
    DWORD                       LineNo;
}
DELAYED_FREE, *PDELAYED_FREE;

#define DELAYED_TAG                     (0xde1aedfe)
#define IS_DELAYED_TIMEOUT(ptr)         (((PDELAYED_FREE)ptr)->Tag == DELAYED_TAG)

//
//  Keep two delayed timeout lists.
//      - one collecting entries
//      - one waiting through one timeout
//

PDELAYED_FREE   CurrentDelayedFreeList;
PDELAYED_FREE   CoolingDelayedFreeList;

DWORD   CurrentDelayedCount;
DWORD   CoolingDelayedCount;


//
//  Cache limit stuff - see enforceCacheLimit().
//

static DWORD g_CacheLimitTimeAdjustments[] =
{
    0,                          //  1st pass - no adjustment - free if expired
    3600,                       //  2cd pass - adjust current time by one hour
    3600 * 24,                  //  3rd pass - adjust current time by one day
    DNS_CACHE_LIMIT_DISCARD_ALL,    //  4th pass - free all eligible RRs
};

DWORD   g_dwCacheLimitCurrentTimeAdjustment = 0;
DWORD   g_dwCacheFreeCount = 0;

//
//  Timeout thread
//

DWORD   TimeoutThreadId;



VOID
Timeout_Initialize(
    VOID
    )
/*++

Routine Description:

    Init timeout array.

Arguments:

    None

Return Value:

    None

--*/
{
    //  clear timeout array

    RtlZeroMemory(
        TimeoutBinArray,
        sizeof( TimeoutBinArray ) );

    //  init time base time
    //  will do this again on timeout thread start, but do here so any
    //  caching before start completed is handled correctly

    TimeoutBaseTime = DNS_TIME();

    //
    //  init globals
    //      - init in code to allow restart
    //

    TimeoutInterval = TIMEOUT_INTERVAL;

    //  bin pointers

    CurrentTimeoutBin   = 0;
    CheckTimeoutBin     = 254;

    //  delayed free lists

    CurrentDelayedFreeList = NULL;
    CoolingDelayedFreeList = NULL;

    //  debug info

    CoolingDelayedCount = 0;
    CurrentDelayedCount = 0;

    //  lock to protect simultaneous access to bins

    InitializeCriticalSection( &csTimeoutLock );
}



VOID
Timeout_Shutdown(
    VOID
    )
/*++

Routine Description:

    Cleanup timeout on shutdown.

Arguments:

    None

Return Value:

    None

--*/
{
    RtlDeleteCriticalSection( &csTimeoutLock );
}



//
//  Private timeout functions
//

PTIMEOUT_ARRAY
createTimeoutArray(
    VOID
    )
/*++

Routine Description:

    Set timeout on node.

Arguments:

    pNode -- node to check at timeout

    dwTimeout -- time of this timeout

Return Value:

    None.

--*/
{
    PTIMEOUT_ARRAY  parray;

    DNS_DEBUG( TIMEOUT, ( "Creating new timeout array struct\n" ));

    //
    //  for first cut using node structure as blocks
    //

    parray = (PTIMEOUT_ARRAY) ALLOC_TAGHEAP( sizeof(TIMEOUT_ARRAY), MEMTAG_TIMEOUT );
    IF_NOMEM( !parray )
    {
        return( NULL );
    }
    STAT_INC( TimeoutStats.ArrayBlocksCreated );

    parray->Count = 0;
    parray->pNext = NULL;

    return( parray );
}



VOID
deleteTimeoutArray(
    IN OUT  PTIMEOUT_ARRAY  pArray
    )
/*++

Routine Description:

    Delete timeout array block.

Arguments:

    pArray -- ptr to timeout array block being deleted

Return Value:

    None.

--*/
{
    DNS_DEBUG( TIMEOUT, ( "Deleting timeout array struct\n" ));

    STAT_INC( TimeoutStats.ArrayBlocksDeleted );

    FREE_HEAP( pArray );
}



VOID
insertPtrInTimeout(
    IN OUT  PDB_NODE    pNode,
    IN      UCHAR       Bin
    )
/*++

Routine Description:

    Set timeout on node.

    Note: this function assumes timeout lock held by caller.

Arguments:

    pNode -- node (or delayed free ptr) to check at timeout

    Bin -- index of bin to insert node into

Return Value:

    None.

--*/
{
    PTIMEOUT_ARRAY  ptimeoutArray;
    PTIMEOUT_ARRAY  plastArray;
    DWORD           index;

    DNS_DEBUG( TIMEOUT, (
        "Insert ptr %p in timeout bin %d\n",
        pNode,
        Bin ));

    //
    //  never cache into CheckBin or (CheckBin + 1), as these
    //  may be in use by timeout thread or will be before this
    //  function returns
    //
    //  we should never have even been pointed at CheckTimeoutBin,
    //  but may be aimed at CheckTimeoutBin+1, if we were pointed
    //  at CurrentTimeoutBin and just did bin advance
    //

    if ( Bin == CheckTimeoutBin || Bin == CheckTimeoutBin + 1 )
    {
        ASSERT( Bin != CheckTimeoutBin );
        Bin = CurrentTimeoutBin;
    }

    //  save node ptr
    //      - put in next available slot in bins timeout array

    ptimeoutArray = TimeoutBinArray[ Bin ];
    plastArray = ( PTIMEOUT_ARRAY ) &TimeoutBinArray[ Bin ];

    while ( 1 )
    {
        //  if no timeout array at this bin or all arrays are full
        //      then must create new one

        if ( !ptimeoutArray )
        {
            ptimeoutArray = createTimeoutArray();
            IF_NOMEM( !ptimeoutArray )
            {
                 return;
            }
            plastArray->pNext = ptimeoutArray;
        }

        //  find index for next node in array

        index = ptimeoutArray->Count;
        if ( index < MAX_TIMEOUT_NODES )
        {
            ptimeoutArray->pNode[index] = pNode;
            ptimeoutArray->Count++;
            break;
        }

        //  this array block is full, continue on to next block

        plastArray = ptimeoutArray;
        ptimeoutArray = ptimeoutArray->pNext;
        continue;
    }
}



DNS_STATUS
timeoutDbaseNode(
    IN OUT  PDB_NODE    pNode
    )
/*++

Routine Description:

    Make timeout check on node.

Arguments:

    pNode -- ptr to node to check for timeout

Return Value:

    DNSSRV_STATUS_NODE_RECENTLY_ACCESSED for recent access.
    ERROR_SUCCESS if node still valid.
    ERROR_TIMEOUT if node timed out.

--*/
{

    STAT_INC( TimeoutStats.Checks );

    //
    //  DCR:  move node in timeout list for faster timeout
    //      move forward
    //          - if recent access
    //          - if records didn't time out
    //

    //
    //  if node is recently accessed, then do NOT mess with it, don't want to
    //      delete the records if they are currently being used
    //

    if ( IS_NODE_RECENTLY_ACCESSED( pNode ) )
    {
        STAT_INC( TimeoutStats.RecentAccess );
        return DNSSRV_STATUS_NODE_RECENTLY_ACCESSED;
    }

    //
    //  timeout RR list
    //
    //
    //  DEVNOTE: don't quit if RR list remains on aggressive delete
    //  DEVNOTE: aggressive delete, delete RR list if safe
    //  DEVNOTE: determine timeout on remaining RRs and move (esp. if aggressive delete)
    //

    if ( pNode->pRRList )
    {
        RR_ListTimeout( pNode );

        if ( pNode->pRRList )
        {
            STAT_INC( TimeoutStats.ActiveRecord );
            return ERROR_SUCCESS;
        }
    }

    //
    //  check if node should NOT be freed
    //      - has children
    //      - has static RR records
    //      - referenced by another node
    //      - is authoritative zone root
    //      - accessed in timeout interval
    //
    //  for children or reference, get out immediately
    //      - saves grabbing the lock
    //

    if ( pNode->pChildren
            ||
         pNode->cReferenceCount
            ||
         IS_NODE_NO_DELETE(pNode)
            ||
         IS_AUTH_ZONE_ROOT(pNode) &&
            pNode->pZone &&
            ((PZONE_INFO)(pNode->pZone))->pZoneRoot == pNode )
    {
        STAT_INC( TimeoutStats.CanNotDelete );
        return ERROR_SUCCESS;
    }

#if 0
    //
    //  DEVNOTE:  agressive delete?  delete even untimedout records?
    //
    //      need to test again, inside locks for kids, ref, access
    //      then delete all cached records in the list
    //
    //      don't want to do zone nodes, unless know there is CACHED
    //      DATA
    //

    RR_ListDelete( pNode );
#endif

    //
    //  no RRs -- delete node
    //
    //  NTree_RemoveNode() holds both locks, see it for a description
    //  of locking requirements
    //

    IF_DEBUG( DATABASE )
    {
        Dbg_NodeName(
            "Timeout thread deleting node ",
            pNode,
            "\n" );
    }

    if ( NTree_RemoveNode( pNode ) )
    {
        STAT_INC( TimeoutStats.Deleted );
        return ERROR_TIMEOUT;
    }

    STAT_INC( TimeoutStats.CanNotDelete );
    return ERROR_SUCCESS;
}



VOID
executeDelayedFree(
    IN      PDELAYED_FREE   pTimeoutFree
    )
/*++

Routine Description:

    Execute a delayed (timeout) free.

Arguments:

    pv -- ptr to free after timeout

Return Value:

    None.

--*/
{
    STAT_INC( TimeoutStats.DelayedFreesExecuted );

    ASSERT( pTimeoutFree->Tag == DELAYED_TAG );

    if ( pTimeoutFree->pFreeFunction )
    {
        STAT_INC( TimeoutStats.DelayedFreesExecutedWithFunction );

#if DBG
        // catch bogus record frees

        if ( *pTimeoutFree->pFreeFunction == RR_Free )
        {
            SET_SLOWFREE_RANK( ((PDB_RECORD)pTimeoutFree->pItem) );
        }
#endif

        (*pTimeoutFree->pFreeFunction)( pTimeoutFree->pItem );
    }
    else
    {
        FREE_HEAP( pTimeoutFree->pItem );
    }

    //  free timeout free struct itself

    FREE_TAGHEAP( pTimeoutFree, sizeof(DELAYED_FREE), MEMTAG_TIMEOUT );
}



VOID
checkNodesInTimeoutBin(
    IN      UCHAR       Bin
    )
/*++

Routine Description:

    Set timeout on node.

Arguments:

    Bin -- timeout bin to check

Return Value:

    None.

--*/
{
    PTIMEOUT_ARRAY  ptimeoutArray;
    PTIMEOUT_ARRAY  pback;
    DWORD           i;
    DNS_STATUS      status;
    PDB_NODE        pnode;

    DNS_DEBUG( TIMEOUT, (
        "Checking nodes in timeout bin %d\n",
        Bin ));

    //
    //  walk all timeout arrays in this bin
    //      - execute delayed timeouts
    //      - check nodes, possibly timing out

    pback = (PTIMEOUT_ARRAY) &TimeoutBinArray[ Bin ];

    while ( ptimeoutArray = pback->pNext )
    {
        i = 0;

        while ( i < ptimeoutArray->Count )
        {
            pnode = ptimeoutArray->pNode[i];

            //  check for service exit, before dumping node

            if ( fDnsServiceExit )
            {
                return;
            }
            status = timeoutDbaseNode( pnode );
            if ( status == ERROR_SUCCESS )
            {
                i++;
                continue;
            }
            ASSERT( status == ERROR_TIMEOUT || status == DNSSRV_STATUS_NODE_RECENTLY_ACCESSED );

            //  remove entry from this array

            ptimeoutArray->Count--;
            ptimeoutArray->pNode[i] = ptimeoutArray->pNode[ ptimeoutArray->Count ];

            //  if node was recently accessed, then requeue to current bin
            //  this saves full cycle wait when node has been touched but
            //      still should be in timeout system

            if ( status == DNSSRV_STATUS_NODE_RECENTLY_ACCESSED )
            {
                LOCK_TIMEOUT();
                insertPtrInTimeout( pnode, CurrentTimeoutBin );
                pnode->uchTimeoutBin = CurrentTimeoutBin;
                UNLOCK_TIMEOUT();
            }
        }

        //  check for service exit on each array

        if ( fDnsServiceExit )
        {
            return;
        }

        //  if deleted all nodes in timeout array, then delete array from chain
        //  otherwise reset pback to move forward

        if ( ptimeoutArray->Count == 0 )
        {
            pback->pNext = ptimeoutArray->pNext;
            deleteTimeoutArray( ptimeoutArray );
            continue;
        }
        else
        {
            pback = ptimeoutArray;
        }
    }
}



VOID
enforceCacheLimit(
    VOID
    )
/*++

Routine Description:

    This function makes several passes through the cache, becoming more
    aggressive on each pass, attempting to free enough nodes to put the
    cache below it's maximum limit. Note that the maximum cache size
    is a soft limit - the cache can exceed it for brief periods of time.

    We assume that this function is only called by the timeout thread so
    that the bin pointers will not be changing during this function.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DBG_FN( "enforceCacheLimit" )

    INT                     passCount = sizeof( g_CacheLimitTimeAdjustments ) /
                                            sizeof( g_CacheLimitTimeAdjustments[ 0 ] );
    INT                     passIdx = -1;
    ULONG                   desiredCacheSize;   //  in bytes
    BOOLEAN                 fDone = FALSE;

    g_dwCacheFreeCount = 0;

    //
    //  This function should never be called if a cache limit is not set.
    //

    if ( SrvCfg_dwMaxCacheSize == DNS_SERVER_UNLIMITED_CACHE_SIZE )
    {
        DNS_DEBUG( TIMEOUT, (
            "%s: called but cache is not limited!\n", fn ));
        ASSERT( FALSE );
        return;
    }

    //
    //  The desired cache size is 90% of maximum.
    //
    //  DEVNOTE: tune this? make sure delta is not too small?
    //

    desiredCacheSize = ( ULONG ) ( SrvCfg_dwMaxCacheSize * 1000 * 0.90 );

    DNS_DEBUG( TIMEOUT, (
        "%s: starting at %d\n"
        "\tcurrentCacheSize   = %lu\n"
        "\tdesiredCacheSize   = %lu\n"
        "\texcess mem in use  = %ld (negative means below limit)\n"
        "\tCheckTimeoutBin    = %d\n"
        "\tCurrentTimeoutBin  = %d\n",
        fn,
        DNS_TIME(),
        DNS_SERVER_CURRENT_CACHE_BYTES,
        desiredCacheSize,
        DNS_SERVER_CURRENT_CACHE_BYTES - desiredCacheSize,
        ( int ) CheckTimeoutBin,
        ( int ) CurrentTimeoutBin ));

    //
    //  Loop until the cache is "sufficiently clear", becoming more
    //  aggressive each pass.
    //

    while ( !fDone && ++passIdx < passCount )
    {
        UCHAR   bin = CheckTimeoutBin;

        DNS_DEBUG( TIMEOUT, (
            "%s: starting pass %d adjustment %d\n", fn,
            passIdx,
            g_CacheLimitTimeAdjustments[ passIdx ] ));

        //
        //  If this enforcement requires at least one iteration with
        //  a time adjustment, bump "aggressive" stat.
        //

        if ( passIdx == 1 )
        {
            STAT_INC( CacheStats.PassesRequiringAggressiveFree );
        }

        //
        //  Set current time adjustment for this pass.
        //

        g_dwCacheLimitCurrentTimeAdjustment =
            g_CacheLimitTimeAdjustments[ passIdx ];

        //
        //  Loop through bins checking for nodes to free. 
        //

        LOCK_TIMEOUT();
        while ( bin != CurrentTimeoutBin )
        {
            //
            //  Do nothing if this bin is empty.
            //

            if ( TimeoutBinArray[ bin ] &&
                ( TimeoutBinArray[ bin ]->Count ||
                    TimeoutBinArray[ bin ]->pNext ) )
            {
                //
                //  Are we done? Check for service exit or if the cache
                //  is now acceptable in size.
                //

                if ( fDnsServiceExit ||
                    DNS_SERVER_CURRENT_CACHE_BYTES < desiredCacheSize )
                {
                    fDone = TRUE;
                    break;
                }

                //
                //  Free nodes in this bin. 
                //

                DNS_DEBUG( TIMEOUT, (
                    "%s: checking bin=%d pass=%d timeAdjust=%d\n", fn,
                    bin,
                    passIdx,
                    g_dwCacheLimitCurrentTimeAdjustment ));

                checkNodesInTimeoutBin( bin );
            }
            --bin;
        }
        UNLOCK_TIMEOUT();
    }

    if ( g_dwCacheFreeCount == 0 )
    {
        STAT_INC( CacheStats.PassesWithNoFrees );
    }

    //
    //  Reset current time adjustment to zero.
    //

    g_dwCacheLimitCurrentTimeAdjustment = 0;

    DNS_DEBUG( TIMEOUT, (
        "%s: finished at %d\n"
        "\tcurrentCacheSize   = %lu\n"
        "\tdesiredCacheSize   = %lu\n"
        "\texcess mem in use  = %ld (negative means below limit)\n"
        "\tfreed items        = %ld\n",
        fn,
        DNS_TIME(),
        DNS_SERVER_CURRENT_CACHE_BYTES,
        desiredCacheSize,
        DNS_SERVER_CURRENT_CACHE_BYTES - desiredCacheSize,
        g_dwCacheFreeCount ));

    if ( DNS_SERVER_CURRENT_CACHE_BYTES > desiredCacheSize )
    {
        STAT_INC( CacheStats.FailedFreePasses );
    }
    else
    {
        STAT_INC( CacheStats.SuccessfulFreePasses );
    }
}   //  enforceCacheLimit



//
//  Timeout thread.
//

DWORD
Timeout_Thread(
    IN      LPVOID  Dummy
    )
/*++

Routine Description:

    Thread to delete expired cached resource records and corresponding
    emptry domain nodes.

Arguments:

    Dummy - unused

Return Value:

    Exit code.
    Exit from DNS service terminating or error in wait call.

--*/
{
    DWORD   err;
    DWORD   waitTime;
    DWORD   nextBinTimeout;
    DWORD   nextDelayedCleanup;
    DWORD   lastUpdateOwnRecordsTime = DNS_TIME();
    DWORD   now;

    HANDLE  arrayWaitHandles[] =
        {
        hDnsCacheLimitEvent,
        hDnsShutdownEvent
        };

    //  save off timeout thread ID

    TimeoutThreadId = GetCurrentThreadId();

    //  hold timeout until started

    if ( ! Thread_ServiceCheck() )
    {
        DNS_DEBUG( ANY, ( "Terminating timeout thread.\n" ));
        return( 1 );
    }

    //  init time base time
    //  force current time, after startup, so base time can not possibly
    //      include any load time

    TimeoutBaseTime = UPDATE_DNS_TIME();
    nextBinTimeout = TimeoutBaseTime + TimeoutInterval;
    nextDelayedCleanup = TimeoutBaseTime + TIMEOUT_FREE_DELAY;

    //
    //  loop until service exit
    //

    while ( TRUE )
    {
        DWORD   timeSlept;

        //  calculate timeout
        //      - nearer of next delayed free or next timeout bin
        //      - note we wait an extra second to allow for slop in DNS_TIME()

        waitTime = nextDelayedCleanup;
        if ( waitTime > nextBinTimeout )
        {
            waitTime = nextBinTimeout;
        }
        waitTime -= DNS_TIME() - 1;

        //  protect against less than zero wrap

        EnterWait:

        if ( ( INT ) waitTime < 0 )
        {
            DNS_DEBUG( ANY, (
                "ERROR:  timeout thread waitTime calculated less than zero!!!\n" ));
            waitTime = 1;
        }

        DNS_DEBUG( TIMEOUT, (
            "Entering timeout wait at %d:\n"
            "\ttimebase = %d\n"
            "\tbin      = %d\n"
            "\twait     = %d\n",
            DNS_TIME(),
            TimeoutBaseTime,
            CurrentTimeoutBin,
            waitTime ));

        //
        //  Wait for
        //      - timer expiration
        //      - termination event
        //

        timeSlept = UPDATE_DNS_TIME();

        err = WaitForMultipleObjects(
                    sizeof( arrayWaitHandles ) / sizeof( arrayWaitHandles[ 0 ] ),
                    arrayWaitHandles,
                    FALSE,
                    waitTime * 1000 );

        timeSlept = UPDATE_DNS_TIME() - timeSlept;

        //
        //  Check and possibly wait on service status
        //

        if ( ! Thread_ServiceCheck() )
        {
            DNS_DEBUG( ANY, ( "Terminating timeout thread.\n" ));
            return( 1 );
        }

        //
        //  Adjust timeout for time slept in case we just right back up to
        //  the Wait call above. If we don't jump back up we will recalculate
        //  waitTime at the top of the loop.
        //

        waitTime -= timeSlept;

        //
        //  Signalled to enforce cache limit?
        //

        if ( err == WAIT_OBJECT_0 )
        {
            DNS_DEBUG( TIMEOUT, (
                "TimeoutThread: cache limit event at %d\n",
                DNS_TIME() ));
            enforceCacheLimit();
            goto EnterWait;
        }

        //
        //  Normal timeout has occurred.
        //

        ASSERT( err == WAIT_TIMEOUT );

        DNS_DEBUG( TIMEOUT, (
            "Timeout wakeup at %d\n"
            "\tcleanup interval = %d\n"
            "\tnext cleanup     = %d\n"
            "\tcurrent bin      = %d\n"
            "\tcheck bin        = %d\n"
            "\ttimeout interval = %d\n"
            "\tnext timeout     = %d\n",
            DNS_TIME(),
            TIMEOUT_FREE_DELAY,
            nextDelayedCleanup,
            CurrentTimeoutBin,
            CheckTimeoutBin,
            TimeoutInterval,
            nextBinTimeout ));

        //  for timer update
        //  otherwise may not appear to have done complete wait and
        //      tests below could fail by tiny margin

        now = UPDATE_DNS_TIME();

        //
        //  Push the log buffer to disk (if any logging is enabled). This
        //  is not a necessity, but on a server where only a few infrequent
        //  packets are logged it's nice to see them get dumped to disk
        //  every so often.
        //

        if ( SrvCfg_dwLogLevel != 0 )
        {
            Log_PushToDisk();
        }

        //
        //  check for and if necessary start scavenging
        //

        Scavenge_CheckForAndStart( FALSE );

        //
        //  Call tombstone function. This may or may not trigger a tombstone
        //  search-and-destroy thread.
        //

        Tombstone_Trigger();

        //
        //  Update self-registrations. Do this every 20 minutes. The
        //  shortest refresh interval is 60 minutes, so perform refresh
        //  of own records every 20 minute to ensure it will be updated
        //  at least two or three times per refresh interval.
        //

        if ( now > lastUpdateOwnRecordsTime + 20*60 )
        {
            DNS_DEBUG( TIMEOUT, (
                "TimeoutThread: updating own zone records at %d\n"
                "    last done at           %d\n",
                now,
                lastUpdateOwnRecordsTime ));

            Zone_UpdateOwnRecords( FALSE );

            lastUpdateOwnRecordsTime = now;
        }

        //
        //  Free delayed frees
        //
        //  this is done on a faster time scale than timeout bin, so if not
        //  time for a full timeout bin cleanup, cycle back to wait
        //

        if ( DNS_TIME() > nextDelayedCleanup )
        {
            Timeout_CleanupDelayedFreeList();
            nextDelayedCleanup = DNS_TIME() + TIMEOUT_FREE_DELAY;
        }
#if DBG
        else if ( DNS_TIME() < nextBinTimeout )
        {
            DNS_PRINT((
                "\nERROR:  Timeout thread still messed up!!!\n"
                "\tFailed delayed free test; failed timeout bin test!\n"
                "Timeout wakeup at %d\n"
                "\tcleanup interval = %d\n"
                "\tnext cleanup     = %d\n"
                "\tcurrent bin      = %d\n"
                "\tcheck bin        = %d\n"
                "\ttimeout interval = %d\n"
                "\tnext timeout     = %d\n",
                DNS_TIME(),
                TIMEOUT_FREE_DELAY,
                nextDelayedCleanup,
                CurrentTimeoutBin,
                CheckTimeoutBin,
                TimeoutInterval,
                nextBinTimeout ));
        }
#endif
        //
        //  timeout next bin?
        //      - if wokeup only for delayed frees list, then
        //      go back into wait

        if ( DNS_TIME() < nextBinTimeout )
        {
            continue;
        }

        //
        //  reset timeout globals for next interval
        //
        //  to allow recovery from debug session where clock gets
        //  past next timeout interval, we'll just reset TimeoutBaseTime
        //  at current time;  total drift over a cycle will be minimal
        //  and correction to caching bin is made continuously.
        //

        CurrentTimeoutBin++;
        CheckTimeoutBin++;

        DNS_DEBUG( TIMEOUT, (
            "Moving to timeout bin %d\n"
            "\tcheck bin        = %d\n"
            "\ttimeout interval = %d\n"
            "\tprev timebase    = %d\n"
            "\tcurrent time     = %d\n",
            CurrentTimeoutBin,
            CheckTimeoutBin,
            TimeoutInterval,
            TimeoutBaseTime,
            DNS_TIME() ));

        ASSERT( CurrentTimeoutBin == (UCHAR)(CheckTimeoutBin + (UCHAR)2) );
        //ASSERT( nextBinTimeout + TimeoutInterval > DNS_TIME() );

        TimeoutBaseTime = DNS_TIME();
        nextBinTimeout = TimeoutBaseTime + TimeoutInterval;

        //  cleanup expired security sessions

        if ( g_fSecurityPackageInitialized )
        {
            Dns_TimeoutSecurityContextList( 0 );
        }

        //
        //  Check database nodes for timeout
        //

        checkNodesInTimeoutBin( CheckTimeoutBin );

        //
        //  check for exit
        //      - do again here as may be in timeout quite some time,
        //      likely to be aborted in timeout
        //

        if ( fDnsServiceExit )
        {
            DNS_DEBUG( ANY, ( "Terminating expiration timeout thread.\n" ));
            return( 1 );
        }

        //
        //  zone write back timeout
        //
        //  since debug builds have a very short timeout interval, we'll avoid
        //  writing back every time on debug builds;  every fifth time brings
        //  this up to ten minutes, more in line with retail 15minute interval
        //
#if 0
#if DBG
        if ( CurrentTimeoutBin % 5 )
        {
            continue;
        }
#endif
#endif
        Zone_WriteBackDirtyZones( FALSE );
    }
}



//
//  Public timeout functions
//

VOID
Timeout_SetTimeoutOnNodeEx(
    IN OUT  PDB_NODE        pNode,
    IN      DWORD           dwTimeout,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Set timeout on node.

Arguments:

    pNode       -- node to check at timeout

    dwTimeout   -- timeout for caching nodes in seconds

    dwFlag      -- flags, currently is BOOL,
        TIMEOUT_REFERENCE if added from deleting reference to node
        TIMEOUT_PARENT if added from deleting child
        0 for direct timeout

Return Value:

    None.

--*/
{
    UCHAR   binIndex;

    DNS_DEBUG( TIMEOUT, (
        "SetTimeoutOnNodeEx( %p )\n"
        "\tflag     = %lx\n"
        "\ttimeout  = %d\n"
        "\tlabel    = %s\n",
        pNode,
        dwFlag,
        dwTimeout,
        pNode->szLabel ));

    //
    //  never enter node in timeout system more than once
    //  so no need to worry about multiple references to node;
    //  timeout thread does any moving around of nodes.
    //
    //  toss nodes already in timeout system -- before we lock
    //

    if ( IS_TIMEOUT_NODE(pNode) )
    {
        STAT_INC( TimeoutStats.AlreadyInSystem );
        return;
    }

    //  lock node while insert in timeout system

    LOCK_TIMEOUT();

    if ( IS_TIMEOUT_NODE(pNode) )
    {
        STAT_INC( TimeoutStats.AlreadyInSystem );
        goto Unlock;
    }

    SET_TIMEOUT_NODE( pNode );
    SET_NODE_ACCESSED( pNode );

    //
    //  log why we are setting timeout
    //

    if ( dwFlag & TIMEOUT_REFERENCE )
    {
        STAT_INC( TimeoutStats.SetFromDereference );
    }
    else if ( dwFlag & TIMEOUT_PARENT )
    {
        STAT_INC( TimeoutStats.SetFromChildDelete );
    }
    else
    {
        ASSERT( dwFlag == 0 || dwFlag == TIMEOUT_NODE_LOCKED );
        STAT_INC( TimeoutStats.SetDirect );
    }
    STAT_INC( TimeoutStats.SetTotal );

    //
    //  if caching timeout, then determine bin
    //  otherwise default is next bin
    //
    //  determine bin (offset from current) for this timeout
    //      - determine timeout in number of intervals
    //      - then use only mod256
    //

    if ( dwTimeout )
    {
        binIndex = ( UCHAR ) ( ( dwTimeout / TimeoutInterval ) & 0xff );
        DNS_DEBUG( TIMEOUT2, (
            "Timeout bin offset %d for node at %p\n",
            binIndex,
            pNode ));

        //
        //  determine actual bin
        //  note, if CurrentBin increments after calcing offset, we are
        //  still ok, we just end up one bin further along before trying timeout
        //
        //  however restrict so that DO NOT write into CheckBin or CheckBin+1,
        //  as these may be read by timeout thread asynchronously with this call;
        //  write to current bin instead
        //

        if ( binIndex > MAX_ALLOWED_BIN_OFFSET )
        {
            binIndex = 0;
        }
        binIndex += CurrentTimeoutBin;
    }
    else
    {
        binIndex = CurrentTimeoutBin;
    }

    //  insert node in timeout system

    insertPtrInTimeout( pNode, binIndex );
    pNode->uchTimeoutBin = binIndex;

Unlock:

    UNLOCK_TIMEOUT();
}



BOOL
Timeout_ClearNodeTimeout(
    IN OUT  PDB_NODE        pNode
    )
/*++

Routine Description:

    Clear node from timeout bin.

Arguments:

    pNode -- node (or delayed free ptr) to check at timeout

Return Value:

    TRUE -- if pNode removed from timeout
    FALSE -- if timeout thread will clean up

--*/
{
    PTIMEOUT_ARRAY  ptimeoutArray;
    DWORD           i;
    UCHAR           bin = pNode->uchTimeoutBin;


    DNS_DEBUG( TIMEOUT, (
        "Clearing node %p from timeout bin %d\n",
        pNode,
        bin ));

    ASSERT( GetCurrentThreadId() == TimeoutThreadId );

    //
    //  DEVNOTE:  this function should ONLY run under timeout thread
    //      if so can avoid this check and always cleanup
    //
    //  if timeout going on on bin -- stop
    //      - let timeout thread clean up this node
    //
    //  however, all tree deletes on once-active trees, are done by delayed
    //  free, so we should always BE the timeout thread if we get here
    //

    if ( bin == CheckTimeoutBin || bin == CheckTimeoutBin+1 )
    {
        if ( GetCurrentThreadId() != TimeoutThreadId )
        {
            DNS_PRINT((
                "ERROR:  clearing node (%p) timeout outside timeout thread!!!!\n",
                pNode ));
            ASSERT( FALSE );
            return( FALSE );
        }
    }

    //
    //  traverse this bin, until find pNode ptr and remove
    //

    LOCK_TIMEOUT();

    ptimeoutArray = TimeoutBinArray[ bin ];

    while ( 1 )
    {
        if ( !ptimeoutArray )
        {
            break;
        }

        //  check this array block for pNode ptr
        //      - if pNode found, delete it, replace with last ptr in array

        for ( i=0; i < ptimeoutArray->Count; i++ )
        {
            if ( ptimeoutArray->pNode[ i ] == pNode )
            {
                ptimeoutArray->Count--;
                ptimeoutArray->pNode[ i ] = ptimeoutArray->pNode[ ptimeoutArray->Count ];
                goto Done;
            }
        }

        //  check next array block

        ptimeoutArray = ptimeoutArray->pNext;
        continue;
    }

    DNS_DEBUG( ANY, (
        "ERROR:  node %p, not found in timeout bin %d as indicated!\n",
        pNode,
        bin ));
    ASSERT( FALSE );

Done:

    UNLOCK_TIMEOUT();
    return TRUE;
}



//
//  Timeout free
//

VOID
Timeout_FreeWithFunctionEx(
    IN      PVOID           pItem,
    IN      VOID            (*pFreeFunction)( PVOID ),
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    )
/*++

Routine Description:

    Set ptr to be freed after timeout.

Arguments:

    pItem -- item to be freed

    pFreeFunction -- function to free the desired item

    pszFile -- file name of caller

    LineNo -- line number of caller

Return Value:

    None.

--*/
{
    PDELAYED_FREE   pfree;

    //  handle NULL ptrs to simplify calling code

    if ( !pItem )
    {
        return;
    }

    HARD_ASSERT( Mem_VerifyHeapBlock(pItem,0,0) );

    //
    //  allocate timeout free list element
    //

    pfree = (PDELAYED_FREE) ALLOC_TAGHEAP( sizeof(DELAYED_FREE), MEMTAG_TIMEOUT );
    IF_NOMEM( !pfree )
    {
        return;
    }
    pfree->Tag = DELAYED_TAG;
    pfree->pItem = pItem;
    pfree->pFreeFunction = pFreeFunction;
    pfree->pszFile = pszFile;
    pfree->LineNo = LineNo;

    STAT_INC( TimeoutStats.DelayedFreesQueued );
    if ( pFreeFunction )
    {
        STAT_INC( TimeoutStats.DelayedFreesQueuedWithFunction );
    }

    //
    //  Collect delayed frees in a list
    //      - just stick entry on the front of the list
    //

    LOCK_TIMEOUT();
    pfree->pNext = CurrentDelayedFreeList;
    CurrentDelayedFreeList = pfree;
    CurrentDelayedCount++;
    UNLOCK_TIMEOUT();
}



VOID
Timeout_CleanupDelayedFreeList(
    VOID
    )
/*++

Routine Description:

    Cleanup delayed free list.

Arguments:

    None

Return Value:

    None

--*/
{
    PDELAYED_FREE   pfree;
    PDELAYED_FREE   pdeleteList;
    DWORD   count;

    DNS_DEBUG( TIMEOUT, (
        "Executing delayed frees for this timeout interval.\n"
        "\tCurrentDelayedFreeList = %p\n"
        "\tCoolingDelayedFreeList = %p\n",
        CurrentDelayedFreeList,
        CoolingDelayedFreeList ));

    //
    //  switch lists around
    //      - current goes into wait
    //      - wait list can now be deleted
    //
    //  need to do this under lock, to protect queuing
    //

    LOCK_TIMEOUT();
    pdeleteList = CoolingDelayedFreeList;
    CoolingDelayedFreeList = CurrentDelayedFreeList;
    CurrentDelayedFreeList = NULL;

    count = CoolingDelayedCount;
    CoolingDelayedCount = CurrentDelayedCount;
    CurrentDelayedCount = 0;
    UNLOCK_TIMEOUT();

    //
    //  delete entries in Delete list
    //      - since list can be long, check for service exit on each free
    //

    while ( pdeleteList )
    {
        if ( fDnsServiceExit )
        {
            return;
        }
        pfree = pdeleteList;
        pdeleteList = pfree->pNext;
        executeDelayedFree( pfree );
        count--;
    }

    ASSERT( count == 0 );
}



VOID
Timeout_FreeAndReplaceZoneDataEx(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PVOID *         ppZoneData,
    IN      PVOID           pNewData,
    IN      VOID            (*pFreeFunction)( PVOID ),
    IN      LPSTR           pszFile,
    IN      DWORD           LineNo
    )
/*++

Routine Description:

    Timeout free zone data and replace within lock.

    The purpose of the function is to correctly handle the interlocking
    in one place to avoid possiblity of double free from MT access.

Arguments:

    pZone -- zone ptr

    ppZoneData -- addr in zone block of item to free

    pNewData -- ptr to new data

    pFreeFunction -- function to free the desired item

    pszFile -- file name of caller

    LineNo -- line number of caller

Return Value:

    None.

--*/
{
    PVOID   poldData = *ppZoneData;

    //
    //  replace zone data ptr -- within lock
    //

    Zone_UpdateLock( pZone );

    poldData = *ppZoneData;

    *ppZoneData = pNewData;

    Zone_UpdateUnlock( pZone );

    //
    //  timeout free the old data
    //

    Timeout_FreeWithFunctionEx(
        poldData,
        pFreeFunction,
        pszFile,
        LineNo );
}

//
//  End of timeout.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\tree.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    tree.c

Abstract:

    Domain Name System (DNS) Server

    Tree routines.

    DNS server's database will be stored in the form of an Tree,
    matching the global domain space.  I.e. each level of label in a
    domain name will correspond to a level in the Tree.

Author:

    Jim Gilroy (jamesg)     March 1995

Revision History:

--*/


#include "dnssrv.h"


//
//  Child list locking
//
//  Currently just hold database lock.
//
//  DEVNOTE: need node locking, or global read\write locking
//

#define LOCK_CHILD_LIST( pParent )        Dbase_LockDatabase()
#define UNLOCK_CHILD_LIST( pParent )      Dbase_UnlockDatabase()


//
//  Masks for quick compare labels of less than a DWORD in size
//      - & these with label to mask out bytes beyond label length
//

DWORD QuickCompareMask[] =
{
    0,
    0xff000000,
    0xffff0000,
    0xffffff00
};


//
//  At 255 references -- lock node down permanently
//

#define NO_DELETE_REF_COUNT     (0xff)


//
//  Case preservation
//
//  Probably best to just ALWAYS have this on.
//  It doesn't really cost much, and elminates unnecessary option.
//

#define SrvCfg_fCasePreservation    (TRUE)
//#define SrvCfg_fCasePreservation    (FALSE)


//
//  Length of a node
//

#define DB_NODE_LENGTH( _cchLabelLength )                                   \
    ( ( DB_NODE_FIXED_LENGTH ) + ( _cchLabelLength ) +                      \
        ( ( SrvCfg_fCasePreservation ) ? ( _cchLabelLength ) + 1 : 0 ) )


//
//  Private protos
//

DWORD
makeQuickCompareDwordLabel(
    IN      PCHAR   pchLabel,
    IN      DWORD   cchLabel
    );

PCHAR
getDowncasedLabel(
    IN      PDB_NODE        pNode
    );

#define DOWNCASED_NODE_NAME(pnode)  (getDowncasedLabel(pnode))


#ifndef DBG
#define NTreeVerifyNode( pNode )    (TRUE)
#endif

#ifndef DBG
#define NTree_VerifyNode( pNode )    (TRUE)
#endif

BOOL
NTree_VerifyNodeInSiblingList(
    IN      PDB_NODE       pNode
    );



PDB_NODE
NTree_Initialize(
    VOID
    )
/*++

Routine Description:

    Initialize Tree.

    Initializes tree including creation of root node.

Arguments:

    None.

Return Value:

    Ptr to root if successful.
    NULL on error.

--*/
{
    PDB_NODE    pnodeRoot;

    pnodeRoot = NTree_CreateNode( NULL, NULL, 0, 0 );

    //  tree root always zone root
    //      - setting flag makes search terminations on ZONE_ROOT flag safe

    SET_ZONE_ROOT( pnodeRoot );

    return( pnodeRoot );
}



PDB_NODE
NTree_CreateNode(
    IN      PCHAR       pchLabel,
    IN      PCHAR       pchDownLabel,
    IN      DWORD       cchLabelLength,
    IN      DWORD       dwMemTag            //  zero for generic node
    )
/*++

Routine Description:

    Create Tree node.

    This is essentially an allocate and initialize function.

    It handles initialization of
        - name
        - corresponding quick comparision
        - parent link
        - parent's zone
        - parent's child count

    Note, this does NOT INSERT node into the sibling list.

Arguments:

    pchLabel -- label

    pchDownLabel -- downcased label

    cchLabelLength -- label length

    dwMemTag -- mem tag for new node or zero for generic

Return Value:

    Pointer to new node.

--*/
{
    PDB_NODE    pNode;
    DWORD       length;

    if ( cchLabelLength > DNS_MAX_LABEL_LENGTH )
    {
        ASSERT( FALSE );
        return( NULL );
    }

    DNS_DEBUG( DATABASE, (
        "NTree_CreateNode( %.*s, down=%s, tag=%d )\n",
        cchLabelLength,
        pchLabel,
        pchDownLabel,
        dwMemTag ));

    //
    //  allocate node -- use standard allocator
    //

    length = DB_NODE_LENGTH( cchLabelLength );

    pNode = ALLOC_TAGHEAP( length, dwMemTag ? dwMemTag : MEMTAG_NODE );
    IF_NOMEM( !pNode )
    {
        DNS_DEBUG( DATABASE, (
            "Unable to allocate new node for %.*s\n",
            cchLabelLength,
            pchLabel
            ));
        return( NULL );
    }

    STAT_INC( DbaseStats.NodeUsed );
    STAT_INC( DbaseStats.NodeInUse );
    STAT_ADD( DbaseStats.NodeMemory, length );
    PERF_ADD( pcDatabaseNodeMemory , length );       // PerfMon hook

    //
    //  clear all fixed fields
    //

    RtlZeroMemory(
        pNode,
        DB_NODE_FIXED_LENGTH );

    //
    //  write node name
    //      - must NULL terminate so shorter name compares correctly
    //        e.g.  so on compare jamesg < jamesg1
    //

    RtlCopyMemory(
        pNode->szLabel,
        pchLabel,
        cchLabelLength );

    pNode->szLabel[ cchLabelLength ] = 0;
    pNode->cchLabelLength = (UCHAR) cchLabelLength;

    if ( SrvCfg_fCasePreservation )
    {
        PCHAR   pdown = DOWNCASED_NODE_NAME(pNode);

        //  note, i'm not storing DownLabelLength
        //      assuming that it will be the same as original

        RtlCopyMemory(
            pdown,
            pchDownLabel,
            cchLabelLength );

        pdown[ cchLabelLength ] = 0;
    }
#if 0
    //  can't do this until have debug routine that handles node
    //  without associate database context, esp. parents

    IF_DEBUG( DATABASE2 )
    {
        Dbg_DbaseNode(
            "New tree node:\n",
            pNode );
    }
#endif
    DNS_DEBUG( DATABASE2, (
        "Created tree node at 0x%p:\n"
        "\tLabel        = %.*s\n"
        "\tLength       = %d\n",
        pNode,
        cchLabelLength,
        pchLabel,
        cchLabelLength
        ));

    return( pNode );
}



PDB_NODE
NTree_CopyNode(
    IN      PDB_NODE    pNode
    )
/*++

Routine Description:

    Copy a node.

    This is useful in creating temporary nodes for secure update.
    This does NOT correct or fix up node's links in tree.

Arguments:

    pNode   -- node to copy

Return Value:

    Pointer to new node.

--*/
{
    PDB_NODE    pnodeCopy;
    DWORD       length;

    //
    //  allocate node -- use standard allocator
    //

    length = DB_NODE_LENGTH( pNode->cchLabelLength );

    pnodeCopy = ALLOC_TAGHEAP( length, MEMTAG_NODE_COPY );
    IF_NOMEM( !pnodeCopy )
    {
        DNS_DEBUG( DATABASE, (
            "ERROR:  Unable to allocate copy of node %p\n",
            pNode ));
        return( NULL );
    }

    STAT_INC( DbaseStats.NodeUsed );
    STAT_INC( DbaseStats.NodeInUse );
    STAT_ADD( DbaseStats.NodeMemory, length );
    PERF_ADD( pcDatabaseNodeMemory , length );

    //
    //  copy node data
    //

    RtlCopyMemory(
        pnodeCopy,
        pNode,
        length );

    //
    //  clear "inappropriate" flags
    //

    pnodeCopy->wNodeFlags = (pNode->wNodeFlags & NODE_FLAGS_SAVED_ON_COPY);

    DNS_DEBUG( DATABASE2, (
        "Created tree node copy at 0x%p:\n",
        pnodeCopy ));

    return( pnodeCopy );
}



VOID
NTree_FreeNode(
    IN OUT  PDB_NODE    pNode
    )
/*++

Routine Description:

    Free a tree node.

    This is in function as it used both in normal NTree_RemoveNode()
    and in hard subtree delete.

Arguments:

    pNode - node to delete

Return Value:

    None.

--*/
{
    DWORD length;

    //
    //  verify NOT in timeout system
    //      - if in system, just cut node loose, let system clean it up
    //
    //  DEVNOTE: cleanup of nodes in timeout system
    //      need to locate timeout system reference and delete
    //      rogue node is possibly lame
    //

    if ( IS_TIMEOUT_NODE(pNode) )
    {
        //
        //  should only be doing free on nodes in timeout system from
        //      timeout thread -- i.e. delayed tree free
        //
        //  should not have free on node already cut from list
        //  except when timeout thread fires, and it will clear the
        //      TIMEOUT flag in NTree_RemoveNode()

        if ( !Timeout_ClearNodeTimeout(pNode) )
        {
            IF_DEBUG( DATABASE )
            {
                Dbg_DbaseNode(
                    "WARNING:  Unable to free node from timeout system.\n",
                    pNode );
            }
            ASSERT( FALSE );
            //STAT_INC( DebugStats.NodeDeleteFailure );
            return;
        }

        DNS_DEBUG( DATABASE, (
            "Successfully removed node %p (l=%s) from timeout system.\n"
            "\tNow continue with standard node free.\n",
            pNode,
            pNode->szLabel ));
    }

    length = DB_NODE_LENGTH( pNode->cchLabelLength );

    //  note:  may be copy node or regular node so can't tag the free

    FREE_TAGHEAP( pNode, length, 0 );

    STAT_INC( DbaseStats.NodeReturn );
    STAT_DEC( DbaseStats.NodeInUse );
    STAT_SUB( DbaseStats.NodeMemory, length );
    PERF_SUB( pcDatabaseNodeMemory , length );
}



BOOL
NTree_RemoveNode(
    IN OUT  PDB_NODE    pNode
    )
/*++

Routine Description:

    Remove a node from Tree.

    This deletes the node from the tree ONLY if it is legal:
        - no children
        - no RR list
        - no reference count
        - no recent access

    Caller MUST HOLD lock on access to this node AND to child list
    of parent.  In current implementation this means database lock.

    In current implementation this is ONLY called by the timeout
    thread, to cleanup node.

Arguments:

    pNode - node to delete

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    PDB_NODE    pparent;

    ASSERT( pNode != NULL );
    ASSERT( !IS_ON_FREE_LIST(pNode) );

    //
    //  lock
    //
    //  Must hold both database and RR list locks during a delete, because
    //  node access flag may be SET under either:
    //      - Dbase lock, when doing lookup
    //      - Node data (RR list) lock, when doing indirect access
    //
    //  DEVNOTE: zone\tree specific locking for deletes
    //      should pass zone\dbase\lock
    //

    Dbase_LockDatabase();

#if DBG
    NTree_VerifyNode( pNode );
#endif

    //
    //  verify - NO children
    //

    if ( pNode->pChildren != NULL )
    {
        ASSERT( pNode->cChildren );
        DNS_DEBUG( DATABASE, (
            "Fail delete (has children) of node at %p.\n", pNode ));
        goto NoDelete;
    }

    //
    //  TYPE_SPECIFIC:
    //      - verify NO resource records
    //      - verify NO reference count
    //      - NOT recently accessed
    //

    if ( pNode->pRRList && !IS_NOEXIST_NODE(pNode) ||
        pNode->cReferenceCount  ||
        IS_NODE_RECENTLY_ACCESSED(pNode) ||
        IS_NODE_NO_DELETE(pNode) )
    {
        DNS_DEBUG( DATABASE, (
            "Fail delete of node at %p.\n", pNode ));
        goto NoDelete;
    }

    //  database root should have been marked no-delete

    pparent = pNode->pParent;
    ASSERT( pparent );

    //
    //  cut node from sibling list
    //

    NTree_CutNode( pNode );

    //
    //  if removing last child node, then make sure parent is put into timeout system
    //
    //  DEVNOTE: we could have a bit more subtlety here and ignore for zone nodes with
    //      data
    //

    if ( pparent && !pparent->pChildren && !IS_TIMEOUT_NODE( pparent ) )
    {
        Timeout_SetTimeoutOnNodeEx(
            pparent,
            0,
            TIMEOUT_PARENT | TIMEOUT_NODE_LOCKED
            );
    }

    //
    //  delete node
    //      - must clear timeout flag, so NTree_FreeNode() will not
    //      check that we're in timeout system -- which we already know
    //

    Dbase_UnlockDatabase();

    DNS_DEBUG( DATABASE, (
        "Deleted tree node at 0x%p:\n"
        "\tLabel  = %s\n"
        "\tLength = %d\n",
        pNode,
        pNode->szLabel,
        pNode->cchLabelLength ));

    CLEAR_TIMEOUT_NODE( pNode );
    NTree_FreeNode( pNode );
    return( TRUE );

NoDelete:

    //  no delete -- unlock database

    Dbase_UnlockDatabase();
    return( FALSE );
}



VOID
NTree_ReferenceNode(
    IN OUT  PDB_NODE        pNode
    )
/*++

Routine Description:

    Increment reference count of node in database.

Arguments:

    pNode -- ptr to node

Return Value:

    None

--*/
{
    ASSERT( !IS_ON_FREE_LIST(pNode) );

    if ( pNode->cReferenceCount == NO_DELETE_REF_COUNT )
    {
        return;
    }

    Dbase_LockDatabase();
    pNode->cReferenceCount++;
    Dbase_UnlockDatabase();
}



BOOL
FASTCALL
NTree_DereferenceNode(
    IN OUT  PDB_NODE        pNode
    )
/*++

Routine Description:

    Dereference node.

Arguments:

    pNode - node to deref

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    ASSERT( !IS_ON_FREE_LIST(pNode) );

    NTree_VerifyNode( pNode );

    //
    //  dereference
    //
    //  DEVNOTE: currently NOT dereferencing on retail builds
    //  DEVNOTE: hence NEVER timing out referenced nodes
    //
    //  when figure out ref count < 0 bug, then can put back into build
    //

    if ( pNode->cReferenceCount == NO_DELETE_REF_COUNT )
    {
        return( TRUE );
    }

    //  error if already at zero

    if ( pNode->cReferenceCount == 0 )
    {
        DnsDebugLock();
        Dbg_NodeName(
            "ERROR:  Dereferencing zero ref count node ", pNode, "\n" );
        ASSERT( FALSE );
        DnsDebugUnlock();

        Dbase_LockDatabase();
        pNode->cReferenceCount = NO_DELETE_REF_COUNT;
        Dbase_UnlockDatabase();
        return( TRUE );
    }

    Dbase_LockDatabase();
    pNode->cReferenceCount--;

    //
    //  if removing last reference set access so can NOT be cleaned up
    //  while any reference is outstanding;  this makes sure it is at least
    //  a timeout interval before node is deleted
    //
    //  if last ref on leaf node, then make sure node is in timeout system,
    //

    if ( pNode->cReferenceCount == 0 )
    {
        SET_NODE_ACCESSED(pNode);
        Dbase_UnlockDatabase();
        if ( !pNode->pChildren && !IS_TIMEOUT_NODE(pNode) )
        {
            Timeout_SetTimeoutOnNodeEx(
                pNode,
                0,
                TIMEOUT_REFERENCE | TIMEOUT_NODE_LOCKED
                );
        }
    }
    else
    {
        Dbase_UnlockDatabase();
    }

    DNS_DEBUG( DATABASE, (
        "Dereferenced node %p (label=%s), ref count now = %d\n",
        pNode,
        pNode->szLabel,
        pNode->cReferenceCount ));

    return( TRUE );
}



#if DBG
BOOL
NTree_VerifyNode(
    IN      PDB_NODE       pNode
    )
/*++

Routine Description:

    Verify valid tree node.

Arguments:

    pNode - node to verify

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    PDB_RECORD  pRR;

    ASSERT( pNode != NULL );
    ASSERT( !IS_ON_FREE_LIST(pNode) );

    //
    //  verify this node's child list
    //

    IF_DEBUG( DATABASE2 )
    {
        ASSERT( NTree_VerifyChildList( pNode, NULL ) );
    }

    //
    //  verify this node's sibling list
    //

#if 0
    //  this just wastes cycles -- in general we've done the parent on the way in

    if ( pNode->pParent )
    {
        IF_DEBUG( DATABASE2 )
        {
            ASSERT( NTree_VerifyChildList( pNode->pParent, pNode ) );
        }
    }
#endif

    //
    //  verify RR list
    //      - this just AVs if RR list is busted
    //

    if ( !IS_NOEXIST_NODE(pNode) )
    {
        pRR = FIRST_RR( pNode );

        while ( pRR != NULL )
        {
            pRR = pRR->pRRNext;
        }
    }
    return( TRUE );
}
#endif



VOID
NTree_WriteDerivedStats(
    VOID
    )
/*++

Routine Description:

    Write derived statistics.

    Calculate stats dervived from basic record counters.
    This routine is called prior to stats dump.

    Caller MUST hold stats lock.

Arguments:

    None.

Return Value:

    None.

--*/
{
}



//
//  Sibling list architecture
//
//  The sibling list is implemented as a balanced B-tree, with dynamically
//  added hash "nodes" extending this to an N-tree when necessary to limit
//  B-tree size and improve performance.
//
//  Design goals:
//
//  1) not expensive for terminal or single nodes;  in additional to
//  all the terminal nodes, probably half the cached nodes will have
//  a single child (ex. www.mycompany.com);  any method to handle
//  the large zones, must also handle this common case inexpensively
//
//  2) able to handle LARGE zones;  authoritative domains for larger
//  organizations can obviously run above 100,000 hosts;  then if we
//  wish to be a root server we must be able to handle the huge top level
//  domains -- most notably the "com" domain
//
//  3) able to handle large zones, dynamically;  with WINS integration
//  and dynamic DNS we can't assume we can determine load at startup;
//  must be able to handle a large number of nodes DYNAMICALLY entering
//  sibling list and still do efficient lookup
//
//  4) be able to determine large zones dynamically;  with the use of
//  the WEB it will be quite common for SPs and even forwarding servers
//  at larger organizations to build up large "cached" domains;  most
//  obvious is the monstrous "com" domain, but other domains may have
//  similar problems in other organizations or countries and new domain
//  structures may evolve
//
//
//  Implementation details:
//
//  - Sibling list defaults to B-tree.
//  - When B-trees reach a given size, a simple alphabetic hash is added
//    for the next character in the label.  Each bucket in the hash may point
//    to a root of a B-tree for nodes in that bucket.  The nodes of the
//    existing B-tree are then reloaded to spread across these buckets.
//  - Hash expansion is limited to four levels (first four characters of
//    label name).  After that B-trees may grow without bound.
//  - Once created hash "nodes" are not deleted.  Except at parent node
//    delete (hence no nodes in sibling list at all).
//  - The B-trees are kept balanced only when loading database or re-loading
//    nodes into a new hash's buckets.
//
//
//  Why not just a B-Tree?
//  The main reason is that some B-trees would still be very big.  This
//  has two disadvantages:
//  1)  You still touch log(n) nodes which for the largest zones (ex. com)
//      can still run 15-20 levels, and still allows significant chance
//      of unnecessary page faults.
//  2)  More important to make sure you stay reasonably balanced to keep
//      your tree close the the optimium level.  Even limit rebalancing
//      to only during load, this will be a major time ssync, and may
//      make top level domains unloadable.
//
//  Why not always a hash?
//  Essentially because of design goal #1 above. The hash table is much
//  bigger than a node.  We do not want to add this overhead for the many
//  domains which do not need it.
//
//  Why dynamic hashing?
//  Essentially design goal #4 -- big cached domains.  We want efficient
//  lookup for larger cached domains as well as large authoritative zones.
//
//  Why multi-level hash?
//  Same reasons as hashing at all.  Want to restrict B-trees to managable
//  size.  Yet don't want to layout large hash as (since in-order alphabetic)
//  we'd either have to know how the names break down in advance, or we'd
//  waste a lot of space on unused buckets (ex. the zb, zc, zd buckets).
//  Multi-level hash lets amount of hashing adapt dynamically to the names
//  at the domain, putting the required level of hashing at just the right
//  places to keep the B-trees small.
//  Example:
//      Entire z?.com B-tree in one bucket of top level com domain hash.
//      But might even have hash at mic?.com.  Yet no third level hash
//      at mh?.com.
//


//
//  Rebalancing B-Trees
//
//  Global flag indicates that we strictly balance B-trees.  This is
//  sensible during initial load (likely in-order), and when replace
//  B-tree with hash, initializing a set of new B-trees.
//

INT gcFullRebalance = 0;

//
//  Rebalance array -- on stack so make big enough that
//      never overflow even if our count gets messed up
//

#define DEFAULT_REBALANCE_ARRAY_LEN  (500)


INT
NTree_HashTableIndexEx(
    IN      PDB_NODE        pNode,
    IN      PCHAR           pszName,
    IN      UCHAR           cLevel
    );

#define NTree_HashTableIndex( pNode, cLevel ) \
        NTree_HashTableIndexEx( (pNode), NULL, (cLevel) )

PDB_NODE
FASTCALL
NTree_NextHashedNode(
    IN      PSIB_HASH_TABLE pHash,
    IN      PDB_NODE        pNode   OPTIONAL
    );

VOID
NTree_CreateHashAtNode(
    IN      PDB_NODE        pNode
    );

INT
NTree_AddNodeInHashBucket(
    IN      PSIB_HASH_TABLE pHash,
    IN      PDB_NODE        pNode
    );

VOID
NTree_SetNodeAsHashBucketRoot(
    IN      PSIB_HASH_TABLE pHash,
    IN      PDB_NODE        pNode
    );

#if DBG
VOID
Dbg_SiblingHash(
    IN      PSIB_HASH_TABLE pHash
    );
#else
#define Dbg_SiblingHash(pHash)
#endif



//
//  Private tree utils
//

DWORD
makeQuickCompareDwordLabel(
    IN      PCHAR           pchLabel,
    IN      DWORD           cchLabel
    )
/*++

Routine Description:

    Create quick comparison DWORD, from first four bytes of label.

        - downcase
        - byte flip so first label byte in high byte
        - NULL terminate if less than three characters

Arguments:

    pchLabel -- ptr to label

    cchLabel -- count of bytes in label

Return Value:

    DWORD with first four bytes of label downcased.

--*/
{
    DWORD   dwQuickLabel = 0;
    DWORD   i;
    CHAR    ch;

    for ( i=0; i<4; i++ )
    {
        dwQuickLabel <<= 8;

        if ( i < cchLabel )
        {
            ch = *pchLabel++;
            dwQuickLabel += tolower( ch );
        }
    }
    return( dwQuickLabel );
}



PCHAR
getDowncasedLabel(
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Return downcased label for node.

    This simply hides the issue of where downcased label is stored.

Arguments:

    pNode -- ptr to node

Return Value:

    Ptr to downcased label.

--*/
{
    if ( !SrvCfg_fCasePreservation )
    {
        return( pNode->szLabel );
    }
    else
    {
        return( pNode->szLabel + pNode->cchLabelLength + 1 );
    }
}



//
//  B-Tree Rebalancing utilities
//

VOID
btreeReadToArray(
    IN      PDB_NODE        pNode,
    IN      PDB_NODE *      pNodeArray,
    IN      DWORD           dwCount
    )
/*++

Routine Description:

    Read nodes into array.

Arguments:

    pNodeArray - array to hold nodes

    pRootNode - root node of existing B-tree

    dwCount - count of nodes in B-tree

Return Value:

    TRUE if successful.
    FALSE on allocation error.

--*/
{
    DWORD           index = 0;
    PDB_NODE        ptemp;

    //
    //  read existing B-tree into array
    //      - sever root node's uplink to hash (if any) to limit traversal
    //      to sibling nodes in other hash buckets;  (we're only traversing
    //      sibling list in this node's B-tree)
    //      - NULL terminate ptr array;  caller can use this instead of count
    //      to protect against bogus counts
    //

    pNode->pSibUp = NULL;

    while ( ptemp = pNode->pSibLeft )
    {
        pNode = ptemp;
    }
    while ( pNode )
    {
        pNodeArray[index++] = pNode;
        pNode = NTree_NextSibling( pNode );
    }
    ASSERT( index == dwCount );
    pNodeArray[index] = NULL;
}



PDB_NODE
btreeRebalanceLeftJustifyPrivate(
    IN      PDB_NODE *      apNodes,
    IN      DWORD           dwCount
    )
/*++

Routine Description:

    Rebalance B-tree.

    This is a recursive function.  At each level it is called to pick the
    subtree root from the array, then attach it to the result of the
    recursive call on the left and right sides of the array.

Arguments:

    apNodes - array of ptrs to domain nodes

    dwCount - array count

Return Value:

    New B-tree root.

--*/
{
    PDB_NODE        proot;
    PDB_NODE        pleft;
    PDB_NODE        pright;
    DWORD           index;
    DWORD           twoToN;

    ASSERT( dwCount != 0 );

    //
    //  do terminal optimizations
    //
    //  instead of drilling down to NULL, this saves the last couple
    //      of recursions, which will acount for 3/4 of the total
    //      function calls in a real scenario
    //

    if ( dwCount <= 3 )
    {
        if ( dwCount == 1 )
        {
            proot = apNodes[0];
            proot->pSibLeft = NULL;
            proot->pSibRight = NULL;
        }
        else if ( dwCount == 2 )
        {
            pleft = apNodes[0];
            proot = apNodes[1];

            proot->pSibLeft = pleft;
            proot->pSibRight = NULL;

            pleft->pSibUp = proot;
            pleft->pSibLeft = NULL;
            pleft->pSibRight = NULL;
        }
        else    // dwCount == 3
        {
            pleft = apNodes[0];
            proot = apNodes[1];
            pright = apNodes[2];

            proot->pSibLeft = pleft;
            proot->pSibRight = pright;

            pleft->pSibUp = proot;
            pleft->pSibLeft = NULL;
            pleft->pSibRight = NULL;

            pright->pSibUp = proot;
            pright->pSibLeft = NULL;
            pright->pSibRight = NULL;
        }
        return( proot );
    }

    //
    //  find next lowest 2**N value
    //

    twoToN = 1;
    index = dwCount;
    while( (index >>= 1) )
    {
        twoToN <<= 1;
    }

    //
    //  find b-tree root index
    //
    //  example (N=3);  8 <= dwCount <= 15
    //      count   index
    //          8       4
    //          9       5
    //         10       6
    //         11       7
    //         12       7
    //         13       7
    //         14       7
    //         15       7
    //

    index = (twoToN >> 1) + (dwCount - twoToN);
    if ( index > twoToN )
    {
        index = twoToN;
    }
    index--;

    //
    //  get root node
    //      - point at parent
    //

    proot = apNodes[index];

    //
    //  balance left side
    //      - nodes in array from 0 to index-1
    //

    ASSERT( index );

    pleft = btreeRebalanceLeftJustifyPrivate(
                apNodes,
                index );
    proot->pSibLeft = pleft;
    pleft->pSibUp = proot;

    //
    //  balance right side
    //      - nodes in array from index+1 to dwCount-1

    index++;
    dwCount -= index;
    ASSERT( dwCount );

    pright = btreeRebalanceLeftJustifyPrivate(
                &apNodes[index],
                dwCount );
    proot->pSibRight = pright;
    pright->pSibUp = proot;

    //
    //  reset root balance
    //

    return( proot );
}



VOID
btreeRebalance(
    IN      PDB_NODE        pRootNode,
    IN      DWORD           dwCount
    )
/*++

Routine Description:

    Rebalance B-tree.

Arguments:

    pNodeArray - array to hold nodes

    pRootNode - root node of existing B-tree

    dwCount - count of nodes in B-tree

Return Value:

    TRUE if successful.
    FALSE on allocation error.

--*/
{
    PDB_NODE        arrayNodes[ DEFAULT_REBALANCE_ARRAY_LEN ];
    PDB_NODE *      pnodeArray = arrayNodes;
    PDB_NODE        pnodeUp;
    PDB_NODE *      ppnodeRoot;

    //
    //  verify that have space for rebalance
    //

    if ( dwCount > DEFAULT_REBALANCE_ARRAY_LEN )
    {
        pnodeArray = (PDB_NODE *) ALLOCATE_HEAP( dwCount * sizeof(PDB_NODE) );
        IF_NOMEM( !pnodeArray )
        {
            return;
        }
        ASSERT( FALSE );
    }

    //
    //  save uplink info
    //      - up itself
    //      - addr of ptr in up that points at root
    //

    pnodeUp = pRootNode->pSibUp;

    if ( !pnodeUp )
    {
        ppnodeRoot = & pRootNode->pParent->pChildren;
    }
    else if ( IS_HASH_TABLE(pnodeUp) )
    {
        ppnodeRoot = NULL;
    }
    else if ( pnodeUp->pSibLeft == pRootNode )
    {
        ppnodeRoot = & pnodeUp->pSibLeft;
    }
    else
    {
        ASSERT( pnodeUp->pSibRight == pRootNode );
        ppnodeRoot = & pnodeUp->pSibRight;
    }

    //
    //  read B-tree into array
    //

    btreeReadToArray(
        pRootNode,
        pnodeArray,
        dwCount );

    //
    //  rebalance then reattach
    //

    pRootNode = btreeRebalanceLeftJustifyPrivate(
                    pnodeArray,
                    dwCount );

    if ( ppnodeRoot )
    {
        *ppnodeRoot = pRootNode;
        pRootNode->pSibUp = pnodeUp;
    }
    else    //  up node is hash
    {
        NTree_SetNodeAsHashBucketRoot(
            (PSIB_HASH_TABLE) pnodeUp,
            pRootNode );
    }

    if ( dwCount > DEFAULT_REBALANCE_ARRAY_LEN )
    {
        FREE_HEAP( pnodeArray );
    }
    IF_DEBUG( BTREE2 )
    {
        Dbg_SiblingList(
            "B-tree after rebalance:\n",
            pRootNode );
    }
}



//
//  Hash Table Routines
//

INT
NTree_HashTableIndexEx(
    IN      PDB_NODE        pNode,
    IN      PCHAR           pszName,
    IN      UCHAR           cLevel
    )
/*++

Routine Description:

    Find index to hash table.

Arguments:

    pszName - name, MUST be downcased

    cLevel - hash table level

Return Value:

    Index into hash table.

--*/
{
    PCHAR   pname;
    UCHAR   ch;
    INT     i;

    //  if passing in name, use it

    if ( pszName )
    {
        pname = pszName;
    }

    //  if node, use downcased name for node

    else
    {
        pname = DOWNCASED_NODE_NAME(pNode);
    }

    //  must rule out walking off end of name
    //      since not given name length

    i = 0;
    do
    {
        ch = (UCHAR) pname[i];
        if ( ch == 0 )
        {
            return( 0 );
        }
        i++;
    }
    while( i <= cLevel );

    return( (INT)ch );

#if 0
    //
    //  There's a huge problem with hashes that don't completely
    //  discriminate between every character.
    //  Essentially they end up putting several characters together
    //  in a hash bucket making it less simple to discriminate at
    //  the next level in the hash.
    //
    //  Example:
    //      ep
    //      ep-7
    //      ep0-
    //      ep08
    //  at in zero bucket for third character.  Hashing fourth character
    //  is now more complicated (ep-7 is < ep0-, so can't be in '7' bucket).
    //
    //  Now, it is possible to check previous characters against a "standard"
    //  character for their bucket and determine that it was lesser and
    //  hence for all further hashing always goes into zero bucket OR was
    //  greater and hence for all further caching goes into MAX bucket.
    //
    //  The huge disadvantage of this is UTF8.  You must either include all
    //  characters OR you quickly lose hashing as all names are confined to
    //  0 or MAX buckets as you hash down.
    //
    //  So either do a specialized UTF8-expando-hash, or you might as well
    //  use 0-255 hash from the get go.
    //

    DWORD   indexBucket;
    INT     i;

    //
    //  find character to index hash
    //      push through name until reach desired index
    //      - this protects us from end of name problem
    //
    //  JBUBUG:  could eliminate by passing name and namelength
    //      which still requires strlen on lookup name
    //      for any realistic case this loop terminates quickly
    //

    i = 0;
    do
    {
        indexBucket = (UCHAR) pszName[i];
        if ( indexBucket == 0 )
        {
            return( 0 );
        }
        i++;
    }
    while( i <= cLevel );

    ASSERT( indexBucket > 'Z' || indexBucket < 'A' );

    //
    //  determine hash bucket index for character
    //
    //  note:  obviously there are better hashes, BUT I want to hash
    //      and maintain sorted order for writing back to files and
    //      enumerating nodes to admin tool;  also the secure NAME_ERROR
    //      responses (if implemented) will require knowledge of ordering
    //      withing a zone;
    //      for the main purpose of chopping down the B-tree size simply
    //      using character is good enough, probably within a
    //      factor of two of a perfect hash
    //
    //  Note also that main emphasis is on forward lookup zones.
    //  Reverse lookup nodes will only have 256 children which make
    //  would only be depth 8 tree, and most reverse nodes start with
    //  '1' or '2'.  We hash only to avoid breaking out a multiple hash
    //  depth.
    //
    //  chars   hash bucket
    //  -----   -----------
    //  < 0         0
    //  0 - 9       0 - 9
    //  9< - <a     9
    //  a - z       10 - 35
    //  > z         35
    //

    if ( indexBucket >= 'a' )
    {
        indexBucket -= ('a' - 10);
        if ( indexBucket > LAST_HASH_INDEX )
        {
            indexBucket = LAST_HASH_INDEX;
        }
    }
    else if ( indexBucket >= '0' )
    {
        indexBucket -= '0';
        if ( indexBucket > 9 )
        {
            indexBucket = 9;
        }
    }
    else
    {
        indexBucket = 0;
    }

    ASSERT( indexBucket <= LAST_HASH_INDEX );
    return( (INT)indexBucket );
#endif
}



PDB_NODE
FASTCALL
NTree_NextHashedNode(
    IN      PSIB_HASH_TABLE pHash,
    IN      PDB_NODE        pNode   OPTIONAL
    )
/*++

Routine Description:

    Get next sibling of node.

Arguments:

    pHash -- hash containing sibling node

    pNode -- node in sibling list;  if not given, get first node of parent

Return Value:

    None.

--*/
{
    PDB_NODE        ptemp;
    INT             index;

    ASSERT( pHash && IS_HASH_TABLE(pHash) );

    DNS_DEBUG( BTREE2, (
        "NTree_NextHashedNode()\n"
        "\tlevel = %d\n"
        "\tcurrent = %s\n",
        pHash->cLevel,
        pNode ? pNode->szLabel : NULL ));

    //
    //  if node given, find its index -- will start at next index
    //  no node, start at 0
    //

    index = 0;
    if ( pNode )
    {
        index = NTree_HashTableIndex( pNode, pHash->cLevel );
        index++;
    }

    //
    //  find hash bucket that contains node(s)
    //

    while( 1 )
    {
        //  if out of buckets
        //      - check for hashing at next level up and continue
        //      - if out of levels, no more siblings, done

        if ( index > LAST_HASH_INDEX )
        {
            if ( pHash->cLevel == 0 )
            {
                return( NULL );
            }
            index = (INT) pHash->iBucketUp + 1;
            ASSERT( pHash->pHashUp );
            ASSERT( pHash->pHashUp->cLevel == pHash->cLevel-1 );
            ASSERT( pHash->pHashUp->aBuckets[index-1] == (PDB_NODE)pHash );
            pHash = pHash->pHashUp;
            continue;
        }

        //  get node (or hash) at hash bucket
        //  if empty bucket, move to next

        ptemp = pHash->aBuckets[index];
        if ( !ptemp )
        {
            index++;
            continue;
        }

        //  hashing at next level down?

        if ( IS_HASH_TABLE(ptemp) )
        {
            ASSERT( ((PSIB_HASH_TABLE)ptemp)->pHashUp == pHash );
            ASSERT( ((PSIB_HASH_TABLE)ptemp)->iBucketUp == index );
            ASSERT( ((PSIB_HASH_TABLE)ptemp)->cLevel == pHash->cLevel+1 );
            pHash = (PSIB_HASH_TABLE)ptemp;
            index = 0;
            continue;
        }

        //  otherwise ptemp is valid B-tree root

        break;
    }

    //
    //  drops here when find bucket with domain node at B-tree top
    //  find leftmost node in B-tree for this bucket
    //

    while( pNode = ptemp->pSibLeft )
    {
        ptemp = pNode;
    }
    return( ptemp );
}



VOID
NTree_CreateHashAtNode(
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Replace sibling B-tree with hash.

Arguments:

    pNode -- root of sibling B-tree to be replaced by hash

Return Value:

    None.

--*/
{
    PSIB_HASH_TABLE phashTable;
    PDB_NODE        pnodeParent = pNode->pParent;
    PDB_NODE        pnodeNext;
    PSIB_HASH_TABLE phashUp = (PSIB_HASH_TABLE) pNode->pSibUp;
    INT             index;
    INT             count;          //  count of nodes
    INT             ihash;          //  hash bucket index
    INT             ihashCurrent;   //  index of bucket being filled
    INT             iarray;         //  array of nodes index
    INT             iarrayStart;    //  index of first node in bucket
    INT             bucketCount;    //  num of nodes in bucket
    PDB_NODE        arrayNodes[DEFAULT_REBALANCE_ARRAY_LEN];

    ASSERT( pNode );
    ASSERT( phashUp == NULL || IS_HASH_TABLE(phashUp) );

    DNS_DEBUG( BTREE, (
        "Switching node to hashed sibling list:\n"
        "\tparent node label %s\n"
        "\tchild B-tree node %s\n",
        pnodeParent->szLabel,
        pNode->szLabel ));

    //
    //  create hash table
    //

    phashTable = (PSIB_HASH_TABLE) ALLOC_TAGHEAP_ZERO( sizeof(SIB_HASH_TABLE), MEMTAG_NODEHASH );
    IF_NOMEM( !phashTable )
    {
        DNS_PRINT((
            "ERROR:  Memory allocation failure creating hash table"
            "\tat sibling node %s\n",
            pNode->szLabel ));
        return;
    }

    //
    //  init hash table
    //      - set hash flag
    //      - set level
    //      - link to parent or higher level hash
    //      - get count
    //

    SET_HASH_FLAG(phashTable);

    if ( phashUp )
    {
        phashTable->pHashUp = phashUp;
        phashTable->cLevel = phashUp->cLevel + 1;

        ihash = NTree_HashTableIndex( pNode, phashUp->cLevel );

        ASSERT( phashUp->aBuckets[ihash] == pNode );

        phashUp->aBuckets[ihash] = (PDB_NODE)phashTable;
        phashTable->iBucketUp = (UCHAR) ihash;
        count = phashUp->aBucketCount[ihash];
    }
    else
    {
        pnodeParent->pChildren = (PDB_NODE)phashTable;
        count = pnodeParent->cChildren;
    }

    //
    //  build node array from existing b-tree
    //
    //  DEVNOTE: should return count so that if count is off, we're
    //      still ok (other alternative would be to zero ptr to signify end)
    //

    ASSERT( count < DEFAULT_REBALANCE_ARRAY_LEN );
    btreeReadToArray(
        pNode,
        arrayNodes,
        count );

    //
    //  read node array into hash table
    //
    //  find all nodes in each hash bucket, then
    //      - build new B-tree
    //      - link B-tree root to hash table
    //      - set bucket count

    iarray = -1;
    iarrayStart = 0;
    ihash = 0;
    ihashCurrent = 0;

    IF_DEBUG( BTREE2 )
    {
        DWORD i = 0;;
        Dbg_Lock();
        DNS_PRINT((
            "B-tree nodes to hash:\n"
            "\tcLevel       = %d\n"
            "\tcount        = %d\n",
            phashTable->cLevel,
            count ));
        while ( arrayNodes[i] )
        {
            Dbg_DbaseNode( NULL, arrayNodes[i] );
            i++;
        }
        Dbg_Unlock();
    }

    while( 1 )
    {
        //  get hash index for next node
        //      - if same as previous node, continue

        pnodeNext = arrayNodes[++iarray];

        if ( pnodeNext )
        {
            ihash = NTree_HashTableIndex(
                        pnodeNext,
                        phashTable->cLevel );

            //  DEVNOTE:  when confident this never happens, pullout debug
            //ASSERT( ihash >= ihashCurrent );
            if ( ihash < ihashCurrent )
            {
                DWORD i = 0;;

                Dbg_Lock();
                DNS_PRINT((
                    "ERROR:  broken B-tree ordering!!!\n"
                    "\tcLevel       = %d\n"
                    "\tcount        = %d\n"
                    "\tiarray       = %d\n"
                    "\tiarrayStart  = %d\n"
                    "\tpnode        = %p (l=%s)\n"
                    "\tihash        = %d\n"
                    "\tihashCurrent = %d\n",
                    phashTable->cLevel,
                    count,
                    iarray,
                    iarrayStart,
                    pnodeNext, pnodeNext->szLabel,
                    ihash,
                    ihashCurrent ));

                DnsDbg_Flush();

                while ( arrayNodes[i] )
                {
                    Dbg_DbaseNode( NULL, arrayNodes[i] );
                    i++;
                }
                Dbg_Unlock();

                ASSERT( ihash >= ihashCurrent );
            }

            if ( ihash == ihashCurrent )
            {
                continue;
            }
        }

        //  node is not in same bucket as previous
        //
        //  build B-tree for previous hash bucket
        //      non-zero test required for startup

        bucketCount = iarray - iarrayStart;
        if ( bucketCount > 0 )
        {
            pNode = btreeRebalanceLeftJustifyPrivate(
                        &arrayNodes[iarrayStart],
                        bucketCount );

            phashTable->aBuckets[ ihashCurrent ] = pNode;
            phashTable->aBucketCount[ ihashCurrent ] = (UCHAR)bucketCount;
            pNode->pSibUp = (PDB_NODE) phashTable;
        }

        //  reset to build next bucket

        if ( pnodeNext )
        {
            iarrayStart = iarray;
            ihashCurrent = ihash;
            continue;
        }
        break;
    }

    IF_DEBUG( BTREE )
    {
        DNS_PRINT(( "New hash table replacing overflowing B-tree:\n" ));
        Dbg_SiblingHash( phashTable );
    }
}



INT
NTree_AddNodeInHashBucket(
    IN      PSIB_HASH_TABLE pHash,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Add node in hash bucket.
    This keeps count of nodes in buckets, and opens new hash
    when necessary.

Arguments:

    pHash -- hash containing sibling node

    pNode -- node in sibling list under hash

Return Value:

    TRUE if node added in hash bucket without incident.
    FALSE if adding node required new secondary hash.

--*/
{
    INT index;

    ASSERT( IS_HASH_TABLE(pHash) );
    ASSERT( !IS_HASH_TABLE(pNode) );

    //
    //  track nodes in each hash bucket
    //      - break out new secondary hashes as necessary
    //
    //  note:  tracking counts even in last hash bucket, so that we can
    //      easily rebalance them during load
    //

    index = NTree_HashTableIndex(
                pNode,
                pHash->cLevel
                );
    pHash->aBucketCount[index]++;

    ASSERT( pHash->cLevel < 63 );

    //
    //  note:  may be desirable to use different (higher) hash limit for
    //      these interior hashes to avoid overhead
    //
    //  zero level hash works well as decent distribution across characters
    //  however interior characters distribute much less effectively
    //  because of "vowel problem" (ex. no names start with mb)
    //

    if ( pHash->aBucketCount[index] >= HASH_BUCKET_MAX0 )
    {
        ASSERT( pHash->aBuckets[index] );
        ASSERT( !IS_HASH_TABLE(pHash->aBuckets[index]) );
        NTree_CreateHashAtNode( pHash->aBuckets[index] );
        return( FALSE );
    }

    return( TRUE );
}



VOID
NTree_DeleteNodeInHashBucket(
    IN      PDB_NODE        pNodeUp,
    IN      PDB_NODE        pNodeCut,
    IN      PDB_NODE        pNodeReplace
    )
/*++

Routine Description:

    Remove node from hash bucket.

    This is called after node has been removed from B-tree,
    and we only need to update hash count and possibly bucket root.

Arguments:

    pNodeUp -- node above cut node in b-tree (may be hash)

    pNodeCut -- node being cut from tree

    pNodeReplace -- node replacing node being cut (may be NULL)

Return Value:

    None

--*/
{
    PSIB_HASH_TABLE phash = (PSIB_HASH_TABLE)pNodeUp;
    INT index;

    ASSERT( pNodeUp );
    ASSERT( !IS_HASH_TABLE(pNodeCut) );
    ASSERT( !pNodeReplace || !IS_HASH_TABLE(pNodeReplace) );

    //
    //  find hash node and decrement appropriate bucket count
    //

    while ( !IS_HASH_TABLE(phash) )
    {
        phash = (PSIB_HASH_TABLE) ((PDB_NODE)phash)->pSibUp;
    }
    index = NTree_HashTableIndex(
                pNodeCut,
                phash->cLevel
                );

    phash->aBucketCount[index]--;

    //
    //  if cutting old hash bucket root, then replace
    //

    if ( phash->aBuckets[index] == pNodeCut )
    {
        ASSERT( phash == (PSIB_HASH_TABLE)pNodeUp );
        phash->aBuckets[index] = pNodeReplace;
    }
    ELSE_ASSERT( phash != (PSIB_HASH_TABLE)pNodeUp
        && phash->aBucketCount[index] > 0 );
}



VOID
NTree_SetNodeAsHashBucketRoot(
    IN      PSIB_HASH_TABLE pHash,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Set node as hash bucket's B-tree root.

Arguments:

    pHash -- hash containing sibling node

    pNode -- node in sibling list to be bucket's B-tree root

Return Value:

    None

--*/
{
    INT index;

    ASSERT( IS_HASH_TABLE(pHash) );
    ASSERT( !IS_HASH_TABLE(pNode) );

    index = NTree_HashTableIndex(
                pNode,
                pHash->cLevel
                );

    pHash->aBuckets[index] = pNode;
    pNode->pSibUp = (PDB_NODE) pHash;
}



VOID
NTree_HashRebalance(
    IN      PSIB_HASH_TABLE pHash
    )
/*++

Routine Description:

    Rebalance all B-trees in this and underlying hashes.

    Note this function calls itself recursively to balance B-trees in
    underlying hashes.

Arguments:

    pHash -- hash containing sibling node

Return Value:

    None.

--*/
{
    INT             i;
    PDB_NODE        ptemp;

    ASSERT( pHash && IS_HASH_TABLE(pHash) );

    IF_DEBUG( BTREE2 )
    {
        DNS_PRINT((
            "NTree_HashRebalance()\n"
            "\tlevel = %d\n",
            pHash->cLevel ));
    }

    //
    //  check each hash bucket
    //      - nothing ignore
    //      - if normal node, rebalance btree
    //      - if next level down is hash, recurse

    for (i=0; i<=LAST_HASH_INDEX; i++)
    {
        ptemp = pHash->aBuckets[i];
        if ( !ptemp )
        {
            ASSERT( pHash->aBucketCount[i] == 0 );
            continue;
        }
        if ( IS_HASH_TABLE(ptemp) )
        {
            NTree_HashRebalance( (PSIB_HASH_TABLE)ptemp );
        }
        else
        {
            btreeRebalance(
                ptemp,
                pHash->aBucketCount[i] );
        }
    }
}



//
//  Debug routines
//

#if DBG

#define BLANK_STRING    "| | | | | | | | | | | | | | | | | | | | | | | | | |"


VOID
Dbg_SiblingBTree(
    IN      PDB_NODE        pNode,
    IN      INT             iIndent
    )
/*++

Routine Description:

    Debug print subtree of sibling B-Tree.

    NOTE:   This function should NOT BE CALLED DIRECTLY!
            This function calls itself recursively and hence to avoid
            unnecessary overhead, prints in this function are not protected.

Arguments:

    pNode - root node of tree/subtree to print

    iIndent - indent level

Return Value:

    None.

--*/
{
    ASSERT( !IS_HASH_TABLE(pNode) );

    //  print left subtree

    if ( pNode->pSibLeft )
    {
        Dbg_SiblingBTree(
            pNode->pSibLeft,
            iIndent + 1 );
    }

    //  print the node

    DnsPrintf(
        "%.*s%s (me=%p, l=%p, r=%p, up=%p)\n",
        (iIndent << 1),
        BLANK_STRING,
        pNode->szLabel,
        pNode,
        pNode->pSibLeft,
        pNode->pSibRight,
        pNode->pSibUp );

    //  print right subtree

    if ( pNode->pSibRight )
    {
        Dbg_SiblingBTree(
            pNode->pSibRight,
            iIndent + 1 );
    }
}



VOID
Dbg_SiblingHash(
    IN      PSIB_HASH_TABLE pHash
    )
/*++

Routine Description:

    Print sibling hash table.

Arguments:

    pHash - child hash table to print

Return Value:

    None

--*/
{
    INT             index;
    INT             indentLevel;
    PDB_NODE        pnode;
    INT             count;

    ASSERT( pHash != NULL );
    ASSERT( IS_HASH_TABLE(pHash) );

    DnsDebugLock();

    //
    //  print hash info
    //

    indentLevel = pHash->cLevel;

    DnsPrintf(
        "%.*sHashTable %p (l=%d, upbuck=%d, up=%p)\n",
        (indentLevel << 1),
        BLANK_STRING,
        pHash,
        pHash->cLevel,
        pHash->iBucketUp,
        pHash->pHashUp );

    indentLevel++;

    //
    //  print hash buckets
    //

    indentLevel <<= 1;

    for (index=0; index<=LAST_HASH_INDEX; index++)
    {
        pnode = pHash->aBuckets[index];
        count = pHash->aBucketCount[index];

        if ( !pnode )
        {
            ASSERT( count == 0 );
            DnsPrintf(
                "%.*sBucket[%d] => NULL\n",
                indentLevel,
                BLANK_STRING,
                index );
        }
        else
        {
            ASSERT( count > 0 );
            DnsPrintf(
                "%.*sBucket[%d] (c=%d) (%s=%p):\n",
                indentLevel,
                BLANK_STRING,
                index,
                count,
                IS_HASH_TABLE(pnode) ? "hash" : "node",
                pnode );

            IF_DEBUG( BTREE2 )
            {
                if ( IS_HASH_TABLE(pnode) )
                {
                    Dbg_SiblingHash( (PSIB_HASH_TABLE)pnode );
                }
                else
                {
                    Dbg_SiblingBTree( pnode, indentLevel );
                }
            }
        }
    }
    DnsPrintf(
        "%.*sEnd level %d hash %p.\n\n",
        (pHash->cLevel << 1),
        BLANK_STRING,
        pHash->cLevel,
        pHash );

    DnsDebugUnlock();
}



VOID
Dbg_SiblingList(
    IN      LPSTR           pszHeader,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Debug print subtree of sibling B-Tree.

Arguments:

    pszHeader - header for B-Tree

    pNode - root node of tree/subtree to print

Return Value:

    None.

--*/
{
    DnsDebugLock();

    DnsPrintf(
        "%s\n",
        pszHeader );

    if ( !pNode )
    {
        DnsPrintf( "\tNULL node\n" );
    }
    else if ( IS_HASH_TABLE(pNode) )
    {
        Dbg_SiblingHash(
            (PSIB_HASH_TABLE) pNode );
    }
    else
    {
        Dbg_SiblingBTree(
            pNode,
            0 );
        DnsPrintf( "\n" );
    }

    DnsDebugUnlock();
}



DWORD
NTree_VerifyChildBTree(
    IN      PDB_NODE        pNode,
    IN      PDB_NODE        pParent,
    IN      PDB_NODE        pNodeChild,     OPTIONAL
    IN      PDWORD          pfFoundChild    OPTIONAL
    )
/*++

Routine Description:

    Verify valid child list for node.

Arguments:

    pNode - node in sibling list to verify

    pParent - DNS parent node

    pNodeChild - node that should be in child list

    pfFoundChild - flag to set if pNodeChild found

Return Value:

    Number of BTree nodes in node's subtree (including node itself).

--*/
{
    PDB_NODE        pleft;
    PDB_NODE        pright;
    DWORD           cleft;
    DWORD           cright;

    ASSERT( pNode != NULL );

    //
    //  verify parent
    //      - can not be its own parent
    //

    if( pNode->pParent != pParent )
    {
        DNS_PRINT((
            "ERROR:  Node (%p) in child list has incorrect parent.\n"
            "\texpected parent = %p\n"
            "\tpnode->pParent = %p\n",
            pNode,
            pParent,
            pNode->pParent ));
        Dbg_DnsTree( "ERROR:  Self-parenting node", pNode );
        ASSERT( FALSE );
        return( FALSE );
    }
    ASSERT( pNode != pParent );

    //
    //  is child we are verifying?
    //

    if ( pNode == pNodeChild )
    {
        *pfFoundChild = TRUE;
    }

    //
    //  verify left
    //

    pleft = pNode->pSibLeft;
    cleft = 0;
    if ( pleft )
    {
        ASSERT( pleft->pSibUp == pNode );
        cleft = NTree_VerifyChildBTree(
                    pleft,
                    pParent,
                    pNodeChild,
                    pfFoundChild );
    }

    //
    //  verify right
    //

    pright = pNode->pSibRight;
    cright = 0;
    if ( pright )
    {
        ASSERT( pright->pSibUp == pNode );
        cright = NTree_VerifyChildBTree(
                    pright,
                    pParent,
                    pNodeChild,
                    pfFoundChild );
    }

    return( cright+cleft+1 );
}



DWORD
NTree_VerifyChildHash(
    IN      PSIB_HASH_TABLE pHash,
    IN      PDB_NODE        pParent,
    IN      PDB_NODE        pNodeChild,     OPTIONAL
    IN      PDWORD          pfFoundChild    OPTIONAL
    )
/*++

Routine Description:

    Verify valid child hash table.

Arguments:

    pHash - child hash table to verify

    pParent - DNS parent node

    pNodeChild - node that should be in child list

    pfFoundChild - flag to set if pNodeChild found

Return Value:

    Number of BTree nodes in node's subtree (including node itself).

--*/
{
    INT             index;
    PDB_NODE        pnode;
    DWORD           countChildren;
    DWORD           countTotalChildren = 0;

    ASSERT( pHash != NULL );
    ASSERT( IS_HASH_TABLE(pHash) );
    ASSERT( pHash->pHashUp || pParent->pChildren == (PDB_NODE)pHash );

    //
    //  verify hash or B-tree for each bucket
    //

    for (index=0; index<=LAST_HASH_INDEX; index++)
    {
        pnode = pHash->aBuckets[index];

        if ( !pnode )
        {
            ASSERT( pHash->aBucketCount[index] == 0 );
            continue;
        }

        else if ( IS_HASH_TABLE(pnode) )
        {
            ASSERT( ((PSIB_HASH_TABLE)pnode)->pHashUp == pHash );
            ASSERT( ((PSIB_HASH_TABLE)pnode)->cLevel == pHash->cLevel+1 );
            ASSERT( ((PSIB_HASH_TABLE)pnode)->iBucketUp == index );

            countChildren = NTree_VerifyChildHash(
                                (PSIB_HASH_TABLE)pnode,
                                pParent,
                                pNodeChild,
                                pfFoundChild );
        }

        //  verify B-tree for bucket
        //  except at last hash level -- where there is no limit
        //  on the number of nodes and hence they don't necessarily
        //  fit in our counter -- the B-tree size should match our
        //  bucket count

        else
        {
            countChildren = NTree_VerifyChildBTree(
                                pnode,
                                pParent,
                                pNodeChild,
                                pfFoundChild );

            ASSERT( countChildren == (DWORD)pHash->aBucketCount[index] );
        }

        countTotalChildren += countChildren;
    }

    return( countTotalChildren );
}



BOOL
NTree_VerifyChildList(
    IN      PDB_NODE        pNode,
    IN      PDB_NODE        pNodeChild      OPTIONAL
    )
/*++

Routine Description:

    Verify valid child list for node.

Arguments:

    pNode - node to verify child list of

    pNodeChild - optional node that should be in child list

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    PDB_NODE        pchild;
    DWORD           countChildren;
    BOOL            foundChild = FALSE;

    ASSERT( pNode != NULL );

    //
    //  no children
    //

    pchild = pNode->pChildren;
    if ( !pchild )
    {
        if ( pNode->cChildren != 0 )
        {
            DNS_PRINT((
                "ERROR:  Node (%s) has child count %d but no child list!\n"
                "\tpNode = %p\n"
                "\tcountChildren = %d\n",
                pNode->szLabel,
                pNode,
                pNode->cChildren ));
            ASSERT( pNode->cChildren == 0 );
            return( FALSE );
        }
        return( TRUE );
    }

    //
    //  first level hash
    //

    if ( IS_HASH_TABLE(pchild) )
    {
        countChildren = NTree_VerifyChildHash(
                            (PSIB_HASH_TABLE)pchild,
                            pNode,
                            pNodeChild,
                            & foundChild );
    }

    //
    //  B-tree only
    //

    else
    {
        countChildren = NTree_VerifyChildBTree(
                            pchild,
                            pNode,
                            pNodeChild,
                            & foundChild );
    }

    if ( pNode->cChildren != countChildren )
    {
        DNS_PRINT((
            "WARNING:  Node (%s) child count does not match child list length.\n"
            "\tpNode = %p\n"
            "\tcountChildren = %d\n"
            "\tcount found   = %d\n",
            pNode->szLabel,
            pNode,
            pNode->cChildren,
            countChildren ));

        //
        //  DEVNOTE: I believe there's a problem maintaining child count over hash
        //      nodes, needs fixing but not now
        //
        //  count only has functional value for determining when to pop out hash
        //  and as rough estimate of child nodes to come in rpc enum
        //

        ASSERT( pNode->cChildren == countChildren );
        //  Dbg_DumpTree( pNode );
        //  return( FALSE );
        return( TRUE );
    }

    if ( pNodeChild && !foundChild )
    {
        DNS_PRINT((
            "ERROR:  Node (%s %p) not found in parent's child list.\n"
            "\tpParent = %p\n",
            pNodeChild->szLabel,
            pNodeChild,
            pNode ));
        Dbg_DnsTree( "ERROR:  node not in parent's child list", pNode );
        Dbg_DbaseNode(
            "Missing child node.\n",
            pNodeChild );
        ASSERT( FALSE );
        return( FALSE );
    }
    return( TRUE );
}

#endif



BOOL
NTree_VerifyNodeInSiblingList(
    IN      PDB_NODE       pNode
    )
/*++

Routine Description:

    Verify node is valid member of sibling list.

Arguments:

    pNode - node to verify

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    PDB_NODE        pnode;
    PDB_NODE        pparent;
    PDB_NODE        pchild;
    PSIB_HASH_TABLE phash;
    PSIB_HASH_TABLE phashUp;
    INT             index;

    ASSERT( pNode != NULL );
    ASSERT( !IS_ON_FREE_LIST(pNode) );

    //
    //  find parent
    //      - if root, then no siblings
    //

    pparent = pNode->pParent;
    if ( !pparent )
    {
        HARD_ASSERT( pNode->pSibUp == NULL );
        HARD_ASSERT( pNode->pSibLeft == NULL );
        HARD_ASSERT( pNode->pSibRight == NULL );
        return( TRUE );
    }

    //
    //  verify immediate B-tree children
    //      - node is their B-tree parent
    //      - node's DNS parent, is their DNS parent
    //

    pchild = pNode->pSibLeft;
    if ( pchild )
    {
        HARD_ASSERT( pchild->pSibUp == pNode );
        HARD_ASSERT( pchild->pParent == pparent );
    }
    pchild = pNode->pSibRight;
    if ( pchild )
    {
        HARD_ASSERT( pchild->pSibUp == pNode );
        HARD_ASSERT( pchild->pParent == pparent );
    }

    //
    //  traverse up B-tree
    //      - verify top node is parent's direct child
    //

    pnode = pNode;

    while ( 1 )
    {
        phash = (PSIB_HASH_TABLE) pnode->pSibUp;
        if ( !phash )
        {
            HARD_ASSERT( pparent->pChildren == pnode );
            return( TRUE );
        }
        if ( !IS_HASH_TABLE(phash) )
        {
            pnode = (PDB_NODE) phash;
            continue;
        }
        break;
    }

    //  have hash block
    //      - find our bin, and verify hash points at top of our B-tree

    index = NTree_HashTableIndex(
                pNode,
                phash->cLevel
                );
    HARD_ASSERT( phash->aBuckets[index] == pnode );

    //
    //  traverse up hash blocks
    //      - note, could verify index at each node
    //      - verify top hash block is parent's direct child
    //

    while ( phashUp = phash->pHashUp )
    {
        HARD_ASSERT( phashUp->cLevel == phash->cLevel-1 );
        phash = phashUp;
    }

    HARD_ASSERT( phash->cLevel == 0 );
    HARD_ASSERT( pparent->pChildren == (PDB_NODE)phash );

    return( TRUE );
}



//
//  Public Sibling list functions
//

VOID
NTree_StartFileLoad(
    VOID
    )
/*++

Routine Description:

    Turn on full rebalancing of sibling trees.

Arguments:

    None.

Return Value:

    None.

--*/
{
    gcFullRebalance++;
}


VOID
NTree_StopFileLoad(
    VOID
    )
/*++

Routine Description:

    Turn off full rebalancing of sibling trees.

Arguments:

    None.

Return Value:

    None.

--*/
{
    gcFullRebalance--;
}



PDB_NODE
FASTCALL
NTree_FirstChild(
    IN      PDB_NODE        pParent
    )
/*++

Routine Description:

    Get first child node.

Arguments:

    pParent -- parent node to get child of

Return Value:

    None.

--*/
{
    PDB_NODE        pleft;
    PDB_NODE        ptemp;

    ASSERT( pParent );

    //
    //  get child tree root
    //

    LOCK_CHILD_LIST( pParent );

    pleft = pParent->pChildren;
    if ( !pleft )
    {
        // done
    }

    //
    //  hash table node?
    //

    else if ( IS_HASH_TABLE(pleft) )
    {
        pleft = NTree_NextHashedNode(
                    (PSIB_HASH_TABLE)pleft,
                    NULL );
    }

    //
    //  go all the way left for first node
    //

    else
    {
        while( ptemp = pleft->pSibLeft )
        {
            pleft = ptemp;
        }
    }

    UNLOCK_CHILD_LIST( pParent );
    return( pleft );
}



PDB_NODE
FASTCALL
NTree_NextSibling(
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Get next sibling of node.

Arguments:

    pNode -- node in sibling list

Return Value:

    None.

--*/
{
    PDB_NODE    ptemp;

    ASSERT( pNode );

    DNS_DEBUG( BTREE2, (
        "NTree_NextSibling(%s)\n",
        pNode->szLabel ));

    //
    //  if node has right child
    //      => go down right subtree, then all the way left

    if ( ptemp = pNode->pSibRight )
    {
        while( pNode = ptemp->pSibLeft )
        {
            ptemp = pNode;
        }
        return( ptemp );
    }

    //
    //  if no right child, then go back up until first "right ancestor"
    //  right ancestor means we came up left branch of its subtree
    //
    //  if encounter hash table, then find first node in next hash bucket
    //

    else
    {
        while( ptemp = pNode->pSibUp )
        {
            if ( IS_HASH_TABLE(ptemp) )
            {
                return  NTree_NextHashedNode(
                            (PSIB_HASH_TABLE)ptemp,
                            pNode );
            }

            //  if node was left child, then ptemp is next node

            if ( ptemp->pSibLeft == pNode )
            {
                return( ptemp );
            }

            //  right child, continue up tree

            ASSERT( ptemp->pSibRight == pNode );
            pNode = ptemp;
        }
        return( NULL );
    }
}



PDB_NODE
FASTCALL
NTree_NextSiblingWithLocking(
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Get next sibling of node.

Arguments:

    pNode -- node in sibling list

Return Value:

    None.

--*/
{
    PDB_NODE    ptemp;

    //
    //  note we set ACCESS flag so timeout thread can NOT whack this node
    //  before we've moved in
    //  better solution is to do traverse with timeout thread locked out
    //

    LOCK_CHILD_LIST( pNode->pParent );

    ptemp = NTree_NextSibling(pNode);
    if ( ptemp )
    {
        SET_NODE_ACCESSED( ptemp );
    }

    UNLOCK_CHILD_LIST( pNode->pParent );

#if DBG
    IF_DEBUG( BTREE )
    {
        if ( ptemp )
        {
            NTree_VerifyNode( pNode );
        }
    }
#endif
    return( ptemp );
}



VOID
FASTCALL
NTree_RebalanceChildList(
    IN      PDB_NODE        pParent
    )
/*++

Routine Description:

    Rebalance child list of node.

Arguments:

    pParent -- node who's child list is to be rebalanced

Return Value:

    None.

--*/
{
    PDB_NODE        pnodeChildRoot;

    ASSERT( pParent );
    DNS_DEBUG( BTREE, (
        "NTree_RebalanceChildList( %s )\n",
        pParent->szLabel ));

    //
    //  less than three children -- no point to rebal
    //

    if ( pParent->cChildren < 3 )
    {
        return;
    }
    ASSERT( pParent->pChildren );

    //
    //  if B-tree at root rebal
    //

    pnodeChildRoot = pParent->pChildren;

    if ( !IS_HASH_TABLE(pnodeChildRoot) )
    {
        btreeRebalance( pnodeChildRoot, pParent->cChildren );
        return;
    }

    //
    //  balance B-trees in all sibling hashes
    //

    NTree_HashRebalance( (PSIB_HASH_TABLE)pnodeChildRoot );
}



int
quickStrCmp(
    IN      int             keyLength,
    IN      PCHAR           pszKey,
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Does a fast string compare between a key string and the label
    string for a node. Before calling this function you must try 
    DWORD compare to see if the compare can be resolved that way.
    If you call this function before comparing the DWORD compare
    values you may get incorrect results!

Arguments:

    keyLength - length of pszKey

    pszKey - the search string

    pNode - node whose label will be compared against the key

Return Value:

    Returns:
        -1 if key < node label
         0 if key == node label
        +1 if key > node label

--*/
{
    int iCompare;
    int iLabelLengthDiff = keyLength - pNode->cchLabelLength;

    ASSERT( pszKey );
    ASSERT( pNode );

    if ( keyLength <= sizeof( DWORD ) ||
        pNode->cchLabelLength <= sizeof( DWORD ) )
    {
        if ( iLabelLengthDiff == 0 )
        {
            return 0;
        }
        iCompare = iLabelLengthDiff;
    }
    else
    {
        iCompare = strncmp(
                        pszKey,
                        DOWNCASED_NODE_NAME( pNode ),
                        keyLength );
        if ( !iCompare )
        {
            if ( !iLabelLengthDiff )
            {
                return 0;
            }
            iCompare = iLabelLengthDiff;
            ASSERT( iCompare < 0 );
        }
    }
    return iCompare;
} // quickStrCmp



void
walkBinaryTree(
    DWORD           dwordSearchKey,     IN
    PCHAR           szlabel,            IN
    DWORD           labelLength,        IN
    PDB_NODE *      ppnodePrev,         OUT
    PDB_NODE *      ppnodeCurrent,      OUT
    PDB_NODE **     pppnodeNext,        IN
    PDB_NODE *      ppnodeNxt           OUT
    )
/*++

Routine Description:

    This function performs the guts of the binary tree walking
    for NTree_FindOrCreateChildNode().

    As we go, test if the current node is a candidate
    for being the node that immediately precedes the node we're
    searching for. The node is a candidate if:
        node->value < searchkey &&
        ( node->right->value == NULL || node->right->value > searchkey )

    This is called the NXT node because it's the node that can
    be used to satisfy the NXT requirement for the search name.

Arguments:

    dwordSearchKey - lookup name converted to 4 bytes for fast compares

    szlabel - lookup name in regular string form

    ppnodePrev - ptr to the previous node

    ppnodeCurrent - ptr to the current node

    pppnodeNext - ptr to the next node - INPUT: starting node for search

    ppnodeNxt - ptr to the NXT node - the node preceding the search key

Return Value:

--*/
{
    LONG            icompare;

    ASSERT( szlabel );
    ASSERT( ppnodePrev );
    ASSERT( ppnodeCurrent );
    ASSERT( pppnodeNext );

    while ( *ppnodeCurrent = **pppnodeNext )
    {
        //  save backptr for adds

        *ppnodePrev = *ppnodeCurrent;

        //
        //  compare labels
        //      - database string store WITHOUT case
        //      - compare DWORD faster comparison first
        //      - full case sensitive compare only on DWORD compare match
        //

        //  check for no DWORD match
        //      - drop appropriately to left or right node
        //      - save back ptr for adding new node
        //
        //  note can NOT use integer diff to compare;  need to know which is greater
        //      in absolute unwrapped terms to handle extended characters

        if ( ppnodeNxt &&
            (*ppnodeCurrent)->dwCompare < dwordSearchKey &&
            ( (*ppnodeCurrent)->pSibRight == NULL ||
                (*ppnodeCurrent)->pSibRight->dwCompare > dwordSearchKey ||
                ( (*ppnodeCurrent)->pSibRight->dwCompare == dwordSearchKey &&
                    quickStrCmp(
                        labelLength,
                        szlabel,
                        (*ppnodeCurrent)->pSibRight ) > 0 ) ) )
        {
            *ppnodeNxt = *ppnodeCurrent;
        }

        if ( dwordSearchKey < (*ppnodeCurrent)->dwCompare )
        {
            *pppnodeNext = &(*ppnodeCurrent)->pSibLeft;
            continue;
        }
        else if ( dwordSearchKey > (*ppnodeCurrent)->dwCompare )
        {
            *pppnodeNext = &(*ppnodeCurrent)->pSibRight;
            continue;
        }

        //
        //  quick compare DWORD exact match
        //

        //
        //  compare label lengths
        //  if either label contained in quick-compare DWORD ?
        //
        //  - labels lengths equal => complete match
        //  - else length diff indicates which larger
        //

        icompare = quickStrCmp(
                        labelLength,
                        szlabel,
                        *ppnodeCurrent );
        
        if ( !icompare )
        {
            return;
        }

        //
        //  drop appropriately to left or right node
        //      - save address in previous node for ptr
        //      - cut allowed imbalance in half
        //

        if ( ppnodeNxt &&
            icompare > 0 &&
            ( (*ppnodeCurrent)->pSibRight == NULL ||
                (*ppnodeCurrent)->pSibRight->dwCompare > dwordSearchKey ||
                ( (*ppnodeCurrent)->pSibRight->dwCompare == dwordSearchKey &&
                    quickStrCmp(
                        labelLength,
                        szlabel,
                        (*ppnodeCurrent)->pSibRight ) > 0 ) ) )
        {
            *ppnodeNxt = *ppnodeCurrent;
        }

        if ( icompare < 0 )
        {
            *pppnodeNext = &(*ppnodeCurrent)->pSibLeft;
            continue;
        }
        else
        {
            ASSERT( icompare > 0 );
            *pppnodeNext = &(*ppnodeCurrent)->pSibRight;
            continue;
        }
    }
}   //  walkBinaryTree



PSIB_HASH_TABLE
NTree_PreviousHash(
    IN      PSIB_HASH_TABLE     pHash,
    IN OUT  PINT                pHashIdx
    )
/*++

Routine Description:

    Finds the previous hash node and index starting from a given hash node
    and index. NULL hash buckets are skipped over.
    
    pHash must be a hash node, and pHashIdx must be set to the index
    at which to begin the traverse. The node returned will be a hash node, and
    the value at pHashIdx will be set to the index of the next node in the
    returned hash node.

    The returned hash bucket will be bottom-level, that is, the pointer will
    be a pointer to a DB_NODE, not to another hash table.

    JJW: LOCKING!!

Arguments:

    pHash - ptr to starting hash node

    pHashIdx - IN: ptr to starting hash idx
               OUT: ptr to hash index in returned hash node

Return Value:

    Pointer to previous hash node, with hash index at pHashIdx. NULL if there
    is no non-empty hash bucket before the specified bucket.

--*/
{
    PSIB_HASH_TABLE     pPrevNode;

    --( *pHashIdx );

    while( 1 )
    {
        DNS_DEBUG( LOOKUP, (
            "NTree_PreviousHash: pHash %p hashIdx %d\n",
            pHash,
            *pHashIdx ));

        //
        //  If out of buckets in this hash node, move up to parent hash node
        //  and set index for the index of the current node in the parent.
        //

        if ( *pHashIdx < 0 )
        {
            if ( pHash->cLevel == 0 )
            {
                //  Hit top of tree - no more nodes!
                *pHashIdx = -1;
                return NULL;
            }
            *pHashIdx = pHash->iBucketUp - 1;

            ASSERT( pHash->pHashUp );
            ASSERT( pHash->pHashUp->cLevel == pHash->cLevel - 1 );
            ASSERT( pHash->pHashUp->aBuckets[ *pHashIdx + 1 ] ==
                    ( PDB_NODE ) pHash );

            pHash = pHash->pHashUp;
            continue;
        }
        ASSERT( *pHashIdx < LAST_HASH_INDEX );

        //
        //  Check pointer in the current node at the current index. If NULL,
        //  advance to next bucket pointer.
        //

        pPrevNode = ( PSIB_HASH_TABLE ) pHash->aBuckets[ *pHashIdx ];
        if ( !pPrevNode )
        {
            --( *pHashIdx );
            continue;
        }

        //
        //  If the node is another hash table, set the index to the last
        //  element and continue to search for a non-NULL bucket pointer.
        //

        if ( IS_HASH_TABLE( pPrevNode ) )
        {
            ASSERT( pPrevNode->pHashUp == pHash );
            ASSERT( pPrevNode->iBucketUp == *pHashIdx );
            ASSERT( pPrevNode->cLevel ==
                        pHash->cLevel + 1 );
            pHash = pPrevNode;
            *pHashIdx = LAST_HASH_INDEX - 1;
            continue;
        }

        break;      //  We've found the previous non-null hash bucket!
    }
    return pHash;
}   //  NTree_PreviousHash



PDB_NODE
NTree_FindOrCreateChildNode(
    IN      PDB_NODE        pParent,
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength,
    IN      BOOL            fCreate,
    IN      DWORD           dwMemTag,
    OUT     PDB_NODE *      ppnodePrevious          OPTIONAL
    )
/*++

Routine Description:

    Find or create a node in child list of tree.

    Assumes lock held on child B-tree.

Arguments:

    pParent - parent of child node to find

    pchName - child node's label

    cchNameLength - child node's label length

    fCreate - create flag TRUE to create node if not found

    dwMemTag - tag for node or zero for generic

    ppnodePrevious - If no match found or created, will be set
        to the node that immediately precedes the search key
        e.g. if the tree contains A, B, D, E and you search for
        C, ppnodePrevious will point at B. Pass NULL if you
        don't care.

Return Value:

    Ptr to child node if found or created.
    NULL if pchName is invalid name or in find case
    if NOT a child node of pParent.

--*/
{
    PDB_NODE        pnodeCurrent;
    LONG            icompare;
    LONG            ilabelLengthDiff;
    DWORD           labelLength;
    DWORD           dwordName;
    INT             downResult;
    PDB_NODE        pnodeAdd;
    PDB_NODE        pnodePrev;
    PDB_NODE *      ppnodeNext;
    PZONE_INFO      pzone;
    DWORD           nameCheckFlag;
    CHAR            szlabel[ DNS_MAX_LABEL_BUFFER_LENGTH ] = "";
    INT             hashIdx = 0;
    PDB_NODE        pHash = NULL;

#if DBG
    ASSERT( pParent != NULL );
    IF_DEBUG( DATABASE )
    {
        ASSERT( NTree_VerifyNode(pParent) );
    }
    IF_DEBUG( BTREE2 )
    {
        DnsDebugLock();
        DnsPrintf(
            "NTree_FindOrCreateChild()\n"
            "\tparent label: (%s)\n"
            "\t\tchild count = %d\n"
            "\t\tzone        = %p\n"
            "\tchild label: (%.*s)\n",
            pParent->szLabel,
            pParent->cChildren,
            pParent->pZone,
            cchNameLength,
            pchName );
        Dbg_SiblingList(
            "Child list before lookup:",
            pParent->pChildren );
        DnsDebugUnlock();
    }
#endif

    //
    //  verify node, minimum AV protection
    //

    if ( pParent == NULL )
    {
        ASSERT( FALSE );
        return( NULL );
    }

    if ( ppnodePrevious )
    {
        *ppnodePrevious = NULL;
    }

    //
    //  child count problem detection\protection
    //

    if ( pParent->pChildren == NULL )
    {
        if ( pParent->cChildren != 0 )
        {
            DNS_PRINT((
                "ERROR:  Bachelor node (%s) (%p) has non-zero child count = %d\n",
                pParent->szLabel,
                pParent,
                pParent->cChildren ));
            TEST_ASSERT( FALSE );
            pParent->cChildren = 0;
        }
    }
    ELSE_IF_DEBUG( ANY )
    {
        if ( pParent->cChildren == 0 )
        {
            DnsDebugLock();
            DNS_PRINT((
                "ERROR:  Parent node (%s) (%p) has zero child count.\n",
                pParent->szLabel,
                pParent ));
            Dbg_SiblingList(
                "Child list of parent with zero children:\n",
                pParent->pChildren );
            TEST_ASSERT( FALSE );
            DnsDebugUnlock();
        }
    }

    //
    //  zero children on find -- done
    //

    if ( pParent->pChildren == NULL  &&  !fCreate )
    {
        return( NULL );
    }

    //
    //  validate and downcase incoming label
    //
    //  - in primary zones, use configurable NameCheckFlag
    //  - in secondaries, must take anything primary sends
    //  - in cache, allow anything
    //
    //      - ASCII -> 0 (length must be the same as input)
    //      - error -> (-1)
    //      - extended -> length of extended name
    //


    nameCheckFlag = DNS_ALLOW_ALL_NAMES;

    pzone = (PZONE_INFO) pParent->pZone;
    if ( pzone && IS_ZONE_PRIMARY(pzone) )
    {
        nameCheckFlag = SrvCfg_dwNameCheckFlag;
    }

    downResult = Dns_DowncaseNameLabel(
                    szlabel,
                    pchName,
                    cchNameLength,
                    nameCheckFlag
                    );

    if ( downResult == 0 )
    {
        labelLength = cchNameLength;
    }
    else if ( downResult == (-1) )
    {
        DNS_DEBUG( LOOKUP, (
            "Label %.*s failed validity-downcase check\n"
            "\tNameCheckFlag = %d\n"
            "\tNTree_FindOrCreate() bailing out\n",
            cchNameLength,
            pchName,
            nameCheckFlag ));

        SetLastError( DNS_ERROR_INVALID_NAME );
        return( NULL );
    }

    //
    //  extended name
    //      - result is downcased label length
    //      for UTF8 this "could" be different than input length

    else
    {
        labelLength = downResult;
        if ( labelLength != cchNameLength )
        {
            DNS_DEBUG( LOOKUP, (
                "WARNING:  Label %.*s validity-downcase check returned new length\n"
                "\tlength in    = %d\n"
                "\tlength out   = %d\n",
                cchNameLength,
                pchName,
                cchNameLength,
                labelLength ));
        }
        DNS_DEBUG( LOOKUP, (
            "Label %.*s\n"
            "\tcannonicalize to %s\n"
            "\tname length = %d\n"
            "\tlabel length = %d\n",
            cchNameLength,
            pchName,
            szlabel,
            cchNameLength,
            labelLength ));
    }


    //
    //  make DWORD label for quick compare
    //      - mask off bytes beyond label name
    //

    INLINE_DWORD_FLIP( dwordName, *(PDWORD)szlabel );
    if ( labelLength < 4 )
    {
        dwordName &= QuickCompareMask[ labelLength ];
    }

    //
    //  get sibling B-tree root
    //

    pnodePrev = NULL;
    ppnodeNext = &pParent->pChildren;
    while ( ( pnodeCurrent = *ppnodeNext ) != NULL &&
        IS_HASH_TABLE( pnodeCurrent ) )
    {
        pHash = pnodePrev = pnodeCurrent;
        hashIdx = NTree_HashTableIndexEx(
                        NULL,
                        szlabel,
                        ( ( PSIB_HASH_TABLE ) pHash )->cLevel );
        ppnodeNext = &( ( PSIB_HASH_TABLE ) pHash )->aBuckets[ hashIdx ];
    }

    //
    //  Walk the binary tree we've found, searching for the node.
    //

    walkBinaryTree( 
        dwordName,
        szlabel,
        labelLength,
        &pnodePrev,
        &pnodeCurrent,
        &ppnodeNext,
        ppnodePrevious );
    
    if ( pnodeCurrent )
    {
        return pnodeCurrent;
    }

    #if 0
    DNS_DEBUG( ANY, (
        "JJW: search %.*s found %.*s previous %.*s\n",
        cchNameLength, pchName,
        pnodeCurrent ? pnodeCurrent->cchLabelLength : 4,
        pnodeCurrent ? pnodeCurrent->szLabel : "NULL",
        ppnodePrevious && *ppnodePrevious ? (*ppnodePrevious)->cchLabelLength : 4,
        ppnodePrevious && *ppnodePrevious  ? (*ppnodePrevious)->szLabel : "NULL" ));
    #endif

    //
    //  We drop here if NOT found.
    //

    ASSERT( pnodeCurrent == NULL );

    if ( !fCreate )
    {
        //
        //  If we don't have a "previous node", the previous node is in
        //  another tree. Find the root of the next tree, and search it
        //  for the previous node. BUT we can only do this if pHash is not
        //  NULL - if we didn't start searching in a tree with no hash tables.
        //

        if ( ppnodePrevious && !*ppnodePrevious && pHash )
        {
            pnodeCurrent = ( PDB_NODE )
                NTree_PreviousHash( ( PSIB_HASH_TABLE ) pHash, &hashIdx );
            if ( pnodeCurrent )
            {
                ppnodeNext =
                    &( ( PSIB_HASH_TABLE ) pnodeCurrent )->aBuckets[ hashIdx ];
                #if 0
                DNS_DEBUG( ANY, (
                    "JJW: regressing to previous tree %.*s\n",
                    *ppnodeNext ? (*ppnodeNext)->cchLabelLength : 4,
                    *ppnodeNext ? (*ppnodeNext)->szLabel : "NULL" ));
                #endif
                pnodePrev = pnodeCurrent = NULL;
                walkBinaryTree( 
                    dwordName,
                    szlabel,
                    labelLength,
                    &pnodePrev,
                    &pnodeCurrent,
                    &ppnodeNext,
                    ppnodePrevious );
            }
        }
        return NULL;
    }

    //
    //  creating new node -- allocate and build
    //
    //  note:  do NOT preserve case on extended names,
    //  for multibyte names, case preservation is "problematic"
    //  (casing language issues) so UTF8 is always downcased on the
    //  wire, and we should NOT preserve case;  this also eliminates
    //  the problem of original\downcased having different lengths
    //

    if ( downResult == 0 )      // no-multibyte
    {
        pnodeAdd = NTree_CreateNode(
                        pchName,            // original name
                        szlabel,            // downcased name
                        labelLength,
                        dwMemTag );
    }
    else                        // multibyte
    {
        pnodeAdd = NTree_CreateNode(
                        szlabel,            // downcased name
                        szlabel,            // downcased name
                        labelLength,
                        dwMemTag );
    }

    if ( !pnodeAdd )
    {
        ASSERT( FALSE );
        return( NULL );
    }

    //
    //  set quick compare DWORD
    //

    pnodeAdd->dwCompare = dwordName;

    //
    //  link to parent
    //  set label count from parent
    //

    pParent->cChildren++;
    pnodeAdd->pParent = pParent;
    pnodeAdd->cLabelCount = pParent->cLabelCount + 1;

    //  point at parent's zone
    //      - when creating zone root we'll immediately overwrite

    pnodeAdd->pZone = pParent->pZone;

#if 0
    //
    //  DEVNOTE: this messes up zonetree;
    //      inheritance is desirable in 99% case in zone data trees, but currently
    //          overwriting every node anyway
    //      we could go either way here and allow zone ptr, and do more figuring
    //          but this is harder to clean up on zone shutdown\unload
    //      or could have zone tree traverse NULL out non-AUTH_ROOT nodes
    //
#endif

    //
    //  link to sibling tree
    //  or sets parent's child tree, if first node at parent
    //  or sets hash table ptr, if first node in hash bucket
    //

    *ppnodeNext = pnodeAdd;
    pnodeAdd->pSibUp = pnodePrev;

    //
    //  siblings in one b-tree
    //      - check if need top level hash
    //

    if ( !IS_HASH_TABLE(pParent->pChildren) )
    {
        if ( pParent->cChildren > HASH_BUCKET_MAX0 )
        {
            NTree_CreateHashAtNode( pParent->pChildren );
        }
        IF_DEBUG( DATABASE )
        {
            ASSERT( NTree_VerifyNode(pParent) );
        }
    }

    //
    //  if under hash table -- reset count, routine should rebal
    //      if ADDing over given value
    //

    else
    {
        pnodeCurrent = pnodeAdd;
        while ( (pnodeCurrent = pnodeCurrent->pSibUp)
                && !IS_HASH_TABLE(pnodeCurrent) )
        {
        }
        ASSERT( pnodeCurrent && IS_HASH_TABLE(pnodeCurrent) );
        NTree_AddNodeInHashBucket(
            (PSIB_HASH_TABLE) pnodeCurrent,
            pnodeAdd );

        IF_DEBUG( DATABASE )
        {
            ASSERT( NTree_VerifyNode(pParent) );
        }
    }

    IF_DEBUG( BTREE2 )
    {
        Dbg_SiblingList(
            "Full sibling list after insert:",
            pParent->pChildren );
    }
    IF_DEBUG( DATABASE2 )
    {
        Dbg_DbaseNode(
            "Node after create and insert:",
            pnodeAdd );
    }

    NTree_VerifyNodeInSiblingList( pnodeAdd );

    return( pnodeAdd );
}



VOID
NTree_CutNode(
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Cut node from sibling B-tree.

Arguments:

    pNode -- node to cut out

Return Value:

    None.

--*/
{
    PDB_NODE        preplace;
    PDB_NODE        ptemp;
    PDB_NODE        preplaceUp;
    PDB_NODE        pnodeUp;
    PDB_NODE        pleft;
    PDB_NODE        pright;
    PDB_NODE        pParent = pNode->pParent;

    ASSERT( pNode );

    DNS_DEBUG( BTREE, (
        "NTree_CutNode(%s)\n",
        pNode->szLabel ));

    IF_DEBUG( BTREE2 )
    {
        Dbg_SiblingList(
            "Cutting node.  Node's subtree:",
            pNode );
    }
    NTree_VerifyNodeInSiblingList( pNode );

    //
    //  save pNode's links
    //

    pParent = pNode->pParent;
    ASSERT( pParent );              // can not delete root node
    pnodeUp = pNode->pSibUp;
    pleft = pNode->pSibLeft;
    pright = pNode->pSibRight;

    //
    //  if leaf node, cut it out cleanly
    //

    if ( !pleft && !pright )
    {
        preplace = NULL;
        goto FixBTreeParent;
    }

    //
    //  not a leaf -- must replace with node node in sub-tree
    //
    //  default to left side, then try right
    //

    if ( pleft )
    {
        //  step left, then go all the way right

        preplace = pleft;
        ASSERT( preplace );
        while( ptemp = preplace->pSibRight )
        {
            preplace = ptemp;
        }
        ASSERT( preplace->pSibRight == NULL );
        preplaceUp = preplace->pSibUp;

        //
        //  replacing with immediate left child of node being cut
        //      - no right child
        //      - simply slide up to replace cut node
        //

        if ( preplaceUp == pNode )
        {
            ASSERT( preplace == pleft );

            preplace->pSibUp = pnodeUp;
            if ( pright )
            {
                preplace->pSibRight = pright;
                pright->pSibUp = preplace;
            }
            goto FixBTreeParent;
        }

        //
        //  replace with rightmost node in cut node's left subtree
        //
        //  - replace node must be right child of its parent
        //  - "pulling" replacement left up a level
        //      - point parent->right at replace->left
        //      - point replace->left->up points to parent
        //

        ASSERT( preplaceUp->pSibRight == preplace );

        ptemp = preplace->pSibLeft;
        preplaceUp->pSibRight = ptemp;
        if ( ptemp )
        {
            ptemp->pSibUp = preplaceUp;
        }
    }

    else
    {
        //  step right, then go all the way left

        preplace = pright;
        ASSERT( preplace );
        while( ptemp = preplace->pSibLeft )
        {
            preplace = ptemp;
        }
        ASSERT( preplace->pSibLeft == NULL );
        preplaceUp = preplace->pSibUp;

        //
        //  replacing with immediate right child of node being cut
        //      - simply slide up to replace cut node
        //

        if ( preplaceUp == pNode )
        {
            ASSERT( preplace == pright );

            preplace->pSibUp = pnodeUp;
            if ( pleft )
            {
                preplace->pSibLeft = pleft;
                pleft->pSibUp = preplace;
            }
            goto FixBTreeParent;
        }

        //
        //  replace with leftmost node in cut node's right subtree
        //
        //  - replace node must be left child of its parent
        //  - "pulling" replacement right up a level
        //      - point parent->left at replace->right
        //      - point replace->right->up points to parent
        //

        ASSERT( preplaceUp->pSibLeft == preplace );

        ptemp = preplace->pSibRight;
        preplaceUp->pSibLeft = ptemp;
        if ( ptemp )
        {
            ptemp->pSibUp = preplaceUp;
        }
    }

    //
    //  drop here if replace node NOT immediate child of pNode
    //  hook replacement into pNode's place in tree
    //

    preplace->pSibUp    = pnodeUp;
    preplace->pSibLeft  = pleft;
    preplace->pSibRight = pright;

    if ( pleft )
    {
        pleft->pSibUp = preplace;
    }
    if ( pright )
    {
        pright->pSibUp = preplace;
    }

FixBTreeParent:

    //
    //  point cut node's B-tree parent at replacement node
    //      - note need this if no (NULL) replacement
    //

    if ( !pnodeUp )
    {
        //  cutting top node in tree, must replace DNS tree parent's
        //      child ptr

        ASSERT( pParent->pChildren == pNode );
        pParent->pChildren = preplace;
    }
    else if ( IS_HASH_TABLE(pnodeUp) )
    {
        //  no action -- handled by delete in hash bucket function below
    }
    else if ( pnodeUp->pSibLeft == pNode )
    {
        //  cut node was left child of B-Tree parent
        pnodeUp->pSibLeft = preplace;
    }
    else
    {
        //  cut node was right child of B-Tree parent
        ASSERT( pnodeUp->pSibRight == pNode );
        pnodeUp->pSibRight = preplace;
    }

    //
    //  one less DNS tree child
    //

    pParent->cChildren--;

    //
    //  if node was under hash table -- reset count
    //

    if ( pParent->pChildren && IS_HASH_TABLE(pParent->pChildren) )
    {
        NTree_DeleteNodeInHashBucket(
            pnodeUp,
            pNode,
            preplace );
    }

    IF_DEBUG( BTREE2 )
    {
        Dbg_SiblingList(
            "Full sibling list after cut",
            pNode->pParent->pChildren );
    }

    //
    //  verify sibling list memembers happy
    //

    if ( preplace )
    {
        NTree_VerifyNodeInSiblingList( preplace );
    }
    if ( pnodeUp )
    {
        if ( !IS_HASH_TABLE(pnodeUp) )
        {
            NTree_VerifyNodeInSiblingList( pnodeUp );
        }
    }
}



VOID
NTree_RebalanceSubtreeChildLists(
    IN OUT  PDB_NODE    pParent,
    IN      PVOID       pZone
    )
/*++

Routine Description:

    Rebalance child lists of all nodes in subtree.

    Note calls itself recursively.

Arguments:

    pParent -- parent node of subtree

    pZone -- zone to limit rebalance to

Return Value:

    None.

--*/
{
    PDB_NODE    pchild;

    ASSERT( pParent );
    IF_DEBUG( BTREE2 )
    {
        DNS_PRINT((
            "NTree_RebalanceSubtreeChildLists( %s )\n",
            pParent->szLabel ));
    }

    //
    //  if no children -- done
    //

    if ( !pParent->pChildren )
    {
        ASSERT( pParent->cChildren == 0 );
        return;
    }

    //
    //  rebalance parent node's child list first
    //      - optimize away unnecessary case to avoid even making call
    //

    if ( pParent->cChildren > 3 )
    {
        NTree_RebalanceChildList( pParent );
    }

    //
    //  recurse to rebalance children's child lists
    //

    ASSERT( pParent->cChildren && pParent->pChildren );

    pchild = NTree_FirstChild( pParent );
    ASSERT( pchild );

    while ( pchild )
    {
        NTree_RebalanceSubtreeChildLists(
            pchild,
            pZone );
        pchild = NTree_NextSiblingWithLocking( pchild );
    }
}




//
//  Subtree delete routines
//
//  Need special routines to delete all nodes in sibling list, because
//  walk functions do "in order" walk.  When we delete B-tree nodes in-order
//  we can no longer safely continue the in-order walk.
//
//  Since the full sibling list delete is ONLY used when we are deleting
//  the entire DNS subtree, under a node, these routines are coded to
//  delete all the DNS children, as we delete the nodes in the sibling
//  list.
//
//  Note, there is NO LOCKING in these routines.  Currently they are
//  used only to delete temp database used in zone transfer receive,
//  which are owned by a single thread.  If other use is made, caller
//  should get top level lock, or recode.
//

VOID
btreeDeleteSubtree(
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Hard delete of B-tree subtree and their DNS tree children.

    This is used to delete temp database after zone transfer, so
        - delete RR list without dereference
        - delete all nodes, ignoring ref counts and access

Arguments:

    pNode -- B-tree root

Return Value:

    None.

--*/
{
    ASSERT( pNode );

    //
    //  delete all nodes in left subtree, including their DNS tree children
    //  then same for right subtree
    //

    if ( pNode->pSibLeft )
    {
        btreeDeleteSubtree( pNode->pSibLeft );
    }
    if ( pNode->pSibRight )
    {
        btreeDeleteSubtree( pNode->pSibRight );
    }

    //
    //  delete this node's DNS subtree
    //

    NTree_DeleteSubtree( pNode );
}



VOID
NTree_HashDeleteSubtree(
    IN      PSIB_HASH_TABLE pHash
    )
/*++

Routine Description:

    Hard delete of nodes in hash and their DNS tree children.

    This is used to delete temp database after zone transfer, so
        - delete RR list without dereference
        - delete all nodes, ignoring ref counts and access

Arguments:

    pHash -- hash containing nodes to delete

Return Value:

    None.

--*/
{
    INT             i;
    PDB_NODE        ptemp;

    ASSERT( pHash && IS_HASH_TABLE(pHash) );

    //
    //  delete all nodes (and DNS subtrees) in B-tree or hash
    //      at each hash bucket
    //

    for (i=0; i<=LAST_HASH_INDEX; i++)
    {
        ptemp = pHash->aBuckets[i];
        if ( !ptemp )
        {
            ASSERT( pHash->aBucketCount[i] == 0 );
            continue;
        }
        if ( IS_HASH_TABLE(ptemp) )
        {
            NTree_HashDeleteSubtree( (PSIB_HASH_TABLE)ptemp );
        }
        else
        {
            btreeDeleteSubtree( ptemp );
        }
    }

    //  delete hash table

    FREE_TAGHEAP( pHash, sizeof(SIB_HASH_TABLE), MEMTAG_NODEHASH );
}



VOID
NTree_DeleteSubtree(
    IN      PDB_NODE        pNode
    )
/*++

Routine Description:

    Hard delete of node and its DNS subtree.

    This is used to delete temp database after zone transfer, so
        - delete RR list without dereference
        - delete all nodes, ignoring ref counts and access

Arguments:

    pNode -- root of subtree to delete

Return Value:

    None.

--*/
{
    PDB_NODE        pchild;

    ASSERT( pNode );

    //
    //  if children, delete all the children
    //

    pchild = pNode->pChildren;

    if ( !pchild )
    {
        ASSERT( pNode->cChildren == 0 );
    }
    else if ( IS_HASH_TABLE(pchild) )
    {
        NTree_HashDeleteSubtree( (PSIB_HASH_TABLE) pchild );
    }
    else
    {
        ASSERT( pNode->cChildren != 0 );
        btreeDeleteSubtree( pchild );
    }

    //  make sure RR list is deleted

    if ( pNode->pRRList )
    {
        RR_ListDelete( pNode );
    }

    //  delete this node itself

    NTree_FreeNode( pNode );
}

//
//  End tree.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\tombston.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    Tombston.c

Abstract:

    Domain Name System (DNS) Server

    Implementation of tombstone search and destroy mechanism.

Author:

    Jeff Westhead   September 1999

Revision History:

--*/


/*
Tombstone notes:

A node is marked as dead or "tombstoned" in the DS by giving it a
DNS record type of zero and an attribute value of "dNSTombstoned=TRUE".
Tombstoned records must be held in the DS for a certain time interval
to allow the deletion to replicate to other DS servers. When this
interval has expired, the record must be deleted from the DS. The
data in the DNS data blob holds the time when the record was tombstoned
int FILETIME format.

Tombstone_Thread will periodically do the following:
1) perform an LDAP search to find all tombstoned records
2) delete expired tombstoned records
*/


/*
JJW issues:
- increment stats as in ds.c - tombstone delete count at the very least
*/


//
// Include directives
//


#include "dnssrv.h"
#include "ds.h"


//
// Define directives
//


#define SECONDS_IN_FILETIME( secs ) (secs*10000000i64)

#ifdef UNICODE // copied this from ds.c - why do we do this?
#undef UNICODE
#endif

#if DBG
#define TRIGGER_INTERVAL (30*60)            // 30 minutes
#else
#define TRIGGER_INTERVAL (24*60*60)         // 24 hours
#endif



//
// Types
//


//
// Static global variables
//


static WCHAR    g_szTombstoneFilter[] = LDAP_TEXT("(dNSTombstoned=TRUE)");
static BOOL     g_TombstoneThreadRunning = FALSE;


//
// Functions
//



DNS_STATUS
startTombstoneSearch(
    IN OUT  PDS_SEARCH      pSearchBlob
    )
/*++

Routine Description:

    Starts a paged LDAP search for tombstoned DNS records.

Arguments:

    pSearchBlob -- pointer to a search blob

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DBG_FN( "startTombstoneSearch" )

    DNS_STATUS      status;
    PLDAPSearch     psearch = NULL;
    PLDAPControl    ctrls[] =
                    {
                        &NoDsSvrReferralControl,
                        NULL
                    };
    PWSTR           searchAttrs[] =
                    {
                        DSATTR_DNSRECORD,
                        NULL
                    };

    Ds_InitializeSearchBlob( pSearchBlob );

    psearch = ldap_search_init_page(
                    pServerLdap,                // ldap handle
                    DSEAttributes[I_DSE_DEF_NC].pszAttrVal,     // base
                    LDAP_SCOPE_SUBTREE,         // search scope
                    g_szTombstoneFilter,        // search filter
                    searchAttrs,                // attribute list
                    FALSE,                      // attributes only
                    ctrls,                      // server controls
                    NULL,                       // client controls
                    0,                          // page time limit
                    0,                          // total size limit
                    NULL );                     // sort keys

    if ( !psearch )
    {
        DNS_DEBUG( TOMBSTONE,
            ( "%s: error %lu trying to init search\n", fn, LdapGetLastError() ));
        status = Ds_ErrorHandler( LdapGetLastError(), NULL, pServerLdap );
        ASSERT( status != ERROR_SUCCESS );
        if ( status == ERROR_SUCCESS )
        {
            status = DNSSRV_STATUS_DS_UNAVAILABLE;
        }
        goto Failed;
    }

    pSearchBlob->pSearchBlock = psearch;

    return( ERROR_SUCCESS );

Failed:

    if ( psearch )
    {
        ldap_search_abandon_page(
            pServerLdap,
            psearch );
    }
    DNS_DEBUG( TOMBSTONE, ( "%s: failed %d\n", fn, status ));
    return( status );
} // startTombstoneSearch



DNS_STATUS
Tombstone_Thread(
    IN      PVOID           pvDummy
    )
/*++

Routine Description:

    Main tombstone processing. This thread will fire at regular intervals
    to check for tombstoned records that have expired. Any expired records
    can be deleted from the DS.

Arguments:

    Unreferenced.

Return Value:

    Status in win32 error space

--*/
{
    DBG_FN( "Tombstone_Thread" )

    DNS_STATUS      status = ERROR_SUCCESS;
    ULONG           deleteStatus = LDAP_SUCCESS;
    DS_SEARCH       searchBlob;


    DNS_DEBUG( TOMBSTONE, ( "%s: start at %d (ldap=%p)\n", fn, DNS_TIME(), pServerLdap ));

    g_TombstoneThreadRunning = TRUE;

    Ds_InitializeSearchBlob( &searchBlob );

    // Search for tombstoned records
    // JJW: ds.c keeps stats with DS_SEARCH_START - should do that here?

    if ( startTombstoneSearch( &searchBlob ) != ERROR_SUCCESS )
        goto Cleanup;

    // Iterate through the entries in the paged LDAP search result.

    while ( 1 )
    {
        PLDAP_BERVAL *  ppvals = NULL;
        PDS_RECORD      pdsRecord = NULL;
        BOOL            isTombstoned = FALSE;
        ULARGE_INTEGER  tombstoneTime = { 0 };
        PWSTR           wdn = NULL;

        // Get the next search result.

        status = Ds_GetNextMessageInSearch( &searchBlob );
        if ( status != ERROR_SUCCESS )
        {
            ASSERT( status != LDAP_CONSTRAINT_VIOLATION );
            break;
        } // if

        // Retrieve the DN of the result. This is mostly for logging
        // but it does provide a sanity test on the record.

        wdn = ldap_get_dn( pServerLdap, searchBlob.pNodeMessage );
        DNS_DEBUG( TOMBSTONE, (
            "%s: found tombstoned entry %S\n",
            fn, wdn ? wdn : LDAP_TEXT( "NULL-DN" ) ));
        if ( !wdn || *wdn == 0 )
        {
            DNS_DEBUG( TOMBSTONE, (
                "%s: skipping tombstone search result (no dn)\n", fn ));
            if ( wdn )
                ldap_memfree( wdn ); // dn can be empty but not NULL
            continue; // Skip this result
        } // if

        // Read the DNS data blob out of the record. Check for the
        // correct record type and copy the tombstone time if this
        // is in fact a tombstoned record.
        // If the tombstoned record has no DNS data blob the record
        // has gotten screwy somehow so delete it.

        ppvals = ldap_get_values_len(
            pServerLdap,
            searchBlob.pNodeMessage,
            DSATTR_DNSRECORD );
        if ( ppvals && ppvals[ 0 ] )
        {
            pdsRecord = ( PDS_RECORD )( ppvals[0]->bv_val );
            if ( pdsRecord->wType == DNSDS_TOMBSTONE_TYPE )
            {
                isTombstoned = TRUE;
                memcpy( &tombstoneTime, &pdsRecord->Data,
                    sizeof( tombstoneTime ) );
            } // if
            else
            {
                DNS_DEBUG( TOMBSTONE, (
                    "%s: record found but record type is %d\n",
                    fn, ( int ) pdsRecord->wType ));
            } // else
        } // if
        else
        {
            DNS_DEBUG( TOMBSTONE, (
                "%s: deleting bogus tombstone %S\n", fn, wdn ));
            deleteStatus = ldap_delete_s( pServerLdap, wdn );
            if ( deleteStatus != LDAP_SUCCESS )
            {
                DNS_DEBUG( TOMBSTONE, (
                    "%s: error <%lu> deleting bogus tombstone %S\n",
                    fn, deleteStatus, wdn ));
            } // if
        } // else
        ldap_value_free_len( ppvals );
        ppvals = NULL;

        // If the record is tombstoned, see if the tombstone has expired.
        // Delete the record if the tombstone is expired.

        if ( isTombstoned )
        {
            ULARGE_INTEGER      now;

            GetSystemTimeAsFileTime( ( PFILETIME ) &now );

            DNS_DEBUG( TOMBSTONE, (
                "%s: tombstone age is %I64u (max %lu) seconds\n",
                fn, ( now.QuadPart - tombstoneTime.QuadPart ) / 10000000,
                ( ULONG ) SrvCfg_dwDsTombstoneInterval ));

            if ( now.QuadPart - tombstoneTime.QuadPart >
                 ( ULONGLONG )
                 SECONDS_IN_FILETIME( SrvCfg_dwDsTombstoneInterval ) )
            {
                DNS_DEBUG( TOMBSTONE, (
                    "%s: deleting tombstone %S\n", fn, wdn ));
                deleteStatus = ldap_delete_s( pServerLdap, wdn );
                if ( deleteStatus != LDAP_SUCCESS )
                {
                    DNS_DEBUG( TOMBSTONE, (
                        "%s: error <%lu> deleting tombstone %S\n",
                        fn, deleteStatus, wdn ));
                } // if
            } // if
        } // if

        ldap_memfree( wdn );
        wdn = NULL;
    } // while

    Cleanup:

    Ds_CleanupSearchBlob( &searchBlob );

    g_TombstoneThreadRunning = FALSE;
    DNS_DEBUG( TOMBSTONE, ( "%s: exit at %d\n", fn, DNS_TIME() ));
    Thread_Close( FALSE );
    return status;
} // Tombstone_Thread



DNS_STATUS
Tombstone_Trigger(
    VOID
    )
/*++

Routine Description:

    Main entry point for tombstone search and destroy. If more than
    24 hours have elapsed since the last time a tombstone thread was
    kicked off, then kick off another thread.

Arguments:

    Unreferenced.

Return Value:

    Status in win32 error space

--*/
{
    DBG_FN( "Tombstone_Trigger" )

    static DWORD lastTriggerTime = 0;
    #if 0


    #else

    static WORD lastRunHour = -1;
    SYSTEMTIME localTime;
    BOOL runNow = FALSE;
    WORD start_hour = 2;
    WORD recur_hour = 0;

    #endif

    //
    // We do not do any tombstone searching if the DS is not available.
    //

    if ( !SrvCfg_fDsAvailable )
    {
        DNS_DEBUG( TOMBSTONE, (
            "%s: DS unavailable\n", fn ));
        return ERROR_SUCCESS;
    } // if

    if ( !pServerLdap )
    {
        DNS_DEBUG( TOMBSTONE, (
            "%s: no server LDAP session\n", fn ));
        return ERROR_SUCCESS;
    } // if

    #if 0

    //
    // Create tombstone thread if proper time has passed since last run.
    //

    if ( !lastTriggerTime )
    {
        lastTriggerTime = DNS_TIME();
    } // if
    else if ( DNS_TIME() - lastTriggerTime > TRIGGER_INTERVAL &&
              !g_TombstoneThreadRunning )
    {
        if ( Thread_Create(
                "TombstoneThread",
                Tombstone_Thread,
                NULL,
                0 ) )
        {
            DNS_DEBUG( TOMBSTONE, (
                "Tombstone_Trigger: dispatched tombstone thread\n" ));
            lastTriggerTime = DNS_TIME();
        } // if
        else
        {
            DNS_PRINT(( "ERROR:  Failed to create tombstone thread!\n" ));
        } // else
    } // else if
    else
    {
        DNS_DEBUG( TOMBSTONE, (
            "Tombstone_Trigger: no thread dispatch at %d (interval %d)\n",
            DNS_TIME(), TRIGGER_INTERVAL ));
    } // else

    #else

    //
    // Decide if this is the right time to kick off a tombstone thread.
    //   for example:
    //   start_hour=2, recur_hour=0: run only at 2:00 every day
    //   start_hour=5, recur_hour=8: run at 5:00, 13:00, 21:00 every day
    //

    GetLocalTime( &localTime );
    if ( lastRunHour != localTime.wHour )
    {
        if ( recur_hour == 0 )
        {
            runNow = localTime.wHour == start_hour;
        } // if
        else if ( localTime.wHour >= start_hour )
        {
            runNow = ( localTime.wHour - start_hour ) % recur_hour == 0;
        } // else
    } // if

    //
    // Create tombstone thread if the time is right.
    //

    if ( runNow )
        {
        if ( Thread_Create(
                "TombstoneThread",
                Tombstone_Thread,
                NULL,
                0 ) )
        {
            DNS_DEBUG( TOMBSTONE, (
                "%s: dispatched tombstone thread\n", fn ));
            lastRunHour = localTime.wHour;
        } // if
        else
        {
            DNS_PRINT((
                "%s: ERROR - Failed to create tombstone thread!\n", fn ));
        } // else
    } // if
    else
    {
        DNS_DEBUG( TOMBSTONE, (
            "%s: no thread dispatch for %d:00 "
            "(start %d:00 every %d hours)\n",
            fn,
            ( int ) localTime.wHour,
            ( int ) start_hour,
            ( int ) recur_hour ));
    } // else

    #endif

    return ERROR_SUCCESS;
} // Tombstone_Start



DNS_STATUS
Tombstone_Initialize(
    VOID
    )
/*++

Routine Description:

    Initializes the tombstone searching system

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    return ERROR_SUCCESS;
}



VOID
Tombstone_Cleanup(
    VOID
    )
/*++

Routine Description:

    Cleanup tombstone searching system

Arguments:

    None

Return Value:

    None

--*/
{
}



//
//  End of tombston.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\udp.c ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    udp.c

Abstract:

    Receives and processes UDP DNS packets using i/o completion ports.

Author:

    Jim Gilroy,  November 1996

Revision History:

--*/

#include "dnssrv.h"

//
//  UDP completion port
//

HANDLE  g_hUdpCompletionPort;

//
//  Limit retries to protect against WSAECONNRESET nonsense
//
//  Retry on CONRESET for 10000 times then give up for unbind and
//      slow retry.
//  We retry on repeated GQCS failures at 10ms interval.
//

#define RECV_RETRY_MAX_COUNT            (10000)
#define RECV_RETRY_SLEEP_TIME           (10)

//
//  Recv counters to detect socket failures
//

DWORD   UdpRecvCount        = 0;
DWORD   LastUdpRecvTime     = 0;
DWORD   NextUdpLogTime      = 0;

#define UDP_RECV_TICK() \
        {               \
            UdpRecvCount++;                 \
            LastUdpRecvTime = DNS_TIME();   \
        }



VOID
Udp_DropReceive(
    IN OUT  PDNS_SOCKET     pContext
    )
/*++

Routine Description:

    Drop down UDP receive request.

Arguments:

    pContext -- context for socket being recieved

Return Value:

    None.

--*/
{
    PDNS_MSGINFO    pmsg;
    DNS_STATUS      status;

    IF_DEBUG( READ2 )
    {
        DNS_PRINT((
            "Drop WSARecvFrom on socket %d (thread=%p).\n",
            pContext->Socket,
            GetCurrentThreadId() ));
        ASSERT( pContext->Overlapped.Offset == 0
            &&  pContext->Overlapped.OffsetHigh == 0
            &&  pContext->Overlapped.hEvent == NULL );
    }

    //
    //  Check for service shutdown/pause.
    //

    if ( !Thread_ServiceCheck() )
    {
        DNS_DEBUG( SHUTDOWN, (
            "Udp_DropReceive detected shutdown -- returning\n" ));
        return;
    }

    ASSERT( pContext->State != SOCKSTATE_UDP_RECV_DOWN );

    //
    //  get DNS message buffer
    //
    //  DEVNOTE: allocation failure handling
    //

    pmsg = Packet_AllocateUdpMessage();
    IF_NOMEM( !pmsg )
    {
        ASSERT( FALSE );
        return;
    }

    pContext->pMsg = pmsg;
    pContext->WsaBuf.len = pmsg->MaxBufferLength;
    pContext->WsaBuf.buf = (PCHAR) DNS_HEADER_PTR(pmsg);
    pContext->RecvfromFlags = 0;

    pmsg->Socket = pContext->Socket;


    //
    //  loop until successful WSARecvFrom() is down
    //
    //  this loop is only active while we continue to recv
    //  WSAECONNRESET or WSAEMSGSIZE errors, both of which
    //  cause us to dump data and retry;
    //
    //  note loop rather than recursion (to this function) is
    //  required to avoid possible stack overflow from malicious
    //  send
    //
    //  normal returns from WSARecvFrom() are
    //      SUCCESS -- packet was waiting, GQCS will fire immediately
    //      WSA_IO_PENDING -- no data yet, GQCS will fire when ready
    //

    while ( 1 )
    {
        pContext->State = SOCKSTATE_UDP_RECV_DOWN;

        status = WSARecvFrom(
                    pContext->Socket,
                    & pContext->WsaBuf,
                    1,
                    & pContext->BytesRecvd,
                    & pContext->RecvfromFlags,
                    (PSOCKADDR) & pmsg->RemoteAddress,
                    & pmsg->RemoteAddressLength,
                    & pContext->Overlapped,
                    NULL );

        if ( status == ERROR_SUCCESS )
        {
            DNS_DEBUG( RECV, (
                "WSARecvFrom( %d ) immediate completion %d bytes.\n",
                pContext->Socket,
                pContext->BytesRecvd ));
            pContext->fRetry = 0;
            return;
        }

        status = GetLastError();
        if ( status == WSA_IO_PENDING )
        {
            DNS_DEBUG( RECV, (
                "WSARecvFrom( %d ) WSA_IO_PENDING.\n",
                pContext->Socket ));
            pContext->fRetry = 0;
            return;
        }

        //
        //  if we are doing processing here, then it means completion port
        //      should not be waking folks on these errors
        //

        ASSERT( pContext->State == SOCKSTATE_UDP_RECV_DOWN ||
                pContext->State == SOCKSTATE_DEAD );

        if ( pContext->State != SOCKSTATE_UDP_RECV_DOWN )
        {
            DWORD   state = pContext->State;

            DnsDbg_Lock();
            DNS_DEBUG( ANY, (
                "ERROR:  WSARecvFrom() failed with socket %d in state %d\n"
                "\tthread = %p\n",
                pContext->Socket,
                state,
                GetCurrentThreadId() ));
            Dbg_SocketContext(
                "WSARecvFrom() failed socket in incorrect state\n"
                "\tnote state shown below may be altered!\n",
                pContext );
            DnsDbg_Unlock();

            if ( state == SOCKSTATE_DEAD )
            {
                ASSERT( status == WSAENOTSOCK );
                Sock_CleanupDeadSocketMessage( pContext );
            }
            ELSE_ASSERT_FALSE;

            Log_SocketFailure(
                "ERROR:  RecvFrom failure in weird state.",
                pContext,
                status );
            return;
        }

        pContext->State = SOCKSTATE_UDP_RECV_ERROR;

        DNS_DEBUG( RECV, (
            "WSARecvFrom() error %d %p.\n"
            "\tpContext = %p\n"
            "\tsocket   = %d\n"
            "\tthread   = %p\n",
            status, status,
            pContext,
            pContext->Socket,
            GetCurrentThreadId() ));

        //
        //  new winsock feature returns WSAECONNRESET when last send ICMP'd
        //      - set flag to indicate retry and repost send
        //      - if over some reasonable number of retries, assume error
        //          and fall through recv failure code
        //

        if ( status == WSAECONNRESET )
        {
            DNS_DEBUG( RECV, ( "WSARecvFrom() WSAECONNRESET.\n" ));
            if ( pContext->fRetry < RECV_RETRY_MAX_COUNT )
            {
                DNS_DEBUG( RECV, (
                    "WSARecvFrom( %d ) ECONNRESET (retry=%d).\n",
                    pContext->Socket,
                    pContext->fRetry ));
                pContext->fRetry++;
                STAT_INC( PrivateStats.UdpConnResets );
                continue;
            }
            DNS_DEBUG( ANY, (
                "ERROR:  unsuccessful in shaking CONNRESET in %d retries\n"
                "\tIndicating recv() error on socket %d to avoid cycle on this\n"
                "\tthread.\n",
                pContext->fRetry,
                pContext->Socket ));

            STAT_INC( PrivateStats.UdpConnResetRetryOverflow );
        }

        //
        //  message too big
        //      - treat like truncated message
        //
        //  DEVNOTE: treat WSAEMSGSIZE like trunctated message
        //

        if ( status == WSAEMSGSIZE )
        {
            DNS_DEBUG( RECV, (
                "WSARecvFrom( %d ) EMSGSIZE (retry=%d).\n",
                pContext->Socket,
                pContext->fRetry ));

            STAT_INC( PrivateStats.UdpErrorMessageSize );
            continue;
        }

        //
        //  DEVNOTE: Plug+Play may byte us on WSARecvFrom, need to cleanup
        //      gracefully
        //  note, I believe we can return cleanly GetQueuedCompletionStatus()
        //  will get new context
        //  if add PnP event, the event handling must generate all init on
        //  socket

        if ( ! Thread_ServiceCheck() )
        {
            DNS_DEBUG( SHUTDOWN, (
                "WSARecvFrom failed (%d) due to shutdown -- returning\n",
                status ));
            return;
        }

        //
        //  check for PnP delete of socket
        //  note, socket list is locked for entire time we do PnP reconfig
        //      so when GetAssociateIpAddr() returns we only have valid
        //      address if socket is still enlisted

        if ( Sock_GetAssociatedIpAddr(pContext->Socket) == DNS_INVALID_IP )
        {
            DNS_DEBUG( SOCKET, (
                "WSARecvFrom( %d ) failure, socket no longer enlisted.\n"
                "\tcontext ptr = %p\n",
                pContext->Socket,
                pContext ));

            Sock_CleanupDeadSocketMessage( pContext );
            return;
        }

        //
        //  recvfrom() failure with active socket
        //      - set global flag to indicate retry after timeout
        //      - log event
        //

        Packet_FreeUdpMessage( pmsg );
        STAT_INC( PrivateStats.UdpRecvFailure );
        Sock_IndicateUdpRecvFailure( pContext, status );

        DNS_PRINT((
            "ERROR: WSARecvFrom( %d ) failed = %d\n"
            "\tcontext ptr %p\n",
            pContext->Socket,
            status,
            pContext ));

#if DBG
        DNS_LOG_EVENT(
           DNS_EVENT_RECVFROM_CALL_FAILED,
           0,
           NULL,
           NULL,
           status );
#endif
        return;
    }
}



BOOL
Udp_RecvThread(
    IN      LPVOID  pvDummy
    )
/*++

Routine Description:

    UDP receiving thread.

    Loops waiting on sockets, recieving then processing DNS requests.

Arguments:

    pvDummy -- unused

Return Value:

    TRUE on normal service shutdown
    FALSE on socket error

--*/
{
    PDNS_SOCKET   pcontext;
    PDNS_MSGINFO  pmsg;
    DNS_STATUS    status;
    DWORD         bytesRecvd;
    LPOVERLAPPED  poverlapped;


    DNS_DEBUG( INIT, ( "\nStart UDP receive thread.\n" ));

    //  hold off processing until started

    if ( ! Thread_ServiceCheck() )
    {
        DNS_DEBUG( ANY, ( "Terminating UDP thread.\n" ));
        return( 1 );
    }

    //
    //  loop receiving and processing packets, until service shutdown
    //

    while ( TRUE )
    {
        pcontext = NULL;        //  PREFIX paranoia

        //
        //  Wait for incoming packet
        //

        if ( ! GetQueuedCompletionStatus(
                    g_hUdpCompletionPort,
                    & bytesRecvd,
                    & (ULONG_PTR) pcontext,
                    & poverlapped,
                    INFINITE ) )
        {
            DWORD   state = 0;

            status = GetLastError();
#if 0
            // ideal to fast path this, but avoid too much duplicate code
            //
            //  ICMP port unreachable
            //      when response is late, and client has left (hence no port)
            //      socket is indicated with conn-reset (WSARecvFrom)
            //      or port-unreachable GQCS
            //
            //  DEVNOTE: perhaps a similar error when clients IP is entirely
            //      down, should trap it also

            if ( status == ERROR_PORT_UNREACHABLE )
            {
                STAT_INC( PrivateStats.UdpGQCSConnReset );

                if ( pcontext )
                {
                    pcontext->State = SOCKSTATE_UDP_GQCS_ERROR;
                    DNS_DEBUG( SOCKET, (
                        "GQCS port-unreachable on socket %d (%p)\n"
                        "\ttime         = %d\n"
                        "\tpcontext     = %p\n",
                        pcontext ? pcontext->Socket : 0,
                        pcontext ? pcontext->Socket : 0,
                        DNS_TIME(),
                        pcontext ));

                    //  free message (if any)
                    //  redrop recv
                    //  wait again in GQCS

                    Packet_FreeUdpMessage( pcontext->pMsg );
                    Udp_DropReceive( pcontext );
                }
                continue;
            }
#endif
            //
            //  if fail with socket context, MUST own context
            //  no other thread should own context
            //
            //  if detect another thread messing with context, then
            //  clear context -- it belongs to other guy
            //

            if ( pcontext )
            {
                state = pcontext->State;

                //
                //  winsock -- if shutdown just get outta dodge, don't
                //      expect that they haven't woken 27 threads on this socket
                //

                if ( fDnsServiceExit )
                {
                    DNS_DEBUG( SHUTDOWN, ( "\nTerminating UDP receive thread.\n" ));

                    IF_DEBUG( ANY )
                    {
                        if ( state != SOCKSTATE_UDP_RECV_DOWN &&
                             state != SOCKSTATE_DEAD &&
                             state != SOCKSTATE_UDP_GQCS_ERROR )
                        {
                            DNS_DEBUG( ANY, (
                                "Winsock getting weird on me again during socket shutdown:\n"
                                "\tsocket handle    = %d\n"
                                "\tsock state       = %d\n",
                                pcontext->Socket,
                                pcontext->State ));
                        }
                    }
                    return( 1 );
                }

                //  DEVNOTE: winsock has a bug waking up multiple threads on socket close
                //      so it's possible on shutdown to also have the GQCS
                //      state set by first woken thread, when second comes through
                //      hence the additional shutdown case
                //
                //      now i've also seen a bug here where state = UDP_COMPLETE which
                //      again implies that winsock has woken another thread which is
                //      processing this socket (this context);  this is handled by
                //      the second case which just bails from the context
                //

                ASSERT( state == SOCKSTATE_UDP_RECV_DOWN || state == SOCKSTATE_DEAD
                    || (fDnsServiceExit && state == SOCKSTATE_UDP_GQCS_ERROR) );

                //
                //  normal failure
                //      - signal in failed state
                //      - fall through to standard failure processing below

                if ( state == SOCKSTATE_UDP_RECV_DOWN )
                {
                    pcontext->State = SOCKSTATE_UDP_GQCS_ERROR;
                }

                //
                //  socket dead (probably via PnP)
                //      - standard cleanup

                else if ( state == SOCKSTATE_DEAD )
                {
                    Log_SocketFailure(
                        "ERROR:  GQCS failure on dead socket.",
                        pcontext,
                        status );

                    Sock_CleanupDeadSocketMessage( pcontext );
                    pcontext = NULL;
                }
                else
                {
#if 0
                    if ( fDnsServiceExit )
                    {
                        DNS_DEBUG( SHUTDOWN, ( "\nTerminating UDP receive thread.\n" ));
                        return( 1 );
                    }
#endif
                    DNS_DEBUG( ANY, (
                        "ERROR:  GQCS() failed with socket %d in state %d\n"
                        "\tthread = %p\n",
                        pcontext->Socket,
                        state,
                        GetCurrentThreadId() ));
                    Dbg_SocketContext(
                        "GCQS() failed socket in incorrect state\n"
                        "\tnote state shown below has been altered!\n",
                        pcontext );

                    Log_SocketFailure(
                        "ERROR:  GQCS failure in weird state.",
                        pcontext,
                        status );
                    ASSERT( FALSE );
                    pcontext = NULL;
                }
            }

            //
            //  if i/o failed, check for shutdown
            //
            //  errors seen:
            //      995 (operation aborted) -- on socket close
            //      1234 (port unreachable) -- ICMP port unreachable \ WSAECONNRESET
            //

            if ( ! Thread_ServiceCheck() )
            {
                DNS_DEBUG( SHUTDOWN, (
                    "\nTerminating UDP receive thread.\n" ));
                return( 1 );
            }
#if DBG
            //  exclude port-unreach errors from ANY print

            if ( status != ERROR_PORT_UNREACHABLE )
            {
                DNS_DEBUG( ANY, (
                    "ERROR:  GetQueuedCompletionStatus (GQCS) failed %d (%p)\n"
                    "\tthread id    = %d\n"
                    "\ttime         = %d\n"
                    "\tpcontext     = %p\n"
                    "\tbytesRecvd   = %d\n",
                    status, status,
                    GetCurrentThreadId(),
                    DNS_TIME(),
                    pcontext,
                    bytesRecvd ));
                if ( pcontext )
                {
                    Dbg_SocketContext(
                        "GCQS() failure context\n",
                        pcontext );
                }
            }
#endif
            STAT_INC( PrivateStats.UdpGQCSFailure );

            //
            //  no socket context? -- continue wait on GQCS()
            //

            if ( !pcontext )
            {
                continue;
            }

            //
            //  socket context with failure
            //      - attempt to restart recv() on socket
            //      - then continue to wait on GQCS()
            //
            //  DEVNOTE: need action here -- restart all UDP sockets?
            //                  rebuild new completion port?
            //

            STAT_INC( PrivateStats.UdpGQCSFailureWithContext );

            if ( status == ERROR_PORT_UNREACHABLE )
            {
                STAT_INC( PrivateStats.UdpGQCSConnReset );
            }

            Packet_FreeUdpMessage( pcontext->pMsg );

            //
            //  keep dropping recv
            //  Udp_DropReceive has code to handle the retry\giveup-unbind-retry issue
            //
            //  but avoid CPU spin, if continually banging on this go into very
            //  light (10ms) sleep to allow any other socket to run
            //

            if ( pcontext->fRetry > RECV_RETRY_MAX_COUNT )
            {
                Log_SocketFailure(
                    "ERROR:  GQCS failure forcing socket sleep.",
                    pcontext,
                    status );

                Sleep( RECV_RETRY_SLEEP_TIME );
            }
            Udp_DropReceive( pcontext );
            continue;
        }

        //
        //  successful completion
        //

        #if DBG

        //
        //  Verify that winsock has not written too many bytes to the packet.
        //

        if ( pcontext && pcontext->pMsg )
        {
            if ( bytesRecvd > pcontext->pMsg->MaxBufferLength )
            {
                DNS_DEBUG( ANY, (
                    "FATAL: too many bytes: %d expected max %d msg %p\n",
                    bytesRecvd,
                    pcontext->pMsg->MaxBufferLength,
                    pcontext->pMsg ));
                HARD_ASSERT( bytesRecvd <= pcontext->pMsg->MaxBufferLength );
            }

            //
            //  NOTE: this is expensive!
            //

            //  HeapDbgValidateAllocList();
        }

        #endif  //  DBG
       
        //  check if main thread signalling service shutdown

        if ( !pcontext )
        {
            if ( ! Thread_ServiceCheck() )
            {
                DNS_DEBUG( SHUTDOWN, ( "\nTerminating UDP receive thread.\n" ));
                return( 1 );
            }
            ASSERT( FALSE );
            continue;
        }

        #if DBG
        if ( pcontext->State != SOCKSTATE_UDP_RECV_DOWN )
        {
            DNS_DEBUG( ANY, (
                "unexpected socket state %ul for %d %s %p\n",
                pcontext->State,
                pcontext->Socket,
                IP_STRING( pcontext->ipAddr ),
                pcontext ));
        }
        #endif

        ASSERT( pcontext->State == SOCKSTATE_UDP_RECV_DOWN );
        pcontext->State = SOCKSTATE_UDP_COMPLETED;

        //
        //  get message info from context
        //
        //  immediately clear pMsg from context so that alternative
        //  GQCS wakeup (like socket close) will not have ptr to message
        //  in use;
        //  this should NOT be necessary, but reliablity of
        //  GQCS not to wakeup before WSARecvFrom (and hence new pMsg)
        //  is in some doubt;
        //      - there seem to be cases where it wakes up even when WSARecvFrom()
        //      fails through
        //      - also may wake up on socket close, before WSARecvFrom() reposts
        //      completion request
        //

        pmsg = pcontext->pMsg;
        if ( !pmsg )
        {
            DNS_PRINT((
                "ERROR:  no message came back with pcontext = %p\n",
                pcontext ));
            ASSERT( FALSE );

            Udp_DropReceive( pcontext );
            continue;
        }
        pcontext->pMsg = NULL;
        pcontext->fRetry = 0;

        DNS_DEBUG( RECV2, (
            "I/O completion:\n"
            "\tbytes recvd      = %d\n"
            "\toverlapped       = %p\n"
            "\tpcontext         = %p\n"
            "\t\tpmsg           = %p\n"
            "\t\toverlapped     = %p\n"
            "\t\tsocket         = %d\n"
            "\t\tbytes recvd    = %d\n",
            bytesRecvd,
            poverlapped,
            pcontext,
            pcontext->pMsg,
            & pcontext->Overlapped,
            pcontext->Socket,
            pcontext->BytesRecvd ));

        ASSERT( pmsg->Socket == pcontext->Socket
            &&  &pcontext->Overlapped == poverlapped );

        //  track successful recv

        UDP_RECV_TICK();


        //
        //  Check and possibly wait on service status
        //      - even if pause dump packet as now useless
        //

        if ( fDnsThreadAlert )
        {
            DNS_DEBUG( RECV, ( "\nThread alert in UDP recv thread.\n" ));

            if ( ! Thread_ServiceCheck() )
            {
                DNS_DEBUG( SHUTDOWN, ( "\nTerminating UDP receive thread.\n" ));
                return( 1 );
            }
            Packet_FreeUdpMessage( pmsg );
            Udp_DropReceive( pcontext );
            continue;
        }

        //
        //  drop another recv on socket
        //  do this here rather than after processing -- so that if
        //  on MP machine, we can have another thread receive and
        //  process message from this socket
        //

        Udp_DropReceive( pcontext );

        //
        //  received packet stats
        //

        if ( pmsg->Head.IsResponse )
        {
            STAT_INC( QueryStats.UdpResponsesReceived );
        }
        else
        {
            STAT_INC( QueryStats.UdpQueries );
            PERF_INC( pcUdpQueryReceived );
            PERF_INC( pcTotalQueryReceived );
        }

        //
        //  set info / header
        //      - set for UDP
        //      - save length
        //      - flip XID and RR count bytes
        //

        SET_MESSAGE_FIELDS_AFTER_RECV( pmsg );
        pmsg->MessageLength = ( WORD ) bytesRecvd;

        DNSMSG_SWAP_COUNT_BYTES( pmsg );

        DNS_LOG_MESSAGE_RECV( pmsg );

        IF_DEBUG( RECV )
        {
            Dbg_DnsMessage(
                "Received UDP packet",
                pmsg );
        }

        //  process the packet

        #if DBG
        if ( SrvCfg_fTest9 )
        {
            DNS_DEBUG( ANY, ( "fTest9: ignoring UDP packet\n" ));
        }
        else
        #endif

        Answer_ProcessMessage( pmsg );

        //
        //  for debug dump statistics every so often
        //

        IF_DEBUG( ANY )
        {
            if ( QueryStats.UdpQueries == 10 )
            {
                Dbg_Statistics();
            }
            if ( ! (QueryStats.UdpQueries % 10000) )
            {
                Dbg_Statistics();
            }
        }

        //  loop back to wait on next available message
    }
}



VOID
Udp_RecvCheck(
    VOID
    )
/*++

Routine Description:

    Check that UDP socket recv is functioning properly.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD timeDelta;

    //  no action if not logging

    if ( !SrvCfg_dwQuietRecvLogInterval )
    {
        return;
    }

    //
    //  if received packets since last check -- we're fine
    //

    if ( UdpRecvCount )
    {
        UdpRecvCount = 0;
        return;
    }

    //  reset time on startup

    if ( LastUdpRecvTime == 0 )
    {
        LastUdpRecvTime = DNS_TIME();
    }

    //
    //  test if recv quiet for a long interval
    //      - but count loggings and only log once per log interval
    //
    //  note:  none of these globals are protected by CS, so entirely
    //      possible for recv thread to reset while in this function
    //      but effect is limited to:
    //      - an extra logging, right when recv counted
    //      (RecvFailureLogCount dropped after timeDelta calculated)
    //      - or logging or faulting appropriately, but immediately
    //      after recv has reset globals (only problem is that in
    //      debugging globals won't look correct)
    //

    timeDelta = DNS_TIME() - LastUdpRecvTime;

    if ( timeDelta < SrvCfg_dwQuietRecvLogInterval ||
        DNS_TIME() < NextUdpLogTime )
    {
        return;
    }

    Log_Printf(
        "WARNING:  No recv for %d seconds\r\n",
        timeDelta
        );
    NextUdpLogTime = DNS_TIME() + SrvCfg_dwQuietRecvLogInterval;

    //
    //  quiet a REALLY long time -- fault
    //

    if ( SrvCfg_dwQuietRecvFaultInterval &&
        timeDelta > SrvCfg_dwQuietRecvFaultInterval )
    {
        DNS_DEBUG( ANY, (
            "Recv quiet for longer than fault interval %d -- fault now!\n",
            SrvCfg_dwQuietRecvFaultInterval
            ));
        HARD_ASSERT( FALSE );
    }
}



DNS_STATUS
Udp_CreateReceiveThreads(
    VOID
    )
/*++

Routine Description:

    Setup UDP I/O and dispatch threads.

Arguments:

    None.

Return Value:

    TRUE if successful.
    FALSE if failure.

--*/
{
    PDNS_SOCKET     pcontext;
    DWORD           countUdpThreads;
    DWORD           i;
    SOCKET          s;
    HANDLE          hport;
    DWORD           status;

    //
    //  calculate number of worker threads to create
    //      - twice total processors in system (Paula Tomlison
    //      assuming so that with blocked threads (on send?), still
    //      thread to run on processor)
    //
    //  DEVNOTE: like to set number of threads limit
    //      - low  >= 2
    //      - high  above say 4 processors, processors * 80% for scaling
    //

    countUdpThreads = g_ProcessorCount * 2;

    //
    //  setup sockets with completion port
    //  then drop initial receive on each socket
    //

    status = Sock_StartReceiveOnUdpSockets();
    if ( status != ERROR_SUCCESS )
    {
        ASSERT( FALSE );
        //  DEVNOTE: figure out what to do here, if started on some
        //              sockets continue
        //return( FALSE );
    }

    //
    //  dispatch UDP recv() threads
    //

    for ( i=0; i<countUdpThreads; i++ )
    {
        if ( ! Thread_Create(
                    "UDP Listen",
                    Udp_RecvThread,
                    (PVOID) 0,
                    0 ) )
        {
            DNS_PRINT((
                "ERROR:  failed to create UDP recv thread %d\n",
                i ));
            ASSERT( FALSE );
            return( ERROR_SERVICE_NO_THREAD );
        }
    }

    return( ERROR_SUCCESS );
}


#if 0

DNS_STATUS
Udp_StartReceiveOnSocket(
    IN      SOCKET      Socket
    )
/*++

Routine Description:

    Start receive on given UDP socket.

Arguments:

    Socket -- socket to start receive on.

Return Value:

   ERROR_SUCCESS if successful
   Error code on failure.

--*/
{
    PDNS_SOCKET   pcontext;
    HANDLE              hport;

    //
    //  create context for socket
    //  this is returned by the GetQueuedCompletionStatus() call
    //

    pcontext = ALLOC_TAGHEAP( sizeof(DNS_SOCKET), MEMTAG_SOCKET );
    IF_NOMEM( !pcontext )
    {
        return( GetLastError() );
    }

    pcontext->Socket = Socket;
    pcontext->Overlapped.Offset = 0;
    pcontext->Overlapped.OffsetHigh = 0;
    pcontext->Overlapped.hEvent = NULL;

    hport = CreateIoCompletionPort(
                (HANDLE) pcontext->Socket,
                g_hUdpCompletionPort,
                (DWORD) pcontext,
                0       // threads matched to system processors
                );
    if ( !hport )
    {
        DNS_PRINT(( "ERROR: in CreateIoCompletionPort\n" ));
        ASSERT( FALSE );
        return( GetLastError() );
    }
    ASSERT( hport == g_hUdpCompletionPort );

    DNS_DEBUG( INIT, (
        "Created i/o context %p for UDP socket %d\n"
        "\toverlapped ptr = %p\n",
        pcontext,
        pcontext->Socket,
        &pcontext->Overlapped ));

    Udp_DropReceive( pcontext );

    return( ERROR_SUCCESS );
}
#endif



VOID
Udp_ShutdownListenThreads(
    VOID
    )
/*++

Routine Description:

    Shutdown UDP listen threads.
    All threads do not necessarily terminate due to socket
    closure as they are not directly associated with a socket.

Arguments:

    None.

Return Value:

    TRUE if successful.
    FALSE if failure.

--*/
{
    HANDLE hport = g_hUdpCompletionPort;

    //  wake up threads hung in wait

    PostQueuedCompletionStatus(
        g_hUdpCompletionPort,
        0,
        0,
        NULL );

    //
    //  if allowing UDP threads to shutdown, then have concurrency issue
    //      avoiding double close or NULL close
    //  interlocked set value?

    g_hUdpCompletionPort = NULL;
    if ( !hport )
    {
        CloseHandle( hport );
    }
}

//
//  End udp.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\tree.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    tree.h

Abstract:

    Domain Name System (DNS) Server

    N-Tree definitions and declarations.
    N-Tree is used for DNS database.

Author:

    Jim Gilroy (jamesg)     Feb 25, 1995

Revision History:

    October 1996    jamesg  -   B-tree sibling list with multi-level drop
                                down hash

--*/


#ifndef _TREE_H_INCLUDED_
#define _TREE_H_INCLUDED_


#if DBG
#define TREE_ID_VALID 0xADED
#define TREE_ID_DONE 0xFFED
#endif


//
//  Implementation Note:
//
//  Domain names are stored in original case in database.  Pre RFC name
//  recovery is desirable.  Use a DWORD first four bytes downcased for
//  fast comparison -- even in huge domain this will get binary search
//  down to just a few (often no) names that need case insensitive
//  comparsion.
//
//  Using a default length for the label that encompassed most cases
//  and allows lables at this length or smaller to be stored in standard
//  sized blocks -- which simplifies memory use.
//  This standard length should be adjusted to keep the end of the
//  structure DWORD aligned.
//

#define STANDARD_NODE_LABEL_LENGTH  (15)


//
//  Tree definition
//
//  Note:  nice to dump reference count, but can not unitl another
//      way to handle update list reference issue.
//  One possibility would be a single bit.  Node stays if referenced
//  in update list at all.
//

typedef struct _DnsTreeNode
{
    struct _DnsTreeNode * pParent;      //  parent

    //  sibling B-Tree

    struct _DnsTreeNode * pSibUp;       //  sibling parent
    struct _DnsTreeNode * pSibLeft;     //  left sibling
    struct _DnsTreeNode * pSibRight;    //  right sibling

    //  offset 16\32

    struct _DnsTreeNode * pChildren;    //  child tree

    PVOID       pZone;                  // ptr to zone for node
    PVOID       pRRList;

    DWORD       dwCompare;              //  first four byte of name, for quick compare

    //  offset 32\60

    ULONG       cChildren;              //  count of children

    //  offset 36\64
    WORD        wNodeFlags;             //  flags
    UCHAR       uchAuthority;           //  authority, zone, delegation, outside
    UCHAR       cReferenceCount;        //  references to node

    //  offset 40\68
    UCHAR       uchAccessBin;           //  timeout bin of last access to node
    UCHAR       uchTimeoutBin;          //  timeout bin node is in

    UCHAR       cLabelCount;            //  label count
    UCHAR       cchLabelLength;

    //  offset 44\72

    CHAR        szLabel[ STANDARD_NODE_LABEL_LENGTH+1 ];

    //  end offset 60\88

    //
    //  Variable length allocation
    //
    //  Node's with labels longer than default length, will have size
    //  allocated will that extend szLabel to accomodate NULL
    //  terminated string for its label.
    //
}
DB_NODE, *PDB_NODE;

typedef const DB_NODE  *PCDB_NODE;

#define DB_NODE_FIXED_LENGTH    (sizeof(DB_NODE) - STANDARD_NODE_LABEL_LENGTH)

#define DB_REVERSE_ZONE_ROOT    ( &((PDB_NODE)REVERSE_TABLE)->pRRList )
#define DB_REVERSE_ZONE_DATA    ( &((PDB_NODE)REVERSE_DATA_TABLE)->pZone )


//
//  Tree Node Flags
//

//  Node state

#define NODE_NOEXIST            0x0001      //  cached name error
#define NODE_THIS_HOST          0x0002      //  DNS server's host node
#define NODE_TOMBSTONE          0x0004      //  Node is DS-tombstoned
#define NODE_SECURE_EXPIRED     0x0008      //  Node security info has exprired (pre- zone secure time)

//  Node database properties

#define NODE_ZONE_ROOT          0x0010
#define NODE_CNAME              0x0020
#define NODE_WILDCARD_PARENT    0x0040
#define NODE_AUTH_ZONE_ROOT     0x0100
#define NODE_ZONETREE           0x0200

//
// additional node properties (since we're running out of space here
//
#define NODE_ADMIN_RESERVED     0x0400
#define NODE_AVAIL_TO_AUTHUSER  0x0800


//  Permanent properties

#define NODE_IN_TIMEOUT         0x1000      // node in timeout list
#define NODE_FORCE_ENUM         0x2000
#define NODE_SELECT             0x4000
#define NODE_NO_DELETE          0x8000


//
//  DEVNOTE: cleanup these security check macros;
//      pretty sure they're unnecessary;  at best they should
//      be flagged here as purely temp node issues that could
//      be overloaded if necessary (better might be overloading
//      node timeout stuff, as temp nodes not queued for timeout)
//

//
//  Node property checks
//

#define IS_NOEXIST_NODE(pNode)      ( (pNode)->wNodeFlags & NODE_NOEXIST )

#define IS_THIS_HOST_NODE(pNode)    ( (pNode)->wNodeFlags & NODE_THIS_HOST )
#define IS_TOMBSTONE_NODE(pNode)    ( (pNode)->wNodeFlags & NODE_TOMBSTONE )
#define IS_ZONE_ROOT(pNode)         ( (pNode)->wNodeFlags & NODE_ZONE_ROOT )
#define IS_AUTH_ZONE_ROOT(pNode)    ( (pNode)->wNodeFlags & NODE_AUTH_ZONE_ROOT )
#define IS_CNAME_NODE(pNode)        ( (pNode)->wNodeFlags & NODE_CNAME )
#define IS_WILDCARD_PARENT(pNode)   ( (pNode)->wNodeFlags & NODE_WILDCARD_PARENT )
#define IS_TIMEOUT_NODE(pNode)      ( (pNode)->wNodeFlags & NODE_IN_TIMEOUT     )
#define IS_ENUM_NODE(pNode)         ( (pNode)->wNodeFlags & NODE_FORCE_ENUM )
#define IS_NODE_NO_DELETE(pNode)    ( (pNode)->wNodeFlags & NODE_NO_DELETE )
//#define IS_SELECT_NODE(pNode)       ( (pNode)->wNodeFlags & NODE_SELECT )
#define IS_SELECT_NODE(pNode)       ( FALSE )
#define IS_ZONETREE_NODE(pNode)     ( (pNode)->wNodeFlags & NODE_ZONETREE )

#define IS_SECURE_EXPIRED_NODE(pNode)   ( (pNode)->wNodeFlags & NODE_SECURE_EXPIRED )

#define IS_AVAIL_TO_AUTHUSER(pNode)     ( (pNode)->wNodeFlags & NODE_AVAIL_TO_AUTHUSER )

#define IS_SECURITY_UPDATE_NODE(pNode)  ( (pNode)->wNodeFlags &      \
                                          ( NODE_TOMBSTONE      |    \
                                            NODE_SECURE_EXPIRED))

//
//  Node property set/clear
//

#define SET_NOEXIST_NODE(pNode)     ( (pNode)->wNodeFlags |= NODE_NOEXIST )
#define SET_THIS_HOST_NODE(pNode)   ( (pNode)->wNodeFlags |= NODE_THIS_HOST )
#define SET_TOMBSTONE_NODE(pNode)   ( (pNode)->wNodeFlags |= NODE_TOMBSTONE )
#define SET_SECURE_EXPIRED_NODE(pNode)   ( (pNode)->wNodeFlags |= NODE_SECURE_EXPIRED )
#define SET_AVAIL_TO_AUTHUSER_NODE(pNode)   ( (pNode)->wNodeFlags |= NODE_AVAIL_TO_AUTHUSER )
#define SET_NEW_NODE(pNode)         ( (pNode)->wNodeFlags |= NODE_NEW_ZONE )
#define SET_ZONE_ROOT(pNode)        ( (pNode)->wNodeFlags |= NODE_ZONE_ROOT )
#define SET_AUTH_ZONE_ROOT(pNode)   ( (pNode)->wNodeFlags |= NODE_AUTH_ZONE_ROOT )
#define SET_CNAME_NODE(pNode)       ( (pNode)->wNodeFlags |= NODE_CNAME )
#define SET_WILDCARD_PARENT(pNode)  ( (pNode)->wNodeFlags |= NODE_WILDCARD_PARENT )
#define SET_TIMEOUT_NODE(pNode)     ( (pNode)->wNodeFlags |= NODE_IN_TIMEOUT )
#define SET_ENUM_NODE(pNode)        ( (pNode)->wNodeFlags |= NODE_FORCE_ENUM )
#define SET_SELECT_NODE(pNode)      ( (pNode)->wNodeFlags |= NODE_SELECT )
#define SET_NODE_NO_DELETE(pNode)   ( (pNode)->wNodeFlags |= NODE_NO_DELETE )
#define SET_ZONETREE_NODE(pNode)    ( (pNode)->wNodeFlags |= NODE_ZONETREE )

#define CLEAR_NOEXIST_NODE(pNode)   ( (pNode)->wNodeFlags &= ~NODE_NOEXIST )
#define CLEAR_THIS_HOST_NODE(pNode)   ( (pNode)->wNodeFlags &= ~NODE_THIS_HOST )
#define CLEAR_TOMBSTONE_NODE(pNode)   ( (pNode)->wNodeFlags &= ~NODE_TOMBSTONE )
#define CLEAR_SECURE_EXPIRED_NODE(pNode)   ( (pNode)->wNodeFlags &= ~NODE_SECURE_EXPIRED )

#define CLEAR_AVAIL_TO_AUTHUSER_NODE(pNode)   ( (pNode)->wNodeFlags &= ~NODE_AVAIL_TO_AUTHUSER )
#define CLEAR_NEW_NODE(pNode)       ( (pNode)->wNodeFlags &= ~NODE_NEW_ZONE )
#define CLEAR_ZONE_ROOT(pNode)      ( (pNode)->wNodeFlags &= ~NODE_ZONE_ROOT )
#define CLEAR_AUTH_ZONE_ROOT(pNode) ( (pNode)->wNodeFlags &= ~NODE_AUTH_ZONE_ROOT )
#define CLEAR_CNAME_NODE(pNode)     ( (pNode)->wNodeFlags &= ~NODE_CNAME )
#define CLEAR_WILDCARD_PARENT(pNode)( (pNode)->wNodeFlags &= ~NODE_WILDCARD_PARENT )
#define CLEAR_TIMEOUT_NODE(pNode)   ( (pNode)->wNodeFlags &= ~NODE_IN_TIMEOUT )
#define CLEAR_ENUM_NODE(pNode)      ( (pNode)->wNodeFlags &= ~NODE_FORCE_ENUM )
#define CLEAR_NODE_NO_DELETE(pNode) ( (pNode)->wNodeFlags &= ~NODE_NO_DELETE )
#define CLEAR_ZONETREE_NODE(pNode)  ( (pNode)->wNodeFlags &= ~NODE_ZONETREE )

#define CLEAR_TOMBSTONE_NODE(pNode)         ( (pNode)->wNodeFlags &= ~NODE_TOMBSTONE )
#define CLEAR_SECURE_EXPIRED_NODE(pNode)    ( (pNode)->wNodeFlags &= ~NODE_SECURE_EXPIRED )
#define CLEAR_ADMIN_RESERVED_NODE(pNode)    ( (pNode)->wNodeFlags &= ~NODE_ADMIN_RESERVED )

#define CLEAR_NODE_FLAGS(pNode)         ( (pNode)->wNodeFlags = 0 )
#define CLEAR_EXCEPT_FLAG(pNode, Flag)  ( (pNode)->wNodeFlags &= (WORD)Flag )

// clear all node security related flags
#define CLEAR_NODE_SECURITY_FLAGS(pNode)        ( (pNode)->wNodeFlags &= (~(NODE_TOMBSTONE      |  \
                                                                            NODE_SECURE_EXPIRED) ) )


//  Flags to save on making copy of node.
//      More or less those that apply to immediate record data.
//      Key flag to remove is TIMEOUT which eliminates possibility of delete.
//

#define NODE_FLAGS_SAVED_ON_COPY \
            ( NODE_NOEXIST | NODE_CNAME | NODE_ZONE_ROOT | NODE_AUTH_ZONE_ROOT | NODE_THIS_HOST )

#define COPY_BACK_NODE_FLAGS( pNodeReal, pNodeCopy ) \
        {                                           \
            WORD   _flags;                          \
            _flags = (pNodeReal)->wNodeFlags;       \
            _flags &= ~NODE_FLAGS_SAVED_ON_COPY;    \
            _flags |= ((pNodeCopy)->wNodeFlags & NODE_FLAGS_SAVED_ON_COPY); \
            (pNodeReal)->wNodeFlags = _flags;       \
        }


//
//  Node authority
//

#define AUTH_ZONE               (0xf2)
#define AUTH_DELEGATION         (0x43)
#define AUTH_GLUE               (0x23)
#define AUTH_OUTSIDE            (0x10)
#define AUTH_NONE               (0x00)

#define AUTH_ZONE_SUBTREE_BIT   (0x02)
#define AUTH_SUBZONE_BIT        (0x01)

//
//  In zone tree or cache
//

#define IS_ZONE_TREE_NODE(pNode)        ((pNode)->pZone)
#define IS_CACHE_TREE_NODE(pNode)       (!((pNode)->pZone))

//
//  Authority level of node in zone tree
//

#define IS_OUTSIDE_ZONE_NODE(pNode)     ((pNode)->uchAuthority == AUTH_OUTSIDE)
#define IS_AUTH_NODE(pNode)             ((pNode)->uchAuthority == AUTH_ZONE)
#define IS_DELEGATION_NODE(pNode)       ((pNode)->uchAuthority == AUTH_DELEGATION)
#define IS_GLUE_NODE(pNode)             ((pNode)->uchAuthority == AUTH_GLUE)

#define SET_AUTH_NODE(pNode)            ((pNode)->uchAuthority = AUTH_ZONE)
#define SET_DELEGATION_NODE(pNode)      ((pNode)->uchAuthority = AUTH_DELEGATION)
#define SET_GLUE_NODE(pNode)            ((pNode)->uchAuthority = AUTH_GLUE)
#define SET_OUTSIDE_ZONE_NODE(pNode)    ((pNode)->uchAuthority = AUTH_OUTSIDE)

//  Entire zone subtree including delegation -- zone root on down

#define IS_ZONE_SUBTREE_NODE(pNode)     ((pNode)->uchAuthority & AUTH_ZONE_SUBTREE_BIT)

//  In any subzone including at delegation

#define IS_SUBZONE_NODE(pNode)          ((pNode)->uchAuthority & AUTH_SUBZONE_BIT)



//
//  Node access
//  When we access a node set its bin to the current timeout bin.
//

extern UCHAR    CurrentTimeoutBin;

#define IS_NODE_RECENTLY_ACCESSED(pNode) \
            ( (pNode)->uchAccessBin == CurrentTimeoutBin || \
              (pNode)->uchAccessBin == (UCHAR)(CurrentTimeoutBin-1) )

#define SET_NODE_ACCESSED(pNode)    \
            ( (pNode)->uchAccessBin = CurrentTimeoutBin )



//
//  Ptr to indicate node already cut from list.
//  This allows timeout thread reference to be cleaned up after node already cut loose
//      and no longer part of database.

#ifdef _WIN64
#define CUT_NODE_PTR            ((PVOID) (0xccffccffccffccff))
#else
#define CUT_NODE_PTR            ((PVOID) (0xccffccff))
#endif

#define IS_CUT_NODE(pNode)      ((pNode)->pSibUp == CUT_NODE_PTR)


//
//  Main lookup routine
//

PDB_NODE
NTree_FindOrCreateChildNode(
    IN OUT  PDB_NODE        pParent,
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength,
    IN      BOOL            fCreate,
    IN      DWORD           dwMemTag,
    OUT     PDB_NODE *      ppnodeFollowing
    );


//
//  Tree routines
//

PDB_NODE
NTree_Initialize(
    VOID
    );

VOID
NTree_StartFileLoad(
    VOID
    );

VOID
NTree_StopFileLoad(
    VOID
    );

PDB_NODE
NTree_CreateNode(
    IN      PCHAR       pchLabel,
    IN      PCHAR       pchDownLabel,
    IN      DWORD       cchLabelLength,
    IN      DWORD       dwMemTag            //  zero for generic node
    );

PDB_NODE
NTree_CopyNode(
    IN      PDB_NODE    pNode
    );

VOID
NTree_FreeNode(
    IN OUT  PDB_NODE    pNode
    );

BOOL
NTree_InsertChildNode(
    IN OUT  PDB_NODE    pParent,
    IN OUT  PDB_NODE    pNewNode
    );

PDB_NODE
FASTCALL
NTree_FirstChild(
    IN      PDB_NODE    pParent
    );

PDB_NODE
FASTCALL
NTree_NextSibling(
    IN      PDB_NODE    pNode
    );

PDB_NODE
FASTCALL
NTree_NextSiblingWithLocking(
    IN      PDB_NODE    pNode
    );

BOOL
NTree_RemoveNode(
    IN OUT  PDB_NODE    pNode
    );

VOID
NTree_ReferenceNode(
    IN OUT  PDB_NODE    pNode
    );

BOOL
FASTCALL
NTree_DereferenceNode(
    IN OUT  PDB_NODE    pNode
    );

VOID
NTree_DeleteSubtree(
    IN OUT  PDB_NODE    pNode
    );

#if DBG
BOOL
NTree_VerifyNode(
    IN      PDB_NODE    pNode
    );
#endif

VOID
NTree_RebalanceSubtreeChildLists(
    IN OUT  PDB_NODE    pParent,
    IN      PVOID       pZone
    );


//
//  Sibling list B-Tree
//
//  Public only for purposes of use by tree routines.
//

extern INT gcFullRebalance;

VOID
NTree_CutNode(
    IN      PDB_NODE    pNode
    );

BOOL
NTree_VerifyChildList(
    IN      PDB_NODE    pNode,
    IN      PDB_NODE    pNodeChild      OPTIONAL
    );

#if DBG
VOID
Dbg_SiblingList(
    IN      LPSTR       pszHeader,
    IN      PDB_NODE    pNode
    );
#else
#define Dbg_SiblingList(pszHeader,pNode)
#endif


//
//  Node statistics collection
//

VOID
NTree_WriteDerivedStats(
    VOID
    );


//
//  Internal tree structures. These definitions are in a header file 
//  only so that the DNS server debugger extension can see them. No
//  other server module should use these definitions.
//

//
//  Hash table
//

//#define LAST_HASH_INDEX     (35)
#define LAST_HASH_INDEX     (255)

#define HASH_BUCKET_MAX0    (64)        // 64 nodes in b-tree then hash

#define IS_HASH_FLAG        (0xff)

#define IS_HASH_TABLE(phash) \
        ( ((PSIB_HASH_TABLE)phash)->IsHash == (UCHAR)IS_HASH_FLAG )

#define SET_HASH_FLAG(phash) \
        ( phash->IsHash = (UCHAR)IS_HASH_FLAG )

//
//  Hash table structure
//
//  Note, the IsHash flag is set to 0xffff.
//  This position would correspond to the low byte of the pParent ptr
//  in a domain node.  Since 0xffff can never be valid as the low byte
//  of a domain node pointer, we can test domain nodes and immediate
//  see that we have a hash table rather than a B-tree root.
//

typedef struct _SibHashTable
{
    UCHAR                   IsHash;
    UCHAR                   Resv;
    UCHAR                   cLevel;
    UCHAR                   iBucketUp;
    struct _SibHashTable *  pHashUp;
    PDB_NODE                aBuckets[ LAST_HASH_INDEX+1 ];
    DWORD                   aBucketCount[ LAST_HASH_INDEX+1 ];
}
SIB_HASH_TABLE, *PSIB_HASH_TABLE;


#endif  //  _TREE_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\server\server\update.c ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    update.c

Abstract:

    Domain Name System (DNS) Server

    Dynamic update routines.

Author:

    Jim Gilroy (jamesg)     September 1996

Revision History:

--*/


#include "dnssrv.h"

//  Bring in security definitions

#define SECURITY_WIN32
#include "sspi.h"
#include "sdutl.h"

//
//  Testing new stuff
//

#define TEST_UP  1

//
//  Update implementation
//

#define UPTYPE


//
//  Update queue info
//

PPACKET_QUEUE   g_UpdateQueue;
PPACKET_QUEUE   g_UpdateForwardingQueue;

//
//  Security TKEY negotiation queue
//      - security calls can block for significant time so negotiation
//      must be done outside of main threads
//

PPACKET_QUEUE   g_SecureNegoQueue;

//
//  Update validity interval
//  Note:  this MUST be kept to a value that is less than the final
//      client update timeout, otherwise the server may process an update
//      after the client has given up, and the client may try again to
//      another server (in DS case) resulting in DS replication collision
//

#define UPDATE_TIMEOUT     (15)    // 15 seconds

//
//  Buffering for writing log file
//      - twice max record insures lots of space so everything gets buffered
//

#define UPDATE_LOG_BUFFER_SIZE      (2*MAX_RECORD_FILE_WRITE)


//
//  Update log file limit
//

#define UPDATE_LOG_FILE_LIMIT   (100000)

//
//  Always keep a last few updates in update list to allow small
//  zones to do IXFR and avoid TCP connection.
//

#define MIN_UPDATE_LIST_LENGTH      (20)

#define MAX_UPDATE_LIST_LENGTH      (0x10000)   // 64k


//
//  Use RCODEs as status, so need to note highest update RCODE
//  so can distinguish non-rcode status codes.
//

#define MAX_UPDATE_RCODE    (DNS_RCODE_NOTZONE)


//
//  Flag to create records for delete
//

#define PSUEDO_DELETE_RECORD_TTL    (0xf1e2d3f0)


#define checkForEmptyUpdate( pUpdateList, pZone ) \
            ( !(pUpdateList->pListHead) )


//
//  Implementation note
//
//  Each zone has associated update list containing essentially a recent
//  history of zone changes.
//
//  There are several possibilities for representing this information.
//  Unfortunately the best -- keeping no data and identifying the RR sets
//  (node and type) is not possible because of the IXFR RFC, which
//  requires history.
//
//  Delete Data:
//
//  IXFR requires that we keep pDeleteRR.  In all cases the update pDeleteRR
//  ptr is the "final" reference to the record and it is available for delete.
//  (Under some scenarios, a previous update's pAddRR may also reference the
//  record, but it would be deleted first.)
//
//  Add Data:
//
//  Here there are essentially three choices:
//
//  1) pAddRR are independent (copies) of actual added data.
//  Advantages:
//      - fairly clean, (always free pAddRR on delete, can execute on copies)
//      - directly maps into IXFR write
//  Disadvantage
//      - eats up more memory
//      - execution essentially equivalent to two update lists
//
//  2) pAddRR are actual added records.
//  They then point either to actual list data OR to records in later
//  delete updates.
//  Advantages:
//      - no extra memory
//      - directly maps into IXFR write
//  Disadvantage
//      - update MUST be executed on real database node
//      can not execute on temporary node and copy result, as the pAddRR in
//      previous updates may be dumped;
//      so effectively update must be executed twice, at least in DS case where
//      need rollback;  this in turn requires extra complexity to make sure
//      aging data properly propagated
//
//  3) no pAddRR pointers in update list
//
//  Advantages:
//      - simplicity
//      - no extra memory
//  Disadvantages
//      - extra IXFR traffic, if touching multi-IP server
//      - a bit more complexity to maintain logging info
//
//
//  We're chosen #3.  No add pointers or records are kept.  We send complete RR sets
//  for ANY RR-set that has had an add.
//


//
//  Private protos
//

DWORD
Update_Thread(
    IN      LPVOID          Dummy
    );

DNS_STATUS
prepareUpdateListForExecution(
    IN      PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    );

BOOL
checkTempNodesForUpdateEffect(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    );

VOID
resetAndSuppressTempUpdatesForCompletion(
    IN      PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    );

DNS_STATUS
processNonDsUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    );

DNS_STATUS
processDsUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    );

DNS_STATUS
processDsSecureUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    );

BOOL
processWireUpdateMessage(
    IN OUT  PDNS_MSGINFO    pMsg
    );

DNS_STATUS
parseUpdatePacket(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN OUT  PUPDATE_LIST    pUpdateList
    );

VOID
rejectUpdateWithRcode(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      DWORD           Rcode
    );

DNS_STATUS
initiateDsPeerUpdate(
    IN      PUPDATE_LIST    pUpdateList
    );

DNS_STATUS
checkDnsServerHostUpdate(
    IN      PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      PDB_NODE        pNodeReal,
    IN      PDB_NODE        pNodeTemp
    );

#if DBG
#define VALIDATE_UPDATE_LIST(plist) \
        IF_DEBUG( UPDATE )          \
        {                           \
            Up_VerifyUpdateList( plist );  \
        }

#else
#define Dbg_UpdateList(psz,plist)
#define Dbg_Update(psz,pup)
#define Up_VerifyUpdateList(plist)
#define Up_VerifyUpdate(pUp)
#define VALIDATE_UPDATE_LIST(plist)
#endif



//
//  Update list routines
//

#if DBG
VOID
Dbg_Update(
    IN      LPSTR           pszHeader,
    IN      PUPDATE         pUpdate
    )
/*++

Routine Description:

    Debug print update.

Arguments:

    pszHeader - header message to print

    pUpdate - update

Return Value:

    None

--*/
{
    DnsDebugLock();
    DnsPrintf(
        "%s\n"
        "\tptr          = %p\n"
        "\tversion      = %d\n"
        "\tpNode        = %p (%s) %s\n"
        "\tpAdd RR      = %p (type=%d)\n"
        "\tadd type     = %d\n"
        "\tpDelete RR   = %p (type=%d)\n"
        "\tdelete type  = %d\n"
        "\tpNext        = %p\n",
        pszHeader ? pszHeader : "Update:",
        pUpdate,
        pUpdate->dwVersion,
        pUpdate->pNode,
        (pUpdate->pNode)
            ?   pUpdate->pNode->szLabel
            :   NULL,
        (pUpdate->pNode && IS_TNODE(pUpdate->pNode))
            ?   "[Temp]"
            :   "",
        pUpdate->pAddRR,
        (pUpdate->pAddRR)
            ?   pUpdate->pAddRR->wType
            :   0,
        pUpdate->wAddType,
#if 0
        pUpdate->wAddType == UPDATE_OP_PRECON
            ?   "[PRECON]"
            :   "",
        pUpdate->wAddType == UPDATE_OP_DUPLICATE_ADD
            ?   "[DUP]"
            :   "",
#endif
        pUpdate->pDeleteRR,
        (pUpdate->pDeleteRR)
            ?   pUpdate->pDeleteRR->wType
            :   0,
        pUpdate->wDeleteType,
        pUpdate->pNext );


    if ( pUpdate->pAddRR )
    {
        Dbg_DbaseRecord( "\tAdd RR:", pUpdate->pAddRR );
    }
    if ( pUpdate->pDeleteRR )
    {
        PDB_RECORD prr = pUpdate->pDeleteRR;
        while ( prr )
        {
            Dbg_DbaseRecord( "\tDelete RR:", prr );
            prr = NEXT_RR(prr);
        }
    }

    DnsDebugUnlock();
}

VOID
Dbg_UpdateList(
    IN      LPSTR           pszHeader,
    IN      PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Debug print update list.

Arguments:

    pszHeader - header message to print

    pUpdateList - update list

Return Value:

    None

--*/
{
    PUPDATE     pupdate;

    DnsDebugLock();
    DnsPrintf(
        "%s\n"
        "\tlist ptr     = %p\n"
        "\tflag         = %p\n"
        "\tcount        = %d\n"
        "\thead         = %p\n"
        "\ttail         = %p\n"
        "\tpMsg         = %p\n"
        "\tnet records  = %d\n",
        pszHeader ? pszHeader : "Update List:",
        pUpdateList,
        pUpdateList->Flag,
        pUpdateList->dwCount,
        pUpdateList->pListHead,
        pUpdateList->pCurrent,
        pUpdateList->pMsg,
        pUpdateList->iNetRecords );

    pupdate = (PUPDATE) pUpdateList;

    while ( pupdate = pupdate->pNext )
    {
        Dbg_Update( "--Update", pupdate );
    }

    if ( pUpdateList->pTempNodeList )
    {
        PDB_NODE    pnodeTemp;

        DnsPrintf(
            "--Temporary node list:\n" );

        for ( pnodeTemp = pUpdateList->pTempNodeList;
              pnodeTemp != NULL;
              pnodeTemp = TNODE_NEXT_TEMP_NODE(pnodeTemp) )
        {
            PDB_NODE pnodeReal = TNODE_MATCHING_REAL_NODE(pnodeTemp);
            DnsPrintf(
                "\ttemp node %s (%p) (f=%p) (w=%p) for real node %s (%p)\n",
                pnodeTemp->szLabel,
                pnodeTemp,
                TNODE_FLAG(pnodeTemp),
                TNODE_WRITE_STATE(pnodeTemp),
                pnodeReal->szLabel,
                pnodeReal );
        }
    }
    DnsPrintf(
        "--- End Update List ---\n" );

    DnsDebugUnlock();
}



BOOL
Up_VerifyUpdate(
    IN      PUPDATE         pUpdate
    )
/*++

Routine Description:

    Verify validity of update.

Arguments:

    pUpdate - update

Return Value:

    TRUE if valid
    FALSE if invalid

--*/
{
    if ( !pUpdate )
    {
        ASSERT( FALSE )
        return( FALSE );
    }

    //
    //  verify pUpdate memory
    //      - valid heap
    //      - UPDATE tag
    //      - adequate length
    //      - not on free list
    //

    if ( ! Mem_VerifyHeapBlock(
                pUpdate,
                MEMTAG_UPDATE,
                sizeof(UPDATE) ) )
    {
        DNS_PRINT((
            "\nERROR:  Update at %p, failed mem check!!!\n",
            pUpdate ));
        ASSERT( FALSE );
        return( FALSE );
    }

    ASSERT( !IS_ON_FREE_LIST(pUpdate) );

    //
    //  validate update record lists
    //

    if ( pUpdate->pAddRR )
    {
#if 0
        //  we seem to hit this on SOA replace updates
        //  where the SOA in the update has already been
        //  dumped into a SLOW_FREE

        RR_ListVerifyDetached(
            pUpdate->pAddRR,
            pUpdate->wAddType,
            0       // no required source
            );
#endif
    }
    if ( pUpdate->pDeleteRR )
    {
        RR_ListVerifyDetached(
            pUpdate->pDeleteRR,
            (WORD) ((pUpdate->wDeleteType >= DNS_TYPE_ALL) ? 0 : pUpdate->wDeleteType),
            0       // no required source
            );
    }

    //  validate update node

    RR_ListVerify( pUpdate->pNode );

    //  should always have something in there

    if ( ! pUpdate->pAddRR  &&
         ! pUpdate->pDeleteRR  &&
         ! pUpdate->wAddType  &&
         ! pUpdate->wDeleteType )
    {
        ASSERT( FALSE );
        return( FALSE );
    }

    return( TRUE );
}



BOOL
Up_VerifyUpdateList(
    IN      PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Verify validity of update list.

Arguments:

    pUpdateList - update list

Return Value:

    TRUE if valid
    FALSE if invalid

--*/
{
    PUPDATE     pupdate;
    PUPDATE     pback;

    //
    //  empty list?
    //

    if ( pUpdateList->dwCount == 0
        || pUpdateList->pListHead == NULL
        || pUpdateList->pCurrent == NULL )
    {
        if ( pUpdateList->dwCount != 0
            || pUpdateList->pListHead != NULL
            || pUpdateList->pCurrent != NULL )
        {
            Dbg_UpdateList( "ERROR:  Invalid empty update list:", pUpdateList );
            ASSERT( FALSE );
            return( FALSE );
        }
        return( TRUE );
    }

    //
    //  one entry
    //

    if ( pUpdateList->dwCount == 1
        || pUpdateList->pListHead == pUpdateList->pCurrent )
    {
        if ( pUpdateList->dwCount != 1
            || pUpdateList->pListHead != pUpdateList->pCurrent )
        {
            Dbg_UpdateList( "ERROR:  Invalid single value update list:", pUpdateList );
            ASSERT( FALSE );
            return( FALSE );
        }
        Up_VerifyUpdate( pUpdateList->pListHead );
        return( TRUE );
    }

    //
    //  anything else, just walk it to make sure it is valid
    //

    pback = (PUPDATE) pUpdateList;

    while ( pupdate = pback->pNext )
    {
        Up_VerifyUpdate(pupdate);
        pback = pupdate;
    }

    if ( pback != pUpdateList->pCurrent )
    {
        Dbg_UpdateList( "ERROR:  Invalid tail of update list:", pUpdateList );
        ASSERT( FALSE );
        return( FALSE );
    }
    return( TRUE );
}
#endif



PUPDATE_LIST
Up_InitUpdateList(
    IN OUT  PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Initialize update list.

Arguments:

    pUpdateList - update list

Return Value:

    Returns a pointer to initialized update list.
    (good for returning ptrs to update list from the call stack)

--*/
{
    RtlZeroMemory(
        pUpdateList,
        sizeof(UPDATE_LIST) );
    return( pUpdateList );
}



PUPDATE_LIST
Up_CreateUpdateList(
    IN      PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Create (allocate) and update list.

Arguments:

    None

Return Value:

    New update list.
    NULL on allocation failure.

--*/
{
    PUPDATE_LIST    pnewList;

    //
    //  allocate update list, then init
    //

    pnewList = (PUPDATE_LIST) ALLOC_TAGHEAP( sizeof(UPDATE_LIST), MEMTAG_UPDATE_LIST );
    IF_NOMEM( !pnewList )
    {
        return( NULL );
    }

    //  if given, make copy
    //  otherwise init

    if ( pUpdateList )
    {
        RtlCopyMemory(
            pnewList,
            pUpdateList,
            sizeof(UPDATE_LIST)
            );
    }
    else
    {
        Up_InitUpdateList( pnewList );
    }

    return( pnewList );
}



VOID
Up_CleanAndVersionPostUpdate(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      DWORD           dwVersion
    )
/*++

Routine Description:

    Cleans up after update execution.

Arguments:

    pUpdateList - update list to append to

    dwVersion - zone version of updates

Return Value:

    None

--*/
{
    register    PUPDATE pup;

    ASSERT( pUpdateList );

    VALIDATE_UPDATE_LIST( pUpdateList );

    //
    //  set version in new updates
    //
    //  DEVNOTE: some sort of counting heuristic?
    //

    pup = (PUPDATE) pUpdateList;
    while ( pup = pup->pNext )
    {
#ifdef UPIMPL3
        pup->pAddRR = NULL;
#endif
        pup->dwVersion = dwVersion;
    }
}



VOID
Up_AppendUpdateList(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      PUPDATE_LIST    pAppendList,
    IN      DWORD           dwVersion
    )
/*++

Routine Description:

    Append one update list to another.

    Sets zone version in updates being appended.  This is not done while
    updates are built or executed as may not know final resting serial of
    zone after update for SOA changes \ DS read cases.

Arguments:

    pUpdateList - update list to append to

    pAppendList - update list to append

    dwVersion - zone version of updates

Return Value:

    None

--*/
{
    register    PUPDATE pup;

    ASSERT( pUpdateList && pAppendList );

    VALIDATE_UPDATE_LIST( pAppendList );

    //
    //  no-op if nothing to append
    //

    if ( !pAppendList->pListHead )
    {
        ASSERT( !pAppendList->pCurrent );
        return;
    }
    ASSERT( pAppendList->pCurrent );

    //
    //  set version in new updates
    //      - need to have this while this is used by IXFR
    //      to version each add\delete pass
    //
    //  DEVNOTE: some sort of counting heuristic?
    //

    pup = (PUPDATE) pAppendList;
    while ( pup = pup->pNext )
    {
        pup->dwVersion = dwVersion;
    }

    //
    //  add update count
    //

    pUpdateList->dwCount += pAppendList->dwCount;

    //
    //  empty list
    //

    if ( !pUpdateList->pListHead )
    {
        ASSERT( !pUpdateList->pCurrent );
        pUpdateList->pListHead  = pAppendList->pListHead;
        pUpdateList->pCurrent   = pAppendList->pCurrent;
    }

    //
    //  not empty, just whack append list onto end
    //

    else
    {
        ASSERT( pUpdateList->pCurrent );

        pUpdateList->pCurrent->pNext = pAppendList->pListHead;
        pUpdateList->pCurrent = pAppendList->pCurrent;

        VALIDATE_UPDATE_LIST( pUpdateList );
    }

    //  clear appended list
    //  need to do this for update lists, where temp list will be sent
    //      to list free function to free temp nodes
    //  can NOT do reinit of update list because still need to keep temp
    //      node list around for final delete (unless we decide to do that
    //      here also -- one reason not to is modest perf boost in getting
    //      to unlock)

    pAppendList->pListHead = NULL;
    pAppendList->pCurrent = NULL;
    pAppendList->dwCount = 0;
}



PUPDATE
Up_CreateUpdate(
    IN      PDB_NODE        pNode,
    IN      PDB_RECORD      pAddRR,
    IN      WORD            wDeleteType,
    IN      PDB_RECORD      pDeleteRR
    )
/*++

Routine Description:

    Create UPDATE entry.

Arguments:

    pNode - node where update occurred

    pAddRR - update RR added

    wDeleteType - delete type

    pDeleteRR - update RR or RR list deleted

Return Value:

    Ptr to update list.
    NULL on allocation error.

--*/
{
    PUPDATE pupdate;

    //
    //  allocate update
    //

    pupdate = (PUPDATE) ALLOC_TAGHEAP( sizeof(UPDATE), MEMTAG_UPDATE );
    IF_NOMEM( !pupdate )
    {
        return( NULL );
    }

    //
    //  bump reference count of node to prevent delete
    //

    NTree_ReferenceNode( pNode );

    //
    //  set node and RRs
    //

    pupdate->pNext          = NULL;
    pupdate->pNode          = pNode;
    pupdate->pAddRR         = pAddRR;
    pupdate->pDeleteRR      = pDeleteRR;
    pupdate->dwVersion      = 0;
    pupdate->dwFlag         = 0;
    pupdate->wAddType       = 0;
    pupdate->wDeleteType    = wDeleteType;

    IF_DEBUG( UPDATE2 )
    {
        Dbg_Update(
            "New update:",
            pupdate );
    }

    //
    //  Conditional breakpoint if node name matches break name, or if the
    //  break name is "..ALL".
    //

    if ( pNode &&
        pNode->pZone &&
        ( ( PZONE_INFO ) pNode->pZone )->pszBreakOnUpdateName )
    {
        PZONE_INFO  pZone = ( PZONE_INFO ) pNode->pZone;
        LPSTR       pszBreakOnUpdateName =
                        ( ( PZONE_INFO ) pNode->pZone )->pszBreakOnUpdateName;

        if ( strcmp( pszBreakOnUpdateName, "..ALL" ) == 0 ||
            _stricmp( pszBreakOnUpdateName, pNode->szLabel ) == 0 )
        {
            DNS_PRINT(( "HARD BREAK: " 
                DNS_REGKEY_ZONE_BREAK_ON_NAME_UPDATE
                " \"%s\" in zone %s\n",
                pszBreakOnUpdateName,
                (( PZONE_INFO ) pNode->pZone )->pszZoneName ));
            DebugBreak();
        }
    }
    
    return( pupdate );
}   //  Up_CreateUpdate



PUPDATE
Up_CreateAppendUpdate(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      PDB_NODE        pNode,
    IN      PDB_RECORD      pAddRR,
    IN      WORD            wDeleteType,
    IN      PDB_RECORD      pDeleteRR
    )
/*++

Routine Description:

    Create UPDATE entry and append to update list.

Arguments:

    pUpdateList - update list

    pNode - node where update occurred

    pAddRR - update RR added

    wDeleteType - delete type

    pDeleteRR - update RR or RR list deleted

Return Value:

    Ptr to update list.
    NULL on allocation error.

--*/
{
    PUPDATE pupdate;

    //
    //  create update
    //

    pupdate = Up_CreateUpdate(
                pNode,
                pAddRR,
                wDeleteType,
                pDeleteRR );
    IF_NOMEM( !pupdate )
    {
        return( NULL );
    }

    //
    //  append to list, inc update count
    //

    if ( pUpdateList->pCurrent )
    {
        pUpdateList->pCurrent->pNext = pupdate;
        pUpdateList->pCurrent = pupdate;
    }
    else
    {
        ASSERT( pUpdateList->pListHead == NULL );

        pUpdateList->pListHead = pupdate;
        pUpdateList->pCurrent = pupdate;
    }

    pUpdateList->dwCount++;

    VALIDATE_UPDATE_LIST( pUpdateList );
    return( pupdate );

}   //  Up_CreateAppendUpdate



PUPDATE
Up_CreateAppendUpdateMultiRRAdd(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      PDB_NODE        pNode,
    IN      PDB_RECORD      pAddRR,
    IN      WORD            wDeleteType,
    IN      PDB_RECORD      pDeleteRR
    )
/*++

Routine Description:

    Create UPDATE entry and append to update list.

    Same as above except for multiple RRs in pAddRR
    These are not currently supported in updates, hence must
    break into individual update blobs.

Arguments:

    pUpdateList - update list

    pNode - node where update occurred

    pAddRR - update RR added

    wDeleteType - delete type

    pDeleteRR - update RR list deleted (currently unsupported)

Return Value:

    Ptr to update list.
    NULL on allocation error.

--*/
{
    PUPDATE     pupdate = NULL;
    PDB_RECORD  prrNext;

    ASSERT( pNode && !pDeleteRR );

    //
    //  create individual updates for all these updates
    //      - first Add creates update with wDeleteType making it a replace
    //      - remaining Adds are just plain adds
    //
    //  problem is update list keep pAddRR as ptrs to actual RRs
    //      IN the database;  to fix need to process
    //
    //  DEVNOTE: multi RR add problem
    //
    //      note:  one solution would be special casing update to
    //      indicate replace;  these would get copy and be stored
    //      as copy;
    //
    //      note how this problem stems from having to maintain history
    //      list, hence ultimately from IXFR RFC
    //

    if ( pAddRR )
    {
        prrNext = pAddRR->pRRNext;
        pAddRR->pRRNext = NULL;

        pupdate = Up_CreateAppendUpdate(
                    pUpdateList,
                    pNode,
                    pAddRR,
                    wDeleteType,
                    NULL );

        while ( prrNext )
        {
            pAddRR = prrNext;
            prrNext = prrNext->pRRNext;
            pAddRR->pRRNext = NULL;

            Up_CreateAppendUpdate(
                pUpdateList,
                pNode,
                pAddRR,
                0,
                NULL );
        }
    }

    return( pupdate );

}   //  Up_CreateAppendUpdateMultiAddRR



VOID
Up_DetachAndFreeUpdateGivenPrevious(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN OUT  PUPDATE         pUpdatePrevious,
    IN OUT  PUPDATE         pUpdateDelete
    )
/*++

Routine Description:

    Remove update from update list, and delete it.

Arguments:

    pUpdateList - update list

    pUpdatePrevious - previous update in list

    pUpdate - update to delete from list

Return Value:

    None

--*/
{
    PUPDATE     pnext;

    //  can not validate this update list as it legitimately may
    //  have no-ops -- which we are now catching with validation function
    // VALIDATE_UPDATE_LIST( pUpdateList );

    //
    //  hack update from list
    //

    pnext = pUpdateDelete->pNext;
    pUpdatePrevious->pNext = pnext;

    //
    //  fix up update list parameters
    //      - dec count
    //      - if deleting list head, new list head written automatically
    //          by statement above
    //      - but need to special case pCurrent field
    //

    pUpdateList->dwCount--;

    if ( pUpdateList->pCurrent == pUpdateDelete )
    {
        pUpdateList->pCurrent = pUpdatePrevious;
        if( pUpdatePrevious == (PUPDATE) pUpdateList )
        {
            ASSERT( pUpdateList->pListHead == NULL && pUpdateList->dwCount == 0 );
            pUpdateList->pCurrent = NULL;
        }
    }

    //Up_FreeUpdateStructOnly( pUpdateDelete );

    Up_FreeUpdateEx(
        pUpdateDelete,
        pUpdateList->Flag & DNSUPDATE_EXECUTED,     // already executed?
        TRUE                                        // deref update nodes
        );

    //  can not validate this update list as it legitimately may
    //  have no-ops -- which we are now catching with validation function
    //  even after detach, there may be update further down in the list
    //  which is not kosher
    //
    // VALIDATE_UPDATE_LIST( pUpdateList );

}



VOID
Up_DetachAndFreeUpdate(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN OUT  PUPDATE         pUpdate
    )
/*++

Routine Description:

    Remove update from update list, and delete it.

Arguments:

    pUpdateList - update list

    pUpdate - update to delete from list

Return Value:

    None

--*/
{
    PUPDATE     pcheck;
    PUPDATE     pback;

    //
    //  loop through list until find update, then hack it out and free it
    //

    pback = (PUPDATE) pUpdateList;

    while ( pcheck = pback->pNext )
    {
        if ( pcheck == pUpdate )
        {
            Up_DetachAndFreeUpdateGivenPrevious(
                pUpdateList,
                pback,
                pcheck );
            return;
        }
        pback = pcheck;
    }

    //  assuming this is only called when update actually in list

    ASSERT( FALSE );
}



VOID
Up_FreeUpdateStructOnly(
    IN      PUPDATE     pUpdate
    )
/*++

Routine Description:

    Free UPDATE structures.

Arguments:

    pUpdate - update to be freed

Return Value:

    None.

--*/
{
    FREE_TAGHEAP( pUpdate, sizeof(UPDATE), MEMTAG_UPDATE );

}   //  Up_FreeUpdateStructOnly



PUPDATE
Up_FreeUpdateEx(
    IN      PUPDATE         pUpdate,
    IN      BOOL            fExecuted,
    IN      BOOL            fDeref
    )
/*++

Routine Description:

    Free UPDATE struct and substructures.

Arguments:

    pUpdate -- update to be freed

    fExecuted -- TRUE if update has been applied to zone
        in that case do NOT delete ADD records

    fDeref -- deref the node (default behavior only time
        you don't do this is on temp node

Return Value:

    Ptr to next update in list.

--*/
{
    register    PDB_RECORD  prr;
    PUPDATE     pnextUpdate;

    DNS_DEBUG( UPDATE, (
        "Up_FreeUpdateEx( %p, executed=%d, deref=%d )\n",
        pUpdate,
        fExecuted,
        fDeref ));

    //
    //  free records
    //      - ADD RRs only deleted if NOT executed update
    //          executed ADD RRs are either
    //              - in temp node
    //              - in active zone node
    //              - in delete RR list of later zone update
    //      - DELETE RRs always free
    //

    prr = pUpdate->pAddRR;
    if ( prr  &&  !IS_UPDATE_EXECUTED(pUpdate) )
    {
        RR_ListFree( prr );
    }

    prr = pUpdate->pDeleteRR;
    if ( prr )
    {
        RR_ListFree( prr );
    }

    //  dereference node
    //      make sure we deref real nodes only

    if ( fDeref )
    {
        PDB_NODE pnode = pUpdate->pNode;
        if ( IS_TNODE(pnode) )
        {
            pnode = TNODE_MATCHING_REAL_NODE( pnode );
        }
        NTree_DereferenceNode( pnode );
    }

    //  delete update struct
    //      first saving ptr to next update

    pnextUpdate = pUpdate->pNext;

    FREE_TAGHEAP( pUpdate, sizeof(UPDATE), MEMTAG_UPDATE );

    return( pnextUpdate );

}   //  Up_FreeUpdateEx



VOID
Up_FreeUpdatesInUpdateList(
    IN OUT  PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Free updates in list.
    Deletes update RRs and derefs nodes depending on
    update list properties.

    Note, there's no cleanup of update list block itself.
    If user is going to reuse, they must re-init.

Arguments:

    pUpdateList -- update list to free

Return Value:

    None

--*/
{
    PUPDATE     pupdate;
    PUPDATE     pupdateNext;
    PDB_RECORD  prr;
    PDB_RECORD  prrNext;
    DWORD       deleteCount;
    PDB_NODE    pnodeTemp;
    PDB_NODE    pnodeTempNext;
    BOOL        fexecuted;
    BOOL        fderef;


    DNS_DEBUG( UPDATE, (
        "Up_FreeUpdatesInUpdateList( %p )\n",
        pUpdateList ));

    if ( pUpdateList == NULL )
    {
        return;
    }
    IF_DEBUG( UPDATE )
    {
        Up_VerifyUpdateList( pUpdateList );
    }

    //
    //  delete updates
    //      - free delete RRs in update
    //      - frees add RRs if NOT executed update
    //      - deref node according to flag;  it can be turned
    //      off when dumping list of dead zone tree
    //

    fexecuted = (pUpdateList->Flag & DNSUPDATE_EXECUTED);
    fderef = !(pUpdateList->Flag & DNSUPDATE_NO_DEREF);

    pupdate = pUpdateList->pListHead;

    while( pupdate )
    {
        pupdate = Up_FreeUpdateEx(
                    pupdate,
                    fexecuted,
                    fderef );
    }

    //
    //  walk temp node list deleting temp nodes
    //
    //  note these may contain mixtures of records copied from real node
    //  and those copied from records built from update packet, but all
    //  the records are copies
    //

    pnodeTemp = pUpdateList->pTempNodeList;

    while ( pnodeTemp )
    {
        pnodeTempNext = TNODE_NEXT_TEMP_NODE(pnodeTemp);

        //  DEVNOTE: verify match with real database node
        //      (if update was successful)

        //  delete temp node
        //      - first record list
        //      - then node itself

        RR_ListFree( pnodeTemp->pRRList );
        NTree_FreeNode( pnodeTemp );

        pnodeTemp = pnodeTempNext;
    }

    DNS_DEBUG( UPDATE, (
        "Leaving Up_FreeUpdatesInUpdateList( %p )\n",
        pUpdateList ));

    return;
}



VOID
Up_FreeUpdateList(
    IN OUT  PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Free update list.

Arguments:

    pUpdateList -- update list to free

Return Value:

    None

--*/
{
    DNS_DEBUG( UPDATE, (
        "Up_FreeUpdateList( %p )\n",
        pUpdateList ));

    Up_FreeUpdatesInUpdateList( pUpdateList );

    FREE_HEAP( pUpdateList );
}



BOOL
Up_SetUpdateListSerial(
    IN OUT  PZONE_INFO      pZone,
    IN      PUPDATE         pUpdate
    )
/*++

Routine Description:

    Set update list zone serial numbers.

Arguments:

    pZone -- ptr to zone

    pUpdate -- ptr to head of update list

Return Value:

    TRUE -- if successful
    FALSE -- otherwise

--*/
{
    while ( pUpdate != NULL )
    {
        pUpdate->dwVersion = pZone->dwSerialNo;

        pUpdate = pUpdate->pNext;   // next update record
    }
    return( TRUE );
}



//
//  Zone update list routines
//

DNS_STATUS
Up_LogZoneUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN      PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Log new updates for this zone.

Arguments:

    pZone -- ptr to zone

    pUpdateList -- ptr to update list

Return Value:

    ERROR_SUCCESS if successful
    ErrorCode on failure.

--*/
{
    PUPDATE     pupdate;
    PDB_NODE    pnodeWrite;
    PDB_NODE    pnodePrevious = NULL;
    PDB_RECORD  prr;
    BOOL        fadd;
    HANDLE      hfile;
    LONG        count;
    BUFFER      buffer;
    CHAR        data[ UPDATE_LOG_BUFFER_SIZE ];
    CHAR        sourceBuf[ 50 ];
    PCHAR       psource;
    DWORD       flag;


    DNS_DEBUG( UPDATE, (
        "Up_LogZoneUpdate( zone=%s ).\n",
        pZone->pszZoneName ));

    //
    //  allow folks not to log updates
    //      -- at a minimum, need to allow for DS integrated case
    //

    if ( !pZone->fLogUpdates )
    {
        return( ERROR_SUCCESS );
    }

    //
    //  don't log incoming DS updates, only originating updates
    //

    if ( pZone->fDsIntegrated && (pUpdateList->Flag & DNSUPDATE_DS) )
    {
        DNS_DEBUG( UPDATE, ( "Skip logging of DS update.\n" ));
        return( ERROR_SUCCESS );
    }

    //
    //  if update log file NOT open -- open it
    //

    hfile = pZone->hfileUpdateLog;

    if ( !hfile )
    {
        WCHAR  wslogName[ MAX_PATH ];

        ASSERT( IS_ZONE_PRIMARY(pZone) );

        //
        //  if no log file name, create it
        //
        //  DEVNOTE -- check that appended file name stays within MAX_PATH
        //

        if ( ! pZone->pwsLogFile )
        {
            if ( pZone->pszDataFile )
            {
                wcscpy( wslogName, pZone->pwsDataFile );
                wcscat( wslogName, L".log" );
            }
            else
            {
                wcscpy( wslogName, pZone->pwsZoneName );
                wcscat( wslogName, L".dns.log" );
            }
            DNS_DEBUG( UPDATE, (
                "Created new zone log file %S\n",
                wslogName ));

            pZone->pwsLogFile = Dns_StringCopyAllocate_W(
                                    wslogName,
                                    0 );
        }

        //  create file path

        if ( ! File_CreateDatabaseFilePath(
                    wslogName,
                    NULL,
                    pZone->pwsLogFile ) )
        {
            //  should have checked all names when read in boot file
            //  or entered by admin

            ASSERT( FALSE );
            goto Failed;
        }

        //  open log file -- append

        hfile = OpenWriteFileEx(
                    wslogName,
                    TRUE        // append
                    );
        if ( !hfile )
        {
            DNS_PRINT((
                "ERROR:  Unable to open update log file %S.\n",
                wslogName ));
            goto Failed;
        }
        pZone->hfileUpdateLog = hfile;
    }

    //  setup empty buffer

    InitializeFileBuffer(
        & buffer,
        data,
        UPDATE_LOG_BUFFER_SIZE,
        hfile );

    //
    //  write update
    //      - determine update source
    //      - first zone version
    //      - then ADD/DELETE for RR
    //      - then each RR in update
    //

    flag = pUpdateList->Flag;
    if ( flag & DNSUPDATE_PACKET )
    {
        sprintf(
            sourceBuf,
            "PACKET %s",
            MSG_IP_STRING( (PDNS_MSGINFO)pUpdateList->pMsg ) );
        psource = sourceBuf;
    }
    else if ( flag & DNSUPDATE_SCAVENGE )
    {
        psource = "SCAVENGE";
    }
    else if ( flag & DNSUPDATE_DS )
    {
        psource = "DIRECTORY";
    }
    else if ( flag & DNSUPDATE_IXFR )
    {
        psource = "IXFR";
    }
    else if ( flag & DNSUPDATE_ADMIN )
    {
        psource = "ADMIN";
    }
    else if ( flag & DNSUPDATE_AUTO_CONFIG )
    {
        psource = "AUTO_CONFIG";
    }
    else
    {
        ASSERT( FALSE );
        psource = "UNKNOWN";
    }

    FormattedWriteToFileBuffer(
        &buffer,
        "\r\n"
        "$SOURCE  %s\r\n"
        "$VERSION %d\r\n",
        psource,
        pZone->dwSerialNo );

    //  fadd indicates previous write of update $ADD or $DELETE, start
    //  to force write (set so neither thinks it was last written)

    fadd = (BOOL)(-1);
    pnodePrevious = NULL;
    count = 0;

    for ( pupdate = pUpdateList->pListHead;
          pupdate != NULL;
          pupdate = pupdate->pNext )
    {
        count++;
        pupdate->dwVersion = pZone->dwSerialNo;

        //  need to write node?
        //  if same as previous just default it

        pnodeWrite = pupdate->pNode;
        if ( pnodeWrite == pnodePrevious )
        {
            pnodeWrite = NULL;
        }
        else
        {
            pnodePrevious = pnodeWrite;
        }
        if ( !pnodePrevious )
        {
            ASSERT( pnodePrevious );
            continue;
        }

        //
        //  delete
        //      - may be multiple delete records
        //      - if fail to write (bogus record), simply continue
        //

        prr = pupdate->pDeleteRR;
        if ( prr )
        {
            if ( fadd != FALSE )
            {
                FormattedWriteToFileBuffer( &buffer, "$DELETE\r\n" );
                fadd = FALSE;
            }
            do
            {
                if ( RR_WriteToFile(
                            &buffer,
                            pZone,
                            prr,
                            pnodeWrite
                            ) )
                {
                    pnodeWrite = NULL;
                }
                prr = prr->pRRNext;
            }
            while ( prr );
        }

        //
        //  add ?
        //
        //  note:  add RRs are valid RRs in database, MUST NOT muck with
        //  them at all;  also must not assume they are still valid as
        //  they may be immediately deleted by another UPDATE packet
        //
        //  two add cases
        //      - single record add, just write record pointed to by update
        //      - RR list replace (DS read) write all the records for the
        //          node

        prr = pupdate->pAddRR;
        if ( prr )
        {
            WORD    replaceType = pupdate->wDeleteType;

            if ( IS_ON_FREE_LIST(prr) || IS_SLOW_FREE_RR(prr) )
            {
                ASSERT( !IS_ON_FREE_LIST(prr) );
                continue;
            }

            if ( fadd != TRUE )
            {
                FormattedWriteToFileBuffer( &buffer, "$ADD\r\n" );
                fadd = TRUE;
            }

            //  RR set replace update
            //      - write entire RR set or entire RR list
            //      - since writing at active node, take lock

            if ( replaceType && replaceType <= DNS_TYPE_ALL )
            {
                LOCK_READ_RR_LIST(pnodePrevious);

                while ( prr  &&
                        ( replaceType == DNS_TYPE_ALL ||
                          prr->wType == replaceType ) )
                {
                    if ( IS_ON_FREE_LIST(prr) || IS_SLOW_FREE_RR(prr) )
                    {
                        ASSERT( !IS_ON_FREE_LIST(prr) );
                        break;
                    }
                    if ( RR_WriteToFile(
                                &buffer,
                                pZone,
                                prr,
                                pnodeWrite
                                ) )
                    {
                        pnodeWrite = NULL;
                    }
                    prr = prr->pRRNext;
                }

                UNLOCK_READ_RR_LIST(pnodePrevious);
            }

            //  single ADD record write

            else
            {
                if ( RR_WriteToFile(
                            &buffer,
                            pZone,
                            prr,
                            pnodeWrite
                            ) )
                {
                    pnodeWrite = NULL;
                }
            }
        }
    }

    //  push log file to disk

    WriteBufferToFile( &buffer );

    //
    //  if log file too big, copy to backup
    //
    //  DEVNOTE: log backup;  catch failures
    //  DEVNOTE: write back datafile when backup log
    //              or at least schedule it for write
    //

    pZone->iUpdateLogCount += count;
    if ( pZone->iUpdateLogCount > UPDATE_LOG_FILE_LIMIT )
    {
        ASSERT( pZone->pwsLogFile );
        DNS_DEBUG( UPDATE, (
            "Update log file %S, exceeds limit.\n"
            "\tcopying to backup directory.\n",
            pZone->pwsLogFile ));

        CloseHandle( pZone->hfileUpdateLog );
        pZone->hfileUpdateLog = NULL;
        pZone->iUpdateLogCount = 0;

        if ( !File_MoveToBackupDirectory( pZone->pwsLogFile ) )
        {
            //  should have checked all names when read in boot file
            //  or entered by admin

            ASSERT( FALSE );
            goto Failed;
        }
    }
    return( ERROR_SUCCESS );

Failed:

    //
    //  if failed to get access to update file, skip logging
    //
    //  DEVNOTE-LOG: log EVENT on logging failure
    //  DEVNOTE: set flag and try rewrite of entire log
    //

    return( ERROR_CANTWRITE );
}



VOID
Up_CleanZoneUpdateList(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Clean update list of unnecessary entries.

Arguments:

    pZone - zone to check

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    PUPDATE     pupdate;
    DWORD       lastVersion;
    DWORD       updateVersion;
    INT         deleteCount;
    INT         maxCount;
    INT         count = pZone->UpdateList.dwCount;

    DNS_DEBUG( UPDATE, (
        "Up_CleanUpdateList(), zone %s = %p\n"
        "\tzone RR count %d\n"
        "\tzone update count %d\n",
        pZone->pszZoneName,
        pZone,
        pZone->iRRCount,
        count ));

    IF_DEBUG( UPDATE2 )
    {
        Dbg_UpdateList( "Zone update list before cleanup:", &pZone->UpdateList );
    }

    //
    //  if zone not IXFR capable, don't keep update list
    //

    if ( ! Zone_IsIxfrCapable(pZone) )
    {
        Up_FreeUpdatesInUpdateList( &pZone->UpdateList );
        Up_InitUpdateList( &pZone->UpdateList );
        pZone->UpdateList.Flag |= DNSUPDATE_EXECUTED;
        return;
    }

    //
    //  limit updates to < 25% of zone record count
    //      - but to keep this working for small zones, always leave a small number
    //      of updates in list, so that even with small zone we can use IXFR on
    //      UDP packet rather than forcing to TCP for AXFR
    //      (also keeps Denise from testing with a small zone and not seeing it
    //      work)
    //
    //  DEVNOTE: zone RR count is not properly maintained
    //  DEVNOTE: once fixed can have legitimate "small zone" test to make sure
    //      enough updates stay around
    //

    ASSERT( count >= 0  );
    if ( pZone->iRRCount < 0 )
    {
        DNS_PRINT(( "ERROR:  zone %s iRRCount = %d\n",
            pZone->pszZoneName,
            pZone->iRRCount ));
        pZone->iRRCount = 1;
    }

    //
    //  determine maximum update list count
    //      - one eight size of zone RR set
    //      - up to hard max limit (for big zones)
    //      - but always allow enough updates even on small zone for UDP IXFR
    //

    maxCount = pZone->iRRCount >> 3;
    if ( maxCount > MAX_UPDATE_LIST_LENGTH )
    {
        maxCount = MAX_UPDATE_LIST_LENGTH;
    }
    else if ( maxCount < MIN_UPDATE_LIST_LENGTH )
    {
        maxCount = MIN_UPDATE_LIST_LENGTH;
    }

    count -= maxCount;
    if ( count <= 0 )
    {
        DNS_DEBUG( UPDATE, (
            "Update count for zone %s less than max count %d, no truncation of list.\n",
            pZone->pszZoneName,
            maxCount
            ));
        return;
    }

    //
    //  strip unecessary updates
    //
    //  delete count number of updates, but always delete all updates
    //  for a given zone version;  hence once reach count to delete, delete
    //  until the NEXT zone version
    //

    DNS_DEBUG( UPDATE, (
        "Update count exceeds desired count, truncating %d entries.\n",
        count ));

    deleteCount = 0;
    pupdate = pZone->UpdateList.pListHead;

    while( pupdate )
    {
        //  don't delete the last update
        //      otherwise big last update may drive us below minimum

        updateVersion = pupdate->dwVersion;
        if ( updateVersion == pZone->dwSerialNo )
        {
            break;
        }

        //  when reach delete required update count, stop
        //  but insure delete is on version boundary
        //      - at count save version
        //      - over count stop when reach next update version

        if ( deleteCount >= count )
        {
            if ( deleteCount == count )
            {
                lastVersion = updateVersion;
            }
            else if ( lastVersion != updateVersion )
            {
                break;
            }
        }

        //  delete update
        //      - delete DELETE RRs
        //      - deref node

        pupdate = Up_FreeUpdateEx(
                    pupdate,
                    TRUE,           // executed zone update (no add record delete)
                    TRUE            // deref node
                    );
        deleteCount++;
    }

    //
    //  emptied update list
    //      - reset list
    //
    //  WARNING:  should never delete last update with delete code as above
    //      as we never delete update that takes us to current version
    //      AND there should ALWAYS be an update that takes us to current zone
    //      version
    //

    if ( !pupdate )
    {
        DNS_PRINT((
            "WARNING:  eliminated all updates cleaning update list\n"
            "\tfor zone %s\n",
            pZone->pszZoneName ));

        Up_InitUpdateList( &pZone->UpdateList );
        pZone->UpdateList.Flag |= DNSUPDATE_EXECUTED;
    }
    else
    {
        pZone->UpdateList.pListHead = pupdate;
        pZone->UpdateList.dwCount -= deleteCount;
        ASSERT( (INT)pZone->UpdateList.dwCount >= 0 );
    }

    IF_DEBUG( UPDATE )
    {
        Up_VerifyUpdateList( &pZone->UpdateList );
    }
    IF_DEBUG( UPDATE2 )
    {
        Dbg_UpdateList( "Zone update list after cleanup:", &pZone->UpdateList );
    }

}   //  Up_CleanUpdateList




DNS_STATUS
Up_ApplyUpdatesToDatabase(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN OUT  PZONE_INFO      pZone,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Execute updates to in-memory database.
    Makes the updates to in memory database.

Arguments:

    pUpdateList - list with update

    pZone - zone being updated

    dwFlag - update flags

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    PUPDATE         pupdate;
    PUPDATE         pprevUpdate;
    PDB_RECORD      prr;
    PDB_RECORD      ptempRR;
    PDB_NODE        pnode;
    PDB_NODE        pnodeThisHost = NULL;
    DNS_STATUS      status;
    INT             netRecordCount = 0;
    DWORD           flag = pUpdateList->Flag | dwFlag;


    DNS_DEBUG( UPDATE, (
        "Up_ApplyUpdatesToDatabase(), zone %s = %p\n"
        "\tflags            = 0x%08X\n"
        "\tzone RR count    = %d\n"
        "\tcurrent serial   = %d\n",
        pZone->pszZoneName,
        pZone,
        dwFlag,
        pZone->iRRCount,
        pZone->dwSerialNo ));

    IF_DEBUG( UPDATE2 )
    {
        Dbg_UpdateList(
            "List before ApplyUpdatesToDatabase():",
            pUpdateList );
    }

    //
    //  log empty "ping" updates
    //

    if ( !pUpdateList->pListHead )
    {
        ASSERT( pUpdateList->dwCount == 0 );
        ASSERT( pUpdateList->pCurrent == NULL );
        if ( flag & DNSUPDATE_PACKET )
        {
            //  STAT_INC( UpdateStats.Empty );
            UPDATE_STAT_INC( pUpdateList, Empty );
            PERF_INC( pcDynamicUpdateNoOp );
        }
        DNS_DEBUG( UPDATE, (
            "Leaving Up_ApplyUpdatesToDatabase(), zone %s,\n"
            "\tupdate was empty ping update\n",
            pZone->pszZoneName ));

        //  if completion desired, at least do the unlocking

        goto Complete;
    }

    //
    //  loop through all updates in list
    //
    //  note startup works as front of update list ptr is the first
    //      ptr in UPDATE_LIST and pNext
    //
    //  note, NO LOCKING is required anymore;
    //      for updates, the updates themselves are on temporary nodes
    //      not the real database nodes;
    //      for IXFR the zone is locked but we won't refuse to query just
    //      because the data involving multiple nodes, won't necessarily
    //      be consistent
    //
    //  DEVNOTE:   if nothing left after delete make type ALL (for SIXFR)
    //  DEVNOTE:   if multiple type adds, make type ALL
    //
    //  DEVNOTE:   need cleanup\rollback on failure
    //              most fail silently, but can get outright failures
    //                  - WINS or SOA or NS misplacement
    //                  - CNAME issue if want to fix broken DynUpd RFC
    //

    //
    //  DEVNOTE: whack 'n add problem
    //
    //      one approach -- glom all the update for node together
    //          - if MORE than one, build temp, execute and check
    //          if no change from current (DS thing)
    //


    pprevUpdate = (PUPDATE) pUpdateList;

    while ( pupdate = pprevUpdate->pNext )
    {
        pnode = pupdate->pNode;

        //
        //  catch disappearing root-hints stuff
        //      - refuse to do update delete on RootHints root node
        //
        //  note:  only "update" root-hints via DS-polling
        //      RPC updates simply mark the root-hints dirty
        //      but do not make an "official" update
        //

        if ( IS_ZONE_CACHE(pZone) )
        {
            ASSERT( flag & DNSUPDATE_DS );
            ASSERT( pupdate->wDeleteType == DNS_TYPE_ALL );

            if ( pnode == pZone->pTreeRoot )
            {
                IF_DEBUG( UPDATE )
                {
                    Dbg_Update(
                        "Update apply at root-hints root.\n",
                        pupdate );
                }

                //  refuse to clear root-hints root
                //      - no-op the update

                if ( !pupdate->pAddRR )
                {
                    Dbg_Update(
                        "BAD Update apply at root-hints root.\n",
                        pupdate );

                    Up_DetachAndFreeUpdateGivenPrevious(
                        pUpdateList,
                        pprevUpdate,
                        pupdate );
                    continue;
                }
            }
        }

        //
        //  add or replace
        //
        //  note after update
        //      - pAddRR now points to actual database record
        //      - pDeleteRR may point at database (copy) records deleted
        //

        if ( pupdate->pAddRR )
        {
            //
            //  straight add -- no delete type specified
            //
            //    - note on mandatory replace cases (SOA, CNAME), add may
            //      also delete records from node and set pDeleteRR in update
            //
            //  Packet update is presumed to be good to go and all conditions are
            //  ignoreable -- i.e. execute what's there and party on.
            //
            //  for ADMIN updates status code used to detect duplicate records
            //
            //  DEVNOTE: missing ExecuteUpdate() rollback for terminal errors
            //

            if ( !pupdate->wDeleteType )
            {
                status = RR_UpdateAdd(
                            pZone,
                            pnode,
                            pupdate->pAddRR,
                            pupdate,
                            flag );

                if ( status != ERROR_SUCCESS )
                {
                    if ( (flag & DNSUPDATE_ADMIN) || (flag & DNSUPDATE_PACKET) )
                    {
                        DNS_DEBUG( UPDATE, (
                            "RR_UpdateAdd() failure %d (%p) on admin or packet update.\n",
                            status, status ));
                        goto Failed;
                    }

                    DNS_DEBUG( UPDATE, (
                        "WARNING:  Ignoring RR_UpdateAdd() status = %d (%p)\n"
                        "\tfor IXFR update of zone %s\n",
                        status, status,
                        pZone->pszZoneName ));

                    ASSERT( FALSE );
                }
            }

            //
            //  precondition update
            //      - should ONLY be applying to temp node
            //      - should ONLY fail when DS integrated and read
            //          different RR set then tested prior to lock
            //      - free precon RRs
            //      - clear update as no data impact (just timestamp)
            //

            else if ( pupdate->wDeleteType == UPDATE_OP_PRECON )
            {
                ASSERT( IS_TNODE(pupdate->pNode) );

                if ( ! RR_ListIsMatchingSet(
                            pupdate->pNode,
                            pupdate->pAddRR,
                            TRUE        // force refresh
                            ) )
                {
                    IF_DEBUG( UPDATE )
                    {
                        Dbg_DbaseNode(
                            "UPDATE Precon RR set match failure node -- inside APPLY!\n",
                            pupdate->pNode );
                    }
                    ASSERT( pZone->fDsIntegrated );
                    return( DNS_RCODE_NXRRSET );
                }

                RR_ListFree( pupdate->pAddRR );
                pupdate->pAddRR = NULL;
            }

            //
            //  full replace update -- type all delete and records to add
            //      - this used on updates from DS
            //
            //  DEVNOTE: for now this ok, but must fix function for full check
            //  handle straight type ALL delete separately as already have code
            //      that saves necessary records (SOA, NS)
            //
            //  DEVNOTE: must fix failure case here;
            //      in multi-update may have already committed some updates
            //      when hit failure
            //          - roll back
            //          - or kick out (and cleanup) this update and continue
            //      in temp node failure, we're ok
            //

            else if ( pupdate->wDeleteType == DNS_TYPE_ALL )
            {
                DWORD addCount = 0;

                prr = pupdate->pAddRR;
                while ( prr )
                {
                    addCount++;
                    prr = prr->pRRNext;
                }

                status = RR_ListReplace(
                            pupdate,
                            pnode,
                            pupdate->pAddRR,
                            & pupdate->pDeleteRR
                            );
                if ( status != ERROR_SUCCESS )
                {
                    DNS_DEBUG( ANY, (
                        "ERROR:  Type all update failure on node %p (l=%s)\n"
                        "\tstatus = %d (%p)\n",
                        pnode, pnode->szLabel,
                        status, status ));

                    if ( IS_TNODE(pnode) )
                    {
                        DNS_DEBUG( UPDATE, (
                            "RR_UpdateAdd() failure %d (%p) on admin or packet update.\n",
                            status, status ));
                        ASSERT( (flag & DNSUPDATE_ADMIN) || (flag & DNSUPDATE_PACKET) );
                        goto Failed;
                    }

                    //  failures on real memory nodes are gracefully cleaned up
                    //      - update is no-op'd
                    //      - and rest of list can still be processed

                    ASSERT( (flag & DNSUPDATE_DS) || (flag & DNSUPDATE_IXFR) );
                    ASSERT( pupdate->pDeleteRR == NULL && pupdate->pAddRR == NULL );
                }

                //  replace update
                //      - note we skip generic post-ADD processing below
                //      but use delete processing

                if ( pupdate->pAddRR )
                {
                    pupdate->wAddType = DNS_TYPE_ALL;
                    netRecordCount += addCount;
                }
            }

            //
            //  RR set replace
            //
            //  DEVNOTE: update RR set replace looses info?
            //      looks like there's an issue here if multiple add RR
            //      we'd then end up with interpreting as only one RR
            //      in later XFR
            //

            else
            {
                ASSERT( pupdate->pAddRR->wType == pupdate->wDeleteType );

                prr = RR_ReplaceSet(
                            pZone,
                            pnode,
                            pupdate->pAddRR,
                            0       // no flags
                            );
                pupdate->pDeleteRR = prr;
                ASSERT( !prr || prr->wType == pupdate->wDeleteType );
            }
        }

        //
        //  delete specfic RR
        //      - pDeleteRR is valid temp RR
        //
        //  note that update delete RR is freed;
        //  update now contains ptr to deleted RR
        //

        else if ( ptempRR = pupdate->pDeleteRR )
        {
            ASSERT( pupdate->pAddRR == NULL );

            prr = RR_UpdateDeleteMatchingRecord(
                        pnode,
                        ptempRR );

            pupdate->pDeleteRR = prr;
            ASSERT( !prr || prr->pRRNext == NULL );

            RR_Free( ptempRR );
        }

        //
        //  scavenge update
        //

        else if ( pupdate->wDeleteType == UPDATE_OP_SCAVENGE )
        {
            prr = RR_UpdateScavenge(
                        pZone,
                        pnode,
                        flag );
            pupdate->pDeleteRR = prr;
        }

        //
        //  force aging update
        //      - mark zone dirty as we have no ADD\DELETE effect
        //      we won't mark it dirty below
        //

        else if ( pupdate->wDeleteType == UPDATE_OP_FORCE_AGING )
        {
            if ( RR_UpdateForceAging(
                        pZone,
                        pnode,
                        flag ) )
            {
                pZone->fDirty = TRUE;
            }
        }

        //
        //  type delete
        //      - wDeleteType is type
        //      - pDeleteRR will contain records actually deleted
        //
        //  note that update now has pointer to actual database (copy) records
        //

        else if ( pupdate->wDeleteType )
        {
            prr = RR_UpdateDeleteType(
                        pZone,
                        pnode,
                        pupdate->wDeleteType,
                        flag );
            pupdate->pDeleteRR = prr;
        }

        //
        //  must have some kind of update!
        //      - only non-executed update should be in root hints

        ELSE_ASSERT( FALSE );

        //
        //  successful update
        //

        if ( pupdate->pAddRR || pupdate->pDeleteRR )
        {
            pprevUpdate = pupdate;

            //  mark update as executed

            MARK_UPDATE_EXECUTED(pupdate);

            //  mark zone dirty
            //  if update at root, mark root dirty
            //      note, that this handles IXFR only, primary updates
            //      are on temporary nodes and zone root gets marked during
            //      check of update effect

            pZone->fDirty = TRUE;
            if ( pnode == pZone->pZoneRoot )
            {
                pZone->fRootDirty = TRUE;
            }

            //  set ADD type
            //  count ADD
            //      - replace case is handled above

            if ( pupdate->pAddRR  &&
                 pupdate->wAddType != DNS_TYPE_ALL )
            {
                pupdate->wAddType = pupdate->pAddRR->wType;
                netRecordCount++;
            }

            //  count delete RRs

            prr = pupdate->pDeleteRR;
            while ( prr )
            {
                prr = prr->pRRNext;
                netRecordCount--;
            }

            RR_ListVerifyDetached(
                pupdate->pDeleteRR,
                (WORD) ((pupdate->wDeleteType >= DNS_TYPE_ALL) ? 0 : pupdate->wDeleteType),
                0       // no required source
                );

            RR_ListVerify( pnode );

            //
            //  check for THIS host update
            //      - actual update, not IXFR or DS write
            //          (check this by checking for TNODE)
            //      - save node ptr
            //

            if ( IS_THIS_HOST_NODE(pnode) &&
                 IS_TNODE(pnode) )
            {
                pnodeThisHost = pnode;
            }
            continue;
        }

        //
        //  eliminate no-op update from list
        //      - this removes update from list and resets update list fields
        //      - previous update doesn't move forward but its next pointer
        //          has been reset to next update
        //      - note this is useful even with final node before\after check
        //          in eliminating individual updates that do nothing, even if
        //          the whole set is valid;  typical example would be a type
        //          delete with no existing data, followed by an add
        //

        IF_DEBUG( UPDATE )
        {
            Dbg_Update(
                "Update turned into no-op on DB-execution.",
                pupdate );
        }

        Up_DetachAndFreeUpdateGivenPrevious(
            pUpdateList,
            pprevUpdate,
            pupdate );
    }

    //
    //  unlock would be here:  see NO LOCKING note above
    //

    //
    //  check for changing DNS server host data
    //      - if "down to zero" delete from packet
    //      then refuse the update at this node
    //      (don't write, don't update)
    //
    //  DEVNOTE: better bail out on suppressing host-A delete
    //      currently all packet updates are atomic in node and
    //      record type;  however other packet updates may not be
    //      desirable to
    //          - bail to produce error code
    //          - reset temp node to match real node
    //          (or match in A records) and proceed
    //

    if ( pnodeThisHost )
    {
        ASSERT( IS_TNODE(pnodeThisHost) );

        if ( (flag & DNSUPDATE_PACKET) &&
              ! RR_FindNextRecord(
                    pnodeThisHost,
                    DNS_TYPE_A,
                    NULL,
                    0 ) )
        {
            DNS_DEBUG( ANY, (
                "Update %p for zone %s is suppressed due to host-A delete\n",
                pUpdateList,
                pZone->pszZoneName ));

            status = DNS_ERROR_RCODE_REFUSED;
            goto Failed;
        }
    }

    //  count updates and no-ops for dynamic update

    if ( flag & DNSUPDATE_PACKET )
    {
        if ( pUpdateList->pListHead )
        {
            ASSERT( pUpdateList->dwCount );
            //  STAT_INC( UpdateStats.Completed );
            UPDATE_STAT_INC( pUpdateList, Completed );
            PERF_INC( pcDynamicUpdateWriteToDB );
        }
        else
        {
            ASSERT( pUpdateList->dwCount == 0 );
            //  STAT_INC( UpdateStats.NoOps );
            UPDATE_STAT_INC( pUpdateList, NoOps );
            PERF_INC( pcDynamicUpdateNoOp );
        }
    }

    //  IXFR execution should always include SOA update

    ASSERT( !(flag & DNSUPDATE_IXFR) || pZone->fRootDirty );

    //  save count of net records

    pUpdateList->iNetRecords = netRecordCount;

    //  flag update list as "EXECUTED"

    pUpdateList->Flag |= DNSUPDATE_EXECUTED;


Complete:

    IF_DEBUG( UPDATE2 )
    {
        Dbg_UpdateList(
            "Update list after ApplyToDatabase():",
            pUpdateList );
    }
    DNS_DEBUG( UPDATE, (
        "Leaving Up_ApplyUpdatesToDatabase(), zone %s = %p\n"
        "\tzone RR count = %d\n",
        pZone->pszZoneName,
        pZone,
        pZone->iRRCount ));

    //
    //  if cleanup desired, cleanup
    //

    if ( flag & DNSUPDATE_COMPLETE )
    {
        Up_CompleteZoneUpdate(
            pZone,
            pUpdateList,
            flag );
    }

    return( ERROR_SUCCESS );


Failed:

    //  IXFR or DS poll should NEVER fail out of this function
    //  only updates can fail for doing something bogus
    //  or restricted by policy

    ASSERT( !(flag & DNSUPDATE_IXFR) );
    ASSERT( !(flag & DNSUPDATE_DS) );

    return( status );

}   //  ApplyUpdatesToDatabase



DNS_STATUS
Up_ExecuteUpdateEx(
    IN      PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      DWORD           Flag,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Execute update.

    This is the main routine for executing updates.
        - takes lock
        - executes in DS (if necessary)
        - executes in memory
        - successful update zone processing
        - unlock
        - notify

    This serves as main entry point for non-wire updates.
    Wire updates call into it after parsing, and pass a flag to
    do completion on there own.

Arguments:

    pZone       -- zone context

    pUpdateList -- update list to execute

    Flag        -- additional flags to update

    pszFile     -- source file (for lock tracking)

    dwLine      -- source line (for lock tracking)

Return Value:

    TRUE if update completed.
    FALSE if update requeued.

--*/
{
    DNS_STATUS  status;

    ASSERT( pZone );
    ASSERT( pUpdateList );

    DNS_DEBUG( UPDATE, ( "Up_ExecuteUpdate( z=%s )\n", pZone->pszZoneName ));
    IF_DEBUG( UPDATE2 )
    {
        Dbg_UpdateList( "List entering ExecuteUpdate:", pUpdateList );
    }

    //
    //  lock zone
    //
    //  if admin specific have wait lock here that will wait a few seconds
    //  to get lock and execute
    //

    if ( ! (Flag & DNSUPDATE_ALREADY_LOCKED) )
    {
        DWORD   waitTime = 0;

        if ( Flag & DNSUPDATE_ADMIN )
        {
            waitTime = DEFAULT_ADMIN_ZONE_LOCK_WAIT;
        }
        else if ( Flag & DNSUPDATE_SCAVENGE )
        {
            waitTime = DEFAULT_SCAVENGE_ZONE_LOCK_WAIT;
        }

        if ( ! Zone_LockForWriteEx(
                    pZone,
                    LOCK_FLAG_UPDATE,
                    waitTime,
                    pszFile,
                    dwLine ) )
        {
            DNS_DEBUG( UPDATE, (
                "WARNING:  unable to lock zone %s for UPDATE.\n",
                pZone->pszZoneName ));

            status = DNS_ERROR_ZONE_LOCKED;
            goto FailedLock;
        }
    }

    //
    //  append user supplied flags to update
    //

    pUpdateList->Flag |= Flag;
    Flag = pUpdateList->Flag;

    //
    //  set zone's refresh below time
    //  set timestamps on update records
    //

    Aging_InitZoneUpdate( pZone, pUpdateList );

    //
    //  execute
    //      - clear COMPLETE flag since explicitly completing below
    //
    //  DS zones do additional processing to allow for
    //      - security
    //      - roll back on write failure
    //
    //  Handle non-DS, DS-secure and non-secure separately.
    //  Except that updates from DNS server itself can bypass security.
    //

    if ( !pZone->fDsIntegrated )
    {
        status = processNonDsUpdate(
                    pZone,
                    pUpdateList
                    );
    }

    //
    //  secure zone -- do secure update
    //      except bypass
    //      - local system updates
    //      - non-secure dynamic update packets
    //      these will be processed to determine if no-op, and only if
    //      update is required, do we refuse;  this avoids security
    //      negotiation phase unless necessary
    //

    else if ( pZone->fAllowUpdate == ZONE_UPDATE_SECURE
                &&
              ! (Flag & DNSUPDATE_NONSECURE_PACKET)
                &&
              ! (Flag & DNSUPDATE_LOCAL_SYSTEM) )
    {
        status = processDsSecureUpdate(
                    pZone,
                    pUpdateList
                    );
    }
    else    // DS non-secure
    {
        status = processDsUpdate(
                    pZone,
                    pUpdateList
                    );
    }

    if ( status != ERROR_SUCCESS )
    {
        goto Failure;
    }

    //
    //  apply temp update results to database
    //

    resetAndSuppressTempUpdatesForCompletion(
        pZone,
        pUpdateList
        );

    //
    //  finish update and unlock zone
    //
    //  DEVNOTE: should pass through flag here
    //      didn't have it in there for all NT5 test, so not adding it now
    //      post-ship, add it
    //

    Up_CompleteZoneUpdate(
        pZone,
        pUpdateList,
        0
        //  Flag
        );

    return ERROR_SUCCESS;


Failure:

    //  unlock non-update cases

    Zone_UnlockAfterAdminUpdate( pZone );

FailedLock:

    //  cleanup update list

    Up_FreeUpdatesInUpdateList( pUpdateList );

    return status;
}



VOID
Up_CompleteZoneUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Take all necessary actions on zone once updated in database
    is completed.

    Includes:
        -- serial increment
        -- zone data update on dirty root
        -- update in memory update list
        -- logging
        -- unlock zone
        -- notify any secondaries

Arguments:

    pZone -- zone being updated

    pUpdateList -- completed updates on zone

    dwFlags
        DNSUPDATE_NO_UNLOCK     -- do NOT unlock
        DNSUPDATE_NO_NOTIFY     -- do NOT notify secondaries
        DNSUPDATE_NO_INCREMENT  -- do NOT increment version

Return Value:

    None.

--*/
{
    DNS_STATUS  status;
    DWORD       serialPrevious;

    DNS_DEBUG( UPDATE, (
        "Up_CompleteZoneUpdate() on zone %s\n"
        "\tcurrent serial = %d\n",
        pZone->pszZoneName,
        pZone->dwSerialNo ));

    IF_DEBUG( UPDATE2 )
    {
        Dbg_UpdateList( "Update list to complete:", pUpdateList );
    }

    dwFlags |= pUpdateList->Flag;

    //
    //  root-hints zone?
    //

    if ( IS_ZONE_CACHE(pZone) )
    {
        DNS_DEBUG( ANY, (
            "WARNING:  CompleteUpdate on root hints zone %p!\n",
            pZone ));
        Up_FreeUpdatesInUpdateList( pUpdateList );
        return;
    }

    //
    //  if zone root is dirty, update zone info
    //

    serialPrevious = pZone->dwSerialNo;

    if ( pZone->fRootDirty )
    {
        Zone_GetZoneInfoFromResourceRecords( pZone );
    }

    //
    //  if update is NULL, ignore, no notify
    //
    //  note, we do this AFTER updating zone info, as root may be dirty from
    //      an aging only update, that changed root records, but did not
    //      change data and hence was no-op'd out of update list
    //

    if ( pUpdateList->dwCount == 0 )
    {
        DNS_DEBUG( UPDATE, (
            "Empty update list, unlock and return\n" ));

        dwFlags |= DNSUPDATE_NO_NOTIFY;
        goto Unlock;
    }

    //
    //  update zone version, EXCEPT do NOT update if
    //
    //  1) serial was moved forward by SOA change (i.e. SOA update keeps serial of update)
    //
    //  2) no serial increment if flag set
    //      this if for DS polls which have already set new version
    //      (to higher of high version in DS update RRs or current+1
    //      -- see Zone_UpdateAfterDsRead() )
    //

    if ( (dwFlags & (DNSUPDATE_NO_INCREMENT | DNSUPDATE_IXFR)) == 0 &&
        Zone_SerialNoCompare( pZone->dwSerialNo, serialPrevious ) <= 0 )
    {
        Zone_IncrementVersion( pZone );
    }

    //
    //  new serial should always be greater than what we started with
    //  UNLESS, couldn't save start serial
    //
    //  should always have SOA and it should always match pZone->dwSerialNo
    //

    ASSERT( Zone_SerialNoCompare(pZone->dwSerialNo, pUpdateList->dwStartVersion) > 0
            || pUpdateList->dwStartVersion == 0 );

    ASSERT( pZone->pSoaRR || IS_ZONE_CACHE (pZone) );
    ASSERT( IS_ZONE_CACHE(pZone) ||
            ntohl( pZone->pSoaRR->Data.SOA.dwSerialNo ) == pZone->dwSerialNo );


    IF_DEBUG( OFF )
    {
        DnsDebugLock();
        Dbg_DnsTree(
            "Zone after UPDATE packet\n",
            pZone->pZoneRoot );
        DnsDebugUnlock();
    }

    //
    //  log updates to file (if desired)
    //

    Up_LogZoneUpdate( pZone, pUpdateList );

    //
    //  if IXFR allowed
    //      - XFR allowed
    //      - not (DS-integrated and no-XFR)
    //      (can not IXFR a DS zone to secondary that hasn't had XFR)
    //
    //  then save update list to zone update list
    //      - version list
    //      - put in "processed mode"
    //      - append to zone master list
    //
    //  DEVNOTE: possibly over-versioning updates from IXFR
    //      they are version stamped in add\delete passes and
    //      we actually lose information -- granularity that we
    //      can pass to downstream secondaries -- by restamping to
    //      final version
    //
    //  DEVNOTE: leaving in the clean and version to skip ASSERTs on
    //      cleanup (as it checks pAddRecord field for validity);
    //      could fix validity check, but also should be sure here that
    //      pAddRecord does NOT get freed, which shouldn't happen because
    //      of DNSUPDATE_EXECUTED flag;  safest to leave this in and
    //      clear pAddRecord field
    //

    Up_CleanAndVersionPostUpdate( pUpdateList, pZone->dwSerialNo );

    if ( Zone_IsIxfrCapable(pZone) )
    {
        Up_AppendUpdateList( &pZone->UpdateList, pUpdateList, pZone->dwSerialNo );
    }

    //  keep rough record count for zone
    //      if out of whack, fix up

    pZone->iRRCount += pUpdateList->iNetRecords;

    if ( pZone->iRRCount <= 0 )
    {
        DNS_PRINT((
            "ERROR:  zone %s iRRCount %d after update!\n"
            "\tresetting to one.\n",
            pZone->pszZoneName,
            pZone->iRRCount ));
        pZone->iRRCount = 1;
    }

    Up_CleanZoneUpdateList( pZone );

Unlock:

    //
    //  unlock zone
    //  notify secondaries
    //  update DS peers (if necessary)
    //  free temp nodes and records
    //

    if ( ! (dwFlags & DNSUPDATE_NO_UNLOCK) )
    {
        Zone_UnlockAfterAdminUpdate( pZone );
    }

    if ( ! (dwFlags & DNSUPDATE_NO_NOTIFY) )
    {
        Xfr_SendNotify( pZone );
    }

    if ( dwFlags & DNSUPDATE_DS_PEERS )
    {
        initiateDsPeerUpdate( pUpdateList );
    }

    Up_FreeUpdatesInUpdateList( pUpdateList );
}



//
//  Dynamic update routines
//

BOOL
Up_InitializeUpdateProcessing(
    VOID
    )
/*++

Routine Description:

    Initializes dynamic update processing.
    Creates update queues and threads.

Arguments:

    None

Return Value:

    TRUE, if successful
    FALSE on error.

--*/
{
    DWORD   countUpdateThreads;

    //
    //  update queue for delayed updates
    //      - set event on queuing
    //      - discard expired and dups
    //      - keep in query order
    //

    g_UpdateQueue = PQ_CreatePacketQueue(
                        "Update",
                        QUEUE_SET_EVENT |
                            QUEUE_DISCARD_EXPIRED |
                            QUEUE_DISCARD_DUPLICATES |
                            QUEUE_QUERY_TIME_ORDER,
                        UPDATE_TIMEOUT );
    if ( !g_UpdateQueue )
    {
        DNS_PRINT(( "Update queue init FAILED!!!\n" ));
        ASSERT( FALSE );
        goto Failed;
    }

    //
    //  setup update forwarding queue to hold packets sent to primary
    //      - NO event on queuing
    //      - discard expired and dups
    //      - keep in query order
    //

    g_UpdateForwardingQueue = PQ_CreatePacketQueue(
                                "UpdateForwarding",
                                QUEUE_DISCARD_EXPIRED |
                                    QUEUE_DISCARD_DUPLICATES |
                                    QUEUE_QUERY_TIME_ORDER,
                                UPDATE_TIMEOUT );
    if ( !g_UpdateForwardingQueue )
    {
        DNS_PRINT(( "Update queue init FAILED!!!\n" ));
        ASSERT( FALSE );
        goto Failed;
    }

    //
    //  secure negotiation queue
    //      - negotiation also serviced up update threads
    //      - set event on queuing
    //      - discard expired and dups
    //      - keep in query order
    //

    g_SecureNegoQueue = PQ_CreatePacketQueue(
                                "SecureNego",
                                QUEUE_SET_EVENT |
                                    QUEUE_DISCARD_EXPIRED |
                                    QUEUE_DISCARD_DUPLICATES |
                                    QUEUE_QUERY_TIME_ORDER,
                                UPDATE_TIMEOUT );
    if ( !g_SecureNegoQueue )
    {
        DNS_PRINT(( "Secure nego queue init FAILED!!!\n" ));
        ASSERT( FALSE );
        goto Failed;
    }

    //
    //  create update threads
    //

    countUpdateThreads = g_ProcessorCount + 1;
    while ( countUpdateThreads-- )
    {
        if ( ! Thread_Create(
                    "Update",
                    Update_Thread,
                    NULL,
                    0 ) )
        {
            DNS_PRINT(( "Update thread create FAILED!!!\n" ));
            ASSERT( FALSE );
            goto Failed;
        }
    }
    return( ERROR_SUCCESS );

Failed:

    DNS_DEBUG( ANY, ( "ERROR:  Update init failed.\n" ));
    return( DNSSRV_UNSPECIFIED_ERROR );
}   //  Up_InitializeUpdateProcessing



VOID
Up_UpdateShutdown(
    VOID
    )
/*++

Routine Description:

    Initializes recursion to other DNS servers.

Arguments:

    None

Return Value:

    TRUE, if successful
    FALSE on error.

--*/
{
    PQ_CleanupPacketQueueHandles( g_UpdateQueue );
    PQ_CleanupPacketQueueHandles( g_UpdateForwardingQueue );
    PQ_CleanupPacketQueueHandles( g_SecureNegoQueue );
}



//
//  Update packet processing
//

VOID
Up_ProcessUpdate(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Process dynamic update message.

    This is called by recv thread handling update packet.
    Never called by UpdateThread itself.

Arguments:

    pMsg -- UPDATE packet

Return Value:

    None.

--*/
{
    PDB_NODE        pnode;
    PZONE_INFO      pzone;
    DNS_STATUS      status;
    UPDATE_LIST     updateList;
    DWORD           exception;


    ASSERT( pMsg->Head.Opcode == DNS_OPCODE_UPDATE );

    DNS_DEBUG( UPDATE, ( "Up_ProcessUpdate( %p ).\n", pMsg ));
    IF_DEBUG( UPDATE2 )
    {
        Dbg_DnsMessage(
            "Received UPDATE request:\n",
            pMsg );
    }

    STAT_INC( WireUpdateStats.Received );
    PERF_INC( pcDynamicUpdateReceived );

    //
    //  verify qtype SOA
    //

    if ( pMsg->wQuestionType != DNS_TYPE_SOA )
    {
        DNS_PRINT(( "WARNING:  message at %p, non-SOA UPDATE.\n" ));
        status = DNS_RCODE_FORMAT_ERROR;
        goto Failure;
    }

    //
    //  get zone being updated
    //

    pzone = Lookup_ZoneForPacketName(
                (PCHAR) pMsg->MessageBody,
                pMsg );
    if ( ! pzone )
    {
        Dbg_MessageName(
            "ERROR:  received update for non-authoritative zone ",
            pMsg->MessageBody,
            pMsg );
        status = DNS_RCODE_NOTAUTH;
        goto Failure;
    }
    pMsg->pzoneCurrent = pzone;

    //
    //  If this is a stub zone, reject the update.
    //

    if ( IS_ZONE_STUB( pzone ) || IS_ZONE_FORWARDER( pzone ) )
    {
        rejectUpdateWithRcode(
            pMsg,
            DNS_RCODE_NOTAUTH );
        return;
    }

    //
    //  forward to primary?
    //
    //  DEVNOTE: once DS enabled, do we need separate DS check
    //      should be able to update DS zone
    //

    if ( ! IS_ZONE_PRIMARY(pzone) )
    {
        Up_ForwardUpdateToPrimary( pMsg );
        return;
    }

    //
    //  zone security
    //
    //  DEVNOTE: additional zone centric update security checks!!!
    //      - may want IP list check
    //      - later RFC security
    //

    if ( ! pzone->fAllowUpdate )
    {
        Dbg_MessageName(
            "ERROR:  received update for non-updateable zone ",
            pMsg->MessageBody,
            pMsg );
        status = DNS_RCODE_NOT_IMPLEMENTED;
        STAT_INC( WireUpdateStats.NotImpl );
        goto Failure;
    }

    //
    //  queue all updates to update thread
    //
    //  this doesn't take great advantage of MP capability, but updates shouldn't
    //  be coming is such great quantity as to make that an issue
    //
    //  at a minimum, some updates can take too long so should be queuing
    //      -- all secure update (potentially way too long)
    //      -- DS updates (DS write potentially too long, especially on single
    //          TCP thread)
    //

    DNS_DEBUG( UPDATE2, (
        "Queuing update packet %p to update queue.\n",
        pMsg ));
    PQ_QueuePacketEx( g_UpdateQueue, pMsg, FALSE );
    return;

Failure:

    rejectUpdateWithRcode(
        pMsg,
        status );
}



DNS_STATUS
writeUpdateFromPacketRecord(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      PDB_NODE        pNode,
    IN      PPARSE_RECORD   pParseRR,
    IN      PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Create resource record given in packet, at a given node.

Arguments:

    pUpdateList - update list to append to

    pNode - owner node of record to be created

    pParseRR - parsed RR

    pMsg - ptr to response info

Return Value:

    ERROR_SUCCESS on successful creation.
    Otherwise error status.

--*/
{
    PDB_RECORD  prrAdd;
    PDB_RECORD  prrDelete = NULL;

    //
    //  build wire record
    //

    prrAdd = Wire_CreateRecordFromWire(
                pMsg,
                pParseRR,
                pParseRR->pchData,
                MEMTAG_RECORD_DYNUP
                );
    if ( !prrAdd )
    {
        return( DNS_ERROR_RCODE_FORMAT_ERROR );
    }

    //
    //  if delete swap -- record is delete record
    //

    if ( pParseRR->wClass == DNS_RCLASS_NONE )
    {
        prrDelete = prrAdd;
        prrAdd = NULL;

        IF_DEBUG( UPDATE2 )
        {
            Dbg_DbaseRecord(
                "New delete RR from update packet\n",
                prrDelete );
        }
    }
    ELSE_IF_DEBUG( UPDATE2 )
    {
        Dbg_DbaseRecord(
            "New add RR from update packet\n",
            prrAdd );
    }

    //
    //  create update for record
    //

    Up_CreateAppendUpdate(
        pUpdateList,
        pNode,
        prrAdd,         //  record to add
        0,              //  not type delete
        prrDelete       //  record to delete
        );
    return( ERROR_SUCCESS );
}



BOOL
doPreconditionsRRSetsMatch(
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN      BOOL            bPreconOnly
    )
/*++

Routine Description:

    Check specific RR set match preconditions.

Arguments:

    pUpdateList -- ptr to update list which contains RR set(s) that must
        match

    bPreconOnly -- precon only update

Return Value:

    TRUE -- if match
    FALSE -- no match

--*/
{
    PDB_RECORD      prr;
    PDB_RECORD      prrSetLast = NULL;
    PUPDATE         pupdateFirst = NULL;
    PUPDATE         pupdate;
    PDB_NODE        pnodePrevious = NULL;
    WORD            typePrevious = 0;
    BOOL            fmatch = TRUE;
    INT             countUpdates = 0;

    DNS_DEBUG( UPDATE, ( "doPreconditionsRRSetsMatch()\n" ));

    IF_DEBUG( UPDATE )
    {
        Dbg_UpdateList( "Precon update list", pUpdateList );
    }


    //
    //  DEVNOTE: preconditions and security?
    //      several possible models for precon and security
    //      1) full security
    //          - must validate packet, before security
    //          this keeps folks from forcing DS reads
    //          - in this model, we REFUSE all packet with secure blob
    //          virtue of simplicity here, but expensive if want clients
    //          to do periodic assert updates
    //
    //      2) full "write" security
    //          - can answer precon, but if DS write required to
    //          update aging -- then REFUSE and make them do the
    //          full deal
    //          - with this approach, can do DS write in users
    //          context, per normal op
    //          - if desired can OPTIONALLY skip precon read, unless
    //          write is indicated
    //
    //      3) no security
    //          - do refresh writes in our context, all the time
    //

    //
    //  note:  i've separated collection and execution here because
    //      A)  the code is cleaner
    //      B)  later i may clean up parsing in which case this function
    //      may be delivered a nice clean RR set ready to go
    //

    //
    //  loop through all updates in list
    //      - group precondition RRs into sets
    //

    pupdate = (PUPDATE) pUpdateList->pListHead;
    ASSERT( pupdate && pupdate->pNode );

    while ( pupdate )
    {
        prr = pupdate->pAddRR;
        ASSERT( prr && prr->pRRNext == NULL );

        //
        //  starting new RR set?
        //      - set name\type for update
        //      - if attach update to previous saved update
        //      (may not be attached because previous was built from several
        //      updates)
        //      - reset ptr to first update
        //

        if ( pupdate->pNode != pnodePrevious ||
             prr->wType != typePrevious )
        {
            countUpdates++;
            pnodePrevious = pupdate->pNode;
            typePrevious = prr->wType;
            prrSetLast = prr;

            if ( pupdateFirst )
            {
                pupdateFirst->pNext = pupdate;
            }
            pupdateFirst = pupdate;
            pupdate = pupdate->pNext;
            continue;
        }

        //
        //  same node and type as previous
        //      - cut RR from this update and add it to current RR set
        //      - cut this update from list (careful to save next ptr)
        //      - dump update structure
        //

        else
        {
            register PUPDATE pupdateNext;

            ASSERT( pupdate && prr );
            ASSERT( pupdateFirst && prrSetLast );

            prrSetLast->pRRNext = prr;
            prrSetLast = prr;

            pupdateFirst->pNext = NULL;
            pupdate->pAddRR = NULL;
            pupdateNext = pupdate->pNext;

            Up_FreeUpdateEx(
                pupdate,
                FALSE,      // not executed
                TRUE        // deref update node
                );
            pupdate = pupdateNext;
            continue;
        }
    }

    //
    //  reset shortened update list
    //

    pUpdateList->pCurrent = pupdateFirst;
    pUpdateList->dwCount = countUpdates;

    IF_DEBUG( UPDATE2 )
    {
        Dbg_UpdateList( "Precon collapsed list", pUpdateList );
    }


    //
    //  execute preconditions check
    //      - if successful, save as PRECON update for refresh
    //

    pupdate = (PUPDATE) pUpdateList->pListHead;
    ASSERT( pupdate && pupdate->pNode );

    while ( pupdate )
    {
        if ( ! RR_ListIsMatchingSet(
                    pupdate->pNode,
                    pupdate->pAddRR,
                    FALSE               // no forcing refresh
                    ) )
        {
            IF_DEBUG( UPDATE )
            {
                Dbg_DbaseNode(
                    "UPDATE Precon RR set match failure node\n",
                    pnodePrevious );
            }
            fmatch = FALSE;
            break;
        }
        pupdate->wDeleteType = UPDATE_OP_PRECON;
        pupdate = pupdate->pNext;
    }


    //
    //  if match, and aging ON, save as PRECON update
    //
    //  if ONLY PRECON update, then execute as local system update
    //  and skip security negotiation even if DS write required
    //
    //  DEVNOTE: not using LOCAL_SYSTEM for precon updates
    //      idea here is we won't WRITE to the DS with anything but user
    //      credentials to avoid precon update (aging update) bug;
    //      once we've made that decision then secure updates, need
    //      to stay in users context;   non-secure can progress in secure
    //      zone UNTIL we decide that we need to write, then they are
    //      refused;
    //
    //      an optimization is possible:
    //      precon updates CAN write as LOCAL_SYSTEM, as long as the
    //      DS node has already been written;  but if open, then must
    //      use users context;   the problem here is to handle secure
    //      update failovers -- if try to go in non-secure and FAIL
    //      must come back and use user credentials;  it is probably
    //      better to simply assume that if we arrive with credentials
    //      then it's because we were REFUSED or want mutual-auth, so
    //      should do full secure update
    //

    if ( fmatch  &&  (pUpdateList->Flag & DNSUPDATE_AGING_ON) )
    {
        if ( bPreconOnly )
        {
            DNS_DEBUG( UPDATE, (
                "Precon-only update %p, will be executed as local system.\n",
                pUpdateList->pMsg ));

            //pUpdateList->Flag |= DNSUPDATE_LOCAL_SYSTEM | DNSUPDATE_PRECON;
            pUpdateList->Flag |= DNSUPDATE_PRECON;
        }
    }

    //
    //  if precon failure or not aging -- cleanup list
    //

    else
    {
        DWORD   flag;

        //
        //  cleanup update list
        //      - free updates and records
        //      - but save and restore flags
        //

        ASSERT( ! (pUpdateList->Flag & DNSUPDATE_EXECUTED) );
        ASSERT( ! (pUpdateList->Flag & DNSUPDATE_COPY) );

        flag = pUpdateList->Flag;

        Up_FreeUpdatesInUpdateList( pUpdateList );
        Up_InitUpdateList( pUpdateList );

        pUpdateList->Flag = flag;
    }

    return( fmatch );

}   //  doPreconditionsRRSetsMatch



BOOL
checkUpdatePolicy(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Checks to see if updates allowed under update policy.

Arguments:

    pUpdateList - list with update

    pZone - zone being updated

Return Value:

    TRUE -- update allowed to proceed
    FALSE -- update failed policy check

--*/
{
    PUPDATE         pupdate;
    PDB_NODE        pnode;
    WORD            type;
    DWORD           options;
    DWORD           nodeMask;
    DWORD           typeMask;


    DNS_DEBUG( UPDATE, (
        "checkUpdatePolicy(), zone %s = %p\n"
        "\tpUpdateList = %p\n",
        pZone->pszZoneName,
        pZone,
        pUpdateList ));

    //
    //  get policy options for this zone update type
    //      - secure option bits are one byte higher
    //

    options = SrvCfg_dwUpdateOptions;

    if ( pZone->fAllowUpdate == ZONE_UPDATE_SECURE )
    {
        options = (options >> 8);
    }
    if ( options == 0 )
    {
        return( TRUE );
    }

    //
    //  loop through all updates in list
    //

    for ( pupdate = pUpdateList->pListHead;
          pupdate != NULL;
          pupdate = pupdate->pNext )
    {
        pnode = pupdate->pNode;

        //
        //  if precon check, then ignore policy
        //

        if ( pupdate->wDeleteType == UPDATE_OP_PRECON )
        {
            continue;
        }

        //
        //  node check
        //      - zone root             -> root NS SOA checks
        //      - DNS server host node  -> host check, delegation check
        //      - regular node          -> delegation check

        if ( pnode == pZone->pZoneRoot )
        {
            nodeMask = UPDATE_NO_SOA | UPDATE_NO_ROOT_NS;
        }
        else if ( IS_THIS_HOST_NODE(pnode) )
        {
            nodeMask = UPDATE_NO_DELEGATION_NS | UPDATE_NO_SERVER_HOST;
        }
        else
        {
            nodeMask = UPDATE_NO_DELEGATION_NS;
        }

        //
        //  find update type
        //

        if ( pupdate->pAddRR )
        {
            type = pupdate->pAddRR->wType;
        }
        else if ( pupdate->pDeleteRR )
        {
            type = pupdate->pDeleteRR->wType;
        }
        else
        {
            type = pupdate->wDeleteType;
        }

        //
        //  build policy mask for type
        //
        //  delete all is oddball case:
        //  potentially disallowed at root or DNS server host, but
        //  for ordinary node DELEGATION policy only interesting if
        //  node is ALREADY a zone root
        //

        if ( type == DNS_TYPE_A )
        {
            typeMask = UPDATE_NO_SERVER_HOST;
        }
        else if ( type == DNS_TYPE_NS )
        {
            typeMask = UPDATE_NO_ROOT_NS | UPDATE_NO_DELEGATION_NS;
        }
        else if ( type == DNS_TYPE_SOA )
        {
            typeMask = UPDATE_NO_SOA;
        }
        else if ( type == DNS_TYPE_ALL )
        {
            typeMask = 0xffffffff;

            if ( nodeMask == UPDATE_NO_DELEGATION_NS &&
                 ! IS_ZONE_ROOT(pnode) )
            {
                continue;
            }
        }
        else    // type is harmless
        {
            continue;
        }

        //
        //  if type and node have no policy
        //

        if ( (typeMask & nodeMask) & options )
        {
            DNS_DEBUG( UPDATE, (
                "Update policy failure!\n"
                "\tzone     = %s (up=%d)\n"
                "\toptions  = %p\n"
                "\tnode     = %s\n"
                "\tmask     = %p\n"
                "\ttype     = %d\n"
                "\tmask     = %p\n",
                pZone->pszZoneName,
                pZone->fAllowUpdate,
                options,
                pnode->szLabel,
                nodeMask,
                type,
                typeMask ));

            return( FALSE );
        }

        DNS_DEBUG( OFF, (
            "Update policy passes!\n"
            "\tzone     = %s (up=%d)\n"
            "\toptions  = %p\n"
            "\tnode     = %s\n"
            "\tmask     = %p\n"
            "\ttype     = %d\n"
            "\tmask     = %p\n",
            pZone->pszZoneName,
            pZone->fAllowUpdate,
            options,
            pnode->szLabel,
            nodeMask,
            type,
            typeMask ));

        continue;
    }

    return( TRUE );
}



DNS_STATUS
parseUpdatePacket(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN OUT  PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Check preconditions on UPDATE request.

Arguments:

    pMsg - ptr to response info

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    register PCHAR      pch;
    PCHAR               pchname;
    PCHAR               pchNextName;
    PDB_NODE            pnode = NULL;
    PDB_NODE            pnodeClosest;
    PZONE_INFO          pzone = pMsg->pzoneCurrent;
    INT                 sectionIndex;
    INT                 countSectionRR;
    WORD                type;
    WORD                updateType = 0;
    WORD                class;
    PCHAR               pchpacketEnd;
    DNS_STATUS          status = ERROR_SUCCESS;
    BOOL                fpreconPostProcessing = FALSE;
    PARSE_RECORD        parseRR;
    DWORD               dwFlag;


    DNS_DEBUG( UPDATE, (
        "parseUpdatePacket(), zone %s = %p, pMsg = %p\n",
        pzone->pszZoneName,
        pzone,
        pMsg ));

    //
    //  loop through all resource records
    //      - already processed zone section
    //

    pchpacketEnd = DNSMSG_END( pMsg );
    pchNextName = pMsg->pCurrent;

    sectionIndex = ZONE_SECTION_INDEX;
    countSectionRR = 0;

    while( 1 )
    {
        //
        //  new section?
        //

        if ( countSectionRR == 0 )
        {
            if ( sectionIndex == ADDITIONAL_SECTION_INDEX )
            {
                break;
            }
            sectionIndex++;
            countSectionRR = RR_SECTION_COUNT( pMsg, sectionIndex );
            continue;
        }
        countSectionRR--;

        //
        //  read next RR name
        //      - insure we stay within message

        pchname = pchNextName;

        IF_DEBUG ( READ2 )
        {
            Dbg_MessageName(
                "RR name ",
                pchname,
                pMsg );
        }
        pch = Wire_SkipPacketName( pMsg, pchname );
        if ( ! pch )
        {
            DNS_PRINT(( "ERROR:  bad RR owner name in update packet.\n" ));
            status = DNS_RCODE_FORMAT_ERROR;
            break;
        }

        //
        //  extract RR info, type, datalength
        //      - verify RR within message
        //

        pchNextName = Wire_ParseWireRecord(
                        pch,
                        pchpacketEnd,
                        FALSE,          // no CLASS_IN requirement
                        & parseRR
                        );
        if ( !pchNextName )
        {
            DNS_PRINT(( "ERROR:  bad RR in packet.\n" ));
            status = DNS_RCODE_FORMAT_ERROR;
            break;
        }
        type = parseRR.wType;
        class = parseRR.wClass;

        //
        //  preconditions RR section -- test preconditions
        //

        if ( sectionIndex == PREREQ_SECTION_INDEX )
        {
            //  all preconditions TTLs zero
            //  note:  could argue prereq no-exists should accept type==0
            //      and screen only for existence

            if ( parseRR.dwTtl != 0 || type == 0 )
            {
                DNS_PRINT(( "ERROR:  non-zero TTL in preconditions RR.\n" ));
                status = DNS_RCODE_FORMAT_ERROR;
                break;
            }

            //  all preconditions RRs must be within zone
            //
            //  DEVNOTE: should allow non-zone names, in zone subtree?
            //  JJCONVERT:  create lookup that allows specification of FIND in zone or delegation
            //

            pnode = Lookup_ZoneNode(
                        pzone,
                        pchname,
                        pMsg,
                        NULL,           // no lookup name
                        0,              // no flags
                        &pnodeClosest,  // find
                        NULL            // following node ptr
                        );
            if ( !pnodeClosest )
            {
                DNS_DEBUG( UPDATE, (
                    "ERROR:  Update delete RR outside update zone.\n" ));
                status = DNS_RCODE_NOTZONE;
                break;
            }
            else if ( IS_OUTSIDE_ZONE_NODE(pnodeClosest) )
            {
                DNS_DEBUG( UPDATE, (
                    "ERROR:  Update delete RR outside update zone.\n" ));
                status = DNS_RCODE_NOTZONE;
                break;
            }

            //
            //  zone class -- entire RR set must exist
            //      - type NOT compound type
            //      - name must exist
            //      - build and save temporary RR
            //

            if ( class == DNS_RCLASS_INTERNET )
            {
                if ( IS_COMPOUND_TYPE(type) )
                {
                    DNS_PRINT(( "ERROR:  Bad type (%d) in prereq RR.\n", type ));
                    status = DNS_RCODE_FORMAT_ERROR;
                    break;
                }
                if ( !pnode )
                {
                    DNS_DEBUG( UPDATE, (
                        "ERROR:  Prereq RR set at nonexistant node.\n" ));
                    status = DNS_RCODE_NXRRSET;
                    break;
                }
                status = writeUpdateFromPacketRecord(
                            pUpdateList,
                            pnode,
                            & parseRR,
                            pMsg
                            );
                if ( status != ERROR_SUCCESS )
                {
                    break;
                }
                fpreconPostProcessing = TRUE;
                continue;
            }

            //
            //  other classes -- ANY, NONE -- are name and RR set exist\no
            //      - no compound types except ANY
            //      - no data
            //
            //  note:  compound test perhaps not strictly necessary, could
            //      just let the type check succeed or fail
            //

            if ( parseRR.wDataLength != 0 )
            {
                DNS_PRINT(( "ERROR:  Preconditions RR data in non-zone class.\n" ));
                status = DNS_RCODE_FORMAT_ERROR;
                break;
            }
            if ( IS_COMPOUND_TYPE_EXCEPT_ANY(type) )
            {
                DNS_PRINT(( "ERROR:  Preconditions RR with invalid type.\n" ));
                status = DNS_RCODE_FORMAT_ERROR;
                break;
            }

            //
            //  class ANY -- MUST exist
            //      - for ANY, name MUST exist
            //      - for other types, RR set of type MUST exist
            //

            if ( class == DNS_RCLASS_ALL )
            {
                if ( ! RR_ListIsMatchingType(
                            pnode,
                            type ) )
                {
                    if ( type == DNS_TYPE_ANY )
                    {
                        DNS_DEBUG( UPDATE, (
                            "ERROR:  Preconditions missing name.\n" ));
                        status = DNS_RCODE_NAME_ERROR;
                        break;
                    }
                    else
                    {
                        DNS_DEBUG( UPDATE, (
                            "ERROR:  Preconditions missing RR set.\n" ));
                        status = DNS_RCODE_NXRRSET;
                        break;
                    }
                }
                continue;
            }

            //
            //  class NONE -- MUST NOT exist
            //      - for ANY, name MUST NOT exist
            //      - for other types, RR set of type MUST NOT exist
            //

            else if ( class == DNS_RCLASS_NONE )
            {
                if ( RR_ListIsMatchingType(
                        pnode,
                        type ) )
                {
                    if ( type == DNS_TYPE_ANY )
                    {
                        DNS_DEBUG( UPDATE,
                            ( "ERROR:  Preconditions fail no-exist name.\n" ));
                        status = DNS_RCODE_YXDOMAIN;
                        break;
                    }
                    else
                    {
                        DNS_DEBUG( UPDATE,
                            ( "ERROR:  Preconditions fail no-exist RR set.\n" ));
                        status = DNS_RCODE_YXRRSET;
                        break;
                    }
                }
                continue;
            }

            //
            //  all other classes are errors
            //

            else
            {
                DNS_PRINT(( "ERROR:  Invalid UPDATE precon class %d.\n", class ));
                status = DNS_RCODE_FORMAT_ERROR;
                break;
            }

        }   // end preconditions processing


        //
        //  in Update RR section -- do update processing
        //

        else if ( sectionIndex == UPDATE_SECTION_INDEX )
        {
            //
            //  delayed preconditions processing
            //

            if ( fpreconPostProcessing )
            {
                fpreconPostProcessing = FALSE;
                if ( ! doPreconditionsRRSetsMatch(
                            pUpdateList,
                            FALSE           // not precon only
                            ) )
                {
                    status = DNS_RCODE_NXRRSET;
                    break;
                }
            }

            //  trap type==0
            //  note:  could be considered valid for delete conditions
            //      but simpler just to whack right here
            //      type==0, records kick of type existence ASSERT()s

            if ( type == 0 )
            {
                DNS_PRINT(( "ERROR:  zero type in update RR.\n" ));
                status = DNS_RCODE_FORMAT_ERROR;
                break;
            }

            //  track update types
            //      - track if single type or mixed type update

            if ( type != updateType )
            {
                if ( updateType )
                {
                    updateType = STATS_TYPE_MIXED;
                }
                else
                {
                    updateType = type;
                }
            }

            //
            //  zone class -- RR add
            //      - find/create name since doing add
            //      - name must be in zone
            //      - type NOT compound type
            //
            //  DEVNOTE: no update of non-glue, non-NS records below zone?
            //

            if ( class == DNS_RCLASS_INTERNET )
            {
                if ( IS_COMPOUND_TYPE(type) )
                {
                    DNS_PRINT(( "ERROR:  Bad (compound) type in update RR.\n" ));
                    status = DNS_RCODE_FORMAT_ERROR;
                    break;
                }

                pnode = Lookup_ZoneNode(
                            pzone,
                            pchname,
                            pMsg,
                            NULL,                   // no lookup name
                            LOOKUP_WITHIN_ZONE,     // don't create outside zone
                            NULL,                   // create not find
                            NULL                    // following node ptr
                            );
                if ( !pnode )
                {
                    //  might be bad name, but return NOT_ZONE to keep denise happy
                    status = GetLastError();
                    if ( status == ERROR_INVALID_NAME )
                    {
                        status = DNS_RCODE_FORMERR;
                    }
                    else
                    {
                        status = DNS_RCODE_NOTZONE;
                    }
                    break;
                }
                if ( IS_OUTSIDE_ZONE_NODE(pnode) )
                {
                    status = DNS_RCODE_NOTZONE;
                    break;
                }
                status = writeUpdateFromPacketRecord(
                            pUpdateList,
                            pnode,
                            & parseRR,
                            pMsg
                            );
                if ( status != ERROR_SUCCESS )
                {
                    break;
                }
                continue;
            }

            //
            //  all other classes -- delete operations
            //      - no TTL
            //      - find name since only doing delete
            //
            //  DEVNOTE: should allow non-zone names, in zone subtree?
            //

            if ( parseRR.dwTtl != 0 )
            {
                DNS_PRINT(( "ERROR:  Non-zero TTL in update delete.\n" ));
                status = DNS_RCODE_FORMAT_ERROR;
                break;
            }
            pnode = Lookup_ZoneNode(
                        pzone,
                        pchname,
                        pMsg,
                        NULL,                   // no lookup name
                        LOOKUP_WITHIN_ZONE,     // don't create outside zone
                        &pnodeClosest,          // find
                        NULL                    // following node ptr
                        );
            if ( !pnodeClosest )
            {
                DNS_DEBUG( UPDATE, (
                    "ERROR:  Update delete RR outside update zone.\n" ));
                status = DNS_RCODE_NOTZONE;
                break;
            }
            else if ( IS_OUTSIDE_ZONE_NODE(pnodeClosest) )
            {
                DNS_PRINT(( "ERROR:  Update delete RR outside update zone.\n" ));
                status = DNS_RCODE_NOTZONE;
                break;
            }

            //
            //  class ANY -- delete RR set, or all sets
            //      - no RR data
            //      - ANY type allow, but no other compound types
            //      - no update if node doesn't exist
            //      - do delete, special case update zone root
            //

            if ( class == DNS_RCLASS_ALL )
            {
                if ( parseRR.wDataLength != 0 || IS_COMPOUND_TYPE_EXCEPT_ANY(type) )
                {
                    DNS_PRINT(( "ERROR:  Update class ANY (delete) invalid.\n" ));
                    status = DNS_RCODE_FORMAT_ERROR;
                    break;
                }
                if ( !pnode )
                {
                    DNS_DEBUG( UPDATE, ( "UPDATE delete a non-existant node.\n" ));
                    continue;
                }

                if ( !Up_CreateAppendUpdate(
                          pUpdateList,
                          pnode,
                          NULL,
                          type,       // type delete
                          NULL ) )
                {
                    status = DNS_RCODE_SERVER_FAILURE;
                    break;
                }
                continue;
            }

            //
            //  class NONE -- delete a particular RR from an RR set
            //      - no compound types
            //      - ignore attempt to delete SOA
            //      - ignore attempts to delete non-existent record
            //
            //  DEVNOTE: DS issue -- delete non-existant record should query DS
            //          for name, then fail
            //

            else if ( class == DNS_RCLASS_NONE )
            {
                if ( IS_COMPOUND_TYPE(type) )
                {
                    DNS_PRINT((
                        "ERROR:  Update class NONE (delete) invalid with type = %d.\n",
                        type ));
                    status = DNS_RCODE_FORMAT_ERROR;
                    break;
                }
                if ( !pnode )
                {
                    DNS_DEBUG( UPDATE, ( "UPDATE delete a non-existant node.\n" ));
                    continue;
                }
                if ( type == DNS_TYPE_SOA )
                {
                    DNS_DEBUG( UPDATE, ( "UPDATE delete an SOA record.\n" ));
                    continue;
                }
                status = writeUpdateFromPacketRecord(
                            pUpdateList,
                            pnode,
                            & parseRR,
                            pMsg
                            );
                if ( status != ERROR_SUCCESS )
                {
                    break;
                }
                continue;
            }

            //
            //  unknown class
            //

            else
            {
                DNS_PRINT(( "ERROR:  Invalid UPDATE class %d.\n", class ));
                status = DNS_RCODE_FORMAT_ERROR;
                break;
            }

        }   //  end Update section

        //
        //  in Additional section
        //

        else
        {
            ASSERT( sectionIndex == ADDITIONAL_SECTION_INDEX );
            break;
        }

    }   // loop writing update RRs to database

    //
    //  delayed preconditions processing
    //  test again here to allow for case where no update section
    //

    if ( fpreconPostProcessing )
    {
        DNS_DEBUG( UPDATE, (
            "WARNING:  Processing preconditions RR set for packet %p\n"
            "\twith no UPDATE section.\n",
            pMsg ));

        if ( ! doPreconditionsRRSetsMatch(
                    pUpdateList,
                    TRUE            // precon only
                    ) )
        {
            status = DNS_RCODE_NXRRSET;
        }
    }

    //
    //  update type tracking
    //

    if ( status == ERROR_SUCCESS && updateType )
    {
        if ( updateType > STATS_TYPE_MAX )
        {
            updateType = STATS_TYPE_UNKNOWN;
        }
        STAT_INC( WireUpdateStats.UpdateType[updateType] );
    }

    //
    //  check dynamic update policy
    //

    if ( ! checkUpdatePolicy( pzone, pUpdateList ) )
    {
        status = DNS_RCODE_REFUSED;
    }

    DNS_DEBUG( UPDATE, (
        "Parsed UPDATE message at %p\n"
        "\tstatus = %p\n",
        pMsg,
        status ));

    return( status );

}   // parseUpdatePacket



VOID
rejectUpdateWithRcode(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      DWORD           Rcode
    )
/*++

Routine Description:

    Reject update request with given response code.

Arguments:

    pMsg -- update message being rejected

    Rcode -- rcode to return in response

Return Value:

    None.

--*/
{
    LPSTR   pszclientIp = inet_ntoa( pMsg->RemoteAddress.sin_addr );

    DNS_DEBUG( UPDATE, (
        "ERROR:  Update failure (%s) for packet %p.\n"
        "\tclient IP %s\n",
        Dns_ResponseCodeString( Rcode ),
        pMsg,
        pszclientIp ));

    switch( Rcode )
    {

    case DNS_RCODE_SERVER_FAILURE:
#if 0
        //
        //  server failure now encompasses common case of collision, don't log error
        //
        DNS_LOG_EVENT(
            DNS_EVENT_SERVER_FAILURE_PROCESSING_PACKET,
            1,
            & pszclientIp,
            EVENTARG_ALL_UTF8,
            0 );
#endif
        DNS_DEBUG( UPDATE, (
            "Server failure processing UPDATE packet from %s\n",
            pszclientIp
            ));
        //ASSERT( FALSE );
        break;

    case DNS_RCODE_FORMAT_ERROR:

        DNS_LOG_EVENT(
            DNS_EVENT_BAD_UPDATE_PACKET,
            1,
            & pszclientIp,
            EVENTARG_ALL_UTF8,
            0 );
        DNS_DEBUG( ANY, (
            "FORMERR in UPDATE packet from %s\n",
            pszclientIp
            ));
        STAT_INC( WireUpdateStats.FormErr );
        break;

    case DNS_RCODE_NAME_ERROR:

        STAT_INC( WireUpdateStats.NxDomain );
        break;

    case DNS_RCODE_REFUSED:

        DNS_DEBUG( UPDATE, (
            "Refused UPDATE query at %p from %s\n",
            pMsg,
            pszclientIp ));
        STAT_INC( WireUpdateStats.Refused );
        break;

    case DNS_RCODE_YXDOMAIN:

        STAT_INC( WireUpdateStats.YxDomain );
        break;

    case DNS_RCODE_YXRRSET:

        STAT_INC( WireUpdateStats.YxRrset );
        break;

    case DNS_RCODE_NXRRSET:

        STAT_INC( WireUpdateStats.NxRrset );
        break;

    case DNS_RCODE_NOTAUTH:

        STAT_INC( WireUpdateStats.NotAuth );
        break;

    case DNS_RCODE_NOTZONE:

        STAT_INC( WireUpdateStats.NotZone );
        break;

    case DNS_RCODE_NOT_IMPLEMENTED:

        //
        // used to be refused, but changed to not implemented.
        // we'll use the same counter for now.
        //
        STAT_INC( WireUpdateStats.Refused );
        break;

    default:
        DNS_PRINT(( "ERROR:  unknown rcode = %p\n", Rcode ));
        ASSERT( FALSE );
    }

    IF_DEBUG( UPDATE2 )
    {
        Dbg_DnsMessage(
            "Sending update failure response:\n",
            pMsg );
    }
    Reject_RequestIntact( pMsg, ( UCHAR ) Rcode, 0 );
    STAT_INC( WireUpdateStats.Rejected );
    PERF_INC( pcDynamicUpdateRejected );              // PerfMon hook
}



BOOL
processWireUpdateMessage(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Process dynamic update message.

    This is the core routine that locks zone and database, calls parser
    do update (if necessary), logs update, unlocks, sends response.

Arguments:

    pMsg -- UPDATE packet

Return Value:

    TRUE if update completed.
    FALSE if update requeued.

--*/
{
    PZONE_INFO      pzone = pMsg->pzoneCurrent;
    DNS_STATUS      status;
    UPDATE_LIST     updateList;
    DWORD           exception;
    DWORD           dwType;
    BOOL            bnoUpdatePrecon = FALSE;

    //
    //  lock zone for update, if fail requeue packet
    //
    //  should not generally happen as check if zone locked before dequeue
    //  but occasionally someone else could sneak in
    //

    if ( ! Zone_LockForUpdate( pzone ) )
    {
        DNS_PRINT((
            "WARNING:  unable to lock zone for UPDATE packet %p.\n",
            pMsg ));
        PQ_QueuePacketEx( g_UpdateQueue, pMsg, FALSE );
        return( FALSE );
    }

    //  init update list
    //  aging on for dynamic updates

    Up_InitUpdateList( &updateList );

    updateList.Flag = DNSUPDATE_PACKET;
    updateList.Flag |= DNSUPDATE_AGING_ON;

    //
    //  parse packet
    //

    status = parseUpdatePacket( pMsg, &updateList );
    if ( status != ERROR_SUCCESS )
    {
        goto Failure;
    }

    //  if precon only and not aging zone -- then no update necessary

    if ( (updateList.Flag & DNSUPDATE_PRECON)  &&  !pzone->bAging )
    {
        goto PreconOnly;
    }

    //  note if has security section
    //
    //  DEVNOTE: should parse update and know if packet secure

    if ( pMsg->Head.AdditionalCount == 0 )
    {
        updateList.Flag |= DNSUPDATE_NONSECURE_PACKET;
    }

    updateList.pMsg = pMsg;

    status = Up_ExecuteUpdate(
                    pzone,
                    &updateList,
                    DNSUPDATE_ALREADY_LOCKED
                    );
    if ( status != ERROR_SUCCESS )
    {
        goto FailAlreadyCleanedUp;
    }

    //  ACK update packet
    //      - setup packet for response

    pMsg->pCurrent = DNSMSG_END( pMsg );
    pMsg->Head.IsResponse = TRUE;
    pMsg->fDelete = TRUE;

    IF_DEBUG( UPDATE2 )
    {
        Dbg_DnsMessage(
            "Sending update response:\n",
            pMsg );
    }
    Send_Msg( pMsg );

    return( TRUE );


PreconOnly:

    DNS_DEBUG( UPDATE2, (
        "Successful precon only update in non-aging zone.\n" ));

    //  clear zone lock

    Zone_UnlockAfterAdminUpdate( pzone );

    //  ACK update packet

    pMsg->pCurrent = DNSMSG_END( pMsg );
    pMsg->Head.IsResponse = TRUE;
    pMsg->fDelete = TRUE;

    IF_DEBUG( UPDATE2 )
    {
        Dbg_DnsMessage(
            "Sending precon update response:\n",
            pMsg );
    }
    Send_Msg( pMsg );

    //  cleanup update list

    Up_FreeUpdatesInUpdateList( &updateList );

    return( TRUE );


Failure:

    //
    //  all failure (non-update) cases
    //

    Zone_UnlockAfterAdminUpdate( pzone );

    //  cleanup update list

    Up_FreeUpdatesInUpdateList( &updateList );


FailAlreadyCleanedUp:

    //  determine failure RCODE

    if ( (DWORD)status > MAX_UPDATE_RCODE )
    {
        //  map standard DNS ERRORs corresponding to RCODEs directly

        if ( status > DNS_ERROR_RESPONSE_CODES_BASE  &&
             status < DNS_ERROR_RESPONSE_CODES_BASE + 16 )
        {
            status -= DNS_ERROR_RESPONSE_CODES_BASE;
        }

        //  map invalid into FORMERR

        else if ( status == DNS_ERROR_INVALID_NAME ||
                  status == DNS_ERROR_INVALID_DATA )
        {
            status = DNS_RCODE_FORMAT_ERROR;
        }

        //  default with REFUSED
        //      - handles all possible status codes from secure update

        else
        {
            status = DNS_RCODE_REFUSED;
        }
    }

    rejectUpdateWithRcode(
        pMsg,
        status );

    return( TRUE );
}




VOID
Up_WriteDerivedUpdateStats(
    VOID
    )
/*++

Routine Description:

    Write derived UPDATE status.

Arguments:

    None

Return Value:

    None

--*/
{
    //  stats from update queue

    WireUpdateStats.Queued  = g_UpdateQueue->cQueued;
    PERF_SET( pcDynamicUpdateQueued , g_UpdateQueue->cQueued );      // PerfMon hook
    WireUpdateStats.Timeout = g_UpdateQueue->cTimedOut;
    PERF_SET( pcDynamicUpdateTimeOut , g_UpdateQueue->cTimedOut );   // PerfMon hook
    WireUpdateStats.InQueue = g_UpdateQueue->cLength;

    //  stats from forwarding queue

    WireUpdateStats.Forwards        = g_UpdateForwardingQueue->cQueued;
    WireUpdateStats.ForwardTimeouts = g_UpdateForwardingQueue->cTimedOut;
    WireUpdateStats.ForwardInQueue  = g_UpdateForwardingQueue->cLength;
}



//
//  Update forwarding
//

VOID
updateForwardConnectCallback(
    IN OUT  PDNS_MSGINFO    pMsg,
    IN      BOOL            fConnected
    )
/*++

Routine Description:

    Callback when TCP forwarding routines complete connect.

    If connected -- send update query
    If not -- continue lookup on query

Arguments:

    pMsg -- update message

    fConnected -- connect to remote DNS completed

Return Value:

    None

--*/
{
    ASSERT( pMsg );
    ASSERT( !pMsg->pConnection );

    DNS_DEBUG( UPDATE, (
        "updateConnectCallback( %p )\n"
        "\tTCP = %d\n"
        "\tremote DNS = %s\n"
        "\tconnect successful = %d\n",
        pMsg,
        pMsg->fTcp,
        IP_STRING( pMsg->RemoteAddress.sin_addr.s_addr ),
        fConnected ));

    //
    //  send update forward
    //      - clear forwarding queue of dead entries
    //      - stick on forwarding packet queue
    //      - use new XID in forward
    //
    //  note:  to avoid duplicating this code, we're also calling this routine
    //      to send regular UDP forwards
    //

    if ( fConnected )
    {
        if ( g_UpdateForwardingQueue->cLength )
        {
            PQ_DiscardExpiredQueuedPackets(
                g_UpdateForwardingQueue,
                FALSE );
        }

        pMsg->wQueuingXid = 0;      //  not requeuing, get new XID
        pMsg->dwExpireTime = 0;     //  default expire time

        DNS_DEBUG( UPDATE2, (
            "Forwarding UPDATE packet %p, queuing XID = %hx.\n"
            "\tto zone primary at %s.\n",
            pMsg,
            pMsg->Head.Xid,
            IP_STRING( pMsg->RemoteAddress.sin_addr.s_addr )
            ));

        PQ_QueuePacketWithXidAndSend(
                g_UpdateForwardingQueue,
                pMsg );

        STAT_INC( WireUpdateStats.Forwards );
        return;
    }

    //
    //  connection failed
    //      - send failure to client
    //

    else
    {
        IF_DEBUG( UPDATE )
        {
            Dbg_DnsMessage(
                "Failed TCP connect update forward",
                pMsg );
        }
        ASSERT( !pMsg->fTcp );

        RESTORE_FORWARDING_FIELDS(pMsg);
        pMsg->fDelete = TRUE;
        Reject_RequestIntact( pMsg, DNS_RCODE_SERVER_FAILURE, 0 );
        return;
    }
}



VOID
Up_ForwardUpdateToPrimary(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Forward dynamic update to primary DNS for zone.

Arguments:

    pMsg -- UPDATE packet

Return Value:

    None.

--*/
{
    PZONE_INFO  pzone = pMsg->pzoneCurrent;
    IP_ADDRESS  primaryIp;

    DNS_DEBUG( UPDATE, (
        "Up_ForwardUpdateToPrimary( %p ).\n"
        "\tzone = %s\n",
        pMsg,
        pzone->pszZoneName ));

    //
    //  get primary IP
    //
    //  DEVNOTE: must save primary IP
    //      - get from SOA primary, NS, A
    //      - on load, again on successful transfer
    //

    primaryIp = pzone->ipPrimary;
    if ( !primaryIp )
    {
        if ( pzone->aipMasters  &&  pzone->aipMasters->AddrCount > 0 )
        {
            primaryIp = pzone->ipPrimary = pzone->aipMasters->AddrArray[0];
        }
        else
        {
            Reject_RequestIntact( pMsg, DNS_RCODE_SERVER_FAILURE, 0 );
            ASSERT( FALSE );
            return;
        }
    }
    ASSERT( pzone->ipPrimary );

    //
    //  setup message for queuing and resend
    //

    SAVE_FORWARDING_FIELDS(pMsg);
    pMsg->fDelete = FALSE;
    pMsg->pCurrent = DNSMSG_END( pMsg );
    pMsg->Socket = g_UdpSendSocket;
    pMsg->RemoteAddress.sin_addr.s_addr = primaryIp;
    pMsg->RemoteAddress.sin_port = DNS_PORT_NET_ORDER;

    //
    //  DEVNOTE: common forward query architecture?
    //      - save off old
    //      - do TCP check, connect, save circut
    //      - send
    //      - note recurse (cause queries always < 512)
    //          will already have saved
    //

    //
    //  need TCP connection to primary
    //      - must connect if greater than max UDP length
    //

    if ( pMsg->MessageLength > DNS_RFC_MAX_UDP_PACKET_LENGTH )
    {
        ASSERT( pMsg->fTcp );

        STAT_INC( WireUpdateStats.TcpForwards );

        Tcp_ConnectForForwarding(
             pMsg,
             primaryIp,
             updateForwardConnectCallback );
        return;
    }

    //
    //  forward update packet
    //
    //  note:  to save duplicate code, we just call TCP forwarding connect
    //      completion routine above, with successful connect indication
    //      this queues and send update to remote DNS
    //

    updateForwardConnectCallback(
        pMsg,
        TRUE        // UDP equivalent to successful connect
        );
}



VOID
Up_ForwardUpdateResponseToClient(
    IN OUT  PDNS_MSGINFO    pResponse
    )
/*++

Routine Description:

    Forward dynamic update response back to client.

Arguments:

    pResponse -- UPDATE packet

Return Value:

    None.

--*/
{
    PDNS_MSGINFO  pquery;

    DNS_DEBUG( UPDATE, (
        "Up_ForwardUpdateResponseToClient( %p ).\n",
        pResponse ));

    //
    //  note that caller frees pResponse (answer.c)
    //  this routine need only cleanup original query (if found in queue)
    //

    //
    //  dequeue matching update query
    //

    pquery = PQ_DequeuePacketWithMatchingXid(
                g_UpdateForwardingQueue,
                pResponse->Head.Xid
                );
    if ( !pquery )
    {
        //  no matching query?
        //  this can happen if reponse comes back after timeout

        IF_DEBUG( RECURSE )
        {
            EnterCriticalSection( & g_UpdateForwardingQueue->csQueue );
            DNS_PRINT((
                "No matching UPDATE for response at %p -- discarding.\n"
                "\tResponse XID = 0x%04x\n",
                pResponse,
                pResponse->Head.Xid ));
            Dbg_PacketQueue(
                "Update packet queue -- no matching response",
                g_UpdateForwardingQueue );
            LeaveCriticalSection( & g_UpdateForwardingQueue->csQueue );
        }
        return;
    }

    //
    //  setup message for response to client
    //      - if TCP close connection used for forwarding
    //      - note:  we do NOT close connection from client;  it is
    //      allowed to send multiple messages per RFC
    //

    if ( pResponse->fTcp )
    {
        DNS_DEBUG( UPDATE, (
            "Deleting TCP update forwarding connection on socket %d\n",
            pResponse->Socket ));

        Tcp_ConnectionDeleteForSocket( pResponse->Socket, NULL );
    }
    STAT_INC( WireUpdateStats.ForwardResponses );

    Send_ForwardResponseAsReply(
            pResponse,
            pquery );

    Packet_Free( pquery );
    return;
}



DNS_STATUS
rollBackFailedUpdateFromDs(
    IN      PLDAP           pLdapHandle,
    IN OUT  PUPDATE_LIST    pUpdateList,
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Roll back failed update, rewriting current nodes to DS.

Arguments:

    pUpdateList - list with failed update

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    PDB_NODE        pnodeReal;
    PDB_NODE        pnodeTemp;
    DNS_STATUS      status;

    DNS_DEBUG( UPDATE, (
        "rollBackFailedUpdateFromDs()\n" ));

    //
    //  loop through all updates in list
    //
    //      - find or create temporary node for real database node
    //      - if creating, create copy of node's RR list, to "execute" update on
    //      - update reset to point at temporary node
    //

    for ( pnodeTemp = pUpdateList->pTempNodeList;
          pnodeTemp != NULL;
          pnodeTemp = TNODE_NEXT_TEMP_NODE(pnodeTemp) )
    {
        //  if reach node that failed write, we're done rolling back

        if ( pnodeTemp == pUpdateList->pNodeFailed )
        {
            break;
        }

        if ( TNODE_FLAG(pnodeTemp) == TNODE_FLAG_ROLLED_BACK )
        {
            DNS_DEBUG( UPDATE, (
                "Rollback previous completed on temp node %p\n", pnodeTemp ));
            ASSERT( FALSE );
            continue;
        }

        //  find real node corresponding to update temp node
        //  rewrite real node to DS to overwrite previous update
        //
        //  note:  this depends on fact that currently keeping all DNS records
        //      in a single DS attribute;  if this changes, then MUST include
        //      type information here from update OR always rewrite entire
        //      node when rolling back
        //

        pnodeReal = TNODE_MATCHING_REAL_NODE( pnodeTemp );
        TNODE_FLAG(pnodeTemp) = TNODE_FLAG_ROLLED_BACK;

        DNS_DEBUG( UPDATE, (
            "Rollback temp node %p, real node %p\n",
            pnodeTemp, pnodeReal ));

        status = Ds_WriteNodeToDs(
                    pLdapHandle,
                    pnodeReal,
                    DNS_TYPE_ALL,
                    DNSDS_REPLACE,
                    pZone,
                    0 );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR:  rollback DS write failed on node %s %p\n",
                pnodeReal->szLabel,
                pnodeReal ));
            (DWORD) Ds_ErrorHandler ( status, NULL, pLdapHandle );
        }
    }

    return( ERROR_SUCCESS );
}



//
//  Update thread
//

DWORD
Update_Thread(
    IN      LPVOID      Dummy
    )
/*++

Routine Description:

    Thread to execute dynamic updates.

    There are not done in line, for two reasons:

    1) security updates can take a while, so that any reasonably long list
        of updates would block UDP thread cleaning update list for a while

    2) secure updates come in on TCP thread and hence directly block TCP
        thread's capability to function while update is being processed

Arguments:

    Dummy - unused

Return Value:

    Exit code.
    Exit from DNS service terminating or error in wait call.

--*/
{
    PDNS_MSGINFO    pmsg;
    HANDLE          waitHandleArray[3];
    DWORD           err;


    UPDATE_DNS_TIME();

    DNS_DEBUG( INIT, (
        "\nStarting update thread at %d.\n",
        DNS_TIME() ));

    //
    //  initialize array of objects to wait on
    //      - shutdown
    //      - update packet queued

    waitHandleArray[0] = hDnsShutdownEvent;
    waitHandleArray[1] = g_UpdateQueue->hEvent;
    waitHandleArray[2] = g_SecureNegoQueue->hEvent;


    //
    //  loop until service exit
    //
    //  this thread executes whenever an update is queued to it
    //

    while ( TRUE )
    {
        //  Check and possibly wait on service status
        //  doing this at top of loop, so we hold off any processing
        //  until zones are loaded

        if ( ! Thread_ServiceCheck() )
        {
            DNS_DEBUG( SHUTDOWN, ( "Terminating recursion timeout thread.\n" ));
            return( 1 );
        }

        UPDATE_DNS_TIME();

        //
        //  process update packet for if it's zone is unlocked
        //

        while ( pmsg = PQ_DequeueNextPacketOfUnlockedZone( g_UpdateQueue ) )
        {
            processWireUpdateMessage(pmsg);
        }

        //
        //  clean forwarding queue -- if anything in there
        //

        if ( g_UpdateForwardingQueue->cLength )
        {
            PQ_DiscardExpiredQueuedPackets(
                g_UpdateForwardingQueue,
                FALSE       // queue not locked
                );
        }

        //
        //  handle security negotiation
        //
        //  DEVNOTE: need to delete and respond? at all?
        //      if nego packet is more than client timeout old
        //      interesting side issue:  completing pending negotiations
        //      (in stage two) so that the context is available when
        //      client retries
        //

        while ( pmsg = PQ_DequeueNextPacket( g_SecureNegoQueue, FALSE ) )
        {

            Answer_TkeyQuery( pmsg );
        }

        //
        //  if no more updates available -- wait.
        //      - five minute limit to limit forwarding storm filling queue
        //

        err = WaitForMultipleObjects(
                    3,
                    waitHandleArray,
                    FALSE,                  // either event
                    300000                  // five minutes
                    );

        ASSERT( err <= ( WAIT_OBJECT_0 + 2 ) || err == WAIT_TIMEOUT );

        DNS_DEBUG( UPDATE, (
            "Update thread wakeup for %s.\n",
            (err == WAIT_TIMEOUT) ? "timeout" : "event" ));

        //  we immediately check service status before retrying
        //  so no need to separate wait events

    }   //  loop until service shutdown
}




//
//  Update execution subroutines
//

DNS_STATUS
processDsSecureUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Process dynamic update message.

    This is the core routine that locks zone and database, calls parser
    do update (if necessary), logs update, unlocks, sends response.

Arguments:

    pZone       -- zone being updated

    pUpdateList -- parsed update list

Return Value:

    TRUE if update completed.
    FALSE if update requeued.

--*/
{
    DBG_FN( "processDsSecureUpdate" )

    DNS_STATUS      status = ERROR_SUCCESS;
    DNS_STATUS      statusFinal = ERROR_SUCCESS;
    DNS_STATUS      tempStatus;
    HANDLE          hcontext = NULL;
    PLDAP           pldap = NULL;
    //DNS_SECCTXT_KEY key;
    BOOL            fimpersonatingClient = FALSE;
    BOOL            fimpersonatingRpcClient = FALSE;
    PDB_NODE        pnode;
    PDB_NODE        pRealNode, pNode;
    LPSTR           pszFailInfo = NULL;
    PDNS_MSGINFO    pMsg = (PDNS_MSGINFO) pUpdateList->pMsg;


    DNS_DEBUG( UPDATE, ( "Enter processSecureUpdate()\n" ));

    //
    //  DEVNOTE: finally in a position to check for no-ops before security check
    //      i'm not sure this is desirably (our clients in general won't send them,
    //      they'll do precon stuff first -- not sure about Cliff though
    //

    //
    //  reject unsecure packets immediately as optimization
    //      - unless no-ops, in which case just return success, allowing
    //          security stuff to be skipped
    //

    if ( pMsg &&
         pMsg->Head.AdditionalCount == 0 )
    {
        //  shouldn't fall here anymore

        ASSERT( FALSE );

        if ( checkForEmptyUpdate(
                    pUpdateList,
                    pZone ) )
        {
            DNS_DEBUG( UPDATE, (
                "No-op non-secure update %p in secure zone -- returning NOERROR.\n",
                pMsg ));
            return( ERROR_SUCCESS );
        }
        DNS_DEBUG( UPDATE, (
            "Non-secure update %p in secure zone -- returning REFUSED.\n",
            pMsg ));

        UPDATE_STAT_INC( pUpdateList, RefusedNonSecure );
        return( DNS_RCODE_REFUSED );
    }

    //
    //  DEVNOTE: eliminate SKWANSEC hacks
    //
    //  HACK:  setup hack arounds
    //

    if ( SrvCfg_fTest6 )
    {
        SecBigTimeSkew = SrvCfg_fTest6;
    }

    if ( pMsg )
    {
        //
        // We have a message to process:
        // wire processing
        //
        ASSERT( pUpdateList->Flag & DNSUPDATE_PACKET );

        //
        //  read TSIG, match to security context and verify sig
        //
        //  if fails and TSIG exists, set appropriate extended RCODE
        //

        status = Dns_FindSecurityContextFromAndVerifySignature(
                    & hcontext,
                    pMsg->RemoteAddress.sin_addr.s_addr,
                    DNS_HEADER_PTR(pMsg),
                    DNSMSG_END(pMsg) );

        if ( status != ERROR_SUCCESS )
        {
            pszFailInfo = "Security context verification";
            goto Failed;
        }
    }

    //
    //  detect, respond to empty updates
    //      - do this now so can avoid security processing
    //
    //  note, could argue to do security check first, to handle REFUSED case
    //  however since we can generate just as much activity with query, there
    //  doesn't seem to be any real denial of service hole that is opened up here
    //  folks simply learn the current state of various names, which they can
    //  learn more easily through query
    //
    //  note: now doing this after security check AS must SIGN the response to
    //      give full security to clients -- client knows update successful
    //

    //
    //  note, we now handle non-secure packets to secure zone that no-op
    //  as success (no security hole there -- think about it)
    //  so this already screens out folks who do NOT NEED mutual auth, and
    //      are no-oping the update
    //  so if we worked around security for no-ops now, that would simply bypass
    //      mutual auth for folks who presumably wanted it
    //
    //  DEVNOTE: we take AdditionaCount==0 to be non-secure, so the one caveat
    //      is that folks who put something in Additional section will not get
    //      this work around above
    //


    //  note, should log-to-stats (empty or duplicate)


    if ( checkForEmptyUpdate(
                pUpdateList,
                pZone
                ) )
    {
        DNS_DEBUG( UPDATE, (
            "No-op secure update %p, sent directly to signing.\n",
            pMsg ));

        // if wire processing sign & send response

        if ( pMsg )
        {
            goto Sign;
        }
        ASSERT( status == ERROR_SUCCESS );
        goto Failed;
    }

    //
    //  build update
    //      1) build temporary node\RR copies of target of updates
    //      2) execute update on these temporary nodes
    //

    status = prepareUpdateListForExecution( pZone, pUpdateList );
    if ( status != ERROR_SUCCESS )
    {
        pszFailInfo = "DS update initialization";
        statusFinal = DNS_ERROR_RCODE_SERVER_FAILURE;
        goto Failed;
    }

    status = Up_ApplyUpdatesToDatabase(
                pUpdateList,
                pZone,
                pUpdateList->Flag | DNSUPDATE_SECURE_PACKET );
    if ( status != ERROR_SUCCESS )
    {
        pszFailInfo = "Update in-memory execution";
        goto Failed;
    }

    //
    //  determine if DS write is necessary
    //      - update changed RRs
    //      OR
    //      - some RRs need refresh
    //
    //  skip impersonation and write, drop to sign response
    //

    if ( ! checkTempNodesForUpdateEffect(
                pZone,
                pUpdateList ) )
    {
        //  DEVNOTE: separate these to update stats

        STAT_INC( DsStats.UpdateLists );
        STAT_INC( DsStats.UpdateNodes );
        STAT_INC( DsStats.UpdateSuppressed );
        STAT_INC( DsStats.DsWriteSuppressed );
        goto Sign;
    }

    //
    //  dynamic update -- impersonate client
    //

    if ( pMsg )
    {
        ASSERT ( pUpdateList->Flag & DNSUPDATE_PACKET );

        status = Dns_SrvImpersonateClient( hcontext );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT(( "FAILURE: can't impersonate client \n" ));
            ASSERT( FALSE );
            statusFinal = DNS_ERROR_RCODE_SERVER_FAILURE;
            pszFailInfo = "Impersonating incoming client";
            goto Failed;
        }

        #if DBG
        {
            PSID                    pSid = NULL;
            HANDLE                  hToken = NULL;

            if ( OpenThreadToken(
                    GetCurrentThread(),
                    TOKEN_QUERY,
                    TRUE,
                    &hToken ) )
            {
                if ( Dbg_GetUserSidForToken( hToken, &pSid ) )
                {
                    DNS_DEBUG( UPDATE, (
                        "%s: impersonating: %S\n", fn,
                        Dbg_DumpSid( pSid ) ));
                    Dbg_FreeUserSid( &pSid );
                }
                else
                {
                    DNS_DEBUG( UPDATE, (
                        "%s: GetUserSidForToken failed\n", fn ));
                }
                CloseHandle( hToken );
            }
            else
            {
                DNS_DEBUG( RPC, (
                    "%s: error %d opening thread token (debug only!)\n", fn,
                     GetLastError() ));
            }
        }
        #endif

        fimpersonatingClient = TRUE;
    }

    //
    //  RPC update -- impersonate client
    //

    else if ( pUpdateList->Flag & DNSUPDATE_ADMIN )
    {
        fimpersonatingRpcClient = RpcUtil_SwitchSecurityContext( RPC_CLIENT_CONTEXT );
        ASSERT( fimpersonatingRpcClient );
    }

    ELSE_ASSERT( pUpdateList->Flag & DNSUPDATE_LOCAL_SYSTEM );

    //
    //  open LDAP in impersonated context
    //

    ASSERT ( !(fimpersonatingClient && fimpersonatingRpcClient) );

    if ( fimpersonatingClient || fimpersonatingRpcClient )
    {
        status = Ds_OpenServerForSecureUpdate( &pldap );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT(( "FAILURE: can't open DS server \n" ));
            statusFinal = DNS_ERROR_RCODE_SERVER_FAILURE;
            pszFailInfo = "Contacting DS";
            goto Failed;
        }
        ASSERT( pldap );
    }

    //
    //  attempt to execute update in DS
    //      => if succeeds security check successful
    //      => if fails we roll back DS update by rewriting REAL nodes to DS
    //
    //      -- note if exactly matches what is already in DS, then
    //      then we'll suppress write
    //
    //  If successful, caller will execute updates in memory exactly as in
    //  non-secure case;  only difference is final write to DS is skipped
    //
    //  DEVNOTE: map DS errors into RCODE REFUSED or SERVER_FAILURE
    //

    status = Ds_WriteUpdateToDs(
                pldap,
                pUpdateList,
                pZone );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( UPDATE, (
            "SECURE UPDATE failed on DS write:  status = %p %d\n",
            status, status ));

        //  roll back any-nodes already written

        rollBackFailedUpdateFromDs(
            pldap,
            pUpdateList,
            pZone );

        statusFinal = DNS_ERROR_RCODE_REFUSED;
        UPDATE_STAT_INC( pUpdateList, RefusedAccessDenied );
        UPDATE_STAT_INC( pUpdateList, SecureDsWriteFailure );
        pszFailInfo = "Write to the DS";
        goto Failed;
    }


Sign:

    //
    //  sign the response packet
    //      - since signing, set response bit now
    //
    //  DEVNOTE: need failed signing
    //      when fail but can sign
    //

    if ( pMsg )
    {
        ASSERT( pMsg );
        ASSERT( pUpdateList->Flag & DNSUPDATE_PACKET );

        pMsg->fDelete = TRUE;
        pMsg->Head.IsResponse = TRUE;

        status = Dns_SignMessageWithGssTsig(
                        hcontext,
                        DNS_HEADER_PTR(pMsg),
                        pMsg->pBufferEnd,
                        & pMsg->pCurrent
                        );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT(( "FAILURE: createResponseToSecureUpdate failed.\n" ));
            statusFinal = DNS_ERROR_RCODE_SERVER_FAILURE;
            pszFailInfo = "Signing return message";
            goto Failed;
        }
        DNS_DEBUG( UPDATE2, (
            "Prepared successful secure-update response:\n" ));
    }

    //  drop to cleanup

Failed:

    //
    //  DEVNOTE: we have NEVER address issue of signed REFUSAL
    //      in those cases where able to authenticate, but get ACL
    //      failure writing to DS (or some SERVER_FAILURE) we should
    //      we able to give signed failure response
    //

    if ( pldap )
    {
        Ds_CloseServerAfterSecureUpdate( pldap );
    }

    if ( fimpersonatingClient )
    {
        Dns_SrvRevertToSelf( hcontext );
    }
    else if ( fimpersonatingRpcClient )
    {
        RpcUtil_SwitchSecurityContext( RPC_SERVER_CONTEXT );
    }

    //
    //  return security context to queue
    //

    if ( hcontext )
    {
        Dns_CleanupSessionAndEnlistContext( hcontext );
    }

    //
    //  logging
    //      - log actual status failure
    //      - but return packet friendly status
    //

    if ( status == ERROR_SUCCESS )
    {
        UPDATE_STAT_INC( pUpdateList, SecureSuccess );
        PERF_INC( pcSecureUpdateReceived );      // PerfMon hook
    }
    else
    {
        if ( status == ERROR_ACCESS_DENIED )
        {
            statusFinal = DNS_RCODE_REFUSED;
        }
        else if ( statusFinal == ERROR_SUCCESS )
        {
            statusFinal = status;
        }

        UPDATE_STAT_INC( pUpdateList, SecureFailure );
        PERF_INC( pcSecureUpdateFailure );       // PerfMon hook
        PERF_INC( pcSecureUpdateReceived );      // PerfMon hook

        Log_LeveledPrintf(
            DNS_LOG_LEVEL_DS_UPDATE,
            "Update Error <%lu>: %s\r\n",
            status,
            pszFailInfo ? pszFailInfo : "<none>" );
    }

    return( statusFinal );
}



DNS_STATUS
processDsUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Process dynamic update message.

    This is the core routine that locks zone and database, calls parser
    do update (if necessary), logs update, unlocks, sends response.

Arguments:

    pZone       -- zone being updated

    pUpdateList -- parsed update list

Return Value:

    TRUE if update completed.
    FALSE if update requeued.

--*/
{
    DNS_STATUS      status;
    DNS_STATUS      statusFinal = ERROR_SUCCESS;
    PLDAP           pldap = NULL;
    PDB_NODE        pnode;
    LPSTR           pszFailInfo = NULL;


    DNS_DEBUG( UPDATE, ( "Enter processDsUpdate()\n" ));

    //
    //  detect, respond to empty updates
    //
    //  note, should log-to-stats (empty or duplicate)
    //

    if ( checkForEmptyUpdate(
                pUpdateList,
                pZone
                ) )
    {
        return( ERROR_SUCCESS );
    }

    //
    //  build update
    //      0) bring nodes into sync with DS
    //      1) build temporary node\RR copies of target of updates
    //      2) execute update on these temporary nodes
    //

    status = prepareUpdateListForExecution( pZone, pUpdateList );
    if ( status != ERROR_SUCCESS )
    {
        ASSERT( status == ERROR_INVALID_DATA );
        pszFailInfo = "DS update initialization";
        goto Failed;
    }

    status = Up_ApplyUpdatesToDatabase(
                pUpdateList,
                pZone,
                pUpdateList->Flag
                );
    if ( status != ERROR_SUCCESS )
    {
        pszFailInfo = "Executing update";
        goto Failed;
    }

    //
    //  determine if DS write is necessary
    //      - update changed RRs
    //      OR
    //      - some RRs need refresh
    //

    if ( ! checkTempNodesForUpdateEffect(
                pZone,
                pUpdateList ) )
    {
        //  update is no-op

        //  DEVNOTE: separate these to update stats

        STAT_INC( DsStats.UpdateLists );
        STAT_INC( DsStats.UpdateNodes );
        STAT_INC( DsStats.UpdateSuppressed );
        STAT_INC( DsStats.DsWriteSuppressed );
        goto Failed;
    }

    //
    //  screen out dynamic updates to secure zones
    //
    //  we've allowed dynamic updates to secure zones to go down this
    //  path for performance reasons -- aging means precon updates are
    //  also generated which must be checked;  now if we must WRITE
    //  to database need to REFUSE and cause security negotiation
    //

#if 0
    if ( pZone->fAllowUpdate == ZONE_UPDATE_SECURE &&
        (pUpdateList->Flag & DNSUPDATE_NONSECURE_PACKET) &&
        !(pUpdateList->Flag & DNSUPDATE_LOCAL_SYSTEM) )
#else
    if ( pZone->fAllowUpdate == ZONE_UPDATE_SECURE &&
        (pUpdateList->Flag & DNSUPDATE_NONSECURE_PACKET) )
#endif
    {
        DNS_DEBUG( UPDATE, (
            "Non-secure update packet %p in secure zone -- returning REFUSED\n"
            "\tzone update = %d, update flags = 0x%08X\n",
            pUpdateList->pMsg,
            pZone->fAllowUpdate,
            pUpdateList->Flag ));

        UPDATE_STAT_INC( pUpdateList, RefusedNonSecure );
        return( DNS_RCODE_REFUSED );
    }

    //
    //  attempt to execute update in DS
    //      => if succeeds done
    //      => if fails we roll back DS update by rewriting REAL nodes to DS
    //
    //  -- note if exactly matches what is already in DS, then
    //      then we'll suppress write
    //
    //  If successful, caller will execute updates in memory but
    //  DS write is skipped.
    //

    status = Ds_WriteNonSecureUpdateToDs(
                NULL,
                pUpdateList,
                pZone );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( ANY, (
            "DS UPDATE failed on DS write:  status = %p %d\n",
            status, status ));

        //  DNS server should never fail because of security constraint

        ASSERT( status != LDAP_INSUFFICIENT_RIGHTS );

        //  roll back any-nodes already written

        rollBackFailedUpdateFromDs(
            NULL,
            pUpdateList,
            pZone );

        pszFailInfo = "Applying update to the DS";
        statusFinal = DNS_ERROR_RCODE_SERVER_FAILURE;
        UPDATE_STAT_INC( pUpdateList, DsWriteFailure );
        goto Failed;
    }

    DNS_DEBUG( UPDATE2, (
            "Prepared successful DS-update response.\n" ));

    UPDATE_STAT_INC( pUpdateList, DsSuccess );

    //  drop to cleanup

Failed:

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( UPDATE, (
            "Error <%lu>: processDsUpdateMessage failed\n" ,
            status ));

        Log_LeveledPrintf(
            DNS_LOG_LEVEL_DS_UPDATE,
            "Update Error <%lu>: %s\r\n",
            status,
            pszFailInfo ? pszFailInfo : "<none>" );

        if ( statusFinal == ERROR_SUCCESS )
        {
            statusFinal = status;
        }
    }

    return( statusFinal );
}



DNS_STATUS
processNonDsUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Process dynamic update message.

    This is the core routine that locks zone and database, calls parser
    do update (if necessary), logs update, unlocks, sends response.

Arguments:

    pZone       -- zone being updated

    pUpdateList -- parsed update list

Return Value:

    TRUE if update completed.
    FALSE if update requeued.

--*/
{
    DNS_STATUS      status;
    PDB_NODE        pnode;
    LPSTR           pszFailInfo = NULL;


    DNS_DEBUG( UPDATE, ( "Enter processNonDsUpdate()\n" ));

    //
    //  detect, respond to empty updates
    //
    //  note, should log-to-stats (empty or duplicate)
    //

    if ( checkForEmptyUpdate(
                pUpdateList,
                pZone
                ) )
    {
        return( ERROR_SUCCESS );
    }

    //
    //  build update
    //      0) bring nodes into sync with DS
    //      1) build temporary node\RR copies of target of updates
    //      2) execute update on these temporary nodes
    //

    status = prepareUpdateListForExecution( pZone, pUpdateList );
    if ( status != ERROR_SUCCESS )
    {
        pszFailInfo = "update initialization";
        goto Failed;
    }

    status = Up_ApplyUpdatesToDatabase(
                pUpdateList,
                pZone,
                0
                );
    if ( status != ERROR_SUCCESS )
    {
        pszFailInfo = "Executing update";
        goto Failed;
    }

    DNS_DEBUG( UPDATE, (
        "Successful non-DS update.\n" ));

    status = ERROR_SUCCESS;

    //  drop to cleanup

Failed:

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( UPDATE, (
            "Error <%lu>: processNonDsUpdateMessage failed\n" ,
            status ));

        Log_LeveledPrintf(
            DNS_LOG_LEVEL_DS_UPDATE,
            "Update Error <%lu>: %s\r\n",
            status,
            pszFailInfo ? pszFailInfo : "<none>" );
    }

    return( status );
}



BOOL
checkTempNodesForUpdateEffect(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Check temp nodes for effect of update.

    This involves determining whether update has changed the nodes
    RR list.  Whether or not DS write is necessary is based on this.

Arguments:

    pZone - zone to update

    pUpdateList - list with update

Return Value:

    TRUE if need write to DS.
    FALSE if no write required.

--*/
{
    PDB_NODE        pnodeReal;
    PDB_NODE        pnodeTemp;
    BOOL            fneedUpdate = FALSE;
    BOOL            fneedWrite = FALSE;

    DNS_DEBUG( UPDATE, (
        "checkTempNodesForUpdateEff