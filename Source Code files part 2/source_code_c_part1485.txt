AME;

	HRESULT hr = S_OK;
	//find the dispid of local time on the element
	hr = m_pdispElement->GetIDsOfNames( IID_NULL,
										&name,
										1,
										LCID_SCRIPTING,
										&m_dispidLocalTime
									   );

	if( FAILED( hr ) )
	{
		m_dispidLocalTime = -1;
	}

	return S_OK;
}


//*****************************************************************************
//private methods
//*****************************************************************************


HRESULT
CElementPropertyMonitor::ProcessLocalTimeChange( )
{
	if( m_pdispElement == NULL || m_pLocalTimeListener == NULL )
	{
		return S_OK;
	}

	HRESULT hr = S_OK;

	DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
	VARIANT varResult;

	::VariantInit( &varResult );


	//get the value of local time from the element

	hr = m_pdispElement->Invoke( m_dispidLocalTime, 
								 IID_NULL, 
								 LCID_SCRIPTING, 
								 DISPATCH_PROPERTYGET, 
								 &dispparamsNoArgs, 
								 &varResult, 
								 NULL, 
								 NULL );
	CheckHR( hr, "Failed to invoke the local time dispatch on the element", end );
	
	if( V_VT( &varResult ) != VT_R4 )
	{
		hr = ::VariantChangeTypeEx( &varResult, &varResult, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R4 );
		CheckHR( hr, "Failed to change the type of local time to a double", end );
	}


	//call onLocalTimeChange on the listener
	m_pLocalTimeListener->OnLocalTimeChange( V_R4( &varResult ) );

end:
	::VariantClear( &varResult );

	return hr;
}

//*****************************************************************************

HRESULT
CElementPropertyMonitor::AttachToElementConPt()
{
    if( m_pelemElement == NULL )
        return E_FAIL;

    HRESULT hr = S_OK;

    IConnectionPointContainer   *pContainer = NULL;

    hr = m_pelemElement->QueryInterface( IID_TO_PPV( IConnectionPointContainer, &pContainer ) );
    CheckHR( hr, "QI for IConnectionPointContainer on IHTMLElement Failed", end );

    hr= pContainer->FindConnectionPoint( IID_IPropertyNotifySink, &m_pconptElement );
    CheckHR( hr, "Failed to find the connection point for element envents", end );

    hr = m_pconptElement->Advise( static_cast<IUnknown *>(this), &m_dwElementPropertyConPtCookie );
    CheckHR( hr, "Failed to connect to the element connection point", end );

end:
    ReleaseInterface( pContainer );

    return hr;

}

//*****************************************************************************

HRESULT
CElementPropertyMonitor::DetachFromElementConPt( )
{
    if( m_pconptElement == NULL || m_dwElementPropertyConPtCookie == 0 )
        return E_FAIL;

    HRESULT hr = S_OK;

    hr = m_pconptElement->Unadvise( m_dwElementPropertyConPtCookie );
    CheckHR( hr, "Failed to unadvise the connection point", end );

    ReleaseInterface( m_pconptElement );

end:

    return hr;
}

//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\eventsink.cpp ===
///////////////////////////////////////////////////////////////
// Copyright (c) 1998 Microsoft Corporation
//
// File: EventSink.cpp
//
// Abstract:  
//
///////////////////////////////////////////////////////////////


#include "headers.h"
#include "eventmgr.h"
#include "mshtmdid.h"
#include "eventsink.h"
#include "basebvr.h"

#define THR(_arg) _arg

struct {
    ELEMENT_EVENT event;
    wchar_t * wsz_name;
} g_ElementEventNames[] =
{
    { EE_ONPROPCHANGE,         L"onpropertychange" },
    //add non-input related events to hook here
    { EE_ONREADYSTATECHANGE,   L"onreadystatechange" },
    { EE_ONMOUSEMOVE,          L"onmousemove" },
    { EE_ONMOUSEDOWN,          L"onmousedown" },
    { EE_ONMOUSEUP,            L"onmouseup" },
    { EE_ONKEYDOWN,            L"onkeydown" }, 
    { EE_ONKEYUP,              L"onkeyup" },
    { EE_ONBLUR,               L"onblur" }
    //add input events here
};

///////////////////////////////////////////////////////////////
//  Name: CEventSink
//  Parameters:
//    CTIMEElement  & elm
//                               This parameter must be passed
//                               to the constructor so that 
//                               we can get info from elm
//    CEventMgr *    pEventMgr
//                               This parameter is passed so 
//                               the eventsync can notify then
//                               parent EventMgr when events
//                               have occured.
//  Abstract:
//    Stash away the element so we can get the OM when we need it
///////////////////////////////////////////////////////////////
CEventSink::CEventSink(IEventManagerClient* client, CEventMgr *pEventMgr)
: m_client(client),
  m_pElement(NULL),
  m_refCount(0),
  m_pEventMgr(NULL)
{
    m_pEventMgr = pEventMgr;
}

///////////////////////////////////////////////////////////////
//  Name: ~CEventSink
//
//  Abstract:
//    Cleanup
///////////////////////////////////////////////////////////////
CEventSink::~CEventSink()
{


}


///////////////////////////////////////////////////////////////
//  Name:  Init
//  Parameters:  None
//
//  Abstract:
//    Initializes the object
///////////////////////////////////////////////////////////////
HRESULT CEventSink::Init()
{
    HRESULT hr = S_OK;

    //m_pElement = m_bvr.GetElement();
	m_pElement = m_client->GetElementToSink();
	if( m_pElement != NULL )
	{
		m_pElement->AddRef();
    
		hr = THR(AttachEvents());
		if (FAILED(hr))
		{
			goto done;
		}
	}

  done:
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name:  Init
//  Parameters:  None
//
//  Abstract:
//    Attaches to mouse and keyboard events
///////////////////////////////////////////////////////////////
HRESULT CEventSink::InitMouse()
{
    CComPtr <IHTMLElement2> pElement2;
    HRESULT hr = S_OK;
    VARIANT_BOOL bSuccess;
    int i = 0;

    if (!m_pElement)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_pElement->QueryInterface(IID_IHTMLElement2, (void**)&pElement2));
    if (FAILED(hr))
    {
        goto done;
    }

    //attach to mouse events
	//TODO: This should ask the behavior if it wants to handle mouse events
	// TODO: register for mouse events only if we have some listeners
    if (true)
    {
        for (i = EE_ONREADYSTATECHANGE + 1; i < EE_MAX; i++)
        {
            hr = THR(pElement2->attachEvent(g_ElementEventNames[i].wsz_name, (IDispatch *)this, &bSuccess)) ;
            if (FAILED(hr))
            {
                goto done;
            }
        }   
    }
    
  done:
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name:  Deinit
//  Parameters:  None
//
//  Abstract:
//    Cleans up the object
///////////////////////////////////////////////////////////////
HRESULT CEventSink::Deinit()
{
    HRESULT hr = S_OK;

    hr = THR(DetachEvents());

    if (m_pElement)
    {
        m_pElement->Release();
        m_pElement = NULL;
    }

    if (m_dwElementEventConPtCookie != 0 && m_pElementConPt)
    {
        m_pElementConPt->Unadvise(m_dwElementEventConPtCookie);
    }

    return hr;
}


///////////////////////////////////////////////////////////////
//  Name: AddRef
// 
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CEventSink::AddRef(void)
{
    return ++m_refCount;
}

///////////////////////////////////////////////////////////////
//  Name: Release
// 
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CEventSink::Release(void)
{
    m_refCount--;
    if (m_refCount == 0)
    {
        //delete this;
    }

    return m_refCount;
}



///////////////////////////////////////////////////////////////
//  Name: GetTypeInfoCount
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventSink::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: GetTypeInfo
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventSink::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
                                   /* [in] */ LCID /*lcid*/,
                                   /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: GetIDsOfNames
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventSink::GetIDsOfNames(
    /* [in] */ REFIID /*riid*/,
    /* [size_is][in] */ LPOLESTR* /*rgszNames*/,
    /* [in] */ UINT /*cNames*/,
    /* [in] */ LCID /*lcid*/,
    /* [size_is][out] */ DISPID* /*rgDispId*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: Invoke
// 
//  Abstract:
//     dispIdMember is always 0 so this Invoke switches on the
//     name of the event that causes the callback.
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventSink::Invoke(
    /* [in] */ DISPID dispIdMember,
    /* [in] */ REFIID /*riid*/,
    /* [in] */ LCID /*lcid*/,
    /* [in] */ WORD /*wFlags*/,
    /* [out][in] */ DISPPARAMS* pDispParams,
    /* [out] */ VARIANT* pvarResult,
    /* [out] */ EXCEPINFO* /*pExcepInfo*/,
    /* [out] */ UINT* puArgErr)
{
    // Listen for the two events we're interested in, and call back if necessary
    HRESULT hr = S_OK;
    CComPtr <IHTMLEventObj> pEventObj;
    BSTR bstrEventName;

    //get the event object from the IDispatch passed in
    hr = THR((pDispParams->rgvarg[0].pdispVal)->QueryInterface(IID_IHTMLEventObj, (void**)&pEventObj));
    if (FAILED(hr))
    {
        goto done;
    }
    
    //get the event name
    hr = THR(pEventObj->get_type(&bstrEventName));
    if (FAILED(hr))
    {
        goto done;
    }

    //handle the MouseMove event
    if (_wcsicmp (bstrEventName, g_ElementEventNames[EE_ONMOUSEMOVE].wsz_name + 2) == 0)
    {
        NotifyMouseMove(pEventObj);
    }
    //handle the MouseDown event
    else if (_wcsicmp (bstrEventName, g_ElementEventNames[EE_ONMOUSEDOWN].wsz_name + 2) == 0)
    {
        NotifyMouseDown(pEventObj);
    }
    //handle the MouseUp event
    else if (_wcsicmp (bstrEventName, g_ElementEventNames[EE_ONMOUSEUP].wsz_name + 2) == 0)
    {
        NotifyMouseUp(pEventObj);
    }
    //handle the KeyDown event
    else if (_wcsicmp (bstrEventName, g_ElementEventNames[EE_ONKEYDOWN].wsz_name + 2) == 0)
    {
        NotifyKeyDown(pEventObj);
    }
    //handle the KeyUp event
    else if (_wcsicmp (bstrEventName, g_ElementEventNames[EE_ONKEYUP].wsz_name + 2) == 0)
    {
        NotifyKeyUp(pEventObj);
    }
    //handle the Blur event
    else if (_wcsicmp (bstrEventName, g_ElementEventNames[EE_ONBLUR].wsz_name + 2) == 0)
    {
        m_pEventMgr->KeyEvent(TRUE, TRUE, FALSE, FALSE, FALSE, 0, 0);
    }
    //handle the PropertyChange event
    else if (_wcsicmp(bstrEventName, g_ElementEventNames[EE_ONPROPCHANGE].wsz_name + 2) == 0)
    {
        NotifyPropertyChange(pEventObj);
    }
    //handle the OnReadyStateChange event
    else if (_wcsicmp(bstrEventName, g_ElementEventNames[EE_ONREADYSTATECHANGE].wsz_name + 2) == 0)
    {
        NotifyReadyState(pEventObj);
    }
    
    //return TRUE
    VARIANT vReturnVal;
    VariantInit(&vReturnVal);
    vReturnVal.vt = VT_BOOL;
    vReturnVal.boolVal = VARIANT_TRUE;
    pEventObj->put_returnValue(vReturnVal);
	
    SysFreeString(bstrEventName);

  done:
    return S_OK;
}

///////////////////////////////////////////////////////////////
//  Name: QueryInterface
// 
//  Abstract:
//    This QI only handles the IDispatch for HTMLElementEvents
//    and returns this as the interface.
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventSink::QueryInterface( REFIID riid, void **ppv )
{
    if (NULL == ppv)
        return E_POINTER;

    *ppv = NULL;

    if ( InlineIsEqualGUID(riid, IID_IDispatch))
    {
        *ppv = this;
    }
        
    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;
}


///////////////////////////////////////////////////////////////
//  Name: AttachEvents
// 
//  Abstract:
//    Hooks all the trident events that we are interested in.
//    automatically hooks non-mouse events.  Only hooks the mouse
//    events if they are relevant to the behavior.
///////////////////////////////////////////////////////////////
HRESULT CEventSink::AttachEvents()
{
    CComPtr <IHTMLElement2> pElement2;
    HRESULT hr = S_OK;
    VARIANT_BOOL bSuccess;
    int i = 0;

    if (!m_pElement)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_pElement->QueryInterface(IID_IHTMLElement2, (void**)&pElement2));
    if (FAILED(hr))
    {
        goto done;
    }

    //register for events that all sync's need.
    for (i = 0; i <= EE_ONREADYSTATECHANGE; i++)
    {
        hr = THR(pElement2->attachEvent(g_ElementEventNames[i].wsz_name, (IDispatch *)this, &bSuccess)) ;
        if (FAILED(hr))
        {
            goto done;
        }
    }

  done:
    return hr;  
}


///////////////////////////////////////////////////////////////
//  Name: DetachEvents
// 
//  Abstract:
//    Detaches from all events to allow clean shutdown.
///////////////////////////////////////////////////////////////
HRESULT CEventSink::DetachEvents()
{
    CComPtr <IHTMLElement2> pElement2;
    HRESULT hr = S_OK;
    int i = 0;

    if (!m_pElement)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_pElement->QueryInterface(IID_IHTMLElement2, (void**)&pElement2));
    if (FAILED(hr))
    {
        goto done;
    }

    
    //detach from events that all sync's need.
    for (i = 0; i <= EE_ONREADYSTATECHANGE; i++)
    {
        //attach to the onreadystatechangeevent
        hr = THR(pElement2->detachEvent(g_ElementEventNames[i].wsz_name, (IDispatch *)this)) ;
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    //detach from mouse events
	//TODO: should ask the behavior if it wants mouse events here.
	//TODO: detach only if we attached
    if (true)
    {
        for (i = EE_ONREADYSTATECHANGE + 1; i < EE_MAX; i++)
        {
            //attach to the onreadystatechangeevent
            hr = THR(pElement2->detachEvent(g_ElementEventNames[i].wsz_name, (IDispatch *)this));
            if (FAILED(hr))
            {
                goto done;
            }
        }   
    }

  done:
    return hr;  
}


///////////////////////////////////////////////////////////////
//  Name: NotifyReadyState
// 
//  Parameters
//    IHTMLEventObj *pEventObj    A pointer to the event object
//                                that was passed to IDispatch::Invoke.
//
//  Abstract:
//    Determines the ready state that caused the ReadyStateChange
//    event and calls the EventManager to handle the new ready
//    state.
///////////////////////////////////////////////////////////////
HRESULT CEventSink::NotifyReadyState(IHTMLEventObj *pEventObj)
{
    HRESULT hr = S_OK;
    CComPtr <IHTMLElement> pElement;
    CComPtr <IHTMLElement2> pElement2;
    CComPtr <IHTMLEventObj2> pEventObj2;
    VARIANT vReadyState;
    
    hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void **)&pEventObj2));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pEventObj2->get_srcElement(&pElement));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pElement->QueryInterface(IID_IHTMLElement2, (void **)&pElement2));
    if (FAILED(hr))
    {
        goto done;
    }
    
    VariantInit(&vReadyState);
    hr = THR(pElement2->get_readyState(&vReadyState));
    if (FAILED(hr))
    {
        goto done;
    }

    //if this is not a valid ready state, get the parent element's readystate.
    if (vReadyState.vt != VT_BSTR)
    {
        CComPtr <IHTMLElement> pParentEle;
        CComPtr <IHTMLElement2> pParentEle2;

        hr = THR(pElement->get_parentElement(&pParentEle));
        if (FAILED (hr))
        {
            goto done;
        }

        hr = THR(pParentEle->QueryInterface(IID_IHTMLElement2, (void **)&pParentEle2));
        if (FAILED (hr))
        {
            goto done;
        }

        VariantClear(&vReadyState);
        hr = THR(pParentEle2->get_readyState(&vReadyState));
        if (FAILED(hr))
        {
            goto done;
        }

    }
    m_pEventMgr->ReadyStateChange(vReadyState.bstrVal);
    VariantClear(&vReadyState);

  done:
    return hr;
}



///////////////////////////////////////////////////////////////
//  Name: NotifyPropertyChange
// 
//  Parameters
//    IHTMLEventObj *pEventObj    A pointer to the event object
//                                that was passed to IDispatch::Invoke.
//
//  Abstract:
//    Determines the ready state that caused the PropertyChange
//    event and calls the EventManager to handle the property
//    change.
///////////////////////////////////////////////////////////////
HRESULT CEventSink::NotifyPropertyChange(IHTMLEventObj *pEventObj)
{
    HRESULT hr = S_OK;

    CComPtr <IHTMLEventObj2> pEventObj2;
    CComPtr <IHTMLElement> pElement;
    BSTR bstrPropertyName;

    hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void **)&pEventObj2));
    if (FAILED(hr))
    {
        goto done;
    }
    
    //get the property name
    hr = THR(pEventObj2->get_propertyName(&bstrPropertyName));
    if (FAILED(hr))
    {
        goto done;
    }

    m_pEventMgr->PropertyChange(bstrPropertyName);
    SysFreeString(bstrPropertyName);
  
  done:
    return hr;

}


///////////////////////////////////////////////////////////////
//  Name: NotifyMouseMove
// 
//  Abstract:
//    This functions gets all the relevent information 
//    about a mouse move event from the event object
//    and notifies the event manager ofthe event.  
///////////////////////////////////////////////////////////////
HRESULT CEventSink::NotifyMouseMove(IHTMLEventObj *pEventObj)
{
    long x;
    long y;
    VARIANT_BOOL bShiftKeyPressed;
    VARIANT_BOOL bAltKeyPressed;
    VARIANT_BOOL bCtrlKeyPressed;
    long lButton;
    HRESULT hr = S_OK;

    hr = THR(pEventObj->get_clientX(&x));
    hr = THR(pEventObj->get_clientY(&y));
    hr = THR(pEventObj->get_shiftKey(&bShiftKeyPressed));
    hr = THR(pEventObj->get_altKey(&bAltKeyPressed));
    hr = THR(pEventObj->get_ctrlKey(&bCtrlKeyPressed));
    hr = THR(pEventObj->get_button(&lButton));

    m_pEventMgr->MouseEvent(x, 
                            y, 
                            TRUE,
                            FALSE,
                            bShiftKeyPressed, 
                            bAltKeyPressed, 
                            bCtrlKeyPressed,
                            lButton);

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: NotifyMouseUp
// 
//  Abstract:
//    This functions gets all the relevent information 
//    about a mouse up event from the event object
//    and notifies the event manager ofthe event.
///////////////////////////////////////////////////////////////
HRESULT CEventSink::NotifyMouseUp(IHTMLEventObj *pEventObj)
{
    
    long x;
    long y;
    VARIANT_BOOL bShiftKeyPressed;
    VARIANT_BOOL bAltKeyPressed;
    VARIANT_BOOL bCtrlKeyPressed;
    long Button;
    HRESULT hr = S_OK;

    hr = THR(pEventObj->get_clientX(&x));
    hr = THR(pEventObj->get_clientY(&y));
    hr = THR(pEventObj->get_shiftKey(&bShiftKeyPressed));
    hr = THR(pEventObj->get_altKey(&bAltKeyPressed));
    hr = THR(pEventObj->get_ctrlKey(&bCtrlKeyPressed));
    hr = THR(pEventObj->get_button(&Button));
    
    m_pEventMgr->MouseEvent(x, 
                            y, 
                            FALSE,
                            TRUE,
                            bShiftKeyPressed, 
                            bAltKeyPressed, 
                            bCtrlKeyPressed,
                            Button);

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: NotifyMouseDown
// 
//  Abstract:
//    This functions gets all the relevent information 
//    about a mouse down event from the event object
//    and notifies the event manager ofthe event.
///////////////////////////////////////////////////////////////
HRESULT CEventSink::NotifyMouseDown(IHTMLEventObj *pEventObj)
{
    
    long x;
    long y;
    VARIANT_BOOL bShiftKeyPressed;
    VARIANT_BOOL bAltKeyPressed;
    VARIANT_BOOL bCtrlKeyPressed;
    long Button;
    HRESULT hr = S_OK;

    hr = THR(pEventObj->get_clientX(&x));
    hr = THR(pEventObj->get_clientY(&y));
    hr = THR(pEventObj->get_shiftKey(&bShiftKeyPressed));
    hr = THR(pEventObj->get_altKey(&bAltKeyPressed));
    hr = THR(pEventObj->get_ctrlKey(&bCtrlKeyPressed));
    hr = THR(pEventObj->get_button(&Button));

    m_pEventMgr->MouseEvent(x, 
                            y, 
                            FALSE,
                            FALSE,
                            bShiftKeyPressed, 
                            bAltKeyPressed, 
                            bCtrlKeyPressed,
                            Button);

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: NotifyKeyDown
// 
//  Abstract:
//    This functions gets all the relevent information 
//    about a key down event from the event object
//    and notifies the event manager ofthe event.
///////////////////////////////////////////////////////////////
HRESULT CEventSink::NotifyKeyDown(IHTMLEventObj *pEventObj)
{
    CComPtr <IHTMLEventObj2> pEventObj2;
    VARIANT_BOOL bShiftKeyPressed;
    VARIANT_BOOL bAltKeyPressed;
    VARIANT_BOOL bCtrlKeyPressed;
    long KeyCode;
    long RepeatCount = 0;
    HRESULT hr = S_OK;

    hr = THR(pEventObj->get_shiftKey(&bShiftKeyPressed));
    hr = THR(pEventObj->get_altKey(&bAltKeyPressed));
    hr = THR(pEventObj->get_ctrlKey(&bCtrlKeyPressed));
    hr = THR(pEventObj->get_keyCode(&KeyCode));
    
    //determine if this is a repeat keypress.
    hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void **)&pEventObj2));
    if (SUCCEEDED(hr))
    {
        VARIANT_BOOL bRepeat;
        hr = THR(pEventObj2->get_repeat(&bRepeat));
        if (SUCCEEDED(hr) && bRepeat)
        {
            RepeatCount = 1;
        }
    }
    
    m_pEventMgr->KeyEvent(FALSE,
                          FALSE,
                          bShiftKeyPressed,
                          bAltKeyPressed,
                          bCtrlKeyPressed,
                          KeyCode,
                          RepeatCount);

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: NotifyKeyUp
// 
//  Abstract:
//    This functions gets all the relevent information 
//    about a key up event from the event object
//    and notifies the event manager ofthe event.
///////////////////////////////////////////////////////////////
HRESULT CEventSink::NotifyKeyUp(IHTMLEventObj *pEventObj)
{
    VARIANT_BOOL bShiftKeyPressed;
    VARIANT_BOOL bAltKeyPressed;
    VARIANT_BOOL bCtrlKeyPressed;
    long KeyCode;

    HRESULT hr = S_OK;

    hr = THR(pEventObj->get_shiftKey(&bShiftKeyPressed));
    hr = THR(pEventObj->get_altKey(&bAltKeyPressed));
    hr = THR(pEventObj->get_ctrlKey(&bCtrlKeyPressed));
    hr = THR(pEventObj->get_keyCode(&KeyCode));
    
    m_pEventMgr->KeyEvent(FALSE,
                          TRUE,
                          bShiftKeyPressed,
                          bAltKeyPressed,
                          bCtrlKeyPressed,
                          KeyCode,
                          0);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\move.cpp ===
//*****************************************************************************
//
// File:            move.cpp
// Author:          jeff ort
// Date Created:    Sept 26, 1998
//
// Abstract: Implementation of CMoveBvr object which implements
//			 the chromeffects move DHTML behavior
//
// Modification List:
// Date		Author		Change
// 10/20/98	jeffort		Created this file
// 10/21/98 jeffort     Reworked code, use values as percentage
// 10/30/98 markhal     Check for BSTR variant type in Build2DTransform
//*****************************************************************************

#include "headers.h"

#include "move.h"
#include "attrib.h"
#include "dautil.h"

#undef THIS
#define THIS CMoveBvr
#define SUPER CBaseBehavior

#include "pbagimp.cpp"

// These are used for the IPersistPropertyBag2 as it is implemented
// in the base class.  This takes an array of BSTR's, gets the
// attributes, queries this class for the variant, and copies
// the result.  The order of these defines is important

#define VAR_FROM        0
#define VAR_TO          1
#define VAR_BY          2
#define VAR_V           3
#define VAR_TYPE        4
#define VAR_MODE		5
#define VAR_DIRECTION   6
WCHAR * CMoveBvr::m_rgPropNames[] = {
                                     BEHAVIOR_PROPERTY_FROM,
                                     BEHAVIOR_PROPERTY_TO,
                                     BEHAVIOR_PROPERTY_BY,
                                     BEHAVIOR_PROPERTY_V,
                                     BEHAVIOR_PROPERTY_TYPE,
									 BEHAVIOR_PROPERTY_MODE,
                                     BEHAVIOR_PROPERTY_DIRECTION
                                    };

//*****************************************************************************

CMoveBvr::CMoveBvr() :
    m_DefaultType(e_RelativeAccum),
    m_pPathManager(NULL),
    m_pdispActor(NULL),
    m_lCookie(0),
    m_pSampler( NULL ),
    m_lSampledCookie( 0 )
{
    VariantInit(&m_varFrom);
    VariantInit(&m_varTo);
    VariantInit(&m_varBy);
    VariantInit(&m_varPath);
    VariantInit(&m_varType);
	VariantInit(&m_varMode);
    VariantInit(&m_varDirection);
    m_clsid = CLSID_CrMoveBvr;

    VariantInit( &m_varCurrentX );
    V_VT(&m_varCurrentX) = VT_R8;
    V_R8(&m_varCurrentX) = 0.0;
    
    VariantInit( &m_varCurrentY );
    V_VT(&m_varCurrentY) = VT_R8;
    V_R8(&m_varCurrentY) = 0.0;
    
} // CMoveBvr

//*****************************************************************************

CMoveBvr::~CMoveBvr()
{
    VariantClear(&m_varFrom);
    VariantClear(&m_varTo);
    VariantClear(&m_varBy);
    VariantClear(&m_varType);  
	VariantClear(&m_varMode);
    VariantClear(&m_varDirection);

    VariantClear( &m_varCurrentX );
    VariantClear( &m_varCurrentY );
    
    if (m_pPathManager != NULL)
        delete m_pPathManager;
    ReleaseInterface( m_pdispActor );
    m_lCookie = 0;

    if( m_pSampler != NULL )
    {
    	RemoveBehaviorFromAnimatedElement( m_lSampledCookie );
    	m_pSampler->Invalidate();
    	m_pSampler = NULL;
    }
} // ~MoveBvr

//*****************************************************************************

HRESULT CMoveBvr::FinalConstruct()
{

    HRESULT hr = SUPER::FinalConstruct();
    if (FAILED(hr))
    {
        DPF_ERR("Error in move behavior FinalConstruct initializing base classes");
        return hr;
    }
    return S_OK;
} // FinalConstruct

//*****************************************************************************

VARIANT *
CMoveBvr::VariantFromIndex(ULONG iIndex)
{
    DASSERT(iIndex < NUM_MOVE_PROPS);
    switch (iIndex)
    {
    case VAR_FROM:
        return &m_varFrom;
        break;
    case VAR_TO:
        return &m_varTo;
        break;
    case VAR_BY:
        return &m_varBy;
        break;
    case VAR_V:
        return &m_varPath;
        break;
    case VAR_DIRECTION:
        return &m_varDirection;
        break;
	case VAR_TYPE:
		return &m_varType;
		break;
	case VAR_MODE:
		return &m_varMode;
		break;
    default:
        // We should never get here
        DASSERT(false);
        return NULL;
    }
} // VariantFromIndex

//*****************************************************************************

HRESULT 
CMoveBvr::GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames)
{
    *pulProperties = NUM_MOVE_PROPS;
    *pppPropNames = m_rgPropNames;
    return S_OK;
} // GetPropertyBagInfo

//*****************************************************************************

STDMETHODIMP 
CMoveBvr::Init(IElementBehaviorSite *pBehaviorSite)
{
	return SUPER::Init(pBehaviorSite);
} // Init

//*****************************************************************************

STDMETHODIMP 
CMoveBvr::Notify(LONG event, VARIANT *pVar)
{
	HRESULT hr = SUPER::Notify(event, pVar);
	CheckHR( hr, "Notify in base class failed", end);

	switch( event )
	{
	case BEHAVIOREVENT_CONTENTREADY:
		DPF_ERR("Got Content Ready");
			
		{
			hr = RequestRebuild( );
			CheckHR( hr, "Request for rebuild failed", end );
			
		}break;
    case BEHAVIOREVENT_DOCUMENTREADY:
		break;
    case BEHAVIOREVENT_APPLYSTYLE:
		DPF_ERR("Got ApplyStyle");
		break;
    case BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE:
		DPF_ERR("Got Document context change");
		break;
	default:
		DPF_ERR("Unknown event");
	}

end:
	
	return hr;
} // Notify

//*****************************************************************************

STDMETHODIMP
CMoveBvr::Detach()
{

	if( m_pSampler != NULL )
    {
    	RemoveBehaviorFromAnimatedElement( m_lSampledCookie );
    	m_pSampler->Invalidate();
    	m_pSampler = NULL;
    }

	HRESULT hr = SUPER::Detach();
	if( FAILED( hr ) )
	{
		DPF_ERR("Failed to detach superclass" );
	}

	if( m_pdispActor != NULL && m_lCookie != 0 )
	{
		//remove our behavior fragment from the actor
		hr = RemoveBehaviorFromActor( m_pdispActor, m_lCookie );
		CheckHR( hr, "Failed to remove the behavior fragment from the actor", end );

		m_lCookie = 0;
	}

	ReleaseInterface( m_pdispActor );
end:

	return hr;
	
} // Detach 

//*****************************************************************************

STDMETHODIMP
CMoveBvr::put_animates(VARIANT varAnimates)
{
    return SUPER::SetAnimatesProperty(varAnimates);
} // put_animates

//*****************************************************************************

STDMETHODIMP
CMoveBvr::get_animates(VARIANT *pRetAnimates)
{
    return SUPER::GetAnimatesProperty(pRetAnimates);
} // get_animates

//*****************************************************************************

STDMETHODIMP
CMoveBvr::put_from(VARIANT varFrom)
{
    HRESULT hr = VariantCopy(&m_varFrom, &varFrom);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting from for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRMOVEBVR_FROM);
} // put_from

//*****************************************************************************

STDMETHODIMP
CMoveBvr::get_from(VARIANT *pRetFrom)
{
    if (pRetFrom == NULL)
    {
        DPF_ERR("Error in move:get_from, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetFrom, &m_varFrom);
} // get_from

//*****************************************************************************

STDMETHODIMP 
CMoveBvr::put_to(VARIANT varTo)
{
    HRESULT hr = VariantCopy(&m_varTo, &varTo);
    if (FAILED(hr))
    {
        DPF_ERR("Error in put_to copying variant");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRMOVEBVR_TO);
} // put_to

//*****************************************************************************

STDMETHODIMP 
CMoveBvr::get_to(VARIANT *pRetTo)
{
    if (pRetTo == NULL)
    {
        DPF_ERR("Error in move:get_to, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetTo, &m_varTo);
} // get_to

//*****************************************************************************

STDMETHODIMP 
CMoveBvr::put_by(VARIANT varBy)
{
    HRESULT hr = VariantCopy(&m_varBy, &varBy);
    if (FAILED(hr))
    {
        DPF_ERR("Error in put_by copying variant");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRMOVEBVR_BY);
} // put_by

//*****************************************************************************

STDMETHODIMP 
CMoveBvr::get_by(VARIANT *pRetBy)
{
    if (pRetBy == NULL)
    {
        DPF_ERR("Error in move:get_by, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetBy, &m_varBy);
} // get_by

//*****************************************************************************

STDMETHODIMP
CMoveBvr::put_v(VARIANT varPath)
{
    HRESULT hr = VariantCopy(&m_varPath, &varPath);
    if (FAILED(hr))
    {
        DPF_ERR("Error in put_v copying variant");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRMOVEBVR_V);
} // put_v

//*****************************************************************************

STDMETHODIMP
CMoveBvr::get_v(VARIANT *pRetPath)
{
    if (pRetPath == NULL)
    {
        DPF_ERR("Error in move:get_v, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetPath, &m_varPath);
} // get_v

//*****************************************************************************

STDMETHODIMP
CMoveBvr::put_type(VARIANT varType)
{
    HRESULT hr = VariantCopy(&m_varType, &varType);
    if (FAILED(hr))
    {
        DPF_ERR("Error in put_type copying variant");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }

    return NotifyPropertyChanged(DISPID_ICRMOVEBVR_TYPE);
} // put_type

//*****************************************************************************

STDMETHODIMP
CMoveBvr::get_type(VARIANT *pRetType)
{
    if (pRetType == NULL)
    {
        DPF_ERR("Error in move:get_type, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetType, &m_varType);
} // get_type

//*****************************************************************************

STDMETHODIMP 
CMoveBvr::put_mode(VARIANT varMode)
{
    HRESULT hr = VariantCopy(&m_varMode, &varMode);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting mode for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRMOVEBVR_MODE);
} // put_mode

//*****************************************************************************

STDMETHODIMP 
CMoveBvr::get_mode(VARIANT *pRetMode)
{
    if (pRetMode == NULL)
    {
        DPF_ERR("Error in get_mode, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetMode, &m_varMode);
} // get_mode

//*****************************************************************************

STDMETHODIMP
CMoveBvr::put_direction(VARIANT varDirection)
{
    HRESULT hr = VariantCopy(&m_varDirection, &varDirection);
    if (FAILED(hr))
    {
        DPF_ERR("Error in put_direction copying variant");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRMOVEBVR_DIRECTION);
} // put_direction

//*****************************************************************************

STDMETHODIMP
CMoveBvr::get_direction(VARIANT *pRetDirection)
{
    if (pRetDirection == NULL)
    {
        DPF_ERR("Error in move:get_direction, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetDirection, &m_varDirection);
} // get_direction

//*****************************************************************************

HRESULT
CMoveBvr::PositionSampled( void *thisPtr,
 			  	 			long id,
				 			double startTime,
				 			double globalNow,
				 			double localNow,
				 			IDABehavior * sampleVal,
				 			IDABehavior **ppReturn)
{
	HRESULT hr = S_OK;

	reinterpret_cast<CMoveBvr*>(thisPtr)->UpdatePosition( sampleVal );
	
	return S_OK;
}


//*****************************************************************************

HRESULT	
CMoveBvr::UpdatePosition( IDABehavior *sampleVal )
{
	if( sampleVal == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	IDAPoint2 *pbvrPoint = NULL;
	IDANumber *pbvrValue = NULL;
	double dValue = 0.0;
	
	//get  IDApoint2 from the sample behavior
	hr = sampleVal->QueryInterface( IID_TO_PPV( IDAPoint2, &pbvrPoint ) );
	CheckHR( hr, "Failed to get point2 from the sampled val", end );
	
	//get the x
	hr = pbvrPoint->get_X( &pbvrValue );
	CheckHR( hr, "Failed to get x from the point2", end ); 
	//extract it
	hr = pbvrValue->Extract( &dValue );
	CheckHR( hr, "Failed to extract the y value", end );
	//put the new value in our local variant
	V_R8(&m_varCurrentX) = dValue;

	ReleaseInterface( pbvrValue );
	
	//get the y
	hr = pbvrPoint->get_Y( &pbvrValue );
	CheckHR( hr, "Failed to get the y bvr from the point", end );
	//extract it
	hr = pbvrValue->Extract( &dValue );
	CheckHR( hr, "Failed to extract the value for y ", end );
	//put the new value in our local variant
	V_R8( &m_varCurrentY ) = dValue;

end:

	ReleaseInterface(pbvrPoint);
	ReleaseInterface(pbvrValue);

	return S_OK;
}


//*****************************************************************************


STDMETHODIMP
CMoveBvr::buildBehaviorFragments(IDispatch *pActorDisp)
{
	HRESULT hr;

	//if our behavior fragment is already on an actor
    if( m_pdispActor != NULL && m_lCookie != 0 )
    {
        hr = RemoveBehaviorFromActor( m_pdispActor, m_lCookie );
        if( FAILED( hr ) )
        {
        	DPF_ERR("Failed to remove the behavior fragment from the actor");
        	return hr;
        }
        
        m_lCookie = 0;

        ReleaseInterface( m_pdispActor );
    }

    //release the sampler if we have one
    if( m_pSampler != NULL )
	{
    	//remove the sampled behavior from time
    	RemoveBehaviorFromAnimatedElement( m_lSampledCookie );
    	//invalidate the sampler
    	m_pSampler->Invalidate();
    	m_pSampler = NULL;
    }
    
    // TODO: we need to possibly build a 3D transform
    // at some later time.  For now, we will just handle the 2D
    // move case
    IDATransform2 *pbvrTransform;
    hr = Build2DTransform(pActorDisp, &pbvrTransform);
	if( SUCCEEDED( hr ) )
	{
		BSTR bstrPropertyName = SysAllocString( L"translation" );
			
		ActorBvrFlags flags;
/*
		if( V_VT(&m_varType) == VT_BSTR && V_BSTR(&m_varType) != NULL && SysStringLen( V_BSTR(&m_varType) ) != 0  )
		{
			//type is set we should use it to determine whether or not we are absolute or relative
			
			if( wcsicmp( V_BSTR(&m_varType), BEHAVIOR_TYPE_ABSOLUTE ) == 0 )
				flags = e_Absolute;
			else
				flags = e_Relative;
		}
		else //type is not set
		{

			//default to what we have set
			flags = m_DefaultType;
		}
*/

		IDAPoint2* pOrigin = NULL;
		IDAPoint2* pTransformed = NULL;
		IDABehavior *pbvrHooked = NULL;
		//push a point2 through the transform
		hr = GetDAStatics()->get_Origin2( &pOrigin );
		if(FAILED( hr ) )
		{
			DPF_ERR("");
			ReleaseInterface( pbvrTransform );
			return hr;
		}

		hr = pOrigin->Transform( pbvrTransform, &pTransformed );
		ReleaseInterface( pOrigin );
		if( FAILED( hr ) )
		{
			DPF_ERR("");
			ReleaseInterface( pbvrTransform );
			return hr;
		}

		//hook the result
		m_pSampler = new CSampler( PositionSampled, reinterpret_cast<void*>(this) );
		if( m_pSampler == NULL )
		{
			DPF_ERR("");
			ReleaseInterface( pbvrTransform );
			ReleaseInterface( pTransformed );
			return E_OUTOFMEMORY;
		}

		hr = m_pSampler->Attach( pTransformed, &pbvrHooked );
		ReleaseInterface( pTransformed );
		if( FAILED( hr ) )
		{
			DPF_ERR("");
			ReleaseInterface( pbvrTransform );
			return hr;
		}

		//add the resulting behavior to time as a bvr to run
		hr = AddBehaviorToAnimatedElement( pbvrHooked, &m_lSampledCookie );
		ReleaseInterface( pbvrHooked );
		if(FAILED( hr ) )
		{
			DPF_ERR("");
			ReleaseInterface( pbvrTransform );
			return hr;
		}

		flags = FlagFromTypeMode(m_DefaultType, &m_varType, &m_varMode);

		IDispatch *pdispThis = NULL;
		hr = GetHTMLElement()->QueryInterface( IID_TO_PPV( IDispatch, &pdispThis ) );
		if( FAILED( hr ) )
		{
			DPF_ERR("QI for Idispatch on the element failed");
			SysFreeString( bstrPropertyName );
			ReleaseInterface(pbvrTransform);
			return hr;
		}

		
		hr = AttachBehaviorToActorEx( pActorDisp, 
									  pbvrTransform, 
									  bstrPropertyName, 
									  flags, 
									  e_Translation, 
									  pdispThis, 
									  &m_lCookie ); 

		ReleaseInterface( pdispThis );
		
		SysFreeString( bstrPropertyName );
		ReleaseInterface(pbvrTransform);
		if (FAILED(hr))
		{
			DPF_ERR("Error applying move behavior to object");
			return hr;
		}

		//save the actor away so we can remove the behavior later
		m_pdispActor = pActorDisp;
		m_pdispActor->AddRef();
	}
	else //error building move transform
    {
        DPF_ERR("error building move transform");
    }

    return hr;
}

//*****************************************************************************

STDMETHODIMP
CMoveBvr::get_currentX( VARIANT *pRetCurrent )
{
	if( pRetCurrent == NULL )
		return E_INVALIDARG;

	return VariantCopy( pRetCurrent, &m_varCurrentX );
}

//*****************************************************************************

STDMETHODIMP
CMoveBvr::get_currentY( VARIANT *pRetCurrent )
{
	if( pRetCurrent == NULL )
		return E_INVALIDARG;
		
	return VariantCopy( pRetCurrent, &m_varCurrentY );
}

//*****************************************************************************

// These are used to index array values below

#define XVAL 0
#define YVAL 1
#define ZVAL 2

//*****************************************************************************

HRESULT 
CMoveBvr::Build2DTransform(IDispatch *pActorDisp, IDATransform2 **ppbvrTransform)
{
    HRESULT hr;

    DASSERT(ppbvrTransform != NULL);
    *ppbvrTransform = NULL;

    IDANumber *pbvrMoveX;
    IDANumber *pbvrMoveY;

    IDispatch *pDisp;
    hr = GetHTMLElement()->get_children(&pDisp);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting child collection");
        return SetErrorInfo(hr);
    }

    IHTMLElementCollection *pCollection;
    hr = pDisp->QueryInterface(IID_TO_PPV(IHTMLElementCollection, &pCollection));
    ReleaseInterface(pDisp);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing IDispatch for collection");
        return SetErrorInfo(hr);
    }

    // get the length of the collection
    long cChildren;
    hr = pCollection->get_length(&cChildren);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting number of children from collection");
        ReleaseInterface(pCollection);
        return SetErrorInfo(hr);
    }
    // now cycle through looking for the correct get property on each child
    for (long i = 0; i < cChildren; i++)
    {
        VARIANT varIndex;
        VariantInit(&varIndex);
        varIndex.vt = VT_I4;
        varIndex.intVal = 0;            

        VARIANT varName;
        VariantInit(&varName);
        varIndex.vt = VT_I4;
        varIndex.intVal = i;    
     
        IDispatch *pDisp;

        hr = pCollection->item(varName, varIndex, &pDisp);
        if (FAILED(hr))
        {
            DPF_ERR("Error obtaining item from collection");
            ReleaseInterface(pCollection);
            return SetErrorInfo(hr);
        }

        IHTMLElement *pChildElement;
        hr = pDisp->QueryInterface(IID_TO_PPV(IHTMLElement, &pChildElement));
        ReleaseInterface(pDisp);
        if (FAILED(hr))
        {
            DPF_ERR("Error QI'ing child Dispatch for HTML Element");
            ReleaseInterface(pCollection);
            return SetErrorInfo(hr);
        }

        // now invoke the child for the get_DATransform method
        HRESULT hr;
	    DISPPARAMS		params;
	    VARIANT			varResult;

        VARIANT         rgvarInputParms[1];

        IDANumber *pbvrProgress;
        hr = GetTIMEProgressNumber(&pbvrProgress);
        if (FAILED(hr))
        {
            DPF_ERR("Error retireving progress value from TIME");
            ReleaseInterface(pCollection);
            return hr;
        }
        
		VariantInit( &rgvarInputParms[0] );

        rgvarInputParms[0].vt = VT_DISPATCH;
        rgvarInputParms[0].pdispVal = pbvrProgress;

	    VariantInit(&varResult);

	    params.rgvarg				= rgvarInputParms;
	    params.rgdispidNamedArgs	= NULL;
	    params.cArgs				= 1;
	    params.cNamedArgs			= 0;
	    
        hr = CallInvokeOnHTMLElement(pChildElement,
                                     L"GetDATransform", 
                                     DISPATCH_METHOD,
                                     &params,
                                     &varResult);
        ReleaseInterface(pChildElement);
        ReleaseInterface(pbvrProgress);
        // we want to watch for failure, but an acceptable failure
        // is when the property is not supported
        if (FAILED(hr) && hr != DISP_E_UNKNOWNNAME)
        {
            DPF_ERR("Error calling Invoke on child element");
            ReleaseInterface(pCollection);
            return hr;
        }
        else if ((SUCCEEDED(hr)) && (varResult.vt == VT_DISPATCH))
        {
            // try and QI for an IDATransfrom2 here
            hr = varResult.pdispVal->QueryInterface(IID_TO_PPV(IDATransform2,
                                                               ppbvrTransform));
            VariantClear(&varResult);
            if (SUCCEEDED(hr))
            {
                // we found what we are looking for, get out of here
                break;
            }
        }
        else
        {
            VariantClear(&varResult);
        }
    }

	ReleaseInterface( pCollection );
    // We need to check to see if a path property was set and to
    // see if it has a path transform.  If it does not, then
    // we need to examine all our children to see if a path
    // behavior exists and if it has a valid transform.  If there
    // is not, then we will attempt to use our vector attributes.
    if (*ppbvrTransform == NULL && m_varPath.vt == VT_BSTR && m_varPath.bstrVal != NULL)
    {
        if (m_pPathManager == NULL)
        {
            m_pPathManager = new CPathManager;
            if (m_pPathManager == NULL)
            {
                DPF_ERR("Error creating path manger for move behavior");
                return SetErrorInfo(E_OUTOFMEMORY);
            }
        }
        hr = m_pPathManager->Initialize(m_varPath.bstrVal);
        if (FAILED(hr))
        {
            DPF_ERR("Error intitializing path object");
            return SetErrorInfo(hr);
        }
        IDANumber *pbvrProgress;
        hr = GetTIMEProgressNumber(&pbvrProgress);
        if (FAILED(hr))
        {
            DPF_ERR("Error getting progress behavior from animation object");
            return hr;
        }
        hr = m_pPathManager->BuildTransform(GetDAStatics(),
                                            pbvrProgress,
                                            0.0f,
                                            1.0f,
                                            ppbvrTransform);
        ReleaseInterface(pbvrProgress);
    }


    // if we still have not found a transform, try and build one from our
    // own paramters
    if (*ppbvrTransform == NULL)
    {
		hr = GetMoveToTransform(pActorDisp, ppbvrTransform);
		if (FAILED(hr))
		{
			float rgflFrom[2];
			float rgflTo[2];

			hr = GetMove2DVectorValues(rgflFrom, rgflTo);
			if (FAILED(hr))
			{
				DPF_ERR("Error extracting values from vecotors in CMoveBvr::BuildAnimationAsDABehavior");
				return hr;
			}
			hr = BuildTIMEInterpolatedNumber(rgflFrom[XVAL],
											 rgflTo[XVAL],
											 &pbvrMoveX);
			if (FAILED(hr))
			{
				DPF_ERR("Error building interpolated X value for move behavior");
				return hr;
			}

			hr = BuildTIMEInterpolatedNumber(rgflFrom[YVAL],
											 rgflTo[YVAL],
											 &pbvrMoveY);
			if (FAILED(hr))
			{
				DPF_ERR("Error building interpolated X value for move behavior");
				ReleaseInterface(pbvrMoveX);
				return hr;
			}

			hr = CDAUtils::BuildMoveTransform2(GetDAStatics(),
											   pbvrMoveX,
											   pbvrMoveY,
											   ppbvrTransform);
			ReleaseInterface(pbvrMoveX);
			ReleaseInterface(pbvrMoveY);
			if (FAILED(hr))
			{
				DPF_ERR("Error building move transform2");
				return SetErrorInfo(hr);
			}
		}
    }
    return S_OK;
} // Build2DTransform

//*****************************************************************************

HRESULT 
CMoveBvr::GetMove2DVectorValues(float  rgflFrom[2],
                                float  rgflTo[2])
{

    int cReturnedFromValues;
    HRESULT hr;
    float flDummyVal;

    hr = CUtils::GetVectorFromVariant(&m_varFrom, 
                                      &cReturnedFromValues, 
                                      &(rgflFrom[XVAL]), 
                                      &(rgflFrom[YVAL]),
                                      &flDummyVal);

    if (FAILED(hr) || cReturnedFromValues < MIN_NUM_MOVE_VALUES)
    {
        // If we did not get the minimum number of move params
        // here, then we will use all 0's
        rgflFrom[XVAL] = 0.0f;
        rgflFrom[YVAL] = 0.0f;
    }

    int cReturnedToValues;
    hr = CUtils::GetVectorFromVariant(&m_varTo, 
                                      &cReturnedToValues, 
                                      &(rgflTo[XVAL]), 
                                      &(rgflTo[YVAL]), 
                                      &flDummyVal);
    if (FAILED(hr) || cReturnedToValues < MIN_NUM_MOVE_VALUES)
    {
        // there was no valid to attribute specified, try for a by attribute
        hr = CUtils::GetVectorFromVariant(&m_varBy, 
                                          &cReturnedToValues, 
                                          &(rgflTo[XVAL]), 
                                          &(rgflTo[YVAL]), 
                                          &flDummyVal);
        if (FAILED(hr) || cReturnedToValues < MIN_NUM_MOVE_VALUES)
        {
            DPF_ERR("Error converting to and by variant to float in CMoveBvr::BuildAnimationAsDABehavior");
            return SetErrorInfo(hr);
        }
        rgflTo[XVAL] += rgflFrom[XVAL];
        rgflTo[YVAL] += rgflFrom[YVAL];
        m_DefaultType = e_RelativeAccum;
    }
    else
    {
        // they specified a TO vector, we will therefor default to
        // absolute movement if no type is specified
        m_DefaultType = e_Absolute;
    }
    return S_OK;
} // GetMove2DVectorValues

HRESULT 
CMoveBvr::GetMoveToTransform(IDispatch *pActorDisp, IDATransform2 **ppResult)
{

    HRESULT hr;
    int cReturnedValues;
    float x, y, z;

    hr = CUtils::GetVectorFromVariant(&m_varFrom, 
                                      &cReturnedValues, 
                                      &x, 
                                      &y,
                                      &z);

	if (SUCCEEDED(hr))
		return E_FAIL;

    hr = CUtils::GetVectorFromVariant(&m_varTo, 
                                      &cReturnedValues, 
                                      &x, 
                                      &y, 
                                      &z);

    if (FAILED(hr) || cReturnedValues < MIN_NUM_MOVE_VALUES)
    {
		return E_FAIL;
	}

	IDABehavior *pFromBvr;
	hr = GetBvrFromActor(pActorDisp, L"translation", e_From, e_Translation, &pFromBvr);
	if (FAILED(hr))
		return hr;

	IDATransform2 *pFromTrans;
	hr = pFromBvr->QueryInterface(IID_TO_PPV(IDATransform2, &pFromTrans));
	ReleaseInterface(pFromBvr);
	if (FAILED(hr))
		return hr;

	// Translate the origin and extract x and y
	IDAPoint2 *pOrigin;
	hr = GetDAStatics()->get_Origin2(&pOrigin);
	if (FAILED(hr))
	{
		ReleaseInterface(pFromTrans);
		return hr;
	}

	IDAPoint2 *pFrom;
	hr = pOrigin->Transform(pFromTrans, &pFrom);
	ReleaseInterface(pOrigin);
	ReleaseInterface(pFromTrans);
	if (FAILED(hr))
		return hr;

	IDANumber *pFromX;
	hr = pFrom->get_X(&pFromX);
	if (FAILED(hr))
	{
		ReleaseInterface(pFrom);
		return hr;
	}

	IDANumber *pFromY;
	hr = pFrom->get_Y(&pFromY);
	ReleaseInterface(pFrom);
	if (FAILED(hr))
	{
		ReleaseInterface(pFromX);
		return hr;
	}

	IDANumber *pToX;
	hr = GetDAStatics()->DANumber(x, &pToX);
	if (FAILED(hr))
	{
		ReleaseInterface(pFromX);
		ReleaseInterface(pFromY);
		return hr;
	}

	IDANumber *pToY;
	hr = GetDAStatics()->DANumber(y, &pToY);
	if (FAILED(hr))
	{
		ReleaseInterface(pFromX);
		ReleaseInterface(pFromY);
		ReleaseInterface(pToX);
		return hr;
	}

	IDANumber *pX;
	hr = BuildTIMEInterpolatedNumber(pFromX, pToX, &pX);
	ReleaseInterface(pFromX);
	ReleaseInterface(pToX);
	if (FAILED(hr))
	{
		ReleaseInterface(pFromY);
		ReleaseInterface(pToY);
		return hr;
	}

	IDANumber *pY;
	hr = BuildTIMEInterpolatedNumber(pFromY, pToY, &pY);
	ReleaseInterface(pFromY);
	ReleaseInterface(pToY);
	if (FAILED(hr))
	{
		ReleaseInterface(pX);
		return hr;
	}

	hr = GetDAStatics()->Translate2Anim(pX, pY, ppResult);
	ReleaseInterface(pX);
	ReleaseInterface(pY);
	if (FAILED(hr))
		return hr;

	m_DefaultType = e_AbsoluteAccum;

	return S_OK;
} // GetMove2DVectorValues


//*****************************************************************************

HRESULT 
CMoveBvr::BuildAnimationAsDABehavior()
{
	return S_OK;
} // BuildAnimationAsDABehavior

//*****************************************************************************

HRESULT 
CMoveBvr::GetTIMEProgressNumber(IDANumber **ppbvrRet)
{
    DASSERT(ppbvrRet != NULL);
    *ppbvrRet = NULL;
    HRESULT hr;

    IDANumber *pbvrProgress;
    hr = SUPER::GetTIMEProgressNumber(&pbvrProgress);
    if (FAILED(hr))
    {
        DPF_ERR("Error retireving progress value from TIME");
        return hr;
    }
    
    hr = CUtils::InsurePropertyVariantAsBSTR(&m_varDirection);
    if ( SUCCEEDED(hr) && (0 == wcsicmp(m_varDirection.bstrVal, L"backwards")) )
    {
        // pbvrProgress = 1 - pbvrProgress
        IDANumber *pbvrOne;
        
        hr = CDAUtils::GetDANumber(GetDAStatics(), 1.0f, &pbvrOne);
        if (FAILED(hr))
        {
            DPF_ERR("Error creating DANumber from 1.0f");
            ReleaseInterface(pbvrProgress);
            return hr;
        }

        IDANumber *pbvrTemp;
        hr = GetDAStatics()->Sub(pbvrOne, pbvrProgress, &pbvrTemp);
        ReleaseInterface(pbvrOne);
        ReleaseInterface(pbvrProgress);
        pbvrProgress = pbvrTemp;
        pbvrTemp = NULL;
        if (FAILED(hr))
        {
            DPF_ERR("Error creating 1-progress expression");
            return hr;
        }
    }
    *ppbvrRet = pbvrProgress;
    return S_OK;
} // GetTIMEProgressNumber

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\factory.cpp ===
//*****************************************************************************
//
// File: factory.cpp
// Author: jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of CCrBehaviorFactory object which implements
//			 the chromeffects factory for DHTML behaviors
//
// Modification List:
// Date		Author		Change
// 09/26/98	jeffort		Created this file
// 10/21/98 jeffort     Changed FindBehavior from using class to using the tag
//                      to determine the behavior type being created
// 11/12/98 markhal     FindBehavior now accepts null arguments 
//
//*****************************************************************************
#include "headers.h"

#include "factory.h"
#include "colorbvr.h"
#include "rotate.h"
#include "scale.h"
#include "move.h"
#include "path.h"
#include "number.h"
#include "set.h"
#include "actorbvr.h"
#include "attrib.h"
#include "effect.h"
#include "action.h"

#include "datime.h"

#define WZ_TIMEDA_URN L"#time#da"

//*****************************************************************************

ECRBEHAVIORTYPE 
CCrBehaviorFactory::GetBehaviorTypeFromBstr(BSTR bstrBehaviorType)
{
    DASSERT(bstrBehaviorType != NULL);
    // If this list grows to be too long,
    // we should consider a binary search, but for eight behaviors, compare
    // is OK
	if (_wcsicmp(BEHAVIOR_TYPE_COLOR, bstrBehaviorType) == 0)
        return crbvrColor;
	else if (_wcsicmp(BEHAVIOR_TYPE_ROTATE, bstrBehaviorType) == 0)
        return crbvrRotate;
    else if (_wcsicmp(BEHAVIOR_TYPE_SCALE, bstrBehaviorType) == 0)
        return crbvrScale;
    else if (_wcsicmp(BEHAVIOR_TYPE_SET, bstrBehaviorType) == 0)
        return crbvrSet;
    else if (_wcsicmp(BEHAVIOR_TYPE_NUMBER, bstrBehaviorType) == 0)
        return crbvrNumber;
    else if (_wcsicmp(BEHAVIOR_TYPE_MOVE, bstrBehaviorType) == 0)
        return crbvrMove;
    else if (_wcsicmp(BEHAVIOR_TYPE_PATH, bstrBehaviorType) == 0)
        return crbvrPath;
    else if (_wcsicmp(BEHAVIOR_TYPE_ACTOR, bstrBehaviorType) == 0)
        return crbvrActor;
    else if (_wcsicmp(BEHAVIOR_TYPE_EFFECT, bstrBehaviorType) == 0)
        return crbvrEffect;
    else if ( _wcsicmp(BEHAVIOR_TYPE_ACTION, bstrBehaviorType) == 0)
        return crbvrAction;
    else if ( _wcsicmp(BEHAVIOR_TYPE_DA, bstrBehaviorType) == 0)
        return crbvrDA;
    // otherwise we do not know what the behavior type is, so return unkown
    else
        return crbvrUnknown;
} // GetBehaviorTypeFromBstr

//*****************************************************************************

STDMETHODIMP 
CCrBehaviorFactory::FindBehavior(LPOLESTR pchBehaviorName,
							     LPOLESTR pchBehaviorURL,
								 IUnknown *pUnkArg,
								 IElementBehavior **ppBehavior)
{
    HRESULT hr = E_FAIL;

    // (TIME bails if we are in 16 or less color mode. Need to the same
    // here because LM crashes if time is not around.)
    // If we are in 16 or less color mode on the Primary Device, bail.
    // Note: Multi-monitor API are currently unavailable in this build
    HWND hwndDesktop = NULL;
    hwndDesktop = GetDesktopWindow();
    if (NULL != hwndDesktop)
    {
        HDC hdcPrimaryDevice = NULL;
        hdcPrimaryDevice = GetDC(NULL);
        if (NULL != hdcPrimaryDevice)
        {
            int bpp = 32;
            bpp = GetDeviceCaps(hdcPrimaryDevice, BITSPIXEL);
            ReleaseDC(hwndDesktop, hdcPrimaryDevice);
            if (bpp <= 4)
            {
                // This prevents LM bvrs from being created
                return E_FAIL;
            }
        }
    }

	// check the paramters passed in to insure they are valid
	if (pUnkArg == NULL ||
		ppBehavior == NULL) 
	{
		DPF_ERR("Invalid Parameter passed into FindBehavior is NULL");
		return SetErrorInfo(E_INVALIDARG);
	}

    BSTR bstrTagName;
    if (pchBehaviorName == NULL || _wcsicmp(DEFAULT_BEHAVIOR_AS_TAG_URL, pchBehaviorName) == 0)
    {
        // we need to get the tag name from the HTMLElement that we are being
        // created from.  To do this we use the IUnknown to get a IElementBehaviorSite,
        // from this we get the HTMLElement, and get the tagname from this.
        IElementBehaviorSite *pBehaviorSite;
        hr = pUnkArg->QueryInterface(IID_TO_PPV(IElementBehaviorSite, &pBehaviorSite));
        if (FAILED(hr))
        {
            DPF_ERR("Unable to get an ElementBehaviorSite from IUnknown in FindBehavior");
            return SetErrorInfo(hr);
        }
        DASSERT(pBehaviorSite != NULL);
        IHTMLElement *pElement;
        hr = pBehaviorSite->GetElement(&pElement);
        ReleaseInterface(pBehaviorSite);
        if (FAILED(hr))
        {
            DPF_ERR("Error retrieving HTMLElement from BehaviorSite in FindBehavior");
            return SetErrorInfo(hr);
        }
        DASSERT(pElement != NULL);
        hr = pElement->get_tagName(&bstrTagName);
        ReleaseInterface(pElement);
        if (FAILED(hr))
        {
            DPF_ERR("Error retrieving tagname from HTML element in FindBehavior");
            return SetErrorInfo(hr);
        }
    }
    else
    {
        bstrTagName = pchBehaviorName;
    }


    DASSERT(bstrTagName != NULL);
    ECRBEHAVIORTYPE ecrBehaviorType = GetBehaviorTypeFromBstr(bstrTagName);

	//if we don't recognize the behavior name
    if (ecrBehaviorType == crbvrUnknown )
	{
		//if the behavior name came from the tag
		if(bstrTagName != pchBehaviorName )
		{
			if (bstrTagName != pchBehaviorName)
				SysFreeString(bstrTagName);

			//create an actor
			CComObject<CActorBvr> *pActor;
			hr = CComObject<CActorBvr>::CreateInstance(&pActor);
			if (FAILED(hr))
			{
				DPF_ERR("Error creating actor behavior in FindBehavior");
				return SetErrorInfo(hr);
			}
			// this will do the necessary AddRef to the object
			hr = pActor->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
			DASSERT(SUCCEEDED(hr));
			
			return hr;
		}
		else //else the behavior name did not come from the tag
		{
			if (bstrTagName != pchBehaviorName)
				SysFreeString(bstrTagName);

			DPF_ERR("Error: Unknown behavior type passed into FindBehavior");
			return SetErrorInfo(E_INVALIDARG);
		}
	}

	if (bstrTagName != pchBehaviorName)
        SysFreeString(bstrTagName);

    switch (ecrBehaviorType)
    {
    case crbvrColor:
        CComObject<CColorBvr> *pColor;
        hr = CComObject<CColorBvr>::CreateInstance(&pColor);
        if (FAILED(hr))
		{
			DPF_ERR("Error creating color behavior in FindBehavior");
			return SetErrorInfo(hr);
		}
		// this will do the necessary AddRef to the object
        hr = pColor->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
		DASSERT(SUCCEEDED(hr));
        break;

    case crbvrRotate:
        CComObject<CRotateBvr> *pRotate;
        hr = CComObject<CRotateBvr>::CreateInstance(&pRotate);
        if (FAILED(hr))
		{
			DPF_ERR("Error creating rotate behavior in FindBehavior");
			return SetErrorInfo(hr);
		}
		// this will do the necessary AddRef to the object
        hr = pRotate->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
		DASSERT(SUCCEEDED(hr));
        break;

    case crbvrScale:
        CComObject<CScaleBvr> *pScale;
        hr = CComObject<CScaleBvr>::CreateInstance(&pScale);
        if (FAILED(hr))
		{
			DPF_ERR("Error creating scale behavior in FindBehavior");
			return SetErrorInfo(hr);
		}
		// this will do the necessary AddRef to the object
        hr = pScale->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
		DASSERT(SUCCEEDED(hr));
        break;

    case crbvrMove:
        CComObject<CMoveBvr> *pMove;
        hr = CComObject<CMoveBvr>::CreateInstance(&pMove);
        if (FAILED(hr))
		{
			DPF_ERR("Error creating move behavior in FindBehavior");
			return SetErrorInfo(hr);
		}
		// this will do the necessary AddRef to the object
        hr = pMove->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
		DASSERT(SUCCEEDED(hr));
        break;

    case crbvrPath:
        CComObject<CPathBvr> *pPath;
        hr = CComObject<CPathBvr>::CreateInstance(&pPath);
        if (FAILED(hr))
		{
			DPF_ERR("Error creating path behavior in FindBehavior");
			return SetErrorInfo(hr);
		}
		// this will do the necessary AddRef to the object
        hr = pPath->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
		DASSERT(SUCCEEDED(hr));
        break;

    case crbvrNumber:
        CComObject<CNumberBvr> *pNumber;
        hr = CComObject<CNumberBvr>::CreateInstance(&pNumber);
        if (FAILED(hr))
		{
			DPF_ERR("Error creating number behavior in FindBehavior");
			return SetErrorInfo(hr);
		}
		// this will do the necessary AddRef to the object
        hr = pNumber->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
		DASSERT(SUCCEEDED(hr));
        break;
	
    case crbvrSet:
        CComObject<CSetBvr> *pSet;
        hr = CComObject<CSetBvr>::CreateInstance(&pSet);
        if (FAILED(hr))
		{
			DPF_ERR("Error creating set behavior in FindBehavior");
			return SetErrorInfo(hr);
		}
		// this will do the necessary AddRef to the object
        hr = pSet->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
		DASSERT(SUCCEEDED(hr));
		break;
	case crbvrActor:
		CComObject<CActorBvr> *pActor;
		hr = CComObject<CActorBvr>::CreateInstance(&pActor);
		if (FAILED(hr))
		{
			DPF_ERR("Error creating actor behavior in FindBehavior");
			return SetErrorInfo(hr);
		}
		// this will do the necessary AddRef to the object
		hr = pActor->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
		DASSERT(SUCCEEDED(hr));
		break;
	case crbvrEffect:
		CComObject<CEffectBvr> *pEffect;
		hr = CComObject<CEffectBvr>::CreateInstance(&pEffect);
		if (FAILED(hr))
		{
			DPF_ERR("Error creating effect behavior in FindBehavior");
			return SetErrorInfo(hr);
		}
		// this will do the necessary AddRef to the object
		hr = pEffect->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
		DASSERT(SUCCEEDED(hr));
		break;
	case crbvrAction:
		CComObject<CActionBvr> *pAction;
		hr = CComObject<CActionBvr>::CreateInstance(&pAction);
		if (FAILED(hr))
		{
			DPF_ERR("Error creating action behavior in FindBehavior");
			return SetErrorInfo(hr);
		}
		// this will do the necessary AddRef to the object
		hr = pAction->QueryInterface(IID_TO_PPV(IElementBehavior, ppBehavior));
		DASSERT(SUCCEEDED(hr));
		break;
	case crbvrDA:
		ITIMEFactory *pTimeFactory;
		hr = CoCreateInstance(CLSID_TIMEFactory, 
                              NULL, 
                              CLSCTX_INPROC_SERVER, 
                              IID_ITIMEFactory, 
                              (void**)&pTimeFactory);
        if (FAILED(hr))
        {
            DPF_ERR("Error creating time factory in FindBehavior");
            return SetErrorInfo(hr);
        }
        IElementBehaviorFactory *pBehaviorFactory;
        hr = pTimeFactory->QueryInterface(IID_TO_PPV(IElementBehaviorFactory, &pBehaviorFactory)); 
        ReleaseInterface(pTimeFactory);
        if (FAILED(hr))
        {
            DPF_ERR("Error Querying for IElementBehaviorFactor in FindBehavior");
            return hr;
        }
        // QI pUnkArg for pBehaviorSite and pass to FindBehavior(...)
        // TODO: (dilipk) this QI goes away with the old FindBehavior Signature (#38656).
        IElementBehaviorSite *pBehaviorSite;
        hr = pUnkArg->QueryInterface(IID_TO_PPV(IElementBehaviorSite, &pBehaviorSite)); 
        if (FAILED(hr))
        {
            DPF_ERR("Error Querying for IElementBehaviorSite in FindBehavior");
            return hr;
        }
        hr = pBehaviorFactory->FindBehavior( pchBehaviorName,
                                             WZ_TIMEDA_URN,
                                             pBehaviorSite,
                                             ppBehavior);
        ReleaseInterface(pBehaviorSite);
        ReleaseInterface(pBehaviorFactory);
        break;
    default:
        // should never ever reach here
        DASSERT(false);
        hr = E_INVALIDARG;
	}
    return hr;

} // FindBehavior

//*****************************************************************************

STDMETHODIMP 
CCrBehaviorFactory::GetInterfaceSafetyOptions(REFIID riid, 
                                              DWORD *pdwSupportedOptions, 
                                              DWORD *pdwEnabledOptions)
{
	if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
		return E_POINTER;
	HRESULT hr = S_OK;

	if (riid == IID_IDispatch)
	{
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
	}
	else if (riid == IID_IPersistPropertyBag2 )
	{
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_DATA;
	}
	else
	{
		*pdwSupportedOptions = 0;
		*pdwEnabledOptions = 0;
		hr = E_NOINTERFACE;
	}
	return hr;
} // GetInterfaceSafetyOptions

//*****************************************************************************

STDMETHODIMP 
CCrBehaviorFactory::SetInterfaceSafetyOptions(REFIID riid, 
                                              DWORD dwOptionSetMask, 
                                              DWORD dwEnabledOptions)
{	
	// If we're being asked to set our safe for scripting or
	// safe for initialization options then oblige
	if (riid == IID_IDispatch || riid == IID_IPersistPropertyBag2)
	{
		// Store our current safety level to return in GetInterfaceSafetyOptions
		m_dwSafety = dwEnabledOptions & dwOptionSetMask;
		return S_OK;
	}

	return E_NOINTERFACE;
} // SetInterfaceSafetyOptions

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\headers.h ===
#pragma once
#ifndef CRBVR_HEADERS_HXX
#define CRBVR_HEADERS_HXX
//*****************************************************************************
//
// Microsoft Chrome
// Copyright (C) Microsoft Corporation, 1998
//
// Filename:    headers.h
//
// Author:	    jeffort
//
// Created:	    10/07/98
//
// Abstract:    default headers for this project
// Modifications:
// 10/07/98 jeffort created file
//
//*****************************************************************************

/* Standard */
#include <math.h>
//#ifdef DEBUGMEM
//#include "crtdbg.h"
//#endif
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#ifndef _NO_CRT
#include <ios.h>
#include <fstream.h>
#include <iostream.h>
#include <ostream.h>
#include <strstrea.h>
#include <istream.h>
#include <ctype.h>
#include <sys/types.h>
#endif
#include <string.h>
#include <malloc.h>
#include <memory.h>
#include <wtypes.h>

// ATL - needs to be before windows.h

#define _ATL_NO_DEBUG_CRT 1

#ifdef _DEBUG
#undef _ASSERTE
#endif

#define _ASSERTE(expr) ((void)0)

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

/* Windows */
#include <windows.h>
#include <windowsx.h>

#include <mshtmhst.h>
#include <mshtml.h>
#include <mshtmdid.h>

#include <ddraw.h>
#include <danim.h>

// CrBvr utilities
#include "..\include\utils.h"
#include "..\include\defaults.h"

//#define CRSTANDALONE 1
#ifdef CRSTANDALONE
    #include <crbvr.h>
#else
    #include <lmrt.h>
#endif // CRSTANDALONE

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
#endif // CRBVR_HEADERS_HXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\path.cpp ===
//*****************************************************************************
//
// File:    path.cpp
// Author:  jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of CPathBvr object which implements
//			 the chromeffects Path DHTML behavior
//
// Modification List:
// Date		Author		Change
// 10/23/98	jeffort		Created this file
//*****************************************************************************

#include "headers.h"

#include "path.h"
#include <math.h>
#include "attrib.h"
#include "dautil.h"

#undef THIS
#define THIS CPathBvr
#define SUPER CBaseBehavior

#include "pbagimp.cpp"

// These are used for the IPersistPropertyBag2 as it is implemented
// in the base class.  This takes an array of BSTR's, gets the
// attributes, queries this class for the variant, and copies
// the result.  The order of these defines is important

#define VAR_V           0

WCHAR * CPathBvr::m_rgPropNames[] = {
                                     BEHAVIOR_PROPERTY_V,
                                    };

//*****************************************************************************

CPathBvr::CPathBvr() :
    m_pPathManager(NULL)
{
    VariantInit(&m_varPath);
    m_clsid = CLSID_CrPathBvr;
} // CPathBvr

//*****************************************************************************

CPathBvr::~CPathBvr()
{
    if (NULL != m_pPathManager)
    {
        delete m_pPathManager;
        m_pPathManager = NULL;
    }

    VariantClear(&m_varPath);
} // ~PathBvr

//*****************************************************************************

HRESULT CPathBvr::FinalConstruct()
{
    HRESULT hr = SUPER::FinalConstruct();
    if (FAILED(hr))
    {
        DPF_ERR("Error in path behavior FinalConstruct initializing base classes");
        return hr;
    }
    m_pPathManager = new CPathManager;
    if (m_pPathManager == NULL)
    {
        DPF_ERR("Error creating member: subpath in CPathBvr FinalConstruct");
        return SetErrorInfo(E_OUTOFMEMORY);
    }
    return S_OK;
} // FinalConstruct

//*****************************************************************************

VARIANT *
CPathBvr::VariantFromIndex(ULONG iIndex)
{
    DASSERT(iIndex < NUM_MOVE_PROPS);
    switch (iIndex)
    {
    case VAR_V:
        return &m_varPath;
        break;
    default:
        // We should never get here
        DASSERT(false);
        return NULL;
    }
} // VariantFromIndex

//*****************************************************************************

HRESULT 
CPathBvr::GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames)
{
    *pulProperties = NUM_PATH_PROPS;
    *pppPropNames = m_rgPropNames;
    return S_OK;
} // GetPropertyBagInfo

//*****************************************************************************

STDMETHODIMP 
CPathBvr::Init(IElementBehaviorSite *pBehaviorSite)
{
	return SUPER::Init(pBehaviorSite);
} // Init

//*****************************************************************************

STDMETHODIMP 
CPathBvr::Notify(LONG event, VARIANT *pVar)
{
	return SUPER::Notify(event, pVar);
} // Notify

//*****************************************************************************

STDMETHODIMP
CPathBvr::Detach()
{
	return SUPER::Detach();
} // Detach 

//*****************************************************************************

STDMETHODIMP
CPathBvr::put_v(VARIANT varPath)
{
    HRESULT hr = VariantCopy(&m_varPath, &varPath);
    if (FAILED(hr))
    {
        DPF_ERR("Error in put_v copying variant");
        return SetErrorInfo(hr);
    }
    return NotifyPropertyChanged(DISPID_ICRPATHBVR_V);
} // put_v

//*****************************************************************************

STDMETHODIMP
CPathBvr::get_v(VARIANT *pRetPath)
{
    if (pRetPath == NULL)
    {
        DPF_ERR("Error in path:get_v, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetPath, &m_varPath);
} // get_v

//*****************************************************************************

STDMETHODIMP
CPathBvr::GetDATransform(IDispatch *pDispProgress, 
                         VARIANT *pRetTrans)
{
    IDATransform2 *pbvrTransform;
    HRESULT hr;

    VariantInit(pRetTrans);
    hr = CUtils::InsurePropertyVariantAsBSTR(&m_varPath);
    if (FAILED(hr))
    {
        DPF_ERR("Error in path: property does not contain bstr for path");
        return SetErrorInfo(hr);
    }


    hr = m_pPathManager->Initialize(m_varPath.bstrVal);
    if (FAILED(hr))
    {
        DPF_ERR("Error initializing path object");
        return SetErrorInfo(hr);
    }

    IDANumber *pbvrProgress;
    hr = pDispProgress->QueryInterface(IID_TO_PPV(IDANumber, &pbvrProgress));
    if (FAILED(hr))
    {
        DPF_ERR("Error getting progress behavior from IDispatch");
        return hr;
    }
    hr = m_pPathManager->BuildTransform(GetDAStatics(),
                                        pbvrProgress,
                                        0.0f,
                                        1.0f,
                                        &pbvrTransform);
    ReleaseInterface(pbvrProgress);
    if (FAILED(hr))
    {
        DPF_ERR("Error building transform for path");
        return SetErrorInfo(hr);
    }


    hr = pbvrTransform->QueryInterface(IID_TO_PPV(IDispatch, &(pRetTrans->pdispVal)));
    ReleaseInterface(pbvrTransform);
    if (FAILED(hr))
    {
        DPF_ERR("Error QI'ing for IDispatch");
        return SetErrorInfo(hr);
    }
    pRetTrans->vt = VT_DISPATCH;
    return S_OK;
} // get_DATransform

//*****************************************************************************

HRESULT 
CPathBvr::BuildAnimationAsDABehavior()
{

    return S_OK;
} // BuildAnimationAsDABehavior

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\pathline.cpp ===
//*****************************************************************************
//
// File:    pathline.cpp
// Author:  jeff wall
// Date Created: 11/09/98
//
// Abstract: Implementation of CPathLineSegment object
//
// Modification List:
// Date		Author		Change
// 11/09/98	jeffwall Created this file from path.cpp
//
//
//*****************************************************************************

#include "headers.h"

#include "pathline.h"
#include "dautil.h"


//*****************************************************************************

CPathLineSegment::CPathLineSegment() :
    m_flStartX(0.0f),
    m_flStartY(0.0f),
    m_flEndX(0.0f),
    m_flEndY(0.0f)
{

} //CPathLineSegment

//*****************************************************************************

CPathLineSegment::~CPathLineSegment()
{

} // ~CPathLineSegment

//*****************************************************************************

float 
CPathLineSegment::Distance()
{
    // our distance is simple the distance formula
    return (float) sqrt( ((m_flEndX - m_flStartX) * (m_flEndX - m_flStartX)) +
                 ((m_flEndY - m_flStartY) * (m_flEndY - m_flStartY)));
} // Distance

//*****************************************************************************
void
CPathLineSegment::SetValues(float flStartX, 
                            float flStartY, 
                            float flEndX, 
                            float flEndY)
{
    m_flStartX = flStartX;
    m_flStartY = flStartY;
    m_flEndX = flEndX;
    m_flEndY = flEndY;

}; // SetValues

//*****************************************************************************

HRESULT 
CPathLineSegment::BuildTransform(IDA2Statics *pDAStatics,
                                 IDANumber *pbvrProgress, 
                                 float flStartPercentage,
                                 float flEndPercentage,
                                 IDATransform2 **ppbvrResult)
{
    DASSERT(pDAStatics != NULL);
    DASSERT(pbvrProgress != NULL);
    DASSERT(flStartPercentage >= 0.0f);
    DASSERT(flStartPercentage <= 1.0f);
    DASSERT(flEndPercentage >= 0.0f);
    DASSERT(flEndPercentage <= 1.0f);
    DASSERT(ppbvrResult != NULL);
    *ppbvrResult = NULL;

    HRESULT hr;

    // we need to build two DA numbers representing the
    // X and Y portions of the transform.  Each number is in
    // the format of:
    // X = startX + ((endX - startX) * norm-prog)
    // where:
    // norm-prog = progress - startpercentage / endpercentage - startpercentage

    // First build our normalized progress value

    IDANumber *pbvrNormalizedProgress;
    hr = NormalizeProgressValue(pDAStatics,
                                pbvrProgress,
                                flStartPercentage,
                                flEndPercentage,
                                &pbvrNormalizedProgress);
    if (FAILED(hr))
    {
        DPF_ERR("Error normalizing progress");
        return hr;
    }

    DASSERT(pbvrNormalizedProgress != NULL);
    IDANumber *pbvrX;
    IDANumber *pbvrY;

    hr = CDAUtils::TIMEInterpolateNumbers(pDAStatics, 
                                          m_flStartX, 
                                          m_flEndX, 
                                          pbvrNormalizedProgress, 
                                          &pbvrX);
    if (FAILED(hr))
    {
        DPF_ERR("Error interpolating DA number in CPathLineSegment::BuildTransform");
        ReleaseInterface(pbvrNormalizedProgress);
        return hr;
    }
    hr = CDAUtils::TIMEInterpolateNumbers(pDAStatics, 
                                          m_flStartY, 
                                          m_flEndY, 
                                          pbvrNormalizedProgress, 
                                          &pbvrY);
    ReleaseInterface(pbvrNormalizedProgress);
    if (FAILED(hr))
    {
        DPF_ERR("Error interpolating DA number in CPathLineSegment::BuildTransform");
        ReleaseInterface(pbvrX);
        return hr;
    }

    hr = CDAUtils::BuildMoveTransform2(pDAStatics,
                                       pbvrX,
                                       pbvrY,
                                       ppbvrResult);
    ReleaseInterface(pbvrX);
    ReleaseInterface(pbvrY);
    if (FAILED(hr))
    {
        DPF_ERR("Error building move transform2 in CPathLineSegment::BuildTransform");
        return hr;
    }    
    return S_OK;

} // BuildTransform



//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\pcurve.cpp ===
//*****************************************************************************
//
// File:    pathcurv.cpp
// Author:  jeff wall
// Date Created: 11/09/98
//
// Abstract: Implementation of CPathCurve object
//
// Modification List:
// Date		Author		Change
// 11/09/98	jeffwall Created this file from path.cpp
//
//
//*****************************************************************************

#include "headers.h"

#include "pcurve.h"
#include "pathline.h"
#include "dautil.h"

static const float LINETO   = 2.0f;
static const float BEZIERTO = 4.0f;
static const float MOVETO   = 6.0f;

//*****************************************************************************

CPathCurve::CPathCurve() :
    m_flStartX(0.0f),
    m_flStartY(0.0f),
    m_flControl1X(0.0f),
    m_flControl1Y(0.0f),
    m_flControl2X(0.0f),
    m_flControl2Y(0.0f),
    m_flEndX(0.0f),
    m_flEndY(0.0f),
    m_flDistance(0.0f),
    m_pListHead(NULL),
    m_pListTail(NULL),
    m_segCount(0)
{

} //CPathLineSegment

//*****************************************************************************

CPathCurve::~CPathCurve()
{
    CPathElement *pElement = m_pListHead;
    while(NULL != pElement)
    {
        CPathElement *pTemp = pElement->m_pNext;
        delete pElement;
        pElement = pTemp;
    }
    m_pListHead = NULL;
    m_pListTail = NULL;
} // ~CPathLineSegment

//*****************************************************************************

#define TOLERANCE 0.001f

static float
DistanceBetweenTwoPoints(float flX1, float flY1, float flX2, float flY2)
{
    return (float) sqrt( ((flX2 - flX1) * (flX2 - flX1)) +
                 ((flY2 - flY1) * (flY2 - flY1)));
}

//*****************************************************************************

static void SplitBezierComponents(float *pflXComponents,
                           float *pflYComponents,
                           float *pflLeftXComponents,
                           float *pflLeftYComponents,
                           float *pflRightXComponents,
                           float *pflRightYComponents)
{

    float VXTemp[4][4];
    float VYTemp[4][4];
    int i, j;


    for (j=0; j <= 3; j++)
    {
        VXTemp[0][j] = pflXComponents[j];
        VYTemp[0][j] = pflYComponents[j];
    }

    for (i = 1; i <= 3; i++)
    {
        for (j = 0; (j+i) <= 3; j++)
        {
            VXTemp[i][j] = (0.5f * VXTemp[i-1][j]) +
                           (0.5f * VXTemp[i-1][j+1]);

            VYTemp[i][j] = (0.5f * VYTemp[i-1][j]) +
                           (0.5f * VYTemp[i-1][j+1]);
        }
    }

    for (j = 0; j <=3; j++)
    {
        pflLeftXComponents[j] = VXTemp[j][0];
        pflLeftYComponents[j] = VYTemp[j][0];
        pflRightXComponents[j] = VXTemp[3-j][j];
        pflRightYComponents[j] = VYTemp[3-j][j];
    }
       
}

//*****************************************************************************

HRESULT
CPathCurve::createCurveSegments(float *pflXComponents,
                                 float *pflYComponents,
                                 float *pflLength,
                                 float flTolerance)                                 
{
    HRESULT hr = S_OK;
    float flBezLength = 0.0f;
    float flChordLength = 0.0f;

    for (int i = 0; i <= 2; i++)
        flBezLength += DistanceBetweenTwoPoints(pflXComponents[i],
                                                pflYComponents[i],
                                                pflXComponents[i+1],
                                                pflYComponents[i+1]);
    flChordLength = DistanceBetweenTwoPoints(pflXComponents[0],
                                             pflYComponents[0],
                                             pflXComponents[3],
                                             pflYComponents[3]);
    if ((flBezLength - flChordLength) > flTolerance)
    {
        float rgflLeftXComponents[4];
        float rgflLeftYComponents[4];
        float rgflRightXComponents[4];
        float rgflRightYComponents[4];
        SplitBezierComponents(pflXComponents, pflYComponents,
                              rgflLeftXComponents, rgflLeftYComponents,
                              rgflRightXComponents, rgflRightYComponents);
        hr = createCurveSegments(rgflLeftXComponents, rgflLeftYComponents,
                      pflLength, flTolerance);
        if (FAILED(hr))
        {
            return hr;
        }

        hr = createCurveSegments(rgflRightXComponents, rgflRightYComponents,
                      pflLength, flTolerance);
        if (FAILED(hr))
        {
            return hr;
        }
    }
    else
    {
        *pflLength += flBezLength;
        CPathLineSegment * pSegment = new CPathLineSegment;
        if (NULL == pSegment)
            return E_OUTOFMEMORY;

        if (NULL == m_pListHead)
            m_pListHead = pSegment;
        else
            m_pListTail->m_pNext = pSegment;
        m_pListTail = pSegment;
        m_segCount++;
        pSegment->SetValues(pflXComponents[0], pflYComponents[0], pflXComponents[3], pflYComponents[3]);
        
    }
    return S_OK;
}

//*****************************************************************************

float 
CPathCurve::Distance()
{
    return m_flDistance;
} // Distance

//*****************************************************************************
HRESULT 
CPathCurve::SetValues(float flStartX, 
                      float flStartY, 
                      float flControl1X,
                      float flControl1Y,
                      float flControl2X,
                      float flControl2Y,
                      float flEndX, 
                      float flEndY)
{
    m_flStartX = flStartX;
    m_flStartY = flStartY;
    m_flControl1X = flControl1X;
    m_flControl1Y = flControl1Y;
    m_flControl2X = flControl2X;
    m_flControl2Y = flControl2Y;
    m_flEndX = flEndX;
    m_flEndY = flEndY;

    float rgflXComponents[4] = {m_flStartX,
                                m_flControl1X,
                                m_flControl2X,
                                m_flEndX};
    float rgflYComponents[4] = {m_flStartY,
                                m_flControl1Y,
                                m_flControl2Y,
                                m_flEndY};
    return createCurveSegments(rgflXComponents, rgflYComponents, &m_flDistance, TOLERANCE);
}; // SetValues

//*****************************************************************************

HRESULT 
CPathCurve::BuildTransform(IDA2Statics *pDAStatics,
                           IDANumber *pbvrProgress, 
                           float flStartPercentage,
                           float flEndPercentage,
                           IDATransform2 **ppbvrResult)
{
    HRESULT hr = E_FAIL;
    DASSERT(ppbvrResult != NULL);
    *ppbvrResult = NULL;
    int ptcount  = 0;
    int i        = 0;
#ifdef _DEBUG
    int numSegs  = 0;
#endif
    
    CComPtr<IDAPath2>	ppCompletePath;
    CComPtr<IDANumber>	pbvrNormalizedProgress;
    CPathElement        *pSegment = m_pListHead;

    SAFEARRAY * saPoints = SafeArrayCreateVector(VT_R8, 0, (m_segCount+1)* 2);
    SAFEARRAY * saCodes  = SafeArrayCreateVector(VT_R8, 0, (m_segCount+1));

    if (!saPoints || !saCodes)
    {
        goto done;
    }

    VARIANT varPoints;
    VARIANT varCodes;
	
    double *pdblPoints;
    double *pdblCodes;

    VariantInit(&varPoints);
    VariantInit(&varCodes);

    V_ARRAY(&varPoints) = saPoints;
    varPoints.vt = VT_ARRAY | VT_R8;

    V_ARRAY(&varCodes) = saCodes;
    varCodes.vt  = VT_ARRAY | VT_R8;

    pdblPoints = (double *)saPoints->pvData;
    pdblCodes  = (double *)saCodes->pvData;

    // Need to move to the starting point
    pdblCodes[0] = MOVETO;
    for(i=1;i < (m_segCount+1);i++)
        pdblCodes[i]  = LINETO;
   
    while (NULL != pSegment)
    {
       	CPathLineSegment *pLineSegment = reinterpret_cast<CPathLineSegment*>(pSegment);
        if(ptcount == 0)
        {
            // Need to set the starting point
            pdblPoints[ptcount++] = pLineSegment->m_flStartX;
            pdblPoints[ptcount++] = pLineSegment->m_flStartY;
        }

        pdblPoints[ptcount++] = pLineSegment->m_flEndX;
        pdblPoints[ptcount++] = pLineSegment->m_flEndY;
		
        pSegment = pSegment->m_pNext;
#ifdef _DEBUG
        numSegs++;
#endif
    }

#ifdef _DEBUG
	LMTRACE( "created a transform for a path with %d segments\n", numSegs);
#endif
  
    hr = pDAStatics->PolydrawPath(varPoints,varCodes ,&ppCompletePath);
    if(FAILED(hr))
    {
        DPF_ERR("Error creating path");
        goto done;
    }

    hr = NormalizeProgressValue(pDAStatics,
                                pbvrProgress,
                                flStartPercentage,
                                flEndPercentage,
                                &pbvrNormalizedProgress);
    
    if (FAILED(hr))
    {
        DPF_ERR("Error normalizing progress");
        goto done;
    }
    
    hr = pDAStatics->FollowPathEval(ppCompletePath, pbvrNormalizedProgress, ppbvrResult);

done:
    if (saPoints)
    {
        SafeArrayDestroy(saPoints);
    }

    if (saCodes)
    {
        SafeArrayDestroy(saCodes);
    }

    return hr;
}

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\number.cpp ===
//*****************************************************************************
//
// File:    numberbvr.cpp
// Author:  jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of CNumberBvr object which implements
//			 the chromeffects Number DHTML behavior
//
// Modification List:
// Date		Author		Change
// 09/26/98	jeffort		Created this file
// 10/16/98 jeffort     Added animates property
// 10/16/98 jeffort     Renamed functions
// 11/16/98 jeffort     implemented expression attribute
// 11/17/98 kurtj       moved to actor construction
//*****************************************************************************

#include "headers.h"

#include "number.h"
#include "attrib.h"
#include "dautil.h"

#undef THIS
#define THIS CNumberBvr
#define SUPER CBaseBehavior

#include "pbagimp.cpp"

// These are used for the IPersistPropertyBag2 as it is implemented
// in the base class.  This takes an array of BSTR's, gets the
// attributes, queries this class for the variant, and copies
// the result.  The order of these defines is important

#define VAR_FROM        0
#define VAR_TO          1
#define VAR_BY          2
#define VAR_TYPE		3
#define VAR_MODE		4
#define VAR_PROPERTY    5
WCHAR * CNumberBvr::m_rgPropNames[] = {
                                     BEHAVIOR_PROPERTY_FROM,
                                     BEHAVIOR_PROPERTY_TO,
                                     BEHAVIOR_PROPERTY_BY,
									 BEHAVIOR_PROPERTY_TYPE,
									 BEHAVIOR_PROPERTY_MODE,
                                     BEHAVIOR_PROPERTY_PROPERTY
                                    };

//*****************************************************************************

CNumberBvr::CNumberBvr() :
	m_pdispActor( NULL ),
	m_lCookie( 0 )
{
    VariantInit(&m_varFrom);
    VariantInit(&m_varTo);
    VariantInit(&m_varBy);
	VariantInit(&m_varType);
	VariantInit(&m_varMode);
    VariantInit(&m_varExpression);
    VariantInit(&m_varBeginProperty);
    VariantInit(&m_varProperty);
    m_clsid = CLSID_CrNumberBvr;
} // CNumberBvr

//*****************************************************************************

CNumberBvr::~CNumberBvr()
{
    VariantClear(&m_varFrom);
    VariantClear(&m_varTo);
    VariantClear(&m_varBy);
	VariantClear(&m_varType);
	VariantClear(&m_varMode);
    VariantClear(&m_varExpression);
    VariantClear(&m_varBeginProperty);
    VariantClear(&m_varProperty);

    ReleaseInterface( m_pdispActor );
} // ~NumberBvr

//*****************************************************************************

HRESULT CNumberBvr::FinalConstruct()
{
    HRESULT hr = SUPER::FinalConstruct();
    if (FAILED(hr))
    {
        DPF_ERR("Error in number behavior FinalConstruct initializing base classes");
        return hr;
    }
    return S_OK;
} // FinalConstruct

//*****************************************************************************

VARIANT *
CNumberBvr::VariantFromIndex(ULONG iIndex)
{
    DASSERT(iIndex < NUM_MOVE_PROPS);
    switch (iIndex)
    {
    case VAR_FROM:
        return &m_varFrom;
        break;
    case VAR_TO:
        return &m_varTo;
        break;
    case VAR_BY:
        return &m_varBy;
        break;
	case VAR_TYPE:
		return &m_varType;
		break;
	case VAR_MODE:
		return &m_varMode;
		break;
    case VAR_PROPERTY:
        return &m_varProperty;
        break;
    default:
        // We should never get here
        DASSERT(false);
        return NULL;
    }
} // VariantFromIndex

//*****************************************************************************

HRESULT 
CNumberBvr::GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames)
{
    *pulProperties = NUM_NUMBER_PROPS;
    *pppPropNames = m_rgPropNames;
    return S_OK;
} // GetPropertyBagInfo

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::Init(IElementBehaviorSite *pBehaviorSite)
{
	return SUPER::Init(pBehaviorSite);
} // Init

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::Notify(LONG event, VARIANT *pVar)
{
	HRESULT hr = SUPER::Notify(event, pVar);
	CheckHR( hr, "Notify in base class failed", end);

	switch( event )
	{
	case BEHAVIOREVENT_CONTENTREADY:
		DPF_ERR("Got Content Ready");
			
		{
			hr = RequestRebuild( );
			CheckHR( hr, "Request for rebuild failed", end );
			
		}break;
    case BEHAVIOREVENT_DOCUMENTREADY:
		break;
    case BEHAVIOREVENT_APPLYSTYLE:
		DPF_ERR("Got ApplyStyle");
		break;
    case BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE:
		DPF_ERR("Got Document context change");
		break;
	default:
		DPF_ERR("Unknown event");
	}

end:
	
	return hr;
} // Notify

//*****************************************************************************

STDMETHODIMP
CNumberBvr::Detach()
{
	HRESULT hr = SUPER::Detach();
	if( FAILED( hr ) )
	{
		DPF_ERR( "Failure in detach of superclass" );
	}

	hr = RemoveFragment();
	CheckHR( hr, "Failed to remove the behavior fragment from the actor", end );

end:
	return hr;
} // Detach 

//*****************************************************************************

STDMETHODIMP
CNumberBvr::put_animates(VARIANT varAnimates)
{
    return SUPER::SetAnimatesProperty(varAnimates);
} // put_animates

//*****************************************************************************

STDMETHODIMP
CNumberBvr::get_animates(VARIANT *pRetAnimates)
{
    return SUPER::GetAnimatesProperty(pRetAnimates);
} // get_animates

//*****************************************************************************

STDMETHODIMP
CNumberBvr::put_from(VARIANT varFrom)
{
    HRESULT hr = VariantCopy(&m_varFrom, &varFrom);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting from for CNumberBvr");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRNUMBERBVR_FROM);
} // put_from

//*****************************************************************************

STDMETHODIMP
CNumberBvr::get_from(VARIANT *pRetFrom)
{
    if (pRetFrom == NULL)
    {
        DPF_ERR("Error in number:get_from, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetFrom, &m_varFrom);
} // get_from

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::put_to(VARIANT varTo)
{
    HRESULT hr = VariantCopy(&m_varTo, &varTo);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting to for CNumberBvr");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    return NotifyPropertyChanged(DISPID_ICRNUMBERBVR_TO);
} // put_to

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::get_to(VARIANT *pRetTo)
{
    if (pRetTo == NULL)
    {
        DPF_ERR("Error in number:get_to, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetTo, &m_varTo);
} // get_to

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::put_expression(VARIANT varExpression)
{
    HRESULT hr = VariantCopy(&m_varExpression, &varExpression);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting expression for CNumberBvr");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRNUMBERBVR_EXPRESSION);
} // put_expression

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::get_expression(VARIANT *pRetExpression)
{
    if (pRetExpression == NULL)
    {
        DPF_ERR("Error in number:get_expression, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetExpression, &m_varExpression);
} // get_expression

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::put_by(VARIANT varBy)
{
    HRESULT hr = VariantCopy(&m_varBy, &varBy);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting by for CNumberBvr");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRNUMBERBVR_BY);
} // put_by

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::get_by(VARIANT *pRetBy)
{
    if (pRetBy == NULL)
    {
        DPF_ERR("Error in number:get_by, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetBy, &m_varBy);
} // get_by

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::put_type(VARIANT varType)
{
    HRESULT hr = VariantCopy(&m_varType, &varType);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting type for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRNUMBERBVR_TYPE);
} // put_type

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::get_type(VARIANT *pRetType)
{
    if (pRetType == NULL)
    {
        DPF_ERR("Error in get_type, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetType, &m_varType);
} // get_type

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::put_mode(VARIANT varMode)
{
    HRESULT hr = VariantCopy(&m_varMode, &varMode);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting mode for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRNUMBERBVR_MODE);
} // put_mode

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::get_mode(VARIANT *pRetMode)
{
    if (pRetMode == NULL)
    {
        DPF_ERR("Error in get_mode, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetMode, &m_varMode);
} // get_mode

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::put_property(VARIANT varProperty)
{
    HRESULT hr = VariantCopy(&m_varProperty, &varProperty);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting property for CNumberBvr");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRNUMBERBVR_PROPERTY);
} // put_property

//*****************************************************************************

STDMETHODIMP 
CNumberBvr::get_property(VARIANT *pRetProperty)
{
    if (pRetProperty == NULL)
    {
        DPF_ERR("Error in number:get_property, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetProperty, &m_varProperty);
} // get_property

//*****************************************************************************

STDMETHODIMP
CNumberBvr::get_beginProperty(VARIANT *pRetBeginProperty)
{
    if (pRetBeginProperty == NULL)
    {
        DPF_ERR("Error in number:get_beginProperty, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetBeginProperty, &m_varBeginProperty);
} // get_beginProperty

//*****************************************************************************

STDMETHODIMP
CNumberBvr::buildBehaviorFragments( IDispatch* pActorDisp )
{
	HRESULT hr;

	hr = RemoveFragment();
	if( FAILED( hr ) )
	{
		DPF_ERR( "could not remove the old fragment from the actor" );
		return hr;
	}
	
    hr = CUtils::InsurePropertyVariantAsBSTR(&m_varProperty);
    if (FAILED(hr))
    {
        DPF_ERR("Error, property attribute for number behavior not set");
        return SetErrorInfo(E_INVALIDARG);
    }

	ActorBvrFlags flags = e_Absolute;
    IDANumber *pbvrFinalElementNumber = NULL;
#ifndef EXPRESSION_BUG_FIXED
    if (false)
    {
#else
    hr = CUtils::InsurePropertyVariantAsBSTR(&m_varExpression);
    if (SUCCEEDED(hr))
    {
        // we need to build a DA behavior for the number and hook it so
        // we can update it at tick time
        float flValue;
        hr = EvaluateScriptExpression(m_varExpression.bstrVal, flValue);
        if (FAILED(hr))
        {
            DPF_ERR("Error evaulating expression for first sample");
            return hr;
        }
        IDANumber *pbvrNum;
        hr = CDAUtils::GetDANumber(GetDAStatics(), flValue, &pbvrNum);
        if (FAILED(hr))
        {
            DPF_ERR("Error creating DA number");
            return SetErrorInfo(hr);
        }
        IDABehavior *pbvrHooked;
        hr = pbvrNum->Hook(this, &pbvrHooked);
        ReleaseInterface(pbvrNum);
        if (FAILED(hr))
        {
            DPF_ERR("Error hooking behavior");
            return SetErrorInfo(hr);
        }
        hr = pbvrHooked->QueryInterface(IID_TO_PPV(IDANumber, &pbvrFinalElementNumber));
        ReleaseInterface(pbvrHooked);
        if (FAILED(hr))
        {
            DPF_ERR("Error QI'ing behavior for IDANumber");
            return SetErrorInfo(hr);
        }
#endif // EXPRESSION_BUG_FIXED
    }
    else
    {

		float flFrom, flTo;

		hr = CUtils::InsurePropertyVariantAsFloat(&m_varFrom);
		if (FAILED(hr))
		{
			// There was no from, there could be a by attribute
			hr = CUtils::InsurePropertyVariantAsFloat(&m_varBy);
			if (FAILED(hr))
			{
				hr = CUtils::InsurePropertyVariantAsFloat(&m_varTo);

				if (FAILED(hr))
				{
					// Nothing we can do
					return hr;
				}

				// We have a to but no from.  This means we need to get the
				// to value from the actor
				IDABehavior *pFromBvr;
				hr = GetBvrFromActor(pActorDisp, V_BSTR(&m_varProperty), e_From, e_Number, &pFromBvr);
				if (FAILED(hr))
					return hr;

				IDANumber *pFrom;
				hr = pFromBvr->QueryInterface(IID_TO_PPV(IDANumber, &pFrom));
				ReleaseInterface(pFromBvr);
				if (FAILED(hr))
					return hr;

				IDANumber *pTo;
				hr = GetDAStatics()->DANumber(m_varTo.fltVal, &pTo);
				if (FAILED(hr))
				{
					ReleaseInterface(pFrom);
					return hr;
				}

				hr = BuildTIMEInterpolatedNumber(pFrom, pTo, &pbvrFinalElementNumber);
				ReleaseInterface(pFrom);
				ReleaseInterface(pTo);
				if (FAILED(hr))
					return hr;

				flags = e_AbsoluteAccum;
			}
			else
			{
				// Create a relative number from 0 to by
				flFrom = 0;
				flTo = m_varBy.fltVal;
				flags = e_RelativeAccum;
			}
		}
		else
		{
			// We got a valid from value
			flFrom = m_varFrom.fltVal;
			flags = e_Absolute;

			hr = CUtils::InsurePropertyVariantAsFloat(&m_varTo);
			if (FAILED(hr))
			{
				// there was no valid to attribute specified, try for a by attribute
				hr = CUtils::InsurePropertyVariantAsFloat(&m_varBy);
				if (FAILED(hr))
				{
					DPF_ERR("Inappropriate set of attributes");
					return SetErrorInfo(hr);
				}
				flTo = flFrom + m_varBy.fltVal;
			}
			else
			{
				flTo = m_varTo.fltVal;
			}
		}

		if (pbvrFinalElementNumber == NULL)
		{
			// We need to build a number behavior from from and to
			hr = BuildTIMEInterpolatedNumber(flFrom,
											 flTo,
											 &pbvrFinalElementNumber);
			if (FAILED(hr))
			{
				DPF_ERR("Error building interpolated number");
				return hr;
			}
		}
	}

    DASSERT(pbvrFinalElementNumber != NULL);

	IDispatch *pdispThis = NULL;
	hr = GetHTMLElementDispatch( &pdispThis );
	if( FAILED( hr ) )
	{
		DPF_ERR("Failed to get the dispatch from the element" );
		ReleaseInterface( pbvrFinalElementNumber );
		return hr;
	}
	
	hr = AttachBehaviorToActorEx( pActorDisp, 
								  pbvrFinalElementNumber, 
								  V_BSTR(&m_varProperty), 
								  FlagFromTypeMode(flags, &m_varType, &m_varMode), 
								  e_Number,
								  pdispThis,
								  &m_lCookie);

	ReleaseInterface( pdispThis );
    ReleaseInterface(pbvrFinalElementNumber);
    if (FAILED(hr))
    {
        DPF_ERR("Error applying number behavior to object");
        return hr;
    }

    m_pdispActor = pActorDisp;
    m_pdispActor->AddRef();

    return S_OK;
}

//*****************************************************************************

HRESULT 
CNumberBvr::EvaluateScriptExpression(WCHAR *wzScript, float &flReturn)
{

    HRESULT hr;
    IHTMLElement *pElement;

    pElement = GetHTMLElement();
    DASSERT(pElement != NULL);

    IDispatch *pDisp;
    hr = pElement->get_document(&pDisp);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting docuemnt form HTML element");
        return SetErrorInfo(hr);
    }

    IHTMLDocument2 *pDoc;
    hr = pDisp->QueryInterface(IID_TO_PPV(IHTMLDocument2, &pDoc));
    ReleaseInterface(pDisp);
    if (FAILED(hr))
    {
        DPF_ERR("error QI'ng for Document2");
        return SetErrorInfo(hr);
    }


    IDispatch *pscriptEng = NULL;
    hr = pDoc->get_Script( &pscriptEng );
    ReleaseInterface(pDoc);
    if (FAILED(hr))
    {
        DPF_ERR("Error obtianing script object from document");
        return SetErrorInfo(hr);
    }

    OLECHAR *rgNames[] = {L"eval"};
    DISPID   dispidEval = 0u;
    hr = pscriptEng->GetIDsOfNames(IID_NULL,
                                   rgNames,
                                   1,
                                   LOCALE_SYSTEM_DEFAULT,
                                   &dispidEval);
    if (FAILED(hr))
    {
        DPF_ERR("Error calling GetIDsOfNames on scripting object");
        ReleaseInterface(pscriptEng);
        return SetErrorInfo(hr);
    }

    DISPPARAMS      dispParams = {0};
    VARIANTARG      rgvargs[1];
    VARIANT         varResult = {0};
    EXCEPINFO       xinfo = {0};                        
    unsigned int    idxParamErr = 0u;

    VariantInit( &rgvargs[0] );
    rgvargs[0].vt = VT_BSTR;
    rgvargs[0].bstrVal = wzScript;
    dispParams.rgvarg = rgvargs;
    dispParams.cArgs  = 1;                        

    VariantInit(&varResult);
    hr = pscriptEng->Invoke(dispidEval,
                            IID_NULL,
                            LOCALE_SYSTEM_DEFAULT,
                            DISPATCH_METHOD,
                            &dispParams,
                            &varResult,
                            &xinfo,
                            &idxParamErr);
    ReleaseInterface(pscriptEng);
    if (FAILED(hr))
    {
        DPF_ERR("Error callin ginvoke on scripting engine");
        return SetErrorInfo(hr);
    }
    hr = CUtils::InsurePropertyVariantAsFloat(&varResult);
    if (FAILED(hr))
    {
        DPF_ERR("Error expression does not evaluate to a float");
        return SetErrorInfo(hr);
    }
    flReturn = varResult.fltVal;
    return S_OK;
} // EvaluateScriptExpression

//*****************************************************************************

HRESULT 
CNumberBvr::BuildAnimationAsDABehavior()
{
//depricated
	return S_OK;
} // BuildAnimationAsDABehavior

//*****************************************************************************

HRESULT 
CNumberBvr::Notify(LONG id,
                   VARIANT_BOOL startingPerformance,
                   double startTime,
                   double gTime,
                   double lTime,
                   IDABehavior *sampleVal,
                   IDABehavior *curRunningBvr,
                   IDABehavior **ppBvr)
{
    HRESULT hr;
    float flValue;
    // If we get here, then the behavior must have been set up
    // for handling an expression, therefor, the expression
    // must be valid.  Assert this here
    DASSERT(m_varExpression.vt == VT_BSTR);
    DASSERT(m_varExpression.bstrVal != NULL);

    hr = EvaluateScriptExpression(m_varExpression.bstrVal, flValue);
    if (FAILED(hr))
    {
        DPF_ERR("Error evaulating expression for first sample");
        return hr;
    }
    IDANumber *pbvrNum;
    hr = CDAUtils::GetDANumber(GetDAStatics(), flValue, &pbvrNum);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating DA number");
        return SetErrorInfo(hr);
    }
    *ppBvr = pbvrNum;
    return S_OK;

} // Notify

//*****************************************************************************

HRESULT
CNumberBvr::RemoveFragment()
{
	HRESULT hr = S_OK;
	
	if( m_pdispActor != NULL && m_lCookie != 0 )
	{
		hr  = RemoveBehaviorFromActor( m_pdispActor, m_lCookie );
		ReleaseInterface( m_pdispActor );
		m_lCookie = 0;
		CheckHR( hr, "Failed to remove a fragment from the actor", end );
	}

end:

	return hr;
}


//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\pbagimp.cpp ===
//*****************************************************************************
//
// File: pbagimp.cpp
// Author: jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of IPersistPropertyBag2 interface
//           for all objects to call to base class.
//
// Modification List:
// Date		Author		Change
// 11/21/98	jeffort		Created this file
//
//*****************************************************************************

STDMETHODIMP 
THIS::GetClassID(CLSID* pclsid)
{
    return SUPER::GetClassID(pclsid);
} // GetClassID

//*****************************************************************************

STDMETHODIMP 
THIS::InitNew(void)
{
    return SUPER::InitNew();
} // InitNew

//*****************************************************************************

STDMETHODIMP 
THIS::Load(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog)
{
    return SUPER::Load(pPropBag, pErrorLog);
} // Load

//*****************************************************************************

STDMETHODIMP 
THIS::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    return SUPER::Save(pPropBag, fClearDirty, fSaveAllProperties);

} // Save 

//*****************************************************************************

HRESULT 
THIS::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\pellipse.cpp ===
//*****************************************************************************
//
// File:    pathange.cpp
// Author:  jeff wall
// Date Created: 11/09/98
//
// Abstract: Implementation of CPathEllipse object
//
// Modification List:
// Date		Author		Change
// 11/09/98	jeffwall Created this file
//
//
//*****************************************************************************

#include "headers.h"

#include "pellipse.h"
#include "dautil.h"

//*****************************************************************************

CPathEllipse::CPathEllipse() :
    m_flHeight(0.0f),
    m_flWidth(0.0f),
    m_flStartAngle(0.0f),
    m_flSweep(0.0f),
    m_flCenterX(0.0f),
    m_flCenterY(0.0f),
    m_flDistance(0.0f)
{

} //CPathAngleElpise

//*****************************************************************************

CPathEllipse::~CPathEllipse()
{

} // ~CPathEllipse

//*****************************************************************************

float 
CPathEllipse::Distance()
{
    return m_flDistance;
}

float 
CPathEllipse::internalDistance()
{
    // Distance is curcumference of the ellipse, * (sweep / 360)
    // 
    // Perimeter == pi * (a + b) [ 1 + 1/4 * ((a - b)/(a + b))^2 + 1/64 * ((a - b)/(a + b))^4 + 1/256 * ((a - b)/(a + b))^6 + ...]
    // or 
    // Perimeter ~= pi * (a + b)/4 [ 3 * ( 1 + lamda ) + 1/(1-lamda) ] where lamda = [ (a-b)/(2 * (a+b) ) ]^2

    float flA = m_flWidth / 2.0f;
    float flB = m_flHeight / 2.0f;

    float flLamda = (float)pow( ( flA - flB ) / ( 2.0f * ( flA + flB) ), 2.0f );
    
    const float pi = 3.14159f;
    float flCircum = (pi * (flB + flA) / 4.0f ) * ( 3.0f * (1.0f + flLamda) + 1.0f / (1.0f - flLamda) );

    float flLength = flCircum * (m_flSweep / ( 2 * pi) );

    return flLength;
} // Distance

//*****************************************************************************
void
CPathEllipse::SetValues(float flCenterX, 
                      float flCenterY, 
                      float flWidth,
                      float flHeight,
                      float flStartAngle,
                      float flSweep,
                      float *flStartX,
                      float *flStartY,
                      float *flEndX,
                      float *flEndY)
{
    m_flCenterX = flCenterX;
    m_flCenterY = flCenterY;
    m_flWidth = flWidth;
    m_flHeight = flHeight;
    m_flStartAngle = flStartAngle;
    m_flSweep = flSweep;

    m_flDistance = (float) fabs(internalDistance());

    
    *flStartX = flCenterX + (m_flWidth / 2.0f) * (float) cos(flStartAngle);
    *flStartY = flCenterY + (m_flHeight / 2.0f) * (float) sin(flStartAngle);
    
    *flEndX = flCenterX + (m_flWidth / 2.0f) * (float) cos(flStartAngle + flSweep);
    *flEndY = flCenterY + (m_flHeight / 2.0f) * (float) sin(flStartAngle + flSweep);
}; // SetValues

//*****************************************************************************

HRESULT 
CPathEllipse::BuildTransform(IDA2Statics *pDAStatics,
                           IDANumber *pbvrProgress, 
                           float flStartPercentage,
                           float flEndPercentage,
                           IDATransform2 **ppbvrResult)
{
    DASSERT(pDAStatics != NULL);
    DASSERT(pbvrProgress != NULL);
    DASSERT(flStartPercentage >= 0.0f);
    DASSERT(flStartPercentage <= 1.0f);
    DASSERT(flEndPercentage >= 0.0f);
    DASSERT(flEndPercentage <= 1.0f);
    DASSERT(ppbvrResult != NULL);
    *ppbvrResult = NULL;

    HRESULT hr = S_OK;

    IDANumber *pbvrNormalizedProgress = NULL;
    IDANumber *pbvrX = NULL;
    IDANumber *pbvrY = NULL;
    IDANumber *pbvrStartAngle = NULL;
    IDANumber *pbvrSweep = NULL;
    IDANumber *pbvrPartialSweep = NULL;
    IDANumber *pbvrTheta = NULL;
    IDANumber *pbvrCos = NULL;
    IDANumber *pbvrA = NULL;
    IDANumber *pbvrMulX = NULL;
    IDANumber *pbvrCenterX = NULL;
    IDANumber *pbvrSin = NULL;
    IDANumber *pbvrB = NULL;
    IDANumber *pbvrMulY = NULL;
    IDANumber *pbvrCenterY = NULL;

    hr = NormalizeProgressValue(pDAStatics,
                                pbvrProgress,
                                flStartPercentage,
                                flEndPercentage,
                                &pbvrNormalizedProgress);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    DASSERT(pbvrNormalizedProgress != NULL);
    
    
    hr = CDAUtils::GetDANumber(pDAStatics, m_flStartAngle, &pbvrStartAngle);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    hr = CDAUtils::GetDANumber(pDAStatics, -1.0f * m_flSweep, &pbvrSweep);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    hr = pDAStatics->Mul(pbvrNormalizedProgress, pbvrSweep, &pbvrPartialSweep);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    hr = pDAStatics->Add(pbvrPartialSweep, pbvrStartAngle, &pbvrTheta);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    
    // Calculate X bvr
    hr = pDAStatics->Cos(pbvrTheta, &pbvrCos);
    if (FAILED(hr))
    {
        goto cleanup;
    }
        
    hr = CDAUtils::GetDANumber(pDAStatics, m_flWidth / 2.0f, &pbvrA);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    hr = pDAStatics->Mul(pbvrA, pbvrCos, &pbvrMulX);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    hr = CDAUtils::GetDANumber(pDAStatics, m_flCenterX, &pbvrCenterX);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    hr = pDAStatics->Add(pbvrMulX, pbvrCenterX, &pbvrX);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    // calculate Y bvr
    hr = pDAStatics->Sin(pbvrTheta, &pbvrSin);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    hr = CDAUtils::GetDANumber(pDAStatics, m_flHeight / 2.0f, &pbvrB);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    hr = pDAStatics->Mul(pbvrB, pbvrSin, &pbvrMulY);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    hr = CDAUtils::GetDANumber(pDAStatics, m_flCenterY, &pbvrCenterY);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    hr = pDAStatics->Add(pbvrMulY, pbvrCenterY, &pbvrY);
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    hr = CDAUtils::BuildMoveTransform2(pDAStatics,
        pbvrX,
        pbvrY,
        ppbvrResult);
    if (FAILED(hr))
    {
        goto cleanup;
    }

cleanup:
    ReleaseInterface(pbvrNormalizedProgress);
    ReleaseInterface(pbvrX);
    ReleaseInterface(pbvrY);
    ReleaseInterface(pbvrStartAngle);
    ReleaseInterface(pbvrSweep);
    ReleaseInterface(pbvrPartialSweep);
    ReleaseInterface(pbvrTheta);
    ReleaseInterface(pbvrCos);
    ReleaseInterface(pbvrA);
    ReleaseInterface(pbvrMulX);
    ReleaseInterface(pbvrCenterX);
    ReleaseInterface(pbvrSin);
    ReleaseInterface(pbvrB);
    ReleaseInterface(pbvrMulY);
    ReleaseInterface(pbvrCenterY);

    return hr;
} // BuildTransform



//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\pelement.cpp ===
//*****************************************************************************
//
// File:    pathelmt.cpp
// Author:  jeff wall
// Date Created: 11/09/98
//
// Abstract: Implementation of CPathElement object which implements
//
// Modification List:
// Date		Author		Change
// 11/09/98	jeffwall Created this file from path.cpp
//
//
//*****************************************************************************

#include "headers.h"

#include "pelement.h"
#include "dautil.h"

//*****************************************************************************

CPathElement::CPathElement() :
    m_pNext(NULL)
{
} // CPathElement 

//*****************************************************************************

CPathElement::~CPathElement() 
{
} // ~CPathElement 

//*****************************************************************************
HRESULT
CPathElement::NormalizeProgressValue(IDA2Statics *pDAStatics,
                                     IDANumber *pbvrProgress, 
                                     float flStartPercentage,
                                     float flEndPercentage,
                                     IDANumber **ppbvrReturn)
{

    DASSERT(pDAStatics != NULL);
    DASSERT(pbvrProgress != NULL);
    DASSERT(flStartPercentage >= 0.0f);
    DASSERT(flStartPercentage <= 1.0f);
    DASSERT(flEndPercentage >= 0.0f);
    DASSERT(flEndPercentage <= 1.0f);
    DASSERT(ppbvrReturn != NULL);
    *ppbvrReturn = NULL;
    
    HRESULT hr;

    if (flStartPercentage >= flEndPercentage)
    {
        DPF_ERR("Error, invalid percentage values");
        return E_INVALIDARG;
    }

    IDANumber *pbvrProgressRange;
    hr = CDAUtils::GetDANumber(pDAStatics, (flEndPercentage - flStartPercentage),
                               &pbvrProgressRange);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating DA number in CPathElement::NormalizeProgressValue");
        return hr;
    }
    DASSERT(pbvrProgressRange != NULL);

    IDANumber *pbvrStart;
    hr = CDAUtils::GetDANumber(pDAStatics, flStartPercentage, &pbvrStart);
    if (FAILED(hr))
    {
        DPF_ERR("Error creating DA number in CPathElement::NormalizeProgressValue");
        ReleaseInterface(pbvrProgressRange);
        return hr;
    }
    DASSERT(pbvrStart != NULL);
    IDANumber *pbvrSub;
    hr = pDAStatics->Sub(pbvrProgress, pbvrStart, &pbvrSub);
    ReleaseInterface(pbvrStart);
    if (FAILED(hr))
    {
        DPF_ERR("Error subtracting DA number in CPathElement::NormalizeProgressValue");
        ReleaseInterface(pbvrProgressRange);
        return hr;
    }
    DASSERT(pbvrSub != NULL);
    hr = pDAStatics->Div(pbvrSub, pbvrProgressRange, ppbvrReturn);
    ReleaseInterface(pbvrSub);
    ReleaseInterface(pbvrProgressRange);
    if (FAILED(hr))
    {
        DPF_ERR("Error Dividing DA numbers in CPathElement::NormalizeProgressValue");
        return hr;
    }
    return S_OK;
} // NormalizeProgressValue


//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\rotate.cpp ===
//*****************************************************************************
//
// File: rotate.cpp
// Author: jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of CRotateBvr object which implements
//			 the chromeffects rotate DHTML behavior
//
// Modification List:
// Date		Author		Change
// 09/26/98	jeffort		Created this file
// 10/16/98 jeffort     Added animates property
// 10/16/98 jeffort     Renamed functions, implemented building DA behavior
// 10/21/98 jeffort     changed code to use base class to build DA Number
//
//*****************************************************************************

#include "headers.h"

#include "rotate.h"
#include "attrib.h"
#include "dautil.h"

#undef THIS
#define THIS CRotateBvr
#define SUPER CBaseBehavior

#include "pbagimp.cpp"

// These are used for the IPersistPropertyBag2 as it is implemented
// in the base class.  This takes an array of BSTR's, gets the
// attributes, queries this class for the variant, and copies
// the result.  The order of these defines is important

#define VAR_FROM        0
#define VAR_TO          1
#define VAR_BY          2
#define VAR_TYPE		3
#define VAR_MODE		4

WCHAR * CRotateBvr::m_rgPropNames[] = {
                                     BEHAVIOR_PROPERTY_FROM,
                                     BEHAVIOR_PROPERTY_TO,
                                     BEHAVIOR_PROPERTY_BY,
									 BEHAVIOR_PROPERTY_TYPE,
									 BEHAVIOR_PROPERTY_MODE
                                    };

//*****************************************************************************

CRotateBvr::CRotateBvr():
	m_pdispActor( NULL ),
	m_lCookie( 0 )
{
    VariantInit(&m_varFrom);
    VariantInit(&m_varTo);
    VariantInit(&m_varBy);
	VariantInit(&m_varType);
	VariantInit(&m_varMode);
    m_clsid = CLSID_CrRotateBvr;
} // CRotateBvr

//*****************************************************************************

CRotateBvr::~CRotateBvr()
{
    VariantClear(&m_varFrom);
    VariantClear(&m_varTo);
    VariantClear(&m_varBy);
	VariantClear(&m_varType);
	VariantClear(&m_varMode);

	ReleaseInterface( m_pdispActor );
} // ~RotateBvr

//*****************************************************************************

HRESULT CRotateBvr::FinalConstruct()
{
    HRESULT hr = SUPER::FinalConstruct();
    if (FAILED(hr))
    {
        DPF_ERR("Error in rotate behavior FinalConstruct initializing base classes");
        return hr;
    }

    return S_OK;
} // FinalConstruct

//*****************************************************************************

VARIANT *
CRotateBvr::VariantFromIndex(ULONG iIndex)
{
    DASSERT(iIndex < NUM_ROTATE_PROPS);
    switch (iIndex)
    {
    case VAR_FROM:
        return &m_varFrom;
        break;
    case VAR_TO:
        return &m_varTo;
        break;
    case VAR_BY:
        return &m_varBy;
        break;
	case VAR_TYPE:
		return &m_varType;
		break;
	case VAR_MODE:
		return &m_varMode;
		break;
    default:
        // We should never get here
        DASSERT(false);
        return NULL;
    }
} // VariantFromIndex

//*****************************************************************************

HRESULT 
CRotateBvr::GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames)
{
    *pulProperties = NUM_ROTATE_PROPS;
    *pppPropNames = m_rgPropNames;
    return S_OK;
} // GetPropertyBagInfo

//*****************************************************************************

STDMETHODIMP 
CRotateBvr::Init(IElementBehaviorSite *pBehaviorSite)
{
	LMTRACE( L"Init for RotateBvr <%p>\n", this );
	return SUPER::Init(pBehaviorSite);
} // Init

//*****************************************************************************

STDMETHODIMP 
CRotateBvr::Notify(LONG event, VARIANT *pVar)
{
	HRESULT hr = SUPER::Notify(event, pVar);
	CheckHR( hr, "Notify in base class failed", end);

	switch( event )
	{
	case BEHAVIOREVENT_CONTENTREADY:
		DPF_ERR("Got Content Ready");
			
		{
			hr = RequestRebuild( );
			CheckHR( hr, "Request for rebuild failed", end );
			
		}break;
    case BEHAVIOREVENT_DOCUMENTREADY:
		break;
    case BEHAVIOREVENT_APPLYSTYLE:
		DPF_ERR("Got ApplyStyle");
		break;
    case BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE:
		DPF_ERR("Got Document context change");
		break;
	default:
		DPF_ERR("Unknown event");
	}

end:
	
	return hr;
} // Notify

//*****************************************************************************

STDMETHODIMP
CRotateBvr::Detach()
{
	HRESULT hr = SUPER::Detach();
	if( FAILED( hr ) )
	{
		DPF_ERR( "Failed in superclass detach" );
	}

	hr = RemoveFragment();
	CheckHR( hr, "Failed to remove the fragment from the actor ", end );

end:
	return hr;
} // Detach 

//*****************************************************************************

STDMETHODIMP
CRotateBvr::put_animates(VARIANT varAnimates)
{
    return SUPER::SetAnimatesProperty(varAnimates);
} // put_animates

//*****************************************************************************

STDMETHODIMP
CRotateBvr::get_animates(VARIANT *pRetAnimates)
{
    return SUPER::GetAnimatesProperty(pRetAnimates);
} // get_animates

//*****************************************************************************

STDMETHODIMP
CRotateBvr::put_from(VARIANT varFrom)
{
    HRESULT hr = VariantCopy(&m_varFrom, &varFrom);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting from for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRROTATEBVR_FROM);
} // put_from

//*****************************************************************************

STDMETHODIMP
CRotateBvr::get_from(VARIANT *pRetFrom)
{
    if (pRetFrom == NULL)
    {
        DPF_ERR("Error in CRotateBvr:get_from, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetFrom, &m_varFrom);
} // get_from

//*****************************************************************************

STDMETHODIMP 
CRotateBvr::put_to(VARIANT varTo)
{
    HRESULT hr = VariantCopy(&m_varTo, &varTo);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting to for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRROTATEBVR_TO);
} // put_to

//*****************************************************************************

STDMETHODIMP 
CRotateBvr::get_to(VARIANT *pRetTo)
{
    if (pRetTo == NULL)
    {
        DPF_ERR("Error in CRotateBvr:get_to, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetTo, &m_varTo);
} // get_to

//*****************************************************************************

STDMETHODIMP 
CRotateBvr::put_by(VARIANT varBy)
{
    HRESULT hr = VariantCopy(&m_varBy, &varBy);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting to for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRROTATEBVR_BY);
} // put_by

//*****************************************************************************

STDMETHODIMP 
CRotateBvr::get_by(VARIANT *pRetBy)
{
    if (pRetBy == NULL)
    {
        DPF_ERR("Error in CRotateBvr:get_by, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetBy, &m_varBy);
} // get_by

//*****************************************************************************

STDMETHODIMP 
CRotateBvr::put_type(VARIANT varType)
{
    HRESULT hr = VariantCopy(&m_varType, &varType);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting type for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRROTATEBVR_TYPE);
} // put_type

//*****************************************************************************

STDMETHODIMP 
CRotateBvr::get_type(VARIANT *pRetType)
{
    if (pRetType == NULL)
    {
        DPF_ERR("Error in get_type, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetType, &m_varType);
} // get_type

//*****************************************************************************

STDMETHODIMP 
CRotateBvr::put_mode(VARIANT varMode)
{
    HRESULT hr = VariantCopy(&m_varMode, &varMode);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting mode for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRROTATEBVR_MODE);
} // put_mode

//*****************************************************************************

STDMETHODIMP 
CRotateBvr::get_mode(VARIANT *pRetMode)
{
    if (pRetMode == NULL)
    {
        DPF_ERR("Error in get_mode, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetMode, &m_varMode);
} // get_mode

//*****************************************************************************

HRESULT 
CRotateBvr::BuildAnimationAsDABehavior()
{
	// TODO (markhal): This goes away soon
	return S_OK;
}

//*****************************************************************************

STDMETHODIMP
CRotateBvr::buildBehaviorFragments( IDispatch* pActorDisp )
{

	LMTRACE( L"buildBehaviorFragments for Rotate <%p>\n", this );
    HRESULT hr;

    hr = RemoveFragment();
    if( FAILED( hr ) )
    {
    	DPF_ERR( "Failed to remove fragment" );
    	return hr;
    }
    
    float flFrom, flTo;
	ActorBvrFlags flags = e_Absolute;
    IDANumber *pbvrInterpolatedAngle = NULL;

    hr = CUtils::InsurePropertyVariantAsFloat(&m_varFrom);
    if (FAILED(hr))
    {
		// There was no from, there could be a by attribute
		hr = CUtils::InsurePropertyVariantAsFloat(&m_varBy);
		if (FAILED(hr))
		{
			hr = CUtils::InsurePropertyVariantAsFloat(&m_varTo);

			if (FAILED(hr))
			{
				// Nothing we can do
				return hr;
			}

			// We have a to but no from.  This means we need to get the
			// to value from the actor
			IDABehavior *pFromBvr;
			hr = GetBvrFromActor(pActorDisp, L"style.rotation", e_From, e_Number, &pFromBvr);
			if (FAILED(hr))
				return hr;

			IDANumber *pFrom;
			hr = pFromBvr->QueryInterface(IID_TO_PPV(IDANumber, &pFrom));
			ReleaseInterface(pFromBvr);
			if (FAILED(hr))
				return hr;

			IDANumber *pTo;
			hr = GetDAStatics()->DANumber(m_varTo.fltVal, &pTo);
			if (FAILED(hr))
			{
				ReleaseInterface(pFrom);
				return hr;
			}

			hr = BuildTIMEInterpolatedNumber(pFrom, pTo, &pbvrInterpolatedAngle);
			ReleaseInterface(pFrom);
			ReleaseInterface(pTo);
			if (FAILED(hr))
				return hr;

			flags = e_AbsoluteAccum;
		}
		else
		{
			// Create a relative rotation from 0 to by
			flFrom = 0;
			flTo = m_varBy.fltVal;
			flags = e_RelativeAccum;
		}
	}
	else
	{
		// We got a valid from value
		flFrom = m_varFrom.fltVal;
		flags = e_Absolute;

		hr = CUtils::InsurePropertyVariantAsFloat(&m_varTo);
		if (FAILED(hr))
		{
			// there was no valid to attribute specified, try for a by attribute
			hr = CUtils::InsurePropertyVariantAsFloat(&m_varBy);
			if (FAILED(hr))
			{
				DPF_ERR("Inappropriate set of attributes");
				return SetErrorInfo(hr);
			}
			flTo = flFrom + m_varBy.fltVal;
		}
		else
		{
			flTo = m_varTo.fltVal;
		}
	}

	if (pbvrInterpolatedAngle == NULL)
	{
		// We need to build a rotate behavior from from and to
		hr = BuildTIMEInterpolatedNumber(flFrom,
										 flTo,
										 &pbvrInterpolatedAngle);
		if (FAILED(hr))
		{
			DPF_ERR("Error building interpolated angle");
			return hr;
		}
	}

/* Don't do this any more.  Just animate the style.rotation attribute
	// Convert to Radians
	IDANumber *pAngleRadians = NULL;
	hr = GetDAStatics()->ToRadians(pbvrInterpolatedAngle, &pAngleRadians);
	ReleaseInterface(pbvrInterpolatedAngle);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to convert to radians");
		return hr;
	}

	// Turn the rotation into an IDATransform2
	IDATransform2 *pTransform = NULL;
	hr = GetDAStatics()->Rotate2Anim(pAngleRadians, &pTransform);
	ReleaseInterface(pAngleRadians);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to created rotation transform");
		return hr;
	}

	// Send transform to actor
	hr = AttachBehaviorToActor( pActorDisp, pTransform, L"rotation", (relative?e_Relative:e_Absolute) , e_Rotation );
    if (FAILED(hr))
    {
        DPF_ERR("Error attaching rotation behavior to actor");
        return hr;
    }
*/
	IDispatch *pdispThis = NULL;
	hr = GetHTMLElementDispatch( &pdispThis );
	if( FAILED( hr ) )
	{
		DPF_ERR("Failed to get the dispatch of the element" );
		return hr;
	}

	// Send rotation to actor
	hr = AttachBehaviorToActorEx( pActorDisp, 
								  pbvrInterpolatedAngle, 
								  L"style.rotation", 
								  FlagFromTypeMode(flags, &m_varType, &m_varMode), 
								  e_Number,
								  pdispThis,
								  &m_lCookie);

	ReleaseInterface( pdispThis );
	
    if (FAILED(hr))
    {
        DPF_ERR("Error attaching rotation behavior to actor");
        return hr;
    }

    m_pdispActor = pActorDisp;
    m_pdispActor->AddRef();

    return S_OK;
}


//*****************************************************************************

HRESULT
CRotateBvr::RemoveFragment()
{
	HRESULT hr = S_OK;
	
	if( m_pdispActor != NULL && m_lCookie != 0 )
	{
		hr  = RemoveBehaviorFromActor( m_pdispActor, m_lCookie );
		ReleaseInterface( m_pdispActor );
		m_lCookie = 0;
		CheckHR( hr, "Failed to remove a fragment from the actor", end );
	}

end:

	return hr;
}

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\sampler.cpp ===
//*****************************************************************************
//
// File:            sampler.cpp
// Author:          kurtj
// Date Created:    11/10/98
//
// Abstract: Implementation of an object that abstracts away sampling of a behavior
//
//*****************************************************************************

#include "headers.h"

#include "sampler.h"
#include "..\chrome\include\utils.h"


//*****************************************************************************

CSampler::CSampler( ILMSample* target ) : m_target(target),
										  m_callback(NULL),
										  m_thisPtr(NULL),
                                          m_cRefs(1)
{
}

//*****************************************************************************

CSampler::CSampler( SampleCallback callback, void *thisPtr ) : m_target(NULL),
												m_callback(callback),
												m_thisPtr(thisPtr),
												m_cRefs(1)
{
}

//*****************************************************************************

CSampler::~CSampler()
{
}

//*****************************************************************************
// IUnknown Interface
//*****************************************************************************

STDMETHODIMP
CSampler::QueryInterface( REFIID riid, void** ppv )
{
    if( ppv == NULL )
        return E_POINTER;

    if( riid == IID_IDABvrHook )
    {
        (*ppv) = static_cast<IDABvrHook*>(this);
    }
    else
    {
        (*ppv) = NULL;
        return E_NOINTERFACE;
    }

    static_cast<IUnknown*>(*ppv)->AddRef();

    return S_OK;

}

//*****************************************************************************

STDMETHODIMP_(ULONG)
CSampler::AddRef()
{
    m_cRefs++;
    return m_cRefs;
}

//*****************************************************************************

STDMETHODIMP_(ULONG)
CSampler::Release()
{
    ULONG refs = --m_cRefs;

    if( refs == 0 )
        delete this;

    return refs;
}

//*****************************************************************************

STDMETHODIMP
CSampler::Invalidate()
{
    m_target = NULL;
	m_callback = NULL;
	m_thisPtr = NULL;
    static_cast<IUnknown*>(this)->Release();
    return S_OK;
}

//*****************************************************************************

STDMETHODIMP
CSampler::Attach( IDABehavior* bvrToHook, IDABehavior** result )
{
    if( bvrToHook == NULL || result == NULL )
        return E_POINTER;
    
    HRESULT hr = S_OK;

    hr = bvrToHook->Hook( static_cast<IDABvrHook*>(this), result );
    if( FAILED( hr ) )
    {
        DPF_ERR( "CSampler: could not hook behavior" );
    }

    return hr;
}

//*****************************************************************************
//IDABvrHook Interface
//*****************************************************************************

STDMETHODIMP     
CSampler::Notify( LONG id,
                  VARIANT_BOOL startingPerformance,
                  double startTime,
                  double gTime,
                  double lTime,
                  IDABehavior * sampleVal,
                  IDABehavior * curRunningBvr,
                  IDABehavior ** ppBvr)
{
	//continue with the current behavior
	(*ppBvr) = NULL;

    if( (m_target != NULL) && !startingPerformance )
    {
        m_target->Sample( startTime, gTime, lTime );
    }

	if ( m_callback != NULL && !startingPerformance)
	{
		(*m_callback)(m_thisPtr, id, startTime, gTime, lTime, sampleVal, ppBvr);
	}
    
    return S_OK;
}

//*****************************************************************************
// End of file
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\pmanager.cpp ===
//*****************************************************************************
//
// File:    pathcurv.cpp
// Author:  jeff wall
// Date Created: 11/09/98
//
// Abstract: Implementation of CPathManager object
//
// Modification List:
// Date		Author		Change
// 11/09/98	jeffwall Created this file from path.cpp
//
//
//*****************************************************************************

#include "headers.h"

#include "pmanager.h"
#include "dautil.h"

#include "pathline.h"
#include "pcurve.h"
#include "pellipse.h"

const float pi = 3.14159f;

//*****************************************************************************

CPathManager::CPathManager() :
    m_pPathHead(NULL),
    m_pPathTail(NULL),
    m_flEndX(0.0f),
    m_flEndY(0.0f),
    m_flStartX(0.0f),
    m_flStartY(0.0f)
{
}; // CPathManager

//*****************************************************************************

CPathManager::~CPathManager()
{
	DeletePathList();
    
} // ~CPathManager


void
CPathManager::DeletePathList()
{
	CPathElement *pDeleteList = m_pPathHead;
    while (pDeleteList != NULL)
    {
        CPathElement *pNext = pDeleteList->m_pNext;
        delete pDeleteList;
        pDeleteList = pNext;
    }
    m_pPathHead = NULL;
    m_pPathTail = NULL;

}

//*****************************************************************************

HRESULT
CPathManager::Initialize(BSTR bstrPath)
{
	DeletePathList();
	
    m_flEndX = 0.0f;
    m_flEndY = 0.0f;
    m_flStartX = 0.0f;
    m_flStartY = 0.0f;

    BSTR bstrParsePath = bstrPath;
    HRESULT hr;
    hr = S_OK;
    while (hr == S_OK)
    {
        CUtils::SkipWhiteSpace(&bstrParsePath);
        hr = ParseForPathElements(&bstrParsePath);
        if (FAILED(hr))
        {
            DPF_ERR("Error parsing for path elements");
            return hr;
        }
    }
    return S_OK;
} // Initialize

//*****************************************************************************

HRESULT 
CPathManager::ParseForPathElements(BSTR *pbstrPath)
{
    HRESULT hr;

    // we need to parse through for objects we know
    switch (**pbstrPath)
    {
    case (L'e'):
        m_flStartX = 0.0f;
        m_flStartY = 0.0f;
        m_flEndX = 0.0f;
        m_flEndY = 0.0f;
        break;

    case (L'm'):
        {
        // for the move to, we should have two floats which resets
        // the start X and Y and we reset our current end values to these
        // skip past the char
        (*pbstrPath)++;
        float flX;
        float flY;
        hr = CUtils::ParseFloatValueFromString(pbstrPath, &flX);
        if (hr != S_OK)
        {
            DPF_ERR("Error in path string: float value expected");
            return E_INVALIDARG;
        }
        hr = CUtils::ParseFloatValueFromString(pbstrPath, &flY);
        if (hr != S_OK)
        {
            DPF_ERR("Error in path string: float value expected");
            return E_INVALIDARG;
        }
        m_flStartX = flX;
        m_flStartY = flY;
        m_flEndX = flX;
        m_flEndY = flY;
        }
        break;

    case (L't'):
        {
        (*pbstrPath)++;
        float flX;
        float flY;
        hr = CUtils::ParseFloatValueFromString(pbstrPath, &flX);
        if (hr != S_OK)
        {
            DPF_ERR("Error in path string: float value expected");
            return E_INVALIDARG;
        }
        hr = CUtils::ParseFloatValueFromString(pbstrPath, &flY);
        if (hr != S_OK)
        {
            DPF_ERR("Error in path string: float value expected");
            return E_INVALIDARG;
        }
        m_flStartX += flX;
        m_flStartY += flY;
        m_flEndX += flX;
        m_flEndY += flY;
        }
        break;
    case (L'l'):
    case (L'r'):
        hr = ParseLineElement(pbstrPath);
        if (FAILED(hr))
        {
            DPF_ERR("Error creating line element");
            return hr;
        }
        hr = S_OK;
        break;

    case (L'c'):
    case (L'v'):
        hr = ParseCurveElement(pbstrPath);
        if (FAILED(hr))
        {
            DPF_ERR("Error creating curve element");
            return hr;
        }
        hr = S_OK;
        break;
    case (L'x'):
        // Skip Past the 'x' tag
        (*pbstrPath)++;
        CPathLineSegment *pLineSegment;
        pLineSegment = new CPathLineSegment;
        if (pLineSegment == NULL)
        {
            DPF_ERR("Error creating line segment object");
            return E_OUTOFMEMORY;
        }
        pLineSegment->SetValues(m_flEndX, m_flEndY, m_flStartX, m_flStartY);
        // and add this line segment to our list
        AddPathObjectToList(pLineSegment);
        m_flEndX = m_flStartX;
        m_flEndY = m_flStartY;
        hr = S_OK;

        break;
    case (L'a'):
    case (L'w'):
        wchar_t wcNext;
        (*pbstrPath)++;
        wcNext = (**pbstrPath);
        (*pbstrPath)--;
        switch(wcNext)
        {
        case (L'l'):
        case (L'e'):
            hr = ParseEllipseElement(pbstrPath);
            if (FAILED(hr))
            {
                DPF_ERR("Error creating ellipse element");
                return hr;
            }
            hr = S_OK;
            break;
        case (L't'):
        case (L'r'):
        case (L'a'):
            hr = ParseArcElement(pbstrPath);
            if (FAILED(hr))
            {
                DPF_ERR("Error creating arc element");
                return hr;
            }
            hr = S_OK;
            break;
        default:
            hr = S_FALSE;
            break;
        }
        break;
    case (L'q'):        
        (*pbstrPath)++;
        wcNext = (**pbstrPath);
        (*pbstrPath)--;
        switch(wcNext)
        {
        case (L'x'):
        case (L'y'):
            hr = ParseEllipseQuadrant(pbstrPath);
            if (FAILED(hr))
            {
                DPF_ERR("Error createing EllipseQuadrant");
                return hr;
            }
            hr = S_OK;
            break;
        case (L'b'):
            break;
        }
        break;
    default:
        hr = S_FALSE;
        break;
    }

    return hr;
} // ParseForPathElements

//*****************************************************************************

void 
CPathManager::AddPathObjectToList(CPathElement *pObject)
{
    DASSERT(pObject != NULL);
    if (m_pPathTail != NULL)
        m_pPathTail->m_pNext = pObject;
    else
        m_pPathHead = pObject;
     m_pPathTail = pObject;
     pObject->m_pNext = NULL;

} // AddPathObjectToList

//*****************************************************************************

HRESULT 
CPathManager::RecursiveBuildAllPathTransforms(IDA2Statics *pDAStatics,
                                          IDANumber *pbvrProgress,
                                          CPathElement *pPathObj,
                                          float flStartPercentage,
                                          float flTotalPercentage,
                                          float flTotalDistance,
                                          IDATransform2 **ppbvrResult)
{
    DASSERT(pDAStatics != NULL);
    DASSERT(pbvrProgress != NULL);
    DASSERT(pPathObj != NULL);
    DASSERT(flStartPercentage >= 0.0f);
    DASSERT(flStartPercentage <= 1.0f);
    DASSERT(flTotalPercentage >= 0.0f);
    DASSERT(flTotalPercentage <= 1.0f);
    DASSERT(ppbvrResult != NULL);
    *ppbvrResult = NULL;

    HRESULT hr;
    // first we build the transform for the current path element
    IDATransform2 *pbvrTransform;
    float flDistance = pPathObj->Distance();
    float flEndPercentage = flStartPercentage + (flTotalPercentage * (flDistance / flTotalDistance));
    hr = pPathObj->BuildTransform(pDAStatics,
                        pbvrProgress,
                        flStartPercentage,
                        flEndPercentage,
                        &pbvrTransform);
    if (pPathObj->m_pNext == NULL)
    {
        // we can simply return the built transform
        *ppbvrResult = pbvrTransform;
    }
    else
    {
        // we need to build a conditional by recursing in and getting
        // the next transform for the next object
        IDATransform2 *pbvrTransformNext;
        hr = RecursiveBuildAllPathTransforms(pDAStatics,
                                             pbvrProgress,
                                             pPathObj->m_pNext,
                                             flEndPercentage,
                                             flTotalPercentage,
                                             flTotalDistance,
                                             &pbvrTransformNext);
        if (FAILED(hr))
        {
            DPF_ERR("Error creating next transform");
            ReleaseInterface(pbvrTransform);
            return hr;
        }
        // now build the conditional for this
        IDANumber *pbvrEndProgress;
        hr = CDAUtils::GetDANumber(pDAStatics, flEndPercentage, &pbvrEndProgress);
        if (FAILED(hr))
        {
            DPF_ERR("Error getting DA number");
            ReleaseInterface(pbvrTransform);
            ReleaseInterface(pbvrTransformNext);
            return hr;
        }
        IDABoolean *pbvrBoolean;
        hr = pDAStatics->LTE(pbvrProgress, pbvrEndProgress, &pbvrBoolean);
        ReleaseInterface(pbvrEndProgress);
        if (FAILED(hr))
        {
            DPF_ERR("Error building boolean");
            ReleaseInterface(pbvrTransform);
            ReleaseInterface(pbvrTransformNext);
            return hr;
        }
        IDABehavior *pbvrReturn;
        hr = pDAStatics->Cond(pbvrBoolean, 
                              pbvrTransform, 
                              pbvrTransformNext, 
                              &pbvrReturn);
        ReleaseInterface(pbvrBoolean);
        ReleaseInterface(pbvrTransform);
        ReleaseInterface(pbvrTransformNext);
        if (FAILED(hr))
        {
            DPF_ERR("Error in calling DA Cond");
            return hr;
        }
        hr = pbvrReturn->QueryInterface(IID_TO_PPV(IDATransform2, ppbvrResult));
        ReleaseInterface(pbvrReturn);
        if (FAILED(hr))
        {
            DPF_ERR("Error QI'ing behavior for IDATranform2");
            return hr;
        }
    }
    return S_OK;
} // RecursiveBuildAllPathTransforms

//*****************************************************************************

HRESULT 
CPathManager::BuildTransform(IDA2Statics *pDAStatics,
                         IDANumber *pbvrProgress, 
                         float flStartPercentage,
                         float flEndPercentage,
                         IDATransform2 **ppbvrResult)
{

    DASSERT(pDAStatics != NULL);
    DASSERT(pbvrProgress != NULL);
    DASSERT(flStartPercentage >= 0.0f);
    DASSERT(flStartPercentage <= 1.0f);
    DASSERT(flEndPercentage >= 0.0f);
    DASSERT(flEndPercentage <= 1.0f);
    DASSERT(ppbvrResult != NULL);
    *ppbvrResult = NULL;



    HRESULT hr;

    // What we need to do is count the number of path objects
    // we have pointers to and use this to calculate the start
    // and end percentage of progress that each Path element
    // uses based on distance.  We then can get a transform
    // from each object and build a conditional using progress as below

    int cNumPathElements = 0;
    float flTotalDistance = 0.0f;
    CPathElement *pbvrList = m_pPathHead;
    while (pbvrList != NULL)
    {
        cNumPathElements++;
        flTotalDistance += pbvrList->Distance();
        pbvrList = pbvrList->m_pNext;
    }
    if (cNumPathElements == 0)
    {
        DPF_ERR("Error invalid path containing no elements");
        return E_INVALIDARG;
    }
    else if (cNumPathElements == 1)
    {
        // in the case of a single path element, we can simply
        // get its transform and return
        hr = m_pPathHead->BuildTransform(pDAStatics,
                                           pbvrProgress,
                                           flStartPercentage,
                                           flEndPercentage,
                                           ppbvrResult);
        if (FAILED(hr))
        {
            DPF_ERR("Error getting transform for single path element");
            return hr;
        }
    }
    else
    {
        hr = RecursiveBuildAllPathTransforms(pDAStatics,
                                             pbvrProgress,
                                             m_pPathHead,
                                             flStartPercentage,
                                             flEndPercentage - flStartPercentage,
                                             flTotalDistance,
                                             ppbvrResult);
        if (FAILED(hr))
        {
            DPF_ERR("Error recursively building transform");
            return hr;
        }
    }
    return S_OK;
} // BuildTransform

//*****************************************************************************

HRESULT 
CPathManager::ParseLineElement(BSTR *pbstrPath)
{
    HRESULT hr = S_OK;
    bool fRelativeLines = false;

    DASSERT(**pbstrPath == L'l' || **pbstrPath == L'r');
    if (**pbstrPath == L'r')
        fRelativeLines = true;
    // Skip Past the 'l' or 'r' tag
    (*pbstrPath)++;
    while (hr == S_OK && **pbstrPath != L'\0')
    {
        CUtils::SkipWhiteSpace(pbstrPath);
        float flX, flY;
        hr = CUtils::ParseFloatValueFromString(pbstrPath, &flX);
        if (FAILED(hr))
        {
            DPF_ERR("Error parsing line: float value expected");
            return hr;
        }
        hr = CUtils::ParseFloatValueFromString(pbstrPath, &flY);
        // this check is for more than just failed, we need to
        // insure that a y value came if an x value was set
        if (hr != S_OK)
        {
            DPF_ERR("Error parsing line: float value expected");
            return hr;
        }
        if (fRelativeLines)
        {
            flX += m_flEndX;
            flY += m_flEndY;
        }

        // create a new line segment
        CPathLineSegment *pLineSegment = new CPathLineSegment;
        if (pLineSegment == NULL)
        {
            DPF_ERR("Error creating line segment object");
            return E_OUTOFMEMORY;
        }
        pLineSegment->SetValues(m_flEndX, m_flEndY, flX, flY);
        // and add this line segment to our list
        AddPathObjectToList(pLineSegment);
        m_flEndX = flX;
        m_flEndY = flY;
    }
    return S_OK;
} // ParseLineElement

//*****************************************************************************

HRESULT 
CPathManager::ParseCurveElement(BSTR *pbstrPath)
{
    HRESULT hr = S_OK;
    bool fRelativeCurve = false;

    DASSERT(**pbstrPath == L'c' || **pbstrPath == L'v');
    if (**pbstrPath == L'v')
        fRelativeCurve = true;
    // Skip Past the 'v' or 'c' tag
    (*pbstrPath)++;
    while (hr == S_OK && **pbstrPath != L'\0')
    {
        CUtils::SkipWhiteSpace(pbstrPath);
        float flControl1X, flControl1Y;
        float flControl2X, flControl2Y;
        float flEndX, flEndY;
        hr = CUtils::ParseFloatValueFromString(pbstrPath, &flControl1X);
        if (hr != S_OK)
        {
            DPF_ERR("Error parsing curve: float value expected");
            return hr;
        }
        hr = CUtils::ParseFloatValueFromString(pbstrPath, &flControl1Y);
        if (hr != S_OK)
        {
            DPF_ERR("Error parsing curve: float value expected");
            return hr;
        }
        hr = CUtils::ParseFloatValueFromString(pbstrPath, &flControl2X);
        if (hr != S_OK)
        {
            DPF_ERR("Error parsing curve: float value expected");
            return hr;
        }
        hr = CUtils::ParseFloatValueFromString(pbstrPath, &flControl2Y);
        if (hr != S_OK)
        {
            DPF_ERR("Error parsing curve: float value expected");
            return hr;
        }
        hr = CUtils::ParseFloatValueFromString(pbstrPath, &flEndX);
        if (hr != S_OK)
        {
            DPF_ERR("Error parsing curve: float value expected");
            return hr;
        }
        hr = CUtils::ParseFloatValueFromString(pbstrPath, &flEndY);
        if (hr != S_OK)
        {
            DPF_ERR("Error parsing curve: float value expected");
            return hr;
        }
        if (fRelativeCurve)
        {
            flControl1X += m_flEndX;
            flControl1Y += m_flEndY;
            flControl2X += m_flEndX;
            flControl2Y += m_flEndY;
            flEndX += m_flEndX;
            flEndY += m_flEndY;
        }

        // create a new line segment
        CPathCurve *pCurve = new CPathCurve;
        if (pCurve == NULL)
        {
            DPF_ERR("Error creating curve object");
            return E_OUTOFMEMORY;
        }
        // and add this curve to our list
        AddPathObjectToList(pCurve);

        hr = pCurve->SetValues(m_flEndX, m_flEndY, 
                          flControl1X, flControl1Y,
                          flControl2X, flControl2Y,
                          flEndX, flEndY);
        if (FAILED(hr))
        {
            DPF_ERR("Error Parsing curve: error setting values");
            return hr;
        }

        m_flEndX = flEndX;
        m_flEndY = flEndY;
    }
    return S_OK;
} // ParseCurveElement

//*****************************************************************************

HRESULT 
CPathManager::ParseEllipseElement(BSTR *pbstrPath)
{
    HRESULT hr = S_OK;

    DASSERT(L'a' == **pbstrPath );

    // Skip Past the 'a' tag
    (*pbstrPath)++;
    
    DASSERT(L'l' == **pbstrPath || L'e' == **pbstrPath);
    
    bool fLineTo = false;
    if (L'e' == **pbstrPath)
    {
        // need to create a line seqment to here starting position
        fLineTo = true;
    }

    // skip path 'l' or 'e' tag
    (*pbstrPath)++;

    // Begin parsing the float values.

    CUtils::SkipWhiteSpace(pbstrPath);
    
    float flCenterX, flCenterY;
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flCenterX);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }
    
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flCenterY);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }
    
    float flWidth, flHeight;
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flWidth);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }
    if (flWidth < 0.0f)
    {
        return E_INVALIDARG;
    }
    
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flHeight);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }
    if (flHeight < 0.0f)
    {
        return E_INVALIDARG;
    }
    
    float flStartAngle, flSweep;
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flStartAngle);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }
    
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flSweep);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }
    
    float flStartX, flStartY;

    float flEndX, flEndY;
    
    CPathEllipse *pEllipse;
    pEllipse = new CPathEllipse;
    if (NULL == pEllipse)
    {
        DPF_ERR("Error creating ellipse object");
        return E_OUTOFMEMORY;
    }

    pEllipse->SetValues(flCenterX, flCenterY, flWidth, flHeight, flStartAngle, flSweep, &flStartX, &flStartY, &flEndX, &flEndY);
   
    if (fLineTo)
    {
        // create a new line segment
        CPathLineSegment *pLineSegment = new CPathLineSegment;
        if (pLineSegment == NULL)
        {
            DPF_ERR("Error creating line segment object");
            return E_OUTOFMEMORY;
        }
        pLineSegment->SetValues(m_flEndX, m_flEndY, flStartX, flStartY);
        
        // and add this line segment to our list
        AddPathObjectToList(pLineSegment);
    }
    
    AddPathObjectToList(pEllipse);
    
    m_flEndX = flEndX;
    m_flEndY = flEndY;
    
    
    return S_OK;
} // ParseEllipseElement

//*****************************************************************************

HRESULT 
CPathManager::ParseArcElement(BSTR *pbstrPath)
{
    HRESULT hr = S_OK;

    DASSERT(L'a' == **pbstrPath || L'w' == **pbstrPath);
    bool fCCW = true;
    if (L'w' == **pbstrPath)
    {
        fCCW = false;
    }

    // Skip Past the 'a' tag
    (*pbstrPath)++;
    
    DASSERT(L't' == **pbstrPath || L'r' == **pbstrPath || L'a' == **pbvrPath);
    
    bool fLineTo = false;
    if (L't' == **pbstrPath || L'a' == **pbstrPath)
    {
        // need to create a line seqment to here starting position
        fLineTo = true;
    }

    // skip path 'l' or 'e' tag
    (*pbstrPath)++;

    // Begin parsing the float values.

    CUtils::SkipWhiteSpace(pbstrPath);
    
    float flLeft, flTop;
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flLeft);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }
    
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flTop);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }
    
    float flRight, flBottom;
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flRight);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }

    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flBottom);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }

    float flStartX, flStartY;
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flStartX);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }
    
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flStartY);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }

    float flEndX, flEndY;
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flEndX);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }
    
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flEndY);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }
    
    CPathEllipse *pEllipse;
    pEllipse = new CPathEllipse;
    if (NULL == pEllipse)
    {
        DPF_ERR("Error creating ellipse object");
        return E_OUTOFMEMORY;
    }

    float flCenterX;
    flCenterX = (flLeft + flRight) / 2.0f;
    float flCenterY;
    flCenterY = (flTop + flBottom) / 2.0f;
    float flWidth;
    flWidth = (flRight - flLeft);
    float flHeight;
    flHeight = (flBottom - flTop);

    float flDeltaY, flDeltaX;
    flDeltaY = flStartY - flCenterY;
    flDeltaX = flStartX - flCenterX;

    float flStartAngle;
    GetAngle(flDeltaX, flDeltaY, &flStartAngle);
    DASSERT( flStartAngle >= 0.0f && flStartAngle < ( 2 * pi ) );

    flDeltaY = flEndY - flCenterY;
    flDeltaX = flEndX - flCenterX;

    float flEndAngle;
    GetAngle(flDeltaX, flDeltaY, &flEndAngle);
    DASSERT( flEndAngle >= 0.0f && flEndAngle < ( 2 * pi ) );

    float flSweep;
    if (fCCW)
    {
        if (flEndAngle > flStartAngle)
            // we are crossing over 0 radians
            flSweep = flStartAngle + (2 * pi) - flEndAngle;
        else
            flSweep = flStartAngle - flEndAngle;
    }
    else
    {
        if (flEndAngle > flStartAngle)
            flSweep = -1.0f * (flEndAngle - flStartAngle);
        else
            // crossing over 0 radians
            flSweep = -1.0f * (flEndAngle + (2 * pi) - flStartAngle);
    }
    pEllipse->SetValues(flCenterX, flCenterY, flWidth, flHeight, flStartAngle, flSweep, &flStartX, &flStartY, &flEndX, &flEndY);
   
    if (fLineTo)
    {
        // create a new line segment
        CPathLineSegment *pLineSegment = new CPathLineSegment;
        if (pLineSegment == NULL)
        {
            DPF_ERR("Error creating line segment object");
            return E_OUTOFMEMORY;
        }
        pLineSegment->SetValues(m_flEndX, m_flEndY, flStartX, flStartY);
        
        // and add this line segment to our list
        AddPathObjectToList(pLineSegment);
    }
    
    AddPathObjectToList(pEllipse);
    
    m_flEndX = flEndX;
    m_flEndY = flEndY;
    
    
    return S_OK;
} // ParseEllipseElement

//*****************************************************************************
HRESULT 
CPathManager::ParseEllipseQuadrant(BSTR *pbstrPath)
{
    HRESULT hr = S_OK;

    DASSERT(L'q' == **pbstrPath );

    // Skip Past the 'a' tag
    (*pbstrPath)++;
    
    DASSERT(L'x' == **pbstrPath || L'y' == **pbstrPath);

    bool fQuadrantX = true;
    if (L'y' == **pbstrPath)
    {
        fQuadrantX = false;
    }

    // skip path 'x' or 'y' tag
    (*pbstrPath)++;

    // Begin parsing the float values.

    CUtils::SkipWhiteSpace(pbstrPath);

    float flEndX, flEndY;
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flEndX);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }
    
    hr = CUtils::ParseFloatValueFromString(pbstrPath, &flEndY);
    if (S_OK != hr)
    {
        DPF_ERR("Error parsing Ellipse: float value expected");
        return hr;
    }
    
    CPathEllipse *pEllipse;
    pEllipse = new CPathEllipse;
    if (NULL == pEllipse)
    {
        DPF_ERR("Error creating ellipse object");
        return E_OUTOFMEMORY;
    }

    AddPathObjectToList(pEllipse);
    
    float flCenterX, flCenterY, flStartAngle, flSweep;
    
    if(fQuadrantX)
    {
        flCenterX = m_flEndX;
        flCenterY = flEndY;

        if ((flEndY - m_flEndY) > 0.0f)
        {
            // Positive deltaY
            flStartAngle = 3.0f * pi / 2.0f;
            if ((flEndX - m_flEndX) > 0.0f)
            {
                // Positive deltaX -- same as deltaY
                flSweep = pi / -2.0f;
            }
            else
            {
                // Negative deltaX -- different from deltaY
                flSweep = pi / 2.0f;
            }
        }
        else
        {
            // Negative deltaY
            flStartAngle = pi / 2.0f;
            if ((flEndX - m_flEndX) > 0.0f)
            {
                // positive deltaX -- different from deltaY
                flSweep = pi / 2.0f;
            }
            else
            {
                // negative deltaX -- same as deltaY
                flSweep = pi / -2.0f;
            }
            
        }
    } // if (fQuadrantX)
    else  // fQuadrantY
    {
        flCenterX = flEndX;
        flCenterY = m_flEndY;

        if ((flEndX - m_flEndX) > 0.0f)
        {
            // Positive deltaX
            flStartAngle = pi;
            if ((flEndY - m_flEndY) > 0.0f)
            {
                // positve deltaY -- same as deltaX
                flSweep = pi / 2.0f;
            }
            else
            {
                // negative deltaY -- different from deltaX
                flSweep = pi / -2.0f;
            }
        }
        else
        {
            // Negative deltaX
            flStartAngle = 0.0f;
            if ((flEndY - m_flEndY) > 0.0f)
            {
                // positve deltaY -- different from deltaX
                flSweep = pi / -2.0f;
            }
            else
            {
                // negative deltaY -- same as deltaX
                flSweep = pi / 2.0f;
            }
        }
    } // if (fQuadrantY)

    float flWidth = 2.0f * (float)fabs(m_flEndX - flEndX);
    float flHeight = 2.0f * (float)fabs(m_flEndY - flEndY);

    float flJunk;
    pEllipse->SetValues(flCenterX, flCenterY, flWidth, flHeight, flStartAngle, flSweep, &flJunk, &flJunk, &flJunk, &flJunk);
   
    m_flEndX = flEndX;
    m_flEndY = flEndY;
        
    return S_OK;
} // ParseEllipseQuadrant

//*****************************************************************************

float
CPathManager::Distance()
{
    float flTotalDistance = 0.0f;
    CPathElement *pList = m_pPathHead;
    while (pList != NULL)
    {
        flTotalDistance += pList->Distance();
        pList = pList->m_pNext;
    }
    return flTotalDistance;
} // Distance

//*****************************************************************************
// calculate the angle of the point(DeltaX, DeltaY), in radians: 0 <= ret < 2pi
//
void CPathManager::GetAngle(float flDeltaX, float flDeltaY, float *flAngle)
{
    const float EPSILON = 1e-5f;

    if (fabs(flDeltaX) < EPSILON)
    {
        // Point is on Y axis
        if (flDeltaY > 0.0f)
        {
            *flAngle = pi / 2.0f;
        }
        else
        {
            *flAngle = 3.0f * pi / 2.0f;
        }
        return;
    }
    if (fabs(flDeltaY) < EPSILON)
    {
        // Point is on X axis
        if (flDeltaX > 0.0f)
        {
            *flAngle = 0.0f;
        }
        else
        {
            *flAngle = pi;
        }
        return;
    }

    *flAngle = (float) atan( flDeltaY / flDeltaX );

    if (flDeltaY > 0.0f && flDeltaX > 0.0f)
    {
        //Quadrant I
        DASSERT(flAngle > 0.0f);
        return;
    }
    else if (flDeltaY > 0.0f && flDeltaX < 0.0f)
    {
        //Quadrant II
        DASSERT(flAngle < 0.0f);
        *flAngle += pi;
        return;
    }
    else if (flDeltaY < 0.0f && flDeltaX < 0.0f)
    {
        //Quadrant III
        DASSERT(flAngle > 0.0f);
        *flAngle += pi;
        return;
    }
    else if (flDeltaY < 0.0f && flDeltaX > 0.0f)
    {
        //Quadrant IV
        DASSERT(flAngle < 0.0f);
        *flAngle += 2 * pi;
        return;
    }
}

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\scale.cpp ===
//*****************************************************************************
//
// File: scale.cpp
// Author: jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of CScaleBvr object which implements
//			 the chromeffects scale DHTML behavior
//
// Modification List:
// Date		Author		Change
// 10/20/98	jeffort		Created this file
// 10/21/98 jeffort     Reworked code, use values as percentage
//*****************************************************************************

#include "headers.h"

#include "scale.h"
#include "attrib.h"
#include "dautil.h"

#undef THIS
#define THIS CScaleBvr
#define SUPER CBaseBehavior

#define SCALE_NORMALIZATION_VALUE   100.0f

#include "pbagimp.cpp"

// These are used for the IPersistPropertyBag2 as it is implemented
// in the base class.  This takes an array of BSTR's, gets the
// attributes, queries this class for the variant, and copies
// the result.  The order of these defines is important

#define VAR_FROM        0
#define VAR_TO          1
#define VAR_BY          2
#define VAR_TYPE		3
#define VAR_MODE		4

WCHAR * CScaleBvr::m_rgPropNames[] = {
                                     BEHAVIOR_PROPERTY_FROM,
                                     BEHAVIOR_PROPERTY_TO,
                                     BEHAVIOR_PROPERTY_BY,
									 BEHAVIOR_PROPERTY_TYPE,
									 BEHAVIOR_PROPERTY_MODE
                                    };

//*****************************************************************************

CScaleBvr::CScaleBvr() :
	m_pdispActor( NULL ),
	m_lCookie( 0 )
{
    VariantInit(&m_varFrom);
    VariantInit(&m_varTo);
    VariantInit(&m_varBy);
	VariantInit(&m_varType);
	VariantInit(&m_varMode);
    m_clsid = CLSID_CrScaleBvr;
} // CScaleBvr

//*****************************************************************************

CScaleBvr::~CScaleBvr()
{
    VariantClear(&m_varFrom);
    VariantClear(&m_varTo);
    VariantClear(&m_varBy);
	VariantClear(&m_varType);
	VariantClear(&m_varMode);

	ReleaseInterface( m_pdispActor );
} // ~ScaleBvr

//*****************************************************************************

HRESULT CScaleBvr::FinalConstruct()
{
    HRESULT hr = SUPER::FinalConstruct();
    if (FAILED(hr))
    {
        DPF_ERR("Error in scale behavior FinalConstruct initializing base classes");
        return hr;
    }
    return S_OK;
} // FinalConstruct

//*****************************************************************************

VARIANT *
CScaleBvr::VariantFromIndex(ULONG iIndex)
{
    DASSERT(iIndex < NUM_SCALE_PROPS);
    switch (iIndex)
    {
    case VAR_FROM:
        return &m_varFrom;
        break;
    case VAR_TO:
        return &m_varTo;
        break;
    case VAR_BY:
        return &m_varBy;
        break;
	case VAR_TYPE:
		return &m_varType;
		break;
	case VAR_MODE:
		return &m_varMode;
		break;
    default:
        // We should never get here
        DASSERT(false);
        return NULL;
    }
} // VariantFromIndex

//*****************************************************************************

HRESULT 
CScaleBvr::GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames)
{
    *pulProperties = NUM_SCALE_PROPS;
    *pppPropNames = m_rgPropNames;
    return S_OK;
} // GetPropertyBagInfo

//*****************************************************************************

STDMETHODIMP 
CScaleBvr::Init(IElementBehaviorSite *pBehaviorSite)
{
	return SUPER::Init(pBehaviorSite);
} // Init

//*****************************************************************************

STDMETHODIMP 
CScaleBvr::Notify(LONG event, VARIANT *pVar)
{
	HRESULT hr = SUPER::Notify(event, pVar);
	CheckHR( hr, "Notify in base class failed", end);

	switch( event )
	{
	case BEHAVIOREVENT_CONTENTREADY:
		DPF_ERR("Got Content Ready");
			
		{
			hr = RequestRebuild( );
			CheckHR( hr, "Request for rebuild failed", end );
			
		}break;
    case BEHAVIOREVENT_DOCUMENTREADY:
		break;
    case BEHAVIOREVENT_APPLYSTYLE:
		DPF_ERR("Got ApplyStyle");
		break;
    case BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE:
		DPF_ERR("Got Document context change");
		break;
	default:
		DPF_ERR("Unknown event");
	}

end:
	
	return hr;

} // Notify

//*****************************************************************************

STDMETHODIMP
CScaleBvr::Detach()
{
	LMTRACE( "Begin detach of CScaleBvr <%p>\n", this );
	HRESULT hr = SUPER::Detach();
	if( FAILED( hr ) )
	{
		DPF_ERR("failed to in super class detach " );
	}

	if( m_pdispActor != NULL && m_lCookie != NULL )
	{
		hr = RemoveBehaviorFromActor( m_pdispActor, m_lCookie );
		ReleaseInterface( m_pdispActor );
		CheckHR( hr, "Failed to remove the behavior from the actor", end );
		m_lCookie = 0;
	}

	LMTRACE( "End detach of CScaleBvr <%p>\n", this );

end:
	return hr;
} // Detach 

//*****************************************************************************

STDMETHODIMP
CScaleBvr::put_animates(VARIANT varAnimates)
{
    return SUPER::SetAnimatesProperty(varAnimates);
} // put_animates

//*****************************************************************************

STDMETHODIMP
CScaleBvr::get_animates(VARIANT *pRetAnimates)
{
    return SUPER::GetAnimatesProperty(pRetAnimates);
} // get_animates

//*****************************************************************************

STDMETHODIMP
CScaleBvr::put_from(VARIANT varFrom)
{
    HRESULT hr = VariantCopy(&m_varFrom, &varFrom);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting from for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRSCALEBVR_FROM);
} // put_from

//*****************************************************************************

STDMETHODIMP
CScaleBvr::get_from(VARIANT *pRetFrom)
{
    if (pRetFrom == NULL)
    {
        DPF_ERR("Error in CScaleBvr:get_from, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetFrom, &m_varFrom);
} // get_from

//*****************************************************************************

STDMETHODIMP 
CScaleBvr::put_to(VARIANT varTo)
{
    HRESULT hr = VariantCopy(&m_varTo, &varTo);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting to for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRSCALEBVR_TO);
} // put_to

//*****************************************************************************

STDMETHODIMP 
CScaleBvr::get_to(VARIANT *pRetTo)
{
    if (pRetTo == NULL)
    {
        DPF_ERR("Error in CScaleBvr:get_to, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetTo, &m_varTo);
} // get_to

//*****************************************************************************

STDMETHODIMP 
CScaleBvr::put_by(VARIANT varBy)
{
    HRESULT hr = VariantCopy(&m_varBy, &varBy);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting by for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRSCALEBVR_BY);
} // put_by

//*****************************************************************************

STDMETHODIMP 
CScaleBvr::get_by(VARIANT *pRetBy)
{
    if (pRetBy == NULL)
    {
        DPF_ERR("Error in CScaleBvr:get_by, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetBy, &m_varBy);
} // get_by

//*****************************************************************************

STDMETHODIMP 
CScaleBvr::put_type(VARIANT varType)
{
    HRESULT hr = VariantCopy(&m_varType, &varType);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting type for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRSCALEBVR_TYPE);
} // put_type

//*****************************************************************************

STDMETHODIMP 
CScaleBvr::get_type(VARIANT *pRetType)
{
    if (pRetType == NULL)
    {
        DPF_ERR("Error in get_type, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetType, &m_varType);
} // get_type

//*****************************************************************************

STDMETHODIMP 
CScaleBvr::put_mode(VARIANT varMode)
{
    HRESULT hr = VariantCopy(&m_varMode, &varMode);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting mode for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    
    return NotifyPropertyChanged(DISPID_ICRSCALEBVR_MODE);
} // put_mode

//*****************************************************************************

STDMETHODIMP 
CScaleBvr::get_mode(VARIANT *pRetMode)
{
    if (pRetMode == NULL)
    {
        DPF_ERR("Error in get_mode, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetMode, &m_varMode);
} // get_mode

//*****************************************************************************

STDMETHODIMP
CScaleBvr::buildBehaviorFragments(IDispatch* pActorDisp)
{
    HRESULT hr;

    if( m_pdispActor != NULL && m_lCookie != 0 )
    {
    	//remove the old behavior from time.
    	hr = RemoveBehaviorFromActor( m_pdispActor, m_lCookie );
    	if( FAILED( hr ) )
    	{
    		DPF_ERR("failed to remove the behavior from the actor");
    		return hr;
    	}
    	m_lCookie = 0;
    	ReleaseInterface( m_pdispActor );
    }

	IDATransform2 *pTransform;
	hr = GetScaleToTransform(pActorDisp, &pTransform);
	if (SUCCEEDED(hr))
	{
		//get the dispatch off of the element to which we are attached.
		IDispatch *pdispThis = NULL;
		hr = GetHTMLElementDispatch( &pdispThis );				
		if( FAILED( hr ) )
		{
			DPF_ERR("QI for IDispatch on element failed" );
			ReleaseInterface( pTransform );
			return hr;
		}
	
		BSTR bstrPropertyName = SysAllocString( L"scale" );
		hr = AttachBehaviorToActorEx( pActorDisp, 
									  pTransform, 
									  bstrPropertyName, 
									  FlagFromTypeMode(e_AbsoluteAccum, &m_varType, &m_varMode), 
									  e_Scale,
									  pdispThis,
									  &m_lCookie);

		ReleaseInterface( pdispThis );
		ReleaseInterface( pTransform );
		::SysFreeString( bstrPropertyName );

		return hr;
	}

    float rgflFrom[3];
    float rgflTo[3];
    int iNumValues;
	bool relative;

    hr = GetScaleVectorValues(rgflFrom, rgflTo, &iNumValues, &relative);
	if(SUCCEEDED( hr ) )
	{
		if (iNumValues >= NUM_VECTOR_VALUES_2D)
		{
			IDATransform2 *pbvrTransform;
			hr = Build2DTransform(rgflFrom, rgflTo, &pbvrTransform);
			if( SUCCEEDED(hr) )
			{

				//get the dispatch off of the element to which we are attached.
				IDispatch *pdispThis = NULL;
				hr = GetHTMLElementDispatch( &pdispThis );				
				if( FAILED( hr ) )
				{
					DPF_ERR("QI for IDispatch on element failed" );
					ReleaseInterface( pbvrTransform );
					return hr;
				}
				
				BSTR bstrPropertyName = SysAllocString( L"scale" );

				hr = AttachBehaviorToActorEx( pActorDisp, 
											  pbvrTransform, 
											  bstrPropertyName, 
											  FlagFromTypeMode(relative, &m_varType, &m_varMode), 
											  e_Scale,
											  pdispThis,
											  &m_lCookie);

				ReleaseInterface( pdispThis );
				ReleaseInterface( pbvrTransform );
				::SysFreeString( bstrPropertyName );
				if( FAILED( hr ) )
				{
					DPF_ERR("Failed to attach scale behavior to actor");
				}
			}
			else //error building scale transform
			{
				DPF_ERR("error building scale transform");
				return hr;
			}
		}
	}
	else //Error extracting values from vecotors in CScaleBvr::BuildAnimationAsDABehavior
    {
        DPF_ERR("Error extracting values from vecotors in CScaleBvr::BuildAnimationAsDABehavior");
        return hr;
    }

    m_pdispActor = pActorDisp;
    m_pdispActor->AddRef();

    return S_OK;
} // buildBehaviorFragments

//*****************************************************************************

/*
HRESULT 
CScaleBvr::Apply2DScaleBehaviorToAnimationElement(IDATransform2 *pbvrScale)
{
    HRESULT hr;

    // This is a complete hack for now until the actor object is in place
    // We will simply push a unit vector in through the transform,
    // extracto out the X and Y values and apply each component
    // to width and height

    // we first need to get the original height and width
    long lHeight = DEFAULT_SCALE_HEIGHT;
    long lWidth = DEFAULT_SCALE_WIDTH;

    IHTMLElement *pElement;
    hr = GetElementToAnimate(&pElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting animated element");
        return hr;
    }
    IHTMLStyle *pStyle;
    hr = pElement->get_style(&pStyle);
    ReleaseInterface(pElement);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting style object from HTML element");
        return SetErrorInfo(hr);
    }
    
    hr = pStyle->get_pixelHeight(&lHeight);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting height from style object");
        ReleaseInterface(pStyle);
        return SetErrorInfo(hr);
    }
    hr = pStyle->get_pixelWidth(&lWidth);
    ReleaseInterface(pStyle);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting width from style object");
        return SetErrorInfo(hr);
    }

    // TODO What do we do when these attributes are not set????
    if (lHeight == 0)
        lHeight = DEFAULT_SCALE_HEIGHT;
    if (lWidth == 0)
        lWidth = DEFAULT_SCALE_WIDTH;


    IDAVector2 *pbvrUnitVector;

    hr = GetDAStatics()->Vector2(1.0, 1.0, &pbvrUnitVector);
    if (FAILED(hr))
    {
        DPF_ERR("error creating DA unit vector");
        return SetErrorInfo(hr);
    }

    IDAVector2 *pbvrTransformedVector;
    hr = pbvrUnitVector->Transform(pbvrScale, &pbvrTransformedVector);
    ReleaseInterface(pbvrUnitVector);
    if (FAILED(hr))
    {
        DPF_ERR("Error transforming unit vector");
        return SetErrorInfo(hr);
    }
    DASSERT(pbvrTransformedVector != NULL);
    IDANumber *pbvrVectorComponent;
    hr = pbvrTransformedVector->get_X(&pbvrVectorComponent);
    if (FAILED(hr))
    {
        DPF_ERR("error extracting X value from vector");
        ReleaseInterface(pbvrTransformedVector);
        return SetErrorInfo(hr);
    }
    DASSERT(pbvrVectorComponent != NULL);
    // we need to multiply this value with width to get the proper
    // value to animate the property with
    IDANumber *pbvrMultiplier;
    hr = CDAUtils::GetDANumber(GetDAStatics(),
                               static_cast<float>(lWidth),
                               &pbvrMultiplier);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting DA number for width");
        ReleaseInterface(pbvrTransformedVector);
        ReleaseInterface(pbvrVectorComponent);
        return SetErrorInfo(hr);
    }
    DASSERT(pbvrMultiplier != NULL);

    IDANumber *pbvrResult;
    hr = GetDAStatics()->Mul(pbvrVectorComponent, pbvrMultiplier, &pbvrResult);
    ReleaseInterface(pbvrVectorComponent);
    ReleaseInterface(pbvrMultiplier);
    if (FAILED(hr))
    {
        DPF_ERR("Error multiplying DA numbers for width");
        ReleaseInterface(pbvrTransformedVector);
        return SetErrorInfo(hr);
    } 
    DASSERT(pbvrResult != NULL);
    hr = ApplyNumberBehaviorToAnimationElement(pbvrResult, L"style.width");
    ReleaseInterface(pbvrResult);
    if (FAILED(hr))
    {
        DPF_ERR("error calling ApplyNumberBehaviorToAnimationElement");
        ReleaseInterface(pbvrTransformedVector);
        return SetErrorInfo(hr);
    }    





    hr = pbvrTransformedVector->get_Y(&pbvrVectorComponent);
    ReleaseInterface(pbvrTransformedVector);
    if (FAILED(hr))
    {
        DPF_ERR("error extracting Y value from vector");
        return SetErrorInfo(hr);
    }
    DASSERT(pbvrVectorComponent != NULL);
    hr = CDAUtils::GetDANumber(GetDAStatics(),
                               static_cast<float>(lHeight),
                               &pbvrMultiplier);
    if (FAILED(hr))
    {
        DPF_ERR("Error getting DA number for height");
        ReleaseInterface(pbvrVectorComponent);
        return SetErrorInfo(hr);
    }
    DASSERT(pbvrMultiplier != NULL);
    hr = GetDAStatics()->Mul(pbvrVectorComponent, pbvrMultiplier, &pbvrResult);
    ReleaseInterface(pbvrVectorComponent);
    ReleaseInterface(pbvrMultiplier);
    if (FAILED(hr))
    {
        DPF_ERR("Error multiplying DA numbers for height");
        return SetErrorInfo(hr);
    } 
    DASSERT(pbvrResult != NULL);


    hr = ApplyNumberBehaviorToAnimationElement(pbvrResult, L"style.height");
    ReleaseInterface(pbvrResult);
    if (FAILED(hr))
    {
        DPF_ERR("error calling ApplyNumberBehaviorToAnimationElement");
        return SetErrorInfo(hr);
    }    
    return S_OK;
} // Apply2DScaleBehaviorToAnimationElement
*/
//*****************************************************************************

// These are used to index array values below

#define XVAL 0
#define YVAL 1
#define ZVAL 2

//*****************************************************************************

HRESULT 
CScaleBvr::Build2DTransform(float  rgflFrom[2],
                            float  rgflTo[2],
                            IDATransform2 **ppbvrTransform)
{
    HRESULT hr;

    IDANumber *pbvrScaleX;
    IDANumber *pbvrScaleY;

    hr = BuildTIMEInterpolatedNumber(rgflFrom[XVAL],
                                     rgflTo[XVAL],
                                     &pbvrScaleX);
    if (FAILED(hr))
    {
        DPF_ERR("Error building interpolated X value for scale behavior");
        return hr;
    }

    hr = BuildTIMEInterpolatedNumber(rgflFrom[YVAL],
                                     rgflTo[YVAL],
                                     &pbvrScaleY);
    if (FAILED(hr))
    {
        DPF_ERR("Error building interpolated X value for scale behavior");
        ReleaseInterface(pbvrScaleX);
        return hr;
    }

    hr = CDAUtils::BuildScaleTransform2(GetDAStatics(),
                                        pbvrScaleX,
                                        pbvrScaleY,
                                        ppbvrTransform);
    ReleaseInterface(pbvrScaleX);
    ReleaseInterface(pbvrScaleY);
    if (FAILED(hr))
    {
        DPF_ERR("Error building scale transform2");
        return SetErrorInfo(hr);
    }
    return S_OK;
} // Build2DTransform

//*****************************************************************************
/*
HRESULT 
CScaleBvr::Build3DTransform(float  rgflFrom[3],
                            float  rgflTo[3],
                            IDATransform3 **ppbvrTransform)
{
    HRESULT hr;

    IDANumber *pbvrScaleX;
    IDANumber *pbvrScaleY;
    IDANumber *pbvrScaleZ;

    // TODO: get these values from HTML
    float flOriginalX = 1.0f;
    float flOriginalY = 1.0f;
    float flOriginalZ = 1.0f;


    hr = BuildTIMEInterpolatedNumber(rgflFrom[XVAL],
                                     rgflTo[XVAL],
                                     flOriginalX,
                                     &pbvrScaleX);
    if (FAILED(hr))
    {
        DPF_ERR("Error building interpolated X value for scale behavior");
        return hr;
    }

    hr = BuildTIMEInterpolatedNumber(rgflFrom[YVAL],
                                     rgflTo[YVAL],
                                     flOriginalY,
                                     &pbvrScaleY);
    if (FAILED(hr))
    {
        DPF_ERR("Error building interpolated Y value for scale behavior");
        ReleaseInterface(pbvrScaleX);
        return hr;
    }
    hr = BuildTIMEInterpolatedNumber(rgflFrom[ZVAL],
                                     rgflTo[ZVAL],
                                     flOriginalZ,
                                     &pbvrScaleZ);
    if (FAILED(hr))
    {
        DPF_ERR("Error building interpolated Z value for scale behavior");
        ReleaseInterface(pbvrScaleX);
        ReleaseInterface(pbvrScaleY);
        return hr;
    }
    hr = CDAUtils::BuildScaleTransform3(GetDAStatics(),
                                        pbvrScaleX,
                                        pbvrScaleY,
                                        pbvrScaleZ,
                                        ppbvrTransform);
    ReleaseInterface(pbvrScaleX);
    ReleaseInterface(pbvrScaleY);
    ReleaseInterface(pbvrScaleZ);
    if (FAILED(hr))
    {
        DPF_ERR("Error building scale transform2");
        return SetErrorInfo(hr);
    }
    return S_OK;
} // Build3DTransform
*/
//*****************************************************************************

HRESULT 
CScaleBvr::GetScaleVectorValues(float  rgflFrom[3],
                                float  rgflTo[3],
                                int    *piNumValues,
								bool   *prelative)
{

    int cReturnedFromValues;
	int cReturnedToValues;
    HRESULT hr;

    hr = CUtils::GetVectorFromVariant(&m_varFrom, 
                                      &cReturnedFromValues, 
                                      &(rgflFrom[XVAL]), 
                                      &(rgflFrom[YVAL]), 
                                      &(rgflFrom[ZVAL]));
    if (FAILED(hr) || cReturnedFromValues < MIN_NUM_SCALE_VALUES)
    {
        // there was no valid from attribute specified.
        // try the by attribute
		hr = CUtils::GetVectorFromVariant(&m_varBy, 
										  &cReturnedToValues, 
										  &(rgflTo[XVAL]), 
										  &(rgflTo[YVAL]), 
										  &(rgflTo[ZVAL]));
		if (FAILED(hr))
		{
			DPF_ERR("Error converting to and by variant to float in CScaleBvr::BuildAnimationAsDABehavior");
			return SetErrorInfo(hr);
		}

		// Got a by.  Must be relative and from must be 0
		*prelative = true;

		rgflFrom[0] = 1;
		rgflFrom[1] = 1;
		rgflFrom[2] = 1;

		rgflTo[XVAL] /= SCALE_NORMALIZATION_VALUE;
		rgflTo[YVAL] /= SCALE_NORMALIZATION_VALUE;
		rgflTo[ZVAL] /= SCALE_NORMALIZATION_VALUE;
    }
	else
	{
		// there was a valid from attribute, try to or by
		hr = CUtils::GetVectorFromVariant(&m_varTo, 
										  &cReturnedToValues, 
										  &(rgflTo[XVAL]), 
										  &(rgflTo[YVAL]), 
										  &(rgflTo[ZVAL]));
		bool fHasBy = false;
		if (FAILED(hr))
		{
			// there was no valid to attribute specified, try for a by attribute
			hr = CUtils::GetVectorFromVariant(&m_varBy, 
											  &cReturnedToValues, 
											  &(rgflTo[XVAL]), 
											  &(rgflTo[YVAL]), 
											  &(rgflTo[ZVAL]));
			if (FAILED(hr))
			{
				DPF_ERR("Error converting to and by variant to float in CScaleBvr::BuildAnimationAsDABehavior");
				return SetErrorInfo(hr);
			}
        
			fHasBy = true;
		}

		if (cReturnedToValues < MIN_NUM_SCALE_VALUES)
		{
			DPF_ERR("Error in to/by vector for scale, not enough params");
			return SetErrorInfo(E_INVALIDARG);
		}

		rgflFrom[XVAL] /= SCALE_NORMALIZATION_VALUE;
		rgflFrom[YVAL] /= SCALE_NORMALIZATION_VALUE;
		rgflFrom[ZVAL] /= SCALE_NORMALIZATION_VALUE;

		rgflTo[XVAL] /= SCALE_NORMALIZATION_VALUE;
		rgflTo[YVAL] /= SCALE_NORMALIZATION_VALUE;
		rgflTo[ZVAL] /= SCALE_NORMALIZATION_VALUE;

		if (true == fHasBy)
		{
			// this scale has a "by", TO = FROM + TO
			rgflTo[XVAL] += rgflFrom[XVAL];
			rgflTo[YVAL] += rgflFrom[YVAL];
			if (cReturnedToValues == NUM_VECTOR_VALUES_3D)
				rgflTo[ZVAL] += rgflFrom[ZVAL];
		}

		// This is an absolute scale
		*prelative = false;
	}

    *piNumValues = cReturnedToValues;
    return S_OK;
} // GetScaleVectorValues

HRESULT 
CScaleBvr::GetScaleToTransform(IDispatch *pActorDisp, IDATransform2 **ppResult)
{

    HRESULT hr;
    int cReturnedValues;
    float x, y, z;

    hr = CUtils::GetVectorFromVariant(&m_varFrom, 
                                      &cReturnedValues, 
                                      &x, 
                                      &y,
                                      &z);

	if (SUCCEEDED(hr))
		return E_FAIL;

    hr = CUtils::GetVectorFromVariant(&m_varTo, 
                                      &cReturnedValues, 
                                      &x, 
                                      &y, 
                                      &z);

    if (FAILED(hr) || cReturnedValues != 2)
    {
		return E_FAIL;
	}

	IDABehavior *pFromBvr;
	hr = GetBvrFromActor(pActorDisp, L"scale", e_From, e_Scale, &pFromBvr);
	if (FAILED(hr))
		return hr;

	IDATransform2 *pFromTrans;
	hr = pFromBvr->QueryInterface(IID_TO_PPV(IDATransform2, &pFromTrans));
	ReleaseInterface(pFromBvr);
	if (FAILED(hr))
		return hr;

	// Transform the point 1,1 and extract x and y
	IDAPoint2 *pOrigin;
	hr = GetDAStatics()->Point2(1, 1, &pOrigin);
	if (FAILED(hr))
	{
		ReleaseInterface(pFromTrans);
		return hr;
	}

	IDAPoint2 *pFrom;
	hr = pOrigin->Transform(pFromTrans, &pFrom);
	ReleaseInterface(pOrigin);
	ReleaseInterface(pFromTrans);
	if (FAILED(hr))
		return hr;

	IDANumber *pFromX;
	hr = pFrom->get_X(&pFromX);
	if (FAILED(hr))
	{
		ReleaseInterface(pFrom);
		return hr;
	}

	IDANumber *pFromY;
	hr = pFrom->get_Y(&pFromY);
	ReleaseInterface(pFrom);
	if (FAILED(hr))
	{
		ReleaseInterface(pFromX);
		return hr;
	}

	IDANumber *pToX;
	hr = GetDAStatics()->DANumber(x/SCALE_NORMALIZATION_VALUE, &pToX);
	if (FAILED(hr))
	{
		ReleaseInterface(pFromX);
		ReleaseInterface(pFromY);
		return hr;
	}

	IDANumber *pToY;
	hr = GetDAStatics()->DANumber(y/SCALE_NORMALIZATION_VALUE, &pToY);
	if (FAILED(hr))
	{
		ReleaseInterface(pFromX);
		ReleaseInterface(pFromY);
		ReleaseInterface(pToX);
		return hr;
	}

	IDANumber *pX;
	hr = BuildTIMEInterpolatedNumber(pFromX, pToX, &pX);
	ReleaseInterface(pFromX);
	ReleaseInterface(pToX);
	if (FAILED(hr))
	{
		ReleaseInterface(pFromY);
		ReleaseInterface(pToY);
		return hr;
	}

	IDANumber *pY;
	hr = BuildTIMEInterpolatedNumber(pFromY, pToY, &pY);
	ReleaseInterface(pFromY);
	ReleaseInterface(pToY);
	if (FAILED(hr))
	{
		ReleaseInterface(pX);
		return hr;
	}

	hr = GetDAStatics()->Scale2Anim(pX, pY, ppResult);
	ReleaseInterface(pX);
	ReleaseInterface(pY);
	if (FAILED(hr))
		return hr;

	return S_OK;
} 

//*****************************************************************************

HRESULT 
CScaleBvr::BuildAnimationAsDABehavior()
{
	return S_OK;
} // BuildAnimationAsDABehavior


//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\set.cpp ===
//*****************************************************************************
//
// File:    setbvr.cpp
// Author:  jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of CSetBvr object which implements
//			 the chromeffects Set DHTML behavior
//
// Modification List:
// Date		Author		Change
// 09/26/98	jeffort		Created this file
// 10/16/98 jeffort     Added animates property
// 10/16/98 jeffort     Renamed functions
// 11/20/98 markhal     Converted to use actor
//*****************************************************************************

#include "headers.h"

#include "set.h"
#include "attrib.h"
#include "dautil.h"

#undef THIS
#define THIS CSetBvr
#define SUPER CBaseBehavior

#include "pbagimp.cpp"

// These are used for the IPersistPropertyBag2 as it is implemented
// in the base class.  This takes an array of BSTR's, gets the
// attributes, queries this class for the variant, and copies
// the result.  The order of these defines is important

#define VAR_VALUE        0
#define VAR_PROPERTY     1
#define VAR_TYPE         2

WCHAR * CSetBvr::m_rgPropNames[] = {
                                   BEHAVIOR_PROPERTY_VALUE,
                                   BEHAVIOR_PROPERTY_PROPERTY,
                                   BEHAVIOR_PROPERTY_TYPE
                                   };

//*****************************************************************************

CSetBvr::CSetBvr() 
{
    VariantInit(&m_varValue);
    VariantInit(&m_varProperty);
    VariantInit(&m_varType);
    m_clsid = CLSID_CrSetBvr;
    m_lCookie = 0;
    m_pdispActor = NULL;
} // CSetBvr

//*****************************************************************************

CSetBvr::~CSetBvr()
{
    VariantClear(&m_varValue);
    VariantClear(&m_varProperty);
    VariantClear(&m_varType);

	ReleaseInterface( m_pdispActor );
} // ~SetBvr

//*****************************************************************************

HRESULT CSetBvr::FinalConstruct()
{
    HRESULT hr = SUPER::FinalConstruct();
    if (FAILED(hr))
    {
        DPF_ERR("Error in set behavior FinalConstruct initializing base classes");
        return hr;
    }
    return S_OK;
} // FinalConstruct

//*****************************************************************************

VARIANT *
CSetBvr::VariantFromIndex(ULONG iIndex)
{
    DASSERT(iIndex < NUM_SET_PROPS);
    switch (iIndex)
    {
    case VAR_VALUE:
        return &m_varValue;
        break;
    case VAR_PROPERTY:
        return &m_varProperty;
        break;
    case VAR_TYPE:
        return &m_varType;
        break;
    default:
        // We should never get here
        DASSERT(false);
        return NULL;
    }
} // VariantFromIndex

//*****************************************************************************

HRESULT 
CSetBvr::GetPropertyBagInfo(ULONG *pulProperties, WCHAR ***pppPropNames)
{
    *pulProperties = NUM_SET_PROPS;
    *pppPropNames = m_rgPropNames;
    return S_OK;
} // GetPropertyBagInfo

//*****************************************************************************

STDMETHODIMP 
CSetBvr::Init(IElementBehaviorSite *pBehaviorSite)
{

	HRESULT hr = SUPER::Init(pBehaviorSite);
	CheckHR( hr, "Init of base class failed", end );

end:

	return hr;
} // Init

//*****************************************************************************

STDMETHODIMP 
CSetBvr::Notify(LONG event, VARIANT *pVar)
{	
	
	HRESULT hr = SUPER::Notify(event, pVar);
	CheckHR( hr, "Notify in base class failed", end);

	switch( event )
	{
	case BEHAVIOREVENT_CONTENTREADY:
		DPF_ERR("Got Content Ready");
			
		{
			hr = RequestRebuild( );
			CheckHR( hr, "Request for rebuild failed", end );
			
		}break;
    case BEHAVIOREVENT_DOCUMENTREADY:
		break;
    case BEHAVIOREVENT_APPLYSTYLE:
		DPF_ERR("Got ApplyStyle");
		break;
    case BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE:
		DPF_ERR("Got Document context change");
		break;
	default:
		DPF_ERR("Unknown event");
	}

end:
	
	return hr;
} // Notify

//*****************************************************************************

STDMETHODIMP
CSetBvr::Detach()
{
    //we have to remove our behavior from the actor

    LMTRACE( L"Detaching Set Behavior <%p>\n", this );

    HRESULT hr = S_OK;
    
    hr = SUPER::Detach();
    CheckHR( hr, "Failed in super.detach for set", end );

	//we have a behavior in the actor.  Remove it.
    if( m_pdispActor != NULL && m_lCookie != 0 )
    {
    	hr = RemoveBehaviorFromActor( m_pdispActor, m_lCookie );
    	CheckHR( hr, "Failed to remove the behavior from the actor", end );

    	m_lCookie = 0;
    }

    ReleaseInterface( m_pdispActor );

    LMTRACE( L"End Detach set <%p>\n", this );

end:
    return hr;
} // Detach 

//*****************************************************************************

STDMETHODIMP
CSetBvr::put_animates(VARIANT varAnimates)
{
    return SUPER::SetAnimatesProperty(varAnimates);
} // put_animates

//*****************************************************************************

STDMETHODIMP
CSetBvr::get_animates(VARIANT *pRetAnimates)
{
    return SUPER::GetAnimatesProperty(pRetAnimates);
} // get_animates

//*****************************************************************************

STDMETHODIMP
CSetBvr::put_value(VARIANT varValue)
{
    HRESULT hr = VariantCopy(&m_varValue, &varValue);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting value for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    return NotifyPropertyChanged(DISPID_ICRSETBVR_VALUE);
} // put_value

//*****************************************************************************

STDMETHODIMP
CSetBvr::get_value(VARIANT *pRetValue)
{
    if (pRetValue == NULL)
    {
        DPF_ERR("Error in CSetBvr:get_value, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetValue, &m_varValue);
} // get_value

//*****************************************************************************

STDMETHODIMP 
CSetBvr::put_property(VARIANT varProperty)
{
    HRESULT hr = VariantCopy(&m_varProperty, &varProperty);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting property for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    return NotifyPropertyChanged(DISPID_ICRSETBVR_PROPERTY);
} // put_property

//*****************************************************************************

STDMETHODIMP 
CSetBvr::get_property(VARIANT *pRetProperty)
{
    if (pRetProperty == NULL)
    {
        DPF_ERR("Error in CSetBvr:get_property, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetProperty, &m_varProperty);
} // get_property

//*****************************************************************************

STDMETHODIMP 
CSetBvr::put_type(VARIANT varType)
{
    HRESULT hr = VariantCopy(&m_varType, &varType);
    if (FAILED(hr))
    {
        DPF_ERR("Error setting Type for element");
        return SetErrorInfo(hr);
    }

    hr = RequestRebuild();
    if( FAILED( hr ) )
    {
    	DPF_ERR("Failed to request a rebuild on property put" );
    	return hr;
    }
    return NotifyPropertyChanged(DISPID_ICRSETBVR_TYPE);
} // put_type

//*****************************************************************************

STDMETHODIMP 
CSetBvr::get_type(VARIANT *pRetType)
{
    if (pRetType == NULL)
    {
        DPF_ERR("Error in CSetBvr:get_type, invalid pointer passed in");
        return SetErrorInfo(E_POINTER);
    }
    return VariantCopy(pRetType, &m_varType);
} // get_type

//*****************************************************************************

HRESULT 
CSetBvr::BuildAnimationAsDABehavior()
{
	// TODO (markhal): This will go away when all behaviors have been converted
	return S_OK;
}

//*****************************************************************************

STDMETHODIMP
CSetBvr::buildBehaviorFragments( IDispatch* pActorDisp )
{
    HRESULT hr;

    //make sure that any behaviors we have added to the actor have been removed
    if( m_lCookie != 0 )
    {
        //detach the behavior from the actor
        hr = RemoveBehaviorFromActor( m_lCookie );
        if( FAILED( hr ) )
        {
            DPF_ERR("Failed to remove the previous behavior was removed from the actor");
            return hr;
        }
        m_lCookie = 0;
    }

    hr = CUtils::InsurePropertyVariantAsBSTR(&m_varProperty);
    if (FAILED(hr))
    {
        DPF_ERR("Error, property attribute for set behavior not set");
        return SetErrorInfo(E_INVALIDARG);
    }

    hr = CUtils::InsurePropertyVariantAsBSTR(&m_varValue);
    if (FAILED(hr))
    {
        DPF_ERR("Error, value attribute for set behavior not set");
        return SetErrorInfo(E_INVALIDARG);
    }

    IDABehavior *pbvrBehavior = NULL;
    ActorBvrType eType = e_String;

    if (VT_EMPTY != m_varType.vt && SUCCEEDED(CUtils::InsurePropertyVariantAsBSTR(&m_varType) ) )
    {
        if (0 == _wcsicmp(V_BSTR(&m_varType), BEHAVIOR_TYPE_COLOR))
        {
            IDAColor *pbvrColor;
            hr = ExtractColor(m_varValue, &pbvrColor);
            if (FAILED(hr))
                return hr;

            eType = e_Color;
            pbvrBehavior = pbvrColor;           
        }
        else if (0 == _wcsicmp(V_BSTR(&m_varType), BEHAVIOR_TYPE_NUMBER))
        {
            IDANumber *pbvrNumber;
            hr = ExtractNumber(m_varValue, &pbvrNumber);
            if (FAILED(hr))
                return hr;

            eType = e_Number;
            pbvrBehavior = pbvrNumber;            
        }        
    }
    else
    {
        IDAColor *pbvrColor;
        IDANumber *pbvrNumber;
        // try for a color
        if (SUCCEEDED(ExtractColor(m_varValue, &pbvrColor)))
        {
            eType = e_Color;
            pbvrBehavior = pbvrColor;
        }
        // try for a number
        else if (SUCCEEDED(ExtractNumber(m_varValue, &pbvrNumber)))
        {
            eType = e_Number;
            pbvrBehavior = pbvrNumber;
        }
    }

    if (NULL == pbvrBehavior)
    {
        // build the string we need
        IDAString *pbvrString = NULL;
        
        hr = CDAUtils::GetDAString(GetDAStatics(), 
                                   m_varValue.bstrVal, 
                                   &pbvrString);
        if (FAILED(hr))
        {
            DPF_ERR("Error building DA string for value property");
            return SetErrorInfo(hr);
        }
        eType = e_String;
        pbvrBehavior = pbvrString;
    }

    IDispatch *pdispElem = NULL;

    hr = GetHTMLElement()->QueryInterface( IID_TO_PPV( IDispatch, &pdispElem ) );
    if( FAILED(hr) )
    {
        DPF_ERR("Failed to QI the behavior element for IDispatch" );
        return hr;
    }

	hr = AttachBehaviorToActorEx( pActorDisp,
								  pbvrBehavior,
								  V_BSTR(&m_varProperty),
								  e_Absolute,
								  eType,
                                  pdispElem,
                                  &m_lCookie);

	ReleaseInterface(pbvrBehavior);

	ReleaseInterface( pdispElem );

	if (FAILED(hr))
	{
		DPF_ERR("Failed to attach behavior to actor");
		return SetErrorInfo(hr);
	}

	//stash the actor so we can remove our behaviors
	// later.
	m_pdispActor = pActorDisp;
	m_pdispActor->AddRef();

	
    return S_OK;
} //buildBehaviorFragments

//*****************************************************************************

HRESULT
CSetBvr::ExtractColor(VARIANT varValue, IDAColor **ppbvrColor)
{
    HRESULT hr;

    *ppbvrColor = NULL;
    DWORD dwColor = CUtils::GetColorFromVariant(&m_varValue);
    if (PROPERTY_INVALIDCOLOR == dwColor)
    {
        DPF_ERR("CSetBvr::ExtractColor exiting, GetColorFromVariant failed!");
        return E_INVALIDARG;
    }

    hr = CDAUtils::BuildDAColorFromRGB(GetDAStatics(), dwColor, ppbvrColor);
    if (FAILED(hr))
    {
        DPF_ERR("CSetBvr::ExtractColor exiting, BuildDAColorFromStaticHSL failed!");
        return SetErrorInfo(hr);
    }
    
    return S_OK;
}

//*****************************************************************************

HRESULT
CSetBvr::ExtractNumber(VARIANT varValue, IDANumber **ppbvrNumber)
{
    HRESULT hr;
    *ppbvrNumber = NULL;

    int cChars = SysStringLen(V_BSTR(&varValue));
    if (cChars == 0)
        return E_INVALIDARG;
    
    WCHAR * pchEnd = NULL;
    double dValue = wcstod(V_BSTR(&varValue), &pchEnd);
    if (pchEnd != (V_BSTR(&varValue) + cChars))
    {
        DPF_ERR("CSetBvr::ExtractNumber exiting, wcstod found non-float characters!");
        return E_INVALIDARG;
    }
    
    hr = CDAUtils::GetDANumber(GetDAStatics(), (float) dValue, ppbvrNumber);
    if (FAILED(hr))
    {
        DPF_ERR("CSetBvr::ExtractNumber exiting, GetDANumber failed!");
        return SetErrorInfo(hr);
    }

    return S_OK;
}


//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\chrome\src\util.cpp ===
//*****************************************************************************
//
// File:    util.cpp
// Author:  jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of utility functions
//
// Modification List:
// Date		Author		Change
// 10/16/98	jeffort		Created this file
//*****************************************************************************

#include <headers.h>
#include "utils.h"

//*****************************************************************************

#ifdef DEBUG
#define ASSERT_BANNER_STRING "************************************************************"

void debugAssert(LPCSTR szFile, INT nLine, LPCSTR szCondition)
{
    char szBuffer[MAX_PATH];

    //
    // Build the debug stream message.
    //
    wsprintfA(szBuffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition);

    //
    // Issue the message
    //
    DPF_ERR(ASSERT_BANNER_STRING);
    DPF_ERR(szBuffer);
    DPF_ERR(ASSERT_BANNER_STRING);

#ifdef _X86_
    _asm {int 3};
#else
    DebugBreak();
#endif // _X86_
}

#endif // DEBUG 


//*****************************************************************************

HRESULT CUtils::InsurePropertyVariantAsBool(VARIANT *varValue)
{
    // If the variant is empty or null, then return
    if (varValue->vt == VT_NULL || varValue->vt == VT_EMPTY)
    {
        return E_INVALIDARG;
    }
    // if the type currently is not a BOOL then coerce it to one
    if (varValue->vt != VT_BOOL)
    {
        VARIANT var;
        VariantInit(&var);
        HRESULT hr = VariantChangeTypeEx(&var, 
                                       varValue,
                                       LCID_SCRIPTING,
                                       VARIANT_NOUSEROVERRIDE,
                                       VT_BOOL);
        if (FAILED(hr))
        {
            DPF_ERR("Error changing variant type to bool");
            return hr;
        }
        hr = VariantCopy(varValue, &var);
        VariantClear(&var);
        if (FAILED(hr))
        {
            DPF_ERR("Error copying variant");
            return hr;
        }
    }
    return S_OK;
}

//*****************************************************************************


HRESULT CUtils::InsurePropertyVariantAsBSTR(VARIANT *varValue)
{
    // If the variant is empty or null, then the code below will
    // convert it to the empty string, but we will consider this to be
    // invalid, and only want to convert objects of substance
    if (varValue->vt == VT_NULL || varValue->vt == VT_EMPTY)
    {
        return E_INVALIDARG;
    }
    // if the type currently is not a BSTR then coerce it to one
    if (varValue->vt != VT_BSTR)
    {
        VARIANT var;
        VariantInit(&var);
        HRESULT hr = VariantChangeTypeEx(&var, 
                                       varValue,
                                       LCID_SCRIPTING,
                                       VARIANT_NOUSEROVERRIDE,
                                       VT_BSTR);
        if (FAILED(hr))
        {
            DPF_ERR("Error changing variant type to bstr in GetPropertyAsBSTR");
            return hr;
        }
        hr = VariantCopy(varValue, &var);
        VariantClear(&var);
        if (FAILED(hr))
        {
            DPF_ERR("Error copying variant in GetPropertyAsBSTR");
            return hr;
        }
    }
    return S_OK;
} // PropertyVariantInsureBSTR


//*****************************************************************************

typedef struct _COLORVALUE_PAIR
{
    const WCHAR *wzName;
    DWORD        dwValue;
} COLORVALUE_PAIR;

const COLORVALUE_PAIR
rgColorNames[] =
{
    { (L"aliceblue"),             0x01f0f8ff },
    { (L"antiquewhite"),          0x02faebd7 },
    { (L"aqua"),                  0x0300ffff },
    { (L"aquamarine"),            0x047fffd4 },
    { (L"azure"),                 0x05f0ffff },
    { (L"beige"),                 0x06f5f5dc },
    { (L"bisque"),                0x07ffe4c4 },
    { (L"black"),                 0x08000000 },
    { (L"blanchedalmond"),        0x09ffebcd },
    { (L"blue"),                  0x0a0000ff },
    { (L"blueviolet"),            0x0b8a2be2 },
    { (L"brown"),                 0x0ca52a2a },
    { (L"burlywood"),             0x0ddeb887 },
    { (L"cadetblue"),             0x0e5f9ea0 },
    { (L"chartreuse"),            0x0f7fff00 },
    { (L"chocolate"),             0x10d2691e },
    { (L"coral"),                 0x11ff7f50 },
    { (L"cornflowerblue"),        0x126495ed },
    { (L"cornsilk"),              0x13fff8dc },
    { (L"crimson"),               0x14dc143c },
    { (L"cyan"),                  0x1500ffff },
    { (L"darkblue"),              0x1600008b },
    { (L"darkcyan"),              0x17008b8b },
    { (L"darkgoldenrod"),         0x18b8860b },
    { (L"darkgray"),              0x19a9a9a9 },
    { (L"darkgreen"),             0x1a006400 },
    { (L"darkkhaki"),             0x1bbdb76b },
    { (L"darkmagenta"),           0x1c8b008b },
    { (L"darkolivegreen"),        0x1d556b2f },
    { (L"darkorange"),            0x1eff8c00 },
    { (L"darkorchid"),            0x1f9932cc },
    { (L"darkred"),               0x208b0000 },
    { (L"darksalmon"),            0x21e9967a },
    { (L"darkseagreen"),          0x228fbc8f },
    { (L"darkslateblue"),         0x23483d8b },
    { (L"darkslategray"),         0x242f4f4f },
    { (L"darkturquoise"),         0x2500ced1 },
    { (L"darkviolet"),            0x269400d3 },
    { (L"deeppink"),              0x27ff1493 },
    { (L"deepskyblue"),           0x2800bfff },
    { (L"dimgray"),               0x29696969 },
    { (L"dodgerblue"),            0x2a1e90ff },
    { (L"firebrick"),             0x2bb22222 },
    { (L"floralwhite"),           0x2cfffaf0 },
    { (L"forestgreen"),           0x2d228b22 },
    { (L"fuchsia"),               0x2eff00ff },
    { (L"gainsboro"),             0x2fdcdcdc },
    { (L"ghostwhite"),            0x30f8f8ff },
    { (L"gold"),                  0x31ffd700 },
    { (L"goldenrod"),             0x32daa520 },
    { (L"gray"),                  0x33808080 },
    { (L"green"),                 0x34008000 },
    { (L"greenyellow"),           0x35adff2f },
    { (L"honeydew"),              0x36f0fff0 },
    { (L"hotpink"),               0x37ff69b4 },
    { (L"indianred"),             0x38cd5c5c },
    { (L"indigo"),                0x394b0082 },
    { (L"ivory"),                 0x3afffff0 },
    { (L"khaki"),                 0x3bf0e68c },
    { (L"lavender"),              0x3ce6e6fa },
    { (L"lavenderblush"),         0x3dfff0f5 },
    { (L"lawngreen"),             0x3e7cfc00 },
    { (L"lemonchiffon"),          0x3ffffacd },
    { (L"lightblue"),             0x40add8e6 },
    { (L"lightcoral"),            0x41f08080 },
    { (L"lightcyan"),             0x42e0ffff },
    { (L"lightgoldenrodyellow"),  0x43fafad2 },
    { (L"lightgreen"),            0x4490ee90 },
    { (L"lightgrey"),             0x45d3d3d3 },
    { (L"lightpink"),             0x46ffb6c1 },
    { (L"lightsalmon"),           0x47ffa07a },
    { (L"lightseagreen"),         0x4820b2aa },
    { (L"lightskyblue"),          0x4987cefa },
    { (L"lightslategray"),        0x4a778899 },
    { (L"lightsteelblue"),        0x4bb0c4de },
    { (L"lightyellow"),           0x4cffffe0 },
    { (L"lime"),                  0x4d00ff00 },
    { (L"limegreen"),             0x4e32cd32 },
    { (L"linen"),                 0x4ffaf0e6 },
    { (L"magenta"),               0x50ff00ff },
    { (L"maroon"),                0x51800000 },
    { (L"mediumaquamarine"),      0x5266cdaa },
    { (L"mediumblue"),            0x530000cd },
    { (L"mediumorchid"),          0x54ba55d3 },
    { (L"mediumpurple"),          0x559370db },
    { (L"mediumseagreen"),        0x563cb371 },
    { (L"mediumslateblue"),       0x577b68ee },
    { (L"mediumspringgreen"),     0x5800fa9a },
    { (L"mediumturquoise"),       0x5948d1cc },
    { (L"mediumvioletred"),       0x5ac71585 },
    { (L"midnightblue"),          0x5b191970 },
    { (L"mintcream"),             0x5cf5fffa },
    { (L"mistyrose"),             0x5dffe4e1 },
    { (L"moccasin"),              0x5effe4b5 },
    { (L"navajowhite"),           0x5fffdead },
    { (L"navy"),                  0x60000080 },
    { (L"oldlace"),               0x61fdf5e6 },
    { (L"olive"),                 0x62808000 },
    { (L"olivedrab"),             0x636b8e23 },
    { (L"orange"),                0x64ffa500 },
    { (L"orangered"),             0x65ff4500 },
    { (L"orchid"),                0x66da70d6 },
    { (L"palegoldenrod"),         0x67eee8aa },
    { (L"palegreen"),             0x6898fb98 },
    { (L"paleturquoise"),         0x69afeeee },
    { (L"palevioletred"),         0x6adb7093 },
    { (L"papayawhip"),            0x6bffefd5 },
    { (L"peachpuff"),             0x6cffdab9 },
    { (L"peru"),                  0x6dcd853f },
    { (L"pink"),                  0x6effc0cb },
    { (L"plum"),                  0x6fdda0dd },
    { (L"powderblue"),            0x70b0e0e6 },
    { (L"purple"),                0x71800080 },
    { (L"red"),                   0x72ff0000 },
    { (L"rosybrown"),             0x73bc8f8f },
    { (L"royalblue"),             0x744169e1 },
    { (L"saddlebrown"),           0x758b4513 },
    { (L"salmon"),                0x76fa8072 },
    { (L"sandybrown"),            0x77f4a460 },
    { (L"seagreen"),              0x782e8b57 },
    { (L"seashell"),              0x79fff5ee },
    { (L"sienna"),                0x7aa0522d },
    { (L"silver"),                0x7bc0c0c0 },
    { (L"skyblue"),               0x7c87ceeb },
    { (L"slateblue"),             0x7d6a5acd },
    { (L"slategray"),             0x7e708090 },
    { (L"snow"),                  0x7ffffafa },
    { (L"springgreen"),           0x8000ff7f },
    { (L"steelblue"),             0x814682b4 },
    { (L"tan"),                   0x82d2b48c },
    { (L"teal"),                  0x83008080 },
    { (L"thistle"),               0x84d8bfd8 },
    { (L"tomato"),                0x85ff6347 },
    { (L"turquoise"),             0x8640e0d0 },
    { (L"violet"),                0x87ee82ee },
    { (L"wheat"),                 0x88f5deb3 },
    { (L"white"),                 0x89ffffff },
    { (L"whitesmoke"),            0x8af5f5f5 },
    { (L"yellow"),                0x8bffff00 },
    { (L"yellowgreen"),           0x8c9acd32 }

}; // rgColorNames[]

#define SIZE_OF_COLOR_TABLE (sizeof(rgColorNames) / sizeof(COLORVALUE_PAIR))
#define PROPERTY_INVALIDCOLOR 0x99999999

//*****************************************************************************

static int
CompareColorValuePairsByName(const void *pv1, const void *pv2)
{
    return _wcsicmp(((COLORVALUE_PAIR*)pv1)->wzName,
                    ((COLORVALUE_PAIR*)pv2)->wzName);
} // CompareColorValuePairsByName

//*****************************************************************************

HRESULT CUtils::InsurePropertyVariantAsFloat(VARIANT *varFloat)
{
    // If the variant is empty or null, then the code below will
    // convert it to the float 0, but we will consider this to be
    // invalid, and only want to convert objects of substance
    if (varFloat->vt == VT_NULL || varFloat->vt == VT_EMPTY)
    {
        return E_INVALIDARG;
    }
    if (varFloat->vt != VT_R4)
    {
        VARIANT var;
        VariantInit(&var);
        HRESULT hr = VariantChangeTypeEx(&var, 
                                       varFloat,
                                       LCID_SCRIPTING,
                                       VARIANT_NOUSEROVERRIDE,
                                       VT_R4);
        if (FAILED(hr))
        {
            DPF_ERR("Error changing variant type to float in GetFloatFromVariant");
            return hr;
        }
        hr = VariantCopy(varFloat, &var);
        VariantClear(&var);
        if (FAILED(hr))
        {
            DPF_ERR("Error copying variant in GetFloatFromVariant");
            return hr;
        }
    }
    return S_OK;
} // GetFloatFromVariant

//*****************************************************************************

DWORD CUtils::GetColorFromVariant(VARIANT *varColor)
{


    DWORD dwRet;
    
    if (0 == lstrlenW(varColor->bstrVal))
        return PROPERTY_INVALIDCOLOR;

    // first check if this string is possibly a color by name
    // by checking the first character for '#'
    if (varColor->bstrVal[0] != L'#')
    {
        // check if it is a string named color
        COLORVALUE_PAIR ColorName;
        ColorName.wzName = varColor->bstrVal;

        COLORVALUE_PAIR * pColorPair = (COLORVALUE_PAIR*)bsearch(&ColorName,
                                              rgColorNames,
                                              SIZE_OF_COLOR_TABLE,
                                              sizeof(COLORVALUE_PAIR),
                                              CompareColorValuePairsByName);
        if (NULL == pColorPair)
            return PROPERTY_INVALIDCOLOR;
        else
            return pColorPair->dwValue;
    }
    if (lstrlenW(varColor->bstrVal) != 7)
        return PROPERTY_INVALIDCOLOR;
    dwRet = 0;
    for (int i = 1; i < 7; i++)
    {
        // shift dwRet by 4
        dwRet <<= 4;
        // and add in the value of this string
        switch (varColor->bstrVal[i])
        {
        case '0':
            dwRet +=  0;
            break;
        case '1':
            dwRet +=  1;
            break;
        case '2':
            dwRet +=  2;
            break;
        case '3':
            dwRet +=  3;
            break;
        case '4':
            dwRet +=  4;
            break;
        case '5':
            dwRet +=  5;
            break;
        case '6':
            dwRet +=  6;
            break;
        case '7':
            dwRet +=  7;
            break;
        case '8':
            dwRet +=  8;
            break;
        case '9':
            dwRet +=  9;
            break;
        case 'a':
        case 'A':
            dwRet += 10;
            break;
        case 'b':
        case 'B':
            dwRet += 11;
            break;
        case 'c':
        case 'C':
            dwRet += 12;
            break;
        case 'd':
        case 'D':
            dwRet += 13;
            break;
        case 'e':
        case 'E':
            dwRet += 14;
            break;
        case 'f':
        case 'F':
            dwRet += 15;
            break;
        default:
            return PROPERTY_INVALIDCOLOR;
        }
    }
    return dwRet;
} // GetColorFromVariant

//*****************************************************************************
// The reason this function exists is to work around a compiler bug
// where the compare in the function below was failing when it should
// have been working.  This would fail if the floating point value
// was on the stack and not stored in a variable.  This forces it to be
// in a variable correctly.
//*****************************************************************************
bool 
CUtils::CompareForEqualFloat(float flComp1, float flComp2)
{
    return (flComp1 == flComp2);
} // CompareForEqual

//*****************************************************************************

void CUtils::GetHSLValue(DWORD dwInputColor, 
						 float *pflHue, 
						 float *pflSaturation, 
						 float *pflLightness)
{

	float flRed, flGreen, flBlue;

	flRed = ((float)((dwInputColor & 0x00FF0000) >> 16)) / 255.0f;
	flGreen = ((float)((dwInputColor & 0x0000FF00) >> 8)) / 255.0f;
	flBlue =  ((float)(dwInputColor & 0x000000FF)) / 255.0f;

    float flMin, flMax;

    if (flRed > flGreen && flRed > flBlue)
    {
        flMax = flRed;
        if (flGreen < flBlue)
            flMin = flGreen;
        else
            flMin = flBlue;
    }
    else if (flGreen > flBlue)
    {
        flMax = flGreen;
        if (flRed < flBlue)
            flMin = flRed;
        else
            flMin = flBlue;
    }
    else
    {
        flMax = flBlue;
        if (flGreen < flRed)
            flMin = flGreen;
        else
            flMin = flRed;
    }

    *pflLightness = (flMax + flMin) / 2;

    if ( CompareForEqualFloat(flMin, flMax) )
    {
        *pflSaturation = 0;
        *pflHue = 0;
    }
    else
    {
        if (*pflLightness <= 0.5f)
            *pflSaturation = (flMax - flMin) / (flMax + flMin);
        else
            *pflSaturation = (flMax - flMin) / (2 - flMax - flMin);

        if (CompareForEqualFloat(flRed, flMax))
        {
            if ( CompareForEqualFloat( flBlue, flMin ) )
                *pflHue = 1 + (flGreen - flRed) / (flMax - flMin);
            else
                *pflHue = 5 + (flRed - flBlue) / (flMax - flMin);
        }
        else if (CompareForEqualFloat(flGreen, flMax))
        {
            if ( CompareForEqualFloat( flRed, flMin ) )
                *pflHue = 3 + (flBlue - flGreen) / (flMax - flMin);
            else
                *pflHue = 1 + (flGreen - flRed) / (flMax - flMin);
        }
        else
        {
            if ( CompareForEqualFloat( flGreen, flMin ) )
                *pflHue = 5 + (flRed - flBlue) / (flMax - flMin);
            else
                *pflHue = 3 + (flBlue - flGreen) / (flMax - flMin);
        }

        *pflHue /= 6;
    }
} // GetHSLValue

//*****************************************************************************

HRESULT 
CUtils::GetVectorFromVariant(VARIANT *varVector,
                             int *piFloatsReturned, 
                             float *pflX, 
                             float *pflY, 
                             float *pflZ)
{

    DASSERT(varVector != NULL);
    DASSERT(piFloatsReturned != NULL);
    *piFloatsReturned = 0;

    HRESULT hr;
    hr = InsurePropertyVariantAsBSTR(varVector);
    if (FAILED(hr))
    {
        DPF_ERR("Error in parsing vector, variant is not a string");
        return hr;
    }
    LPWSTR pwzVector = varVector->bstrVal;
    DASSERT(pwzVector != NULL);
    
    if (pflX != NULL)
    {
        hr = ParseFloatValueFromString(&pwzVector, pflX);
        if (FAILED(hr))
        {
            DPF_ERR("error parsing X value from bstr in GetVectorFromVariant");
            return hr;
        }
        if (hr == S_OK)
            (*piFloatsReturned)++;
    }
    if (pflY != NULL && hr == S_OK)
    {
        hr = ParseFloatValueFromString(&pwzVector, pflY);
        if (FAILED(hr))
        {
            DPF_ERR("error parsing Y value from bstr in GetVectorFromVariant");
            return hr;
        }
        if (hr == S_OK)
            (*piFloatsReturned)++;
    }
    if (pflZ != NULL && hr == S_OK)
    {
        hr = ParseFloatValueFromString(&pwzVector, pflZ);
        if (FAILED(hr))
        {
            DPF_ERR("error parsing Z value from bstr in GetVectorFromVariant");
            return hr;
        }
        if (hr == S_OK)
            (*piFloatsReturned)++;
    }
    return S_OK;
} // GetVectorFromVariant

//*****************************************************************************

HRESULT CUtils::ParseFloatValueFromString(LPWSTR *ppwzFloatString, float *pflRet)
{
    DASSERT(ppwzFloatString);
    DASSERT(pflRet);

    SkipWhiteSpace(ppwzFloatString);

    // the following will look for the first null
    // char or first white space char, or first ',' 
    LPWSTR pwzDelimiter = *ppwzFloatString;
    while (*pwzDelimiter != L'\0' && !iswspace(*pwzDelimiter) && *pwzDelimiter != L',')
        pwzDelimiter++;
    // we need to save the character and replace it with 0
    WCHAR wcSave = *pwzDelimiter;
    *pwzDelimiter = L'\0';
    // we will scan for a float and the character following it
    // Getting the character following this insures there are no
    // non-digit characters other than our delimiter or whitespace
    WCHAR wcCheckNextChar = L'\0';
    int ret = swscanf(*ppwzFloatString, L"%f%C", pflRet, &wcCheckNextChar);
    *pwzDelimiter = wcSave;
    if (!iswspace(wcCheckNextChar) && wcCheckNextChar != L'\0')
    {
        DPF_ERR("Error in string, invalid chars");
        return E_INVALIDARG;
    }
    if (ret != 1)
    {
        return S_FALSE;
    }
    *ppwzFloatString = pwzDelimiter;
    return S_OK;

} // ParseFloatValueFromString

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\control\engine.h ===
#ifndef __ENGINE_H_
#define __ENGINE_H_

#include "resource.h"       // main symbols

#include "..\behaviors\headers.h"
#include "wtypes.h"
#include "danim.h"
#include "lmrt.h"
#include <wininet.h>
#include <docobj.h>
//#include <ocidl.h>
#include <control.h>
#include <strmif.h>


extern HINSTANCE hInst;

// The initial size for the stacks and temporary store
const static int INITIAL_SIZE = 100;

// The number of VAR_ARGS
const static int MAX_VAR_ARGS = 10;

// Engine status constants, based on HRESULT codes

// Engine should continue processing next instruction
static long STATUS_CONTINUE = S_OK;

// Engine found an unimplemented instruction
static long STATUS_UNIMPLEMENTED = 0xE0000001;

// Engine found an unsupported instruction
static long STATUS_UNSUPPORTED = 0xE0000002;

// Engine found an unknown instruction
static long STATUS_UNKNOWN = 0xE0000003;

// Engine encountered an error
static long STATUS_ERROR = 0xE0000004;

// Engine finished running the command stream
static long STATUS_FINISHED = 0x20000003;

static long STATUS_NODATA = 0xE0000005;

static long DEFAULT_ASYNC_BLKSIZE = 10000;

static ULONG EVENT_RESOLUTION = 25;

static ULONG DEFAULT_ASYNC_DELAY = 50;

static WCHAR* LMRT_EVENT_PREFIX = L"LMRT";
static ULONG LMRT_EVENT_PREFIX_LENGTH = 4;

class CLMReader;

class CLMNotifier;

class CLMExportTable;

class ByteArrayStream;

#define WORKERHWND_CLASS "LMEngineWorkerPrivateHwndClass"

#define WM_LMENGINE_TIMER_CALLBACK	(WM_USER + 1000)
#define WM_LMENGINE_DATA			(WM_USER + 2000)
#define WM_LMENGINE_SCRIPT_CALLBACK	(WM_USER + 3000)

class CLMEngineInstrData
{
public:
	BOOLEAN			pending;
	ByteArrayStream	*byteArrayStream;
};

class CLMEngineScriptData
{
public:
	BSTR scriptSourceToInvoke;
	BSTR scriptLanguage;
	IDAEvent	*event;
	IDABehavior	*eventData;
};

class ATL_NO_VTABLE CLMEngineWrapper:
	public CComObjectRootEx<CComMultiThreadModel>,
	public ILMEngineWrapper
{
public:
	CLMEngineWrapper();
	~CLMEngineWrapper();

BEGIN_COM_MAP(CLMEngineWrapper)
	COM_INTERFACE_ENTRY(ILMEngineWrapper)
END_COM_MAP()

	STDMETHOD(GetWrapped)(IUnknown **ppWrapped);
	STDMETHOD(SetWrapped)(IUnknown *pWrapped);
	STDMETHOD(Invalidate)();

private:
	IUnknown *m_pWrapped;
	bool m_bValid;
};


// Provides an abstraction of a stream of instruction codes
// Subclasses will implement synchronous, asynchronous, and callback specifics
class CodeStream
{
public:
	// Mark the stream for potential rewind
	STDMETHOD (Commit)() = 0;
	
	// Revert the stream to the last commit
	STDMETHOD (Revert)() = 0;

	// Reads a byte from the instruction stream.  Returns -1 on EOF,
	// which is why it returns a short, not a BYTE
	STDMETHOD(readByte)(BYTE *pByte) = 0;

	// Reads count BYTES into the given buffer.  Returns -1 if reaches EOF
	// before being done
	STDMETHOD(readBytes)(BYTE *pByte, ULONG count, ULONG *pNumRead) = 0;
	
	//ensure that the blocksize used by this code stream is at least blockSize
	STDMETHOD(ensureBlockSize)(ULONG blockSize) = 0;

	virtual ~CodeStream() {};
};

class ATL_NO_VTABLE CLMEngine : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CLMEngine, &CLSID_LMEngine>,
	public IDispatchImpl<ILMEngine2, &IID_ILMEngine2, &LIBID_LiquidMotion>,
    public IObjectSafetyImpl<CLMEngine>,
	public IBindStatusCallbackImpl<CLMEngine>,
	public ILMCodecDownload,
	public ILMEngineExecute
{
public:
	CLMEngine();
	~CLMEngine();

DECLARE_REGISTRY(CLSID_LMEngine,
                 "LiquidMotion" ".LMEngine.1",
                 "LiquidMotion" ".LMEngine",
                 0,
                 THREADFLAGS_BOTH);

BEGIN_COM_MAP(CLMEngine)
	COM_INTERFACE_ENTRY(ILMEngine2)
    COM_INTERFACE_ENTRY(ILMEngine)
    COM_INTERFACE_ENTRY(IDispatch)
//    COM_INTERFACE_ENTRY_IID(__uuidof(ILMStartStop), ILMStartStop)
    COM_INTERFACE_ENTRY(ILMCodecDownload)
	COM_INTERFACE_ENTRY(ILMEngineExecute)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    COM_INTERFACE_ENTRY_IMPL(IBindStatusCallback)
END_COM_MAP()

	STDMETHOD(runFromStream)(/*[in]*/ LPSTREAM pStream);
	STDMETHOD(runFromURL)(/*[in]*/ BSTR url);
	STDMETHOD(initFromBytes)(BYTE *array, ULONG size);
	STDMETHOD(initAsync)();
	STDMETHOD(put_ClientSite)(/*[in]*/ IOleClientSite *clientSite);
    STDMETHOD(get_Image)(/*[out, retval]*/ IDAImage **pVal);
    STDMETHOD(get_Sound)(/*[out, retval]*/ IDASound **pVal);
	STDMETHOD(put_Reader)(/*[in]*/ ILMReader *reader);
	STDMETHOD(SetStatusText)(BSTR text);
	STDMETHOD(Notify)(IDABehavior *eventData,
					  IDABehavior *curRunningBvr,
					  IDAView *curView,
					  IDABehavior **ppBvr);
	STDMETHOD(GetBehavior)(/*[in, string]*/ BSTR tag,
						   /*[in]*/ IDABehavior *pIDefaultBvr,
						   /*[out, retval]*/ IDABehavior **pVal);
	STDMETHOD(ExecuteFromAsync)();
	STDMETHOD(SetAsyncBlkSize)(LONG blkSize);
	STDMETHOD(SetAsyncDelay)(LONG delay);

	static void CALLBACK TimerCallback(
						     UINT wTimerID,
                             UINT msg,
                             DWORD_PTR dwordUser,
                             DWORD_PTR unused1,
                             DWORD_PTR unused2);
	static LRESULT  CALLBACK WorkerWndProc(HWND hwnd,
										   UINT msg,
										   WPARAM wParam,
										   LPARAM lParam);

// IObjectSafetyImpl
	STDMETHOD(SetInterfaceSafetyOptions)(
							/* [in] */ REFIID riid,
							/* [in] */ DWORD dwOptionSetMask,
							/* [in] */ DWORD dwEnabledOptions);
	STDMETHOD(GetInterfaceSafetyOptions)(
							/* [in] */ REFIID riid, 
							/* [out] */DWORD *pdwSupportedOptions, 
							/* [out] */DWORD *pdwEnabledOptions);

// IBindStatusCallbackImpl
	STDMETHOD(OnDataAvailable)(
		/* [in] */ DWORD grfBSCF, 
		/* [in] */ DWORD dwSize,
		/* [in] */ FORMATETC *pfmtetc, 
		/* [in] */ STGMEDIUM * pstgmed);

	STDMETHOD(OnMemDataAvailable)(BOOLEAN lastBlock, 
								  DWORD blockSize,
							      BYTE *block);

	STDMETHOD(OnStopBinding)(/* [in] */HRESULT hrStatus, /*[in, string]*/ LPCWSTR szStatusText);
	STDMETHOD(OnStartBinding)(DWORD dwReserved, IBinding *pBinding);
	STDMETHOD(GetBindInfo)(DWORD *pgrfBINDF, BINDINFO *pbindInfo);

	STDMETHOD(releaseFilterGraph)();
	STDMETHOD(releaseAllFilterGraph)();

    STDMETHODIMP Start(LONGLONG rtNow);
    STDMETHODIMP Stop();
    STDMETHODIMP SetMediaCacheDir(WCHAR *wszM); 

	STDMETHOD(disableAutoAntialias)();

	STDMETHOD(ensureBlockSize)(ULONG blockSize);
    
	STDMETHOD(getExecuteFromUnknown)( IUnknown *pUnk, ILMEngineExecute **ppExecute );
	STDMETHOD(getEngine2FromUnknown)( IUnknown *pUnk, ILMEngine2 **ppEngine2 );
	STDMETHOD(getIDispatchOnHost)( IDispatch **ppHostDisp );

	/**
	*  ILMCodecDownload
	*/
	STDMETHOD(setAutoCodecDownloadEnabled)(BOOL bEnabled);

	/**
	*  ILMEngineExecute
	*/
	STDMETHOD (ExportBehavior)(BSTR key, IDABehavior *toExport);
	STDMETHOD (SetImage)(IDAImage *pImage);
	STDMETHOD (SetSound)(IDASound *pSound);

protected:

	ILMEngineWrapper *m_pWrapper;
	// The image that will be set by Engine.setImage and
	// returned after executing the instruction stream
	IDAImage *m_pImage;

	// The sound that will be set by Engine.setSound and
	// returned after executing the instruction stream
	IDASound *m_pSound;

	// The IDAStatics object used to make Statics calls
	IDAStatics *staticStatics;

	// The LMReader control 
	ILMReader2 *m_pReader;

	// Export behavior table
	CLMExportTable	*m_exportTable;

	// A CodeStream from which the instructions are being read
	CodeStream *codeStream;

	// Called to validate the header
	HRESULT validateHeader();

	// Called to execute instructions from the current
	// instruction stream
	HRESULT execute();
	
	// Reads a LONG from the instruction stream.  Does NOT return -1 on EOF
	STDMETHOD(readLong)(LPLONG pLong);

	// Reads a SIGNED LONG from the instruction stream.  Does NOT return -1 on EOF
	STDMETHOD(readSignedLong)(LPLONG pLong);

	// Reads a float from the instruction stream
	STDMETHOD(readFloat)(PFLOAT pFloat);

	// Reads a double from the instruction stream
	STDMETHOD(readDouble)(double *pDouble);

	// Stack of LONGS
	LONG *longStack;
	LONG *longTop;
	LONG longStackSize;

	// Stack of doubles
	double *doubleStack;
	double *doubleTop;
	int doubleStackSize;

	// Array of doubles
	double *doubleArray;
	long doubleArrayLen;
	long doubleArrayCap;

	// Stack of strings
	BSTR *stringStack;
	BSTR *stringTop;
	int stringStackSize;

	// Stack of COM objects
	IUnknown **comStack;
	IUnknown **comTop;
	int comStackSize;

	// Stack of arrays of COM objects
	IUnknown ***comArrayStack;
	IUnknown ***comArrayTop;
	// Stack of array lengths
	LONG *comArrayLenStack;
	LONG *comArrayLenTop;
	int comArrayStackSize;

	// Array of temporary COM objects, accessed through the
	// copy to temp and copy from temp instructions.  Stores
	// reused COM values.  Other values cannot be reused.
	IUnknown **comStore;
	int comStoreSize;

	// Array for var args
	VARIANTARG varArgs[MAX_VAR_ARGS];
	VARIANTARG varArgReturn;
	int nextVarArg;

	// Release var args
	HRESULT releaseVarArgs();

	//The appTriggeredEvent that will be triggered when we get a stop()
	IDAEvent *m_pStopEvent;

	//The appTriggeredEvent that will be triggered when we get a start()
	IDAEvent *m_pStartEvent;

	STDMETHOD(SetStartEvent)(IDAEvent *pNewStartEvent, BOOL bOverwrite);
	STDMETHOD(SetStopEvent)(IDAEvent *pNewStopEvent, BOOL bOverwrite);

	//The pointer the parent of this engine. Only set if this engine is
	//  running a notifier.
	ILMEngine2 *m_pParentEngine;

	STDMETHOD(setParentEngine)(ILMEngine2 *parent);
	STDMETHOD(clearParentEngine)();

	//gets the current time from the filter graph that is driving this engine,
	// or the parent engine if this engine is running a notifier.
	// returns -1 if this engine is not streaming
	STDMETHOD(getCurrentGraphTime)(double *pGraphTime);

	//A pointer to the IMediaPosition on the current filter graph, if there
	// is one.
	IMediaPosition* m_pMediaPosition;

	//A pointer to the IMediaEventSink on the current filter graph, if there
	// is one
	IMediaEventSink* m_pMediaEventSink;

	//get the Pointer to the IMediaPosition on the current FilterGraph.
	STDMETHOD(getIMediaPosition)(IMediaPosition **ppMediaPosition);

	//get the Pointer to the IMediaEventSink on the current FilterGraph.
	STDMETHOD(getIMediaEventSink)(IMediaEventSink **ppMediaEventSink);

	double parseDoubleFromVersionString( BSTR version );
	double getDAVersionAsDouble();
	double getLMRTVersionAsDouble();

	bool m_bEnableAutoAntialias;

	BOOL m_bAutoCodecDownloadEnabled;

	// Flag indicating whether or not header has been read
	BOOL	m_bHeaderRead;

	ULONG	m_PrevRead;

	CComPtr<IBindStatusCallback>	m_pIbsc;
	CComPtr<IBinding>				m_spBinding;

    CComPtr<IMediaControl> m_pmc; // activemovie graph
#ifdef DEBUG
    bool m_fDbgInRenderFile;
#endif

	DWORD	m_millisToUse;
	BOOL	m_bPending;
	ULONG	m_AsyncBlkSize;
	ULONG	m_AsyncDelay;
	MMRESULT m_Timer;

	BOOL	m_bAbort;
	BOOL	m_bMoreToParse;
	HANDLE	m_hDoneEvent;

	// Releases all refs to any remaining COM objects
	void releaseAll();

	// Free a COM array, with zero test
	void freeCOMArray(IUnknown **array, LONG length);

	// Free a COM object, with zero test
	inline void freeCOM(IUnknown *com) {
		if (com != 0)
			com->Release();
	}

	// Ensure that the doubleArray has requested capacity
	HRESULT ensureDoubleArrayCap(long cap);

	STDMETHOD(initNotify)(BYTE *bytes, ULONG count, IDAUntilNotifier **pNotifier);

	// The current notifier
	CLMNotifier *notifier;

        BSTR m_bstrMediaCacheDir;
	IOleClientSite *m_pClientSite;
	
	HWND	m_workerHwnd;

	CRITICAL_SECTION m_CriticalSection;

	STDMETHOD(navigate)(/* [in] */BSTR url, 
						/* [in] */BSTR location,
						/* [in] */BSTR frame, 
						/* [in] */int newWindowFlag);
	STDMETHOD(getDAViewerOnPage)(BSTR tag, IDAViewerControl **pVal);
	STDMETHOD(getElementOnPage)(BSTR tag, IUnknown **pVal);
	STDMETHOD(callScriptOnPage)(/*[in, string]*/BSTR scriptSourceToInvoke,
								/*[in, string]*/BSTR scriptLanguage);
	STDMETHOD(createObject)(BSTR str, IUnknown **ppObj);
	STDMETHOD(invokeDispMethod)(IUnknown *pIUnknown, BSTR method, WORD wFlags, 
					  unsigned int nArgs, VARIANTARG *pV, VARIANT *pRetV);
	STDMETHOD(initVariantArg)(BSTR arg, VARTYPE type, VARIANT *pV);
	STDMETHOD(initVariantArgFromString)(BSTR arg, VARIANT *pV);
	STDMETHOD(initVariantArgFromLong)(long lVal, int type, VARIANT *pV);
	STDMETHOD(initVariantArgFromDouble)(double dbl, int type, VARIANT *pV);
	STDMETHOD(initVariantArgFromIUnknown)(IUnknown *pI, int type, VARIANT *pV);
	STDMETHOD(initVariantArgFromIDispatch)(IDispatch *pI, int type, VARIANT *pV);
	STDMETHOD_(char *, GetURLOfClientSite)(void);
	STDMETHOD(StartTimer)();
	STDMETHOD(InitTimer)();
	STDMETHOD(createMsgWindow)();
	STDMETHOD(TimerCallbackHandler)();
	STDMETHOD(NewDataHandler)(CLMEngineInstrData *d);
	STDMETHOD(AbortExecution)();
	STDMETHOD_(BSTR, ExpandImportPath)(BSTR path);
};

// A CodeStream that reads out of a synchronous stream
class SyncStream : public CodeStream
{
public:
	// Constructs a SyncStream that reads from the given LPSTREAM
	SyncStream(LPSTREAM pStream);

	SyncStream::~SyncStream(void);	// Destructor

	STDMETHOD (Commit)();
	STDMETHOD (Revert)();
	STDMETHOD (readByte)(LPBYTE pByte);
	STDMETHOD (readBytes)(LPBYTE pByte, ULONG count, ULONG *pNumRead);
	STDMETHODIMP ensureBlockSize(ULONG blockSize) 
		{ return S_OK; }

protected:
	// Stream that the instructions are being read from
	LPSTREAM m_pStream;
};

// A CodeStream that reads out of an array of bytes
class ByteArrayStream : public CodeStream
{
public:
	// Constructs a ByteArrayStream that reads from the given array of the given size
	// The array is copied into a local array
	ByteArrayStream(LPBYTE array, ULONG size);
	
	~ByteArrayStream(void);

	STDMETHOD (Commit)();
	STDMETHOD (Revert)();
	bool hasBufferedData();
	STDMETHOD (readByte)(LPBYTE pByte);
	STDMETHOD (readBytes)(LPBYTE pByte, ULONG count, ULONG *pNumRead);
	STDMETHODIMP ensureBlockSize(ULONG blockSize)
		{return S_OK;}
	
	// Reset the stream to start reading at the beginning
	void reset();
	
protected:
	// Array that the bytes are being read from
	BYTE *array;
	
	// The size of the array
	ULONG size;
	
	// Pointer to next byte
	BYTE *next;
	
	// Remaining count
	ULONG remaining;

	// Mark for potential rewind
	BYTE *mark;
};

class ByteArrayStreamQueue
{
public:
	ByteArrayStream			*pBAStream;
	ByteArrayStreamQueue	*next;
};

// A CodeStream that reads out of a list of ByteArrayStreams to handle asynchronous reading from
// a stream with the ability to do mark & revert
class AsyncStream : public CodeStream
{
public:
	// Constructs an AsyncStream that reads from the given LPSTREAM
	AsyncStream(ByteArrayStream *pBAStream, ULONG blkSize);
	
	~AsyncStream(void); // Destructor
	
	STDMETHOD (Commit)();
	STDMETHOD (Revert)();
	bool hasBufferedData();
	STDMETHOD (readByte)(LPBYTE pByte);		
	STDMETHOD (readBytes)(LPBYTE pByte, ULONG count, ULONG *pNumRead);
	STDMETHOD(ensureBlockSize)(ULONG blockSize);
	STDMETHOD (SetPending)(BOOL bFlag);
	STDMETHOD (AddByteArrayStream)(ByteArrayStream *pNewBAStream);
	STDMETHOD (ResetBlockRead)();

protected:
	// Queue of ByteArrayStreams for handling mark & revert
	ByteArrayStreamQueue	*pBAStreamQueue;
	ByteArrayStreamQueue	*pBAStreamQueueTail;
	ByteArrayStreamQueue	*pBAStreamQueueHead;

	BOOL	m_bPendingData;
	ULONG	m_nRead;
	ULONG	m_BlkSize;
};

class CLMNotifier : public IDAUntilNotifier
{
protected:
	long				_cRefs;
	CLMEngine*			m_pEngine;		

public:

	CLMNotifier(CLMEngine *pEngine);
	~CLMNotifier();

	STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
	STDMETHOD_(ULONG, AddRef)(); 
	STDMETHOD_(ULONG, Release)();
	

	STDMETHOD(GetTypeInfoCount)(UINT *pctinfo);
	STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
	STDMETHOD(GetIDsOfNames)(
		REFIID riid, LPOLESTR *rgszNames, UINT cNames,
		LCID lcid, DISPID *rgdispid);
	STDMETHOD(Invoke)(
		DISPID dispidMember, REFIID riid, LCID lcid,
		WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
		EXCEPINFO *pexcepinfo, UINT *puArgErr);
	STDMETHOD(ClearEngine)();
	STDMETHOD(Notify)(IDABehavior *eventData,
						IDABehavior *curRunningBvr,
						IDAView *curView,
						IDABehavior **ppBvr);
};

struct CLMExportList
{
	BSTR			tag;
	IDABehavior		*pBvr;
	CLMExportList	*next;
};

class CLMExportTable
{
protected:
	int				m_nBvrs;
	CLMExportList	*m_exportList;
	CLMExportList	*m_tail;
	IDAStatics		*m_pStatics;

public:
	CLMExportTable(IDAStatics *pStatics);
	~CLMExportTable();

	STDMETHOD (AddBehavior)(BSTR tag, IDABehavior *pBvr);
	STDMETHOD (GetBehavior)(BSTR tag, IDABehavior *pIDefaultBvr, IDABehavior **ppBvr);
};

class URLRelToAbsConverter
{
  public:
	URLRelToAbsConverter(LPSTR baseURL, LPSTR relURL);
	LPSTR GetAbsoluteURL ();
  protected:
    char _url[INTERNET_MAX_URL_LENGTH] ;
} ;

class URLCombineAndCanonicalizeOLESTR
{
  public:
    URLCombineAndCanonicalizeOLESTR(char * base, LPOLESTR path);
    LPSTR GetURL ();
	LPWSTR GetURLWide ();
  protected:
    char _url[INTERNET_MAX_URL_LENGTH] ;
	WCHAR _urlWide[INTERNET_MAX_URL_LENGTH];
} ;


#endif // __ENGINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\control\engine.cpp ===
#include "Engine.h"
#include <evcode.h>
#include <hlink.h>
#include <oleidl.h>
#include <oleauto.h>
#include <mshtml.h>
#include <uuids.h>
#include <control.h>
#include <lmrtrend.h>

#define MIN(a, b)	(((a) <= (b)) ? (a) : (b))
#define MAX(a, b)	(((a) > (b)) ? (a) : (b))

const IID IID_ILMRTRenderer = {0x3c89d120,0x6f65,0x11d1,{0xa5,0x20,0x0,0x0,0x0,0x0,0x0,0x0}};

static inline void WideToAnsi(LPOLESTR wide, char *ansi) {
    if (wide) {
        WideCharToMultiByte(CP_ACP, 0,
                            wide, -1,
                            ansi,
                            INTERNET_MAX_URL_LENGTH - 1,
                            NULL, NULL);
    } else {
        ansi[0] = '\0';
    }
}

static inline void AnsiToWide( char *ansi, LPWSTR wide )
{
	if( ansi != NULL )
	{
		MultiByteToWideChar( CP_ACP, 0,
							 ansi,
							 -1,
							 wide,
							 INTERNET_MAX_URL_LENGTH -1 );
	}
	else
	{
		wide[0] = L'\0';
	}
}

CLMEngineWrapper::CLMEngineWrapper(): m_pWrapped(NULL), m_bValid(false)
{
}

CLMEngineWrapper::~CLMEngineWrapper()
{
	m_pWrapped = NULL;
}


STDMETHODIMP CLMEngineWrapper::GetWrapped( IUnknown **ppWrapped )
{
	if( ppWrapped == NULL )
		return E_POINTER;

	if( !m_bValid )
	{
		(*ppWrapped) = NULL;
		return E_FAIL;
	}
	
	if( m_pWrapped == NULL )
		return E_FAIL;
	
	(*ppWrapped) = m_pWrapped;
	m_pWrapped->AddRef();
	
	return S_OK;
}

STDMETHODIMP CLMEngineWrapper::SetWrapped( IUnknown *pWrapped )
{
	if( m_pWrapped != NULL )
		return E_FAIL;
	if( pWrapped == NULL )
		return E_POINTER;
	//we do not add ref here because this is a weak ref
	m_pWrapped = pWrapped;
	m_bValid = true;
	
	return S_OK;
}

STDMETHODIMP CLMEngineWrapper::Invalidate()
{
	m_bValid = false;
	return S_OK;
}

/**
* Constructor
*/
CLMEngine::CLMEngine()
{

	CComObject<CLMEngineWrapper> *pWrapper;
	CComObject<CLMEngineWrapper>::CreateInstance( &pWrapper );
	m_pWrapper = NULL;
	pWrapper->QueryInterface( IID_ILMEngineWrapper, (void**)&m_pWrapper );
	m_pWrapper->SetWrapped( GetUnknown() );

	longStackSize = INITIAL_SIZE;
	longTop = longStack = new LONG[longStackSize];

	doubleStackSize = INITIAL_SIZE;
	doubleTop = doubleStack = new double[doubleStackSize];

	stringStackSize = INITIAL_SIZE;
	stringTop = stringStack = new BSTR[stringStackSize];

	comStackSize = INITIAL_SIZE;
	comTop = comStack = new IUnknown*[comStackSize];

	comArrayStackSize = INITIAL_SIZE;
	comArrayTop = comArrayStack = new IUnknown**[comArrayStackSize];
	comArrayLenTop = comArrayLenStack = new long[comArrayStackSize];

	comStoreSize = INITIAL_SIZE;
	comStore = new IUnknown*[comStoreSize];
	// Make sure it is initialized, so that we can release it later on
	for (int i=0; i<comStoreSize; i++)
		comStore[i] = 0;

	for (int j=0; j<MAX_VAR_ARGS; j++)
		varArgs[j].vt = VT_EMPTY;
	varArgReturn.vt = VT_EMPTY;
	nextVarArg = 0;

	doubleArray = 0;

	m_pReader = NULL;

	HRESULT hr = CoCreateInstance(
		CLSID_DAStatics,
		NULL,
		CLSCTX_INPROC_SERVER,
		IID_IDAStatics,
		(void **) &staticStatics);

	m_pImage = NULL;
	m_pSound = NULL;

	m_exportTable = new CLMExportTable(staticStatics);

	codeStream = 0;
	notifier = 0;
	m_pClientSite = 0;
	m_PrevRead = 0;
	m_AsyncDelay = DEFAULT_ASYNC_DELAY;
	m_AsyncBlkSize = DEFAULT_ASYNC_BLKSIZE;
	m_Timer = NULL;
	m_workerHwnd = NULL;
	m_hDoneEvent = NULL;
	m_bAbort = FALSE;
	m_bMoreToParse = FALSE;

	m_pStartEvent = NULL;
	m_pStopEvent = NULL;
        m_bstrMediaCacheDir = 0;

	m_pMediaPosition = NULL;

	m_pMediaEventSink = NULL;

	m_pParentEngine = NULL;

	m_bEnableAutoAntialias = false;

	m_bAutoCodecDownloadEnabled = FALSE;

	createMsgWindow();

	InitializeCriticalSection(&m_CriticalSection);
}

/**
* Destructor
*/
CLMEngine::~CLMEngine()
{
	if( m_pWrapper != NULL )
	{
		m_pWrapper->Invalidate();
		m_pWrapper->Release();
	}

	if (codeStream)
		delete codeStream;

	if (m_pImage)
		m_pImage->Release();

	if (m_pSound)
		m_pSound->Release();

	if (staticStatics)
		staticStatics->Release();

	if (notifier) {
		// Clear out the engine in case DA still has a ref to the notifier
		notifier->ClearEngine();
		notifier->Release();
	}

	if (longStack)
		delete[] longStack;

	if (doubleStack)
		delete[] doubleStack;

	if (doubleArray)
		delete[] doubleArray;

	if (stringStack)
		delete[] stringStack;

	if (comStack)
		delete[] comStack;

	if (comArrayStack)
		delete[] comArrayStack;

	if (comArrayLenStack)
		delete[] comArrayLenStack;

	if (comStore)
		delete[] comStore;

	if (m_Timer)
		timeKillEvent(m_Timer);

	if (m_exportTable)
		delete m_exportTable;

	if (m_workerHwnd) {
		DestroyWindow (m_workerHwnd);
		UnregisterClass(WORKERHWND_CLASS, hInst);
	}

	if (m_hDoneEvent)
		CloseHandle(m_hDoneEvent);

	if( m_pStartEvent != NULL )
		m_pStartEvent->Release();

	if( m_pStopEvent != NULL )
		m_pStopEvent->Release();

	if( m_pMediaPosition != NULL )
		m_pMediaPosition->Release();

	if( m_pMediaEventSink != NULL )
		m_pMediaEventSink->Release();

	DeleteCriticalSection(&m_CriticalSection);

        SysFreeString(m_bstrMediaCacheDir);
}

/**
* Tell the engine what reader constructed it.
* The engine will call back to the reader to get info now and again
*/
STDMETHODIMP CLMEngine::put_Reader(ILMReader *reader)
{
	CComQIPtr<ILMReader2, &IID_ILMReader2> pLMReader( reader );
	if( pLMReader == NULL )
	{
		m_pReader = NULL;
		return E_NOINTERFACE;
	}

	m_pReader = pLMReader;
	return S_OK;
}

/**
* Tell the engine what the client site is
*/
STDMETHODIMP CLMEngine::put_ClientSite(IOleClientSite *clientSite)
{
	// Must set client site so that relative URL's can work
	// TODO: Check that clientSite is non-null and this call succeeds
    if (!clientSite) {
        return E_POINTER;
    }

	m_pClientSite = clientSite;
	staticStatics->put_ClientSite(clientSite);

	return S_OK;
}

/**
* Execute the instructions in the passed stream synchronously
*/
STDMETHODIMP CLMEngine::runFromStream(LPSTREAM pStream)
{
#if 0
	char cbuf[100];
	sprintf(cbuf, "CLMEngine::run(0x%X)", pStream);
	MessageBox(NULL, cbuf, "CLMEngine", MB_OK);
#endif
	codeStream = new SyncStream(pStream);

	HRESULT hr;

	if (!SUCCEEDED(hr = validateHeader()))
		return hr;

	hr = execute();

	releaseAll();

	return hr;
}

/**
* Set this engine up to read instructions from the passed byte array.
* Used to set up UntilNotifiers where the entire set of instructions is
* known in a single block
*/
STDMETHODIMP CLMEngine::initFromBytes(BYTE *array, ULONG size)
{
	codeStream = new ByteArrayStream(array, size);

	return S_OK;
}

/**
* Get the base URL of document in the client site
*/
STDMETHODIMP_(char*) CLMEngine::GetURLOfClientSite(void)
{
	char	*_clientSiteURL = NULL;
	
	// Fail gracefully if we don't have a client site, since not
	// all uses will.
	if (m_pClientSite) {
		
		// However, if we do have a client site, we should be able
		// to get these other elements.  If we don't, assert.
		// (TODO: what's going to happen in IE3?)
		CComPtr<IOleContainer>			pRoot;
		CComPtr<IHTMLDocument2>			pDoc2;
		if (FAILED(m_pClientSite->GetContainer(&pRoot)) ||
			FAILED(pRoot->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc2)))
			return NULL;

		CComPtr<IHTMLElementCollection>	pElementCollection;
		if (FAILED(pDoc2->get_all(&pElementCollection)))
			return NULL;

		CComVariant baseName;
		baseName.vt = VT_BSTR;
		baseName.bstrVal = SysAllocString(L"BASE");

		CComPtr<IDispatch>				pDispatch;
		if (FAILED(pElementCollection->tags(baseName, &pDispatch)))
			return NULL;

                pElementCollection.Release();

		if (FAILED(pDispatch->QueryInterface(IID_IHTMLElementCollection, (void **)&pElementCollection)))
			return NULL;

                pDispatch.Release();

		CComVariant	index;
		index.vt = VT_I2;
		index.iVal = 0;
		BSTR tempBstr = NULL;
		if (FAILED(pElementCollection->item(index, index, &pDispatch)))
		{
			if (FAILED(pDoc2->get_URL(&tempBstr)))
				return NULL;
		}
		else
		{
			// There seems to be a bug wherein item() doesn't fail but sets pDispatch to NULL
			if (pDispatch.p == NULL)
			{
				if (FAILED(pDoc2->get_URL(&tempBstr)))
					return NULL;
			}
			else
			{
				CComPtr<IHTMLBaseElement>		pBaseElement;
				if (FAILED(pDispatch->QueryInterface(IID_IHTMLBaseElement, (void **)&pBaseElement)))
					return NULL;
				
				if (FAILED(pBaseElement->get_href(&tempBstr)))
					return NULL;
			}
		}

		long len = lstrlenW(tempBstr);
		_clientSiteURL = new char[(len + 1) * 2 * sizeof(char)] ;
		
		if (_clientSiteURL) {
			// Need to pass in len + 1 to get the terminator
			AtlW2AHelper(_clientSiteURL,tempBstr,len + 1);
		}
		
		SysFreeString(tempBstr);
	}

	return _clientSiteURL;
}

/**
* Initialize the engine to read asynchronously
*/
STDMETHODIMP CLMEngine::initAsync()
{
	CComPtr<IDAImage>	splashImage;
	CComPtr<IDASound>	splashSound;
	
	// Create a splash screen in a modifiable image behavior
	staticStatics->get_EmptyImage(&splashImage);
	staticStatics->ModifiableBehavior(splashImage, (IDABehavior **)&m_pImage);
	
	// Create a splash sound in a modifiable sound behavior
	staticStatics->get_Silence(&splashSound);
	staticStatics->ModifiableBehavior(splashSound, (IDABehavior **)&m_pSound);
	
	m_bHeaderRead = FALSE;
	m_bPending = TRUE;

	HRESULT hr = InitTimer();
	if (!SUCCEEDED(hr))
		return hr;

	m_PrevRead = 0;

	m_hDoneEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);

	return S_OK;
}


HRESULT FindInterfaceOnGraph(IFilterGraph *pGraph, REFIID riid, void **ppInterface)
{
    *ppInterface= NULL;

    IEnumFilters *pEnum;
    HRESULT hr = pGraph->EnumFilters(&pEnum);
    if(SUCCEEDED(hr))
    {
        hr = E_NOINTERFACE;
        IBaseFilter *pFilter;
    
        // find the first filter in the graph that supports riid interface
        while(!*ppInterface && pEnum->Next(1, &pFilter, NULL) == S_OK)
        {
            hr = pFilter->QueryInterface(riid, ppInterface);
            pFilter->Release();
        }

        pEnum->Release();
    }
    return hr;
}

IPin *GetPin(IBaseFilter *pf)
{
    IPin *pip = 0;
    
    IEnumPins *pep;
    HRESULT hr = pf->EnumPins(&pep);
    if(SUCCEEDED(hr))
    {
        pep->Next(1, &pip, 0);
        pep->Release();
    }

    return pip;
}

HRESULT UseDsound(IGraphBuilder *pGB)
{
    HRESULT hr = S_OK;
    
    IBasicAudio *pba;
    if(FindInterfaceOnGraph(pGB, IID_IBasicAudio, (void **)&pba) == S_OK)
    {
        IBaseFilter *pfwo;
                
        hr = pba->QueryInterface(IID_IBaseFilter, (void **)&pfwo);
        if(SUCCEEDED(hr))
        {
            CLSID clsfil;
            hr= pfwo->GetClassID(&clsfil);
            if(clsfil != CLSID_DSoundRender)
            {
                IPin *pip = GetPin(pfwo);
                if(pip)
                {
                    IPin *pop;
                    if(pip->ConnectedTo(&pop) == S_OK)
                    {
                        if(pGB->RemoveFilter(pfwo) == S_OK)
                        {
                            IBaseFilter *pfds;
                            hr = CoCreateInstance(CLSID_DSoundRender, 0, CLSCTX_INPROC, IID_IBaseFilter, (void **)&pfds);
                            if(SUCCEEDED(hr))
                            {
                                hr = pGB->AddFilter(pfds, L"ds");
                                if(SUCCEEDED(hr))
                                {
                                    IPin *pipds = GetPin(pfds);
                                    if(pipds) {
                                        hr = pGB->Connect(pop, pipds);
                                        pipds->Release();
                                    }
                                    else {
                                        hr = E_UNEXPECTED;
                                    }
                                }
                                pfds->Release();
                            }
                        }
                        pop->Release();
                    }

                    pip->Release();
                }
            }
                    
            pfwo->Release();
        }

        pba->Release();
    }

    return hr;
}


/**
* Read from a URL.  Checks Async flag to see whether the file should
* be read synchronously or asynchronously
*/
STDMETHODIMP CLMEngine::runFromURL(BSTR url)
{
	VARIANT_BOOL	bAsync;
	HRESULT			hr = S_OK;
	IStream			*pStream;

    if( m_pReader == NULL )
        return E_FAIL;

	// Get the proper URL
	char *clientURL = GetURLOfClientSite();
	URLCombineAndCanonicalizeOLESTR canonURL(clientURL, url);
	free(clientURL);

	// Are we reading async?
	m_pReader->get_Async(&bAsync);

	// If url points to a .avi or .asf file, then stream it in
	wchar_t  *suffix = wcsrchr(url, '.');

	if (suffix != NULL && (!wcsicmp(suffix, L".asf") || !wcsicmp(suffix, L".avi")))
	{
            _ASSERTE(m_pmc == 0);
            
            // Need to stream the file
            // Create a filter graph instantiated from the URL
            if (!SUCCEEDED(hr = CoCreateInstance(CLSID_FilterGraph,
                                                 NULL,
                                                 CLSCTX_INPROC,
                                                 IID_IMediaControl,
                                                 (void **)&m_pmc)))
            {
                return hr;
            }

            CComPtr<IGraphBuilder> pGB;
            if (!SUCCEEDED(hr = m_pmc->QueryInterface(IID_IGraphBuilder, (void **)&pGB)))
                return hr;

            hr = UseDsound(pGB);
            if(FAILED(hr)) {
                return hr;
            }

			if( m_bAutoCodecDownloadEnabled == TRUE )
			{
				CComQIPtr<IObjectWithSite, &IID_IObjectWithSite> siteTarget(m_pmc);
				if( siteTarget != NULL )
					siteTarget->SetSite(m_pReader);
			}

#ifdef DEBUG
            m_fDbgInRenderFile = true;
#endif
            

			
            // RenderFile can dispatch messages and call back into us
			if (!SUCCEEDED(hr = pGB->RenderFile(canonURL.GetURLWide(), NULL))) {
                // !!! map quartz errors to standard errors
                return hr;
            }

#ifdef DEBUG
            m_fDbgInRenderFile = false;
#endif

            if(m_pmc == 0) {
                return E_ABORT;
            }


            // Locate the LMRT Renderer filter. 
            CComPtr<ILMRTRenderer> pLMFilter;
            if (!SUCCEEDED(hr = FindInterfaceOnGraph(pGB, IID_ILMRTRenderer, (void **)&pLMFilter))) {
                // probably the file doesn't have a .XT stream
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            // Initialize for async reads from memory blocks
            if (!SUCCEEDED(hr = initAsync()))
                return hr;

            // Set the engine on it. This creates a circular reference
            // count as long as we hold the filter (through m_pmc). So
            // we have to make sure the filter (and the graph) are
            // released before our destructor.
            
            pLMFilter->SetLMEngine(this);

            if (!SUCCEEDED(hr = m_pmc->Run())) {
                return hr;
            }

            //long evCode;
            //hr = pME->WaitForCompletion(INFINITE, &evCode);

	} else if (bAsync) {
		// Initialize for async reads
		hr = initAsync();
		if (!SUCCEEDED(hr))
			return hr;

		// Get BindStatusCallback interface
		m_pIbsc = 0;
		hr = GetUnknown()->QueryInterface(IID_IBindStatusCallback, (void**)&m_pIbsc);
		if (!SUCCEEDED(hr))
			return hr;

		// Open the URL stream to read asynchronously
		// OnDataAvailable will be called when data is available
		hr = URLOpenStream(GetUnknown(), canonURL.GetURL(), 0, m_pIbsc);

	} else {
		// Open the URL stream to read synchronously
		hr = URLOpenBlockingStream(GetUnknown(), canonURL.GetURL(), &pStream, 0, 0);
		if (!SUCCEEDED(hr))
			return hr;

		// Call runFromStream to execute the instructions
		hr = runFromStream(pStream);

		// Cleanup
		pStream->Release();
		pStream = NULL;
	}

	return hr;
}

/**
* Returns the Image set in this Engine
*/
STDMETHODIMP CLMEngine::get_Image(IDAImage **pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

	if (m_pImage)
		m_pImage->AddRef();

	*pVal = (IDAImage *)m_pImage;

	return S_OK;
}

/**
* Returns the Sound set in this Engine
*/
STDMETHODIMP CLMEngine::get_Sound(IDASound **pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

	if (m_pSound)
		m_pSound->AddRef();

	*pVal = (IDASound *)m_pSound;

	return S_OK;
}

/**
* Return the named Behavior.  If the named Behavior is not available yet,
* then we return a switchable behavior with initial value of pDefaultBvr
*/
STDMETHODIMP CLMEngine::GetBehavior(BSTR tag, IDABehavior *pDefaultBvr, IDABehavior **ppVal)
{
	if (!ppVal)
		return E_POINTER;

	return m_exportTable->GetBehavior(tag, pDefaultBvr, ppVal);
}

/**
* Initialize this engine as an UntilNotifier, passing in a byte array containing the
* instructions and a count of bytes.  Returns an UntilNotifier for use in DA
*/
STDMETHODIMP CLMEngine::initNotify(BYTE *bytes, ULONG count, IDAUntilNotifier **pNotifier)
{
	// Initialize this engine from the given byte array
	HRESULT hr = initFromBytes(bytes, count);
	if (!SUCCEEDED(hr))
		return hr;

	// Create a new notifier object
	notifier = new CLMNotifier(this);

	// Test for null
	if (notifier == 0)
		return E_UNEXPECTED;

	// Increment reference count for return
	notifier->AddRef();

	// Put it in the return value
	*pNotifier = notifier;

	return S_OK;
}

/**
* Read and returns a long from the current codeStream.  The long is compressed 1-4 bytes
*/
STDMETHODIMP CLMEngine::readLong(LPLONG pLong)
{
	if (!pLong)
		return E_POINTER;

	BYTE	byte;

	HRESULT status = codeStream->readByte(&byte);
	if (!SUCCEEDED(status))
		return status;

	LONG result = (long)byte;

	switch (result & 0xc0) {
	case 0x40:
		status = codeStream->readByte(&byte);
		if (!SUCCEEDED(status))
			return status;
		result = ((result & 0x3F) << 8) + byte;
		break;

	case 0x80:
		status = codeStream->readByte(&byte);
		if (!SUCCEEDED(status))
			return status;
		result = ((result & 0x3f) << 16) + ((LONG)byte << 8);
		status = codeStream->readByte(&byte);
		if (!SUCCEEDED(status))
			return status;
		result += byte;
		break;

	case 0xc0:
		status = codeStream->readByte(&byte);
		if (!SUCCEEDED(status))
			return status;
		result = ((result & 0x3f) << 24) + ((LONG)byte << 16);
		status = codeStream->readByte(&byte);
		if (!SUCCEEDED(status))
			return status;
		result += (LONG)byte << 8;
		status = codeStream->readByte(&byte);
		if (!SUCCEEDED(status))
			return status;
		result += byte;
		break;
	}

#if 0
	char cbuf[100];
	sprintf(cbuf, "readLong::%ld", result);
	MessageBox(NULL, cbuf, "CLMEngine", MB_OK);
#endif

	*pLong = result;
	return status;
}

/**
* Read and return a signed long from the current code stream.  The long is
* compressed 1-4 bytes
*/
LONG CLMEngine::readSignedLong(LPLONG pLong)
{
	if (!pLong)
		return E_POINTER;

	BYTE	byte;
	HRESULT status = codeStream->readByte(&byte);
	LONG result = (LONG)byte;

	switch (result & 0xc0) {
	case 0x00:
		result -= 0x20;
		break;

	case 0x40:
		status = codeStream->readByte(&byte);
		if (!SUCCEEDED(status))
			return status;
		result = ((result & 0x3f) << 8) + byte;
		result -= 0x2000;
		break;

	case 0x80:
		status = codeStream->readByte(&byte);
		if (!SUCCEEDED(status))
			return status;
		result = ((result & 0x3f) << 16) + ((LONG)byte << 8);
		status = codeStream->readByte(&byte);
		if (!SUCCEEDED(status))
			return status;
		result += (LONG)byte;
		result -= 0x200000;
		break;

	case 0xc0:
		status = codeStream->readByte(&byte);
		if (!SUCCEEDED(status))
			return status;
		result = ((result & 0x3f) << 24) + ((LONG)byte << 16);
		status = codeStream->readByte(&byte);
		if (!SUCCEEDED(status))
			return status;
		result += (LONG)byte << 8;
		status = codeStream->readByte(&byte);
		if (!SUCCEEDED(status))
			return status;
		result += byte;
		result -= 0x20000000;
		break;
	}

#if 0
	char cbuf[100];
	sprintf(cbuf, "readSignedLong::%ld", result);
	MessageBox(NULL, cbuf, "CLMEngine", MB_OK);
#endif

	*pLong = result;
	return status;
}

/**
* Read a float from the code stream
*/
STDMETHODIMP CLMEngine::readFloat(PFLOAT pFloat)
{
	if (!pFloat)
		return E_POINTER;

	// Float follows in 4 bytes, low byte first
	// CAUTION: Assumes byte order and format of float
	// in binary stream matches the C format
	return codeStream->readBytes((LPBYTE)pFloat, 4L, NULL);
}

/**
* Read a double from the code stream
*/
STDMETHODIMP CLMEngine::readDouble(double *pDouble)
{
	if (!pDouble)
		return E_POINTER;

	// Double follows in 8 bytes, low byte first
	// CAUTION: Assumes byte order and format of double
	// in binary stream matches the C format
	return codeStream->readBytes((LPBYTE)pDouble, 8L, NULL);
}

/**
*  Set the appTriggered event that will be triggered when the
*  filter graph is started.  The argument is expected to be an
*  AppTriggeredEvent in the media graph of the DAControl to which
*  this engine or its parent is attached.
*/

STDMETHODIMP CLMEngine::SetStartEvent( IDAEvent *pNewStartEvent, BOOL bOverwrite )
{
	if( m_pStartEvent != NULL )
	{
		//if we are told to overwrite the event.
		if( bOverwrite == TRUE )
			m_pStartEvent->Release();
		else //do not reset the start event.
			return S_OK;
	}
	m_pStartEvent = pNewStartEvent;
	m_pStartEvent->AddRef();

	return S_OK;
}

/**
*  Set the appTriggered event that will be triggered when the
*  filter graph is stopped.  The argument is expected to be an
*  AppTriggeredEvent in the media graph of the DAControl to which
*  this engine or its parent is attached
*/
STDMETHODIMP CLMEngine::SetStopEvent( IDAEvent *pNewStopEvent, BOOL bOverwrite )
{
	if( m_pStopEvent != NULL )
	{
		//if we are told to overwrite the event
		if( bOverwrite == TRUE )
			m_pStopEvent->Release();
		else //do not reset the stop event
			return S_OK;
	}
	m_pStopEvent = pNewStopEvent;
	m_pStopEvent->AddRef();
	
	return S_OK;
}

/**
*  Sets the parent of this engine.  This should only be called
*  on an engine that runs a notifier.
*/
STDMETHODIMP CLMEngine::setParentEngine( ILMEngine2 *parentEngine)
{
	m_pParentEngine = parentEngine;
	return S_OK;
}

/**
*  Clear the pointer to the parent engine.
*/
STDMETHODIMP CLMEngine::clearParentEngine()
{
	m_pParentEngine = NULL;
	return S_OK;
}

/**
*  If this engine or it's parent is running in a filter graph, 
*  then the time in that filter graph is returned. Otherwise,
*  -1 is returned.  All values are returned through the pGraphTime 
*  argument.
*/
STDMETHODIMP CLMEngine::getCurrentGraphTime( double *pGraphTime )
{

	if( pGraphTime == NULL )
		return E_POINTER;
	//get the IMediaPosition on the filter graph
	IMediaPosition *pMediaPosition = NULL;
	HRESULT hr =  getIMediaPosition( &pMediaPosition );
	//if we got the IMediaPosition
	if( SUCCEEDED( hr ) )
	{
		REFTIME currentTime;
		//get the current time from the fiter graph
		pMediaPosition->get_CurrentPosition( &currentTime );
		//set the return value
		(*pGraphTime) = currentTime;
		pMediaPosition->Release();
	} else { //we failed to get the IMediaPosition for some reason
		(*pGraphTime) = -1.0;
		return hr;
	}

	return S_OK;
}

STDMETHODIMP CLMEngine::getIMediaPosition( IMediaPosition **ppMediaPosition )
{
	if( ppMediaPosition == NULL )
		return E_POINTER;

	if( m_pMediaPosition != NULL )
	{
		(*ppMediaPosition) = m_pMediaPosition;
		(*ppMediaPosition)->AddRef();
		return S_OK;
	}

	//get the viewer control from the reader.
	HRESULT hr;
	IDAViewerControl *viewerControl = NULL;

	if( m_pReader == NULL )
		return E_POINTER;

	hr = m_pReader->get_ViewerControl( &viewerControl );
	//if we got the viewer control
	if( SUCCEEDED( hr ) )
	{
		//if the viewer control is not null
		if( viewerControl != NULL )
		{
			//see if the DAControl supports IBaseFilter ( we are streaming )
			IBaseFilter* pBaseFilter = NULL;
			hr = viewerControl->QueryInterface( IID_IBaseFilter, (void**)&pBaseFilter );
			viewerControl->Release();
			//if the DAControl supports IBaseFilter
			if( SUCCEEDED( hr ) )
			{
				FILTER_INFO filterInfo;
				hr = pBaseFilter->QueryFilterInfo( &filterInfo );
				//if we got the filterInfo
				if( SUCCEEDED( hr ) )
				{
					//get the MediaControl Interface
					IMediaControl* pMediaControl = NULL;
					hr = filterInfo.pGraph->QueryInterface( IID_IMediaControl, (void **)&pMediaControl ); 
					filterInfo.pGraph->Release();
					//if we got the mediaControl interface
					if( SUCCEEDED( hr ) )
					{
						//Query the control for IMediaPosition
						IMediaPosition *pMediaPosition;
						hr = pMediaControl->QueryInterface( IID_IMediaPosition, (void **)&pMediaPosition );
						//if we got IMediaPosition from the control
						if( SUCCEEDED( hr ) )
						{
							//cache it for later use.
							m_pMediaPosition = pMediaPosition;
							//This creates a circular reference, but we know the filter graph
							// will not go away until we get a ReleaseFilterGraph call
							//m_pMediaPosition->AddRef();
							//set the return value
							(*ppMediaPosition) = m_pMediaPosition;

							//free up interfaces we don't need anymore.
							pBaseFilter->Release();
							pMediaControl->Release();

							return S_OK;
						} else { //we failed to get IMediaPosition from the control
							//free up interfaces we've queried
							pMediaControl->Release();
							pBaseFilter->Release();
						}
					} else { //we failed to get IMediaControl from the filter graph
						//free up interfaces we've queried
						pBaseFilter->Release();
					}
				} else {//we failed to get the filter info from IBaseFilter
					//free up interfaces we've queried
					pBaseFilter->Release();
				}
			}//we failed to get IBaseFilter from the control
		} else {//the ViewerControl was null, perhaps we are running standalone
			//if the pointer to the filter graph is set
			if( m_pmc != NULL )
			{
				//query the control for IMediaPosition
				IMediaPosition *pMediaPosition;
				hr = m_pmc->QueryInterface( IID_IMediaPosition, (void **)&pMediaPosition );
				//if the control supports IMediaPosition
				if( SUCCEEDED( hr ) )
				{
					//cache it for later use
					m_pMediaPosition = pMediaPosition;
					//This creates a circular reference, but we know the filter graph
					// will not go away until we get a ReleaseFilterGraph call
					//m_pMediaPosition->AddRef();
					//set the return value
					(*ppMediaPosition) = m_pMediaPosition;
					//return success
					return S_OK;
				}//we failed to get IMediaPosition from the control
			} else {//the pointer to the filter graph was null
				hr = E_FAIL;
			}
		}
	}
	//else an error occurred
	//set the media position to null
	(*ppMediaPosition) = NULL;
	//return the error code
	return hr;
}

STDMETHODIMP CLMEngine::getIMediaEventSink( IMediaEventSink** ppMediaEventSink )
{
	if( ppMediaEventSink == NULL )
		return E_POINTER;

	if( m_pMediaEventSink != NULL )
	{
		m_pMediaEventSink->AddRef();
		(*ppMediaEventSink) = m_pMediaEventSink;
		return S_OK;
	}

	HRESULT hr;
	if( m_pReader != NULL )
	{
		//if we are not inside the Media player this call should fail in which case we will return
		// failure
		IDAViewerControl *pViewerControl = NULL;
		hr = m_pReader->get_ViewerControl( &pViewerControl );
		//if the viewercontrol is set and valid
		if( SUCCEEDED( hr ) && pViewerControl != NULL )
		{
			//see if the viewer control is aggregated by lmrtrend ( as in the streaming case)
			IBaseFilter* pBaseFilter;
			hr = pViewerControl->QueryInterface( IID_IBaseFilter, (void**)&pBaseFilter );
			pViewerControl->Release();
			//if the viewercontrol has been aggregated by lmrtrend
			if( SUCCEEDED( hr ) )
			{
				//find the filter info
				FILTER_INFO pFilterInfo;
				hr = pBaseFilter->QueryFilterInfo( &pFilterInfo );
				pBaseFilter->Release();
				//if we successfully got the filterInfo
				if( SUCCEEDED( hr ) )
				{
					//get the MediaEventSink from the filterInfo
					//CComQIPtr<IMediaEventSink, &IID_IMediaEventSink> pMediaEventSink( pFilterInfo.pGraph );
					IMediaEventSink *pMediaEventSink;
					pFilterInfo.pGraph->QueryInterface( IID_IMediaEventSink, (void**)&pMediaEventSink );
					pFilterInfo.pGraph->Release();
					if( pMediaEventSink != NULL )
					{
						(*ppMediaEventSink) = pMediaEventSink;
						m_pMediaEventSink = pMediaEventSink;

						return S_OK;
					}
				}
			}
		}
	}
	return E_NOINTERFACE;
}

double CLMEngine::parseDoubleFromVersionString( BSTR version )
{
	double versionNum = 0.0;
	HRESULT stringLen = SysStringLen( version );
	for( int curChar = 0; curChar < stringLen; curChar++ )
	{
		if( version[curChar] != L'.' && version[curChar] >= L'0' && version[curChar] <= L'9' )
		{
			//pVersionString[ curChar - numPeriodsFound ] = pVersionString[ curChar ];
			versionNum = versionNum*10 + (int)(version[curChar] - L'0');
		}
	}

	return versionNum;
}

double CLMEngine::getDAVersionAsDouble()
{	
	//get the Version string from the DA Control
	BSTR pVersionString;
	HRESULT hr;
	hr = staticStatics->get_VersionString( &pVersionString );
	if( SUCCEEDED( hr ) )
	{
		//create a double from the version string
		double versionNum = parseDoubleFromVersionString( pVersionString );

		//free up resources
		SysFreeString( pVersionString );

		return versionNum;
	}
	return -1.0;
}

double CLMEngine::getLMRTVersionAsDouble()
{	
	//get the Version string from the Reader
	BSTR pVersionString;
	HRESULT hr;
	
	if( m_pReader == NULL )
		return -1.0;

	hr = m_pReader->get_VersionString( &pVersionString );
	if( SUCCEEDED( hr ) )
	{
		//create a double from the version string
		double versionNum = parseDoubleFromVersionString( pVersionString );

		//free up resources
		SysFreeString( pVersionString );

		return versionNum;
	}
	return -1.0;
}


// Override IObjectSafetyImpl

STDMETHODIMP CLMEngine::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
	if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
		return E_POINTER;
	HRESULT hr = S_OK;

	if (riid == IID_IDispatch)
	{
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
	}
	else if (riid == IID_IPersistPropertyBag)
	{
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_DATA;
	}
	else
	{
		*pdwSupportedOptions = 0;
		*pdwEnabledOptions = 0;
		hr = E_NOINTERFACE;
	}
	return hr;
}

STDMETHODIMP CLMEngine::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{	
	// If we're being asked to set our safe for scripting or
	// safe for initialization options then oblige
	if (riid == IID_IDispatch || riid == IID_IPersistPropertyBag  || riid == IID_IPersistStreamInit)
	{
		// Store our current safety level to return in GetInterfaceSafetyOptions
		m_dwSafety = dwEnabledOptions & dwOptionSetMask;
		return S_OK;
	}

	return E_NOINTERFACE;
}

/**********************************************************************************
* Asynchronous loading methods
***********************************************************************************/

/**
* Set the asynchronous block size
*/
STDMETHODIMP CLMEngine::SetAsyncBlkSize(LONG blkSize)
{
	if (blkSize > 0L)
		m_AsyncBlkSize = (ULONG)blkSize;
	return S_OK;
}

/**
* Set the asynchronous delay
*/
STDMETHODIMP CLMEngine::SetAsyncDelay(LONG delay)
{
	if (delay > 0L)
		m_AsyncDelay = (ULONG)delay;
	return S_OK;
}

/**
* Called from TimerCallback when the timer goes off.  Posts a message to indicate
* that the timer went off, so that execution of the instructions does not happen
* in the timer callback.
*/
STDMETHODIMP CLMEngine::TimerCallbackHandler()
{
	if (!PostMessage(m_workerHwnd, WM_LMENGINE_TIMER_CALLBACK, (WPARAM)this, 0))
		return E_FAIL;
	else
		return S_OK;
}

/**
* Called when the timer goes off.  Redirects call to TimerCallbackHandler in
* the appropriate engine.
*/
void CALLBACK
CLMEngine::TimerCallback(UINT wTimerID,
                         UINT msg,
                         DWORD_PTR dwordUser,
                         DWORD_PTR unused1,
                         DWORD_PTR unused2)
{
    // Just call the right timer method.
    CLMEngine *pEngine = (CLMEngine *)(dwordUser);
    pEngine->TimerCallbackHandler();
}

/**
* Initialize timer
*/
STDMETHODIMP CLMEngine::InitTimer()
{
	TIMECAPS tc;
	if (timeGetDevCaps(&tc, sizeof(TIMECAPS)) != TIMERR_NOERROR) {
		return E_FAIL;
	}
	
	// Ensure in the min -> max range
	m_millisToUse = MIN(MAX(m_AsyncDelay, tc.wPeriodMin), tc.wPeriodMax);

	return S_OK;
}

/**
* Starts the timer
*/
STDMETHODIMP CLMEngine::StartTimer()
{
	
	m_Timer = timeSetEvent(m_millisToUse,
		EVENT_RESOLUTION,
		CLMEngine::TimerCallback,
		(DWORD_PTR) this,
		TIME_ONESHOT);
	if (m_Timer)
		return S_OK;
	else
		return E_FAIL;
}

/**
* Called by the message handling routine when it gets a message that more
* data is available from an asynchronous data stream.
* Adds the ByteArrayStream containing the data to the list of 
* ByteArrayStreams in the AsyncStream and calls execute
*/
STDMETHODIMP CLMEngine::NewDataHandler(CLMEngineInstrData *data)
{
    EnterCriticalSection(&m_CriticalSection);

    // TODO: I would be more comfortable if the code to add the
    // ByteArrayStream to the AsyncStream went in OnDataAvailable.
    // But the critical section stuff might be preventing the change
    // to the data structure being made during an execute in a different
    // thread?  If not, we could do away with this whole method.

    HRESULT hr = S_OK;

    if (m_bAbort) {
        hr = E_ABORT;
    }
    else 
    {
        if (data && data->byteArrayStream)
        {
            // There's a ByteArrayStream to add to the AsyncStream
            if (!codeStream)
            {
                // No AsyncStream yet.  Create one
                if (!(codeStream = new AsyncStream(data->byteArrayStream, m_AsyncBlkSize)))
                {
                    delete data->byteArrayStream;
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                // Code stream exists.  Add the ByteArrayStream to it
                ((AsyncStream *)codeStream)->AddByteArrayStream(data->byteArrayStream);
            }

            // TODO: This only works if the entire header is in the first block
            if (SUCCEEDED(hr) && !m_bHeaderRead)
            {
                // Try to read in the header
                hr = validateHeader();
                if (SUCCEEDED(hr))
                {
                    m_bHeaderRead = TRUE;
                }
                else
                {
                    delete codeStream;
                    codeStream = NULL;
                }
            }
        }

        if(SUCCEEDED(hr))
        {
            // Even if there is no data we want to do this so that
            // we can switch from pending to not pending and
            // finish up nicely.
            m_bPending = data ? data->pending : false;

            if(codeStream) {
                ((AsyncStream *)codeStream)->SetPending(m_bPending);
                hr = ExecuteFromAsync();
            }                    
        }
    }

    LeaveCriticalSection(&m_CriticalSection);

    delete data;

    return hr;
}

/**
* Called by external components delivering instructions asynchronously to this engine
* through a stream or a chunk of memory.
* Queues a message so that the execution of the instructions happens in a different thread.
* The message causes the method NewDataHandler to be called.
*/
STDMETHODIMP CLMEngine::OnDataAvailable (DWORD grfBSCF, 
									     DWORD dwSize,
										 FORMATETC *pfmtetc, 
										 STGMEDIUM * pstgmed)
{
	HRESULT hr;
	ByteArrayStream *byteArrayStream = 0;

	if (m_bAbort)
		return E_ABORT;

	BYTE *pBuf = 0;			// To be filled in with the instruction bytes

	if (pstgmed->tymed == TYMED_ISTREAM)
	{
		// The data is being passed in a stream
		// Read it out into pBuf
		if (!pstgmed->pstm)
			return E_POINTER;

		// In the case of a stream we need to take into account the
		// fact that we have already read some bytes
		dwSize -= m_PrevRead;

		if (!(pBuf = new BYTE[dwSize]))
			return E_OUTOFMEMORY;

		if (!SUCCEEDED(hr = pstgmed->pstm->Read((void*)pBuf, dwSize, NULL)))
			return hr;

		m_PrevRead += dwSize;

	}
	else if (pstgmed->tymed == TYMED_HGLOBAL)
	{
		// TODO: Test this!!!!!!!
		// The data is being passed through a memory chunk
		if (!pstgmed->hGlobal)
			return E_POINTER;

		// Lock the chunk
		LPVOID block = GlobalLock(pstgmed->hGlobal);

		if (!block)
			return E_FAIL;

		// Allocate new buf and copy into it
		if (!(pBuf = new BYTE[dwSize]))
			return E_OUTOFMEMORY;

		CopyMemory(pBuf, block, dwSize);

		// Unlock the chunk
		GlobalUnlock(pstgmed->hGlobal);
	}

	if (!pBuf)
	{
		// Failed to read any data
		return E_FAIL;
	}

	// Create a ByteArrayStream from the instructions to be used in NewDataAvailable
	if (!(byteArrayStream = new ByteArrayStream(pBuf, dwSize)))
	{
		delete pBuf;
		return E_OUTOFMEMORY;
	}

	// Put the information in a new CLMEngineInstrData
	CLMEngineInstrData *data = new CLMEngineInstrData();
	if (data == 0)
	{
		delete byteArrayStream;
		return E_OUTOFMEMORY;
	}

	data->byteArrayStream = byteArrayStream;

	// Work out whether there is more data pending
	if ((grfBSCF & BSCF_LASTDATANOTIFICATION) == BSCF_LASTDATANOTIFICATION)
		data->pending = FALSE;
	else 
		data->pending = TRUE;

		
	// Post a message to say that we have more data available
	if (!PostMessage (m_workerHwnd, WM_LMENGINE_DATA, (WPARAM)this, (LPARAM)data))
	{
		delete byteArrayStream;
		delete data;
		return E_ABORT;
	}

	return S_OK;
}

/**
* Called by external components delivering instructions asynchronously to this engine
* through a chunk of memory (could use OnDataAvailable with global mem handles, but
* this is more straightforward if the caller doesn't have a handle to the mem).
* Queues a message so that the execution of the instructions happens in a different thread.
* The message causes the method NewDataHandler to be called.
*/
STDMETHODIMP CLMEngine::OnMemDataAvailable (BOOLEAN lastBlock, 
									        DWORD blockSize,
										    BYTE *block)
{
	// It's OK to call this with a null block if only to inform us
	// that data has finished
	if (lastBlock && block == 0)
	{
		// Post a message with empty data so that we can finish up nicely
		if (!PostMessage (m_workerHwnd, WM_LMENGINE_DATA, (WPARAM)this, 0))
			return E_ABORT;
		return S_OK;
	}

	if (block == 0)
		return E_POINTER;

	if (m_bAbort)
		return E_ABORT;

	// Allocate new buffer and copy data into it
	BYTE *pBuf;				
	if (!(pBuf = new BYTE[blockSize]))
		return E_OUTOFMEMORY;

	// TODO: What's a way to do this without a loop and without the CRT?
	DWORD count = blockSize;
	BYTE *p = pBuf;
	while (count--)
		*p++ = *block++;

	// Create a ByteArrayStream from the instructions to be used in NewDataAvailable
	ByteArrayStream *byteArrayStream;
	if (!(byteArrayStream = new ByteArrayStream(pBuf, blockSize)))
	{
		delete pBuf;
		return E_OUTOFMEMORY;
	}

	// Put the information in a new CLMEngineInstrData
	CLMEngineInstrData *data = new CLMEngineInstrData();
	if (data == 0)
	{
		delete byteArrayStream;
		return E_OUTOFMEMORY;
	}

	data->byteArrayStream = byteArrayStream;
	data->pending = !lastBlock;

	// Post a message to say that we have more data available
	if (!PostMessage (m_workerHwnd, WM_LMENGINE_DATA, (WPARAM)this, (LPARAM)data))
	{
		delete byteArrayStream;
		delete data;
		return E_ABORT;
	}

	return S_OK;
}

STDMETHODIMP CLMEngine::OnStartBinding(DWORD dwReserved, IBinding *pBinding)
{
	m_spBinding = pBinding;
	return S_OK;
}

STDMETHODIMP CLMEngine::OnStopBinding(HRESULT hrStatus, LPCWSTR szStatusText)
{
	if (hrStatus != S_OK) 
		AbortExecution();

	m_spBinding.Release();
	return S_OK;
}
 
STDMETHODIMP CLMEngine::GetBindInfo(DWORD *pgrfBINDF, BINDINFO *pbindInfo)
{
	ATLTRACE(_T("CBindStatusCallback::GetBindInfo\n"));
	*pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE |
		BINDF_GETNEWESTVERSION | BINDF_NOWRITECACHE;
	pbindInfo->cbSize = sizeof(BINDINFO);
	pbindInfo->szExtraInfo = NULL;
	memset(&pbindInfo->stgmedData, 0, sizeof(STGMEDIUM));
	pbindInfo->grfBindInfoF = 0;
	pbindInfo->dwBindVerb = BINDVERB_GET;
	pbindInfo->szCustomVerb = NULL;
	return S_OK;
}

/**
* Release all the handles that this engine has on the Filter Graph.
*/
STDMETHODIMP CLMEngine::releaseFilterGraph()
{
	if( m_pMediaPosition != NULL )
		m_pMediaPosition = NULL;
	if( m_pMediaEventSink != NULL )
		m_pMediaEventSink = NULL;

	return S_OK;
}

/**
* Release all hanldels on the filter graph held by all engines
* that share the same reader with this engine.
*/
STDMETHODIMP CLMEngine::releaseAllFilterGraph()
{
	if( m_pReader != NULL )
		m_pReader->releaseFilterGraph();
	return S_OK;
}

HRESULT CLMEngine::Start(LONGLONG rtNow)
{
	if( m_pStartEvent != NULL )
	{
		IDANumber *pData;
		HRESULT hr = staticStatics->DANumber( 0.0f, &pData );
		if( SUCCEEDED( hr ) )
		{
			hr = staticStatics->TriggerEvent( m_pStartEvent, pData );
			pData->Release();
			// do something if we fail ? do we care if no one has set up the stop event?
		}
	}
    return S_OK;
}

HRESULT CLMEngine::Stop()
{
	if( m_pStopEvent != NULL )
	{
		IDANumber *pData;
		HRESULT hr = staticStatics->DANumber( 0.0f, &pData );
		if( SUCCEEDED( hr ) )
		{
			hr = staticStatics->TriggerEvent( m_pStopEvent, pData );
			pData->Release();
			// do something if we fail ? do we care if no one has set up the stop event?
		}
	}
    return S_OK;
}

HRESULT CLMEngine::SetMediaCacheDir(WCHAR *wsz)
{
    SysFreeString(m_bstrMediaCacheDir);
    m_bstrMediaCacheDir = SysAllocString(wsz);
    return m_bstrMediaCacheDir ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CLMEngine::disableAutoAntialias()
{
	m_bEnableAutoAntialias = false;
	return S_OK;
}

STDMETHODIMP CLMEngine::ensureBlockSize( ULONG blockSize )
{
	if( blockSize > m_AsyncBlkSize )
	{
		m_AsyncBlkSize = blockSize;
		if( codeStream != NULL )
			codeStream->ensureBlockSize( blockSize );
	}
	return S_OK;
}


/**
* Called by the message thread or NewDataHandler to execute
* some instructions from the AsyncStream
*/
STDMETHODIMP CLMEngine::ExecuteFromAsync()
{
	EnterCriticalSection(&m_CriticalSection);

	if (m_bAbort == TRUE)
		return E_FAIL;

    if(codeStream != NULL) {
	    ((AsyncStream *)codeStream)->ResetBlockRead();
    }
	else 
	{
		LeaveCriticalSection(&m_CriticalSection);
		return S_OK;
	}

	m_Timer = NULL;

	HRESULT hr = execute();
	
	if (!((hr == S_OK) || (hr == E_PENDING))) 
		AbortExecution();
	
	if (hr == E_PENDING && ((AsyncStream *)codeStream)->hasBufferedData())
	{
		m_bMoreToParse = TRUE;
		StartTimer();
	}
	else if (m_bPending == FALSE && hr != E_PENDING)
	{
		// We're done, failed or not.
		SetEvent(m_hDoneEvent);
		releaseAll();
		m_pIbsc = NULL;
		delete codeStream;
		codeStream = NULL;
	}

/*	
	if (m_bPending == FALSE) {
		// Last OnDataAvailable
		if (hr == E_PENDING) {
			m_bMoreToParse = TRUE;
			// More data to parse
			StartTimer();
		} else {
			// We're done, failed or not.
			SetEvent(m_hDoneEvent);
			releaseAll();
			m_pIbsc = NULL;
			delete codeStream;
			codeStream = NULL;
		}
	} 
*/

	LeaveCriticalSection(&m_CriticalSection);

	return hr;
}

/************************************************************************************
*
*************************************************************************************/

/**
* Find and return the named element on the page in the client site
*/
STDMETHODIMP CLMEngine::getElementOnPage(BSTR tag, IUnknown **pVal)
{
	CComVariant						vName, vIndex;
    CComPtr<IHTMLDocument2>			pHTMLDoc;
	CComPtr<IHTMLElementCollection>	pElemCollection;
	CComPtr<IDispatch>				pDispatch;
	IOleContainer *pContainer;
	IOleClientSite *pClientSite;
	IOleObject *pOleObj;
	HRESULT hr = E_FAIL;

	if (!pVal) {
        return E_POINTER;
    }

	if ( m_pClientSite == NULL || FAILED(m_pClientSite->GetContainer(&pContainer)))
	{
		//we may be embedded in the MediaPlayer check the DA Control
		if( m_pReader != NULL )
		{
			IDAViewerControl *pViewer;
			hr = m_pReader->get_ViewerControl( &pViewer );
			if( SUCCEEDED( hr ) && pViewer != NULL )
			{
				hr = pViewer->QueryInterface( IID_IOleObject, (void**) &pOleObj );
				pViewer->Release();
				
				if( SUCCEEDED( hr ) )
				{
					hr = pOleObj->GetClientSite( &pClientSite );
					pOleObj->Release();
					if( SUCCEEDED( hr ) )
					{
						hr = pClientSite->GetContainer( &pContainer );
						pClientSite->Release();
						if( FAILED( hr ) ) 
							return hr;
					}
					else
						return hr;
				}
				else
					return hr;
			}
			else
				return E_FAIL;
		}
		else
			return E_FAIL;
	}
	//search for the nearest host that supports IHTMLDocument2
	pHTMLDoc = NULL;
	while( pHTMLDoc == NULL )
	{
		if( FAILED( pContainer->QueryInterface( IID_IHTMLDocument2, (void **)&pHTMLDoc ) ) )
		{
			//look for a parent
			hr = pContainer->QueryInterface( IID_IOleObject, (void**)&pOleObj );
			pContainer->Release();
			if( SUCCEEDED( hr ) )
			{
				hr = pOleObj->GetClientSite( &pClientSite );
				pOleObj->Release();
				if( SUCCEEDED( hr ) )
				{
					hr = pClientSite->GetContainer( &pContainer );
					pClientSite->Release();
					if( FAILED( hr ) )
						return hr;
				}
				else
					return hr;
			}
			else
				return hr;
		}
		else  //we succeeded in finding IHTMLDocument2
		{
			//release the contaier
			pContainer->Release();
		}
	}


	//if (FAILED(pRoot->QueryInterface(IID_IHTMLDocument2, (void **)&pHTMLDoc)))
	//	return E_FAIL;

	if (FAILED(pHTMLDoc->get_all(&pElemCollection)))
		return E_FAIL;

	vIndex.vt = VT_EMPTY;
	vName.vt = VT_BSTR;
	vName.bstrVal = tag;

	if (FAILED(pElemCollection->item(vName, vIndex, &pDispatch)))
		return E_FAIL;

	// There's a Trident bug (43078) that has the item()
	// method called above returning S_OK even if it
	// doesn't find the item.  Therefore, check for this
	// case explicitly. 
	if (pDispatch.p == NULL)
		return E_FAIL;

	hr = pDispatch->QueryInterface(IID_IUnknown, (void **)pVal);
	return hr;
}

/**
* Get the named DAViewerControl on the page contained in the client site
*/
STDMETHODIMP CLMEngine::getDAViewerOnPage(BSTR tag, IDAViewerControl **pViewer)
{
	CComPtr<IUnknown>			pObj;

	if (!pViewer || m_pReader == NULL)
        return E_POINTER;

	HRESULT hr;

	// First check to see whether the reader has one
	if (!SUCCEEDED(hr = m_pReader->get_ViewerControl(pViewer)))
		return hr;

	if (*pViewer != 0)
		return S_OK;
	
	hr = getElementOnPage(tag, &pObj);
	if (pObj)
	{
		hr = pObj->QueryInterface(IID_IDAViewerControl, (void **)pViewer);
		if (!SUCCEEDED(hr))
			return hr;
	} 

	return hr;
}



/**
* Request a navigation to the named URL
*/
STDMETHODIMP CLMEngine::navigate(BSTR url, BSTR location, BSTR frame, int newWindowFlag)
{


	/*
	CComPtr<IDAViewerControl> viewerControl = NULL;
	hr = m_pReader->get_ViewerControl( &viewerControl );

	CComPtr< IOleContainer> pContainer;
	if( SUCCEEDED(hr) && viewerControl != NULL )
	{
		CComQIPtr<IOleObject, IID_IOleObject> pOleObject(viewerControl);
		CComPtr<IOleClientSite> pClientSite;

		hr = pOleObject->GetClientSite( &pClientSite );
		if( SUCCEEDED( hr ) )
		{
			pOleObject->Q
			if( pContainer != NULL )
			{
			}
		}
	}
	*/

/*	
	if( viewerControl != NULL )
	{
		return HlinkSimpleNavigateToString(
											url,
											location,
											frame,
											viewerControl,
											_pbc,
											NULL,
											newWindowFlag == 0 ? HLNF_INTERNALJUMP : HLNF_OPENINNEWWINDOW,
											0);
	}
*/
	HRESULT hr;
	
	IMediaEventSink *pMediaEventSink = NULL;

	hr = getIMediaEventSink( &pMediaEventSink );
	if( SUCCEEDED( hr ) )
	{
		
		if ( url != NULL && location != NULL && frame != NULL )
		{
			//allocate enough space for the final URL string which is the
			// length of the URL + the length of the location + the length of the target frame
			// + 3 WCHARs for the "&&" and the terminating "\0"
			WCHAR *szURLBuf = new WCHAR[ SysStringLen( url ) + 
				SysStringLen( location ) + 
				SysStringLen( frame ) + 3 ];
			if( szURLBuf != NULL )
			{
				BSTR szType = SysAllocString( L"URL" );
				BSTR szURL = NULL;

				szURLBuf[0] = L'\0';
				
				wcscpy( szURLBuf, url );
				wcscat( szURLBuf, location );
				
				if( frame[0] != L'' )
				{
					wcscat( szURLBuf, L"&&" );
					wcscat( szURLBuf, frame );
				}
				
				szURL = SysAllocString( szURLBuf );
				delete[] szURLBuf;

				if( szURL != NULL && szType != NULL )
				{
					pMediaEventSink->Notify( EC_OLE_EVENT, (LONG_PTR) szType, (LONG_PTR) szURL );

					SysFreeString( szURL );
					SysFreeString( szType );

					hr = S_OK;
				} else {
					if( szType != NULL )
						SysFreeString( szURL );
					hr = E_FAIL;
				}

			} else //we failed to allocate szURLBuf
				hr = E_FAIL;

		} else //one of the strings passed in was null
			hr = E_POINTER;
		
		pMediaEventSink->Release();
		
		return hr;
	} else {//we could not get IMediaEventSink, perhaps we are not in the MediaPlayer
	
		//if we have a reader and a client site then we can navigate
		if (m_pReader != NULL && m_pClientSite != NULL)	
		{
			CComPtr<IBindCtx> _pbc;
			HRESULT hr = CreateBindCtx(0, &_pbc);
			if (FAILED(hr))
				return hr;
			return HlinkSimpleNavigateToString(
				url,
				location,
				frame,
				m_pReader,
				_pbc,
				NULL,
				newWindowFlag == 0 ? HLNF_INTERNALJUMP : HLNF_OPENINNEWWINDOW,
				0);
		} else {
			return E_POINTER;
		}
	}

	return hr;
}

/**
* Call a piece of script on the page
*/
STDMETHODIMP CLMEngine::callScriptOnPage(BSTR scriptSourceToInvoke,
										 BSTR scriptLanguage)
{    
	
	HRESULT hr;
	IMediaEventSink *pMediaEventSink = NULL;

	hr = getIMediaEventSink( &pMediaEventSink );
	if( SUCCEEDED( hr ) )
	{
		if( scriptSourceToInvoke != NULL && scriptLanguage != NULL )
		{
			BSTR szType = NULL;

			WCHAR *szTypeBuf = new WCHAR[ SysStringLen( scriptLanguage ) + LMRT_EVENT_PREFIX_LENGTH + 1 ];
			if( szTypeBuf != NULL )
			{
				szTypeBuf[0] = L'\0';
				wcscpy( szTypeBuf, LMRT_EVENT_PREFIX );
				wcscat( szTypeBuf, scriptLanguage );

				szType = SysAllocString( szTypeBuf );

				delete[] szTypeBuf;
			} else
				hr = E_FAIL;

			if( szType != NULL )
			{
				hr = pMediaEventSink->Notify( EC_OLE_EVENT, (LONG_PTR) szType, (LONG_PTR) scriptSourceToInvoke );

				SysFreeString( szType );
				pMediaEventSink->Release();

				return S_OK;
			} else
				hr = E_FAIL;
		}
		else
			hr = E_POINTER;
		pMediaEventSink->Release();
		return hr;
		
	} else { //we are not in a filter graph
		//try to do a callscript through the container
		CComPtr<IOleContainer> pRoot;
		CComPtr<IHTMLDocument> pHTMLDoc;
		CComPtr<IDispatch> pDispatch;
		CComPtr<IHTMLWindow2> pHTMLWindow2;
		CComVariant	retV;
		
		if (!m_pClientSite ||
			FAILED(m_pClientSite->GetContainer(&pRoot)) ||
			FAILED(pRoot->QueryInterface(IID_IHTMLDocument, (void **)&pHTMLDoc)) ||
			FAILED(pHTMLDoc->get_Script(&pDispatch)) ||
			FAILED(pDispatch->QueryInterface(IID_IHTMLWindow2, (void **)&pHTMLWindow2)))
			return E_FAIL;
		
		return pHTMLWindow2->execScript(scriptSourceToInvoke,
			scriptLanguage,
			&retV);
	}
}

/**
* Set the status line
*/
STDMETHODIMP CLMEngine::SetStatusText(BSTR s)
{    
    CComPtr<IOleContainer> pRoot;
    CComPtr<IHTMLDocument> pHTMLDoc;
    CComPtr<IDispatch> pDispatch;
    CComPtr<IHTMLWindow2> pHTMLWindow2;
    
	if (m_pClientSite == NULL ||
		FAILED(m_pClientSite->GetContainer(&pRoot)) ||
        FAILED(pRoot->QueryInterface(IID_IHTMLDocument, (void **)&pHTMLDoc)) ||
        FAILED(pHTMLDoc->get_Script(&pDispatch)) ||
        FAILED(pDispatch->QueryInterface(IID_IHTMLWindow2, (void **)&pHTMLWindow2)))
        return E_FAIL;

    return pHTMLWindow2->put_status(s);
}

/**
* Create a COM object given either the ProgID or the CLSID as a string
*/
STDMETHODIMP CLMEngine::createObject(BSTR str, IUnknown **ppObj)
{
	// This routine creates a COM object
	//
	// str is either the string representation of a CLSID, or a ProgID
	// We attempt to parse it as a ProgID first.

	CLSID				clsid;

	if (!ppObj)
		return E_POINTER;

	HRESULT hr = CLSIDFromString(str, &clsid);
	if (!SUCCEEDED(hr))
		return hr;

	return ::CoCreateInstance(clsid,
							NULL,
							CLSCTX_INPROC_SERVER,
							IID_IUnknown, (void **)ppObj);
}

/**
* Invoke a method on a COM object through IDispatch
*/
STDMETHODIMP CLMEngine::invokeDispMethod(IUnknown *pIUnknown, BSTR method, WORD wFlags, unsigned int nArgs, VARIANTARG *pV, VARIANT *pRetV)
{
	DISPID				dispid;
	CComPtr<IDispatch>	pIDispatch;

	HRESULT hr = pIUnknown->QueryInterface(IID_IDispatch, (void **)&pIDispatch);
	if (!SUCCEEDED(hr))
		return hr;

	hr = pIDispatch->GetIDsOfNames(IID_NULL,
									&method,
									1,
									GetUserDefaultLCID(),
									&dispid);
	if (!SUCCEEDED(hr)) 
		return hr;

	/*
	 * wFlags are the same as wFlags in IDispatch::Invoke
	 *
	 * #define DISPATCH_METHOD         0x1
	 * #define DISPATCH_PROPERTYGET    0x2
	 * #define DISPATCH_PROPERTYPUT    0x4
	 * #define DISPATCH_PROPERTYPUTREF 0x8
	 */

	DISPPARAMS	params;
	params.cArgs = nArgs;
	params.rgvarg = pV;
	params.cNamedArgs = 0;
	params.rgdispidNamedArgs = NULL;

	return pIDispatch->Invoke(dispid,
							IID_NULL,
							GetUserDefaultLCID(),
							wFlags,
							&params,
							pRetV,
							NULL,
							NULL);

}

STDMETHODIMP CLMEngine::initVariantArg(BSTR arg, VARTYPE type, VARIANT *pV)
{
	VARIANT strVar;

	if (!arg || !pV)
		return E_POINTER;

	VariantInit(pV);

    strVar.vt = VT_BSTR;
	strVar.bstrVal = arg;

	return VariantChangeType(pV, &strVar, 0, type);
}

STDMETHODIMP CLMEngine::initVariantArgFromString(BSTR arg, VARIANT *pV)
{
	if (!arg || !pV)
		return E_POINTER;

    pV->vt = VT_BSTR;
	pV->bstrVal = arg;

	return S_OK;
}

STDMETHODIMP CLMEngine::initVariantArgFromLong(long lVal, int type, VARIANT *pV)
{
	if (!pV)
		return E_POINTER;

    pV->vt = VT_I4;
	pV->lVal = lVal;

	return S_OK;
}

STDMETHODIMP CLMEngine::initVariantArgFromDouble(double dbl, int type, VARIANT *pV)
{
	if (!pV)
		return E_POINTER;

    pV->vt = VT_R8;
	pV->dblVal = dbl;

	return S_OK;
}

STDMETHODIMP CLMEngine::initVariantArgFromIUnknown(IUnknown *pI, int type, VARIANT *pV)
{
	if (!pI || !pV)
		return E_POINTER;

    pV->vt = VT_UNKNOWN;
	pV->punkVal = pI;

	return S_OK;
}

STDMETHODIMP CLMEngine::initVariantArgFromIDispatch(IDispatch *pI, int type, VARIANT *pV)
{
	if (!pI || !pV)
		return E_POINTER;

    pV->vt = VT_DISPATCH;
	pV->punkVal = pI;

	return S_OK;
}

STDMETHODIMP CLMEngine::getIDispatchOnHost( IDispatch **ppHostDisp )
{
	if( ppHostDisp == NULL )
		return E_POINTER;

	HRESULT hr = E_FAIL;

	if( m_pReader != NULL )
	{
		IDAViewerControl *pViewer;
		hr = m_pReader->get_ViewerControl( &pViewer );
		if( SUCCEEDED( hr ) && pViewer != NULL )
		{
			IOleObject *pOleObj;
			hr = pViewer->QueryInterface( IID_IOleObject, (void**) &pOleObj );
			pViewer->Release();
			
			if( SUCCEEDED( hr ) )
			{
				IOleClientSite *pClientSite;
				hr = pOleObj->GetClientSite( &pClientSite );
				pOleObj->Release();

				if( SUCCEEDED( hr ) )
				{
					IOleContainer *pContainer;
					hr = pClientSite->GetContainer( &pContainer );
					pClientSite->Release();
					if( SUCCEEDED( hr ) )
					{
						IDispatch *pDispatch;
						hr = pContainer->QueryInterface( IID_IDispatch, (void**)&pDispatch );
						pContainer->Release();
						if( SUCCEEDED( hr ) )
						{
							pDispatch->Release();
						}
					}
				}
			}
			
		}
	}
	return hr;

}

/***************************************
 * SyncStream
 ***************************************/

SyncStream::SyncStream(LPSTREAM pStream)
{
	m_pStream = pStream;
}

SyncStream::~SyncStream()
{
}

STDMETHODIMP SyncStream::Commit()
{
	return m_pStream->Commit(STGC_DEFAULT);
}

STDMETHODIMP SyncStream::Revert()
{
	return m_pStream->Revert();
}

STDMETHODIMP SyncStream::readByte(LPBYTE pByte)
{
	if (!pByte)
		return E_POINTER;

	HRESULT hr = NULL;
	ULONG	nRead;
	hr = m_pStream->Read((void*)pByte, 1L, &nRead);

#if 0
	char cbuf[100];
	sprintf(cbuf, "readByte::%d bytes read, buf = %d, 0x%X", nRead, buf, buf);
	MessageBox(NULL, cbuf, "CLMEngine", MB_OK);
#endif

	if (hr == S_FALSE || (hr == S_OK && nRead != 1))
		hr = E_FAIL;

	return hr;
}


STDMETHODIMP SyncStream::readBytes(LPBYTE pByte, ULONG count, ULONG *pNumRead)
{
	if (!pByte)
		return E_POINTER;

	ULONG	nRead;
	HRESULT hr = m_pStream->Read((void *)pByte, count, &nRead);

	if (hr == S_FALSE || (hr == S_OK && nRead != count))
		hr = E_FAIL;

	if (pNumRead)
		*pNumRead = nRead;

	return hr;
}

/***************************************
 * AsyncStream
 ***************************************/
AsyncStream::AsyncStream(ByteArrayStream *pBAStream, ULONG blkSize)
{
	pBAStreamQueue = new ByteArrayStreamQueue;
	pBAStreamQueueTail = new ByteArrayStreamQueue;
	pBAStreamQueueHead = pBAStreamQueueTail;
	pBAStreamQueue->next = pBAStreamQueueTail;
	pBAStreamQueueTail->pBAStream = pBAStream;
	pBAStreamQueueTail->next = NULL;
	m_bPendingData = FALSE;
	m_nRead = 0;
	m_BlkSize = blkSize;
}

AsyncStream::~AsyncStream()
{
	ByteArrayStreamQueue	*pBAStreamQNext;
	
	if (pBAStreamQueue != NULL) {
		pBAStreamQNext = pBAStreamQueue->next;
		delete pBAStreamQueue;
		
		while (pBAStreamQNext != NULL) {
			pBAStreamQueue = pBAStreamQNext;
			pBAStreamQNext = pBAStreamQNext->next;
			delete pBAStreamQueue->pBAStream;
			delete pBAStreamQueue;
		}
	}
}

STDMETHODIMP AsyncStream::Commit()
{
	ByteArrayStreamQueue *tmpQ = pBAStreamQueue->next;
	ByteArrayStreamQueue *nextQ;

	if (tmpQ != pBAStreamQueueHead) {
		while ((tmpQ != pBAStreamQueueHead) && (tmpQ != NULL)) {
			nextQ = tmpQ->next;
			delete tmpQ->pBAStream;
			delete tmpQ;
			tmpQ = nextQ;
		}
		pBAStreamQueue->next = pBAStreamQueueHead;
	}

	pBAStreamQueueHead->pBAStream->Commit();

	return S_OK;
}

STDMETHODIMP AsyncStream::Revert()
{
	HRESULT hr = E_FAIL;

	pBAStreamQueueHead = pBAStreamQueue->next;

	ByteArrayStreamQueue	*tmpQ = pBAStreamQueueHead;

	while (tmpQ) {
		hr = tmpQ->pBAStream->Revert();
		if (!SUCCEEDED(hr))
			break;
		tmpQ = tmpQ->next;
	}
	return hr;
}


STDMETHODIMP AsyncStream::readByte(LPBYTE pByte)
{
	HRESULT hr = E_FAIL;
	
	if (!pBAStreamQueueHead) {
		if (m_bPendingData)
			hr = E_PENDING;
		else
			hr = E_FAIL;
	} else {
		if (m_nRead >= m_BlkSize) 
			hr = E_PENDING;
		else {
			if (pBAStreamQueueHead->pBAStream)
				hr = pBAStreamQueueHead->pBAStream->readByte(pByte);
			if (hr == E_FAIL) {
				// No more data in this stream, try moving on to the next one.
				if (pBAStreamQueueHead != pBAStreamQueueTail) {
					pBAStreamQueueHead = pBAStreamQueueHead->next;
					hr = readByte(pByte);
				} else {
					// We've run out of streams
					if (m_bPendingData)
						hr = E_PENDING;
					else
						hr = E_FAIL;
				}
			} else
				m_nRead++;
		}
	}
	return hr;
}

bool AsyncStream::hasBufferedData()
{
	if (pBAStreamQueueHead == 0)
		return false;

	if (pBAStreamQueueHead->pBAStream != 0 && pBAStreamQueueHead->pBAStream->hasBufferedData() )
		return true;

	if (pBAStreamQueueHead == pBAStreamQueueTail)
		return false;

	return true;
}


STDMETHODIMP AsyncStream::readBytes(LPBYTE pByte, ULONG count, ULONG *pNumRead)
{
	ULONG	nRead;
	HRESULT	hr = E_FAIL;

	if (!pBAStreamQueueHead) {
		if (m_bPendingData)
			hr = E_PENDING;
		else
			hr = E_FAIL;
	} else {
		if (m_nRead >= m_BlkSize)
			hr = E_PENDING;
		else {
			if (pBAStreamQueueHead->pBAStream)
				hr = pBAStreamQueueHead->pBAStream->readBytes(pByte, count, &nRead);
			m_nRead += nRead;
			if (hr == E_FAIL) {
				// No more data in this stream, try moving on to the next one.
				if (pBAStreamQueueHead != pBAStreamQueueTail) {
					pByte += nRead;
					pBAStreamQueueHead = pBAStreamQueueHead->next;

					ULONG	_nRead;
					hr = readBytes(pByte, count - nRead, &_nRead);
					nRead += _nRead;
				} else {
					// We've run out of streams
					if (m_bPendingData)
						hr = E_PENDING;
					else
						hr = E_FAIL;
				}
			} 
		}
	}

	if (pNumRead)
		*pNumRead = nRead;

	return hr;
}

STDMETHODIMP AsyncStream::ensureBlockSize( ULONG blockSize )
{
	//if the size that we are ensuring is greater than the 
	// current block size
	if( blockSize > m_BlkSize )
		//grow the current block size.
		m_BlkSize = blockSize;
	return S_OK;

}

STDMETHODIMP AsyncStream::SetPending(BOOL bFlag)
{
	m_bPendingData = bFlag;
	return S_OK;
}

STDMETHODIMP AsyncStream::ResetBlockRead()
{
	m_nRead = 0;
	return S_OK;
}

STDMETHODIMP AsyncStream::AddByteArrayStream(ByteArrayStream *pNewBAStream)
{
	pBAStreamQueueTail->next = new ByteArrayStreamQueue;
	if (!pBAStreamQueueTail->next)
		return E_OUTOFMEMORY;
	pBAStreamQueueTail = pBAStreamQueueTail->next;
	pBAStreamQueueTail->pBAStream = pNewBAStream;
	pBAStreamQueueTail->next = NULL;
	return S_OK;
}


/***************************************
 * ByteArrayStream
 ***************************************/

STDMETHODIMP ByteArrayStream::Commit()
{
	mark = next;
	return S_OK;
}

STDMETHODIMP ByteArrayStream::Revert()
{
	next = mark;
	remaining = size - (ULONG)(next - array);
	return S_OK;
}

ByteArrayStream::ByteArrayStream(BYTE *array, ULONG size)
{
	this->array = array;

	if (this->array) {
		this->size = size;
		this->remaining = size;

		BYTE *from = array;
		BYTE *to = this->array;

		while (size--)
			*to++ = *from++;
	} else {
		this->size = 0;
		this->remaining = 0;
	}

	this->next = this->array;
	Commit();
}

ByteArrayStream::~ByteArrayStream()
{
	if (array)
		delete[] array;
}

bool ByteArrayStream::hasBufferedData()
{
	if (remaining > 0)
		return true;
	else
		return false;
}

STDMETHODIMP ByteArrayStream::readByte(LPBYTE pByte)
{
	if (!pByte)
		return E_POINTER;

	HRESULT status;

	if (remaining) {
		remaining--;
		*pByte = *next++;
		status = S_OK;
	} else
		status = E_FAIL;

	return status;
}

STDMETHODIMP ByteArrayStream::readBytes(LPBYTE pByte, ULONG count, ULONG *pNumRead)
{
	HRESULT status;

	if (!pByte)
		return E_POINTER;

	if (remaining >= count) {
		if (pNumRead)
			*pNumRead = count;
		remaining -= count;

		while (count--)
			*pByte++ = *next++;

		status = S_OK;
	} else {
		if (pNumRead)
			*pNumRead = remaining;
		while (remaining--)
			*pByte++ = *next++;
		status = E_FAIL;
	}

	return status;
}

void ByteArrayStream::reset()
{
	next = array;
	remaining = size;
	mark = next;
}

/***************************************
 * CLMNotifier
 ***************************************/

STDMETHODIMP_(ULONG) CLMNotifier::AddRef() { return InterlockedIncrement(&_cRefs); }
	
STDMETHODIMP_(ULONG) CLMNotifier::Release() 
{
	ULONG refCount = InterlockedDecrement(&_cRefs);
	if (!refCount) {
		delete this;
		return refCount;
	}
	return _cRefs;
}

STDMETHODIMP CLMNotifier::QueryInterface(REFIID riid, void **ppv) 
{
	if (!ppv)
		return E_POINTER;
	
	*ppv = NULL;
	if (riid == IID_IUnknown) {
		*ppv = (void *)(IUnknown *)this;
	} else if (riid == IID_IDABvrHook) {
		*ppv = (void *)(IDAUntilNotifier *)this;
	}
	
	if (*ppv) {
		((IUnknown *)*ppv)->AddRef();
		return S_OK;
	}
	
	return E_NOINTERFACE;
}

STDMETHODIMP CLMNotifier::GetTypeInfoCount(UINT *pctinfo) { return E_NOTIMPL; }
STDMETHODIMP CLMNotifier::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo) { return E_NOTIMPL; }
STDMETHODIMP CLMNotifier::GetIDsOfNames(
						   REFIID riid, LPOLESTR *rgszNames, UINT cNames,
						   LCID lcid, DISPID *rgdispid) { return E_NOTIMPL; }
STDMETHODIMP CLMNotifier::Invoke(
					DISPID dispidMember, REFIID riid, LCID lcid,
					WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
					EXCEPINFO *pexcepinfo, UINT *puArgErr) { return E_NOTIMPL; }

STDMETHODIMP CLMNotifier::ClearEngine() { m_pEngine = NULL; return S_OK; }

CLMNotifier::CLMNotifier(CLMEngine *pEngine)
{
	m_pEngine = pEngine;
	//((IUnknown *)m_pEngine)->AddRef();
	
	_cRefs = 1;
}

CLMNotifier::~CLMNotifier()
{
	//((IUnknown *)m_pEngine)->Release();
}

STDMETHODIMP CLMNotifier::Notify(IDABehavior *eventData,
					IDABehavior *curRunningBvr,
					IDAView *curView,
					IDABehavior **ppBvr)
{
	if (!m_pEngine)
		return E_UNEXPECTED;

	return m_pEngine->Notify(eventData, curRunningBvr, curView, ppBvr);
}

/***************************************
 * CLMExportTable
 ***************************************/
CLMExportTable::CLMExportTable(IDAStatics *statics)
{

	m_nBvrs = 0;
	m_exportList = new CLMExportList;
	m_exportList->tag = NULL;
	m_exportList->pBvr = NULL;
	m_exportList->next = NULL;
	m_tail = m_exportList;
	m_pStatics = statics;
}

CLMExportTable::~CLMExportTable()
{
	CLMExportList	*next, *head;

	if (!m_exportList)
		return;

	head = m_exportList;
	m_exportList = m_exportList->next;
	free(head);
	while (m_exportList != NULL) {
		if (m_exportList->pBvr != NULL) 
			m_exportList->pBvr->Release();
		if (m_exportList->tag)
			free(m_exportList->tag);
		next = m_exportList->next;
		delete m_exportList;
		m_exportList = next;
	} 
}

STDMETHODIMP CLMExportTable::AddBehavior(BSTR tag, IDABehavior *pBvr)
{
	// First, let's look to see if the Script outpaced us and already put a 
	// switchable behavior here...
	CLMExportList	*pList = m_exportList->next;
	while (pList != NULL) {
		if (!lstrcmpW(tag, pList->tag)) {
			break;
		}
		pList = pList->next;
	}

	if (pList != NULL) {
		// Already exists!  Script must have been here first.  We'll just switch it in then.
		return pList->pBvr->SwitchTo(pBvr);
	}

	long len = lstrlenW(tag);
	m_tail->next = new CLMExportList;
	if (!m_tail->next)
		return E_OUTOFMEMORY;
	m_tail->next->tag = (OLECHAR *)new char[(len + 1) * 2 * sizeof(char)] ;
	if (!m_tail->next->tag) {
		delete m_tail->next;
		m_tail->next = NULL;
		return E_OUTOFMEMORY;
	}
	m_tail = m_tail->next;
	lstrcpyW(m_tail->tag, tag);
	m_tail->pBvr = pBvr;
	pBvr->AddRef();
	m_tail->next = NULL;
	return S_OK;
}

STDMETHODIMP CLMExportTable::GetBehavior(BSTR tag, IDABehavior *pDefaultBvr, IDABehavior **ppBvr)
{
	CLMExportList	*pList = m_exportList->next;

	if (!ppBvr)
		return E_POINTER;

	while (pList != NULL) {
		if (!lstrcmpW(tag, pList->tag)) {
			*ppBvr = pList->pBvr;
			pList->pBvr->AddRef();
			break;
		}
		pList = pList->next;
	}

	if (pList == NULL) {
		// Didn't find it yet, we'll switch on it later
		IDABehavior *pINewBvr;
		m_pStatics->ModifiableBehavior(pDefaultBvr, (IDABehavior **)&pINewBvr);
		AddBehavior(tag, pINewBvr);
		*ppBvr = pINewBvr;
	} 
	return S_OK;
}


URLRelToAbsConverter::URLRelToAbsConverter(LPSTR baseURL, LPSTR relURL) {
	DWORD len = INTERNET_MAX_URL_LENGTH;
		  
	if (!InternetCombineUrlA (baseURL, relURL, _url, &len, ICU_NO_ENCODE)) {
		// If we cannot determine if the path is absolute then assume
		// it is absolute
		lstrcpy (_url, relURL) ;
	}
}

LPSTR URLRelToAbsConverter::GetAbsoluteURL () { 
	return _url; 
}

URLCombineAndCanonicalizeOLESTR::URLCombineAndCanonicalizeOLESTR(char * base, LPOLESTR path) {

	WideToAnsi(path, _url);
            
	// Need to combine (takes care of canonicalization
	// internally)
	URLRelToAbsConverter absolutified(base, _url);
	char *resultURL = absolutified.GetAbsoluteURL();
	
	lstrcpy(_url, resultURL);

	AnsiToWide( _url, _urlWide );
}

LPSTR URLCombineAndCanonicalizeOLESTR::GetURL() { 
	return _url; 
}

LPWSTR URLCombineAndCanonicalizeOLESTR::GetURLWide() 
{
	return _urlWide;
}

STDMETHODIMP CLMEngine::createMsgWindow()
{
	WNDCLASS wndclass;
	
	memset(&wndclass, 0, sizeof(WNDCLASS));
	wndclass.style          = 0;
	wndclass.lpfnWndProc    = WorkerWndProc;
	wndclass.hInstance      = hInst;
	wndclass.hCursor        = NULL;
	wndclass.hbrBackground  = NULL;
	wndclass.lpszClassName  = WORKERHWND_CLASS;
	
	RegisterClass(&wndclass) ;
    
    m_workerHwnd = ::CreateWindow (WORKERHWND_CLASS,
                                   "LMEngine Worker Private Window",
                                   0,0,0,0,0,NULL,NULL,hInst,NULL);
	if (m_workerHwnd)
		return S_OK;
	else
		return E_FAIL;
}

LRESULT CALLBACK
CLMEngine::WorkerWndProc(HWND hwnd,
                     UINT msg,
                     WPARAM wParam,
                     LPARAM lParam)
{
    BOOL    fDefault = FALSE;
	LRESULT	lResult = E_FAIL;
    
    switch (msg) {
	  case WM_LMENGINE_DATA:
		  {
			  // OnDataAvailable has been called
			  CLMEngine *pEngine = (CLMEngine *)(wParam);

              // the last "we're done" message releases the daviewer
              // control (ReleaseAll()) which releases us. and
              // lmrtrend has already released us, so we need to bump
              // up our ref count.
              ((ILMEngine *)pEngine)->AddRef();
			  pEngine->NewDataHandler((CLMEngineInstrData *)lParam);


              // may be final release
              ((ILMEngine *)pEngine)->Release();

			  lResult = NO_ERROR;
		  }
		  break;

	  case WM_LMENGINE_TIMER_CALLBACK:
		  {
			  // The timer fired.  Lets process some more data
			  CLMEngine *pEngine = (CLMEngine *)(wParam);
              ((ILMEngine *)pEngine)->AddRef();
			  pEngine->ExecuteFromAsync();
              ((ILMEngine *)pEngine)->Release();
			  lResult = NO_ERROR;
		  }
		  break;

	  case WM_LMENGINE_SCRIPT_CALLBACK:
		  {
			  // Do a script callback
			  CLMEngine *pEngine = (CLMEngine *)wParam;
			  CLMEngineScriptData *scriptData = (CLMEngineScriptData *)lParam;
			  pEngine->callScriptOnPage(scriptData->scriptSourceToInvoke, scriptData->scriptLanguage);

			  // Trigger event indicating that the script has actually been called
			  if (scriptData->event)
				  pEngine->staticStatics->TriggerEvent(scriptData->event, scriptData->eventData);

			  // Clear everything
			  SysFreeString(scriptData->scriptSourceToInvoke);
			  SysFreeString(scriptData->scriptLanguage);
			  if (scriptData->event)
				  scriptData->event->Release();
			  if (scriptData->eventData)
				  scriptData->eventData->Release();
			  free(scriptData);
			  lResult = NO_ERROR;
		  }
		  break;

      default:
		  lResult = DefWindowProc(hwnd, msg, wParam, lParam);
		  break ;
    }

    return lResult;
}

STDMETHODIMP CLMEngine::AbortExecution()
{
	EnterCriticalSection(&m_CriticalSection);

        if(m_pmc)
        {
            m_pmc->Stop();

            {
                // make RenderFile fail if it called us.
                CComQIPtr<IGraphBuilder, &IID_IGraphBuilder> pgb(m_pmc);
                if(pgb)
                {
                    HRESULT hrTmp = pgb->Abort();
                    _ASSERTE(hrTmp == S_OK);
                }
            }

            long l = m_pmc.p->Release();
            m_pmc.p = 0;

            // that should have removed our last reference on the
            // graph and thus released the LM filter. If not, we have
            // a circular reference that won't go away. 
            _ASSERTE(l == 0 || m_fDbgInRenderFile);

        }
        
	if (m_bAbort == FALSE) {
		if (m_Timer)
			timeKillEvent(m_Timer);
		m_Timer = NULL;
		m_bAbort = TRUE;
		releaseAll();
		m_pIbsc = NULL;
		if (codeStream)
			delete codeStream;
		codeStream = NULL;
	}
	LeaveCriticalSection(&m_CriticalSection);

	return S_OK;
}

STDMETHODIMP_(BSTR) CLMEngine::ExpandImportPath(BSTR path)
{
	bool	doExpand = true;
	BSTR	expandedBSTR;

	/* Only do the expansion if the path is not absolute already;
	 * special case 'lmrt:'
         */

        if(m_bstrMediaCacheDir && wcsncmp(path, L"lmrt:", 5) == 0)
        {
            // waste!!!
            int cch = wcslen(path) + 1; 
            WCHAR *wsz = (WCHAR *)_alloca((cch + wcslen(m_bstrMediaCacheDir) + 20) * sizeof(WCHAR));
            wcscpy(wsz, L"file://");
            wcscat(wsz, m_bstrMediaCacheDir);
            wcscat(wsz, L"/");
            wcscat(wsz, path + 5);
            expandedBSTR = SysAllocString(wsz);
        }
        else
        {
            wchar_t  *wstr = wcschr(path, ':');
            if (wstr != NULL &&  (wcsncmp(wstr, L"://", 3) == 0))
            {
		// Just copy the original
		expandedBSTR = SysAllocStringLen(path, ::SysStringLen(path));
            }
            else
            {
		// Use the client site's url as the base, and create an absolute path from that.
		char *clientURL = GetURLOfClientSite();
		URLCombineAndCanonicalizeOLESTR canonURL(clientURL, path);
		free(clientURL);

		// Convert the result from ansi to wide
		char *url = canonURL.GetURL();
		int len = (lstrlenA(url)+1);
		LPWSTR absURL = ATLA2WHELPER((LPWSTR) alloca(len*2), url, len);

		// Create a bstr out of the result
		expandedBSTR = SysAllocString(absURL);
            }
        }

	return expandedBSTR;
}

STDMETHODIMP CLMEngine::getExecuteFromUnknown( IUnknown *pUnk, ILMEngineExecute **ppExecute )
{
	if( pUnk == NULL )
		return E_POINTER;
	if( ppExecute == NULL )
		return E_POINTER;
	HRESULT hr;

	ILMEngineWrapper *pWrapper;
	hr = pUnk->QueryInterface( IID_ILMEngineWrapper, (void**)&pWrapper );
	if( SUCCEEDED( hr ) )
	{
		IUnknown *pWrapped;
		hr = pWrapper->GetWrapped( &pWrapped );
		pWrapper->Release();
		if( SUCCEEDED( hr ) )
		{
			ILMEngineExecute *pExecute;
			hr = pWrapped->QueryInterface( IID_ILMEngineExecute, (void**)&pExecute );
			pWrapped->Release();
			if( SUCCEEDED( hr ) )
			{
				(*ppExecute) = pExecute;
				return S_OK;
			}
		}
	}
	else //perhaps this was not wrapped
	{
		ILMEngineExecute *pExecute;
		hr = pUnk->QueryInterface( IID_ILMEngineExecute, (void**)&pExecute );
		if( SUCCEEDED( hr ) )
		{
			(*ppExecute) = pExecute;
			return S_OK;
		}
	}
	return hr;
}

STDMETHODIMP CLMEngine::getEngine2FromUnknown( IUnknown *pUnk, ILMEngine2 **ppEngine )
{
	if( pUnk == NULL )
		return E_POINTER;
	if( ppEngine == NULL )
		return E_POINTER;
	HRESULT hr;

	ILMEngineWrapper *pWrapper;
	hr = pUnk->QueryInterface( IID_ILMEngineWrapper, (void**)&pWrapper );
	if( SUCCEEDED( hr ) )
	{
		IUnknown *pWrapped;
		hr = pWrapper->GetWrapped( &pWrapped );
		pWrapper->Release();
		if( SUCCEEDED( hr ) )
		{
			ILMEngine2 *pEngine;
			hr = pWrapped->QueryInterface( IID_ILMEngine2, (void**)&pEngine );
			pWrapped->Release();
			if( SUCCEEDED( hr ) )
			{
				(*ppEngine) = pEngine;
				return S_OK;
			}
		}
	}
	else //perhaps this was not wrapped
	{
		ILMEngine2 *pEngine;
		hr = pUnk->QueryInterface( IID_ILMEngine2, (void**)&pEngine );
		if( SUCCEEDED( hr ) )
		{
			(*ppEngine) = pEngine;
			return S_OK;
		}
	}
	return hr;
}

/**
* ILMCodecDownload
**/
STDMETHODIMP CLMEngine::setAutoCodecDownloadEnabled(BOOL bEnabled )
{
	m_bAutoCodecDownloadEnabled = bEnabled;
	return S_OK;
}

/**
*  ILMEngineExecute 
*/
STDMETHODIMP CLMEngine::ExportBehavior(BSTR key, IDABehavior *toExport)
{
	IUnknown *pUnk;
	m_exportTable->AddBehavior( key, toExport );
	return S_OK;
}

STDMETHODIMP CLMEngine::SetImage(IDAImage *pImage)
{
	if ( m_pImage != NULL )
		m_pImage->SwitchTo( pImage );
	else {
		m_pImage = pImage;
		m_pImage->AddRef();
	}
	return S_OK;
}

STDMETHODIMP CLMEngine::SetSound(IDASound *pSound)
{
	if (m_pSound != NULL)
		m_pSound->SwitchTo( pSound );
	else {
		m_pSound = pSound;
		m_pSound->AddRef();
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\dll\stdafx.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Ole Object initialization

Revision:

--*/

#include "..\behaviors\headers.h"
#include "resource.h"

#undef map
#undef SubclassWindow

// Put this here to initialize all the ATL stuff

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\control\execute.cpp ===
#include "Engine.h"

//#define COM_DEBUG

#ifdef COM_DEBUG
int _com_count = 0;
#define Assert(x, s) if (!(x)) MessageBox(NULL, s, "execute", MB_OK)
#endif

//#define instrTrace(s) { OutputDebugString(s); OutputDebugString("\n"); }
//#define instrTrace(s) MessageBox(NULL, s, "execute", MB_OK);
#define instrTrace(s)

// Returns address of top of LONG stack, postincrements pointer
#define PUSH_LONG_ADDR			(longTop++)

// Pushes the given LONG onto the LONG stack
#define PUSH_LONG(x)			(*longTop++ = (x))

// Returns value at top of LONG stack and pops it
#define POP_LONG				(*--longTop)

// Returns value of LONG at top-i
#define USE_LONG(i)				(*(longTop-i))

// Uses the value of LONG at top-i to create a VARIANT_BOOL
#define USE_LONG_AS_BOOL(i)		((short)-(*(longTop-i)))

// Pops i LONGS from top of int stack
#define FREE_LONG(i)			(longTop-=i)

// Address of returned int, which is actually a long
#define RET_LONG_ADDR			(&longTmp1)

// The value of the returned int, which is actually a long
#define RET_LONG				(longTmp1)

// Returns address of top of double stack, postincrements pointer
#define PUSH_DOUBLE_ADDR		(doubleTop++)

// Pushes the given double onto the double stack
#define PUSH_DOUBLE(x)			(*doubleTop++ = (x))

// Returns value at top of double stack and pops it
#define POP_DOUBLE				(*--doubleTop)

// Returns value of double at top-i
#define USE_DOUBLE(i)			(*(doubleTop-i))

// Pops i doubles from top of double stack
#define FREE_DOUBLE(i)			(doubleTop-=i)

// Pushes the given string onto the string stack
#define PUSH_STRING(x)			(*stringTop++ = (x))

// Returns value of the string at top-i
#define USE_STRING(i)			(*(stringTop-i))

// Pops and frees the string at the top of the string stack
#define FREE_STRING				(SysFreeString(*(--stringTop)))

// Pops without freeing a string
#define POP_STRING_NO_FREE		(*--stringTop)

// Pushes the given COM object onto the COM object stack
#define PUSH_COM(x)				(*(comTop++) = (x))

// Returns address of top of COM stack, postincrements pointer
#ifdef COM_DEBUG
#define PUSH_COM_ADDR			(_com_count++, comTop++)
#else
#define PUSH_COM_ADDR			(comTop++)
#endif

// Returns the value of the COM object at top-i
#define USE_COM(i)				(*(comTop-i))

// Pops and frees the COM object at the top of the COM object stack
#ifdef COM_DEBUG
#define FREE_COM				{	\
	_com_count--;					\
	(*--comTop)->Release();			\
	*comTop = NULL;					\
}
#else
#define FREE_COM				{	\
	((*--comTop)->Release());		\
	*comTop = NULL;					\
}
#endif

// Pops and frees the COM object, but tests whether it is null
#define FREE_COM_TEST			(freeCOM(*--comTop))

// Pops without freeing the COM object
#define POP_COM_NO_FREE			(*--comTop)

// Returns the address to the variable used to store returned COM objects
#ifdef COM_DEBUG
#define RET_COM_ADDR			(_com_count++, &comTmp)
#else
#define RET_COM_ADDR			(&comTmp)
#endif

// Returns retCom
#define RET_COM					(comTmp)

// Pushes a COM array ontot the COM array stack
#define PUSH_COM_ARRAY(x)		(*(comArrayTop++) = (x))

// Returns the value of the COM array object at top-i
#define USE_COM_ARRAY(i)		(*(comArrayTop-i))

// Pops and frees the COM array at the top of the COM array stack
// Also pops the associated com array length
#ifdef COM_DEBUG
#define FREE_COM_ARRAY		(freeCOMArray(*(--comArrayTop), *(--comArrayLenTop)), _com_count -= *(comArrayLenTop))
#else
#define FREE_COM_ARRAY		(freeCOMArray(*(--comArrayTop), *(--comArrayLenTop)))
#endif

// Push the given length onto the array length stack
#define PUSH_COM_ARRAY_LENGTH(x)	(*(comArrayLenTop++) = (x))

// Return the value of array length at top-i
#define USE_COM_ARRAY_LENGTH(i)		(*(comArrayLenTop-i))

// Method call with zero or more args
#define METHOD_CALL_0(obj, name) (status = (obj)->name())
#define METHOD_CALL_1(obj, name, a1) (status = (obj)->name((a1)))
#define METHOD_CALL_2(obj, name, a1, a2) (status = (obj)->name((a1), (a2)))
#define METHOD_CALL_3(obj, name, a1, a2, a3) (status = (obj)->name((a1), (a2), (a3)))
#define METHOD_CALL_4(obj, name, a1, a2, a3, a4) (status = (obj)->name((a1), (a2), (a3), (a4)))
#define METHOD_CALL_5(obj, name, a1, a2, a3, a4, a5) (status = (obj)->name((a1), (a2), (a3), (a4), (a5)))
#define METHOD_CALL_6(obj, name, a1, a2, a3, a4, a5, a6) (status = (obj)->name((a1), (a2), (a3), (a4), (a5), (a6)))
#define METHOD_CALL_7(obj, name, a1, a2, a3, a4, a5, a6, a7) (status = (obj)->name((a1), (a2), (a3), (a4), (a5), (a6), (a7)))
#define METHOD_CALL_8(obj, name, a1, a2, a3, a4, a5, a6, a7, a8) (status = (obj)->name((a1), (a2), (a3), (a4), (a5), (a6), (a7), (a8)))
#define METHOD_CALL_9(obj, name, a1, a2, a3, a4, a5, a6, a7, a8, a9) (status = (obj)->name((a1), (a2), (a3), (a4), (a5), (a6), (a7), (a8), (a9)))

#define IMPORT_METHOD_CALL_0(obj, name) (METHOD_CALL_0((obj), name))
#define IMPORT_METHOD_CALL_1(obj, name, a1) { BSTR _absPath = ExpandImportPath(a1); METHOD_CALL_1((obj), name, _absPath); SysFreeString(_absPath) }
#define IMPORT_METHOD_CALL_2(obj, name, a1, a2) { BSTR _absPath = ExpandImportPath(a1);	METHOD_CALL_2((obj), name, _absPath, (a2));	SysFreeString(_absPath); } 
#define IMPORT_METHOD_CALL_3(obj, name, a1, a2, a3) { BSTR _absPath = ExpandImportPath(a1); METHOD_CALL_3((obj), name, _absPath, (a2), (a3)); SysFreeString(_absPath); }
#define IMPORT_METHOD_CALL_4(obj, name, a1, a2, a3, a4) { BSTR _absPath = ExpandImportPath(a1); METHOD_CALL_4((obj), name, _absPath, (a2), (a3), (a4)); SysFreeString(_absPath); }
#define IMPORT_METHOD_CALL_5(obj, name, a1, a2, a3, a4, a5) { BSTR _absPath = ExpandImportPath(a1); METHOD_CALL_5((obj), name, _absPath, (a2), (a3), (a4), (a5)); SysFreeString(_absPath); }
#define IMPORT_METHOD_CALL_6(obj, name, a1, a2, a3, a4, a5, a6) { BSTR _absPath = ExpandImportPath(a1); METHOD_CALL_6((obj), name, _absPath, (a2), (a3), (a4), (a5), (a6)); SysFreeString(_absPath); }
#define IMPORT_METHOD_CALL_7(obj, name, a1, a2, a3, a4, a5, a6, a7) { BSTR _absPath = ExpandImportPath(a1); METHOD_CALL_7((obj), name, _absPath, (a2), (a3), (a4), (a5), (a6), (a7)); SysFreeString(_absPath); }
#define IMPORT_METHOD_CALL_8(obj, name, a1, a2, a3, a4, a5, a6, a7, a8) { BSTR _absPath = ExpandImportPath(a1); METHOD_CALL_8((obj), name, _absPath, (a2), (a3), (a4), (a5), (a6), (a7), (a8)); SysFreeString(_absPath); }
#define IMPORT_METHOD_CALL_9(obj, name, a1, a2, a3, a4, a5, a6, a7, a8, a9) { BSTR _absPath = ExpandImportPath(a1); METHOD_CALL_9((obj), name, _absPath, (a2), (a3), (a4), (a5), (a6), (a7), (a8), (a9)); SysFreeString(_absPath); }


// Create COM instance
#ifdef COM_DEBUG
#define COM_CREATE(c, i, dest) {	\
  (status = CoCreateInstance(c, NULL, CLSCTX_INPROC_SERVER, i, (void **) dest));	\
  _com_count++;	\
}
#else
#define COM_CREATE(c, i, dest)			(status = CoCreateInstance(c, NULL, CLSCTX_INPROC_SERVER, i, (void **) dest))
#endif

long CLMEngine::execute()
{
	BYTE command;

	HRESULT status = S_OK;

	ULONG	nRead;

	// Temp variables are available for personal use within
	// each case statement

	// Temporary LONG variables
	LONG longTmp1;
	LONG longTmp2;

	// Temporary BYTE variables
	BYTE byteTmp1;
	BYTE byteTmp2;

	// Temporary float variables
	float floatTmp1;

	// Temporary double variables
	double doubleTmp1;
	double doubleTmp2;
	double doubleTmp3;

	// Temporary BSTR variables
	BSTR bstrTmp1;
	BSTR bstrTmp2;

	// Temporary COM variables
	IUnknown *comTmp;

	// Temporary COM array variables
	IUnknown **comArrayTmp1;
	IUnknown **comArrayTmp2;

	// Temporary BOOLEAN variables
	VARIANT_BOOL tmpBool1;

	// Instruction version used to generate the following code
	int instructionVersion = 57;
		
	VARIANT_BOOL bNoExports;
	m_pReader->get_NoExports(&bNoExports);

	while (status == S_OK) {

		EnterCriticalSection(&m_CriticalSection);

		if (m_bAbort == TRUE) {
			status = E_ABORT;
			break;
		}

		// stream should be positioned at beginning of next command
		// or eof

		// Mark the stream in case we get interrupted mid command
		codeStream->Commit();

		// Get first byte of command
		status = codeStream->readByte(&command);

		// Failure means EOF
		if (status == E_FAIL) {
			status = S_OK;
			break;
		}

		if (status != S_OK)
			break;

		// Switch on the sort of command.  If it is a double byte
		// command then flow is given to a second switch

		// BEGIN AUTOGENERATED
		
		// Code must adhere to the following format:
		// case x:
		//    // Execute: "instruction_name"
		//    lines_of_code
		//    break;
		// where instruction_name is listed in Instructions.txt
		
		// Switch for 0
		switch(command)
		{
		case 0:
			// Execute: "unsupported"
			// USER GENERATED
			instrTrace("unsupported");
			status = E_INVALIDARG;
			break;
			
		case 1:
			// Execute: "check version"
				// USER GENERATED
				status = readLong(&longTmp1);
				if (SUCCEEDED(status) && (longTmp1 != instructionVersion))
					status = E_FAIL;
			break;
			
		case 2:
			// Execute: "push double"
			// USER GENERATED
			instrTrace("push double");
			if (SUCCEEDED(status = readDouble(&doubleTmp1)))
				PUSH_DOUBLE(doubleTmp1);
			break;
			
		case 3:
			// Execute: "push float as double"
			// USER GENERATED
			instrTrace("push float as double");
			if (SUCCEEDED(status = readFloat(&floatTmp1)))
				PUSH_DOUBLE((double)floatTmp1);
			break;
			
		case 4:
			// Execute: "push long as double"
			// USER GENERATED
			instrTrace("push long as double");
			if (SUCCEEDED(status = readLong(&longTmp1)))
				PUSH_DOUBLE((double)longTmp1);
			break;
			
		case 5:
			// Execute: "pop double"
			// USER GENERATED
			instrTrace("pop double");
			POP_DOUBLE;
			break;
			
		case 6:
			// Execute: "push string"
			// USER GENERATED
			instrTrace("push string");
			// Length follows as long
			// Characters follow after
			// Format of BSTR is 4 byte length, followed by Unicode chars
			// terminated by a 0
			if (SUCCEEDED(status = readLong(&longTmp1))) {
				bstrTmp2 = bstrTmp1 = SysAllocStringLen(0, longTmp1);
				if (bstrTmp2 != 0) {
					while (longTmp1-- && SUCCEEDED(status)) {
						if (SUCCEEDED(status = codeStream->readByte(&byteTmp1)))
							*bstrTmp2++ = byteTmp1;
					}
			
					if (SUCCEEDED(status)) {
						*bstrTmp2++ = 0;
						PUSH_STRING(bstrTmp1);
					} else 
						SysFreeString(bstrTmp1);
				} else
					status = STATUS_ERROR;
			}
			break;
			
		case 7:
			// Execute: "push unicode string"
			// USER GENERATED
				{
				instrTrace("push unicode string");
				// Length follows as long
				// Characters follow after in Unicode format
				// Format of BSTR is 4 byte length, followed by Unicode chars
				// terminated by a 0
				if (SUCCEEDED(status = readLong(&longTmp1))) {
					bstrTmp2 = bstrTmp1 = SysAllocStringLen(0, longTmp1);
					if (bstrTmp2 != 0) {
						OLECHAR tmpChar;
						while (longTmp1-- && SUCCEEDED(status)) {
							if (SUCCEEDED(status = codeStream->readByte(&byteTmp1))) {
								tmpChar = byteTmp1;
								if (SUCCEEDED(status = codeStream->readByte(&byteTmp1))) {
									tmpChar += ((OLECHAR)byteTmp1 << 8);
									*bstrTmp2++ = tmpChar;
								}
							}
						}
						
						if (SUCCEEDED(status)) {
							*bstrTmp2++ = 0; 
							PUSH_STRING(bstrTmp1);
						} else
							SysFreeString(bstrTmp1);
					} else
						status = STATUS_ERROR;
				}
				}
			break;
			
		case 8:
			// Execute: "pop string"
			// USER GENERATED
			instrTrace("pop string");
			FREE_STRING;
			break;
			
		case 9:
			// Execute: "push int"
			// USER GENERATED
			instrTrace("push int");
			if (SUCCEEDED(status = readSignedLong(&longTmp1)))
				PUSH_LONG(longTmp1);
			break;
			
		case 10:
			// Execute: "pop int"
			// USER GENERATED
			instrTrace("pop int");
			POP_LONG;
			break;
			
		case 11:
			// Execute: "push null com"
			// USER GENERATED
			instrTrace("push null com");
			PUSH_COM(0);
			break;
			
		case 12:
			// Execute: "push com from temp"
			// USER GENERATED
			instrTrace("push com from temp");
			// Get index of temp to copy from
			if (SUCCEEDED(status = readLong(&longTmp1))) {
				if (longTmp1 < comStoreSize &&
					(comTmp = comStore[longTmp1]) != 0) {
					
					// Inc reference count
					comTmp->AddRef();
					// Push it
					PUSH_COM(comTmp);
				} else
					status = E_INVALIDARG;
			}
			break;
			
		case 13:
			// Execute: "push com from temp release"
			// USER GENERATED
			instrTrace("push com from temp release");
			// Get index of temp to copy from
			if (SUCCEEDED(status = readLong(&longTmp1))) {
				if (longTmp1 < comStoreSize) {
					// Push it
					PUSH_COM(comStore[longTmp1]);
					// Set it to null so we don't try to release it on cleanup
					comStore[longTmp1] = 0;
				} else
					status = E_INVALIDARG;
			}
			break;
			
		case 14:
			// Execute: "copy com to temp"
			// USER GENERATED
			instrTrace("copy com to temp");
			// Get index of temp to copy comTop to
			if (SUCCEEDED(status = readLong(&longTmp1))) {
				if (longTmp1 < comStoreSize &&
					(comTmp = USE_COM(1)) != 0) {
					
					// Inc reference count
					comTmp->AddRef();
					// Stash it
					comStore[longTmp1] = comTmp;
				} else
					status = E_INVALIDARG;
			}
			break;
			
		case 15:
			// Execute: "pop com to temp"
			// USER GENERATED
			instrTrace("pop com to temp");
			// Get index of temp to copy comTop to
			if (SUCCEEDED(status = readLong(&longTmp1))) {				
				if (longTmp1 < comStoreSize) {
					// Stash it
					comStore[longTmp1] = POP_COM_NO_FREE;
				} else
					status = E_INVALIDARG;
			}
			break;
			
		case 16:
			// Execute: "pop com"
			// USER GENERATED
			FREE_COM_TEST;
			break;
			
		case 17:
			// Execute: "push array from coms"
			// USER GENERATED
			instrTrace("push array from coms");
			// Following long is length of array
			if (SUCCEEDED(status = readLong(&longTmp1))) {
				longTmp2 = longTmp1;
				// Create array of that size
				comArrayTmp1 = comArrayTmp2 = new IUnknown*[longTmp1];
				if (comArrayTmp1 != 0) {
					// POP_COM_NO_FREE COM's from stack into array
					while (longTmp2--)
						*comArrayTmp2++ = POP_COM_NO_FREE;
					// Push array onto comArray stack
					PUSH_COM_ARRAY(comArrayTmp1);
					// Push length onto array length stack
					PUSH_COM_ARRAY_LENGTH(longTmp1);
				} else
					status = E_OUTOFMEMORY;
			}
			break;
			
		case 18:
			// Execute: "pop array"
			// USER GENERATED
			FREE_COM_ARRAY;
			break;
			
		case 19:
			// Execute: "push null array"
			// USER GENERATED
			PUSH_COM_ARRAY(0);
			PUSH_COM_ARRAY_LENGTH(0);
			break;
			
		case 20:
			// Execute: "push Point3Bvr Bbox3Bvr.getMin()"
			// AUTOGENERATED
			instrTrace("push Point3Bvr Bbox3Bvr.getMin()");
			METHOD_CALL_1(
				(IDABbox3*)USE_COM(1),
				get_Min,
				(IDAPoint3**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 21:
			// Execute: "push Point3Bvr Bbox3Bvr.getMax()"
			// AUTOGENERATED
			instrTrace("push Point3Bvr Bbox3Bvr.getMax()");
			METHOD_CALL_1(
				(IDABbox3*)USE_COM(1),
				get_Max,
				(IDAPoint3**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 22:
			// Execute: "push Point2Bvr Bbox2Bvr.getMin()"
			// AUTOGENERATED
			instrTrace("push Point2Bvr Bbox2Bvr.getMin()");
			METHOD_CALL_1(
				(IDABbox2*)USE_COM(1),
				get_Min,
				(IDAPoint2**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 23:
			// Execute: "push Point2Bvr Bbox2Bvr.getMax()"
			// AUTOGENERATED
			instrTrace("push Point2Bvr Bbox2Bvr.getMax()");
			METHOD_CALL_1(
				(IDABbox2*)USE_COM(1),
				get_Max,
				(IDAPoint2**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 24:
			// Execute: "push NumberBvr Vector3Bvr.getZ()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Vector3Bvr.getZ()");
			METHOD_CALL_1(
				(IDAVector3*)USE_COM(1),
				get_Z,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 25:
			// Execute: "push Vector3Bvr Vector3Bvr.normalize()"
			// AUTOGENERATED
			instrTrace("push Vector3Bvr Vector3Bvr.normalize()");
			METHOD_CALL_1(
				(IDAVector3*)USE_COM(1),
				Normalize,
				(IDAVector3**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 26:
			// Execute: "push NumberBvr Vector3Bvr.getX()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Vector3Bvr.getX()");
			METHOD_CALL_1(
				(IDAVector3*)USE_COM(1),
				get_X,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 27:
			// Execute: "push NumberBvr Vector3Bvr.lengthSquared()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Vector3Bvr.lengthSquared()");
			METHOD_CALL_1(
				(IDAVector3*)USE_COM(1),
				get_LengthSquared,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 28:
			// Execute: "push NumberBvr Vector3Bvr.getY()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Vector3Bvr.getY()");
			METHOD_CALL_1(
				(IDAVector3*)USE_COM(1),
				get_Y,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 29:
			// Execute: "push Vector3Bvr Vector3Bvr.transform(Transform3Bvr)"
			// AUTOGENERATED
			instrTrace("push Vector3Bvr Vector3Bvr.transform(Transform3Bvr)");
			METHOD_CALL_2(
				(IDAVector3*)USE_COM(1),
				Transform,
				(IDATransform3*)USE_COM(2),
				(IDAVector3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 30:
			// Execute: "push Vector3Bvr Vector3Bvr.mul(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Vector3Bvr Vector3Bvr.mul(NumberBvr)");
			METHOD_CALL_2(
				(IDAVector3*)USE_COM(1),
				MulAnim,
				(IDANumber*)USE_COM(2),
				(IDAVector3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 31:
			// Execute: "push Vector3Bvr Vector3Bvr.mul(double)"
			// AUTOGENERATED
			instrTrace("push Vector3Bvr Vector3Bvr.mul(double)");
			METHOD_CALL_2(
				(IDAVector3*)USE_COM(1),
				Mul,
				USE_DOUBLE(1),
				(IDAVector3**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 32:
			// Execute: "push NumberBvr Vector3Bvr.length()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Vector3Bvr.length()");
			METHOD_CALL_1(
				(IDAVector3*)USE_COM(1),
				get_Length,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 33:
			// Execute: "push Vector3Bvr Vector3Bvr.div(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Vector3Bvr Vector3Bvr.div(NumberBvr)");
			METHOD_CALL_2(
				(IDAVector3*)USE_COM(1),
				DivAnim,
				(IDANumber*)USE_COM(2),
				(IDAVector3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 34:
			// Execute: "push Vector3Bvr Vector3Bvr.div(double)"
			// AUTOGENERATED
			instrTrace("push Vector3Bvr Vector3Bvr.div(double)");
			METHOD_CALL_2(
				(IDAVector3*)USE_COM(1),
				Div,
				USE_DOUBLE(1),
				(IDAVector3**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 35:
			// Execute: "push Vector2Bvr Vector2Bvr.normalize()"
			// AUTOGENERATED
			instrTrace("push Vector2Bvr Vector2Bvr.normalize()");
			METHOD_CALL_1(
				(IDAVector2*)USE_COM(1),
				Normalize,
				(IDAVector2**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 36:
			// Execute: "push NumberBvr Vector2Bvr.getX()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Vector2Bvr.getX()");
			METHOD_CALL_1(
				(IDAVector2*)USE_COM(1),
				get_X,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 37:
			// Execute: "push NumberBvr Vector2Bvr.lengthSquared()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Vector2Bvr.lengthSquared()");
			METHOD_CALL_1(
				(IDAVector2*)USE_COM(1),
				get_LengthSquared,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 38:
			// Execute: "push NumberBvr Vector2Bvr.getY()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Vector2Bvr.getY()");
			METHOD_CALL_1(
				(IDAVector2*)USE_COM(1),
				get_Y,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 39:
			// Execute: "push Vector2Bvr Vector2Bvr.transform(Transform2Bvr)"
			// AUTOGENERATED
			instrTrace("push Vector2Bvr Vector2Bvr.transform(Transform2Bvr)");
			METHOD_CALL_2(
				(IDAVector2*)USE_COM(1),
				Transform,
				(IDATransform2*)USE_COM(2),
				(IDAVector2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 40:
			// Execute: "push NumberBvr Vector2Bvr.length()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Vector2Bvr.length()");
			METHOD_CALL_1(
				(IDAVector2*)USE_COM(1),
				get_Length,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 41:
			// Execute: "push Vector2Bvr Vector2Bvr.mul(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Vector2Bvr Vector2Bvr.mul(NumberBvr)");
			METHOD_CALL_2(
				(IDAVector2*)USE_COM(1),
				MulAnim,
				(IDANumber*)USE_COM(2),
				(IDAVector2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 42:
			// Execute: "push Vector2Bvr Vector2Bvr.mul(double)"
			// AUTOGENERATED
			instrTrace("push Vector2Bvr Vector2Bvr.mul(double)");
			METHOD_CALL_2(
				(IDAVector2*)USE_COM(1),
				Mul,
				USE_DOUBLE(1),
				(IDAVector2**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 43:
			// Execute: "push Vector2Bvr Vector2Bvr.div(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Vector2Bvr Vector2Bvr.div(NumberBvr)");
			METHOD_CALL_2(
				(IDAVector2*)USE_COM(1),
				DivAnim,
				(IDANumber*)USE_COM(2),
				(IDAVector2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 44:
			// Execute: "push Vector2Bvr Vector2Bvr.div(double)"
			// AUTOGENERATED
			instrTrace("push Vector2Bvr Vector2Bvr.div(double)");
			METHOD_CALL_2(
				(IDAVector2*)USE_COM(1),
				Div,
				USE_DOUBLE(1),
				(IDAVector2**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 45:
			// Execute: "push NumberBvr Point3Bvr.getZ()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Point3Bvr.getZ()");
			METHOD_CALL_1(
				(IDAPoint3*)USE_COM(1),
				get_Z,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 46:
			// Execute: "push NumberBvr Point3Bvr.getX()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Point3Bvr.getX()");
			METHOD_CALL_1(
				(IDAPoint3*)USE_COM(1),
				get_X,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 47:
			// Execute: "push NumberBvr Point3Bvr.getY()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Point3Bvr.getY()");
			METHOD_CALL_1(
				(IDAPoint3*)USE_COM(1),
				get_Y,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 48:
			// Execute: "push Point3Bvr Point3Bvr.transform(Transform3Bvr)"
			// AUTOGENERATED
			instrTrace("push Point3Bvr Point3Bvr.transform(Transform3Bvr)");
			METHOD_CALL_2(
				(IDAPoint3*)USE_COM(1),
				Transform,
				(IDATransform3*)USE_COM(2),
				(IDAPoint3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 49:
			// Execute: "push NumberBvr Point2Bvr.getX()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Point2Bvr.getX()");
			METHOD_CALL_1(
				(IDAPoint2*)USE_COM(1),
				get_X,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 50:
			// Execute: "push NumberBvr Point2Bvr.getY()"
			// AUTOGENERATED
			instrTrace("push NumberBvr Point2Bvr.getY()");
			METHOD_CALL_1(
				(IDAPoint2*)USE_COM(1),
				get_Y,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 51:
			// Execute: "push Point2Bvr Point2Bvr.transform(Transform2Bvr)"
			// AUTOGENERATED
			instrTrace("push Point2Bvr Point2Bvr.transform(Transform2Bvr)");
			METHOD_CALL_2(
				(IDAPoint2*)USE_COM(1),
				Transform,
				(IDATransform2*)USE_COM(2),
				(IDAPoint2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 52:
			// Execute: "push Path2Bvr Path2Bvr.close()"
			// AUTOGENERATED
			instrTrace("push Path2Bvr Path2Bvr.close()");
			METHOD_CALL_1(
				(IDAPath2*)USE_COM(1),
				Close,
				(IDAPath2**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 53:
			// Execute: "push ImageBvr Path2Bvr.draw(LineStyleBvr)"
			// AUTOGENERATED
			instrTrace("push ImageBvr Path2Bvr.draw(LineStyleBvr)");
			METHOD_CALL_2(
				(IDAPath2*)USE_COM(1),
				Draw,
				(IDALineStyle*)USE_COM(2),
				(IDAImage**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 54:
			// Execute: "push ImageBvr Path2Bvr.fill(LineStyleBvr, ImageBvr)"
			// AUTOGENERATED
			instrTrace("push ImageBvr Path2Bvr.fill(LineStyleBvr, ImageBvr)");
			METHOD_CALL_3(
				(IDAPath2*)USE_COM(1),
				Fill,
				(IDALineStyle*)USE_COM(2),
				(IDAImage*)USE_COM(3),
				(IDAImage**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 55:
			// Execute: "push Path2Bvr Path2Bvr.transform(Transform2Bvr)"
			// AUTOGENERATED
			instrTrace("push Path2Bvr Path2Bvr.transform(Transform2Bvr)");
			METHOD_CALL_2(
				(IDAPath2*)USE_COM(1),
				Transform,
				(IDATransform2*)USE_COM(2),
				(IDAPath2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 56:
			// Execute: "push Bbox2Bvr Path2Bvr.boundingBox(LineStyleBvr)"
			// AUTOGENERATED
			instrTrace("push Bbox2Bvr Path2Bvr.boundingBox(LineStyleBvr)");
			METHOD_CALL_2(
				(IDAPath2*)USE_COM(1),
				BoundingBox,
				(IDALineStyle*)USE_COM(2),
				(IDABbox2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 57:
			// Execute: "push MatteBvr MatteBvr.transform(Transform2Bvr)"
			// AUTOGENERATED
			instrTrace("push MatteBvr MatteBvr.transform(Transform2Bvr)");
			METHOD_CALL_2(
				(IDAMatte*)USE_COM(1),
				Transform,
				(IDATransform2*)USE_COM(2),
				(IDAMatte**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 58:
			// Execute: "push ImageBvr ImageBvr.clipPolygon(Point2Bvr[])"
			// AUTOGENERATED
			instrTrace("push ImageBvr ImageBvr.clipPolygon(Point2Bvr[])");
			METHOD_CALL_3(
				(IDAImage*)USE_COM(1),
				ClipPolygonImageEx,
				USE_COM_ARRAY_LENGTH(1),
				(IDAPoint2**)USE_COM_ARRAY(1),
				(IDAImage**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM_ARRAY;
			PUSH_COM(RET_COM);
			break;
			
		case 59:
			// Execute: "push ImageBvr ImageBvr.crop(Point2Bvr, Point2Bvr)"
			// AUTOGENERATED
			instrTrace("push ImageBvr ImageBvr.crop(Point2Bvr, Point2Bvr)");
			METHOD_CALL_3(
				(IDAImage*)USE_COM(1),
				Crop,
				(IDAPoint2*)USE_COM(2),
				(IDAPoint2*)USE_COM(3),
				(IDAImage**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 60:
			// Execute: "push ImageBvr ImageBvr.opacity(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push ImageBvr ImageBvr.opacity(NumberBvr)");
			METHOD_CALL_2(
				(IDAImage*)USE_COM(1),
				OpacityAnim,
				(IDANumber*)USE_COM(2),
				(IDAImage**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 61:
			// Execute: "push ImageBvr ImageBvr.opacity(double)"
			// AUTOGENERATED
			instrTrace("push ImageBvr ImageBvr.opacity(double)");
			METHOD_CALL_2(
				(IDAImage*)USE_COM(1),
				Opacity,
				USE_DOUBLE(1),
				(IDAImage**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 62:
			// Execute: "push ImageBvr ImageBvr.transform(Transform2Bvr)"
			// AUTOGENERATED
			instrTrace("push ImageBvr ImageBvr.transform(Transform2Bvr)");
			METHOD_CALL_2(
				(IDAImage*)USE_COM(1),
				Transform,
				(IDATransform2*)USE_COM(2),
				(IDAImage**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 63:
			// Execute: "push Bbox2Bvr ImageBvr.boundingBox()"
			// AUTOGENERATED
			instrTrace("push Bbox2Bvr ImageBvr.boundingBox()");
			METHOD_CALL_1(
				(IDAImage*)USE_COM(1),
				get_BoundingBox,
				(IDABbox2**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 64:
			// Execute: "push ImageBvr ImageBvr.mapToUnitSquare()"
			// AUTOGENERATED
			instrTrace("push ImageBvr ImageBvr.mapToUnitSquare()");
			METHOD_CALL_1(
				(IDAImage*)USE_COM(1),
				MapToUnitSquare,
				(IDAImage**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 65:
			// Execute: "push ImageBvr ImageBvr.undetectable()"
			// AUTOGENERATED
			instrTrace("push ImageBvr ImageBvr.undetectable()");
			METHOD_CALL_1(
				(IDAImage*)USE_COM(1),
				Undetectable,
				(IDAImage**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 66:
			// Execute: "push GeometryBvr GeometryBvr.lightColor(ColorBvr)"
			// AUTOGENERATED
			instrTrace("push GeometryBvr GeometryBvr.lightColor(ColorBvr)");
			METHOD_CALL_2(
				(IDAGeometry*)USE_COM(1),
				LightColor,
				(IDAColor*)USE_COM(2),
				(IDAGeometry**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 67:
			// Execute: "push GeometryBvr GeometryBvr.lightAttenuation(NumberBvr, NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push GeometryBvr GeometryBvr.lightAttenuation(NumberBvr, NumberBvr, NumberBvr)");
			METHOD_CALL_4(
				(IDAGeometry*)USE_COM(1),
				LightAttenuationAnim,
				(IDANumber*)USE_COM(2),
				(IDANumber*)USE_COM(3),
				(IDANumber*)USE_COM(4),
				(IDAGeometry**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 68:
			// Execute: "push GeometryBvr GeometryBvr.opacity(double)"
			// AUTOGENERATED
			instrTrace("push GeometryBvr GeometryBvr.opacity(double)");
			METHOD_CALL_2(
				(IDAGeometry*)USE_COM(1),
				Opacity,
				USE_DOUBLE(1),
				(IDAGeometry**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 69:
			// Execute: "push GeometryBvr GeometryBvr.opacity(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push GeometryBvr GeometryBvr.opacity(NumberBvr)");
			METHOD_CALL_2(
				(IDAGeometry*)USE_COM(1),
				OpacityAnim,
				(IDANumber*)USE_COM(2),
				(IDAGeometry**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 70:
			// Execute: "push GeometryBvr GeometryBvr.lightAttenuation(double, double, double)"
			// AUTOGENERATED
			instrTrace("push GeometryBvr GeometryBvr.lightAttenuation(double, double, double)");
			METHOD_CALL_4(
				(IDAGeometry*)USE_COM(1),
				LightAttenuation,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				USE_DOUBLE(3),
				(IDAGeometry**)RET_COM_ADDR
			);
			FREE_DOUBLE(3);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 71:
			// Execute: "push GeometryBvr GeometryBvr.diffuseColor(ColorBvr)"
			// AUTOGENERATED
			instrTrace("push GeometryBvr GeometryBvr.diffuseColor(ColorBvr)");
			METHOD_CALL_2(
				(IDAGeometry*)USE_COM(1),
				DiffuseColor,
				(IDAColor*)USE_COM(2),
				(IDAGeometry**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 72:
			// Execute: "push GeometryBvr GeometryBvr.texture(ImageBvr)"
			// AUTOGENERATED
			instrTrace("push GeometryBvr GeometryBvr.texture(ImageBvr)");
			METHOD_CALL_2(
				(IDAGeometry*)USE_COM(1),
				Texture,
				(IDAImage*)USE_COM(2),
				(IDAGeometry**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 73:
			// Execute: "push Statics.mousePosition"
			// AUTOGENERATED
			instrTrace("push Statics.mousePosition");
			METHOD_CALL_1(
				staticStatics,
				get_MousePosition,
				(IDAPoint2**)PUSH_COM_ADDR
			);
			break;
			
		case 74:
			// Execute: "push Statics.leftButtonState"
			// AUTOGENERATED
			instrTrace("push Statics.leftButtonState");
			METHOD_CALL_1(
				staticStatics,
				get_LeftButtonState,
				(IDABoolean**)PUSH_COM_ADDR
			);
			break;
			
		case 75:
			// Execute: "push Statics.rightButtonState"
			// AUTOGENERATED
			instrTrace("push Statics.rightButtonState");
			METHOD_CALL_1(
				staticStatics,
				get_RightButtonState,
				(IDABoolean**)PUSH_COM_ADDR
			);
			break;
			
		case 76:
			// Execute: "push Statics.trueBvr"
			// AUTOGENERATED
			instrTrace("push Statics.trueBvr");
			METHOD_CALL_1(
				staticStatics,
				get_DATrue,
				(IDABoolean**)PUSH_COM_ADDR
			);
			break;
			
		case 77:
			// Execute: "push Statics.falseBvr"
			// AUTOGENERATED
			instrTrace("push Statics.falseBvr");
			METHOD_CALL_1(
				staticStatics,
				get_DAFalse,
				(IDABoolean**)PUSH_COM_ADDR
			);
			break;
			
		case 78:
			// Execute: "push Statics.localTime"
			// AUTOGENERATED
			instrTrace("push Statics.localTime");
			METHOD_CALL_1(
				staticStatics,
				get_LocalTime,
				(IDANumber**)PUSH_COM_ADDR
			);
			break;
			
		case 79:
			// Execute: "push Statics.globalTime"
			// AUTOGENERATED
			instrTrace("push Statics.globalTime");
			METHOD_CALL_1(
				staticStatics,
				get_GlobalTime,
				(IDANumber**)PUSH_COM_ADDR
			);
			break;
			
		case 80:
			// Execute: "push Statics.pixel"
			// AUTOGENERATED
			instrTrace("push Statics.pixel");
			METHOD_CALL_1(
				staticStatics,
				get_Pixel,
				(IDANumber**)PUSH_COM_ADDR
			);
			break;
			
		case 81:
			// Execute: "push Statics.red"
			// AUTOGENERATED
			instrTrace("push Statics.red");
			METHOD_CALL_1(
				staticStatics,
				get_Red,
				(IDAColor**)PUSH_COM_ADDR
			);
			break;
			
		case 82:
			// Execute: "push Statics.green"
			// AUTOGENERATED
			instrTrace("push Statics.green");
			METHOD_CALL_1(
				staticStatics,
				get_Green,
				(IDAColor**)PUSH_COM_ADDR
			);
			break;
			
		case 83:
			// Execute: "push Statics.blue"
			// AUTOGENERATED
			instrTrace("push Statics.blue");
			METHOD_CALL_1(
				staticStatics,
				get_Blue,
				(IDAColor**)PUSH_COM_ADDR
			);
			break;
			
		case 84:
			// Execute: "push Statics.cyan"
			// AUTOGENERATED
			instrTrace("push Statics.cyan");
			METHOD_CALL_1(
				staticStatics,
				get_Cyan,
				(IDAColor**)PUSH_COM_ADDR
			);
			break;
			
		case 85:
			// Execute: "push Statics.magenta"
			// AUTOGENERATED
			instrTrace("push Statics.magenta");
			METHOD_CALL_1(
				staticStatics,
				get_Magenta,
				(IDAColor**)PUSH_COM_ADDR
			);
			break;
			
		case 86:
			// Execute: "push Statics.yellow"
			// AUTOGENERATED
			instrTrace("push Statics.yellow");
			METHOD_CALL_1(
				staticStatics,
				get_Yellow,
				(IDAColor**)PUSH_COM_ADDR
			);
			break;
			
		case 87:
			// Execute: "push Statics.black"
			// AUTOGENERATED
			instrTrace("push Statics.black");
			METHOD_CALL_1(
				staticStatics,
				get_Black,
				(IDAColor**)PUSH_COM_ADDR
			);
			break;
			
		case 88:
			// Execute: "push Statics.white"
			// AUTOGENERATED
			instrTrace("push Statics.white");
			METHOD_CALL_1(
				staticStatics,
				get_White,
				(IDAColor**)PUSH_COM_ADDR
			);
			break;
			
		case 89:
			// Execute: "push Statics.leftButtonDown"
			// AUTOGENERATED
			instrTrace("push Statics.leftButtonDown");
			METHOD_CALL_1(
				staticStatics,
				get_LeftButtonDown,
				(IDAEvent**)PUSH_COM_ADDR
			);
			break;
			
		case 90:
			// Execute: "push Statics.leftButtonUp"
			// AUTOGENERATED
			instrTrace("push Statics.leftButtonUp");
			METHOD_CALL_1(
				staticStatics,
				get_LeftButtonUp,
				(IDAEvent**)PUSH_COM_ADDR
			);
			break;
			
		case 91:
			// Execute: "push Statics.rightButtonDown"
			// AUTOGENERATED
			instrTrace("push Statics.rightButtonDown");
			METHOD_CALL_1(
				staticStatics,
				get_RightButtonDown,
				(IDAEvent**)PUSH_COM_ADDR
			);
			break;
			
		case 92:
			// Execute: "push Statics.rightButtonUp"
			// AUTOGENERATED
			instrTrace("push Statics.rightButtonUp");
			METHOD_CALL_1(
				staticStatics,
				get_RightButtonUp,
				(IDAEvent**)PUSH_COM_ADDR
			);
			break;
			
		case 93:
			// Execute: "push Statics.always"
			// AUTOGENERATED
			instrTrace("push Statics.always");
			METHOD_CALL_1(
				staticStatics,
				get_Always,
				(IDAEvent**)PUSH_COM_ADDR
			);
			break;
			
		case 94:
			// Execute: "push Statics.never"
			// AUTOGENERATED
			instrTrace("push Statics.never");
			METHOD_CALL_1(
				staticStatics,
				get_Never,
				(IDAEvent**)PUSH_COM_ADDR
			);
			break;
			
		case 95:
			// Execute: "push Statics.emptyGeometry"
			// AUTOGENERATED
			instrTrace("push Statics.emptyGeometry");
			METHOD_CALL_1(
				staticStatics,
				get_EmptyGeometry,
				(IDAGeometry**)PUSH_COM_ADDR
			);
			break;
			
		case 96:
			// Execute: "push Statics.emptyImage"
			// AUTOGENERATED
			instrTrace("push Statics.emptyImage");
			METHOD_CALL_1(
				staticStatics,
				get_EmptyImage,
				(IDAImage**)PUSH_COM_ADDR
			);
			break;
			
		case 97:
			// Execute: "push Statics.detectableEmptyImage"
			// AUTOGENERATED
			instrTrace("push Statics.detectableEmptyImage");
			METHOD_CALL_1(
				staticStatics,
				get_DetectableEmptyImage,
				(IDAImage**)PUSH_COM_ADDR
			);
			break;
			
		case 98:
			// Execute: "push Statics.ambientLight"
			// AUTOGENERATED
			instrTrace("push Statics.ambientLight");
			METHOD_CALL_1(
				staticStatics,
				get_AmbientLight,
				(IDAGeometry**)PUSH_COM_ADDR
			);
			break;
			
		case 99:
			// Execute: "push Statics.directionalLight"
			// AUTOGENERATED
			instrTrace("push Statics.directionalLight");
			METHOD_CALL_1(
				staticStatics,
				get_DirectionalLight,
				(IDAGeometry**)PUSH_COM_ADDR
			);
			break;
			
		case 100:
			// Execute: "push Statics.pointLight"
			// AUTOGENERATED
			instrTrace("push Statics.pointLight");
			METHOD_CALL_1(
				staticStatics,
				get_PointLight,
				(IDAGeometry**)PUSH_COM_ADDR
			);
			break;
			
		case 101:
			// Execute: "push Statics.defaultLineStyle"
			// AUTOGENERATED
			instrTrace("push Statics.defaultLineStyle");
			METHOD_CALL_1(
				staticStatics,
				get_DefaultLineStyle,
				(IDALineStyle**)PUSH_COM_ADDR
			);
			break;
			
		case 102:
			// Execute: "push Statics.emptyLineStyle"
			// AUTOGENERATED
			instrTrace("push Statics.emptyLineStyle");
			METHOD_CALL_1(
				staticStatics,
				get_EmptyLineStyle,
				(IDALineStyle**)PUSH_COM_ADDR
			);
			break;
			
		case 103:
			// Execute: "push Statics.joinStyleBevel"
			// AUTOGENERATED
			instrTrace("push Statics.joinStyleBevel");
			METHOD_CALL_1(
				staticStatics,
				get_JoinStyleBevel,
				(IDAJoinStyle**)PUSH_COM_ADDR
			);
			break;
			
		case 104:
			// Execute: "push Statics.joinStyleRound"
			// AUTOGENERATED
			instrTrace("push Statics.joinStyleRound");
			METHOD_CALL_1(
				staticStatics,
				get_JoinStyleRound,
				(IDAJoinStyle**)PUSH_COM_ADDR
			);
			break;
			
		case 105:
			// Execute: "push Statics.joinStyleMiter"
			// AUTOGENERATED
			instrTrace("push Statics.joinStyleMiter");
			METHOD_CALL_1(
				staticStatics,
				get_JoinStyleMiter,
				(IDAJoinStyle**)PUSH_COM_ADDR
			);
			break;
			
		case 106:
			// Execute: "push Statics.endStyleFlat"
			// AUTOGENERATED
			instrTrace("push Statics.endStyleFlat");
			METHOD_CALL_1(
				staticStatics,
				get_EndStyleFlat,
				(IDAEndStyle**)PUSH_COM_ADDR
			);
			break;
			
		case 107:
			// Execute: "push Statics.endStyleSquare"
			// AUTOGENERATED
			instrTrace("push Statics.endStyleSquare");
			METHOD_CALL_1(
				staticStatics,
				get_EndStyleSquare,
				(IDAEndStyle**)PUSH_COM_ADDR
			);
			break;
			
		case 108:
			// Execute: "push Statics.endStyleRound"
			// AUTOGENERATED
			instrTrace("push Statics.endStyleRound");
			METHOD_CALL_1(
				staticStatics,
				get_EndStyleRound,
				(IDAEndStyle**)PUSH_COM_ADDR
			);
			break;
			
		case 109:
			// Execute: "push Statics.dashStyleSolid"
			// AUTOGENERATED
			instrTrace("push Statics.dashStyleSolid");
			METHOD_CALL_1(
				staticStatics,
				get_DashStyleSolid,
				(IDADashStyle**)PUSH_COM_ADDR
			);
			break;
			
		case 110:
			// Execute: "push Statics.dashStyleDashed"
			// AUTOGENERATED
			instrTrace("push Statics.dashStyleDashed");
			METHOD_CALL_1(
				staticStatics,
				get_DashStyleDashed,
				(IDADashStyle**)PUSH_COM_ADDR
			);
			break;
			
		case 111:
			// Execute: "push Statics.defaultMicrophone"
			// AUTOGENERATED
			instrTrace("push Statics.defaultMicrophone");
			METHOD_CALL_1(
				staticStatics,
				get_DefaultMicrophone,
				(IDAMicrophone**)PUSH_COM_ADDR
			);
			break;
			
		case 112:
			// Execute: "push Statics.opaqueMatte"
			// AUTOGENERATED
			instrTrace("push Statics.opaqueMatte");
			METHOD_CALL_1(
				staticStatics,
				get_OpaqueMatte,
				(IDAMatte**)PUSH_COM_ADDR
			);
			break;
			
		case 113:
			// Execute: "push Statics.clearMatte"
			// AUTOGENERATED
			instrTrace("push Statics.clearMatte");
			METHOD_CALL_1(
				staticStatics,
				get_ClearMatte,
				(IDAMatte**)PUSH_COM_ADDR
			);
			break;
			
		case 114:
			// Execute: "push Statics.emptyMontage"
			// AUTOGENERATED
			instrTrace("push Statics.emptyMontage");
			METHOD_CALL_1(
				staticStatics,
				get_EmptyMontage,
				(IDAMontage**)PUSH_COM_ADDR
			);
			break;
			
		case 115:
			// Execute: "push Statics.silence"
			// AUTOGENERATED
			instrTrace("push Statics.silence");
			METHOD_CALL_1(
				staticStatics,
				get_Silence,
				(IDASound**)PUSH_COM_ADDR
			);
			break;
			
		case 116:
			// Execute: "push Statics.sinSynth"
			// AUTOGENERATED
			instrTrace("push Statics.sinSynth");
			METHOD_CALL_1(
				staticStatics,
				get_SinSynth,
				(IDASound**)PUSH_COM_ADDR
			);
			break;
			
		case 117:
			// Execute: "push Statics.defaultFont"
			// AUTOGENERATED
			instrTrace("push Statics.defaultFont");
			METHOD_CALL_1(
				staticStatics,
				get_DefaultFont,
				(IDAFontStyle**)PUSH_COM_ADDR
			);
			break;
			
		case 118:
			// Execute: "push Statics.xVector2"
			// AUTOGENERATED
			instrTrace("push Statics.xVector2");
			METHOD_CALL_1(
				staticStatics,
				get_XVector2,
				(IDAVector2**)PUSH_COM_ADDR
			);
			break;
			
		case 119:
			// Execute: "push Statics.yVector2"
			// AUTOGENERATED
			instrTrace("push Statics.yVector2");
			METHOD_CALL_1(
				staticStatics,
				get_YVector2,
				(IDAVector2**)PUSH_COM_ADDR
			);
			break;
			
		case 120:
			// Execute: "push Statics.zeroVector2"
			// AUTOGENERATED
			instrTrace("push Statics.zeroVector2");
			METHOD_CALL_1(
				staticStatics,
				get_ZeroVector2,
				(IDAVector2**)PUSH_COM_ADDR
			);
			break;
			
		case 121:
			// Execute: "push Statics.origin2"
			// AUTOGENERATED
			instrTrace("push Statics.origin2");
			METHOD_CALL_1(
				staticStatics,
				get_Origin2,
				(IDAPoint2**)PUSH_COM_ADDR
			);
			break;
			
		case 122:
			// Execute: "push Statics.xVector3"
			// AUTOGENERATED
			instrTrace("push Statics.xVector3");
			METHOD_CALL_1(
				staticStatics,
				get_XVector3,
				(IDAVector3**)PUSH_COM_ADDR
			);
			break;
			
		case 123:
			// Execute: "push Statics.yVector3"
			// AUTOGENERATED
			instrTrace("push Statics.yVector3");
			METHOD_CALL_1(
				staticStatics,
				get_YVector3,
				(IDAVector3**)PUSH_COM_ADDR
			);
			break;
			
		case 124:
			// Execute: "push Statics.zVector3"
			// AUTOGENERATED
			instrTrace("push Statics.zVector3");
			METHOD_CALL_1(
				staticStatics,
				get_ZVector3,
				(IDAVector3**)PUSH_COM_ADDR
			);
			break;
			
		case 125:
			// Execute: "push Statics.zeroVector3"
			// AUTOGENERATED
			instrTrace("push Statics.zeroVector3");
			METHOD_CALL_1(
				staticStatics,
				get_ZeroVector3,
				(IDAVector3**)PUSH_COM_ADDR
			);
			break;
			
		case 126:
			// Execute: "push Statics.origin3"
			// AUTOGENERATED
			instrTrace("push Statics.origin3");
			METHOD_CALL_1(
				staticStatics,
				get_Origin3,
				(IDAPoint3**)PUSH_COM_ADDR
			);
			break;
			
		case 127:
			// Execute: "push Statics.identityTransform3"
			// AUTOGENERATED
			instrTrace("push Statics.identityTransform3");
			METHOD_CALL_1(
				staticStatics,
				get_IdentityTransform3,
				(IDATransform3**)PUSH_COM_ADDR
			);
			break;
			
		case 128:
			// Execute: "push Statics.identityTransform2"
			// AUTOGENERATED
			instrTrace("push Statics.identityTransform2");
			METHOD_CALL_1(
				staticStatics,
				get_IdentityTransform2,
				(IDATransform2**)PUSH_COM_ADDR
			);
			break;
			
		case 129:
			// Execute: "push NumberBvr Statics.distance(Point2Bvr, Point2Bvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.distance(Point2Bvr, Point2Bvr)");
			METHOD_CALL_3(
				staticStatics,
				DistancePoint2,
				(IDAPoint2*)USE_COM(1),
				(IDAPoint2*)USE_COM(2),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 130:
			// Execute: "push NumberBvr Statics.distance(Point3Bvr, Point3Bvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.distance(Point3Bvr, Point3Bvr)");
			METHOD_CALL_3(
				staticStatics,
				DistancePoint3,
				(IDAPoint3*)USE_COM(1),
				(IDAPoint3*)USE_COM(2),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 131:
			// Execute: "push ImageBvr Statics.solidColorImage(ColorBvr)"
			// AUTOGENERATED
			instrTrace("push ImageBvr Statics.solidColorImage(ColorBvr)");
			METHOD_CALL_2(
				staticStatics,
				SolidColorImage,
				(IDAColor*)USE_COM(1),
				(IDAImage**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 132:
			// Execute: "push SoundBvr Statics.mix(SoundBvr, SoundBvr)"
			// AUTOGENERATED
			instrTrace("push SoundBvr Statics.mix(SoundBvr, SoundBvr)");
			METHOD_CALL_3(
				staticStatics,
				Mix,
				(IDASound*)USE_COM(1),
				(IDASound*)USE_COM(2),
				(IDASound**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 133:
			// Execute: "push Behavior Statics.untilEx(Behavior, DXMEvent)"
			// AUTOGENERATED
			instrTrace("push Behavior Statics.untilEx(Behavior, DXMEvent)");
			METHOD_CALL_3(
				staticStatics,
				UntilEx,
				(IDABehavior*)USE_COM(1),
				(IDAEvent*)USE_COM(2),
				(IDABehavior**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 134:
			// Execute: "push ColorBvr Statics.colorRgb(NumberBvr, NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push ColorBvr Statics.colorRgb(NumberBvr, NumberBvr, NumberBvr)");
			METHOD_CALL_4(
				staticStatics,
				ColorRgbAnim,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDANumber*)USE_COM(3),
				(IDAColor**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 135:
			// Execute: "push ColorBvr Statics.colorRgb(double, double, double)"
			// AUTOGENERATED
			instrTrace("push ColorBvr Statics.colorRgb(double, double, double)");
			METHOD_CALL_4(
				staticStatics,
				ColorRgb,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				USE_DOUBLE(3),
				(IDAColor**)RET_COM_ADDR
			);
			FREE_DOUBLE(3);
			PUSH_COM(RET_COM);
			break;
			
		case 136:
			// Execute: "push Transform3Bvr Statics.compose(Transform3Bvr, Transform3Bvr)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.compose(Transform3Bvr, Transform3Bvr)");
			METHOD_CALL_3(
				staticStatics,
				Compose3,
				(IDATransform3*)USE_COM(1),
				(IDATransform3*)USE_COM(2),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 137:
			// Execute: "push Transform2Bvr Statics.compose(Transform2Bvr, Transform2Bvr)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.compose(Transform2Bvr, Transform2Bvr)");
			METHOD_CALL_3(
				staticStatics,
				Compose2,
				(IDATransform2*)USE_COM(1),
				(IDATransform2*)USE_COM(2),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 138:
			// Execute: "push NumberBvr Statics.floor(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.floor(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				Floor,
				(IDANumber*)USE_COM(1),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 139:
			// Execute: "push Transform2Bvr Statics.scale2(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.scale2(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				Scale2UniformAnim,
				(IDANumber*)USE_COM(1),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 140:
			// Execute: "push Transform2Bvr Statics.scale2(double)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.scale2(double)");
			METHOD_CALL_2(
				staticStatics,
				Scale2Uniform,
				USE_DOUBLE(1),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			PUSH_COM(RET_COM);
			break;
			
		case 141:
			// Execute: "push NumberBvr Statics.ceiling(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.ceiling(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				Ceiling,
				(IDANumber*)USE_COM(1),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 142:
			// Execute: "push NumberBvr Statics.ln(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.ln(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				Ln,
				(IDANumber*)USE_COM(1),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 143:
			// Execute: "push ImageBvr Statics.overlay(ImageBvr, ImageBvr)"
			// AUTOGENERATED
			instrTrace("push ImageBvr Statics.overlay(ImageBvr, ImageBvr)");
			METHOD_CALL_3(
				staticStatics,
				Overlay,
				(IDAImage*)USE_COM(1),
				(IDAImage*)USE_COM(2),
				(IDAImage**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 144:
			// Execute: "push BooleanBvr Statics.gte(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push BooleanBvr Statics.gte(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				GTE,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDABoolean**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 145:
			// Execute: "push NumberBvr Statics.radiansToDegrees(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.radiansToDegrees(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				ToRadians,
				(IDANumber*)USE_COM(1),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 146:
			// Execute: "push Transform3Bvr Statics.scale3(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.scale3(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				Scale3UniformAnim,
				(IDANumber*)USE_COM(1),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 147:
			// Execute: "push Transform3Bvr Statics.scale3(double)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.scale3(double)");
			METHOD_CALL_2(
				staticStatics,
				Scale3Uniform,
				USE_DOUBLE(1),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			PUSH_COM(RET_COM);
			break;
			
		case 148:
			// Execute: "push NumberBvr Statics.toBvr(double)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.toBvr(double)");
			METHOD_CALL_2(
				staticStatics,
				DANumber,
				USE_DOUBLE(1),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			PUSH_COM(RET_COM);
			break;
			
		case 149:
			// Execute: "push DXMEvent Statics.keyUp(int)"
			// AUTOGENERATED
			instrTrace("push DXMEvent Statics.keyUp(int)");
			METHOD_CALL_2(
				staticStatics,
				KeyUp,
				USE_LONG(1),
				(IDAEvent**)RET_COM_ADDR
			);
			FREE_LONG(1);
			PUSH_COM(RET_COM);
			break;
			
		case 150:
			// Execute: "push BooleanBvr Statics.toBvr(boolean)"
			// AUTOGENERATED
			instrTrace("push BooleanBvr Statics.toBvr(boolean)");
			METHOD_CALL_2(
				staticStatics,
				DABoolean,
				USE_LONG_AS_BOOL(1),
				(IDABoolean**)RET_COM_ADDR
			);
			FREE_LONG(1);
			PUSH_COM(RET_COM);
			break;
			
		case 151:
			// Execute: "push BooleanBvr Statics.or(BooleanBvr, BooleanBvr)"
			// AUTOGENERATED
			instrTrace("push BooleanBvr Statics.or(BooleanBvr, BooleanBvr)");
			METHOD_CALL_3(
				staticStatics,
				Or,
				(IDABoolean*)USE_COM(1),
				(IDABoolean*)USE_COM(2),
				(IDABoolean**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 152:
			// Execute: "push NumberBvr Statics.mul(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.mul(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				Mul,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 153:
			// Execute: "push BooleanBvr Statics.not(BooleanBvr)"
			// AUTOGENERATED
			instrTrace("push BooleanBvr Statics.not(BooleanBvr)");
			METHOD_CALL_2(
				staticStatics,
				Not,
				(IDABoolean*)USE_COM(1),
				(IDABoolean**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 154:
			// Execute: "push Vector3Bvr Statics.cross(Vector3Bvr, Vector3Bvr)"
			// AUTOGENERATED
			instrTrace("push Vector3Bvr Statics.cross(Vector3Bvr, Vector3Bvr)");
			METHOD_CALL_3(
				staticStatics,
				CrossVector3,
				(IDAVector3*)USE_COM(1),
				(IDAVector3*)USE_COM(2),
				(IDAVector3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 155:
			// Execute: "push NumberBvr Statics.dot(Vector2Bvr, Vector2Bvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.dot(Vector2Bvr, Vector2Bvr)");
			METHOD_CALL_3(
				staticStatics,
				DotVector2,
				(IDAVector2*)USE_COM(1),
				(IDAVector2*)USE_COM(2),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 156:
			// Execute: "push NumberBvr Statics.dot(Vector3Bvr, Vector3Bvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.dot(Vector3Bvr, Vector3Bvr)");
			METHOD_CALL_3(
				staticStatics,
				DotVector3,
				(IDAVector3*)USE_COM(1),
				(IDAVector3*)USE_COM(2),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 157:
			// Execute: "push BooleanBvr Statics.and(BooleanBvr, BooleanBvr)"
			// AUTOGENERATED
			instrTrace("push BooleanBvr Statics.and(BooleanBvr, BooleanBvr)");
			METHOD_CALL_3(
				staticStatics,
				And,
				(IDABoolean*)USE_COM(1),
				(IDABoolean*)USE_COM(2),
				(IDABoolean**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 158:
			// Execute: "push NumberBvr Statics.add(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.add(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				Add,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 159:
			// Execute: "push Vector2Bvr Statics.add(Vector2Bvr, Vector2Bvr)"
			// AUTOGENERATED
			instrTrace("push Vector2Bvr Statics.add(Vector2Bvr, Vector2Bvr)");
			METHOD_CALL_3(
				staticStatics,
				AddVector2,
				(IDAVector2*)USE_COM(1),
				(IDAVector2*)USE_COM(2),
				(IDAVector2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 160:
			// Execute: "push Point2Bvr Statics.add(Point2Bvr, Vector2Bvr)"
			// AUTOGENERATED
			instrTrace("push Point2Bvr Statics.add(Point2Bvr, Vector2Bvr)");
			METHOD_CALL_3(
				staticStatics,
				AddPoint2Vector,
				(IDAPoint2*)USE_COM(1),
				(IDAVector2*)USE_COM(2),
				(IDAPoint2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 161:
			// Execute: "push Vector3Bvr Statics.add(Vector3Bvr, Vector3Bvr)"
			// AUTOGENERATED
			instrTrace("push Vector3Bvr Statics.add(Vector3Bvr, Vector3Bvr)");
			METHOD_CALL_3(
				staticStatics,
				AddVector3,
				(IDAVector3*)USE_COM(1),
				(IDAVector3*)USE_COM(2),
				(IDAVector3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 162:
			// Execute: "push Point3Bvr Statics.add(Point3Bvr, Vector3Bvr)"
			// AUTOGENERATED
			instrTrace("push Point3Bvr Statics.add(Point3Bvr, Vector3Bvr)");
			METHOD_CALL_3(
				staticStatics,
				AddPoint3Vector,
				(IDAPoint3*)USE_COM(1),
				(IDAVector3*)USE_COM(2),
				(IDAPoint3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 163:
			// Execute: "push NumberBvr Statics.sqrt(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.sqrt(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				Sqrt,
				(IDANumber*)USE_COM(1),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 164:
			// Execute: "push Behavior Statics.sequence(Behavior, Behavior)"
			// AUTOGENERATED
			instrTrace("push Behavior Statics.sequence(Behavior, Behavior)");
			METHOD_CALL_3(
				staticStatics,
				Sequence,
				(IDABehavior*)USE_COM(1),
				(IDABehavior*)USE_COM(2),
				(IDABehavior**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 165:
			// Execute: "push Transform3Bvr Statics.xShear(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.xShear(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				XShear3Anim,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 166:
			// Execute: "push Transform3Bvr Statics.xShear(double, double)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.xShear(double, double)");
			METHOD_CALL_3(
				staticStatics,
				XShear3,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_DOUBLE(2);
			PUSH_COM(RET_COM);
			break;
			
		case 167:
			// Execute: "push Transform3Bvr Statics.zShear(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.zShear(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				ZShear3Anim,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 168:
			// Execute: "push Transform3Bvr Statics.zShear(double, double)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.zShear(double, double)");
			METHOD_CALL_3(
				staticStatics,
				ZShear3,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_DOUBLE(2);
			PUSH_COM(RET_COM);
			break;
			
		case 169:
			// Execute: "push Transform2Bvr Statics.xShear(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.xShear(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				XShear2Anim,
				(IDANumber*)USE_COM(1),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 170:
			// Execute: "push NumberBvr Statics.degreesToRadians(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.degreesToRadians(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				ToRadians,
				(IDANumber*)USE_COM(1),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 171:
			// Execute: "push Transform2Bvr Statics.xShear(double)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.xShear(double)");
			METHOD_CALL_2(
				staticStatics,
				XShear2,
				USE_DOUBLE(1),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			PUSH_COM(RET_COM);
			break;
			
		case 172:
			// Execute: "push NumberBvr Statics.div(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.div(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				Div,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 173:
			// Execute: "push DXMEvent Statics.keyDown(int)"
			// AUTOGENERATED
			instrTrace("push DXMEvent Statics.keyDown(int)");
			METHOD_CALL_2(
				staticStatics,
				KeyDown,
				USE_LONG(1),
				(IDAEvent**)RET_COM_ADDR
			);
			FREE_LONG(1);
			PUSH_COM(RET_COM);
			break;
			
		case 174:
			// Execute: "push Vector2Bvr Statics.vector2(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Vector2Bvr Statics.vector2(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				Vector2Anim,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDAVector2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 175:
			// Execute: "push Vector2Bvr Statics.vector2(double, double)"
			// AUTOGENERATED
			instrTrace("push Vector2Bvr Statics.vector2(double, double)");
			METHOD_CALL_3(
				staticStatics,
				Vector2,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				(IDAVector2**)RET_COM_ADDR
			);
			FREE_DOUBLE(2);
			PUSH_COM(RET_COM);
			break;
			
		case 176:
			// Execute: "push DXMEvent Statics.notEvent(DXMEvent)"
			// AUTOGENERATED
			instrTrace("push DXMEvent Statics.notEvent(DXMEvent)");
			METHOD_CALL_2(
				staticStatics,
				NotEvent,
				(IDAEvent*)USE_COM(1),
				(IDAEvent**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 177:
			// Execute: "push Vector3Bvr Statics.vector3(NumberBvr, NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Vector3Bvr Statics.vector3(NumberBvr, NumberBvr, NumberBvr)");
			METHOD_CALL_4(
				staticStatics,
				Vector3Anim,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDANumber*)USE_COM(3),
				(IDAVector3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 178:
			// Execute: "push Vector3Bvr Statics.vector3(double, double, double)"
			// AUTOGENERATED
			instrTrace("push Vector3Bvr Statics.vector3(double, double, double)");
			METHOD_CALL_4(
				staticStatics,
				Vector3,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				USE_DOUBLE(3),
				(IDAVector3**)RET_COM_ADDR
			);
			FREE_DOUBLE(3);
			PUSH_COM(RET_COM);
			break;
			
		case 179:
			// Execute: "push ColorBvr Statics.colorHsl(double, double, double)"
			// AUTOGENERATED
			instrTrace("push ColorBvr Statics.colorHsl(double, double, double)");
			METHOD_CALL_4(
				staticStatics,
				ColorHsl,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				USE_DOUBLE(3),
				(IDAColor**)RET_COM_ADDR
			);
			FREE_DOUBLE(3);
			PUSH_COM(RET_COM);
			break;
			
		case 180:
			// Execute: "push ColorBvr Statics.colorHsl(NumberBvr, NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push ColorBvr Statics.colorHsl(NumberBvr, NumberBvr, NumberBvr)");
			METHOD_CALL_4(
				staticStatics,
				ColorHslAnim,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDANumber*)USE_COM(3),
				(IDAColor**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 181:
			// Execute: "push Path2Bvr Statics.line(Point2Bvr, Point2Bvr)"
			// AUTOGENERATED
			instrTrace("push Path2Bvr Statics.line(Point2Bvr, Point2Bvr)");
			METHOD_CALL_3(
				staticStatics,
				Line,
				(IDAPoint2*)USE_COM(1),
				(IDAPoint2*)USE_COM(2),
				(IDAPath2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 182:
			// Execute: "push Point2Bvr Statics.point2(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Point2Bvr Statics.point2(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				Point2Anim,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDAPoint2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 183:
			// Execute: "push Point2Bvr Statics.point2(double, double)"
			// AUTOGENERATED
			instrTrace("push Point2Bvr Statics.point2(double, double)");
			METHOD_CALL_3(
				staticStatics,
				Point2,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				(IDAPoint2**)RET_COM_ADDR
			);
			FREE_DOUBLE(2);
			PUSH_COM(RET_COM);
			break;
			
		case 184:
			// Execute: "push DXMEvent Statics.timer(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push DXMEvent Statics.timer(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				TimerAnim,
				(IDANumber*)USE_COM(1),
				(IDAEvent**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 185:
			// Execute: "push DXMEvent Statics.timer(double)"
			// AUTOGENERATED
			instrTrace("push DXMEvent Statics.timer(double)");
			METHOD_CALL_2(
				staticStatics,
				Timer,
				USE_DOUBLE(1),
				(IDAEvent**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			PUSH_COM(RET_COM);
			break;
			
		case 186:
			// Execute: "push Point3Bvr Statics.point3(NumberBvr, NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Point3Bvr Statics.point3(NumberBvr, NumberBvr, NumberBvr)");
			METHOD_CALL_4(
				staticStatics,
				Point3Anim,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDANumber*)USE_COM(3),
				(IDAPoint3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 187:
			// Execute: "push Point3Bvr Statics.point3(double, double, double)"
			// AUTOGENERATED
			instrTrace("push Point3Bvr Statics.point3(double, double, double)");
			METHOD_CALL_4(
				staticStatics,
				Point3,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				USE_DOUBLE(3),
				(IDAPoint3**)RET_COM_ADDR
			);
			FREE_DOUBLE(3);
			PUSH_COM(RET_COM);
			break;
			
		case 188:
			// Execute: "push NumberBvr Statics.cos(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.cos(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				Cos,
				(IDANumber*)USE_COM(1),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 189:
			// Execute: "push BooleanBvr Statics.lt(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push BooleanBvr Statics.lt(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				LT,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDABoolean**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 190:
			// Execute: "push NumberBvr Statics.neg(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.neg(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				Neg,
				(IDANumber*)USE_COM(1),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 191:
			// Execute: "push Vector2Bvr Statics.neg(Vector2Bvr)"
			// AUTOGENERATED
			instrTrace("push Vector2Bvr Statics.neg(Vector2Bvr)");
			METHOD_CALL_2(
				staticStatics,
				NegVector2,
				(IDAVector2*)USE_COM(1),
				(IDAVector2**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 192:
			// Execute: "push Vector3Bvr Statics.neg(Vector3Bvr)"
			// AUTOGENERATED
			instrTrace("push Vector3Bvr Statics.neg(Vector3Bvr)");
			METHOD_CALL_2(
				staticStatics,
				NegVector3,
				(IDAVector3*)USE_COM(1),
				(IDAVector3**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 193:
			// Execute: "push Transform3Bvr Statics.translate(NumberBvr, NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.translate(NumberBvr, NumberBvr, NumberBvr)");
			METHOD_CALL_4(
				staticStatics,
				Translate3Anim,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDANumber*)USE_COM(3),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 194:
			// Execute: "push Transform3Bvr Statics.translate(double, double, double)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.translate(double, double, double)");
			METHOD_CALL_4(
				staticStatics,
				Translate3,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				USE_DOUBLE(3),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_DOUBLE(3);
			PUSH_COM(RET_COM);
			break;
			
		case 195:
			// Execute: "push Transform3Bvr Statics.translate(Vector3Bvr)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.translate(Vector3Bvr)");
			METHOD_CALL_2(
				staticStatics,
				Translate3Vector,
				(IDAVector3*)USE_COM(1),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 196:
			// Execute: "push Transform3Bvr Statics.translate(Point3Bvr)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.translate(Point3Bvr)");
			METHOD_CALL_2(
				staticStatics,
				Translate3Point,
				(IDAPoint3*)USE_COM(1),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 197:
			// Execute: "push Transform3Bvr Statics.rotate(Vector3Bvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.rotate(Vector3Bvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				Rotate3Anim,
				(IDAVector3*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 198:
			// Execute: "push Transform3Bvr Statics.rotate(Vector3Bvr, double)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.rotate(Vector3Bvr, double)");
			METHOD_CALL_3(
				staticStatics,
				Rotate3,
				(IDAVector3*)USE_COM(1),
				USE_DOUBLE(1),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 199:
			// Execute: "push Transform2Bvr Statics.translate(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.translate(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				Translate2Anim,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 200:
			// Execute: "push Transform2Bvr Statics.translate(double, double)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.translate(double, double)");
			METHOD_CALL_3(
				staticStatics,
				Translate2,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_DOUBLE(2);
			PUSH_COM(RET_COM);
			break;
			
		case 201:
			// Execute: "push Transform2Bvr Statics.translate(Vector2Bvr)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.translate(Vector2Bvr)");
			METHOD_CALL_2(
				staticStatics,
				Translate2Vector,
				(IDAVector2*)USE_COM(1),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 202:
			// Execute: "push Transform2Bvr Statics.translate(Point2Bvr)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.translate(Point2Bvr)");
			METHOD_CALL_2(
				staticStatics,
				Translate2Point,
				(IDAPoint2*)USE_COM(1),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 203:
			// Execute: "push Transform2Bvr Statics.rotate(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.rotate(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				Rotate2Anim,
				(IDANumber*)USE_COM(1),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 204:
			// Execute: "push Transform2Bvr Statics.rotate(double)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.rotate(double)");
			METHOD_CALL_2(
				staticStatics,
				Rotate2,
				USE_DOUBLE(1),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			PUSH_COM(RET_COM);
			break;
			
		case 205:
			// Execute: "push NumberBvr Statics.sub(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.sub(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				Sub,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 206:
			// Execute: "push Behavior Statics.until(Behavior, DXMEvent, Behavior)"
			// AUTOGENERATED
			instrTrace("push Behavior Statics.until(Behavior, DXMEvent, Behavior)");
			METHOD_CALL_4(
				staticStatics,
				Until,
				(IDABehavior*)USE_COM(1),
				(IDAEvent*)USE_COM(2),
				(IDABehavior*)USE_COM(3),
				(IDABehavior**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 207:
			// Execute: "push Vector2Bvr Statics.sub(Vector2Bvr, Vector2Bvr)"
			// AUTOGENERATED
			instrTrace("push Vector2Bvr Statics.sub(Vector2Bvr, Vector2Bvr)");
			METHOD_CALL_3(
				staticStatics,
				SubVector2,
				(IDAVector2*)USE_COM(1),
				(IDAVector2*)USE_COM(2),
				(IDAVector2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 208:
			// Execute: "push Point2Bvr Statics.sub(Point2Bvr, Vector2Bvr)"
			// AUTOGENERATED
			instrTrace("push Point2Bvr Statics.sub(Point2Bvr, Vector2Bvr)");
			METHOD_CALL_3(
				staticStatics,
				SubPoint2Vector,
				(IDAPoint2*)USE_COM(1),
				(IDAVector2*)USE_COM(2),
				(IDAPoint2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 209:
			// Execute: "push Vector2Bvr Statics.sub(Point2Bvr, Point2Bvr)"
			// AUTOGENERATED
			instrTrace("push Vector2Bvr Statics.sub(Point2Bvr, Point2Bvr)");
			METHOD_CALL_3(
				staticStatics,
				SubPoint2,
				(IDAPoint2*)USE_COM(1),
				(IDAPoint2*)USE_COM(2),
				(IDAVector2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 210:
			// Execute: "push Vector3Bvr Statics.sub(Vector3Bvr, Vector3Bvr)"
			// AUTOGENERATED
			instrTrace("push Vector3Bvr Statics.sub(Vector3Bvr, Vector3Bvr)");
			METHOD_CALL_3(
				staticStatics,
				SubVector3,
				(IDAVector3*)USE_COM(1),
				(IDAVector3*)USE_COM(2),
				(IDAVector3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 211:
			// Execute: "push Point3Bvr Statics.sub(Point3Bvr, Vector3Bvr)"
			// AUTOGENERATED
			instrTrace("push Point3Bvr Statics.sub(Point3Bvr, Vector3Bvr)");
			METHOD_CALL_3(
				staticStatics,
				SubPoint3Vector,
				(IDAPoint3*)USE_COM(1),
				(IDAVector3*)USE_COM(2),
				(IDAPoint3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 212:
			// Execute: "push Vector3Bvr Statics.sub(Point3Bvr, Point3Bvr)"
			// AUTOGENERATED
			instrTrace("push Vector3Bvr Statics.sub(Point3Bvr, Point3Bvr)");
			METHOD_CALL_3(
				staticStatics,
				SubPoint3,
				(IDAPoint3*)USE_COM(1),
				(IDAPoint3*)USE_COM(2),
				(IDAVector3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 213:
			// Execute: "push GeometryBvr Statics.union(GeometryBvr, GeometryBvr)"
			// AUTOGENERATED
			instrTrace("push GeometryBvr Statics.union(GeometryBvr, GeometryBvr)");
			METHOD_CALL_3(
				staticStatics,
				UnionGeometry,
				(IDAGeometry*)USE_COM(1),
				(IDAGeometry*)USE_COM(2),
				(IDAGeometry**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 214:
			// Execute: "push MatteBvr Statics.union(MatteBvr, MatteBvr)"
			// AUTOGENERATED
			instrTrace("push MatteBvr Statics.union(MatteBvr, MatteBvr)");
			METHOD_CALL_3(
				staticStatics,
				UnionMatte,
				(IDAMatte*)USE_COM(1),
				(IDAMatte*)USE_COM(2),
				(IDAMatte**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 215:
			// Execute: "push MontageBvr Statics.union(MontageBvr, MontageBvr)"
			// AUTOGENERATED
			instrTrace("push MontageBvr Statics.union(MontageBvr, MontageBvr)");
			METHOD_CALL_3(
				staticStatics,
				UnionMontage,
				(IDAMontage*)USE_COM(1),
				(IDAMontage*)USE_COM(2),
				(IDAMontage**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 216:
			// Execute: "push NumberBvr Statics.abs(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.abs(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				Abs,
				(IDANumber*)USE_COM(1),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 217:
			// Execute: "push DXMEvent Statics.thenEvent(DXMEvent, DXMEvent)"
			// AUTOGENERATED
			instrTrace("push DXMEvent Statics.thenEvent(DXMEvent, DXMEvent)");
			METHOD_CALL_3(
				staticStatics,
				ThenEvent,
				(IDAEvent*)USE_COM(1),
				(IDAEvent*)USE_COM(2),
				(IDAEvent**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 218:
			// Execute: "push NumberBvr Statics.round(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.round(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				Round,
				(IDANumber*)USE_COM(1),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 219:
			// Execute: "push DXMEvent Statics.andEvent(DXMEvent, DXMEvent)"
			// AUTOGENERATED
			instrTrace("push DXMEvent Statics.andEvent(DXMEvent, DXMEvent)");
			METHOD_CALL_3(
				staticStatics,
				AndEvent,
				(IDAEvent*)USE_COM(1),
				(IDAEvent*)USE_COM(2),
				(IDAEvent**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 220:
			// Execute: "push DXMEvent Statics.orEvent(DXMEvent, DXMEvent)"
			// AUTOGENERATED
			instrTrace("push DXMEvent Statics.orEvent(DXMEvent, DXMEvent)");
			METHOD_CALL_3(
				staticStatics,
				OrEvent,
				(IDAEvent*)USE_COM(1),
				(IDAEvent*)USE_COM(2),
				(IDAEvent**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 221:
			// Execute: "push DXMEvent Statics.predicate(BooleanBvr)"
			// AUTOGENERATED
			instrTrace("push DXMEvent Statics.predicate(BooleanBvr)");
			METHOD_CALL_2(
				staticStatics,
				Predicate,
				(IDABoolean*)USE_COM(1),
				(IDAEvent**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 222:
			// Execute: "push NumberBvr Statics.mod(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.mod(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				Mod,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 223:
			// Execute: "push ColorBvr Statics.colorRgb255(short, short, short)"
			// AUTOGENERATED
			instrTrace("push ColorBvr Statics.colorRgb255(short, short, short)");
			METHOD_CALL_4(
				staticStatics,
				ColorRgb255,
				(short)USE_LONG(1),
				(short)USE_LONG(2),
				(short)USE_LONG(3),
				(IDAColor**)RET_COM_ADDR
			);
			FREE_LONG(3);
			PUSH_COM(RET_COM);
			break;
			
		case 224:
			// Execute: "push Transform3Bvr Statics.scale(NumberBvr, NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.scale(NumberBvr, NumberBvr, NumberBvr)");
			METHOD_CALL_4(
				staticStatics,
				Scale3Anim,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDANumber*)USE_COM(3),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 225:
			// Execute: "push Transform3Bvr Statics.scale(double, double, double)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.scale(double, double, double)");
			METHOD_CALL_4(
				staticStatics,
				Scale3,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				USE_DOUBLE(3),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_DOUBLE(3);
			PUSH_COM(RET_COM);
			break;
			
		case 226:
			// Execute: "push Transform3Bvr Statics.scale(Vector3Bvr)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.scale(Vector3Bvr)");
			METHOD_CALL_2(
				staticStatics,
				Scale3Vector,
				(IDAVector3*)USE_COM(1),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 227:
			// Execute: "push Transform2Bvr Statics.scale(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.scale(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				Scale2Anim,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 228:
			// Execute: "push Transform2Bvr Statics.scale(double, double)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.scale(double, double)");
			METHOD_CALL_3(
				staticStatics,
				Scale2,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_DOUBLE(2);
			PUSH_COM(RET_COM);
			break;
			
		case 229:
			// Execute: "push Transform2Bvr Statics.scale(Vector2Bvr)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.scale(Vector2Bvr)");
			METHOD_CALL_2(
				staticStatics,
				Scale2Vector,
				(IDAVector2*)USE_COM(1),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 230:
			// Execute: "push ImageBvr PickableImage.getImageBvr()"
			// AUTOGENERATED
			instrTrace("push ImageBvr PickableImage.getImageBvr()");
			METHOD_CALL_1(
				(IDAPickableResult*)USE_COM(1),
				get_Image,
				(IDAImage**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 231:
			// Execute: "push DXMEvent PickableImage.getPickEvent()"
			// AUTOGENERATED
			instrTrace("push DXMEvent PickableImage.getPickEvent()");
			METHOD_CALL_1(
				(IDAPickableResult*)USE_COM(1),
				get_PickEvent,
				(IDAEvent**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 232:
			// Execute: "push DXMEvent PickableGeometry.getPickEvent()"
			// AUTOGENERATED
			instrTrace("push DXMEvent PickableGeometry.getPickEvent()");
			METHOD_CALL_1(
				(IDAPickableResult*)USE_COM(1),
				get_PickEvent,
				(IDAEvent**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 233:
			// Execute: "push GeometryBvr PickableGeometry.getGeometryBvr()"
			// AUTOGENERATED
			instrTrace("push GeometryBvr PickableGeometry.getGeometryBvr()");
			METHOD_CALL_1(
				(IDAPickableResult*)USE_COM(1),
				get_Geometry,
				(IDAGeometry**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 234:
			// Execute: "push PickableGeometry GeometryBvr.pickableOccluded()"
			// AUTOGENERATED
			instrTrace("push PickableGeometry GeometryBvr.pickableOccluded()");
			METHOD_CALL_1(
				(IDAGeometry*)USE_COM(1),
				PickableOccluded,
				(IDAPickableResult**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 235:
			// Execute: "push PickableGeometry GeometryBvr.pickable()"
			// AUTOGENERATED
			instrTrace("push PickableGeometry GeometryBvr.pickable()");
			METHOD_CALL_1(
				(IDAGeometry*)USE_COM(1),
				Pickable,
				(IDAPickableResult**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 236:
			// Execute: "push PickableImage ImageBvr.pickableOccluded()"
			// AUTOGENERATED
			instrTrace("push PickableImage ImageBvr.pickableOccluded()");
			METHOD_CALL_1(
				(IDAImage*)USE_COM(1),
				PickableOccluded,
				(IDAPickableResult**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 237:
			// Execute: "push PickableImage ImageBvr.pickable()"
			// AUTOGENERATED
			instrTrace("push PickableImage ImageBvr.pickable()");
			METHOD_CALL_1(
				(IDAImage*)USE_COM(1),
				Pickable,
				(IDAPickableResult**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 238:
			// Execute: "push NumberBvr Statics.sin(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push NumberBvr Statics.sin(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				Sin,
				(IDANumber*)USE_COM(1),
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 239:
			// Execute: "push Transform3Bvr Statics.yShear(NumberBvr, NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.yShear(NumberBvr, NumberBvr)");
			METHOD_CALL_3(
				staticStatics,
				YShear3Anim,
				(IDANumber*)USE_COM(1),
				(IDANumber*)USE_COM(2),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 240:
			// Execute: "push Transform3Bvr Statics.yShear(double, double)"
			// AUTOGENERATED
			instrTrace("push Transform3Bvr Statics.yShear(double, double)");
			METHOD_CALL_3(
				staticStatics,
				YShear3,
				USE_DOUBLE(1),
				USE_DOUBLE(2),
				(IDATransform3**)RET_COM_ADDR
			);
			FREE_DOUBLE(2);
			PUSH_COM(RET_COM);
			break;
			
		case 241:
			// Execute: "push Transform2Bvr Statics.yShear(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.yShear(NumberBvr)");
			METHOD_CALL_2(
				staticStatics,
				YShear2Anim,
				(IDANumber*)USE_COM(1),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 242:
			// Execute: "push Transform2Bvr Statics.yShear(double)"
			// AUTOGENERATED
			instrTrace("push Transform2Bvr Statics.yShear(double)");
			METHOD_CALL_2(
				staticStatics,
				YShear2,
				USE_DOUBLE(1),
				(IDATransform2**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			PUSH_COM(RET_COM);
			break;
			
		case 243:
			// Execute: "push MatteBvr Statics.fillMatte(Path2Bvr)"
			// AUTOGENERATED
			instrTrace("push MatteBvr Statics.fillMatte(Path2Bvr)");
			METHOD_CALL_2(
				staticStatics,
				FillMatte,
				(IDAPath2*)USE_COM(1),
				(IDAMatte**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 244:
			// Execute: "push Behavior Behavior.duration(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Behavior Behavior.duration(NumberBvr)");
			METHOD_CALL_2(
				(IDABehavior*)USE_COM(1),
				DurationAnim,
				(IDANumber*)USE_COM(2),
				(IDABehavior**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 245:
			// Execute: "push Behavior Behavior.duration(double)"
			// AUTOGENERATED
			instrTrace("push Behavior Behavior.duration(double)");
			METHOD_CALL_2(
				(IDABehavior*)USE_COM(1),
				Duration,
				USE_DOUBLE(1),
				(IDABehavior**)RET_COM_ADDR
			);
			FREE_DOUBLE(1);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 246:
			// Execute: "push Behavior Behavior.substituteTime(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Behavior Behavior.substituteTime(NumberBvr)");
			METHOD_CALL_2(
				(IDABehavior*)USE_COM(1),
				SubstituteTime,
				(IDANumber*)USE_COM(2),
				(IDABehavior**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 247:
			// Execute: "call Behavior.init(Behavior)"
			// AUTOGENERATED
			instrTrace("call Behavior.init(Behavior)");
			METHOD_CALL_1(
				(IDABehavior*)USE_COM(1),
				Init,
				(IDABehavior*)USE_COM(2)
			);
			FREE_COM;
			FREE_COM;
			break;
			
		case 248:
			// Execute: "push Behavior ArrayBvr.nth(NumberBvr)"
			// AUTOGENERATED
			instrTrace("push Behavior ArrayBvr.nth(NumberBvr)");
			METHOD_CALL_2(
				(IDAArray*)USE_COM(1),
				NthAnim,
				(IDANumber*)USE_COM(2),
				(IDABehavior**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 249:
			// Execute: "push NumberBvr ArrayBvr.length()"
			// AUTOGENERATED
			instrTrace("push NumberBvr ArrayBvr.length()");
			METHOD_CALL_1(
				(IDAArray*)USE_COM(1),
				Length,
				(IDANumber**)RET_COM_ADDR
			);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 250:
			// Execute: "push Behavior TupleBvr.nth(int)"
			// AUTOGENERATED
			instrTrace("push Behavior TupleBvr.nth(int)");
			METHOD_CALL_2(
				(IDATuple*)USE_COM(1),
				Nth,
				USE_LONG(1),
				(IDABehavior**)RET_COM_ADDR
			);
			FREE_LONG(1);
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 251:
			// Execute: "push int TupleBvr.length()"
			// AUTOGENERATED
			instrTrace("push int TupleBvr.length()");
			METHOD_CALL_1(
				(IDATuple*)USE_COM(1),
				get_Length,
				RET_LONG_ADDR
			);
			FREE_COM;
			PUSH_LONG(RET_LONG);
			break;
			
		case 252:
			// Execute: "push DXMEvent DXMEvent.snapshotEvent(Behavior)"
			// AUTOGENERATED
			instrTrace("push DXMEvent DXMEvent.snapshotEvent(Behavior)");
			METHOD_CALL_2(
				(IDAEvent*)USE_COM(1),
				Snapshot,
				(IDABehavior*)USE_COM(2),
				(IDAEvent**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 253:
			// Execute: "push FontStyleBvr FontStyleBvr.color(ColorBvr)"
			// AUTOGENERATED
			instrTrace("push FontStyleBvr FontStyleBvr.color(ColorBvr)");
			METHOD_CALL_2(
				(IDAFontStyle*)USE_COM(1),
				Color,
				(IDAColor*)USE_COM(2),
				(IDAFontStyle**)RET_COM_ADDR
			);
			FREE_COM;
			FREE_COM;
			PUSH_COM(RET_COM);
			break;
			
		case 255:
			// Switch for 255
			 if (!SUCCEEDED(status = codeStream->readByte(&command))) 
				continue; 
			switch (command)
			{
			case 0:
				// Execute: "push FontStyleBvr FontStyleBvr.size(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr FontStyleBvr.size(NumberBvr)");
				METHOD_CALL_2(
					(IDAFontStyle*)USE_COM(1),
					SizeAnim,
					(IDANumber*)USE_COM(2),
					(IDAFontStyle**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 1:
				// Execute: "push FontStyleBvr FontStyleBvr.size(double)"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr FontStyleBvr.size(double)");
				METHOD_CALL_2(
					(IDAFontStyle*)USE_COM(1),
					Size,
					USE_DOUBLE(1),
					(IDAFontStyle**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 2:
				// Execute: "push FontStyleBvr FontStyleBvr.italic()"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr FontStyleBvr.italic()");
				METHOD_CALL_1(
					(IDAFontStyle*)USE_COM(1),
					Italic,
					(IDAFontStyle**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 3:
				// Execute: "push FontStyleBvr FontStyleBvr.bold()"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr FontStyleBvr.bold()");
				METHOD_CALL_1(
					(IDAFontStyle*)USE_COM(1),
					Bold,
					(IDAFontStyle**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 4:
				// Execute: "push Vector2Bvr Statics.vector2PolarDegrees(double, double)"
				// AUTOGENERATED
				instrTrace("push Vector2Bvr Statics.vector2PolarDegrees(double, double)");
				METHOD_CALL_3(
					staticStatics,
					Vector2PolarDegrees,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					(IDAVector2**)RET_COM_ADDR
				);
				FREE_DOUBLE(2);
				PUSH_COM(RET_COM);
				break;
				
			case 5:
				// Execute: "push Transform2Bvr Statics.compose2Array(Transform2Bvr[])"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.compose2Array(Transform2Bvr[])");
				METHOD_CALL_3(
					staticStatics,
					Compose2ArrayEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDATransform2**)USE_COM_ARRAY(1),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 6:
				// Execute: "push Path2Bvr Statics.arc(double, double, double, double)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.arc(double, double, double, double)");
				METHOD_CALL_5(
					staticStatics,
					ArcRadians,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					USE_DOUBLE(3),
					USE_DOUBLE(4),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_DOUBLE(4);
				PUSH_COM(RET_COM);
				break;
				
			case 7:
				// Execute: "push Path2Bvr Statics.arc(NumberBvr, NumberBvr, NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.arc(NumberBvr, NumberBvr, NumberBvr, NumberBvr)");
				METHOD_CALL_5(
					staticStatics,
					ArcRadiansAnim,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDANumber*)USE_COM(3),
					(IDANumber*)USE_COM(4),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 8:
				// Execute: "push Path2Bvr Statics.arcDegrees(double, double, double, double)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.arcDegrees(double, double, double, double)");
				METHOD_CALL_5(
					staticStatics,
					ArcDegrees,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					USE_DOUBLE(3),
					USE_DOUBLE(4),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_DOUBLE(4);
				PUSH_COM(RET_COM);
				break;
				
			case 9:
				// Execute: "push Path2Bvr Statics.concatArray(Path2Bvr[])"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.concatArray(Path2Bvr[])");
				METHOD_CALL_3(
					staticStatics,
					ConcatArrayEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDAPath2**)USE_COM_ARRAY(1),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 10:
				// Execute: "push NumberBvr Statics.slowInSlowOut(NumberBvr, NumberBvr, NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.slowInSlowOut(NumberBvr, NumberBvr, NumberBvr, NumberBvr)");
				METHOD_CALL_5(
					staticStatics,
					SlowInSlowOutAnim,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDANumber*)USE_COM(3),
					(IDANumber*)USE_COM(4),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 11:
				// Execute: "push NumberBvr Statics.slowInSlowOut(double, double, double, double)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.slowInSlowOut(double, double, double, double)");
				METHOD_CALL_5(
					staticStatics,
					SlowInSlowOut,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					USE_DOUBLE(3),
					USE_DOUBLE(4),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_DOUBLE(4);
				PUSH_COM(RET_COM);
				break;
				
			case 12:
				// Execute: "push Path2Bvr Statics.pie(double, double, double, double)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.pie(double, double, double, double)");
				METHOD_CALL_5(
					staticStatics,
					PieRadians,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					USE_DOUBLE(3),
					USE_DOUBLE(4),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_DOUBLE(4);
				PUSH_COM(RET_COM);
				break;
				
			case 13:
				// Execute: "push Path2Bvr Statics.pie(NumberBvr, NumberBvr, NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.pie(NumberBvr, NumberBvr, NumberBvr, NumberBvr)");
				METHOD_CALL_5(
					staticStatics,
					PieRadiansAnim,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDANumber*)USE_COM(3),
					(IDANumber*)USE_COM(4),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 14:
				// Execute: "push Path2Bvr Statics.ray(Point2Bvr)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.ray(Point2Bvr)");
				METHOD_CALL_2(
					staticStatics,
					Ray,
					(IDAPoint2*)USE_COM(1),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 15:
				// Execute: "push Transform2Bvr Statics.followPathAngleUpright(Path2Bvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.followPathAngleUpright(Path2Bvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					FollowPathAngleUprightEval,
					(IDAPath2*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 16:
				// Execute: "push Transform2Bvr Statics.followPath(Path2Bvr, double)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.followPath(Path2Bvr, double)");
				METHOD_CALL_3(
					staticStatics,
					FollowPath,
					(IDAPath2*)USE_COM(1),
					USE_DOUBLE(1),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 17:
				// Execute: "push Transform2Bvr Statics.followPath(Path2Bvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.followPath(Path2Bvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					FollowPathEval,
					(IDAPath2*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 18:
				// Execute: "push ImageBvr Statics.gradientPolygon(Point2Bvr[], ColorBvr[])"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.gradientPolygon(Point2Bvr[], ColorBvr[])");
				METHOD_CALL_5(
					staticStatics,
					GradientPolygonEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDAPoint2**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDAColor**)USE_COM_ARRAY(2),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 19:
				// Execute: "push StringBvr Statics.toBvr(java.lang.String)"
				// AUTOGENERATED
				instrTrace("push StringBvr Statics.toBvr(java.lang.String)");
				METHOD_CALL_2(
					staticStatics,
					DAString,
					USE_STRING(1),
					(IDAString**)RET_COM_ADDR
				);
				FREE_STRING;
				PUSH_COM(RET_COM);
				break;
				
			case 20:
				// Execute: "push Path2Bvr Statics.cubicBSplinePath(Point2Bvr[], NumberBvr[])"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.cubicBSplinePath(Point2Bvr[], NumberBvr[])");
				METHOD_CALL_5(
					staticStatics,
					CubicBSplinePathEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDAPoint2**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDANumber**)USE_COM_ARRAY(2),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 21:
				// Execute: "push ImageBvr Statics.stringImage(StringBvr, FontStyleBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.stringImage(StringBvr, FontStyleBvr)");
				METHOD_CALL_3(
					staticStatics,
					StringImageAnim,
					(IDAString*)USE_COM(1),
					(IDAFontStyle*)USE_COM(2),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 22:
				// Execute: "push ImageBvr Statics.stringImage(java.lang.String, FontStyleBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.stringImage(java.lang.String, FontStyleBvr)");
				METHOD_CALL_3(
					staticStatics,
					StringImage,
					USE_STRING(1),
					(IDAFontStyle*)USE_COM(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 23:
				// Execute: "push Path2Bvr Statics.pieDegrees(double, double, double, double)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.pieDegrees(double, double, double, double)");
				METHOD_CALL_5(
					staticStatics,
					PieDegrees,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					USE_DOUBLE(3),
					USE_DOUBLE(4),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_DOUBLE(4);
				PUSH_COM(RET_COM);
				break;
				
			case 24:
				// Execute: "push ImageBvr Statics.gradientHorizontal(ColorBvr, ColorBvr, double)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.gradientHorizontal(ColorBvr, ColorBvr, double)");
				METHOD_CALL_4(
					staticStatics,
					GradientHorizontal,
					(IDAColor*)USE_COM(1),
					(IDAColor*)USE_COM(2),
					USE_DOUBLE(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 25:
				// Execute: "push ImageBvr Statics.gradientHorizontal(ColorBvr, ColorBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.gradientHorizontal(ColorBvr, ColorBvr, NumberBvr)");
				METHOD_CALL_4(
					staticStatics,
					GradientHorizontalAnim,
					(IDAColor*)USE_COM(1),
					(IDAColor*)USE_COM(2),
					(IDANumber*)USE_COM(3),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 26:
				// Execute: "push ImageBvr Statics.hatchHorizontal(ColorBvr, double)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.hatchHorizontal(ColorBvr, double)");
				METHOD_CALL_3(
					staticStatics,
					HatchHorizontal,
					(IDAColor*)USE_COM(1),
					USE_DOUBLE(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 27:
				// Execute: "push ImageBvr Statics.hatchHorizontal(ColorBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.hatchHorizontal(ColorBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					HatchHorizontalAnim,
					(IDAColor*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 28:
				// Execute: "push FontStyleBvr Statics.font(StringBvr, NumberBvr, ColorBvr)"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr Statics.font(StringBvr, NumberBvr, ColorBvr)");
				METHOD_CALL_4(
					staticStatics,
					FontAnim,
					(IDAString*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDAColor*)USE_COM(3),
					(IDAFontStyle**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 29:
				// Execute: "push FontStyleBvr Statics.font(java.lang.String, double, ColorBvr)"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr Statics.font(java.lang.String, double, ColorBvr)");
				METHOD_CALL_4(
					staticStatics,
					Font,
					USE_STRING(1),
					USE_DOUBLE(1),
					(IDAColor*)USE_COM(1),
					(IDAFontStyle**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 30:
				// Execute: "push Transform3Bvr Statics.translateRate(double, double, double)"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Statics.translateRate(double, double, double)");
				METHOD_CALL_4(
					staticStatics,
					Translate3Rate,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					USE_DOUBLE(3),
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_DOUBLE(3);
				PUSH_COM(RET_COM);
				break;
				
			case 31:
				// Execute: "push Transform3Bvr Statics.scaleRate(double, double, double)"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Statics.scaleRate(double, double, double)");
				METHOD_CALL_4(
					staticStatics,
					Scale3Rate,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					USE_DOUBLE(3),
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_DOUBLE(3);
				PUSH_COM(RET_COM);
				break;
				
			case 32:
				// Execute: "push Transform3Bvr Statics.rotateRate(Vector3Bvr, double)"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Statics.rotateRate(Vector3Bvr, double)");
				METHOD_CALL_3(
					staticStatics,
					Rotate3,
					(IDAVector3*)USE_COM(1),
					USE_DOUBLE(1),
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 33:
				// Execute: "push Transform2Bvr Statics.translateRate(double, double)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.translateRate(double, double)");
				METHOD_CALL_3(
					staticStatics,
					Translate2Rate,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_DOUBLE(2);
				PUSH_COM(RET_COM);
				break;
				
			case 34:
				// Execute: "push Transform2Bvr Statics.scaleRate(double, double)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.scaleRate(double, double)");
				METHOD_CALL_3(
					staticStatics,
					Scale2Rate,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_DOUBLE(2);
				PUSH_COM(RET_COM);
				break;
				
			case 35:
				// Execute: "push Transform2Bvr Statics.rotateRate(double)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.rotateRate(double)");
				METHOD_CALL_2(
					staticStatics,
					Rotate2Rate,
					USE_DOUBLE(1),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				PUSH_COM(RET_COM);
				break;
				
			case 36:
				// Execute: "push GeometryBvr Statics.soundSource(SoundBvr)"
				// AUTOGENERATED
				instrTrace("push GeometryBvr Statics.soundSource(SoundBvr)");
				METHOD_CALL_2(
					staticStatics,
					SoundSource,
					(IDASound*)USE_COM(1),
					(IDAGeometry**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 37:
				// Execute: "push GeometryBvr Statics.spotLight(NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push GeometryBvr Statics.spotLight(NumberBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					SpotLightAnim,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDAGeometry**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 38:
				// Execute: "push GeometryBvr Statics.spotLight(NumberBvr, double)"
				// AUTOGENERATED
				instrTrace("push GeometryBvr Statics.spotLight(NumberBvr, double)");
				METHOD_CALL_3(
					staticStatics,
					SpotLight,
					(IDANumber*)USE_COM(1),
					USE_DOUBLE(1),
					(IDAGeometry**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 39:
				// Execute: "push Transform3Bvr Statics.compose3Array(Transform3Bvr[])"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Statics.compose3Array(Transform3Bvr[])");
				METHOD_CALL_3(
					staticStatics,
					Compose3ArrayEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDATransform3**)USE_COM_ARRAY(1),
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 40:
				// Execute: "push Path2Bvr Statics.concat(Path2Bvr, Path2Bvr)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.concat(Path2Bvr, Path2Bvr)");
				METHOD_CALL_3(
					staticStatics,
					Concat,
					(IDAPath2*)USE_COM(1),
					(IDAPath2*)USE_COM(2),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 41:
				// Execute: "push MontageBvr Statics.imageMontage(ImageBvr, double)"
				// AUTOGENERATED
				instrTrace("push MontageBvr Statics.imageMontage(ImageBvr, double)");
				METHOD_CALL_3(
					staticStatics,
					ImageMontage,
					(IDAImage*)USE_COM(1),
					USE_DOUBLE(1),
					(IDAMontage**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 42:
				// Execute: "push MontageBvr Statics.imageMontage(ImageBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push MontageBvr Statics.imageMontage(ImageBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					ImageMontageAnim,
					(IDAImage*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDAMontage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 43:
				// Execute: "push ImageBvr ImageBvr.clip(MatteBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr ImageBvr.clip(MatteBvr)");
				METHOD_CALL_2(
					(IDAImage*)USE_COM(1),
					Clip,
					(IDAMatte*)USE_COM(2),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 44:
				// Execute: "push NumberBvr Statics.distanceSquared(Point2Bvr, Point2Bvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.distanceSquared(Point2Bvr, Point2Bvr)");
				METHOD_CALL_3(
					staticStatics,
					DistanceSquaredPoint2,
					(IDAPoint2*)USE_COM(1),
					(IDAPoint2*)USE_COM(2),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 45:
				// Execute: "push NumberBvr Statics.distanceSquared(Point3Bvr, Point3Bvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.distanceSquared(Point3Bvr, Point3Bvr)");
				METHOD_CALL_3(
					staticStatics,
					DistanceSquaredPoint3,
					(IDAPoint3*)USE_COM(1),
					(IDAPoint3*)USE_COM(2),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 46:
				// Execute: "push Transform3Bvr Statics.xShearRate(double, double)"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Statics.xShearRate(double, double)");
				METHOD_CALL_3(
					staticStatics,
					XShear3Rate,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_DOUBLE(2);
				PUSH_COM(RET_COM);
				break;
				
			case 47:
				// Execute: "push Transform3Bvr Statics.zShearRate(double, double)"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Statics.zShearRate(double, double)");
				METHOD_CALL_3(
					staticStatics,
					ZShear3Rate,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_DOUBLE(2);
				PUSH_COM(RET_COM);
				break;
				
			case 48:
				// Execute: "push Transform2Bvr Statics.xShearRate(double)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.xShearRate(double)");
				METHOD_CALL_2(
					staticStatics,
					XShear2Rate,
					USE_DOUBLE(1),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				PUSH_COM(RET_COM);
				break;
				
			case 49:
				// Execute: "push BooleanBvr Statics.eq(NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push BooleanBvr Statics.eq(NumberBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					EQ,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDABoolean**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 50:
				// Execute: "push Transform3Bvr Statics.rotateDegrees(Vector3Bvr, double)"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Statics.rotateDegrees(Vector3Bvr, double)");
				METHOD_CALL_3(
					staticStatics,
					Rotate3Degrees,
					(IDAVector3*)USE_COM(1),
					USE_DOUBLE(1),
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 51:
				// Execute: "push Transform3Bvr Statics.rotateRateDegrees(Vector3Bvr, double)"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Statics.rotateRateDegrees(Vector3Bvr, double)");
				METHOD_CALL_3(
					staticStatics,
					Rotate3RateDegrees,
					(IDAVector3*)USE_COM(1),
					USE_DOUBLE(1),
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 52:
				// Execute: "push Transform2Bvr Statics.rotateDegrees(double)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.rotateDegrees(double)");
				METHOD_CALL_2(
					staticStatics,
					Rotate2Degrees,
					USE_DOUBLE(1),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				PUSH_COM(RET_COM);
				break;
				
			case 53:
				// Execute: "push Transform2Bvr Statics.rotateRateDegrees(double)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.rotateRateDegrees(double)");
				METHOD_CALL_2(
					staticStatics,
					Rotate2RateDegrees,
					USE_DOUBLE(1),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				PUSH_COM(RET_COM);
				break;
				
			case 54:
				// Execute: "push Path2Bvr Statics.rect(double, double)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.rect(double, double)");
				METHOD_CALL_3(
					staticStatics,
					Rect,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_DOUBLE(2);
				PUSH_COM(RET_COM);
				break;
				
			case 55:
				// Execute: "push Path2Bvr Statics.rect(NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.rect(NumberBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					RectAnim,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 56:
				// Execute: "push ImageBvr Statics.radialGradientRegularPoly(ColorBvr, ColorBvr, double, double)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.radialGradientRegularPoly(ColorBvr, ColorBvr, double, double)");
				METHOD_CALL_5(
					staticStatics,
					RadialGradientRegularPoly,
					(IDAColor*)USE_COM(1),
					(IDAColor*)USE_COM(2),
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_DOUBLE(2);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 57:
				// Execute: "push ImageBvr Statics.radialGradientRegularPoly(ColorBvr, ColorBvr, NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.radialGradientRegularPoly(ColorBvr, ColorBvr, NumberBvr, NumberBvr)");
				METHOD_CALL_5(
					staticStatics,
					RadialGradientRegularPolyAnim,
					(IDAColor*)USE_COM(1),
					(IDAColor*)USE_COM(2),
					(IDANumber*)USE_COM(3),
					(IDANumber*)USE_COM(4),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 58:
				// Execute: "push MatteBvr Statics.intersect(MatteBvr, MatteBvr)"
				// AUTOGENERATED
				instrTrace("push MatteBvr Statics.intersect(MatteBvr, MatteBvr)");
				METHOD_CALL_3(
					staticStatics,
					IntersectMatte,
					(IDAMatte*)USE_COM(1),
					(IDAMatte*)USE_COM(2),
					(IDAMatte**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 59:
				// Execute: "push Path2Bvr Statics.roundRect(double, double, double, double)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.roundRect(double, double, double, double)");
				METHOD_CALL_5(
					staticStatics,
					RoundRect,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					USE_DOUBLE(3),
					USE_DOUBLE(4),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_DOUBLE(4);
				PUSH_COM(RET_COM);
				break;
				
			case 60:
				// Execute: "push Path2Bvr Statics.roundRect(NumberBvr, NumberBvr, NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.roundRect(NumberBvr, NumberBvr, NumberBvr, NumberBvr)");
				METHOD_CALL_5(
					staticStatics,
					RoundRectAnim,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDANumber*)USE_COM(3),
					(IDANumber*)USE_COM(4),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 61:
				// Execute: "push Transform2Bvr Statics.followPathAngle(Path2Bvr, double)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.followPathAngle(Path2Bvr, double)");
				METHOD_CALL_3(
					staticStatics,
					FollowPathAngle,
					(IDAPath2*)USE_COM(1),
					USE_DOUBLE(1),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 62:
				// Execute: "push MatteBvr Statics.textMatte(StringBvr, FontStyleBvr)"
				// AUTOGENERATED
				instrTrace("push MatteBvr Statics.textMatte(StringBvr, FontStyleBvr)");
				METHOD_CALL_3(
					staticStatics,
					TextMatte,
					(IDAString*)USE_COM(1),
					(IDAFontStyle*)USE_COM(2),
					(IDAMatte**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 63:
				// Execute: "push Path2Bvr Statics.stringPath(StringBvr, FontStyleBvr)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.stringPath(StringBvr, FontStyleBvr)");
				METHOD_CALL_3(
					staticStatics,
					StringPathAnim,
					(IDAString*)USE_COM(1),
					(IDAFontStyle*)USE_COM(2),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 64:
				// Execute: "push Path2Bvr Statics.stringPath(java.lang.String, FontStyleBvr)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.stringPath(java.lang.String, FontStyleBvr)");
				METHOD_CALL_3(
					staticStatics,
					StringPath,
					USE_STRING(1),
					(IDAFontStyle*)USE_COM(1),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 65:
				// Execute: "push NumberBvr Statics.interpolate(NumberBvr, NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.interpolate(NumberBvr, NumberBvr, NumberBvr)");
				METHOD_CALL_4(
					staticStatics,
					InterpolateAnim,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDANumber*)USE_COM(3),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 66:
				// Execute: "push NumberBvr Statics.interpolate(double, double, double)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.interpolate(double, double, double)");
				METHOD_CALL_4(
					staticStatics,
					Interpolate,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					USE_DOUBLE(3),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_DOUBLE(3);
				PUSH_COM(RET_COM);
				break;
				
			case 67:
				// Execute: "push NumberBvr Statics.atan2(NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.atan2(NumberBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					Atan2,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 68:
				// Execute: "push ImageBvr ImageBvr.tile()"
				// AUTOGENERATED
				instrTrace("push ImageBvr ImageBvr.tile()");
				METHOD_CALL_1(
					(IDAImage*)USE_COM(1),
					Tile,
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 69:
				// Execute: "push Transform3Bvr Statics.transform4x4(NumberBvr[])"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Statics.transform4x4(NumberBvr[])");
				METHOD_CALL_3(
					staticStatics,
					Transform4x4AnimEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 70:
				// Execute: "push NumberBvr Statics.log10(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.log10(NumberBvr)");
				METHOD_CALL_2(
					staticStatics,
					Log10,
					(IDANumber*)USE_COM(1),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 71:
				// Execute: "push Vector3Bvr Statics.vector3Spherical(NumberBvr, NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Vector3Bvr Statics.vector3Spherical(NumberBvr, NumberBvr, NumberBvr)");
				METHOD_CALL_4(
					staticStatics,
					Vector3SphericalAnim,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDANumber*)USE_COM(3),
					(IDAVector3**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 72:
				// Execute: "push Vector3Bvr Statics.vector3Spherical(double, double, double)"
				// AUTOGENERATED
				instrTrace("push Vector3Bvr Statics.vector3Spherical(double, double, double)");
				METHOD_CALL_4(
					staticStatics,
					Vector3Spherical,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					USE_DOUBLE(3),
					(IDAVector3**)RET_COM_ADDR
				);
				FREE_DOUBLE(3);
				PUSH_COM(RET_COM);
				break;
				
			case 73:
				// Execute: "push ImageBvr Statics.gradientSquare(ColorBvr, ColorBvr, ColorBvr, ColorBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.gradientSquare(ColorBvr, ColorBvr, ColorBvr, ColorBvr)");
				METHOD_CALL_5(
					staticStatics,
					GradientSquare,
					(IDAColor*)USE_COM(1),
					(IDAColor*)USE_COM(2),
					(IDAColor*)USE_COM(3),
					(IDAColor*)USE_COM(4),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 74:
				// Execute: "push ImageBvr Statics.radialGradientSquare(ColorBvr, ColorBvr, double)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.radialGradientSquare(ColorBvr, ColorBvr, double)");
				METHOD_CALL_4(
					staticStatics,
					RadialGradientSquare,
					(IDAColor*)USE_COM(1),
					(IDAColor*)USE_COM(2),
					USE_DOUBLE(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 75:
				// Execute: "push ImageBvr Statics.radialGradientSquare(ColorBvr, ColorBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.radialGradientSquare(ColorBvr, ColorBvr, NumberBvr)");
				METHOD_CALL_4(
					staticStatics,
					RadialGradientSquareAnim,
					(IDAColor*)USE_COM(1),
					(IDAColor*)USE_COM(2),
					(IDANumber*)USE_COM(3),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 76:
				// Execute: "push Transform2Bvr Statics.followPathAngle(Path2Bvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.followPathAngle(Path2Bvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					FollowPathAngleEval,
					(IDAPath2*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 77:
				// Execute: "push ImageBvr Statics.overlayArray(ImageBvr[])"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.overlayArray(ImageBvr[])");
				METHOD_CALL_3(
					staticStatics,
					OverlayArrayEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDAImage**)USE_COM_ARRAY(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 78:
				// Execute: "push SoundBvr Statics.mixArray(SoundBvr[])"
				// AUTOGENERATED
				instrTrace("push SoundBvr Statics.mixArray(SoundBvr[])");
				METHOD_CALL_3(
					staticStatics,
					MixArrayEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDASound**)USE_COM_ARRAY(1),
					(IDASound**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 79:
				// Execute: "push NumberBvr Statics.pow(NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.pow(NumberBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					Pow,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 80:
				// Execute: "push NumberBvr Statics.seededRandom(double)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.seededRandom(double)");
				METHOD_CALL_2(
					staticStatics,
					SeededRandom,
					USE_DOUBLE(1),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				PUSH_COM(RET_COM);
				break;
				
			case 81:
				// Execute: "push Transform3Bvr Statics.lookAtFrom(Point3Bvr, Point3Bvr, Vector3Bvr)"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Statics.lookAtFrom(Point3Bvr, Point3Bvr, Vector3Bvr)");
				METHOD_CALL_4(
					staticStatics,
					LookAtFrom,
					(IDAPoint3*)USE_COM(1),
					(IDAPoint3*)USE_COM(2),
					(IDAVector3*)USE_COM(3),
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 82:
				// Execute: "push NumberBvr Statics.asin(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.asin(NumberBvr)");
				METHOD_CALL_2(
					staticStatics,
					Asin,
					(IDANumber*)USE_COM(1),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 83:
				// Execute: "push NumberBvr Statics.integral(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.integral(NumberBvr)");
				METHOD_CALL_2(
					staticStatics,
					Integral,
					(IDANumber*)USE_COM(1),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 84:
				// Execute: "push Vector2Bvr Statics.integral(Vector2Bvr)"
				// AUTOGENERATED
				instrTrace("push Vector2Bvr Statics.integral(Vector2Bvr)");
				METHOD_CALL_2(
					staticStatics,
					IntegralVector2,
					(IDAVector2*)USE_COM(1),
					(IDAVector2**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 85:
				// Execute: "push Vector3Bvr Statics.integral(Vector3Bvr)"
				// AUTOGENERATED
				instrTrace("push Vector3Bvr Statics.integral(Vector3Bvr)");
				METHOD_CALL_2(
					staticStatics,
					IntegralVector3,
					(IDAVector3*)USE_COM(1),
					(IDAVector3**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 86:
				// Execute: "push StringBvr Statics.concat(StringBvr, StringBvr)"
				// AUTOGENERATED
				instrTrace("push StringBvr Statics.concat(StringBvr, StringBvr)");
				METHOD_CALL_3(
					staticStatics,
					ConcatString,
					(IDAString*)USE_COM(1),
					(IDAString*)USE_COM(2),
					(IDAString**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 87:
				// Execute: "push Transform3Bvr Statics.scale3Rate(double)"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Statics.scale3Rate(double)");
				METHOD_CALL_2(
					staticStatics,
					Scale3UniformRate,
					USE_DOUBLE(1),
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				PUSH_COM(RET_COM);
				break;
				
			case 88:
				// Execute: "push Transform3Bvr Statics.yShearRate(double, double)"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Statics.yShearRate(double, double)");
				METHOD_CALL_3(
					staticStatics,
					YShear3Rate,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_DOUBLE(2);
				PUSH_COM(RET_COM);
				break;
				
			case 89:
				// Execute: "push Transform2Bvr Statics.yShearRate(double)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.yShearRate(double)");
				METHOD_CALL_2(
					staticStatics,
					YShear2Rate,
					USE_DOUBLE(1),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				PUSH_COM(RET_COM);
				break;
				
			case 90:
				// Execute: "push MatteBvr Statics.difference(MatteBvr, MatteBvr)"
				// AUTOGENERATED
				instrTrace("push MatteBvr Statics.difference(MatteBvr, MatteBvr)");
				METHOD_CALL_3(
					staticStatics,
					DifferenceMatte,
					(IDAMatte*)USE_COM(1),
					(IDAMatte*)USE_COM(2),
					(IDAMatte**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 91:
				// Execute: "push Transform2Bvr Statics.transform3x2(NumberBvr[])"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.transform3x2(NumberBvr[])");
				METHOD_CALL_3(
					staticStatics,
					Transform3x2AnimEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 92:
				// Execute: "push Path2Bvr Statics.polyline(Point2Bvr[])"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.polyline(Point2Bvr[])");
				METHOD_CALL_3(
					staticStatics,
					PolylineEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDAPoint2**)USE_COM_ARRAY(1),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 93:
				// Execute: "push ImageBvr Statics.hatchVertical(ColorBvr, double)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.hatchVertical(ColorBvr, double)");
				METHOD_CALL_3(
					staticStatics,
					HatchVertical,
					(IDAColor*)USE_COM(1),
					USE_DOUBLE(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 94:
				// Execute: "push ImageBvr Statics.hatchVertical(ColorBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.hatchVertical(ColorBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					HatchVerticalAnim,
					(IDAColor*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 95:
				// Execute: "push Point3Bvr Statics.point3Spherical(NumberBvr, NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Point3Bvr Statics.point3Spherical(NumberBvr, NumberBvr, NumberBvr)");
				METHOD_CALL_4(
					staticStatics,
					Point3SphericalAnim,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDANumber*)USE_COM(3),
					(IDAPoint3**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 96:
				// Execute: "push Point3Bvr Statics.point3Spherical(double, double, double)"
				// AUTOGENERATED
				instrTrace("push Point3Bvr Statics.point3Spherical(double, double, double)");
				METHOD_CALL_4(
					staticStatics,
					Point3Spherical,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					USE_DOUBLE(3),
					(IDAPoint3**)RET_COM_ADDR
				);
				FREE_DOUBLE(3);
				PUSH_COM(RET_COM);
				break;
				
			case 97:
				// Execute: "push BooleanBvr Statics.gt(NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push BooleanBvr Statics.gt(NumberBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					GT,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDABoolean**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 98:
				// Execute: "push ImageBvr Statics.hatchForwardDiagonal(ColorBvr, double)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.hatchForwardDiagonal(ColorBvr, double)");
				METHOD_CALL_3(
					staticStatics,
					HatchForwardDiagonal,
					(IDAColor*)USE_COM(1),
					USE_DOUBLE(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 99:
				// Execute: "push ImageBvr Statics.hatchForwardDiagonal(ColorBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.hatchForwardDiagonal(ColorBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					HatchForwardDiagonalAnim,
					(IDAColor*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 100:
				// Execute: "push ImageBvr Statics.hatchBackwardDiagonal(ColorBvr, double)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.hatchBackwardDiagonal(ColorBvr, double)");
				METHOD_CALL_3(
					staticStatics,
					HatchBackwardDiagonal,
					(IDAColor*)USE_COM(1),
					USE_DOUBLE(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 101:
				// Execute: "push ImageBvr Statics.hatchBackwardDiagonal(ColorBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.hatchBackwardDiagonal(ColorBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					HatchBackwardDiagonalAnim,
					(IDAColor*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 102:
				// Execute: "push NumberBvr Statics.atan(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.atan(NumberBvr)");
				METHOD_CALL_2(
					staticStatics,
					Atan,
					(IDANumber*)USE_COM(1),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 103:
				// Execute: "push Vector2Bvr Statics.vector2Polar(NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Vector2Bvr Statics.vector2Polar(NumberBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					Vector2PolarAnim,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDAVector2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 104:
				// Execute: "push Vector2Bvr Statics.vector2Polar(double, double)"
				// AUTOGENERATED
				instrTrace("push Vector2Bvr Statics.vector2Polar(double, double)");
				METHOD_CALL_3(
					staticStatics,
					Vector2Polar,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					(IDAVector2**)RET_COM_ADDR
				);
				FREE_DOUBLE(2);
				PUSH_COM(RET_COM);
				break;
				
			case 105:
				// Execute: "push ImageBvr Statics.hatchCross(ColorBvr, double)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.hatchCross(ColorBvr, double)");
				METHOD_CALL_3(
					staticStatics,
					HatchCross,
					(IDAColor*)USE_COM(1),
					USE_DOUBLE(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 106:
				// Execute: "push ImageBvr Statics.hatchCross(ColorBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.hatchCross(ColorBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					HatchCrossAnim,
					(IDAColor*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 107:
				// Execute: "push ImageBvr Statics.hatchDiagonalCross(ColorBvr, double)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.hatchDiagonalCross(ColorBvr, double)");
				METHOD_CALL_3(
					staticStatics,
					HatchDiagonalCross,
					(IDAColor*)USE_COM(1),
					USE_DOUBLE(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 108:
				// Execute: "push ImageBvr Statics.hatchDiagonalCross(ColorBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.hatchDiagonalCross(ColorBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					HatchDiagonalCrossAnim,
					(IDAColor*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 109:
				// Execute: "push NumberBvr Statics.acos(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.acos(NumberBvr)");
				METHOD_CALL_2(
					staticStatics,
					Acos,
					(IDANumber*)USE_COM(1),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 110:
				// Execute: "push Transform2Bvr Statics.scale2Rate(double)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.scale2Rate(double)");
				METHOD_CALL_2(
					staticStatics,
					Scale2UniformRate,
					USE_DOUBLE(1),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				PUSH_COM(RET_COM);
				break;
				
			case 111:
				// Execute: "push BooleanBvr Statics.ne(NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push BooleanBvr Statics.ne(NumberBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					NE,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDABoolean**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 112:
				// Execute: "push BooleanBvr Statics.lte(NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push BooleanBvr Statics.lte(NumberBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					LTE,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDABoolean**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 113:
				// Execute: "push NumberBvr Statics.tan(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.tan(NumberBvr)");
				METHOD_CALL_2(
					staticStatics,
					Tan,
					(IDANumber*)USE_COM(1),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 114:
				// Execute: "push Path2Bvr Statics.oval(double, double)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.oval(double, double)");
				METHOD_CALL_3(
					staticStatics,
					Oval,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_DOUBLE(2);
				PUSH_COM(RET_COM);
				break;
				
			case 115:
				// Execute: "push Path2Bvr Statics.oval(NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.oval(NumberBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					OvalAnim,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 116:
				// Execute: "push Point2Bvr Statics.point2Polar(NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Point2Bvr Statics.point2Polar(NumberBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					Point2PolarAnim,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDAPoint2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 117:
				// Execute: "push Point2Bvr Statics.point2Polar(double, double)"
				// AUTOGENERATED
				instrTrace("push Point2Bvr Statics.point2Polar(double, double)");
				METHOD_CALL_3(
					staticStatics,
					Point2Polar,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					(IDAPoint2**)RET_COM_ADDR
				);
				FREE_DOUBLE(2);
				PUSH_COM(RET_COM);
				break;
				
			case 118:
				// Execute: "push Vector2Bvr Statics.derivative(Vector2Bvr)"
				// AUTOGENERATED
				instrTrace("push Vector2Bvr Statics.derivative(Vector2Bvr)");
				METHOD_CALL_2(
					staticStatics,
					DerivativeVector2,
					(IDAVector2*)USE_COM(1),
					(IDAVector2**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 119:
				// Execute: "push Vector3Bvr Statics.derivative(Vector3Bvr)"
				// AUTOGENERATED
				instrTrace("push Vector3Bvr Statics.derivative(Vector3Bvr)");
				METHOD_CALL_2(
					staticStatics,
					DerivativeVector3,
					(IDAVector3*)USE_COM(1),
					(IDAVector3**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 120:
				// Execute: "push Vector2Bvr Statics.derivative(Point2Bvr)"
				// AUTOGENERATED
				instrTrace("push Vector2Bvr Statics.derivative(Point2Bvr)");
				METHOD_CALL_2(
					staticStatics,
					DerivativePoint2,
					(IDAPoint2*)USE_COM(1),
					(IDAVector2**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 121:
				// Execute: "push Vector3Bvr Statics.derivative(Point3Bvr)"
				// AUTOGENERATED
				instrTrace("push Vector3Bvr Statics.derivative(Point3Bvr)");
				METHOD_CALL_2(
					staticStatics,
					DerivativePoint3,
					(IDAPoint3*)USE_COM(1),
					(IDAVector3**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 122:
				// Execute: "push NumberBvr Statics.derivative(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.derivative(NumberBvr)");
				METHOD_CALL_2(
					staticStatics,
					Derivative,
					(IDANumber*)USE_COM(1),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 123:
				// Execute: "push ImageBvr Statics.radialGradientPolygon(ColorBvr, ColorBvr, Point2Bvr[], double)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.radialGradientPolygon(ColorBvr, ColorBvr, Point2Bvr[], double)");
				METHOD_CALL_6(
					staticStatics,
					RadialGradientPolygonEx,
					(IDAColor*)USE_COM(1),
					(IDAColor*)USE_COM(2),
					USE_COM_ARRAY_LENGTH(1),
					(IDAPoint2**)USE_COM_ARRAY(1),
					USE_DOUBLE(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				FREE_COM;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 124:
				// Execute: "push ImageBvr Statics.radialGradientPolygon(ColorBvr, ColorBvr, Point2Bvr[], NumberBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.radialGradientPolygon(ColorBvr, ColorBvr, Point2Bvr[], NumberBvr)");
				METHOD_CALL_6(
					staticStatics,
					RadialGradientPolygonAnimEx,
					(IDAColor*)USE_COM(1),
					(IDAColor*)USE_COM(2),
					USE_COM_ARRAY_LENGTH(1),
					(IDAPoint2**)USE_COM_ARRAY(1),
					(IDANumber*)USE_COM(3),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 125:
				// Execute: "push NumberBvr Statics.exp(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.exp(NumberBvr)");
				METHOD_CALL_2(
					staticStatics,
					Exp,
					(IDANumber*)USE_COM(1),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 126:
				// Execute: "push CameraBvr Statics.perspectiveCamera(double, double)"
				// AUTOGENERATED
				instrTrace("push CameraBvr Statics.perspectiveCamera(double, double)");
				METHOD_CALL_3(
					staticStatics,
					PerspectiveCamera,
					USE_DOUBLE(1),
					USE_DOUBLE(2),
					(IDACamera**)RET_COM_ADDR
				);
				FREE_DOUBLE(2);
				PUSH_COM(RET_COM);
				break;
				
			case 127:
				// Execute: "push CameraBvr Statics.perspectiveCamera(NumberBvr, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push CameraBvr Statics.perspectiveCamera(NumberBvr, NumberBvr)");
				METHOD_CALL_3(
					staticStatics,
					PerspectiveCameraAnim,
					(IDANumber*)USE_COM(1),
					(IDANumber*)USE_COM(2),
					(IDACamera**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 128:
				// Execute: "push CameraBvr Statics.parallelCamera(double)"
				// AUTOGENERATED
				instrTrace("push CameraBvr Statics.parallelCamera(double)");
				METHOD_CALL_2(
					staticStatics,
					ParallelCamera,
					USE_DOUBLE(1),
					(IDACamera**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				PUSH_COM(RET_COM);
				break;
				
			case 129:
				// Execute: "push CameraBvr Statics.parallelCamera(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push CameraBvr Statics.parallelCamera(NumberBvr)");
				METHOD_CALL_2(
					staticStatics,
					ParallelCameraAnim,
					(IDANumber*)USE_COM(1),
					(IDACamera**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 130:
				// Execute: "push Transform2Bvr Statics.followPathAngleUpright(Path2Bvr, double)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.followPathAngleUpright(Path2Bvr, double)");
				METHOD_CALL_3(
					staticStatics,
					FollowPathAngleUpright,
					(IDAPath2*)USE_COM(1),
					USE_DOUBLE(1),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 131:
				// Execute: "push GeometryBvr Statics.importGeometry(java.lang.String)"
				// AUTOGENERATED
				instrTrace("push GeometryBvr Statics.importGeometry(java.lang.String)");
				IMPORT_METHOD_CALL_2(
					staticStatics,
					ImportGeometry,
					USE_STRING(1),
					(IDAGeometry**)RET_COM_ADDR
				);
				FREE_STRING;
				PUSH_COM(RET_COM);
				break;
				
			case 132:
				// Execute: "push Behavior Statics.modifiableBehavior(Behavior)"
				// AUTOGENERATED
				instrTrace("push Behavior Statics.modifiableBehavior(Behavior)");
				METHOD_CALL_2(
					staticStatics,
					ModifiableBehavior,
					(IDABehavior*)USE_COM(1),
					(IDABehavior**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 133:
				// Execute: "call Behavior.switchTo(Behavior)"
				// AUTOGENERATED
				instrTrace("call Behavior.switchTo(Behavior)");
				METHOD_CALL_1(
					(IDABehavior*)USE_COM(1),
					SwitchTo,
					(IDABehavior*)USE_COM(2)
				);
				FREE_COM;
				FREE_COM;
				break;
				
			case 134:
				// Execute: "call Behavior.switchTo(double)"
				// AUTOGENERATED
				instrTrace("call Behavior.switchTo(double)");
				METHOD_CALL_1(
					(IDABehavior*)USE_COM(1),
					SwitchToNumber,
					USE_DOUBLE(1)
				);
				FREE_DOUBLE(1);
				FREE_COM;
				break;
				
			case 135:
				// Execute: "call Behavior.switchTo(java.lang.String)"
				// AUTOGENERATED
				instrTrace("call Behavior.switchTo(java.lang.String)");
				METHOD_CALL_1(
					(IDABehavior*)USE_COM(1),
					SwitchToString,
					USE_STRING(1)
				);
				FREE_STRING;
				FREE_COM;
				break;
				
			case 136:
				// Execute: "push Behavior Behavior.repeat(int)"
				// AUTOGENERATED
				instrTrace("push Behavior Behavior.repeat(int)");
				METHOD_CALL_2(
					(IDABehavior*)USE_COM(1),
					Repeat,
					USE_LONG(1),
					(IDABehavior**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 137:
				// Execute: "push Behavior Behavior.repeatForever()"
				// AUTOGENERATED
				instrTrace("push Behavior Behavior.repeatForever()");
				METHOD_CALL_1(
					(IDABehavior*)USE_COM(1),
					RepeatForever,
					(IDABehavior**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 138:
				// Execute: "push Behavior Behavior.importance(double)"
				// AUTOGENERATED
				instrTrace("push Behavior Behavior.importance(double)");
				METHOD_CALL_2(
					(IDABehavior*)USE_COM(1),
					Importance,
					USE_DOUBLE(1),
					(IDABehavior**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 139:
				// Execute: "push Behavior Behavior.runOnce()"
				// AUTOGENERATED
				instrTrace("push Behavior Behavior.runOnce()");
				METHOD_CALL_1(
					(IDABehavior*)USE_COM(1),
					RunOnce,
					(IDABehavior**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 140:
				// Execute: "push TupleBvr Statics.tuple(Behavior[])"
				// AUTOGENERATED
				instrTrace("push TupleBvr Statics.tuple(Behavior[])");
				METHOD_CALL_3(
					staticStatics,
					DATupleEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDABehavior**)USE_COM_ARRAY(1),
					(IDATuple**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 141:
				// Execute: "push TupleBvr Statics.uninitializedTuple(TupleBvr)"
				// AUTOGENERATED
				instrTrace("push TupleBvr Statics.uninitializedTuple(TupleBvr)");
				METHOD_CALL_2(
					staticStatics,
					UninitializedTuple,
					(IDATuple*)USE_COM(1),
					(IDATuple**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 142:
				// Execute: "push ArrayBvr Statics.array(Behavior[])"
				// AUTOGENERATED
				instrTrace("push ArrayBvr Statics.array(Behavior[])");
				METHOD_CALL_3(
					staticStatics,
					DAArrayEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDABehavior**)USE_COM_ARRAY(1),
					(IDAArray**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 143:
				// Execute: "push ArrayBvr Statics.uninitializedArray(ArrayBvr)"
				// AUTOGENERATED
				instrTrace("push ArrayBvr Statics.uninitializedArray(ArrayBvr)");
				METHOD_CALL_2(
					staticStatics,
					UninitializedArray,
					(IDAArray*)USE_COM(1),
					(IDAArray**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 144:
				// Execute: "push DXMEvent DXMEvent.attachData(Behavior)"
				// AUTOGENERATED
				instrTrace("push DXMEvent DXMEvent.attachData(Behavior)");
				METHOD_CALL_2(
					(IDAEvent*)USE_COM(1),
					AttachData,
					(IDABehavior*)USE_COM(2),
					(IDAEvent**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 145:
				// Execute: "push DXMEvent DXMEvent.scriptCallback(java.lang.String, java.lang.String)"
				// AUTOGENERATED
				instrTrace("push DXMEvent DXMEvent.scriptCallback(java.lang.String, java.lang.String)");
				METHOD_CALL_3(
					(IDAEvent*)USE_COM(1),
					ScriptCallback,
					USE_STRING(1),
					USE_STRING(2),
					(IDAEvent**)RET_COM_ADDR
				);
				FREE_STRING;
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 146:
				// Execute: "push LineStyleBvr LineStyleBvr.join(JoinStyleBvr)"
				// AUTOGENERATED
				instrTrace("push LineStyleBvr LineStyleBvr.join(JoinStyleBvr)");
				METHOD_CALL_2(
					(IDALineStyle*)USE_COM(1),
					Join,
					(IDAJoinStyle*)USE_COM(2),
					(IDALineStyle**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 147:
				// Execute: "push LineStyleBvr LineStyleBvr.end(EndStyleBvr)"
				// AUTOGENERATED
				instrTrace("push LineStyleBvr LineStyleBvr.end(EndStyleBvr)");
				METHOD_CALL_2(
					(IDALineStyle*)USE_COM(1),
					End,
					(IDAEndStyle*)USE_COM(2),
					(IDALineStyle**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 148:
				// Execute: "push LineStyleBvr LineStyleBvr.detail()"
				// AUTOGENERATED
				instrTrace("push LineStyleBvr LineStyleBvr.detail()");
				METHOD_CALL_1(
					(IDALineStyle*)USE_COM(1),
					Detail,
					(IDALineStyle**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 149:
				// Execute: "push LineStyleBvr LineStyleBvr.color(ColorBvr)"
				// AUTOGENERATED
				instrTrace("push LineStyleBvr LineStyleBvr.color(ColorBvr)");
				METHOD_CALL_2(
					(IDALineStyle*)USE_COM(1),
					Color,
					(IDAColor*)USE_COM(2),
					(IDALineStyle**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 150:
				// Execute: "push LineStyleBvr LineStyleBvr.width(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push LineStyleBvr LineStyleBvr.width(NumberBvr)");
				METHOD_CALL_2(
					(IDALineStyle*)USE_COM(1),
					WidthAnim,
					(IDANumber*)USE_COM(2),
					(IDALineStyle**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 151:
				// Execute: "push LineStyleBvr LineStyleBvr.width(double)"
				// AUTOGENERATED
				instrTrace("push LineStyleBvr LineStyleBvr.width(double)");
				METHOD_CALL_2(
					(IDALineStyle*)USE_COM(1),
					width,
					USE_DOUBLE(1),
					(IDALineStyle**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 152:
				// Execute: "push LineStyleBvr LineStyleBvr.dash(DashStyleBvr)"
				// AUTOGENERATED
				instrTrace("push LineStyleBvr LineStyleBvr.dash(DashStyleBvr)");
				METHOD_CALL_2(
					(IDALineStyle*)USE_COM(1),
					Dash,
					(IDADashStyle*)USE_COM(2),
					(IDALineStyle**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 153:
				// Execute: "push LineStyleBvr LineStyleBvr.lineAntialiasing(double)"
				// AUTOGENERATED
				instrTrace("push LineStyleBvr LineStyleBvr.lineAntialiasing(double)");
				METHOD_CALL_2(
					(IDALineStyle*)USE_COM(1),
					AntiAliasing,
					USE_DOUBLE(1),
					(IDALineStyle**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 154:
				// Execute: "push FontStyleBvr FontStyleBvr.family(StringBvr)"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr FontStyleBvr.family(StringBvr)");
				METHOD_CALL_2(
					(IDAFontStyle*)USE_COM(1),
					FamilyAnim,
					(IDAString*)USE_COM(2),
					(IDAFontStyle**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 155:
				// Execute: "push FontStyleBvr FontStyleBvr.family(java.lang.String)"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr FontStyleBvr.family(java.lang.String)");
				METHOD_CALL_2(
					(IDAFontStyle*)USE_COM(1),
					Family,
					USE_STRING(1),
					(IDAFontStyle**)RET_COM_ADDR
				);
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 156:
				// Execute: "push FontStyleBvr FontStyleBvr.textAntialiasing(double)"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr FontStyleBvr.textAntialiasing(double)");
				METHOD_CALL_2(
					(IDAFontStyle*)USE_COM(1),
					AntiAliasing,
					USE_DOUBLE(1),
					(IDAFontStyle**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 157:
				// Execute: "push FontStyleBvr FontStyleBvr.weight(double)"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr FontStyleBvr.weight(double)");
				METHOD_CALL_2(
					(IDAFontStyle*)USE_COM(1),
					Weight,
					USE_DOUBLE(1),
					(IDAFontStyle**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 158:
				// Execute: "push FontStyleBvr FontStyleBvr.weight(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr FontStyleBvr.weight(NumberBvr)");
				METHOD_CALL_2(
					(IDAFontStyle*)USE_COM(1),
					WeightAnim,
					(IDANumber*)USE_COM(2),
					(IDAFontStyle**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 159:
				// Execute: "push FontStyleBvr FontStyleBvr.underline()"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr FontStyleBvr.underline()");
				METHOD_CALL_1(
					(IDAFontStyle*)USE_COM(1),
					Underline,
					(IDAFontStyle**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 160:
				// Execute: "push FontStyleBvr FontStyleBvr.strikethrough()"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr FontStyleBvr.strikethrough()");
				METHOD_CALL_1(
					(IDAFontStyle*)USE_COM(1),
					Strikethrough,
					(IDAFontStyle**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 161:
				// Execute: "push NumberBvr Vector3Bvr.getSphericalCoordLength()"
				// AUTOGENERATED
				instrTrace("push NumberBvr Vector3Bvr.getSphericalCoordLength()");
				METHOD_CALL_1(
					(IDAVector3*)USE_COM(1),
					get_SphericalCoordLength,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 162:
				// Execute: "push NumberBvr Vector3Bvr.getSphericalCoordXYAngle()"
				// AUTOGENERATED
				instrTrace("push NumberBvr Vector3Bvr.getSphericalCoordXYAngle()");
				METHOD_CALL_1(
					(IDAVector3*)USE_COM(1),
					get_SphericalCoordXYAngle,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 163:
				// Execute: "push NumberBvr Vector3Bvr.getSphericalCoordYZAngle()"
				// AUTOGENERATED
				instrTrace("push NumberBvr Vector3Bvr.getSphericalCoordYZAngle()");
				METHOD_CALL_1(
					(IDAVector3*)USE_COM(1),
					get_SphericalCoordYZAngle,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 164:
				// Execute: "push NumberBvr Vector2Bvr.getPolarCoordAngle()"
				// AUTOGENERATED
				instrTrace("push NumberBvr Vector2Bvr.getPolarCoordAngle()");
				METHOD_CALL_1(
					(IDAVector2*)USE_COM(1),
					get_PolarCoordAngle,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 165:
				// Execute: "push NumberBvr Vector2Bvr.getPolarCoordLength()"
				// AUTOGENERATED
				instrTrace("push NumberBvr Vector2Bvr.getPolarCoordLength()");
				METHOD_CALL_1(
					(IDAVector2*)USE_COM(1),
					get_PolarCoordLength,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 166:
				// Execute: "push Transform3Bvr Transform3Bvr.inverse()"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Transform3Bvr.inverse()");
				METHOD_CALL_1(
					(IDATransform3*)USE_COM(1),
					Inverse,
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 167:
				// Execute: "push BooleanBvr Transform3Bvr.isSingular()"
				// AUTOGENERATED
				instrTrace("push BooleanBvr Transform3Bvr.isSingular()");
				METHOD_CALL_1(
					(IDATransform3*)USE_COM(1),
					get_IsSingular,
					(IDABoolean**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 168:
				// Execute: "push Transform2Bvr Transform3Bvr.parallelTransform2()"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Transform3Bvr.parallelTransform2()");
				METHOD_CALL_1(
					(IDATransform3*)USE_COM(1),
					ParallelTransform2,
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 169:
				// Execute: "push Transform2Bvr Transform2Bvr.inverse()"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Transform2Bvr.inverse()");
				METHOD_CALL_1(
					(IDATransform2*)USE_COM(1),
					Inverse,
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 170:
				// Execute: "push BooleanBvr Transform2Bvr.isSingular()"
				// AUTOGENERATED
				instrTrace("push BooleanBvr Transform2Bvr.isSingular()");
				METHOD_CALL_1(
					(IDATransform2*)USE_COM(1),
					get_IsSingular,
					(IDABoolean**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 171:
				// Execute: "push SoundBvr SoundBvr.rate(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push SoundBvr SoundBvr.rate(NumberBvr)");
				METHOD_CALL_2(
					(IDASound*)USE_COM(1),
					RateAnim,
					(IDANumber*)USE_COM(2),
					(IDASound**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 172:
				// Execute: "push SoundBvr SoundBvr.rate(double)"
				// AUTOGENERATED
				instrTrace("push SoundBvr SoundBvr.rate(double)");
				METHOD_CALL_2(
					(IDASound*)USE_COM(1),
					Rate,
					USE_DOUBLE(1),
					(IDASound**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 173:
				// Execute: "push SoundBvr SoundBvr.loop()"
				// AUTOGENERATED
				instrTrace("push SoundBvr SoundBvr.loop()");
				METHOD_CALL_1(
					(IDASound*)USE_COM(1),
					Loop,
					(IDASound**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 174:
				// Execute: "push SoundBvr SoundBvr.phase(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push SoundBvr SoundBvr.phase(NumberBvr)");
				METHOD_CALL_2(
					(IDASound*)USE_COM(1),
					PhaseAnim,
					(IDANumber*)USE_COM(2),
					(IDASound**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 175:
				// Execute: "push SoundBvr SoundBvr.phase(double)"
				// AUTOGENERATED
				instrTrace("push SoundBvr SoundBvr.phase(double)");
				METHOD_CALL_2(
					(IDASound*)USE_COM(1),
					Phase,
					USE_DOUBLE(1),
					(IDASound**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 176:
				// Execute: "push SoundBvr SoundBvr.pan(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push SoundBvr SoundBvr.pan(NumberBvr)");
				METHOD_CALL_2(
					(IDASound*)USE_COM(1),
					PanAnim,
					(IDANumber*)USE_COM(2),
					(IDASound**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 177:
				// Execute: "push SoundBvr SoundBvr.pan(double)"
				// AUTOGENERATED
				instrTrace("push SoundBvr SoundBvr.pan(double)");
				METHOD_CALL_2(
					(IDASound*)USE_COM(1),
					Pan,
					USE_DOUBLE(1),
					(IDASound**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 178:
				// Execute: "push SoundBvr SoundBvr.gain(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push SoundBvr SoundBvr.gain(NumberBvr)");
				METHOD_CALL_2(
					(IDASound*)USE_COM(1),
					GainAnim,
					(IDANumber*)USE_COM(2),
					(IDASound**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 179:
				// Execute: "push SoundBvr SoundBvr.gain(double)"
				// AUTOGENERATED
				instrTrace("push SoundBvr SoundBvr.gain(double)");
				METHOD_CALL_2(
					(IDASound*)USE_COM(1),
					Gain,
					USE_DOUBLE(1),
					(IDASound**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 180:
				// Execute: "push Point2Bvr Point3Bvr.project(CameraBvr)"
				// AUTOGENERATED
				instrTrace("push Point2Bvr Point3Bvr.project(CameraBvr)");
				METHOD_CALL_2(
					(IDAPoint3*)USE_COM(1),
					Project,
					(IDACamera*)USE_COM(2),
					(IDAPoint2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 181:
				// Execute: "push NumberBvr Point3Bvr.getSphericalCoordLength()"
				// AUTOGENERATED
				instrTrace("push NumberBvr Point3Bvr.getSphericalCoordLength()");
				METHOD_CALL_1(
					(IDAPoint3*)USE_COM(1),
					get_SphericalCoordLength,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 182:
				// Execute: "push NumberBvr Point3Bvr.getSphericalCoordXYAngle()"
				// AUTOGENERATED
				instrTrace("push NumberBvr Point3Bvr.getSphericalCoordXYAngle()");
				METHOD_CALL_1(
					(IDAPoint3*)USE_COM(1),
					get_SphericalCoordXYAngle,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 183:
				// Execute: "push NumberBvr Point3Bvr.getSphericalCoordYZAngle()"
				// AUTOGENERATED
				instrTrace("push NumberBvr Point3Bvr.getSphericalCoordYZAngle()");
				METHOD_CALL_1(
					(IDAPoint3*)USE_COM(1),
					get_SphericalCoordYZAngle,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 184:
				// Execute: "push NumberBvr Point2Bvr.getPolarCoordLength()"
				// AUTOGENERATED
				instrTrace("push NumberBvr Point2Bvr.getPolarCoordLength()");
				METHOD_CALL_1(
					(IDAPoint2*)USE_COM(1),
					get_PolarCoordLength,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 185:
				// Execute: "push NumberBvr Point2Bvr.getPolarCoordAngle()"
				// AUTOGENERATED
				instrTrace("push NumberBvr Point2Bvr.getPolarCoordAngle()");
				METHOD_CALL_1(
					(IDAPoint2*)USE_COM(1),
					get_PolarCoordAngle,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 186:
				// Execute: "push StringBvr NumberBvr.toString(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push StringBvr NumberBvr.toString(NumberBvr)");
				METHOD_CALL_2(
					(IDANumber*)USE_COM(1),
					ToStringAnim,
					(IDANumber*)USE_COM(2),
					(IDAString**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 187:
				// Execute: "push StringBvr NumberBvr.toString(double)"
				// AUTOGENERATED
				instrTrace("push StringBvr NumberBvr.toString(double)");
				METHOD_CALL_2(
					(IDANumber*)USE_COM(1),
					ToString,
					USE_DOUBLE(1),
					(IDAString**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 188:
				// Execute: "push ImageBvr MontageBvr.render()"
				// AUTOGENERATED
				instrTrace("push ImageBvr MontageBvr.render()");
				METHOD_CALL_1(
					(IDAMontage*)USE_COM(1),
					Render,
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 189:
				// Execute: "push MicrophoneBvr MicrophoneBvr.transform(Transform3Bvr)"
				// AUTOGENERATED
				instrTrace("push MicrophoneBvr MicrophoneBvr.transform(Transform3Bvr)");
				METHOD_CALL_2(
					(IDAMicrophone*)USE_COM(1),
					Transform,
					(IDATransform3*)USE_COM(2),
					(IDAMicrophone**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 190:
				// Execute: "push SoundBvr GeometryBvr.render(MicrophoneBvr)"
				// AUTOGENERATED
				instrTrace("push SoundBvr GeometryBvr.render(MicrophoneBvr)");
				METHOD_CALL_2(
					(IDAGeometry*)USE_COM(1),
					RenderSound,
					(IDAMicrophone*)USE_COM(2),
					(IDASound**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 191:
				// Execute: "push GeometryBvr GeometryBvr.transform(Transform3Bvr)"
				// AUTOGENERATED
				instrTrace("push GeometryBvr GeometryBvr.transform(Transform3Bvr)");
				METHOD_CALL_2(
					(IDAGeometry*)USE_COM(1),
					Transform,
					(IDATransform3*)USE_COM(2),
					(IDAGeometry**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 192:
				// Execute: "push ImageBvr GeometryBvr.render(CameraBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr GeometryBvr.render(CameraBvr)");
				METHOD_CALL_2(
					(IDAGeometry*)USE_COM(1),
					Render,
					(IDACamera*)USE_COM(2),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 193:
				// Execute: "push Bbox3Bvr GeometryBvr.boundingBox()"
				// AUTOGENERATED
				instrTrace("push Bbox3Bvr GeometryBvr.boundingBox()");
				METHOD_CALL_1(
					(IDAGeometry*)USE_COM(1),
					get_BoundingBox,
					(IDABbox3**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 194:
				// Execute: "push GeometryBvr GeometryBvr.undetectable()"
				// AUTOGENERATED
				instrTrace("push GeometryBvr GeometryBvr.undetectable()");
				METHOD_CALL_1(
					(IDAGeometry*)USE_COM(1),
					Undetectable,
					(IDAGeometry**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 195:
				// Execute: "push NumberBvr ColorBvr.getRed()"
				// AUTOGENERATED
				instrTrace("push NumberBvr ColorBvr.getRed()");
				METHOD_CALL_1(
					(IDAColor*)USE_COM(1),
					get_Red,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 196:
				// Execute: "push NumberBvr ColorBvr.getSaturation()"
				// AUTOGENERATED
				instrTrace("push NumberBvr ColorBvr.getSaturation()");
				METHOD_CALL_1(
					(IDAColor*)USE_COM(1),
					get_Saturation,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 197:
				// Execute: "push NumberBvr ColorBvr.getHue()"
				// AUTOGENERATED
				instrTrace("push NumberBvr ColorBvr.getHue()");
				METHOD_CALL_1(
					(IDAColor*)USE_COM(1),
					get_Hue,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 198:
				// Execute: "push NumberBvr ColorBvr.getBlue()"
				// AUTOGENERATED
				instrTrace("push NumberBvr ColorBvr.getBlue()");
				METHOD_CALL_1(
					(IDAColor*)USE_COM(1),
					get_Blue,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 199:
				// Execute: "push NumberBvr ColorBvr.getGreen()"
				// AUTOGENERATED
				instrTrace("push NumberBvr ColorBvr.getGreen()");
				METHOD_CALL_1(
					(IDAColor*)USE_COM(1),
					get_Green,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 200:
				// Execute: "push NumberBvr ColorBvr.getLightness()"
				// AUTOGENERATED
				instrTrace("push NumberBvr ColorBvr.getLightness()");
				METHOD_CALL_1(
					(IDAColor*)USE_COM(1),
					get_Lightness,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 201:
				// Execute: "push CameraBvr CameraBvr.depthResolution(double)"
				// AUTOGENERATED
				instrTrace("push CameraBvr CameraBvr.depthResolution(double)");
				METHOD_CALL_2(
					(IDACamera*)USE_COM(1),
					DepthResolution,
					USE_DOUBLE(1),
					(IDACamera**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 202:
				// Execute: "push CameraBvr CameraBvr.depthResolution(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push CameraBvr CameraBvr.depthResolution(NumberBvr)");
				METHOD_CALL_2(
					(IDACamera*)USE_COM(1),
					DepthResolutionAnim,
					(IDANumber*)USE_COM(2),
					(IDACamera**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 203:
				// Execute: "push CameraBvr CameraBvr.transform(Transform3Bvr)"
				// AUTOGENERATED
				instrTrace("push CameraBvr CameraBvr.transform(Transform3Bvr)");
				METHOD_CALL_2(
					(IDACamera*)USE_COM(1),
					Transform,
					(IDATransform3*)USE_COM(2),
					(IDACamera**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 204:
				// Execute: "push CameraBvr CameraBvr.depth(double)"
				// AUTOGENERATED
				instrTrace("push CameraBvr CameraBvr.depth(double)");
				METHOD_CALL_2(
					(IDACamera*)USE_COM(1),
					Depth,
					USE_DOUBLE(1),
					(IDACamera**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 205:
				// Execute: "push CameraBvr CameraBvr.depth(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push CameraBvr CameraBvr.depth(NumberBvr)");
				METHOD_CALL_2(
					(IDACamera*)USE_COM(1),
					DepthAnim,
					(IDANumber*)USE_COM(2),
					(IDACamera**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 206:
				// Execute: "push Statics.aqua"
				// AUTOGENERATED
				instrTrace("push Statics.aqua");
				METHOD_CALL_1(
					staticStatics,
					get_Aqua,
					(IDAColor**)PUSH_COM_ADDR
				);
				break;
				
			case 207:
				// Execute: "push Statics.fuchsia"
				// AUTOGENERATED
				instrTrace("push Statics.fuchsia");
				METHOD_CALL_1(
					staticStatics,
					get_Fuchsia,
					(IDAColor**)PUSH_COM_ADDR
				);
				break;
				
			case 208:
				// Execute: "push Statics.gray"
				// AUTOGENERATED
				instrTrace("push Statics.gray");
				METHOD_CALL_1(
					staticStatics,
					get_Gray,
					(IDAColor**)PUSH_COM_ADDR
				);
				break;
				
			case 209:
				// Execute: "push Statics.lime"
				// AUTOGENERATED
				instrTrace("push Statics.lime");
				METHOD_CALL_1(
					staticStatics,
					get_Lime,
					(IDAColor**)PUSH_COM_ADDR
				);
				break;
				
			case 210:
				// Execute: "push Statics.maroon"
				// AUTOGENERATED
				instrTrace("push Statics.maroon");
				METHOD_CALL_1(
					staticStatics,
					get_Maroon,
					(IDAColor**)PUSH_COM_ADDR
				);
				break;
				
			case 211:
				// Execute: "push Statics.navy"
				// AUTOGENERATED
				instrTrace("push Statics.navy");
				METHOD_CALL_1(
					staticStatics,
					get_Navy,
					(IDAColor**)PUSH_COM_ADDR
				);
				break;
				
			case 212:
				// Execute: "push Statics.olive"
				// AUTOGENERATED
				instrTrace("push Statics.olive");
				METHOD_CALL_1(
					staticStatics,
					get_Olive,
					(IDAColor**)PUSH_COM_ADDR
				);
				break;
				
			case 213:
				// Execute: "push Statics.purple"
				// AUTOGENERATED
				instrTrace("push Statics.purple");
				METHOD_CALL_1(
					staticStatics,
					get_Purple,
					(IDAColor**)PUSH_COM_ADDR
				);
				break;
				
			case 214:
				// Execute: "push Statics.silver"
				// AUTOGENERATED
				instrTrace("push Statics.silver");
				METHOD_CALL_1(
					staticStatics,
					get_Silver,
					(IDAColor**)PUSH_COM_ADDR
				);
				break;
				
			case 215:
				// Execute: "push Statics.teal"
				// AUTOGENERATED
				instrTrace("push Statics.teal");
				METHOD_CALL_1(
					staticStatics,
					get_Teal,
					(IDAColor**)PUSH_COM_ADDR
				);
				break;
				
			case 216:
				// Execute: "push NumberBvr StaticsBase.seededRandom(double)"
				// AUTOGENERATED
				instrTrace("push NumberBvr StaticsBase.seededRandom(double)");
				METHOD_CALL_2(
					staticStatics,
					SeededRandom,
					USE_DOUBLE(1),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				PUSH_COM(RET_COM);
				break;
				
			case 217:
				// Execute: "push Behavior StaticsBase.cond(BooleanBvr, Behavior, Behavior)"
				// AUTOGENERATED
				instrTrace("push Behavior StaticsBase.cond(BooleanBvr, Behavior, Behavior)");
				METHOD_CALL_4(
					staticStatics,
					Cond,
					(IDABoolean*)USE_COM(1),
					(IDABehavior*)USE_COM(2),
					(IDABehavior*)USE_COM(3),
					(IDABehavior**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 218:
				// Execute: "push ImageBvr Statics.importImage(java.lang.String)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.importImage(java.lang.String)");
				IMPORT_METHOD_CALL_2(
					staticStatics,
					ImportImage,
					USE_STRING(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_STRING;
				PUSH_COM(RET_COM);
				break;
				
			case 219:
				// Execute: "push BooleanBvr Statics.keyState(NumberBvr)"
				// AUTOGENERATED
				instrTrace("push BooleanBvr Statics.keyState(NumberBvr)");
				METHOD_CALL_2(
					staticStatics,
					KeyState,
					(IDANumber*)USE_COM(1),
					(IDABoolean**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 220:
				// Execute: "push NumberBvr StaticsBase.bSpline(int, NumberBvr[], NumberBvr[], NumberBvr[], NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr StaticsBase.bSpline(int, NumberBvr[], NumberBvr[], NumberBvr[], NumberBvr)");
				METHOD_CALL_9(
					staticStatics,
					NumberBSplineEx,
					USE_LONG(1),
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDANumber**)USE_COM_ARRAY(2),
					USE_COM_ARRAY_LENGTH(3),
					(IDANumber**)USE_COM_ARRAY(3),
					(IDANumber*)USE_COM(1),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_COM;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 221:
				// Execute: "push Point2Bvr StaticsBase.bSpline(int, NumberBvr[], Point2Bvr[], NumberBvr[], NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Point2Bvr StaticsBase.bSpline(int, NumberBvr[], Point2Bvr[], NumberBvr[], NumberBvr)");
				METHOD_CALL_9(
					staticStatics,
					Point2BSplineEx,
					USE_LONG(1),
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDAPoint2**)USE_COM_ARRAY(2),
					USE_COM_ARRAY_LENGTH(3),
					(IDANumber**)USE_COM_ARRAY(3),
					(IDANumber*)USE_COM(1),
					(IDAPoint2**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_COM;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 222:
				// Execute: "push Point3Bvr StaticsBase.bSpline(int, NumberBvr[], Point3Bvr[], NumberBvr[], NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Point3Bvr StaticsBase.bSpline(int, NumberBvr[], Point3Bvr[], NumberBvr[], NumberBvr)");
				METHOD_CALL_9(
					staticStatics,
					Point3BSplineEx,
					USE_LONG(1),
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDAPoint3**)USE_COM_ARRAY(2),
					USE_COM_ARRAY_LENGTH(3),
					(IDANumber**)USE_COM_ARRAY(3),
					(IDANumber*)USE_COM(1),
					(IDAPoint3**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_COM;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 223:
				// Execute: "push Vector2Bvr StaticsBase.bSpline(int, NumberBvr[], Vector2Bvr[], NumberBvr[], NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Vector2Bvr StaticsBase.bSpline(int, NumberBvr[], Vector2Bvr[], NumberBvr[], NumberBvr)");
				METHOD_CALL_9(
					staticStatics,
					Vector2BSplineEx,
					USE_LONG(1),
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDAVector2**)USE_COM_ARRAY(2),
					USE_COM_ARRAY_LENGTH(3),
					(IDANumber**)USE_COM_ARRAY(3),
					(IDANumber*)USE_COM(1),
					(IDAVector2**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_COM;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 224:
				// Execute: "push Vector3Bvr StaticsBase.bSpline(int, NumberBvr[], Vector3Bvr[], NumberBvr[], NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Vector3Bvr StaticsBase.bSpline(int, NumberBvr[], Vector3Bvr[], NumberBvr[], NumberBvr)");
				METHOD_CALL_9(
					staticStatics,
					Vector3BSplineEx,
					USE_LONG(1),
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDAVector3**)USE_COM_ARRAY(2),
					USE_COM_ARRAY_LENGTH(3),
					(IDANumber**)USE_COM_ARRAY(3),
					(IDANumber*)USE_COM(1),
					(IDAVector3**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_COM;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 225:
				// Execute: "push DXMEvent DXMEvent.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push DXMEvent DXMEvent.newUninitBvr()");
				COM_CREATE(
					CLSID_DAEvent, 
					IID_IDAEvent, 
					PUSH_COM_ADDR
				);
				break;
				
			case 226:
				// Execute: "push Bbox3Bvr Bbox3Bvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push Bbox3Bvr Bbox3Bvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DABbox3, 
					IID_IDABbox3, 
					PUSH_COM_ADDR
				);
				break;
				
			case 227:
				// Execute: "push Bbox2Bvr Bbox2Bvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push Bbox2Bvr Bbox2Bvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DABbox2, 
					IID_IDABbox2, 
					PUSH_COM_ADDR
				);
				break;
				
			case 228:
				// Execute: "push DashStyleBvr DashStyleBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push DashStyleBvr DashStyleBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DADashStyle, 
					IID_IDADashStyle, 
					PUSH_COM_ADDR
				);
				break;
				
			case 229:
				// Execute: "push JoinStyleBvr JoinStyleBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push JoinStyleBvr JoinStyleBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAJoinStyle, 
					IID_IDAJoinStyle, 
					PUSH_COM_ADDR
				);
				break;
				
			case 230:
				// Execute: "push EndStyleBvr EndStyleBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push EndStyleBvr EndStyleBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAEndStyle, 
					IID_IDAEndStyle, 
					PUSH_COM_ADDR
				);
				break;
				
			case 231:
				// Execute: "push LineStyleBvr LineStyleBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push LineStyleBvr LineStyleBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DALineStyle, 
					IID_IDALineStyle, 
					PUSH_COM_ADDR
				);
				break;
				
			case 232:
				// Execute: "push FontStyleBvr FontStyleBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push FontStyleBvr FontStyleBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAFontStyle, 
					IID_IDAFontStyle, 
					PUSH_COM_ADDR
				);
				break;
				
			case 233:
				// Execute: "push Vector3Bvr Vector3Bvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push Vector3Bvr Vector3Bvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAVector3, 
					IID_IDAVector3, 
					PUSH_COM_ADDR
				);
				break;
				
			case 234:
				// Execute: "push Vector2Bvr Vector2Bvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push Vector2Bvr Vector2Bvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAVector2, 
					IID_IDAVector2, 
					PUSH_COM_ADDR
				);
				break;
				
			case 235:
				// Execute: "push Transform3Bvr Transform3Bvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Transform3Bvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DATransform3, 
					IID_IDATransform3, 
					PUSH_COM_ADDR
				);
				break;
				
			case 236:
				// Execute: "push Transform2Bvr Transform2Bvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Transform2Bvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DATransform2, 
					IID_IDATransform2, 
					PUSH_COM_ADDR
				);
				break;
				
			case 237:
				// Execute: "push StringBvr StringBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push StringBvr StringBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAString, 
					IID_IDAString, 
					PUSH_COM_ADDR
				);
				break;
				
			case 238:
				// Execute: "push SoundBvr SoundBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push SoundBvr SoundBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DASound, 
					IID_IDASound, 
					PUSH_COM_ADDR
				);
				break;
				
			case 239:
				// Execute: "push Point3Bvr Point3Bvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push Point3Bvr Point3Bvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAPoint3, 
					IID_IDAPoint3, 
					PUSH_COM_ADDR
				);
				break;
				
			case 240:
				// Execute: "push Point2Bvr Point2Bvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push Point2Bvr Point2Bvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAPoint2, 
					IID_IDAPoint2, 
					PUSH_COM_ADDR
				);
				break;
				
			case 241:
				// Execute: "push Path2Bvr Path2Bvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Path2Bvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAPath2, 
					IID_IDAPath2, 
					PUSH_COM_ADDR
				);
				break;
				
			case 242:
				// Execute: "push NumberBvr NumberBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push NumberBvr NumberBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DANumber, 
					IID_IDANumber, 
					PUSH_COM_ADDR
				);
				break;
				
			case 243:
				// Execute: "push MontageBvr MontageBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push MontageBvr MontageBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAMontage, 
					IID_IDAMontage, 
					PUSH_COM_ADDR
				);
				break;
				
			case 244:
				// Execute: "push MicrophoneBvr MicrophoneBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push MicrophoneBvr MicrophoneBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAMicrophone, 
					IID_IDAMicrophone, 
					PUSH_COM_ADDR
				);
				break;
				
			case 245:
				// Execute: "push MatteBvr MatteBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push MatteBvr MatteBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAMatte, 
					IID_IDAMatte, 
					PUSH_COM_ADDR
				);
				break;
				
			case 246:
				// Execute: "push ImageBvr ImageBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push ImageBvr ImageBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAImage, 
					IID_IDAImage, 
					PUSH_COM_ADDR
				);
				break;
				
			case 247:
				// Execute: "push GeometryBvr GeometryBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push GeometryBvr GeometryBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAGeometry, 
					IID_IDAGeometry, 
					PUSH_COM_ADDR
				);
				break;
				
			case 248:
				// Execute: "push ColorBvr ColorBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push ColorBvr ColorBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DAColor, 
					IID_IDAColor, 
					PUSH_COM_ADDR
				);
				break;
				
			case 249:
				// Execute: "push CameraBvr CameraBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push CameraBvr CameraBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DACamera, 
					IID_IDACamera, 
					PUSH_COM_ADDR
				);
				break;
				
			case 250:
				// Execute: "push BooleanBvr BooleanBvr.newUninitBvr()"
				// AUTOGENERATED
				instrTrace("push BooleanBvr BooleanBvr.newUninitBvr()");
				COM_CREATE(
					CLSID_DABoolean, 
					IID_IDABoolean, 
					PUSH_COM_ADDR
				);
				break;
				
			case 251:
				// Execute: "call Engine.navigate(java.lang.String, java.lang.String, java.lang.String, int)"
				// USER GENERATED
				instrTrace("call Engine.navigate(java.lang.String, java.lang.String, java.lang.String, int)");
				
				//if the version of da that we are using is not the ie40 version
				if( getDAVersionAsDouble() != 501150828 )
				{
					status = navigate(
						USE_STRING(1),
						USE_STRING(2),
						USE_STRING(3),
						USE_LONG(1)
						);
					FREE_LONG(1);
					FREE_STRING;
					FREE_STRING;
					FREE_STRING;
				} else { //we are running the ie40 version of da
					//in this case the byte code has assumed that this is an old LMRT and is using
					// the 3 argument version of navigate, we need to translate
					
					bstrTmp1 = SysAllocString( L"_top" );
					status = navigate(
									  USE_STRING(1),
									  USE_STRING(2),
									  bstrTmp1,
									  USE_LONG(1)
									  );
					SysFreeString( bstrTmp1 );
					FREE_LONG(1);
					FREE_STRING;
					FREE_STRING;
					
				
				}
				
				status = S_OK;
				break;
				
			case 252:
				// Execute: "call Engine.exportBvr(java.lang.String, Behavior)"
				// USER GENERATED
				{
					IDABehavior *pBvr;
					status = USE_COM(1)->QueryInterface( IID_IDABehavior, (void**)&pBvr );
					if( SUCCEEDED( status ) )
					{
						status = ExportBehavior( USE_STRING(1), pBvr );
						pBvr->Release();
					}
				}
				FREE_STRING;
				FREE_COM;
				break;
				
			case 253:
				// Execute: "push ViewerControl Engine.getViewerControl(java.lang.String)"
				// USER GENERATED
				instrTrace("push ViewerControl Engine.getViewerControl(java.lang.String)");
				status = getDAViewerOnPage(
					USE_STRING(1),
					(IDAViewerControl**)RET_COM_ADDR
				);
				FREE_STRING;
				PUSH_COM(RET_COM);
				break;
				
			case 254:
				// Execute: "call ViewerControl.setBackgroundImage(ImageBvr)"
				// AUTOGENERATED
				instrTrace("call ViewerControl.setBackgroundImage(ImageBvr)");
				METHOD_CALL_1(
					(IDAViewerControl*)USE_COM(1),
					put_BackgroundImage,
					(IDAImage*)USE_COM(2)
				);
				FREE_COM;
				FREE_COM;
				break;
				
			case 255:
				// Execute: "call ViewerControl.setOpaqueForHitDetect(boolean)"
				// AUTOGENERATED
				instrTrace("call ViewerControl.setOpaqueForHitDetect(boolean)");
				METHOD_CALL_1(
					(IDAViewerControl*)USE_COM(1),
					put_OpaqueForHitDetect,
					USE_LONG_AS_BOOL(1)
				);
				FREE_LONG(1);
				FREE_COM;
				break;
				
			default:
				status = E_INVALIDARG;
				break;
			}
			break;
		
		case 254:
			// Switch for 254
			 if (!SUCCEEDED(status = codeStream->readByte(&command))) 
				continue; 
			switch (command)
			{
			case 0:
				// Execute: "call ViewerControl.addBehaviorToRun(Behavior)"
				// AUTOGENERATED
				instrTrace("call ViewerControl.addBehaviorToRun(Behavior)");
				METHOD_CALL_1(
					(IDAViewerControl*)USE_COM(1),
					AddBehaviorToRun,
					(IDABehavior*)USE_COM(2)
				);
				FREE_COM;
				FREE_COM;
				break;
				
			case 1:
				// Execute: "call ViewerControl.start()"
				// AUTOGENERATED
				instrTrace("call ViewerControl.start()");
				METHOD_CALL_0(
					(IDAViewerControl*)USE_COM(1),
					Start
				);
				FREE_COM;
				break;
				
			case 2:
				// Execute: "call ViewerControl.setImage(ImageBvr)"
				// USER GENERATED
				instrTrace("call ViewerControl.setImage(ImageBvr)");
				{
					IDAImage *rootImage = (IDAImage*)USE_COM(2);
					IDAImage *finalImage = NULL;

					if( m_bEnableAutoAntialias )
					{
						CComQIPtr<IDA2Image, &IID_IDA2Image> root2Image(rootImage);
						
						if( root2Image != NULL )
						{
							if( FAILED( root2Image->ImageQuality( DAQUAL_AA_LINES_ON | DAQUAL_AA_SOLIDS_ON | DAQUAL_AA_TEXT_ON, 
																  &finalImage ) ) )
							{
								finalImage = rootImage;
							}
							if( finalImage == NULL )
							{
								finalImage = rootImage;
							}
						} 
						else
						{
							finalImage = rootImage;
						}
					}else { //AutoAntiAlias is disabled.
						//use the root Image we were passed
						finalImage = rootImage;
					}
				
					METHOD_CALL_1(
						(IDAViewerControl*)USE_COM(1),
						put_Image,
						//(IDAImage*)USE_COM(2)
						finalImage
					);
					if( finalImage != rootImage )
						finalImage->Release();
					FREE_COM;
					FREE_COM;
				}
				break;
				
			case 3:
				// Execute: "call ViewerControl.setSound(SoundBvr)"
				// AUTOGENERATED
				instrTrace("call ViewerControl.setSound(SoundBvr)");
				METHOD_CALL_1(
					(IDAViewerControl*)USE_COM(1),
					put_Sound,
					(IDASound*)USE_COM(2)
				);
				FREE_COM;
				FREE_COM;
				break;
				
			case 4:
				// Execute: "call ViewerControl.setUpdateInterval(double)"
				// AUTOGENERATED
				instrTrace("call ViewerControl.setUpdateInterval(double)");
				METHOD_CALL_1(
					(IDAViewerControl*)USE_COM(1),
					put_UpdateInterval,
					USE_DOUBLE(1)
				);
				FREE_DOUBLE(1);
				FREE_COM;
				break;
				
			case 5:
				// Execute: "push Behavior PairBvr.getFirst()"
				// AUTOGENERATED
				instrTrace("push Behavior PairBvr.getFirst()");
				METHOD_CALL_1(
					(IDAPair*)USE_COM(1),
					get_First,
					(IDABehavior**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 6:
				// Execute: "push Behavior PairBvr.getSecond()"
				// AUTOGENERATED
				instrTrace("push Behavior PairBvr.getSecond()");
				METHOD_CALL_1(
					(IDAPair*)USE_COM(1),
					get_Second,
					(IDABehavior**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 7:
				// Execute: "push StringBvr StringBvr.animateProperty(java.lang.String, java.lang.String, boolean, double)"
				// AUTOGENERATED
				instrTrace("push StringBvr StringBvr.animateProperty(java.lang.String, java.lang.String, boolean, double)");
				METHOD_CALL_5(
					(IDAString*)USE_COM(1),
					AnimateProperty,
					USE_STRING(1),
					USE_STRING(2),
					USE_LONG_AS_BOOL(1),
					USE_DOUBLE(1),
					(IDAString**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_DOUBLE(1);
				FREE_STRING;
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 8:
				// Execute: "push Point2Bvr Point2Bvr.animateControlPositionPixel(java.lang.String, java.lang.String, boolean, double)"
				// AUTOGENERATED
				instrTrace("push Point2Bvr Point2Bvr.animateControlPositionPixel(java.lang.String, java.lang.String, boolean, double)");
				METHOD_CALL_5(
					(IDAPoint2*)USE_COM(1),
					AnimateControlPositionPixel,
					USE_STRING(1),
					USE_STRING(2),
					USE_LONG_AS_BOOL(1),
					USE_DOUBLE(1),
					(IDAPoint2**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_DOUBLE(1);
				FREE_STRING;
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 9:
				// Execute: "push Point2Bvr Point2Bvr.animateControlPosition(java.lang.String, java.lang.String, boolean, double)"
				// AUTOGENERATED
				instrTrace("push Point2Bvr Point2Bvr.animateControlPosition(java.lang.String, java.lang.String, boolean, double)");
				METHOD_CALL_5(
					(IDAPoint2*)USE_COM(1),
					AnimateControlPosition,
					USE_STRING(1),
					USE_STRING(2),
					USE_LONG_AS_BOOL(1),
					USE_DOUBLE(1),
					(IDAPoint2**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_DOUBLE(1);
				FREE_STRING;
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 10:
				// Execute: "push NumberBvr NumberBvr.animateProperty(java.lang.String, java.lang.String, boolean, double)"
				// AUTOGENERATED
				instrTrace("push NumberBvr NumberBvr.animateProperty(java.lang.String, java.lang.String, boolean, double)");
				METHOD_CALL_5(
					(IDANumber*)USE_COM(1),
					AnimateProperty,
					USE_STRING(1),
					USE_STRING(2),
					USE_LONG_AS_BOOL(1),
					USE_DOUBLE(1),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_DOUBLE(1);
				FREE_STRING;
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 11:
				// Execute: "call Engine.showStatusLine(java.lang.String)"
				// USER GENERATED
				SetStatusText(
					USE_STRING(1)
				);
				FREE_STRING;
				break;
				
			case 12:
				// Execute: "push DXMEvent ImportationResult.getCompletionEvent()"
				// AUTOGENERATED
				instrTrace("push DXMEvent ImportationResult.getCompletionEvent()");
				METHOD_CALL_1(
					(IDAImportationResult*)USE_COM(1),
					get_CompletionEvent,
					(IDAEvent**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 13:
				// Execute: "push GeometryBvr ImportationResult.getGeometry()"
				// AUTOGENERATED
				instrTrace("push GeometryBvr ImportationResult.getGeometry()");
				METHOD_CALL_1(
					(IDAImportationResult*)USE_COM(1),
					get_Geometry,
					(IDAGeometry**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 14:
				// Execute: "push NumberBvr ImportationResult.getProgress()"
				// AUTOGENERATED
				instrTrace("push NumberBvr ImportationResult.getProgress()");
				METHOD_CALL_1(
					(IDAImportationResult*)USE_COM(1),
					get_Progress,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 15:
				// Execute: "push ImageBvr ImportationResult.getImage()"
				// AUTOGENERATED
				instrTrace("push ImageBvr ImportationResult.getImage()");
				METHOD_CALL_1(
					(IDAImportationResult*)USE_COM(1),
					get_Image,
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 16:
				// Execute: "push NumberBvr ImportationResult.getSize()"
				// AUTOGENERATED
				instrTrace("push NumberBvr ImportationResult.getSize()");
				METHOD_CALL_1(
					(IDAImportationResult*)USE_COM(1),
					get_Size,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 17:
				// Execute: "push SoundBvr ImportationResult.getSound()"
				// AUTOGENERATED
				instrTrace("push SoundBvr ImportationResult.getSound()");
				METHOD_CALL_1(
					(IDAImportationResult*)USE_COM(1),
					get_Sound,
					(IDASound**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 18:
				// Execute: "push NumberBvr ImportationResult.getDuration()"
				// AUTOGENERATED
				instrTrace("push NumberBvr ImportationResult.getDuration()");
				METHOD_CALL_1(
					(IDAImportationResult*)USE_COM(1),
					get_Duration,
					(IDANumber**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 19:
				// Execute: "push ImportationResult Statics.importMovie(java.lang.String)"
				// AUTOGENERATED
				instrTrace("push ImportationResult Statics.importMovie(java.lang.String)");
				IMPORT_METHOD_CALL_2(
					staticStatics,
					ImportMovie,
					USE_STRING(1),
					(IDAImportationResult**)RET_COM_ADDR
				);
				FREE_STRING;
				PUSH_COM(RET_COM);
				break;
				
			case 20:
				// Execute: "push ImportationResult Statics.importMovie(java.lang.String, ImageBvr, SoundBvr)"
				// AUTOGENERATED
				instrTrace("push ImportationResult Statics.importMovie(java.lang.String, ImageBvr, SoundBvr)");
				IMPORT_METHOD_CALL_4(
					staticStatics,
					ImportMovieAsync,
					USE_STRING(1),
					(IDAImage*)USE_COM(1),
					(IDASound*)USE_COM(2),
					(IDAImportationResult**)RET_COM_ADDR
				);
				FREE_STRING;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 21:
				// Execute: "push ImportationResult Statics.importGeometry(java.lang.String, GeometryBvr)"
				// AUTOGENERATED
				instrTrace("push ImportationResult Statics.importGeometry(java.lang.String, GeometryBvr)");
				IMPORT_METHOD_CALL_3(
					staticStatics,
					ImportGeometryAsync,
					USE_STRING(1),
					(IDAGeometry*)USE_COM(1),
					(IDAImportationResult**)RET_COM_ADDR
				);
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 22:
				// Execute: "push ImportationResult Statics.importImage(java.lang.String, ImageBvr)"
				// AUTOGENERATED
				instrTrace("push ImportationResult Statics.importImage(java.lang.String, ImageBvr)");
				IMPORT_METHOD_CALL_3(
					staticStatics,
					ImportImageAsync,
					USE_STRING(1),
					(IDAImage*)USE_COM(1),
					(IDAImportationResult**)RET_COM_ADDR
				);
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 23:
				// Execute: "push ImportationResult Statics.importSound(java.lang.String)"
				// AUTOGENERATED
				instrTrace("push ImportationResult Statics.importSound(java.lang.String)");
				IMPORT_METHOD_CALL_2(
					staticStatics,
					ImportSound,
					USE_STRING(1),
					(IDAImportationResult**)RET_COM_ADDR
				);
				FREE_STRING;
				PUSH_COM(RET_COM);
				break;
				
			case 24:
				// Execute: "push ImportationResult Statics.importSound(java.lang.String, SoundBvr)"
				// AUTOGENERATED
				instrTrace("push ImportationResult Statics.importSound(java.lang.String, SoundBvr)");
				IMPORT_METHOD_CALL_3(
					staticStatics,
					ImportSoundAsync,
					USE_STRING(1),
					(IDASound*)USE_COM(1),
					(IDAImportationResult**)RET_COM_ADDR
				);
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 25:
				// Execute: "push Engine Engine.run(java.lang.String)"
				// USER GENERATED
				instrTrace("push Engine Engine.run(java.lang.String)")
				status = m_pReader->execute(
					USE_STRING(1),
					(ILMEngine**)RET_COM_ADDR
				);
				FREE_STRING;
				PUSH_COM(RET_COM);
				break;
				
			case 26:
				// Execute: "call Engine.exportsAreDone()"
				// USER GENERATED
				instrTrace("call Engine.exportsAreDone()");
				break;
				
			case 27:
				// Execute: "ensure long stack size"
				// USER GENERATED
				{
					instrTrace("ensure long stack size");
					// Load the size from the instruction stream
					LONG newSize;
					if (SUCCEEDED(status = readLong(&newSize))) {
						if (newSize > longStackSize) {
							// Allocate new stack
							LONG *newStack = new LONG[newSize];
							if (newStack != 0) {
								// Remember old stack
								LONG *oldStack = longStack;
								// Do the copy
								LONG *newTop = newStack;
								while (longStack != longTop)
									*newTop++ = *longStack++;
								// Clean up
								longStack = newStack;
								longTop = newTop;
								longStackSize = newSize;
								// Delete old stack
								delete[] oldStack;
							} else {
								status = E_OUTOFMEMORY;
							}
						}
					} 
				}
				break;
				
			case 28:
				// Execute: "ensure double stack size"
				// USER GENERATED
				{
					instrTrace("ensure double stack size");
					// Load the size from the instruction stream
					LONG newSize;
					if (SUCCEEDED(status = readLong(&newSize))) {
						if (newSize > doubleStackSize) {
							// Allocate new stack
							double *newStack = new double[newSize];
							if (newStack != 0) {
								// Remember old stack
								double *oldStack = doubleStack;
								// Do the copy
								double *newTop = newStack;
								while (doubleStack != doubleTop)
									*newTop++ = *doubleStack++;
								// Clean up
								doubleStack = newStack;
								doubleTop = newTop;
								doubleStackSize = newSize;
								// Delete old stack
								delete[] oldStack;
							} else {
								status = E_OUTOFMEMORY;
							}
						}
					}
				}
				break;
				
			case 29:
				// Execute: "ensure string stack size"
				// USER GENERATED
				{
					instrTrace("ensure string stack size");
					// Load the size from the instruction stream
					LONG newSize;
					if (SUCCEEDED(status = readLong(&newSize))) {
						if (newSize > stringStackSize) {
							// Allocate new stack
							BSTR *newStack = new BSTR[newSize];
							if (newStack != 0) {
								// Remember old stack
								BSTR *oldStack = stringStack;
								// Do the copy
								BSTR *newTop = newStack;
								while (stringStack != stringTop)
									*newTop++ = *stringStack++;
								// Clean up
								stringStack = newStack;
								stringTop = newTop;
								stringStackSize = newSize;
								// Delete old stack
								delete[] oldStack;
							} else {
								status = E_OUTOFMEMORY;
							}
						}
					}
				}
				break;
				
			case 30:
				// Execute: "ensure com stack size"
				// USER GENERATED
				{
					instrTrace("ensure com stack size");
					// Load the size from the instruction stream
					LONG newSize;
					if (SUCCEEDED(status = readLong(&newSize))) {
						if (newSize > comStackSize) {
							// Allocate new stack
							IUnknown **newStack = new IUnknown*[newSize];
							if (newStack != 0) {
								// Remember old stack
								IUnknown **oldStack = comStack;
								// Do the copy
								IUnknown **newTop = newStack;
								while (comStack != comTop)
									*newTop++ = *comStack++;
								// Clean up
								comStack = newStack;
								comTop = newTop;
								comStackSize = newSize;
								// Delete old stack
								delete[] oldStack;
							} else {
								status = E_OUTOFMEMORY;
							}
						}
					}
				}
				break;
				
			case 31:
				// Execute: "ensure com array stack size"
				// USER GENERATED
				{
					instrTrace("ensure com array stack size");
					// Load the size from the instruction stream
					LONG newSize;
					if (SUCCEEDED(status = readLong(&newSize))) {
						if (newSize > comArrayStackSize) {
							// Allocate new stack
							IUnknown ***newStack = new IUnknown**[newSize];
							long *newLenStack = new long[newSize];
							if (newStack != 0 && newLenStack != 0) {
								// Remember old stack
								IUnknown ***oldStack = comArrayStack;
								long *oldLenStack = comArrayLenStack;
								// Do the copy
								IUnknown ***newTop = newStack;
								long *newLenTop = newLenStack;
								while (comArrayStack != comArrayTop) {
									*newTop++ = *comArrayStack++;
									*newLenTop++ = *comArrayLenStack++;
								}
								// Clean up
								comArrayStack = newStack;
								comArrayTop = newTop;
								comArrayStackSize = newSize;
								
								comArrayLenStack = newLenStack;
								comArrayLenTop = newLenTop;
								// Delete old stack
								delete[] oldStack;
								delete[] oldLenStack;
							} else {
								status = E_OUTOFMEMORY;
							}
						}
					}
				}
				break;
				
			case 32:
				// Execute: "ensure com store size"
				// USER GENERATED
				{
					instrTrace("ensure com store size");
					// Load the size from the instruction stream
					LONG newSize;
					if (SUCCEEDED(status = readLong(&newSize))) {
						if (newSize > comStoreSize) {
							// Allocate new store
							IUnknown **newStore = new IUnknown*[newSize];
							if (newStore != 0) {
								// Initialize it to 0, so we can release it at the end
								for (int i=0; i<newSize; i++)
									newStore[i] = 0;
								// Remember old store
								IUnknown **oldStore = comStore;
								// Do the copy
								IUnknown **newTop = newStore;
								while (comStoreSize--)
									*newTop++ = *comStore++;
								// Clean up
								comStore = newStore;
								comStoreSize = newSize;
								// Delete old store
								delete[] oldStore;
							} else {
								status = E_OUTOFMEMORY;
							}
						}
					}
				}
				break;
				
			case 33:
				// Execute: "call Engine.setImage(ImageBvr)"
				// USER GENERATED
				instrTrace("call Engine.setImage(ImageBvr)");
				if (m_pImage)
					m_pImage->SwitchTo((IDAImage*)USE_COM(1));
				else {
					m_pImage = (IDAImage *)USE_COM(1);
					m_pImage->AddRef();
				}
				FREE_COM;
				break;
				
			case 34:
				// Execute: "push DXMEvent DXMEvent.notifyEvent(UntilNotifier)"
				// AUTOGENERATED
				instrTrace("push DXMEvent DXMEvent.notifyEvent(UntilNotifier)");
				METHOD_CALL_2(
					(IDAEvent*)USE_COM(1),
					Notify,
					(IDAUntilNotifier*)USE_COM(2),
					(IDAEvent**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 35:
				// Execute: "push Behavior Statics.untilNotify(Behavior, DXMEvent, UntilNotifier)"
				// AUTOGENERATED
				instrTrace("push Behavior Statics.untilNotify(Behavior, DXMEvent, UntilNotifier)");
				METHOD_CALL_4(
					staticStatics,
					UntilNotify,
					(IDABehavior*)USE_COM(1),
					(IDAEvent*)USE_COM(2),
					(IDAUntilNotifier*)USE_COM(3),
					(IDABehavior**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 36:
				// Execute: "push untilnotifier"
				// USER GENERATED
				instrTrace("push untilnotifier");
				{
					// Get number of bytes in method code
					if (SUCCEEDED(status = readLong(&longTmp1))) {
						// Create an array of this size to read the bytes into
						BYTE *buffer = new BYTE[longTmp1];
						// A new engine for executing the method call
						ILMEngine *engine;
						// An IDANotifier created from the engine
						IDAUntilNotifier *notifier;
						
						if (buffer != 0) {
							if (SUCCEEDED(status = codeStream->readBytes(buffer, longTmp1, NULL))) {
								if (SUCCEEDED(status = m_pReader->createEngine(&engine))) {
									if (SUCCEEDED(status = engine->initNotify(buffer, longTmp1, &notifier)))
									{
										CComQIPtr<ILMEngine2, &IID_ILMEngine2> engine2(engine);
										if( engine2 != NULL )
											engine2->setParentEngine( this );
										PUSH_COM(notifier);
									} else {
										// initNotify !SUCCEEDED
										engine->Release();
										engine = NULL;
										delete [] buffer;
									}
								} else {
									// Engine create !SUCCEEDED
									delete [] buffer;
								}
							} else {
								// Read !SUCCEEDED
								delete [] buffer;
							}
						} else {
							status = E_OUTOFMEMORY;
						}
					}
				}
				break;
				
			case 37:
				// Execute: "call Statics.triggerEvent(DXMEvent, Behavior)"
				// AUTOGENERATED
				instrTrace("call Statics.triggerEvent(DXMEvent, Behavior)");
				METHOD_CALL_2(
					staticStatics,
					TriggerEvent,
					(IDAEvent*)USE_COM(1),
					(IDABehavior*)USE_COM(2)
				);
				FREE_COM;
				FREE_COM;
				break;
				
			case 38:
				// Execute: "push DXMEvent Statics.appTriggeredEvent()"
				// AUTOGENERATED
				instrTrace("push DXMEvent Statics.appTriggeredEvent()");
				METHOD_CALL_1(
					staticStatics,
					AppTriggeredEvent,
					(IDAEvent**)RET_COM_ADDR
				);
				PUSH_COM(RET_COM);
				break;
				
			case 39:
				// Execute: "call Engine.callScript(java.lang.String, java.lang.String)"
				// USER GENERATED
				instrTrace("call Engine.callScript(java.lang.String, java.lang.String)");
				
				// Call script synchronously
				status = callScriptOnPage(
					USE_STRING(1),
					USE_STRING(2)
					);
				FREE_STRING;
				FREE_STRING;
				
				status = S_OK;
				break;
				
			case 40:
				// Execute: "push ImageBvr ImageBvr.applyBitmapEffect(IUnknown, DXMEvent)"
				// AUTOGENERATED
				instrTrace("push ImageBvr ImageBvr.applyBitmapEffect(IUnknown, DXMEvent)");
				METHOD_CALL_3(
					(IDAImage*)USE_COM(1),
					ApplyBitmapEffect,
					(IUnknown*)USE_COM(2),
					(IDAEvent*)USE_COM(3),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 41:
				// Execute: "push IUnknown Engine.getElement(java.lang.String)"
				// USER GENERATED
				instrTrace("push IUnknown Engine.getElement(java.lang.String)");
				status = getElementOnPage(
					USE_STRING(1),
					(IUnknown**)RET_COM_ADDR
				);
				FREE_STRING;
				PUSH_COM(RET_COM);
				break;
				
			case 42:
				// Execute: "push GeometryBvr Statics.unionArray(GeometryBvr[])"
				// AUTOGENERATED
				instrTrace("push GeometryBvr Statics.unionArray(GeometryBvr[])");
				METHOD_CALL_3(
					staticStatics,
					UnionGeometryArrayEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDAGeometry**)USE_COM_ARRAY(1),
					(IDAGeometry**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 43:
				// Execute: "push Path2Bvr Statics.polydrawPath(Point2Bvr[], NumberBvr[])"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.polydrawPath(Point2Bvr[], NumberBvr[])");
				METHOD_CALL_5(
					staticStatics,
					PolydrawPathEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDAPoint2**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDANumber**)USE_COM_ARRAY(2),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 44:
				// Execute: "push ImageBvr Statics.textImage(StringBvr, FontStyleBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.textImage(StringBvr, FontStyleBvr)");
				METHOD_CALL_3(
					staticStatics,
					StringImageAnim,
					(IDAString*)USE_COM(1),
					(IDAFontStyle*)USE_COM(2),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 45:
				// Execute: "push ImageBvr Statics.textImage(java.lang.String, FontStyleBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.textImage(java.lang.String, FontStyleBvr)");
				METHOD_CALL_3(
					staticStatics,
					StringImage,
					USE_STRING(1),
					(IDAFontStyle*)USE_COM(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 46:
				// Execute: "push Path2Bvr Statics.textPath(StringBvr, FontStyleBvr)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.textPath(StringBvr, FontStyleBvr)");
				METHOD_CALL_3(
					staticStatics,
					StringPathAnim,
					(IDAString*)USE_COM(1),
					(IDAFontStyle*)USE_COM(2),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 47:
				// Execute: "push ImageBvr ImageBvr.clipPolygon(Point2Array)"
				// AUTOGENERATED
				instrTrace("push ImageBvr ImageBvr.clipPolygon(Point2Array)");
				METHOD_CALL_3(
					(IDAImage*)USE_COM(1),
					ClipPolygonImageEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDAPoint2**)USE_COM_ARRAY(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 48:
				// Execute: "push ImageBvr Statics.radialGradientPolygon(ColorBvr, ColorBvr, Point2Array, double)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.radialGradientPolygon(ColorBvr, ColorBvr, Point2Array, double)");
				METHOD_CALL_6(
					staticStatics,
					RadialGradientPolygonEx,
					(IDAColor*)USE_COM(1),
					(IDAColor*)USE_COM(2),
					USE_COM_ARRAY_LENGTH(1),
					(IDAPoint2**)USE_COM_ARRAY(1),
					USE_DOUBLE(1),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_DOUBLE(1);
				FREE_COM;
				FREE_COM;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 49:
				// Execute: "push ImageBvr Statics.radialGradientPolygon(ColorBvr, ColorBvr, Point2Array, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push ImageBvr Statics.radialGradientPolygon(ColorBvr, ColorBvr, Point2Array, NumberBvr)");
				METHOD_CALL_6(
					staticStatics,
					RadialGradientPolygonAnimEx,
					(IDAColor*)USE_COM(1),
					(IDAColor*)USE_COM(2),
					USE_COM_ARRAY_LENGTH(1),
					(IDAPoint2**)USE_COM_ARRAY(1),
					(IDANumber*)USE_COM(3),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_COM;
				FREE_COM;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 50:
				// Execute: "push Path2Bvr Statics.polyline(Point2Array)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.polyline(Point2Array)");
				METHOD_CALL_3(
					staticStatics,
					PolylineEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDAPoint2**)USE_COM_ARRAY(1),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 51:
				// Execute: "push Path2Bvr Statics.polydrawPath(Point2Array, NumberArray)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.polydrawPath(Point2Array, NumberArray)");
				METHOD_CALL_5(
					staticStatics,
					PolydrawPathEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDAPoint2**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDANumber**)USE_COM_ARRAY(2),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 52:
				// Execute: "push Point2Array Statics.point2Array(DoubleArray)"
				// USER GENERATED
				instrTrace("push Point2Array Statics.point2Array(DoubleArray)");
				{
					// Get length of array
					longTmp1 = longTmp2 = doubleArrayLen/2;
					// Create array of that size
					comArrayTmp1 = comArrayTmp2 = new IUnknown*[longTmp1];
					if (comArrayTmp1 != 0) {
				
						// Create Point2Bvr for each double
						double *tmpDouble = doubleArray;
						while (longTmp2-- && SUCCEEDED(status)) {
							doubleTmp1 = *tmpDouble++;
							doubleTmp2 = *tmpDouble++;
							status = staticStatics->Point2(doubleTmp1, doubleTmp2, (IDAPoint2**)comArrayTmp2++);
						}
				
						// Push array onto comArray stack
						PUSH_COM_ARRAY(comArrayTmp1);
						// Push length onto array length stack
						PUSH_COM_ARRAY_LENGTH(longTmp1);
					} else {
						status = E_OUTOFMEMORY;
					}
				}
				break;
				
			case 53:
				// Execute: "push Point2Array Statics.point2Array(Point2Bvr[])"
				// USER GENERATED
				instrTrace("push Point2Array Statics.point2Array(Point2Bvr[])");
				// NULL OP
				break;
				
			case 54:
				// Execute: "push Vector3Array Statics.vector3Array(DoubleArray)"
				// USER GENERATED
				instrTrace("push Vector3Array Statics.vector3Array(DoubleArray)");
				{
					// Get length of array
					longTmp1 = longTmp2 = doubleArrayLen/3;
					// Create array of that size
					comArrayTmp1 = comArrayTmp2 = new IUnknown*[longTmp1];
					if (comArrayTmp1 != 0) {
				
						// Create Vector3Bvr for each double
						double *tmpDouble = doubleArray;
						while (longTmp2-- && SUCCEEDED(status)) {
							doubleTmp1 = *tmpDouble++;
							doubleTmp2 = *tmpDouble++;
							doubleTmp3 = *tmpDouble++;
							status = staticStatics->Vector3(doubleTmp1, doubleTmp2, doubleTmp3, (IDAVector3**)comArrayTmp2++);
						}
				
						// Push array onto comArray stack
						PUSH_COM_ARRAY(comArrayTmp1);
						// Push length onto array length stack
						PUSH_COM_ARRAY_LENGTH(longTmp1);
					} else {
						status = E_OUTOFMEMORY;
					}
				}
				break;
				
			case 55:
				// Execute: "push Vector3Array Statics.vector3Array(Vector3Bvr[])"
				// USER GENERATED
				instrTrace("push Vector3Array Statics.vector3Array(Vector3Bvr[])");
				// NULL OP
				break;
				
			case 56:
				// Execute: "push Vector2Array Statics.vector2Array(DoubleArray)"
				// USER GENERATED
				instrTrace("push Vector2Array Statics.vector2Array(DoubleArray)");
				{
					// Get length of array
					longTmp1 = longTmp2 = doubleArrayLen/2;
					// Create array of that size
					comArrayTmp1 = comArrayTmp2 = new IUnknown*[longTmp1];
					if (comArrayTmp1 != 0) {
				
						// Create Vector2Bvr for each double
						double *tmpDouble = doubleArray;
						while (longTmp2-- && SUCCEEDED(status)) {
							doubleTmp1 = *tmpDouble++;
							doubleTmp2 = *tmpDouble++;
							status = staticStatics->Vector2(doubleTmp1, doubleTmp2, (IDAVector2**)comArrayTmp2++);
						}
				
						// Push array onto comArray stack
						PUSH_COM_ARRAY(comArrayTmp1);
						// Push length onto array length stack
						PUSH_COM_ARRAY_LENGTH(longTmp1);
					} else {
						status = E_OUTOFMEMORY;
					}
				}
				break;
				
			case 57:
				// Execute: "push Vector2Array Statics.vector2Array(Vector2Bvr[])"
				// USER GENERATED
				instrTrace("push Vector2Array Statics.vector2Array(Vector2Bvr[])");
				// NULL OP
				break;
				
			case 58:
				// Execute: "push Transform2Bvr Statics.transform3x2(NumberArray)"
				// AUTOGENERATED
				instrTrace("push Transform2Bvr Statics.transform3x2(NumberArray)");
				METHOD_CALL_3(
					staticStatics,
					Transform3x2AnimEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					(IDATransform2**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 59:
				// Execute: "push Transform3Bvr Statics.transform4x4(NumberArray)"
				// AUTOGENERATED
				instrTrace("push Transform3Bvr Statics.transform4x4(NumberArray)");
				METHOD_CALL_3(
					staticStatics,
					Transform4x4AnimEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					(IDATransform3**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 60:
				// Execute: "push Path2Bvr Statics.cubicBSplinePath(Point2Array, NumberArray)"
				// AUTOGENERATED
				instrTrace("push Path2Bvr Statics.cubicBSplinePath(Point2Array, NumberArray)");
				METHOD_CALL_5(
					staticStatics,
					CubicBSplinePathEx,
					USE_COM_ARRAY_LENGTH(1),
					(IDAPoint2**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDANumber**)USE_COM_ARRAY(2),
					(IDAPath2**)RET_COM_ADDR
				);
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 61:
				// Execute: "push NumberArray Statics.numberArray(DoubleArray)"
				// USER GENERATED
				{
					instrTrace("push NumberArray Statics.numberArray(DoubleArray)");
					// Get length of array
					longTmp1 = longTmp2 = doubleArrayLen;
					// Create array of that size
					comArrayTmp1 = comArrayTmp2 = new IUnknown*[longTmp1];
					if (comArrayTmp1 != 0) {
				
						// Create NumberBvr for each double
						double *tmpDouble = doubleArray;
						while (longTmp2-- && SUCCEEDED(status)) {
							status = staticStatics->DANumber(*tmpDouble++, (IDANumber**)comArrayTmp2++);
						}
				
						// Push array onto comArray stack
						PUSH_COM_ARRAY(comArrayTmp1);
						// Push length onto array length stack
						PUSH_COM_ARRAY_LENGTH(longTmp1);
					} else {
						status = E_OUTOFMEMORY;
					}
				}
				break;
				
			case 62:
				// Execute: "push NumberArray Statics.numberArray(NumberBvr[])"
				// USER GENERATED
				instrTrace("push NumberArray Statics.numberArray(NumberBvr[])");
				// NULL OP
				break;
				
			case 63:
				// Execute: "push Point3Array Statics.point3Array(DoubleArray)"
				// USER GENERATED
				instrTrace("push Point3Array Statics.point3Array(DoubleArray)");
				{
					// Get length of array
					longTmp1 = longTmp2 = doubleArrayLen/3;
					// Create array of that size
					comArrayTmp1 = comArrayTmp2 = new IUnknown*[longTmp1];
					if (comArrayTmp1 != 0) {
				
						// Create Point2Bvr for each double
						double *tmpDouble = doubleArray;
						while (longTmp2-- && SUCCEEDED(status)) {
							doubleTmp1 = *tmpDouble++;
							doubleTmp2 = *tmpDouble++;
							doubleTmp3 = *tmpDouble++;
							status = staticStatics->Point3(doubleTmp1, doubleTmp2, doubleTmp3, (IDAPoint3**)comArrayTmp2++);
						}
				
						// Push array onto comArray stack
						PUSH_COM_ARRAY(comArrayTmp1);
						// Push length onto array length stack
						PUSH_COM_ARRAY_LENGTH(longTmp1);
					} else {
						status = E_OUTOFMEMORY;
					}
				}
				break;
				
			case 64:
				// Execute: "push Point3Array Statics.point3Array(Point3Bvr[])"
				// USER GENERATED
				instrTrace("push Point3Array Statics.point3Array(Point3Bvr[])");
				// NULL OP
				break;
				
			case 65:
				// Execute: "push NumberBvr Statics.bSpline(int, NumberArray, NumberArray, NumberArray, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push NumberBvr Statics.bSpline(int, NumberArray, NumberArray, NumberArray, NumberBvr)");
				METHOD_CALL_9(
					staticStatics,
					NumberBSplineEx,
					USE_LONG(1),
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDANumber**)USE_COM_ARRAY(2),
					USE_COM_ARRAY_LENGTH(3),
					(IDANumber**)USE_COM_ARRAY(3),
					(IDANumber*)USE_COM(1),
					(IDANumber**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_COM;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 66:
				// Execute: "push Point2Bvr Statics.bSpline(int, NumberArray, Point2Array, NumberArray, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Point2Bvr Statics.bSpline(int, NumberArray, Point2Array, NumberArray, NumberBvr)");
				METHOD_CALL_9(
					staticStatics,
					Point2BSplineEx,
					USE_LONG(1),
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDAPoint2**)USE_COM_ARRAY(2),
					USE_COM_ARRAY_LENGTH(3),
					(IDANumber**)USE_COM_ARRAY(3),
					(IDANumber*)USE_COM(1),
					(IDAPoint2**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_COM;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 67:
				// Execute: "push Point3Bvr Statics.bSpline(int, NumberArray, Point3Array, NumberArray, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Point3Bvr Statics.bSpline(int, NumberArray, Point3Array, NumberArray, NumberBvr)");
				METHOD_CALL_9(
					staticStatics,
					Point3BSplineEx,
					USE_LONG(1),
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDAPoint3**)USE_COM_ARRAY(2),
					USE_COM_ARRAY_LENGTH(3),
					(IDANumber**)USE_COM_ARRAY(3),
					(IDANumber*)USE_COM(1),
					(IDAPoint3**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_COM;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 68:
				// Execute: "push Vector2Bvr Statics.bSpline(int, NumberArray, Vector2Array, NumberArray, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Vector2Bvr Statics.bSpline(int, NumberArray, Vector2Array, NumberArray, NumberBvr)");
				METHOD_CALL_9(
					staticStatics,
					Vector2BSplineEx,
					USE_LONG(1),
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDAVector2**)USE_COM_ARRAY(2),
					USE_COM_ARRAY_LENGTH(3),
					(IDANumber**)USE_COM_ARRAY(3),
					(IDANumber*)USE_COM(1),
					(IDAVector2**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_COM;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 69:
				// Execute: "push Vector3Bvr Statics.bSpline(int, NumberArray, Vector3Array, NumberArray, NumberBvr)"
				// AUTOGENERATED
				instrTrace("push Vector3Bvr Statics.bSpline(int, NumberArray, Vector3Array, NumberArray, NumberBvr)");
				METHOD_CALL_9(
					staticStatics,
					Vector3BSplineEx,
					USE_LONG(1),
					USE_COM_ARRAY_LENGTH(1),
					(IDANumber**)USE_COM_ARRAY(1),
					USE_COM_ARRAY_LENGTH(2),
					(IDAVector3**)USE_COM_ARRAY(2),
					USE_COM_ARRAY_LENGTH(3),
					(IDANumber**)USE_COM_ARRAY(3),
					(IDANumber*)USE_COM(1),
					(IDAVector3**)RET_COM_ADDR
				);
				FREE_LONG(1);
				FREE_COM;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				FREE_COM_ARRAY;
				PUSH_COM(RET_COM);
				break;
				
			case 70:
				// Execute: "push DoubleArray Statics.doubleArray(int[])"
				// USER GENERATED
				instrTrace("push DoubleArray Statics.doubleArray(int[])");
				{
					// Get the length of the array
					if (SUCCEEDED(status = readLong(&longTmp1))) {
						// Remember it
						doubleArrayLen = longTmp1;
						// Ensure double array is big enough and copy ints to it
						if (SUCCEEDED(status = ensureDoubleArrayCap(longTmp1))) {
							double *to = doubleArray;
							while (longTmp1-- && SUCCEEDED(status)) {
								if (SUCCEEDED(status = readSignedLong(&longTmp2)))
									*to++ = (double)longTmp2;
							}
						}
					}
				}
				break;
				
			case 71:
				// Execute: "push DoubleArray Statics.doubleArray(float[])"
				// USER GENERATED
				instrTrace("push DoubleArray Statics.doubleArray(float[])");
				{
					// Get the length of the array
					if (SUCCEEDED(status = readLong(&longTmp1))) {
						// Remember it
						doubleArrayLen = longTmp1;
						// Ensure double array is big enough and copy floats to it
						if (SUCCEEDED(status = ensureDoubleArrayCap(longTmp1))) {
							double *to = doubleArray;
							while (longTmp1-- && SUCCEEDED(status)) {			
								status = readFloat(&floatTmp1);
								*to++ = (double)floatTmp1;
							}
							
						}
					}
				}
				break;
				
			case 72:
				// Execute: "push DoubleArray Statics.doubleArray(double[])"
				// USER GENERATED
				instrTrace("push DoubleArray Statics.doubleArray(double[])");
				{
					// Get the length of the array
					if (SUCCEEDED(status = readLong(&longTmp1))) {
						// Remember it
						doubleArrayLen = longTmp1;
						// Ensure double array is big enough and copy doubles to it
						if (SUCCEEDED(status = ensureDoubleArrayCap(longTmp1))) {
							double *to = doubleArray;
							while (longTmp1-- && SUCCEEDED(status))
								status = readDouble(to++);
						}
					}
				}
				break;
				
			case 73:
				// Execute: "push DoubleArray Statics.doubleArrayOffset2(int[])"
				// USER GENERATED
				instrTrace("push DoubleArray Statics.doubleArrayOffset2(int[])");
				{
					// Get the length of the array
					if (SUCCEEDED(status = readLong(&longTmp1))) {
						// Remember it
						doubleArrayLen = longTmp1;
						// Initialize offsets
						doubleTmp1 = 0;
						doubleTmp2 = 0;
						// Ensure double array is big enough and copy adjusted ints to it
						if (SUCCEEDED(status = ensureDoubleArrayCap(longTmp1))) {
							double *to = doubleArray;
							longTmp1 /= 2;
							while (longTmp1-- && SUCCEEDED(status)) {
								if (SUCCEEDED(status = readSignedLong(&longTmp2))) {
									doubleTmp1 = *to++ = (double)longTmp2 + doubleTmp1;
									if (SUCCEEDED(status = readSignedLong(&longTmp2))) 
										doubleTmp2 = *to++ = (double)longTmp2 + doubleTmp2;
								}
							}
						}
					}
				}
				break;
				
			case 74:
				// Execute: "push DoubleArray Statics.doubleArrayPathSpecial(int[])"
				// USER GENERATED
				instrTrace("push DoubleArray Statics.doubleArrayPathSpecial(int[])");
				{
					// Get the count of 6's indices (subtract 1 for the initial size)
					if (SUCCEEDED(status = readLong(&longTmp1))) {
						longTmp1--;
						// Get the size of the actual array
						if (SUCCEEDED(status = readSignedLong(&longTmp2))) {
							// Remember it
							doubleArrayLen = longTmp2;
							// Ensure double array is big enough and fill it with 4's and 6's
							if (SUCCEEDED(status = ensureDoubleArrayCap(longTmp2))) {
								// Put in the 4's
								double *to = doubleArray;
								while (longTmp2--)
									*to++ = 4.0;
								
								// Now read in the indices of the 6's and set them
								while (longTmp1-- && SUCCEEDED(status)) {
									if (SUCCEEDED(status = readSignedLong(&longTmp2)))
										doubleArray[longTmp2] = 6.0;
								}
							}
						}
					}
				}
				break;
				
			case 75:
				// Execute: "push DoubleArray Statics.doubleArrayOffset3(int[])"
				// USER GENERATED
				instrTrace("push DoubleArray Statics.doubleArrayOffset3(int[])");
				{
					// Get the length of the array
					if (SUCCEEDED(status = readLong(&longTmp1))) {
						// Remember it
						doubleArrayLen = longTmp1;
						// Initialize offsets
						doubleTmp1 = 0;
						doubleTmp2 = 0;
						doubleTmp3 = 0;
						// Ensure double array is big enough and copy adjusted ints to it
						if (SUCCEEDED(status = ensureDoubleArrayCap(longTmp1))) {
							double *to = doubleArray;
							longTmp1 /= 3;
							while (longTmp1-- && SUCCEEDED(status)) {
								if (SUCCEEDED(status = readSignedLong(&longTmp2))) {
									doubleTmp1 = *to++ = (double)longTmp2 + doubleTmp1;
									if (SUCCEEDED(status = readSignedLong(&longTmp2))) {
										doubleTmp2 = *to++ = (double)longTmp2 + doubleTmp2;
										if (SUCCEEDED(status = readSignedLong(&longTmp2)))
											doubleTmp3 = *to++ = (double)longTmp2 + doubleTmp3;
									}
								}
							}
						}
					}
				}
				break;
				
			case 76:
				// Execute: "push DoubleArray Statics.doubleArrayOffset(int[])"
				// USER GENERATED
				instrTrace("push DoubleArray Statics.doubleArrayOffset(int[])");
				{
					// Get the length of the array
					if (SUCCEEDED(status = readLong(&longTmp1))) {
						// Remember it
						doubleArrayLen = longTmp1;
						// Initialize offset
						doubleTmp1 = 0;
						// Ensure double array is big enough and copy adjusted ints to it
						if (SUCCEEDED(status = ensureDoubleArrayCap(longTmp1))) {
							double *to = doubleArray;
							while (longTmp1-- && SUCCEEDED(status)) {
								if (SUCCEEDED(status = readSignedLong(&longTmp2)))
									doubleTmp1 = *to++ = (double)longTmp2 + doubleTmp1;
							}
						}
					}
				}
				break;
				
			case 77:
				// Execute: "push double NumberBvr.extractDouble()"
				// USER GENERATED
				instrTrace("push double NumberBvr.extractDouble()");
				METHOD_CALL_1(
					(IDANumber*)USE_COM(1),
					Extract,
					PUSH_DOUBLE_ADDR
				);
				FREE_COM;
				break;
				
			case 78:
				// Execute: "push ImageBvr Statics.importImageColorKey(java.lang.String, short, short, short)"
				// USER GENERATED
				instrTrace("push ImageBvr Statics.importImageColorKey(java.lang.String, short, short, short)");
				IMPORT_METHOD_CALL_5(
					staticStatics,
					ImportImageColorKey,
					USE_STRING(1),
					(BYTE)USE_LONG(1),
					(BYTE)USE_LONG(2),
					(BYTE)USE_LONG(3),
					(IDAImage**)RET_COM_ADDR
				);
				FREE_LONG(3);
				FREE_STRING;
				PUSH_COM(RET_COM);
				break;
				
			case 79:
				// Execute: "push ImportationResult Statics.importImageColorKey(java.lang.String, ImageBvr, short, short, short)"
				// USER GENERATED
				instrTrace("push ImportationResult Statics.importImageColorKey(java.lang.String, ImageBvr, short, short, short)");
				IMPORT_METHOD_CALL_6(
					staticStatics,
					ImportImageAsyncColorKey,
					USE_STRING(1),
					(IDAImage*)USE_COM(1),
					(BYTE)USE_LONG(1),
					(BYTE)USE_LONG(2),
					(BYTE)USE_LONG(3),
					(IDAImportationResult**)RET_COM_ADDR
				);
				FREE_LONG(3);
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 80:
				// Execute: "push UserData Statics.userData(IUnknown)"
				// AUTOGENERATED
				instrTrace("push UserData Statics.userData(IUnknown)");
				METHOD_CALL_2(
					staticStatics,
					UserData,
					(IUnknown*)USE_COM(1),
					(IDAUserData**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 81:
				// Execute: "call Statics.pixelConstructionMode(boolean)"
				// AUTOGENERATED
				instrTrace("call Statics.pixelConstructionMode(boolean)");
				METHOD_CALL_1(
					staticStatics,
					put_PixelConstructionMode,
					USE_LONG_AS_BOOL(1)
				);
				FREE_LONG(1);
				break;
				
			case 82:
				// Execute: "call Engine.setSound(SoundBvr)"
				// USER GENERATED
				instrTrace("call Engine.setSound(SoundBvr)");
				if (m_pSound)
					m_pSound->SwitchTo((IDASound*)USE_COM(1));
				else {
					m_pSound = (IDASound *)USE_COM(1);
					m_pSound->AddRef();
				}
				FREE_COM;
				break;
				
			case 83:
				// Execute: "push boolean BooleanBvr.extractBoolean()"
				// USER GENERATED
				instrTrace("push boolean BooleanBvr.extractBoolean()");
				// A VARIANT_BOOL is a short that is -1 for true, 0 for false
				METHOD_CALL_1(
					(IDABoolean*)USE_COM(1),
					Extract,
					&tmpBool1
				);
				FREE_COM;
				PUSH_LONG(-tmpBool1);
				break;
				
			case 84:
				// Execute: "push IUnknown UserData.extractIUnknown()"
				// AUTOGENERATED
				instrTrace("push IUnknown UserData.extractIUnknown()");
				METHOD_CALL_1(
					(IDAUserData*)USE_COM(1),
					get_Data,
					(IUnknown**)RET_COM_ADDR
				);
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 85:
				// Execute: "push java.lang.String StringBvr.extractString()"
				// USER GENERATED
				instrTrace("push java.lang.String StringBvr.extractString()");
				METHOD_CALL_1(
					(IDAString*)USE_COM(1),
					Extract,
					&bstrTmp1
				);
				FREE_COM;
				bstrTmp2 = SysAllocString(bstrTmp1);
				PUSH_STRING(bstrTmp2);
				
				if (bstrTmp2 == 0)
					status = STATUS_ERROR;
				break;
				
			case 86:
				// Execute: "push IUnknown Engine.createObject(java.lang.String)"
				// USER GENERATED
				instrTrace("push IUnknown Engine.createObject(java.lang.String)");
				status = createObject(
					USE_STRING(1),
					(IUnknown**)RET_COM_ADDR
				);
				FREE_STRING;
				PUSH_COM(RET_COM);
				break;
				
			case 87:
				// Execute: "call Engine.initVarArg(java.lang.String)"
				// USER GENERATED
				bstrTmp1 = SysAllocString(USE_STRING(1));
				if (bstrTmp1 == 0)
					status = STATUS_ERROR;
				if (SUCCEEDED(status)) {
					status = initVariantArgFromString(
						bstrTmp1,
						&varArgs[nextVarArg++]
					);
				}
				FREE_STRING;
				break;
				
			case 88:
				// Execute: "call Engine.initVarArg(java.lang.String, int)"
				// USER GENERATED
				// WARNING: Possibly bad to call this if it grabs the string without copying!
				// TODO: Check what this really does, and see if we need to copy the
				// arg before we pass it in
				status = initVariantArg(
					USE_STRING(1),
					(VARTYPE)USE_LONG(1),
					&varArgs[nextVarArg++]
				);
				FREE_LONG(1);
				FREE_STRING;
				break;
				
			case 89:
				// Execute: "call Engine.initVarArg(IUnknown)"
				// USER GENERATED
				status = initVariantArgFromIUnknown(
					(IUnknown*)USE_COM(1),
					VT_UNKNOWN,
					&varArgs[nextVarArg++]
				);
				// Don't release here, release will be done when varArg is released
				POP_COM_NO_FREE;
				break;
				
			case 90:
				// Execute: "call Engine.initVarArg(int)"
				// USER GENERATED
				status = initVariantArgFromLong(
					USE_LONG(1),
					VT_I4,
					&varArgs[nextVarArg++]
				);
				FREE_LONG(1);
				break;
				
			case 91:
				// Execute: "call Engine.initVarArg(double)"
				// USER GENERATED
				status = initVariantArgFromDouble(
					USE_DOUBLE(1),
					VT_R8,
					&varArgs[nextVarArg++]
				);
				FREE_DOUBLE(1);
				break;
				
			case 92:
				// Execute: "call IUnknown.invokeMethod(java.lang.String, VarArgs)"
				// USER GENERATED
				instrTrace("call IUnknown.invokeMethod(java.lang.String, VarArgs)");
				status = invokeDispMethod(
					(IUnknown*)USE_COM(1),
					USE_STRING(1),
					DISPATCH_METHOD,
					nextVarArg,
					varArgs,
					&varArgReturn
				);
				FREE_STRING;
				FREE_COM;
				
				if (SUCCEEDED(status))
					status = releaseVarArgs();
				
				break;
				
			case 93:
				// Execute: "call IUnknown.putProperty(java.lang.String, VarArgs)"
				// USER GENERATED
				instrTrace("call IUnknown.putProperty(java.lang.String, VarArgs)");
				status = invokeDispMethod(
					(IUnknown*)USE_COM(1),
					USE_STRING(1),
					DISPATCH_PROPERTYPUT,
					nextVarArg,
					varArgs,
					&varArgReturn
				);
				FREE_STRING;
				FREE_COM;
				
				if (SUCCEEDED(status))
					status = releaseVarArgs();
				
				break;
				
			case 94:
				// Execute: "push double IUnknown.getDoubleProperty(java.lang.String, VarArgs)"
				// USER GENERATED
				instrTrace("call IUnknown.getDoubleProperty(java.lang.String, VarArgs)");
				status = invokeDispMethod(
					(IUnknown*)USE_COM(1),
					USE_STRING(1),
					DISPATCH_PROPERTYGET,
					nextVarArg,
					varArgs,
					&varArgReturn
				);
				FREE_STRING;
				FREE_COM;
				
				if (SUCCEEDED(status) &&
					SUCCEEDED(VariantChangeType(&varArgReturn, &varArgReturn, 0, VT_R8))) {
					
					PUSH_DOUBLE(varArgReturn.dblVal);
					status = releaseVarArgs();
				}
				
				break;
				
			case 95:
				// Execute: "push java.lang.String IUnknown.getStringProperty(java.lang.String, VarArgs)"
				// USER GENERATED
				instrTrace("push java.lang.String IUnknown.getStringProperty(java.lang.String, VarArgs)");
				status = invokeDispMethod(
					(IUnknown*)USE_COM(1),
					USE_STRING(1),
					DISPATCH_PROPERTYGET,
					nextVarArg,
					varArgs,
					&varArgReturn
				);
				FREE_STRING;
				FREE_COM;
				
				if (SUCCEEDED(status) &&
					SUCCEEDED(VariantChangeType(&varArgReturn, &varArgReturn, 0, VT_BSTR))) {
				
					bstrTmp1 = SysAllocString(varArgReturn.bstrVal);
					PUSH_STRING(bstrTmp1);
				
					if (bstrTmp1 == 0)
						status = STATUS_ERROR;
				}
				
				if (SUCCEEDED(status))
					status = releaseVarArgs();
				
				break;
				
			case 96:
				// Execute: "push IUnknown IUnknown.getIUnknownProperty(java.lang.String, VarArgs)"
				// USER GENERATED
				instrTrace("push IUnknown IUnknown.getIUnknownProperty(java.lang.String, VarArgs)");
				status = invokeDispMethod(
					(IUnknown*)USE_COM(1),
					USE_STRING(1),
					DISPATCH_PROPERTYGET,
					nextVarArg,
					varArgs,
					&varArgReturn
				);
				FREE_STRING;
				FREE_COM;
				
				if (SUCCEEDED(status) &&
					SUCCEEDED(VariantChangeType(&varArgReturn, &varArgReturn, 0, VT_UNKNOWN))) {
				
					if (varArgReturn.punkVal != 0) {
						varArgReturn.punkVal->AddRef();
						PUSH_COM(varArgReturn.punkVal);
						status = releaseVarArgs();
					} else
						status = STATUS_ERROR;
				}
				
				break;
				
			case 97:
				// Execute: "push double IUnknown.invokeDoubleMethod(java.lang.String, VarArgs)"
				// USER GENERATED
				instrTrace("push double IUnknown.invokeDoubleMethod(java.lang.String, VarArgs)");
				status = invokeDispMethod(
					(IUnknown*)USE_COM(1),
					USE_STRING(1),
					DISPATCH_METHOD,
					nextVarArg,
					varArgs,
					&varArgReturn
				);
				FREE_STRING;
				FREE_COM;
				
				if (SUCCEEDED(status) &&
					SUCCEEDED(VariantChangeType(&varArgReturn, &varArgReturn, 0, VT_R8))) {
				
					PUSH_DOUBLE(varArgReturn.dblVal);
					status = releaseVarArgs();
				}
								
				break;
				
			case 98:
				// Execute: "push java.lang.String IUnknown.invokeStringMethod(java.lang.String, VarArgs)"
				// USER GENERATED
				instrTrace("push java.lang.String IUnknown.invokeStringMethod(java.lang.String, VarArgs)");
				status = invokeDispMethod(
					(IUnknown*)USE_COM(1),
					USE_STRING(1),
					DISPATCH_METHOD,
					nextVarArg,
					varArgs,
					&varArgReturn
				);
				FREE_STRING;
				FREE_COM;
				
				if (SUCCEEDED(status) &&
					SUCCEEDED(status = VariantChangeType(&varArgReturn, &varArgReturn, 0, VT_BSTR))) {
				
					bstrTmp1 = SysAllocString(varArgReturn.bstrVal);
					PUSH_STRING(bstrTmp1);
				
					if (bstrTmp1 == 0)
						status = STATUS_ERROR;
				}
				
				if (SUCCEEDED(status))
					status = releaseVarArgs();
				
				break;
				
			case 99:
				// Execute: "push IUnknown IUnknown.invokeIUnknownMethod(java.lang.String, VarArgs)"
				// USER GENERATED
				instrTrace("push IUnknown IUnknown.invokeIUnknownMethod(java.lang.String, VarArgs)");
				status = invokeDispMethod(
					(IUnknown*)USE_COM(1),
					USE_STRING(1),
					DISPATCH_METHOD,
					nextVarArg,
					varArgs,
					&varArgReturn
				);
				FREE_STRING;
				FREE_COM;
				
				if (SUCCEEDED(status) &&
					SUCCEEDED(status = VariantChangeType(&varArgReturn, &varArgReturn, 0, VT_UNKNOWN))) {
				
					if (varArgReturn.punkVal != 0) {
						varArgReturn.punkVal->AddRef();
						PUSH_COM(varArgReturn.punkVal);
						status = releaseVarArgs();
					} else
						status = STATUS_ERROR;
				}
				
				break;
				
			case 100:
				// Execute: "push int IUnknown.invokeIntMethod(java.lang.String, VarArgs)"
				// USER GENERATED
				instrTrace("push int IUnknown.invokeIntMethod(java.lang.String, VarArgs)");
				status = invokeDispMethod(
					(IUnknown*)USE_COM(1),
					USE_STRING(1),
					DISPATCH_METHOD,
					nextVarArg,
					varArgs,
					&varArgReturn
				);
				FREE_STRING;
				FREE_COM;
				
				if (SUCCEEDED(status) &&
					SUCCEEDED(status = VariantChangeType(&varArgReturn, &varArgReturn, 0, VT_I4))) {
				
					PUSH_LONG(varArgReturn.lVal);
					status = releaseVarArgs();
				}
				
				break;
				
			case 101:
				// Execute: "push int IUnknown.getIntProperty(java.lang.String, VarArgs)"
				// USER GENERATED
				instrTrace("push int IUnknown.getIntProperty(java.lang.String, VarArgs)");
				status = invokeDispMethod(
					(IUnknown*)USE_COM(1),
					USE_STRING(1),
					DISPATCH_PROPERTYGET,
					nextVarArg,
					varArgs,
					&varArgReturn
				);
				FREE_STRING;
				FREE_COM;
				
				if (SUCCEEDED(status) &&
					SUCCEEDED(status = VariantChangeType(&varArgReturn, &varArgReturn, 0, VT_I4))) {
				
					PUSH_LONG(varArgReturn.lVal);
					status = releaseVarArgs();
				}
				
				break;
				
			case 102:
				// Execute: "call Engine.putNoExports(boolean)"
				// USER GENERATED
				instrTrace("call Engine.putNoExports(boolean)");
				status = m_pReader->put_NoExports(
					USE_LONG_AS_BOOL(1)
				);
				FREE_LONG(1);
				break;
				
			case 103:
				// Execute: "push boolean Engine.getNoExports()"
				// USER GENERATED
				instrTrace("push boolean Engine.getNoExports()");
				status = m_pReader->get_NoExports(
					&tmpBool1
				);
				PUSH_LONG(-tmpBool1);
				break;
				
			case 104:
				// Execute: "call Engine.putAsync(boolean)"
				// USER GENERATED
				instrTrace("call Engine.putAsync(boolean)");
				status = m_pReader->put_Async(
					USE_LONG_AS_BOOL(1)
				);
				FREE_LONG(1);
				break;
				
			case 105:
				// Execute: "push boolean Engine.getAsync()"
				// USER GENERATED
				instrTrace("push boolean Engine.getAsync()");
				status = m_pReader->get_Async(
					&tmpBool1
				);
				PUSH_LONG(-tmpBool1);
				break;
				
			case 106:
				// Execute: "push Statics.engine"
				// USER GENERATED
				instrTrace("push Statics.engine");
				/*
				GetUnknown()->AddRef();
				PUSH_COM((ILMEngine*)this);
				*/
				m_pWrapper->AddRef();
				PUSH_COM( m_pWrapper );
				break;
				
			case 107:
				// Execute: "push Behavior Engine.getBehavior(java.lang.String, Behavior)"
				// USER GENERATED
				instrTrace("push Behavior Engine.getBehavior(java.lang.String, Behavior)");
				METHOD_CALL_3(
					(ILMEngine*)USE_COM(1),
					GetBehavior,
					USE_STRING(1),
					(IDABehavior *)USE_COM(2),
					(IDABehavior**)RET_COM_ADDR
				);
				FREE_COM;
				FREE_STRING;
				FREE_COM;
				PUSH_COM(RET_COM);
				break;
				
			case 108:
				// Execute: "call Engine.setImage(Engine, ImageBvr)"
				// USER GENERATED
				instrTrace("call Engine.setImage(Engine, ImageBvr)");
				{
					//CLMEngine *engine = (CLMEngine*)(ILMEngine *)USE_COM(1);
					ILMEngineExecute *pExecute;
					status = getExecuteFromUnknown( USE_COM(1), &pExecute );
					if( SUCCEEDED( status ) )
					{
						IDAImage *pImage;
						status = USE_COM(2)->QueryInterface( IID_IDAImage, (void**)&pImage );
						if( SUCCEEDED( status ) )
						{
							pExecute->SetImage( pImage );
							pExecute->Release();
							pImage->Release();
						}
						else
							pExecute->Release();
					}
				
					FREE_COM;
					FREE_COM;
				}
				break;
				
			case 109:
				// Execute: "call Engine.exportBvr(Engine, java.lang.String, Behavior)"
				// USER GENERATED
				instrTrace("call Engine.exportBvr(Engine, java.lang.String, Behavior)");
				{
					//CLMEngine *engine = (CLMEngine*)(ILMEngine*)USE_COM(1);
					ILMEngineExecute *pExecute;
					status = getExecuteFromUnknown( USE_COM(1), &pExecute );
					if( SUCCEEDED( status ) )
					{
						IDABehavior *pBvr;
						status = USE_COM(2)->QueryInterface( IID_IDABehavior, (void**)&pBvr );
						if( SUCCEEDED( status ) )
						{
							//status = engine->m_exportTable->AddBehavior(USE_STRING(1), pBvr);
							status = pExecute->ExportBehavior( USE_STRING(1), pBvr );
							pBvr->Release();
							pExecute->Release();
						}
						else
							pExecute->Release();
					}
				
					FREE_STRING;
					FREE_COM;
					FREE_COM;
				}
				break;
				
			case 110:
				// Execute: "call Engine.setSound(Engine, SoundBvr)"
				// USER GENERATED
				instrTrace("call Engine.setSound(Engine, SoundBvr)");
				{
					//CLMEngine *engine = (CLMEngine*)(ILMEngine*)USE_COM(1);
					ILMEngineExecute *pExecute;
					status = getExecuteFromUnknown( USE_COM(1), &pExecute );
					if( SUCCEEDED( status ) )
					{
						IDASound *pSound;
						status = USE_COM(2)->QueryInterface( IID_IDASound, (void**)&pSound );
						if( SUCCEEDED( status ) )
						{
							
							pSound->Release();
							pExecute->Release();
						}
						else
							pExecute->Release();
					}
				
					FREE_COM;
					FREE_COM;
				}
				break;
				
			case 111:
				// Execute: "call ViewerControl.setTimerSource(int)"
				// USER GENERATED
				
				instrTrace("call ViewerControl.setTimerSource(int)");
				METHOD_CALL_1(
					(IDAViewerControl*)USE_COM(1),
					put_TimerSource,
					(DA_TIMER_SOURCE)USE_LONG(1)
				);
				FREE_LONG(1);
				FREE_COM;
				break;
				
			case 112:
				// Execute: "call Engine.callScriptAsync(java.lang.String, java.lang.String)"
				// USER GENERATED
				instrTrace("call Engine.callScriptAsync(java.lang.String, java.lang.String)");
				
				{
					// Call script asynchronously
					CLMEngineScriptData *scriptData = new CLMEngineScriptData();
					scriptData->scriptSourceToInvoke = USE_STRING(1);
					scriptData->scriptLanguage = USE_STRING(2);
					scriptData->event = NULL;
					scriptData->eventData = NULL;
					PostMessage(m_workerHwnd, WM_LMENGINE_SCRIPT_CALLBACK, (WPARAM)this, (LPARAM)scriptData);
					
					// The scriptData fields will be freed when the message is processed
					POP_STRING_NO_FREE;
					POP_STRING_NO_FREE;
				}
				break;
				
			case 113:
				// Execute: "call Engine.callScriptAsyncEvent(java.lang.String, java.lang.String, DXMEvent)"
				// USER GENERATED
				instrTrace("call Engine.callScriptAsyncEvent(java.lang.String, java.lang.String, DXMEvent)");
				
				{	
					// Call script asynchronously
					CLMEngineScriptData *scriptData = new CLMEngineScriptData();
					scriptData->scriptSourceToInvoke = USE_STRING(1);
					scriptData->scriptLanguage = USE_STRING(2);
					
					// This event will be triggered when the message is received and the
					// script has been executed.
					scriptData->event = (IDAEvent *)USE_COM(1);
					scriptData->eventData = NULL;
					PostMessage(m_workerHwnd, WM_LMENGINE_SCRIPT_CALLBACK, (WPARAM)this, (LPARAM)scriptData);
					
					// The scriptData fields will be freed when the message is processed
					POP_COM_NO_FREE;
					POP_STRING_NO_FREE;
					POP_STRING_NO_FREE;
				}
				break;
				
			case 114:
				// Execute: "call Engine.callScriptAsyncEventData(java.lang.String, java.lang.String, DXMEvent, Behavior)"
				// USER GENERATED
				instrTrace("call Engine.callScriptAsyncEventData(java.lang.String, java.lang.String, DXMEvent, Behavior)");
				
				{
					// Call script asynchronously
					CLMEngineScriptData *scriptData = new CLMEngineScriptData();
					scriptData->scriptSourceToInvoke = USE_STRING(1);
					scriptData->scriptLanguage = USE_STRING(2);
					
					// This event will be triggered when the message is received and the
					// script has been executed.
					scriptData->event = (IDAEvent *)USE_COM(1);
					scriptData->eventData = (IDABehavior *)USE_COM(2);
					PostMessage(m_workerHwnd, WM_LMENGINE_SCRIPT_CALLBACK, (WPARAM)this, (LPARAM)scriptData);
					
					// The scriptData fields will be freed when the message is processed
					POP_COM_NO_FREE;
					POP_COM_NO_FREE;
					POP_STRING_NO_FREE;
					POP_STRING_NO_FREE;
				}
				break;
				
			case 115:
				// Execute: "call Engine.setPauseEvent(DXMEvent, boolean)"
				// USER GENERATED
				
				//set the stop event on the engine pointed to by the first argument. com 1
				instrTrace("call Engine.setPauseEvent(DXMEvent, boolean)");
				
				{
					//CLMEngine *engine = (CLMEngine*)(ILMEngine*)USE_COM(1);
					ILMEngineExecute *pExecute;
					status = getExecuteFromUnknown( USE_COM(1), &pExecute );
					if( SUCCEEDED( status ) )
					{
						IDAEvent *pEvent;
						status = USE_COM(2)->QueryInterface( IID_IDAEvent, (void**)&pEvent );
						if( SUCCEEDED( status ) )
						{
							pExecute->SetStopEvent( pEvent, ( USE_LONG(1) == 1 )?TRUE:FALSE );
							pExecute->Release();
							pEvent->Release();
						}
						else
							pExecute->Release();
					}
				
					FREE_COM;
					FREE_COM;
					FREE_LONG(1);
				}
				break;
				
			case 116:
				// Execute: "call Engine.setPlayEvent(DXMEvent, boolean)"
				// USER GENERATED
				
				//set the start event on the engine pointed to by the first argument. com 1
				instrTrace("call Engine.setPlayEvent(DXMEvent, boolean)");
				{
					//CLMEngine *engine = (CLMEngine*)(ILMEngine*)USE_COM(1);
					ILMEngineExecute *pExecute;
					status = getExecuteFromUnknown( USE_COM(1), &pExecute );
					if( SUCCEEDED( status ) )
					{
						IDAEvent *pEvent;
						USE_COM(2)->QueryInterface( IID_IDAEvent, (void**)&pEvent );
						if( SUCCEEDED( status ) )
						{
							pExecute->SetStartEvent( pEvent, ( USE_LONG(1) == 1 )?TRUE:FALSE );
							pEvent->Release();
							pExecute->Release();
						}
						else
							pExecute->Release();
					}
				
				}
				FREE_COM;
				FREE_COM;
				FREE_LONG(1);
				break;
				
			case 117:
				// Execute: "push double Engine.getCurrentTime()"
				// USER GENERATED
				instrTrace("push double Engine.getCurrentTime()");
				
				{
					//get the engine pointed to by the first argument
					//CLMEngine *engine = (CLMEngine*)(ILMEngine*)USE_COM(1);
					ILMEngine2 *pEngine;
					status = getEngine2FromUnknown( USE_COM(1), &pEngine );
					if( SUCCEEDED( status ) )
					{
						double currentTime = -1.0;
						if( SUCCEEDED( pEngine->getCurrentGraphTime( &currentTime ) ) )
						{
							PUSH_DOUBLE( currentTime );
						} else {
							PUSH_DOUBLE( -1.0 );
						}
						pEngine->Release();
					}
				}
				//free the engine from the com stack
				FREE_COM;
				break;
				
			case 118:
				// Execute: "push boolean Engine.isStandaloneStreaming()"
				// USER GENERATED
				instrTrace("push boolean Engine.isStandaloneStreaming()");
				if(m_pReader != NULL )
				{
					//we can't do this without adding a method to ILMReader. blech.
					//if( ((CLMReader*)m_pReader)->isStandaloneStreaming() )
					IDAViewerControl *pViewerControl = NULL;
					m_pReader->get_ViewerControl( &pViewerControl );
					if( pViewerControl != NULL )
					{
						pViewerControl->Release();
						PUSH_LONG( 1 );
					}
					else
					{
						PUSH_LONG( 0 );
					}
				}
				else
				{
					PUSH_LONG( 0 );
				}
				break;
				
			case 119:
				// Execute: "push double Engine.getDAVersion()"
				// USER GENERATED
				instrTrace("push double Engine.getDAVersion()");
				{
					PUSH_DOUBLE( getDAVersionAsDouble() );
				}
				
				break;
				
			case 120:
				// Execute: "call ViewerControl.stopModel()"
				// USER GENERATED
				instrTrace("call ViewerControl.stopModel()");
				
				{
					IDAViewerControl *pViewerControl = (IDAViewerControl*)USE_COM(1);
					IDAView *pView = NULL;
					status = pViewerControl->get_View( &pView );
					if( SUCCEEDED( status ) )
					{
						status = pView->StopModel();
						pView->Release();
					}
				}
				//don't kill LMRT if we fail to get the view.
				status = S_OK;
				
				FREE_COM;
				break;
				
			case 121:
				// Execute: "push double Engine.staticGetCurrentTime()"
				// USER GENERATED
				instrTrace("push double Engine.staticGetCurrentTime()");
				{
					
					double currentTime = -1.0;
					if( m_pParentEngine != NULL )
					{
						if( SUCCEEDED( m_pParentEngine->getCurrentGraphTime( &currentTime ) ) )
						{
							PUSH_DOUBLE( currentTime );
						} else {
							PUSH_DOUBLE( -1.0 );
						}
					} else {
						if( SUCCEEDED( getCurrentGraphTime( &currentTime ) ) )
						{
							PUSH_DOUBLE( currentTime );
						} else {
							PUSH_DOUBLE( -1.0 );
						}
					}
					
					//PUSH_DOUBLE(-1.0);
				}
				break;
				
			case 122:
				// Execute: "call Engine.disableAutoAntialias()"
				// USER GENERATED
				instrTrace("call Engine.disableAutoAntialias()");

				if( m_pParentEngine != NULL )
					m_pParentEngine->disableAutoAntialias();
				else
					disableAutoAntialias();
				break;
				
			case 123:
				// Execute: "push double Engine.getLMRTVersion()"
				// USER GENERATED
				instrTrace("push double Engine.getLMRTVersion()");
				
				PUSH_DOUBLE( getLMRTVersionAsDouble() );

				break;
				
			case 124:
				// Execute: "call Engine.ensureBlockSize(int)"
				// USER GENERATED
				instrTrace("call Engine.ensureBlockSize(int)");
				
				if( m_pParentEngine != NULL )
					m_pParentEngine->ensureBlockSize( USE_LONG(1) );
				else
					ensureBlockSize( USE_LONG(1) );
				
				FREE_LONG(1);
				break;
				
			default:
				status = E_INVALIDARG;
				break;
			}
			break;
		
		default:
			status = E_INVALIDARG;
			break;
		}
		
		// END AUTOGENERATED

		LeaveCriticalSection(&m_CriticalSection);
		
		if (status == E_NOTIMPL)
			status = S_OK;
	}

#ifdef COM_DEBUG
	Assert(_com_count == 0, "COM count is not 0 at end of parsing");
#endif

	if (status == E_PENDING) 
		codeStream->Revert();

	return status;
}

void CLMEngine::releaseAll()
{
	// Release all com objects left on the stack, in arrays, and in temp store

	// Do the com stack
	while (comTop > comStack)
		FREE_COM_TEST;

	// Do the com array stack
	while (comArrayTop > comArrayStack)
		FREE_COM_ARRAY;

	// Do the com store
	for (int i=0; i<comStoreSize; i++) {
		if (comStore[i] != 0) {
			comStore[i]->Release();
			comStore[i] = NULL;
		}
	}

	// Release varArgs
	releaseVarArgs();
}

HRESULT CLMEngine::releaseVarArgs()
{
	HRESULT hr;

	for (int i=0; i<nextVarArg; i++)
		VariantClear(&varArgs[i]);

	nextVarArg = 0;

	VariantClear(&varArgReturn);

	return S_OK;
}

void CLMEngine::freeCOMArray(IUnknown** array, long length)
{
	if (array == 0)
		return;

	for (IUnknown **tmp = array; length--; ) {
		(*tmp)->Release();
		*tmp++ = NULL;
	}

	delete[] array;
}

HRESULT CLMEngine::ensureDoubleArrayCap(long cap)
{
	if (doubleArray && doubleArrayCap < cap) {
		// Allocated one is too small. Get rid of it
		delete[] doubleArray;
		doubleArray = 0;
	}

	if (doubleArray == 0) {
		// Not allocated yet
		doubleArray = new double[cap];

		if (doubleArray == 0)
			return E_UNEXPECTED;

		doubleArrayCap = cap;
	}

	return S_OK;
}


STDMETHODIMP CLMEngine::Notify(IDABehavior *eventData,
					IDABehavior *curRunningBvr,
					IDAView *curView,
					IDABehavior **ppBvr)
{
	if (!ppBvr)
		return E_POINTER;

	if (!curRunningBvr)
		return E_POINTER;

	if (!notifier)
		return E_UNEXPECTED;
	
// 	MessageBox(NULL, "Notify!!", "CLMNotifier", MB_OK);

	// Put the args into the temp variables
	comStore[0] = eventData;
	comStore[1] = curRunningBvr;

	eventData->AddRef();
	curRunningBvr->AddRef();

	// Reset the code stream to start from the beginning
	((ByteArrayStream*)codeStream)->reset();

	// Execute the code stream
	HRESULT hr = execute();

	if (SUCCEEDED(hr)) {
		// Pop the resulting behavior into the return variable, with no release
		*ppBvr = (IDABehavior*)POP_COM_NO_FREE;
	}

	// Release all COM objects
	releaseAll();

	return hr;
}

HRESULT CLMEngine::validateHeader()
{
	// Check for two possibilites:
	//   Header starts with LMReader
	//   Header starts with 200 bytes containing valid .x header with LMReader somewhere in it

	BYTE head[] = "xof 0302bin 0032{183C2599-0480-11d1-87EA-00C04FC29D46}";
	BYTE text[] = "LMReader";

	int count = 54;

	int checkLMReader = 0;
	int checkXHeader = 0;
	int checkLMReaderFailed = 0;

	BYTE *headp = head;
	BYTE *textp = text;

	HRESULT status = S_OK;

	codeStream->Commit();

	while (count-- && status == S_OK) {
		BYTE	byte;
		if (SUCCEEDED(status = codeStream->readByte(&byte))) {
			
			if (checkXHeader >= 0 && checkXHeader < 54) {
				if (*headp == byte) {
					headp++;
					checkXHeader++;
				} else {
					checkXHeader = -1;
				}
			}
			
			if (checkLMReader >= 0 && checkLMReader < 8) {
				if (*textp == byte) {
					textp++;
					checkLMReader++;
				} else {
					checkLMReader = -1;
				}
			}
			
			if (checkLMReader == 8)
				return S_OK;
		}
	}

	if (status == E_PENDING) 
		codeStream->Revert();

	if (!SUCCEEDED(status))
		return status;

	if (checkXHeader == 54)
		return S_OK;

	return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\control\fgcallb.h ===
EXTERN_GUID(IID_IAMFilterGraphCallback,0x56a868fd,0x0ad4,0x11ce,0xb0,0xa3,0x0,0x20,0xaf,0x0b,0xa7,0x70);

interface IAMFilterGraphCallback : IUnknown
{
    // S_OK means rendering complete, S_FALSE means "retry now".
    virtual HRESULT UnableToRender(IPin *pPin) = 0;

    // other methods?
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\dll\main.cpp ===
/*******************************************************************************
  Copyright (c) 1995-96 Microsoft Corporation

  Abstract:

    Initialization

 *******************************************************************************/

#include <..\behaviors\headers.h>
#include "control\lmctrl.h"
#include "..\behaviors\lmfactory.h"
//#include "..\behaviors\avoidfollow.h"
#include "..\behaviors\autoeffect.h"
//#include "..\behaviors\jump.h"
#include "..\chrome\include\resource.h"
#include "..\chrome\src\headers.h"
#include "..\chrome\include\action.h"
#include "..\chrome\include\factory.h"
#include "..\chrome\include\colorbvr.h"
#include "..\chrome\include\rotate.h"
#include "..\chrome\include\scale.h"
#include "..\chrome\include\move.h"
#include "..\chrome\include\path.h"
#include "..\chrome\include\number.h"
#include "..\chrome\include\set.h"
#include "..\chrome\include\actorbvr.h"
#include "..\chrome\include\effect.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_LMReader, CLMReader)
    OBJECT_ENTRY(CLSID_LMEngine, CLMEngine)
    OBJECT_ENTRY(CLSID_LMBehaviorFactory, CLMBehaviorFactory)
//    OBJECT_ENTRY(CLSID_LMAvoidFollowBvr, CAvoidFollowBvr) // punted for V1
    OBJECT_ENTRY(CLSID_LMAutoEffectBvr, CAutoEffectBvr)
//    OBJECT_ENTRY(CLSID_LMJumpBvr, CJumpBvr) //punted for V 1
    OBJECT_ENTRY(CLSID_CrBehaviorFactory, CCrBehaviorFactory)
    OBJECT_ENTRY(CLSID_CrColorBvr, CColorBvr)
    OBJECT_ENTRY(CLSID_CrRotateBvr, CRotateBvr)
    OBJECT_ENTRY(CLSID_CrScaleBvr, CScaleBvr)
    OBJECT_ENTRY(CLSID_CrMoveBvr, CMoveBvr)
    OBJECT_ENTRY(CLSID_CrPathBvr, CPathBvr)
    OBJECT_ENTRY(CLSID_CrNumberBvr, CNumberBvr)
    OBJECT_ENTRY(CLSID_CrSetBvr, CSetBvr)
    OBJECT_ENTRY(CLSID_CrActorBvr, CActorBvr)
    OBJECT_ENTRY(CLSID_CrEffectBvr, CEffectBvr)
	OBJECT_ENTRY(CLSID_CrActionBvr, CActionBvr)
END_OBJECT_MAP()

HINSTANCE  hInst;

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        hInst = hInstance;
        DisableThreadLibraryCalls(hInstance);
        _Module.Init(ObjectMap, hInstance);
    }        
    else if (dwReason == DLL_PROCESS_DETACH) {
        _Module.Term();
//#ifdef DEBUGMEM
//		_CrtDumpMemoryLeaks();
//#endif
	
    }
    
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\idl\lmbvrdispid.h ===
#ifndef __LMBEHAVIORDISPID_H_
#define __LMBEHAVIORDISPID_H_
//*********************************************************************************
//
// File: lmbvrdispid.h
// Author: kurtj
// Date Created: 11/6/98
//
//
//*********************************************************************************

//avoidfollow Behavior dispids
#define DISPID_AVOIDFOLLOWBVR_BASE 1
#define DISPID_IAVOIDFOLLOWBVR_ANIMATES             (DISPID_AVOIDFOLLOWBVR_BASE + 0)
#define DISPID_IAVOIDFOLLOWBVR_RADIUS				(DISPID_AVOIDFOLLOWBVR_BASE + 1)
#define DISPID_IAVOIDFOLLOWBVR_TARGET				(DISPID_AVOIDFOLLOWBVR_BASE + 2)
#define DISPID_IAVOIDFOLLOWBVR_VELOCITY				(DISPID_AVOIDFOLLOWBVR_BASE + 3)
#define DISPID_IAVOIDFOLLOWBVR_BUILDBVRFRAGS		(DISPID_AVOIDFOLLOWBVR_BASE + 4)

//autoeffect Behavior dispids
#define DISPID_AUTOEFFECTBVR_BASE 1
#define DISPID_IAUTOEFFECTBVR_ANIMATES				(DISPID_AUTOEFFECTBVR_BASE + 0)
#define DISPID_IAUTOEFFECTBVR_TYPE					(DISPID_AUTOEFFECTBVR_BASE + 1)
#define DISPID_IAUTOEFFECTBVR_CAUSE					(DISPID_AUTOEFFECTBVR_BASE + 2)
#define DISPID_IAUTOEFFECTBVR_SPAN					(DISPID_AUTOEFFECTBVR_BASE + 3)
#define DISPID_IAUTOEFFECTBVR_SIZE					(DISPID_AUTOEFFECTBVR_BASE + 4)
#define DISPID_IAUTOEFFECTBVR_RATE					(DISPID_AUTOEFFECTBVR_BASE + 5)
#define DISPID_IAUTOEFFECTBVR_GRAVITY				(DISPID_AUTOEFFECTBVR_BASE + 6)
#define DISPID_IAUTOEFFECTBVR_WIND					(DISPID_AUTOEFFECTBVR_BASE + 7)
#define DISPID_IAUTOEFFECTBVR_FILLCOLOR				(DISPID_AUTOEFFECTBVR_BASE + 8)
#define DISPID_IAUTOEFFECTBVR_STROKECOLOR			(DISPID_AUTOEFFECTBVR_BASE + 9)
#define DISPID_IAUTOEFFECTBVR_OPACITY				(DISPID_AUTOEFFECTBVR_BASE + 10)
#define DISPID_IAUTOEFFECTBVR_BUILDBVRFRAGS			(DISPID_AUTOEFFECTBVR_BASE + 11)
#define DISPID_IAUTOEFFECTBVR_MOUSEEVENT			(DISPID_AUTOEFFECTBVR_BASE + 12)

// Jump Behavior dispids
#define DISPID_JUMPBVR_BASE					1
#define DISPID_IJUMPBVR_INTERVAL			(DISPID_JUMPBVR_BASE+1)
#define DISPID_IJUMPBVR_RANGE				(DISPID_JUMPBVR_BASE+2)
#define DISPID_IJUMPBVR_BUILDBVRFRAGS		(DISPID_JUMPBVR_BASE+3)


//*********************************************************************************
//
// End of File
//
//*********************************************************************************
#endif //__LMBEHAVIORDISPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\idl\makefile.inc ===
$(SDKDIR)\lmrt.h : $(O)\lmrt.h
    copy /v $? $@

$(SDKDIR)\lmrt.tlb : $(O)\lmrt.tlb
    copy /v $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\control\lmctrl.cpp ===
// lmctrl.cpp : Implementation of CLMReader
#include "..\behaviors\headers.h"
#include "lmctrl.h"

#include <winuser.h>
#include <hlink.h>
#include <mshtml.h>
#include <uuids.h> //for dshow uuids
#include <mmreg.h> //for WAVE_FORMAT_MPEGLAYER3

/////////////////////////////////////////////////////////////////////////////
// LMReader

/**
* Constructor
*/

CLMReader::CLMReader()
{
	m_bNoExports = VARIANT_TRUE;
	m_bAsync = VARIANT_FALSE;
	m_Src = NULL;
	m_pEngine = NULL;
	m_AsyncBlkSize = -1;
	m_AsyncDelay = -1;
	engineList = NULL;
    m_bWindowOnly  = 0;
	m_pViewerControl = 0;
	m_clsidDownloaded = GUID_NULL;
	m_bAutoCodecDownloadEnabled = FALSE;
}

/**
* Destructor.
* Releases all the engines created by this reader.
*/
CLMReader::~CLMReader()
{/*
	int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
	tmpFlag |= (_CRTDBG_ALLOC_MEM_DF | _CRTDBG_CHECK_ALWAYS_DF | _CRTDBG_CHECK_CRT_DF);
	_CrtSetDbgFlag(tmpFlag);
	*/

	if (engineList) {
		LMEngineList *item = engineList->next;
		LMEngineList *next;
		
		delete engineList;
		while (item != NULL) {
			next = item->next;
			item->engine->Release();
			delete item;
			item = next;
		}
	}

	// Release the viewer control
	if (m_pViewerControl)
		m_pViewerControl->Release();

	/*
#ifdef DEBUGMEM
	_CrtDumpMemoryLeaks();
#endif
	*/

}

/**
*  Returns true if this reader is running in the standAlone streaming player, and
*  false otherwise.
*/
bool CLMReader::isStandaloneStreaming()
{
	return ( m_pViewerControl != NULL );
}

/**
* Returns the Image from the last Engine created (not counting UntilNotifier engines)
*/   
STDMETHODIMP CLMReader::get_Image(IDAImage **pVal)
{
	if (m_pEngine != NULL)
		return m_pEngine->get_Image(pVal);
	else
		return E_FAIL;
}

/**
* Returns the Sound from the last Engine created (not counting UntilNotifier engines)
*/
STDMETHODIMP CLMReader::get_Sound(IDASound **pVal)
{
	if (m_pEngine != NULL)
		return m_pEngine->get_Sound(pVal);
	else
		return E_FAIL;
}

/**
* Returns the last Engine created (not counting UntilNotifier engines)
*/
STDMETHODIMP CLMReader::get_Engine(ILMEngine **pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
	
	if (m_pEngine)
		m_pEngine->AddRef();
	*pVal = (ILMEngine *)m_pEngine;
    return S_OK;
}

/**
* Creates an Engine that is set up to be fed instructions asynchronously.
* Instructions are fed to the Engine through the OnDataAvailable mechanism
*/
STDMETHODIMP CLMReader::createAsyncEngine(/*[out, retval]*/ ILMEngine **pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

	HRESULT hr = createEngine(&m_pEngine);

	if (SUCCEEDED(hr)) {
		if (!SUCCEEDED(hr = m_pEngine->SetAsyncBlkSize(m_AsyncBlkSize))) 
			return hr;

		if (!SUCCEEDED(hr = m_pEngine->SetAsyncDelay(m_AsyncDelay)))
			return hr;

		hr = m_pEngine->initAsync();

		CComQIPtr<ILMCodecDownload, &IID_ILMCodecDownload> codecDl(m_pEngine);
		if( codecDl != NULL )
		{
			codecDl->setAutoCodecDownloadEnabled( m_bAutoCodecDownloadEnabled );
		}
	
		if (SUCCEEDED(hr)) {
			m_pEngine->AddRef();
			*pVal = (ILMEngine *)m_pEngine;
		}

	}

	return hr;
}

/**
* Creates an Engine and adds it to the list of Engines for release in the destructor.
* Returns the Engine and does not set m_pEngine.
*/
STDMETHODIMP CLMReader::createEngine(/*[out, retval]*/ ILMEngine **pVal )
{
	if (!pVal) {
		return E_POINTER;
	}

	ILMEngine *pEngine;

	HRESULT hr = CoCreateInstance(
		CLSID_LMEngine,
		NULL,
		CLSCTX_INPROC_SERVER,
		IID_ILMEngine,
		(void **) &pEngine);

	// Add new engine to list of engines
	if (!engineList) {
		engineList = new LMEngineList;
		if (!engineList) {
			pEngine->Release();
			return E_OUTOFMEMORY;
		}
		engineListTail = engineList;
	}

	if (!(engineListTail->next = new LMEngineList)) {
		pEngine->Release();
		return E_OUTOFMEMORY;
	}
	engineListTail = engineListTail->next;
	engineListTail->next = NULL;
	engineListTail->engine = pEngine;

	if (SUCCEEDED(hr)) {	
		pEngine->put_Reader(this);	

		pEngine->put_ClientSite(m_spClientSite);
		*pVal = pEngine;

		CComQIPtr<ILMCodecDownload, &IID_ILMCodecDownload> codecDL(pEngine);
		if( codecDL != NULL )
		{
			codecDL->setAutoCodecDownloadEnabled( m_bAutoCodecDownloadEnabled );
		}
	}

	return hr;
}

/**
* Executes the instructions contained in the file referenced by the given URL.
* Creates and returns an engine to do the execution.
* Parameters blkSize and delay are used in asynchronous reads.
*/
STDMETHODIMP CLMReader::_execute(BSTR url, LONG blkSize, LONG delay, ILMEngine **pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

	HRESULT hr;
	
	hr = createEngine(&m_pEngine);

	if (SUCCEEDED(hr)) {
		if (!SUCCEEDED(hr = m_pEngine->SetAsyncBlkSize(blkSize))) 
			return hr;

		if (!SUCCEEDED(hr = m_pEngine->SetAsyncDelay(delay)))
			return hr;

		hr = m_pEngine->runFromURL(url);
	
		if (SUCCEEDED(hr)) {
			m_pEngine->AddRef();
			*pVal = (ILMEngine *)m_pEngine;
		}
	}

	return hr;
}

/**
* Executes the instructions contained in the file referenced by the URL.
* Returns the Engine created to do the execution.
*/
STDMETHODIMP CLMReader::execute(/*[in, string]*/ BSTR url, /*[out, retval]*/ILMEngine **pVal)//Pointer to the URL from which the object should be loaded 
{
	return _execute(url, m_AsyncBlkSize, m_AsyncDelay, pVal);
}

// Property handling

/**
* Gets the value of the NoExports flag
*/
STDMETHODIMP CLMReader::get_NoExports(VARIANT_BOOL *pbNoExports)
{
	if (!pbNoExports)
		return E_POINTER;

	*pbNoExports = m_bNoExports;
	return S_OK;
}

/**
* Puts the value of the NoExports flag
*/
STDMETHODIMP CLMReader::put_NoExports(VARIANT_BOOL bNoExports)
{
	m_bNoExports = bNoExports;
	return S_OK;
}

/**
* Gets the value of the Async flag
*/
STDMETHODIMP CLMReader::get_Async(VARIANT_BOOL *pbAsync)
{
	if (!pbAsync)
		return E_POINTER;

	*pbAsync = m_bAsync;
	return S_OK;
}

/**
* Puts the value of the Async flag
*/
STDMETHODIMP CLMReader::put_Async(VARIANT_BOOL bAsync)
{
	m_bAsync = bAsync;
	return S_OK;
}

/**
* Gets the string passed as the SRC parameter to the control
*/
STDMETHODIMP CLMReader::get_Src(BSTR *pBstr)
{
	if (!pBstr)
		return E_POINTER;

	*pBstr = m_Src;
	return S_OK;
}

/**
* Puts an external ViewerControl created in cases like the standalone player
*/
STDMETHODIMP CLMReader::put_ViewerControl(IDAViewerControl *viewerControl)
{
	if (!viewerControl)
		return E_POINTER;

	// Release any current viewer control
	if (m_pViewerControl)
		m_pViewerControl->Release();

	m_pViewerControl = viewerControl;

	// Grab a ref
	if (m_pViewerControl)
		m_pViewerControl->AddRef();

	return S_OK;
}

/**
* gets the version string for lmrt
*/
STDMETHODIMP CLMReader::get_VersionString( BSTR *versionString )
{
	if( versionString == NULL )
		return E_POINTER;

	char *charVersion = VERSION;
	(*versionString) = A2BSTR(charVersion);

	return (*versionString != NULL)?(S_OK):(E_OUTOFMEMORY);
}

/**
* Tells this reader and all of its engines to release their handles
* on the filter graph if they have any
**/
STDMETHODIMP CLMReader::releaseFilterGraph()
{
	if (engineList) {
		LMEngineList *item = engineList->next;
		ILMEngine2 *engine2;

		while (item != NULL) 
		{
			if( SUCCEEDED( item->engine->QueryInterface( IID_ILMEngine2, (void**) &engine2) ) )
			{
				engine2->releaseFilterGraph();
				engine2->Release();
			}

			item = item->next;
		}
	}
	return S_OK;
}
/**
* Gets the external ViewerControl
*/
STDMETHODIMP CLMReader::get_ViewerControl(IDAViewerControl **viewerControl)
{
	if (!viewerControl)
		return E_POINTER;

	*viewerControl = m_pViewerControl;

	if (m_pViewerControl)
		m_pViewerControl->AddRef();

	return S_OK;
}

/**
* Override IPersistStreamInitImpl
* Implements instantiation of control from stream
*/
STDMETHODIMP CLMReader::Load( LPSTREAM pStm)//Pointer to the stream from which the object should be loaded 
{
	HRESULT hr = createEngine(&m_pEngine);
	if (SUCCEEDED(hr))
		hr = m_pEngine->runFromStream(pStm);
	return hr;
}

/**
* Override IPersistPropertyBagImpl
* Implements instantiation of control using parameters
*/
STDMETHODIMP CLMReader::Load(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog)
{
    VARIANT v;

	VariantInit(&v);
	v.vt = VT_BOOL;
    v.boolVal = TRUE;
	if (SUCCEEDED(pPropertyBag->Read(L"NOEXPORTS", &v, pErrorLog))) 
		m_bNoExports = v.boolVal;
	VariantClear(&v);

	VariantInit(&v);
	v.vt = VT_BOOL;
	v.boolVal = VARIANT_TRUE;
	if (SUCCEEDED(pPropertyBag->Read(L"ASYNC", &v, pErrorLog)))
		m_bAsync = v.boolVal;
	VariantClear(&v);

	VariantInit(&v);
	v.vt = VT_I4;
	v.lVal = 0L;
	if (SUCCEEDED(pPropertyBag->Read(L"ASYNC_READ_BLOCK_SIZE", &v, pErrorLog)))
		m_AsyncBlkSize = v.lVal;
	VariantClear(&v);

	VariantInit(&v);
	v.vt = VT_I4;
	v.lVal = 0L;
	if (SUCCEEDED(pPropertyBag->Read(L"ASYNC_DELAY_MILLIS", &v, pErrorLog)))
		m_AsyncDelay = v.lVal;
	VariantClear(&v);

	VariantInit(&v);
	v.vt = VT_BSTR;
	v.bstrVal = NULL;
	if (SUCCEEDED(pPropertyBag->Read(L"SRC", &v, pErrorLog)))
		m_Src = v.bstrVal;

	VariantInit(&v);
	v.vt = VT_BOOL;
	v.boolVal = VARIANT_FALSE;
	if(SUCCEEDED(pPropertyBag->Read(L"ENABLE_CODEC_DOWNLOAD", &v, pErrorLog)))
		m_bAutoCodecDownloadEnabled = (v.boolVal==VARIANT_TRUE) ? TRUE : FALSE;

	HRESULT hr = S_OK;

	if (m_Src != NULL) {
		ILMEngine *pEngine;
		hr = _execute(m_Src, m_AsyncBlkSize, m_AsyncDelay, &pEngine);

		if (SUCCEEDED(hr))
			// We don't need the engine here so just release it.
			pEngine->Release();
	}

	VariantClear(&v);

	return hr;
}


// Override IObjectSafetyImpl

STDMETHODIMP CLMReader::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
	if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
		return E_POINTER;
	HRESULT hr = S_OK;

	if (riid == IID_IDispatch)
	{
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
	}
	else if (riid == IID_IPersistPropertyBag)
	{
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_DATA;
	}
	else
	{
		*pdwSupportedOptions = 0;
		*pdwEnabledOptions = 0;
		hr = E_NOINTERFACE;
	}
	return hr;
}

STDMETHODIMP CLMReader::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{	
	// If we're being asked to set our safe for scripting or
	// safe for initialization options then oblige
	if (riid == IID_IDispatch || riid == IID_IPersistPropertyBag  || riid == IID_IPersistStreamInit)
	{
		// Store our current safety level to return in GetInterfaceSafetyOptions
		m_dwSafety = dwEnabledOptions & dwOptionSetMask;
		return S_OK;
	}

	return E_NOINTERFACE;
}

STDMETHODIMP CLMReader::InPlaceDeactivate()
{
    // This replaces the implementation in ATL's atlctl.h, and just
    // adds our shutdown code at the beginning.

	if (m_pEngine)
		m_pEngine->AbortExecution();

    // ... continue by calling the "original" deactivate.
    return IOleInPlaceObject_InPlaceDeactivate();
}

/*
 * IOleCommandTarget methods.
 */
STDMETHODIMP CLMReader::QueryStatus(const GUID* pguidCmdGroup, ULONG cCmds,
									OLECMD prgCmds[], OLECMDTEXT* pCmdText )
{
    if ( pguidCmdGroup != NULL )
	{
		// It's a nonstandard group!!
        return OLECMDERR_E_UNKNOWNGROUP;
	}

    MSOCMD*     pCmd;
    INT         c;
    HRESULT     hr = S_OK;

    // Command text is NOT SUPPORTED.
    if ( pCmdText && ( pCmdText->cmdtextf != OLECMDTEXTF_NONE ) )
	{
        pCmdText->cwActual = 0;
	}

    // Loop through each command in the ary, setting the status of each.
    for ( pCmd = prgCmds, c = cCmds; --c >= 0; pCmd++ )
    {
        // By default command status is NOT SUPPORTED.
		if (pCmd->cmdID == OLECMDID_STOP)
			pCmd->cmdf = OLECMDF_SUPPORTED;
		else
			pCmd->cmdf = 0;
	}

    return (hr);
}
        
STDMETHODIMP CLMReader::Exec(const GUID* pguidCmdGroup, DWORD nCmdID,
							 DWORD nCmdexecopt, VARIANTARG* pvaIn, VARIANTARG* pvaOut)
{
    HRESULT hr = S_OK;
	
    if ( pguidCmdGroup == NULL ) {		
        switch (nCmdID)
        {
		case OLECMDID_STOP:
			if (m_pEngine)
				m_pEngine->AbortExecution();
			break;
			
		default:
			hr = OLECMDERR_E_NOTSUPPORTED;
			break;
        }
    } else 
        hr = OLECMDERR_E_UNKNOWNGROUP;
	
    return (hr);
}

/**************************
** IAMFilterGraphCallback Methods
**********************/

//========================================================================
//
// GetAMediaType
//
// Enumerate the media types of *ppin.  If they all have the same majortype
// then set MajorType to that, else set it to CLSID_NULL.  If they all have
// the same subtype then set SubType to that, else set it to CLSID_NULL.
// If something goes wrong, set both to CLSID_NULL and return the error.
//========================================================================
HRESULT GetAMediaType( IPin * ppin, CLSID & MajorType, CLSID & SubType)
{

    HRESULT hr;
    IEnumMediaTypes *pEnumMediaTypes;

    /* Set defaults */
    MajorType = CLSID_NULL;
    SubType = CLSID_NULL;

    hr = ppin->EnumMediaTypes(&pEnumMediaTypes);

    if (FAILED(hr)) 
	{
		return hr;    // Dumb or broken filters don't get connected.
    }

    _ASSERTE (pEnumMediaTypes!=NULL);

    /* Put the first major type and sub type we see into the structure.
       Thereafter if we see a different major type or subtype then set
       the major type or sub type to CLSID_NULL, meaning "dunno".
       If we get so that both are dunno, then we might as well return (NYI).
    */

    BOOL bFirst = TRUE;

    for ( ; ; ) 
	{

		AM_MEDIA_TYPE *pMediaType = NULL;
		ULONG ulMediaCount = 0;

		/* Retrieve the next media type
		   Need to delete it when we've done.
		*/
		hr = pEnumMediaTypes->Next(1, &pMediaType, &ulMediaCount);
		_ASSERTE(SUCCEEDED(hr));
		if (FAILED(hr)) 
		{
			MajorType = CLSID_NULL;
			SubType = CLSID_NULL;
			pEnumMediaTypes->Release();
			return NOERROR;    // we can still plough on
		}

		if (ulMediaCount==0) 
		{
			pEnumMediaTypes->Release();
			return NOERROR;       // normal return
		}

		if (bFirst) 
		{
			MajorType = pMediaType[0].majortype;
			SubType = pMediaType[0].subtype;
			bFirst = FALSE;
		} else {
			if (SubType != pMediaType[0].subtype) 
			{
				SubType = CLSID_NULL;
			}
			if (MajorType != pMediaType[0].majortype) 
			{
				MajorType = CLSID_NULL;
			}
		}
	
		if (pMediaType->cbFormat != 0) 
		{
			CoTaskMemFree(pMediaType->pbFormat);
		}
		CoTaskMemFree(pMediaType);

		// stop if we have a type
		if (SubType != CLSID_NULL) 
		{
			pEnumMediaTypes->Release();
			return NOERROR;
		}
    }

    // NOTREACHED
    
} // GetAMediaType

// {6B6D0800-9ADA-11d0-A520-00A0D10129C0}
EXTERN_GUID(CLSID_NetShowSource, 
0x6b6d0800, 0x9ada, 0x11d0, 0xa5, 0x20, 0x0, 0xa0, 0xd1, 0x1, 0x29, 0xc0);

EXTERN_GUID(CLSID_SourceStub, 
0x6b6d0803, 0x9ada, 0x11d0, 0xa5, 0x20, 0x0, 0xa0, 0xd1, 0x1, 0x29, 0xc0);


/**
*  Called when the filtergraph is unable to render in the browser case.
*  This code attempts to download the codec for the pin that failed
*  to render.
**/
HRESULT CLMReader::UnableToRender( IPin *pPin )
{
	CLSID clsidWanted;
    HRESULT hr = E_NOINTERFACE;
	
    DWORD dwVerLS = 0, dwVerMS = 0;
	
	CLSID clsidMajor;
    // else get the media type exposed by this stream....
    if (FAILED(hr)) 
	{
		ATLTRACE(_T("No IComponentDownload, trying first media type\n"));
		// get the first media type from this pin....
		hr = GetAMediaType(pPin, clsidMajor, clsidWanted);
		
		if (FAILED(hr)) 
		{
			ATLTRACE(_T("Couldn't get a media type to try\n"));
			return hr;
		}
    }
	
	//Don't need to look for ourselves here

    if (clsidMajor == CLSID_NetShowSource) 
	{
		ATLTRACE(_T("auto-downloading known major type\n"));
		clsidWanted = clsidMajor;
	} else if (clsidMajor != MEDIATYPE_Video &&
			   clsidMajor != MEDIATYPE_Audio &&
			   clsidMajor != CLSID_SourceStub) 
	{
		ATLTRACE(_T("For now, we only support audio & video auto-download\n"));
		return E_FAIL;
	}

	
	if (clsidWanted == MEDIASUBTYPE_MPEG1AudioPayload) 
	{
			ATLTRACE(_T("Hack: we know we don't want to download MPEG-1 audio, try layer 3\n"));
			clsidWanted.Data1 = WAVE_FORMAT_MPEGLAYER3;
	}
	
			
	if (clsidWanted == CLSID_NULL) 
	{
		ATLTRACE(_T("Couldn't guess a CLSID to try to download\n"));
		return E_FAIL;
	}
			
	// !!! perhaps keep track of last codec we tried to download and
	// don't try again immediately, to prevent ugly looping?
	if (clsidWanted == m_clsidDownloaded) 
	{
		ATLTRACE(_T("Already thought we downloaded this codec!\n"));
				
		// fire an ERRORABORTEX here that we downloaded a codec, but it didn't do
		// any good?
		//BSTR bstrError = FormatBSTR(IDS_ERR_BROKEN_CODEC, NULL);
				
		//if (bstrError) 
		//{
			// !!! hack, should we really NotifyEvent through the graph?
		//	ProcessEvent(EC_ERRORABORTEX, VFW_E_INVALIDMEDIATYPE, (LONG) bstrError, FALSE);
		//	}
				
		return E_FAIL;
	}
			
	WCHAR guidstr[50];
	StringFromGUID2(clsidWanted, guidstr, 50);
			
	TCHAR szKeyName[60];
			
	wsprintf(szKeyName, "CLSID\\%ls", guidstr);
	CRegKey crk;
			
	LONG    lr;
	lr = crk.Open(HKEY_CLASSES_ROOT, szKeyName);
	if(ERROR_SUCCESS == lr)
	{
		crk.QueryValue(dwVerMS, _T("VerMS"));
		crk.QueryValue(dwVerLS, _T("VerLS"));
		
		// ask for a version just past what we have already....
		++dwVerLS;
		
				
		crk.Close();
	}
			
	//SetStatusMessage(NULL, IDS_DOWNLOADINGCODEC);
			
#ifdef DEBUG
			ATLTRACE(_T("Trying to download GUID %ls\n"), guidstr);
#endif
			
			
	//  This API is our friend....
	//  STDAPI CoGetClassObjectFromURL( REFCLSID rCLASSID,
	//        LPCWSTR szCODE, DWORD dwFileVersionMS, 
	//        DWORD dwFileVersionLS, LPCWSTR szTYPE,
	//        LPBINDCTX pBindCtx, DWORD dwClsContext,
	//        LPVOID pvReserved, REFIID riid, LPVOID * ppv);
	
	// issue: is this CLASSID just the same as the minor type?
			
	CComObject<CDownloadCallback> * pCallback;
	hr = CComObject<CDownloadCallback>::CreateInstance(&pCallback);

	pCallback->m_pLMR = this;
			
	if (FAILED(hr))
		return hr;
						
	IBindStatusCallback *pBSCallback;
	hr = pCallback->QueryInterface(IID_IBindStatusCallback, (void **) &pBSCallback);
		_ASSERTE(hr == S_OK);
			
	// which of these should we use?  Depends whether a BindCtx is passed in...
	// STDAPI CreateAsyncBindCtx(DWORD reserved, IBindStatusCallback *pBSCb,                       
	//                            IEnumFORMATETC *pEFetc, IBindCtx **ppBC);                   
	// STDAPI CreateAsyncBindCtxEx(IBindCtx *pbc, DWORD dwOptions, IBindStatusCallback *pBSCb, IEnumFORMATETC *pEnum,   
	//                            IBindCtx **ppBC, DWORD reserved);                                                     
			
	IBindCtx *pBindCtx = NULL; // !!!!
			
	hr = CreateAsyncBindCtx(0, pBSCallback, NULL, &pBindCtx);
			
	if (FAILED(hr)) 
	{
		ATLTRACE(_T("CreateAsyncBindCtx failed hr = %x\n"), hr);
		return hr;
	}
			
	IBaseFilter *pFilter = NULL;
			
	hr = CoGetClassObjectFromURL(clsidWanted, NULL, dwVerMS, dwVerLS, NULL,
				pBindCtx, CLSCTX_INPROC, NULL, IID_IBaseFilter,
				(void **) &pFilter);
			
	ATLTRACE(_T("CoGetClassObjectFromURL returned %x\n"), hr);
			
	if (hr == S_ASYNCHRONOUS) 
	{
		ATLTRACE(_T("Oh dear, it's asynchronous, what now?\n"));
				
		// !!! wait here until it finishes?
		for (;;) 
		{
			HANDLE ev = pCallback->m_evFinished;
					
			DWORD dwResult = MsgWaitForMultipleObjects(
				1,
				&ev,
				FALSE,
				INFINITE,
				QS_ALLINPUT);
			if (dwResult == WAIT_OBJECT_0)
				break;
					
			_ASSERTE(dwResult == WAIT_OBJECT_0 + 1);
			//  Eat messages and go round again
			MSG Message;
			while (PeekMessage(&Message,NULL,0,0,PM_REMOVE)) 
			{
				TranslateMessage(&Message);
				DispatchMessage(&Message);
			}
		}
				
		ATLTRACE(_T("Finished waiting.... m_pUnk is %x, hr = %lx\n"),
		pCallback->m_pUnk, pCallback->m_hrBinding);
				
		hr = pCallback->m_hrBinding;
				
		if (SUCCEEDED(hr)) 
		{
			hr = pCallback->m_pUnk->QueryInterface(IID_IBaseFilter, (void **) &pFilter);
		}
	}
			
	pBSCallback->Release();
	pBindCtx->Release();
			
	if (SUCCEEDED(hr)) 
	{
		pFilter->Release();     // graph will re-instantiate the filter, we hope
	} else {
		// oh well, we didn't get one.
	}
			
	if (REGDB_E_CLASSNOTREG == hr) 
	{
		ATLTRACE(_T("Hack: treating ClassNotReg as success, and hoping...."));
		hr = S_OK;
	}
			
	if (SUCCEEDED(hr)) 
	{
		m_clsidDownloaded = clsidWanted; // avoid infinite loop
	} else {
		// fire an ERRORABORTEX here that we downloaded a codec, but it didn't do
		// any good?
		/*
		BSTR bstrError = NULL;
		
		if( FACILITY_CERT == HRESULT_FACILITY( hr ) )
		{
			//bstrError = FormatBSTR( IDS_ERR_CODEC_NOT_TRUSTED, NULL );
		} else {
			//bstrError = FormatBSTR(IDS_ERR_NO_CODEC, NULL);
		}
				
		if (bstrError) {
			// !!! hack, should we really NotifyEvent through the graph?
			//ProcessEvent(EC_ERRORABORTEX, VFW_E_INVALIDMEDIATYPE, (LONG) bstrError, FALSE);
		}
		*/
	}
			
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// 
CDownloadCallback::CDownloadCallback()
    : m_pLMR(NULL),
	  m_hrBinding(S_ASYNCHRONOUS),
      m_pUnk(NULL),
      m_ulProgress(0), m_ulProgressMax(0)
{
    m_evFinished = CreateEvent(NULL, FALSE, FALSE, NULL);
}


STDMETHODIMP CDownloadCallback::Authenticate(HWND *phwnd, LPWSTR *pszUsername, LPWSTR *pszPassword)
{
    ATLTRACE(_T("Callback Authenticate\n"));
    m_pLMR->getHwnd(phwnd); // !!! is this right?
    *pszUsername = NULL;
    *pszPassword = NULL;
    return S_OK;
}

    // IWindowForBindingUI methods
STDMETHODIMP
CDownloadCallback:: GetWindow(REFGUID rguidReason, HWND *phwnd)
{

	m_pLMR->getHwnd( phwnd );

#ifdef DEBUG
    WCHAR achguid[50];
    StringFromGUID2(rguidReason, achguid, 50);
    
    ATLTRACE(_T("Callback GetWindow: (%ls) returned %x\n"), achguid, *phwnd );
#endif
    
    return S_OK;
}

STDMETHODIMP
CDownloadCallback::OnCodeInstallProblem(ULONG ulStatusCode, LPCWSTR szDestination,
					   LPCWSTR szSource, DWORD dwReserved)
{
    ATLTRACE(_T("Callback: OnCodeInstallProblem: %d    %ls -> %ls\n"),
		ulStatusCode, szDestination, szSource );

    return S_OK;   // !!!!!!!@!!!!!!!!!!!
}


/////////////////////////////////////////////////////////////////////////////
// 
CDownloadCallback::~CDownloadCallback()
{
    if (m_pUnk)
		m_pUnk->Release();

    //_ASSERTE(m_pDXMP->m_pDownloadBinding == NULL);

    if (m_evFinished)
		CloseHandle(m_evFinished);
}

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP CDownloadCallback::QueryService(REFGUID guidService, REFIID riid, void ** ppvObject)
{
#ifdef DEBUG

    // Dump requested stuff here....
    WCHAR achguid[50], achiid[50];
    StringFromGUID2(guidService, achguid, 50);
    StringFromGUID2(riid, achiid, 50);
    ATLTRACE(_T("Callback QS: (%ls, %ls)\n"), achguid, achiid);

#endif

    return E_NOINTERFACE;
}

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::OnStartBinding(DWORD grfBSCOption, IBinding* pbinding)
{
    ATLTRACE(_T("OnStartBinding, pbinding=%x\n"), pbinding);

    return S_OK;

}  // CDownloadCallback::OnStartBinding

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::GetPriority(LONG* pnPriority)
{
    ATLTRACE(_T("GetPriority\n"));

    return E_NOTIMPL;
}  // CDownloadCallback::GetPriority

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::OnLowResource(DWORD dwReserved)
{
    ATLTRACE(_T("OnLowResource %d\n"), dwReserved);

    return E_NOTIMPL;
}  // CDownloadCallback::OnLowResource

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::OnProgress(ULONG ulProgress, ULONG ulProgressMax,
		       ULONG ulStatusCode, LPCWSTR szStatusText)
{

    return(NOERROR);
}  // CDownloadCallback::OnProgress

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::OnStopBinding(HRESULT hrStatus, LPCWSTR pszError)
{
	return S_OK;

}  // CDownloadCallback::OnStopBinding

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindInfo)
{
    ATLTRACE(_T("GetBindInfo\n"));

    // !!! are these the right flags?

    *pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_NEEDFILE;
    pbindInfo->cbSize = sizeof(BINDINFO);
    pbindInfo->szExtraInfo = NULL;
    memset(&pbindInfo->stgmedData, 0, sizeof(STGMEDIUM));
    pbindInfo->grfBindInfoF = 0;
    pbindInfo->dwBindVerb = BINDVERB_GET;
    pbindInfo->szCustomVerb = NULL;
    return S_OK;
}  // CDownloadCallback::GetBindInfo

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC* pfmtetc, STGMEDIUM* pstgmed)
{
    ATLTRACE(_T("OnDataAvailable, dwSize = %x\n"), dwSize);

    // !!! do we care?

    return S_OK;
}  // CDownloadCallback::OnDataAvailable

/////////////////////////////////////////////////////////////////////////////
// 
STDMETHODIMP
CDownloadCallback::OnObjectAvailable(REFIID riid, IUnknown* punk)
{
    ATLTRACE(_T("OnObjectAvailable\n"));

    // should only be used in BindToObject case, which we don't use?
    m_pUnk = punk;
    if (punk)
	punk->AddRef();

    return S_OK;
}  // CDownloadCallback::OnObjectAvailable
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\control\lmctrl.h ===
// lmctrl.h :

#ifndef __LMCTRL_H_
#define __LMCTRL_H_

#include "resource.h"       // main symbols
#include <htmlfilter.h>
#include "danim.h"
#include <strmif.h>  //for IPin
#include "fgcallb.h"
#include "lmrt.h"
#include "Engine.h"
#include "version.h"

/////////////////////////////////////////////////////////////////////////////
class LMEngineList
{
public:
	ILMEngine		*engine;
	LMEngineList	*next;
};

class ATL_NO_VTABLE CLMReader : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CLMReader, &CLSID_LMReader>,
    public CComControl<CLMReader>,
    public IDispatchImpl<ILMReader2, &IID_ILMReader2, &LIBID_LiquidMotion>,
    public IProvideClassInfo2Impl<&CLSID_LMReader, NULL, &LIBID_LiquidMotion>,
    public IPersistStreamInitImpl<CLMReader>,
    public IPersistStorageImpl<CLMReader>,
    public IOleControlImpl<CLMReader>,
    public IOleObjectImpl<CLMReader>,
    public IOleInPlaceActiveObjectImpl<CLMReader>,
    public IViewObjectExImpl<CLMReader>,
    public IOleInPlaceObjectWindowlessImpl<CLMReader>,
    public IDataObjectImpl<CLMReader>,
    public ISpecifyPropertyPagesImpl<CLMReader>,
    public IObjectSafetyImpl<CLMReader>,
	public IOleCommandTarget,
	public IPersistPropertyBagImpl<CLMReader>,
	public IAMFilterGraphCallback
{
  public:
    CLMReader();
    ~CLMReader();
	bool isStandaloneStreaming();

DECLARE_REGISTRY_RESOURCEID(IDR_LMCTRL)

BEGIN_COM_MAP(CLMReader)
		COM_INTERFACE_ENTRY(ILMReader2)
        COM_INTERFACE_ENTRY(ILMReader)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
        COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
        COM_INTERFACE_ENTRY_IMPL(IOleControl)
        COM_INTERFACE_ENTRY_IMPL(IOleObject)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_IMPL(IDataObject)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
        COM_INTERFACE_ENTRY(IProvideClassInfo)
        COM_INTERFACE_ENTRY(IProvideClassInfo2)
 		COM_INTERFACE_ENTRY(IOleCommandTarget)
		COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
		COM_INTERFACE_ENTRY(IAMFilterGraphCallback)
END_COM_MAP()

BEGIN_PROPERTY_MAP(LMReader)
END_PROPERTY_MAP()


BEGIN_MSG_MAP(CLMReader)
END_MSG_MAP()
        
// IOleInPlaceObjectWindowlessImpl
	STDMETHOD(OnWindowMessage)(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
	{
		return ProcessWindowMessage(m_hWnd, msg,
									wParam, lParam,
									*plResult)?S_OK:S_FALSE;
	}

// IOleCommandTarget
	STDMETHOD(QueryStatus)( const GUID* pguidCmdGroup, ULONG cCmds,
		OLECMD prgCmds[], OLECMDTEXT* pCmdText );
	STDMETHOD(Exec)(const GUID* pguidCmdGroup, DWORD nCmdID,
		DWORD nCmdexecopt, VARIANTARG* pvaIn, VARIANTARG* pvaOut );

// ILMReader
    STDMETHOD(get_Image)(/*[out, retval]*/ IDAImage **pVal);
    STDMETHOD(get_Sound)(/*[out, retval]*/ IDASound **pVal);
    STDMETHOD(get_Engine)(/*[out, retval]*/ ILMEngine **pVal);
	STDMETHOD(get_NoExports)(/*[out]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_NoExports)(/*[in]*/ VARIANT_BOOL pVal);
	STDMETHOD(get_Async)(/*[out]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_Async)(/*[in]*/ VARIANT_BOOL pVal);
	STDMETHOD(get_Src)(/*[out]*/ BSTR *pVal);
	STDMETHOD(createEngine)(/*[out, retval]*/ILMEngine **pVal);
	STDMETHOD(createAsyncEngine)(/*[out, retval]*/ILMEngine **pVal);
	STDMETHOD(execute)(/*[in, string]*/ BSTR url, /*[out, retval]*/ ILMEngine **pVal);
	STDMETHOD(_execute)(/*[in, string]*/ BSTR url, /*[in]*/LONG blkSize, /*[in]*/LONG delay, /*[out, retval]*/ ILMEngine **pVal);
	STDMETHOD(Load)(LPSTREAM pStm);
// ILMReader2
    STDMETHOD(put_ViewerControl)(/*[in]*/ IDAViewerControl *viewerControl);
	STDMETHOD(get_ViewerControl)(/*[out, retval]*/IDAViewerControl **viewerControl);
	STDMETHOD(get_VersionString)(/*[out, retval]*/BSTR *versionString);
	STDMETHOD(releaseFilterGraph)();

// IObjectSafetyImpl
	STDMETHOD(SetInterfaceSafetyOptions)(
							/* [in] */ REFIID riid,
							/* [in] */ DWORD dwOptionSetMask,
							/* [in] */ DWORD dwEnabledOptions);
	STDMETHOD(GetInterfaceSafetyOptions)(
							/* [in] */ REFIID riid, 
							/* [out] */DWORD *pdwSupportedOptions, 
							/* [out] */DWORD *pdwEnabledOptions);

// IPropertyBagImpl
	STDMETHOD(Load)(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog);

// IOleInPlaceObjectWindowlessImpl
	STDMETHOD(InPlaceDeactivate)();
// IAMFilterGraphCallback
	HRESULT UnableToRender(IPin* pPin );

	HRESULT getHwnd( HWND* phwnd )
	{
		(*phwnd) = m_hWnd;
		return S_OK;
	}

protected:
	ILMEngine			*m_pEngine;
	VARIANT_BOOL		m_bAsync;
	VARIANT_BOOL		m_bNoExports;
	BSTR				m_Src;
	LONG				m_AsyncBlkSize;
	LONG				m_AsyncDelay;
	LMEngineList		*engineList, *engineListTail;
	IDAViewerControl    *m_pViewerControl;
	BOOL 				m_bAutoCodecDownloadEnabled;

	CLSID   m_clsidDownloaded;

};

class CDownloadCallback : public CComObjectRootEx<CComSingleThreadModel>,
			    public IBindStatusCallback, public IServiceProvider,
			    public IAuthenticate, public ICodeInstall
{
    BEGIN_COM_MAP(CDownloadCallback)
	    COM_INTERFACE_ENTRY(IBindStatusCallback)
	    COM_INTERFACE_ENTRY(IServiceProvider)
	    COM_INTERFACE_ENTRY(IAuthenticate)
	    COM_INTERFACE_ENTRY(ICodeInstall)
	    COM_INTERFACE_ENTRY(IWindowForBindingUI)
    END_COM_MAP()
	    
public:
    CDownloadCallback();
    ~CDownloadCallback();
    
    // --- IBindStatusCallback methods ---

    STDMETHODIMP    OnStartBinding(DWORD grfBSCOption, IBinding* pbinding);
    STDMETHODIMP    GetPriority(LONG* pnPriority);
    STDMETHODIMP    OnLowResource(DWORD dwReserved);
    STDMETHODIMP    OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode,
			LPCWSTR pwzStatusText);
    STDMETHODIMP    OnStopBinding(HRESULT hrResult, LPCWSTR szError);
    STDMETHODIMP    GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHODIMP    OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pfmtetc,
			STGMEDIUM* pstgmed);
    STDMETHODIMP    OnObjectAvailable(REFIID riid, IUnknown* punk);

    // IServiceProvider methods
    STDMETHODIMP     QueryService(REFGUID guidService, REFIID riid, void ** ppvObject);
    
    // IAuthenticate methods
    STDMETHODIMP Authenticate(HWND *phwnd, LPWSTR *pszUsername, LPWSTR *pszPassword);

    // IWindowForBindingUI methods
    STDMETHODIMP GetWindow(REFGUID rguidReason, HWND *phwnd);

    // ICodeInstall methods
    STDMETHODIMP OnCodeInstallProblem(ULONG ulStatusCode, LPCWSTR szDestination, 
				      LPCWSTR szSource, DWORD dwReserved);

	CLMReader*          m_pLMR;
    HRESULT             m_hrBinding;
    IUnknown *          m_pUnk;
    HANDLE              m_evFinished;
    ULONG		m_ulProgress, m_ulProgressMax;
};

#endif //__LMCTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\include\lmdefaults.h ===
#ifndef INC_LM_DEFAULTS_H
#define INC_LM_DEFAULTS_H

//include the chrome defaults
#include "..\chrome\include\defaults.h"

#define DEFAULT_AUTOEFFECT_TYPE				L"sparkles"
#define DEFAULT_AUTOEFFECT_CAUSE			L"time"		
#define DEFAULT_AUTOEFFECT_SPAN				0.5f
#define DEFAULT_AUTOEFFECT_SIZE				0.5f
#define DEFAULT_AUTOEFFECT_RATE				0.5f
#define DEFAULT_AUTOEFFECT_GRAVITY			0.0f
#define DEFAULT_AUTOEFFECT_WIND				0.0f
#define DEFAULT_AUTOEFFECT_FILLCOLOR		0xffffff
#define DEFAULT_AUTOEFFECT_STROKECOLOR		0x000000
#define DEFAULT_AUTOEFFECT_OPACITY			1.0f

#define DEFAULT_JUMPBVR_RANGE				L"page"
#define DEFAULT_JUMPBVR_INTERVAL			1.0f

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\include\lmattrib.h ===
#ifndef INC_LM_ATTRIB_H
#define INC_LM_ATTRIB_H

//include the chrome attributes
#include "..\chrome\include\attrib.h"

#define BEHAVIOR_TYPE_AUTOEFFECT                 L"autoEffect"
#define BEHAVIOR_TYPE_AVOIDFOLLOW                L"avoidFollow"
#define BEHAVIOR_TYPE_JUMP   		             L"jump"

//properties for autoeffects
#define BEHAVIOR_PROPERTY_TYPE                   L"type"
#define BEHAVIOR_PROPERTY_CAUSE                  L"cause"
#define BEHAVIOR_PROPERTY_SPAN                   L"span"
#define BEHAVIOR_PROPERTY_SIZE                   L"size"
#define BEHAVIOR_PROPERTY_RATE                   L"rate"
#define BEHAVIOR_PROPERTY_GRAVITY                L"gravity"
#define BEHAVIOR_PROPERTY_WIND                   L"wind"
#define BEHAVIOR_PROPERTY_FILLCOLOR              L"fillColor"
#define BEHAVIOR_PROPERTY_STROKECOLOR            L"strokeColor"
#define BEHAVIOR_PROPERTY_OPACITY				 L"opacity"

//properties for avoid follow
#define BEHAVIOR_PROPERTY_RADIUS                 L"radius"
#define BEHAVIOR_PROPERTY_TARGET                 L"target"
#define BEHAVIOR_PROPERTY_VELOCITY               L"velocity"
#define TARGET_MOUSE                             L"mouse"

//properties for jump
#define BEHAVIOR_PROPERTY_INTERVAL				 L"interval"
#define BEHAVIOR_PROPERTY_RANGE					 L"range"

#endif// INC_LM_ATTRIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\include\resource.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    LM Resources

*******************************************************************************/


#ifndef _RESOURCE_H
#define _RESOURCE_H

#define IDR_LMCTRL            101
#define IDR_LMBVRFACTORY      102
//#define IDR_AVOIDFOLLOWBVR    103 //punted for v1
#define IDR_AUTOEFFECTBVR	  104
//#define IDR_JUMPBVR			  105 //punted for v1

#define RESID_TYPELIB           1



#include "..\chrome\include\resource.h"

#endif /* _RESOURCE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\include\lmatl.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _LMATL_H
#define _LMATL_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define _ATL_NO_DEBUG_CRT 1

#ifdef _DEBUG
#undef _ASSERTE
#endif

#define _ASSERTE(expr) ((void)0)

#define _ATL_STATIC_REGISTRY 1


#ifdef _DEBUG
inline void _cdecl AtlTrace2(LPCTSTR , ...){}
#define ATLTRACE            1 ? (void)0 : AtlTrace2
#endif

#include <atlbase.h>

//#define _ATL_APARTMENT_THREADED
// THIS MUST BE CALLED _Module - all the ATL header files depend on it
extern CComModule _Module;

#include <atlcom.h>
#include <atlctl.h>

// Just to make things more uniform
#define RELEASE(x) if (x) { (x)->Release(); (x) = NULL; }

#define LMCLEANUPIFFAILED(hr)	if (FAILED(hr)) { DASSERT(FALSE); goto cleanup; }
#define LMRETURNIFFAILED(hr)	if (FAILED(hr)) { DASSERT(FALSE); return hr; }
#define LMRETURNIFNULL(p)		if (p == NULL) { DASSERT(FALSE); return E_FAIL; }

#endif /* _LMATL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\lmbehav\dll\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\include\lmtrace.h ===
#ifndef _LM_TRACE_INC_
#define _LM_TRACE_INC_
/////////////////////////////////////////////////////////////
//trace definitions stolen from ATL 30 headers and customized
/////////////////////////////////////////////////////////////

/////////////////////////////////////
// LM DEBUG Defines
////////////////////////////////////
#ifdef _DEBUG
#include <assert.h>
#define LMASSERT(expr) assert((expr))

#define LM_TRACE_CATEGORY	(lmTraceNone)
#define LM_TRACE_LEVEL		(0)
#else
#define LMASSERT(expr) ((void)0)
#endif //_DEBUG
////////////////////////////////////
// End LM DEBUG Defines
////////////////////////////////////

enum lmTraceFlags
{
	//LM defined categories
	lmTraceNone					= 0x00000000,
	lmTraceLMRT 				= 0x00000001,
	lmTraceBaseBehavior			= 0x00000002,
	lmTraceMoveBehavior			= 0x00000004,
	lmTraceColorBehavior 		= 0x00000008,
	lmTraceAll					= 0xFFFFFFFF,
};

#ifndef LM_TRACE_CATEGORY
#define LM_TRACE_CATEGORY (lmTraceAll)
#endif

#ifdef _DEBUG

#ifndef LM_TRACE_LEVEL
#define LM_TRACE_LEVEL 0
#endif

inline void _cdecl LmTrace(LPCSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	char szBuffer[512];

	nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
	LMASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

	OutputDebugStringA(szBuffer);
	va_end(args);
}
inline void _cdecl LmTrace2(DWORD category, UINT level, LPCSTR lpszFormat, ...)
{
	if (category & LM_TRACE_CATEGORY && level <= LM_TRACE_LEVEL)
	{
		va_list args;
		va_start(args, lpszFormat);

		int nBuf;
		char szBuffer[512];

		nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
		LMASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

		OutputDebugStringA("LM: ");
		OutputDebugStringA(szBuffer);
		va_end(args);
	}
}
#ifndef OLE2ANSI
inline void _cdecl LmTrace(LPCWSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	WCHAR szBuffer[512];

	nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
	LMASSERT(nBuf < sizeof(szBuffer));//Output truncated as it was > sizeof(szBuffer)

	OutputDebugStringW(szBuffer);
	va_end(args);
}
inline void _cdecl LmTrace2(DWORD category, UINT level, LPCWSTR lpszFormat, ...)
{
	if (category & LM_TRACE_CATEGORY && level <= LM_TRACE_LEVEL)
	{
		va_list args;
		va_start(args, lpszFormat);

		int nBuf;
		WCHAR szBuffer[512];

		nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
		LMASSERT(nBuf < sizeof(szBuffer));//Output truncated as it was > sizeof(szBuffer)

		OutputDebugStringW(L"LM: ");
		OutputDebugStringW(szBuffer);
		va_end(args);
	}
}
#endif //!OLE2ANSI


#ifndef LMTRACE
#define LMTRACE            LmTrace
#define LMTRACE2           LmTrace2
#endif
#define LMTRACENOTIMPL(funcname)   LMTRACE2(lmTraceNotImpl, 2, _T("LM: %s not implemented.\n"), funcname); return E_NOTIMPL
#else // !DEBUG
inline void _cdecl LmTrace(LPCSTR , ...){}
inline void _cdecl LmTrace2(DWORD, UINT, LPCSTR , ...){}
#ifndef OLE2ANSI
inline void _cdecl LmTrace(LPCWSTR , ...){}
inline void _cdecl LmTrace2(DWORD, UINT, LPCWSTR , ...){}
#endif //OLE2ANSI
#ifndef LMTRACE
#define LMTRACE            1 ? (void)0 : LmTrace
#define LMTRACE2			1 ? (void)0 : LmTrace2
#endif //LMTRACE
#define LMTRACENOTIMPL(funcname)   return E_NOTIMPL
#endif //_DEBUG

#endif //_LM_TRACE_INC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\lmbehav\dll\behavior.cpp ===
// behavior.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f behaviorps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "behavior.h"

#include "src\jump.h"
#include "src\factory.h"
#include "src\pulsate.h"
#include "src\colcycle.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_JumpBehavior, CJumpBehavior)
	OBJECT_ENTRY(CLSID_LMBehaviorFactory, CLMBehaviorFactory)
	OBJECT_ENTRY(CLSID_PulsateBehavior, CPulsateBehavior)
	OBJECT_ENTRY(CLSID_ColorCycleBehavior, CColorCycleBehavior)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\lmbehav\include\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by behavior.rc
//
#define IDS_PROJNAME                    100
#define IDR_JUMPBEHAVIOR                101
#define IDR_LMBEHAVIORFACTORY           102
#define IDR_PULSATEBEHAVIOR             103
#define IDR_COLORCYCLEBEHAVIOR          104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\lmbehav\rsrc\makefile.inc ===
behavior.rc : $(TARGETPATH)\$(TARGET_DIRECTORY)\lmbehav.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\lmbehav\include\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__43AAC678_387C_11D2_BB7D_00A0C999C4C1__INCLUDED_)
#define AFX_STDAFX_H__43AAC678_387C_11D2_BB7D_00A0C999C4C1__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define _WIN32_WINNT 0x0400

#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#include <mshtml.h>

#import "d:/nt/private/danim/libd/i386/danim.dll" \
  exclude( "_RemotableHandle", "IMoniker", "IPersist", "ISequentialStream", \
  "IParseDisplayName", "IOleClientSite", "_FILETIME", "tagSTATSTG" ) \
  named_guids \
  rename( "GUID", "DAGUID" ) \
  rename_namespace( "DAnim" )

using namespace DAnim;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__43AAC678_387C_11D2_BB7D_00A0C999C4C1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\lmbehav\src\colcycle.cpp ===
// ColorCycleBehavior.cpp : Implementation of CColorCycleBehavior
#include "stdafx.h"
#include <limits.h>

#include "Behavior.h"
#include "ColCycle.h"

const WCHAR *	CColorCycleBehavior::RGSZ_DIRECTIONS[ NUM_DIRS ]	=
{
	L"clockwise",
	L"cclockwise",
	L"noHue"
};

/////////////////////////////////////////////////////////////////////////////
// CColorCycleBehavior

CColorCycleBehavior::CColorCycleBehavior() :
	m_bstrProperty( L"style.color" )
{
	m_direction			= DIR_CLOCKWISE;
}

HRESULT CColorCycleBehavior::BuildDABehaviors()
{
	HRESULT	hr		= S_OK;

	// Set up the DA tree.
	//----------------------------------------------------------------------
	IDAStaticsPtr	e;

	e.CreateInstance( L"DirectAnimation.DAStatics" );

	// Set up time
	//----------------------------------------------------------------------
	float 			fDuration	= 0.0;
	if ( FAILED( GetDur( &fDuration ) ) )
		return E_FAIL;

	IDANumberPtr	timePtr	= GetTimeNumberBvr();
	if ( timePtr == NULL )
		return E_FAIL;

	// Interpolate between the 2 colors in HSL space.
	//----------------------------------------------------------------------
	float h1, l1, s1;
	float h2, l2, s2;

	h1 = m_colorFrom.GetH();
	s1 = m_colorFrom.GetS();
	l1 = m_colorFrom.GetL();
	
	h2 = m_colorTo.GetH();
	s2 = m_colorTo.GetS();
	l2 = m_colorTo.GetL();

	// Hue is a circle, so adding or subtracting 1 gives the same hue, but
	// will cause a change in direction from initial hue to final hue.
	if ( ( h2 <= h1 ) && ( m_direction == DIR_CLOCKWISE ) )
	{
		h2 += 1.0;
	}
	else if ( ( h2 >= h1 ) && ( m_direction == DIR_CCLOCKWISE ) )
	{
		h2 -= 1.0;
	}

	IDANumberPtr	tNorm	= e->Div( timePtr, e->DANumber( fDuration ) );
	IDANumberPtr	hueNum1 = e->DANumber( h1 );
	IDANumberPtr	hueNum	= e->Add( hueNum1, e->Mul( tNorm, e->Sub( e->DANumber(h2), hueNum1 ) ) );
	
	IDANumberPtr	satNum1	= e->DANumber( s1 );
	IDANumberPtr	satNum	= e->Add( satNum1, e->Mul( tNorm, e->Sub( e->DANumber(s2), satNum1 ) ) );

	IDANumberPtr	lumNum1	= e->DANumber( l1 );
	IDANumberPtr	lumNum	= e->Add( lumNum1, e->Mul( tNorm, e->Sub( e->DANumber(l2), lumNum1 ) ) );
	
	IDAColorPtr		color	= e->ColorHslAnim( hueNum, satNum, lumNum );

	// Convert HSL into a long value representing the corresponding RGB.
	//----------------------------------------------------------------------
	IDANumberPtr	rgbNum;

	rgbNum = e->Add( e->Add( e->Mul( e->Round( e->Mul( color->Red, e->DANumber( UCHAR_MAX ) ) ), 
									 e->DANumber( UCHAR_MAX * UCHAR_MAX ) ),
							 e->Mul( e->Round( e->Mul( color->Green, e->DANumber( UCHAR_MAX ) ) ),
									 e->DANumber( UCHAR_MAX ) ) ),
					 e->Round( e->Mul( color->Blue, e->DANumber( UCHAR_MAX ) ) ) );

	// Animate the specified property.
	//----------------------------------------------------------------------
	CComBSTR cbstrID;
	CComBSTR sProp;

	hr = GetParentID( &cbstrID );
	if ( FAILED(hr) ) return hr;
	
	if ( cbstrID != NULL )
		sProp = cbstrID;

	sProp += ".";
	sProp += m_bstrProperty;

	rgbNum = e->Cond( e->GT( timePtr, e->DANumber( -1 ) ),
					  rgbNum,
					  e->DANumber( m_colorFrom.ToRGBDWORD() ) );
	
	IDANumberPtr animNum = rgbNum->AnimateProperty( _bstr_t(sProp), "JScript", VARIANT_FALSE, 0.02 );

	// Add to the behaviors to run
	//----------------------------------------------------------------------
	if ( m_vwrControlPtr != NULL )
		hr = m_vwrControlPtr->AddBehaviorToRun( animNum );
	
// 	LONG	lCookie;
	
// 	hr = AddBehavior( animNum, &lCookie );
// 	if ( FAILED(hr) ) return hr;

// 	hr = TurnOn();
// 	if ( FAILED(hr) ) return hr;

	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CColorCycleBehavior::Notify(LONG dwNotify, VARIANT * pVar)
{
	HRESULT hr = CBaseBehavior::Notify( dwNotify, pVar );

	if ( dwNotify == BEHAVIOREVENT_DOCUMENTREADY )
	{
// 		AddTimeBehavior();
		BuildDABehaviors();
	}
	
	return hr;
}


STDMETHODIMP CColorCycleBehavior::get_from(BSTR * out_pbstr)
{
	return m_colorFrom.ToString( out_pbstr );
}

STDMETHODIMP CColorCycleBehavior::put_from(BSTR in_bstr)
{
	return m_colorFrom.Parse( in_bstr );
}

STDMETHODIMP CColorCycleBehavior::get_to(BSTR * out_pbstr)
{
	return m_colorTo.ToString( out_pbstr );
}

STDMETHODIMP CColorCycleBehavior::put_to(BSTR in_bstr)
{
	return m_colorTo.Parse( in_bstr );
}

STDMETHODIMP CColorCycleBehavior::get_property(BSTR *out_pbstr)
{
	if ( out_pbstr == NULL )
		return E_POINTER;
	
	*out_pbstr = m_bstrProperty.Copy();
	
	return S_OK;
}

STDMETHODIMP CColorCycleBehavior::put_property(BSTR in_bstr)
{
	m_bstrProperty = in_bstr;

	return S_OK;
}

STDMETHODIMP CColorCycleBehavior::get_direction(BSTR * pbstrDir)
{
	if ( pbstrDir == NULL ) return E_INVALIDARG;
	
	*pbstrDir = ::SysAllocString( RGSZ_DIRECTIONS[ m_direction ] );

	return S_OK;
}

STDMETHODIMP CColorCycleBehavior::put_direction(BSTR bstrDir)
{
	HRESULT	hr = E_INVALIDARG;
	
	for ( int i = 0; i < NUM_DIRS; i++ )
	{
		if ( _wcsicmp( bstrDir, RGSZ_DIRECTIONS[ i ] ) == 0 )
		{
			m_direction	= (DirectionType) i;
			hr			= S_OK;
			break;
		}
	}

	return hr;
}

STDMETHODIMP CColorCycleBehavior::get_on(VARIANT * pVal)
{
	if( pVal == NULL )
		return E_INVALIDARG;

	V_VT(pVal)  = VT_BOOL;
	V_BOOL(pVal)= m_on ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CColorCycleBehavior::put_on(VARIANT newVal)
{
	VariantChangeType( &newVal, &newVal, 0, VT_BOOL );
	
	m_on = V_BOOL(&newVal) == VARIANT_TRUE ? true : false;
	
	HandleOnChange( m_on );

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\lmbehav\src\color.cpp ===
#include "stdafx.h"
#include "color.h"

const WCHAR 	CColor::PREFIX_COLOR					= '#';
const float 	CColor::HUE_UNDEFINED					= 0.0f;

CColor::CColor() :
	m_r( 0 ),
	m_g( 0 ),
	m_b( 0 ),
	m_h( 0.0f ),
	m_s( 0.0f ),
	m_l( 0.0f )
{
}

HRESULT CColor::Parse( BSTR in_bstr )
{
	if ( in_bstr == NULL )
		return E_POINTER;

	// TODO: Support named colors
	UINT cChars = ::SysStringLen( in_bstr );
	if ( ( cChars < 7 ) || ( in_bstr[0] != PREFIX_COLOR ) )
		return E_INVALIDARG;

	--cChars;

	WCHAR	*pStart = in_bstr + 1;
	WCHAR 	*pEnd;
	ULONG 	ulColor = wcstoul( pStart, &pEnd, 16 );
	
	if ( pEnd != pStart + cChars )
		return E_INVALIDARG;

	m_r = LOBYTE( HIWORD( ulColor ) );
	m_g = HIBYTE( LOWORD( ulColor ) );
	m_b = LOBYTE( LOWORD( ulColor ) );

	RGBToHSL( GetR(), GetG(), GetB(), m_h, m_s, m_l );
	
	return S_OK;
}

HRESULT CColor::ToString( BSTR * out_pbstr )
{
	if ( out_pbstr == NULL )
		return E_POINTER;
	
	WCHAR			wszColor[33];
	WCHAR			wszBuffer[34];
	unsigned long	ulColor = ToRGBDWORD();

	_ultow( ulColor, wszColor, 16 );
	swprintf( wszBuffer, L"#%s", wszColor );
	*out_pbstr = ::SysAllocString( wszBuffer );

	return S_OK;
}

ULONG CColor::ToRGBDWORD()
{
	unsigned long	ulColor = MAKELONG( MAKEWORD( m_b, m_g ), MAKEWORD( m_r, 0 ) );
	return ulColor;
}

HRESULT CColor::RGBToHSL( float r, float g, float b, float& h, float& s, float& l )
{
#define MIN( a, b ) ( (a) < (b) ? (a) : (b) )
#define MAX( a, b ) ( (a) > (b) ? (a) : (b) )
	
	HRESULT	hr = S_OK;
	
	float fMax = MAX(MAX(r, g), b);
	float fMin = MIN(MIN(r, g), b);

	l = (fMax + fMin) / 2;

	if( fMax == fMin )
	{
		s = 0.0f;
		h = HUE_UNDEFINED;
		hr = S_FALSE;
	}
	else
	{
		if( l < 0.5 )
			s = (fMax-fMin)/(fMax+fMin);
		else
			s = (fMax-fMin)/(2-fMax-fMin);

		float delta = fMax-fMin;

		if( r == fMax )
			h = (g-b)/delta;

		else if ( g == fMax )
			h = 2 + (b-r)/delta;

		else // if (b == fMax )
			h = 4 + (b-r)/delta;

		h = h / 6.0f; // Convert Ensure it's in [0...1]

		if( h < 1 )
			h = h + 1;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\lmbehav\src\colcycle.h ===
// ColorCycleBehavior.h : Declaration of the CColorCycleBehavior

#ifndef __COLORCYCLEBEHAVIOR_H_
#define __COLORCYCLEBEHAVIOR_H_

#include "resource.h"       // main symbols
#include "base.h"
#include "color.h"

/////////////////////////////////////////////////////////////////////////////
// CColorCycleBehavior
class ATL_NO_VTABLE CColorCycleBehavior :
	public CBaseBehavior,
	public CComCoClass<CColorCycleBehavior, &CLSID_ColorCycleBehavior>,
	public IDispatchImpl<IColorCycleBehavior, &IID_IColorCycleBehavior, &LIBID_BEHAVIORLib>
{
public:
	CColorCycleBehavior();

    // IElementBehavior
    //
	STDMETHOD(Notify)(LONG event, VARIANT * pVar);

DECLARE_REGISTRY_RESOURCEID(IDR_COLORCYCLEBEHAVIOR)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CColorCycleBehavior)
	COM_INTERFACE_ENTRY(IColorCycleBehavior)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_CHAIN(CBaseBehavior)
END_COM_MAP()

    // Needed by CBaseBehavior
    void * 	GetInstance() { return (IColorCycleBehavior *) this ; }
	
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }
	
// IColorCycleBehavior
public:
	STDMETHOD(get_on)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_on)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_direction)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_direction)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_property)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_property)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_to)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_to)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_from)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_from)(/*[in]*/ BSTR newVal);
	
protected:	
	enum DirectionType {
		DIR_CLOCKWISE,
		DIR_CCLOCKWISE,
		DIR_NOHUE,
		NUM_DIRS
	};

	static const WCHAR *	RGSZ_DIRECTIONS[ NUM_DIRS ];
	
protected:
	HRESULT			BuildDABehaviors();
	
protected:
	CColor					m_colorFrom;
	CColor					m_colorTo;

	CComBSTR				m_bstrProperty;
	DirectionType			m_direction;
};

#endif //__COLORCYCLEBEHAVIOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\lmbehav\src\base.h ===
/********************************
*
* CBaseBehavior
*
*/

#ifndef __BASEBEHAVIOR_H_
#define __BASEBEHAVIOR_H_

class ATL_NO_VTABLE CBaseBehavior: 
		public CComObjectRootEx<CComSingleThreadModel>,
		public IObjectSafetyImpl<CBaseBehavior, INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
		public IElementBehavior
{
public:
	CBaseBehavior();
	~CBaseBehavior();

	//Derived Classes must implement these

	//returns a pointer to the instance of IDispatch
	virtual void *GetInstance()=0;
	//
	virtual HRESULT GetTypeInfo( ITypeInfo **ppTypeInfo )=0;

	// IObjectSafetyImpl
	STDMETHOD(SetInterfaceSafetyOptions)(
							/* [in] */ REFIID riid,
							/* [in] */ DWORD dwOptionSetMask,
							/* [in] */ DWORD dwEnabledOptions);
	STDMETHOD(GetInterfaceSafetyOptions)(
							/* [in] */ REFIID riid, 
							/* [out] */DWORD *pdwSupportedOptions, 
							/* [out] */DWORD *pdwEnabledOptions);

	//IElementBehavior methods
	STDMETHOD(Init)(IElementBehaviorSite *pSite);
	STDMETHOD(Notify)(LONG event, VARIANT *pVar);
	
BEGIN_COM_MAP(CBaseBehavior)
	COM_INTERFACE_ENTRY(IObjectSafety)
	COM_INTERFACE_ENTRY(IElementBehavior)
END_COM_MAP()

protected:
	//methods
	STDMETHOD(InitProps)( void* pInstance, ITypeInfo *pTypeInfo, IHTMLElement *pElement );
	STDMETHOD(UpdateProp)( void* pInstance, ITypeInfo *pTypeInfo, IHTMLElement *pElement, LPFUNCDESC pFuncDesc );
	STDMETHOD(Detach)();

	HRESULT CacheTimeDispids();
	HRESULT	AddTimeBehavior();
	HRESULT	CacheDAControl();
	HRESULT AddBehavior( IDABehavior * in_pBehavior, long * out_pCookie );
	HRESULT	TurnOn();
	HRESULT GetDur( float *out_pDur );
	HRESULT GetRepeatCount( float *out_pRepeatCount );
	HRESULT GetRepeatDur( float *out_pRepeatDur );
	
	HRESULT GetParentElement( IHTMLElement** out_ppParentElement );
	HRESULT GetParentID( BSTR *out_ppParentID );

	HRESULT GetElementIDispatch( IDispatch **out_pDispatch );

	IDANumberPtr GetTimeNumberBvr();

	void HandleOnChange( bool on );

	
	//member vars

	static const WCHAR *rgszNames[];

	CComDispatchDriver						m_DispatchDriver;
	DISPID 									*m_rgTimeDispids;
	IElementBehaviorSite  					*m_pBehaviorSite;
	static CComPtr<IElementBehaviorFactory>	m_timeBehaviorFactoryPtr;

	// HACK
	IDAViewerControlPtr						m_vwrControlPtr;
	static bool								m_bDAStarted;
	bool m_on;

private:
	IDANumberPtr							m_time;
	IDAEventPtr								m_startEvent;

	DWORD									m_dwSafety;
};
#endif __BASEBEHAVIOR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\lmbehav\src\base.cpp ===
/****************************************
*
* CBaseBehavior
*
*  A base class for LM behaviors
* 
****************************************/

#include "stdafx.h"

#include "behavior.h"

#include "base.h"

enum{
		DISP_ADDDABEHAVIOR,
		DISP_REMOVEDABEHAVIOR,
		DISP_TURNON,
		DISP_TURNOFF,
		DISP_DUR,
		DISP_REPEATCOUNT,
		DISP_REPEATDUR,
		NUM_TIME_DISPIDS
	};
const WCHAR * CBaseBehavior::rgszNames[] = {
		L"AddBehavior",
		L"RemoveBehavior",
		L"TurnOn",
		L"TurnOff",
		L"Dur",
		L"RepeatCount",
		L"RepeatDur"
	};

CComPtr<IElementBehaviorFactory> CBaseBehavior::m_timeBehaviorFactoryPtr;

bool CBaseBehavior::m_bDAStarted = false;

CBaseBehavior::CBaseBehavior()
{
	m_pBehaviorSite = NULL;

	m_rgTimeDispids = new DISPID[ NUM_TIME_DISPIDS ];
}

CBaseBehavior::~CBaseBehavior()
{
	if ( m_pBehaviorSite != NULL )
		m_pBehaviorSite->Release();
	if( m_rgTimeDispids != NULL )
		delete[] m_rgTimeDispids;
}

STDMETHODIMP CBaseBehavior::Init( IElementBehaviorSite *pSite )
{
	if( pSite == NULL )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	CComPtr<ITypeInfo> pTypeInfo;
	CComPtr<IHTMLElement> pElem;

	m_pBehaviorSite = pSite;
	pSite->AddRef();

	if( FAILED( hr = m_pBehaviorSite->GetElement( &pElem ) ) ||
		FAILED( hr = GetTypeInfo( &pTypeInfo ) ) )
		return hr;

	InitProps( GetInstance(), pTypeInfo, pElem );

	return hr;
}

STDMETHODIMP CBaseBehavior::Notify( LONG dwNotify, VARIANT *pVar )
{
	if ( dwNotify == BEHAVIOREVENT_DOCUMENTREADY )
	{
		CacheTimeDispids();
		CacheDAControl();
	}
	
	return S_OK;
}

STDMETHODIMP CBaseBehavior::Detach()
{
	return S_OK;
}

STDMETHODIMP CBaseBehavior::InitProps(void* pInstance, ITypeInfo *pTypeInfo, IHTMLElement *pElement)
{
	HRESULT hr;
    
    if( pInstance == NULL )
		return E_INVALIDARG;
	if( pTypeInfo == NULL )
		return E_INVALIDARG;
	if( pElement == NULL )
		return E_INVALIDARG;

    int cFuncs;
    
    {
        LPTYPEATTR pTypeAttr;
        
        hr = pTypeInfo->GetTypeAttr(&pTypeAttr);
        
        if (FAILED(hr))
        {
            goto done;
        }

        cFuncs = pTypeAttr->cFuncs;

        pTypeInfo->ReleaseTypeAttr(pTypeAttr);
    }
    
    int i;
    
    for (i = 0; i < cFuncs; i++)
    {
        LPFUNCDESC pFuncDesc;

        hr = pTypeInfo->GetFuncDesc(i, &pFuncDesc) ;
        
        if (FAILED(hr))
        {
            goto done;
        }

        if (pFuncDesc->invkind == INVOKE_PROPERTYPUT)
        {
            hr = UpdateProp(pInstance, pTypeInfo, pElement, pFuncDesc);
        }

        pTypeInfo->ReleaseFuncDesc(pFuncDesc);

        if (FAILED(hr))
        {
            goto done;
        }
    }

  done:
    return hr;
}

STDMETHODIMP CBaseBehavior::UpdateProp(void* pInstance, ITypeInfo *pTypeInfo, IHTMLElement *pElement, LPFUNCDESC pFuncDesc )
{
	HRESULT hr;
    
    CComVariant attribute;
    BSTR rgbstrNames[1] ;
    UINT cNames ;
    
    hr = pTypeInfo->GetNames(pFuncDesc->memid, rgbstrNames, 1, &cNames);
    
    if (FAILED(hr))
    {
        goto done;
    }
    
    // This should not happen but let's be safe and check
    if (cNames < 1)
    {
        hr = S_OK;
        goto done;
    }
    
    hr = pElement->getAttribute( rgbstrNames[0] , 0, &attribute );
    
    // For some reason if the property is not set it will still return
    // success but return a VT_NULL.  We want to ignore these.
    
    if (SUCCEEDED(hr) && V_VT(&attribute) != VT_NULL)
    {
        UINT* puArgErr = 0;
        DISPID propPutDispid = DISPID_PROPERTYPUT;
        DISPPARAMS dispparams;
        
        dispparams.rgvarg = &attribute;
        dispparams.rgdispidNamedArgs = &propPutDispid;
        dispparams.cArgs = 1;
        dispparams.cNamedArgs = 1;
        
        pTypeInfo->Invoke(pInstance,
                        pFuncDesc->memid,
                        DISPATCH_PROPERTYPUT,
                        &dispparams,
                        NULL,
                        NULL,
                        puArgErr);
    }
    
    SysFreeString(rgbstrNames[0]) ;

    hr = S_OK;
    
  done:
    return hr;
}

HRESULT CBaseBehavior::CacheTimeDispids()
{
	if ( m_pBehaviorSite == NULL ) return E_FAIL;

	CComPtr<IHTMLElement>	pElement;
	HRESULT					hr								= S_OK;
	
	hr = m_pBehaviorSite->GetElement( &pElement );
	if ( FAILED(hr) ) return hr;
	
	HRESULT	hrRet = S_OK;

	// Get the ID of each member of TIME that we're interested in.
	//----------------------------------------------------------------------
	//TODO: hack this to get the DA control off the page for the time being...
	CComQIPtr<IDispatch, &IID_IDispatch> pDispatch( pElement );
	if ( pDispatch == NULL ) return E_FAIL;

	for ( int i = 0; i < NUM_TIME_DISPIDS; i++ )
	{
		hr = pDispatch->GetIDsOfNames( IID_NULL,
									   const_cast<WCHAR**>( &rgszNames[i]),
									   1,
									   LOCALE_SYSTEM_DEFAULT,
									   &m_rgTimeDispids[i] );
		if ( FAILED(hr) ) hrRet = hr;;
	}
	
	return hrRet;
}

// REVIEW: This function may not be needed.
//----------------------------------------------------------------------

HRESULT CBaseBehavior::AddTimeBehavior()
{
	if ( m_pBehaviorSite == NULL ) return E_FAIL;

	HRESULT					hr = S_OK;

	// Cache pointer to time behavior factory if we don't have it
	//----------------------------------------------------------------------
	if ( m_timeBehaviorFactoryPtr == NULL )
	{
		hr = m_timeBehaviorFactoryPtr.CoCreateInstance( CLSID_LMBehaviorFactory, NULL );
		if ( FAILED(hr) ) return hr;
	}
	
	// Add behavior to our element
	//----------------------------------------------------------------------
	CComQIPtr<IUnknown, &IID_IUnknown> punkFactory( m_timeBehaviorFactoryPtr );
	CComPtr<IHTMLElement>	pElement;
 	
	hr = m_pBehaviorSite->GetElement( &pElement );
	if ( FAILED(hr) ) return hr;

	CComQIPtr<IHTMLElement2, &IID_IHTMLElement2> pElement2( pElement );
	if ( pElement2 == NULL ) return E_FAIL;

	CComVariant		varFactory( punkFactory );
	LONG			lCookie;
	
	hr = pElement2->addBehavior( CComBSTR( L"#TIMEFactory#Jump" ),
								 &varFactory,
								 &lCookie );

	return hr;
}

HRESULT CBaseBehavior::CacheDAControl()
{
	if ( m_pBehaviorSite == NULL ) return E_FAIL;

	// Get pointer to DA control
	CComPtr<IHTMLElement>	pElement;
	
	HRESULT hr = m_pBehaviorSite->GetElement( &pElement );
	if ( FAILED(hr) ) return hr;
	
	CComPtr<IDispatch>	pDispDoc;
	pElement->get_document( &pDispDoc );
	CComQIPtr<IHTMLDocument2, &IID_IHTMLDocument2> pDoc( pDispDoc );

	CComPtr<IHTMLElementCollection> pColl;
	pDoc->get_all( &pColl );

	CComVariant	varName( L"DAControl" );
	CComVariant varIndex( 0L );
	CComPtr<IDispatch> pDispElm;
	hr = pColl->item( varName, varIndex, &pDispElm );
	if ( FAILED(hr) ) return hr;
	if ( pDispElm == NULL ) return E_FAIL;

	CComQIPtr<IHTMLObjectElement, &IID_IHTMLObjectElement> pObjElt( pDispElm );
	if ( pObjElt == NULL ) return E_FAIL;

	CComPtr<IDispatch> pDispObjElt;
	pObjElt->get_object( &pDispObjElt );

	hr = pDispObjElt->QueryInterface( IID_IDAViewerControl, (LPVOID *) &m_vwrControlPtr );
	//if( !m_bDAStarted )
	//{
		m_bDAStarted = true;
		m_vwrControlPtr->raw_Start();
	//}
	/*
	else
	{
		CComPtr<IDAView> pView;
		CComPtr<IDAImage> pImage;
		CComPtr<IDASound> pSound;

		hr = m_vwrControlPtr->get_View( &pView );
		if( FAILED( hr ) )
			return hr;

		hr = m_vwrControlPtr->get_Image( &pImage );
		if( FAILED( hr ) )
			return hr;

		hr = m_vwrControlPtr->get_Sound( &pSound );
		if( FAILED( hr ) )
			return hr;

		double simTime;
		pView->get_SimulationTime( &simTime );
		pView->StopModel();

		pView->StartModel( pImage, pSound, simTime );

	}
	*/
	
	return hr;
}

HRESULT CBaseBehavior::AddBehavior( IDABehavior * in_pBehavior, long * out_pCookie )
{
	if ( m_pBehaviorSite == NULL ) return E_FAIL;

	CComPtr<IHTMLElement>	pElement;
	
	HRESULT hr = m_pBehaviorSite->GetElement( &pElement );
	if ( FAILED(hr) ) return hr;
	
	CComQIPtr<IDispatch, &IID_IDispatch> pDispatch( pElement );
	if ( pDispatch == NULL ) return E_FAIL;

	DISPPARAMS		params;
	CComVariant		varBehavior( in_pBehavior );
	CComVariant		varResult;
	EXCEPINFO		excepInfo;
	VARIANTARG		rgVarArgs[2];
	UINT			nArgErr;

	params.rgvarg				= &varBehavior;
	params.rgdispidNamedArgs	= NULL;
	params.cArgs				= 1;
	params.cNamedArgs			= 0;
	
	hr = pDispatch->Invoke( m_rgTimeDispids[ DISP_ADDDABEHAVIOR ],
							IID_NULL,
							LOCALE_USER_DEFAULT,
							DISPATCH_METHOD,
							&params,
							&varResult,
							&excepInfo,
							&nArgErr );

	if ( out_pCookie )
		*out_pCookie = V_I4( &varResult );
	
	return hr;
}

HRESULT CBaseBehavior::TurnOn()
{
	if ( m_pBehaviorSite == NULL ) return E_FAIL;

	CComPtr<IHTMLElement>	pElement;
	
	HRESULT hr = m_pBehaviorSite->GetElement( &pElement );
	if ( FAILED(hr) ) return hr;
	
	CComQIPtr<IDispatch, &IID_IDispatch> pDispatch( pElement );
	if ( pDispatch == NULL ) return E_FAIL;

	DISPPARAMS		paramsNoArgs = { NULL, NULL, 0, 0 };
	CComVariant		varResult;
	EXCEPINFO		excepInfo;
	VARIANTARG		rgVarArgs[2];
	UINT			nArgErr;

	hr = pDispatch->Invoke( m_rgTimeDispids[ DISP_TURNON ],
							IID_NULL,
							LOCALE_USER_DEFAULT,
							DISPATCH_METHOD,
							&paramsNoArgs,
							&varResult,
							&excepInfo,
							&nArgErr );
	
	return hr;
}

/**
*
*  Get the IDispatch pointer on the element.  For now we are not
*  supposed to cache pointers to the element, so we have to query
*  every time.
*
*/
HRESULT
CBaseBehavior::GetElementIDispatch( IDispatch **out_pDispatch )
{
	if( out_pDispatch == NULL )
		return E_INVALIDARG;

	if( m_pBehaviorSite == NULL )
		return E_FAIL;

	CComPtr<IHTMLElement> pElement;

	if( FAILED( m_pBehaviorSite->GetElement( &pElement ) ) )
		return E_FAIL;

	if( FAILED( pElement->QueryInterface( IID_IDispatch, (void**)out_pDispatch ) ) )
		return E_FAIL;

	return S_OK;
}

HRESULT 
CBaseBehavior::GetDur( float *out_pDur )
{
	if( out_pDur == NULL )
		return E_INVALIDARG;

	CComPtr<IDispatch> pDispatch;

	if( FAILED( GetElementIDispatch( &pDispatch ) ) )
		return E_FAIL;

	CComVariant varResult;

	m_DispatchDriver.GetProperty( pDispatch,  
								   m_rgTimeDispids[DISP_DUR], 
								   &varResult );

	varResult.ChangeType( VT_R4 );
	
	(*out_pDur) = V_R4( &varResult );

	return S_OK;
}

HRESULT 
CBaseBehavior::GetRepeatCount( float *out_pRepeatCount )
{
	if( out_pRepeatCount == NULL )
		return E_INVALIDARG;

	CComPtr<IDispatch> pDispatch;

	if( FAILED( GetElementIDispatch( &pDispatch ) ) )
		return E_FAIL;

	CComVariant varResult;

	m_DispatchDriver.GetProperty( pDispatch,  
								   m_rgTimeDispids[DISP_REPEATCOUNT], 
								   &varResult );

	varResult.ChangeType( VT_R4 );
	
	(*out_pRepeatCount) = V_R4( &varResult );

	return S_OK;
}

HRESULT 
CBaseBehavior::GetRepeatDur( float *out_pRepeatDur )
{
	if( out_pRepeatDur == NULL )
		return E_INVALIDARG;

	CComPtr<IDispatch> pDispatch;

	if( FAILED( GetElementIDispatch( &pDispatch ) ) )
		return E_FAIL;

	CComVariant varResult;

	m_DispatchDriver.GetProperty( pDispatch,  
								   m_rgTimeDispids[DISP_REPEATDUR], 
								   &varResult );

	varResult.ChangeType( VT_R4 );
	
	(*out_pRepeatDur) = V_R4( &varResult );
	return S_OK;
}

HRESULT
CBaseBehavior::GetParentElement( IHTMLElement** out_ppParentElement )
{
	if( out_ppParentElement == NULL )
		return E_INVALIDARG;
	if( m_pBehaviorSite == NULL )
		return E_FAIL;

	HRESULT hr = S_OK;

	// Get parent element
	//----------------------------------------------------------------------
	CComPtr<IHTMLElement>	pElement;
	IHTMLElement*	pParentElt;
	
	CComBSTR name;
	CComBSTR className;

	m_pBehaviorSite->GetElement( &pElement );
	pElement->get_parentElement( &pParentElt );

	//work our way up to a parent that is not an LM:ACTION
	if( pParentElt != NULL )
	{
		pParentElt->get_tagName( &name );
		pParentElt->get_className( &className );
	}

	IHTMLElement *pOldParent;

	while( pParentElt != NULL && 
		   ( (name != NULL && _wcsicmp( L"action", name )  == 0 ) || 
			 (className != NULL && _wcsicmp( L"action", className ) == 0 ) ) 
		 )
	{
		pOldParent = pParentElt;
		pOldParent->get_parentElement( &pParentElt );
		pOldParent->Release();

		if( pParentElt != NULL )
		{
			pParentElt->get_tagName( &name );
			pParentElt->get_className( &className );
		}
	}

	(*out_ppParentElement) = pParentElt;

	return S_OK;
}
	
HRESULT 
CBaseBehavior::GetParentID( BSTR *out_ppParentID )
{
	HRESULT hr = S_OK;

	CComPtr<IHTMLElement> pParentElt;

	GetParentElement( &pParentElt );

	if ( pParentElt != NULL )
	{
		pParentElt->get_id( out_ppParentID );

		// REVIEW: Get unique id if no ID was specified.
		//------------------------------------------------------------------
		if ( (*out_ppParentID) == NULL || SysStringLen( (*out_ppParentID) ) == 0 )
		{
			CComQIPtr<IHTMLUniqueName, &IID_IHTMLUniqueName> pUnique( pParentElt );
			if ( pUnique != NULL )
			{
				pUnique->get_uniqueID( out_ppParentID );
			}
		}
	}

	return hr;
}


IDANumberPtr 
CBaseBehavior::GetTimeNumberBvr()
{
	if( m_time != NULL )
	{
		return m_time;
	}

	CComPtr<IDispatch> pDispatch;

	if( FAILED( GetElementIDispatch( &pDispatch ) ) )
		return NULL;

	CComVariant varResult;

	m_DispatchDriver.GetProperty( pDispatch,  
								   m_rgTimeDispids[DISP_DUR], 
								   &varResult );

	varResult.ChangeType( VT_R4 );
	
	float duration = V_R4( &varResult);

	IDAStaticsPtr	s;
	s.CreateInstance( L"DirectAnimation.DAStatics" );

	IDANumberPtr baseTime = s->GlobalTime;

	m_startEvent = s->AppTriggeredEvent();

	IDANumberPtr startTime = s->UntilEx( s->DANumber( 0 ), m_startEvent->Snapshot( baseTime ) );
	startTime = startTime->RunOnce();

	if ( m_vwrControlPtr != NULL )
		m_vwrControlPtr->AddBehaviorToRun( startTime );

	//LONG lCookie;
	//AddBehavior( startTime, &lCookie );


	baseTime = s->Until( s->DANumber( -1 ), m_startEvent, s->Sub( baseTime, startTime ) );
	baseTime = baseTime->RunOnce();

	IDANumberPtr durationBvr = s->DANumber( duration );
	IDANumberPtr time = s->Cond( s->LT( baseTime, durationBvr ), 
								 baseTime,
								 durationBvr  
							   );

	//time = time->RunOnce();

	m_time = time;

	return time;
}

void CBaseBehavior::HandleOnChange( bool on )
{
	IDAStaticsPtr	s;
	s.CreateInstance( L"DirectAnimation.DAStatics" );

	if( on )
		s->TriggerEvent(m_startEvent, s->DATrue );
}

STDMETHODIMP CBaseBehavior::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
	if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
		return E_POINTER;
	HRESULT hr = S_OK;

	if (riid == IID_IDispatch)
	{
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
	}
	else if (riid == IID_IPersistPropertyBag)
	{
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_DATA;
	}
	else
	{
		*pdwSupportedOptions = 0;
		*pdwEnabledOptions = 0;
		hr = E_NOINTERFACE;
	}
	return hr;
}

STDMETHODIMP CBaseBehavior::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{	
	// If we're being asked to set our safe for scripting or
	// safe for initialization options then oblige
	if (riid == IID_IDispatch || riid == IID_IPersistPropertyBag  || riid == IID_IPersistStreamInit)
	{
		// Store our current safety level to return in GetInterfaceSafetyOptions
		m_dwSafety = dwEnabledOptions & dwOptionSetMask;
		return S_OK;
	}

	return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\lmbehav\src\factory.h ===
// LMBehaviorFactory.h : Declaration of the CLMBehaviorFactory

#ifndef __LMBEHAVIORFACTORY_H_
#define __LMBEHAVIORFACTORY_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CLMBehaviorFactory
class ATL_NO_VTABLE CLMBehaviorFactory : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CLMBehaviorFactory, &CLSID_LMBehaviorFactory>,
	public IDispatchImpl<ILMBehaviorFactory, &IID_ILMBehaviorFactory, &LIBID_BEHAVIORLib>,
	public IObjectSafetyImpl<CLMBehaviorFactory, INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
	public IElementBehaviorFactory
{
public:
	CLMBehaviorFactory()
	{
	}

	// IObjectSafetyImpl
	STDMETHOD(SetInterfaceSafetyOptions)(
							/* [in] */ REFIID riid,
							/* [in] */ DWORD dwOptionSetMask,
							/* [in] */ DWORD dwEnabledOptions);
	STDMETHOD(GetInterfaceSafetyOptions)(
							/* [in] */ REFIID riid, 
							/* [out] */DWORD *pdwSupportedOptions, 
							/* [out] */DWORD *pdwEnabledOptions);
    //
    // IElementBehaviorFactory
    //

	STDMETHOD(FindBehavior)(
        LPOLESTR pchNameSpace, LPOLESTR	pchTagName, IUnknown * pUnkArg, IElementBehavior ** ppBehavior);

	STDMETHODIMP UIDeactivate() { return S_OK; }
	
DECLARE_REGISTRY_RESOURCEID(IDR_LMBEHAVIORFACTORY)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CLMBehaviorFactory)
	COM_INTERFACE_ENTRY(ILMBehaviorFactory)
	COM_INTERFACE_ENTRY(IObjectSafety)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IElementBehaviorFactory)
END_COM_MAP()


private:
	DWORD m_dwSafety;

// ILMBehaviorFactory
public:
};

#endif //__LMBEHAVIORFACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\lmbehav\src\factory.cpp ===
// LMBehaviorFactory.cpp : Implementation of CLMBehaviorFactory
#include "stdafx.h"

#include "behavior.h"
#include "factory.h"

// Behaviors
#include "jump.h"
#include "pulsate.h"
#include "colcycle.h"
#include "move.h"

/////////////////////////////////////////////////////////////////////////////
// CLMBehaviorFactory

STDMETHODIMP CLMBehaviorFactory::FindBehavior( LPOLESTR pchBehaviorName,
											   LPOLESTR	pchBehaviorURL,
											   IUnknown * pUnkArg,
											   IElementBehavior ** ppBehavior)
{
    HRESULT     hr = E_FAIL;
 
	if ( _wcsicmp( L"Jump", pchBehaviorName ) == 0 )
	{
        CComObject<CJumpBehavior> * pJump;

        hr = CComObject<CJumpBehavior>::CreateInstance(&pJump);
        if ( FAILED(hr) ) goto Cleanup;

        hr = pJump->QueryInterface(IID_IElementBehavior, (void**)ppBehavior);
        if ( FAILED(hr) ) goto Cleanup;
	}
	else if ( _wcsicmp( L"Scale", pchBehaviorName ) == 0 )
	{
        CComObject<CPulsateBehavior> * pPulsate;

        hr = CComObject<CPulsateBehavior>::CreateInstance(&pPulsate);
        if ( FAILED(hr) ) goto Cleanup;

        hr = pPulsate->QueryInterface(IID_IElementBehavior, (void**)ppBehavior);
        if ( FAILED(hr) ) goto Cleanup;
	}
	else if ( _wcsicmp( L"Color", pchBehaviorName ) == 0 )
	{
        CComObject<CColorCycleBehavior> * pColor;

        hr = CComObject<CColorCycleBehavior>::CreateInstance(&pColor);
        if ( FAILED(hr) ) goto Cleanup;

        hr = pColor->QueryInterface(IID_IElementBehavior, (void**)ppBehavior);
        if ( FAILED(hr) ) goto Cleanup;
	}
	else if ( _wcsicmp( L"Move", pchBehaviorName ) == 0 )
	{
		CComObject<CMoveBehavior> *pMove;

		hr = CComObject<CMoveBehavior>::CreateInstance( &pMove );
		if( FAILED(hr) ) goto Cleanup;

		hr = pMove->QueryInterface( IID_IElementBehavior, (void**)ppBehavior );
		if( FAILED(hr) ) goto Cleanup;
	}
	
Cleanup:
    return hr;

}

STDMETHODIMP CLMBehaviorFactory::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
	if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
		return E_POINTER;
	HRESULT hr = S_OK;

	if (riid == IID_IDispatch)
	{
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
	}
	else if (riid == IID_IPersistPropertyBag2 )
	{
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_DATA;
	}
	else
	{
		*pdwSupportedOptions = 0;
		*pdwEnabledOptions = 0;
		hr = E_NOINTERFACE;
	}
	return hr;
}

STDMETHODIMP CLMBehaviorFactory::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{	
	// If we're being asked to set our safe for scripting or
	// safe for initialization options then oblige
	if (riid == IID_IDispatch || riid == IID_IPersistPropertyBag2 )
	{
		// Store our current safety level to return in GetInterfaceSafetyOptions
		m_dwSafety = dwEnabledOptions & dwOptionSetMask;
		return S_OK;
	}

	return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\lmbehav\src\color.h ===
#ifndef __COLOR_H__
#define __COLOR_H__

#include <limits.h>

class CColor
{
public:
	CColor();

	float	GetR() { return m_r / ((float) UCHAR_MAX ); }
	float	GetG() { return m_g / ((float) UCHAR_MAX ); }
	float	GetB() { return m_b / ((float) UCHAR_MAX ); }

	float	GetH() { return m_h; }
	float	GetS() { return m_s; }
	float 	GetL() { return m_l; }
	
	HRESULT	Parse( BSTR in_bstr );
	HRESULT	ToString( BSTR * out_pbstr );
	ULONG	ToRGBDWORD();
	HRESULT	RGBToHSL( float r, float g, float b, float& h, float& s, float &l );

public:
	static const WCHAR PREFIX_COLOR;
	static const float HUE_UNDEFINED;

private:
	unsigned char	m_r;
	unsigned char	m_g;
	unsigned char	m_b;

	float	m_h;
	float 	m_s;
	float	m_l;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\lmbehav\src\jump.cpp ===
// JumpBehavior.cpp : Implementation of CJumpBehavior
#include "stdafx.h"

#include "behavior.h"
#include "Jump.h"

/////////////////////////////////////////////////////////////////////////////
// CJumpBehavior

CJumpBehavior::CJumpBehavior()
{
}

HRESULT CJumpBehavior::BuildDABehaviors()
{
	HRESULT	hr		= S_OK;

	// Get parent element
	//----------------------------------------------------------------------
	CComPtr<IHTMLElement>	pElement;
	CComPtr<IHTMLElement>	pParentElt;
	CComPtr<IHTMLStyle>		pParentStyle;
	m_pBehaviorSite->GetElement( &pElement );
	pElement->get_parentElement( &pParentElt );

	pParentElt->get_style( &pParentStyle );

	if ( pParentStyle == NULL ) return E_FAIL;

	// Get original values
	//----------------------------------------------------------------------
	CComBSTR								cbstrID;
	
	hr = GetParentID( &cbstrID );
	if ( FAILED(hr) ) return hr;

	float 		fLeft, fTop;
	
	hr = pParentStyle->get_posLeft( &fLeft );
	if ( FAILED(hr) ) return E_FAIL;
	hr = pParentStyle->get_posTop( &fTop );
	if ( FAILED(hr) ) return E_FAIL;

	// Set up DA Tree
	//----------------------------------------------------------------------
	IDAStaticsPtr	e;

	e.CreateInstance( L"DirectAnimation.DAStatics" );

	float 			fDuration	= 0.0;
	if ( FAILED( GetDur( &fDuration ) ) )
		return E_FAIL;

	IDANumberPtr	timePtr	= GetTimeNumberBvr();
	if ( timePtr == NULL )
		return E_FAIL;

	// Animate values
	//----------------------------------------------------------------------
	double			dXRange		= 300.0;
	double			dYRange		= 300.0;
	
	// Random numbers between -0.5 and 0.5
	IDANumberPtr	randX = e->Sub( e->Mod( e->SeededRandom( rand() ), e->DANumber( 1.0 ) ), e->DANumber( 0.5 ) );
	IDANumberPtr	randY = e->Sub( e->Mod( e->SeededRandom( rand() ), e->DANumber( 1.0 ) ), e->DANumber( 0.5 ) );

	// Time changes only once at each interval
	IDANumberPtr	time = e->Floor( e->Div( timePtr, e->DANumber( fDuration ) ) );

	randX = randX->SubstituteTime( time );
	randY = randY->SubstituteTime( time );

 	// Jump range
	IDANumberPtr	rangeLeft = e->Add( e->DANumber( fLeft ), e->Mul( randX, e->DANumber( dXRange ) ) );
	IDANumberPtr	rangeTop  = e->Add( e->DANumber( fTop ), e->Mul( randY, e->DANumber( dYRange ) ) );

	IDAPoint2Ptr pos = e->Point2Anim( rangeLeft, rangeTop );

	pos = e->Cond( e->GT( timePtr, e->DANumber( -1 ) ),
				   pos,
				   e->Point2( fLeft, fTop ) );
					   
	IDAPoint2Ptr animPos = pos->AnimateControlPosition(
		_bstr_t( cbstrID ), L"JScript", VARIANT_FALSE, 0.02 );

	// Add to the behaviors to run
	//----------------------------------------------------------------------
	if ( m_vwrControlPtr != NULL )
		hr = m_vwrControlPtr->AddBehaviorToRun( animPos );
	
// 	LONG	lCookie;
// 	hr = AddBehavior( animPos, &lCookie );
// 	if ( FAILED(hr) ) return hr;
	
// 	hr = TurnOn();
// 	if ( FAILED(hr) ) return hr;
	
	return hr;
}

STDMETHODIMP CJumpBehavior::Notify(LONG dwNotify, VARIANT * pVar)
{
	HRESULT hr = CBaseBehavior::Notify( dwNotify, pVar );

	if ( dwNotify == BEHAVIOREVENT_DOCUMENTREADY )
	{
		BuildDABehaviors();
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\lmbehav\src\jump.h ===
// JumpBehavior.h : Declaration of the CJumpBehavior

#ifndef __JUMPBEHAVIOR_H_
#define __JUMPBEHAVIOR_H_

#include "resource.h"       // main symbols
#include "base.h"

/////////////////////////////////////////////////////////////////////////////
// CJumpBehavior
class ATL_NO_VTABLE CJumpBehavior :
	public CBaseBehavior, 
	public CComCoClass<CJumpBehavior, &CLSID_JumpBehavior>,
	public IDispatchImpl<IJumpBehavior, &IID_IJumpBehavior, &LIBID_BEHAVIORLib>
{
public:
	CJumpBehavior();

	STDMETHOD(Notify)(LONG event, VARIANT * pVar);
	
	//needed by CBaseBehavior
	void *GetInstance() { return (IJumpBehavior *) this ; }
	
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }

DECLARE_REGISTRY_RESOURCEID(IDR_JUMPBEHAVIOR)

BEGIN_COM_MAP(CJumpBehavior)
	COM_INTERFACE_ENTRY(IJumpBehavior)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY_CHAIN(CBaseBehavior)
END_COM_MAP()

// IJumpBehavior
public:

protected:
	HRESULT			BuildDABehaviors();
};

#endif //__JUMPBEHAVIOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\lmbehav\src\move.h ===
/**********************************
*
*
*
************************************/

#ifndef __MOVEBEHAVIOR_H_
#define __MOVEBEHAVIOR_H_

#include "resource.h"

#include "behavior.h"

#include "base.h"

#include "point.h"

class ATL_NO_VTABLE CMoveBehavior: 
	public CComCoClass<CMoveBehavior, &CLSID_MoveBehavior>,
	public IDispatchImpl<IMoveBehavior, &IID_IMoveBehavior, &LIBID_BEHAVIORLib>,
	public CBaseBehavior
{
public:
	CMoveBehavior();
	~CMoveBehavior();

	DECLARE_PROTECT_FINAL_CONSTRUCT()

	BEGIN_COM_MAP(CMoveBehavior)
		COM_INTERFACE_ENTRY(IMoveBehavior)
		COM_INTERFACE_ENTRY(IDispatch)
		COM_INTERFACE_ENTRY_CHAIN(CBaseBehavior)
	END_COM_MAP()
public:
	STDMETHOD(get_on)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_on)(/*[in]*/ VARIANT newVal);
	//IElementBehavior
	STDMETHOD(Notify)(LONG event, VARIANT * pVar);

	//IMoveBehavior
	STDMETHOD(get_to)(/*[out, retval]*/ BSTR* pVal);
	STDMETHOD(put_to)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_from)(/*[out, retval]*/ BSTR* pVal);
	STDMETHOD(put_from)(/*[in]*/ BSTR newVal);

	//returns a pointer to the instance of IDispatch
	void *GetInstance() 
		{ return (IMoveBehavior*)this; }
	//
	HRESULT GetTypeInfo( ITypeInfo **ppTypeInfo )
		{ return GetTI(GetUserDefaultLCID(), ppTypeInfo); }

protected:
	HRESULT BuildDABehaviors();
private:

	CPoint *m_pFrom;
	CPoint *m_pTo;

	DWORD m_cookie;
};

#endif //ifndef __MOVEBEHAVIOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\lmbehav\src\point.cpp ===
#include "stdafx.h"

#include "point.h"

//States for the parser
#define PARSE_ERROR -1
#define GETX  1
#define GETY  2
#define GETZ  3
#define END   4
/*
#define PARSE_ERROR -1
#define START 0
#define GOTX  1
#define GOTY  2
#define GOTZ  3
#define XDBL  4
#define YDBL  5
#define ZDBL  6
#define ENDX  7
#define ENDY  8
#define ENDZ  9
#define DONE  10
*/

CPoint::CPoint():
	m_x(0.0), 
	m_y(0.0), 
	m_z(0.0),
	m_pStringRep(NULL)
{
}

CPoint::~CPoint()
{
	if( m_pStringRep != NULL )
		SysFreeString( m_pStringRep );
}

HRESULT
CPoint::ToString( BSTR* pToString )
{
	if( pToString == NULL )
		return E_INVALIDARG;

	(*pToString) = SysAllocString( m_pStringRep );

	return S_OK;
}

HRESULT
CPoint::Parse(BSTR pString)
{
	if( m_pStringRep != NULL )
		SysFreeString( m_pStringRep );
	m_pStringRep = SysAllocString( pString );

	//zero out the double representation
	m_x = m_y = m_z = 0;

	int state = GETX;

	//if the string representation is non null
	if( m_pStringRep != NULL && state != END )
	{
		CComBSTR buffer( m_pStringRep );
		wchar_t* token = NULL;

		wchar_t* seps = L" ,\t\n";

		token = wcstok( buffer.m_str, seps );
		while( token != NULL )
		{
			switch( state )
			{
			case GETX:
				if( swscanf( token, L"%lf", &m_x ) == 1 )
					state = GETY;
				else
					state = PARSE_ERROR;
				break;
			case GETY:
				if( swscanf( token, L"%lf", &m_y ) == 1 )
					state = GETZ;
				else
					state = PARSE_ERROR;
				break;
			case GETZ:
				if( swscanf( token, L"%lf", &m_z ) == 1 )
					state = END;
				else
					state = PARSE_ERROR;
				break;
			default:
				state = PARSE_ERROR;
			}
			
			if( state != PARSE_ERROR )
				token = wcstok( NULL, seps );
		}
		if( state != GETX &&
			state != GETY &&
			state != GETZ &&
			state != END )
			return E_INVALIDARG;
	/*
		//parse it into double representation
		//we are expecting a string of the format
		//[x:[NN[.NN]];][y:[NN[.NN]];][z:[NN[.NN]];]
		//where N is a digit 0-9 and any value not specified
		// defaults to 0

		int state = START;

		int curCharNum = 0;
		WCHAR curChar;
		int len = SysStringLen(m_pStringRep);

		double whole = 0.0; 
		double frac = 0.0;
		bool inFrac = false;

		while( curCharNum < len && state != PARSE_ERROR )
		{
			curChar = m_pStringRep[curCharNum];
			//eat whitespace
			while( iswspace( curChar ) )
			{
				curCharNum++;
				if( curCharNum < len )
				{
					curChar = m_pStringRep[curCharNum];
				}
				else
				{
					state = PARSE_ERROR;
					break;
				}
			}

			switch( state )
			{

			case START:
				if( curChar == L'x' || curChar == L'X' )
					state = GOTX;
				else if( curChar == L'y' || curChar == L'Y' )
					state = GOTY;
				else if( curChar == L'z' || curChar == L'Z' )
					state = GOTZ;
				else
					state = PARSE_ERROR;
				break;
			case GOTX:
				if( curChar == L':' )
					state = XDBL;
				else
					state = PARSE_ERROR;
				break;
			case GOTY:
				if( curChar == L':' )
					state = YDBL;
				else
					state = PARSE_ERROR;
				break;
			case GOTZ:
				if( curChar == L':' )
					state = ZDBL;
				else
					state = PARSE_ERROR;
				break;
			case XDBL:
			case YDBL:
			case ZDBL:
				whole = 0.0;
				frac = 0.0;
				inFrac = false;
				//parse a double from the string
				while( curCharNum < len && 
					   ( (curChar >= L'0' && curChar <=L'9') || 
						 (curChar == L'.') 
					   ) 
					 )
				{
					curChar = m_pStringRep[curCharNum];

					if( curChar >= L'0' && curChar <= L'9' )
					{
						if( !inFrac )
							whole = 10 * whole + (curChar - L'0');
						else
							frac = (frac + (curChar - L'0' ) ) * 0.1;
					}
					else if( curChar == L'.' )
					{
						if( !inFrac )
							inFrac = true;
						else
						{
							state = PARSE_ERROR;
							break;
						}
					}

					curCharNum++;
				}

				if( state == PARSE_ERROR )
					break;
				
				curCharNum--;

				//eat whitespace
				while( iswspace( curChar ) )
				{
					curCharNum++;
					if( curCharNum < len )
					{
						curChar = m_pStringRep[curCharNum];
					}
					else
					{
						state = PARSE_ERROR;
						break;
					}
				}

				if( curChar == L';' )
				{
					if( state == XDBL )
					{
						m_x = whole + frac;
						state = ENDX;
					}
					else if( state == YDBL )
					{
						m_y = whole + frac;
						state = ENDY;
					}
					else if( state == ZDBL )
					{
						m_z = whole + frac;
						state = ENDZ;
					}
				}
				else
					state = PARSE_ERROR;
				break;
			case ENDX:
				if( curChar == L'y' || curChar == L'Y' )
					state = GOTY;
				else if( curChar == L'z' || curChar == L'Z' )
					state = GOTZ;
				else if( curChar == L'\0' )
					state = DONE;
				else
					state = PARSE_ERROR;
				break;
			case ENDY:
				if( curChar == L'z' || curChar == L'Z' )
					state = GOTZ;
				else if( curChar == L'\0' )
					state = DONE;
				else
					state = PARSE_ERROR;
				break;
			case ENDZ:
				if( curChar == L'\0' )
					state = DONE;
				else
					state = PARSE_ERROR;
				break;
			default:
				//shouldn't get here
				state = PARSE_ERROR;
			}

			curCharNum++;
		}
		if( state != DONE && 
			state != ENDX && 
			state != ENDY && 
			state != ENDZ)
		{
			return E_INVALIDARG;
		}
		*/
	}

	return S_OK;
}

IDAPoint2Ptr 
CPoint::GetDAPoint2( IDAStaticsPtr s )
{
	return s->Point2( m_x, m_y );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\lmbehav\src\stdafx.h ===
#include "../include/stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\lmbehav\src\move.cpp ===
#include "stdafx.h"

#include "move.h"

CMoveBehavior::CMoveBehavior() : 
	m_pFrom(NULL),
	m_pTo(NULL)
{
}

CMoveBehavior::~CMoveBehavior()
{
	if( m_pFrom != NULL )
		delete m_pFrom;
	
	if( m_pTo != NULL )
		delete m_pTo;
}

//IElementBehavior

STDMETHODIMP 
CMoveBehavior::Notify(LONG dwNotify, VARIANT * pVar)
{
	HRESULT hr = CBaseBehavior::Notify( dwNotify, pVar );

	if ( dwNotify == BEHAVIOREVENT_DOCUMENTREADY )
	{
		BuildDABehaviors();

		CComPtr<IHTMLElement> pParent;
		GetParentElement( &pParent );
		if( pParent != NULL )
		{
			CComPtr<IHTMLCurrentStyle> pCurrentStyle;
			CComBSTR pCurrentPosition;

			CComQIPtr<IHTMLElement2, &IID_IHTMLElement2> pParent2(pParent);
			if( pParent2 == NULL )
				return E_FAIL;
			hr = pParent2->get_currentStyle( &pCurrentStyle );
			if( FAILED( hr ) )
				return hr;
			if( pCurrentStyle != NULL )
			{
				hr = pCurrentStyle->get_position( &pCurrentPosition );
				if( FAILED( hr ) )
					return hr;
				if( !pCurrentPosition || 
					( _wcsicmp( L"static", pCurrentPosition ) == 0 ) )
				{
					CComPtr<IHTMLStyle> pStyle;
					hr = pParent2->get_runtimeStyle( &pStyle );
					if( FAILED( hr ) )
						return hr;
					if( pStyle != NULL )
					{
						CComQIPtr<IHTMLStyle2, &IID_IHTMLStyle2> pStyle2(pStyle);
						hr = pStyle2->put_position( L"relative" );
						if( FAILED( hr ) )
							return hr;
					}
				}
			}
		}
	}
	
	return hr;
}


//IMoveBehavior

STDMETHODIMP 
CMoveBehavior::get_from(BSTR *pVal)
{
	if( pVal == NULL )
		return E_INVALIDARG;
	
	if( m_pFrom != NULL)
		m_pFrom->ToString( pVal );
	else
		(*pVal) = NULL;

	return S_OK;
}

STDMETHODIMP 
CMoveBehavior::put_from(BSTR newVal)
{
	if( m_pFrom == NULL )
		m_pFrom = new CPoint();
	
	if( FAILED( m_pFrom->Parse( newVal ) ) )
		return E_FAIL;

	return S_OK;
}

STDMETHODIMP
CMoveBehavior::get_to(BSTR *pVal)
{

	if( pVal == NULL )
		return E_INVALIDARG;
	
	if(m_pTo != NULL )
		m_pTo->ToString( pVal );
	else
		(*pVal) = NULL;

	return S_OK;
}

STDMETHODIMP
CMoveBehavior::put_to(BSTR newVal)
{
	if( m_pTo == NULL )
		m_pTo = new CPoint();
	
	if( FAILED( m_pTo->Parse( newVal ) ) )
		return E_FAIL;

	return S_OK;
}

//class members

HRESULT
CMoveBehavior::BuildDABehaviors()
{
	if( m_pFrom == NULL || m_pTo == NULL )
		return E_FAIL;

	HRESULT hr = S_OK;
	CComBSTR pParentID;

	hr = GetParentID( &pParentID );
	
	if( FAILED( hr ) )
		return hr;

	IDANumberPtr timeFunction;

	float duration = 0.0;
	if( FAILED ( GetDur( &duration ) ) )
		return E_FAIL;

	timeFunction = GetTimeNumberBvr();
	if( timeFunction == NULL )
		return E_FAIL;

	IDAStaticsPtr	s;

	s.CreateInstance( L"DirectAnimation.DAStatics" );

	//IDANumberPtr xCoord = s->Interpolate( m_pFrom->GetX(), m_pTo->GetX(), duration );
	//IDANumberPtr yCoord = s->Interpolate( m_pFrom->GetY(), m_pTo->GetY(), duration );

	IDANumberPtr startX = s->DANumber( m_pFrom->GetX() );
	IDANumberPtr startY = s->DANumber( m_pFrom->GetY() );
	IDANumberPtr endX   = s->DANumber( m_pTo->GetX() );
	IDANumberPtr endY   = s->DANumber( m_pTo->GetY() );
	IDANumberPtr durationBvr = s->DANumber( duration );

	IDANumberPtr t = s->Div( timeFunction, durationBvr );

	IDANumberPtr xCoord =  s->Add( startX, s->Mul( s->Sub( endX, startX ), t ) );
	IDANumberPtr yCoord =  s->Add( startY, s->Mul( s->Sub( endY, startY ), t ) );


	IDAPoint2Ptr pos = s->Point2Anim( xCoord, yCoord );

	pos = s->Cond( s->GT( timeFunction, s->DANumber( -1 ) ),
				   pos,
				   s->Point2( m_pFrom->GetX(), m_pFrom->GetY() )
				 );

	pos = pos->AnimateControlPosition( pParentID.m_str, L"JavaScript", VARIANT_FALSE, 0.02 );

	//add the behavior and start time.
	LONG	lCookie;
	
	if ( m_vwrControlPtr != NULL )
		hr = m_vwrControlPtr->AddBehaviorToRun( pos );

//	hr = AddBehavior( pos, &lCookie );
//		if ( FAILED(hr) ) return hr;

//	hr = TurnOn();
//		if ( FAILED(hr) ) return hr;

	return hr;
}

STDMETHODIMP CMoveBehavior::get_on(VARIANT * pVal)
{
	if( pVal == NULL )
		return E_INVALIDARG;

	V_VT(pVal)  = VT_BOOL;
	V_BOOL(pVal)= m_on ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CMoveBehavior::put_on(VARIANT newVal)
{
	VariantChangeType( &newVal, &newVal, 0, VT_BOOL );
	
	m_on = V_BOOL(&newVal) == VARIANT_TRUE ? true : false;
	
	HandleOnChange( m_on );

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\lmbehav\src\point.h ===
/********************************
*
*
*********************************/

#ifndef __POINT_H_
#define __POINT_H_

#include "resource.h"

class CPoint
{
public:
	CPoint();
	~CPoint();

	double GetX(){ return m_x; }
	double GetY(){ return m_y; }
	double GetZ(){ return m_z; }

	HRESULT Parse( BSTR pString );

	HRESULT ToString( BSTR* pToString );

	IDAPoint2Ptr GetDAPoint2( IDAStaticsPtr s );

private:
	double m_x;
	double m_y;
	double m_z;

	BSTR m_pStringRep;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\lmbehav\src\pulsate.h ===
// PulsateBehavior.h : Declaration of the CPulsateBehavior




#ifndef __PULSATEBEHAVIOR_H_
#define __PULSATEBEHAVIOR_H_

#include "resource.h"       // main symbols
#include "base.h"
#include "point.h"

/////////////////////////////////////////////////////////////////////////////
// CPulsateBehavior
class ATL_NO_VTABLE CPulsateBehavior : 
	public CBaseBehavior,
	public CComCoClass<CPulsateBehavior, &CLSID_PulsateBehavior>,
	public IDispatchImpl<IPulsateBehavior, &IID_IPulsateBehavior, &LIBID_BEHAVIORLib>
{
protected:
	double					m_dPercent;
	
public:
	CPulsateBehavior();
	~CPulsateBehavior();

	STDMETHOD(Notify)(LONG event, VARIANT * pVar);
	
	//needed by CBaseBehavior
	void *GetInstance() { return (IPulsateBehavior *) this ; }

    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }
	
DECLARE_REGISTRY_RESOURCEID(IDR_PULSATEBEHAVIOR)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPulsateBehavior)
	COM_INTERFACE_ENTRY(IPulsateBehavior)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY_CHAIN(CBaseBehavior)
END_COM_MAP()

// IPulsateBehavior
public:
	STDMETHOD(get_by)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_by)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_to)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_to)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_from)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_from)(/*[in]*/ BSTR newVal);

protected:
	HRESULT			BuildDABehaviors();
	
protected:
	CPoint	*	m_pFrom;
	CPoint	*	m_pTo;
	CPoint	*	m_pBy;
};

#endif //__PULSATEBEHAVIOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\messages\usa\makefile.inc ===
lmrt.rc : $(SDKDIR)\lmrt.tlb \
          lmctrl.rgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\lm\lmbehav\src\pulsate.cpp ===
// PulsateBehavior.cpp : Implementation of CPulsateBehavior
#include "stdafx.h"
#include "Behavior.h"
#include "Pulsate.h"

/////////////////////////////////////////////////////////////////////////////
// CPulsateBehavior

CPulsateBehavior::CPulsateBehavior() :
	m_pFrom( NULL ),
	m_pTo( NULL ),
	m_pBy( NULL )
{
}

CPulsateBehavior::~CPulsateBehavior()
{
	delete m_pFrom;
	delete m_pTo;
	delete m_pBy;
}

HRESULT	CPulsateBehavior::BuildDABehaviors()
{
	if ( m_pBehaviorSite == NULL ) return E_FAIL;

	// Get parent element
	//----------------------------------------------------------------------
	CComPtr<IHTMLElement>	pElement;
	CComPtr<IHTMLElement>	pParentElt;
	CComPtr<IHTMLStyle>		pParentStyle;
	
	m_pBehaviorSite->GetElement( &pElement );
	pElement->get_parentElement( &pParentElt );

	pParentElt->get_style( &pParentStyle );

	if ( pParentStyle == NULL ) return E_FAIL;

	// Set up DA Tree
	//----------------------------------------------------------------------
	IDAStaticsPtr	e;
	
	e.CreateInstance( L"DirectAnimation.DAStatics" );

	float 			fDuration	= 0.0;
	if ( FAILED( GetDur( &fDuration ) ) )
		return E_FAIL;

	IDANumberPtr	timePtr	= GetTimeNumberBvr();
	if ( timePtr == NULL )
		return E_FAIL;

	IDANumberPtr	tNorm = e->Div( timePtr, e->DANumber( fDuration ) );
	
	// Get original values
	//----------------------------------------------------------------------
	HRESULT		hr			= S_OK;
	CComBSTR	cbstrID;
	
	hr = GetParentID( &cbstrID );
	if ( FAILED(hr) ) return hr;

	float 		fLeft, fTop, fWidth, fHeight;
		
	hr = pParentStyle->get_posLeft( &fLeft );
	if ( FAILED(hr) ) return E_FAIL;
	hr = pParentStyle->get_posTop( &fTop );
	if ( FAILED(hr) ) return E_FAIL;
	hr = pParentStyle->get_posWidth( &fWidth );
	if ( FAILED(hr) ) return E_FAIL;
	hr = pParentStyle->get_posHeight( &fHeight );
	if ( FAILED(hr) ) return E_FAIL;

	double			dXFrom, dYFrom;
	double			dXTo, dYTo;
	
	if ( m_pFrom == NULL )
	{
		dXFrom = 1.0;
		dYFrom = 1.0;
	}
	else
	{
		dXFrom = m_pFrom->GetX()/100.0;
		dYFrom = m_pFrom->GetY()/100.0;
	}
	
	if ( m_pTo == NULL )
	{
		if ( m_pBy == NULL )
		{
			dXTo = 1.0;
			dYTo = 1.0;
		}
		// TODO: Scale relative to current scale
		else
		{
			dXTo = 1.0;
			dYTo = 1.0;
		}
	}
	else
	{
		dXTo = m_pTo->GetX()/100.0;
		dYTo = m_pTo->GetY()/100.0;
	}
	
	// Animate width and height
	//----------------------------------------------------------------------
	double			xC		= fLeft + fWidth/2;
	double			yC		= fTop + fHeight/2;
	
	IDANumberPtr	fromX	= e->DANumber( dXFrom );
	IDANumberPtr	interpX = e->Add( fromX, e->Mul( tNorm, e->Sub( e->DANumber( dXTo ), fromX ) ) );

	IDANumberPtr	fromY	= e->DANumber( dYFrom );
	IDANumberPtr	interpY	= e->Add( fromY, e->Mul( tNorm, e->Sub( e->DANumber( dYTo ), fromY ) ) );

	IDANumberPtr	xScale	= e->Mul( interpX, e->DANumber( fWidth ) );
	IDANumberPtr	yScale	= e->Mul( interpY, e->DANumber( fHeight ) );

	xScale = e->Cond( e->GT( timePtr, e->DANumber( -1 ) ),
					  xScale,
					  e->DANumber( dXTo * fWidth ) );
	
	yScale = e->Cond( e->GT( timePtr, e->DANumber( -1 ) ),
					  yScale,
					  e->DANumber( dYTo * fHeight ) );
	
	IDANumberPtr	animWidth	= xScale->AnimateProperty(
		_bstr_t( cbstrID + L"." + L"style.posWidth" ), "JScript", VARIANT_FALSE, 0.02 );
	IDANumberPtr	animHeight	= yScale->AnimateProperty(
		_bstr_t( cbstrID + L"." + L"style.posHeight" ), "JScript", VARIANT_FALSE, 0.02 );

	// Left, Top must be animated to keep the center in the same place.
	IDANumberPtr	xPos	= e->Sub( e->DANumber( xC ), e->Div( xScale, e->DANumber( 2 ) ) );
	IDANumberPtr	yPos	= e->Sub( e->DANumber( yC ), e->Div( yScale, e->DANumber( 2 ) ) );

	IDAPoint2Ptr	pos		= e->Point2Anim( xPos, yPos );

	pos = e->Cond( e->GT( timePtr, e->DANumber( -1 ) ),
				   pos,
				   e->Point2( xC-(dXTo*fWidth/2), yC-(dYTo*fHeight/2) ) );
	
	IDAPoint2Ptr	animPos	= pos->AnimateControlPosition(
		_bstr_t( cbstrID ), L"JScript", VARIANT_FALSE, 0.02 );
		
	// Add all the behaviors to run
	//----------------------------------------------------------------------
	if ( m_vwrControlPtr != NULL )
	{
		hr = m_vwrControlPtr->AddBehaviorToRun( animPos );
		if ( FAILED(hr) ) return hr;
		
		hr = m_vwrControlPtr->AddBehaviorToRun( animWidth );
		if ( FAILED(hr) ) return hr;
		
		hr = m_vwrControlPtr->AddBehaviorToRun( animHeight );
		if ( FAILED(hr) ) return hr;
	}
	
// 	LONG			lCookieWidth, lCookieHeight;
// 	LONG			lCookiePos;
	
//  	hr = AddBehavior( animPos, &lCookiePos );
//  	if ( FAILED(hr) ) return hr;
	
// 	hr = AddBehavior( animWidth, &lCookieWidth );
// 	if ( FAILED(hr) ) return hr;
	
// 	hr = AddBehavior( animHeight, &lCookieHeight );
// 	if ( FAILED(hr) ) return hr;
	
// 	hr = TurnOn();
// 	if ( FAILED(hr) ) return hr;
	
	return S_OK;
}

STDMETHODIMP CPulsateBehavior::Notify(LONG dwNotify, VARIANT * pVar)
{
	HRESULT hr = CBaseBehavior::Notify( dwNotify, pVar );

	if ( dwNotify == BEHAVIOREVENT_DOCUMENTREADY )
	{
		BuildDABehaviors();
	}
	
	return hr;
}

STDMETHODIMP CPulsateBehavior::get_from(BSTR * pVal)
{
	if( pVal == NULL )
		return E_INVALIDARG;
	
	if( m_pFrom != NULL)
		m_pFrom->ToString( pVal );
	else
		(*pVal) = NULL;

	return S_OK;
}

STDMETHODIMP CPulsateBehavior::put_from(BSTR newVal)
{
	if( m_pFrom == NULL )
		m_pFrom = new CPoint();
	
	if( FAILED( m_pFrom->Parse( newVal ) ) )
		return E_FAIL;

	return S_OK;
}

STDMETHODIMP CPulsateBehavior::get_to(BSTR * pVal)
{
	if( pVal == NULL )
		return E_INVALIDARG;
	
	if(m_pTo != NULL )
		m_pTo->ToString( pVal );
	else
		(*pVal) = NULL;

	return S_OK;
}

STDMETHODIMP CPulsateBehavior::put_to(BSTR newVal)
{
	if( m_pTo == NULL )
		m_pTo = new CPoint();
	
	if( FAILED( m_pTo->Parse( newVal ) ) )
		return E_FAIL;

	return S_OK;
}

STDMETHODIMP CPulsateBehavior::get_by(BSTR * pVal)
{
	if( pVal == NULL )
		return E_INVALIDARG;
	
	if(m_pBy != NULL )
		m_pBy->ToString( pVal );
	else
		(*pVal) = NULL;

	return S_OK;
}

STDMETHODIMP CPulsateBehavior::put_by(BSTR newVal)
{
	if( m_pBy == NULL )
		m_pBy = new CPoint();
	
	if( FAILED( m_pBy->Parse( newVal ) ) )
		return E_FAIL;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\mmapi\dll\stdafx.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Ole Object initialization

Revision:

--*/

#include "headers.h"

#undef map
#undef SubclassWindow

// Put this here to initialize all the ATL stuff

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\mmapi\common.inc ===
PROJNAME=mmapi
DO_NOT_USE_EH=1

!include $(ROOT)\common.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\make\make1.inc ===
# -------------------------------------------------------------
# Symbols defined in build.inc or environment
# Note that all user definable symbols are prefixed with an "_".
# -------------------------------------------------------------
# _BCHECKER             - If 1, a BoundsChecker Pro build is done.
# _BROWSE               - full=2, partial=1, none=0 [default=0]
# _COPYMAC              - if 1, mfile Mac Appelles build to Macintosh
# _DEBUG                - 0 = Retail with symbols
#                         1 = Debug
# _ENABLE_PERF_RPTING   - 1 = performance reporting to stdout enabled
#                         0 = disable performance reporting [default]
# _ERRORS_OK            - if 1 then continue building on errors [default=0]
# _KEEPTEMPFILES        - keep temporary makefiles [default=0]
# _LINK_WITH_OBJS       - list objs in .lib files [default=0]
# _MACFOLDER            - root Mac folder to which Mac Appelles is mfile'd
# _MACSYMS              - compile and copy Macintosh symbol files
# _MACTEXT              - defined if no RichText library available
# _MACHINE              - [default=x86]
# _MAP                  - if 1 then build map files [default=0]
# _NO_CRT               - if 1 then don't use c runtime [default=0]
# _NO_DYNLINKCRT        - if 1 then don't use crt dll [default = 1]
# _NO_INCREMENTAL_LINK  - 1 forces a full link. 0 implies _MAP=0
#                          [default=0 for _DEBUG==1, 1 otherwise]
# _NO_MINIMAL_REBUILD   - 0 = Allow C++ compiler to skip .CPP files if no class
#                             definitions in any .H files have changed
#                         1 = Normal file dependancies
#                          [default = 0 iff PDBFILE != NONE,
#                                     1 otherwise ]
# _NO_INCREMENTAL_COMP  - 0 = Allow C++ compiler to skip functions which have
#                             not changed since last compile
#                         1 = Normal complete compiles
#                          [default = 1]
# _PROFILE              - 0 = disable IceCAP profiling [default]
#                         1 = enable IceCAP profiling
# _SYSTEM               - [default=winnt]
# _TIMING               - if 1 then turn on timing [default=0]
# _USERCFLAGS           - add to compiler flags [default=]
# _USERLFLAGS           - add to link flags [default=]
# _USERRFLAGS           - add to resource compiler flags [default=]
# _WARNINGLEVEL         - warning level [default=3]
# _WARNINGSAREERRORS    - stop compiling on warnings [default=1]
#
# -------------------------------------------------------------
# Symbols defined in makefile before including make1.inc
# -------------------------------------------------------------
# ROOT          - root of srctree  [required]
# MODULE        - name of module   [required]
# PCHFILE       - name of precompiled header, no extension or path [optional]
# PCHPATH       - path to precompiled header [optional]
# INCLUDEDIRS   - search for include files in these directories [optional]
# PDBFILE       - use this as pdb file, or if "NONE" don't use pdb file
#
# -------------------------------------------------------------
# Symbols defined in makefile after including make1.inc
# -------------------------------------------------------------
# LIBTARG       - build library
# LIBOBJS       - list of object files to add to library
#
# -------------------------------------------------------------
# Symbols defined by this file
# -------------------------------------------------------------
# BLDROOT       - root of build tree
# BLDDIR        - build directory for this module
# SRCROOT       - root of the source tree
# SRCDIR        - this directory
# TMPDIR        - location for temporary files
# BINDIR        - final products directory
# SDKDIR        - Appelles SDK
# ELEVATEDIR    - Elevated files
# CRTLIBC       - path to LIBC[D].LIB (including the "LIBC[D].LIB")
# MACDLLCREATOR - Mac Creator Sig for Appelles dll
# MACEXECREATOR - Mac Creator Sig for Appelles
#
# -------------------------------------------------------------
# Targets
# -------------------------------------------------------------
# beep          Beeps.  Generates a beep function that is audible to the
#                       developer.  Usage:  nmake all beep.
#
# all           Make everything in this module.
# clean         Delete build products from this module.
# depend        Make dependencies for this module.
# fresh         Make clean, depend and all.
#
# fall          Make everything in this module and all dependent modules.
# fclean        Delete build products from this module and all dep. modules.
# fdepend       Make dependencies for this module and all dependent modules.
# ffresh        Make clean, depend and all for this and all dependent modules.
#
# foo.cod       Build code listing for foo.cpp.
# foo.i         Build preprocessed file for foo.cpp.
# foo.obj       Build object file for foo.cpp.

!ifndef MODULE
!error MODULE must be defined in makefile
!endif

!ifndef ROOT
!error ROOT must be defined in makefile
!endif

SRCROOT=$(ROOT)\src

# _RELEASE is defined by the build subdirs, causing the build process
# to ignore the build.inc file.

!if "$(_RELEASE)" == ""
!   if exist ($(SRCROOT)\build.inc)
!       include "$(SRCROOT)\build.inc"
!   else
!       include "$(SRCROOT)\build.smp"
!   endif
!endif

!if exist($(SRCROOT)\project.inc)
!include $(SRCROOT)\project.inc
!endif

!if exist($(MAKEDIR)\..\project.inc)
!include $(MAKEDIR)\..\project.inc
!endif

# -------------------------------------------------------------
# Set user variables to default
# -------------------------------------------------------------

!ifndef _DEBUG
_DEBUG=1
!endif

!ifndef _ERRORS_OK
_ERRORS_OK=0
!endif

!ifndef _SYSTEM
_SYSTEM=winnt
!endif

!ifndef _MACHINE
_MACHINE=$(PROCESSOR_ARCHITECTURE)
!if "$(_MACHINE)" == ""
_MACHINE=x86
!endif
!endif

!ifndef _BROWSE
_BROWSE=0
!endif

!ifndef _MAP
_MAP=0
!endif

!ifndef _TIMING
_TIMING=0
!endif

!ifndef _LINK_WITH_OBJS
_LINK_WITH_OBJS=0
!endif

!ifndef _KEEPTEMPFILES
_KEEPTEMPFILES=0
!endif

!ifndef _WARNINGSAREERRORS
_WARNINGSAREERRORS=0
!endif

!ifndef _WARNINGLEVEL
_WARNINGLEVEL=3
!endif

!ifndef _BLDROOT

_BLDROOT=$(ROOT)\build

!if "$(_MACHINE)" == "MIPS"
_BLDROOT=$(_BLDROOT)\mips
!elseif "$(_MACHINE)" == "x86"
_BLDROOT=$(_BLDROOT)\win
!elseif "$(_MACHINE)" == "PPCMAC"
_BLDROOT=$(_BLDROOT)\ppcmac
!endif

!if "$(_DEBUG)" == "1"
_BLDROOT=$(_BLDROOT)\debug
!elseif "$(_PROFILE)" == "1"
_BLDROOT=$(_BLDROOT)\profile
!else
_BLDROOT=$(_BLDROOT)\ship
!endif

!if "$(_BCHECKER)" == "1"
_BLDROOT=$(_BLDROOT).bc
!endif

!endif

!ifndef _COPYMAC
#!if "$(_MACHINE)" == "PPCMAC" && "$(_MACFOLDER)" != ""
#_COPYMAC = 1
#!else
_COPYMAC = 0
#!endif
!endif

!ifndef _NO_DYNLINKCRT
_NO_DYNLINKCRT = 1
!endif

!ifndef _NO_CRT
!if "$(_DEBUG)" == "1"
_NO_CRT=0
!else
_NO_CRT=1
!endif
!endif

!ifndef _NO_INCREMENTAL_LINK
_NO_INCREMENTAL_LINK=0
!endif

!ifndef _NO_MINIMAL_REBUILD
_NO_MINIMAL_REBUILD=0
!endif

!ifndef _NO_INCREMENTAL_COMP
_NO_INCREMENTAL_COMP=1
!endif

!if "$(_DEBUG)" != "1"
_NO_INCREMENTAL_LINK=1
_NO_INCREMENTAL_COMP=1
!endif

!if "$(PDBFILE)" == "NONE"
_NO_MINIMAL_REBUILD=1
_NO_INCREMENTAL_COMP=1
!endif


# -------------------------------------------------------------
# Directories
# -------------------------------------------------------------

BLDROOT=$(_BLDROOT)
BLDDIR=$(BLDROOT)\$(MODULE)
TMPDIR=$(BLDDIR)
SRCDIR=$(MAKEDIR)
BINDIR=$(BLDROOT)\bin
SDKDIR=$(BLDROOT)\sdk
ELEVATEDIR=$(ROOT)\build\elevated
TOOLSROOT=$(ROOT)\tools
TOOLSDIR=$(TOOLSROOT)\$(_MACHINE)
JAVA15DIR=$(TOOLSDIR)\java15
JAVADIR=$(TOOLSDIR)\java20
QUARTZDIR=$(TOOLSDIR)\quartz
SHAREDDIR=$(TOOLSDIR)\msvc50\SharedIDE
AUXDLLDIR=$(TOOLSDIR)\msvc50\bin
VCDIR=$(TOOLSDIR)\msvc50\vc
SWEEPERDIR=$(VCDIR)
ATLDIR=$(VCDIR)\atl
MINLIBCDIR=$(TOOLSDIR)\minlibc
IE40DIR=$(TOOLSDIR)\ie40

!if "$(_MACHINE)" == "PPCMAC"
TOOLSUTILS=$(ROOT)\tools\x86\utils
TOOLSINCLUDE=
!else
TOOLSUTILS=$(TOOLSDIR)\utils
TOOLSINCLUDE= \
    $(TOOLSDIR)\qvlib\include\
    $(TOOLSDIR)\misc\include\
    $(TOOLSDIR)\quartz\include\
    $(IE40DIR)\inc\
    $(TOOLSDIR)\trident\include
!endif
ATLINCLUDE=$(ATLDIR)\include

TOOLSBINMSVC=$(VCDIR)\bin
TOOLSBINWIN32=$(TOOLSBINMSVC)
TOOLSBINYACC=$(TOOLSDIR)\bison
TOOLSBINLEX=$(TOOLSDIR)\flex
TOOLSBINJAVA=$(JAVADIR)\bin
TOOLSBINSHARED=$(SHAREDDIR)\bin

TOOLSLIBMSVC=$(VCDIR)\lib
TOOLSLIBWIN32=$(TOOLSLIBMSVC)
TOOLSLIBICAP=$(TOOLSDIR)\IceCap\x86
TOOLSLIBRL=$(TOOLSDIR)\RL\lib
TOOLSLIBMISC=$(TOOLSDIR)\misc\lib
TOOLSLIBSWEEPER=$(SWEEPERDIR)\lib
TOOLSLIBQUARTZ=$(QUARTZDIR)\lib
!if "$(_DEBUG)" == "1"
TOOLSLIBQV=$(TOOLSDIR)\QVLib\lib\WinRel
!else
TOOLSLIBQV=$(TOOLSDIR)\QVLib\lib\WinDebug
!endif
TOOLSLIBAACTIVE=$(TOOLSDIR)\aactive\lib
TOOLSLIBDIRECTX=$(TOOLSDIR)\directx\lib
TOOLSLIBGLU=$(TOOLSDIR)\glu\lib
TOOLSLIBAMOVIE=$(TOOLSDIR)\quartz\lib
TOOLSLIBTRIDENT=$(TOOLSDIR)\trident\lib
TOOLSLIBIE40=$(IE40DIR)\lib

MAKE2_INC=$(SRCROOT)\make\make2.inc
CRTLIBC=$(TOOLSLIBMSVC)\libc.lib

# -------------------------------------------------------------
# Tools
# -------------------------------------------------------------

!if "$(PROCESSOR_ARCHITECTURE)" == ""
EAT_ERRORS=
EAT_OUTPUT=
DEL      = -DEL
DELALL   = -ECHO y | DEL
XCOPY    = $(WINDIR)\COMMAND\XCOPY
!else
EAT_ERRORS=2>nul:
EAT_OUTPUT=1>nul:
DEL      = -DEL $(EAT_ERRORS)
DELALL   = $(DEL) /Q
XCOPY    = $(SYSTEMROOT)\SYSTEM32\XCOPY
!endif

SED      = $(TOOLSUTILS)\SED
MKDEP    = $(TOOLSUTILS)\MKDEP
TLMUNGE  = $(TOOLSUTILS)\TLMUNGE
CABARC   = $(TOOLSUTILS)\cabarc
WINZIP   = $(TOOLSDIR)\winzip\winzip32
DUBUILD  = $(TOOLSDIR)\misc\bin\dubuild
MKTYPLIB = $(TOOLSBINMSVC)\MKTYPLIB
CC       = $(TOOLSBINMSVC)\CL
BCC      = $(TOOLSBINMSVC)\CL
LIBR     = $(TOOLSBINMSVC)\LIB
LINK     = $(TOOLSBINMSVC)\LINK
BSCMAKE  = $(TOOLSBINMSVC)\BSCMAKE
MC       = $(TOOLSBINMSVC)\MC
RC       = $(TOOLSBINSHARED)\RC
AS       = $(TOOLSBINMSVC)\ML /c
CVTRES   = $(TOOLSBINMSVC)\CVTRES
JC       = $(TOOLSBINJAVA)\JVC
#JCOMGEN  = $(TOOLSBINJAVA)\jcom
JCOMGEN  = $(JAVA15DIR)\bin\JCOMGEN
ATTRJC   = $(JAVA15DIR)\bin\ATTRJVC
JTLB     = $(JAVA15DIR)\bin\JAVATLB

YACC     = $(TOOLSBINYACC)\bison.exe
LEX      = $(TOOLSBINLEX)\flex.exe

FLEXSKL  = $(TOOLSBINLEX)\flex.skl
BISONFILE= $(TOOLSBINYACC)\share\bison.simple

!if "$(_BCHECKER)" != ""
!if "$(_NORMALCC)" == ""
BCC = $(TOOLSBINMSVC)\BCOMPILE -Zop f:\bchecker.ini
!endif
LINK = $(TOOLSBINMSVC)\BCLINK
!endif

RENAME   = RENAME
SET      = SET
ECHO     = ECHO
MKDIR    = MKDIR $(EAT_ERRORS)
COPY     = COPY
MOVE     = MOVE $(EAT_OUTPUT)

!if "$(_MACHINE)" == "PPCMAC"
MIDL     = $(ROOT)\tools\x86\win32\bin\MIDL
MRC      = $(TOOLSBINMSVC)\MRC
MFILE    = $(TOOLSBINMSVC)\MFILE
MAP2SYM  = $(TOOLSBINMSVC)\MAP2SYM
!else
MIDL     = $(TOOLSBINMSVC)\MIDL
MAP2SYM  = $(TOOLSBINMSVC)\MAPSYM.exe
!endif

# -------------------------------------------------------------
# Miscellaneous Symbols specific to Mac Appelles
# -------------------------------------------------------------
!if "$(TARGET)" == "maccopy"
_COPYMAC = 1
!endif

!if "$(_COPYMAC)" == "1"
!if "$(_MACVOLUME)" == ""
_MACVOLUME=:HD
!else
_MACVOLUME=:$(_MACVOLUME)
!endif
!if "$(_MACFOLDER)" == ""
_MACFOLDER=$(_MACVOLUME):Appelles
!endif

!if "$(_DEBUG)" == "1"
_MACFOLDER=$(_MACFOLDER):debug
!elseif "$(_PROFILE)" == "1"
_MACFOLDER=$(_MACFOLDER):profile
!else
_MACFOLDER=$(_MACFOLDER):ship
!endif #"$(_DEBUG)" == "1"

!endif #"$(_COPYMAC)" == "1"

MACDLLCREATOR = cfmg
MACEXECREATOR = FRM3
MACSYMCREATOR = ????
MACTLBCREATOR = OLE2


MACTARG =
# -------------------------------------------------------------
# Create output directories
# -------------------------------------------------------------

!if [$(MKDIR) $(_BLDROOT)]
!endif

!if [$(MKDIR) $(BLDDIR)]
!endif

# -------------------------------------------------------------
# Verbosity & Temp files
# -------------------------------------------------------------

NOLOGO=/nologo

!if "$(MAKEFLAGS:S=)" != "$(MAKEFLAGS)"
# Use "!ifdef SILENTMODE" to determine if silent mode is on.
SILENTMODE=1
BATCH=/BATCH
!else
!undef SILENTMODE
BATCH=
!endif

!if $(_KEEPTEMPFILES)
KEEPFLAGS=KEEP
!else
KEEPFLAGS=NOKEEP
!endif

#
# Make sure the INCLUDE and CL environment variables are not set or that will
#  mess everything up!
#
!if [$(SET) INCLUDE=]
!endif
!if [$(SET) CL=]
!endif
!if [$(SET) ML=]
!endif
!if [$(SET) LIB=$(TOOLSLIBMSVC)]
!endif
!if [$(SET) PATH=$(TOOLSBINSHARED);$(AUXDLLDIR);%PATH%]
!endif

# -------------------------------------------------------------
# Rules
# -------------------------------------------------------------

# The suffixes list contains inferred dependent file extensions in
# order of precedence.  Do not add target file extensions to this list.
# The first .SUFFIXES line clears the default setttings.
.SUFFIXES:
.SUFFIXES: .cpp .cxx .c .hxx .h .asm .r .rc .h .tdl .l .y .class .java .tlb

#
# .cpp -> .obj
#
{$(SRCDIR)}.cpp.obj:
        $(BCC) $(NOLOGO) $< @$(BLDDIR)\cxx.rsp

#
# .cpp -> .obj
#
{$(BLDDIR)}.cpp.obj:
        $(BCC) $(NOLOGO) $< @$(BLDDIR)\cxx.rsp

#
# .cpp -> .cod
#
.cpp.cod:
        $(BCC) $(NOLOGO) $< /Fc$@ @$(BLDDIR)\cxx.rsp

#
# .cpp -> .i
#
.cpp.i:
        $(BCC) $(NOLOGO) @<< >$@
/I$(INCLUDEPATH:;=
/I)
$(CFLAGS: =
)
$(PCHFLAGS: =
)
/c
/E
$<
<<$(KEEFLAGS)

#
# .cxx -> .obj
#
{$(SRCDIR)}.cxx.obj:
        $(BCC) $(NOLOGO) $< @$(BLDDIR)\cxx.rsp

#
# .asm -> .obj
#
{$(SRCDIR)}.asm.obj:
        $(AS) $(NOLOGO) @<<
/I$(INCLUDEPATH:;=
/I)
$(AFLAGS: =
)
/c
/Fo$@
$<
<<$(KEEFLAGS)

#
# .cxx -> .cod
#
.cxx.cod:
        $(BCC) $(NOLOGO) $< /Fc$@ @$(BLDDIR)\cxx.rsp

#
# .cxx -> .i
#
.cxx.i:
        $(BCC) $(NOLOGO) @<< >$@
/I$(INCLUDEPATH:;=
/I)
$(CFLAGS: =
)
$(PCHFLAGS: =
)
/c
/E
$<
<<$(KEEFLAGS)

#
# .c -> .obj
#
{$(SRCDIR)}.c.obj:
        $(BCC) $(NOLOGO) @<<
/I$(INCLUDEPATH:;=
/I)
$(CFLAGS: =
)
/c
/Fo$@
$<
<<$(KEEFLAGS)

#
# .c -> .obj
# special case for the MIDL generated .c files
#
.c.obj:
        $(BCC) $(NOLOGO) @<<
/I$(INCLUDEPATH:;=
/I)
$(CFLAGS: =
)
/c
/Fo$@
$<
<<$(KEEFLAGS)

#
# .c -> .cod
#
.c.cod:
        $(BCC) $(NOLOGO) @<<
/I$(INCLUDEPATH:;=
/I)
$(CFLAGS: =
)
/c
/Fo$(BLDDIR)\$(@B).obj
/Fc$@
$<
<<$(KEEFLAGS)

#
# .c -> .i
#
.c.i:
        $(BCC) $(NOLOGO) @<< >$@
/I$(INCLUDEPATH:;=
/I)
$(CFLAGS: =
)
/c
/E
$<
<<$(KEEFLAGS)

#
# .h -> .pch
#
{$(SRCDIR)}.h.pch:
        $(ECHO) #include "$<" > $(TMPDIR)/$(@B).cpp
        $(CC) $(NOLOGO) @<<
/I$(INCLUDEPATH:;=
/I)
/c
$(CFLAGS: =
)
/Yc$<
/Fo$(@R).obj
/Fp$(@R).pcT
$(TMPDIR)\$(@B).cpp
<<$(KEEPFLAGS)
        $(DEL) $(@R).pch
        $(RENAME) $(@R).pcT $(@B).pch
!if "$(_BCHECKER)" != ""
!if "$(_NORMALCC)" == ""
        $(BCC) $(NOLOGO) @<<
/I$(INCLUDEPATH:;=
/I)
/c
$(CFLAGS: =
)
/Yc$<
/Fo$(@R).obj
/Fp$(@R).pcT
$(TMPDIR)\$(@B).cpp
<<$(KEEPFLAGS)
!endif
!endif

#
# .rc -> .res
#
{$(SRCDIR)}.rc.res:
!ifdef SILENTMODE
        $(ECHO) $(<F)
!endif
        $(RC) /I$(RESINCLPATH:;= /I) $(RFLAGS) /fo$@ $<

#
# .rc -> .res
#
{$(RESDIR)}.rc.res:
!ifdef SILENTMODE
        $(ECHO) $(<F)
!endif
        $(RC) /I$(RESINCLPATH:;= /I) $(RFLAGS) /fo$@ $<

#
# .odl -> .i
#
.odl.i:
        $(BCC) @<<
/I$(INCLUDEPATH:;=
/I)
/E
$<
>$@
<<$(KEEPFLAGS)

#
# .r -> .rsc
#
{$(SRCDIR)}.r.rsc:
        $(MRC) /I$(RESINCLPATH:;= /I) $(MRFLAGS) /o$@ $<


#
# .l -> .cpp
#
{$(SRCDIR)}.l.cpp:
        $(LEX) $(LEXFLAGS) -o$@ $<

#
# .l -> .c
#
{$(SRCDIR)}.l.c:
        $(LEX) $(LEXFLAGS) -o$@ $<

#
# .y -> .cpp
#
# Need to pass in file name with \\ since the compiler chokes
# on \ since it thinks they are escape sequences in the filename
# and bison generates #line using the exact command line name
{$(SRCDIR)}.y.cpp:
        @$(DEL) $@
        set BISON_SIMPLE=$(BISONFILE)
        $(YACC) $(YACCFLAGS) -o $(@:.cpp=.c) $(<:\=\\)
        @$(MOVE) $(@:.cpp=.c) $@

#
# .y -> .c
#
# Need to pass in file name with \\ since the compiler chokes
# on \ since it thinks they are escape sequences in the filename
# and bison generates #line using the exact command line name
{$(SRCDIR)}.y.c:
        set INIT=$(BISONINIT)
        $(YACC) $(YACCFLAGS) -o $@ $(<:\=\\)

#
# .java -> .class
#
{$(SRCDIR)}.java.class:
        $(JC) $(JCFLAGS) /d $(@D) $(<F)

#
# .class -> .tlb
#
{$(BINDIR)}.class{$(BLDDIR)}.tlb:
        $(JTLB) $(JTLBFLAGS) $<

#
# .class -> .tlb
#
{$(BINDIR)}.class.tlb:
        $(JTLB) $(JTLBFLAGS) $<

#
# .java -> .tlb
#
{$(BINDIR)}.java{$(BLDDIR)}.tlb:
        $(JCOMGEN) $(JCOMGENFLAGS) $<

#
# .java -> .tlb
#
{$(BINDIR)}.java.tlb:
        $(JCOMGEN) $(JCOMGENFLAGS) $<

# -------------------------------------------------------------
# DEFINES
# -------------------------------------------------------------

!if "$(_DEBUG)" == "1"
DEFINES=/D_DEBUG /DDBG=1 /DDEBUG $(DEFINES)
!endif

!if "$(_NO_CRT)" == "1"
DEFINES=$(DEFINES) /D_NO_CRT=1  /D_USE_PRINT=0
!else
DEFINES=$(DEFINES) /D_USE_PRINT=1
!endif

!if "$(_PROFILE)" == "1"
DEFINES=$(DEFINES) /DPRODUCT_PROF
ICECAPLIB=$(TOOLSLIBICAP)\icap.lib
!endif

!if "$(_MACHINE)"=="x86"
DEFINES=$(DEFINES) /D_X86_=1
!elseif "$(_MACHINE)"=="MIPS"
DEFINES=$(DEFINES) /D_MIPS_=1
!else if "$(_MACHINE)" == "PPCMAC"
DEFINES=$(DEFINES) /D_MAC /D_MPPC_ /D__pascal= /D_WLM_NOFORCE_LIBS /D_MACOLENAMES
DEFINES=$(DEFINES) /DOLE2ANSI /D_WIN32NLS /D_WIN32REG /D_WIN32
DEFINES=$(DEFINES) /DOLDROUTINENAMES=0
!if "$(_MACTEXT)" == "1"
DEFINES=$(DEFINES) /D_MACTEXT
!endif
!else
!error Unknown machine $(_MACHINE)
!endif

DEFINES=$(DEFINES) /DWIN32 /D_WINDOWS /DSTRICT /D_WIN32_WINNT=0x400

!if "$(_SYSTEM)" == "winnt"
# DEFINES= $(DEFINES) /DUNICODE /D_UNICODE
!endif

!if "$(_TIMING)" == "1"
DEFINES =$(DEFINES) /DTIMING
!endif

!if "$(_NO_INCREMENTAL_LINK)" == "1"
DEFINES =$(DEFINES) /D_NO_INCREMENTAL_LINK
!endif

# -------------------------------------------------------------
# AFLAGS
# -------------------------------------------------------------

!if "$(_DEBUG)" == "1"
#  /Zi  prepare for debugging
AFLAGS =/Zi
!endif

# -------------------------------------------------------------
# CFLAGS
# -------------------------------------------------------------

INCLUDEPATH=$(INCLUDEDIRS: =;)

!if "$(_MACHINE)"=="x86"
#   /Zp8    pack structs on 8 byte boundaries
#   /Oi     enable intrinsic functions
#   /ML     use Single-Threaded Staticaly-linked C runtime library (LIBC.LIB)
CFLAGS =$(NOLOGO) $(CFLAGS) -Zp8 -Oi
!else if "$(_MACHINE)" == "PPCMAC"
#   /Oi     enable intrinsic functions
#   /QPb    order bitfields low to high
#   /Zp8    pack structures on 1-byte
CFLAGS = $(NOLOGO) $(CFLAGS) -ML -Oi -QPb -Zp8
!endif

!if "$(PDBFILE)" == "NONE"
#   /Z7     generate debug info in OBJ file
CFLAGS =$(CFLAGS) -Z7
!else
#   /Zi     generate debug info in PDB file
CFLAGS =$(CFLAGS) -Zi
!endif

!if "$(_MACHINE)"=="x86"
!if "$(_NO_MINIMAL_REBUILD)" == "0"
#   /Gm     enable minimal rebuild:  allow C++ compiler to skip .CPP files iff
#             no class definitions in any .H files have changed
CFLAGS =$(CFLAGS) -Gm
!endif

!if "$(_NO_INCREMENTAL_COMP)" == "0"
#   /Gi     enable incremental compile:  allow C++ compiler to skip functions
#             which have not changed since last compile
CFLAGS =$(CFLAGS) -Gi
!endif

#   /G5     optimize for Pentium
#   /Gz     __stdcall calling convention
#   /GX     C++ exception unwind semantics
CFLAGS =$(CFLAGS) -G5 -GX
!endif  # _MACHINE == "x86"


!if "$(_DEBUG)" == "1"
#   /MDd    Use debug version of Multi-Threaded Dynamically-linked C runtime
#   /MTd    Use debug version of Multi-Threaded statically-linked C runtime
#   /Od     disable optimizations
#   /Ob1    (inline expansion on (needed for unicode wrappers))
#           XXX but I want it off to make debuggin easier
#   /Ob1    inline expansion on (needed for unicode wrappers)
#   /Ge     enable stack checking calls
#   /Gy     separate functions for linker

!if "$(_NO_DYNLINKCRT)" == "0"
CFLAGS =$(CFLAGS) -MDd
!elseif "$(_NO_CRT)" == "0"
CFLAGS =$(CFLAGS) -MTd
!endif  # _NO_DYNLINKCRT

CFLAGS =$(CFLAGS) -Od -Ob0 -Oi -Ge -Gy

!else

#   /MD     Use Multi-Threaded Dynamically-linked C runtime library
#   /MT     Use Multi-Threaded statically-linked C runtime library
#   /O1     minimize space, same as:
#           /Og  enable global optimization
#           /Os  favor code space
#           /Oy  enable frame pointer omission
#           /Ob1 inline expansion on
#           /Gs  disable stack checking
#           /Gf  enable string pooling
#           /Gy  separate functions for linker

!if "$(_NO_DYNLINKCRT)" == "0"
CFLAGS =$(CFLAGS) -MD
!elseif "$(_NO_CRT)" == "0"
CFLAGS =$(CFLAGS) -MT
!endif

CFLAGS =$(CFLAGS) -O1
!endif

!if "$(_PROFILE)" == "1"
#   /Gh     generate call to __penter in function calls
#           Used by cap and icecap for profiling.
CFLAGS =$(CFLAGS) /Gh
!endif

!ifdef PCHFILE
#   /Fp<file> name precompiled header file
#   /Yu[file] use .PCH file
PCHFLAGS   = /Fp$(PCHPATH)\$(PCHFILE).pch /Yu$(PCHFILE).h
PCHFILEOBJ = $(PCHPATH)\$(PCHFILE).obj
!else
PCHFLAGS   =
PCHFILEOBJ =
!endif

#   /Fd[file] name .PDB file
!if "$(PDBFILE)" != "NONE"
!ifdef PDBFILE
CFLAGS =$(CFLAGS) /Fd$(PDBFILE)
!else
CFLAGS =$(CFLAGS) /Fd$(BINDIR)\danim.pdb
!endif
!endif

!if "$(_BROWSE)" == "1"
#   /Fr[file] name source browser file
CFLAGS =$(CFLAGS) /Fr$(BLDDIR)^\
!endif

!if "$(_BROWSE)" == "2"
#   /FR[file] name extended .SBR file
CFLAGS =$(CFLAGS) /FR$(BLDDIR)^\
!endif

!if "$(_WARNINGSAREERRORS)" != "0"
#   /WX treat warnings as errors
CFLAGS = $(CFLAGS) /WX
!endif

!if "$(_ENABLE_PERF_RPTING)" == "1"
CFLAGS = $(CFLAGS) /DPERFORMANCE_REPORTING
!endif


CFLAGS=$(CFLAGS) /W$(_WARNINGLEVEL)
DEFINES=$(DEFINES) /DWARNINGLEVEL=$(_WARNINGLEVEL)

CFLAGS=$(CFLAGS) $(DEFINES) $(_USERCFLAGS)


# -------------------------------------------------------------
# LFLAGS
# -------------------------------------------------------------

!if "$(_MACHINE)"=="x86"
LINKMACHINE=iX86
!elseif "$(_MACHINE)" == "PPCMAC"
LINKMACHINE=MPPC
!else
LINKMACHINE=$(_MACHINE)
!endif

LFLAGS=$(NOLOGO) $(LFLAGS) /machine:$(LINKMACHINE) /base:@$(SRCROOT)\baseaddr.txt,$(@F)
!if "$(_DEBUG)" == "1" 
LFLAGS=$(LFLAGS) /debug
!endif

!if "$(_NO_INCREMENTAL_LINK)" != "1"
LFLAGS=$(LFLAGS) /incremental:yes
##_MAP=0
!else
!if defined(_DEBUGSHIP) && "$(_DEBUGSHIP)" != "0"
LFLAGS=$(LFLAGS) /incremental:no /debug
!else
LFLAGS=$(LFLAGS) /incremental:no /release
!endif
!endif

!if "$(_MAP)" != "0"
LFLAGS=$(LFLAGS) /map:$(@R).map
!endif

!if "$(_MACHINE)" != "PPCMAC"
!if "$(_PROFILE)" == "1"
LFLAGS=$(LFLAGS) /DEBUG:MAPPED /DEBUGTYPE:cv /opt:ref
!elseif "$(_DEBUG)" == "0"
LFLAGS=$(LFLAGS) /opt:ref
!endif
!endif

#!if "$(_DEBUG)" == "0" & "$(_PROFILE)" == "0"
#LFLAGS=$(LFLAGS) /PDB:NONE
#!else
!  ifdef PDBFILE
LFLAGS=$(LFLAGS) /PDB:$(PDBFILE)
!  else
LFLAGS=$(LFLAGS) /PDB:$*.pdb
!  endif
#!endif

LFLAGS=$(LFLAGS) $(_USERLFLAGS)


# -------------------------------------------------------------
# RFLAGS
# -------------------------------------------------------------

!if "$(RESINCLUDEDIRS)" == ""
RESINCLUDEDIRS=$(INCLUDEDIRS)
!endif

RESINCLPATH=$(RESINCLUDEDIRS: =;)

RFLAGS=$(RFLAGS) $(DEFINES) $(_USERRFLAGS)

!if "$(_MACHINE)" == "PPCMAC"
RESINCLUDEDIRS=$(RESINCLUDEDIRS) $(TOOLSROOT)\macinc\mrc
MRFLAGS=$(DEFINES) $(_USERRFLAGS)
RFLAGS=$(RFLAGS) /m
!endif

# -------------------------------------------------------------
# LEXFLAGS
# -------------------------------------------------------------
!if "$(LEXFLAGS)" == ""
LEXFLAGS= -s8 -S$(FLEXSKL) $(_USER_LEXFLAGS)
!endif

# -------------------------------------------------------------
# YACCFLAGS
# -------------------------------------------------------------
!if "$(YACCFLAGS)" == ""
YACCFLAGS= -d $(_USER_YACCFLAGS)
!endif


# -------------------------------------------------------------
# JCFLAGS
# -------------------------------------------------------------
!if "$(JCFLAGS)" == ""
JCFLAGS= /cp $(JCCLASSPATH) $(_USER_JCFLAGS)
!if "$(_DEBUG)" == "1"
JCFLAGS= $(JCFLAGS) -g
!else
JCFLAGS= $(JCFLAGS)
!endif
!endif

# -------------------------------------------------------------
# ATTRJCFLAGS
# -------------------------------------------------------------
!if "$(ATTRJCFLAGS)" == ""
ATTRJCFLAGS= /cp:p $(JCCLASSPATH) $(_USER_ATTRJCFLAGS)
!if "$(_DEBUG)" == "1"
ATTRJCFLAGS= $(ATTRJCFLAGS) -g
!else
ATTRJCFLAGS= $(ATTRJCFLAGS)
!endif
!endif

# -------------------------------------------------------------
# JCOMGENFLAGS
# -------------------------------------------------------------
!if "$(JCOMGENFLAGS)" == ""
JCOMGENFLAGS= /nologo $(_USER_JCOMGENFLAGS)
!endif

# -------------------------------------------------------------
# JTLBFLAGS
# -------------------------------------------------------------
!if "$(JTLBFLAGS)" == ""
JTLBFLAGS= $(_USER_JTLBFLAGS)
!endif

# -------------------------------------------------------------
# JHFLAGS
# -------------------------------------------------------------
!if "$(JHFLAGS)" == ""
JHFLAGS= -classpath $(JCCLASSPATH) -nologo $(_USER_JHFLAGS)
!endif

# -------------------------------------------------------------
# JCCLASSPATH
# -------------------------------------------------------------
!if "$(JCCLASSPATH)" == ""
JCCLASSPATH= $(JAVADIR)\classes\afc.zip;$(JAVADIR)\classes\classes.zip;$(SRCDIR);$(BLDDIR);$(SDKDIR);$(BINDIR)
!endif


# -------------------------------------------------------------
# Default Goal
# -------------------------------------------------------------

goal: all
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\mmapi\dll\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"
#include "mmapi.h"
#include "dacomutil.h"

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\mmapi\dll\init.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: init.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"

// Macro refers to a function of the name InitializeModule_Name,
// assumed to be defined, and then calls it.  If it's not defined,
// we'll get a link time error.
#define INITIALIZE_MODULE(ModuleName)           \
  extern bool InitializeModule_##ModuleName();  \
  if (!InitializeModule_##ModuleName()) return false;

#define DEINITIALIZE_MODULE(ModuleName,bShutdown)               \
  extern void DeinitializeModule_##ModuleName(bool);            \
  DeinitializeModule_##ModuleName(bShutdown);

bool
InitializeAllModules()
{
    INITIALIZE_MODULE(ATL);

    return true;
}

void
DeinitializeAllModules(bool bShutdown)
{
    DEINITIALIZE_MODULE(ATL, bShutdown);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\mmapi\include\util.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _UTIL_H
#define _UTIL_H

template <class T>
class CRPtr
{
  public:
    typedef T _PtrClass;
    CRPtr() { p = NULL; }
    CRPtr(T* lp, bool baddref = true)
    {
        p = lp;
        if (p != NULL && baddref)
            CRAddRefGC(p);
    }
    CRPtr(const CRPtr<T>& lp, bool baddref = true)
    {
        p = lp.p;

        if (p != NULL && baddref)
            CRAddRefGC(p);
    }
    ~CRPtr() {
        CRReleaseGC(p);
    }
    void Release() {
        CRReleaseGC(p);
        p = NULL;
    }
    operator T*() { return (T*)p; }
    T& operator*() { Assert(p != NULL); return *p; }
    T* operator=(T* lp)
    {
        return Assign(lp);
    }
    T* operator=(const CRPtr<T>& lp)
    {
        return Assign(lp.p);
    }

    bool operator!() const { return (p == NULL); }
    operator bool() const { return (p != NULL); }

    T* p;
  protected:
    T* Assign(T* lp) {
        if (lp != NULL)
            CRAddRefGC(lp);

        CRReleaseGC(p);

        p = lp;

        return lp;
    }
};

class CRLockGrabber
{
  public:
    CRLockGrabber() { CRAcquireGCLock(); }
    ~CRLockGrabber() { CRReleaseGCLock(); }
};


class SafeArrayAccessor
{
  public:
    SafeArrayAccessor(VARIANT & v,
                      bool allowNullArray = false);
    ~SafeArrayAccessor();

    unsigned int GetArraySize() { return _ubound - _lbound + 1; }

    IUnknown **GetArray() { return _isVar?_allocArr:_ppUnk; }

    bool IsOK() { return !_failed; }
  protected:
    SAFEARRAY * _s;
    union {
        VARIANT * _pVar;
        IUnknown ** _ppUnk;
        void * _v;
    };
    
    VARTYPE _vt;
    long _lbound;
    long _ubound;
    bool _inited;
    bool _isVar;
    CComVariant _retVar;
    bool _failed;
    IUnknown ** _allocArr;
};

inline WCHAR * CopyString(const WCHAR *str) {
    int len = str?lstrlenW(str)+1:1;
    WCHAR *newstr = new WCHAR [len] ;
    if (newstr) memcpy(newstr,str?str:L"",len * sizeof(WCHAR)) ;
    return newstr ;
}

#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

#endif /* _UTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\make\make2.inc ===
# --------------------------------------------------------------
# LIBTARG
# --------------------------------------------------------------

!ifdef LIBTARG

!if "$(_NO_INCREMENTAL_LINK)" == "1" && "$(_LINK_WITH_OBJS)" == "0"

$(LIBTARG) : $(BLDDIR)\cxx.rsp $(LIBOBJS)
        $(DEL) $@
!ifdef SILENTMODE
        $(ECHO) Linking $@...
!endif
        $(LIBR) $(NOLOGO) -MACHINE:$(LINKMACHINE) @<<
        -OUT:$*.lib
        $(LIBOBJS: = ^
)
<<$(KEEPFLAGS)

!else

#
# For incremental linking we create a .lib file that is just a text file that
# contains a list of all the objs that would have gone into the lib.
#
$(LIBTARG) : $(BLDDIR)\cxx.rsp $(LIBOBJS)
        $(DEL) $@
        $(ECHO) Incrementally Linking $@...
# The following line creates a file with the name $(LIBTARG) that contains
#  the name of each object file on a separate line. SED is used to remove
#  blank lines.
        $(SED) "/^[ ]*$$/d" << >$@
$(LIBOBJS: = ^
)
<<$(KEEPFLAGS)

!endif

clean::
        $(DEL) $(LIBTARG)
        $(DEL) $(LIBTARG:.dll=.exp)
        $(DEL) $(LIBTARG:.dll=.lib)
!ifdef PDBFILE
        $(DEL) $(PDBFILE)
        $(DEL) $(PDBFILE:.pdb=.idb)
!endif

!endif

# -------------------------------------------------------------
# DLLTARG
# -------------------------------------------------------------

!ifdef DLLTARG


# How do we specify a resource-only DLL on the Mac?
!if "$(RESOURCE_ONLY)" == "1"  && "$(_MACHINE)" != "PPCMAC"
DLLENTRY=/NOENTRY
!else
!       if "$(_MACHINE)" == "PPCMAC"
DLLENTRY=-mac:init=WlmConnectionInit  -mac:term=WlmConnectionTerm
DLLMAC=-mac:NOMFILEPAD
!       else
DLLENTRY=/ENTRY:$(DLLENTRY)
DLLMAC=
!       endif
!endif

$(BLDDIR)\linkdll.rsp : $(DLLLIBS)
        @$(DEL) $(BLDDIR)\linkdll.rsp
        @$(DEL) $(BLDDIR)\linkdll.tmp
!if "$(DLLLIBS)" != ""
!  if "$(_NO_INCREMENTAL_LINK)" == "1" && "$(_LINK_WITH_OBJS)" == "0"
        @!echo $** >> $(BLDDIR)\linkdll.rsp
!  else
        @!type $** >> $(BLDDIR)\linkdll.tmp
        @$(SED) "y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/" $(BLDDIR)\linkdll.tmp > $(BLDDIR)\linkdll.rsp
        $(DEL) $(BLDDIR)\linkdll.tmp
!  endif
!else
        @echo. > $(BLDDIR)\linkdll.rsp
!endif

$(DLLTARG) : $(BLDDIR)\cxx.rsp $(BLDDIR)\linkdll.rsp $(DLLOBJS) $(DLLXLIBS) $(PCHFILEOBJ) $(DLLDEF)
!ifdef SILENTMODE
!  if "$(_NO_INCREMENTAL_LINK)" == "1"
        $(ECHO) Linking $@...
!  else
        $(ECHO) Incrementally Linking $@...
!  endif
!endif
        $(LINK) $(LFLAGS) $(DLLMAC) /DEF:$(DLLDEF) /DLL /OUT:$(DLLTARG) /IMPLIB:$(SDKDIR)\$(@B).lib $(DLLENTRY) @$(BLDDIR)\linkdll.rsp @<<
$(DLLOBJS: =^
)
$(DLLXLIBS: =^
)
!if "$(_PROFILE)" == "1"
$(ICECAPLIB)
!endif
$(PCHFILEOBJ)
<<$(KEEPFLAGS)

!if "$(_MACHINE)"=="x86"
!if "$(_MAP)" != "0"
#        cd $(BINDIR)
        $(DEL) $(BINDIR)\$(@B).sym
        $(ECHO) Creating sym file: $(BINDIR)\$(@B).sym
        $(MAP2SYM) -o $(BINDIR)\$(@B).sym $(BINDIR)\$(@B).map
!endif
!endif


!if "$(_MACHINE)"=="PPCMAC"
$(MACTARG) : $(DLLTARG)
!       if "$(_MACSYMS)"=="1"
       $(DEL) $(@R).sym
       $(MAP2SYM) -n $(@R).sym $(@R).MAP
!       endif
!       if "$(_COPYMAC)"=="1"
#               MFILE requires that mrc.exe be in the executable path
                cd $(TOOLSBIN)
                $(MFILE) copy -n -c $(MACDLLCREATOR) -t shlb $(DLLTARG) \
                        "$(_MACFOLDER):$(@B).dll"
!               if "$(_MACSYMS)"=="1"
               $(MFILE) copy -n -c $(MACDLLCREATOR) -t TEXT $(@R).sym \
                       "$(_MACFOLDER):$(@B).sym"
!               endif
                cd $(ROOT)
                                @echo. > $(MACTARG)
!       endif
!endif



clean::
        $(DEL) $(DLLTARG)
        $(DEL) $(DLLTARG:.dll=.exp)
        $(DEL) $(DLLTARG:.dll=.lib)
        $(DEL) $(DLLTARG:.dll=.map)
        $(DEL) $(DLLTARG:.dll=.ilk)
        $(DEL) $(DLLTARG:.dll=.idb)
        $(DEL) $(DLLTARG:.dll=.dbg)
!ifdef PDBFILE
        $(DEL) $(PDBFILE)
        $(DEL) $(PDBFILE:.pdb=.idb)
!endif

!endif

# -------------------------------------------------------------
# EXETARG
# -------------------------------------------------------------

!ifdef EXETARG
!ifndef EXETYPE
!error EXETYPE must be console or windows for .exes
!endif

!if "$(_MACHINE)" == "PPCMAC"
EXEMAC=-mac:NOMFILEPAD -mac:bundle -mac:type=APPL -mac:creator=$(MACEXECREATOR)
!else
EXEMAC=
!endif

$(BLDDIR)\linkexe.rsp : $(EXELIBS)
        @$(DEL) $(BLDDIR)\linkexe.rsp
        @$(DEL) $(BLDDIR)\linkexe.tmp
!if "$(EXELIBS)" != ""
!  if "$(_NO_INCREMENTAL_LINK)" == "1" && "$(_LINK_WITH_OBJS)" == "0"
        @!echo $** >> $(BLDDIR)\linkexe.rsp
!  else
        @!type $** >> $(BLDDIR)\linkexe.tmp
        @$(SED) "y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/" $(BLDDIR)\linkexe.tmp > $(BLDDIR)\linkexe.rsp
        $(DEL) $(BLDDIR)\linkexe.tmp
!  endif
!else
        @echo. > $(BLDDIR)\linkexe.rsp
!endif

$(EXETARG) : $(BLDDIR)\cxx.rsp $(BLDDIR)\linkexe.rsp $(EXEOBJS) $(EXEXLIBS) $(PCHFILEOBJ)
!ifdef SILENTMODE
!  if "$(_NO_INCREMENTAL_LINK)" == "1"
        $(ECHO) Linking $@...
!  else
        $(ECHO) Incrementally Linking $@...
!  endif
!endif
        $(LINK) $(LFLAGS) $(EXEMAC) -subsystem:$(EXETYPE) /OUT:$(EXETARG) @$(BLDDIR)\linkexe.rsp @<<
$(EXEOBJS: =^
)
$(EXEXLIBS: =^
)
!if "$(_PROFILE)" == "1"
$(ICECAPLIB)
!endif
$(PCHFILEOBJ)
<<$(KEEPFLAGS)

!if "$(_MACHINE)"=="PPCMAC"
$(MACTARG) : $(EXETARG)
!       if "$(_MACSYMS)"=="1"
        $(DEL) $(@B).sym
        $(MAP2SYM) -n $(@R).sym $(@R).MAP
!       endif
!   if "$(_COPYMAC)"=="1"
#       MFILE requires that mrc.exe be in the executable path
#                       (why doesn't PATH work here?)
                cd $(TOOLSBIN)
                $(MFILE) copy -n -c $(MACEXECREATOR) -t APPL $(@R).exe \
                                "$(_MACFOLDER):$(@B)"
!               if "$(_MACSYMS)"=="1"
                        $(MFILE) copy -n -c $(MACSYMCREATOR) -t TEXT $(@R).sym \
                                        "$(_MACFOLDER):$(@B).sym"
!               endif
                cd $(ROOT)
                @echo. > $(MACTARG)
!       endif
!endif

clean::
        $(DEL) $(EXETARG)
        $(DEL) $(EXETARG:.exe=.map)
        $(DEL) $(EXETARG:.exe=.ilk)
        $(DEL) $(EXETARG:.exe=.dbg)
!ifdef PDBFILE
        $(DEL) $(PDBFILE)
        $(DEL) $(PDBFILE:.pdb=.idb)
!endif

!endif

# -------------------------------------------------------------
# Browse
# -------------------------------------------------------------

!if defined(EXETARG)
BROWSETARG=$(EXETARG:.exe=.bsc)
!elseif defined(DLLTARG)
BROWSETARG=$(DLLTARG:.dll=.bsc)
!else
BROWSETARG=$(BLDROOT)\browse.bsc
!endif

browse:
        $(ECHO) /o $(BROWSETARG) /n > $(TMPDIR)\bsc1.tmp
        -DIR /s/b $(ROOT)\tools\x86\msvc\include\*.h > $(TMPDIR)\bsc2.tmp
        $(SED) -e "s/^/\/Ei/" $(TMPDIR)\bsc2.tmp >> $(TMPDIR)\bsc1.tmp
        -DIR /s/b $(BLDROOT)\*.sbr >> $(TMPDIR)\bsc1.tmp
        $(BSCMAKE) $(NOLOGO) @$(TMPDIR)\bsc1.tmp
        $(DEL) $(TMPDIR)\bsc1.tmp
        $(DEL) $(TMPDIR)\bsc2.tmp

# -------------------------------------------------------------
# Other Targets
# -------------------------------------------------------------

beep:
        @ECHO 

clean::
        $(DELALL) $(BLDDIR)\*.*

fresh: clean depend nmake_all

nmake_all::
        nmake all

FULLMAKE=$(MAKE) /$(MAKEFLAGS: =) $(NOLOGO) -f $(SRCROOT)\make\master.mak _RELEASE=$(_RELEASE) SRCROOT=$(SRCROOT) $(MODULE)

fclean:
        $(FULLMAKE) TARGET=clean

fdepend:
        $(FULLMAKE) TARGET=depend

fall:
        $(FULLMAKE) TARGET=all

ffresh: fclean fdepend fall

maccopy::

# -------------------------------------------------------------
# cxx.rsp
# -------------------------------------------------------------

$(BLDDIR)\cxx.rsp : makefile $(SRCROOT)\make\make1.inc $(SRCROOT)\make\make2.inc
    $(COPY) << $(BLDDIR)\cxx.rsp
/I$(INCLUDEPATH:;=
/I)
$(CFLAGS: =
)
$(PCHFLAGS: =
)
/Fo$(BLDDIR)\
/c
<<$(KEEPFLAGS)


# -------------------------------------------------------------
# Depend
# -------------------------------------------------------------

depend::
        $(SET) INCLUDE=
!ifdef PCHFILE
!if exist($(PCHFILE).h)
        $(MKDEP) @<< > $(TMPDIR)\depend.tmp
-n
/I $(INCLUDEDIRS: =
/I )
-s.obj
-P $(BLDDIR)\
*.cpp
*.cxx
*.c
$(BLDDIR)\*.cpp
$(BLDDIR)\*.cxx
$(BLDDIR)\*.c
$(PCHFILE).h
<<$(KEEPFLAGS)
        $(SED) -f << $(TMPDIR)\depend.tmp > $(BLDDIR)\depend.inc
s/$(BLDDIR:\=\\)\\$(PCHFILE)\.obj :/$(PCHPATH:\=\\)\\$(PCHFILE).pch : $(BLDDIR:\=\\)\\cxx.rsp $(PCHFILE).h/
s/\.obj :/.obj : $(BLDDIR:\=\\)\\cxx.rsp $(PCHPATH:\=\\)\\$(PCHFILE).pch/
<<$(KEEPFLAGS)
!else
        $(MKDEP) @<< > $(TMPDIR)\depend.tmp
-d$(PCHFILE).h
-n
/I $(INCLUDEDIRS: =
/I )
-s.obj
-P $(BLDDIR)\
*.cpp
*.cxx
*.c
$(BLDDIR)\*.cpp
$(BLDDIR)\*.cxx
$(BLDDIR)\*.c
<<$(KEEPFLAGS)
        $(SED) -f << $(TMPDIR)\depend.tmp > $(BLDDIR)\depend.inc
s/\.obj :/.obj : $(BLDDIR:\=\\)\\cxx.rsp $(PCHPATH:\=\\)\\$(PCHFILE).pch/
<<$(KEEPFLAGS)
!endif
        $(DEL) $(TMPDIR)\depend.tmp
!else
        $(MKDEP) @<< > $(BLDDIR)\depend.inc
-n
/I $(INCLUDEDIRS: =
/I )
-s.obj
-P $(BLDDIR)\
*.cpp
*.cxx
*.c
$(BLDDIR)\*.cpp
$(BLDDIR)\*.cxx
$(BLDDIR)\*.c
<<$(KEEPFLAGS)
!endif

!if exist($(BLDDIR)\depend.inc)
!include "$(BLDDIR)\depend.inc"
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\mmapi\dll\oleobj.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: oleobj.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "src\mmfactory.h"
#include "dartapi.h"

DeclareTag(tagLockCount,"COM","Lock count");

DAComModule _Module;
extern HINSTANCE hInst;

BEGIN_OBJECT_MAP(COMObjectMap)
    OBJECT_ENTRY(CLSID_MMFactory, CMMFactory)
END_OBJECT_MAP()

bool bFailedLoad = false;

#define EXCEPTION(t) (GetExceptionCode() == t ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH )

LONG
DAComModule::Lock()
{
    // Can't depend on value return from Lock to be accurate.  Since
    // the CRConnect can be called multiple times w/o a problem simply
    // check the internal variable to see if it is 0.  This should
    // never cause anything except multiple calls to CRConnect
    
    bool bNeedConnect = (GetLockCount() == 0);

    LONG l = CComModule::Lock();

    TraceTag((tagLockCount,
              "DAComModule::Lock - new lockcount - %d, returned - %d",
              _Module.GetLockCount(),
              l));
    
    if (bNeedConnect) {
        __try {
            CRConnect(hInst);
        } __except (  EXCEPTION_EXECUTE_HANDLER ) {
            bFailedLoad = true;
        }
    }

    return l;
}

LONG
DAComModule::Unlock()
{
    LONG l = CComModule::Unlock();

    TraceTag((tagLockCount,
              "DAComModule::Unlock - new lockcount - %d, returned - %d",
              _Module.GetLockCount(),
              l));
    
    if (l) return l;
    if (!bFailedLoad)
        CRDisconnect(hInst);
    return 0;
}

#if DEVELOPER_DEBUG
#include <map>

typedef std::map<void *, const char *> ObjectMap;
ObjectMap *objMap = NULL;

void
DAComModule::AddComPtr(void *ptr, const char * name)
{
    EnterCriticalSection(&m_csObjMap);
    (*objMap)[ptr] = name;
    LeaveCriticalSection(&m_csObjMap) ;
}

void
DAComModule::RemoveComPtr(void *ptr)
{
    EnterCriticalSection(&m_csObjMap);
    objMap->erase(ptr);
    LeaveCriticalSection(&m_csObjMap) ;
}

void
DAComModule::DumpObjectList()
{
    if (objMap) {
        EnterCriticalSection(&m_csObjMap);
        if (objMap->size() > 0 || GetLockCount() > 0) {
            OutputDebugString ("MMAPI.DLL: Detected unfreed COM pointers\n");
            OutputDebugString ("Listing pointers and types:\n");
            for (ObjectMap::iterator i = objMap->begin();
                 i != objMap->end();
                 i++) {

                char buf[1024];

                wsprintf(buf, "%#x:", (*i).first);
                OutputDebugString(buf);

                if ((*i).second)
                    OutputDebugString((*i).second);

                OutputDebugString("\n");
            }
        }
             
        LeaveCriticalSection(&m_csObjMap) ;
    }
}

void
DumpCOMObjectList()
{
    _Module.DumpObjectList();
}

#endif

bool
InitializeModule_ATL()
{
    _Module.Init(COMObjectMap, hInst);

#if DEVELOPER_DEBUG
    objMap = NEW ObjectMap;
#endif

    return true;
}

void
DeinitializeModule_ATL(bool bShutdown)
{
#if DEVELOPER_DEBUG
    DumpCOMObjectList();
    
    delete objMap;
    objMap = NULL;
#endif
    
    _Module.Term();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\mmapi\include\headers.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Precompiled headers for mmapi.dll
*******************************************************************************/

#ifndef MMAPI_HEADERS_HXX
#define MMAPI_HEADERS_HXX

/* Standard */
#include <math.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <memory.h>
#include <wtypes.h>

// Warning 4786 (identifier was truncated to 255 chars in the browser
// info) can be safely disabled, as it only has to do with generation
// of browsing information.
#pragma warning(disable:4786)

#include "apeldbg/apeldbg.h"

// ATL - needs to be before windows.h
#include "daatl.h"

/* Windows */
#include <windows.h>
#include <windowsx.h>

/* C++ Replace DLL */
#include "dalibc.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\mmapi\dll\main.cpp ===
/*******************************************************************************
  Copyright (c) 1995-96 Microsoft Corporation

  Abstract:

    Initialization

 *******************************************************************************/

#include "headers.h"

HINSTANCE  hInst;

bool InitializeAllModules(void);
void DeinitializeAllModules(bool bShutdown);

extern "C" BOOL WINAPI _DllMainCRTStartup (HINSTANCE hInstance,
                                           DWORD dwReason,
                                           LPVOID lpReserved);

extern "C" BOOL WINAPI
_DllMainStartup(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_DETACH) {
        // Call the routines in reverse order of initialization
        BOOL r = _DllMainCRTStartup(hInstance,dwReason,lpReserved);
        r = DALibStartup(hInstance,dwReason,lpReserved) && r;

        return r;
    } else {
        // In everything except DLL_PROCESS_DETACH call DALibStartup first
        return (DALibStartup(hInstance,dwReason,lpReserved) &&
                _DllMainCRTStartup(hInstance,dwReason,lpReserved));
    }
}

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        hInst = hInstance;

        DisableThreadLibraryCalls(hInstance);

        // For APELDBG
        RESTOREDEFAULTDEBUGSTATE;

        if (!InitializeAllModules())
        {
            return FALSE;
        }
        
    } else if (dwReason == DLL_PROCESS_DETACH) {
        DeinitializeAllModules(lpReserved != NULL);

#if _DEBUG
        char buf[MAX_PATH + 1];
        
        GetModuleFileName(hInst, buf, MAX_PATH);
        
#if _DEBUGMEM
        TraceTag((tagLeaks, "\n[%s] unfreed memory:", buf));
        DUMPMEMORYLEAKS;
#endif

        // de-initialize the debug trace info.
        DeinitDebug();
#endif
    }
    
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

#ifdef _DEBUG
static bool breakDialog = false ;
DeclareTag(tagDebugBreak, "!Debug", "Breakpoint on entry to DLL");
#endif

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _DEBUG
    if (!breakDialog && IsTagEnabled(tagDebugBreak)) {
        char buf[MAX_PATH + 1];
        
        GetModuleFileName(hInst, buf, MAX_PATH);
        
        MessageBox(NULL,buf,"MMAPI - Creating first COM Object",MB_OK|MB_SETFOREGROUND) ;
        breakDialog = true;
    }
#endif

    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}


#if _DEBUG
STDAPI_(void)
DoTraceTagDialog(HWND hwndStub,
                 HINSTANCE hAppInstance,
                 LPWSTR lpwszCmdLine,
                 int nCmdShow)
{
    DoTracePointsDialog(true);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\mmapi\include\resource.h ===
/*******************************************************************************

Copyright (c) 1998_98 Microsoft Corporation

Abstract:

    MMAPI Resources

*******************************************************************************/


#ifndef _RESOURCE_H
#define _RESOURCE_H

#define RESID_TYPELIB           1

#endif /* _RESOURCE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\mmapi\rsrc\makefile.inc ===
$(PROJNAME).rc : $(SDK_LIB_PATH)\$(PROJNAME).tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\mmapi\src\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"
#include "mmapi.h"
#include "dacomutil.h"
#include "dartapi.h"
#include "util.h"
#include <list>

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\mmapi\src\mmbasebvr.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmbasebvr.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "mmbasebvr.h"
#include "mmplayer.h"

DeclareTag(tagBaseBvr, "API", "CMMBaseBvr methods");

CMMBaseBvr::CMMBaseBvr()
  // The DA bvr we are referencing and its type
: m_id(NULL),
  m_rawbvr(NULL),
  m_typeId(CRINVALID_TYPEID),

  // Basic timing properties - only used to store values
  m_startOffset(0),
  m_duration(-1),
  m_repeatDur(-1),
  m_repeat(1),
  m_bAutoReverse(false),
  m_endOffset(0),
  m_easeIn(0.0),
  m_easeInStart(0.0),
  m_easeOut(0.0),
  m_easeOutEnd(0.0),

  // Calculated times
  m_totalDuration(0.0),
  m_segDuration(0.0),
  m_repDuration(0.0),
  m_totalRepDuration(0.0),
  m_absStartTime( MM_INFINITE ),
  m_absEndTime( MM_INFINITE ),

  m_player(NULL),
  m_parent(NULL),
  m_startSibling(NULL),
  m_endSibling(NULL),
  m_startType(MM_START_ABSOLUTE),

  m_cookie(0)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::CMMBaseBvr()",
              this));
}

CMMBaseBvr::~CMMBaseBvr()
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::~CMMBaseBvr()",
              this));

    delete m_id;
}

HRESULT
CMMBaseBvr::BaseInit(LPOLESTR id, CRBvrPtr rawbvr)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::BaseInit(%ls, %#lx)",
              id,
              rawbvr));
    
    HRESULT hr;

    CRLockGrabber __gclg;

    Assert(rawbvr);

    m_rawbvr = rawbvr;
    
    m_typeId = CRGetTypeId(m_rawbvr);
    
    Assert(m_typeId != CRUNKNOWN_TYPEID &&
           m_typeId != CRINVALID_TYPEID);
    
    m_startTimeBvr = CRModifiableNumber(MM_INFINITE);
    
    if (!m_startTimeBvr)
    {
        hr = CRGetLastError();
        goto done;
    }
    
    m_endTimeBvr = CRModifiableNumber(MM_INFINITE);

    if (!m_endTimeBvr)
    {
        hr = CRGetLastError();
        goto done;
    }
    
    m_timeControl = CRModifiableNumber(MM_INFINITE);

    if (!m_timeControl)
    {
        hr = CRGetLastError();
        goto done;
    }
    
    UpdateTotalDuration();
    
    if (id)
    {
        m_id = CopyString(id);
        
        if (m_id == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    hr = S_OK;

  done:
    return hr;
}

void
CMMBaseBvr::UpdateTotalDuration()
{
    if (m_duration == -1)
    {
        m_segDuration = MM_INFINITE;
    }
    else
    {
        m_segDuration = m_duration;
    }
    
    if (m_bAutoReverse)
    {
        m_repDuration = m_segDuration * 2;
    }
    else
    {
        m_repDuration = m_segDuration;
    }
        
    if (m_repeatDur != -1)
    {
        m_totalRepDuration = m_repeatDur;
    }
    else
    {
        m_totalRepDuration = m_repeat * m_repDuration;
    }

    m_totalDuration = m_startOffset + m_totalRepDuration + m_endOffset;
}

void
CMMBaseBvr::Invalidate()
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::Invalidate()",
              this));

    UpdateTotalDuration();
    
    if (m_parent)
    {
        m_parent->Invalidate();
    }
}

bool
CMMBaseBvr::SetParent(CMMBaseBvr * parent,
                      MM_START_TYPE st,
                      CMMBaseBvr * startSibling)
{
    bool ok = false;
    
    // These will be cleared if we are called correctly
    
    Assert(!m_resultantbvr);
    Assert(m_parent == NULL);
    Assert(m_startTimeSinks.size() == 0);
    Assert(m_endTimeSinks.size() == 0);

    // Validate parameters

    switch (st)
    {
      case MM_START_ABSOLUTE:
        // This is not absolutely necessary but will ensure that if we
        // ever want to take a parameter we know that old code had
        // ensured that it was NULL
        
        if (startSibling != NULL)
        {
            CRSetLastError(E_INVALIDARG, NULL);
            goto done;
        }

        if (!UpdateAbsStartTime(m_startOffset))
        {
            goto done;
        }

        break;
      case MM_START_EVENT:
        // This is not absolutely necessary but will ensure that if we
        // ever want to take a parameter we know that old code had
        // ensured that it was NULL
        
        if (startSibling != NULL)
        {
            CRSetLastError(E_INVALIDARG, NULL);
            goto done;
        }

        if (!UpdateAbsStartTime(MM_INFINITE))
        {
            goto done;
        }

        break;
      case MM_START_WITH:
      case MM_START_AFTER:
        if (startSibling == NULL)
        {
            CRSetLastError(E_INVALIDARG, NULL);
            goto done;
        }

        if (!UpdateAbsStartTime(MM_INFINITE))
        {
            goto done;
        }

        break;
      default:
        CRSetLastError(E_INVALIDARG, NULL);
        goto done;
    }
    
    if (!UpdateAbsEndTime(GetAbsStartTime() + GetTotalRepDuration()))
    {
        goto done;
    }

    // Update args now that we know they are valid

    m_startType = st;
    m_startSibling = startSibling;
    m_parent = parent;

    ok = true;
  done:
    return ok;
}

bool
CMMBaseBvr::ClearParent()
{
    DetachFromSibling();
    
    m_startSibling = NULL;
    m_startType = MM_START_ABSOLUTE;
    m_parent = NULL;
  
    // There is no way for us to ensure this properly (since
    // dependents have no root anymore and our container usually
    // handles this), so our parent better have dealt with it
    
    Assert(m_startTimeSinks.size() == 0);
    Assert(m_endTimeSinks.size() == 0);

    // Just in case
    m_startTimeSinks.clear();
    m_endTimeSinks.clear();

    // Our resultant bvr is no longer valid - clear all constructed
    // behaviors
    DestroyBvr();

    UpdateAbsStartTime(MM_INFINITE);
    UpdateAbsEndTime(MM_INFINITE);

    return true;
}

bool
CMMBaseBvr::AttachToSibling()
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::AttachToSibling()",
              this));
    
    bool ok = false;
    switch(m_startType)
    {
      case MM_START_ABSOLUTE:
        Assert(m_startSibling == NULL);

        if (!UpdateAbsStartTime(m_startOffset))
        {
            goto done;
        }

        break;
      case MM_START_EVENT:
        Assert(m_startSibling == NULL);

        if (!UpdateAbsStartTime(MM_INFINITE))
        {
            goto done;
        }

        break;
      case MM_START_WITH:
        Assert(m_startSibling != NULL);

        // The sibling better have the same parent and it also should not
        // be NULL since it should have been added first
        
        Assert(m_startSibling->GetParent() != NULL);
        Assert(m_startSibling->GetParent() == m_parent);
        
        if (!m_startSibling->AddStartTimeSink(this))
        {
            goto done;
        }
        
        // Our absolute start time is the start time of the sibling
        // plus our start offset
        if (!UpdateAbsStartTime(m_startSibling->GetAbsStartTime() + m_startOffset))
        {
            goto done;
        }

        break;
      case MM_START_AFTER:
        Assert(m_startSibling != NULL);

        // The sibling better have the same parent and it also should not
        // be NULL since it should have been added first
        
        Assert(m_startSibling->GetParent() != NULL);
        Assert(m_startSibling->GetParent() == m_parent);
        
        if (!m_startSibling->AddEndTimeSink(this))
        {
            goto done;
        }
        
        if (!UpdateAbsStartTime(m_startSibling->GetAbsEndTime() + m_startOffset))
        {
            goto done;
        }

        break;
      default:
        Assert(!"CMMBaseBvr::AttachToSibling: Invalid start type");
        break;
    }

    if (!UpdateAbsEndTime(GetAbsStartTime() + GetTotalRepDuration()))
    {
        goto done;
    }

    ok = true;
  done:
    return ok;
}

void
CMMBaseBvr::DetachFromSibling()
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::DetachFromSibling()",
              this));
    
    switch(m_startType)
    {
      case MM_START_ABSOLUTE:
      case MM_START_EVENT:
        Assert(m_startSibling == NULL);
        break;
      case MM_START_WITH:
        Assert(m_startSibling != NULL);
        m_startSibling->RemoveStartTimeSink(this);
        break;
      case MM_START_AFTER:
        Assert(m_startSibling != NULL);
        m_startSibling->RemoveEndTimeSink(this);
        break;
      default:
        Assert(!"CMMBaseBvr::DetachFromSibling: Invalid start type");
        break;
    }
}

void
CMMBaseBvr::SetPlayer(CMMPlayer * player)
{
    Assert(m_player == NULL);
    Assert(!m_resultantbvr);
    
    m_player = player;
}

void
CMMBaseBvr::ClearPlayer()
{
    // We do not need to call Destroy since the clearplayer will do
    // the recursive calls and that would just waste time
    // Our resultant bvr is no longer valid
    ClearResultantBvr();

    m_player = NULL;
}

bool
CMMBaseBvr::ConstructBvr(CRNumberPtr timeline)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::ConstructBvr(%#lx)",
              this,
              timeline));

    bool ok = false;
    
    Assert(!m_resultantbvr);
    // We should never be able to do this w/o a player
    Assert(m_player != NULL);
    
    // Need the GC Lock
    CRLockGrabber __gclg;
    
    CRBvrPtr bvr;

    if ((bvr = EncapsulateBvr(m_rawbvr)) == NULL)
    {
        goto done;
    }

    // First substitute our own control so inside the control we will
    // always refer to local time and it will actually be the local
    // time of the parent since we subst time with the containers
    // timeline after this
    if ((bvr = CRSubstituteTime(bvr, m_timeControl)) == NULL)
    {
        goto done;
    }
    
    // Now subst time the container timer
    
    if ((bvr = CRSubstituteTime(bvr, timeline)) == NULL)
    {
        goto done;
    }
    
    // Update the time control to be consistent with our current state
    // since at this point it has never been set before.
    
    if (!UpdateTimeControl())
    {
        goto done;
    }
    
    // Store away the new bvr in our resultant behavior
    if (!UpdateResultantBvr(bvr))
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok;
}

void
CMMBaseBvr::DestroyBvr()
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::DestroyBvr()",
              this));

    ClearResultantBvr();
}

bool
CMMBaseBvr::UpdateResultantBvr(CRBvrPtr bvr)
{
    Assert(!m_resultantbvr);
    Assert(m_cookie == 0);
    Assert(m_player != NULL);
    
    bool ok = false;
    
    // Run once the behavior so we get a handle to its performance
    if ((bvr = CRRunOnce(bvr)) == NULL)
    {
        goto done;
    }
    
    long cookie;
    
    if ((cookie = m_player->AddRunningBehavior(bvr)) == 0)
    {
        goto done;
    }
    
    m_cookie = cookie;
    m_resultantbvr = bvr;

    ok = true;
  done:
    return ok;
}

void
CMMBaseBvr::ClearResultantBvr()
{
    // Make this robust enough to call even if things are partially setup

    if (m_cookie)
    {
        // If we got here and the player is null then somethings
        // really wrong
        
        Assert(m_player);

        m_player->RemoveRunningBehavior(m_cookie);

        m_cookie = 0;
    }
    
    m_resultantbvr.Release();
}

CRBvrPtr
CMMBaseBvr::EncapsulateBvr(CRBvrPtr rawbvr)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::EncapsulateBvr(%#lx)",
              this,
              rawbvr));

    // Do not need to get GC lock since we have to return a CRBvrPtr
    // and thus the caller must have already acquired it
    
    CRBvrPtr newBvr = NULL;

    // Make sure we calculate the ease in/out coeff
    
    CalculateEaseCoeff();
    
    CRBvrPtr curbvr;

    curbvr = rawbvr;

    CRNumberPtr zeroTime;
    CRNumberPtr durationTime;
    
    if (m_bNeedEase)
    {
        CRNumberPtr time;

        if ((time = EaseTime(CRLocalTime())) == NULL)
        {
            goto done;
        }

        if ((curbvr = CRSubstituteTime(curbvr, time)) == NULL)
        {
            goto done;
        }
    }

    if ((zeroTime = CRCreateNumber(0)) == NULL)
    {
        goto done;
    }
    

    if ((durationTime = CRCreateNumber(m_segDuration)) == NULL)
    {
        goto done;
    }
    
    // For now clamp to the duration as well

    CRNumberPtr timeSub;
    CRBooleanPtr cond;

    if (m_bAutoReverse)
    {
        CRNumberPtr totalTime;
    
        // Invert time from duration to repduration and clamp to
        // zero
        
        if ((totalTime = CRCreateNumber(m_repDuration)) == NULL ||
            (timeSub = CRSub(totalTime, CRLocalTime())) == NULL ||
            (cond = CRLTE(timeSub, zeroTime)) == NULL ||
            (timeSub = (CRNumberPtr) CRCond(cond,
                                            (CRBvrPtr) zeroTime,
                                            (CRBvrPtr) timeSub)) == NULL)
            goto done;
    } else {
        timeSub = durationTime;
    }
    
    // We are localTime until the duration and then we are whatever
    // timeSub is currently set to from above (either clamped for
    // duration time for non-autoreversed or reversed for the autoreverse case)

    if ((cond = CRGTE(CRLocalTime(), durationTime)) == NULL ||
        (timeSub = (CRNumberPtr) CRCond(cond,
                                        (CRBvrPtr) timeSub,
                                        (CRBvrPtr) CRLocalTime())) == NULL)
        goto done;

    // Substitute the clock and clamp to the duration
    
    if (IsContinuousMediaBvr())
    {
        if (!(m_repeat == 0 && m_typeId == CRSOUND_TYPEID))
        {
            if ((curbvr = CRDuration(curbvr, m_segDuration)) == NULL)
                goto done;
        }
    }
    else
    {
        if ((curbvr = CRSubstituteTime(curbvr, timeSub)) == NULL ||
            (curbvr = CRDuration(curbvr, m_repDuration)) == NULL)
            goto done;
    }

    if (m_repeat != 1)
    {
        if (m_repeat == 0)
        {
            curbvr = CRRepeatForever(curbvr);
        }
        else
        {
            curbvr = CRRepeat(curbvr, m_repeat);
        }

        if (curbvr == NULL)
            goto done;
    }

    // We have a total time so add another duration node
    if (m_repeatDur != -1.0f)
    {
        if ((curbvr = CRDuration(curbvr, m_repeatDur)) == NULL)
        {
            goto done;
        }
    }
    
    //
    // We now need to add the start and end hold
    //

    // Offset by the start offset
    if ((timeSub = CRSub(CRLocalTime(), GetStartTimeBvr())) == NULL)
    {
        goto done;
    }
        
    if ((cond = CRGTE(timeSub, zeroTime)) == NULL)
    {
        goto done;
    }
        
    if ((timeSub = (CRNumberPtr) CRCond(cond,
                                        (CRBvrPtr) timeSub,
                                        (CRBvrPtr) zeroTime)) == NULL)
    {
        goto done;
    }
    
    // Now add the end hold and reset to 0 local time after the
    // interval

    CRNumberPtr endholdtime;

    if (m_endOffset != 0.0f)
    {
        // There is an offset so we need to hold the end time behavior
        // for the m_endOffset time
        
        if ((cond = CRGT(CRLocalTime(), GetEndTimeBvr())) == NULL)
        {
            goto done;
        }

        if ((timeSub = (CRNumberPtr) CRCond(cond,
                                            (CRBvrPtr) GetEndTimeBvr(),
                                            (CRBvrPtr) timeSub)) == NULL)
        {
            goto done;
        }

        // Now calculate the end hold time.  It is the behavior end of
        // the behavior plus the end hold value
        if ((endholdtime = CRCreateNumber(m_endOffset)) == NULL)
        {
            goto done;
        }
        
        if ((endholdtime = CRAdd(endholdtime, GetEndTimeBvr())) == NULL)
        {
            goto done;
        }
    }
    else
    {
        // The end time is the end time of the behavior
        endholdtime = GetEndTimeBvr();
    }
    
    if ((cond = CRGT(CRLocalTime(), endholdtime)) == NULL)
    {
        goto done;
    }
    
    if ((timeSub = (CRNumberPtr) CRCond(cond,
                                        (CRBvrPtr) zeroTime,
                                        (CRBvrPtr) timeSub)) == NULL)
    {
        goto done;
    }
    
    if ((curbvr = CRSubstituteTime(curbvr, timeSub)) == NULL)
    {
        goto done;
    }
    
    // indicate success
    newBvr = curbvr;
    
  done:
    return newBvr;
}

bool
CMMBaseBvr::UpdateTimeControl()
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::UpdateTimeControl()",
              this));

    bool ok = false;

    CRLockGrabber __gclg;

    CRNumberPtr tc;
    
    switch(m_startType)
    {
      case MM_START_ABSOLUTE:
        tc = NULL;
        break;
      case MM_START_EVENT:
        {
            if ((tc = CRCreateNumber(GetAbsStartTime())) == NULL)
            {
                goto done;
            }
        }
        
        break;
      case MM_START_WITH:
        Assert(m_startSibling != NULL);

        tc = m_startSibling->GetStartTimeBvr();

        Assert(tc != NULL);

        break;
      case MM_START_AFTER:
        Assert(m_startSibling != NULL);

        tc = m_startSibling->GetEndTimeBvr();

        Assert(tc != NULL);

        break;
      default:
        Assert(!"CMMBaseBvr::UpdateTimeControl: Invalid start type");
        goto done;
    }

    if (tc == NULL)
    {
        tc = CRLocalTime();
    }
    else
    {
        if ((tc = CRAdd(tc, CRLocalTime())) == NULL)
        {
            goto done;
        }
    }

    if (!CRSwitchTo((CRBvrPtr) m_timeControl.p,
                    (CRBvrPtr) tc,
                    true,
                    CRContinueTimeline,
                    0.0))
        goto done;
    
    ok = true;
  done:
    return ok;
}

bool
CMMBaseBvr::AddStartTimeSink( CMMBaseBvr * sink )
{
    m_startTimeSinks.push_back( sink );
    return true;
}

void
CMMBaseBvr::RemoveStartTimeSink( CMMBaseBvr * sink )
{
    m_startTimeSinks.remove( sink );
}

bool
CMMBaseBvr::AddEndTimeSink( CMMBaseBvr* sink )
{
    m_endTimeSinks.push_back( sink );
    return true;
}

void
CMMBaseBvr::RemoveEndTimeSink( CMMBaseBvr* sink )
{
    m_endTimeSinks.remove( sink );
}

// This takes the absolute time to begin.
// If bAfterOffset is true then the time passed in is the time after
// the startoffset, otherwise it is the time before the startoffset

bool 
CMMBaseBvr::StartTimeVisit(double time,
                           CallBackList & l,
                           bool bAfterOffset)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::StartTimeVisit(%g, %#lx, %d)",
              this,
              time,
              &l,
              bAfterOffset));

    bool ok = false;
    double sTime = time;
    
    if (!bAfterOffset)
    {
        // Need to add our offset to get the real start time
        sTime += m_startOffset;
    }
    
    if (!UpdateAbsStartTime(sTime))
    {
        goto done;
    }
    
    if (!UpdateAbsEndTime(GetAbsStartTime() + GetTotalRepDuration()))
    {
        goto done;
    }

    if (!ProcessEvent(l, time - sTime, true, MM_PLAY_EVENT))
    {
        goto done;
    }
    
    {
        for (MMBaseBvrList::iterator i = m_startTimeSinks.begin(); 
             i != m_startTimeSinks.end(); 
             i++)
        {
            if (!(*i)->StartTimeVisit(sTime, l, false))
            {
                goto done;
            }
        }
    }

    ok = true;
  done:
    return ok;
}

bool 
CMMBaseBvr::EndTimeVisit(double time,
                         CallBackList & l)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::EndTimeVisit(%g, %#lx)",
              this,
              time,
              &l));

    bool ok = false;

    if (!UpdateAbsEndTime(time))
    {
        goto done;
    }

    if (!ProcessEvent(l, time - GetAbsStartTime(), false, MM_STOP_EVENT))
    {
        goto done;
    }
    
    // Since we only have beginafters and not endwiths call all the
    // starttimevisit methods
    
    {
        for (MMBaseBvrList::iterator i = m_endTimeSinks.begin(); 
             i != m_endTimeSinks.end(); 
             i++)
        {
            if (!(*i)->StartTimeVisit(time, l, false))
            {
                goto done;
            }
        }
    }

    ok = true;
  done:
    return ok;
}

HRESULT
CMMBaseBvr::Begin(bool bAfterOffset)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::Begin(%d)",
              this,
              bAfterOffset));

    HRESULT hr;
    bool ok = false;
    CallBackList l;
    
    // If no parent set this is an error
    if (m_parent == NULL && m_player == NULL)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    // Get the current time of our parent
    double st;

    st = GetContainerTime();

    // If our container time is indeterminate then just ignore the
    // call
    if (st == MM_INFINITE)
    {
        // Return success: TODO: Need a real error message
        ok = true;
        goto done;
    }
    
    if (!StartTimeVisit(st, l, bAfterOffset))
    {
        goto done;
    }

    if (!ProcessCBList(l))
    {
        goto done;
    }
    
    ok = true;
    
  done:
    return ok?S_OK:Error();
}

HRESULT
CMMBaseBvr::End()
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::End()",
              this));

    HRESULT hr;
    bool ok = false;
    CallBackList l;
    
    // If no parent set this is an error
    if (m_parent == NULL && m_player == NULL)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    // Get the current time of our parent
    double st;

    st = GetContainerTime();

    // If our container time is indeterminate then just ignore the
    // call
    if (st == MM_INFINITE ||
        !IsPlaying())
    {
        // Return success: TODO: Need a real error message
        ok = true;
        goto done;
    }
    
    if (!EndTimeVisit(st, l))
    {
        goto done;
    }

    if (!ProcessCBList(l))
    {
        goto done;
    }
    
    ok = true;
    
  done:
    return ok?S_OK:Error();
}

HRESULT
CMMBaseBvr::Pause()
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::Pause()",
              this));

    HRESULT hr;
    bool ok = false;
    
  done:
    return ok?S_OK:Error();
}

HRESULT
CMMBaseBvr::Resume()
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::Resume()",
              this));

    HRESULT hr;
    bool ok = false;
    
  done:
    return ok?S_OK:Error();
}

HRESULT
CMMBaseBvr::Seek(double lTime)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::Seek(%g)",
              this,
              lTime));

    HRESULT hr;
    bool ok = false;
    
  done:
    return ok?S_OK:Error();
}

double
CMMBaseBvr::GetContainerTime()
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetContainerTime()",
              this));

    double ret = MM_INFINITE;
    
    if (m_parent)
    {
        ret = m_parent->GetCurrentLocalTime();
    }
    else if (m_player)
    {
        // We need to get the time from the player itself
        ret = m_player->GetCurrentTime();
    }
    
    return ret;
}

double
CMMBaseBvr::GetCurrentLocalTime()
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetCurrentLocalTime()",
              this));

    // Get our container's time
    double ret = GetContainerTime();

    // If the container's local time is infinite then so is ours
    if (ret != MM_INFINITE)
    {
        // If we are not inside our range then our local time is
        // infinite
        if (ret >= GetAbsStartTime() &&
            ret <= GetAbsEndTime())
        {
            // Convert our container's time to our local time
            ret = ret - GetAbsStartTime();
        }
        else
        {
            ret = MM_INFINITE;
        }
    }
    
    return ret;
}

bool
CMMBaseBvr::UpdateAbsStartTime(float f)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::UpdateAbsStartTime(%g)",
              this,
              f));

    m_absStartTime = f;

    CRLockGrabber __gclg;
    return CRSwitchToNumber(m_startTimeBvr, (double) f);
}

bool
CMMBaseBvr::UpdateAbsEndTime(float f)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::UpdateAbsEndTime(%g)",
              this,
              f));

    m_absEndTime = f;

    CRLockGrabber __gclg;
    return CRSwitchToNumber(m_endTimeBvr, (double) f);
}

bool
CMMBaseBvr::ResetBvr()
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::ResetBvr()",
              this));

    bool ok = false;

    switch(m_startType)
    {
      case MM_START_ABSOLUTE:
        if (!UpdateAbsStartTime(m_startOffset))
        {
            goto done;
        }

        break;
      case MM_START_EVENT:
        if (!UpdateAbsStartTime(MM_INFINITE))
        {
            goto done;
        }

        break;
      case MM_START_WITH:
        Assert(m_startSibling != NULL);

        if (!UpdateAbsStartTime(m_startSibling->GetAbsStartTime() + m_startOffset))
        {
            goto done;
        }

        break;
      case MM_START_AFTER:
        Assert(m_startSibling != NULL);

        if (!UpdateAbsStartTime(m_startSibling->GetAbsEndTime() + m_startOffset))
        {
            goto done;
        }

        break;
      default:
        Assert(!"CMMBaseBvr::ResetBvr: Invalid start type");
        break;
    }

    if (!UpdateAbsEndTime(GetAbsStartTime() + GetTotalRepDuration()))
    {
        goto done;
    }


    // Now go through our peers which depend on us and reset them

    {
        for (MMBaseBvrList::iterator i = m_startTimeSinks.begin(); 
             i != m_startTimeSinks.end(); 
             i++)
        {
            if (!(*i)->ResetBvr())
            {
                goto done;
            }
        }
    }

    {
        for (MMBaseBvrList::iterator i = m_endTimeSinks.begin(); 
             i != m_endTimeSinks.end(); 
             i++)
        {
            if (!(*i)->ResetBvr())
            {
                goto done;
            }
        }
    }

    ok = true;
  done:
    return ok;
}
    
#if _DEBUG
void
CMMBaseBvr::Print(int spaces)
{
    char buf[1024];

    sprintf(buf, "%*s[id = %ls, dur = %g, ttrep = %g, tt = %g, rep = %d, autoreverse = %d]\r\n",
            spaces,"",
            m_id,
            m_segDuration,
            m_totalRepDuration,
            m_totalDuration,
            m_repeat,
            m_bAutoReverse);

    OutputDebugString(buf);
}
#endif

class __declspec(uuid("f912d958-5c28-11d2-b957-3078302c2030"))
BvrGuid {};

HRESULT WINAPI
CMMBaseBvr::BaseInternalQueryInterface(CMMBaseBvr* pThis,
                                       void * pv,
                                       const _ATL_INTMAP_ENTRY* pEntries,
                                       REFIID iid,
                                       void** ppvObject)
{
    if (InlineIsEqualGUID(iid, __uuidof(BvrGuid)))
    {
        *ppvObject = pThis;
        return S_OK;
    }
    
    return CComObjectRootEx<CComSingleThreadModel>::InternalQueryInterface(pv,
                                                                           pEntries,
                                                                           iid,
                                                                           ppvObject);
}
        
CMMBaseBvr *
GetBvr(IUnknown * pbvr)
{
    CMMBaseBvr * bvr = NULL;

    if (pbvr)
    {
        pbvr->QueryInterface(__uuidof(BvrGuid),(void **)&bvr);
    }
    
    if (bvr == NULL)
    {
        CRSetLastError(E_INVALIDARG, NULL);
    }
                
    return bvr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\mmapi\src\mmbvr.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "mmbvr.h"
#include "mmtimeline.h"

DeclareTag(tagBvr, "API", "CMMBehavior methods");

CMMBehavior::CMMBehavior()
{
    TraceTag((tagBvr,
              "CMMBehavior(%lx)::CMMBehavior()",
              this));
}

CMMBehavior::~CMMBehavior()
{
    TraceTag((tagBvr,
              "CMMBehavior(%lx)::~CMMBehavior()",
              this));
}

HRESULT
CMMBehavior::Init(LPOLESTR id, IDABehavior * dabvr)
{
    TraceTag((tagBvr,
              "CMMBehavior(%lx)::Init(%ls, %lx)",
              this,
              id,
              dabvr));

    HRESULT hr;
    
    CRBvrPtr bvr;
    
    if (!dabvr)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    bvr = COMToCRBvr(dabvr);

    if (!bvr)
    {
        hr = CRGetLastError();
        goto done;
    }

    hr = BaseInit(id, bvr);

    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    return hr;
}

HRESULT
CMMBehavior::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    TraceTag((tagError,
              "CMMBehavior(%lx)::Error(%hr,%ls)",
              this,
              hr,
              str?str:L"NULL"));

    if (str)
        return CComCoClass<CMMBehavior, &__uuidof(CMMBehavior)>::Error(str, IID_IMMBehavior, hr);
    else
        return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\mmapi\src\mmbvr.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _MMBVR_H
#define _MMBVR_H

#include "mmfactory.h"
#include "mmbasebvr.h"

class
__declspec(uuid("ad8888cc-537a-11d2-b955-3078302c2030")) 
ATL_NO_VTABLE CMMBehavior
    : public CComCoClass<CMMBehavior, &__uuidof(CMMBehavior)>,
      public IDispatchImpl<IMMBehavior, &IID_IMMBehavior, &LIBID_WindowsMultimediaRuntime>,
      public ISupportErrorInfoImpl<&IID_IMMBehavior>,
      public CMMBaseBvr
{
  public:
    CMMBehavior();
    ~CMMBehavior();

    HRESULT Init(LPOLESTR id, IDABehavior * bvr);
    
#if _DEBUG
    virtual const char * GetName() { return "CMMBehavior"; }
#endif

    BEGIN_COM_MAP(CMMBehavior)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IMMBehavior)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP();

    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    static inline HRESULT WINAPI
        InternalQueryInterface(CMMBehavior* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject)
    { return BaseInternalQueryInterface(pThis,
                                        (void *) pThis,
                                        pEntries,
                                        iid,
                                        ppvObject); }

    STDMETHOD(get_ID)(LPOLESTR * s)
        { return GetID(s); }
    
    STDMETHOD(put_ID)(LPOLESTR s)
        { return SetID(s); }
        
    STDMETHOD(get_StartOffset)(float * f)
        { return GetStartOffset(f); }
    
    STDMETHOD(put_StartOffset)(float f)
        { return SetStartOffset(f); }
        
    STDMETHOD(get_Duration)(float * pd)
        { return GetDuration(pd); }
    STDMETHOD(put_Duration)(float d)
        { return SetDuration(d); }
        
    STDMETHOD(get_Repeat)(LONG * pr)
        { return GetRepeat(pr); }
    STDMETHOD(put_Repeat)(LONG r)
        { return SetRepeat(r); }
       
    STDMETHOD(get_AutoReverse)(VARIANT_BOOL * pr)
        { return GetAutoReverse(pr); }
    STDMETHOD(put_AutoReverse)(VARIANT_BOOL r)
        { return SetAutoReverse(r); }
        
    STDMETHOD(get_RepeatDur)(float * f)
        { return GetRepeatDur(f); }
    STDMETHOD(put_RepeatDur)(float f)
        { return SetRepeatDur(f); }
        
    STDMETHOD(get_EndOffset)(float * f)
        { return GetEndOffset(f); }
    STDMETHOD(put_EndOffset)(float f)
        { return SetEndOffset(f); }
        
    STDMETHOD(get_EaseIn)(float * pd)
        { return GetEaseIn(pd); }
    STDMETHOD(put_EaseIn)(float d)
        { return SetEaseIn(d); }

    STDMETHOD(get_EaseInStart)(float * pd)
        { return GetEaseInStart(pd); }
    STDMETHOD(put_EaseInStart)(float d)
        { return SetEaseInStart(d); }

    STDMETHOD(get_EaseOut)(float * pd)
        { return GetEaseOut(pd); }
    STDMETHOD(put_EaseOut)(float d)
        { return SetEaseOut(d); }

    STDMETHOD(get_EaseOutEnd)(float * pd)
        { return GetEaseOutEnd(pd); }
    STDMETHOD(put_EaseOutEnd)(float d)
        { return SetEaseOutEnd(d); }

    STDMETHOD(get_EventCB)(IMMEventCB ** ev)
        { return GetEventCB(ev); }
    STDMETHOD(put_EventCB)(IMMEventCB * ev)
        { return SetEventCB(ev); }
        
    STDMETHOD(get_TotalTime)(float * pd)
        { return GetTotalTime(pd); }
        
    STDMETHOD(get_DABehavior)(IDABehavior ** bvr)
        { return CMMBaseBvr::GetDABehavior(IID_IDABehavior, (void **)bvr); }

    STDMETHOD(GetDABehavior)(REFIID riid, void ** bvr)
        { return CMMBaseBvr::GetDABehavior(riid, bvr); }

    STDMETHOD(Begin)(VARIANT_BOOL bAfterOffset)
        { return CMMBaseBvr::Begin(bAfterOffset?true:false); }
    
    STDMETHOD(End)()
        { return CMMBaseBvr::End(); }
    
    STDMETHOD(Pause)()
        { return CMMBaseBvr::Pause(); }
    
    STDMETHOD(Resume)()
        { return CMMBaseBvr::Resume(); }
    
    STDMETHOD(Seek)(double lTime)
        { return CMMBaseBvr::Seek(lTime); }

    STDMETHOD(get_CurrentTime)(double * d)
        { return GetLocalTime(d); }

    STDMETHOD(get_PlayState)(MM_STATE * state)
        { return GetPlayState(state); }

  protected:
    HRESULT Error();
};

#endif /* _MMBVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\mmapi\src\mmbasebvr.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _MMBASEBVR_H
#define _MMBASEBVR_H

#define MM_INFINITE HUGE_VAL

class CMMTimeline;
class CMMBehavior;
class CMMPlayer;

extern TAG tagBaseBvr;

class CallBackData;
typedef std::list<CallBackData *> CallBackList;

class CMMBaseBvr;
typedef std::list<CMMBaseBvr*> MMBaseBvrList;

class
ATL_NO_VTABLE CMMBaseBvr
    : public CComObjectRootEx<CComSingleThreadModel>
{
  public:
    CMMBaseBvr();
    virtual ~CMMBaseBvr();
    
    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;
    
    // We cannot put the real one here since the typecast causes it to
    // get the wrong vtables
    static HRESULT WINAPI
        BaseInternalQueryInterface(CMMBaseBvr* pThis,
                                   void * pv,
                                   const _ATL_INTMAP_ENTRY* pEntries,
                                   REFIID iid,
                                   void** ppvObject);

    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    // Add a dummy one to assert just in case the derived class does
    // not add one
    static inline HRESULT WINAPI
        InternalQueryInterface(CMMBaseBvr* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject)
    {
        AssertStr(false, "InternalQueryInterface not defined in base class");
        return E_FAIL;
    }
    
    HRESULT BaseInit(LPWSTR id, CRBvrPtr rawbvr);

#if _DEBUG
    virtual const char * GetName() { return "CMMBaseBvr"; }
#endif

    // Base interface functions
    
    HRESULT GetID(LPOLESTR *);
    HRESULT SetID(LPOLESTR);
        
    HRESULT GetStartOffset(float *);
    HRESULT SetStartOffset(float);
        
    HRESULT GetDuration(float * pd);
    HRESULT SetDuration(float d);
        
    HRESULT GetRepeat(LONG * pr);
    HRESULT SetRepeat(LONG r);
       
    HRESULT GetAutoReverse(VARIANT_BOOL * pr);
    HRESULT SetAutoReverse(VARIANT_BOOL r);
        
    HRESULT GetRepeatDur(float *);
    HRESULT SetRepeatDur(float);
        
    HRESULT GetEndOffset(float *);
    HRESULT SetEndOffset(float);
        
    HRESULT GetEaseIn(float * pd);
    HRESULT SetEaseIn(float d);

    HRESULT GetEaseInStart(float * pd);
    HRESULT SetEaseInStart(float d);

    HRESULT GetEaseOut(float * pd);
    HRESULT SetEaseOut(float d);

    HRESULT GetEaseOutEnd(float * pd);
    HRESULT SetEaseOutEnd(float d);

    HRESULT GetEventCB(IMMEventCB ** ev);
    HRESULT SetEventCB(IMMEventCB * ev);
        
    HRESULT GetTotalTime(float * pd);
        
    HRESULT GetDABehavior(REFIID riid, void **);

    HRESULT Begin(bool bAfterOffset);
    HRESULT End();
    HRESULT Pause();
    HRESULT Resume();
    HRESULT Seek(double lTime);
    
    HRESULT GetLocalTime(double * d);

    HRESULT GetPlayState(MM_STATE * state);
    
    // Accessors

    CRBvrPtr GetRawBvr() { return m_rawbvr; }
    CRBvrPtr GetResultantBvr() { return m_resultantbvr; }
    float GetStartOffset() { return m_startOffset; }
    float GetDuration() { return m_duration; }
    float GetEndOffset() { return m_endOffset; }
    float GetRepeatDuration() { return m_repDuration; }
    long GetRepeat() { return m_repeat; }
    bool GetAutoReverse() { return m_bAutoReverse; }
    IMMEventCB * GetEventCB() { return m_eventcb; }
    float GetEaseIn() { return m_easeIn; }
    float GetEaseInStart() { return m_easeInStart; }
    float GetEaseOut() { return m_easeOut; }
    float GetEaseOutEnd() { return m_easeOutStart; }
    
    float GetTotalRepDuration() { return m_totalRepDuration; }
    float GetTotalDuration() { return m_totalDuration; }
    float GetStartTime() { return m_startOffset; }
    float GetEndTime() { return m_startOffset + m_totalRepDuration; }
    float GetAbsStartTime() { return m_absStartTime; }
    float GetAbsEndTime() { return m_absEndTime; }
    
    double GetCurrentLocalTime();
    
    CMMBaseBvr * GetParent() { return m_parent; }
    CMMPlayer * GetPlayer() { return m_player; }

    // This will call all the behaviors which are currently running
    // with the given event.  This is used when the timeline needs to
    // process a specific event like Pause/Resume/Stop/Play.
    
    bool ProcessEvent(CallBackList & l,
                      double time,
                      bool bFirstTick,
                      MM_EVENT_TYPE et);
    
    virtual bool _ProcessEvent(CallBackList & l,
                               double time,
                               bool bFirstTick,
                               MM_EVENT_TYPE et,
                               bool bNeedsReverse) { return true; }
    
    bool ProcessCB(CallBackList & l,
                   double lastTick,
                   double curTime,
                   bool bForward,
                   bool bFirstTick,
                   bool bNeedPlay);

    virtual bool _ProcessCB(CallBackList & l,
                            double lastTick,
                            double curTime,
                            bool bForward,
                            bool bFirstTick,
                            bool bNeedPlay,
                            bool bNeedsReverse) { return true; }

    virtual bool EventNotify(CallBackList &l,
                             double lTime,
                             MM_EVENT_TYPE et);
    
    virtual bool ParentEventNotify(CMMBaseBvr * bvr,
                                   double lTime,
                                   MM_EVENT_TYPE et)
    { return true; }
    
    virtual void Invalidate();
    
    virtual bool ConstructBvr(CRNumberPtr timeline);
    virtual void DestroyBvr();
    virtual bool ResetBvr();
    
    bool SetParent(CMMBaseBvr * parent,
                   MM_START_TYPE st,
                   CMMBaseBvr * startSibling);
    bool ClearParent();

    bool AttachToSibling();
    void DetachFromSibling();
    
    virtual void SetPlayer(CMMPlayer * player);
    virtual void ClearPlayer();

    //returns the number CRBvr that represents the start time of this MMBehavior in parent time
    CRNumberPtr GetStartTimeBvr() { return m_startTimeBvr; }
    //returns the number CRBvr that represents the stop time of this MMBehavior in the parent time.
    CRNumberPtr GetEndTimeBvr() { return m_endTimeBvr; }

    CMMBaseBvr *GetStartSibling() { return m_startSibling; }
    CMMBaseBvr *GetEndSibling() { return m_endSibling; }
    MM_START_TYPE GetStartType() { return m_startType; }

#if _DEBUG
    void Print(int spaces);
#endif
  protected:
    
    bool UpdateAbsStartTime(float f);
    bool UpdateAbsEndTime(float f);
    
    bool UpdateResultantBvr(CRBvrPtr bvr);
    void ClearResultantBvr();
    
    CRBvrPtr EncapsulateBvr(CRBvrPtr rawbvr);
    
    void CalculateEaseCoeff();

    // This will take the time behavior and ease it
    CRNumberPtr EaseTime(CRNumberPtr time);

    // This will take the given time and transform it to the correct
    // eased time
    // If the time is outside of our duration (i.e. <0 or >
    // m_duration) this will just return the given time
    double EaseTime(double time);

    virtual bool IsContinuousMediaBvr() { return false; }

    void UpdateTotalDuration();

    // Sibling dependency management
    bool AddStartTimeSink(CMMBaseBvr * sink);
    void RemoveStartTimeSink(CMMBaseBvr * sink);
    bool AddEndTimeSink(CMMBaseBvr* sink);
    void RemoveEndTimeSink(CMMBaseBvr* sink);

    // methods for the propagation of start times and end times.
    // The time passed in is the local time of the parent which we are
    // suppose to start on

    // This is where all the wiring gets hooked up
    // Basicly once we determine what our start time is we can then
    // propagate this information to all of our dependents and allow
    // them to in turn do the same

    bool StartTimeVisit(double time,
                        CallBackList & l,
                        bool bAfterOffset);

    // It is pretty much the same for the end time.  This can be
    // called when our start time is set if we know the duration and
    // will also be called for indeterminate durations or event
    // ending.
    
    bool EndTimeVisit(double time, CallBackList & l);

    bool UpdateTimeControl();

    virtual HRESULT Error() = 0;

    double GetContainerTime();

    bool IsPlaying() { return (GetCurrentLocalTime() != MM_INFINITE); }

    //
    // DATA declarations
    //
  protected:
    LPWSTR m_id;
    float m_startOffset;
    float m_duration;
    float m_repeatDur;
    long m_repeat;
    bool m_bAutoReverse;
    float m_endOffset;
    float m_easeIn;
    float m_easeInStart;
    float m_easeOut;
    float m_easeOutEnd;

    // These are the absolute local times which correspond to when the
    // behavior really starts and really ends - not including start
    // and end offsets.
    float m_absStartTime;
    float m_absEndTime;

    DAComPtr<IMMEventCB> m_eventcb;

    //The way in which this behavior begins.  Can be any of the enum MM_START_TYPE
    MM_START_TYPE m_startType;
    //if this behavior is begin with or after this holds the sibling
    //  that controls when we start.
    CMMBaseBvr *m_startSibling;
    //if this behavior is end with this holds the sibling that controls
    //  when we stop.
    CMMBaseBvr *m_endSibling;

    //TODO: these could be allocated as needed.  They may be fairly rarely used.
    MMBaseBvrList m_startTimeSinks;
    MMBaseBvrList m_endTimeSinks;

    // These behaviors represent the local begin and end times for
    // this behavior.  Siblings can reference these to place
    // themselves relatively according to start with/after and
    // endwith.
    
    CRPtr<CRNumber> m_startTimeBvr;
    CRPtr<CRNumber> m_endTimeBvr;

    // This represents the time sub we are using for the behavior
    // For beginafter/with this points to the siblings appropriate
    // behavior, for an event it points to infinity until the start
    // time is known, and for an absolute it is simply local time.
    // This also allows us to implement slipSync since we can use to
    // adjust ourselves as we need it
    
    CRPtr<CRNumber> m_timeControl;

    // A single segment duration
    float m_segDuration;
    
    // The duration for a single rep of a behavior
    float m_repDuration;

    // Total duration we calculate for a regular behavior 
    float m_totalRepDuration; 

    // The real duration determine by adding totalrepduration + start + end
    float m_totalDuration;

    CRPtr<CRBvr> m_rawbvr;
    CMMBaseBvr * m_parent;
    CR_BVR_TYPEID m_typeId;
    CMMPlayer * m_player;

    CRPtr<CRBvr> m_resultantbvr;
    long m_cookie;
    
    // The ease-in/out behavior modifier is applied using timeline
    // substitution.  The substitute timeline consists of three pieces
    // A, B and C, which are the ease-in, constant velocity and ease-out
    // parts respectively.  For B, a linear timeline is substituted; for
    // A and C, a quadratic warping of the input time is required.

    float m_flA0, m_flA1, m_flA2; // coefficients for the A piece
    float m_flB0, m_flB1;         // coefficients for the B piece
    float m_flC0, m_flC1, m_flC2; // coefficients for the C piece

    // These are the times to perform ease in/out
    float m_easeInEnd;
    float m_easeOutStart;
    bool m_bNeedEase;
};

class CallBackData
{
  public:
    CallBackData(IMMBehavior * bvr,
                 IMMEventCB * eventcb,
                 double time,
                 MM_EVENT_TYPE et);
    ~CallBackData();

    HRESULT CallEvent();

  protected:
    DAComPtr<IMMBehavior> m_bvr;
    double m_time;
    MM_EVENT_TYPE m_et;
    DAComPtr<IMMEventCB> m_eventcb;
};

bool ProcessCBList(CallBackList &l);

#if _DEBUG
inline char * EventString(MM_EVENT_TYPE et) {
    switch(et) {
      case MM_PLAY_EVENT:
        return "Play";
      case MM_STOP_EVENT:
        return "Stop";
      case MM_PAUSE_EVENT:
        return "Pause";
      case MM_RESUME_EVENT:
        return "Resume";
      case MM_REPEAT_EVENT:
        return "Repeat";
      case MM_AUTOREVERSE_EVENT:
        return "Autoreverse";
      default:
        return "Unknown";
    }
}
#endif

CMMBaseBvr * GetBvr(IUnknown *);

#endif /* _MMBASEBVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\mmapi\src\mmfactory.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "mmbvr.h"
#include "mmtimeline.h"
#include "mmplayer.h"
#include "mmfactory.h"

CMMFactory::CMMFactory()
{
}

CMMFactory::~CMMFactory()
{
}


HRESULT
CMMFactory::FinalConstruct()
{
    if (bFailedLoad)
    {
        return E_FAIL;
    }
    
    return S_OK;
}

STDMETHODIMP
CMMFactory::CreateBehavior(LPOLESTR id,
                           IDABehavior *bvr,
                           IMMBehavior **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    DAComObject<CMMBehavior> *pNew;
    DAComObject<CMMBehavior>::CreateInstance(&pNew);

    if (!pNew)
    {
        THR(hr = E_OUTOFMEMORY);
    }
    else
    {
        THR(hr = pNew->Init(id, bvr));
        
        if (SUCCEEDED(hr))
        {
            THR(hr = pNew->QueryInterface(IID_IMMBehavior,
                                          (void **)ppOut));
        }
    }

    if (FAILED(hr))
    {
        delete pNew;
    }

    return hr;
}

STDMETHODIMP
CMMFactory::CreateTimeline(LPOLESTR id,
                           IMMTimeline **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    DAComObject<CMMTimeline> *pNew;
    DAComObject<CMMTimeline>::CreateInstance(&pNew);

    if (!pNew)
    {
        THR(hr = E_OUTOFMEMORY);
    }
    else
    {
        THR(hr = pNew->Init(id));
        
        if (SUCCEEDED(hr))
        {
            THR(hr = pNew->QueryInterface(IID_IMMTimeline,
                                          (void **)ppOut));
        }
    }

    if (FAILED(hr))
    {
        delete pNew;
    }

    return hr;
}

STDMETHODIMP
CMMFactory::CreatePlayer(LPOLESTR id,
                         IMMBehavior * bvr,
                         IDAView * v,
                         IMMPlayer **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    DAComObject<CMMPlayer> *pNew;
    DAComObject<CMMPlayer>::CreateInstance(&pNew);

    if (!pNew)
    {
        THR(hr = E_OUTOFMEMORY);
    }
    else
    {
        THR(hr = pNew->Init(id,bvr,v));
        
        if (SUCCEEDED(hr))
        {
            THR(hr = pNew->QueryInterface(IID_IMMPlayer,
                                          (void **)ppOut));
        }
    }

    if (FAILED(hr))
    {
        delete pNew;
    }

    return hr;
}

HRESULT
CMMFactory::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    if (str)
    {
        return CComCoClass<CMMFactory, &CLSID_MMFactory>::Error(str,
                                                                IID_IMMFactory,
                                                                hr);
    }
    else
    {
        return hr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\mmapi\src\mmfactory.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _MMFACTORY_H
#define _MMFACTORY_H

#define LIBID "WindowsMultimediaRuntime"

class ATL_NO_VTABLE CMMFactory
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CMMFactory, &CLSID_MMFactory>,
      public IDispatchImpl<IMMFactory, &IID_IMMFactory, &LIBID_WindowsMultimediaRuntime>,
      public ISupportErrorInfoImpl<&IID_IMMFactory>
{
  public:
    CMMFactory();
    ~CMMFactory();

    DA_DECLARE_NOT_AGGREGATABLE(CMMFactory);

    HRESULT FinalConstruct();
#if _DEBUG
    const char * GetName() { return "CMMFactory"; }
#endif

    DECLARE_REGISTRY(CLSID_MMFactory,
                     LIBID ".MMFactory.1",
                     LIBID ".MMFactory",
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CMMFactory)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IMMFactory)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP();

    STDMETHOD(CreateBehavior)(LPOLESTR id,
                              IDABehavior *bvr,
                              IMMBehavior **ppOut);
    STDMETHOD(CreateTimeline)(LPOLESTR id,
                              IMMTimeline **ppOut);
    STDMETHOD(CreatePlayer)(LPOLESTR id,
                            IMMBehavior *bvr,
                            IDAView * v,
                            IMMPlayer **ppOut);

    HRESULT Error();
};


#endif /* _MMFACTORY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\mmapi\src\mmnotify.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmnotify.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "mmbasebvr.h"
#include "mmtimeline.h"

DeclareTag(tagNotify, "API", "Notifications");

// IMPORTANT!!!!!
// This needs to be called in the right order so that we get the
// correct children firing during the current interval but they get
// reset for the next interval. Otherwise we will not get the correct
// results.

bool
CMMBaseBvr::EventNotify(CallBackList &l,
                        double gTime,
                        MM_EVENT_TYPE et)
{
    TraceTag((tagNotify,
              "CMMBaseBvr(%#lx)::Notify(%#x): gTime = %g, event = %s",
              this,
              m_parent,
              gTime,
              EventString(et)));

    bool ok = false;
    
    if (m_eventcb)
    {
        CallBackData * data = NEW CallBackData((IMMBehavior *) this,
                                               m_eventcb,
                                               gTime,
                                               et);
    
        if (!data)
        {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
        
        l.push_back(data);
    }

    if (m_parent)
    {
        if (!m_parent->ParentEventNotify(this, gTime, et))
        {
            goto done;
        }
    }
    
    ok = true;
  done:
    return ok;
}

bool
CMMTimeline::EventNotify(CallBackList &l,
                         double gTime,
                         MM_EVENT_TYPE et)
{
    TraceTag((tagNotify,
              "CMMTimeline(%#lx)::Notify(%#x): gTime = %g, event = %s",
              this,
              m_parent,
              gTime,
              EventString(et)));

    bool ok = false;
    
    // For Repeat/Autoreverse events we need to make sure we
    // reset all the children of the behavior.
    
    if (et == MM_REPEAT_EVENT ||
        et == MM_AUTOREVERSE_EVENT)
    {
        if (!ResetChildren())
        {
            goto done;
        }
    }
    
    if (!CMMBaseBvr::EventNotify(l, gTime, et))
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok;
}

// This is in our local time coordinates - which means that we begin
// at 0.  This needs to be handled by the caller

bool
CMMBaseBvr::ProcessCB(CallBackList & l,
                      double lastTick,
                      double curTime,
                      bool bForward,
                      bool bFirstTick,
                      bool bNeedPlay)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::ProcessCB(%g, %g, %d, %d, %d)",
              this,
              lastTick,
              curTime,
              bForward,
              bFirstTick,
              bNeedPlay));

    // The duration is really the end time minus the start time since
    // the user can change it on the fly.  We need to handle this and
    // adjust as appropriate
    
    double totaldur = GetAbsEndTime() - GetAbsStartTime();

    if (bForward)
    {
        // See if we already pass this entire bvr last time or if we
        // have not got to it yet
        
        // The equality just needs to match what we checked below when
        // we fired the event the frame before.  We need to use LT for
        // curTime since we need to fire when we are 0
        
        if (lastTick >= totaldur || curTime < 0)
        {
            // Need to handle boundary case where we start at the end
            // of the animation.  If so then just fire the stop event
            // since the start was done by the start call itself
            
            int offset;
            
            if (curTime == totaldur && lastTick == totaldur && bFirstTick)
            {
                int offset = ceil(curTime / m_segDuration) - 1;
                if (offset < 0)
                {
                    offset = 0;
                }
                double timeOffset = offset * m_segDuration;

                if (!_ProcessCB(l,
                                lastTick - timeOffset,
                                curTime - timeOffset,
                                bForward,
                                bFirstTick,
                                bNeedPlay,
                                m_bAutoReverse && (offset & 0x1)))
                {
                    return false;
                }

                if (!EventNotify(l, totaldur, MM_STOP_EVENT))
                {
                    return false;
                }
            }

            return true;
        }
        
        // We now know that the last tick was less than the
        // totalrepduration and the current time is greater than the
        // beginning

        // If the last tick was 0 then we fire the start last time
        // since the check above if for less than
        // So the rule is fire when curTime == 0.0
        
        bool bNeedStart = (lastTick < 0 || bNeedPlay);

        if (bNeedStart)
        {
            // This means that we just entered

            if (!EventNotify(l, 0, MM_PLAY_EVENT))
            {
                return false;
            }
        }
        
        if (m_segDuration == MM_INFINITE)
        {
            // Just always process our children if we are infinite
            
            if (!_ProcessCB(l,
                            lastTick,
                            curTime,
                            bForward,
                            bFirstTick,
                            bNeedPlay,
                            false))
            {
                return false;
            }
        }
        else
        {
            // This is the last repeat/bounce boundary we hit
        
            int offset = int(lastTick / m_segDuration);

            if (offset < 0)
            {
                offset = 0;
            }

            double timeOffset = offset * m_segDuration;

            // Need to clamp our max time so it does not mess up our children
            double maxtime = min(totaldur, curTime);

            while (1)
            {
                // We need to request a reversal of the underlying
                // behavior if we are bouncing and the offset is odd
                
                if (!_ProcessCB(l,
                                lastTick - timeOffset,
                                maxtime - timeOffset,
                                true,
                                bFirstTick,
                                bNeedStart,
                                m_bAutoReverse && (offset & 0x1)))
                {
                    return false;
                }
                
                // If we have reached the end then notify and break
                
                if (curTime < (timeOffset + m_segDuration))
                {
                    break;
                }
                
                // We have reach the end of our current period so all
                // children must be stopped.
                
                {
                    double t;
                    
                    t = maxtime - timeOffset;
                    
                    if (t > m_segDuration)
                    {
                        t = m_segDuration;
                    }
                    
                    if (!_ProcessEvent(l,
                                       t,
                                       false,
                                       MM_STOP_EVENT,
                                       m_bAutoReverse && (offset & 0x1)))
                    {
                        return false;
                    }
                }
                
                offset++;
                timeOffset += m_segDuration;
                
                if (timeOffset >= totaldur)
                {
                    if (curTime >= totaldur)
                    {
                        // This means we were inside last time but not any more -
                        // generate an exit event
                        
                        if (!EventNotify(l, totaldur, MM_STOP_EVENT))
                        {
                            return false;
                        }
                    }
                    
                    break;
                }
                
                // Indicate a repeat or bounce
                // If we are autoreversing and the offset is odd then it is
                // a reverse and not a repeat
                
                if (m_bAutoReverse && (offset & 0x1))
                {
                    if (!EventNotify(l,
                                     timeOffset,
                                     MM_AUTOREVERSE_EVENT))
                    {
                        return false;
                    }
                }
                else
                {
                    if (!EventNotify(l, timeOffset, MM_REPEAT_EVENT))
                    {
                        return false;
                    }
                }
            }
        }
    } else {
        // See if we already pass this entire bvr last time or if we
        // have not got to it yet
        
        if (curTime > totaldur || lastTick <= 0)
        {
            if (curTime == 0.0 && lastTick == 0.0 && bFirstTick)
            {
                // Need to handle the boundary case where we start at
                // the beginning going backwards.  The start call
                // itself handles the start event but we need to
                // process the rest of the behaviors to fire the stops

                if (!_ProcessCB(l,
                                lastTick,
                                curTime,
                                bForward,
                                true,
                                bNeedPlay,
                                false))
                {
                    return false;
                }

                if (!EventNotify(l, 0.0, MM_STOP_EVENT))
                {
                    return false;
                }
            }
            
            return true;
        }
        
        // We now know that the last tick was greater than the beginning
        // and the current time less than the total duration
        
        bool bNeedStart = (lastTick > totaldur || bNeedPlay);

        if (bNeedStart)
        {
            // This means that we just entered and we cannot have an
            // infinite value

            if (!EventNotify(l, totaldur, MM_PLAY_EVENT))
            {
                return false;
            }
            
        }

        if (m_segDuration == MM_INFINITE)
        {
            // Just always process our children if we are infinite
            
            if (!_ProcessCB(l,
                            lastTick,
                            curTime,
                            bForward,
                            bFirstTick,
                            bNeedPlay,
                            false))
            {
                return false;
            }

            if (curTime <= 0)
            {
                if (!EventNotify(l, 0.0, MM_STOP_EVENT))
                {
                    return false;
                }
            }
                
        } else {
            // This will be the repeat point to begin with
            double maxtime = min(lastTick,totaldur);

            int offset;
            double timeOffset;
                
            // This puts us on the last duration boundary greater than
            // the last position

            // It needs to be one greater since our loop decrements
            // first
            offset = int(ceil(maxtime / m_segDuration));
            timeOffset = offset * m_segDuration;
            
            while (1)
            {
                offset--;
                timeOffset -= m_segDuration;
            
                if (!_ProcessCB(l,
                                maxtime - timeOffset,
                                curTime - timeOffset,
                                false,
                                bFirstTick,
                                bNeedStart,
                                m_bAutoReverse && (offset & 0x1)))
                {
                    return false;
                }
                
                if (timeOffset < curTime)
                {
                    break;
                }
                
                // We have reach the end of our current period so all
                // children must be stopped.
                {
                    double t;

                    t = curTime - timeOffset;

                    if (t > m_segDuration)
                    {
                        t = m_segDuration;
                    }
                
                    if (!_ProcessEvent(l,
                                       t,
                                       false,
                                       MM_STOP_EVENT,
                                       m_bAutoReverse && (offset & 0x1)))
                    {
                        return false;
                    }
                }
                
                // If we have reached the end then notify and break
                
                if (offset <= 0)
                {
                    // This means we were inside last time but not any more -
                    // generate an exit event
                    
                    if (!EventNotify(l, 0.0, MM_STOP_EVENT))
                    {
                        return false;
                    }
                    
                    break;
                }
                
                // Indicate a repeat or bounce
                // If we are bouncing and the offset is odd then it is
                // a bounce and not a repeat
                
                if (m_bAutoReverse && (offset & 0x1))
                {
                    if (!EventNotify(l,
                                     timeOffset,
                                     MM_AUTOREVERSE_EVENT))
                    {
                        return false;
                    }
                }
                else
                {
                    if (!EventNotify(l, timeOffset, MM_REPEAT_EVENT))
                    {
                        return false;
                    }
                }
            }
        }
    }
    


    return true;
}

// This is in our local time space

bool
CMMBaseBvr::ProcessEvent(CallBackList & l,
                         double time,
                         bool bFirstTick,
                         MM_EVENT_TYPE et)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::ProcessEvent(%g, %d, %s)",
              this,
              time,
              bFirstTick,
              EventString(et)));

    double totaldur = GetAbsEndTime() - GetAbsStartTime();
    
    // If it is outside of our range then just bail
    
    if (time < 0 || time > totaldur)
    {
        return true;
    }
    
    // If it is not the first tick and we are on a boundary do not
    // fire the events - they were already fired
    if (!bFirstTick &&
        (time == 0 || time == totaldur))
    {
        return true;
    }
    
    // Plays and Pauses get called on the way down
    if (et == MM_PAUSE_EVENT || et == MM_PLAY_EVENT)
    {
        if (!EventNotify(l, time, et))
        {
            return false;
        }
    }
    
    if (GetTotalDuration() == MM_INFINITE) {
        // Just always process our children if we are infinite
        
        if (!_ProcessEvent(l,
                           time,
                           bFirstTick,
                           et,
                           false))
        {
            return false;
        }
    } else {
        // This is the last repeat/bounce boundary we hit
        int offset = int(time / m_segDuration);
        
        Assert(offset >= 0);

        // We need to request a reversal of the underlying
        // behavior if we are bouncing and the offset is odd
        
        if (!_ProcessEvent(l,
                           time - (offset * m_segDuration),
                           bFirstTick,
                           et,
                           m_bAutoReverse && (offset & 0x1)))
        {
            return false;
        }
    }
    
    // Stops and Resumes get called on the way up
    if (et == MM_STOP_EVENT || et == MM_RESUME_EVENT)
    {
        if (!EventNotify(l, time, et))
        {
            return false;
        }
    }
    
    return true;
}


CallBackData::CallBackData(IMMBehavior * bvr,
                           IMMEventCB * eventcb,
                           double time,
                           MM_EVENT_TYPE et)
: m_bvr(bvr),
  m_eventcb(eventcb),
  m_time(time),
  m_et(et)
{
    Assert(eventcb);
}

CallBackData::~CallBackData()
{
}

HRESULT
CallBackData::CallEvent()
{
    Assert(m_eventcb);
    
    return THR(m_eventcb->OnEvent(m_time,
                                  m_bvr,
                                  m_et));
}

bool
ProcessCBList(CallBackList &l)
{
    bool ok = true;
    
    for (CallBackList::iterator i = l.begin();
         i != l.end();
         i++) {

        if (FAILED((*i)->CallEvent()))
            ok = false;

        delete (*i);
    }

    l.clear();

    if (!ok)
        CRSetLastError(E_FAIL, NULL);

    return ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\mmapi\src\mmease.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmease.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "mmbasebvr.h"

void
CMMBaseBvr::CalculateEaseCoeff()
{
    Assert(m_easeIn >= 0.0f && m_easeIn <= 1.0f);
    Assert(m_easeOut >= 0.0f && m_easeOut <= 1.0f);
    Assert(m_easeInStart >= 0.0f && m_easeInStart <= 1.0f);
    Assert(m_easeOutEnd >= 0.0f && m_easeOutEnd <= 1.0f);

    // We need to ease the behavior if we are not infinite and either
    // ease in or ease out percentages are non-zero
    
    m_bNeedEase = (m_duration != HUGE_VAL &&
                   (m_easeIn > 0.0f || m_easeOut > 0.0f) &&
                   (m_easeIn + m_easeOut <= 1.0f));

    if (!m_bNeedEase) return;
    
    float flEaseInDuration = m_easeIn * m_duration;
    float flEaseOutDuration = m_easeOut * m_duration;
    float flMiddleDuration = m_duration - flEaseInDuration - flEaseOutDuration;
    
    // Compute B1, the velocity during segment B.
    float flInvB1 = (0.5f * m_easeIn * (m_easeInStart - 1.0f) +
                     0.5f * m_easeOut * (m_easeOutEnd - 1.0f) + 1.0f);
    Assert(flInvB1 > 0.0f);
    m_flB1 = 1.0f / flInvB1;
    
    // Basically for accelerated pieces - t = t0 + v0 * t + 1/2 at^2
    // and a = Vend - Vstart / t

    if (flEaseInDuration != 0.0f) {
        m_flA0 = 0.0f;
        m_flA1 = m_easeInStart * m_flB1;
        m_flA2 = 0.5f * (m_flB1 - m_flA1) / flEaseInDuration;
    } else {
        m_flA0 = m_flA1 = m_flA2 = 0.0f;
    }

    m_flB0 = m_flA0 + m_flA1 * flEaseInDuration + m_flA2 * flEaseInDuration * flEaseInDuration;
    
    if (flEaseOutDuration != 0.0f) {
        m_flC0 = m_flB1 * flMiddleDuration + m_flB0;
        m_flC1 = m_flB1;
        m_flC2 = 0.5f * (m_easeOutEnd * m_flB1 - m_flC1) / flEaseOutDuration;
    } else {
        m_flC0 = m_flC1 = m_flC2 = 0.0f;
    }

    m_easeInEnd = flEaseInDuration;
    m_easeOutStart = m_duration - flEaseOutDuration;
}

CRNumberPtr
Quadratic(CRNumberPtr time, float flA, float flB, float flC)
{
    // Assume that the GC lock is acquired
    
    // Need to calculate ax^2 + bx + c

    Assert(time != NULL);

    CRNumberPtr ret = NULL;
    CRNumberPtr accum = NULL;

    if (flC != 0.0f) {
        if ((accum = CRCreateNumber(flC)) == NULL)
            goto done;
    }

    if (flB != 0.0f) {
        CRNumberPtr term;

        if ((term = CRCreateNumber(flB)) == NULL ||
            (term = CRMul(term, time)) == NULL)
            goto done;

        if (accum) {
            if ((term = CRAdd(term, accum)) == NULL)
                goto done;
        }

        accum = term;
    }

    if (flA != 0.0f) {
        CRNumberPtr term;

        if ((term = CRCreateNumber(flA)) == NULL ||
            (term = CRMul(term, time)) == NULL ||
            (term = CRMul(term, time)) == NULL)
            goto done;

        if (accum) {
            if ((term = CRAdd(term, accum)) == NULL)
                goto done;
        }

        accum = term;
    }

    // If all the coeff are zero then just return 0
    
    if (accum == NULL) {
        if ((accum = CRCreateNumber(0.0f)) == NULL)
            goto done;
    }
    
    ret = accum;
    
  done:
    return ret;
}

CRNumberPtr
AddTerm(CRNumberPtr time,
        CRNumberPtr prevTerm,
        float prevDur,
        float flA, float flB, float flC)
{
    CRNumberPtr ret = NULL;
    CRNumberPtr term;
    
    // Offset the time to be zero since that is what the coeffs are
    // based on
    
    if (prevTerm) {
        CRNumberPtr t;
        
        if ((t = CRCreateNumber(prevDur)) == NULL ||
            (time = CRSub(time, t)) == NULL)
            goto done;
    }

    if ((term = Quadratic(time, flA, flB, flC)) == NULL)
        goto done;
    
    // Now we need to conditional use the new term

    if (prevTerm) {
        CRBooleanPtr cond;
        CRNumberPtr zeroTime;
        
        if ((zeroTime = CRCreateNumber(0)) == NULL ||
            (cond = CRLT(time, zeroTime)) == NULL ||
            (term = (CRNumberPtr) CRCond(cond,
                                         (CRBvrPtr) prevTerm,
                                         (CRBvrPtr) term)) == NULL)
            goto done;
    }

    ret = term;
  done:
    return ret;
}

CRNumberPtr
CMMBaseBvr::EaseTime(CRNumberPtr time)
{
    CRNumberPtr ret = NULL;
    CRNumberPtr subTime = NULL;
    
    if (!m_bNeedEase) {
        ret = time;
        goto done;
    }
    
    if (m_easeIn > 0) {
        if ((subTime = AddTerm(time,
                               subTime,
                               0.0,
                               m_flA2, m_flA1, m_flA0)) == NULL)
            goto done;
    }
    
    // If there is space between the end of easing in and the
    // beginning of easing out then we have some constant time
    // interval
    if (m_easeInEnd < m_easeOutStart) {
        if ((subTime = AddTerm(time,
                               subTime,
                               m_easeInEnd,
                               0, m_flB1, m_flB0)) == NULL)
            goto done;
    }

    if (m_easeOut > 0) {
        if ((subTime = AddTerm(time,
                               subTime,
                               m_easeOutStart,
                               m_flC2, m_flC1, m_flC0)) == NULL)
            goto done;
    }
    
    ret = subTime;
    
    Assert(ret);
  done:
    return ret;
}

double
Quadratic(double time, float flA, float flB, float flC)
{
    // Need to calculate ax^2 + bx + c
    // Use x * (a * x + b) + c - since it requires 1 less multiply
    
    return (time * (flA * time + flB) + flC);
}

double
CMMBaseBvr::EaseTime(double time)
{
    if (!m_bNeedEase || time <= 0 || time >= m_duration)
        return time;
    
    if (time <= m_easeInEnd) {
        return Quadratic(time, m_flA2, m_flA1, m_flA0);
    } else if (time < m_easeOutStart) {
        return Quadratic(time - m_easeInEnd, 0.0f, m_flB1, m_flB0);
    } else {
        return Quadratic(time - m_easeOutStart, m_flC2, m_flC1, m_flC0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\mmapi\src\mmplayer.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "mmplayer.h"
#include "mmbasebvr.h"

DeclareTag(tagPlayer, "API", "CMMPlayer methods");
DeclareTag(tagDetailNotify, "API", "Detailed notify");

CMMPlayer::CMMPlayer()
: m_id(NULL),
  m_state(MM_STOPPED_STATE),
  m_bForward(true),
  m_bNeedsUpdate(true),
  m_firstTick(true),
  m_ignoreCB(0)
{
}

CMMPlayer::~CMMPlayer()
{
    // Ensure the player will not try to call us since we are going away

    if (m_playerhook)
    {
        m_playerhook->SetPlayer(NULL);
    }

    if (m_mmbvr)
    {
        m_mmbvr->ClearPlayer();
    }

    delete m_id;

    // run though and delete the items in the vector.
    std::vector<ViewListSt*>::iterator i;
    for (i = m_viewVec.begin(); i < m_viewVec.end(); i++) {
        delete (*i);
    }
}

HRESULT
CMMPlayer::Init(LPOLESTR id,
                IMMBehavior * bvr,
                IDAView * v)
{
    TraceTag((tagPlayer,
              "CMMPlayer(%lx)::Init(%ls, %#lx,%#lx)",
              this,
              id,
              bvr,
              v));
    
    HRESULT hr;
    
    if (!bvr || !v)
    {
        TraceTag((tagError,
                  "CMMPlayer(%lx)::Init: Invalid behavior passed in.",
                  this));
                  
        hr = E_INVALIDARG;
        goto done;
    }

    if (id)
    {
        m_id = CopyString(id);
        
        if (m_id == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    // Need to do this early since some of the other initialization
    // needs the view to be around.  However, make sure on an error
    // that we release it so we do not have an outstanding addref for
    // too long
    hr = THR(v->QueryInterface(IID_IDA3View, (void **) & m_view));

    if (FAILED(hr))
    {
        hr = E_INVALIDARG;
        goto done;
    }
    
    CMMBaseBvr * cbvr;

    cbvr = GetBvr(bvr);
    
    if (!cbvr)
    {
        TraceTag((tagError,
                  "CMMPlayer(%lx)::Init: Invalid behavior passed in.",
                  this));
                  
        hr = E_INVALIDARG;
        goto done;
    }

    m_mmbvr = cbvr;
    
    m_mmbvr->SetPlayer(this);

    if (!m_mmbvr->SetParent(NULL, MM_START_ABSOLUTE, NULL))
    {
        hr = CRGetLastError();
        goto done;
    }

    m_playerhook = NEW PlayerHook;

    if (!m_playerhook)
    {
        TraceTag((tagError,
                  "CMMPlayer(%lx)::Init: Out of memory allocating player hook.",
                  this));
                  
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    {
        CRLockGrabber __gclg;
        m_modbvr = CRModifiableBvr(m_mmbvr->GetRawBvr(), 0);

        if (!m_modbvr)
        {
            hr = CRGetLastError();
            goto done;
        }

        CRNumberPtr ts;
        
        if (!(m_timeSub = CRModifiableNumber(0.0)))
        {
            hr = CRGetLastError();
            goto done;
        }
        
        // Place us in a stopped state
        if (!_Start(0) || !_Stop(0))
        {
            hr = CRGetLastError();
            goto done;
        }
    }

    hr = S_OK;
  done:

    if (FAILED(hr))
    {
        // Do some cleanup early - ensures no cycles
        m_playerhook.Release();
        m_view.Release();
    }
    
    return hr;
}


HRESULT
CMMPlayer::AddView(IDAView *view, IUnknown * pUnk, IDAImage *img, IDASound *snd)
{
    TraceTag((tagPlayer,
              "CMMPlayer(%lx)::AddView()",
              this));

    HRESULT hr;
    bool bPending = false;

    ViewListSt *ptVls;
    ptVls = NEW ViewListSt;

    ptVls->view         = view;
//    ptVls->img          = img;
//    ptVls->snd          = snd;

    hr = pUnk->QueryInterface(IID_IElementBehaviorSiteRender,
                                      (void **) &ptVls->SiteRender);

    if(FAILED(hr))
    {
        goto done;
    }

    m_viewVec.push_back(ptVls);
    
    hr = THR(view->put_DC(NULL));

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    hr = THR(view->StartModel(img, snd, 0.0));

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CMMPlayer::get_ID(LPOLESTR * p)
{
    TraceTag((tagPlayer,
              "CMMPlayer(%lx)::get_ID()",
              this));

    HRESULT hr;
    
    CHECK_RETURN_SET_NULL(p);

    if (m_id)
    {
        *p = SysAllocString(m_id);

        if (*p == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    hr = S_OK;
  done:
    return hr;
}

HRESULT
CMMPlayer::put_ID(LPOLESTR s)
{
    TraceTag((tagPlayer,
              "CMMPlayer(%lx)::put_ID(%ls)",
              this,
              s));

    HRESULT hr;

    delete m_id;
    m_id = NULL;

    if (s)
    {
        s = CopyString(s);

        if (s == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    hr = S_OK;
  done:
    return hr;
}
        
STDMETHODIMP
CMMPlayer::get_Behavior(IMMBehavior ** mmbvr)
{
    CHECK_RETURN_SET_NULL(mmbvr);

    Assert (m_mmbvr);
    
    return m_mmbvr->QueryInterface(IID_IMMBehavior,
                                   (void **) mmbvr);
}

STDMETHODIMP
CMMPlayer::get_View(IDAView ** v)
{
    CHECK_RETURN_SET_NULL(v);

    Assert (m_view);
    
    *v = m_view;
    m_view->AddRef();

    return S_OK;
}

STDMETHODIMP
CMMPlayer::get_PlayerState(MM_STATE * pstate)
{
    CHECK_RETURN_NULL(pstate);
    
    *pstate = m_state;

    return S_OK;
}

STDMETHODIMP
CMMPlayer::get_CurrentTime(double * d)
{
    CHECK_RETURN_NULL(d);

    *d = m_curTick;

    return S_OK;
}

STDMETHODIMP
CMMPlayer::SetPosition(double lTime)
{
    TraceTag((tagPlayer,
              "CMMPlayer(%lx)::SetPosition(%g)",
              this,
              lTime));

    bool ok = false;

    if (!_Seek(lTime))
    {
        goto done;
    }

    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMPlayer::SetDirection(VARIANT_BOOL bForward)
{
    TraceTag((tagPlayer,
              "CMMPlayer(%lx)::SetDirection(%d)",
              this,
              bForward));

    if (IsStarted())
    {
        TraceTag((tagError,
                  "CMMPlayer(%lx)::SetDirection: Behavior already started.",
                  this));

        return E_FAIL;
    }

    m_bForward = bForward?true:false;
    return S_OK;
}


STDMETHODIMP
CMMPlayer::Play()
{
    TraceTag((tagPlayer,
              "CMMPlayer(%lx)::Play()",
              this));

    bool ok = false;
    CallBackList l;

    if (!IsStopped()) {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
        
    if (!_Start(m_curTick) ||
        !ProcessEvent(l, m_curTick, MM_PLAY_EVENT) ||
        !ProcessCBList(l))
        goto done;

    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMPlayer::Stop()
{
    TraceTag((tagPlayer,
              "CMMPlayer(%lx)::Stop()",
              this));

    bool ok = false;
    CallBackList l;

    if (IsStopped()) {
        ok = true;
        goto done;
    }
    
    if (!_Stop(m_curTick) ||
        !ProcessEvent(l, m_curTick, MM_STOP_EVENT) ||
        !ProcessCBList(l))
        goto done;
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMPlayer::Pause()
{
    TraceTag((tagPlayer,
              "CMMPlayer(%lx)::Pause()",
              this));

    bool ok = false;
    CallBackList l;

    if (IsPaused()) {
        ok = true;
        goto done;
    }
    
    if (IsStopped()) {
        if (FAILED(Play()))
            goto done;
    }
    
    Assert(IsPlaying());
        
    if (!_Pause() ||
        !ProcessEvent(l, m_curTick, MM_PAUSE_EVENT) ||
        !ProcessCBList(l))
        goto done;
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMPlayer::Resume()
{
    TraceTag((tagPlayer,
              "CMMPlayer(%lx)::Resume()",
              this));

    bool ok = false;
    CallBackList l;

    if (IsPlaying()) {
        ok = true;
        goto done;
    } else if (IsStopped()) {
        if (FAILED(Play()))
            goto done;
    } else {
        Assert(IsPaused());
    }
    
    if (!_Resume() ||
        !ProcessEvent(l, m_curTick, MM_RESUME_EVENT) ||
        !ProcessCBList(l))
        goto done;
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

bool
CMMPlayer::_Start(double lTime)
{
    bool ok = false;
    
    CRLockGrabber __gclg;
    
    if (!UpdateBvr())
    {
        goto done;
    }

    CRBvrPtr bvr;

    bvr = m_dabasebvr;
    
    if ((m_dabvr = CRSubstituteTime(bvr, m_timeSub)) == NULL)
    {
        goto done;
    }
    
    if (!CRSwitchTo(m_modbvr, m_dabvr, true, CRSwitchCurrentTick, 0))
    {
        goto done;
    }
    
    if (!SetTimeSub(lTime, false))
    {
        goto done;
    }

    m_state = MM_PLAYING_STATE;
    m_curTick = lTime;
    m_firstTick = true;
    m_playerhook->SetPlayer(this);
    
    ok = true;
  done:
    if (!ok)
    {
        _Stop(lTime);
    }

    return ok;
}


bool
CMMPlayer::UpdateBvr()
{
    bool ok = false;
    
#if _DEBUG
    TraceTag((tagError,
              "Player(%#x)",
              this));
    m_mmbvr->Print(2);
#endif

    if (m_bNeedsUpdate)
    {
        CRBvrPtr baseBvr;

        if ((baseBvr = CRHook((CRBvrPtr) CRLocalTime(), m_playerhook)) == NULL)
        {
            TraceTag((tagPlayer,
                      "CMMPlayer(%lx)::UpdateBvr() - Error creating bvr hook",
                      this));

            goto done;
        }
        
        CRBooleanPtr cond;
        CRNumberPtr zeroTime;
        CRNumberPtr timeSub;
        
        if ((zeroTime = CRCreateNumber(0)) == NULL)
        {
            goto done;
        }

        if ((cond = CRLTE(CRLocalTime(), zeroTime)) == NULL)
        {
            goto done;
        }
        
        if ((timeSub = (CRNumberPtr) CRCond(cond,
                                            (CRBvrPtr) zeroTime,
                                            (CRBvrPtr) CRLocalTime())) == NULL)
        {
            goto done;
        }
        
        if (m_mmbvr->GetTotalDuration() != HUGE_VAL)
        {
            CRNumberPtr maxTime;
            
            if ((maxTime = CRCreateNumber(m_mmbvr->GetTotalDuration())) == NULL)
            {
                goto done;
            }

            if ((cond = CRGTE(timeSub, maxTime)) == NULL)
            {
                goto done;
            }
            
            if ((timeSub = (CRNumberPtr) CRCond(cond,
                                                (CRBvrPtr) maxTime,
                                                (CRBvrPtr) timeSub)) == NULL)
            {
                goto done;
            }
        }

        if ((baseBvr = CRSubstituteTime(baseBvr, timeSub)) == NULL)
        {
            goto done;
        }

        if (!m_mmbvr->ConstructBvr((CRNumberPtr) baseBvr))
        {
            TraceTag((tagPlayer,
                      "CMMPlayer(%lx)::UpdateBvr() - Error constructing behaviors",
                      this));

            goto done;
        }
        
        m_dabasebvr = baseBvr;
        m_bNeedsUpdate = false;
    }

    ok = true;

  done:
    if (!ok)
    {
        m_mmbvr->DestroyBvr();
    }
    
    return ok;
}

bool
CMMPlayer::_Stop(double lTime)
{
    bool ok = true;
    
    m_state = MM_STOPPED_STATE;
    m_playerhook->SetPlayer(NULL);
    
    if (!SetTimeSub(lTime, true))
    {
        ok = false;
    }

  done:
    return ok;
}

bool
CMMPlayer::_Pause()
{
    bool ok = false;
    
    if (!SetTimeSub(m_curTick, true))
    {
        goto done;
    }
    
    m_state = MM_PAUSED_STATE;
    
    ok = true;
  done:
    return ok;
}

bool
CMMPlayer::_Resume()
{
    bool ok = false;
    
    if (!SetTimeSub(m_curTick, false))
    {
        goto done;
    }
    
    m_state = MM_PLAYING_STATE;
    
    ok = true;
  done:
    return ok;
}

bool
CMMPlayer::_Seek(double lTime)
{
    TraceTag((tagPlayer,
              "CMMPlayer(%lx)::_Seek(%g)",
              this,
              lTime));

    bool ok = false;

    if (!SetTimeSub(lTime,
                    (m_state != MM_PLAYING_STATE)))
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok;
}

bool
CMMPlayer::SetTimeSub(double lTime, bool bPause)
{
    bool ok = false;
    
    CRLockGrabber __gclg;

    CRNumberPtr tc;
    
    if ((tc = CRCreateNumber(lTime)) == NULL)
        goto done;

    if (!bPause) {
        if (m_bForward) {
            if ((tc = CRAdd(tc, CRLocalTime())) == NULL)
                goto done;
        } else {
            if ((tc = CRSub(tc, CRLocalTime())) == NULL)
                goto done;
        }
    }
    
    if (!CRSwitchTo((CRBvrPtr) m_timeSub.p,
                    (CRBvrPtr) tc,
                    true,
                    CRSwitchCurrentTick,
                    0))
        goto done;

    ok = true;
  done:
    return ok;
}

long
CMMPlayer::AddRunningBehavior(CRBvrPtr bvr)
{
    long ret = 0;

    Assert(m_view);
    Assert(bvr);

    HRESULT hr;

    DAComPtr<IDABehavior> dabvr;
    
    if (!CRBvrToCOM(bvr,
                    IID_IDABehavior,
                    (void **) &dabvr))
    {
        goto done;
    }
    

    // TODO: Need to have flags for AddBvrsToRun so we can tell it to
    // continue the timeline

    long cookie;
    hr = THR(m_view->AddBvrToRun(dabvr, &cookie));

    if (FAILED(hr))
    {
        goto done;
    }
    
    ret = cookie;

  done:
    return ret;
}

bool
CMMPlayer::RemoveRunningBehavior(long cookie)
{
    bool ok = false;

    Assert(m_view);

    HRESULT hr;
    
    // Once the view stops then all of these are removed
    if (IsStarted())
    {
        hr = THR(m_view->RemoveRunningBvr(cookie));
        
        if (FAILED(hr))
        {
            goto done;
        }
    }

    ok = true;
  done:
    return ok;
}

HRESULT
CMMPlayer::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    if (str)
        return CComCoClass<CMMPlayer, &__uuidof(CMMPlayer)>::Error(str, IID_IMMPlayer, hr);
    else
        return hr;
}

bool
CMMPlayer::ProcessCB(CallBackList & l,
                     double lTime)
{
    TraceTag((tagPlayer,
              "CMMPlayer(%lx)::ProcessCB(%lx, %g)",
              this,
              &l,
              lTime));

    TraceTag((tagDetailNotify,
              "ProcessCB(%lx): lTime - %g, m_curTick - %g, firsttick - %d",
              this,
              lTime,
              m_curTick,
              m_firstTick));
    
    if (lTime != m_curTick || m_firstTick)
    {
        // See if we are at the end
        bool bIsDone = ((m_bForward && lTime >= GetTotalDuration()) ||
                        (!m_bForward && lTime <= 0));

        double sTime = m_mmbvr->GetAbsStartTime();

        m_mmbvr->ProcessCB(l,
                           m_curTick - sTime,
                           lTime - sTime,
                           m_bForward,
                           m_firstTick,
                           false);

        m_firstTick = false;
        m_curTick = lTime;

        if (bIsDone)
        {
            _Stop(m_curTick);
        }
    }
    
    // run though and tick the views that we have in our list.
    std::vector<ViewListSt*>::iterator it;
    VARIANT_BOOL needToRender;
    for (it = m_viewVec.begin(); it < m_viewVec.end(); it++) {
        (*it)->view->Tick(lTime,&needToRender);
        if (needToRender)
        {
            (*it)->SiteRender->Invalidate(NULL);
        }
    }
    
    return true;
}

bool
CMMPlayer::ProcessEvent(CallBackList &l,
                        double lTime,
                        MM_EVENT_TYPE event)
{
    return m_mmbvr->ProcessEvent(l, lTime, m_firstTick, event);
}

void
CMMPlayer::HookCallback(double lTime)
{
    TraceTag((tagDetailNotify,
              "HookCallback(%lx): lTime - %, m_curTick - %g, firsttick - %d\n",
              this,
              lTime,
              m_curTick,
              m_firstTick));
    
    if (IsPlaying() && !IsCBDisabled()) {
        CallBackList l;
            
        ProcessCB(l,
                  lTime);

        ProcessCBList(l);
    }
}

// While this object is alive we need to keep the DLL from getting
// unloaded

// Start off with a zero refcount
CMMPlayer::PlayerHook::PlayerHook()
: m_cRef(0),
  m_player(NULL)
{
}

CMMPlayer::PlayerHook::~PlayerHook()
{
}

CRSTDAPICB_(CRBvrPtr)
CMMPlayer::PlayerHook::Notify(long id,
                              bool startingPerformance,
                              double startTime,
                              double gTime,
                              double lTime,
                              CRBvrPtr sampleVal,
                              CRBvrPtr curRunningBvr)
{
    if (m_player && !startingPerformance)
    {
#if _DEBUG
        if (m_player->IsPlaying())
        {
            TraceTag((tagDetailNotify,
                      "Notify(%lx): id - %lx, lTime - %g, gTime - %g",
                      m_player,
                      id,
                      lTime,
                      gTime));
        }
#endif
        m_player->HookCallback(lTime);
    }
    
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\mmapi\src\mmplayer.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmplayer.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#ifndef _MMPLAYER_H
#define _MMPLAYER_H

#include "mmbasebvr.h"
#include <mshtml.h>
#include <vector>

interface IMMBehavior;

struct ViewListSt {
    IDAView  * view;
//    IDAImage * img;
//    IDASound * snd;
    IElementBehaviorSiteRender * SiteRender;
};

typedef std::list< DAComPtr<IDA3View> > ViewList;

class
__declspec(uuid("48ddc6be-5c06-11d2-b957-3078302c2030")) 
ATL_NO_VTABLE CMMPlayer
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CMMPlayer, &__uuidof(CMMPlayer)>,
      public IDispatchImpl<IMMPlayer, &IID_IMMPlayer, &LIBID_WindowsMultimediaRuntime>,
      public ISupportErrorInfoImpl<&IID_IMMPlayer>
{
  public:
    CMMPlayer();
    ~CMMPlayer();

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;
    
    HRESULT Init(LPOLESTR id, IMMBehavior * bvr, IDAView * v);
    HRESULT AddView(IDAView * view, IUnknown * pUnk, IDAImage * img, IDASound * snd);

#if _DEBUG
    const char * GetName() { return "CMMPlayer"; }
#endif

    BEGIN_COM_MAP(CMMPlayer)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IMMPlayer)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP();

    STDMETHOD(get_ID)(LPOLESTR * s);
    STDMETHOD(put_ID)(LPOLESTR s);
        
    STDMETHOD(Play)();
    STDMETHOD(Stop)();
    STDMETHOD(Pause)();
    STDMETHOD(Resume)();
        
    STDMETHOD(get_PlayerState)(MM_STATE *);
        
    STDMETHOD(get_CurrentTime)(double * d);

    STDMETHOD(SetPosition)(double lTime);
    STDMETHOD(SetDirection)(VARIANT_BOOL bForward);
        
    STDMETHOD(get_View)(IDAView **);

    STDMETHOD(get_Behavior)(IMMBehavior ** mmbvr);

    bool IsStopped() { return m_state == MM_STOPPED_STATE; }
    bool IsStarted() { return m_state != MM_STOPPED_STATE; }
    bool IsPlaying() { return m_state == MM_PLAYING_STATE; }
    bool IsPaused() { return m_state == MM_PAUSED_STATE; }

    void Invalidate() { m_bNeedsUpdate = true; }

    void HookCallback(double lTime);

    double GetTotalDuration() { return m_mmbvr->GetTotalDuration(); }

    double GetCurrentTime() { return m_curTick; }

    long AddRunningBehavior(CRBvrPtr bvr);
    bool RemoveRunningBehavior(long);
  protected:
    bool UpdateBvr();
    bool _Start(double lTime);
    bool _Stop(double lTime);
    bool _Pause();
    bool _Resume();
    bool _Seek(double lTime);
    
    bool ProcessEvent(CallBackList &l,
                      double lTime,
                      MM_EVENT_TYPE event);
    
    bool ProcessCB(CallBackList & l,
                   double lTime);
    
    bool SetTimeSub(double lTime, bool bPause);
    
    HRESULT Error();
    
  protected:
    LPWSTR m_id;
    DAComPtr<CMMBaseBvr> m_mmbvr;
    DAComPtr<IDA3View> m_view;
    MM_STATE m_state;
    double m_curTick;
    bool m_bForward;
    bool m_bNeedsUpdate;
    bool m_firstTick;
    long m_ignoreCB;
    
    CRPtr<CRNumber> m_timeSub;
    CRPtr<CRBvr> m_dabvr;
    CRPtr<CRBvr> m_dabasebvr;
    CRPtr<CRBvr> m_modbvr;
    std::vector<ViewListSt*> m_viewVec;

//    ViewList m_viewlist;

    class PlayerHook : public CRBvrHook
    {
      public:
        PlayerHook();
        ~PlayerHook();
        
        virtual CRSTDAPICB_(ULONG) AddRef() { m_cRef++; return m_cRef; }
        virtual CRSTDAPICB_(ULONG) Release() {
            long r = --m_cRef;

            if (r == 0)
                delete this;

            return r;
        }
        
        CRSTDAPICB_(CRBvrPtr) Notify(long id,
                                     bool startingPerformance,
                                     double startTime,
                                     double gTime,
                                     double lTime,
                                     CRBvrPtr sampleVal,
                                     CRBvrPtr curRunningBvr);

        void SetPlayer(CMMPlayer * t) { m_player = t; }

      protected:
        // We do not need a refcount since we are single threaded and
        // the player will NULL it out if it goes away

        CMMPlayer * m_player;
        long m_cRef;
    };

    DAComPtr<PlayerHook> m_playerhook;

    void DisableCB() { m_ignoreCB++; }
    void EnableCB() { m_ignoreCB--; Assert (m_ignoreCB >= 0); }

    bool IsCBDisabled() { return m_ignoreCB > 0; }
};

#endif /* _MMPLAYER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\mmapi\src\mmtimeline.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "mmbasebvr.h"
#include "mmtimeline.h"

DeclareTag(tagTimeline, "API", "CMMTimeline methods");

CMMTimeline::CMMTimeline()
: m_fEndSync(0)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::CMMTimeline()",
              this));
}

CMMTimeline::~CMMTimeline()
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::~CMMTimeline()",
              this));
}

HRESULT
CMMTimeline::Init(LPOLESTR id)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::Init(%ls)",
              this,
              id));
    
    HRESULT hr;

    hr = BaseInit(id, (CRBvrPtr) CRLocalTime());
    
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CMMTimeline::AddView(IDAView *view, IUnknown * pUnk, IDAImage *img, IDASound *snd)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::AddView()",
              this));

    HRESULT hr;

    hr = GetPlayer()->AddView(view,pUnk,img,snd);

  done:
    return hr;
}


STDMETHODIMP
CMMTimeline::AddBehavior(IMMBehavior *bvr,
                         MM_START_TYPE st,
                         IMMBehavior * basebvr)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::AddBehavior(%#lx, %d, %#lx)",
              this,
              bvr,
              st,
              basebvr));
    
    CHECK_RETURN_NULL(bvr);

    bool ok = false;
    
    CMMBaseBvr * mmbvr;
    CMMBaseBvr * mmbasebvr;

    mmbvr = GetBvr(bvr);

    if (mmbvr == NULL)
    {
        goto done;
    }
    
    if (mmbvr->GetParent() != NULL)
    {
        CRSetLastError(E_INVALIDARG, NULL);
        goto done;
    }

    if (basebvr)
    {
        mmbasebvr = GetBvr(basebvr);
        
        if (mmbasebvr == NULL)
        {
            goto done;
        }
    }
    else
    {
        mmbasebvr = NULL;
    }
    
    if (!AddBehavior(mmbvr, st, mmbasebvr))
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMTimeline::RemoveBehavior(IMMBehavior *bvr)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::RemoveBehavior(%#lx)",
              this,
              bvr));
    
    CHECK_RETURN_NULL(bvr);

    bool ok = false;
    
    CMMBaseBvr * mmbvr;

    mmbvr = GetBvr(bvr);

    if (mmbvr == NULL)
    {
        goto done;
    }
    
    if (mmbvr->GetParent() != this)
    {
        CRSetLastError(E_INVALIDARG, NULL);
        goto done;
    }

    if (!RemoveBehavior(mmbvr))
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

bool
CMMTimeline::AddBehavior(CMMBaseBvr *bvr,
                         MM_START_TYPE st,
                         CMMBaseBvr * basebvr)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::AddBehavior(%#lx, %d, %#lx)",
              this,
              bvr,
              st,
              basebvr));
    
    Assert(bvr);
    Assert(bvr->GetParent() == NULL);
    
    bool ok = false;
    
    if (!bvr->SetParent(this, st, basebvr))
    {
        goto done;
    }

    Assert(bvr->GetPlayer() == NULL);
    
    if (GetPlayer() != NULL)
    {
        bvr->SetPlayer(GetPlayer());
    }
    
    // Figure out if our sibling dependent if valid or not
    if (basebvr && !IsChild(basebvr))
    {
        if (basebvr->GetParent() != this &&
            basebvr->GetParent() != NULL)
        {
            CRSetLastError(E_INVALIDARG, NULL);
            goto done;
        }

        // It has not been added to us yet so add this bvr to the
        // pending list
        if (!AddToPending(bvr))
        {
            goto done;
        }
    }
    else
    {
        if (!AddToChildren(bvr))
        {
            goto done;
        }

        if (!UpdatePending(bvr))
        {
            goto done;
        }
    }
    
    ok = true;
  done:

    if (!ok)
    {
        RemoveBehavior(bvr);
    }
    
    return ok;
}

bool
CMMTimeline::RemoveBehavior(CMMBaseBvr *bvr)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::RemoveBehavior(%#lx)",
              this,
              bvr));
    
    Assert(bvr);
    
    // This needs to be callable even from a partially added behavior
    
    bool ok = false;
    
    bvr->ClearParent();
    bvr->ClearPlayer();
    
    RemoveFromChildren(bvr);
    RemoveFromPending(bvr);
    
    ok = true;
  done:
    return ok;
}

bool
CMMTimeline::AddToChildren(CMMBaseBvr * bvr)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::AddToChildren(%#lx)",
              this,
              bvr));

    bool ok = false;
    
    if (!bvr->AttachToSibling())
    {
        goto done;
    }
    
    m_children.push_back(bvr);
    
    if (m_resultantbvr)
    {
        if (!bvr->ConstructBvr((CRNumberPtr) m_resultantbvr.p))
        {
            goto done;
        }
    }

    ok = true;
  done:
    return ok;
}

void
CMMTimeline::RemoveFromChildren(CMMBaseBvr * bvr)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::RemoveFromChildren(%#lx)",
              this,
              bvr));

    // TODO: Need to cycle through the children and remove all
    // dependents
    
    m_children.remove(bvr);
}

bool
CMMTimeline::AddToPending(CMMBaseBvr * bvr)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::AddToPending(%#lx)",
              this,
              bvr));

    bool ok = false;
    
    m_pending.push_back(bvr);

    ok = true;
  done:
    return ok;
}

bool
CMMTimeline::UpdatePending(CMMBaseBvr * bvr)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::UpdatePending(%#lx)",
              this,
              bvr));

    bool ok = false;
    
    MMBaseBvrList newlist;
    
    MMBaseBvrList::iterator i = m_pending.begin();

    while (i != m_pending.end())
    {
        // Need to do this so we can erase j if we need to
        MMBaseBvrList::iterator j = i;
        i++;
        
        if((*j)->GetStartSibling() == bvr)
        {
            newlist.push_back(*j);
            m_pending.erase(j);
        }
    }
    
    for (i = newlist.begin();
         i != newlist.end();
         i++)
    {
        if (!AddToChildren(*i))
        {
            goto done;
        }

        if (!UpdatePending(*i))
        {
            goto done;
        }
    }

    ok = true;
  done:
    return ok;
}

void
CMMTimeline::RemoveFromPending(CMMBaseBvr * bvr)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::RemoveFromPending(%#lx)",
              this,
              bvr));

    m_pending.remove(bvr);
}

bool 
CMMTimeline::IsChild(CMMBaseBvr * bvr)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::IsChild(%#lx)",
              this,
              bvr));

    for (MMBaseBvrList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        if((*i) == bvr)
        {
            return true;
        }
    }
    
    return false;
}

bool 
CMMTimeline::IsPending(CMMBaseBvr * bvr)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::IsPending(%#lx)",
              this,
              bvr));

    for (MMBaseBvrList::iterator i = m_pending.begin(); 
         i != m_pending.end(); 
         i++)
    {
        if((*i) == bvr)
        {
            return true;
        }
    }
    
    return false;
}

void
CMMTimeline::SetPlayer(CMMPlayer * player)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::SetPlayer(%#lx)",
              this,
              player));

    CMMBaseBvr::SetPlayer(player);

    for (MMBaseBvrList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        (*i)->SetPlayer(player);
    }
}

void
CMMTimeline::ClearPlayer()
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::ClearPlayer()",
              this));

    CMMBaseBvr::ClearPlayer();
    
    for (MMBaseBvrList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        (*i)->ClearPlayer();
    }
}

bool
CMMTimeline::ConstructBvr(CRNumberPtr timeline)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::ConstructBvr()",
              this));

    bool ok = false;
    
    Assert(!m_resultantbvr);
    
    if (!CMMBaseBvr::ConstructBvr(timeline))
    {
        goto done;
    }
    
    Assert(m_resultantbvr);
    
    {
        for (MMBaseBvrList::iterator i = m_children.begin(); 
             i != m_children.end(); 
             i++)
        {
            if (!(*i)->ConstructBvr((CRNumberPtr) m_resultantbvr.p))
            {
                goto done;
            }
        }
    }

    ok = true;
  done:
    return ok;
}

void
CMMTimeline::DestroyBvr()
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::DestroyBvr()",
              this));

    CMMBaseBvr::DestroyBvr();
    
    for (MMBaseBvrList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        (*i)->DestroyBvr();
    }
}

bool
CMMTimeline::ResetBvr()
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::ResetBvr()",
              this));

    bool ok = false;

    // Call the base class first
    
    if (!CMMBaseBvr::ResetBvr())
    {
        goto done;
    }
    
    // Now go through our children

    if (!ResetChildren())
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok;
}
    
bool
CMMTimeline::_ProcessCB(CallBackList & l,
                        double lastTick,
                        double curTime,
                        bool bForward,
                        bool bFirstTick,
                        bool bNeedPlay,
                        bool bNeedsReverse)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::_ProcessCB(%g, %g, %d, %d, %d, %d)",
              this,
              lastTick,
              curTime,
              bForward,
              bFirstTick,
              bNeedPlay,
              bNeedsReverse));
    
    // If we need to reverse then invert which direct to process our
    // children and invert times for the current frame not our total
    // duration
    
    if (bNeedsReverse)
    {
        // Our caller should ensure that they do not call me to
        // reverse myself if I am infinite
        Assert(m_segDuration != MM_INFINITE);
        
        lastTick = m_segDuration - lastTick;
        curTime = m_segDuration - curTime;
        
        bForward = !bForward;
    }
    
    for (MMBaseBvrList::iterator i = m_children.begin();
         i != m_children.end();
         i++)
    {
        double sTime = (*i)->GetAbsStartTime();

        if (sTime != MM_INFINITE)
        {
            (*i)->ProcessCB(l,
                            EaseTime(lastTick - sTime),
                            EaseTime(curTime - sTime),
                            bForward,
                            bFirstTick,
                            bNeedPlay);
        }

    }
    
    return true;
}

bool
CMMTimeline::_ProcessEvent(CallBackList & l,
                           double time,
                           bool bFirstTick,
                           MM_EVENT_TYPE et,
                           bool bNeedsReverse)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::_ProcessEvent(%g, %d, %s, %d)",
              this,
              time,
              bFirstTick,
              EventString(et),
              bNeedsReverse));
    
    // If we need to reverse then for the current frame not our total
    // duration
    
    if (bNeedsReverse)
    {
        // Our caller should ensure that they do not call me to
        // reverse myself if I am infinite
        Assert(m_segDuration != MM_INFINITE);
        
        time = m_segDuration - time;
    }
    
    for (MMBaseBvrList::iterator i = m_children.begin();
         i != m_children.end();
         i++)
    {
        double sTime = (*i)->GetAbsStartTime();

        if (sTime != MM_INFINITE)
        {
            (*i)->ProcessEvent(l,
                               EaseTime(time - sTime),
                               bFirstTick,
                               et);
        }
    }
        
    return true;
}

bool
CMMTimeline::ResetChildren()
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::ResetChildren()",
              this));

    bool ok = true;

    // Need to reset all children
    // Even if we detect a failure process all children and then just
    // return false

    // TODO: Should only really reset non-dependent children since the
    // dependents need to be updated by their sibling
    
    for (MMBaseBvrList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        if (!(*i)->ResetBvr())
        {
            ok = false;
        }
    }

  done:
    return ok;
}

bool
CMMTimeline::ParentEventNotify(CMMBaseBvr * bvr,
                               double lTime,
                               MM_EVENT_TYPE et)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::ParentEventNotify(%#lx, %g, %s)",
              this,
              bvr,
              lTime,
              EventString(et)));

    bool ok = true;

    Assert(IsChild(bvr));

    // TODO: Need to handle this.
    
    ok = true;
  done:
    return ok;
}
    
HRESULT
CMMTimeline::get_EndSync(DWORD * f)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::get_EndSync()",
              this));

    CHECK_RETURN_NULL(f);

    *f = m_fEndSync;
    return S_OK;
}

HRESULT
CMMTimeline::put_EndSync(DWORD f)
{
    TraceTag((tagTimeline,
              "CMMTimeline(%lx)::put_EndSync(%d)",
              this,
              f));

    m_fEndSync = f;

    return S_OK;
}
        
HRESULT
CMMTimeline::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    TraceTag((tagError,
              "CMMTimeline(%lx)::Error(%hr,%ls)",
              this,
              hr,
              str?str:L"NULL"));

    if (str)
        return CComCoClass<CMMTimeline, &__uuidof(CMMTimeline)>::Error(str, IID_IMMTimeline, hr);
    else
        return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\mmapi\src\mmprops.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmprops.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "mmbasebvr.h"

HRESULT
CMMBaseBvr::GetID(LPOLESTR * p)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetID()",
              this));

    HRESULT hr;
    
    CHECK_RETURN_SET_NULL(p);

    if (m_id)
    {
        *p = SysAllocString(m_id);

        if (*p == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    hr = S_OK;
  done:
    return hr;
}

HRESULT
CMMBaseBvr::SetID(LPOLESTR s)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::SetID(%ls)",
              this,
              s));

    HRESULT hr;

    delete m_id;
    m_id = NULL;

    if (s)
    {
        s = CopyString(s);

        if (s == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    hr = S_OK;
  done:
    return hr;
}
        
HRESULT
CMMBaseBvr::GetStartOffset(float * p)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetStartOffset()",
              this));

    CHECK_RETURN_NULL(p);

    *p = m_startOffset;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetStartOffset(float s)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::SetStartOffset(%g)",
              this,
              s));

    m_startOffset = s;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetDuration(float * pdur)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetDuration()",
              this));

    CHECK_RETURN_NULL(pdur);

    *pdur = m_duration;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetDuration(float dur)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::SetDuration(%g)",
              this,
              dur));

    m_duration = dur;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetRepeatDur(float * pr)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetRepeatDur()",
              this));

    CHECK_RETURN_NULL(pr);

    *pr = m_repeatDur;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetRepeatDur(float r)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::SetRepeatDur(%g)",
              this,
              r));

    m_repeatDur = r;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetRepeat(LONG * prepeat)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetRepeat()",
              this));

    CHECK_RETURN_NULL(prepeat);

    *prepeat = m_repeat;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetRepeat(LONG repeat)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::SetRepeat(%d)",
              this,
              repeat));

    m_repeat = repeat;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetAutoReverse(VARIANT_BOOL * pautoreverse)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetAutoReverse()",
              this));

    CHECK_RETURN_NULL(pautoreverse);

    *pautoreverse = m_bAutoReverse;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetAutoReverse(VARIANT_BOOL autoreverse)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::SetAutoReverse(%d)",
              this,
              autoreverse));

    m_bAutoReverse = autoreverse?true:false;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetEndOffset(float * p)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetEndOffset()",
              this));

    CHECK_RETURN_NULL(p);

    *p = m_endOffset;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetEndOffset(float s)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::SetEndOffset(%g)",
              this,
              s));

    m_endOffset = s;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetEventCB(IMMEventCB ** evcb)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetEventCB()",
              this));

    CHECK_RETURN_SET_NULL(evcb);

    *evcb = m_eventcb;
    if (m_eventcb) m_eventcb->AddRef();

    return S_OK;
}

HRESULT
CMMBaseBvr::SetEventCB(IMMEventCB * evcb)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::SetEventCB(%lx)",
              this,
              evcb));

    m_eventcb = evcb;
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetEaseIn(float * pd)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetEaseIn()",
              this));

    CHECK_RETURN_NULL(pd);

    *pd = m_easeIn;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetEaseIn(float d)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::SetEaseIn(%g)",
              this,
              d));

    if (d < 0.0 || d > 1.0) return E_INVALIDARG;
    
    m_easeIn = d;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetEaseInStart(float * pd)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetEaseInStart()",
              this));

    CHECK_RETURN_NULL(pd);

    *pd = m_easeInStart;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetEaseInStart(float d)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::SetEaseInStart(%g)",
              this,
              d));

    if (d < 0.0 || d > 1.0) return E_INVALIDARG;

    m_easeInStart = d;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetEaseOut(float * pd)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetEaseOut()",
              this));

    CHECK_RETURN_NULL(pd);

    *pd = m_easeOut;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetEaseOut(float d)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::SetEaseOut(%g)",
              this,
              d));

    if (d < 0.0 || d > 1.0) return E_INVALIDARG;

    m_easeOut = d;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetEaseOutEnd(float * pd)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetEaseOutEnd()",
              this));

    CHECK_RETURN_NULL(pd);

    *pd = m_easeOutEnd;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetEaseOutEnd(float d)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::SetEaseOutEnd(%g)",
              this,
              d));

    if (d < 0.0 || d > 1.0) return E_INVALIDARG;

    m_easeOutEnd = d;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetTotalTime(float * pr)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetTotalTime()",
              this));

    CHECK_RETURN_NULL(pr);

    *pr = m_totalDuration;
    return S_OK;
}


HRESULT
CMMBaseBvr::GetDABehavior(REFIID riid, void ** bvr)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetDABehavior()",
              this));

    CHECK_RETURN_SET_NULL(bvr);

    Assert(m_rawbvr);

    if (!CRBvrToCOM(m_rawbvr,
                    riid,
                    bvr))
        return Error();
    
    return S_OK;
}

HRESULT
CMMBaseBvr::GetLocalTime(double * d)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetLocalTime()",
              this));

    CHECK_RETURN_NULL(d);

    *d = GetCurrentLocalTime();
    
    return S_OK;
}

HRESULT
CMMBaseBvr::GetPlayState(MM_STATE * state)
{
    TraceTag((tagBaseBvr,
              "CMMBaseBvr(%lx)::GetPlayState()",
              this));

    CHECK_RETURN_NULL(state);

    double t = GetCurrentLocalTime();
    
    if (t == MM_INFINITE)
    {
        *state = MM_STOPPED_STATE;
    }
    else
    {
        // Now see if we are in the active period of our local time
        if (t < GetStartTime() ||
            t > GetEndTime())
        {
            *state = MM_STOPPED_STATE;
        }
        else
        {
            *state = MM_PLAYING_STATE;
        }
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\time.inc ===
# include common.inc in da
!include $(ROOT)\common.inc

# treat warnings as errors
USER_C_FLAGS=$(USER_C_FLAGS) /WX

# optimize for the ppro/pII
X86_CPU_OPTIMIZATION = /G6
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\mmapi\src\util.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include <mshtml.h>

#define DISPID_GETSAFEARRAY -2700

#define IS_VARTYPE(x,vt) ((V_VT(x) & VT_TYPEMASK) == (vt))
#define IS_VARIANT(x) IS_VARTYPE(x,VT_VARIANT)
#define GET_VT(x) (V_VT(x) & VT_TYPEMASK)

SafeArrayAccessor::SafeArrayAccessor(VARIANT & v,
                                     bool canBeNull)
: _inited(false),
  _isVar(false),
  _s(NULL),
  _failed(true),
  _allocArr(NULL)
{
    HRESULT hr;
    VARIANT *pVar;

    // Check if it is a reference to another variant
    
    if (V_ISBYREF(&v) && !V_ISARRAY(&v) && IS_VARIANT(&v))
        pVar = V_VARIANTREF(&v);
    else
        pVar = &v;

    // Check for an array
    if (!V_ISARRAY(pVar)) {
        // For JSCRIPT
        // See if it is a IDispatch and see if we can get a safearray from
        // it
        if (!IS_VARTYPE(pVar,VT_DISPATCH)) {
            if (canBeNull && (IS_VARTYPE(pVar, VT_EMPTY) ||
                              IS_VARTYPE(pVar, VT_NULL))) {

                
                // if we allow empty, then just set the safearray
                // to null.
                _s = NULL;
                _v = NULL;
                _ubound = _lbound = 0;
                _inited = true;
                _failed = false;
                return;
            } else {
                CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
                return;
            }
        }

        IDispatch * pdisp;
        
        if (V_ISBYREF(pVar))
            pdisp = *V_DISPATCHREF(pVar);
        else
            pdisp = V_DISPATCH(pVar);
    
        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
        
        // Need to pass in a VARIANT that we own and will free.  Use
        // the internal _retVar parameter
        
        hr = pdisp->Invoke(DISPID_GETSAFEARRAY,
                           IID_NULL,
                           LOCALE_USER_DEFAULT,
                           DISPATCH_METHOD|DISPATCH_PROPERTYGET,
                           &dispparamsNoArgs,
                           &_retVar, NULL, NULL);
        
        if (FAILED(hr)) {
            CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
            return;
        }
        
        // No need to check for a reference since you cannot return
        // VARIANT references
        pVar = &_retVar;
        
        // Check for an array
        if (!V_ISARRAY(pVar)) {
            CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
            return;
        }
    }
    
    // See if it is a variant
    
    if (IS_VARIANT(pVar))
        _isVar = true;
    else if (!IS_VARTYPE(pVar,VT_UNKNOWN) &&
             !IS_VARTYPE(pVar,VT_DISPATCH)) {
        CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
        return;
    }

    if (V_ISBYREF(pVar))
        _s = *V_ARRAYREF(pVar);
    else
        _s = V_ARRAY(pVar);
    
    if (_s == NULL) {
        if (canBeNull) {
            _v = NULL;
            _ubound = _lbound = 0;
            _inited = true;
            _failed = false;
            return;
        } else {
            CRSetLastError (E_INVALIDARG,NULL);
            return;
        }
    }

    if (SafeArrayGetDim(_s) != 1) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }

    hr = SafeArrayGetLBound(_s,1,&_lbound);
        
    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    hr = SafeArrayGetUBound(_s,1,&_ubound);
        
    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    hr = SafeArrayAccessData(_s,(void **)&_v);

    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    _inited = true;

    // If it is a variant see if they are objects or not

    if (_isVar) {
        int size = GetArraySize();
        
        if (size > 0) {
            // Check the first argument to see its type

            VARIANT * pVar = &_pVar[0];

            // Check if it is a reference to another variant
            
            if (V_ISBYREF(pVar) && !V_ISARRAY(pVar) && IS_VARIANT(pVar))
                pVar = V_VARIANTREF(pVar);

            // Check if it is an object
            if (!IS_VARTYPE(pVar,VT_UNKNOWN) &&
                !IS_VARTYPE(pVar,VT_DISPATCH)) {
                CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
                return;
            }

            _allocArr = (IUnknown **) malloc(size * sizeof (IUnknown *));

            if (_allocArr == NULL) {
                CRSetLastError(E_OUTOFMEMORY, NULL);
                return;
            }

            for (int i = 0; i < size; i++) {
                CComVariant var;
                HRESULT hr = var.ChangeType(VT_UNKNOWN, &_pVar[i]);
                
                if (FAILED(hr)) {
                    CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                    return;
                }
                
                _allocArr[i] = var.punkVal;
            }
        }
    }

    _failed = false;
}

SafeArrayAccessor::~SafeArrayAccessor()
{
    if (_inited && _s)
        SafeArrayUnaccessData(_s);
}

#if 0
HRESULT
CallScript(IOleClientSite * pClient,
           LPWSTR fun,
           IDispatch * disp,
           DWORD dwData)
{
    DISPID dispid;
    DAComPtr<IOleContainer> pRoot;
    DAComPtr<IHTMLDocument> pHTMLDoc;
    DAComPtr<IDispatch> pDispatch;
    CRBvrPtr bvr = NULL;
    DAComPtr<IDABehavior> event;
    DAComPtr<IDABehavior> curBvr;
    CComVariant retVal;
    HRESULT hr = E_INVALIDARG;
        
    if (!pClient) goto done;
    
    {
        CComBSTR bstrfun(fun);
        
        if (FAILED(hr = pClient->GetContainer(&pRoot)) ||
            FAILED(hr = pRoot->QueryInterface(IID_IHTMLDocument, (void **)&pHTMLDoc)) ||
            FAILED(hr = pHTMLDoc->get_Script(&pDispatch)) ||
            FAILED(hr = pDispatch->GetIDsOfNames(IID_NULL, &bstrfun, 1,
                                                 LOCALE_USER_DEFAULT,
                                                 &dispid))) {
            goto done;
        }
    }

        
    // paramters needed to be pushed in reverse order
    VARIANT rgvarg[2];
    rgvarg[1].vt = VT_DISPATCH;
    rgvarg[1].pdispVal = disp;
    rgvarg[0].vt = VT_I4;
    rgvarg[0].lVal = dwData;
    
    DISPPARAMS dp;
    dp.cNamedArgs = 0;
    dp.rgdispidNamedArgs = 0;
    dp.cArgs = 2;
    dp.rgvarg = rgvarg;
    
    hr = pDispatch->Invoke(dispid, IID_NULL,
                           LOCALE_USER_DEFAULT, DISPATCH_METHOD,
                           &dp, &retVal, NULL, NULL);

    if (FAILED(hr)) {
        goto done;
    }

  done:
    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\dll\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"
#include "datime.h"
#include "comutil.h"

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\dll\stdafx.cpp ===
/*++

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    Ole Object initialization

Revision:

--*/

#include "headers.h"

#undef map
#undef SubclassWindow

// Put this here to initialize all the ATL stuff

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\include\comutil.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _COMUTIL_H
#define _COMUTIL_H

#define SET_NULL(x) {if (x) *(x) = NULL;}

#define CHECK_RETURN_NULL(x) {if (!(x)) return E_POINTER;}
#define CHECK_RETURN_SET_NULL(x) {if (!(x)) { return E_POINTER ;} else {*(x) = NULL;}}

template <class T>
class DAComPtr
{
  public:
    typedef T _PtrClass;
    DAComPtr() { p = NULL; }
    DAComPtr(T* lp, bool baddref = true)
    {
        p = lp;
        if (p != NULL && baddref)
            p->AddRef();
    }
    DAComPtr(const DAComPtr<T>& lp, bool baddref = true)
    {
        p = lp.p;

        if (p != NULL && baddref)
            p->AddRef();
    }
    ~DAComPtr() {
        if (p) p->Release();
    }
    void Release() {
        if (p) p->Release();
        p = NULL;
    }
    operator T*() { return (T*)p; }
    T& operator*() { Assert(p != NULL); return *p; }
    //The assert on operator& usually indicates a bug.  If this is really
    //what is needed, however, take the address of the p member explicitly.
    T** operator&() { Assert(p == NULL); return &p; }
    T* operator->() { Assert(p != NULL); return p; }
    T* operator=(T* lp)
    {
        return Assign(lp);
    }
    T* operator=(const DAComPtr<T>& lp)
    {
        return Assign(lp.p);
    }

    bool operator!() const { return (p == NULL); }
    operator bool() const { return (p != NULL); }

    T* p;
  protected:
    T* Assign(T* lp) {
        if (lp != NULL)
            lp->AddRef();

        if (p)
            p->Release();

        p = lp;

        return lp;
    }
};

#endif /* _COMUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\include\atlutil.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _LMATL_H
#define _LMATL_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define _ATL_NO_DEBUG_CRT 1

#ifdef _DEBUG
#undef _ASSERTE
#endif

#define _ASSERTE(expr) ((void)0)

#define _ATL_STATIC_REGISTRY 1

#ifdef _DEBUG
inline void _cdecl AtlTrace2(LPCTSTR , ...){}
#define ATLTRACE            1 ? (void)0 : AtlTrace2
#endif

#include <atlbase.h>

// We are overriding these methods so we can hook them and do some
// stuff ourselves.
class DAComModule : public CComModule
{
  public:
    LONG Lock();
    LONG Unlock();

#if DEVELOPER_DEBUG
    void AddComPtr(void *ptr, const char * name);
    void RemoveComPtr(void *ptr);

    void DumpObjectList();
#endif
};

//#define _ATL_APARTMENT_THREADED
// THIS MUST BE CALLED _Module - all the ATL header files depend on it
extern DAComModule _Module;

#include <atlcom.h>
#include <atlctl.h>

#if _DEBUG
#include <typeinfo.h>
#endif

// COPIED FROM ATLCOM.H

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
class ModuleReleaser
{
  public:
    ModuleReleaser() {
        _Module.Lock();
    }

    ~ModuleReleaser() {
        _Module.Unlock();
    }
};

template <class Base>
class DAComObject 
    : public ModuleReleaser,
      public Base
{
  public:
    typedef Base _BaseClass;
    DAComObject(void* = NULL)
    {
#if DEVELOPER_DEBUG
#if _DEBUG
        _Module.AddComPtr(this, GetName());
#else
        _Module.AddComPtr(this, NULL);
#endif
#endif
    }
    // Set refcount to 1 to protect destruction
    ~DAComObject()
    {
#if DEVELOPER_DEBUG
        _Module.RemoveComPtr(this);
#endif
        m_dwRef = 1L;
        FinalRelease();
    }
    //If InternalAddRef or InteralRelease is undefined then your class
    //doesn't derive from CComObjectRoot
    STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
    STDMETHOD_(ULONG, Release)()
    {
        ULONG l = InternalRelease();
        if (l == 0)
            delete this;
        return l;
    }
    //if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
    {return _InternalQueryInterface(iid, ppvObject);}
    static HRESULT WINAPI CreateInstance(DAComObject<Base>** pp);
};

template <class Base>
HRESULT WINAPI DAComObject<Base>::CreateInstance(DAComObject<Base>** pp)
{
    _ASSERTE(pp != NULL);
    HRESULT hRes = E_OUTOFMEMORY;
    DAComObject<Base>* p = NULL;
    ATLTRY((p = new DAComObject<Base>()));
    if (p != NULL) {
        p->SetVoid(NULL);
        p->InternalFinalConstructAddRef();
        hRes = p->FinalConstruct();
        p->InternalFinalConstructRelease();
        if (hRes != S_OK) {
            delete p;
            p = NULL;
        }
    }
    *pp = p;
    return hRes;
}

#define DA_DECLARE_NOT_AGGREGATABLE(x) public:\
        typedef CComCreator2< CComCreator< DAComObject< x > >, CComFailCreator<CLASS_E_NOAGGREGATION> > _CreatorClass;
#define DA_DECLARE_AGGREGATABLE(x) public:\
        typedef CComCreator2< CComCreator< DAComObject< x > >, CComCreator< CComAggObject< x > > > _CreatorClass;

// END OF COPIED CODE
// Just to make things more uniform
#define RELEASE(x) if (x) { (x)->Release(); (x) = NULL; }

extern bool bFailedLoad;

#endif /* _LMATL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\mmapi\src\mmtimeline.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _MMTIMELINE_H
#define _MMTIMELINE_H

#include "mmplayer.h"

class
__declspec(uuid("0dfe0bae-537c-11d2-b955-3078302c2030")) 
ATL_NO_VTABLE
CMMTimeline
    : public CComCoClass<CMMTimeline, &__uuidof(CMMTimeline)>,
      public IDispatchImpl<IMMTimeline, &IID_IMMTimeline, &LIBID_WindowsMultimediaRuntime>,
      public ISupportErrorInfoImpl<&IID_IMMTimeline>,
      public CMMBaseBvr
{
  public:
    CMMTimeline();
    ~CMMTimeline();

    HRESULT Init(LPOLESTR id);

#if _DEBUG
    const char * GetName() { return "CMMTimeline"; }
#endif

    BEGIN_COM_MAP(CMMTimeline)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IMMBehavior)
        COM_INTERFACE_ENTRY(IMMTimeline)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP();

    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    static inline HRESULT WINAPI
        InternalQueryInterface(CMMTimeline* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject)
    { return BaseInternalQueryInterface(pThis,
                                        (void *) pThis,
                                        pEntries,
                                        iid,
                                        ppvObject); }

    

    //
    // IMMTimeline
    //
    
    STDMETHOD(AddView)(IDAView * view, IUnknown * pUnk, IDAImage * img, IDASound * snd);

    STDMETHOD(AddBehavior)(IMMBehavior *bvr,
                           MM_START_TYPE st,
                           IMMBehavior * basebvr);
    STDMETHOD(RemoveBehavior)(IMMBehavior *bvr);

    STDMETHOD(get_EndSync)(DWORD * flags);
    STDMETHOD(put_EndSync)(DWORD flags);

    //
    // IMMBehavior
    //
    
    STDMETHOD(get_ID)(LPOLESTR * s)
        { return GetID(s); }
    
    STDMETHOD(put_ID)(LPOLESTR s)
        { return SetID(s); }
        
    STDMETHOD(get_StartOffset)(float * f)
        { return GetStartOffset(f); }
    
    STDMETHOD(put_StartOffset)(float f)
        { return SetStartOffset(f); }
        
    STDMETHOD(get_Duration)(float * pd)
        { return GetDuration(pd); }
    STDMETHOD(put_Duration)(float d)
        { return SetDuration(d); }
        
    STDMETHOD(get_Repeat)(LONG * pr)
        { return GetRepeat(pr); }
    STDMETHOD(put_Repeat)(LONG r)
        { return SetRepeat(r); }
       
    STDMETHOD(get_AutoReverse)(VARIANT_BOOL * pr)
        { return GetAutoReverse(pr); }
    STDMETHOD(put_AutoReverse)(VARIANT_BOOL r)
        { return SetAutoReverse(r); }
        
    STDMETHOD(get_RepeatDur)(float * f)
        { return GetRepeatDur(f); }
    STDMETHOD(put_RepeatDur)(float f)
        { return SetRepeatDur(f); }
        
    STDMETHOD(get_EndOffset)(float * f)
        { return GetEndOffset(f); }
    STDMETHOD(put_EndOffset)(float f)
        { return SetEndOffset(f); }
        
    STDMETHOD(get_EaseIn)(float * pd)
        { return GetEaseIn(pd); }
    STDMETHOD(put_EaseIn)(float d)
        { return SetEaseIn(d); }

    STDMETHOD(get_EaseInStart)(float * pd)
        { return GetEaseInStart(pd); }
    STDMETHOD(put_EaseInStart)(float d)
        { return SetEaseInStart(d); }

    STDMETHOD(get_EaseOut)(float * pd)
        { return GetEaseOut(pd); }
    STDMETHOD(put_EaseOut)(float d)
        { return SetEaseOut(d); }

    STDMETHOD(get_EaseOutEnd)(float * pd)
        { return GetEaseOutEnd(pd); }
    STDMETHOD(put_EaseOutEnd)(float d)
        { return SetEaseOutEnd(d); }

    STDMETHOD(get_EventCB)(IMMEventCB ** ev)
        { return GetEventCB(ev); }
    STDMETHOD(put_EventCB)(IMMEventCB * ev)
        { return SetEventCB(ev); }
        
    STDMETHOD(get_TotalTime)(float * pd)
        { return GetTotalTime(pd); }
        
    STDMETHOD(get_DABehavior)(IDABehavior ** bvr)
        { return CMMBaseBvr::GetDABehavior(IID_IDABehavior, (void **)bvr); }

    STDMETHOD(GetDABehavior)(REFIID riid, void ** bvr)
        { return CMMBaseBvr::GetDABehavior(riid, bvr); }

    STDMETHOD(Begin)(VARIANT_BOOL bAfterOffset)
        { return CMMBaseBvr::Begin(bAfterOffset?true:false); }
    
    STDMETHOD(End)()
        { return CMMBaseBvr::End(); }
    
    STDMETHOD(Pause)()
        { return CMMBaseBvr::Pause(); }
    
    STDMETHOD(Resume)()
        { return CMMBaseBvr::Resume(); }
    
    STDMETHOD(Seek)(double lTime)
        { return CMMBaseBvr::Seek(lTime); }

    STDMETHOD(get_CurrentTime)(double * d)
        { return GetLocalTime(d); }

    STDMETHOD(get_PlayState)(MM_STATE * state)
        { return GetPlayState(state); }

    virtual bool ConstructBvr(CRNumberPtr timeline);
    virtual void DestroyBvr();

    DWORD GetEndSync() { return m_fEndSync; }
    bool IsLastSync() { return (m_fEndSync & MM_ENDSYNC_LAST) != 0; }
    bool IsFirstSync() { return (m_fEndSync & MM_ENDSYNC_FIRST) != 0; }
  protected:
    HRESULT Error();

    virtual void SetPlayer(CMMPlayer * player);
    virtual void ClearPlayer();

    bool AddBehavior(CMMBaseBvr *bvr,
                     MM_START_TYPE st,
                     CMMBaseBvr * basebvr);
    bool RemoveBehavior(CMMBaseBvr *bvr);
    virtual bool ResetBvr();
    
    bool IsChild(CMMBaseBvr *bvr);
    bool IsPending(CMMBaseBvr *bvr);
    
    bool AddToChildren(CMMBaseBvr * bvr);
    void RemoveFromChildren(CMMBaseBvr * bvr);
    
    bool AddToPending(CMMBaseBvr * bvr);
    bool UpdatePending(CMMBaseBvr * bvr);
    void RemoveFromPending(CMMBaseBvr * bvr);
    
    bool _ProcessCB(CallBackList & l,
                    double lastTick,
                    double curTime,
                    bool bForward,
                    bool bFirstTick,
                    bool bNeedPlay,
                    bool bNeedsReverse);
    
    bool _ProcessEvent(CallBackList & l,
                       double time,
                       bool bFirstTick,
                       MM_EVENT_TYPE et,
                       bool bNeedsReverse);
    
    virtual bool EventNotify(CallBackList &l,
                             double lTime,
                             MM_EVENT_TYPE et);

    virtual bool ParentEventNotify(CMMBaseBvr * bvr,
                                   double lTime,
                                   MM_EVENT_TYPE et);
    
    bool ResetChildren();
  protected:
    MMBaseBvrList m_children;
    MMBaseBvrList m_pending;
    DWORD         m_fEndSync;
};

#endif /* _MMTIMELINE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\include\resource.h ===
/*******************************************************************************

Copyright (c) 1998_98 Microsoft Corporation

Abstract:

    DALite Resources

*******************************************************************************/


#ifndef _RESOURCE_H
#define _RESOURCE_H

#define RESID_TYPELIB           1

#endif /* _RESOURCE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\dll\init.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: init.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"

// Macro refers to a function of the name InitializeModule_Name,
// assumed to be defined, and then calls it.  If it's not defined,
// we'll get a link time error.
#define INITIALIZE_MODULE(ModuleName)           \
  extern bool InitializeModule_##ModuleName();  \
  if (!InitializeModule_##ModuleName()) return false;

#define DEINITIALIZE_MODULE(ModuleName,bShutdown)               \
  extern void DeinitializeModule_##ModuleName(bool);            \
  DeinitializeModule_##ModuleName(bShutdown);

bool
InitializeAllModules()
{
    INITIALIZE_MODULE(ATL);
    INITIALIZE_MODULE(Util);

    return true;
}

void
DeinitializeAllModules(bool bShutdown)
{
    DEINITIALIZE_MODULE(Util, bShutdown);
    DEINITIALIZE_MODULE(ATL, bShutdown);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\dll\oleobj.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: oleobj.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "src\factory.h"
#include "mmapi\mmfactory.h"
#include "dartapi.h"

DeclareTag(tagLockCount,"COM","Lock count");

DAComModule _Module;
extern HINSTANCE hInst;

BEGIN_OBJECT_MAP(COMObjectMap)
    OBJECT_ENTRY(CLSID_TIMEFactory, CTIMEFactory)
    OBJECT_ENTRY(CLSID_TIMEMMFactory, CMMFactory)
END_OBJECT_MAP()

bool bFailedLoad = false;

#define EXCEPTION(t) (GetExceptionCode() == t ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH )

LONG
DAComModule::Lock()
{
    // Can't depend on value return from Lock to be accurate.  Since
    // the CRConnect can be called multiple times w/o a problem simply
    // check the internal variable to see if it is 0.  This should
    // never cause anything except multiple calls to CRConnect

    bool bNeedConnect = (GetLockCount() == 0);

    LONG l = CComModule::Lock();

    TraceTag((tagLockCount,
              "DAComModule::Lock - new lockcount - %d, returned - %d",
              _Module.GetLockCount(),
              l));

    if (bNeedConnect) {
        __try {
            CRConnect(hInst);
        } __except (  EXCEPTION_EXECUTE_HANDLER ) {
            bFailedLoad = true;
        }
    }

    return l;
}

LONG
DAComModule::Unlock()
{
    LONG l = CComModule::Unlock();

    TraceTag((tagLockCount,
              "DAComModule::Unlock - new lockcount - %d, returned - %d",
              _Module.GetLockCount(),
              l));

    if (l) return l;
    if (!bFailedLoad)
        CRDisconnect(hInst);
    return 0;
}

#if DEVELOPER_DEBUG
#include <map>

typedef std::map<void *, const _TCHAR *> ObjectMap;
ObjectMap *objMap = NULL;

void
DAComModule::AddComPtr(void *ptr, const _TCHAR * name)
{
    EnterCriticalSection(&m_csObjMap);
    (*objMap)[ptr] = name;
    LeaveCriticalSection(&m_csObjMap) ;
}

void
DAComModule::RemoveComPtr(void *ptr)
{
    EnterCriticalSection(&m_csObjMap);
    objMap->erase(ptr);
    LeaveCriticalSection(&m_csObjMap) ;
}

void
DAComModule::DumpObjectList()
{
    if (objMap) {
        EnterCriticalSection(&m_csObjMap);
        if (objMap->size() > 0 || GetLockCount() > 0) {
            OutputDebugString (__T("DATIME.DLL: Detected unfreed COM pointers\n"));
            OutputDebugString (__T("Listing pointers and types:\n"));
            for (ObjectMap::iterator i = objMap->begin();
                 i != objMap->end();
                 i++) {

                _TCHAR buf[1024];

                wsprintf(buf, __T("%#x:"), (*i).first);
                OutputDebugString(buf);

                if ((*i).second)
                    OutputDebugString((*i).second);

                OutputDebugString(__T("\n"));
            }
        }

        LeaveCriticalSection(&m_csObjMap) ;
    }
}

void
DumpCOMObjectList()
{
    _Module.DumpObjectList();
}

#endif

bool
InitializeModule_ATL()
{
    _Module.Init(COMObjectMap, hInst);

#if DEVELOPER_DEBUG
    // NOTE: Memory allocation during construction now gives a warning.
    // If this is ok because this is DEV_DEBUG then leave the following
    // pragma, otherwise move this NEW.
#pragma warning( disable: 4291 )
    objMap = NEW ObjectMap;
#endif

    return true;
}

void
DeinitializeModule_ATL(bool bShutdown)
{
#if DEVELOPER_DEBUG
    DumpCOMObjectList();

    delete objMap;
    objMap = NULL;
#endif

    _Module.Term();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\include\headers.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

    Precompiled headers for dalite.dll
*******************************************************************************/

#ifndef DAL_HEADERS_HXX
#define DAL_HEADERS_HXX

/* Standard */
#include <math.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <memory.h>
#include <wtypes.h>

// Warning 4786 (identifier was truncated to 255 chars in the browser
// info) can be safely disabled, as it only has to do with generation
// of browsing information.
#pragma warning(disable:4786)

#include "apeldbg/apeldbg.h"

#pragma warning(disable:4530)
// ATL - needs to be before windows.h
#include "daatl.h"

/* Windows */
#include <windows.h>
#include <windowsx.h>

/* C++ Replace DLL */
#include "dalibc.h"

#include <mshtmhst.h>
#include <mshtml.h>

#include <ddraw.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\dll\main.cpp ===
/*******************************************************************************
  Copyright (c) 1995-96 Microsoft Corporation

  Abstract:

    Initialization

 *******************************************************************************/

#include "headers.h"

HINSTANCE  hInst;

bool InitializeAllModules(void);
void DeinitializeAllModules(bool bShutdown);

extern "C" BOOL WINAPI _DllMainCRTStartup (HINSTANCE hInstance,
                                           DWORD dwReason,
                                           LPVOID lpReserved);

extern "C" BOOL WINAPI
_TIMEDllMainStartup(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_DETACH) {
        // Call the routines in reverse order of initialization
        BOOL r = _DllMainCRTStartup(hInstance,dwReason,lpReserved);
        r = DALibStartup(hInstance,dwReason,lpReserved) && r;

        return r;
    } else {
        // In everything except DLL_PROCESS_DETACH call DALibStartup first
        return (DALibStartup(hInstance,dwReason,lpReserved) &&
                _DllMainCRTStartup(hInstance,dwReason,lpReserved));
    }
}

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        hInst = hInstance;

        DisableThreadLibraryCalls(hInstance);

        // For APELDBG
        RESTOREDEFAULTDEBUGSTATE;

        if (!InitializeAllModules())
        {
            return FALSE;
        }
        
    } else if (dwReason == DLL_PROCESS_DETACH) {
        DeinitializeAllModules(lpReserved != NULL);

#if _DEBUG
        _TCHAR buf[MAX_PATH + 1];
        
        GetModuleFileName(hInst, buf, MAX_PATH);
        
#if _DEBUGMEM
        TraceTag((tagLeaks, "\n[%s] unfreed memory:", buf));
        DUMPMEMORYLEAKS;
#endif

        // de-initialize the debug trace info.
        DeinitDebug();
#endif
    }
    
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

#ifdef _DEBUG
static bool breakDialog = false ;
DeclareTag(tagDebugBreak, "!Debug", "Breakpoint on entry to DLL");
#endif

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _DEBUG
    if (!breakDialog && IsTagEnabled(tagDebugBreak)) {
        _TCHAR buf[MAX_PATH + 1];
        
        GetModuleFileName(hInst, buf, MAX_PATH);
        
        MessageBox(NULL,buf,__T("TIME - Creating first COM Object"),MB_OK|MB_SETFOREGROUND) ;
        breakDialog = true;
    }
#endif

    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}


#if _DEBUG
STDAPI_(void)
DoTraceTagDialog(HWND hwndStub,
                 HINSTANCE hAppInstance,
                 LPWSTR lpwszCmdLine,
                 int nCmdShow)
{
    DoTracePointsDialog(true);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\idl\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\include\util.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/

#ifndef _UTIL_H
#define _UTIL_H

//************************************************************
// this is used globally to denote that when scripting, we 
// use English.
#define LCID_SCRIPTING 0x0409

template <class T>
class CRPtr
{
  public:
    typedef T _PtrClass;
    CRPtr() { p = NULL; }
    CRPtr(T* lp, bool baddref = true)
    {
        p = lp;
        if (p != NULL && baddref)
            CRAddRefGC(p);
    }
    CRPtr(const CRPtr<T>& lp, bool baddref = true)
    {
        p = lp.p;

        if (p != NULL && baddref)
            CRAddRefGC(p);
    }
    ~CRPtr() {
        CRReleaseGC(p);
    }
    void Release() {
        CRReleaseGC(p);
        p = NULL;
    }
    operator T*() { return (T*)p; }
    T& operator*() { Assert(p != NULL); return *p; }
    T* operator=(T* lp)
    {
        return Assign(lp);
    }
    T* operator=(const CRPtr<T>& lp)
    {
        return Assign(lp.p);
    }

    bool operator!() const { return (p == NULL); }
    operator bool() const { return (p != NULL); }

    T* p;
  protected:
    T* Assign(T* lp) {
        if (lp != NULL)
            CRAddRefGC(lp);

        CRReleaseGC(p);

        p = lp;

        return lp;
    }
};

class CRLockGrabber
{
  public:
    CRLockGrabber() { CRAcquireGCLock(); }
    ~CRLockGrabber() { CRReleaseGCLock(); }
};


class SafeArrayAccessor
{
  public:
    SafeArrayAccessor(VARIANT & v,
                      bool allowNullArray = false);
    ~SafeArrayAccessor();

    unsigned int GetArraySize() { return _ubound - _lbound + 1; }

    IUnknown **GetArray() { return _isVar?_allocArr:_ppUnk; }

    bool IsOK() { return !_failed; }
  protected:
    SAFEARRAY * _s;
    union {
        VARIANT * _pVar;
        IUnknown ** _ppUnk;
        void * _v;
    };
    
    VARTYPE _vt;
    long _lbound;
    long _ubound;
    bool _inited;
    bool _isVar;
    CComVariant _retVar;
    bool _failed;
    IUnknown ** _allocArr;
};

inline WCHAR * CopyString(const WCHAR *str) {
    int len = str?lstrlenW(str)+1:1;
    WCHAR *newstr = new WCHAR [len] ;
    if (newstr) memcpy(newstr,str?str:L"",len * sizeof(WCHAR)) ;
    return newstr ;
}

#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

IDirectDraw * GetDirectDraw();

HRESULT
CreateOffscreenSurface(IDirectDraw *ddraw,
                       IDirectDrawSurface **surfPtrPtr,
                       DDPIXELFORMAT *pf,
                       bool vidmem,
                       LONG width, LONG height);

HRESULT
CopyDCToDdrawSurface(HDC srcDC,
                     LPRECT prcSrcRect,
                     IDirectDrawSurface *DDSurf,
                     LPRECT prcDestRect);

/////////////////////////  CriticalSections  //////////////////////

class CritSect
{
  public:
    CritSect();
    ~CritSect();
    void Grab();
    void Release();
    
  protected:
    CRITICAL_SECTION _cs;
};

class CritSectGrabber
{
  public:
    CritSectGrabber(CritSect& cs, bool grabIt = true);
    ~CritSectGrabber();
    
  protected:
    CritSect& _cs;
    bool grabbed;
};

/////////////////////// Misc ////////////////////


#define INDEFINITE HUGE_VAL //defined for Variant conversion functions

#define FOREVER    HUGE_VAL

#define INVALID    -HUGE_VAL

bool CRBvrToVARIANT(CRBvrPtr b, VARIANT * v);
CRBvrPtr VARIANTToCRBvr(VARIANT v, CR_BVR_TYPEID tid = CRINVALID_TYPEID);

HRESULT GetTIMEAttribute(IHTMLElement * elm, LPCWSTR str, LONG lFlags, VARIANT * value);
HRESULT SetTIMEAttribute(IHTMLElement * elm, LPCWSTR str, VARIANT value, LONG lFlags);
BSTR CreateTIMEAttrName(LPCWSTR str);

bool VariantToBool(VARIANT var);
float VariantToFloat(VARIANT var,
                     bool bAllowIndefinite = false,
                     bool bAllowForever = false);
HRESULT VariantToTime(VARIANT vt, float *retVal);
BOOL IsIndefinite(OLECHAR *szTime);

extern const wchar_t * TIMEAttrPrefix;

/////////////////////// Convenience macros ////////////////////

//
// used in QI implementations for safe pointer casting
// e.g. if( IsEqualGUID(IID_IBleah) ) *ppv = SAFECAST(this,IBleah);
// Note: w/ vc5, this is ~equiv to *ppv = static_cast<IBleah*>(this);
//
#define SAFECAST(_src, _type) (((_type)(_src)==(_src)?0:0), (_type)(_src))

// 
// used in QI calls, 
// e.g. IOleSite * pSite;  p->QI( IID_TO_PPV(IOleInPlaceSite, &pSite) ) 
// would cause a C2440 as _src is not really a _type **.
// Note: the riid must be the _type prepended by IID_.
//
#define IID_TO_PPV(_type,_src)      IID_##_type, \
                                    reinterpret_cast<void **>(static_cast<_type **>(_src))


//************************************************************


#if (_M_IX86 >= 300) && defined(DEBUG)
  #define PSEUDORETURN(dw)    _asm { mov eax, dw }
#else
  #define PSEUDORETURN(dw)
#endif // not _M_IX86


//
// ReleaseInterface calls 'Release' and NULLs the pointer
// The Release() return will be in eax for IA builds.
//
#define ReleaseInterface(p)\
{\
    ULONG cRef = 0u; \
    if (NULL != (p))\
    {\
        cRef = (p)->Release();\
        Assert((int)cRef>=0);\
        (p) = NULL;\
    }\
    PSEUDORETURN(cRef) \
}

//************************************************************
// Errot Reporting helper macros

inline HRESULT TIMESetLastError(HRESULT hr, LPCWSTR msg = NULL)
{
    CRSetLastError(hr, msg);
    return hr;
}

inline HRESULT TIMEGetLastError()
{
    return CRGetLastError();
}

#define WZ_OBFUSCATED_TIMEBODY_URN      L"#time#3CA6D405-6352-11d2-AF2D-00A0C9A03B8C"     // a GUID not intended for COM use

HRESULT CheckElementForBehaviorURN(IHTMLElement *pElement,
                                   WCHAR *wzURN,
                                   bool *pfReturn);

HRESULT AddBodyBehavior(IHTMLElement* pElement);
bool IsBodyElement(IHTMLElement *pElement);
HRESULT GetBodyElement(IHTMLElement *pElement, REFIID riid, void **);
bool IsTIMEBodyElement(IHTMLElement *pElement);
HRESULT FindTIMEInterface(IHTMLElement *pHTMLElem, ITIMEElement **ppTIMEElem);
HRESULT FindTIMEBehavior(IHTMLElement *pHTMLElem, IDispatch **ppDisp);


#endif /* _UTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\mmapi\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"
#include "mmapi.h"
#include "dacomutil.h"
#include "dartapi.h"
#include "datime.h"
#include "util.h"
#include <list>

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\mmapi\mmbasebvr.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _MMBASEBVR_H
#define _MMBASEBVR_H

#define MM_INFINITE HUGE_VAL

class CMMTimeline;
class CMMBehavior;
class CMMPlayer;

extern TAG tagMMBaseBvr;

class CallBackData;
typedef std::list<CallBackData *> CallBackList;

class CMMBaseBvr;
typedef std::list<CMMBaseBvr*> MMBaseBvrList;

class
ATL_NO_VTABLE CMMBaseBvr
    : public CComObjectRootEx<CComSingleThreadModel>
{
  public:
    CMMBaseBvr();
    virtual ~CMMBaseBvr();
    
    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;
    
    // We cannot put the real one here since the typecast causes it to
    // get the wrong vtables
    static HRESULT WINAPI
        BaseInternalQueryInterface(CMMBaseBvr* pThis,
                                   void * pv,
                                   const _ATL_INTMAP_ENTRY* pEntries,
                                   REFIID iid,
                                   void** ppvObject);

    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    // Add a dummy one to assert just in case the derived class does
    // not add one
    static inline HRESULT WINAPI
        InternalQueryInterface(CMMBaseBvr* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject)
    {
        AssertStr(false, "InternalQueryInterface not defined in base class");
        return E_FAIL;
    }
    
    HRESULT BaseInit(LPWSTR id, CRBvrPtr rawbvr);

#if _DEBUG
    virtual const _TCHAR * GetName() { return __T("CMMBaseBvr"); }
#endif

    // Base interface functions
    
    HRESULT GetID(LPOLESTR *);
    HRESULT SetID(LPOLESTR);
        
    HRESULT GetStartOffset(float *);
    HRESULT SetStartOffset(float);
        
    HRESULT GetDuration(float * pd);
    HRESULT SetDuration(float d);
        
    HRESULT GetRepeat(LONG * pr);
    HRESULT SetRepeat(LONG r);
       
    HRESULT GetAutoReverse(VARIANT_BOOL * pr);
    HRESULT SetAutoReverse(VARIANT_BOOL r);
        
    HRESULT GetRepeatDur(float *);
    HRESULT SetRepeatDur(float);
        
    HRESULT GetEndOffset(float *);
    HRESULT SetEndOffset(float);
        
    HRESULT GetEaseIn(float * pd);
    HRESULT SetEaseIn(float d);

    HRESULT GetEaseInStart(float * pd);
    HRESULT SetEaseInStart(float d);

    HRESULT GetEaseOut(float * pd);
    HRESULT SetEaseOut(float d);

    HRESULT GetEaseOutEnd(float * pd);
    HRESULT SetEaseOutEnd(float d);

    HRESULT GetSyncFlags(DWORD * flags);
    HRESULT SetSyncFlags(DWORD flags);

    HRESULT GetEventCB(ITIMEMMEventCB ** ev);
    HRESULT SetEventCB(ITIMEMMEventCB * ev);
        
    HRESULT GetTotalTime(float * pd);
        
    HRESULT GetDABehavior(REFIID riid, void **);
    HRESULT GetResultantBehavior(REFIID riid, void **ret);

    HRESULT Begin(bool bAfterOffset);
    HRESULT End();
    HRESULT Pause();
    HRESULT Run();
    HRESULT Seek(double lTime);
    HRESULT Reset(DWORD fCause);
    HRESULT ResetOnEventChanged(bool bBeginEvent);

    HRESULT GetLocalTime(double * d);
    HRESULT GetLocalTimeEx(double * d);

    HRESULT GetSegmentTime(double * d);

    HRESULT GetPlayState(MM_STATE * state);

    HRESULT PutStartType(MM_START_TYPE st)
    {
        m_startType = st; return S_OK;
    }

    // Accessors

    CRBvrPtr GetRawBvr() { return m_rawbvr; }
    CRBvrPtr GetResultantBvr() { return m_resultantbvr; }
    float GetStartOffset() { return m_startOffset; }
    float GetDuration() { return m_duration; }
    float GetEndOffset() { return m_endOffset; }
    float GetRepeatDuration() { return m_repDuration; }
    long GetRepeat() { return m_repeat; }
    bool GetAutoReverse() { return m_bAutoReverse; }
    ITIMEMMEventCB * GetEventCB() { return m_eventcb; }
    float GetEaseIn() { return m_easeIn; }
    float GetEaseInStart() { return m_easeInStart; }
    float GetEaseOut() { return m_easeOut; }
    float GetEaseOutEnd() { return m_easeOutStart; }
    bool IsClockSource();
    bool IsLocked();
    bool IsCanSlip();
    DWORD GetSyncFlags();
    
    double GetTotalRepDuration() { return m_totalRepDuration; }
    double GetTotalDuration() { return m_totalDuration; }
    double GetStartTime() { return m_startOffset; }
    double GetEndTime() { return m_startOffset + m_totalRepDuration; }
    double GetAbsStartTime() { return m_absStartTime; }
    double GetAbsEndTime() { return m_absEndTime; }
    double GetDepStartTime() { return m_depStartTime; }
    double GetDepEndTime() { return m_depEndTime; }
    
    double GetCurrentLocalTime();
    double GetCurrentLocalTimeEx();
    double GetCurrentSegmentTime();
    
    CMMBaseBvr * GetParent() { return m_parent; }
    CMMPlayer * GetPlayer() { return m_player; }

    // This will call all the behaviors which are currently running
    // with the given event.  This is used when the timeline needs to
    // process a specific event like Pause/Resume/Stop/Play.
    
    bool ProcessEvent(CallBackList * l,
                      double time,
                      bool bFirstTick,
                      MM_EVENT_TYPE et,
                      DWORD flags);
    
    virtual bool _ProcessEvent(CallBackList * l,
                               double time,
                               bool bFirstTick,
                               MM_EVENT_TYPE et,
                               bool bNeedsReverse,
                               DWORD flags) { return true; }
    
    bool ProcessCB(CallBackList * l,
                   double lastTick,
                   double curTime,
                   bool bForward,
                   bool bFirstTick,
                   bool bNeedPlay);

    virtual bool _ProcessCB(CallBackList * l,
                            double lastTick,
                            double curTime,
                            bool bForward,
                            bool bFirstTick,
                            bool bNeedPlay,
                            bool bNeedsReverse) { return true; }

    virtual bool EventNotify(CallBackList *l,
                             double lTime,
                             MM_EVENT_TYPE et,
                             DWORD flags);
    
    virtual bool ParentEventNotify(CMMBaseBvr * bvr,
                                   double lTime,
                                   MM_EVENT_TYPE et,
                                   DWORD flags)
    { return true; }
    
    virtual void Invalidate();
    
    virtual bool ConstructBvr(CRNumberPtr timeline);
    virtual void DestroyBvr();
    virtual bool ResetBvr(CallBackList * l,
                          bool bProcessSiblings = true);

    bool SetParent(CMMBaseBvr * parent,
                   MM_START_TYPE st,
                   CMMBaseBvr * startSibling);
    bool ClearParent();

    bool AttachToSibling();
    void DetachFromSibling();
    
    virtual void SetPlayer(CMMPlayer * player);
    virtual void ClearPlayer();

    CMMBaseBvr *GetStartSibling() { return m_startSibling; }
    CMMBaseBvr *GetEndSibling() { return m_endSibling; }
    MM_START_TYPE GetStartType() { return m_startType; }

    inline bool IsPlaying();
    inline bool IsPaused();

    bool IsPlayable(double t);

#if _DEBUG
    virtual void Print(int spaces);
#endif

    virtual bool OnBvrCB(double gTime);

  protected:

    bool UpdateAbsStartTime(double f, bool bUpdateDepTime);
    bool UpdateAbsEndTime(double f, bool bUpdateDepTime);
    
    //returns the number CRBvr that represents the start time of this MMBehavior in parent time
    CRNumberPtr GetStartTimeBvr() { return m_startTimeBvr; }
    //returns the number CRBvr that represents the stop time of this MMBehavior in the parent time.
    CRNumberPtr GetEndTimeBvr() { return m_endTimeBvr; }
    
    bool UpdateResultantBvr(CRBvrPtr bvr);
    void ClearResultantBvr();
    
    CRBvrPtr EncapsulateBvr(CRBvrPtr rawbvr);
    
    void CalculateEaseCoeff();

    // This will take the time behavior and ease it
    CRNumberPtr EaseTime(CRNumberPtr time);

    // This will take the given time and transform it to the correct
    // eased time
    // If the time is outside of our duration (i.e. <0 or >
    // m_duration) this will just return the given time
    double EaseTime(double time);

    // This will take the given time and transform it to the time it
    // would have been w/o an ease
    double ReverseEaseTime(double time);

    virtual bool IsContinuousMediaBvr() { return false; }

    void UpdateTotalDuration();

    // Sibling dependency management
    bool AddStartTimeSink(CMMBaseBvr * sink);
    void RemoveStartTimeSink(CMMBaseBvr * sink);
    bool AddEndTimeSink(CMMBaseBvr* sink);
    void RemoveEndTimeSink(CMMBaseBvr* sink);

    // methods for the propagation of start times and end times.
    // The time passed in is the local time of the parent which we are
    // suppose to start on

    // This is where all the wiring gets hooked up
    // Basicly once we determine what our start time is we can then
    // propagate this information to all of our dependents and allow
    // them to in turn do the same

    bool StartTimeVisit(double time,
                        CallBackList * l,
                        bool bAfterOffset,
                        bool bReset = false,
                        DWORD fCause = 0);

    // It is pretty much the same for the end time.  This can be
    // called when our start time is set if we know the duration and
    // will also be called for indeterminate durations or event
    // ending.
    
    bool EndTimeVisit(double time, CallBackList * l);

    bool UpdateTimeControl();

    bool UpdateSyncTime(double newtime);
    
    virtual HRESULT Error() = 0;

    double GetContainerSegmentTime();
    
    // This will take the local time of the bvr and convert it to
    // it's segment time.  Basically it will take into account repeat
    // and bounce.
    
    double LocalTimeToSegmentTime(double t);

    // This will take the local time of bvr and return the local time
    // of the bvr which started the current segment
    
    double LocalTimeToSegmentBase(double t);

    // This converts a given global time to a local time

    double GlobalTimeToLocalTime(double gt);
    double GlobalTimeToLocalTimeEx(double gt);
    
    bool Sync(double newTime, double nextGlobalTime);

    // This takes pure local timeline times (pre-ease)
    // The curTime is the time on the current timeline we want to now
    // be at newTime.  For regular seeking this would be the current
    // localtime.
    bool _Seek(double curTime, double newTime);

    virtual bool ReconstructBvr(CMMBaseBvr* ) { CRSetLastError(E_NOTIMPL, NULL); return false; }

    //
    // DATA declarations
    //
  protected:
    LPWSTR m_id;
    float m_startOffset;
    float m_duration;
    float m_repeatDur;
    long m_repeat;
    bool m_bAutoReverse;
    float m_endOffset;
    float m_easeIn;
    float m_easeInStart;
    float m_easeOut;
    float m_easeOutEnd;
    DWORD m_syncFlags;
    bool m_bPlaying;

    // These are the absolute local times which correspond to when the
    // behavior really starts and really ends - not including start
    // and end offsets.
    double m_absStartTime;
    double m_absEndTime;

    double m_depStartTime;
    double m_depEndTime;

    DAComPtr<ITIMEMMEventCB> m_eventcb;

    //The way in which this behavior begins.  Can be any of the enum MM_START_TYPE
    MM_START_TYPE m_startType;
    //if this behavior is begin with or after this holds the sibling
    //  that controls when we start.
    CMMBaseBvr *m_startSibling;
    //if this behavior is end with this holds the sibling that controls
    //  when we stop.
    CMMBaseBvr *m_endSibling;

    //TODO: these could be allocated as needed.  They may be fairly rarely used.
    MMBaseBvrList m_startTimeSinks;
    MMBaseBvrList m_endTimeSinks;

    // These behaviors represent the local begin and end times for
    // this behavior.  Siblings can reference these to place
    // themselves relatively according to start with/after and
    // endwith.
    
    CRPtr<CRNumber> m_startTimeBvr;
    CRPtr<CRNumber> m_endTimeBvr;

    // This represents the time sub we are using for the behavior
    // For beginafter/with this points to the siblings appropriate
    // behavior, for an event it points to infinity until the start
    // time is known, and for an absolute it is simply local time.
    // This also allows us to implement slipSync since we can use to
    // adjust ourselves as we need it
    
    CRPtr<CRNumber> m_timeControl;

    // A single segment duration
    double m_segDuration;
    
    // The duration for a single rep of a behavior
    double m_repDuration;

    // Total duration we calculate for a regular behavior 
    double m_totalRepDuration; 

    // The real duration determine by adding totalrepduration + start + end
    float m_totalDuration;

    CRPtr<CRBvr> m_rawbvr;
    CMMBaseBvr * m_parent;
    CR_BVR_TYPEID m_typeId;
    CMMPlayer * m_player;

    CRPtr<CRBvr> m_resultantbvr;
    long m_cookie;
    
    bool m_bPaused;
    double m_pauseTime;
    
    // This is the last time we were ticked to ensure we never fire
    // events twice
    double m_lastTick;
    
    // The ease-in/out behavior modifier is applied using timeline
    // substitution.  The substitute timeline consists of three pieces
    // A, B and C, which are the ease-in, constant velocity and ease-out
    // parts respectively.  For B, a linear timeline is substituted; for
    // A and C, a quadratic warping of the input time is required.

    float m_flA0, m_flA1, m_flA2; // coefficients for the A piece
    float m_flB0, m_flB1;         // coefficients for the B piece
    float m_flC0, m_flC1, m_flC2; // coefficients for the C piece

    // These are the times to perform ease in/out
    float m_easeInEnd;
    float m_easeOutStart;
    bool m_bNeedEase;
    double m_startOnEventTime;
};

class CallBackData
{
  public:
    CallBackData(ITIMEMMBehavior * bvr,
                 ITIMEMMEventCB * eventcb,
                 double time,
                 MM_EVENT_TYPE et,
                 DWORD flags);
    ~CallBackData();

    HRESULT CallEvent();

    ITIMEMMBehavior* GetBehavior() { return m_bvr; }
    MM_EVENT_TYPE GetEventType() { return m_et; }
  protected:
    DAComPtr<ITIMEMMBehavior> m_bvr;
    double m_time;
    MM_EVENT_TYPE m_et;
    DAComPtr<ITIMEMMEventCB> m_eventcb;
    DWORD m_flags;
};

bool ProcessCBList(CallBackList &l);

#if _DEBUG
inline char * EventString(MM_EVENT_TYPE et) {
    switch(et) {
      case MM_PLAY_EVENT:
        return "Play";
      case MM_STOP_EVENT:
        return "Stop";
      case MM_PAUSE_EVENT:
        return "Pause";
      case MM_RESUME_EVENT:
        return "Resume";
      case MM_REPEAT_EVENT:
        return "Repeat";
      case MM_AUTOREVERSE_EVENT:
        return "Autoreverse";
      default:
        return "Unknown";
    }
}
#endif

inline bool
CMMBaseBvr::IsPlaying()
{
    return m_bPlaying;
}

inline bool
CMMBaseBvr::IsPaused()
{
    return m_bPaused;
}

inline bool
CMMBaseBvr::IsClockSource()
{
    return ((m_syncFlags & MM_CLOCKSOURCE) != 0);
}

inline bool
CMMBaseBvr::IsLocked()
{
    return ((m_syncFlags & MM_LOCKED) != 0);
}

inline bool
CMMBaseBvr::IsCanSlip()
{
    return !IsLocked();
}

inline DWORD
CMMBaseBvr::GetSyncFlags()
{
    return m_syncFlags;
}

CMMBaseBvr * GetBvr(IUnknown *);

#endif /* _MMBASEBVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\mmapi\mmbasebvr.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmbasebvr.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "mmbasebvr.h"
#include "mmplayer.h"

#define BEGIN_HOLD_EPSILON 0.000001

DeclareTag(tagMMBaseBvr, "API", "CMMBaseBvr methods");

CMMBaseBvr::CMMBaseBvr()
  // The DA bvr we are referencing and its type
: m_id(NULL),
  m_rawbvr(NULL),
  m_typeId(CRINVALID_TYPEID),

  // Basic timing properties - only used to store values
  m_startOffset(0),
  m_duration(-1),
  m_repeatDur(-1),
  m_repeat(1),
  m_bAutoReverse(false),
  m_endOffset(0),
  m_easeIn(0.0),
  m_easeInStart(0.0),
  m_easeOut(0.0),
  m_easeOutEnd(0.0),
  m_syncFlags(0),

  // Calculated times
  m_totalDuration(0.0),
  m_segDuration(0.0),
  m_repDuration(0.0),
  m_totalRepDuration(0.0),
  m_absStartTime( MM_INFINITE ),
  m_absEndTime( MM_INFINITE ),
  m_depStartTime( MM_INFINITE ),
  m_depEndTime( MM_INFINITE ),

  m_player(NULL),
  m_parent(NULL),
  m_startSibling(NULL),
  m_endSibling(NULL),
  m_startType(MM_START_ABSOLUTE),

  m_cookie(0),
  m_bPaused(false),
  m_bPlaying(false),
  
  m_lastTick(-MM_INFINITE),
  m_startOnEventTime(-MM_INFINITE)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::CMMBaseBvr()",
              this));
}

CMMBaseBvr::~CMMBaseBvr()
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::~CMMBaseBvr()",
              this));

    delete m_id;
}

HRESULT
CMMBaseBvr::BaseInit(LPOLESTR id, CRBvrPtr rawbvr)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::BaseInit(%ls, %#lx)",
              id,
              rawbvr));
    
    HRESULT hr;

    CRLockGrabber __gclg;

    if (rawbvr == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    m_rawbvr = rawbvr;
    
    m_typeId = CRGetTypeId(m_rawbvr);
    
    Assert(m_typeId != CRUNKNOWN_TYPEID &&
           m_typeId != CRINVALID_TYPEID);
    
    m_startTimeBvr = CRModifiableNumber(MM_INFINITE);
    
    if (!m_startTimeBvr)
    {
        hr = CRGetLastError();
        goto done;
    }
    
    m_endTimeBvr = CRModifiableNumber(MM_INFINITE);

    if (!m_endTimeBvr)
    {
        hr = CRGetLastError();
        goto done;
    }
    
    m_timeControl = CRModifiableNumber(MM_INFINITE);

    if (!m_timeControl)
    {
        hr = CRGetLastError();
        goto done;
    }
    
    UpdateTotalDuration();
    
    if (id)
    {
        m_id = CopyString(id);
        
        if (m_id == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    hr = S_OK;

  done:
    return hr;
}

void
CMMBaseBvr::UpdateTotalDuration()
{
    if (m_duration == -1 )
    {
        m_segDuration = MM_INFINITE;
    }
    else
    {
        m_segDuration = m_duration;
    }
    
    if (m_bAutoReverse)
    {
        m_repDuration = m_segDuration * 2;
    }
    else
    {
        m_repDuration = m_segDuration;
    }
        
    if (m_repeatDur != -1)
    {
        m_totalRepDuration = m_repeatDur;

        if (m_segDuration == MM_INFINITE)
        {
            // If our segment time was infinite but we had a repeat
            // dur we can really consider this to be the real duration
            m_segDuration = m_repDuration = m_repeatDur;
        }
    }
    else if (m_repeat == 0)
    {
        m_totalRepDuration = MM_INFINITE;
    }
    else
    {
        m_totalRepDuration = m_repeat * m_repDuration;
    }

    m_totalDuration = m_startOffset + m_totalRepDuration + m_endOffset;
}

void
CMMBaseBvr::Invalidate()
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::Invalidate()",
              this));

    UpdateTotalDuration();
    
    if (m_parent)
    {
        m_parent->Invalidate();
    }
}

bool
CMMBaseBvr::SetParent(CMMBaseBvr * parent,
                      MM_START_TYPE st,
                      CMMBaseBvr * startSibling)
{
    bool ok = false;
    
    // These will be cleared if we are called correctly
    
    Assert(!m_resultantbvr);
    Assert(m_parent == NULL);
    Assert(m_startTimeSinks.size() == 0);
    Assert(m_endTimeSinks.size() == 0);

    // Validate parameters

    switch (st)
    {
      case MM_START_ABSOLUTE:
        // This is not absolutely necessary but will ensure that if we
        // ever want to take a parameter we know that old code had
        // ensured that it was NULL
        
        if (startSibling != NULL)
        {
            CRSetLastError(E_INVALIDARG, NULL);
            goto done;
        }

        if (!UpdateAbsStartTime(m_startOffset, true))
        {
            goto done;
        }

        break;
      case MM_START_EVENT:
        // This is not absolutely necessary but will ensure that if we
        // ever want to take a parameter we know that old code had
        // ensured that it was NULL
        
        if (startSibling != NULL)
        {
            CRSetLastError(E_INVALIDARG, NULL);
            goto done;
        }

        if (!UpdateAbsStartTime(MM_INFINITE, true))
        {
            goto done;
        }

        break;
      case MM_START_WITH:
      case MM_START_AFTER:
        if (startSibling == NULL)
        {
            CRSetLastError(E_INVALIDARG, NULL);
            goto done;
        }

        if (!UpdateAbsStartTime(MM_INFINITE, true))
        {
            goto done;
        }

        break;
      default:
        CRSetLastError(E_INVALIDARG, NULL);
        goto done;
    }
    
    if (!UpdateAbsEndTime(GetAbsStartTime() + GetTotalRepDuration(), true))
    {
        goto done;
    }

    // Update args now that we know they are valid

    m_startType = st;
    m_startSibling = startSibling;
    m_parent = parent;

    ok = true;
  done:
    return ok;
}

bool
CMMBaseBvr::ClearParent()
{
    DetachFromSibling();
    
    m_startSibling = NULL;
    m_startType = MM_START_ABSOLUTE;
    m_parent = NULL;
  
    // There is no way for us to ensure this properly (since
    // dependents have no root anymore and our container usually
    // handles this), so our parent better have dealt with it
    while (!m_startTimeSinks.empty())
    {
        (m_startTimeSinks.front())->DetachFromSibling();
    }
    
    while (!m_endTimeSinks.empty())
    {
        (m_endTimeSinks.front())->DetachFromSibling();
    }

    Assert(m_startTimeSinks.size() == 0);
    Assert(m_endTimeSinks.size() == 0);

    // Just in case
    m_startTimeSinks.clear();
    m_endTimeSinks.clear();

    // Our resultant bvr is no longer valid - clear all constructed
    // behaviors
    DestroyBvr();

    UpdateAbsStartTime(MM_INFINITE, true);
    UpdateAbsEndTime(MM_INFINITE, true);

    return true;
}

bool
CMMBaseBvr::AttachToSibling()
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::AttachToSibling()",
              this));
    
    bool ok = false;
    switch(m_startType)
    {
      case MM_START_ABSOLUTE:
        Assert(m_startSibling == NULL);

        if (!UpdateAbsStartTime(m_startOffset, true))
        {
            goto done;
        }

        break;
      case MM_START_EVENT:
        Assert(m_startSibling == NULL);

        if (!UpdateAbsStartTime(MM_INFINITE, true))
        {
            goto done;
        }

        break;
      case MM_START_WITH:
        Assert(m_startSibling != NULL);

        // The sibling better have the same parent and it also should not
        // be NULL since it should have been added first
        
        Assert(m_startSibling->GetParent() != NULL);
        Assert(m_startSibling->GetParent() == m_parent);
        
        if (!m_startSibling->AddStartTimeSink(this))
        {
            goto done;
        }
        
        // Our absolute start time is the start time of the sibling
        // plus our start offset
        if (!UpdateAbsStartTime(m_startSibling->GetDepStartTime() + m_startOffset, true))
        {
            goto done;
        }

        break;
      case MM_START_AFTER:
        Assert(m_startSibling != NULL);

        // The sibling better have the same parent and it also should not
        // be NULL since it should have been added first
        
        Assert(m_startSibling->GetParent() != NULL);
        Assert(m_startSibling->GetParent() == m_parent);
        
        if (!m_startSibling->AddEndTimeSink(this))
        {
            goto done;
        }
        
        if (!UpdateAbsStartTime(m_startSibling->GetDepEndTime() + m_startOffset, true))
        {
            goto done;
        }

        break;
      default:
        Assert(!"CMMBaseBvr::AttachToSibling: Invalid start type");
        break;
    }

    if (!UpdateAbsEndTime(GetAbsStartTime() + GetTotalRepDuration(), true))
    {
        goto done;
    }

    ok = true;
  done:
    return ok;
}

void
CMMBaseBvr::DetachFromSibling()
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::DetachFromSibling()",
              this));
    if (NULL == m_startSibling)
    {
        return;
    }

    switch(m_startType)
    {
      case MM_START_ABSOLUTE:
      case MM_START_EVENT:
        Assert(m_startSibling == NULL);
        break;
      case MM_START_WITH:
        Assert(m_startSibling != NULL);
        m_startSibling->RemoveStartTimeSink(this);
        break;
      case MM_START_AFTER:
        Assert(m_startSibling != NULL);
        m_startSibling->RemoveEndTimeSink(this);
        break;
      default:
        Assert(!"CMMBaseBvr::DetachFromSibling: Invalid start type");
        break;
    }

    // always clear this.
    m_startSibling = NULL;
}

void
CMMBaseBvr::SetPlayer(CMMPlayer * player)
{
    Assert(m_player == NULL);
    Assert(!m_resultantbvr);
    
    m_player = player;

    // if we need to registered a Timer Callback, add it to the player.
    if (IsClockSource())
    {
        m_player->AddBvrCB(this);
    }
}

void
CMMBaseBvr::ClearPlayer()
{
    // We do not need to call Destroy since the clearplayer will do
    // the recursive calls and that would just waste time
    // Our resultant bvr is no longer valid
    ClearResultantBvr();

    // if we registered a Timer Callback, remove it from the player.
    // Make sure we check for the player since we may not have
    // actually set it yet.
    if (IsClockSource() && m_player)
    {
        m_player->RemoveBvrCB(this);
    }

    m_player = NULL;

}

bool
CMMBaseBvr::ConstructBvr(CRNumberPtr timeline)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::ConstructBvr(%#lx)",
              this,
              timeline));

    bool ok = false;
    
    Assert(!m_resultantbvr);
    // We should never be able to do this w/o a player
    Assert(m_player != NULL);
    
    // Need the GC Lock
    CRLockGrabber __gclg;
    
    CRBvrPtr bvr;

    if ((bvr = EncapsulateBvr(m_rawbvr)) == NULL)
    {
        goto done;
    }

    // First substitute our own control so inside the control we will
    // always refer to local time and it will actually be the local
    // time of the parent since we subst time with the containers
    // timeline after this
    if ((bvr = CRSubstituteTime(bvr, m_timeControl)) == NULL)
    {
        goto done;
    }
    
    // Now subst time the container timer
    
    if ((bvr = CRSubstituteTime(bvr, timeline)) == NULL)
    {
        goto done;
    }
    
    // Update the time control to be consistent with our current state
    // since at this point it has never been set before.
    
    if (!UpdateTimeControl())
    {
        goto done;
    }
    
    // Store away the new bvr in our resultant behavior
    if (!UpdateResultantBvr(bvr))
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok;
}

void
CMMBaseBvr::DestroyBvr()
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::DestroyBvr()",
              this));

    ClearResultantBvr();
}

bool
CMMBaseBvr::UpdateResultantBvr(CRBvrPtr bvr)
{
    Assert(!m_resultantbvr);
    Assert(m_cookie == 0);
    Assert(m_player != NULL);
    
    bool ok = false;
    
    // Run once the behavior so we get a handle to its performance
    if ((bvr = CRRunOnce(bvr)) == NULL)
    {
        goto done;
    }
    
    long cookie;
    
    if ((cookie = m_player->AddRunningBehavior(bvr)) == 0)
    {
        goto done;
    }
    
    m_cookie = cookie;
    m_resultantbvr = bvr;

    ok = true;
  done:
    return ok;
}

void
CMMBaseBvr::ClearResultantBvr()
{
    // Make this robust enough to call even if things are partially setup

    if (m_cookie)
    {
        // If we got here and the player is null then somethings
        // really wrong
        
        Assert(m_player);

        m_player->RemoveRunningBehavior(m_cookie);

        m_cookie = 0;
    }
    
    m_resultantbvr.Release();
}

CRBvrPtr
CMMBaseBvr::EncapsulateBvr(CRBvrPtr rawbvr)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::EncapsulateBvr(%#lx)",
              this,
              rawbvr));

    // Do not need to get GC lock since we have to return a CRBvrPtr
    // and thus the caller must have already acquired it
    
    CRBvrPtr newBvr = NULL;

    // Make sure we calculate the ease in/out coeff
    
    CalculateEaseCoeff();
    
    CRBvrPtr curbvr;

    curbvr = rawbvr;

    CRNumberPtr zeroTime;
    CRNumberPtr durationTime;
    
    if (m_bNeedEase)
    {
        CRNumberPtr time;

        if ((time = EaseTime(CRLocalTime())) == NULL)
        {
            goto done;
        }

        if ((curbvr = CRSubstituteTime(curbvr, time)) == NULL)
        {
            goto done;
        }
    }

    if ((zeroTime = CRCreateNumber(0)) == NULL)
    {
        goto done;
    }
    

    if ((durationTime = CRCreateNumber(m_segDuration)) == NULL)
    {
        goto done;
    }
    
    // For now clamp to the duration as well

    CRNumberPtr timeSub;
    CRBooleanPtr cond;

    if (m_bAutoReverse)
    {
        CRNumberPtr totalTime;
    
        // Invert time from duration to repduration and clamp to
        // zero
        
        if ((totalTime = CRCreateNumber(m_repDuration)) == NULL ||
            (timeSub = CRSub(totalTime, CRLocalTime())) == NULL ||
            (cond = CRLTE(timeSub, zeroTime)) == NULL ||
            (timeSub = (CRNumberPtr) CRCond(cond,
                                            (CRBvrPtr) zeroTime,
                                            (CRBvrPtr) timeSub)) == NULL)
            goto done;
    } else {
        timeSub = durationTime;
    }
    
    // We are localTime until the duration and then we are whatever
    // timeSub is currently set to from above (either clamped for
    // duration time for non-autoreversed or reversed for the autoreverse case)

    if ((cond = CRGTE(CRLocalTime(), durationTime)) == NULL ||
        (timeSub = (CRNumberPtr) CRCond(cond,
                                        (CRBvrPtr) timeSub,
                                        (CRBvrPtr) CRLocalTime())) == NULL)
        goto done;

    // Substitute the clock and clamp to the duration
    
    if (IsContinuousMediaBvr())
    {
        if (!(m_repeat == 0 && m_typeId == CRSOUND_TYPEID))
        {
            if ((curbvr = CRDuration(curbvr, m_segDuration)) == NULL)
                goto done;
        }
    }
    else
    {
        if ((curbvr = CRSubstituteTime(curbvr, timeSub)) == NULL ||
            (curbvr = CRDuration(curbvr, m_repDuration)) == NULL)
            goto done;
    }

    if (m_repeat != 1)
    {
        if (m_repeat == 0)
        {
            curbvr = CRRepeatForever(curbvr);
        }
        else
        {
            curbvr = CRRepeat(curbvr, m_repeat);
        }

        if (curbvr == NULL)
            goto done;
    }

    // We have a total time so add another duration node
    if (m_repeatDur != -1.0f)
    {
        if ((curbvr = CRDuration(curbvr, m_totalRepDuration)) == NULL)
        {
            goto done;
        }
    }
    
    //
    // We now need to add the start and end hold
    //

    // Offset by the start offset
    if ((timeSub = CRSub(CRLocalTime(), GetStartTimeBvr())) == NULL)
    {
        goto done;
    }
        
    if ((cond = CRGTE(timeSub, zeroTime)) == NULL)
    {
        goto done;
    }
        
    if ((timeSub = (CRNumberPtr) CRCond(cond,
                                        (CRBvrPtr) timeSub,
                                        (CRBvrPtr) zeroTime)) == NULL)
    {
        goto done;
    }
    
    // Now add the end hold and reset to 0 local time after the
    // interval

    CRNumberPtr endholdtime;

    if (m_endOffset != 0.0f)
    {
        // There is an offset so we need to hold the end time behavior
        // for the m_endOffset time
        
        if ((cond = CRGT(CRLocalTime(), GetEndTimeBvr())) == NULL)
        {
            goto done;
        }

        CRNumberPtr dur;

        if ((dur = CRSub(GetEndTimeBvr(), GetStartTimeBvr())) == NULL)
        {
            goto done;
        }
        
        if ((timeSub = (CRNumberPtr) CRCond(cond,
                                            (CRBvrPtr) dur,
                                            (CRBvrPtr) timeSub)) == NULL)
        {
            goto done;
        }

        // Now calculate the end hold time.  It is the behavior end of
        // the behavior plus the end hold value
        if ((endholdtime = CRCreateNumber(m_endOffset)) == NULL)
        {
            goto done;
        }
        
        if ((endholdtime = CRAdd(endholdtime, GetEndTimeBvr())) == NULL)
        {
            goto done;
        }
    }
    else
    {
        // The end time is the end time of the behavior
        endholdtime = GetEndTimeBvr();
    }
    
    if ((cond = CRGT(CRLocalTime(), endholdtime)) == NULL)
    {
        goto done;
    }
    
    if ((timeSub = (CRNumberPtr) CRCond(cond,
                                        (CRBvrPtr) zeroTime,
                                        (CRBvrPtr) timeSub)) == NULL)
    {
        goto done;
    }
    
    if ((curbvr = CRSubstituteTime(curbvr, timeSub)) == NULL)
    {
        goto done;
    }
    
    // indicate success
    newBvr = curbvr;
    
  done:
    return newBvr;
}

bool
CMMBaseBvr::UpdateTimeControl(/*bool bReset, double lTime*/)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::UpdateTimeControl()",
              this));

    bool ok = false;

    CRLockGrabber __gclg;

    CRNumberPtr tc;
    DWORD dwFlags;
    
    tc = CRLocalTime();
    dwFlags = CRContinueTimeline;

/*
    if ((tc = CRAdd(GetStartTimeBvr(), CRLocalTime())) == NULL)
    {
        goto done;
    }
*/
    tc = CRLocalTime();
    
    if (!CRSwitchTo((CRBvrPtr) m_timeControl.p,
                    (CRBvrPtr) tc,
                    true,
                    dwFlags,
                    0.0))
        goto done;
    
    ok = true;
  done:
    return ok;
}

bool
CMMBaseBvr::AddStartTimeSink( CMMBaseBvr * sink )
{
    m_startTimeSinks.push_back( sink );
    return true;
}

void
CMMBaseBvr::RemoveStartTimeSink( CMMBaseBvr * sink )
{
    m_startTimeSinks.remove( sink );
}

bool
CMMBaseBvr::AddEndTimeSink( CMMBaseBvr* sink )
{
    m_endTimeSinks.push_back( sink );
    return true;
}

void
CMMBaseBvr::RemoveEndTimeSink( CMMBaseBvr* sink )
{
    m_endTimeSinks.remove( sink );
}

HRESULT
CMMBaseBvr::Begin(bool bAfterOffset)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::Begin(%d)",
              this,
              bAfterOffset));

    HRESULT hr;
    bool ok = false;
    CallBackList l;
    
    // If no parent set this is an error
    if (m_parent == NULL || m_player == NULL)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    if (m_startType == MM_START_WITH ||
        m_startType == MM_START_AFTER)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    // Get the current time of our parent
    double st;

    st = GetContainerSegmentTime();
    if(m_startType == MM_START_EVENT)
    {
        m_lastTick = -MM_INFINITE;
        m_startOnEventTime = st;
    }

    // If our container time is indeterminate then just ignore the
    // call
    if (st == MM_INFINITE || GetParent()->IsPlaying() == false)
    {
        Assert(!IsPlaying());
        
        // Return success: TODO: Need a real error message
        ok = true;
        goto done;
    }
    
    if (!StartTimeVisit(st, &l, bAfterOffset))
    {
        goto done;
    }

    if (!ProcessCBList(l))
    {
        goto done;
    }
    
    m_bPaused = false;
    ok = true;
    
  done:
    return ok?S_OK:Error();
}

HRESULT
CMMBaseBvr::Reset(DWORD fCause)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::Reset()",
              this));

    HRESULT hr;
    bool ok = false;
    CallBackList l;
    MMBaseBvrList::iterator i;
    
    if (m_player == NULL)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    if (m_startType == MM_START_WITH ||
        m_startType == MM_START_AFTER)
    {
        AssertStr(false, _T("Reset called with startType of START_WITH or START_AFTER"));
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    double st;
    st = GetContainerSegmentTime();


    switch(m_startType)
    {
    case MM_START_ABSOLUTE:
        if (st != MM_INFINITE)
        {
            if (!StartTimeVisit(st, &l, false, true, fCause))
            {
                goto done;
            }
        }
        else
        {
            if(!UpdateAbsStartTime(GetStartTime(), true))
            {
                goto done;
            }
            if(!UpdateAbsEndTime(GetAbsStartTime() + GetTotalRepDuration(), true))
            {
                goto done;
            }
        }
        break;
    case MM_START_EVENT:
        double stopTime, startTime, startOffset;
        startOffset = GetStartOffset();
        if( GetAbsStartTime() != MM_INFINITE)
        {
            if(!UpdateAbsStartTime(m_startOnEventTime + startOffset, true))
            {
                goto done;
            }
            if(!UpdateAbsEndTime(GetAbsStartTime() + GetTotalRepDuration(), true))
            {
                goto done;
            }
        }
        stopTime = GetAbsEndTime();
        startTime = GetAbsStartTime();
        if( IsPlaying())
        {
            if( st >= stopTime)
            {
                if (!ProcessEvent(&l, stopTime - GetAbsStartTime(),
                                true,
                                MM_STOP_EVENT, fCause))
                {
                    goto done;
                }
            }
            if( st <= startTime)
            {
                if (!ProcessEvent(&l, 0.0,
                                true,
                                MM_STOP_EVENT, fCause))
                {
                    goto done;
                }
                m_lastTick = -MM_INFINITE;
            }
        }
        else
        {
            if(GetAbsStartTime() == MM_INFINITE) //never played do nothing
                break;
            if (!ProcessEvent(&l, st - GetAbsStartTime(),
                            true,
                            MM_PLAY_EVENT, fCause))
            {
                goto done;
            }
            m_lastTick = -MM_INFINITE;
            
        }
        // Go through all the begin afters and reset them - this means
        // they will get the new end time from this behavior
        
        {
            for (MMBaseBvrList::iterator i = m_endTimeSinks.begin(); 
                 i != m_endTimeSinks.end(); 
                 i++)
            {
                if (FAILED((*i)->End()))
                {
                    goto done;
                }
                
                // Now reset them
                if (!(*i)->ResetBvr(&l))
                {
                    goto done;
                }
            }
        }


        break;
    default:
        break;
    }
    
    if (GetParent())
    {
        if ( !GetParent()->ReconstructBvr(this) )
            goto done;
    }

    if (!ProcessCBList(l))
    {
        goto done;
    }

    // Return error because we could not reconstruct the DA bvr.
    // Note: We do not check for this at the beginning of the function
    // because we want to allow refresh of timing structures by
    // setting a property on the body (editor-clocksourcing bug)
    if (m_parent == NULL)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    ok = true;
    
  done:
    return ok?S_OK:Error();
}

HRESULT
CMMBaseBvr::ResetOnEventChanged(bool bBeginEvent)
{   
    HRESULT hr;
    CallBackList l;
    bool ok = false;
    
    // If no parent set this is an error
    if (m_parent == NULL || m_player == NULL)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    if (m_startType == MM_START_WITH ||
        m_startType == MM_START_AFTER)
    {
        AssertStr(false, _T("Reset called with startType of START_WITH or START_AFTER"));
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    double st;
    st = GetContainerSegmentTime();

    if (bBeginEvent)
    {
        m_startType = MM_START_EVENT;

        // begin event was turned on -- we need to turn off.
        if (!ProcessEvent(&l, st - GetAbsStartTime(),
            true,
            MM_STOP_EVENT, MM_EVENT_PROPERTY_CHANGE))
        {
            goto done;
        }
        
        if ( !UpdateAbsStartTime(MM_INFINITE, true) )
        {
            goto done;
        }
        if ( !UpdateAbsEndTime(MM_INFINITE, true) )
        {
            goto done;
        }
    }
    else
    {
        // end event was turned off -- we need to turn on.
        if ( !UpdateAbsEndTime(GetAbsStartTime() + GetTotalRepDuration(), true) )
        {
            goto done;
        }

        if (!ProcessEvent(&l, st - GetAbsStartTime(),
            true,
            MM_PLAY_EVENT, MM_EVENT_PROPERTY_CHANGE))
        {
            goto done;
        }
    }

    Assert(GetParent() != NULL);
    if (!GetParent()->ReconstructBvr(this))
    {
        goto done;
    }

    if (!ProcessCBList(l))
    {
        goto done;
    }

    ok = true;
done:
    return ok?S_OK:Error();
}
    

HRESULT
CMMBaseBvr::End()
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::End()",
              this));

    HRESULT hr;
    bool ok = false;
    CallBackList l;
    
    // If no parent set this is an error
    if (m_parent == NULL || m_player == NULL)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    // Get the current time of our parent
    double st;

    st = GetContainerSegmentTime();

    // If our container time is indeterminate then just ignore the
    // call
    if (st == MM_INFINITE ||
        !IsPlaying())
    {
        // Return success: TODO: Need a real error message
        ok = true;
        goto done;
    }
    
    if (!EndTimeVisit(st, &l))
    {
        goto done;
    }

    if (!ProcessCBList(l))
    {
        goto done;
    }
    
    m_bPaused = false;
    ok = true;
    
  done:
    return ok?S_OK:Error();
}

HRESULT
CMMBaseBvr::Pause()
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::Pause()",
              this));

    HRESULT hr;
    bool ok = false;
    
    if (!IsPlaying())
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    if (IsPaused())
    {
        m_bPaused = true;
        ok = true;
        goto done;
    }
    
    m_bPaused = true;
    ok = true;
  done:
    return ok?S_OK:Error();
}

HRESULT
CMMBaseBvr::Run()
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::Run()",
              this));

    HRESULT hr;
    bool ok = false;
    
    if (!IsPlaying())
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    if (!IsPaused())
    {
        m_bPaused = false;
        ok = true;
        goto done;
    }
    
    m_bPaused = false;
    ok = true;
  done:
    return ok?S_OK:Error();
}

// This takes times which are post ease (since this is what the user
// sees)

HRESULT
CMMBaseBvr::Seek(double lTime)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::Seek(%g)",
              this,
              lTime));

    bool ok = false;

    // Ensure that the player has been set
    if (NULL == m_player)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    // Enforce rule for seeking only when paused.
    // TODO: this should actually be checking local play state (this->m_state), 
    // but for now we use global play state (m_player->m_state)
    // so we can seek only when whole document is paused
    if(!m_player->IsPaused())
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    // This checks the local play state 
    // (dilipk:) Maybe redundant; looks like local play state is not used anywhere.
    if (!IsPlaying())
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    double curTime;

    curTime = GetCurrentLocalTime();

    if (curTime == MM_INFINITE)
    {
        // I don't think this is possible but just in case handle it
        
        TraceTag((tagError,
                  "Seek: Current time was infinite - not valid"));

        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    if (!_Seek(curTime, lTime))
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

// This takes pure local timeline times (pre-ease)

bool
CMMBaseBvr::_Seek(double curTime, double newTime)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::Seek(%g, %g)",
              this,
              curTime,
              newTime));

    HRESULT hr;
    bool ok = false;
    
    Assert(curTime != MM_INFINITE);
    
    if (curTime == newTime)
    {
        ok = true;
        goto done;
    }
    
    if (IsLocked())
    {
        // Need to determine where to tell our parent to seek to so we
        // are at the new time.

        if (m_parent)
        {
            // TODO: !!!! This does not work - needs to take into
            // where the current parent base code is.
#if 0
            // The code needs to look something like this
            double parentNewTime = 0;
            
            double curParentTime = m_parent->GetCurrentLocalTime();

            // See if we were active last time - if not then use a
            // zero base
            if (curParentTime != MM_INFINITE)
            {
                // Need to calculate the base offset of the parent
                parentNewTime += m_parent->LocalTimeToSegmentBase(curParentTime);

            }
            
#endif
            double parentCurTime = m_parent->ReverseEaseTime(GetAbsStartTime() + curTime);
            double parentNewTime = m_parent->ReverseEaseTime(GetAbsStartTime() + newTime);
        
            hr = THR(m_parent->_Seek(parentCurTime, parentNewTime));

            if (FAILED(hr))
            {
                CRSetLastError(E_FAIL, NULL);
                goto done;
            }
        }
        else
        {
            // This means everything is locked and so we cannot seek
            CRSetLastError(E_FAIL, NULL);
            goto done;
        }
    }
    else
    {
        CallBackList l;

        //
        // if you change the order of this (stop event, play event) you will break a 
        // dependency in mmnotify.cpp : CMMBaseBvr::ProcessEvent(...)
        // jeffwall 2/22/99
        //

        if (!ProcessEvent(&l, curTime, true, MM_STOP_EVENT, MM_EVENT_SEEK))
        {
            goto done;
        }
        
        
        if (!ProcessEvent(&l, newTime, true, MM_PLAY_EVENT, MM_EVENT_SEEK))
        {
            goto done;
        }
        
        // We need to move our start time back by the amount we want to
        // move forward.  This means that we would have started that
        // amount in the past
        if (!UpdateAbsStartTime(GetAbsStartTime() - (newTime - curTime), false))
        {
            goto done;
        }
        
        // Do the same for the end time
        if (!UpdateAbsEndTime(GetAbsEndTime() - (newTime - curTime), true))
        {
            goto done;
        }
        
        // Go through all the begin afters and reset them - this means
        // they will get the new end time from this behavior
        
        {
            for (MMBaseBvrList::iterator i = m_endTimeSinks.begin(); 
                 i != m_endTimeSinks.end(); 
                 i++)
            {
                if (FAILED((*i)->End()))
                {
                    goto done;
                }
                
                // Now reset them
                if (!(*i)->ResetBvr(&l))
                {
                    goto done;
                }
            }
        }

        if (!ProcessCBList(l))
        {
            goto done;
        }
    }
    
    ok = true;
  done:
    return ok;
}

// This takes real times (post-ease)

bool
CMMBaseBvr::Sync(double newTime, double nextGlobalTime)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::Sync(%g, %g)",
              this,
              newTime,
              nextGlobalTime));

    HRESULT hr;
    bool ok = false;
    
    Assert(newTime != MM_INFINITE);
    
    if (IsLocked())
    {
        // Need to determine where to tell our parent to seek to so we
        // are at the new time.

        if (m_parent)
        {
            double parentNewTime = 0;
            
            double curParentTime = m_parent->GetCurrentLocalTime();

            // See if we were active last time - if not then use a
            // zero base
            if (curParentTime != MM_INFINITE)
            {
                // Need to calculate the base offset of the parent
                parentNewTime += m_parent->LocalTimeToSegmentBase(curParentTime);

            }
            
            // Add the start offset
            parentNewTime += GetAbsStartTime();

            // If the newTime 
            if (newTime != -MM_INFINITE)
            {
                parentNewTime += newTime;
            }
            else
            {
                // If we have not started yet and the newtime also
                // indicates that we have not started then we need to
                // make our parent not start yet either
                if (parentNewTime <= 0)
                {
                    parentNewTime = -MM_INFINITE;
                }
            }
        
            hr = THR(m_parent->Sync(parentNewTime, nextGlobalTime));

            if (FAILED(hr))
            {
                CRSetLastError(E_FAIL, NULL);
                goto done;
            }
        }
        else
        {
            // This means everything is locked and so we cannot seek
            CRSetLastError(E_FAIL, NULL);
            goto done;
        }
    }
    else
    {
        double newParentTime = nextGlobalTime;
        
        if (m_parent)
        {
            newParentTime = m_parent->GlobalTimeToLocalTime(newParentTime);
        }
        
        // If our parent is going to end next time them anything we do
        // is irrelevant
        if (newParentTime == MM_INFINITE)
        {
            ok = true;
            goto done;
        }
            
        if (newTime == -MM_INFINITE)
        {
            newTime = -BEGIN_HOLD_EPSILON;
        }
        
        // In order for us to be at newTime next frame take:
        // starttime + localtime == parent time
        // so set starttime = parent time - localtime
        
        if (!UpdateSyncTime(newParentTime - newTime))
        {
            goto done;
        }
    }
    
    ok = true;
  done:
    return ok;
}

bool
CMMBaseBvr::UpdateSyncTime(double newtime)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::UpdateSyncTime(%g)",
              this,
              newtime));

    bool ok = false;

    if (!UpdateAbsStartTime(newtime, true))
    {
        goto done;
    }
    
    // Now update the end time based on the new start time
    if (!UpdateAbsEndTime(GetAbsStartTime() + GetTotalRepDuration(), true))
    {
        goto done;
    }
    
    // Update all the start syncs - unless they are already running
    
    {
        for (MMBaseBvrList::iterator i = m_startTimeSinks.begin(); 
             i != m_startTimeSinks.end(); 
             i++)
        {
            if (!(*i)->IsPlaying())
            {
                if (!(*i)->UpdateSyncTime(GetAbsStartTime()))
                {
                    goto done;
                }
            }
        }
    }

    {
        for (MMBaseBvrList::iterator i = m_endTimeSinks.begin(); 
             i != m_endTimeSinks.end(); 
             i++)
        {
            if (!(*i)->IsPlaying())
            {
                if (!(*i)->UpdateSyncTime(GetAbsEndTime()))
                {
                    goto done;
                }
            }
        }
    }
    
    ok = true;
  done:
    return ok;
}

double
CMMBaseBvr::GetContainerSegmentTime()
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetContainerSegmentTime()",
              this));

    double ret = MM_INFINITE;
    
    if (m_parent)
    {
        ret = m_parent->GetCurrentSegmentTime();
    }
    else if (m_player)
    {
        // We need to get the time from the player itself
        ret = m_player->GetCurrentTime();
    }
    
    return ret;
}

double
CMMBaseBvr::GetCurrentLocalTime()
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetCurrentLocalTime()",
              this));

    double ret = MM_INFINITE;

    if (m_player)
    {
        ret = GlobalTimeToLocalTime(m_player->GetCurrentTime());
    }

    return ret;
}

double
CMMBaseBvr::GetCurrentLocalTimeEx()
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetCurrentLocalTime()",
              this));

    double ret = -MM_INFINITE;

    if (m_player)
    {
        ret = GlobalTimeToLocalTimeEx(m_player->GetCurrentTime());
    }

    return ret;
}

double
CMMBaseBvr::GetCurrentSegmentTime()
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetCurrentSegmentTime()",
              this));

    // Get our container's time
    double ret = GetCurrentLocalTime();

    // If the container's local time is infinite then so is ours
    if (ret != MM_INFINITE)
    {
        ret = LocalTimeToSegmentTime(ret);
    }
    
    return ret;
}

double
CMMBaseBvr::LocalTimeToSegmentBase(double t)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::LocalTimeToSegmentBase(%g)",
              this,
              t));

    double ret = 0;
    
    // Most of this is copied from mmnotify to ensure we calc it the
    // same as the notifications
    if (t != MM_INFINITE && m_segDuration != MM_INFINITE)
    {
        // We need this to round down to the previous boundary
        // point but not inclusive of the boundary point
        // itself.
        int offset = ceil(t / m_segDuration) - 1;
        if (offset < 0)
        {
            offset = 0;
        }
        
        ret = offset * m_segDuration;
    }

    return ret;
}

double
CMMBaseBvr::LocalTimeToSegmentTime(double t)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::LocalTimeToSegmentTime(%g)",
              this,
              t));

    double ret = t;
    
    // Most of this is copied from mmnotify to ensure we calc it the
    // same as the notifications
    if (ret != MM_INFINITE && ret != -MM_INFINITE && m_segDuration != MM_INFINITE)
    {
        // We need this to round down to the previous boundary
        // point but not inclusive of the boundary point
        // itself.
        int offset = ceil(ret / m_segDuration) - 1;
        if (offset < 0)
        {
            offset = 0;
        }
        
        ret = ret - (offset * m_segDuration);

        // If we have autoreverse set and the offset is odd then we
        // are in the reverse segment and need to flip the time to
        // indicate we were moving backwards
        if (m_bAutoReverse && (offset & 0x1))
        {
            ret = m_segDuration - ret;
        }
    }

    // Last thing is we need to ease the time
    
    ret = EaseTime(ret);
    
    return ret;
}

double
CMMBaseBvr::GlobalTimeToLocalTime(double gt)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GlobalTimeToLocalTime(%g)",
              this,
              gt));

    double ret = gt;
    
    if (m_parent)
    {
        ret = m_parent->GlobalTimeToLocalTime(ret);

        if (ret == MM_INFINITE)
        {
            goto done;
        }

        // Now convert to our our segment time
        ret = m_parent->LocalTimeToSegmentTime(ret);
    }
    else
    {
        // Fall through since the parent time is global time
    }
    
    // If we are not inside our range then our local time is
    // infinite
    if (ret >= GetAbsStartTime() &&
        ret <= GetAbsEndTime())
    {
        // Convert our container's time to our local time
        ret = ret - GetAbsStartTime();
    }
    else
    {
        ret = MM_INFINITE;
    }
    
  done:
    return ret;
}


double
CMMBaseBvr::GlobalTimeToLocalTimeEx(double gt)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GlobalTimeToLocalTime(%g)",
              this,
              gt));

    double ret = gt;
    
    if (m_parent)
    {
        ret = m_parent->GlobalTimeToLocalTimeEx(ret);

        if (ret == MM_INFINITE || ret == -MM_INFINITE)
        {
            goto done;
        }

        // Now convert to our our segment time
        ret = m_parent->LocalTimeToSegmentTime(ret);
    }
    else
    {
        // Fall through since the parent time is global time
    }
    
    // If we are not inside our range then our local time is
    // infinite
    if (ret >= GetAbsStartTime() &&
        ret <= GetAbsEndTime())
    {
        // Convert our container's time to our local time
        ret = ret - GetAbsStartTime();
    }
    else if (ret > GetAbsEndTime())
    {
        ret = MM_INFINITE;
    }
    else
    {
        ret = -MM_INFINITE;
    }
    
  done:
    return ret;
}

bool
CMMBaseBvr::UpdateAbsStartTime(double f,
                               bool bUpdateDepTime)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::UpdateAbsStartTime(%g)",
              this,
              f));

    if (bUpdateDepTime)
    {
        m_depStartTime = f;
    }

    m_absStartTime = f;

    CRLockGrabber __gclg;
    return CRSwitchToNumber(m_startTimeBvr, f);
}

bool
CMMBaseBvr::UpdateAbsEndTime(double f,
                             bool bUpdateDepTime)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::UpdateAbsEndTime(%g)",
              this,
              f));

    if (bUpdateDepTime)
    {
        m_depEndTime = f;
    }
    
    m_absEndTime = f;

    CRLockGrabber __gclg;
    return CRSwitchToNumber(m_endTimeBvr, f);
}

// This takes the absolute time to begin.
// If bAfterOffset is true then the time passed in is the time after
// the startoffset, otherwise it is the time before the startoffset

bool 
CMMBaseBvr::StartTimeVisit(double time,
                           CallBackList * l,
                           bool bAfterOffset,
                           bool bReset /* = false */,
                           DWORD fCause /* = 0 */ )
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::StartTimeVisit(%g, %#lx, %d)",
              this,
              time,
              l,
              bAfterOffset));

    bool ok = false;
    double sTime = time;
    
    if (!ResetBvr(l, false))
    {
        goto done;
    }
    
    if (bReset)
    {
        sTime = m_startOffset;
    }
    else if (!bAfterOffset)
    {
        // Need to add our offset to get the real start time
        sTime += m_startOffset;
    }
    
    if (!UpdateAbsStartTime(sTime, true))
    {
        goto done;
    }


    if (!UpdateAbsEndTime(GetAbsStartTime() + GetTotalRepDuration(), true))
    {
        goto done;
    }

    if (!ProcessEvent(l, time - sTime, true, MM_PLAY_EVENT, fCause))
    {
        goto done;
    }
    
    {
        for (MMBaseBvrList::iterator i = m_startTimeSinks.begin(); 
             i != m_startTimeSinks.end(); 
             i++)
        {
            if (!(*i)->StartTimeVisit(sTime, l, false, false, fCause))
            {
                goto done;
            }
        }
    }

    // Go through all the begin afters and reset them - this means
    // they will get the new end time from this behavior
    
    {
        for (MMBaseBvrList::iterator i = m_endTimeSinks.begin(); 
             i != m_endTimeSinks.end(); 
             i++)
        {
            if (FAILED((*i)->End()))
            {
                goto done;
            }

            // Now reset them
            if (!(*i)->ResetBvr(l))
            {
                goto done;
            }
        }
    }
    
    ok = true;
  done:
    return ok;
}

bool 
CMMBaseBvr::EndTimeVisit(double time,
                         CallBackList * l)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::EndTimeVisit(%g, %#lx)",
              this,
              time,
              l));

    bool ok = false;

    if (!UpdateAbsEndTime(time, true))
    {
        goto done;
    }

    // Turn off play variable so we do not get into infinite recursion
    // handling the end sync
    m_bPlaying = false;
    
    if (!ProcessEvent(l, time - GetAbsStartTime(),
                      true,
                      MM_STOP_EVENT, 0))
    {
        goto done;
    }
    
    // Since we only have beginafters and not endwiths call all the
    // starttimevisit methods
    
    {
        for (MMBaseBvrList::iterator i = m_endTimeSinks.begin(); 
             i != m_endTimeSinks.end(); 
             i++)
        {
            if (!(*i)->StartTimeVisit(time, l, false))
            {
                goto done;
            }
        }
    }
    
    ok = true;
  done:
    return ok;
}

bool
CMMBaseBvr::ResetBvr(CallBackList * l,
                     bool bProcessSiblings)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::ResetBvr(%lx, %d)",
              this,
              l,
              bProcessSiblings));

    bool ok = false;

    if (IsPlaying())
    {
        if (!EventNotify(l, 0.0, MM_RESET_EVENT, 0))
        {
            goto done;
        }
    }
    
    // Reset state variables
    
    m_bPlaying = false;
    m_bPaused = false;
    
    m_lastTick = -MM_INFINITE;
    
    switch(m_startType)
    {
      case MM_START_ABSOLUTE:
        if (!UpdateAbsStartTime(m_startOffset, true))
        {
            goto done;
        }

        break;
      case MM_START_EVENT:
        if (!UpdateAbsStartTime(MM_INFINITE, true))
        {
            goto done;
        }

        break;
      case MM_START_WITH:
        Assert(m_startSibling != NULL);

        if (!UpdateAbsStartTime(m_startSibling->GetDepStartTime() + m_startOffset, true))
        {
            goto done;
        }

        break;
      case MM_START_AFTER:
        Assert(m_startSibling != NULL);

        if (!UpdateAbsStartTime(m_startSibling->GetDepEndTime() + m_startOffset, true))
        {
            goto done;
        }

        break;
      default:
        Assert(!"CMMBaseBvr::ResetBvr: Invalid start type");
        break;
    }

    if (!UpdateAbsEndTime(GetAbsStartTime() + GetTotalRepDuration(), true))
    {
        goto done;
    }


    if (bProcessSiblings)
    {
        // Now go through our peers which depend on us and reset them
        
        {
            for (MMBaseBvrList::iterator i = m_startTimeSinks.begin(); 
                 i != m_startTimeSinks.end(); 
                 i++)
            {
                if (!(*i)->ResetBvr(l))
                {
                    goto done;
                }
            }
        }
        
        {
            for (MMBaseBvrList::iterator i = m_endTimeSinks.begin(); 
                 i != m_endTimeSinks.end(); 
                 i++)
            {
                if (!(*i)->ResetBvr(l))
                {
                    goto done;
                }
            }
        }
    }

    ok = true;
  done:
    return ok;
}
    
// This indicates whether the behavior is on the timeline and has not
// finished playing

bool
CMMBaseBvr::IsPlayable(double t)
{
    // If we are on the timeline yet and have not end then we are
    // playable
    
    // If we are on the end time then consider us stopped
    
    return (GetAbsStartTime() != MM_INFINITE &&
            GetAbsEndTime() > t);
}

#if _DEBUG
void
CMMBaseBvr::Print(int spaces)
{
    _TCHAR buf[1024];

    _stprintf(buf, __T("%*s[this = %p, id = %ls, dur = %g, ttrep = %g, tt = %g, rep = %d, autoreverse = %d]\r\n"),
            spaces,"",
            this,
            m_id,
            m_segDuration,
            m_totalRepDuration,
            m_totalDuration,
            m_repeat,
            m_bAutoReverse);

    OutputDebugString(buf);
}
#endif

class __declspec(uuid("f912d958-5c28-11d2-b957-3078302c2030"))
BvrGuid {};

HRESULT WINAPI
CMMBaseBvr::BaseInternalQueryInterface(CMMBaseBvr* pThis,
                                       void * pv,
                                       const _ATL_INTMAP_ENTRY* pEntries,
                                       REFIID iid,
                                       void** ppvObject)
{
    // Do not do an addref but return the original this pointer to
    // give access to the class pointer itself.
    
    if (InlineIsEqualGUID(iid, __uuidof(BvrGuid)))
    {
        *ppvObject = pThis;
        return S_OK;
    }
    
    return CComObjectRootEx<CComSingleThreadModel>::InternalQueryInterface(pv,
                                                                           pEntries,
                                                                           iid,
                                                                           ppvObject);
}
        
CMMBaseBvr *
GetBvr(IUnknown * pbvr)
{
    // This is a total hack to get the original class data.  The QI is
    // implemented above and does NOT do a addref so we do not need to
    // release it
    
    CMMBaseBvr * bvr = NULL;

    if (pbvr)
    {
        pbvr->QueryInterface(__uuidof(BvrGuid),(void **)&bvr);
    }
    
    if (bvr == NULL)
    {
        CRSetLastError(E_INVALIDARG, NULL);
    }
                
    return bvr;
}

DeclareTag(tagClockSync, "Sync", "Clock Sync");

bool
CMMBaseBvr::OnBvrCB(double gTime)
{
    TraceTag((tagClockSync,
              "CMMBaseBvr(%lx)::OnBvrCB(%g)",
              this,
              gTime));

    Assert(IsClockSource());

    if (!IsPlaying() ||
        !IsClockSource() ||
        !m_eventcb)
    {
        goto done;
    }
    
    // TODO:!!!!
    // Need to take into account crossing of our parent's segment
    // boundaries
    
    double dbllastTime;
    dbllastTime = GetCurrentLocalTime();

    if (dbllastTime == MM_INFINITE)
    {
        dbllastTime = -MM_INFINITE;
    }
    
    double dblnextTime;
    dblnextTime = GlobalTimeToLocalTime(gTime);

    // Init the new time to the next time so if they do not do
    // anything we will get the next time
    
    double newtime;
    newtime = dblnextTime;
    
    TraceTag((tagClockSync,
              "CMMBaseBvr(%lx)::OnBvrCB - calling OnTick (%g, %g, %p)",
              this,
              dbllastTime,
              dblnextTime,
              this));

    HRESULT hr;

    hr = m_eventcb->OnTick(dbllastTime,
                           dblnextTime,
                           (ITIMEMMBehavior *)this,
                           &newtime);
    
    TraceTag((tagClockSync,
              "CMMBaseBvr(%lx)::OnBvrCB - return from OnTick (%hr, %g)",
              this,
              hr,
              newtime));

    if (hr != S_OK)
    {
        goto done;
    }
    
    if (newtime == MM_INFINITE)
    {
        // This means that we should have ended.  Ignore this and
        // assume that we will be told to stop using the end method
        
        goto done;
    }
    
    // Our clock can never make us go backwards so check for this and
    // ignore it
    
    // If the newtime is less then the last tick then we are going
    // backwards in time
    // Keep us at the current position
    
    // TODO: Should take into account -MM_INFINITE so that we do not
    // start the behavior - just pass it through
    if (newtime < dbllastTime)
    {
        newtime = dbllastTime;
    }

    TraceTag((tagClockSync,
              "CMMBaseBvr(%lx)::OnBvrCB - calling Sync (%g, %g)",
              this,
              dblnextTime,
              newtime));

    if (dblnextTime == newtime)
    {
        goto done;
    }
    
    if (!Sync(newtime, gTime))
    {
        goto done;
    }
    
  done:
    return true;
} // OnBvrCB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\mmapi\mmfactory.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _MMFACTORY_H
#define _MMFACTORY_H

#include "datime.h"

#define LIBID __T("TIME")

class ATL_NO_VTABLE CMMFactory
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CMMFactory, &CLSID_TIMEMMFactory>,
      public IDispatchImpl<ITIMEMMFactory, &IID_ITIMEMMFactory, &LIBID_TIME>,
      public ISupportErrorInfoImpl<&IID_ITIMEMMFactory>
{
  public:
    CMMFactory();
    ~CMMFactory();

    DA_DECLARE_NOT_AGGREGATABLE(CMMFactory);

    HRESULT FinalConstruct();
#if _DEBUG
    const _TCHAR * GetName() { return __T("CMMFactory"); }
#endif

    DECLARE_REGISTRY(CLSID_TIMEMMFactory,
                     LIBID __T(".MMFactory.1"),
                     LIBID __T(".MMFactory"),
                     0,
                     THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CMMFactory)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ITIMEMMFactory)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP();

    STDMETHOD(CreateBehavior)(LPOLESTR id,
                              IDispatch *bvr,
                              IUnknown **ppOut);
    STDMETHOD(CreateTimeline)(LPOLESTR id,
                              IUnknown **ppOut);
    STDMETHOD(CreatePlayer)(LPOLESTR id,
                            IUnknown *bvr,
                            IServiceProvider * sp,
                            IUnknown **ppOut);
    STDMETHOD(CreateView)(LPOLESTR id,
                          IDispatch * imgbvr,
                          IDispatch * sndbvr,
                          IUnknown * viewsite,
                          IUnknown **ppOut);
    
    HRESULT Error();
};


#endif /* _MMFACTORY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\mmapi\mmease.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmease.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "mmbasebvr.h"

void
CMMBaseBvr::CalculateEaseCoeff()
{
    Assert(m_easeIn >= 0.0f && m_easeIn <= 1.0f);
    Assert(m_easeOut >= 0.0f && m_easeOut <= 1.0f);
    Assert(m_easeInStart >= 0.0f && m_easeInStart <= 1.0f);
    Assert(m_easeOutEnd >= 0.0f && m_easeOutEnd <= 1.0f);

    // We need to ease the behavior if we are not infinite and either
    // ease in or ease out percentagMMes are non-zero
    
    m_bNeedEase = (m_duration != HUGE_VAL &&
                   (m_easeIn > 0.0f || m_easeOut > 0.0f) &&
                   (m_easeIn + m_easeOut <= 1.0f));

    if (!m_bNeedEase) return;
    
    float flEaseInDuration = m_easeIn * m_duration;
    float flEaseOutDuration = m_easeOut * m_duration;
    float flMiddleDuration = m_duration - flEaseInDuration - flEaseOutDuration;
    
    // Compute B1, the velocity during segment B.
    float flInvB1 = (0.5f * m_easeIn * (m_easeInStart - 1.0f) +
                     0.5f * m_easeOut * (m_easeOutEnd - 1.0f) + 1.0f);
    Assert(flInvB1 > 0.0f);
    m_flB1 = 1.0f / flInvB1;
    
    // Basically for accelerated pieces - t = t0 + v0 * t + 1/2 at^2
    // and a = Vend - Vstart / t

    if (flEaseInDuration != 0.0f) {
        m_flA0 = 0.0f;
        m_flA1 = m_easeInStart * m_flB1;
        m_flA2 = 0.5f * (m_flB1 - m_flA1) / flEaseInDuration;
    } else {
        m_flA0 = m_flA1 = m_flA2 = 0.0f;
    }

    m_flB0 = m_flA0 + m_flA1 * flEaseInDuration + m_flA2 * flEaseInDuration * flEaseInDuration;
    
    if (flEaseOutDuration != 0.0f) {
        m_flC0 = m_flB1 * flMiddleDuration + m_flB0;
        m_flC1 = m_flB1;
        m_flC2 = 0.5f * (m_easeOutEnd * m_flB1 - m_flC1) / flEaseOutDuration;
    } else {
        m_flC0 = m_flC1 = m_flC2 = 0.0f;
    }

    m_easeInEnd = flEaseInDuration;
    m_easeOutStart = m_duration - flEaseOutDuration;
}

CRNumberPtr
Quadratic(CRNumberPtr time, float flA, float flB, float flC)
{
    // Assume that the GC lock is acquired
    
    // Need to calculate ax^2 + bx + c

    Assert(time != NULL);

    CRNumberPtr ret = NULL;
    CRNumberPtr accum = NULL;

    if (flC != 0.0f) {
        if ((accum = CRCreateNumber(flC)) == NULL)
            goto done;
    }

    if (flB != 0.0f) {
        CRNumberPtr term;

        if ((term = CRCreateNumber(flB)) == NULL ||
            (term = CRMul(term, time)) == NULL)
            goto done;

        if (accum) {
            if ((term = CRAdd(term, accum)) == NULL)
                goto done;
        }

        accum = term;
    }

    if (flA != 0.0f) {
        CRNumberPtr term;

        if ((term = CRCreateNumber(flA)) == NULL ||
            (term = CRMul(term, time)) == NULL ||
            (term = CRMul(term, time)) == NULL)
            goto done;

        if (accum) {
            if ((term = CRAdd(term, accum)) == NULL)
                goto done;
        }

        accum = term;
    }

    // If all the coeff are zero then just return 0
    
    if (accum == NULL) {
        if ((accum = CRCreateNumber(0.0f)) == NULL)
            goto done;
    }
    
    ret = accum;
    
  done:
    return ret;
}

CRNumberPtr
AddTerm(CRNumberPtr time,
        CRNumberPtr prevTerm,
        float prevDur,
        float flA, float flB, float flC)
{
    CRNumberPtr ret = NULL;
    CRNumberPtr term;
    
    // Offset the time to be zero since that is what the coeffs are
    // based on
    
    if (prevTerm) {
        CRNumberPtr t;
        
        if ((t = CRCreateNumber(prevDur)) == NULL ||
            (time = CRSub(time, t)) == NULL)
            goto done;
    }

    if ((term = Quadratic(time, flA, flB, flC)) == NULL)
        goto done;
    
    // Now we need to conditional use the new term

    if (prevTerm) {
        CRBooleanPtr cond;
        CRNumberPtr zeroTime;
        
        if ((zeroTime = CRCreateNumber(0)) == NULL ||
            (cond = CRLT(time, zeroTime)) == NULL ||
            (term = (CRNumberPtr) CRCond(cond,
                                         (CRBvrPtr) prevTerm,
                                         (CRBvrPtr) term)) == NULL)
            goto done;
    }

    ret = term;
  done:
    return ret;
}

CRNumberPtr
CMMBaseBvr::EaseTime(CRNumberPtr time)
{
    CRNumberPtr ret = NULL;
    CRNumberPtr subTime = NULL;
    
    if (!m_bNeedEase) {
        ret = time;
        goto done;
    }
    
    if (m_easeIn > 0) {
        if ((subTime = AddTerm(time,
                               subTime,
                               0.0,
                               m_flA2, m_flA1, m_flA0)) == NULL)
            goto done;
    }
    
    // If there is space between the end of easing in and the
    // beginning of easing out then we have some constant time
    // interval
    if (m_easeInEnd < m_easeOutStart) {
        if ((subTime = AddTerm(time,
                               subTime,
                               m_easeInEnd,
                               0, m_flB1, m_flB0)) == NULL)
            goto done;
    }

    if (m_easeOut > 0) {
        if ((subTime = AddTerm(time,
                               subTime,
                               m_easeOutStart,
                               m_flC2, m_flC1, m_flC0)) == NULL)
            goto done;
    }
    
    ret = subTime;
    
    Assert(ret);
  done:
    return ret;
}

double
Quadratic(double time, float flA, float flB, float flC)
{
    // Need to calculate ax^2 + bx + c
    // Use x * (a * x + b) + c - since it requires 1 less multiply
    
    return (time * (flA * time + flB) + flC);
}

double
CMMBaseBvr::EaseTime(double time)
{
    if (!m_bNeedEase || time <= 0 || time >= m_duration)
        return time;
    
    if (time <= m_easeInEnd) {
        return Quadratic(time, m_flA2, m_flA1, m_flA0);
    } else if (time < m_easeOutStart) {
        return Quadratic(time - m_easeInEnd, 0.0f, m_flB1, m_flB0);
    } else {
        return Quadratic(time - m_easeOutStart, m_flC2, m_flC1, m_flC0);
    }
}

double
CMMBaseBvr::ReverseEaseTime(double time)
{
    return time;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\mmapi\mmbvr.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "mmbvr.h"
#include "mmtimeline.h"

DeclareTag(tagMMBvr, "API", "CMMBehavior methods");

CMMBehavior::CMMBehavior()
{
    TraceTag((tagMMBvr,
              "CMMBehavior(%lx)::CMMBehavior()",
              this));
}

CMMBehavior::~CMMBehavior()
{
    TraceTag((tagMMBvr,
              "CMMBehavior(%lx)::~CMMBehavior()",
              this));
}

HRESULT
CMMBehavior::Init(LPOLESTR id, IDABehavior * dabvr)
{
    TraceTag((tagMMBvr,
              "CMMBehavior(%lx)::Init(%ls, %lx)",
              this,
              id,
              dabvr));

    HRESULT hr;
    
    CRBvrPtr bvr;
    
    if (!dabvr)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    bvr = COMToCRBvr(dabvr);

    if (!bvr)
    {
        hr = CRGetLastError();
        goto done;
    }

    hr = BaseInit(id, bvr);

    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    return hr;
}

HRESULT
CMMBehavior::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    TraceTag((tagError,
              "CMMBehavior(%lx)::Error(%hr,%ls)",
              this,
              hr,
              str?str:L"NULL"));

    if (str)
        return CComCoClass<CMMBehavior, &__uuidof(CMMBehavior)>::Error(str, IID_ITIMEMMBehavior, hr);
    else
        return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\mmapi\mmfactory.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "mmbvr.h"
#include "mmtimeline.h"
#include "mmplayer.h"
#include "mmview.h"
#include "mmfactory.h"

CMMFactory::CMMFactory()
{
}

CMMFactory::~CMMFactory()
{
}


HRESULT
CMMFactory::FinalConstruct()
{
    if (bFailedLoad)
    {
        return E_FAIL;
    }
    
    return S_OK;
}

STDMETHODIMP
CMMFactory::CreateBehavior(LPOLESTR id,
                           IDispatch *pDisp,
                           IUnknown **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    if (pDisp == NULL)
        return E_POINTER;

    HRESULT hr;
    DAComObject<CMMBehavior> *pNew;
    DAComObject<CMMBehavior>::CreateInstance(&pNew);

    if (!pNew)
    {
        THR(hr = E_OUTOFMEMORY);
    }
    else
    {
        DAComPtr<IDABehavior> pbvr;
        THR(hr = pDisp->QueryInterface(IID_IDABehavior, (void **)&pbvr));
        if (SUCCEEDED(hr))
        {
            THR(hr = pNew->Init(id, pbvr));
            if (SUCCEEDED(hr))
            {
                THR(hr = pNew->QueryInterface(IID_IUnknown, (void **)ppOut));
            }
        }
    }

    if (FAILED(hr))
    {
        delete pNew;
    }

    return hr;
}

STDMETHODIMP
CMMFactory::CreateTimeline(LPOLESTR id,
                           IUnknown **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    DAComObject<CMMTimeline> *pNew;
    DAComObject<CMMTimeline>::CreateInstance(&pNew);

    if (!pNew)
    {
        THR(hr = E_OUTOFMEMORY);
    }
    else
    {
        THR(hr = pNew->Init(id));
        
        if (SUCCEEDED(hr))
        {
            THR(hr = pNew->QueryInterface(IID_IUnknown,
                                          (void **)ppOut));
        }
    }

    if (FAILED(hr))
    {
        delete pNew;
    }

    return hr;
}

STDMETHODIMP
CMMFactory::CreatePlayer(LPOLESTR id,
                         IUnknown * punk,
                         IServiceProvider * sp,
                         IUnknown **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    DAComObject<CMMPlayer> *pNew;
    DAComObject<CMMPlayer>::CreateInstance(&pNew);

    if (!pNew)
    {
        THR(hr = E_OUTOFMEMORY);
    }
    else
    {
        DAComPtr<ITIMEMMBehavior> bvr;

        THR(punk->QueryInterface(IID_ITIMEMMBehavior, (void**)&bvr));
        THR(hr = pNew->Init(id,bvr,sp));
        
        if (SUCCEEDED(hr))
        {
            THR(hr = pNew->QueryInterface(IID_IUnknown,
                                          (void **)ppOut));
        }
    }

    if (FAILED(hr))
    {
        delete pNew;
    }

    return hr;
}

STDMETHODIMP
CMMFactory::CreateView(LPOLESTR id,
                       IDispatch *pimg,
                       IDispatch *psnd,
                       IUnknown  *pUnk,
                       IUnknown **ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    if (pUnk == NULL)
        return E_POINTER;

    DAComObject<CMMView> *pNew;
    DAComObject<CMMView>::CreateInstance(&pNew);

    if (!pNew)
    {
        hr = THR(E_OUTOFMEMORY);
    }
    else
    {
        HRESULT hr1 = S_OK;
        HRESULT hr2 = S_OK;
        DAComPtr<IDAImage> pimgbvr;
        DAComPtr<IDASound> psndbvr;

        if (pimg != NULL)
            hr1 = THR(pimg->QueryInterface(IID_IDAImage, (void**)&pimgbvr));
        if (psnd != NULL)
            hr2 = THR(psnd->QueryInterface(IID_IDASound, (void**)&psndbvr));
        if (SUCCEEDED(hr1) && SUCCEEDED(hr2))
        {
            DAComPtr<ITIMEMMViewSite> site;

            hr = THR(pUnk->QueryInterface(IID_ITIMEMMViewSite, (void**)&site));
            if (SUCCEEDED(hr))
            {
                hr = THR(pNew->Init(id, pimgbvr, psndbvr, site));
                if (SUCCEEDED(hr))
                {
                    hr = THR(pNew->QueryInterface(IID_IUnknown, (void **)ppOut));
                }
            }
        }
    }

    if (FAILED(hr))
    {
        delete pNew;
    }

    return hr;
}

HRESULT
CMMFactory::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    if (str)
    {
        return CComCoClass<CMMFactory, &CLSID_TIMEMMFactory>::Error(str,
                                                                IID_ITIMEMMFactory,
                                                                hr);
    }
    else
    {
        return hr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\mmapi\mmbvr.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _MMBVR_H
#define _MMBVR_H

#include "mmfactory.h"
#include "mmbasebvr.h"

class
__declspec(uuid("ad8888cc-537a-11d2-b955-3078302c2030")) 
ATL_NO_VTABLE CMMBehavior
    : public CComCoClass<CMMBehavior, &__uuidof(CMMBehavior)>,
      public ITIMEMMBehavior,
      public ISupportErrorInfoImpl<&IID_ITIMEMMBehavior>,
      public CMMBaseBvr
{
  public:
    CMMBehavior();
    ~CMMBehavior();

    HRESULT Init(LPOLESTR id, IDABehavior * bvr);
    
#if _DEBUG
    virtual const _TCHAR * GetName() { return __T("CMMBehavior"); }
#endif

    BEGIN_COM_MAP(CMMBehavior)
        COM_INTERFACE_ENTRY(ITIMEMMBehavior)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP();

    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    static inline HRESULT WINAPI
        InternalQueryInterface(CMMBehavior* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject)
    { return BaseInternalQueryInterface(pThis,
                                        (void *) pThis,
                                        pEntries,
                                        iid,
                                        ppvObject); }

    STDMETHOD(get_ID)(LPOLESTR * s)
        { return GetID(s); }
    
    STDMETHOD(put_ID)(LPOLESTR s)
        { return SetID(s); }
        
    STDMETHOD(get_StartOffset)(float * f)
        { return GetStartOffset(f); }
    
    STDMETHOD(put_StartOffset)(float f)
        { return SetStartOffset(f); }
        
    STDMETHOD(get_Duration)(float * pd)
        { return GetDuration(pd); }
    STDMETHOD(put_Duration)(float d)
        { return SetDuration(d); }
        
    STDMETHOD(get_Repeat)(LONG * pr)
        { return GetRepeat(pr); }
    STDMETHOD(put_Repeat)(LONG r)
        { return SetRepeat(r); }
       
    STDMETHOD(get_AutoReverse)(VARIANT_BOOL * pr)
        { return GetAutoReverse(pr); }
    STDMETHOD(put_AutoReverse)(VARIANT_BOOL r)
        { return SetAutoReverse(r); }
        
    STDMETHOD(get_RepeatDur)(float * f)
        { return GetRepeatDur(f); }
    STDMETHOD(put_RepeatDur)(float f)
        { return SetRepeatDur(f); }
        
    STDMETHOD(get_EndOffset)(float * f)
        { return GetEndOffset(f); }
    STDMETHOD(put_EndOffset)(float f)
        { return SetEndOffset(f); }
        
    STDMETHOD(get_EaseIn)(float * pd)
        { return GetEaseIn(pd); }
    STDMETHOD(put_EaseIn)(float d)
        { return SetEaseIn(d); }

    STDMETHOD(get_EaseInStart)(float * pd)
        { return GetEaseInStart(pd); }
    STDMETHOD(put_EaseInStart)(float d)
        { return SetEaseInStart(d); }

    STDMETHOD(get_EaseOut)(float * pd)
        { return GetEaseOut(pd); }
    STDMETHOD(put_EaseOut)(float d)
        { return SetEaseOut(d); }

    STDMETHOD(get_EaseOutEnd)(float * pd)
        { return GetEaseOutEnd(pd); }
    STDMETHOD(put_EaseOutEnd)(float d)
        { return SetEaseOutEnd(d); }

    STDMETHOD(get_SyncFlags)(DWORD * pd)
        { return GetSyncFlags(pd); }
    STDMETHOD(put_SyncFlags)(DWORD d)
        { return SetSyncFlags(d); }

    STDMETHOD(get_EventCB)(ITIMEMMEventCB ** ev)
        { return GetEventCB(ev); }
    STDMETHOD(put_EventCB)(ITIMEMMEventCB * ev)
        { return SetEventCB(ev); }
        
    STDMETHOD(get_TotalTime)(float * pd)
        { return GetTotalTime(pd); }
        
    STDMETHOD(get_DABehavior)(IDABehavior ** bvr)
        { return CMMBaseBvr::GetDABehavior(IID_IDABehavior, (void **)bvr); }

    STDMETHOD(GetDABehavior)(REFIID riid, void ** bvr)
        { return CMMBaseBvr::GetDABehavior(riid, bvr); }

    STDMETHOD(GetResultantBehavior)(REFIID riid, void ** bvr)
        { return CMMBaseBvr::GetResultantBehavior(riid, bvr); }

    STDMETHOD(Begin)(VARIANT_BOOL bAfterOffset)
        { return CMMBaseBvr::Begin(bAfterOffset?true:false); }
    
    STDMETHOD(End)()
        { return CMMBaseBvr::End(); }
    
    STDMETHOD(Pause)()
        { return CMMBaseBvr::Pause(); }
    
    STDMETHOD(Run)()
        { return CMMBaseBvr::Run(); }
    
    STDMETHOD(Seek)(double lTime)
        { return CMMBaseBvr::Seek(lTime); }

    STDMETHOD(Reset)(DWORD fCause)
        { return CMMBaseBvr::Reset(fCause); }

    STDMETHOD(ResetOnEventChanged)(VARIANT_BOOL bBeginEvent)
        { return CMMBaseBvr::ResetOnEventChanged(bBeginEvent?true:false); }

    STDMETHOD(get_LocalTime)(double * d)
        { return GetLocalTime(d); }

    STDMETHOD(get_LocalTimeEx)(double * d)
        { return GetLocalTimeEx(d); }

    STDMETHOD(get_SegmentTime)(double * d)
        { return GetSegmentTime(d); }

    STDMETHOD(get_PlayState)(MM_STATE * state)
        { return GetPlayState(state); }

    STDMETHOD(put_StartType)(MM_START_TYPE st)
        { return PutStartType(st); }

  protected:
    HRESULT Error();
};

#endif /* _MMBVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\mmapi\mmplayer.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "mmplayer.h"
#include "mmbasebvr.h"
#include "mmview.h"

DeclareTag(tagMMPlayer, "API", "CMMPlayer methods");
DeclareTag(tagMMDetailNotify, "API", "Detailed notify");

CMMPlayer::CMMPlayer()
: m_id(NULL),
  m_state(MM_STOPPED_STATE),
  m_bForward(true),
  m_bNeedsUpdate(true),
  m_firstTick(true),
  m_view(NULL)
{
}

CMMPlayer::~CMMPlayer()
{
    Deinit();
}

HRESULT
CMMPlayer::Init(LPOLESTR id,
                ITIMEMMBehavior * bvr,
                IServiceProvider * sp)
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::Init(%ls, %#lx,%#lx)",
              this,
              id,
              bvr,
              sp));
    
    HRESULT hr = S_OK;
    
    Deinit();
    
    if (!bvr || !sp)
    {
        TraceTag((tagError,
                  "CMMPlayer(%lx)::Init: Invalid behavior passed in.",
                  this));
                  
        hr = E_INVALIDARG;
        goto done;
    }

    if (id)
    {
        m_id = CopyString(id);
        
        if (m_id == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    m_sp = sp;
    
    m_view = CRCreateView();

    if (m_view == NULL)
    {
        hr = CRGetLastError();
        goto done;
    }
    
    if (!CRSetServiceProvider(m_view, sp))
    {
        hr = CRGetLastError();
        goto done;
    }
    
    if (!CRSetDC(m_view, NULL))
    {
        hr = CRGetLastError();
        goto done;
    }
    
    if (!CRStartModel(m_view, CREmptyImage(), NULL, 0.0, CRAsyncFlag, NULL))
    {
        hr = CRGetLastError();
        goto done;
    }
    
    CMMBaseBvr * cbvr;

    cbvr = GetBvr(bvr);
    
    if (!cbvr)
    {
        TraceTag((tagError,
                  "CMMPlayer(%lx)::Init: Invalid behavior passed in.",
                  this));
                  
        hr = E_INVALIDARG;
        goto done;
    }

    m_mmbvr = cbvr;
    
    m_mmbvr->SetPlayer(this);

    if (!m_mmbvr->SetParent(NULL, MM_START_ABSOLUTE, NULL))
    {
        hr = CRGetLastError();
        goto done;
    }

    m_playerhook = NEW PlayerHook;

    if (!m_playerhook)
    {
        TraceTag((tagError,
                  "CMMPlayer(%lx)::Init: Out of memory allocating player hook.",
                  this));
                  
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    {
        CRLockGrabber __gclg;

        if (!(m_timeSub = CRModifiableNumber(0.0)))
        {
            hr = CRGetLastError();
            goto done;
        }
        
        if (!UpdateBvr())
        {
            hr = CRGetLastError();
            goto done;
        }

        // Place us in a stopped state
        if (!_Start(0) || !_Stop(0))
        {
            hr = CRGetLastError();
            goto done;
        }
    }

    hr = S_OK;
  done:

    if (FAILED(hr))
    {
        // Clean up now
        Deinit();
    }
    
    return hr;
}

STDMETHODIMP
CMMPlayer::Shutdown()
{
    ViewList::iterator i;

    for (i = m_viewList.begin(); i != m_viewList.end(); i++)
    {
        // Need to call stop on the view to make sure it cleans up
        (*i)->Stop();
    }
    return S_OK;
}

void
CMMPlayer::Deinit()
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::Deinit()",
              this));

    // Ensure the player will not try to call us since we are going away

    if (m_playerhook)
    {
        m_playerhook->SetPlayer(NULL);
        m_playerhook = NULL;
    }

    if (m_mmbvr)
    {
        m_mmbvr->ClearPlayer();
        m_mmbvr = NULL;
    }

    if (m_view)
    {
        CRSetServiceProvider(m_view, NULL);
        CRStopModel(m_view);
        CRDestroyView(m_view);
        m_view = NULL;
    }
        
    m_sp.Release();
    
    delete m_id;
    m_id = NULL;

    BvrCBList::iterator j;
    for (j = m_bvrCBList.begin(); j != m_bvrCBList.end(); j++)
    {
        (*j)->Release();
    }

    // run though and delete the items in the vector.
    ViewList::iterator i;

    for (i = m_viewList.begin(); i != m_viewList.end(); i++)
    {
        // Need to call stop on the view to make sure it cleans up
        (*i)->Stop();
        (*i)->Release();
    }
}

HRESULT
CMMPlayer::get_ID(LPOLESTR * p)
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::get_ID()",
              this));

    HRESULT hr;
    
    CHECK_RETURN_SET_NULL(p);

    if (m_id)
    {
        *p = SysAllocString(m_id);

        if (*p == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    hr = S_OK;
  done:
    return hr;
}

HRESULT
CMMPlayer::put_ID(LPOLESTR s)
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::put_ID(%ls)",
              this,
              s));

    HRESULT hr;

    delete m_id;
    m_id = NULL;

    if (s)
    {
        s = CopyString(s);

        if (s == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    hr = S_OK;
  done:
    return hr;
}
        
STDMETHODIMP
CMMPlayer::get_Behavior(ITIMEMMBehavior ** mmbvr)
{
    CHECK_RETURN_SET_NULL(mmbvr);

    Assert (m_mmbvr);
    
    return m_mmbvr->QueryInterface(IID_ITIMEMMBehavior,
                                   (void **) mmbvr);
}

STDMETHODIMP
CMMPlayer::get_PlayerState(MM_STATE * pstate)
{
    CHECK_RETURN_NULL(pstate);
    
    *pstate = m_state;

    return S_OK;
}

STDMETHODIMP
CMMPlayer::get_CurrentTime(double * d)
{
    CHECK_RETURN_NULL(d);

    *d = m_curTick;

    return S_OK;
}

STDMETHODIMP
CMMPlayer::SetPosition(double lTime)
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::SetPosition(%g)",
              this,
              lTime));

    bool ok = false;

    if (!_Seek(lTime))
    {
        goto done;
    }

    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMPlayer::SetDirection(VARIANT_BOOL bForward)
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::SetDirection(%d)",
              this,
              bForward));

    if (IsStarted())
    {
        TraceTag((tagError,
                  "CMMPlayer(%lx)::SetDirection: Behavior already started.",
                  this));

        return E_FAIL;
    }

    m_bForward = bForward?true:false;
    return S_OK;
}


STDMETHODIMP
CMMPlayer::Play()
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::Play()",
              this));

    bool ok = false;
    CallBackList l;

    if (!IsStopped()) {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
        
    if (!_Start(m_curTick) ||
        !ProcessEvent(l, m_curTick, MM_PLAY_EVENT) ||
        !ProcessCBList(l))
        goto done;

    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMPlayer::Stop()
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::Stop()",
              this));

    bool ok = false;
    CallBackList l;

    if (IsStopped()) {
        ok = true;
        goto done;
    }
    
    if (!_Stop(m_curTick) ||
        !ProcessEvent(l, m_curTick, MM_STOP_EVENT) ||
        !ProcessCBList(l))
        goto done;
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMPlayer::Pause()
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::Pause()",
              this));

    bool ok = false;
    CallBackList l;

    if (IsPaused()) {
        ok = true;
        goto done;
    }
    
    if (IsStopped()) {
        if (FAILED(Play()))
            goto done;
    }
    
    Assert(IsPlaying());
        
    if (!_Pause() ||
        !ProcessEvent(l, m_curTick, MM_PAUSE_EVENT) ||
        !ProcessCBList(l))
        goto done;
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMPlayer::Resume()
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::Resume()",
              this));

    bool ok = false;
    CallBackList l;

    if (IsPlaying()) {
        ok = true;
        goto done;
    } else if (IsStopped()) {
        if (FAILED(Play()))
            goto done;
    } else {
        Assert(IsPaused());
    }
    
    if (!_Resume() ||
        !ProcessEvent(l, m_curTick, MM_RESUME_EVENT) ||
        !ProcessCBList(l))
        goto done;
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMPlayer::AddView(ITIMEMMView * view)
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::AddView(%lx)",
              this,
              view));

    bool ok = false;
    
    // Get the view class from the interface
    
    CMMView * mmview;

    mmview = GetViewFromInterface(view);

    if (mmview == NULL)
    {
        goto done;
    }

    // Start the view
    // This will fail if the view has been added anywhere else (even
    // on this object)
    if (!mmview->Start(*this))
    {
        goto done;
    }
    
    // Now add it last so we do not need to remove it if we fail
    // We need to addref for the list storage
    
    mmview->AddRef();
    m_viewList.push_back(mmview);

    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMPlayer::RemoveView(ITIMEMMView * view)
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::RemoveView(%lx)",
              this,
              view));

    bool ok = false;
    
    // Get the view class from the interface
    
    CMMView * mmview;

    mmview = GetViewFromInterface(view);

    if (mmview == NULL)
    {
        goto done;
    }

    // Stop the view
    // Ignore any failures since we want to clean up as much as
    // possible
    mmview->Stop();
    
    // Remove it from the list

    {
        for (ViewList::iterator i = m_viewList.begin();
             i != m_viewList.end();
             i++)
        {
            if ((*i) == mmview)
            {
                m_viewList.erase(i);
                mmview->Release();
                
                // We know it is only in the list once since we check on
                // add
                // This was done by the start call in addview
                break;
            }
        }
    }

    ok = true;
  done:
    return ok?S_OK:Error();
}

bool
CMMPlayer::_Start(double lTime)
{
    bool ok = false;
    
    CRLockGrabber __gclg;
    
    if (!SetTimeSub(lTime, false))
    {
        goto done;
    }

    m_state = MM_PLAYING_STATE;
    m_curTick = lTime;
    m_firstTick = true;
    m_playerhook->SetPlayer(this);
    
    if (!CRResumeModel(m_view))
    {
        goto done;
    }
    
    {
        // run though and tick the views that we have in our list.
        ViewList::iterator i;
        
        for (i = m_viewList.begin(); i != m_viewList.end(); i++)
        {
            (*i)->Resume();
        }
    }
    
    // Run through the callbacks and make them check their clocks
    {
        // process any callbacks that have been registered
        BvrCBList::iterator j;
        for (j = m_bvrCBList.begin(); j != m_bvrCBList.end(); j++)
        {
            (*j)->OnBvrCB(lTime);
        }
    }

    ok = true;
  done:
    if (!ok)
    {
        _Stop(lTime);
    }

    return ok;
}


bool
CMMPlayer::UpdateBvr()
{
    bool ok = false;
    
#if _DEBUG
    TraceTag((tagError,
              "Player(%#x)",
              this));
    m_mmbvr->Print(2);
#endif

    CRBooleanPtr cond;
    CRNumberPtr zeroTime;
    CRNumberPtr time;
    
    if ((zeroTime = CRCreateNumber(0)) == NULL)
    {
        goto done;
    }
    
    if ((cond = CRLTE(CRLocalTime(), zeroTime)) == NULL)
    {
        goto done;
    }
    
    if ((time = (CRNumberPtr) CRCond(cond,
                                     (CRBvrPtr) zeroTime,
                                     (CRBvrPtr) CRLocalTime())) == NULL)
    {
        goto done;
    }
    
    CRNumberPtr bvrtime;

    if ((bvrtime = (CRNumberPtr) CRSubstituteTime((CRBvrPtr) time, m_timeSub)) == NULL)
    {
        goto done;
    }
    
    if (!m_mmbvr->ConstructBvr(bvrtime))
    {
        TraceTag((tagMMPlayer,
                  "CMMPlayer(%lx)::UpdateBvr() - Error constructing behaviors",
                  this));
        
        goto done;
    }
    
    CRBvrPtr hookBvr;
    
    if ((hookBvr = CRHook((CRBvrPtr) time, m_playerhook)) == NULL)
    {
        TraceTag((tagMMPlayer,
                  "CMMPlayer(%lx)::UpdateBvr() - Error creating bvr hook",
                  this));
        
        goto done;
    }
    
    if ((hookBvr = CRSubstituteTime(hookBvr, m_timeSub)) == NULL)
    {
        goto done;
    }
    
    if (!AddRunningBehavior(hookBvr))
    {
        goto done;
    }

    ok = true;

  done:
    if (!ok)
    {
        m_mmbvr->DestroyBvr();
    }
    
    return ok;
}

bool
CMMPlayer::_Stop(double lTime)
{
    bool ok = true;
    
    m_state = MM_STOPPED_STATE;
    m_playerhook->SetPlayer(NULL);
    
    if (m_view)
    {
        if (!CRPauseModel(m_view))
        {
            goto done;
        }
    }
    
    {
        // run though and tick the views that we have in our list.
        ViewList::iterator i;
        
        for (i = m_viewList.begin(); i != m_viewList.end(); i++)
        {
            (*i)->Pause();
        }
    }
    
    if (!SetTimeSub(lTime, true))
    {
        ok = false;
    }

  done:
    return ok;
}

bool
CMMPlayer::_Pause()
{
    bool ok = false;
    
    if (!CRPauseModel(m_view))
    {
        goto done;
    }
    
    {
        // run though and tick the views that we have in our list.
        ViewList::iterator i;
        
        for (i = m_viewList.begin(); i != m_viewList.end(); i++)
        {
            (*i)->Pause();
        }
    }
    
    if (!SetTimeSub(m_curTick, true))
    {
        goto done;
    }
    
    m_state = MM_PAUSED_STATE;
    
    ok = true;
  done:
    return ok;
}

bool
CMMPlayer::_Resume()
{
    bool ok = false;
    
    if (!CRResumeModel(m_view))
    {
        goto done;
    }
    
    {
        // run though and tick the views that we have in our list.
        ViewList::iterator i;
        
        for (i = m_viewList.begin(); i != m_viewList.end(); i++)
        {
            (*i)->Resume();
        }
    }
    
    if (!SetTimeSub(m_curTick, false))
    {
        goto done;
    }
    
    m_state = MM_PLAYING_STATE;
    
    ok = true;
  done:
    return ok;
}

bool
CMMPlayer::_Seek(double lTime)
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::_Seek(%g)",
              this,
              lTime));

    bool ok = false;

    if (!SetTimeSub(lTime,
                    (m_state != MM_PLAYING_STATE)))
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok;
}

bool
CMMPlayer::SetTimeSub(double lTime, bool bPause)
{
    bool ok = false;
    
    CRLockGrabber __gclg;

    CRNumberPtr tc;
    
    if ((tc = CRCreateNumber(lTime)) == NULL)
        goto done;

    if (!bPause) {
        if (m_bForward) {
            if ((tc = CRAdd(tc, CRLocalTime())) == NULL)
                goto done;
        } else {
            if ((tc = CRSub(tc, CRLocalTime())) == NULL)
                goto done;
        }
    }
    
    if (!CRSwitchTo((CRBvrPtr) m_timeSub.p,
                    (CRBvrPtr) tc,
                    true,
                    CRSwitchCurrentTick,
                    0))
        goto done;

    ok = true;
  done:
    return ok;
}

long
CMMPlayer::AddRunningBehavior(CRBvrPtr bvr)
{
    long ret = 0;

    Assert(m_view);
    Assert(bvr);

    long cookie;

    if (!CRAddBvrToRun(m_view, bvr, true, &cookie))
    {
        goto done;
    }
    
    ret = cookie;

  done:
    return ret;
}

bool
CMMPlayer::RemoveRunningBehavior(long cookie)
{
    bool ok = false;

    Assert(m_view);

    if (!CRRemoveRunningBvr(m_view, cookie))
    {
        goto done;
    }

    ok = true;
  done:
    return ok;
}

STDMETHODIMP
CMMPlayer::Tick(double gTime)
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::Tick(%g)",
              this,
              gTime));

    bool ok = false;
    
    {
        // process any callbacks that have been registered
        BvrCBList::iterator j;
        for (j = m_bvrCBList.begin(); j != m_bvrCBList.end(); j++)
        {
            (*j)->OnBvrCB(gTime);
        }
    }

    // Tick the view
    // We can ignore render since we know we passed in NULL to our
    // view

    // We need to tick first so we fire all events before ticking the
    // real views
    if (!CRTick(m_view, gTime, NULL))
    {
        goto done;
    }
    
    {
        // run though and tick the views that we have in our list.
        ViewList::iterator i;
        
        for (i = m_viewList.begin(); i != m_viewList.end(); i++)
        {
            (*i)->Tick(gTime);
        }
    }
    
    m_firstTick = false;
    ok = true;
  done:
    return ok?S_OK:Error();
}

HRESULT
CMMPlayer::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    if (str)
        return CComCoClass<CMMPlayer, &__uuidof(CMMPlayer)>::Error(str, IID_ITIMEMMPlayer, hr);
    else
        return hr;
}

bool
CMMPlayer::ProcessCB(CallBackList & l,
                     double lTime)
{
    TraceTag((tagMMPlayer,
              "CMMPlayer(%lx)::ProcessCB(%lx, %g)",
              this,
              &l,
              lTime));

    TraceTag((tagMMDetailNotify,
              "ProcessCB(%lx): lTime - %g, m_curTick - %g, firsttick - %d",
              this,
              lTime,
              m_curTick,
              m_firstTick));
    
    if (lTime != m_curTick || m_firstTick)
    {
        double sTime = m_mmbvr->GetAbsStartTime();

        m_mmbvr->ProcessCB(&l,
                           m_curTick - sTime,
                           lTime - sTime,
                           m_bForward,
                           m_firstTick,
                           false);

        m_curTick = lTime;
    }
    
    return true;
}

bool
CMMPlayer::ProcessEvent(CallBackList &l,
                        double lTime,
                        MM_EVENT_TYPE event)
{
    return m_mmbvr->ProcessEvent(&l, (lTime - m_mmbvr->GetAbsStartTime()), m_firstTick, event, 0);
}

void
CMMPlayer::HookCallback(double lTime)
{
    TraceTag((tagMMDetailNotify,
              "HookCallback(%lx): lTime - %, m_curTick - %g, firsttick - %d\n",
              this,
              lTime,
              m_curTick,
              m_firstTick));
    
    if (IsPlaying())
    {
        CallBackList l;
            
        ProcessCB(l,
                  lTime);

        ProcessCBList(l);
    }
}

// While this object is alive we need to keep the DLL from getting
// unloaded

// Start off with a zero refcount
CMMPlayer::PlayerHook::PlayerHook()
: m_cRef(0),
  m_player(NULL)
{
}

CMMPlayer::PlayerHook::~PlayerHook()
{
}

CRSTDAPICB_(CRBvrPtr)
CMMPlayer::PlayerHook::Notify(long id,
                              bool startingPerformance,
                              double startTime,
                              double gTime,
                              double lTime,
                              CRBvrPtr sampleVal,
                              CRBvrPtr curRunningBvr)
{
    if (m_player && !startingPerformance)
    {
#if _DEBUG
        if (m_player->IsPlaying())
        {
            TraceTag((tagMMDetailNotify,
                      "Notify(%lx): id - %lx, lTime - %g, gTime - %g",
                      m_player,
                      id,
                      lTime,
                      gTime));
        }
#endif
        m_player->HookCallback(lTime);
    }
    
    return NULL;
}

bool
CMMPlayer::AddBvrCB(CMMBaseBvr *pbvr)
{
    Assert(pbvr != NULL);

    // Now add it last so we do not need to remove it if we fail
    // We need to addref for the list storage
    pbvr->AddRef();
    m_bvrCBList.push_back(pbvr);
    return S_OK;
} // AddBvrCB

bool
CMMPlayer::RemoveBvrCB(CMMBaseBvr *pbvr)
{
    Assert(pbvr != NULL);
    
    BvrCBList::iterator i;
    for (i = m_bvrCBList.begin(); i != m_bvrCBList.end(); i++)
    {
        if ((*i) == pbvr)
        {
            m_bvrCBList.erase(i);
            pbvr->Release();
            break;
        }
    }
    return S_OK;
} // RemoveBvrCB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\mmapi\mmplayer.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmplayer.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#ifndef _MMPLAYER_H
#define _MMPLAYER_H

#include "mmbasebvr.h"
#include <mshtml.h>
#include <vector>

interface ITIMEMMBehavior;
class CMMView;

typedef std::list< CMMView * > ViewList;
typedef std::list< CMMBaseBvr * > BvrCBList;

class
__declspec(uuid("48ddc6be-5c06-11d2-b957-3078302c2030")) 
ATL_NO_VTABLE CMMPlayer
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CMMPlayer, &__uuidof(CMMPlayer)>,
      public ITIMEMMPlayer,
      public ISupportErrorInfoImpl<&IID_ITIMEMMPlayer>
{
  public:
    CMMPlayer();
    ~CMMPlayer();

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;
    
    HRESULT Init(LPOLESTR id,
                 ITIMEMMBehavior * bvr,
                 IServiceProvider * sp);


    void Deinit();
    
#if _DEBUG
    const _TCHAR * GetName() { return __T("CMMPlayer"); }
#endif

    BEGIN_COM_MAP(CMMPlayer)
        COM_INTERFACE_ENTRY(ITIMEMMPlayer)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP();

    //
    // ITIMEMMPlayer
    //
    
    STDMETHOD(get_ID)(LPOLESTR * s);
    STDMETHOD(put_ID)(LPOLESTR s);
        
    STDMETHOD(Play)();
    STDMETHOD(Stop)();
    STDMETHOD(Pause)();
    STDMETHOD(Resume)();
    STDMETHOD(Shutdown)();
    
    STDMETHOD(get_PlayerState)(MM_STATE *);
        
    STDMETHOD(get_CurrentTime)(double * d);

    STDMETHOD(SetPosition)(double lTime);
    STDMETHOD(SetDirection)(VARIANT_BOOL bForward);
        
    STDMETHOD(get_Behavior)(ITIMEMMBehavior ** mmbvr);

    STDMETHOD(Tick)(double simTime);
    
    STDMETHOD(AddView)(ITIMEMMView * view);
    STDMETHOD(RemoveView)(ITIMEMMView * view);

    //
    // Accessors
    //

    bool IsStopped() { return m_state == MM_STOPPED_STATE; }
    bool IsStarted() { return m_state != MM_STOPPED_STATE; }
    bool IsPlaying() { return m_state == MM_PLAYING_STATE; }
    bool IsPaused() { return m_state == MM_PAUSED_STATE; }

    void Invalidate() { m_bNeedsUpdate = true; }

    void HookCallback(double lTime);

    double GetTotalDuration() { return m_mmbvr->GetTotalDuration(); }

    bool IsFirstTick() { return m_firstTick; }
    double GetCurrentTime() { return m_curTick; }

    long AddRunningBehavior(CRBvrPtr bvr);
    bool RemoveRunningBehavior(long);

    bool AddBvrCB(CMMBaseBvr *pbvr);
    bool RemoveBvrCB(CMMBaseBvr *pbvr);

    // !!This does not addref!!
    IServiceProvider * GetServiceProvider();
  protected:
    bool UpdateBvr();
    bool _Start(double lTime);
    bool _Stop(double lTime);
    bool _Pause();
    bool _Resume();
    bool _Seek(double lTime);
    
    bool ProcessEvent(CallBackList &l,
                      double lTime,
                      MM_EVENT_TYPE event);
    
    bool ProcessCB(CallBackList & l,
                   double lTime);
    
    bool SetTimeSub(double lTime, bool bPause);

    HRESULT Error();
    
  protected:
    LPWSTR m_id;
    DAComPtr<CMMBaseBvr> m_mmbvr;
    DAComPtr<IServiceProvider> m_sp;
    CRViewPtr m_view;
    MM_STATE m_state;
    double m_curTick;
    bool m_bForward;
    bool m_bNeedsUpdate;
    bool m_firstTick;
    
    CRPtr<CRNumber> m_timeSub;
    ViewList m_viewList;
    BvrCBList m_bvrCBList;

    class PlayerHook : public CRBvrHook
    {
      public:
        PlayerHook();
        ~PlayerHook();
        
        virtual CRSTDAPICB_(ULONG) AddRef() { m_cRef++; return m_cRef; }
        virtual CRSTDAPICB_(ULONG) Release() {
            long r = --m_cRef;

            if (r == 0)
                delete this;

            return r;
        }
        
        CRSTDAPICB_(CRBvrPtr) Notify(long id,
                                     bool startingPerformance,
                                     double startTime,
                                     double gTime,
                                     double lTime,
                                     CRBvrPtr sampleVal,
                                     CRBvrPtr curRunningBvr);

        void SetPlayer(CMMPlayer * t) { m_player = t; }

      protected:
        // We do not need a refcount since we are single threaded and
        // the player will NULL it out if it goes away

        CMMPlayer * m_player;
        long m_cRef;
    };

    DAComPtr<PlayerHook> m_playerhook;
};

inline IServiceProvider *
CMMPlayer::GetServiceProvider()
{
    return m_sp;
}

#endif /* _MMPLAYER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\mmapi\mmnotify.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmnotify.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "mmbasebvr.h"
#include "mmtimeline.h"

DeclareTag(tagMMNotify, "API", "Notifications");

// IMPORTANT!!!!!
// This needs to be called in the right order so that we get the
// correct children firing during the current interval but they get
// reset for the next interval. Otherwise we will not get the correct
// results.

bool
CMMBaseBvr::EventNotify(CallBackList * l,
                        double gTime,
                        MM_EVENT_TYPE et,
                        DWORD flags)
{
    TraceTag((tagMMNotify,
              "CMMBaseBvr(%#lx)::Notify(%#x): gTime = %g, event = %s",
              this,
              m_parent,
              gTime,
              EventString(et)));

    bool ok = false;
    
    if (m_eventcb && l)
    {
        CallBackData * data = NEW CallBackData((ITIMEMMBehavior *) this,
                                               m_eventcb,
                                               gTime,
                                               et,
                                               flags);
    
        if (!data)
        {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
        
        l->push_back(data);
    }

    if (et == MM_STOP_EVENT)
    {
        m_bPlaying = false;
    }
    else if (et == MM_PLAY_EVENT)
    {
        m_bPlaying = true;
    }
    
    if (m_parent)
    {
        // Convert time to parents timeline
        if (!m_parent->ParentEventNotify(this,
                                         gTime + GetAbsStartTime(),
                                         et,
                                         flags))
        {
            goto done;
        }
    }
    
    ok = true;
  done:
    return ok;
}

bool
CMMTimeline::EventNotify(CallBackList *l,
                         double gTime,
                         MM_EVENT_TYPE et,
                         DWORD flags)
{
    TraceTag((tagMMNotify,
              "CMMTimeline(%#lx)::Notify(%#x): gTime = %g, event = %s, flags = %lx",
              this,
              m_parent,
              gTime,
              EventString(et),
              flags));

    bool ok = false;
    
    // For Repeat/Autoreverse events we need to make sure we
    // reset all the children of the behavior.
    
    if (et == MM_REPEAT_EVENT ||
        et == MM_AUTOREVERSE_EVENT)
    {
        if (!ResetChildren(l))
        {
            goto done;
        }
    }
    
    if (!CMMBaseBvr::EventNotify(l, gTime, et, flags))
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok;
}

// This is in our local time coordinates - which means that we begin
// at 0.  This needs to be handled by the caller

bool
CMMBaseBvr::ProcessCB(CallBackList * l,
                      double lastTick,
                      double curTime,
                      bool bForward,
                      bool bFirstTick,
                      bool bNeedPlay)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::ProcessCB(lt - %g, m_lt - %g, ct - %g, %d, %d, %d)",
              this,
              lastTick,
              m_lastTick,
              curTime,
              bForward,
              bFirstTick,
              bNeedPlay));

    // The duration is really the end time minus the start time since
    // the user can change it on the fly.  We need to handle this and
    // adjust as appropriate
    
    double totaldur = GetAbsEndTime() - GetAbsStartTime();

    lastTick = m_lastTick;
    
    if (bForward)
    {
        // See if we already pass this entire bvr last time or if we
        // have not got to it yet
        
        // The equality just needs to match what we checked below when
        // we fired the event the frame before.  We need to use LT for
        // curTime since we need to fire when we are 0
        
        if (lastTick >= totaldur || curTime < 0)
        {
            // Need to handle boundary case where we start at the end
            // of the animation.  If so then just fire the stop event
            // since the start was done by the start call itself
            
            if (curTime == totaldur && lastTick == totaldur && bFirstTick)
            {
                // We need this to round down to the previous boundary
                // point but not inclusive of the boundary point
                // itself.
                int offset = ceil(curTime / m_segDuration) - 1;
                if (offset < 0)
                {
                    offset = 0;
                }
                double timeOffset = offset * m_segDuration;

                if (!_ProcessCB(l,
                                lastTick - timeOffset,
                                curTime - timeOffset,
                                bForward,
                                bFirstTick,
                                bNeedPlay,
                                m_bAutoReverse && (offset & 0x1)))
                {
                    return false;
                }

                if (!EventNotify(l, totaldur, MM_STOP_EVENT, 0))
                {
                    return false;
                }
            }

            return true;
        }
        
        // We now know that the last tick was less than the
        // totalrepduration and the current time is greater than the
        // beginning

        // If the last tick was 0 then we fire the start last time
        // since the check above if for less than
        // So the rule is fire when curTime == 0.0
        
        bool bNeedStart = (lastTick < 0 || bNeedPlay);

        if (bNeedStart)
        {
            // This means that we just entered

            if (!EventNotify(l, 0, MM_PLAY_EVENT, 0))
            {
                return false;
            }
        }
        
        if (m_segDuration == MM_INFINITE)
        {
            // Just always process our children if we are infinite
            
            if (!_ProcessCB(l,
                            lastTick,
                            curTime,
                            bForward,
                            bFirstTick,
                            bNeedPlay,
                            false))
            {
                return false;
            }
        }
        else
        {
            // This is the last repeat/bounce boundary we hit
        
            int offset = 0;
            if( lastTick != -MM_INFINITE)
            {
                offset = int(lastTick / m_segDuration);

                if (offset < 0)
                {
                    offset = 0;
                }
            }

            double timeOffset = offset * m_segDuration;

            // Need to clamp our max time so it does not mess up our children
            double maxtime = min(totaldur, curTime);

            while (1)
            {
                // We need to request a reversal of the underlying
                // behavior if we are bouncing and the offset is odd
                
                if (!_ProcessCB(l,
                                lastTick - timeOffset,
                                maxtime - timeOffset,
                                true,
                                bFirstTick,
                                bNeedStart,
                                m_bAutoReverse && (offset & 0x1)))
                {
                    return false;
                }
                
                // We have reach the end of our current period so all
                // children must be stopped.
                
                if (curTime >= (timeOffset + m_segDuration) ||
                    curTime >= totaldur)
                {
                    double t;
                    
                    t = maxtime - timeOffset;
                    
                    if (t > m_segDuration)
                    {
                        t = m_segDuration;
                    }
                    
                    // First fire the end event so they can pass it on
                    // to the parent

                    if (!_ProcessEvent(l,
                                       t,
                                       false,
                                       MM_STOP_EVENT,
                                       m_bAutoReverse && (offset & 0x1),
                                       0))
                    {
                        TraceTag((tagError,
                                  "CMMBaseBvr(%lx)::ProcessCB - _ProcessEvent failed"));

                        return false;
                    }

                    // Now fire the reset so we do not get endholds to
                    // fail
                    
                    if (!_ProcessEvent(l,
                                       t,
                                       false,
                                       MM_RESET_EVENT,
                                       m_bAutoReverse && (offset & 0x1),
                                       0))
                    {
                        TraceTag((tagError,
                                  "CMMBaseBvr(%lx)::ProcessCB - _ProcessEvent failed"));

                        return false;
                    }
                }
                
                offset++;
                timeOffset += m_segDuration;
                
                if (timeOffset > curTime ||
                    timeOffset >= totaldur ||
                    curTime >= totaldur)
                {
                    if (curTime >= totaldur)
                    {
                        // This means we were inside last time but not any more -
                        // generate an exit event
                        
                        if (!EventNotify(l, totaldur, MM_STOP_EVENT, 0))
                        {
                            return false;
                        }
                    }
                    
                    break;
                }
                
                // Indicate a repeat or bounce
                // If we are autoreversing and the offset is odd then it is
                // a reverse and not a repeat
                
                if (m_bAutoReverse && (offset & 0x1))
                {
                    if (!EventNotify(l,
                                     timeOffset,
                                     MM_AUTOREVERSE_EVENT,
                                     0))
                    {
                        return false;
                    }
                }
                else
                {
                    if (!EventNotify(l, timeOffset, MM_REPEAT_EVENT, 0))
                    {
                        return false;
                    }
                }
            }
        }
    } 
    else // we are moving backwards
    {
        // (This is a hack) We move backwards only when Autoreverse is set. At
        // the point of reversal all behaviors are reset. This causes m_lastTick
        // to be set to -MM_INFINITE. This is incorrect for the case when we are
        // moving backwards. m_lastTick should actually be initialized to MM_INFINITY.
        // (makes sense because we are moving from positive infinity to zero)
        // Below we detect and correct this problem.
        if(-MM_INFINITE == lastTick)
        {
            lastTick = MM_INFINITE;
        }

        // See if we already pass this entire bvr last time or if we
        // have not got to it yet
        if (curTime > totaldur || lastTick <= 0)
        {
            if (curTime == 0.0 && lastTick == 0.0 && bFirstTick)
            {
                // Need to handle the boundary case where we start at
                // the beginning going backwards.  The start call
                // itself handles the start event but we need to
                // process the rest of the behaviors to fire the stops

                if (!_ProcessCB(l,
                                lastTick,
                                curTime,
                                bForward,
                                true,
                                bNeedPlay,
                                false))
                {
                    return false;
                }

                if (!EventNotify(l, 0.0, MM_STOP_EVENT, 0))
                {
                    return false;
                }
            }
            
            return true;
        }
        
        // We now know that the last tick was greater than the beginning
        // and the current time less than the total duration. 
        // Below we determine if we need to start playing on the first tick.
        bool bNeedStart = (lastTick >= totaldur || bNeedPlay);
        if (bNeedStart)
        {
            if (!EventNotify(l, totaldur, MM_PLAY_EVENT, 0))
            {
                return false;
            }
            
        }

        if (m_segDuration == MM_INFINITE)
        {
            // Just always process our children if we are infinite
            
            if (!_ProcessCB(l,
                            lastTick,
                            curTime,
                            bForward,
                            bFirstTick,
                            bNeedPlay,
                            false))
            {
                return false;
            }

            if (curTime <= 0)
            {
                if (!EventNotify(l, 0.0, MM_STOP_EVENT, 0))
                {
                    return false;
                }
            }
                
        } else {
            // This will be the repeat point to begin with
            double maxtime = min(lastTick,totaldur);

            int offset;
            double timeOffset;
                
            // This puts us on the last duration boundary greater than
            // the last position

            // It needs to be one greater since our loop decrements
            // first
            offset = int(ceil(maxtime / m_segDuration));
            timeOffset = offset * m_segDuration;
            
            while (1)
            {
                offset--;
                timeOffset -= m_segDuration;
            
                if (!_ProcessCB(l,
                                maxtime - timeOffset,
                                curTime - timeOffset,
                                false,
                                bFirstTick,
                                bNeedStart,
                                m_bAutoReverse && (offset & 0x1)))
                {
                    return false;
                }
                
                if (timeOffset < curTime)
                {
                    break;
                }
                
                // We have reach the end of our current period so all
                // children must be stopped.
                {
                    double t;

                    t = curTime - timeOffset;

                    if (t > m_segDuration)
                    {
                        t = m_segDuration;
                    }
                
                    // First fire the end event so they can pass it on
                    // to the parent

                    if (!_ProcessEvent(l,
                                       t,
                                       false,
                                       MM_STOP_EVENT,
                                       m_bAutoReverse && (offset & 0x1),
                                       0))
                    {
                        return false;
                    }

                    // Now fire the reset so we do not get endholds to
                    // fail
                    
                    if (!_ProcessEvent(l,
                                       t,
                                       false,
                                       MM_RESET_EVENT,
                                       m_bAutoReverse && (offset & 0x1),
                                       0))
                    {
                        return false;
                    }
                }
                
                // If we have reached the end then notify and break
                
                if (offset <= 0)
                {
                    // This means we were inside last time but not any more -
                    // generate an exit event
                    
                    if (!EventNotify(l, 0.0, MM_STOP_EVENT, 0))
                    {
                        return false;
                    }
                    
                    break;
                }
                
                // Indicate a repeat or bounce
                // If we are bouncing and the offset is odd then it is
                // a bounce and not a repeat
                
                if (m_bAutoReverse && (offset & 0x1))
                {
                    if (!EventNotify(l,
                                     timeOffset,
                                     MM_AUTOREVERSE_EVENT,
                                     0))
                    {
                        return false;
                    }
                }
                else
                {
                    if (!EventNotify(l,
                                     timeOffset,
                                     MM_REPEAT_EVENT,
                                     0))
                    {
                        return false;
                    }
                }
            }
        }
    }
    
    m_lastTick = curTime;

    return true;
}

// This is in our local time space

bool
CMMBaseBvr::ProcessEvent(CallBackList * l,
                         double time,
                         bool bFirstTick,
                         MM_EVENT_TYPE et,
                         DWORD flags)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::ProcessEvent(%g, %d, %s, %lx)",
              this,
              time,
              bFirstTick,
              EventString(et),
              flags));

    double totaldur = GetAbsEndTime() - GetAbsStartTime();
    
    // If it is outside of our range then just bail
    if (time < 0 || time > totaldur)
    {
        // (1) Need to update m_lastTick when we are seeking even if 
        // we are out of our range. (2) RESUME is not allowed
        // to update m_lastTick because whenever a 
        // PAUSE -> seek(i.e.STOP+PLAY) -> RESUME 
        // is carried out, RESUME stomps over the 
        // m_lastTick set by the seek. When no seeking is done
        // we should still be fine, since we can assume that
        // a RESUME is always preceeded by a PAUSE, which correctly 
        // sets m_lastTick.
        if ((MM_EVENT_SEEK & flags) && (MM_RESUME_EVENT != et))
        {
            if (MM_PLAY_EVENT == et)
            {
                // hack to make endhold work correctly while seeking fowards (over our lifespan)
                if (m_lastTick < 0 && time > totaldur)
                {
                    EventNotify(l, time, MM_PLAY_EVENT, MM_EVENT_SEEK);
                }
                else 
                {
                    // hack to make endhold work correctly while seeking backwards (over our lifespan)
                    if (time < 0 && m_lastTick > totaldur)
                    {
                        EventNotify(l, time, MM_RESET_EVENT, MM_EVENT_SEEK);
                    }
                }
            }

            m_lastTick = time;
            
            if (!_ProcessEvent(l,
                time,
                bFirstTick,
                et,
                false,
                flags))
            {
                return false;
            }
        }
        return true;
    }

    
    // Plays and Pauses get called on the way down
    if (et == MM_PAUSE_EVENT || et == MM_PLAY_EVENT)
    {
        
        if (!EventNotify(l, time, et, flags))
        {
            return false;
        }

        if (MM_EVENT_SEEK & flags)
        {
            bool bDeleted;
            bDeleted = false;
            for (CallBackList::iterator i = l->begin(); i != l->end(); i++)
            {
                if ( (ITIMEMMBehavior*) this == (*i)->GetBehavior() )
                {
                    if (MM_STOP_EVENT == (*i)->GetEventType() )
                    {
                        CallBackList::iterator j = l->end();
                        for (j--; j != l->begin(); j--)
                        {
                            if ( (ITIMEMMBehavior*) this == (*j)->GetBehavior() )
                            {
                                if ( MM_PLAY_EVENT == (*j)->GetEventType() )
                                {
                                    delete (*j);
                                    delete (*i);                        
                                    
                                    l->erase(i);
                                    l->erase(j);
                                    
                                    bDeleted = true;
                                    
                                    // Get out of inner for loop
                                    break;
                                }
                            }
                        } // for j

                        if (bDeleted)
                            // Get out of outer for loop
                            break;
                    }
                }
            } // for i
        }
    }
    
    if (m_segDuration == MM_INFINITE) {
        // Just always process our children if we are infinite
        
        if (!_ProcessEvent(l,
                           time,
                           bFirstTick,
                           et,
                           false,
                           flags))
        {
            return false;
        }
    } else {
        // This is the last repeat/bounce boundary we hit
        int offset = int(time / m_segDuration);
        
        Assert(offset >= 0);

        // We need to request a reversal of the underlying
        // behavior if we are bouncing and the offset is odd
        
        if (!_ProcessEvent(l,
                           time - (offset * m_segDuration),
                           bFirstTick,
                           et,
                           m_bAutoReverse && (offset & 0x1),
                           flags))
        {
            return false;
        }
    }
    
    // Stops and Resumes get called on the way up
    if (et == MM_STOP_EVENT || et == MM_RESUME_EVENT)
    {
        if (!EventNotify(l, time, et, flags))
        {
            return false;
        }
    }

    // Mark this as the last tick time.
    // RESUME is not allowed to set m_lastTick (See note near the start of this function).
    if (MM_RESUME_EVENT != et)
    {
        m_lastTick = time;
    }
    return true;
}


CallBackData::CallBackData(ITIMEMMBehavior * bvr,
                           ITIMEMMEventCB * eventcb,
                           double time,
                           MM_EVENT_TYPE et,
                           DWORD flags)
: m_bvr(bvr),
  m_eventcb(eventcb),
  m_time(time),
  m_et(et),
  m_flags(flags)
{
    Assert(eventcb);
}

CallBackData::~CallBackData()
{
}

HRESULT
CallBackData::CallEvent()
{
    Assert(m_eventcb);
    
    return THR(m_eventcb->OnEvent(m_time,
                                  m_bvr,
                                  m_et,
                                  m_flags));
}

bool
ProcessCBList(CallBackList &l)
{
    bool ok = true;
    
    for (CallBackList::iterator i = l.begin();
         i != l.end();
         i++) {

        if (FAILED((*i)->CallEvent()))
            ok = false;

        delete (*i);
    }

    l.clear();

    if (!ok)
        CRSetLastError(E_FAIL, NULL);

    return ok;
}

#ifdef _DEBUG

void PrintCBList(CallBackList &l)
{
    TraceTag((tagMMNotify, "Starting PrintCBList"));
    for (CallBackList::iterator i = l.begin(); i != l.end(); i++)
    {
        TraceTag((tagMMNotify,
              "ITIMEMMBehavior(%lx)     Event=%i",
              (*i)->GetBehavior(),
              (*i)->GetEventType() ));
    }
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\mmapi\mmview.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmview.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "mmview.h"
#include "mmplayer.h"

DeclareTag(tagMMView, "API", "CMMView methods");

CMMView::CMMView()
: m_player(NULL),
  m_view(NULL),
  m_hdc(NULL)
{
    TraceTag((tagMMView,
              "CMMView(%lx)::CMMView()",
              this));
}

CMMView::~CMMView()
{
    TraceTag((tagMMView,
              "CMMView(%lx)::~CMMView()",
              this));

    if (m_view)
    {
        CRDestroyView(m_view);
        m_view = NULL;
    }
}

HRESULT
CMMView::Init(LPOLESTR id,
              IDAImage * img,
              IDASound * snd,
              ITIMEMMViewSite * site)
{
    TraceTag((tagMMView,
              "CMMView(%lx)::Init(%ls)",
              this,
              id));
    
    HRESULT hr;

    if (img)
    {
        m_img = (CRImagePtr) COMToCRBvr(img);

        if (!m_img)
        {
            hr = CRGetLastError();
            goto done;
        }
    }

    if (snd)
    {
        m_snd = (CRSoundPtr) COMToCRBvr(snd);

        if (!m_snd)
        {
            hr = CRGetLastError();
            goto done;
        }
    }

    m_view = CRCreateView();

    if (m_view == NULL)
    {
        hr = CRGetLastError();
        goto done;
    }
    
    m_site = site;
    
    hr = S_OK;

  done:

    if (FAILED(hr))
    {
        CRDestroyView(m_view);
        m_view = NULL;
        m_img.Release();
        m_snd.Release();
        m_site.Release();
    }
    
    return hr;
}

STDMETHODIMP
CMMView::Tick()
{
    TraceTag((tagMMView,
              "CMMView(%lx)::Tick()",
              this));

    bool ok = false;
    
    if (!IsStarted())
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    double time;

    time = CRGetSimulationTime(m_view);
    
    if (!Tick(time))
    {
        goto done;
    }

    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMView::Draw(HDC hdc, LPRECT prc)
{
    TraceTag((tagMMView,
              "CMMView(%lx)::Draw(%lx, [%lx, %lx, %lx, %lx])",
              this,
              hdc,
              prc->left,
              prc->right,
              prc->top,
              prc->bottom));

    bool ok = false;
    
    if (!IsStarted())
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    if (hdc)
    {
        RECT rcDeviceBounds = *prc;
//        LPtoDP(hdc, (POINT *) &rcDeviceBounds, 2);

        if (!CRSetViewport(m_view,
                           rcDeviceBounds.left,
                           rcDeviceBounds.top,
                           rcDeviceBounds.right - rcDeviceBounds.left,
                           rcDeviceBounds.bottom - rcDeviceBounds.top))
        {
            goto done;
        }
        
        RECT rcClip;  // in dc coords
        GetClipBox(hdc, &rcClip);
//        LPtoDP(hdc, (POINT *) &rcClip, 2);

        if (!CRSetClipRect(m_view,
                           rcClip.left,
                           rcClip.top,
                           rcClip.right - rcClip.left,
                           rcClip.bottom - rcClip.top))
        {
            goto done;
        }
 
    }

    if (m_hdc != hdc)
    {
        if (!CRSetDC(m_view, hdc))
        {
            goto done;
        }

        // request all of the content to redraw.
        if (!CRRepaint(m_view,
                       prc->left,
                       prc->top,
                       prc->right,
                       prc->bottom))
        {
            goto done;
        }
        
        // cache the DC
        m_hdc = hdc;
    }

    if (!CRRender(m_view))
    {
        goto done;
    }

    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMView::OnMouseMove(double when,
                     LONG xPos, LONG yPos,
                     BYTE modifiers)
{
    TraceTag((tagMMView,
              "CMMView(%lx)::OnMouseMove()",
              this));

    CROnMouseMove(m_view, when, xPos, yPos, modifiers);

    return S_OK;
}

    
STDMETHODIMP
CMMView::OnMouseButton(double when,
                       LONG xPos, LONG yPos,
                       BYTE button,
                       VARIANT_BOOL bPressed,
                       BYTE modifiers)
{
    TraceTag((tagMMView,
              "CMMView(%lx)::OnMouseButton()",
              this));

    CROnMouseButton(m_view,
                    when,
                    xPos,
                    yPos,
                    button,
                    bPressed?true:false,
                    modifiers);

    return S_OK;
}
    
STDMETHODIMP
CMMView::OnKey(double when,
               LONG key,
               VARIANT_BOOL bPressed,
               BYTE modifiers)
{
    TraceTag((tagMMView,
              "CMMView(%lx)::OnKey()",
              this));

    CROnKey(m_view,
            when,
            key,
            bPressed?true:false,
            modifiers);

    return S_OK;
}
    
STDMETHODIMP
CMMView::OnFocus(VARIANT_BOOL bHasFocus)
{
    TraceTag((tagMMView,
              "CMMView(%lx)::OnFocus()",
              this));

    CROnFocus(m_view, bHasFocus?true:false);

    return S_OK;
}

bool
CMMView::Start(CMMPlayer & player)
{
    TraceTag((tagMMView,
              "CMMView(%lx)::Start(%lx)",
              this,
              &player));

    bool ok = false;

    if (m_player != NULL)
    {
        CRSetLastError(E_INVALIDARG, NULL);
        goto done;
    }
    
    if (!CRSetServiceProvider(m_view, player.GetServiceProvider()))
    {
        goto done;
    }
    
    if (!CRSetDC(m_view, NULL))
    {
        goto done;
    }
    
    if (!CRStartModel(m_view, m_img, m_snd, 0.0, CRAsyncFlag, NULL))
    {
        goto done;
    }
    
    // The last thing should be to set the player variable indicating
    // we are started
    
    m_player = &player;
    
    ok = true;
  done:
    return ok;
}

void
CMMView::Stop()
{
    TraceTag((tagMMView,
              "CMMView(%lx)::Stop()",
              this));

    CRSetServiceProvider(m_view, NULL);
    CRStopModel(m_view);
    m_player = NULL;
    
    return;
}

bool
CMMView::Pause()
{
    TraceTag((tagMMView,
              "CMMView(%lx)::Pause()",
              this));

    bool ok = false;
    
    if (!IsStarted())
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    if (!CRPauseModel(m_view))
    {
        goto done;
    }

    ok = true;
    
  done:
    return ok;
}

bool
CMMView::Resume()
{
    TraceTag((tagMMView,
              "CMMView(%lx)::Resume()",
              this));

    bool ok = false;
    
    if (!IsStarted())
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    if (!CRResumeModel(m_view))
    {
        goto done;
    }

    ok = true;
    
  done:
    return ok;
}

bool
CMMView::Tick(double gTime)
{
    TraceTag((tagMMView,
              "CMMView(%lx)::Tick(%g)",
              this,
              gTime));

    bool ok = false;
    bool bNeedRender = false;
    
    if (!IsStarted())
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    if (!CRTick(m_view, gTime, &bNeedRender))
    {
        goto done;
    }

    if (bNeedRender && m_site)
    {
#if 1
        // For now always invalidate everything - there seems to be a
        // bug with this calculation
        IGNORE_HR(m_site->Invalidate(NULL));
#else
        RECT r;

        if (CRGetInvalidatedRects(m_view, 0, 1, &r) == 1)
        {
            IGNORE_HR(m_site->Invalidate(NULL));
        }
        else
        {
            IGNORE_HR(m_site->Invalidate(&r));
        }
#endif
    }
    
    ok = true;
  done:
    return ok;
}

HRESULT
CMMView::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    TraceTag((tagError,
              "CMMView(%lx)::Error(%hr,%ls)",
              this,
              hr,
              str?str:L"NULL"));

    if (str)
        return CComCoClass<CMMView, &__uuidof(CMMView)>::Error(str, IID_ITIMEMMView, hr);
    else
        return hr;
}

class __declspec(uuid("98d6aa3a-9191-11d2-80b9-00c04fa32195"))
ViewGuid {};

HRESULT WINAPI
CMMView::InternalQueryInterface(CMMView* pThis,
                                const _ATL_INTMAP_ENTRY* pEntries,
                                REFIID iid,
                                void** ppvObject)
{
    // Do not do an addref but return the original this pointer to
    // give access to the class pointer itself.
    
    if (InlineIsEqualGUID(iid, __uuidof(ViewGuid)))
    {
        *ppvObject = pThis;
        return S_OK;
    }
    
    return CComObjectRootEx<CComSingleThreadModel>::InternalQueryInterface(pThis,
                                                                           pEntries,
                                                                           iid,
                                                                           ppvObject);
}
        
CMMView *
GetViewFromInterface(IUnknown * pv)
{
    // This is a total hack to get the original class data.  The QI is
    // implemented above and does NOT do a addref so we do not need to
    // release it
    
    CMMView * mmview = NULL;

    if (pv)
    {
        pv->QueryInterface(__uuidof(ViewGuid),(void **)&mmview);
    }
    
    if (mmview == NULL)
    {
        CRSetLastError(E_INVALIDARG, NULL);
    }
                
    return mmview;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\mmapi\mmview.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmview.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _MMVIEW_H
#define _MMVIEW_H

class CMMPlayer;

class
__declspec(uuid("47d014fe-9174-11d2-80b9-00c04fa32195")) 
ATL_NO_VTABLE
CMMView
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CMMView, &__uuidof(CMMView)>,
      public ITIMEMMView,
      public ISupportErrorInfoImpl<&IID_ITIMEMMView>
{
  public:
    CMMView();
    ~CMMView();

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;

    HRESULT Init(LPOLESTR id,
                 IDAImage * img,
                 IDASound * snd,
                 ITIMEMMViewSite * site);

#if _DEBUG
    const _TCHAR * GetName() { return __T("CMMView"); }
#endif

    BEGIN_COM_MAP(CMMView)
        COM_INTERFACE_ENTRY(ITIMEMMView)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP();

    static HRESULT WINAPI
        InternalQueryInterface(CMMView* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject);
    //
    // ITIMEMMView
    //
    
    STDMETHOD(Tick)();
    STDMETHOD(Draw)(HDC dc, LPRECT prc);
    STDMETHOD(OnMouseMove)(double when,
                           LONG xPos, LONG yPos,
                           BYTE modifiers);
    
    STDMETHOD(OnMouseButton)(double when,
                             LONG xPos, LONG yPos,
                             BYTE button,
                             VARIANT_BOOL bPressed,
                             BYTE modifiers);
    
    STDMETHOD(OnKey)(double when,
                     LONG key,
                     VARIANT_BOOL bPressed,
                     BYTE modifiers);
    
    STDMETHOD(OnFocus)(VARIANT_BOOL bHasFocus);

    bool Start(CMMPlayer &);
    bool Pause();
    bool Resume();
    void Stop();

    bool Tick(double gTime);
  protected:
    HRESULT Error();

    CMMPlayer * GetPlayer();
    
    bool IsStarted();
  protected:
    CRViewPtr m_view;
    DAComPtr<ITIMEMMViewSite> m_site;
    CMMPlayer * m_player;
    CRPtr<CRImage> m_img;
    CRPtr<CRSound> m_snd;
    HDC m_hdc;
};

inline CMMPlayer *
CMMView::GetPlayer()
{
    return m_player;
}

inline bool
CMMView::IsStarted()
{
    return m_player != NULL;
}

CMMView * GetViewFromInterface(IUnknown *);

#endif /* _MMVIEW_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\mmapi\mmtimeline.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _MMTIMELINE_H
#define _MMTIMELINE_H

#include "mmplayer.h"

class
__declspec(uuid("0dfe0bae-537c-11d2-b955-3078302c2030")) 
ATL_NO_VTABLE
CMMTimeline
    : public CComCoClass<CMMTimeline, &__uuidof(CMMTimeline)>,
      public ITIMEMMTimeline,
      public ISupportErrorInfoImpl<&IID_ITIMEMMTimeline>,
      public CMMBaseBvr
{
  public:
    CMMTimeline();
    ~CMMTimeline();

    HRESULT Init(LPOLESTR id);
    
    void FinalRelease();

#if _DEBUG
    const _TCHAR * GetName() { return __T("CMMTimeline"); }
#endif

    BEGIN_COM_MAP(CMMTimeline)
        COM_INTERFACE_ENTRY(ITIMEMMBehavior)
        COM_INTERFACE_ENTRY(ITIMEMMTimeline)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP();

    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    static inline HRESULT WINAPI
        InternalQueryInterface(CMMTimeline* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject)
    { return BaseInternalQueryInterface(pThis,
                                        (void *) pThis,
                                        pEntries,
                                        iid,
                                        ppvObject); }

    

    //
    // ITIMEMMTimeline
    //
    
    STDMETHOD(AddBehavior)(ITIMEMMBehavior *bvr,
                           MM_START_TYPE st,
                           ITIMEMMBehavior * basebvr);
    STDMETHOD(RemoveBehavior)(ITIMEMMBehavior *bvr);

    STDMETHOD(get_EndSync)(DWORD * flags);
    STDMETHOD(put_EndSync)(DWORD flags);

    //
    // ITIMEMMBehavior
    //
    
    STDMETHOD(get_ID)(LPOLESTR * s)
        { return GetID(s); }
    
    STDMETHOD(put_ID)(LPOLESTR s)
        { return SetID(s); }
        
    STDMETHOD(get_StartOffset)(float * f)
        { return GetStartOffset(f); }
    
    STDMETHOD(put_StartOffset)(float f)
        { return SetStartOffset(f); }
        
    STDMETHOD(get_Duration)(float * pd)
        { return GetDuration(pd); }
    STDMETHOD(put_Duration)(float d)
        { return SetDuration(d); }
        
    STDMETHOD(get_Repeat)(LONG * pr)
        { return GetRepeat(pr); }
    STDMETHOD(put_Repeat)(LONG r)
        { return SetRepeat(r); }
       
    STDMETHOD(get_AutoReverse)(VARIANT_BOOL * pr)
        { return GetAutoReverse(pr); }
    STDMETHOD(put_AutoReverse)(VARIANT_BOOL r)
        { return SetAutoReverse(r); }
        
    STDMETHOD(get_RepeatDur)(float * f)
        { return GetRepeatDur(f); }
    STDMETHOD(put_RepeatDur)(float f)
        { return SetRepeatDur(f); }
        
    STDMETHOD(get_EndOffset)(float * f)
        { return GetEndOffset(f); }
    STDMETHOD(put_EndOffset)(float f)
        { return SetEndOffset(f); }
        
    STDMETHOD(get_EaseIn)(float * pd)
        { return GetEaseIn(pd); }
    STDMETHOD(put_EaseIn)(float d)
        { return SetEaseIn(d); }

    STDMETHOD(get_EaseInStart)(float * pd)
        { return GetEaseInStart(pd); }
    STDMETHOD(put_EaseInStart)(float d)
        { return SetEaseInStart(d); }

    STDMETHOD(get_EaseOut)(float * pd)
        { return GetEaseOut(pd); }
    STDMETHOD(put_EaseOut)(float d)
        { return SetEaseOut(d); }

    STDMETHOD(get_EaseOutEnd)(float * pd)
        { return GetEaseOutEnd(pd); }
    STDMETHOD(put_EaseOutEnd)(float d)
        { return SetEaseOutEnd(d); }

    STDMETHOD(get_SyncFlags)(DWORD * pd)
        { return GetSyncFlags(pd); }
    STDMETHOD(put_SyncFlags)(DWORD d)
        { return SetSyncFlags(d); }

    STDMETHOD(get_EventCB)(ITIMEMMEventCB ** ev)
        { return GetEventCB(ev); }
    STDMETHOD(put_EventCB)(ITIMEMMEventCB * ev)
        { return SetEventCB(ev); }
        
    STDMETHOD(get_TotalTime)(float * pd)
        { return GetTotalTime(pd); }
        
    STDMETHOD(get_DABehavior)(IDABehavior ** bvr)
        { return CMMBaseBvr::GetDABehavior(IID_IDABehavior, (void **)bvr); }

    STDMETHOD(GetDABehavior)(REFIID riid, void ** bvr)
        { return CMMBaseBvr::GetDABehavior(riid, bvr); }

    STDMETHOD(GetResultantBehavior)(REFIID riid, void ** bvr)
        { return CMMBaseBvr::GetResultantBehavior(riid, bvr); }

    STDMETHOD(Begin)(VARIANT_BOOL bAfterOffset)
        { return CMMBaseBvr::Begin(bAfterOffset?true:false); }
    
    STDMETHOD(End)()
        { return CMMBaseBvr::End(); }
    
    STDMETHOD(Pause)()
        { return CMMBaseBvr::Pause(); }
    
    STDMETHOD(Run)()
        { return CMMBaseBvr::Run(); }
    
    STDMETHOD(Seek)(double lTime)
        { return CMMBaseBvr::Seek(lTime); }

    STDMETHOD(Reset)(DWORD fCause)
        { return CMMBaseBvr::Reset(fCause); }

    STDMETHOD(ResetOnEventChanged)(VARIANT_BOOL bBeginEvent)
        { return CMMBaseBvr::ResetOnEventChanged(bBeginEvent?true:false); }

    STDMETHOD(get_LocalTime)(double * d)
        { return GetLocalTime(d); }

    STDMETHOD(get_LocalTimeEx)(double * d)
        { return GetLocalTimeEx(d); }

    STDMETHOD(get_SegmentTime)(double * d)
        { return GetSegmentTime(d); }

    STDMETHOD(get_PlayState)(MM_STATE * state)
        { return GetPlayState(state); }

    STDMETHOD(put_StartType)(MM_START_TYPE st)
        { return PutStartType(st); }

    virtual bool ConstructBvr(CRNumberPtr timeline);
    virtual void DestroyBvr();

    DWORD GetEndSync() { return m_fEndSync; }
    bool IsLastSync() { return (m_fEndSync & MM_ENDSYNC_LAST) != 0; }
    bool IsFirstSync() { return (m_fEndSync & MM_ENDSYNC_FIRST) != 0; }
  protected:
    HRESULT Error();

    virtual void SetPlayer(CMMPlayer * player);
    virtual void ClearPlayer();

    bool AddBehavior(CMMBaseBvr *bvr,
                     MM_START_TYPE st,
                     CMMBaseBvr * basebvr);
    bool RemoveBehavior(CMMBaseBvr *bvr);
    virtual bool ResetBvr(CallBackList * l,
                          bool bProcessSiblings = true);
    bool CheckEndSync(CallBackList *l);
    
    bool IsChild(CMMBaseBvr *bvr);
    bool IsPending(CMMBaseBvr *bvr);
    
    bool AddToChildren(CMMBaseBvr * bvr);
    void RemoveFromChildren(CMMBaseBvr * bvr);
    
    bool AddToPending(CMMBaseBvr * bvr);
    bool UpdatePending(CMMBaseBvr * bvr, CallBackList * l, double t);
    void RemoveFromPending(CMMBaseBvr * bvr);
    
    bool _ProcessCB(CallBackList * l,
                    double lastTick,
                    double curTime,
                    bool bForward,
                    bool bFirstTick,
                    bool bNeedPlay,
                    bool bNeedsReverse);
    
    bool _ProcessEvent(CallBackList * l,
                       double time,
                       bool bFirstTick,
                       MM_EVENT_TYPE et,
                       bool bNeedsReverse,
                       DWORD flags);
    
    virtual bool EventNotify(CallBackList *l,
                             double lTime,
                             MM_EVENT_TYPE et,
                             DWORD flags);

    virtual bool ParentEventNotify(CMMBaseBvr * bvr,
                                   double lTime,
                                   MM_EVENT_TYPE et,
                                   DWORD flags);
    
    bool ResetChildren(CallBackList * l);

    virtual bool ReconstructBvr(CMMBaseBvr*);

#if _DEBUG
    virtual void Print(int spaces);
#endif
  protected:
    MMBaseBvrList m_children;
    MMBaseBvrList m_pending;
    DWORD         m_fEndSync;
    double        m_endSyncTime;
};

#endif /* _MMTIMELINE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\rsrc\makefile.inc ===
datime.rc : $(SDK_LIB_PATH)\datime.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\mmapi\mmtimeline.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "mmbasebvr.h"
#include "mmtimeline.h"

DeclareTag(tagMMTimeline, "API", "CMMTimeline methods");

CMMTimeline::CMMTimeline()
: m_fEndSync(0),
  m_endSyncTime(MM_INFINITE)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::CMMTimeline()",
              this));
}

CMMTimeline::~CMMTimeline()
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::~CMMTimeline()",
              this));
}

HRESULT
CMMTimeline::Init(LPOLESTR id)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::Init(%ls)",
              this,
              id));
    
    HRESULT hr;

    hr = BaseInit(id, (CRBvrPtr) CRLocalTime());
    
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = S_OK;
  done:
    return hr;
}

void CMMTimeline::FinalRelease()
{
    MMBaseBvrList::iterator i;

    // release bvrs in children list
    for (i = m_children.begin(); i != m_children.end(); i++)
    {
        (*i)->Release();
    }
    m_children.clear();

    // release bvrs in pending list
    for (i = m_pending.begin(); i != m_pending.end(); i++)
    {
        (*i)->Release();
    }
    m_pending.clear();
} // FinalRelease()



STDMETHODIMP
CMMTimeline::AddBehavior(ITIMEMMBehavior *bvr,
                         MM_START_TYPE st,
                         ITIMEMMBehavior * basebvr)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::AddBehavior(%#lx, %d, %#lx)",
              this,
              bvr,
              st,
              basebvr));
    
    CHECK_RETURN_NULL(bvr);

    bool ok = false;
    
    CMMBaseBvr * mmbvr;
    CMMBaseBvr * mmbasebvr;

    mmbvr = GetBvr(bvr);

    if (mmbvr == NULL)
    {
        goto done;
    }
    
    if (mmbvr->GetParent() != NULL)
    {
        CRSetLastError(E_INVALIDARG, NULL);
        goto done;
    }

    if (basebvr)
    {
        mmbasebvr = GetBvr(basebvr);
        
        if (mmbasebvr == NULL)
        {
            goto done;
        }
    }
    else
    {
        mmbasebvr = NULL;
    }
    
    if (!AddBehavior(mmbvr, st, mmbasebvr))
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CMMTimeline::RemoveBehavior(ITIMEMMBehavior *bvr)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::RemoveBehavior(%#lx)",
              this,
              bvr));
    
    CHECK_RETURN_NULL(bvr);

    bool ok = false;
    
    CMMBaseBvr * mmbvr;

    mmbvr = GetBvr(bvr);

    if (mmbvr == NULL)
    {
        goto done;
    }
    
    if (mmbvr->GetParent() != this)
    {
        CRSetLastError(E_INVALIDARG, NULL);
        goto done;
    }

    if (!RemoveBehavior(mmbvr))
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

bool
CMMTimeline::AddBehavior(CMMBaseBvr *bvr,
                         MM_START_TYPE st,
                         CMMBaseBvr * basebvr)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::AddBehavior(%#lx, %d, %#lx)",
              this,
              bvr,
              st,
              basebvr));
    
    Assert(bvr);
    Assert(bvr->GetParent() == NULL);
    
    CallBackList l;
    double t, bvrOffset;
    get_SegmentTime( &t);
    
    bool ok = false;
    
    if (!bvr->SetParent(this, st, basebvr))
    {
        goto done;
    }

    Assert(bvr->GetPlayer() == NULL);
    
    if (GetPlayer() != NULL)
    {
        bvr->SetPlayer(GetPlayer());
    }
    
    // Figure out if our sibling dependent if valid or not
    if (basebvr && !IsChild(basebvr))
    {
        if (basebvr->GetParent() != this &&
            basebvr->GetParent() != NULL)
        {
            CRSetLastError(E_INVALIDARG, NULL);
            goto done;
        }

        // It has not been added to us yet so add this bvr to the
        // pending list
        if (!AddToPending(bvr))
        {
            goto done;
        }
    }
    else
    {
        if (!AddToChildren(bvr))
        {
            goto done;
        }

        if (IsPlaying() && bvr -> GetStartType() == MM_START_ABSOLUTE)
        {
            bvrOffset = bvr -> GetStartOffset();

            if (!bvr->ProcessEvent(&l, t - bvrOffset, true, MM_PLAY_EVENT, 0))
            {
                goto done;
            }

        }

        if (!UpdatePending(bvr, IsPlaying()?(&l):NULL, t))
        {
            goto done;
        }
    }
    
    if (IsPlaying())
    {
        if (!ProcessCBList(l))
        {
            goto done;
        }
    }

    ok = true;
  done:

    if (!ok)
    {
        RemoveBehavior(bvr);
    }
    
    return ok;
}

bool
CMMTimeline::RemoveBehavior(CMMBaseBvr *bvr)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::RemoveBehavior(%#lx)",
              this,
              bvr));
    
    Assert(bvr);
    
    // This needs to be callable even from a partially added behavior
    
    bool ok = false;
    
    bvr->ClearParent();
    bvr->ClearPlayer();
    
    RemoveFromChildren(bvr);
    RemoveFromPending(bvr);
    
    ok = true;

    return ok;
}

bool
CMMTimeline::AddToChildren(CMMBaseBvr * bvr)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::AddToChildren(%#lx)",
              this,
              bvr));

    bool ok = false;
    
    if (!bvr->AttachToSibling())
    {
        goto done;
    }
    
    bvr->AddRef();
    m_children.push_back(bvr);
    
    if (m_resultantbvr)
    {
        if (!bvr->ConstructBvr((CRNumberPtr) m_resultantbvr.p))
        {
            goto done;
        }
    }

    ok = true;
  done:
    return ok;
}

void
CMMTimeline::RemoveFromChildren(CMMBaseBvr * bvr)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::RemoveFromChildren(%#lx)",
              this,
              bvr));

    // TODO: Need to cycle through the children and remove all
    // dependents
    
    for (MMBaseBvrList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        if((*i) == bvr)
        {
            bvr->Release();
        }
    }
    
    m_children.remove(bvr);
}

bool
CMMTimeline::AddToPending(CMMBaseBvr * bvr)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::AddToPending(%#lx)",
              this,
              bvr));

    bool ok = false;
    
    m_pending.push_back(bvr);

    bvr->AddRef();

    ok = true;

    return ok;
}

bool
CMMTimeline::UpdatePending(CMMBaseBvr * bvr, CallBackList * l, double t)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::UpdatePending(%#lx)",
              this,
              bvr));

    bool ok = false;
    
    MMBaseBvrList newlist;
    
    MMBaseBvrList::iterator i = m_pending.begin();

    while (i != m_pending.end())
    {
        // Need to do this so we can erase j if we need to
        MMBaseBvrList::iterator j = i;
        i++;
        
        if((*j)->GetStartSibling() == bvr)
        {
            newlist.push_back(*j);
            // we don't want to call RemoveFromPending() because we
            // don't want the bvr to be deleted at this point. Instead
            // all bvrs in newlist are released at the end, at "done".
            m_pending.erase(j);
        }
    }
    
    for (i = newlist.begin();
         i != newlist.end();
         i++)
    {
        if (!AddToChildren(*i))
        {
            goto done;
        }

        if (l)
        {
            if (!bvr->ProcessEvent(l, t, true, MM_PLAY_EVENT, 0))
            {
                goto done;
            }
        }

        if (!UpdatePending(*i, l ,t))
        {
            goto done;
        }
    }

    ok = true;
  done:
    for (i = newlist.begin();
         i != newlist.end();
         i++)
    {
        (*i)->Release();
    }
    return ok;
}

void
CMMTimeline::RemoveFromPending(CMMBaseBvr * bvr)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::RemoveFromPending(%#lx)",
              this,
              bvr));

    for (MMBaseBvrList::iterator i = m_pending.begin(); 
         i != m_pending.end(); 
         i++)
    {
        if((*i) == bvr)
        {
            bvr->Release();
        }
    }
    
    m_pending.remove(bvr);
}

bool 
CMMTimeline::IsChild(CMMBaseBvr * bvr)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::IsChild(%#lx)",
              this,
              bvr));

    for (MMBaseBvrList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        if((*i) == bvr)
        {
            return true;
        }
    }
    
    return false;
}

bool 
CMMTimeline::IsPending(CMMBaseBvr * bvr)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::IsPending(%#lx)",
              this,
              bvr));

    for (MMBaseBvrList::iterator i = m_pending.begin(); 
         i != m_pending.end(); 
         i++)
    {
        if((*i) == bvr)
        {
            return true;
        }
    }
    
    return false;
}

void
CMMTimeline::SetPlayer(CMMPlayer * player)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::SetPlayer(%#lx)",
              this,
              player));

    CMMBaseBvr::SetPlayer(player);

    for (MMBaseBvrList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        (*i)->SetPlayer(player);
    }
}

void
CMMTimeline::ClearPlayer()
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::ClearPlayer()",
              this));

    CMMBaseBvr::ClearPlayer();
    
    for (MMBaseBvrList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        (*i)->ClearPlayer();
    }
}

bool
CMMTimeline::ReconstructBvr(CMMBaseBvr* pBvr)
{
    bool ok = false;
    Assert(pBvr != NULL);

    pBvr->DestroyBvr();

    if (m_resultantbvr)
    {
        if (!pBvr->ConstructBvr((CRNumberPtr) m_resultantbvr.p))
        {
            goto done;
        }
    }

    ok = true;
done:
    return ok;
}

bool
CMMTimeline::ConstructBvr(CRNumberPtr timeline)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::ConstructBvr()",
              this));

    bool ok = false;
    
    Assert(!m_resultantbvr);
    
    if (!CMMBaseBvr::ConstructBvr(timeline))
    {
        goto done;
    }
    
    Assert(m_resultantbvr);
    
    {
        for (MMBaseBvrList::iterator i = m_children.begin(); 
             i != m_children.end(); 
             i++)
        {
            if (!(*i)->ConstructBvr((CRNumberPtr) m_resultantbvr.p))
            {
                goto done;
            }
        }
    }

    ok = true;
  done:
    return ok;
}

void
CMMTimeline::DestroyBvr()
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::DestroyBvr()",
              this));

    CMMBaseBvr::DestroyBvr();
    
    for (MMBaseBvrList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        (*i)->DestroyBvr();
    }
}

bool
CMMTimeline::ResetBvr(CallBackList * l,
                      bool bProcessSiblings)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::ResetBvr(%lx, %d)",
              this,
              l,
              bProcessSiblings));

    bool ok = false;

    // Call the base class first
    
    if (!CMMBaseBvr::ResetBvr(l, bProcessSiblings))
    {
        goto done;
    }
    
    // Now go through our children

    if (!ResetChildren(l))
    {
        goto done;
    }
    
    m_endSyncTime = MM_INFINITE;
    
    ok = true;
  done:
    return ok;
}
    
bool
CMMTimeline::CheckEndSync(CallBackList *l)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::CMMTimeline(%lx)",
              this,
              &l));
 
    if (IsPlaying() && m_endSyncTime != MM_INFINITE)
    {
        if (!EndTimeVisit(m_endSyncTime, l))
        {
            return false;
        }
    }

    return true;
}

bool
CMMTimeline::_ProcessCB(CallBackList * l,
                        double lastTick,
                        double curTime,
                        bool bForward,
                        bool bFirstTick,
                        bool bNeedPlay,
                        bool bNeedsReverse)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::_ProcessCB(%g, %g, %d, %d, %d, %d)",
              this,
              lastTick,
              curTime,
              bForward,
              bFirstTick,
              bNeedPlay,
              bNeedsReverse));
    
    // If we need to reverse then invert which direct to process our
    // children and invert times for the current frame not our total
    // duration
    
    if (bNeedsReverse)
    {
        // Our caller should ensure that they do not call me to
        // reverse myself if I am infinite
        Assert(m_segDuration != MM_INFINITE);
        
        lastTick = m_segDuration - lastTick;
        curTime = m_segDuration - curTime;
        
        bForward = !bForward;
    }
    
    for (MMBaseBvrList::iterator i = m_children.begin();
         i != m_children.end();
         i++)
    {
        double sTime = (*i)->GetAbsStartTime();

        if (sTime != MM_INFINITE)
        {
            (*i)->ProcessCB(l,
                            EaseTime(lastTick - sTime),
                            EaseTime(curTime - sTime),
                            bForward,
                            bFirstTick,
                            bNeedPlay);
        }

    }
    
    CheckEndSync(l);
    
    return true;
}

bool
CMMTimeline::_ProcessEvent(CallBackList * l,
                           double time,
                           bool bFirstTick,
                           MM_EVENT_TYPE et,
                           bool bNeedsReverse,
                           DWORD flags)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::_ProcessEvent(%g, %d, %s, %d, %lx)",
              this,
              time,
              bFirstTick,
              EventString(et),
              bNeedsReverse,
              flags));
    
    // If we need to reverse then for the current frame not our total
    // duration
    
    if (bNeedsReverse)
    {
        // Our caller should ensure that they do not call me to
        // reverse myself if I am infinite
        Assert(m_segDuration != MM_INFINITE);
        
        time = m_segDuration - time;
    }
    
    for (MMBaseBvrList::iterator i = m_children.begin();
         i != m_children.end();
         i++)
    {
        double sTime = (*i)->GetAbsStartTime();

        if (sTime != MM_INFINITE)
        {
            (*i)->ProcessEvent(l,
                               EaseTime(time - sTime),
                               bFirstTick,
                               et,
                               flags);
        }
    }
        
    CheckEndSync(l);
    
    return true;
}

bool
CMMTimeline::ResetChildren(CallBackList * l)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::ResetChildren(%lx)",
              this,
              l));

    bool ok = true;

    // Need to reset all children
    // Even if we detect a failure process all children and then just
    // return false

    // TODO: Should only really reset non-dependent children since the
    // dependents need to be updated by their sibling
    
    for (MMBaseBvrList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        if (!(*i)->ResetBvr(l))
        {
            ok = false;
        }
    }


    return ok;
}

bool
CMMTimeline::ParentEventNotify(CMMBaseBvr * bvr,
                               double lTime,
                               MM_EVENT_TYPE et,
                               DWORD flags)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::ParentEventNotify(%#lx, %g, %s, %lx)",
              this,
              bvr,
              lTime,
              EventString(et),
              flags));

    bool ok = true;

    Assert(IsChild(bvr));

    switch (et)
    {
      case MM_STOP_EVENT:
        double parentTime;
        parentTime = lTime + bvr->GetAbsStartTime();
        
        if (IsPlaying() && (m_endSyncTime == MM_INFINITE))
        {
            bool bIsEnded;

            if ((m_fEndSync & MM_ENDSYNC_FIRST))
            {
                bIsEnded = true;
            }
            else if (m_fEndSync & MM_ENDSYNC_LAST)
            {
                bIsEnded = true;
                
                for (MMBaseBvrList::iterator i = m_children.begin(); 
                     i != m_children.end(); 
                     i++)
                {
                    // Check each child to see if they are playable.
                    // If none are then this was the last one to stop
                    // and we should setup out endsync time
                    
                    if ((*i)->IsPlayable(parentTime))
                    {
                        bIsEnded = false;
                        break;
                    }
                }
            }
            else
            {
                bIsEnded = false;
            }
            
            if (bIsEnded)
            {
                m_endSyncTime = parentTime;
            }
        }
    }
    
    ok = true;

    return ok;
}
    
HRESULT
CMMTimeline::get_EndSync(DWORD * f)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::get_EndSync()",
              this));

    CHECK_RETURN_NULL(f);

    *f = m_fEndSync;
    return S_OK;
}

HRESULT
CMMTimeline::put_EndSync(DWORD f)
{
    TraceTag((tagMMTimeline,
              "CMMTimeline(%lx)::put_EndSync(%d)",
              this,
              f));

    m_fEndSync = f;

    return S_OK;
}
        
#if _DEBUG
void
CMMTimeline::Print(int spaces)
{
    _TCHAR buf[1024];

    CMMBaseBvr::Print(spaces);
    
    _stprintf(buf, __T("%*s{\r\n"),
            spaces,
            "");

    OutputDebugString(buf);
    
    for (MMBaseBvrList::iterator i = m_children.begin(); 
         i != m_children.end(); 
         i++)
    {
        (*i)->Print(spaces + 2);
    }
    
    _stprintf(buf, __T("%*s}\r\n"),
            spaces,
            "");

    OutputDebugString(buf);
}
#endif

HRESULT
CMMTimeline::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    TraceTag((tagError,
              "CMMTimeline(%lx)::Error(%hr,%ls)",
              this,
              hr,
              str?str:L"NULL"));

    if (str)
        return CComCoClass<CMMTimeline, &__uuidof(CMMTimeline)>::Error(str, IID_ITIMEMMTimeline, hr);
    else
        return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\mmapi\mmprops.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmprops.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "mmbasebvr.h"
#include "mmplayer.h"

HRESULT
CMMBaseBvr::GetID(LPOLESTR * p)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetID()",
              this));

    HRESULT hr;
    
    CHECK_RETURN_SET_NULL(p);

    if (m_id)
    {
        *p = SysAllocString(m_id);

        if (*p == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }
    
    hr = S_OK;
  done:
    return hr;
}

HRESULT
CMMBaseBvr::SetID(LPOLESTR s)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::SetID(%ls)",
              this,
              s));

    HRESULT hr;

    delete m_id;
    m_id = NULL;

    if (s)
    {
        s = CopyString(s);

        if (s == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    hr = S_OK;
  done:
    return hr;
}
        
HRESULT
CMMBaseBvr::GetStartOffset(float * p)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetStartOffset()",
              this));

    CHECK_RETURN_NULL(p);

    *p = m_startOffset;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetStartOffset(float s)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::SetStartOffset(%g)",
              this,
              s));

    m_startOffset = s;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetDuration(float * pdur)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetDuration()",
              this));

    CHECK_RETURN_NULL(pdur);

    *pdur = m_duration;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetDuration(float dur)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::SetDuration(%g)",
              this,
              dur));

    m_duration = dur;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetRepeatDur(float * pr)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetRepeatDur()",
              this));

    CHECK_RETURN_NULL(pr);

    *pr = m_repeatDur;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetRepeatDur(float r)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::SetRepeatDur(%g)",
              this,
              r));

    m_repeatDur = r;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetRepeat(LONG * prepeat)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetRepeat()",
              this));

    CHECK_RETURN_NULL(prepeat);

    *prepeat = m_repeat;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetRepeat(LONG repeat)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::SetRepeat(%d)",
              this,
              repeat));

    m_repeat = repeat;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetAutoReverse(VARIANT_BOOL * pautoreverse)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetAutoReverse()",
              this));

    CHECK_RETURN_NULL(pautoreverse);

    *pautoreverse = m_bAutoReverse;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetAutoReverse(VARIANT_BOOL autoreverse)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::SetAutoReverse(%d)",
              this,
              autoreverse));

    m_bAutoReverse = autoreverse?true:false;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetEndOffset(float * p)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetEndOffset()",
              this));

    CHECK_RETURN_NULL(p);

    *p = m_endOffset;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetEndOffset(float s)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::SetEndOffset(%g)",
              this,
              s));

    m_endOffset = s;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetEventCB(ITIMEMMEventCB ** evcb)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetEventCB()",
              this));

    CHECK_RETURN_SET_NULL(evcb);

    *evcb = m_eventcb;
    if (m_eventcb) m_eventcb->AddRef();

    return S_OK;
}

HRESULT
CMMBaseBvr::SetEventCB(ITIMEMMEventCB * evcb)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::SetEventCB(%lx)",
              this,
              evcb));

    m_eventcb = evcb;
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetEaseIn(float * pd)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetEaseIn()",
              this));

    CHECK_RETURN_NULL(pd);

    *pd = m_easeIn;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetEaseIn(float d)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::SetEaseIn(%g)",
              this,
              d));

    if (d < 0.0 || d > 1.0) return E_INVALIDARG;
    
    m_easeIn = d;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetEaseInStart(float * pd)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetEaseInStart()",
              this));

    CHECK_RETURN_NULL(pd);

    *pd = m_easeInStart;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetEaseInStart(float d)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::SetEaseInStart(%g)",
              this,
              d));

    if (d < 0.0 || d > 1.0) return E_INVALIDARG;

    m_easeInStart = d;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetEaseOut(float * pd)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetEaseOut()",
              this));

    CHECK_RETURN_NULL(pd);

    *pd = m_easeOut;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetEaseOut(float d)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::SetEaseOut(%g)",
              this,
              d));

    if (d < 0.0 || d > 1.0) return E_INVALIDARG;

    m_easeOut = d;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetEaseOutEnd(float * pd)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetEaseOutEnd()",
              this));

    CHECK_RETURN_NULL(pd);

    *pd = m_easeOutEnd;
    return S_OK;
}

HRESULT
CMMBaseBvr::SetEaseOutEnd(float d)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::SetEaseOutEnd(%g)",
              this,
              d));

    if (d < 0.0 || d > 1.0) return E_INVALIDARG;

    m_easeOutEnd = d;

    Invalidate();
    
    return S_OK;
}
        
HRESULT
CMMBaseBvr::GetSyncFlags(DWORD * flags)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetSyncFlags()",
              this));

    CHECK_RETURN_NULL(flags);

    *flags = m_syncFlags;

    return S_OK;
}

HRESULT
CMMBaseBvr::SetSyncFlags(DWORD flags)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::SetSyncFlags(%d)",
              this,
              flags));

    // if we need to registered a Timer Callback, add it to the player.
    if (m_player)
    {
        bool newcs = (flags & MM_CLOCKSOURCE) != 0;
        bool oldcs = IsClockSource();
        
        // If the clock source parameter changed update ourselves in
        // the player
        if (newcs && !oldcs)
        {
            m_player->AddBvrCB(this);
        }
        else if (oldcs && !newcs)
        {
            m_player->RemoveBvrCB(this);
        }
    }

    m_syncFlags = flags;

    return S_OK;
}

HRESULT
CMMBaseBvr::GetTotalTime(float * pr)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetTotalTime()",
              this));

    CHECK_RETURN_NULL(pr);

    *pr = m_totalDuration;
    return S_OK;
}


HRESULT
CMMBaseBvr::GetDABehavior(REFIID riid, void ** bvr)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetDABehavior()",
              this));

    CHECK_RETURN_SET_NULL(bvr);

    Assert(m_rawbvr);

    if (!CRBvrToCOM(m_rawbvr,
                    riid,
                    bvr))
        return Error();
    
    return S_OK;
}

HRESULT
CMMBaseBvr::GetResultantBehavior(REFIID riid, void ** bvr)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetResultantBehavior()",
              this));

    CHECK_RETURN_SET_NULL(bvr);

    if (m_resultantbvr)
    {
        if (!CRBvrToCOM(m_resultantbvr,
                        riid,
                        bvr))
        {
            return Error();
        }
    }
    
    return S_OK;
}

HRESULT
CMMBaseBvr::GetLocalTime(double * d)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetLocalTime()",
              this));

    CHECK_RETURN_NULL(d);

    *d = GetCurrentLocalTime();
    
    return S_OK;
}

HRESULT
CMMBaseBvr::GetLocalTimeEx(double * d)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetLocalTimeEx()",
              this));

    CHECK_RETURN_NULL(d);

    *d = GetCurrentLocalTimeEx();

    return S_OK;
}

HRESULT
CMMBaseBvr::GetSegmentTime(double * d)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetSegmentTime()",
              this));

    CHECK_RETURN_NULL(d);

    *d = GetCurrentSegmentTime();
    
    return S_OK;
}

HRESULT
CMMBaseBvr::GetPlayState(MM_STATE * state)
{
    TraceTag((tagMMBaseBvr,
              "CMMBaseBvr(%lx)::GetPlayState()",
              this));

    CHECK_RETURN_NULL(state);

    double t = GetCurrentLocalTime();
    
    if(m_bPlaying == false)
    {
        *state = MM_STOPPED_STATE;
        }
    else
    {
        *state = m_bPaused?MM_PAUSED_STATE:MM_PLAYING_STATE;
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\mmapi\util.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include <mshtml.h>

#define DISPID_GETSAFEARRAY -2700

#define IS_VARTYPE(x,vt) ((V_VT(x) & VT_TYPEMASK) == (vt))
#define IS_VARIANT(x) IS_VARTYPE(x,VT_VARIANT)
#define GET_VT(x) (V_VT(x) & VT_TYPEMASK)

SafeArrayAccessor::SafeArrayAccessor(VARIANT & v,
                                     bool canBeNull)
: _inited(false),
  _isVar(false),
  _s(NULL),
  _failed(true),
  _allocArr(NULL)
{
    HRESULT hr;
    VARIANT *pVar;

    // Check if it is a reference to another variant
    
    if (V_ISBYREF(&v) && !V_ISARRAY(&v) && IS_VARIANT(&v))
        pVar = V_VARIANTREF(&v);
    else
        pVar = &v;

    // Check for an array
    if (!V_ISARRAY(pVar)) {
        // For JSCRIPT
        // See if it is a IDispatch and see if we can get a safearray from
        // it
        if (!IS_VARTYPE(pVar,VT_DISPATCH)) {
            if (canBeNull && (IS_VARTYPE(pVar, VT_EMPTY) ||
                              IS_VARTYPE(pVar, VT_NULL))) {

                
                // if we allow empty, then just set the safearray
                // to null.
                _s = NULL;
                _v = NULL;
                _ubound = _lbound = 0;
                _inited = true;
                _failed = false;
                return;
            } else {
                CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
                return;
            }
        }

        IDispatch * pdisp;
        
        if (V_ISBYREF(pVar))
            pdisp = *V_DISPATCHREF(pVar);
        else
            pdisp = V_DISPATCH(pVar);
    
        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
        
        // Need to pass in a VARIANT that we own and will free.  Use
        // the internal _retVar parameter
        
        hr = pdisp->Invoke(DISPID_GETSAFEARRAY,
                           IID_NULL,
                           LCID_SCRIPTING,
                           DISPATCH_METHOD|DISPATCH_PROPERTYGET,
                           &dispparamsNoArgs,
                           &_retVar, NULL, NULL);
        
        if (FAILED(hr)) {
            CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
            return;
        }
        
        // No need to check for a reference since you cannot return
        // VARIANT references
        pVar = &_retVar;
        
        // Check for an array
        if (!V_ISARRAY(pVar)) {
            CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
            return;
        }
    }
    
    // See if it is a variant
    
    if (IS_VARIANT(pVar))
        _isVar = true;
    else if (!IS_VARTYPE(pVar,VT_UNKNOWN) &&
             !IS_VARTYPE(pVar,VT_DISPATCH)) {
        CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
        return;
    }

    if (V_ISBYREF(pVar))
        _s = *V_ARRAYREF(pVar);
    else
        _s = V_ARRAY(pVar);
    
    if (_s == NULL) {
        if (canBeNull) {
            _v = NULL;
            _ubound = _lbound = 0;
            _inited = true;
            _failed = false;
            return;
        } else {
            CRSetLastError (E_INVALIDARG,NULL);
            return;
        }
    }

    if (SafeArrayGetDim(_s) != 1) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }

    hr = SafeArrayGetLBound(_s,1,&_lbound);
        
    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    hr = SafeArrayGetUBound(_s,1,&_ubound);
        
    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    hr = SafeArrayAccessData(_s,(void **)&_v);

    if (FAILED(hr)) {
        CRSetLastError (E_INVALIDARG,NULL);
        return;
    }
        
    _inited = true;

    // If it is a variant see if they are objects or not

    if (_isVar) {
        int size = GetArraySize();
        
        if (size > 0) {
            // Check the first argument to see its type

            VARIANT * pVar = &_pVar[0];

            // Check if it is a reference to another variant
            
            if (V_ISBYREF(pVar) && !V_ISARRAY(pVar) && IS_VARIANT(pVar))
                pVar = V_VARIANTREF(pVar);

            // Check if it is an object
            if (!IS_VARTYPE(pVar,VT_UNKNOWN) &&
                !IS_VARTYPE(pVar,VT_DISPATCH)) {
                CRSetLastError (DISP_E_TYPEMISMATCH,NULL);
                return;
            }

            _allocArr = (IUnknown **) malloc(size * sizeof (IUnknown *));

            if (_allocArr == NULL) {
                CRSetLastError(E_OUTOFMEMORY, NULL);
                return;
            }

            for (int i = 0; i < size; i++) {
                CComVariant var;
                HRESULT hr = var.ChangeType(VT_UNKNOWN, &_pVar[i]);
                
                if (FAILED(hr)) {
                    CRSetLastError(DISP_E_TYPEMISMATCH,NULL);
                    return;
                }
                
                _allocArr[i] = var.punkVal;
            }
        }
    }

    _failed = false;
}

SafeArrayAccessor::~SafeArrayAccessor()
{
    if (_inited && _s)
        SafeArrayUnaccessData(_s);
}

#if 0
HRESULT
CallScript(IOleClientSite * pClient,
           LPWSTR fun,
           IDispatch * disp,
           DWORD dwData)
{
    DISPID dispid;
    DAComPtr<IOleContainer> pRoot;
    DAComPtr<IHTMLDocument> pHTMLDoc;
    DAComPtr<IDispatch> pDispatch;
    CRBvrPtr bvr = NULL;
    DAComPtr<IDABehavior> event;
    DAComPtr<IDABehavior> curBvr;
    CComVariant retVal;
    HRESULT hr = E_INVALIDARG;
        
    if (!pClient) goto done;
    
    {
        CComBSTR bstrfun(fun);
        
        if (FAILED(hr = pClient->GetContainer(&pRoot)) ||
            FAILED(hr = pRoot->QueryInterface(IID_IHTMLDocument, (void **)&pHTMLDoc)) ||
            FAILED(hr = pHTMLDoc->get_Script(&pDispatch)) ||
            FAILED(hr = pDispatch->GetIDsOfNames(IID_NULL, &bstrfun, 1,
                                                 LCID_SCRIPTING,
                                                 &dispid))) {
            goto done;
        }
    }

        
    // paramters needed to be pushed in reverse order
    VARIANT rgvarg[2];
    rgvarg[1].vt = VT_DISPATCH;
    rgvarg[1].pdispVal = disp;
    rgvarg[0].vt = VT_I4;
    rgvarg[0].lVal = dwData;
    
    DISPPARAMS dp;
    dp.cNamedArgs = 0;
    dp.rgdispidNamedArgs = 0;
    dp.cArgs = 2;
    dp.rgvarg = rgvarg;
    
    hr = pDispatch->Invoke(dispid, IID_NULL,
                           LCID_SCRIPTING, DISPATCH_METHOD,
                           &dp, &retVal, NULL, NULL);

    if (FAILED(hr)) {
        goto done;
    }

  done:
    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\array.cpp ===
//************************************************************
//
// FileName:        array.cpp
//
// Created:         01/28/98
//
// Author:          TWillie
// 
// Abstract:        Declaration of the array templates
//************************************************************

#include "headers.h"
#include "array.h"

#define CFORMSARY_MAXELEMSIZE    128

//  CImplAry class

//
//  NOTE that this file does not include support for artificial
//    error simulation.  There are common usage patterns for arrays
//    which break our normal assumptions about errors.  For instance,
//    ary.EnsureSize() followed by ary.Append(); code which makes
//    this sequence of calls expects ary.Append() to always succeed.
//
//    Because of this, the Ary methods do not use THR internally.
//    Instead, the code which is calling Ary is expected to follow
//    the normal THR rules and use THR() around any call to an
//    Ary method which could conceivably fail.
//
//    This relies on the Ary methods having solid internal error
//    handling, since the error handling within will not be exercised
//    by the normal artifical failure code.
//

//************************************************************
//
//  Member: CImplAry::~CImplAry
//
//  Synopsis:   Resizeable array destructor. Frees storage allocated for the
//      array.
//
//************************************************************

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

CImplAry::~CImplAry()
{
    if (!UsingStackArray())
    {
        if (NULL != PData())
        {
            GlobalFreePtr(PData());
        }
    }

    m_pv = NULL;
    m_c  = 0;
} // ~CImplAry

//************************************************************
//
//  Member:     CImplAry::GetAlloced, public
//
//  Synopsis:   Returns the number of bytes that have been allocated.
//
//  Arguments:  [cb] -- Size of each element
//
//  Notes:      For the CStackAry classes the value returned is m_cStack*cb if
//              we're still using the stack-allocated array.
//
//************************************************************

ULONG
CImplAry::GetAlloced(size_t cb)
{
    if (UsingStackArray())
    {
        return GetStackSize() * cb;
    }

    if(PData()==NULL)
        return 0;
    else return GlobalSize(GlobalPtrHandle(PData()));
} // GetAlloced

//************************************************************
//
//  Member: CImplAry::EnsureSize
//
//  Synopsis:   Ensures that the array is at least the given size. That is,
//      if EnsureSize(c) succeeds, then (c-1) is a valid index. Note
//      that the array maintains a separate count of the number of
//      elements logically in the array, which is obtained with the
//      Size/SetSize methods. The logical size of the array is never
//      larger than the allocated size of the array.
//
//  Arguments:  cb    Element size
//              c     New allocated size for the array.
//
//  Returns:    HRESULT
//
//************************************************************

HRESULT
CImplAry::EnsureSize(size_t cb, long c)
{
    unsigned long cbAlloc;

    // check to see if we need to do anything
    if (UsingStackArray() && (long)(c * cb) <= (long)GetAlloced(cb))
        return S_OK;

    Assert(c >= 0);

    cbAlloc = ((c + 7) & ~7) * cb;
    
    if (UsingStackArray() ||
        (((unsigned long) c > ((m_c + 7) & ~7)) && cbAlloc > (PData()==NULL?0:GlobalSize(GlobalPtrHandle(PData())))))
    {
        if (UsingStackArray())
        {
            //
            // We have to switch from the stack-based array to an allocated
            // one, so allocate the memory and copy the data over.
            //
            void *pbDataOld = PData();

            PData() = GlobalAllocPtr(GHND, cbAlloc);
            if (PData() ==  NULL)
            {
                TraceTag((tagError, "CImplAry::EnsureSize - unable to alloc memory"));
                PData() = pbDataOld;
                return E_OUTOFMEMORY;
            }

            if(pbDataOld!=NULL) {
                  int cbOld  = GetAlloced(cb);
                  memcpy(PData(), pbDataOld, cbOld);
            }
        }
        else
        {
            // if we already have a pointer, realloc
            if (PData())
            {
                void *pTemp = GlobalReAllocPtr(PData(), cbAlloc, GHND);
                if (pTemp == NULL)
                {
                    TraceTag((tagError, "CImplAry::EnsureSize - unable to realloc memory"));
                    return E_OUTOFMEMORY;
                }

                PData() = pTemp;
            }
            else
            {
                PData() = GlobalAllocPtr(GHND, cbAlloc);
                if (PData() == NULL)
                {
                    TraceTag((tagError, "CImplAry::EnsureSize - unable to alloc memory"));
                    return E_OUTOFMEMORY;
                }
            }

        }

        m_fDontFree = false;
    }

    return S_OK;
} // EnsureSize

//************************************************************
//
//  Member:     CImplAry::Grow, public
//
//  Synopsis:   Ensures enough memory is allocated for c elements and then
//              sets the size of the array to that much.
//
//  Arguments:  [cb] -- Element Size
//              [c]  -- Number of elements to grow array to.
//
//  Returns:    HRESULT
//
//************************************************************

HRESULT
CImplAry::Grow(size_t cb, int c)
{
    HRESULT hr = EnsureSize(cb, c);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CImplAry::Grow - EnsureSize() failed"));
        return hr;
    }

    // BUGBUG - This is a very bad design.  This is too dangerous.
    //          Consider the case where c < m_c.
    SetSize(c);

    return S_OK;
} // Grow

//************************************************************
//
//  Member:     CImplAry::AppendIndirect
//
//  Synopsis:   Appends the given element to the end of the array,
//              incrementing the array's logical size, and growing the
//              array's allocated size if necessary.  Note that the element
//              is passed with a pointer, rather than directly.
//
//  Arguments:  cb        Element size
//              pv        Pointer to the element to be appended
//              ppvPlaced Pointer to the element that's inside the array
//
//  Returns:    HRESULT
//
//  Notes:      If pv is NULL, the element is appended and initialized to
//              zero.
//
//************************************************************

HRESULT
CImplAry::AppendIndirect(size_t cb, void *pv, void **ppvPlaced)
{
    HRESULT hr;

    hr = EnsureSize(cb, m_c + 1);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CImplAry::AppendIndirect - EnsureSize() failed!"));
        return(hr);
    }

    if (ppvPlaced)
    {
        *ppvPlaced = Deref(cb, m_c);
    }

    if (pv == NULL)
    {
        memset(Deref(cb, m_c), 0, cb);
    }
    else
    {
        memcpy(Deref(cb, m_c), pv, cb);
    }

    // increment the count
    m_c++;

    return NOERROR;
} // AppendIndirect

//************************************************************
//
//  Member: CImplAry::DeleteItem
//
//  Synopsis:   Removes the i'th element of the array, shuffling all
//              elements that follow one slot towards the beginning of the
//              array.
//
//  Arguments:  cb  Element size
//              i   Element to delete
//
//************************************************************

void
CImplAry::DeleteItem(size_t cb, int i)
{
    Assert(i >= 0);
    Assert(i < (int)m_c);

    // slide bottom data up one
    memmove(((BYTE *) PData()) + (i * cb),
            ((BYTE *) PData()) + ((i + 1) * cb),
            (m_c - i - 1) * cb);

    // decrement the count
    m_c--;
} // DeleteItem

//************************************************************
//
//  Member: CImplAry::DeleteByValueIndirect
//
//  Synopsis:   Removes the element matching the given value.
//
//  Arguments:  cb  Element size
//              pv  Element to delete
//
//  Returuns:   True if found & deleted.
//
//************************************************************

bool
CImplAry::DeleteByValueIndirect(size_t cb, void *pv)
{
    int i = FindIndirect(cb, pv);
    if (i >= 0)
    {
        DeleteItem(cb, i);
        return true;
    }
    
    return false;
} // DeleteByValueIndirect

//************************************************************
//
//  Member: CImplAry::DeleteMultiple
//
//  Synopsis:   Removes a range of elements of the array, shuffling all
//              elements that follow the last element being deleted slot
//              towards the beginning of the array.
//
//  Arguments:  cb    Element size
//              start First element to delete
//              end   Last element to delete
//
//************************************************************

void
CImplAry::DeleteMultiple(size_t cb, int start, int end)
{
    Assert((start >= 0) && (end >= 0));
    Assert((start < (int)m_c) && (end < (int)m_c));
    Assert(end >= start);

    if ((unsigned)end < (m_c - 1))
    {
        memmove(((BYTE *) PData()) + (start * cb),
                ((BYTE *) PData()) + ((end + 1) * cb),
                (m_c - end - 1) * cb);
    }

    m_c -= (end - start) + 1;
} // DeleteMultiple

//************************************************************
//
//  Member: CImplAry::DeleteAll
//
//  Synopsis:   Efficient method for emptying array of any contents
//
//************************************************************

void
CImplAry::DeleteAll(void)
{
    if (!UsingStackArray())
    {
        if (NULL != PData())
        {
            GlobalFreePtr(PData());
        }

        if (m_fStack)
        {
            PData() = GetStackPtr();
            m_fDontFree = true;
        }
        else
        {
            PData() = NULL;
        }
    }

    m_c = 0;
} // DeleteAll

//************************************************************
//
//  Member: CImplAry::InsertIndirect
//
//  Synopsis:   Inserts a pointer pv at index i. The element previously at
//      index i, and all elements that follow it, are shuffled one
//      slot away towards the end of the array.Note that the
//      clement is passed with a pointer, rather than directly.
//
//  Arguments:  cb    Element size
//              i     Index to insert...
//              pv        ...this pointer at
//
//              if pv is NULL then the element is initialized to all zero.
//
//************************************************************

HRESULT
CImplAry::InsertIndirect(size_t cb, int i, void *pv)
{
    HRESULT hr;

    hr = EnsureSize(cb, m_c + 1);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CImplAry::InsertIndirect - EnsureSize() failed!"));
        return(hr);
    }

    memmove(((BYTE *) PData()) + ((i + 1) * cb),
            ((BYTE *) PData()) + (i * cb),
            (m_c - i) * cb);

    if (pv == NULL)
    {
        memset(Deref(cb, i), 0, cb);
    }
    else
    {
        memcpy(Deref(cb, i), pv, cb);
    }

    // increment the count
    m_c++;
    return NOERROR;

} // InsertIndirect

//************************************************************
//
//  Member:     CImplAry::FindIndirect
//
//  Synopsis:   Finds an element of a non-pointer array.
//
//  Arguments:  cb  The size of the element.
//              pv  Pointer to the element.
//
//  Returns:    The index of the element if found, otherwise -1.
//
//************************************************************

int
CImplAry::FindIndirect(size_t cb, void * pv)
{
    int     i;
    void *  pvT;

    pvT = PData();
    for (i = m_c; i > 0; i--)
    {
        if (!memcmp(pv, pvT, cb))
            return m_c - i;

        pvT = (char *) pvT + cb;
    }

    return -1;
} // FindIndirect

//************************************************************
//
//  Member:     CImplAry::Copy
//
//  Synopsis:   Creates a copy from another CImplAry object.
//
//  Arguments:  ary     Object to copy.
//              fAddRef Addref the elements on copy?
//
//************************************************************

HRESULT
CImplAry::Copy(size_t cb, const CImplAry& ary, bool fAddRef)
{
    return(CopyIndirect(cb, ary.m_c, ((CImplAry *)&ary)->PData(), fAddRef));
} // Copy

//************************************************************
//
//  Member:     CImplAry::CopyIndirect
//
//  Synopsis:   Fills a forms array from a C-style array of raw data
//
//  Arguments:  [cb]
//              [c]
//              [pv]
//              [fAddRef]
//
//  Returns:    HRESULT
//
//************************************************************

HRESULT
CImplAry::CopyIndirect(size_t cb, int c, void *pv, bool fAddRef)
{
    if ((pv == NULL) || (cb < 1) || (c < 1))
    {
        TraceTag((tagError, "CImplAry::CopyIndirect - invalid param"));
        return E_INVALIDARG;
    }

    // if we point to ourselves, da!
    if (pv == PData())
        return S_OK;

    // clear data out
    DeleteAll();

    // ensure size we now want
    HRESULT hr = EnsureSize(cb, c);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CImplAry::CopyIndirect - EnsureSize() failed"));
        return hr;
    }

    // copy data over (blindly)
    memcpy(PData(), pv, c * cb);

    // set element count
    m_c = c;

    if (fAddRef)
    {
        for (IUnknown **ppUnk = (IUnknown **) PData(); c > 0; c--, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }

    return S_OK;
} // CopyIndirect

//************************************************************
//
//  Member:     CImplPtrAry::*
//
//  Synopsis:   CImplPtrAry elements are always of size four.
//              The following functions encode this knowledge.
//
//************************************************************

HRESULT
CImplPtrAry::EnsureSize(long c)
{
    return CImplAry::EnsureSize(sizeof(void *), c);
} // EnsureSize

//************************************************************

HRESULT
CImplPtrAry::Grow(int c)
{
    return CImplAry::Grow(sizeof(void *), c);
} // Grow

//************************************************************

HRESULT
CImplPtrAry::Append(void * pv)
{
    return CImplAry::AppendIndirect(sizeof(void *), &pv);
} // Append

//************************************************************

HRESULT
CImplPtrAry::Insert(int i, void * pv)
{
    return CImplAry::InsertIndirect(sizeof(void *), i, &pv);
} // Insert

//************************************************************

int
CImplPtrAry::Find(void * pv)
{
    int    i;
    void **ppv;

    for (i = 0, ppv = (void **) PData(); (unsigned)i < m_c; i++, ppv++)
    {
        if (pv == *ppv)
            return i;
    }

    return -1;
} // Find

//************************************************************

void
CImplPtrAry::DeleteItem(int i)
{
    CImplAry::DeleteItem(sizeof(void *), i);
}

//************************************************************

bool
CImplPtrAry::DeleteByValue(void *pv)
{
    int i = Find(pv);
    if (i >= 0)
    {
        CImplAry::DeleteItem(sizeof(void *), i);
        return true;
    }

    return false;
} // DeleteByValue

//************************************************************

void
CImplPtrAry::DeleteMultiple(int start, int end)
{
    CImplAry::DeleteMultiple(sizeof(void*), start, end);
} // DeleteMultiple

//************************************************************

void
CImplPtrAry::ReleaseAndDelete(int idx)
{
    IUnknown *pUnk;

    Assert(idx <= (int)m_c);

    // grab element at idx
    pUnk = ((IUnknown **) PData())[idx];
    if (pUnk)
        ReleaseInterface(pUnk);

    DeleteItem(idx);
} // ReleaseAndDelete

//************************************************************

void
CImplPtrAry::ReleaseAll(void)
{
    int        i;
    IUnknown **ppUnk;

    for (i = 0, ppUnk = (IUnknown **) PData(); (unsigned)i < m_c; i++, ppUnk++)
    {
        if (*ppUnk)
            ReleaseInterface(*ppUnk);
    }

    DeleteAll();
} // ReleaseAll

//************************************************************

HRESULT
CImplPtrAry::CopyIndirect(int c, void * pv, bool fAddRef)
{
    return CImplAry::CopyIndirect(sizeof(void *), c, pv, fAddRef);
} // CopyIndirect

//************************************************************

HRESULT
CImplPtrAry::Copy(const CImplAry& ary, bool fAddRef)
{
    return CImplAry::Copy(sizeof(void *), ary, fAddRef);
} // Copy

//************************************************************

HRESULT
CImplPtrAry::EnumElements(REFIID   iid,
                          void   **ppv,
                          bool     fAddRef,
                          bool     fCopy,
                          bool     fDelete)
{
    return CImplAry::EnumElements(sizeof(void *),
                                  iid,
                                  ppv,
                                  fAddRef,
                                  fCopy,
                                  fDelete);
} // EnumElements

//************************************************************

HRESULT
CImplPtrAry::EnumVARIANT(VARTYPE        vt,
                         IEnumVARIANT **ppenum,
                         bool           fCopy,
                         bool           fDelete)
{
    return CImplAry::EnumVARIANT(sizeof(void *),
                                 vt,
                                 ppenum,
                                 fCopy,
                                 fDelete);
} // EnumVARIANT

//************************************************************

// Determines whether a variant is a base type.
#define ISBASEVARTYPE(vt) ((vt & ~VT_TYPEMASK) == 0)

//************************************************************
//
//  CBaseEnum Implementation
//
//************************************************************

//************************************************************
//
//  Member:     CBaseEnum::Init
//
//  Synopsis:   2nd stage initialization performs copy of array if necessary.
//
//  Arguments:  [rgItems] -- Array to enumrate.
//              [fCopy]   -- Copy array?
//
//  Returns:    HRESULT.
//
//************************************************************

HRESULT
CBaseEnum::Init(CImplAry *rgItems, bool fCopy)
{
    HRESULT   hr = S_OK;
    CImplAry *rgCopy = NULL;     // copied array

    if (rgItems == NULL)
    {
        TraceTag((tagError, "CBaseEnum::Init - invalid param"));
        return E_INVALIDARG;
    }

    // Copy array if necessary.
    if (fCopy)
    {
        rgCopy = NEW CImplAry;
        if (rgCopy == NULL)
        {
            TraceTag((tagError, "CBaseEnum::Init - unable to alloc memory for new array class"));
            return E_OUTOFMEMORY;
        }

        hr = rgCopy->Copy(m_cb, *rgItems, m_fAddRef);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CBaseEnum::Init - Copy() failed"));
            delete rgCopy;
            return hr;
        }

        rgItems = rgCopy;
    }

    m_rgItems = rgItems;

    return hr;
} // Init

//************************************************************
//
//  Member:     CBaseEnum::CBaseEnum
//
//  Synopsis:   Constructor.
//
//  Arguments:  [iid]     -- IID of enumerator interface.
//              [fAddRef] -- addref enumerated elements?
//              [fDelete] -- delete array on zero enumerators?
//
//************************************************************

CBaseEnum::CBaseEnum(size_t cb, REFIID iid, bool fAddRef, bool fDelete)
{
    m_ulRefs     = 1;

    m_cb         = cb;
    m_rgItems    = NULL;
    m_piid       = &iid;
    m_i          = 0;
    m_fAddRef    = fAddRef;
    m_fDelete    = fDelete;
} // CBaseEnum

//************************************************************
//
//  Member:     CBaseEnum::CBaseEnum
//
//  Synopsis:   Constructor.
//
//************************************************************

CBaseEnum::CBaseEnum(const CBaseEnum& benum)
{
    m_ulRefs     = 1;

    m_cb         = benum.m_cb;
    m_piid       = benum.m_piid;
    m_rgItems    = benum.m_rgItems;
    m_i          = benum.m_i;
    m_fAddRef    = benum.m_fAddRef;
    m_fDelete    = benum.m_fDelete;
} // CBaseEnum

//************************************************************
//
//  Member:     CBaseEnum::~CBaseEnum
//
//  Synopsis:   Destructor.
//
//************************************************************

CBaseEnum::~CBaseEnum(void)
{
    IUnknown **ppUnk;
    int        i;

    if (m_rgItems && m_fDelete)
    {
        if (m_fAddRef)
        {
            for (i = 0, ppUnk = (IUnknown **) Deref(0);
                 i < m_rgItems->Size();
                 i++, ppUnk++)
            {
                ReleaseInterface(*ppUnk);
            }
        }

        delete m_rgItems;
    }
} // ~CBaseEnum

//************************************************************
//
//  Member:     CBaseEnum::QueryInterface
//
//  Synopsis:   Per IUnknown::QueryInterface.
//
//************************************************************

STDMETHODIMP
CBaseEnum::QueryInterface(REFIID iid, void ** ppv)
{
    if (IsEqualIID(iid, IID_IUnknown) || IsEqualIID(iid, *m_piid))
    {
        AddRef();
        *ppv = this;
        return NOERROR;
    }

    return E_NOINTERFACE;
} // QueryInterface

//************************************************************
//
//  Member:     CBaseEnum::Skip
//
//  Synopsis:   Per IEnum*
//
//************************************************************

STDMETHODIMP
CBaseEnum::Skip(ULONG celt)
{
    int c = min((int) celt, m_rgItems->Size() - m_i);
    m_i += c;

    return ((c == (int) celt) ? S_OK : S_FALSE);
} // Skip

//************************************************************
//
//  Member:     CBaseEnum::Reset
//
//  Synopsis:   Per IEnum*
//
//************************************************************

STDMETHODIMP
CBaseEnum::Reset(void)
{
    m_i = 0;
    return S_OK;
} // Reset

//************************************************************
//
//  CEnumGeneric Implementation
//
//************************************************************

//************************************************************
//
//  Class:      CEnumGeneric (enumg)
//
//  Purpose:    OLE enumerator for class CImplAry.
//
//  Interface:  Next         -- Per IEnum
//              Clone        --     ""
//              Create       -- Creates a new enumerator.
//              CEnumGeneric -- ctor.
//              CEnumGeneric -- ctor.
//
//************************************************************

class CEnumGeneric : public CBaseEnum
{
public:
    //
    //  IEnum methods
    //
    STDMETHOD(Next) (ULONG celt, void *reelt, ULONG *pceltFetched);
    STDMETHOD(Clone) (CBaseEnum **ppenum);

    //
    //  CEnumGeneric methods
    //
    static HRESULT Create(size_t          cb,
                          CImplAry       *rgItems,
                          REFIID          iid,
                          bool            fAddRef,
                          bool            fCopy,
                          bool            fDelete,
                          CEnumGeneric  **ppenum);

protected:
    CEnumGeneric(size_t cb, REFIID iid, bool fAddRef, bool fDelete);
    CEnumGeneric(const CEnumGeneric & enumg);

    CEnumGeneric& operator=(const CEnumGeneric & enumg); // don't define
}; // class CEnumGeneric

//************************************************************
//
//  Member:     CEnumGeneric::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [rgItems] -- Array to enumerate.
//              [iid]     -- IID of enumerator interface.
//              [fAddRef] -- AddRef enumerated elements?
//              [fCopy]   -- Copy array enumerated?
//              [fDelete] -- Delete array when zero enumerators of array?
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//************************************************************

HRESULT
CEnumGeneric::Create(size_t          cb,
                     CImplAry       *rgItems,
                     REFIID          iid,
                     bool            fAddRef,
                     bool            fCopy,
                     bool            fDelete,
                     CEnumGeneric  **ppenum)
{
    HRESULT         hr = S_OK;
    CEnumGeneric   *penum;

    Assert(rgItems);
    Assert(ppenum);
    Assert(!fCopy || fDelete);
    
    *ppenum = NULL;
    
    penum = NEW CEnumGeneric(cb, iid, fAddRef, fDelete);
    if (penum == NULL)
    {
        TraceTag((tagError, "CEnumGeneric::Create - unable to alloc memory for CEnumGeneric"));
        return E_OUTOFMEMORY;
    }

    hr = penum->Init(rgItems, fCopy);
    if (FAILED(hr))
    {
        ReleaseInterface(penum);
        return hr;
    }

    *ppenum = penum;

    return hr;
} // Create

//************************************************************
//
//  Function:   CEnumGeneric
//
//  Synopsis:   ctor.
//
//  Arguments:  [iid]     -- IID of enumerator interface.
//              [fAddRef] -- AddRef enumerated elements?
//              [fDelete] -- delete array on zero enumerators?
//
//************************************************************

CEnumGeneric::CEnumGeneric(size_t cb, REFIID iid, bool fAddRef, bool fDelete) :
    CBaseEnum(cb, iid, fAddRef, fDelete)
{
} // CEnumGeneric (size_t, REFIID, bool, bool)

//************************************************************
//
//  Function:   CEnumGeneric
//
//  Synopsis:   ctor.
//
//************************************************************

CEnumGeneric::CEnumGeneric(const CEnumGeneric& enumg) : CBaseEnum(enumg)
{
} // CEnumGeneric

//************************************************************
//
//  Member:     CEnumGeneric::Next
//
//  Synopsis:   Returns the next celt members in the enumeration. If less
//              than celt members remain, then the remaining members are
//              returned and S_FALSE is reported. In all cases, the number
//              of elements actually returned in placed in *pceltFetched.
//
//  Arguments:  [celt]          Number of elements to fetch
//              [reelt]         The elements are returned in reelt[]
//              [pceltFetched]  Number of elements actually fetched
//
//************************************************************

STDMETHODIMP
CEnumGeneric::Next(ULONG celt, void *reelt, ULONG *pceltFetched)
{
    int        c;
    int        i;
    IUnknown **ppUnk;

    c = min((int) celt, m_rgItems->Size() - m_i);
    if ((c > 0) && (reelt == NULL))
    {
        TraceTag((tagError, "CEnumGeneric::Next - invalid params"));
        return E_INVALIDARG;
    }

    // nothing left
    if (c == 0)
        return S_FALSE;

    if (m_fAddRef)
    {
        for (i = 0, ppUnk = (IUnknown **) Deref(m_i); i < c; i++, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }

    memcpy(reelt, (BYTE *) Deref(m_i), c * m_cb);
    
    if (pceltFetched)
    {
        *pceltFetched = c;
    }
    
    m_i += c;

    return ((c == (int) celt) ? S_OK : S_FALSE);
} // Next

//************************************************************
//
//  Member:     CEnumGeneric::Clone
//
//  Synopsis:   Creates a copy of this enumerator; the copy should have the
//              same state as this enumerator.
//
//  Arguments:  [ppenum]    New enumerator is returned in *ppenum
//
//************************************************************

STDMETHODIMP
CEnumGeneric::Clone(CBaseEnum ** ppenum)
{
    HRESULT hr;

    if (ppenum == NULL)
    {
        TraceTag((tagError, "CEnumGeneric::Clone - invalid param"));
        return E_INVALIDARG;
    }

    *ppenum = NULL;

    hr = m_rgItems->EnumElements(m_cb, *m_piid, (void **) ppenum, m_fAddRef);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CEnumGeneric::Clone - EnumElements() failed"));
        return hr;
    }
    
    (**(CEnumGeneric **)ppenum).m_i = m_i;
    
    return S_OK;
} // Clone

//************************************************************
//
//  Member:     CImplAry::EnumElements
//
//  Synopsis:   Creates and returns an enumerator for the elements of the
//              array.
//
//  Arguments:  [iid]     --    Type of the enumerator.
//              [ppv]     --    Location to put enumerator.
//              [fAddRef] --    AddRef enumerated elements?
//              [fCopy]   --    Create copy of this array for enumerator?
//              [fDelete] --    Delete this after no longer being used by
//                              enumerators?
//
//************************************************************

HRESULT
CImplAry::EnumElements(size_t   cb,
                       REFIID   iid,
                       void   **ppv,
                       bool     fAddRef,
                       bool     fCopy,
                       bool     fDelete)
{
    Assert(ppv);
    return CEnumGeneric::Create(cb,
                                this,
                                iid,
                                fAddRef,
                                fCopy,
                                fDelete,
                                (CEnumGeneric **) ppv);
} // EnumElements

//************************************************************
//
//  CEnumVARIANT Implementation
//
//************************************************************

//************************************************************
//
//  Class:      CEnumVARIANT (enumv)
//
//  Purpose:    OLE enumerator for class CImplAry.
//
//  Interface:  Next         -- Per IEnum
//              Clone        --     ""
//              Create       -- Creates a new enumerator.
//              CEnumGeneric -- ctor.
//              CEnumGeneric -- ctor.
//
//************************************************************

class CEnumVARIANT : public CBaseEnum
{
public:
    //  IEnum methods
    STDMETHOD(Next) (ULONG celt, void *reelt, ULONG *pceltFetched);
    STDMETHOD(Clone) (CBaseEnum **ppenum);

    static HRESULT Create(size_t          cb,
                          CImplAry       *rgItems,
                          VARTYPE         vt,
                          bool            fCopy,
                          bool            fDelete,
                          IEnumVARIANT  **ppenum);

protected:
    CEnumVARIANT(size_t cb, VARTYPE vt, bool fDelete);
    CEnumVARIANT(const CEnumVARIANT & enumv);

    // don't define
    CEnumVARIANT& operator =(const CEnumVARIANT & enumv);

    VARTYPE     m_vt;                    // type of element enumerated
}; // class CEnumVARIANT

//************************************************************
//
//  Member:     CEnumVARIANT::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [rgItems] -- Array to enumerate.
//              [vt]      -- Type of elements enumerated.
//              [fCopy]   -- Copy array enumerated?
//              [fDelete] -- Delete array when zero enumerators of array?
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//************************************************************

HRESULT
CEnumVARIANT::Create(size_t          cb,
                     CImplAry       *rgItems,
                     VARTYPE         vt,
                     bool            fCopy,
                     bool            fDelete,
                     IEnumVARIANT  **ppenum)
{
    HRESULT hr = S_OK;

    Assert(rgItems);
    Assert(ppenum);
    Assert(ISBASEVARTYPE(vt));

    *ppenum = NULL;

    CEnumVARIANT *penum = NEW CEnumVARIANT(cb, vt, fDelete);
    if (ppenum == NULL)
    {
        TraceTag((tagError, "CEnumVARIANT::Create - unable to alloc mem for CEnumVARIANT"));
        return E_OUTOFMEMORY;
    }

    hr = penum->Init(rgItems, fCopy);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CEnumVARIANT::Create - Init() failed"));
        ReleaseInterface(penum);
        return hr;
    }

    *ppenum = (IEnumVARIANT *) (void *) penum;

    return hr;
} // Create

//************************************************************
//
//  Function:   CEnumVARIANT
//
//  Synopsis:   ctor.
//
//  Arguments:  [vt]      -- Type of elements enumerated.
//              [fDelete] -- delete array on zero enumerators?
//
//************************************************************

CEnumVARIANT::CEnumVARIANT(size_t cb, VARTYPE vt, bool fDelete) :
    CBaseEnum(cb, IID_IEnumVARIANT, vt == VT_UNKNOWN || vt == VT_DISPATCH, fDelete)
{
    Assert(ISBASEVARTYPE(vt));
    m_vt = vt;
} // CEnumVARIANT (size_t, VARTYPE, bool)

//************************************************************
//
//  Function:   CEnumVARIANT
//
//  Synopsis:   ctor.
//
//************************************************************

CEnumVARIANT::CEnumVARIANT(const CEnumVARIANT& enumv) : CBaseEnum(enumv)
{
    m_vt = enumv.m_vt;
} // CEnumVARIANT(const CEnumVARIANT&)

//************************************************************
//
//  Member:     CEnumVARIANT::Next
//
//  Synopsis:   Returns the next celt members in the enumeration. If less
//              than celt members remain, then the remaining members are
//              returned and S_FALSE is reported. In all cases, the number
//              of elements actually returned in placed in *pceltFetched.
//
//  Arguments:  [celt]          Number of elements to fetch
//              [reelt]         The elements are returned in reelt[]
//              [pceltFetched]  Number of elements actually fetched
//
//************************************************************

STDMETHODIMP
CEnumVARIANT::Next(ULONG celt, void *reelt, ULONG *pceltFetched)
{
    HRESULT     hr;
    int         c;
    int         i;
    int         j;
    BYTE       *pb;
    VARIANT    *pvar;

    c = min((int) celt, m_rgItems->Size() - m_i);
    
    if ((c > 0) && (reelt == NULL))
    {
        TraceTag((tagError, "CEnumVARIANT::Next - invalid param"));
        return E_INVALIDARG;
    }

    // nothing left
    if (c == 0)
        return S_FALSE;

    for (i = 0, pb = (BYTE *) Deref(m_i), pvar = (VARIANT *) reelt;
         i < c;
         i++, pb += m_cb, pvar++)
    {
        V_VT(pvar) = m_vt;
        switch (m_vt)
        {
        case VT_I2:
            Assert(sizeof(V_I2(pvar)) == m_cb);
            V_I2(pvar) = *(short *) pb;
            break;

        case VT_I4:
            Assert(sizeof(V_I4(pvar)) == m_cb);
            V_I4(pvar) = *(long *) pb;
            break;

        case VT_BOOL:
            Assert(sizeof(V_BOOL(pvar)) == m_cb);
            V_BOOL(pvar) = (short) -*(int *) pb;
            break;

        case VT_BSTR:
            Assert(sizeof(V_BSTR(pvar)) == m_cb);
            V_BSTR(pvar) = *(BSTR *) pb;
            break;

        case VT_UNKNOWN:
            Assert(sizeof(V_UNKNOWN(pvar)) == m_cb);
            V_UNKNOWN(pvar) = *(IUnknown **) pb;
            V_UNKNOWN(pvar)->AddRef();
            break;

        case VT_DISPATCH:
            Assert(sizeof(V_DISPATCH(pvar)) == m_cb);
            hr = (*(IUnknown **) pb)->QueryInterface(IID_TO_PPV(IDispatch, &V_DISPATCH(pvar)));
            if (FAILED(hr))
            {
                // Cleanup
                j = i;
                while (--j >= 0)
                {
                    ReleaseInterface(((IDispatch **) reelt)[j]);
                }

                return hr;
            }
            break;

        default:
            Assert(0 && "Unknown VARTYPE in IEnumVARIANT::Next");
            break;
        }
    }

    if (pceltFetched)
    {
        *pceltFetched = c;
    }

    m_i += c;
    return ((c == (int) celt) ? NOERROR : S_FALSE);
} // Next

//************************************************************
//
//  Member:     CEnumVARIANT::Clone
//
//  Synopsis:   Creates a copy of this enumerator; the copy should have the
//              same state as this enumerator.
//
//  Arguments:  [ppenum]    New enumerator is returned in *ppenum
//
//************************************************************

STDMETHODIMP
CEnumVARIANT::Clone(CBaseEnum **ppenum)
{
    HRESULT hr = S_OK;

    if (ppenum == NULL)
    {
        TraceTag((tagError, "CEnumVARIANT::Clone - invalid param"));
        return E_INVALIDARG;
    }

    *ppenum = NULL;
   
    hr = m_rgItems->EnumVARIANT(m_cb, m_vt, (IEnumVARIANT **)ppenum);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CEnumVARIANT::Clone - EnumVARIANT() failed"));
        return hr;
    }

    (**(CEnumVARIANT **)ppenum).m_i = m_i;
    
    return hr;
} // Clone

//************************************************************
//
//  Member:     CImplAry::EnumElements
//
//  Synopsis:   Creates and returns an IEnumVARIANT enumerator for the elements
//              of the array.
//
//  Arguments:  [vt]      --    Type of elements enumerated.
//              [ppv]     --    Location to put enumerator.
//              [fCopy]   --    Create copy of this array for enumerator?
//              [fDelete] --    Delete this after no longer being used by
//                              enumerators?
//
//************************************************************

HRESULT
CImplAry::EnumVARIANT(size_t         cb,
                      VARTYPE        vt,
                      IEnumVARIANT **ppenum,
                      bool           fCopy,
                      bool           fDelete)
{
    Assert(ppenum);
    return CEnumVARIANT::Create(cb, this, vt, fCopy, fDelete, ppenum);
} // EnumVARIANT

//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\atomtable.h ===
#ifndef _ATOMTABLE_H_
#define _ATOMTABLE_H_

//************************************************************
//
// FileName:        atomtbl.h
//
// Created:         01/28/98
//
// Author:          TWillie
// 
// Abstract:        Declaration of the CAtomTable
//************************************************************

#include "array.h"

class CAtomTable
{
public:
    CAtomTable();
    virtual ~CAtomTable();
    
    //
    // CAtomTable impl
    //
    HRESULT AddNameToAtomTable(const WCHAR *pwszName,
                               long        *plOffset);
    HRESULT GetAtomFromName(const WCHAR *pwszName,
                            long        *plOffset);
    HRESULT GetNameFromAtom(long          lOffset, 
                            const WCHAR **ppwszName);
    
private:
    CPtrAry<BSTR> *m_rgNames;
};

#endif // _ATOMTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\atomtable.cpp ===
//************************************************************
//
// FileName:        atomtbl.cpp
//
// Created:         01/28/98
//
// Author:          TWillie
// 
// Abstract:        Implementation of CAtomTable.
//************************************************************

#include "headers.h"
#include "atomtable.h"

//************************************************************
// Author:          twillie
// Created:         01/28/98
// Abstract:        constructor
//************************************************************

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

CAtomTable::CAtomTable() :
    m_rgNames(NULL)
{
} // CAtomTable

//************************************************************
// Author:          twillie
// Created:         01/28/98
// Abstract:        destructor
//************************************************************

CAtomTable::~CAtomTable()
{
    if (m_rgNames)
    {
        // loop thru and release memory
        long lSize = m_rgNames->Size();
        for(long lIndex = 0; lIndex < lSize; lIndex++)
        {
            SysFreeString((*m_rgNames)[lIndex]);
        }

        delete m_rgNames;
        m_rgNames = NULL;
    }
} // ~CAtomTable

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    
//************************************************************

HRESULT
CAtomTable::AddNameToAtomTable(const WCHAR *pwszName, 
                               long        *plOffset)
{
    if ((plOffset == NULL) || (pwszName == NULL))
    {
        TraceTag((tagError, "CAtomTable::AddNameToAtomTable - Invalid param"));
        return E_INVALIDARG;
    }
    
    *plOffset = 0;
    
    // check to see if array is initialized
    if (m_rgNames == NULL)
    {
        m_rgNames = NEW CPtrAry<BSTR>;
        if (m_rgNames == NULL)
        {
            TraceTag((tagError, "CAtomTable::AddNameToAtomTable - Unable to alloc mem for array"));
            return E_OUTOFMEMORY;
        }
    }

    HRESULT hr = GetAtomFromName(pwszName, plOffset);
    if (hr == DISP_E_MEMBERNOTFOUND)
    {
        BSTR bstrName = SysAllocString(pwszName);
        if (bstrName == NULL)
        {
            TraceTag((tagError, "CAtomTable::AddNameToAtomTable - Unable to alloc mem for string"));
            return E_OUTOFMEMORY;
        }

        // add to table
        hr = m_rgNames->Append(bstrName);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CAtomTable::AddNameToAtomTable - unable to add string to table"));
            SysFreeString(bstrName);
            return hr;
        }

        // calc offset
        *plOffset = m_rgNames->Size() - 1;
    }

    // otherwise return the results of FindAtom
    return hr;
} // AddNameToAtomTable


//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    given a name, return the index
//************************************************************

HRESULT
CAtomTable::GetAtomFromName(const WCHAR *pwszName,
                            long        *plOffset)
{
    // validate out param
    if ((plOffset == NULL) || (pwszName == NULL))
    {
        TraceTag((tagError, "CAtomTable::GetAtomFromName - Invalid param"));
        return E_INVALIDARG;
    }

    // init param
    *plOffset = 0;

    // loop thru table looking for a match
    long   lSize  = m_rgNames->Size();
    BSTR  *ppItem = *m_rgNames;

    for (long lIndex = 0; lIndex < lSize; lIndex++, ppItem++)
    {
        Assert(*ppItem);

        if (wcscmp(pwszName, (*ppItem)) == 0)
        {
            *plOffset = lIndex;
            return S_OK;
        }
    }

    // not found
    return DISP_E_MEMBERNOTFOUND;
} // GetAtomFromName

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    given an index, return the contents
//************************************************************

HRESULT 
CAtomTable::GetNameFromAtom(long lOffset, const WCHAR **ppwszName)
{
    // validate out param
    if (ppwszName == NULL)
    {
        TraceTag((tagError, "CAtomTable::GetNameFromAtom - Invalid param"));
        return E_INVALIDARG;
    }

    *ppwszName = NULL;

    // check for empty table
    if (m_rgNames->Size() == 0)
    {
        TraceTag((tagError, "CAtomTable::GetNameFromAtom - table is empty"));
        return DISP_E_MEMBERNOTFOUND;
    }

    // check to make sure we are in range
    if ((lOffset < 0) || 
        (lOffset >= m_rgNames->Size()))
    {
        TraceTag((tagError, "CAtomTable::GetNameFromAtom - Invalid index"));
        return DISP_E_MEMBERNOTFOUND;
    }

    // set IDispatch
    *ppwszName = (*m_rgNames)[lOffset];
    return S_OK;
} // GetNameFromAtom

//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\basebvr.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: basebvr.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _BASEBVR_H
#define _BASEBVR_H

class CBaseBvr :   
    public CComObjectRootEx<CComSingleThreadModel>,
    public IElementBehavior,
    public IElementBehaviorRender,
    public IServiceProvider,
    public IOleClientSite
{
  public:
    CBaseBvr();
    
    virtual void * GetInstance() = 0;
    virtual HRESULT GetTypeInfo(ITypeInfo ** ppInfo) = 0;

    // IElementBehavior
    //
    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);
    STDMETHOD(Notify)(LONG event, VARIANT * pVar);
    STDMETHOD(Detach)();

    //
    // IElementBehaviorRender
    //
    STDMETHOD(Draw)(HDC hdc, LONG dwLayer, LPRECT prc, IUnknown * pParams);
    STDMETHOD(GetRenderInfo)(LONG *pdwRenderInfo);
    STDMETHOD(HitTestPoint)(LPPOINT point,
                            IUnknown *pReserved,
                            BOOL *hit);
    
    IElementBehaviorSite * GetBvrSite()
    { return m_pBvrSite; }

    IElementBehaviorSiteOM * GetBvrSiteOM()
    { return m_pBvrSiteOM; }

    IElementBehaviorSiteRender * GetBvrSiteRender()
    { return m_pBvrSiteRender; }

    IHTMLElement * GetElement()
    { return m_pHTMLEle; }

    IHTMLDocument2 * GetDocument()
    { return m_pHTMLDoc; }
    
    IServiceProvider * GetServiceProvider()
    { return m_pSp; }
    
    virtual void InvalidateRect(LPRECT lprect);
    virtual void InvalidateRenderInfo();

    BEGIN_COM_MAP(CBaseBvr)
        COM_INTERFACE_ENTRY(IElementBehavior)
        COM_INTERFACE_ENTRY(IElementBehaviorRender)
        COM_INTERFACE_ENTRY(IServiceProvider)
        COM_INTERFACE_ENTRY(IOleClientSite)
    END_COM_MAP();

    //
    // IServiceProvider interfaces
    //

    STDMETHOD(QueryService)(REFGUID guidService,
                            REFIID riid,
                            void** ppv);

    //
    // IOleClientSite interfaces
    //
    
    STDMETHOD(SaveObject)()
    { return E_NOTIMPL; }
    STDMETHOD(GetMoniker)(DWORD dwAssign,
                          DWORD dwWhichMoniker, 
                          LPMONIKER * ppmk)
    { CHECK_RETURN_SET_NULL(ppmk); return E_NOTIMPL; }
    STDMETHOD(GetContainer)(LPOLECONTAINER * ppContainer)
    { CHECK_RETURN_SET_NULL(ppContainer); return E_NOTIMPL; }
    STDMETHOD(ShowObject)()
    { return E_NOTIMPL; }
    STDMETHOD(OnShowWindow)(BOOL fShow)
    { return E_NOTIMPL; }
    STDMETHOD(RequestNewObjectLayout)()
    { return E_NOTIMPL; }

    virtual WCHAR* GetBehaviorTypeAsURN() = 0;

  protected:
    DAComPtr<IElementBehaviorSite>          m_pBvrSite;
    DAComPtr<IElementBehaviorSiteOM>        m_pBvrSiteOM;
    DAComPtr<IElementBehaviorSiteRender>    m_pBvrSiteRender;
    DAComPtr<IHTMLElement>                  m_pHTMLEle;
    DAComPtr<IHTMLDocument2>                m_pHTMLDoc;
    DAComPtr<IServiceProvider>              m_pSp;
};

#endif /* _BASEBVR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\bodyelm.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: bodyelm.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "bodyelm.h"
#include "daelm.h"
#include <mshtmdid.h>

DeclareTag(tagTimeBodyElm, "API", "CTIMEBodyElement methods");

// static class data.
CPtrAry<BSTR> CTIMEBodyElement::ms_aryPropNames;
DWORD CTIMEBodyElement::ms_dwNumBodyElems = 0;

// These must align with the class PROPERTY_INDEX enumeration.
LPWSTR CTIMEBodyElement::ms_rgwszTBodyPropNames[] = {
    L"timeStartRule",
};

CTIMEBodyElement::CTIMEBodyElement() :
    m_startRule(STARTRULE_ONDOCLOAD_TOKEN),
    m_player(*this),
    m_bodyPropertyAccesFlags(0),
    m_fStartRoot(false)
{
    TraceTag((tagTimeBodyElm,
              "CTIMEBodyElement(%lx)::CTIMEBodyElement()",
              this));

    m_clsid = __uuidof(CTIMEBodyElement);
    CTIMEBodyElement::ms_dwNumBodyElems++;

    // Override the default action
    // TODO: The right way to do this is to pass it in the constructor
    // but I am too lazy and this will work fine
    
    m_timeAction = NONE_TOKEN;

    // Set our body to be ourself
    m_pTIMEBody = this;
}

CTIMEBodyElement::~CTIMEBodyElement()
{
    CTIMEBodyElement::ms_dwNumBodyElems--;

    if (0 == CTIMEBodyElement::ms_dwNumBodyElems)
    {
        int iNames = CTIMEBodyElement::ms_aryPropNames.Size();

        for (int i = iNames - 1; i >= 0; i--)
        {
            BSTR bstrName = CTIMEBodyElement::ms_aryPropNames[i];
            CTIMEBodyElement::ms_aryPropNames.DeleteItem(i);
            ::SysFreeString(bstrName);
        }
    }
}


HRESULT
CTIMEBodyElement::Init(IElementBehaviorSite * pBehaviorSite)
{
    TraceTag((tagTimeBodyElm,
              "CTIMEBodyElement(%lx)::Init(%lx)",
              this,
              pBehaviorSite));
    
    HRESULT hr;

    hr = THR(CTIMEElementBase::Init(pBehaviorSite));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

done:
    if (FAILED(hr))
    {
        Detach();
    }
    
    return hr;
}

HRESULT
CTIMEBodyElement::InitTimeline()
{
    TraceTag((tagTimeBodyElm, "CTIMEBodyElement(%lx)::InitTimeline()", this));
    HRESULT hr;

    hr = CTIMEElementBase::InitTimeline();
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(m_timeline);
    
    if (!m_player.Init(*m_timeline))
    {
        hr = CRGetLastError();
        goto done;
    }

    Assert(!m_fStartRoot);

    // After we load properties, check to see if we need to start now.
    // If the doc is already started, we should start now.
    if ((m_startRule == STARTRULE_IMMEDIATE_TOKEN) || IsDocumentStarted())
    {
        HRESULT hr = THR(StartRootTime(NULL));
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEBodyElement::OnLoadComplete - StartRootTime() failed!"));
            goto done;
        }
    }
    hr = S_OK;
done:
    return hr;
}

STDMETHODIMP
CTIMEBodyElement::Detach()
{
    TraceTag((tagTimeBodyElm, "CTIMEBodyElement(%lx)::Detach()", this));
    
    HRESULT hr;

    if (m_fStartRoot)
    {
        Assert(m_timeline != NULL);
        StopRootTime(NULL);
    }

    m_player.Deinit();

    THR(CTIMEElementBase::Detach());

    hr = S_OK;

    return hr;
}


void CTIMEBodyElement::OnReadyStateChange(TOKEN state)
{
    TraceTag((tagTimeBodyElm, "CTIMEBodyElement(%lx)::OnReadyStateChange()", this));

    if (state == READYSTATE_COMPLETE_TOKEN)
    {
        // if the startRule is set to onDocComplete, start root time now.
        if ((m_startRule == STARTRULE_ONDOCCOMPLETE_TOKEN))
        {
            Assert(!m_fStartRoot);
            HRESULT hr = THR(StartRootTime(NULL));
            if (FAILED(hr))
            {
                TraceTag((tagError, "CTIMEBodyElement::OnReadyStateChange - StartRootTime() failed!"));
                goto done;
            }
        }
    }
        
done:
    return;
}

void CTIMEBodyElement::OnLoad()
{
    TraceTag((tagTimeBodyElm, "CTIMEBodyElement(%lx)::OnLoad()", this));

    // if the startRule is set to onDocLoad, start root time now.
    if ((m_startRule == STARTRULE_ONDOCLOAD_TOKEN))
    {
        Assert(!m_fStartRoot);
        HRESULT hr = THR(StartRootTime(NULL));
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEBodyElement::OnLoad - StartRootTime() failed!"));
            goto done;
        }
    }
        
done:
    CTIMEElementBase::OnLoad();
    return;
}

void
CTIMEBodyElement::OnPause(double dblLocalTime)
{
    base_pause();
    CTIMEElementBase::OnPause(dblLocalTime);
}

void
CTIMEBodyElement::OnResume(double dblLocalTime)
{
    base_resume();
    CTIMEElementBase::OnResume(dblLocalTime);
}

void
CTIMEBodyElement::OnSync(double dbllastTime, double & dblnewTime)
{
    IGNORE_HR(NotifyPropertyChanged(DISPID_TIMEELEMENT_LOCALTIME));
}


HRESULT
CTIMEBodyElement::StartRootTime(MMTimeline * tl)
{
    HRESULT hr;
    
    hr = THR(CTIMEElementBase::StartRootTime(tl));

    if (FAILED(hr))
    {
        goto done;
    }
    
    if (!IsDocumentInEditMode())
    {
        if (!m_player.Play())
        {
            hr = CRGetLastError();
            goto done;
        }
    }
    else
    {
        if (!m_player.Pause())
        {
            hr = CRGetLastError();
            goto done;
        }
    }

    hr = S_OK;
    m_fStartRoot = true;
  done:
    return hr;
}

void
CTIMEBodyElement::StopRootTime(MMTimeline * tl)
{
    m_fStartRoot = false;

    CTIMEElementBase::StopRootTime(tl);
    
    m_player.Stop();
}

HRESULT
CTIMEBodyElement::base_pause()
{
    bool ok = false;
    HRESULT hr;

    if (!m_player.Pause())
    {
        goto done;
    }
    
    hr = THR(CTIMEElementBase::base_pause());

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

HRESULT
CTIMEBodyElement::base_resume()
{
    bool ok = false;
    
    m_player.Resume();
    IGNORE_HR(CTIMEElementBase::base_resume());

    ok = true;

    return ok?S_OK:Error();
}

HRESULT
CTIMEBodyElement::get_timeStartRule(LPOLESTR * rule)
{
    HRESULT hr;
    
    CHECK_RETURN_SET_NULL(rule);

    *rule = SysAllocString(TokenToString(m_startRule));

    if (*rule == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEBodyElement::put_timeStartRule(LPOLESTR rule)
{
    HRESULT hr;
    TOKEN newrule;

    newrule = StringToToken(rule);
    if (INVALID_TOKEN == newrule)
    {
        return E_INVALIDARG;
    }

    if (m_startRule != newrule)
    {
        m_startRule = newrule;
    }
    
    SetPropertyFlagAndNotify(DISPID_TIMEBODYELEMENT_TIMESTARTRULE, tb_startRule);
    hr = S_OK;
    return hr;
}

STDMETHODIMP
CTIMEBodyElement::addTIMEDAElement(ITIMEDAElement * elm)
{
    bool ok = false;
    
    CTIMEDAElement * daelm;

    daelm = GetDAElementFromInterface(elm);

    if (daelm == NULL)
    {
        goto done;
    }

    if (!daelm->AddToBody(*this))
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CTIMEBodyElement::removeTIMEDAElement(ITIMEDAElement * elm)
{
    bool ok = false;
    
    CTIMEDAElement * daelm;

    daelm = GetDAElementFromInterface(elm);

    if (daelm == NULL)
    {
        goto done;
    }

    daelm->RemoveFromBody();
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

HRESULT
CTIMEBodyElement::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    if (str)
        return CComCoClass<CTIMEBodyElement, &__uuidof(CTIMEBodyElement)>::Error(str, IID_ITIMEBodyElement, hr);
    else
        return hr;
}

//*****************************************************************************

HRESULT 
CTIMEBodyElement::SetPropertyByIndex(unsigned uIndex, VARIANT *pvarProp)
{
    HRESULT hr = E_FAIL;

    // Rely on the enumeration interval to determine where to look for the property.
    if (teb_maxTIMEElementBaseProp > uIndex)
    {
        hr = CTIMEElementBase::SetPropertyByIndex(uIndex, pvarProp);
    }
    else if (tb_maxTIMEBodyProp > uIndex)
    {
        switch (uIndex)
        {
            case tb_startRule :
                hr = put_timeStartRule(V_BSTR(pvarProp));
                break;
        };
    }

    return hr;
} // SetPropertyByIndex


void CTIMEBodyElement::SetPropertyFlag(DWORD uIndex)
{
    DWORD relIndex;
    if (teb_maxTIMEElementBaseProp > uIndex)
    {
        CTIMEElementBase::SetPropertyFlag(uIndex);
        return;
    }

    relIndex = uIndex - teb_maxTIMEElementBaseProp;
    DWORD bitPosition = 1 << relIndex;
    m_bodyPropertyAccesFlags =  m_bodyPropertyAccesFlags | bitPosition;
}

void CTIMEBodyElement::ClearPropertyFlag(DWORD uIndex)
{
    DWORD relIndex;
    if (teb_maxTIMEElementBaseProp > uIndex)
    {
        CTIMEElementBase::ClearPropertyFlag(uIndex);
        return;
    }

    relIndex = uIndex - teb_maxTIMEElementBaseProp;
    DWORD bitPosition = 1 << relIndex;
    m_bodyPropertyAccesFlags =  m_bodyPropertyAccesFlags & (~bitPosition);
}

bool CTIMEBodyElement::IsPropertySet(DWORD uIndex)
{
    DWORD relIndex;

    if (teb_maxTIMEElementBaseProp > uIndex)
    {
        return CTIMEElementBase::IsPropertySet( uIndex);
    }

    relIndex = uIndex - teb_maxTIMEElementBaseProp;
    if( relIndex >= 32) return true;
    if( relIndex >= tb_maxTIMEBodyProp - teb_maxTIMEElementBaseProp) return true;
    DWORD bitPosition = 1 << relIndex;
    if(m_bodyPropertyAccesFlags & bitPosition)
        return true;
    return false;
}

HRESULT 
CTIMEBodyElement::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint


//*****************************************************************************

HRESULT 
CTIMEBodyElement::GetPropertyByIndex(unsigned uIndex, VARIANT *pvarProp)
{
    HRESULT hr = E_FAIL;

    // Rely on the enumeration interval to determine where to look for the property.
    if (teb_maxTIMEElementBaseProp > uIndex)
    {
        hr = CTIMEElementBase::GetPropertyByIndex(uIndex, pvarProp);
    }
    else if (tb_maxTIMEBodyProp > uIndex)
    {
        Assert(VT_EMPTY == V_VT(pvarProp));
        switch (uIndex)
        {
            case tb_startRule :
                hr = get_timeStartRule(&(V_BSTR(pvarProp)));
                if (SUCCEEDED(hr) && (NULL != V_BSTR(pvarProp)))
                {
                    V_VT(pvarProp) = VT_BSTR;
                }
                break;
        };
    }

    return hr;
} // GetPropertyByIndex

//*****************************************************************************

HRESULT
CTIMEBodyElement::BuildPropertyNameList(CPtrAry<BSTR> *paryPropNames)
{
    // Start from the base class.
    HRESULT hr = CTIMEElementBase::BuildPropertyNameList(paryPropNames);

    if (SUCCEEDED(hr))
    {
        for (int i = teb_maxTIMEElementBaseProp; 
             (i < tb_maxTIMEBodyProp) && (SUCCEEDED(hr)); i++)
        {
            int iRelative = i - teb_maxTIMEElementBaseProp;
            Assert(NULL != ms_rgwszTBodyPropNames[iRelative]);
            BSTR bstrNewName = CreateTIMEAttrName(ms_rgwszTBodyPropNames[iRelative]);
            Assert(NULL != bstrNewName);
            if (NULL != bstrNewName)
            {
                hr = paryPropNames->Append(bstrNewName);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
} // BuildPropertyNameList

//*****************************************************************************

HRESULT 
CTIMEBodyElement::GetPropertyBagInfo(CPtrAry<BSTR> **pparyPropNames)
{
    HRESULT hr = S_OK;

    // If we haven't built this yet, build it now.
    if (0 == ms_aryPropNames.Size())
    {
        hr = BuildPropertyNameList(&(CTIMEBodyElement::ms_aryPropNames));
    }

    if (SUCCEEDED(hr))
    {
        *pparyPropNames = &(CTIMEBodyElement::ms_aryPropNames);
    }

    return hr;
} // GetPropertyBagInfo

//*****************************************************************************

bool
CTIMEBodyElement::IsDocumentStarted()
{
    TraceTag((tagTimeBodyElm, "CTIMEBodyElement::IsDocumentStarted"));
    bool frc = false;
    BSTR bstrState = NULL;
    // get state
    HRESULT hr = GetDocument()->get_readyState(&bstrState);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CTIMEBodyElement::IsDocumentStarted - get_readyState() failed!"));
        goto done;
    }

    Assert(bstrState != NULL);

    if (StrCmpIW(bstrState, L"complete") == 0)
    {
        frc = true;
    }

    SysFreeString(bstrState);

done:
    return frc;
}

#undef THIS
#define THIS CTIMEBodyElement
#define SUPER CTIMEElementBase

#include "pbagimp.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\basebvr.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: basebvr.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "basebvr.h"
#include "tokens.h"

DeclareTag(tagBaseBvr, "API", "CBaseBvr methods");

CBaseBvr::CBaseBvr()
{

    TraceTag((tagBaseBvr,
              "CBaseBvr(%lx)::CBaseBvr()",
              this));
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IElementBehavior

//////////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CBaseBvr::Init(IElementBehaviorSite * pBehaviorSite)
{
    TraceTag((tagBaseBvr,
              "CBaseBvr(%lx)::Init(%lx)",
              this,
              pBehaviorSite));
    
    HRESULT hr = S_OK; 
    DAComPtr<IDispatch> pIDispatch;  
    
    if (pBehaviorSite == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }
    
    m_pBvrSite = pBehaviorSite;

    hr = m_pBvrSite->QueryInterface(IID_IElementBehaviorSiteOM, (void **) &m_pBvrSiteOM);
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(m_pBvrSiteOM.p != NULL);
        
    hr = m_pBvrSiteOM->RegisterName(WZ_REGISTERED_NAME);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pBehaviorSite->GetElement(&m_pHTMLEle));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(m_pHTMLEle.p != NULL);
        
    hr = m_pBvrSite->QueryInterface(IID_IElementBehaviorSiteRender, (void **) &m_pBvrSiteRender);
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(m_pBvrSiteRender.p != NULL);
        
    hr = THR(m_pBvrSite->QueryInterface(IID_IServiceProvider, (void **)&m_pSp));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(m_pSp.p != NULL);
        
    hr = THR(m_pHTMLEle->get_document(&pIDispatch));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(pIDispatch.p != NULL);
        
    hr = THR(pIDispatch->QueryInterface(IID_IHTMLDocument2, (void**)&m_pHTMLDoc));
    if (FAILED(hr))
    {
        goto done;
    }
    
    Assert(m_pHTMLDoc.p != NULL);
        
    // Do not set the init flag since it will be set by the first
    // notify which we want to skip
    
  done:
    return hr;
}
   
STDMETHODIMP
CBaseBvr::Notify(LONG, VARIANT *)
{
    return S_OK;
}

STDMETHODIMP
CBaseBvr::Detach()
{
    TraceTag((tagBaseBvr,
              "CBaseBvr(%lx)::Detach()",
              this));

    m_pBvrSite.Release();
    m_pBvrSiteOM.Release();
    m_pBvrSiteRender.Release();
    m_pHTMLEle.Release();
    m_pHTMLDoc.Release();
    m_pSp.Release();
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IElementBehaviorRender

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBaseBvr::GetRenderInfo(LONG *pdwRenderInfo)
{
    TraceTag((tagBaseBvr,
              "CBaseBvr(%lx)::GetRenderInfo()",
              this));
    
    // Return the layers we are interested in drawing

    // We do not do any rendering so return 0
    
    *pdwRenderInfo = 0;

    return S_OK;
}


STDMETHODIMP
CBaseBvr::Draw(HDC hdc, LONG dwLayer, LPRECT prc, IUnknown * pParams)
{
    TraceTag((tagBaseBvr,
              "CBaseBvr(%lx)::Draw(%#x, %#x, (%d, %d, %d, %d), %#x)",
              this,
              hdc,
              dwLayer,
              prc->left,
              prc->top,
              prc->right,
              prc->bottom,
              pParams));
    
    return E_NOTIMPL;
}

STDMETHODIMP
CBaseBvr::HitTestPoint(LPPOINT point,
                       IUnknown *pReserved,
                       BOOL *hit)
{
    TraceTag((tagBaseBvr,
              "CBaseBvr(%lx)::HitTestPoint()",
              this));

    *hit = FALSE;

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CBaseBvr Methods

void
CBaseBvr::InvalidateRect(LPRECT lprect)
{
    TraceTag((tagBaseBvr,
              "CBaseBvr(%lx)::InvalidateRect",
              this));

    if (m_pBvrSiteRender)
    {
        m_pBvrSiteRender->Invalidate(lprect);
    }
}

void
CBaseBvr::InvalidateRenderInfo()
{
    TraceTag((tagBaseBvr,
              "CBaseBvr(%lx)::InvalidateRenderInfo",
              this));

    if (m_pBvrSiteRender)
    {
        m_pBvrSiteRender->InvalidateRenderInfo();
    }
}

//
// IServiceProvider interfaces
//
STDMETHODIMP
CBaseBvr::QueryService(REFGUID guidService,
                       REFIID riid,
                       void** ppv)
{
    if (InlineIsEqualGUID(guidService, SID_SHTMLWindow))
    {
        DAComPtr<IHTMLWindow2> wnd;

        if (SUCCEEDED(THR(m_pHTMLDoc->get_parentWindow(&wnd))))
        {
            if (wnd)
            {
                if (SUCCEEDED(wnd->QueryInterface(riid, ppv)))
                {
                    return S_OK;
                }
            }
        }
    }

    // Just delegate to our service provider

    return m_pSp->QueryService(guidService,
                               riid,
                               ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\array.h ===
#ifndef _ARRAY_H_
#define _ARRAY_H_

//************************************************************
//
// FileName:        array.h
//
// Created:         01/28/98
//
// Author:          TWillie
// 
// Abstract:        Declaration of the array templates
//
//************************************************************


#define ULREF_IN_DESTRUCTOR 256

//************************************************************
//
// This is the implementation of the generic resizeable array classes. There
// are four array classes:
//
// CPtrAry<ELEM> --
//
//       Dynamic array class which is optimized for sizeof(ELEM) equal
//       to 4. The array is initially empty with no space or memory allocated
//       for data.
//
// CDataAry<ELEM> --
//
//       Same as CPtrAry but where sizeof(ELEM) is != 4 and less than 128.
//
// CStackPtrAry<ELEM, N> --
//
//       Dynamic array class optimized for sizeof(ELEM) equal to 4.
//       Space for N elements is allocated as member data of the class. If
//       this class is created on the stack, then space for N elements will
//       be created on the stack. The class can grow beyond N elements, at
//       which point memory will be allocated for the array data.
//
// CStackDataAry<ELEM, N> --
//
//       Same as CStackPtrAry, but where sizeof(ELEM) is != 4 and less than 128.
//
//
// All four classes have virtually the same methods, and are used the same.
// The only difference is that the DataAry classes have AppendIndirect and
// InsertIndirect, while the PtrAry classes use Append and Insert. The reason
// for the difference is that the Indirect methods take a pointer to the data,
// while the non-indirect methods take the actual data as an argument.
//
// The Stack arrays (CStackPtrAry and CStackDataAry) are used to pre-allocate
// space for elements in the array. This is useful if you create the array on
// the stack and you know that most of the time the array will be less than
// a certain number of elements. Creating one of these arrays on the stack
// allocates the array on the stack as well, preventing a separate memory
// allocation. Only if the array grows beyond the initial size will any
// additional memory be allocated.
//
// The fastest and most efficient way of looping through all elements in
// the array is as follows:
//
//            ELEM * pElem;
//            int    i;
//
//            for (i = aryElems.Size(), pElem = aryElems;
//                 i > 0;
//                 i--, pElem++)
//            {
//                (*pElem)->DoSomething();
//            }
//
// This loop syntax has been shown to be the fastest and produce the smallest
// code. Here's an example using a real data type:
//
//            CStackPtrAry<CSite*, 16> arySites;
//            CSite **ppSite;
//            int     i;
//
//            // Populate the array.
//            ...
//
//            // Now loop through every element in the array.
//            for (i = arySites.Size(), ppSite = arySites;
//                 i > 0;
//                 i--, ppSite++)
//            {
//                (*ppSite)->DoSomething();
//            }
//
// METHOD DESCRIPTIONS:
//
// Commonly used methods:
//
//        Size()             Returns the number of elements currently stored
//                           in the array.
//
//        operator []        Returns the given element in the array.
//
//        Item(int i)        Returns the given element in the array.
//
//        operator ELEM*     Allows the array class to be cast to a pointer
//                           to ELEM. Returns a pointer to the first element
//                           in the array. (Same as a Base() method).
//
//        Append(ELEM e)     Adds a new pointer to the end of the array,
//                           growing the array if necessary.  Only valid
//                           for arrays of pointers (CPtrAry, CStackPtrAry).
//
//        AppendIndirect(ELEM *pe, ELEM** ppePlaced)
//                           As Append, for non-pointer arrays
//                           (CDataAry, CStackDataAry).
//                           pe [in] - Pointer to element to add to array. The
//                                     data is copied into the array. Can be
//                                     NULL, in which case the new element is
//                                     initialized to all zeroes.
//                           ppePlaced [out] - Returns pointer to the new
//                                     element. Can be NULL.
//
//        Insert(int i, ELEM e)
//                           Inserts a new element (e) at the given index (i)
//                           in the array, growing the array if necessary. Any
//                           elements at or following the index are moved
//                           out of the way.
//
//        InsertIndirect(int i, ELEM *pe)
//                           As Insert, for non-pointer arrays
//                                 (CDataAry, CStackDataAry).
//
//        Find(ELEM e)       Returns the index at which a given element (e)
//                           is found (CPtrAry, CStackPtrAry).
//
//        FindIndirect(ELEM *pe)
//                           As Find, for non-pointer arrays
//                                 (CDataAry, CStackDataAry).
//
//        DeleteAll()        Empties the array and de-allocates associated
//                           memory.
//
//        DeleteItem(int i)  Deletes an element of the array, moving any
//                           elements that follow it to fill
//
//        DeleteMultiple(int start, int end)
//                           Deletes a range of elements from the array,
//                           moving to fill. [start] and [end] are the indices
//                           of the start and end elements (inclusive).
//
//        DeleteByValue(ELEM e)
//                           Delete the element matching the given value.
//
//        DeleteByValueIndirect(ELEM *pe)
//                           As DeleteByValue, for non-pointer arrays.
//                                    (CDataAry, CStackDataAry).
//
//
// Less commonly used methods:
//
//        EnsureSize(long c) If you know how many elements you are going to put
//                          in the array before you actually do it, you can use
//                          EnsureSize to allocate the memory all at once instead
//                          of relying on Append(Indirect) to grow the array. This
//                          can be much more efficient (by causing only a single
//                          memory allocation instead of many) than just using
//                          Append(Indirect). You pass in the number of elements
//                          that memory should be allocated for. Note that this
//                          does not affect the "Size" of the array, which is
//                          the number of elements currently stored in it.
//
//        SetSize(int c)    Sets the "Size" of the array, which is the number
//                          of elements currently stored in it. SetSize will not
//                          allocate memory if you're growing the array.
//                          EnsureSize must be called first to reserve space if
//                          the array is growing. Setting the size smaller does
//                          not de-allocate memory, it just chops off the
//                          elements at the end of the array.
//
//        Grow(int c)       Equivalent to calling EnsureSize(c) followed by
//                          SetSize(c).
//
//        BringToFront(int i) Moves the given element of the array to index 0,
//                          shuffling elements to make room.
//
//        SendToBack(int i) Moves the given element to the end of the array,
//                          shuffling elements to make room.
//
//        Swap(int i, int j) Swaps the given two elements.
//
//        ReleaseAll()      (CPtrAry and CStackPtrAry only) Calls Release()
//                          on each element in the array and empties the array.
//
//        ReleaseAndDelete(int idx)
//                          (CPtrAry and CStackPtrAry only) Calls Release() on
//                          the given element and removes it from the array.
//
//           (See the class definitions below for signatures of the following
//            methods and src\core\cdutil\formsary.cxx for argument
//            descriptions)
//
//        CopyAppend        Appends data from another array (of the same type)
//                          to the end.
//
//        Copy              Copies data from another array (of the same type)
//                          into this array, replacing any existing data.
//
//        CopyAppendIndirect  Appends data from a C-style array of element data
//                          to the end of this array.
//
//        CopyIndirect      Copies elements from a C-style array into this array
//                          replacing any existing data.
//
//        EnumElements      Create an enumerator which supports the given
//                          interface ID for the contents of the array
//
//        EnumVARIANT       Create an IEnumVARIANT enumerator.
//
//        operator void *   Allow the CImplAry class to be cast
//                          to a (void *). Avoid using if possible - use
//                          the type-safe operator ELEM * instead.
//
//************************************************************

//************************************************************
//
// Class:     CImplAry
//
// Purpose:   Base implementation of all the dynamic array classes.
//
// Interface:
//
//        Deref       Returns a pointer to an element of the array;
//                    should only be used by derived classes. Use the
//                    type-safe methods operator[] or Item() instead.
//
//        GetAlloced  Get number of elements allocated
//
//  Members:    m_c          Current size of the array
//              m_pv         Buffer storing the elements
//
//  Note:       The CImplAry class only supports arrays of elements
//              whose size is less than 128.
//
//************************************************************

class CImplAry
{
    friend class CBaseEnum;
    friend class CEnumGeneric;
    friend class CEnumVARIANT;

public:
    ~CImplAry();

    inline long Size() const
    {
        return m_c;
    } // Size

    inline void SetSize(int c)
    {
        m_c = c;
    } // SetSize

    inline operator void *()
    {
        return PData();
    } // void *
    
    void DeleteAll();

    void * Deref(size_t cb, int i);

//    NO_COPY(CImplAry);

protected:

    //  Methods which are wrapped by inline subclass methods
    CImplAry();

    HRESULT     EnsureSize(size_t cb, long c);
    HRESULT     Grow(size_t cb, int c);
    HRESULT     AppendIndirect(size_t cb, void *pv, void **ppvPlaced=NULL);
    HRESULT     InsertIndirect(size_t cb, int i, void *pv);
    int         FindIndirect(size_t cb, void *);

    void        DeleteItem(size_t cb, int i);
    bool        DeleteByValueIndirect(size_t cb, void *pv);
    void        DeleteMultiple(size_t cb, int start, int end);

    HRESULT     CopyAppend(size_t cb, const CImplAry& ary, bool fAddRef);
    HRESULT     Copy(size_t cb, const CImplAry& ary, bool fAddRef);
    HRESULT     CopyIndirect(size_t cb, int c, void *pv, bool fAddRef);

    ULONG       GetAlloced(size_t cb);

    HRESULT     EnumElements(size_t   cb,
                             REFIID   iid,
                             void   **ppv,
                             bool     fAddRef,
                             bool     fCopy = true,
                             bool     fDelete = true);

    HRESULT     EnumVARIANT(size_t         cb,
                            VARTYPE        vt,
                            IEnumVARIANT **ppenum,
                            bool           fCopy = true,
                            bool           fDelete = true);

    inline bool UsingStackArray()
    {
        return m_fDontFree;
    } // UsingStackArray

    UINT GetStackSize()
    { 
        Assert(m_fStack);
        return *(UINT*)((BYTE*)this + sizeof(CImplAry));
    } // GetStackSize

    void * GetStackPtr()
    {
        Assert(m_fStack);
        return (void*)((BYTE*)this + sizeof(CImplAry) + sizeof(int));
    } // GetStackPtr

    bool          m_fStack;    // Set if we're a stack-based array.
    bool          m_fDontFree; // Cleared if m_pv points to alloced memory.
    unsigned long m_c;         // Count of elements

    void           *m_pv;

    inline void * & PData()
    {
        return m_pv;
    } // PData
};

//************************************************************
//
//  Member:     CImplAry::CImplAry
//
//************************************************************

inline
CImplAry::CImplAry()
{
    memset(this, 0, sizeof(CImplAry));
} // CImplAry 

//************************************************************
//
//  Member:     CImplAry::Deref
//
//  Synopsis:   Returns a pointer to the i'th element of the array. This
//              method is normally called by type-safe methods in derived
//              classes.
//
//  Arguments:  i
//
//************************************************************

inline void *
CImplAry::Deref(size_t cb, int i)
{
    Assert(i >= 0);
    Assert(ULONG( i ) < GetAlloced(cb));

    return ((BYTE *) PData()) + i * cb;
} // Deref

//************************************************************
//
//  Class:      CImplPtrAry (ary)
//
//  Purpose:    Subclass used for arrays of pointers.  In this case, the
//              element size is known to be sizeof(void *).  Normally, the
//              CPtrAry template is used to define a specific concrete
//              implementation of this class, to hold a specific type of
//              pointer.
//
//              See documentation above for use.
//
//************************************************************

class CImplPtrAry : public CImplAry
{
protected:
    CImplPtrAry() : CImplAry()
    {
    } // CImplPtrAry

    HRESULT     Append(void * pv);
    HRESULT     Insert(int i, void * pv);
    int         Find(void * pv);
    bool        DeleteByValue(void *pv);

    HRESULT     CopyAppend(const CImplAry& ary, bool fAddRef);
    HRESULT     Copy(const CImplAry& ary, bool fAddRef);
    HRESULT     CopyIndirect(int c, void * pv, bool fAddRef);


public:
    HRESULT     EnsureSize(long c);

    HRESULT     Grow(int c);

    void        DeleteItem(int i);
    void        DeleteMultiple(int start, int end);

    void        ReleaseAll();
    void        ReleaseAndDelete(int idx);

    HRESULT     EnumElements(REFIID iid,
                             void **ppv,
                             bool   fAddRef,
                             bool   fCopy = true,
                             bool   fDelete = true);

    HRESULT     EnumVARIANT(VARTYPE        vt,
                            IEnumVARIANT **ppenum,
                            bool           fCopy = true,
                            bool           fDelete = true);
}; // CImplPtrAry

//************************************************************
//
//  Class:      CDataAry
//
//  Purpose:    This template class declares a concrete derived class
//              of CImplAry.
//
//              See documentation above for use.
//
//************************************************************

template <class ELEM>
class CDataAry : public CImplAry
{
public:
    CDataAry() : CImplAry()
    {
    } // CDataAry

    operator ELEM *()
    {
        return (ELEM *)PData();
    } // ELEM *

    CDataAry(const CDataAry &);

    ELEM & Item(int i)
    {
        return *(ELEM*)Deref(sizeof(ELEM), i);
    } // Item

    HRESULT EnsureSize(long c)
    {
        return CImplAry::EnsureSize(sizeof(ELEM), c);
    } // EnsureSize
    
    HRESULT Grow(int c)
    {
        return CImplAry::Grow(sizeof(ELEM), c);
    } // Grow
    
    HRESULT AppendIndirect(ELEM *pe, ELEM **ppePlaced=NULL)
    {
        return CImplAry::AppendIndirect(sizeof(ELEM), (void*)pe, (void**)ppePlaced);
    } // AppendIndirect
    
    ELEM * Append()
    {
        ELEM *pElem;
        return AppendIndirect( NULL, & pElem ) ? NULL : pElem;
    } // Append
    
    HRESULT InsertIndirect(int i, ELEM * pe)
    {
        return CImplAry::InsertIndirect(sizeof(ELEM), i, (void*)pe);
    } // InsertIndirect
    
    int FindIndirect(ELEM * pe)
    {
        return CImplAry::FindIndirect(sizeof(ELEM), (void*)pe);
    } // FindIndirect
    
    void DeleteItem(int i)
    {
        CImplAry::DeleteItem(sizeof(ELEM), i);
    } // DeleteItem
    
    bool DeleteByValueIndirect(ELEM *pe)
    {
        return CImplAry::DeleteByValueIndirect(sizeof(ELEM), (void*)pe);
    } // DeleteByValueIndirect
    
    void DeleteMultiple(int start, int end)
    {
        CImplAry::DeleteMultiple(sizeof(ELEM), start, end);
    } // DeleteMultiple
    
    HRESULT CopyAppend(const CDataAry<ELEM>& ary, bool fAddRef)
    {
        return E_NOTIMPL;
    } // CopyAppend
    
    HRESULT Copy(const CDataAry<ELEM>& ary, bool fAddRef)
    {
        return CImplAry::Copy(sizeof(ELEM), ary, fAddRef);
    } // Copy
    
    HRESULT CopyIndirect(int c, ELEM *pv, bool fAddRef)
    {
        return CImplAry::CopyIndirect(sizeof(ELEM), c, (void*)pv, fAddRef);
    } // CopyIndirect

    HRESULT EnumElements(REFIID  iid,
                         void  **ppv,
                         bool    fAddRef,
                         bool    fCopy = true,
                         bool    fDelete = true)
    {
        return CImplAry::EnumElements(sizeof(ELEM), iid, ppv, fAddRef, fCopy, fDelete);
    } // EnumElements

    HRESULT EnumVARIANT(VARTYPE        vt,
                        IEnumVARIANT **ppenum,
                        bool           fCopy = true,
                        bool           fDelete = true)
    {
        return CImplAry::EnumVARIANT(sizeof(ELEM), vt, ppenum, fCopy, fDelete);
    } // EnumVARIANT
}; // CDataAry

//************************************************************
//
//  Class:      CPtrAry
//
//  Purpose:    This template class declares a concrete derived class
//              of CImplPtrAry.
//
//              See documentation above for use.
//
//************************************************************

template <class ELEM>
class CPtrAry : public CImplPtrAry
{
public:

    CPtrAry() : CImplPtrAry()
    {
        Assert(sizeof(ELEM) == sizeof(void*));
    } // CPtrAry
    
    operator ELEM *()
    {
        return (ELEM *)PData();
    } // ELEM *
    
    CPtrAry(const CPtrAry &);

    ELEM & Item(int i)
    {
        return *(ELEM*)Deref(sizeof(ELEM), i);
    } // Item

    HRESULT Append(ELEM e)
    {
        return CImplPtrAry::Append((void*)e);
    } // Append

    HRESULT Insert(int i, ELEM e)
    {
        return CImplPtrAry::Insert(i, (void*)e);
    } // Insert

    bool DeleteByValue(ELEM e)
    {
        return CImplPtrAry::DeleteByValue((void*)e);
    } // DeleteByValue

    int Find(ELEM e)
    {
        return CImplPtrAry::Find((void*)e);
    } // Find

    HRESULT CopyAppend(const CPtrAry<ELEM>& ary, bool fAddRef)
    {
        return E_NOTIMPL;
    } // CopyAppend
    
    HRESULT Copy(const CPtrAry<ELEM>& ary, bool fAddRef)
    {
        return CImplPtrAry::Copy(ary, fAddRef);
    } // Copy
    
    HRESULT CopyIndirect(int c, ELEM *pe, bool fAddRef)
    {
        return CImplPtrAry::CopyIndirect(c, (void*)pe, fAddRef);
    } // CopyIndirect
}; // CPtrAry

//************************************************************
//
//  Class:      CStackDataAry
//
//  Purpose:    Declares a CDataAry that has initial storage on the stack.
//              N elements are declared on the stack, and the array will
//              grow dynamically beyond that if necessary.
//
//              See documentation above for use.
//
//************************************************************

template <class ELEM, int N>
class CStackDataAry : public CDataAry<ELEM>
{
public:
    CStackDataAry(): CDataAry<ELEM> ()
    {
        m_cStack     = N;
        m_fStack     = true;
        m_fDontFree  = true;
        PData()      = (void *) & m_achTInit;
    } // CStackDataAry

protected:
    int   m_cStack;                     // Must be first data member.
    char  m_achTInit[N*sizeof(ELEM)];
}; // CStackDataAry

//************************************************************
//
//  Class:      CStackPtrAry
//
//  Purpose:    Same as CStackDataAry except for pointer types.
//
//              See documentation above for use.
//
//************************************************************

template <class ELEM, int N>
class CStackPtrAry : public CPtrAry<ELEM>
{
public:
    CStackPtrAry() : CPtrAry<ELEM> ()
    {
        m_cStack     = N;
        m_fStack     = true;
        m_fDontFree  = true;
        PData()      = (void *) & m_achTInit;
    } // CStackPtrAry

protected:
    int   m_cStack;                     // Must be first data member.
    char  m_achTInit[N*sizeof(ELEM)];
}; // CStackPtrAry

//************************************************************
//
//  Class:      CBaseEnum (benum)
//
//  Purpose:    Base OLE enumerator class for a CImplAry.
//
//  Interface:  DECLARE_FORMS_STANRARD_IUNKNOWN
//
//              Next                   -- Per IEnum*
//              Skip                   --    ""
//              Reset                  --    ""
//              Clone                  --    ""
//              CBaseEnum              -- ctor.
//              CBaseEnum              -- ctor.
//              ~CBaseEnum             -- dtor.
//              Init                   -- 2nd stage initialization.
//              Deref                  -- gets pointer to element.
//
//  Notes:      Since there is no IEnum interface, we create a vtable
//              with the same layout as all IEnum interfaces.  Be careful
//              where you put virtual function declarations!
//
//************************************************************

class CBaseEnum : public IUnknown
{
public:
    //
    // IUnknown
    //
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);
    
    STDMETHOD_(ULONG, AddRef) (void)
    {
        return ++m_ulRefs;
    } // AddRef

    STDMETHOD_(ULONG, Release) (void)
    {
        if (--m_ulRefs == 0)
        {
            m_ulRefs = ULREF_IN_DESTRUCTOR;
            delete this;
            return 0;
        }
        return m_ulRefs;
    } // Release

    ULONG GetRefs(void)
    {
        return m_ulRefs;
    } // GetRefs

    //
    //  IEnum methods
    //
    STDMETHOD(Next) (ULONG celt, void * reelt, ULONG * pceltFetched) PURE;
    STDMETHOD(Skip) (ULONG celt);
    STDMETHOD(Reset) ();
    STDMETHOD(Clone) (CBaseEnum ** ppenum) PURE;

    //
    // Ensure that vtable contains virtual destructor after other virtual methods.
    //
    virtual ~CBaseEnum();

protected:
    CBaseEnum(size_t cb, REFIID iid, bool fAddRef, bool fDelete);
    CBaseEnum(const CBaseEnum & benum);

    CBaseEnum& operator=(const CBaseEnum & benum); // don't define

    HRESULT Init(CImplAry *rgItems, bool fCopy);
    void *  Deref(int i);

    CImplAry   *m_rgItems;
    const IID  *m_piid;
    int         m_i;
    size_t      m_cb;
    bool        m_fAddRef;
    bool        m_fDelete;
    ULONG       m_ulRefs;
}; // CBaseEnum

//************************************************************
//
//  Member:     CBaseEnum::Deref
//
//  Synopsis:   Forwards deref to m_rgItems.  Required because classes derived
//              from CBaseEnum are friends of CImplAry.
//
//************************************************************

inline void *
CBaseEnum::Deref(int i)
{
    Assert(i >= 0);
    return (BYTE *)m_rgItems->PData() + i * m_cb;
} // Deref 

#endif // _ARRAY_H_

//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\bodyelmevents.cpp ===
///////////////////////////////////////////////////////////////
// Copyright (c) 1998 Microsoft Corporation
//
// File: EventMgr.cpp
//
// Abstract:  
//
///////////////////////////////////////////////////////////////

#include "headers.h"
#include "daview.h"
#include "mshtmdid.h"
#include "tokens.h"
#include "bodyelm.h"
#include "BodyElementEvents.h"

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  


DeclareTag(tagBodyElementEvents, "API", "Body Element Events methods");


CBodyElementEvents::CBodyElementEvents(CTIMEBodyElement & elm)
: m_elm(elm),
  m_pDocConPt(NULL),
  m_pWndConPt(NULL),
  m_dwDocumentEventConPtCookie(0),
  m_dwWindowEventConPtCookie(0),
  m_refCount(1),
  m_pElement(NULL)
{
    TraceTag((tagBodyElementEvents,
              "CBodyElementEvents(%lx)::CBodyElementEvents(%lx)",
              this,
              &elm));
}

CBodyElementEvents::~CBodyElementEvents()
{
    TraceTag((tagBodyElementEvents,
              "CBodyElementEvents(%lx)::~CBodyElementEvents()",
              this));
}


HRESULT CBodyElementEvents::Init()
{
    HRESULT hr;
      
    m_pElement = m_elm.GetElement();
    m_pElement->AddRef();

    hr = THR(ConnectToContainerConnectionPoint());
    if (FAILED(hr))
    {
        goto done;
    }

  done:
    return hr;
}

HRESULT CBodyElementEvents::Deinit()
{
    if (m_pElement)
    {
        m_pElement->Release();
        m_pElement = NULL;
    }

    if (m_dwDocumentEventConPtCookie != 0 && m_pDocConPt)
    {
        m_pDocConPt->Unadvise (m_dwDocumentEventConPtCookie);
    }
    m_dwDocumentEventConPtCookie = 0;

    if (m_dwWindowEventConPtCookie != 0 && m_pWndConPt)
    {
        m_pWndConPt->Unadvise (m_dwWindowEventConPtCookie);
    }
    m_dwWindowEventConPtCookie = 0;

    
    return S_OK;
}

HRESULT CBodyElementEvents::ConnectToContainerConnectionPoint()
{
// Get a connection point to the container
    DAComPtr<IConnectionPointContainer> pWndCPC;
    DAComPtr<IConnectionPointContainer> pDocCPC; 
    DAComPtr<IHTMLDocument> pDoc; 
    DAComPtr<IDispatch> pDocDispatch;
    DAComPtr<IDispatch> pScriptDispatch;

    HRESULT hr;

    hr = THR(m_pElement->get_document(&pDocDispatch));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //get the document and cache it.
    hr = THR(pDocDispatch->QueryInterface(IID_IHTMLDocument, (void**)&pDoc));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //hook the documents events
    hr = THR(pDoc->QueryInterface(IID_IConnectionPointContainer, (void**)&pDocCPC));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(pDocCPC->FindConnectionPoint( DIID_HTMLDocumentEvents, &m_pDocConPt ));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    
    hr = THR(m_pDocConPt->Advise((IUnknown *)this, &m_dwDocumentEventConPtCookie));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //hook the windows events
    hr = THR(pDoc->get_Script (&pScriptDispatch));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(pScriptDispatch->QueryInterface(IID_IConnectionPointContainer, (void**)&pWndCPC));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    } 

    hr = THR(pWndCPC->FindConnectionPoint( DIID_HTMLWindowEvents, &m_pWndConPt ));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_pWndConPt->Advise((IUnknown *)this, &m_dwWindowEventConPtCookie));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;    
}


//IDispatch Methods
STDMETHODIMP CBodyElementEvents::QueryInterface( REFIID riid, void **ppv )
{
    if (NULL == ppv)
        return E_POINTER;

    *ppv = NULL;

    if ( InlineIsEqualGUID(riid, IID_IDispatch))
    {
        *ppv = this;
    }
        
    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CBodyElementEvents::AddRef(void)
{
    return ++m_refCount;
}


STDMETHODIMP_(ULONG) CBodyElementEvents::Release(void)
{
    m_refCount--;
    if (m_refCount == 0)
    {
        //delete this;
    }

    return m_refCount;
}

STDMETHODIMP CBodyElementEvents::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBodyElementEvents::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
                                   /* [in] */ LCID /*lcid*/,
                                   /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBodyElementEvents::GetIDsOfNames(
    /* [in] */ REFIID /*riid*/,
    /* [size_is][in] */ LPOLESTR* /*rgszNames*/,
    /* [in] */ UINT /*cNames*/,
    /* [in] */ LCID /*lcid*/,
    /* [size_is][out] */ DISPID* /*rgDispId*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBodyElementEvents::Invoke(
    /* [in] */ DISPID dispIdMember,
    /* [in] */ REFIID /*riid*/,
    /* [in] */ LCID /*lcid*/,
    /* [in] */ WORD /*wFlags*/,
    /* [out][in] */ DISPPARAMS* pDispParams,
    /* [out] */ VARIANT* pVarResult,
    /* [out] */ EXCEPINFO* /*pExcepInfo*/,
    /* [out] */ UINT* puArgErr)
{
    // Listen for the two events we're interested in, and call back if necessary
    HRESULT hr = S_OK;

    switch (dispIdMember)
    {
        case DISPID_EVPROP_ONREADYSTATECHANGE:
        case DISPID_EVMETH_ONREADYSTATECHANGE:
            IGNORE_HR(ReadyStateChange());
            break;

        case DISPID_EVPROP_ONLOAD:
        case DISPID_EVMETH_ONLOAD:
            m_elm.OnLoad();
            break;

        case DISPID_EVPROP_ONUNLOAD:
        case DISPID_EVMETH_ONUNLOAD:
            m_elm.OnUnload();    
            break;
    }
    
  done:
    return S_OK;
}


HRESULT CBodyElementEvents::ReadyStateChange()
{   
    HRESULT hr;
    DAComPtr <IHTMLElement2> pElement2;
    VARIANT vReadyState;

    TOKEN tokReadyState = INVALID_TOKEN; 

    hr = THR(m_pElement->QueryInterface(IID_IHTMLElement2, (void **)&pElement2));
    if (FAILED (hr))
    {
        goto done;
    }

    hr = THR(pElement2->get_readyState(&vReadyState));
    if (FAILED (hr))
    {
        goto done;
    }

    if (vReadyState.vt != VT_BSTR)
    {
        hr = THR(VariantChangeType(&vReadyState, &vReadyState, 0, VT_BSTR));
        if (FAILED(hr))
        {
            VariantClear(&vReadyState)         ;
            goto done;
        }
    }

    tokReadyState = StringToToken(vReadyState.bstrVal);

    if (tokReadyState != INVALID_TOKEN)
    {
        m_elm.OnReadyStateChange(tokReadyState);
    }

    SysFreeString (vReadyState.bstrVal);
    VariantClear(&vReadyState);

  done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\bodyelm.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: bodyelm.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _BODYELM_H
#define _BODYELM_H

#include "timeelmbase.h"
#include "mmutil.h"

/////////////////////////////////////////////////////////////////////////////
// CTIMEBodyElement

#define DEFAULT_SYNC_TOLERANCE_S 0.2f

class
ATL_NO_VTABLE
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CTIMEBodyElement :
    public CTIMEElementBase,
    public CComCoClass<CTIMEBodyElement, &__uuidof(CTIMEBodyElement)>,
    public IDispatchImpl<ITIMEBodyElement, &IID_ITIMEBodyElement, &LIBID_TIME>,
    public ISupportErrorInfoImpl<&IID_ITIMEBodyElement>,
    public IConnectionPointContainerImpl<CTIMEBodyElement>,
    public IPersistPropertyBag2,
    public IPropertyNotifySinkCP<CTIMEBodyElement>
{
    public:
        CTIMEBodyElement();
        ~CTIMEBodyElement();
    
#if _DEBUG
        const _TCHAR * GetName() { return __T("CTIMEBodyElement"); }
#endif

        STDMETHOD_(ULONG,AddRef)(void) = 0;
        STDMETHOD_(ULONG,Release)(void) = 0;
        STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;

        STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);
        STDMETHOD(Detach)();

        virtual HRESULT InitTimeline(void);

        virtual void OnReadyStateChange(TOKEN state);
        virtual void OnLoad();
        virtual void OnPause(double dblLocalTime);
        virtual void OnResume(double dblLocalTime);
        virtual void OnSync(double dbllastTime, double & dblnewTime);

        virtual HRESULT base_pause();
        virtual HRESULT base_resume();

        //
        //IPersistPropertyBag2
        // 
        STDMETHOD(GetClassID)(CLSID* pclsid);
        STDMETHOD(InitNew)(void);
        STDMETHOD(IsDirty)(void)
            {return S_OK;};
        STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
        STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

        //
        // ITIMEElement
        //
    
        STDMETHOD(get_begin)(VARIANT * time)
        { return base_get_begin(time); }
        STDMETHOD(put_begin)(VARIANT time)
        { return base_put_begin(time); }

        STDMETHOD(get_beginWith)(VARIANT * time)
        { return base_get_beginWith(time); }
        STDMETHOD(put_beginWith)(VARIANT time)
        { return base_put_beginWith(time); }

        STDMETHOD(get_beginAfter)(VARIANT * time)
        { return base_get_beginAfter(time); }
        STDMETHOD(put_beginAfter)(VARIANT time)
        { return base_put_beginAfter(time); }

        STDMETHOD(get_beginEvent)(VARIANT * time)
        { return base_get_beginEvent(time); }
        STDMETHOD(put_beginEvent)(VARIANT time)
        { return base_put_beginEvent(time); }

        STDMETHOD(get_dur)(VARIANT * time)
        { return base_get_dur(time); }
        STDMETHOD(put_dur)(VARIANT time)
        { return base_put_dur(time); }

        STDMETHOD(get_end)(VARIANT * time)
        { return base_get_end(time); }
        STDMETHOD(put_end)(VARIANT time)
        { return base_put_end(time); }

        STDMETHOD(get_endWith)(VARIANT * time)
        { return base_get_endWith(time); }
        STDMETHOD(put_endWith)(VARIANT time)
        { return base_put_endWith(time); }

        STDMETHOD(get_endEvent)(VARIANT * time)
        { return base_get_endEvent(time); }
        STDMETHOD(put_endEvent)(VARIANT time)
        { return base_put_endEvent(time); }

        STDMETHOD(get_endSync)(VARIANT * time)
        { return base_get_endSync(time); }
        STDMETHOD(put_endSync)(VARIANT time)
        { return base_put_endSync(time); }

        STDMETHOD(get_repeat)(VARIANT * time)
        { return base_get_repeat(time); }
        STDMETHOD(put_repeat)(VARIANT time)
        { return base_put_repeat(time); }

        STDMETHOD(get_repeatDur)(VARIANT * time)
        { return base_get_repeatDur(time); }
        STDMETHOD(put_repeatDur)(VARIANT time)
        { return base_put_repeatDur(time); }

        STDMETHOD(get_accelerate)(int * time)
        { return base_get_accelerate(time); }
        STDMETHOD(put_accelerate)(int time)
        { return base_put_accelerate(time); }

        STDMETHOD(get_decelerate)(int  * time)
        { return base_get_decelerate(time); }
        STDMETHOD(put_decelerate)(int time)
        { return base_put_decelerate(time); }

        STDMETHOD(get_autoReverse)(VARIANT_BOOL * b)
        { return base_get_autoReverse(b); }
        STDMETHOD(put_autoReverse)(VARIANT_BOOL b)
        { return base_put_autoReverse(b); }

        STDMETHOD(get_endHold)(VARIANT_BOOL * b)
        { return base_get_endHold(b); }
        STDMETHOD(put_endHold)(VARIANT_BOOL b)
        { return base_put_endHold(b); }

        STDMETHOD(get_eventRestart)(VARIANT_BOOL * b)
        { return base_get_eventRestart(b); }
        STDMETHOD(put_eventRestart)(VARIANT_BOOL b)
        { return base_put_eventRestart(b); }

        STDMETHOD(get_timeAction)(LPOLESTR * time)
        { return base_get_timeAction(time); }
        STDMETHOD(put_timeAction)(LPOLESTR time)
        { return base_put_timeAction(time); }

        STDMETHOD(beginElement)()
        { return base_beginElement(true); }
        STDMETHOD(endElement)()
        { return base_endElement(); }
        STDMETHOD(pause)()
        { return base_pause(); }
        STDMETHOD(resume)()
        { return base_resume(); }
        STDMETHOD(cue)()
        { return base_cue(); }

        STDMETHOD(get_timeline)(BSTR * pbstrTimeLine)
        { return base_get_timeline(pbstrTimeLine); }
        STDMETHOD(put_timeline)(BSTR bstrTimeLine)
        { return base_put_timeline(bstrTimeLine); }

        STDMETHOD(get_currTime)(float * time)
        { return base_get_currTime(time); }
        STDMETHOD(put_currTime)(float time)
        { return base_put_currTime(time); }

        STDMETHOD(get_localTime)(float * time)
        { return base_get_localTime(time); }
        STDMETHOD(put_localTime)(float time)
        { return base_put_localTime(time); }

        STDMETHOD(get_currState)(LPOLESTR * state)
        { return base_get_currState(state); }
        STDMETHOD(put_currState)(LPOLESTR state)
        { return base_put_currState(state); }

        STDMETHOD(get_syncBehavior)(LPOLESTR * sync)
        { return base_get_syncBehavior(sync); }
        STDMETHOD(put_syncBehavior)(LPOLESTR sync)
        { return base_put_syncBehavior(sync); }

        STDMETHOD(get_syncTolerance)(VARIANT * tol)
        { return base_get_syncTolerance(tol); }
        STDMETHOD(put_syncTolerance)(VARIANT tol)
        { return base_put_syncTolerance(tol); }

        STDMETHOD(get_parentTIMEElement)(ITIMEElement **bvr)
        { return base_get_parentTIMEElement(bvr); }
        STDMETHOD(put_parentTIMEElement)(ITIMEElement *bvr)
        { return base_put_parentTIMEElement(bvr); }

        STDMETHOD(get_allTIMEElements)(/*[out, retval]*/ ITIMEElementCollection **ppDisp);
        STDMETHOD(get_childrenTIMEElements)(/*[out, retval]*/ ITIMEElementCollection **ppDisp);
        STDMETHOD(get_allTIMEInterfaces)(/*[out, retval]*/ ITIMEElementCollection **ppDisp);
        STDMETHOD(get_childrenTIMEInterfaces)(/*[out, retval]*/ ITIMEElementCollection **ppDisp);

        STDMETHOD(get_timelineBehavior)(IDispatch ** bvr)
        { return base_get_timelineBehavior(bvr); }
        STDMETHOD(get_progressBehavior)(IDispatch ** bvr)
        { return base_get_progressBehavior(bvr); }
        STDMETHOD(get_onOffBehavior)(IDispatch ** bvr)
        { return base_get_onOffBehavior(bvr); }

        //
        // ITIMEBodyElement
        //
    
        STDMETHOD(get_timeStartRule)(LPOLESTR * startrule);
        STDMETHOD(put_timeStartRule)(LPOLESTR startrule);

        STDMETHOD(addTIMEDAElement)(ITIMEDAElement * daelm);
        STDMETHOD(removeTIMEDAElement)(ITIMEDAElement * daelm);

        // QI Map
    
        BEGIN_COM_MAP(CTIMEBodyElement)
            COM_INTERFACE_ENTRY(ITIMEBodyElement)
            COM_INTERFACE_ENTRY(ITIMEElement)
            COM_INTERFACE_ENTRY(IDispatch)
            COM_INTERFACE_ENTRY(ISupportErrorInfo)
            COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
            COM_INTERFACE_ENTRY(IPersistPropertyBag2)
            COM_INTERFACE_ENTRY_CHAIN(CBaseBvr)
        END_COM_MAP();

        // Connection Point to allow IPropertyNotifySink
        BEGIN_CONNECTION_POINT_MAP(CTIMEBodyElement)
            CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
        END_CONNECTION_POINT_MAP();

        // This must be in the derived class and not the base class since
        // the typecast down to the base class messes things up
        static inline HRESULT WINAPI
            InternalQueryInterface(CTIMEBodyElement* pThis,
                                   const _ATL_INTMAP_ENTRY* pEntries,
                                   REFIID iid,
                                   void** ppvObject)
        { return BaseInternalQueryInterface(pThis,
                                            (void *) pThis,
                                            pEntries,
                                            iid,
                                            ppvObject); }

        // Needed by CBvrBase
    
        void * GetInstance()
        { return (ITIMEBodyElement *) this ; }
        HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
        { return GetTI(GetUserDefaultLCID(), ppInfo); }
    
        MMPlayer & GetPlayer()
        { return m_player; }

        virtual bool IsGroup() { return true; }
        virtual bool IsBody() { return true; }
  
        float    GetDefaultSyncTolerance()
        { return DEFAULT_SYNC_TOLERANCE_S; }
        TOKEN    GetDefaultSyncBehavior()
        { return CANSLIP_TOKEN; }

        bool IsDocumentStarted();
        bool IsRootStarted() { return m_fStartRoot; }

    protected:
        HRESULT Error();
    
        virtual HRESULT StartRootTime(MMTimeline * tl);
        virtual void StopRootTime(MMTimeline * tl);

        enum PROPERTY_INDEX
        {
            tb_startRule = teb_maxTIMEElementBaseProp, 
            tb_maxTIMEBodyProp,
        };

        virtual HRESULT BuildPropertyNameList (CPtrAry<BSTR> *paryPropNames);
        virtual HRESULT SetPropertyByIndex(unsigned uIndex, VARIANT *pvarProp);
        virtual HRESULT GetPropertyByIndex(unsigned uIndex, VARIANT *pvarProp);
        virtual void SetPropertyFlag(DWORD uIndex);
        virtual void ClearPropertyFlag(DWORD uIndex);
        virtual bool IsPropertySet(DWORD uIndex);
        virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);
        virtual bool NeedSyncCB() { return true;}

    protected:
        TOKEN           m_startRule;
        MMPlayer        m_player;

        HRESULT GetPropertyBagInfo(CPtrAry<BSTR> **pparyPropNames);

        static LPWSTR ms_rgwszTBodyPropNames[];
        static CPtrAry<BSTR> ms_aryPropNames;
        static DWORD ms_dwNumBodyElems;
        DWORD m_bodyPropertyAccesFlags;
    private:
        bool    m_fStartRoot;
};

inline HRESULT CTIMEBodyElement::get_allTIMEElements(ITIMEElementCollection **ppDisp)
{
    return base_get_collection(ciAllElements, ppDisp);
} // get_all

inline HRESULT CTIMEBodyElement::get_childrenTIMEElements(ITIMEElementCollection **ppDisp)
{
    return base_get_collection(ciChildrenElements, ppDisp);
} // get_children

inline HRESULT CTIMEBodyElement::get_allTIMEInterfaces(ITIMEElementCollection **ppDisp)
{
    return base_get_collection(ciAllInterfaces, ppDisp);
} // get_time_all

inline HRESULT CTIMEBodyElement::get_childrenTIMEInterfaces(ITIMEElementCollection **ppDisp)
{
    return base_get_collection(ciChildrenInterfaces, ppDisp);
} // get_time_children

#endif /* _BODYELM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\bodyelmevents.h ===
///////////////////////////////////////////////////////////////
// Copyright (c) 1998 Microsoft Corporation
//
// File: BodyElementEvents.h
//
// Abstract:
//
///////////////////////////////////////////////////////////////

#ifndef _BODYELEMENTEVENTS_H
#define _BODYELEMENTEVENTS_H

class CTIMEBodyElement;

class CBodyElementEvents
    : public IDispatch
{
  public:
    CBodyElementEvents(CTIMEBodyElement  & elm);
    ~CBodyElementEvents();

    //methods
    HRESULT Init();
    HRESULT Deinit();

    //QueryInterface 
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
    STDMETHODIMP GetTypeInfo(/* [in] */ UINT iTInfo,
                             /* [in] */ LCID lcid,
                             /* [out] */ ITypeInfo** ppTInfo);
    STDMETHODIMP GetIDsOfNames(
        /* [in] */ REFIID riid,
        /* [size_is][in] */ LPOLESTR *rgszNames,
        /* [in] */ UINT cNames,
        /* [in] */ LCID lcid,
        /* [size_is][out] */ DISPID *rgDispId);
    STDMETHODIMP Invoke(
        /* [in] */ DISPID dispIdMember,
        /* [in] */ REFIID riid,
        /* [in] */ LCID lcid,
        /* [in] */ WORD wFlags,
        /* [out][in] */ DISPPARAMS  *pDispParams,
        /* [out] */ VARIANT  *pVarResult,
        /* [out] */ EXCEPINFO *pExcepInfo,
        /* [out] */ UINT *puArgErr);


  protected:
    CTIMEBodyElement &                m_elm;
    DAComPtr<IHTMLElement>            m_pElement;
    DAComPtr<IConnectionPoint>        m_pDocConPt;
    DAComPtr<IConnectionPoint>        m_pWndConPt;
    DWORD                             m_dwDocumentEventConPtCookie;
    DWORD                             m_dwWindowEventConPtCookie;
    long                              m_refCount;   
    
    HRESULT                           ConnectToContainerConnectionPoint();
    HRESULT                           ReadyStateChange();
};

#endif /* _BODYELEMENTEVENTS_H*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\clock.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: clock.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "clock.h"

static LPCTSTR s_rgtchStarvationWindowClassName = _T("StarveTimer");
static LPCTSTR s_rgtchStarvationWindowName = _T("");

static const ULONG s_ulStarveCallbackInterval = 100;
static const ULONG s_ulStarvationThreshold = 3 * s_ulStarveCallbackInterval / 2;
static const ULONG s_ulStarvationFirstBackoffConstant = 2;
static const ULONG s_ulStarvationNBackoffConstant = 5;

DeclareTag(tagClock, "API", "Clock methods");

Clock::Clock()
: m_ulRefs(1),
  m_cookie(0),
  m_lastTime(0.0),
  m_curTime(0.0),
  m_ulLastStarvationCallback(0),
  m_uStarveTimerID(0),
  m_hWndStarveTimer(NULL),
  m_ulConsectiveStarvedTicks(0),
  m_fAllowOnTimer(true),
  m_fAllowStarvationCallback(true),
  m_state(CS_STOPPED)
{
    TraceTag((tagClock,
              "Clock(%lx)::Clock()",
              this));
}

Clock::~Clock()
{
    TraceTag((tagClock,
              "Clock(%lx)::~Clock()",
              this));

    Stop();

    if (NULL != m_hWndStarveTimer)
    {
        ::DestroyWindow(m_hWndStarveTimer);
    }
}

STDMETHODIMP
Clock::QueryInterface(REFIID riid, LPVOID * ppv)
{
    HRESULT hr = E_POINTER;

    if (ppv != NULL)
    {
        hr = E_NOINTERFACE;
        
        if (::IsEqualIID(riid, IID_ITimerSink) ||
            ::IsEqualIID(riid, IID_IUnknown))
        {
            *ppv = (ITimerSink *)this;
            AddRef();
            hr  = S_OK;
        }
    }

    return hr;
}

STDMETHODIMP_(ULONG)
Clock::AddRef(void)
{
    return ++m_ulRefs;
}

STDMETHODIMP_(ULONG)
Clock::Release(void)
{
    if (--m_ulRefs == 0)
    {
        delete this;
        return 0;
    }

    return m_ulRefs;
}

ULONG
Clock::GetNextInterval (void)
{
    ULONG ulInterval = m_interval;

    // If this is our first time through, 
    // we'll use the interval without question
    if (0 != m_ulLastStarvationCallback)
    {
        // How long since our last starvation callback?
        Assert(m_timer);
        if (m_timer)
        {
            CComVariant v;
            HRESULT hr = THR(m_timer->GetTime(&v));

            if (SUCCEEDED(hr))
            {
                // Have we hit the starvation threshold?  Also allow for the unlikely clock rollover.
                ULONG ulTimeSinceLastStarvationCallback = V_UI4(&v) - m_ulLastStarvationCallback;

                if ((m_ulLastStarvationCallback > V_UI4(&v)) ||
                    (ulTimeSinceLastStarvationCallback > s_ulStarvationThreshold))
                {
                    // If we're starving more than once, then back off more.
                    if (0 == m_ulConsectiveStarvedTicks)
                    {
                        ulInterval *= s_ulStarvationFirstBackoffConstant;
                    }
                    else
                    {
                        ulInterval *= s_ulStarvationNBackoffConstant;
                    }
                    m_ulConsectiveStarvedTicks++;
                }
                // Make sure to clear the starved tick count.
                else if (0 != m_ulConsectiveStarvedTicks)
                {
                    m_ulConsectiveStarvedTicks = 0;
                }
            }
        }
    }

    return ulInterval;
} // GetNextInterval

STDMETHODIMP
Clock::OnTimer(VARIANT timeAdvise)
{
    HRESULT hr = S_OK;

    // We have to protect ourselves against 
    // advise sink reentrancy.
    if (m_fAllowOnTimer)
    {
        m_fAllowOnTimer = false;
        // The 'cookie' expires as soon as this
        // callback occurs.
        m_cookie = 0;
        ProcessCB(GetITimerTime());
        // Adjust the new interval based on 
        // current load.
        hr = SetNextTimerInterval(GetNextInterval());
        m_fAllowOnTimer = true;
    }

    return hr;
}

HRESULT
Clock::SetITimer(IServiceProvider * serviceProvider, ULONG interval)
{
    HRESULT hr;

    DAComPtr<ITimerService> pTimerService;

    m_timer.Release();
    m_interval = interval;
    
    if (!serviceProvider)
    {
        return E_FAIL;
    }
    
    hr = serviceProvider->QueryService(SID_STimerService,
                                       IID_ITimerService,
                                       (void**)&pTimerService);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pTimerService->GetNamedTimer(NAMEDTIMER_DRAW, &m_timer);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

double
Clock::GetITimerTime()
{
    Assert(m_timer);
    
    CComVariant v;
    
    HRESULT hr = THR(m_timer->GetTime(&v));

    Assert(SUCCEEDED(hr));

    hr = THR(v.ChangeType(VT_R8));

    Assert(SUCCEEDED(hr));
    
    return (V_R8(&v) / 1000.0);
}

void
Clock::CreateStarveTimerWindow (void)
{
    Assert(NULL == m_hWndStarveTimer);
    if (NULL == m_hWndStarveTimer)
    {
        WNDCLASS wndclass;
        memset(&wndclass, 0, sizeof(wndclass));
        wndclass.style         = 0;
        wndclass.lpfnWndProc   = Clock::StarveWndProc;
        wndclass.hInstance     = _Module.GetModuleInstance();
        wndclass.hCursor       = NULL;
        wndclass.hbrBackground = NULL;
        wndclass.lpszClassName = s_rgtchStarvationWindowClassName;
        ::RegisterClass(&wndclass);
        
        m_hWndStarveTimer = ::CreateWindowEx(
            WS_EX_TOOLWINDOW,
            s_rgtchStarvationWindowClassName,
            s_rgtchStarvationWindowName,
            WS_POPUP,
            0, 0, 0, 0,
            NULL,
            NULL,
            wndclass.hInstance,
            (LPVOID)NULL);
        if (NULL != m_hWndStarveTimer)
        {
            ::SetWindowLongPtr(m_hWndStarveTimer, GWLP_USERDATA, (LONG_PTR)this);
        }
    }
} // CreateStarveTimerWindow

void
Clock::SetStarveTimer (void)
{
    // Create the window on demand.
    if (NULL == m_hWndStarveTimer)
    {
        CreateStarveTimerWindow();
    }

    Assert(NULL != m_hWndStarveTimer);
    if (NULL != m_hWndStarveTimer)
    {
        // Make sure to roll past zero.
        if (0 == (++m_uStarveTimerID))
        {
            ++m_uStarveTimerID;
        }
        UINT uRes = ::SetTimer(m_hWndStarveTimer, m_uStarveTimerID, s_ulStarveCallbackInterval, NULL);
        Assert(uRes);
    }
} // SetStarveTimer

HRESULT
Clock::StartITimer()
{
    // This initializes starvation timer as well 
    // as the last-callback-time data, giving us a baseline 
    // from which to judge starvation at startup.
    StarvationCallback();

    return SetNextTimerInterval(m_interval);
} // StartITimer

HRESULT
Clock::SetNextTimerInterval (ULONG ulNextInterval)
{
    HRESULT hr = S_OK;
    
    // Next, get the current time and with the interval set
    // the timer to advise us again.
    VARIANT vtimeMin, vtimeMax, vtimeInt;

    VariantInit( &vtimeMin );
    VariantInit( &vtimeMax );
    VariantInit( &vtimeInt );
    V_VT(&vtimeMin) = VT_UI4;
    V_VT(&vtimeMax) = VT_UI4;
    V_VT(&vtimeInt) = VT_UI4;
    V_UI4(&vtimeMax) = 0;
    V_UI4(&vtimeInt) = 0;
    hr = THR(m_timer->GetTime(&vtimeMin));
    
    if (FAILED(hr))
    {
        goto done;
    }

    V_UI4(&vtimeMin) += ulNextInterval;

    hr = THR(m_timer->Advise(vtimeMin,
                             vtimeMax,
                             vtimeInt,
                             0,
                             this,
                             &m_cookie));

    if (FAILED(hr))
    {
        goto done;
    }

    if (!m_cookie)
    {
        TraceTag((tagError,
                  "Clock::ITimer::Advise failed with bad cookie"));
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
    
  done:
    return hr;
} // SetNextTimerInterval

HRESULT
Clock::StopITimer()
{
    HRESULT hr = S_OK;
    
    if (m_timer && m_cookie)
    {
        hr = THR(m_timer->Unadvise(m_cookie));

        m_cookie = 0;
    }

    // Stop the starvation timer and 
    // reset the last starvation callback time.
    if (0 != m_uStarveTimerID)
    {
        ::KillTimer(m_hWndStarveTimer, m_uStarveTimerID);
        m_uStarveTimerID = 0;
    }
    m_ulLastStarvationCallback = 0;

    return hr;
}

HRESULT
Clock::Start()
{
    HRESULT hr;
    
    Stop();

    if (!m_timer)
    {
        hr = E_FAIL;
        goto done;
    }
    
    hr = THR(StartITimer());

    if (FAILED(hr))
    {
        goto done;
    }

    m_curTime = 0.0;
    m_lastTime = GetGlobalTime();
    m_state = CS_STARTED;
    
    hr = S_OK;
  done:
    return hr;
}

HRESULT
Clock::Pause()
{
    HRESULT hr;

    if (m_state == CS_PAUSED)
    {
        hr = S_OK;
        goto done;
    }

    if (m_state == CS_STARTED)
    {
        hr = THR(StopITimer());

        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    m_state = CS_PAUSED;
    hr = S_OK;
    
  done:
    return hr;
}

HRESULT
Clock::Resume()
{
    HRESULT hr;

    if (m_state == CS_STARTED)
    {
        hr = S_OK;
        goto done;
    }

    if (m_state == CS_STOPPED)
    {
        hr = THR(Start());
        goto done;
    }
    
    Assert(m_state == CS_PAUSED);

    hr = THR(StartITimer());

    if (FAILED(hr))
    {
        goto done;
    }
    
    m_lastTime = GetGlobalTime();
    m_state = CS_STARTED;
    
    hr = S_OK;
    
  done:
    return hr;
}

HRESULT
Clock::Stop()
{
    THR(StopITimer());
    m_state = CS_STOPPED;
    return S_OK;
}

void
Clock::ProcessCB(double time)
{
    if (m_state == CS_STARTED)
    {
        if (time > m_lastTime)
        {
            m_curTime += (time - m_lastTime);
            m_lastTime = time;

            if (m_pClockSink)
            {
                m_pClockSink->OnTimer(m_curTime);
            }
        }
    }
}

void
Clock::StarvationCallback (void)
{
    if (m_fAllowStarvationCallback)
    {
        m_fAllowStarvationCallback = false;
        Assert(m_timer);
        if (m_timer)
        {
            CComVariant v;
            HRESULT hr = THR(m_timer->GetTime(&v));
            if (SUCCEEDED(hr))
            {
                m_ulLastStarvationCallback = V_UI4(&v);
            }
        }
        ::KillTimer(m_hWndStarveTimer, m_uStarveTimerID);
        SetStarveTimer();
        m_fAllowStarvationCallback = true;
    }
} // StarvationCallback 

LRESULT __stdcall 
Clock::StarveWndProc(HWND hWnd, UINT uiMessage, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;

    if (uiMessage == WM_TIMER)
    {
        Clock *pThis = reinterpret_cast<Clock *>(::GetWindowLongPtr(hWnd, GWLP_USERDATA));

        if (NULL != pThis)
        {
            pThis->StarvationCallback();
        }
    }

    lResult = ::DefWindowProc(hWnd, uiMessage, wParam, lParam);

    return lResult;
} // StarveWndProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\collect.cpp ===
//************************************************************
//
// Filename:    collect.cpp
//
// Created:     09/25/98
//
// Author:	twillie
//
//              Collection implementation.
//
//************************************************************

#include "headers.h"
#include "collect.h"

// Suppress new warning about NEW without corresponding DELETE
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )

#define TYPELIB_VERSION_MAJOR 1
#define TYPELIB_VERSION_MINOR 0

#define FL_UNSIGNED   1       /* wcstoul called */
#define FL_NEG        2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */

#define LONG_MIN    (-2147483647L - 1) /* minimum (signed) long value */
#define LONG_MAX      2147483647L   /* maximum (signed) long value */
#define ULONG_MAX     0xffffffffUL  /* maximum unsigned long value */

//
// local prototypes
//
HRESULT ttol_with_error(const WCHAR *pStr, long *plValue);
static HRESULT PropertyStringToLong(const WCHAR   *nptr,
                                    WCHAR        **endptr,
                                    int            ibase,
                                    int            flags,
                                    unsigned long *plNumber);


DeclareTag(tagTimeCollection, "API", "CTIMEElementCollection methods");
DeclareTag(tagCollectionCache, "API", "CCollectionCache methods");


//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    check to see if string is number
//************************************************************

HRESULT
ttol_with_error(const WCHAR *pStr, long *plValue)
{
    // Always do base 10 regardless of contents of
    return PropertyStringToLong(pStr, NULL, 10, 0, (unsigned long *)plValue);
} // ttol_with_error

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    try to convert string to number
//************************************************************
static HRESULT
PropertyStringToLong(const WCHAR   *nptr,
                     WCHAR        **endptr,
                     int            ibase,
                     int            flags,
                     unsigned long *plNumber)
{
    const WCHAR *p;
    WCHAR c;
    unsigned long number;
    unsigned digval;
    unsigned long maxval;

    *plNumber = 0;                  /* on error result is 0 */

    p = nptr;                       /* p is our scanning pointer */
    number = 0;                     /* start with zero */

    c = *p++;                       /* read char */
    while (_istspace(c))
        c = *p++;                   /* skip whitespace */

    if (c == '-')
    {
        flags |= FL_NEG;        /* remember minus sign */
        c = *p++;
    }
    else if (c == '+')
        c = *p++;               /* skip sign */

    if (ibase < 0 || ibase == 1 || ibase > 36)
    {
        /* bad base! */
        if (endptr)
            /* store beginning of string in endptr */
            *endptr = (WCHAR *)nptr;
        return E_POINTER;              /* return 0 */
    }
    else if (ibase == 0)
    {
        /* determine base free-lance, based on first two chars of
           string */
        if (c != L'0')
            ibase = 10;
        else if (*p == L'x' || *p == L'X')
            ibase = 16;
        else
            ibase = 8;
    }

    if (ibase == 16)
    {
        /* we might have 0x in front of number; remove if there */
        if (c == L'0' && (*p == L'x' || *p == L'X'))
        {
            ++p;
            c = *p++;       /* advance past prefix */
        }
    }

    /* if our number exceeds this, we will overflow on multiply */
    maxval = ULONG_MAX / ibase;


    for (;;)
    {      /* exit in middle of loop */
        /* convert c to value */
        if (_istdigit(c))
            digval = c - L'0';
        else if (_istalpha(c))
        {
            if (ibase > 10)
            {
                digval = (unsigned) PtrToUlong(CharUpper((LPTSTR)(LONG_PTR)c)) - L'A' + 10;
            }
            else
            {
                return E_INVALIDARG;              /* return 0 */
            }
        }
        else
            break;

        if (digval >= (unsigned)ibase)
            break;          /* exit loop if bad digit found */

        /* record the fact we have read one digit */
        flags |= FL_READDIGIT;

        /* we now need to compute number = number * base + digval,
           but we need to know if overflow occured.  This requires
           a tricky pre-check. */

        if (number < maxval || (number == maxval &&
            (unsigned long)digval <= ULONG_MAX % ibase))
        {
            /* we won't overflow, go ahead and multiply */
            number = number * ibase + digval;
        }
        else
        {
            /* we would have overflowed -- set the overflow flag */
            flags |= FL_OVERFLOW;
        }

        c = *p++;               /* read next digit */
    }

    --p;                            /* point to place that stopped scan */

    if (!(flags & FL_READDIGIT))
    {
        number = 0L;                        /* return 0 */

        /* no number there; return 0 and point to beginning of
           string */
        if (endptr)
            /* store beginning of string in endptr later on */
            p = nptr;

        return E_INVALIDARG;            // Return error not a number
    }
    else if ((flags & FL_OVERFLOW) ||
              (!(flags & FL_UNSIGNED) &&
                (((flags & FL_NEG) && (number > -LONG_MIN)) ||
                  (!(flags & FL_NEG) && (number > LONG_MAX)))))
    {
        /* overflow or signed overflow occurred */
        //errno = ERANGE;
        if (flags & FL_UNSIGNED)
            number = ULONG_MAX;
        else if (flags & FL_NEG)
            number = (unsigned long)(-LONG_MIN);
        else
            number = LONG_MAX;
    }

    if (endptr != NULL)
        /* store pointer to char that stopped the scan */
        *endptr = (WCHAR *)p;

    if (flags & FL_NEG)
        /* negate result if there was a neg sign */
        number = (unsigned long)(-(long)number);

    *plNumber = number;
    return S_OK;                  /* done. */
} // PropertyStringToLong

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    constructor
//************************************************************

CTIMEElementCollection::CTIMEElementCollection(CCollectionCache *pCollectionCache, long lIndex) :
    m_pCollectionCache(pCollectionCache),
    m_lCollectionIndex(lIndex),
    m_pInfo(NULL),
    m_cRef(0)
{
} // CTIMEElementCollection

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    destructor
//************************************************************

CTIMEElementCollection::~CTIMEElementCollection()
{
    ReleaseInterface(m_pInfo);
    m_pCollectionCache = NULL;
} // ~CTIMEElementCollection

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        AddRef
//************************************************************

STDMETHODIMP_(ULONG) CTIMEElementCollection::AddRef(void)
{
    return m_cRef++;
} // AddRef

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        Release
//************************************************************

STDMETHODIMP_(ULONG) CTIMEElementCollection::Release(void)
{
    if (m_cRef == 0)
    {
        TraceTag((tagError, "CTIMEElementCollection::Release - YIKES! Trying to decrement when Ref count is zero"));
        return m_cRef;
    }

    if (0 != --m_cRef)
    {
        return m_cRef;
    }

    delete this;
    return 0;
} // Release

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        QI
//************************************************************

HRESULT
CTIMEElementCollection::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
    {
        // SAFECAST macro doesn't work with IUnknown
        *ppv = this;
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppv = SAFECAST((ITIMEElementCollection*)this, IDispatch*);
    }
    else if (IsEqualIID(riid, IID_IDispatchEx))
    {
        *ppv = SAFECAST(this, IDispatchEx*);
    }
    else if (IsEqualIID(riid, IID_ITIMEElementCollection))
    {
        *ppv = SAFECAST(this, ITIMEElementCollection*);
    }

    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
} // QueryInterface

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    IDispatch - GetTypeInfoCount
//************************************************************

HRESULT
CTIMEElementCollection::GetTypeInfoCount(UINT FAR *pctinfo)
{
    if (pctinfo == NULL)
    {
        TraceTag((tagError, "CTIMEElementCollection::GetTypeInfoCount - Invalid param (UINT FAR *)"));
        return TIMESetLastError(E_POINTER);
    }

    *pctinfo = 1;
    return S_OK;
} // GetTypeInfoCount

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    IDispatch - GetTypeInfo
//************************************************************

HRESULT
CTIMEElementCollection::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    if (pptinfo == NULL)
    {
        TraceTag((tagError, "CTIMEElementCollection::GetTypeInfo - Invalid param (ITypeInfo**)"));
        return TIMESetLastError(E_POINTER);
    }

    return GetTI(pptinfo);
} // GetTypeInfo

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    IDispatch - GetIDsOfNames
//************************************************************

HRESULT
CTIMEElementCollection::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames,
                                  UINT cNames, LCID lcid, DISPID FAR *rgdispid)
{
    // punt to IDispatchEx impl.
    return GetDispID(rgszNames[0], cNames, rgdispid);
} // GetIDsOfNames

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    IDispatch - Invoke
//************************************************************

HRESULT
CTIMEElementCollection::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags,
                           DISPPARAMS *pdispparams, VARIANT *pvarResult,
                           EXCEPINFO *pexcepinfo, UINT *pArg)
{
    // punt to IDispatchEx impl.
    return InvokeEx(dispidMember,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    NULL);
} // Invoke

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    IDispatchEx - InvokeEx
//************************************************************

HRESULT
CTIMEElementCollection::InvokeEx(DISPID            dispidMember,
                             LCID              lcid,
                             WORD              wFlags,
                             DISPPARAMS       *pdispparams,
                             VARIANT          *pvarResult,
                             EXCEPINFO        *pexcepinfo,
                             IServiceProvider *pSrvProvider)
{
    HRESULT hr;

    hr = m_pCollectionCache->InvokeEx(m_lCollectionIndex, dispidMember, lcid, wFlags,
                                      pdispparams, pvarResult, pexcepinfo, pSrvProvider);

    // if that failed, try typelib
    if (FAILED(hr))
    {
        ITypeInfo *pInfo;
        hr = GetTI(&pInfo);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementCollection::InvokeEx - GetTI() failed"));
            return TIMESetLastError(hr);
        }

        UINT* puArgErr = NULL;

        IDispatch *pDisp = NULL;
        hr = QueryInterface(IID_TO_PPV(IDispatch, &pDisp));
        if (FAILED(hr))
            return TIMESetLastError(hr);

        Assert(pInfo != NULL);

        hr = pInfo->Invoke(pDisp, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
        ReleaseInterface(pInfo);
        ReleaseInterface(pDisp);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementCollection::InvokeEx - Invoke failed on Typelib"));
            return TIMESetLastError(hr);
        }
    }

    return hr;
} // InvokeEx

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    IDispatchEx - GetDispID
//************************************************************

HRESULT
CTIMEElementCollection::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT hr = m_pCollectionCache->GetDispID(m_lCollectionIndex, bstrName, grfdex, pid);

    // if we failed or found nothing, try typelib
    if ((FAILED(hr)) || (*pid == DISPID_UNKNOWN))
    {
        // have string, see if it's a member function/property in typelib
        ITypeInfo *pInfo;
        hr = GetTI(&pInfo);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementCollection::GetDispID - GetTI() failed"));
            return TIMESetLastError(hr);
        }

        Assert(pInfo != NULL);

        LPOLESTR rgszNames[1];
        rgszNames[0] = bstrName;

        hr = pInfo->GetIDsOfNames(rgszNames, 1, pid);
        ReleaseInterface(pInfo);
    }

    return hr;
} // GetDispID

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    IDispatchEx - deleteMemberByName
//************************************************************

HRESULT
CTIMEElementCollection::DeleteMemberByName(BSTR bstrName, DWORD grfdex)
{
    return TIMESetLastError(m_pCollectionCache->DeleteMemberByName(m_lCollectionIndex, bstrName, grfdex));
} // deleteMemberByName

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    IDispatchEx - deleteMemberByDispID
//************************************************************

HRESULT
CTIMEElementCollection::DeleteMemberByDispID(DISPID id)
{
    return TIMESetLastError(m_pCollectionCache->DeleteMemberByDispID(m_lCollectionIndex, id));
} // deleteMemberByDispID

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    IDispatchEx - GetMemberProperties
//************************************************************

HRESULT
CTIMEElementCollection::GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
{
    return TIMESetLastError(m_pCollectionCache->GetMemberProperties(m_lCollectionIndex, id, grfdexFetch, pgrfdex));
} // GetMemberProperties

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    IDispatchEx - GetMemberName
//************************************************************

HRESULT
CTIMEElementCollection::GetMemberName(DISPID id, BSTR *pbstrName)
{
    return TIMESetLastError(m_pCollectionCache->GetMemberName(m_lCollectionIndex, id, pbstrName));
} // GetMemberName

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    IDispatchEx - GetNextDispID
//************************************************************

STDMETHODIMP
CTIMEElementCollection::GetNextDispID(DWORD grfdex, DISPID id, DISPID *prgid)
{
    return TIMESetLastError(m_pCollectionCache->GetNextDispID(m_lCollectionIndex, grfdex, id, prgid));
} // GetNextDispID

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    IDispatchEx - GetNameSpaceParent
//************************************************************

HRESULT
CTIMEElementCollection::GetNameSpaceParent(IUnknown **ppUnk)
{
    return TIMESetLastError(m_pCollectionCache->GetNameSpaceParent(m_lCollectionIndex, ppUnk));
} // GetNameSpaceParent

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    ITIMEElementCollection - get_length
//************************************************************

HRESULT
CTIMEElementCollection::get_length(long *plSize)
{
    return TIMESetLastError(m_pCollectionCache->get_length(m_lCollectionIndex, plSize));
} // get_length

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    ITIMEElementCollection - put_length
//************************************************************

HRESULT
CTIMEElementCollection::put_length(long lSize)
{
    return TIMESetLastError(m_pCollectionCache->put_length(m_lCollectionIndex, lSize));
} // put_length

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    ITIMEElementCollection - item
//************************************************************

HRESULT
CTIMEElementCollection::item(VARIANTARG var1, VARIANTARG var2, IDispatch **ppDisp)
{
    return TIMESetLastError(m_pCollectionCache->item(m_lCollectionIndex, var1, var2, ppDisp));
} // item

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    ITIMEElementCollection - tags
//************************************************************

HRESULT
CTIMEElementCollection::tags(VARIANT var1, IDispatch **ppDisp)
{
    return TIMESetLastError(m_pCollectionCache->tags(m_lCollectionIndex, var1, ppDisp));
} // tags

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    ITIMEElementCollection - get__newEnum
//************************************************************

HRESULT
CTIMEElementCollection::get__newEnum(IUnknown ** ppEnum)
{
    return TIMESetLastError(m_pCollectionCache->get__newEnum(m_lCollectionIndex, ppEnum));
} // get__newEnum

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    helper function for typeinfo
//************************************************************

HRESULT
CTIMEElementCollection::GetTI(ITypeInfo **pptinfo)
{
    HRESULT hr = E_FAIL;

    Assert(pptinfo != NULL);  //GetTI is an private internal function.  pptinfo should always be valid

    *pptinfo = NULL;

    if (m_pInfo == NULL)
    {
        ITypeLib* pTypeLib;

        hr = LoadRegTypeLib(LIBID_TIME, TYPELIB_VERSION_MAJOR, TYPELIB_VERSION_MINOR, LCID_SCRIPTING, &pTypeLib);
        if (SUCCEEDED(hr))
        {
            ITypeInfo* pTypeInfo;

            hr = pTypeLib->GetTypeInfoOfGuid(IID_ITIMEElementCollection, &pTypeInfo);
            if (SUCCEEDED(hr))
            {
	        m_pInfo = pTypeInfo;
            }

            ReleaseInterface(pTypeLib);
        }
    }

    *pptinfo = m_pInfo;
    if (m_pInfo != NULL)
    {
        m_pInfo->AddRef();
        hr = S_OK;
    }

    return hr;
} // GetTI

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Constructor
//************************************************************

CCollectionCache::CCollectionCache(CTIMEElementBase *pBase,
                                   CAtomTable *pAtomTable /* = NULL */,
                                   PFN_CVOID_ENSURE pfnEnsure /* = NULL */,
                                   PFN_CVOID_CREATECOL pfnCreation /* = NULL */,
                                   PFN_CVOID_REMOVEOBJECT pfnRemove /* = NULL */,
                                   PFN_CVOID_ADDNEWOBJECT pfnAddNewObject /* = NULL */) :
    m_pBase(pBase),
    m_pAtomTable(pAtomTable),
    m_pfnEnsure(pfnEnsure),
    m_pfnCreateCollection(pfnCreation),
    m_pfnRemoveObject(pfnRemove),
    m_pfnAddNewObject(pfnAddNewObject),
    m_lReservedSize(0),
    m_lCollectionVersion(0),
    m_lDynamicCollectionVersion(0),
    m_rgItems(NULL)
{
    Assert(m_pBase != NULL);
} // CCollectionCache

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Destructor
//************************************************************

CCollectionCache::~CCollectionCache()
{
    if (m_rgItems)
    {
        long lSize = m_rgItems->Size();

        for (long lIndex = 0; lIndex < lSize; lIndex++)
        {
            CCacheItem *pce = (*m_rgItems)[lIndex];
            if (pce->m_fOKToDelete)
            {
                // delete CCacheItem
                delete pce;
                pce = NULL;
            }
        }

        // delete array of CCacheItems
        delete m_rgItems;
        m_rgItems = NULL;
    }
} // ~CCollectionCache

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Initialize class
//************************************************************

HRESULT
CCollectionCache::Init(long lReservedSize, long lIdentityIndex /* = -1 */)
{
    HRESULT hr = E_INVALIDARG;

    m_lReservedSize = lReservedSize;

    // Clear the reserved part of the cache.
    if (m_lReservedSize >= 0)
    {
        m_rgItems = NEW CPtrAry<CCacheItem *>;
        if (m_rgItems == NULL)
        {
            TraceTag((tagError, "CCollectionCache::Init - unable to alloc mem for array"));
            return E_OUTOFMEMORY;
        }

        // this is a speed thing.  Since we know we need a certain size,
        // make it so.
        hr = m_rgItems->EnsureSize(m_lReservedSize);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::Init - unable to init array to reserved size"));
            return hr;
        }

        // loop through initializing each reserved array
        for (long lIndex = 0; lIndex < lReservedSize; lIndex++)
        {
            // create new cache item
            CCacheItem *pce = NEW CCacheItem();
            if (pce == NULL)
            {
                TraceTag((tagError, "CCollectionCache::Init - unable to alloc mem for array (CCacheItem)"));
                return E_OUTOFMEMORY;
            }

            // add item to array
            hr = m_rgItems->Append(pce);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::Init - unable to add cache item"));
                delete pce;
                return hr;
            }

            // attach CTIMEElementCollection to item
            hr = CreateCollectionHelper(&pce->m_pDisp, lIndex);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::Init - CreateCollectionHelper() failed"));
                return hr;
            }
        }

        // handle identity flag
        if ((lIdentityIndex >= 0) && (lIdentityIndex < m_lReservedSize))
        {
            (*m_rgItems)[lIdentityIndex]->m_fIdentity = true;
        }
    }

    return S_OK;
} // Init

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Get IDispatch for collection index
//************************************************************

HRESULT
CCollectionCache::GetCollectionDisp(long lCollectionIndex, IDispatch **ppDisp)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetCollectionDisp - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (ppDisp == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetCollectionDisp - Invalid param (IDispatch**)"));
        return E_POINTER;
    }

    HRESULT hr = S_OK;

    *ppDisp = NULL;

    // fetch particular Collection
    CCacheItem *pce = (*m_rgItems)[lCollectionIndex];

    // if identity, QI for IDispatch and return
    if (pce->m_fIdentity)
    {
        return GetOuterDisp(lCollectionIndex, m_pBase, ppDisp);
    }

    // if not identity and there is a collection, addref and return it
    Assert(pce->m_pDisp != NULL);

    pce->m_pDisp->AddRef();
    *ppDisp = pce->m_pDisp;

    return S_OK;
} // GetCollectionDisp

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Set collection cache type
//************************************************************

HRESULT
CCollectionCache::SetCollectionType(long lCollectionIndex, COLLECTIONCACHETYPE cctype, bool fReturnHTMLInterface /*false*/)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::SetCollectionType - Invalid index"));
        return E_INVALIDARG;
    }

    CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
    pce->m_cctype = cctype;
    pce->m_fReturnHTMLInterface = !!fReturnHTMLInterface;
    return S_OK;
} // SetCollectionType

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    given an index, see if it's a child collection
//************************************************************

bool
CCollectionCache::IsChildrenCollection(long lCollectionIndex)
{
    if ((lCollectionIndex >= 0) && lCollectionIndex < m_rgItems->Size())
    {
        CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
        if (pce->m_cctype == ctChildren)
            return true;
    }
    return false;
} // IsChildrenCollection

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    given an index, see if it's an all collection
//************************************************************

bool
CCollectionCache::IsAllCollection(long lCollectionIndex)
{
    if ((lCollectionIndex >= 0) && lCollectionIndex < m_rgItems->Size())
    {
        CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
        if (pce->m_cctype == ctAll)
            return true;
    }
    return false;
} // IsAllCollection

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Implementation of IDispatchEx - GetDispID
//************************************************************

HRESULT
CCollectionCache::GetDispID(long lCollectionIndex, BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT hr;
    long    lItemIndex = 0;

    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetDispID - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (pid == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetDispID - Invalid param (DISPID*)"));
        return E_POINTER;
    }

    *pid = 0;

    // make sure array is up-to-date.
    hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDispID - EnsureArray() failed"));
        return hr;
    }

    // check for index (number) - which equates to an ordinal
    hr = ttol_with_error(bstrName, &lItemIndex);
    if (hr == S_OK)
    {
        // Try to map name to a named element in the collection.
        // Ignore it if we're not promoting ordinals
        if (!(*m_rgItems)[lCollectionIndex]->m_fPromoteOrdinals)
        {
            return DISP_E_UNKNOWNNAME;
        }

        if (m_pfnAddNewObject)
        {
            // The presence of m_pfnAddNewObject indicates that the collection
            // allows setting to arbitrary indices. Expando on the collection
            // is not allowed.
            *pid = GetOrdinalMemberMin(lCollectionIndex) + lItemIndex;
            if (*pid > GetOrdinalMemberMax(lCollectionIndex))
            {
                return DISP_E_UNKNOWNNAME;
            }
            return S_OK;
        }

        // Without a m_pfnAddNewObject, the collection only supports
        // access to ordinals in the current range. Other accesses
        // become expando.
        if ((lItemIndex >= 0) &&
            (lItemIndex < Size(lCollectionIndex)))
        {
            *pid = GetOrdinalMemberMin(lCollectionIndex) + lItemIndex;
            if (*pid > GetOrdinalMemberMax(lCollectionIndex) )
            {
                return DISP_E_UNKNOWNNAME;
            }
            return S_OK;
        }

        return DISP_E_UNKNOWNNAME;
    }

    // see if it's an expando

    // If we don't promote named items - nothing more to do
    if (!(*m_rgItems)[lCollectionIndex]->m_fPromoteNames)
        return DISP_E_UNKNOWNNAME;

    CTIMEElementBase *pElem = NULL;
    long lIndex = 0;
    bool fCaseSensitive = ( grfdex & fdexNameCaseSensitive ) != 0;

    // check to make sure min/max are not wacky
    Assert((*m_rgItems)[lCollectionIndex]->m_dispidMin != 0);
    Assert(((*m_rgItems)[lCollectionIndex]->m_dispidMax != 0) &&
            ((*m_rgItems)[lCollectionIndex]->m_dispidMax > (*m_rgItems)[lCollectionIndex]->m_dispidMin));

    hr = GetItemByName(lCollectionIndex, bstrName, lIndex, &pElem, fCaseSensitive);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDispID - GetItemByName() failed"));
        return hr;
    }

    Assert(pElem != NULL);  // double check to make sure we found something

    // add name to table
    long lOffset = 0;
    hr =  m_pAtomTable->AddNameToAtomTable(bstrName, &lOffset);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDispID - AddNameToAtomTable() failed"));
        return hr;
    }

    // cook up an ID based on offset plus case sensitivity
    long lMax;
    if (fCaseSensitive)
    {
        lOffset += GetSensitiveNamedMemberMin(lCollectionIndex);
        lMax = GetSensitiveNamedMemberMax(lCollectionIndex);
    }
    else
    {
        lOffset += GetNotSensitiveNamedMemberMin(lCollectionIndex);
        lMax = GetNotSensitiveNamedMemberMax(lCollectionIndex);
    }

    *pid = lOffset;

    // if id greater than the max, punt
    if (*pid > lMax)
    {
        hr = DISP_E_UNKNOWNNAME;
    }
    return hr;
} // GetDispID

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Implementation of IDispatchEx - InvokeEx
//************************************************************

HRESULT
CCollectionCache::InvokeEx(long lCollectionIndex, DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, IServiceProvider *pSrvProvider)
{
    HRESULT hr;

    // validate params
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::InvokeEx - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (pdispparams == NULL)
    {
        TraceTag((tagError, "CCollectionCache::InvokeEx - Invalid param (DISPPARAMS*)"));
        return E_POINTER;
    }

    // make sure array is up-to-date
    hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::InvokeEx - unable to ensure array index"));
        return hr;
    }

    // make sure ID is in collection range
    // Note: this stop's requests for length which is handled
    //       in CTIMEElementCollection
    if ((id < (*m_rgItems)[lCollectionIndex]->m_dispidMin) ||
        (id > (*m_rgItems)[lCollectionIndex]->m_dispidMax))
        return DISP_E_MEMBERNOTFOUND;

    //
    // check for ordinal
    //
    if (IsOrdinalCollectionMember(lCollectionIndex, id))
    {
        if (wFlags & DISPATCH_PROPERTYPUT )
        {
            if (!m_pfnAddNewObject)
            {
                TraceTag((tagError, "CCollectionCache::InvokeEx - invalid arg passed to invoke"));
                return E_INVALIDARG;
            }

            if (!(pdispparams && pdispparams->cArgs == 1))
                // No result type we need one for the get to return.
                return DISP_E_MEMBERNOTFOUND;

            // Only allow VARIANT of type IDispatch to be put
            if (pdispparams->rgvarg[0].vt == VT_NULL)
            {
                // the options collection is special. it allows
                // options[n] = NULL to be specified. in this case
                // map the invoke to a delete on that appropriate index
                if ((*m_rgItems)[lCollectionIndex]->m_fSettableNULL)
                {
                    hr = Remove(lCollectionIndex, id - GetOrdinalMemberMin(lCollectionIndex));

                    // Like Nav - silently ignore the put if its's outside the current range
                    if ( hr == E_INVALIDARG )
                        return S_OK;
                    return hr;
                }
                return E_INVALIDARG;
            }
            else if (pdispparams->rgvarg[0].vt != VT_DISPATCH)
            {
                return E_INVALIDARG;
            }

            // All OK, let the collection cache validate the Put
            return ((CVoid *)((void *)m_pBase)->*m_pfnAddNewObject)(lCollectionIndex,
                                                                    V_DISPATCH(pdispparams->rgvarg),
                                                                    id - GetOrdinalMemberMin(lCollectionIndex));
        }
        else if (wFlags & DISPATCH_PROPERTYGET)
        {
            VARIANTARG      v1;
            VARIANTARG      v2;
            WCHAR          *pch = NULL;
            long            lIndex = id - GetOrdinalMemberMin(lCollectionIndex);

            if (!((lIndex >= 0) && (lIndex < Size(lCollectionIndex))))
            {
                hr = S_OK;
                if (pvarResult)
                {
                    VariantClear(pvarResult);
                    pvarResult->vt = VT_NULL;
                    return S_OK;
                }
            }

            v1.vt = VT_I4;
            v1.lVal = lIndex;

            // Always get the item by index.
            v2.vt = VT_ERROR;

            if (pvarResult)
            {
                hr = item(lCollectionIndex, v1, v2, &(pvarResult->pdispVal));
                if (SUCCEEDED(hr))
                {
                    if (!(pvarResult->pdispVal))
                    {
                        hr = E_FAIL;        // use super::Invoke
                    }
                    else
                    {
                        pvarResult->vt = VT_DISPATCH;
                    }
                }
            }
            return hr;
        }

        TraceTag((tagError, "CCollectionCache::InvokeEx - Invalid invocation of ordinal ID"));
        return DISP_E_MEMBERNOTFOUND;
    }

    //
    // check for expando
    //
    if (IsNamedCollectionMember(lCollectionIndex, id))
    {
        bool  fCaseSensitive;
        long  lOffset;

        lOffset = GetNamedMemberOffset(lCollectionIndex, id, &fCaseSensitive);

        const WCHAR  *pwszName;
        hr = m_pAtomTable->GetNameFromAtom(id - lOffset, &pwszName);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::InvokeEx - GetNameFromAtom() failed"));
            return hr;
        }

        // find name
        IDispatch *pDisp = NULL;
        hr = GetDisp(lCollectionIndex,
                     pwszName,
                     false,
                     &pDisp,
                     fCaseSensitive);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::InvokeEx - unable to GetDisp for expando"));
            return hr;
        }

        Assert(pDisp != NULL);
        UINT* puArgErr = NULL;

        if (wFlags == DISPATCH_PROPERTYGET ||
            wFlags == (DISPATCH_METHOD | DISPATCH_PROPERTYGET))
        {
            if (pvarResult == NULL)
            {
                TraceTag((tagError, "CCollectionCache::InvokeEx - invalid param (VARIANT*)"));
                return E_POINTER;
            }

            // cArgs==1 when Doc.foo(0) is used and =0 when Doc.foo.count
            //  this is only an issue when there are multiple occurances
            //  of foo, and a collection is supposed to be returned by
            //  document.foo
            if (pdispparams->cArgs > 1)
            {
                TraceTag((tagError, "CCollectionCache::InvokeEx - bad param count on get_/method call"));
                return DISP_E_BADPARAMCOUNT;
            }
            else if (pdispparams->cArgs == 1)
            {
                return pDisp->Invoke(DISPID_VALUE, IID_NULL, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
            }
            else
            {
                V_VT(pvarResult) = VT_DISPATCH;
                V_DISPATCH(pvarResult) = pDisp;
                return S_OK;
            }
        }
        else if (wFlags == DISPATCH_PROPERTYPUT ||
                 wFlags == DISPATCH_PROPERTYPUTREF)
        {
            if (pdispparams->cArgs != 1)
            {
                TraceTag((tagError, "CCollectionCache::InvokeEx - bad param count on put_ call"));
                return DISP_E_BADPARAMCOUNT;
            }

            return pDisp->Invoke(DISPID_VALUE, IID_NULL, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
        }

        // Any other kind of invocation is not valid.
        TraceTag((tagError, "CCollectionCache::InvokeEx - Invalid invocation of Named ID"));
        return DISP_E_MEMBERNOTFOUND;
    }

    // punt back to outer Invoke...
    return DISP_E_MEMBERNOTFOUND;
} // InvokeEx

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Implementation of IDispatchEx - deleteMemberByName
//              Not needed
//************************************************************

HRESULT
CCollectionCache::DeleteMemberByName(long lCollectionIndex, BSTR bstrName, DWORD grfdex)
{
    return E_NOTIMPL;
} // deleteMemberByName

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Implementation of IDispatchEx - deleteMemberByDispID
//              Not needed
//************************************************************

HRESULT
CCollectionCache::DeleteMemberByDispID(long lCollectionIndex, DISPID id)
{
    return E_NOTIMPL;
} // GetMemberProperties

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Implementation of IDispatchEx - GetMemberProperties
//              Not needed
//************************************************************

HRESULT
CCollectionCache::GetMemberProperties(long lCollectionIndex, DISPID id, DWORD grfdexFetch, DWORD* pgrfdex)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetMemberProperties - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (pgrfdex == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetMemberProperties - Invalid param (DWORD*)"));
        return E_POINTER;
    }

    *pgrfdex = 0;
    return E_NOTIMPL;
} // GetMemberProperties

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Implementation of IDispatchEx - GetMemberName
//************************************************************

HRESULT
CCollectionCache::GetMemberName(long lCollectionIndex, DISPID id, BSTR *pbstrName)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetMemberName - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (pbstrName == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetMemberName - Invalid param (BSTR*)"));
        return E_POINTER;
    }

    *pbstrName = NULL;

    // Make sure our collection is up-to-date.
    HRESULT hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetMemberName - unable to ensure array"));
        return S_FALSE;
    }

    // check to see if DISPID is an ordinal
    if (IsOrdinalCollectionMember(lCollectionIndex, id))
    {
        long lOffset = id - GetOrdinalMemberMin(lCollectionIndex);
        CTIMEElementBase *pElem = NULL;

        // element
        hr = GetItemByIndex(lCollectionIndex, lOffset, &pElem);
        if (FAILED(hr) || (pElem == NULL))
        {
            TraceTag((tagError, "CCollectionCache::GetMemberName - GetItemByIndex() failed"));
            return DISP_E_MEMBERNOTFOUND;
        }

        Assert(pElem != NULL);

        if ((*m_rgItems[lCollectionIndex])->m_fPromoteNames)
        {
            // get ID string
            hr = pElem->getIDString(pbstrName);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::GetMemberName - unable to find ID for element"));
                return DISP_E_MEMBERNOTFOUND;
            }
        }

        // check to see that it's either NULL or ""
        // if so, stick offset in string
        if ((*pbstrName == NULL) || (lstrlenW(*pbstrName) == 0))
        {
            // set offset as text
            VARIANT varData;
            VariantInit(&varData);

            V_VT(&varData) = VT_I4;
            V_I4(&varData) = lOffset;

            VARIANT varNew;
            VariantInit(&varNew);
            hr = VariantChangeTypeEx(&varNew, &varData, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::GetMemberName - Unable to coerce long to BSTR"));
                // NOTE: we return DISP_E_MEMBERNOTFOUND instead of hr
                //       due to predefined method constraints
                return DISP_E_MEMBERNOTFOUND;
            }

            // Since we are going to return the BSTR, no need calling ClearVariant(&varNew).
            VariantClear(&varData);
            *pbstrName = V_BSTR(&varNew);
            return S_OK;
        }

        return S_OK;
    }

    // unable to find DISPID
    return DISP_E_MEMBERNOTFOUND;
} // GetMemberName

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Implementation of IDispatchEx - GetNextDispID
//************************************************************

HRESULT
CCollectionCache::GetNextDispID(long lCollectionIndex, DWORD grfdex, DISPID id, DISPID *prgid)
{
    HRESULT hr;

    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetNextDispID - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (prgid == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetNextDispID - Invalid param (DISPID*)"));
        return E_POINTER;
    }

    *prgid = 0;

    // Make sure our collection is up-to-date.
    hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetNextDispID - unable to ensure array"));
        return S_FALSE;
    }

    // check to see if we are have been sent the enumerator index. (FFFFFFFF)
    if (id == DISPID_STARTENUM)
    {
         // move to the beginning of the array (0)
         *prgid = GetOrdinalMemberMin(lCollectionIndex);
         return S_OK;
    }

    // validate that we are working with ordinals
    if (IsOrdinalCollectionMember(lCollectionIndex, id))
    {
        // calc new offset
        long lItemIndex = id - GetOrdinalMemberMin(lCollectionIndex) + 1;

        // Is the number within range for an item in the collection?
        // We *must* call GetItemCount to be exact.
        long lSize = 0;
        hr = GetItemCount(lCollectionIndex, &lSize);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::GetNextDispID - GetItemCount() failed"));
            return S_FALSE;
        }

        // this is usually were we stop
        if ((lItemIndex < 0) || (lItemIndex >= lSize))
        {
            return S_FALSE;
        }

        // calc new DISPID
        *prgid = GetOrdinalMemberMin(lCollectionIndex) + lItemIndex;

        // check to see if calc DISPID is out of range
        if (*prgid > GetOrdinalMemberMax(lCollectionIndex))
        {
            // this signal's that we are done.
            *prgid = DISPID_UNKNOWN;
        }
        return S_OK;
    }

    // not found
    return S_FALSE;
} // GetNextDispID

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Implementation of IDispatchEx - GetNameSpaceParent
//************************************************************

HRESULT
CCollectionCache::GetNameSpaceParent(long lCollectionIndex, IUnknown **ppUnk)
{
    HRESULT hr;

    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetNameSpaceParent - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (ppUnk == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetNameSpaceParent - Invalid param (IUnknown**)"));
        return E_POINTER;
    }

    *ppUnk = NULL;
    return S_OK;
} // GetNameSpaceParent

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Implementation of standard Collection - get_length
//************************************************************

HRESULT
CCollectionCache::get_length(long lCollectionIndex, long *pretval)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::get_length - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (pretval == NULL)
    {
        TraceTag((tagError, "CCollectionCache::get_length - Invalid param (long*)"));
        return E_POINTER;
    }

    *pretval = 0;

    // Make sure our collection is up-to-date.
    HRESULT hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::get_length - unable to ensure array"));
        return hr;
    }

    return GetItemCount(lCollectionIndex, pretval);
} // get_length

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Implementation of standard Collection - put_length
//              not needed.
//************************************************************

HRESULT
CCollectionCache::put_length(long lCollectionIndex, long retval)
{
    return E_NOTIMPL;
} // put_length

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    item is a standard method for collections
//              which looks up an item in a collection using
//              either a name or a numeric index.
//
//              we handle the following parameter cases:
//                  0 params            : by index = 0
//                  1 params bstr       : by name, index = 0
//                  1 params #          : by index
//                  2 params bstr, #    : by name, index
//                  2 params #, bstr    : by index, ignoring bstr
//************************************************************

HRESULT
CCollectionCache::item(long lCollectionIndex, VARIANTARG var1, VARIANTARG var2, IDispatch **ppDisp)
{
    HRESULT   hr;
    CTIMEElementBase *pElem = NULL;
    VARIANT  *pvarName = NULL;
    VARIANT  *pvarIndex = NULL;
    VARIANT  *pvar = NULL;
    long     lItemIndex = 0;

    // validate out param
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::item - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (ppDisp == NULL)
    {
        TraceTag((tagError, "CCollectionCache::item - Invalid param (IDispatch**)"));
        return E_POINTER;
    }

    // initialize out param
    *ppDisp = NULL;

    pvar = (V_VT(&var1) == (VT_BYREF | VT_VARIANT)) ? V_VARIANTREF(&var1) : &var1;

    // check to see if first param is a string
    if ((V_VT(pvar) == VT_BSTR) || V_VT(pvar) == (VT_BYREF|VT_BSTR))
    {
        pvarName = (V_VT(pvar) & VT_BYREF) ? V_VARIANTREF(pvar) : pvar;

        // check second param.  If valid, it must be a secondary index (numeric)
        if ((V_VT(&var2) != VT_ERROR) && (V_VT(&var2) != VT_EMPTY))
        {
            pvarIndex = &var2;
        }
    }
    // first param is an index.
    // NOTE: we blow off the second param
    else if ((V_VT(&var1) != VT_ERROR) && (V_VT(&var1) != VT_EMPTY))
    {
        pvarIndex = &var1;
    }

    // Make sure our collection is up-to-date.
    hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::item- unable to ensure array"));
        return hr;
    }

    // if we have a pvarIndex, get it
    if (pvarIndex)
    {
        VARIANT varNum;

        VariantInit(&varNum);

        hr = VariantChangeTypeEx(&varNum, pvarIndex, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_I4);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::item - unable to convert variant to index"));
            return hr;
        }

        lItemIndex = V_I4(&varNum);

        VariantClear(&varNum);
    }

    // First, see if we have a string as first param
    if (pvarName)
    {
        BSTR bstrName = V_BSTR(pvarName);

        // NOTE: lItemIndex is always passed in.  In the case
        // were we have no secondary index specifed, it will
        // always be zero.
        if (pvarIndex)
        {
            // this ALWAYS returns a single CTIMEElementBase
            hr = GetDisp(lCollectionIndex, bstrName, lItemIndex, ppDisp);
            if (hr == DISP_E_MEMBERNOTFOUND)
                hr = S_OK;
            return hr;
        }
        else
        {
            // this could return either a collection or an CTIMEElementBase
            hr = GetDisp(lCollectionIndex, bstrName, false, ppDisp);
            if (hr == DISP_E_MEMBERNOTFOUND)
                hr = S_OK;
            return hr;
        }
    }
    else if (pvarIndex)
    {
        // this ALWAYS returns a single CTIMEElementBase
        hr = GetDisp(lCollectionIndex, lItemIndex, ppDisp);
        if (hr == DISP_E_MEMBERNOTFOUND)
            hr = S_OK;
        return hr;
    }

    TraceTag((tagError, "CCollectionCache::item - Invalid args passed in to ::item"));
    return E_INVALIDARG;
} //item

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    get__NewEnum is a standard method for collections
//              returns an enumeration of all the items in a
//              collection.
//************************************************************

HRESULT
CCollectionCache::get__newEnum(long lCollectionIndex, IUnknown **ppUnk)
{
    HRESULT hr;

    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::get__newEnum - Invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (ppUnk == NULL)
    {
        TraceTag((tagError, "CCollectionCache::get__newEnum - Invalid param (IUnknown**)"));
        return E_POINTER;
    }

    *ppUnk = NULL;

    // Make sure our collection is up-to-date.
    hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::get__newEnum - unable to ensure array"));
        return hr;
    }

    // Create new array
    CPtrAry<IUnknown *> *prgElem = NEW CPtrAry<IUnknown *>;
    if (prgElem == NULL)
    {
        TraceTag((tagError, "CCollectionCache::get__newEnum - unable to alloc mem for ptr array"));
        return E_OUTOFMEMORY;
    }

    // child collection
    if (IsChildrenCollection(lCollectionIndex))
    {
        Assert(m_pBase != NULL);

        // get child count
        long lCount = m_pBase->GetImmediateChildCount();
        // loop through, adding children
        for(long lIndex = 0; lIndex < lCount; lIndex++)
        {
            // get element
            CTIMEElementBase *pElemChild = m_pBase->GetChild(lIndex);
            Assert(pElemChild != NULL);
            // get IUnknown for element
            IUnknown *pIUnknown = NULL;
            hr = GetUnknown(lCollectionIndex, pElemChild, &pIUnknown);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - unable to find IUnknown for element"));
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }

            // append to array
            hr = prgElem->Append(pIUnknown);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - unable to append pointer"));
                ReleaseInterface(pIUnknown);
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }
        }
    }
    else if (IsAllCollection(lCollectionIndex)) // is it all collection?
    {
        EnumStart();

        // iterate over every element
        for (;;)
        {
            // get element
            CTIMEElementBase *pElem = NULL;
            hr = EnumNextElement(lCollectionIndex, &pElem);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - EnumNextElement() failed"));
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }

            // if pElem is NULL, we are done.
            if (pElem == NULL)
                break;

            // get IUnknown for element
            IUnknown *pIUnknown = NULL;
            hr = GetUnknown(lCollectionIndex, pElem, &pIUnknown);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - unable to find IUnknown for element"));
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }

            // append to array
            hr = prgElem->Append(pIUnknown);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - unable to append pointer"));
                ReleaseInterface(pIUnknown);
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }

        }
    }
    else // must be an array impl
    {
        long lSize = (*m_rgItems)[lCollectionIndex]->m_rgElem->Size();

        // This is a speed thing.  Since we know the size, alloc now for
        // array.
        hr = prgElem->EnsureSize(lSize);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::get__newEnum - unable to ensure array"));
            prgElem->ReleaseAll();
            delete prgElem;
            return hr;
        }

        for (long lIndex = 0; lIndex < lSize; lIndex++)
        {
            IDispatch * pdisp;

            hr = GetDisp(lCollectionIndex, lIndex, &pdisp);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - GetDisp() failed for index"));
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }

            hr = prgElem->Append(pdisp);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::get__newEnum - unable to append item"));
                prgElem->ReleaseAll();
                delete prgElem;
                return hr;
            }
        }
    } // end of "else everything"

    // Turn the snapshot into an enumerator.
    hr = prgElem->EnumVARIANT(VT_DISPATCH, (IEnumVARIANT **)ppUnk, FALSE, TRUE);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::get__newEnum - EnumVARIANT() failed"));
        prgElem->ReleaseAll();
        delete prgElem;
    }

    return hr;
} // get__newEnum

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Return a subcollection containing only the
//              elements of this collection that have the
//              specified tag name.
//************************************************************

HRESULT
CCollectionCache::tags(long lCollectionIndex, VARIANT var1, IDispatch** ppDisp)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::tags - Invalid param (Collection index)"));
        return E_INVALIDARG;
    }

    if (ppDisp == NULL)
    {
        TraceTag((tagError, "CCollectionCache::tags - Invalid param (IDispatch**)"));
        return E_POINTER;
    }

    *ppDisp = NULL;

    VARIANT *pvarName = NULL;
    pvarName = (V_VT(&var1) == (VT_BYREF | VT_VARIANT)) ? V_VARIANTREF(&var1) : &var1;

    if ((V_VT(pvarName)==VT_BSTR) || V_VT(pvarName)==(VT_BYREF|VT_BSTR))
    {
        pvarName = (V_VT(pvarName)&VT_BYREF) ? V_VARIANTREF(pvarName) : pvarName;
    }
    else
    {
        return DISP_E_MEMBERNOTFOUND;
    }

    // Make sure our collection is up-to-date.
    HRESULT hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::item- unable to ensure array"));
        return hr;
    }

    // Get a collection of the specified tags.
    // NOTE: ALWAYS returns a collection
    return GetDisp(lCollectionIndex, V_BSTR(pvarName), true, ppDisp);
} //get_tags

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    returns Size of a collection
//************************************************************

long
CCollectionCache::Size(long lCollectionIndex)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::Size - invalid param (collection index)"));
        return E_INVALIDARG;
    }

    // Make sure our collection is up-to-date.
    HRESULT hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::Size - unable to ensure array"));
        return hr;
    }

    // if all or children collection, use GetItemCount
    if (IsChildrenCollection(lCollectionIndex) || IsAllCollection(lCollectionIndex))
    {
        long    cElem = 0;
        hr = GetItemCount(lCollectionIndex, &cElem);
        if (FAILED(hr)) {
            TraceTag((tagError, "CCollectionCache::Size - GetItemCount() failed"));
        }

        return cElem;
    }
    else
    {
        // must be an array. return size.
        return (*m_rgItems)[lCollectionIndex]->m_rgElem->Size();
    }
}

HRESULT
CCollectionCache::GetItem(long lCollectionIndex, long i, CTIMEElementBase **ppElem)
{
    if (!ValidateCollectionIndex(lCollectionIndex))
    {
        TraceTag((tagError, "CCollectionCache::GetItem - invalid param (collection index)"));
        return E_INVALIDARG;
    }

    if (ppElem == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetItem - invalid param (CTIMEElementBase**)"));
        return E_POINTER;
    }

    // if all or children collection, use GetItemByIndex
    if (IsChildrenCollection(lCollectionIndex) || IsAllCollection(lCollectionIndex))
    {
        HRESULT hr = GetItemByIndex(lCollectionIndex, i, ppElem);
        if (FAILED(hr))
        {
            if (hr == DISP_E_MEMBERNOTFOUND)
                TraceTag((tagCollectionCache, "CCollectionCache::GetItem - GetItemByIndex didn't find anything!"));
            else
                TraceTag((tagError, "CCollectionCache::GetItem - GetItemByIndex() failed"));
        }
        return hr;
    }
    else
    {
        // must be array.  access index.
        CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
        Assert(pce != NULL);
        *ppElem = (*pce->m_rgElem)[i];
        return S_OK;
    }
} // GetItem

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Validate the given collection Index
//************************************************************

HRESULT
CCollectionCache::EnsureArray(long lCollectionIndex)
{
    HRESULT hr = S_OK;

    if (m_pfnEnsure)
    {
        hr = (((CVoid *)(void *)m_pBase)->*m_pfnEnsure)(&m_lCollectionVersion);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CCollectionCache::EnsureArray - outer Ensure function failed"));
            return hr;
        }
    }

    // used for customized collections
    //
    // if versions don't match invalidate everything
    if (m_lCollectionVersion != m_lDynamicCollectionVersion)
    {
        long lSize = m_rgItems->Size();
        for (long lIndex = m_lReservedSize; lIndex < lSize; lIndex++)
            (*m_rgItems)[lIndex]->m_fInvalid = true;

        // reset version number
        m_lDynamicCollectionVersion = m_lCollectionVersion;
    }

    CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
    if ((lCollectionIndex >= m_lReservedSize) && pce->m_fInvalid)
    {
        // Ensure the collection we're based upon
        // note that this is a recursive call
        hr = EnsureArray(pce->m_lDependentIndex);
        if (FAILED(hr))
            return hr;

        switch (pce->m_cctype)
        {
        case ctTag:
            // Rebuild based on name
            hr = BuildNamedArray(pce->m_lDependentIndex,
                                 pce->m_bstrName,
                                 true,
                                 &pce->m_rgElem);
            if (hr == S_OK)
                pce->m_fInvalid = false;
            break;

        case ctNamed:
            // Rebuild based on tag name
            hr = BuildNamedArray(pce->m_lDependentIndex,
                                 pce->m_bstrName,
                                 false,
                                 &pce->m_rgElem);
            if (hr == S_OK)
                pce->m_fInvalid = false;
            break;


            // all && children collection is dynamic, no need to rebuild
        case ctChildren:
        case ctAll:
            TraceTag((tagError, "CCollectionCache::EnsureArray - This is odd.  Why are we doing this?"));
            Assert(false);
            break;

        case ctFreeEntry:
            // Free collection waiting to be reused
            break;

        default:
            TraceTag((tagError, "CCollectionCache::EnsureArray - invalid cache type"));
            Assert(false);
            break;
        }
    }

    return hr;
} // EnsureArray

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    This gets the out IDispatch for a given CTIMEElementBase
//************************************************************

HRESULT
CCollectionCache::GetOuterDisp(long lCollectionIndex, CTIMEElementBase *pElem, IDispatch **ppDisp)
{
    Assert(ppDisp != NULL);
    *ppDisp = NULL;

    Assert(pElem != NULL);

    HRESULT hr = E_UNEXPECTED;
    CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
    Assert(pce != NULL);

    if (pce->m_fReturnHTMLInterface)
    {
        IHTMLElement *pHTMLElem = pElem->GetElement();
        Assert(NULL != pHTMLElem);
        hr = pHTMLElem->QueryInterface(IID_TO_PPV(IDispatch, ppDisp));
        if (FAILED(hr)) {
            TraceTag((tagError, "CCollectionCache::GetOuterDisp - QI failed (HTML)"));
        }
    }
    else
    {
        ITIMEElement *pTIMEElem = NULL;
        hr = pElem->QueryInterface(IID_TO_PPV(ITIMEElement, &pTIMEElem));
        Assert(SUCCEEDED(hr) && (pTIMEElem != NULL));
        hr = pTIMEElem->QueryInterface(IID_TO_PPV(IDispatch, ppDisp));
        if (FAILED(hr)) {
            TraceTag((tagError, "CCollectionCache::GetOuterDisp - QI failed (TIME)"));
        }
    }

    return hr;
} // GetOuterDisp

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Creates a new collection
//************************************************************

HRESULT
CCollectionCache::CreateCollectionHelper(IDispatch **ppDisp, long lCollectionIndex)
{
    HRESULT hr;

    *ppDisp = NULL;

    if (m_pfnCreateCollection)
    {
        return (((CVoid *)(void *)m_pBase)->*m_pfnCreateCollection)(ppDisp, lCollectionIndex);
    }

    CTIMEElementCollection *pobj = NEW CTIMEElementCollection(this, lCollectionIndex);
    if (pobj == NULL)
    {
        TraceTag((tagError, "CCollectionCache::CreateCollectionHelper - unable to alloc mem for collection"));
        return E_OUTOFMEMORY;
    }

    hr = pobj->QueryInterface(IID_TO_PPV(IDispatch, ppDisp));
    return hr;
} // CreateCollectionHelper

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    retrieved offset of Named Member, given a DISPID
//************************************************************

long
CCollectionCache::GetNamedMemberOffset(long    lCollectionIndex,
                                       DISPID  id,
                                       bool   *pfCaseSensitive /* = NULL */)
{
    long lOffset;
    bool fSensitive;

    Assert(IsNamedCollectionMember(lCollectionIndex, id));

    // Check to see wich half of the dispid space the value goes
    if (IsSensitiveNamedCollectionMember(lCollectionIndex, id))
    {
        lOffset = GetSensitiveNamedMemberMin(lCollectionIndex);
        fSensitive = true;
    }
    else
    {
        lOffset = GetNotSensitiveNamedMemberMin(lCollectionIndex);
        fSensitive = false;
    }

    // return the sensitivity flag if required
    if (pfCaseSensitive != NULL)
        *pfCaseSensitive = fSensitive;

    return lOffset;
} // GetNamedMemberOffset

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Compares names
//************************************************************

bool
CCollectionCache::CompareName(CTIMEElementBase *pElem, const WCHAR *pwszName, bool fTagName, bool fCaseSensitive /* = false */)
{
    if (pwszName == NULL)
        return false;

    BSTR bstrSrcName = NULL;
    HRESULT hr;
    if (fTagName)
        hr = pElem->getTagString(&bstrSrcName);
    else
        hr = pElem->getIDString(&bstrSrcName);

    if (FAILED(hr))
    {
        TraceTag((tagError, "Unable to retrieve src name from element"));
        return false;
    }

    if (bstrSrcName == NULL)
        return false;

    long lCompare;
    if (fCaseSensitive)
        lCompare = StrCmpW(bstrSrcName, pwszName);
    else
        lCompare = StrCmpIW(bstrSrcName, pwszName);

    // free bstr
    SysFreeString(bstrSrcName);

    return (lCompare == 0);
} // CompareName

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    removes an item from collection.
//              NOTE: that in order to do this, caller (owner
//              of the cache) need to provide Remove function.
//************************************************************

HRESULT
CCollectionCache::Remove(long lCollectionIndex, long lItemIndex)
{
    // Make sure our collection is up-to-date.
    HRESULT hr = EnsureArray(lCollectionIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::Remove - unable to ensure array"));
        return hr;
    }

    CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
    if ((lItemIndex < 0) || (lItemIndex >= pce->m_rgElem->Size()))
    {
        TraceTag((tagError, "CCollectionCache::Remove - invalid index"));
        return E_INVALIDARG;
    }

    if (!m_pfnRemoveObject)
    {
        TraceTag((tagError, "CCollectionCache::Remove - outer function not defined"));
        return CTL_E_METHODNOTAPPLICABLE;
    }

    return ((CVoid *)((void *)m_pBase)->*m_pfnRemoveObject)(lCollectionIndex, lItemIndex);
} // Remove

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Builds a Named array from a given collection
//************************************************************

HRESULT
CCollectionCache::BuildNamedArray(long lCollectionIndex, const WCHAR *pwszName, bool fTagName, CPtrAry<CTIMEElementBase *> **prgNamed, bool fCaseSensitive /* = false */)
{
    CPtrAry<CTIMEElementBase *> *rgTemp = *prgNamed;
    HRESULT                      hr = S_OK;

    // if this array already exists, clear it.
    // Otherwise create a new array.
    if (rgTemp)
    {
        rgTemp->SetSize(0);
    }
    else
    {
        rgTemp = NEW CPtrAry<CTIMEElementBase *>;
        if (rgTemp == NULL)
        {
            TraceTag((tagError, "CCollectionCache::BuildNamedArray - unable to alloc mem for array"));
            return E_OUTOFMEMORY;
        }
    }

    // figure out which collection we are looking at,
    // look for matches, and build array

    if (IsChildrenCollection(lCollectionIndex))
    {
        Assert(m_pBase != NULL);

        // get child count
        long lCount = m_pBase->GetImmediateChildCount();
        for(long lIndex = 0; lIndex < lCount; lIndex++)
        {
            // get element
            CTIMEElementBase *pElemChild = m_pBase->GetChild(lIndex);
            Assert(pElemChild != NULL);

            if (CompareName(pElemChild, pwszName, fTagName, fCaseSensitive))
            {
                // append to array
                hr = rgTemp->Append(pElemChild);
                if (FAILED(hr))
                {
                    TraceTag((tagError, "CCollectionCache::BuildNamedArray - unable to append item"));
                    delete rgTemp;
                    return hr;
                }
            }
        }
        *prgNamed = rgTemp;
        return hr;
    }
    else if (IsAllCollection(lCollectionIndex))
    {
        EnumStart();

        // iterate over every element
        for (;;)
        {
            // get element
            CTIMEElementBase *pElem = NULL;
            hr = EnumNextElement(lCollectionIndex, &pElem);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::BuildNamedArray - EnumNextElement() failed"));
                return hr;
            }

            // if pElem is NULL, we are done.
            if (pElem == NULL)
                break;

            // compare name
            if (CompareName(pElem, pwszName, fTagName, fCaseSensitive))
            {
                // append to array
                hr = rgTemp->Append(pElem);
                if (FAILED(hr))
                {
                    TraceTag((tagError, "CCollectionCache::BuildNamedArray - unable to append item"));
                    delete rgTemp;
                    return hr;
                }
            }
        }
        *prgNamed = rgTemp;
        return hr;
    }
    else
    {
        // Must be a named array
        // Build a list of named elements.
        long               lSize = (*m_rgItems)[lCollectionIndex]->m_rgElem->Size();
        CTIMEElementBase  *pElem = NULL;

        for (long lIndex = 0; lIndex < lSize; lIndex++)
        {
            pElem = (*(*m_rgItems)[lCollectionIndex]->m_rgElem)[lIndex];
            Assert(pElem != NULL);

            if (CompareName(pElem, pwszName, fTagName, fCaseSensitive))
            {
                hr = rgTemp->Append(pElem);
                if (FAILED(hr))
                {
                    TraceTag((tagError, "CCollectionCache::BuildNamedArray - unable to append item"));
                    delete rgTemp;
                    return hr;
                }
            }
        }

        *prgNamed = rgTemp;
        return hr;
    }
} // BuildNamedArray

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    return IUnknown Interface for a given CTIMEElementBase
//************************************************************

HRESULT
CCollectionCache::GetUnknown(long lCollectionIndex, CTIMEElementBase *pElem, IUnknown **ppUnk)
{
    Assert(ppUnk != NULL);
    *ppUnk = NULL;

    Assert(pElem != NULL);

    HRESULT hr = E_UNEXPECTED;
    CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
    Assert(pce != NULL);

    if (pce->m_fReturnHTMLInterface)
    {
        ITIMEElement *pTIMEElem = NULL;
        THR(pElem->QueryInterface(IID_TO_PPV(ITIMEElement, &pTIMEElem)));
        Assert(SUCCEEDED(hr) && (pTIMEElem != NULL));
        hr = pTIMEElem->QueryInterface(IID_TO_PPV(IUnknown, ppUnk));
        if (FAILED(hr)) {
            TraceTag((tagError, "CCollectionCache::GetUnknown - QI failed (TIME)"));
        }
    }
    else
    {
        IHTMLElement *pHTMLElem = pElem->GetElement();
        Assert(NULL != pHTMLElem);
        hr = pHTMLElem->QueryInterface(IID_TO_PPV(IUnknown, ppUnk));
        if (FAILED(hr)) {
            TraceTag((tagError, "CCollectionCache::GetUnknown - QI failed (HTML)"));
        }
    }

    return hr;
} // GetUnknown

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Get IDispatch given an Index into a collection
//************************************************************

HRESULT
CCollectionCache::GetDisp(long lCollectionIndex, long lItemIndex, IDispatch **ppDisp)
{
    CTIMEElementBase *pElem = NULL;
    HRESULT hr = GetItemByIndex(lCollectionIndex, lItemIndex, &pElem);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDisp - GetItemByIndex() failed"));
        return hr;
    }

    Assert(pElem != NULL);

    return GetOuterDisp(lCollectionIndex, pElem, ppDisp);
} // GetDisp (long, long, IDispatch **)

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Get IDispatch given a name and index
//************************************************************

HRESULT
CCollectionCache::GetDisp(long lCollectionIndex, const WCHAR *pwszName, long lIndex, IDispatch **ppDisp, bool fCaseSensitive /*= false */)
{
    CTIMEElementBase *pElem = NULL;
    HRESULT hr = GetItemByName(lCollectionIndex, pwszName, lIndex, &pElem, fCaseSensitive);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDisp - GetItemByName() failed"));
        return hr;
    }

    Assert(pElem != NULL);

    return GetOuterDisp(lCollectionIndex, pElem, ppDisp);
} // GetDisp (long, const WCHAR *, long, IDispatch **, bool)

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Get IDispatch given a name.  Could return
//              either a CTIMEElementBase or sub collection depending
//              on results.
//************************************************************

HRESULT
CCollectionCache::GetDisp(long         lCollectionIndex,
                          const WCHAR *pwszName,
                          bool         fTagName,
                          IDispatch  **ppDisp,
                          bool         fCaseSensitive /* = false */)
{
    CPtrAry<CTIMEElementBase *> *rgNamed = NULL;
    HRESULT                      hr = S_OK;

    // figure out if we have this collection already built
    // return this named collection if it already exists.
    CCacheItem *pce = NULL;

    Assert(ppDisp != NULL);
    *ppDisp = NULL;

    long lSize = m_rgItems->Size();
    for (long lIndex = m_lReservedSize; lIndex < lSize; lIndex++)
    {
        pce = (*m_rgItems)[lIndex];

        // if CaseSensitivites match and
        //    Index matches DependentIndex
        //    either a tag or named collection
        bool fIsCaseSensitive = pce->m_fIsCaseSensitive ? true : false;

        if ((fIsCaseSensitive == fCaseSensitive) &&
            (lCollectionIndex == pce->m_lDependentIndex) &&
            ((fTagName && pce->m_cctype == ctTag) ||
             (!fTagName && pce->m_cctype == ctNamed)))
        {
            // compare names
            long lCompare;
            if (fCaseSensitive)
                lCompare = StrCmpW(pwszName, pce->m_bstrName);
            else
                lCompare = StrCmpIW(pwszName, pce->m_bstrName);

            // if we found a match, we are done
            if (lCompare == 0)
            {
                // addref IDispatch since we returning it
                pce->m_pDisp->AddRef();
                *ppDisp = pce->m_pDisp;
                return S_OK;
            }
        }
    }

    // Build a list of named elements.
    hr = BuildNamedArray(lCollectionIndex, pwszName, fTagName, &rgNamed, fCaseSensitive);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDisp - BuildNamedArray() failed"));
        return hr;
    }

    // if we found nothing and are NOT enumerating tags, return
    // not a failure case
    if ((rgNamed->Size() == 0) && !fTagName)
    {
        delete rgNamed;
        return DISP_E_MEMBERNOTFOUND;
    }

    // if only one element was found and we are NOT
    // enumerating tags, then QI for IDispatch for that
    // element and return it.  This only happens in ::item.
    if ((rgNamed->Size() == 1) && !fTagName)
    {
        hr = GetOuterDisp(lCollectionIndex, (*rgNamed)[0], ppDisp);
        Assert(ppDisp != NULL);

        // return ppDisp and release the array.
        delete rgNamed;
        if (FAILED(hr)) {
            TraceTag((tagError, "CCollectionCache::GetDisp - GetOuterDisp() failed"));
        }
        return hr;
    }

    // We found more than one item.  Initialize global list
    // and return IDispatch of collection.
    long lNewIndex = m_rgItems->Size();

    // create new cache item
    pce = NEW CCacheItem();
    if (pce == NULL)
    {
        TraceTag((tagError, "CCollectionCache::GetDisp - unable to alloc memory for cache item"));
        delete rgNamed;
        return E_OUTOFMEMORY;
    }

    // assign pointer to new cache item
    hr = m_rgItems->Append(pce);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDisp - Append() failed"));
        delete pce;
        delete rgNamed;
        return hr;
    }

    hr = CreateCollectionHelper(ppDisp, lNewIndex);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CCollectionCache::GetDisp - CreateCollectionHelper() failed"));
        delete rgNamed;
        return hr;
    }

    Assert(*ppDisp != NULL);

    // init name
    pce->m_bstrName = SysAllocString(pwszName);
    if (pce->m_bstrName == NULL)
    {
        ReleaseInterface(*ppDisp);
        delete rgNamed;
        TraceTag((tagError, "CCollectionCache::GetDisp - unable to alloc mem for string"));
        return E_OUTOFMEMORY;
    }

    pce->m_pDisp            = *ppDisp;
    pce->m_rgElem           = rgNamed;
    pce->m_lDependentIndex  = lCollectionIndex;       // Remember the index we depend on.
    pce->m_cctype           = fTagName ? ctTag : ctNamed;
    pce->m_fInvalid         = false;
    pce->m_fIsCaseSensitive = fCaseSensitive;

    // The collection this named collection was built from is now
    // used to rebuild (ensure) this collection. so we need to
    // put a reference on it so that it will not go away.
    // The matching Release() will be done in the dtor
    // although it is not necessary to addref the reserved collections
    // it is done anyhow, simply for consistency.  This addref
    // only needs to be done for non-reserved collections
    if (lNewIndex >= m_lReservedSize)
    {
        (*ppDisp)->AddRef();
    }

    return S_OK;
} // GetDisp (long, const WCHAR *, bool, IDispatch **, bool)

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Get the number of items in this collection.
//              The default implementation of this method uses
//              EnumStart and EnumNextElement to tally the number
//              of items.  For some subclasses of collection, there
//              will be more efficient means of doing this (e.g.
//              the item count may be stored explicitly.)
//************************************************************

HRESULT
CCollectionCache::GetItemCount(long lCollectionIndex, long *plCount)
{
    Assert(plCount != NULL);
    *plCount = 0;

    if (IsChildrenCollection(lCollectionIndex))
    {
        Assert(m_pBase != NULL);
        *plCount = m_pBase->GetImmediateChildCount();
        return S_OK;
    }
    else if (IsAllCollection(lCollectionIndex))
    {
        Assert(m_pBase != NULL);
        *plCount = m_pBase->GetAllChildCount();
        return S_OK;
    }
    else
    {
        Assert( ((*m_rgItems)[lCollectionIndex]->m_cctype == ctNamed) ||
                ((*m_rgItems)[lCollectionIndex]->m_cctype == ctTag) );

        // must be standard array.  (i.e. sub-collection
        // move to correct offset and find size of array
        *plCount = (*m_rgItems)[lCollectionIndex]->m_rgElem->Size();
        return S_OK;
    }
} // GetItemCount

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Get an indexed item.  The default implementation
//              uses EnumStart and EnumNextElement to scan through
//              the items.  For some subclasses of collection, there
//              will be more efficient means of doing this (e.g.
//              the items are stored in a contiguous array, making
//              random access of the items trivial.)  If the index
//              is out of range, this method will still return
//              S_OK, but pElem will contain NULL.
//************************************************************

HRESULT
CCollectionCache::GetItemByIndex(long lCollectionIndex, long lElementIndex, CTIMEElementBase **ppElem, bool fContinueFromPreviousSearch, long lLast)
{
    Assert(ppElem != NULL);
    *ppElem = NULL;

    if (IsChildrenCollection(lCollectionIndex))
    {
        Assert(m_pBase != NULL);

        // check to see if index is greater than count
        long lChildCount = m_pBase->GetImmediateChildCount();
        if (lElementIndex > lChildCount)
            return E_INVALIDARG;

        *ppElem = m_pBase->GetChild(lElementIndex);
        return S_OK;
    }
    else if (IsAllCollection(lCollectionIndex))
    {
        // All Collection
        // Note: since this is iterative, check to see if we start at the
        //       beginning or from a previous spot.
        long lCount = lLast;
        Assert(lElementIndex >= lLast);
        if (!fContinueFromPreviousSearch)
        {
            lCount = 0;
            EnumStart();
        }

        for (;;)
        {
            HRESULT hr = EnumNextElement(lCollectionIndex, ppElem);
            if (FAILED(hr))
            {
                TraceTag((tagError,  "CCollectionCache::GetItemByIndex - EnumNextElement() failed"));
                return hr;
            }

            Assert(ppElem != NULL);
            if (*ppElem == NULL)
            {
                // we have exceeded the bounds of the collection,
                // and therefor this is an invalid index
                return E_INVALIDARG;
            }

            // Keep scanning until we reach lElementIndex or the
            // last item in the collection.
            if (lElementIndex == lCount)
                break;
            lCount++;
        }
        return S_OK;
    }
    else
    {
        // must be standard array
        // get element at index
        CCacheItem *pce = (*m_rgItems)[lCollectionIndex];
        if ( (lElementIndex < 0) ||
             (lElementIndex >= pce->m_rgElem->Size()) )
        {
            TraceTag((tagError, "CCollectionCache::GetItemByIndex - invalid index"));
            return E_INVALIDARG;
        }

        *ppElem = (*pce->m_rgElem)[lElementIndex];
        return S_OK;
    }
} // GetItemByIndex


//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    Return an item in the collection with a
//              specified id.  If no such item is found,
//              pElem will contain NULL.
//************************************************************

HRESULT
CCollectionCache::GetItemByName(long lCollectionIndex, const WCHAR *pwszName, long lElementIndex, CTIMEElementBase **ppElem, bool fCaseSensitive)
{
    long    lItem = 0;

    Assert(ppElem != NULL);
    *ppElem = NULL;

    if (IsAllCollection(lCollectionIndex) ||
        IsChildrenCollection(lCollectionIndex))
    {
        EnumStart();

        for (;;)
        {
            HRESULT hr = EnumNextElement(lCollectionIndex, ppElem);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CCollectionCache::GetItemByName - EnumNextElement() failed"));
                return hr;
            }

            // See if this was the last item in the collection
            if (*ppElem == NULL)
                break;

            // Compare the element's id to the target id
            if (CompareName(*ppElem, pwszName, false, fCaseSensitive))
            {
                // check to see if we are on specified index
                if (lElementIndex == lItem)
                    return S_OK;

                // continue looking
                lItem++;
            }
        }
        // not an error condition
        return DISP_E_MEMBERNOTFOUND;
    }
    else
    {
        long               lSize = (*m_rgItems)[lCollectionIndex]->m_rgElem->Size();
        CTIMEElementBase  *pElem = NULL;

        // loop thru array, looking for a match.
        // if an index is specified, then keep looking until index condition is met.
        for (long lIndex = 0; lIndex < lSize; lIndex++)
        {
            pElem = (*(*m_rgItems)[lCollectionIndex]->m_rgElem)[lIndex];

            Assert(pElem != NULL);

            if (CompareName(pElem, pwszName, false, fCaseSensitive))
            {
                    // check to see if we are on specified index
                    if (lElementIndex == lItem)
                    {
                        *ppElem = pElem;
                        return S_OK;
                    }

                    // continue looking
                    lItem++;
            }
        }

        // NOTE: if we got here, we didn't find anything
        return DISP_E_MEMBERNOTFOUND;
    }
} // GetItemByName

//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    This function initializes variables so we can
//              start walking the tree.
//************************************************************

void
CCollectionCache::EnumStart()
{
    m_pElemEnum = m_pBase;
    m_lEnumItem = 0;
} // EnumStart


//************************************************************
// Author:	twillie
// Created:	02/06/98
// Abstract:    This function does the walking of our heirarchial
//              tree.
//************************************************************

HRESULT
CCollectionCache::EnumNextElement(long lCollectionIndex, CTIMEElementBase **ppElem)
{
    HRESULT hr;
    Assert(ppElem != NULL);
    *ppElem = NULL;

    if (IsChildrenCollection(lCollectionIndex))
    {
        hr = GetItemByIndex(lCollectionIndex, m_lEnumItem, ppElem);
        m_lEnumItem++;
        return hr;
    }
    else
    {
        long lChildCount = m_pElemEnum->GetImmediateChildCount();
        while (m_lEnumItem == lChildCount)
        {
            // We're one past the last element in the current child element
            // being enumerated.
            if (m_pElemEnum == m_pBase)
            {
                // We're done if we reached the last item in the
                // root element.
                *ppElem = NULL;
                return S_OK;
            }
            else
            {
                // Otherwise, back up the tree until we find some children
                // that we haven't traversed yet.
                // BUGBUG - need internal to walk back wards up tree.
                CTIMEElementBase *pElemParent = m_pElemEnum->GetParent();
                Assert(pElemParent != NULL);

                // It's probably better if we maintain a stack of offsets
                // during traversal, but since no element can appear more
                // than once in the scene graph, we can scan to find our
                // offset in the parent's child array.
                lChildCount = pElemParent->GetImmediateChildCount();
                m_lEnumItem = 0;

                while (m_lEnumItem < lChildCount)
                {
                    CTIMEElementBase *pElemChild = pElemParent->GetChild(m_lEnumItem);
                    m_lEnumItem++;
                    if (pElemChild == m_pElemEnum)
                        break;
                }

                m_pElemEnum = pElemParent;
            }
        }

        // This can only be the result of scene graph corruption
        // during traversal.
        Assert(m_lEnumItem < lChildCount);

        *ppElem = m_pElemEnum->GetChild(m_lEnumItem);
        Assert(*ppElem != NULL);

        // Advance to the next element.  If the current element is
        // has children, we move down the tree and start enumerating its
        // children.  Otherwise, we'll move on to the next child
        // of m_pElemEnum.
        if ((*ppElem)->GetImmediateChildCount() == 0)
        {
            m_lEnumItem++;
        }
        else
        {
            m_lEnumItem = 0;
            m_pElemEnum = *ppElem;
        }

        return S_OK;
    }
} // EnumNextElement


//************************************************************
//
// End of File
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\containerobj.cpp ===
//************************************************************
//
// FileName:        containerobj.cpp
//
// Created:         10/08/98
//
// Author:          TWillie
// 
// Abstract:        container object implementation.
//
//************************************************************

#include "headers.h"
#include "containerobj.h"

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

DeclareTag(tagContainerObj, "API", "CContainerObj methods");

#define MediaPlayerCLSID L"{22d6f312-b0f6-11d0-94ab-0080c74c7e95}"

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        constructor
//************************************************************

CContainerObj::CContainerObj() :
    m_cRef(0),
    m_pSite(NULL),
    m_fStarted(false),
    m_pElem(NULL),
    m_fUsingWMP(false),
    m_bPauseOnPlay(false),
    m_bSeekOnPlay(false),
    m_dblSeekTime(0),
    m_bFirstOnMediaReady(true),
    m_bIsAsfFile(false)
{
    TraceTag((tagContainerObj, "CContainerObj::CContainerObj"));
} // CContainerObj

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        destructor
//************************************************************

CContainerObj::~CContainerObj()
{
    TraceTag((tagContainerObj, "CContainerObj::~CContainerObj"));

    if (m_pSite != NULL)
    {
        // make sure we are stopped
        if (m_fStarted)
            Stop();

        m_pSite->Close();
        ReleaseInterface(m_pSite);
    }
} // ~CContainerObj

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Init
//************************************************************

HRESULT
CContainerObj::Init(REFCLSID clsid, CTIMEElementBase *pElem)
{
    TraceTag((tagContainerObj, "CContainerObj::Init"));

    HRESULT hr;

    Assert(pElem != NULL);

    m_pSite = NEW CContainerSite(this);
    if (m_pSite == NULL)
    {
        TraceTag((tagError, "CContainerObj::Init - Unable to allocate memory for CContainerSite"));
        return E_OUTOFMEMORY;
    }
    
    // addref the site
    m_pSite->AddRef();

    hr =  m_pSite->Init(clsid, pElem);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerObj::Init - Init() failed on CContainerSite"));
        goto done;
    }

    m_pElem = pElem;

    {
        // check to see if we are using WMP

        CLSID clsidWMP;
        if (SUCCEEDED(CLSIDFromString(MediaPlayerCLSID, &clsidWMP)))
        {
            if (IsEqualCLSID(clsid, clsidWMP))
                m_fUsingWMP = true;
        }
    }
done:
    return hr;
} // Init

//************************************************************
// Author:          pauld
// Created:         3/2/99
// Abstract:        DetachFromHostElement
//************************************************************
HRESULT
CContainerObj::DetachFromHostElement (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagContainerObj, "CContainerObj::DetachFromHostElement(%lx)", this));
    m_pElem = NULL;
    if (NULL != m_pSite)
    {
        hr = m_pSite->DetachFromHostElement();
    }

    return hr;
} // DetachFromHostElement

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        AddRef
//************************************************************

STDMETHODIMP_(ULONG)
CContainerObj::AddRef(void)
{
    return ++m_cRef;
} // AddRef

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        Release
//************************************************************

STDMETHODIMP_(ULONG)
CContainerObj::Release(void)
{
    if (m_cRef == 0)
    {
        TraceTag((tagError, "CContainerObj::Release - YIKES! Trying to decrement when Ref count is zero!!!"));
        return m_cRef;
    }

    if (0 != --m_cRef)
    {
        return m_cRef;
    }

    delete this;
    return 0;
} // Release

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        QI
//************************************************************

STDMETHODIMP
CContainerObj::QueryInterface(REFIID riid, void **ppv)
{
    if( NULL == ppv )
    {
        Assert(false);
        return E_POINTER;
    }

    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
    {
        // SAFECAST macro doesn't work with IUnknown
        *ppv = this;
    }
    else if (IsEqualIID(riid, IID_IDispatch) ||
             IsEqualIID(riid, DIID_TIMEMediaPlayerEvents))
    {
        *ppv = SAFECAST(this, IDispatch*);
    }
    else if (IsEqualIID(riid, IID_IConnectionPointContainer))
    {
        *ppv = SAFECAST(this, IConnectionPointContainer*);
    }

    if (NULL != *ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
} // QueryInterface

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetTypeInfoCount, IDispatch
// Abstract:        Returns the number of tyep information 
//                  (ITypeInfo) interfaces that the object 
//                  provides (0 or 1).
//************************************************************

HRESULT
CContainerObj::GetTypeInfoCount(UINT *pctInfo) 
{
    TraceTag((tagContainerObj, "CContainerObj::GetTypeInfoCount"));
    return E_NOTIMPL;
} // GetTypeInfoCount

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetTypeInfo, IDispatch
// Abstract:        Retrieves type information for the 
//                  automation interface. 
//************************************************************

HRESULT
CContainerObj::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptInfo) 
{ 
    TraceTag((tagContainerObj, "CContainerObj::GetTypeInfo"));
    return E_NOTIMPL;
} // GetTypeInfo

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetIDsOfNames, IDispatch
// Abstract:        constructor
//************************************************************

HRESULT
CContainerObj::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID)
{
    TraceTag((tagContainerObj, "CContainerObj::GetIDsOfNames"));
    return E_NOTIMPL;
} // GetIDsOfNames

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        Invoke, IDispatch
// Abstract:        get entry point given ID
//************************************************************

HRESULT
CContainerObj::Invoke(DISPID dispIDMember, REFIID riid, LCID lcid, unsigned short wFlags, 
              DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr) 
{ 
    TraceTag((tagContainerObj, "CContainerObj::Invoke(%08X, %04X)", dispIDMember, wFlags));
    HRESULT hr;

    switch (dispIDMember)
    {
        case DISPID_TIMEMEDIAPLAYEREVENTS_ONBEGIN:
        case DISPID_TIMEMEDIAPLAYEREVENTS_ONEND:
        case DISPID_TIMEMEDIAPLAYEREVENTS_ONRESUME:
        case DISPID_TIMEMEDIAPLAYEREVENTS_ONPAUSE:
        case DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIAREADY:
        case DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIASLIP:
        case DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIALOADFAILED:
            hr = ProcessEvent(dispIDMember);
            break;

        case DISPID_TIMEMEDIAPLAYEREVENTS_READYSTATECHANGE:
            {
                long state = 0;

                // BUGBUG:  need to grovel through args for state
                onreadystatechange(state);
                hr = S_OK;
            }
            break;

        default:
            hr = E_NOTIMPL;

            // HACKHACK
            // Pick off the script command from WMP and repackage the event as our own.
            // This allows triggers to work.  The real fix is to add another event on
            // TIMEMediaPlayerEvents.
            {
                #define DISPID_SCRIPTCOMMAND 3001

                if ( (dispIDMember == DISPID_SCRIPTCOMMAND) && 
                     (m_fUsingWMP) )
                {
                    if (NULL != m_pElem)
                    {
                        static LPWSTR pNames[] = {L"Param", L"scType"};
                        hr = m_pElem->GetEventMgr().FireEvent(TE_ONSCRIPTCOMMAND, 
                                                               pDispParams->cArgs, 
                                                               pNames, 
                                                               pDispParams->rgvarg);
                    }
                    else
                    {
                        hr = E_UNEXPECTED;
                    }
                }
            }
            break;
    }

    return hr;
} // Invoke

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Start
//************************************************************

HRESULT
CContainerObj::Start()
{
    TraceTag((tagContainerObj, "CContainerObj::Start"));
    HRESULT hr;
    
    hr  = m_pSite->begin();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerObj::Start - begin() failed"));
        goto done;
    }

    m_fStarted = true;

done:
    return hr;
} // Start

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Pause
//************************************************************

HRESULT
CContainerObj::Pause()
{
    TraceTag((tagContainerObj, "CContainerObj::Pause"));
    HRESULT hr;
    
    hr  = m_pSite->pause();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerObj::Pause - pause() failed"));
        m_bPauseOnPlay = true;
    }
    return hr;
} // Pause

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Stop
//************************************************************

HRESULT
CContainerObj::Stop()
{
    TraceTag((tagContainerObj, "CContainerObj::Stop(%lx)", this));
    HRESULT hr = S_OK;

    if (m_fStarted)
    {    
        m_fStarted = false;

        hr  = m_pSite->end();
        if (FAILED(hr))
        {
            TraceTag((tagError, "CContainerObj::Stop - end() failed"));
            goto done;
        }
    }
done:
    return hr;
} // Stop

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Resume
//************************************************************

HRESULT
CContainerObj::Resume()
{
    TraceTag((tagContainerObj, "CContainerObj::Resume"));
    HRESULT hr;
    
    hr  = m_pSite->resume();
    if (FAILED(hr))
    {    
        TraceTag((tagError, "CContainerObj::Resume - resume() failed"));
    }
    return hr;
} // Resume

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Render
//************************************************************

HRESULT
CContainerObj::Render(HDC hdc, RECT *prc)
{
    HRESULT hr = S_OK;

    if (prc == NULL)
        TraceTag((tagContainerObj, "CContainerObj::Render(%O8X, NULL)"));
    else
        TraceTag((tagContainerObj, "CContainerObj::Render(%O8X, (%d, %d, %d, %d))", prc->left, prc->right, prc->top, prc->bottom));

    if (m_pSite != NULL)    
        hr = m_pSite->draw(hdc, prc);
    return hr;
} // Render

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        SetMediaSrc
//************************************************************

HRESULT
CContainerObj::SetMediaSrc(WCHAR *pwszSrc)
{
    TraceTag((tagContainerObj, "CContainerObj::SetMediaSrc (%S)", pwszSrc));
    HRESULT hr;

    isFileNameAsfExt(pwszSrc);

    hr  = m_pSite->GetPlayer()->put_src(pwszSrc);
    if (FAILED(hr))
    {    
        TraceTag((tagError, "CContainerObj::SetMediaSrc - put_src() failed"));
    }
    return hr;
} // SetMediaSrc


// the following is a helper function used because the CanSeek method on WMP only
// works on ASF fles.
bool
CContainerObj::isFileNameAsfExt(WCHAR *pwszSrc)
{
    WCHAR *pext;
    
    m_bIsAsfFile = false;
    
    if (NULL != pwszSrc)
    {
        if(wcslen(pwszSrc) > 4)
        {
            pext = pwszSrc + wcslen(pwszSrc) - 4;
            if(wcscmp(pext, L".asf") == 0)
            {
                m_bIsAsfFile = true;
            }
            else
            {
                m_bIsAsfFile = false;
            }
        }
    }

    return m_bIsAsfFile;
}


//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        SetRepeat
//************************************************************

HRESULT
CContainerObj::SetRepeat(long lRepeat)
{
    TraceTag((tagContainerObj, "CContainerObj::SetRepeat (%d)", lRepeat));
    HRESULT hr;
    
    if (lRepeat == 1)
       return S_OK;
    
    Assert(m_pSite->GetPlayer() != NULL);    
    hr  = m_pSite->GetPlayer()->put_repeat(lRepeat);
    if (FAILED(hr))
    {    
        TraceTag((tagError, "CContainerObj::SetRepeat - put_repeat() failed"));
    }
    return hr;
} // SetRepeat

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        clipBegin
//************************************************************

HRESULT
CContainerObj::clipBegin(VARIANT var)
{
    TraceTag((tagContainerObj, "CContainerObj::clipBegin"));
    HRESULT hr;
    
    if (var.vt == VT_EMPTY)
        return S_OK;
            
    Assert(m_pSite->GetPlayer() != NULL);    
    hr  = m_pSite->GetPlayer()->clipBegin(var);
    if (FAILED(hr))
    {    
        TraceTag((tagError, "CContainerObj::clipBegin - clipBegin() failed"));
    }
    return hr;
} // ClipBegin

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        clipEnd
//************************************************************

HRESULT
CContainerObj::clipEnd(VARIANT var)
{
    TraceTag((tagContainerObj, "CContainerObj::clipEnd"));
    HRESULT hr;
    
    if (var.vt == VT_EMPTY)
        return S_OK;

    Assert(m_pSite->GetPlayer() != NULL);    
    hr  = m_pSite->GetPlayer()->clipEnd(var);
    if (FAILED(hr))
    {    
        TraceTag((tagError, "CContainerObj::clipEnd - clipEnd() failed"));
    }
    return hr;
} // ClipEnd

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Render
//************************************************************

HRESULT
CContainerObj::Invalidate(const RECT *prc)
{
    HRESULT  hr;
    RECT     rc;
    RECT    *prcNew;

    // No need to forward call on if we are not started yet or if the element has detached.
    if ((!m_fStarted) || (NULL == m_pElem))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    // since we have incapatible types due to const.  Take the time and repack it.
    if (prc == NULL)
    {
        prcNew = NULL;
    }
    else
    {
        ::CopyRect(&rc, prc);
        prcNew = &rc;
    }

    // m_pElem != is checked above.
    m_pElem->InvalidateRect(prcNew);    
    hr = S_OK;

done:
    return hr;
} // Invalidate

//************************************************************
// Author:          twillie
// Created:         10/26/98
// Abstract:        GetControlDispatch
//************************************************************

HRESULT
CContainerObj::GetControlDispatch(IDispatch **ppDisp)
{
    TraceTag((tagContainerObj, "CContainerObj::GetControlDispatch"));
    Assert(m_pSite != NULL);
    HRESULT hr = m_pSite->GetPlayer()->QueryInterface(IID_TO_PPV(IDispatch, ppDisp));
    if (FAILED(hr))
    {    
        TraceTag((tagError, "CContainerObj::GetControlDispatch - QI failed for IDispatch"));
    }
    return hr;
} // GetControlDispatch

//************************************************************
// Author:          twillie
// Created:         11/06/98
// Abstract:        
//************************************************************

HRESULT
CContainerObj::EnumConnectionPoints(IEnumConnectionPoints ** ppEnum)
{
    TraceTag((tagContainerObj, "CContainerObj::EnumConnectionPoints"));

    if (ppEnum == NULL)
    {
        TraceTag((tagError, "CContainerObj::EnumConnectionPoints - invalid arg"));
        return E_POINTER;
    }

    return E_NOTIMPL;
}

//************************************************************
// Author:          twillie
// Created:         11/06/98
// Abstract:        Finds a connection point with a particular IID.
//************************************************************

HRESULT
CContainerObj::FindConnectionPoint(REFIID iid, IConnectionPoint **ppCP)
{
    TraceTag((tagContainerObj, "CContainerObj::FindConnectionPoint"));

    if (ppCP == NULL)
    {
        TraceTag((tagError, "CContainerObj::FindConnectionPoint - invalid arg"));
        return E_POINTER;
    }

    return E_NOTIMPL;
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CContainerObj::onbegin()
{
    TraceTag((tagContainerObj, "CContainerObj::onbegin"));
    THR(ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONBEGIN));
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CContainerObj::onend()
{
    TraceTag((tagContainerObj, "CContainerObj::onend"));
    THR(ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONEND));
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CContainerObj::onresume()
{
    TraceTag((tagContainerObj, "CContainerObj::onresume"));
    THR(ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONRESUME));
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CContainerObj::onpause()
{
    TraceTag((tagContainerObj, "CContainerObj::onpause"));
    THR(ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONPAUSE));
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CContainerObj::onmediaready()
{
    TraceTag((tagContainerObj, "CContainerObj::onmediaready"));
    THR(ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIAREADY));
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CContainerObj::onmediaslip()
{
    TraceTag((tagContainerObj, "CContainerObj::onmediaslip"));
    THR(ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIASLIP));
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CContainerObj::onmedialoadfailed()
{
    TraceTag((tagContainerObj, "CContainerObj::onmedialoadfailed"));
    THR(ProcessEvent(DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIALOADFAILED));
}

//************************************************************
// Author:          twillie
// Created:         11/12/98
// Abstract:        
//************************************************************
void 
CContainerObj::onreadystatechange(long readystate)
{
    TraceTag((tagContainerObj, "CContainerObj::onreadystatechange"));

    // BUGBUG - need to defined states that the player might want to communicate back to
    //          the host.
}

HRESULT
CContainerObj::ProcessEvent(DISPID dispid)
{
    TraceTag((tagContainerObj, "CContainerObj::ProcessEvent(%lx)",this));

    if (NULL != m_pElem)
    {
        switch (dispid)
        {
            case DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIALOADFAILED:
                m_pElem->FireEvent(TE_ONMEDIALOADFAILED, 0.0, 0);
                break;

            case DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIASLIP:
                m_pElem->FireEvent(TE_ONMEDIASLIP, 0.0, 0);
                break;

            case DISPID_TIMEMEDIAPLAYEREVENTS_ONMEDIAREADY:
                double mediaLength;
                VARIANT vdur;
                HRESULT hr;
                float endTime, duration;

                m_pSite->SetMediaReadyFlag();
                m_pSite->ClearAutosizeFlag();

                VariantInit(&vdur);

                m_pElem->FireEvent(TE_ONMEDIACOMPLETE, 0.0, 0);
                if (m_bFirstOnMediaReady)
                {            
                    m_bFirstOnMediaReady = false;
                    if (m_bPauseOnPlay)
                    {
                        THR(m_pSite->pause());
                        m_bPauseOnPlay = false;
                    }
                    else if (m_bSeekOnPlay)
                    {
                        THR(this->Seek(m_dblSeekTime));
                        m_bSeekOnPlay = false;
                    }

                    //check to see if either dur or end have default
                    //values. If they do not, we do not change the dur.

                    duration = m_pElem->GetDuration();
                    if (duration != valueNotSet)
                    {
                        VariantClear(&vdur);
                        break;
                    }

                    endTime = m_pElem->GetEndTime();
                    if (endTime != valueNotSet)
                    {
                        VariantClear(&vdur);
                        break;
                    }

                    hr = GetMediaLength( mediaLength);
                    if(FAILED(hr))
                    {
                        VariantClear(&vdur);
                        break;
                    }

                    V_VT(&vdur) = VT_R8;
                    V_R8(&vdur) = mediaLength;
                    hr = VariantChangeTypeEx(&vdur, &vdur, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR);
                    if(FAILED(hr))
                    {
                        VariantClear(&vdur);
                        break;
                    }
                    TraceTag((tagError, "CContainerObj::ProcessEvent(%lx) %g",this, mediaLength));

                    m_pElem->base_put_dur(vdur);
                    m_pElem->setNaturalDuration();

                    VariantClear(&vdur);
                }
                break;

            case DISPID_TIMEMEDIAPLAYEREVENTS_ONEND:
                // make sure we are stopped if there 
                // is no Duration specified
                if ( m_pElem->GetRealDuration() == valueNotSet)
                {
                    HRESULT hr = S_OK;
                    double dblMediaLength = 0.0;
                    if ( NULL == m_pElem || NULL == m_pElem->GetMMBvr().GetMMBvr() )
                    {
                        return S_OK;
                    }

                    hr = THR(m_pElem->GetMMBvr().GetMMBvr()->get_SegmentTime(&dblMediaLength));
                    if (FAILED(hr))
                    {
                        dblMediaLength = 0.0;
                    }

                    VARIANT varMediaLength;
                    VariantInit(&varMediaLength);

                    varMediaLength.vt = VT_R8;
                    varMediaLength.dblVal = dblMediaLength;
                    
                    hr = THR(m_pElem->base_put_dur(varMediaLength));

                    VariantClear(&varMediaLength);                                                            
                }
                break;
        }
    }
    return S_OK;
}


HRESULT
CContainerObj::CanSeek(bool &fcanSeek)
{
    HRESULT hr = S_OK;

    if(m_bIsAsfFile == true)
    {
        hr = m_pSite->CanSeek( fcanSeek);

        if(FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        fcanSeek = true;
    }
done:
    return hr;

}



HRESULT
CContainerObj::Seek(double dblTime)
{
    HRESULT hr = S_OK;
    bool fcanSeek;

    if (m_bFirstOnMediaReady)
    {
        // we haven't started yet, wait on the seek
        m_bSeekOnPlay = true;
        m_dblSeekTime = dblTime;
    }
    else if (m_pSite != NULL)
    {
        hr = CanSeek(fcanSeek);
        if(FAILED(hr))
        {
            fcanSeek = false;
            goto done;
        }

        if( fcanSeek == true)
        {
            hr = m_pSite->GetPlayer()->put_CurrentTime(dblTime);
        }
    }
done:
    return hr;
}

double
CContainerObj::GetCurrentTime()
{
    double dblTime = 0.0;
    
    if (m_pSite != NULL)
    {
        double dblTemp = 0.0;
        HRESULT hr;
        hr = m_pSite->GetPlayer()->get_CurrentTime(&dblTemp);
        if (SUCCEEDED(hr))
            dblTime = dblTemp;
    }
    return dblTime;
}


HRESULT
CContainerObj::SetSize(RECT *prect)
{
    HRESULT hr = S_OK;
    IOleInPlaceObject *pInPlaceObject;

    if (m_pSite == NULL)
    {
        hr = E_FAIL;
        goto done;
    }
    pInPlaceObject = m_pSite -> GetIOleInPlaceObject();
    if (pInPlaceObject == NULL)
    {
        hr = E_FAIL;
        goto done;
    }


    hr = pInPlaceObject -> SetObjectRects(prect, prect);

done:
    return hr;
}

HRESULT
CContainerObj::GetMediaLength(double &dblLength)
{
    HRESULT hr;
    if (!m_fUsingWMP)
        return E_FAIL;

    Assert(m_pSite != NULL);
    hr = m_pSite->GetMediaLength(dblLength);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\collect.h ===
#ifndef __COLLECT_H_
#define __COLLECT_H_

//************************************************************
//
// Filename:    collect.h
//
// Created:     09/25/97
//
// Author:	twillie
//
// Abstract:    Collection implementation.
//              
//************************************************************

#include "dispex.h"
#include "atomtable.h"
#include "array.h"
#include "timeelmbase.h"
#include "datimeid.h"


#define NOT_DEPENDENT_COLLECTION   -1
#define CTL_E_METHODNOTAPPLICABLE  STD_CTL_SCODE(444)

//
// A class for declaring poiners to member functions
//
class CVoid
{
}; // CVoid

//
// prototype macros for function over rides
// These are used when owner of collection wants to customize it.
//
typedef HRESULT (STDMETHODCALLTYPE CVoid::*PFN_CVOID_ENSURE)(long *plVersionCookie);

typedef HRESULT (STDMETHODCALLTYPE CVoid::*PFN_CVOID_CREATECOL)(IDispatch **pDisp,
                                                      long        lIndex);

typedef HRESULT (STDMETHODCALLTYPE CVoid::*PFN_CVOID_REMOVEOBJECT)(long lCollection,
                                                         long lIndex);
typedef HRESULT (STDMETHODCALLTYPE CVoid::*PFN_CVOID_ADDNEWOBJECT)(long       lIndex, 
                                                         IDispatch *pObject, 
                                                         long       index);

typedef enum COLLECTIONCACHETYPE
{
    ctFreeEntry,
    ctNamed,
    ctTag,
    ctAll,
    ctChildren,
}; // COLLECTIONCACHETYPE

//
// CCollectionCache
//
class CCollectionCache
{
    class CCacheItem
    {
    public:
        CCacheItem() :
            m_pDisp(NULL),
            m_rgElem(NULL),
            m_cctype(ctFreeEntry),
            m_bstrName(NULL),
            m_lDependentIndex(NOT_DEPENDENT_COLLECTION),
            m_dispidMin(DISPID_COLLECTION_RESERVED_MIN),
            m_dispidMax(DISPID_COLLECTION_RESERVED_MAX),
            m_fInvalid(true),
            m_fIdentity(false),
            m_fOKToDelete(true),
            m_fNeedRebuild(false),
            m_fPromoteNames(true),
            m_fPromoteOrdinals(true),
            m_fGetLastCollectionItem(false),
            m_fIsCaseSensitive(false),
            m_fSettableNULL(false),
            m_fReturnHTMLInterface(false)
        {
        } // constructor

        virtual ~CCacheItem()
        {
            if (m_rgElem)
            {
                delete m_rgElem;
                m_rgElem = NULL;
            }

            if (m_pDisp)
                ReleaseInterface(m_pDisp);

            if (m_bstrName)
                SysFreeString(m_bstrName);
        } // destructor

        IDispatch                   *m_pDisp;           // IDispatch for ICrElementCollection
        CPtrAry<CTIMEElementBase *> *m_rgElem;          // array of elements in collection
        COLLECTIONCACHETYPE          m_cctype;          // cache type
        BSTR                         m_bstrName;        // Name if name-based
        long                         m_lDependentIndex; // Index of item that this depends.
        DISPID                       m_dispidMin;       // Offset to add/subtract
        DISPID                       m_dispidMax;       // Offset to add/subtract

        // bit flags
        int  m_fInvalid:1;      // set for named collections only
        int  m_fIdentity:1;     // set when a collection is Identity with its container/base object
        int  m_fOKToDelete:1;   // true for collections that the cache cooks up false when Base Obj provided this CPtrAry
        int  m_fNeedRebuild:1;  // true is collection need to be rebuilt.
        int  m_fPromoteNames:1;    // true if we promote names from the object
        int  m_fPromoteOrdinals:1; // true if we promote ordinals from the object
        int  m_fGetLastCollectionItem:1; // true to fetch last item only in collection
        int  m_fIsCaseSensitive:1;       // true if item's name must be compared in case sensitive manner
        int  m_fSettableNULL:1;          // true when collection[n]=NULL is valid. normally false.

        int  m_fReturnHTMLInterface:1;   // true when we need to return IHTMLInterface instead of ITIMEElement
    }; // CCacheItem

public:
    //
    // Constructor/Destructor
    //    
    CCollectionCache(CTIMEElementBase *pBase,
                     CAtomTable *pAtomTable = NULL,
                     PFN_CVOID_ENSURE pfnEnsure = NULL,
                     PFN_CVOID_CREATECOL pfnCreation = NULL,
                     PFN_CVOID_REMOVEOBJECT pfnRemove = NULL,
                     PFN_CVOID_ADDNEWOBJECT pfnAddNewObject = NULL);
    virtual ~CCollectionCache();

    //
    // internal methods
    //
    HRESULT Init(long lReservedSize, long lIdentityIndex = -1);
    HRESULT GetCollectionDisp(long lCollectionIndex, IDispatch **ppDisp);
    HRESULT SetCollectionType(long lCollectionIndex, COLLECTIONCACHETYPE cctype, bool fReturnHTMLInterface = false);
    long Size(long lCollectionIndex);
    HRESULT GetItem(long lCollectionIndex, long i, CTIMEElementBase **ppElem);
    void Invalidate();
    void BumpVersion();

    //
    // IDispatchEx methods
    //
    HRESULT GetDispID(long lCollectionIndex, BSTR bstrName, DWORD grfdex, DISPID *pid);
    HRESULT InvokeEx(long                 lCollectionIndex, 
                     DISPID               dispidMember,
                     LCID                 lcid,
                     WORD                 wFlags,
                     DISPPARAMS          *pdispparams,
                     VARIANT             *pvarResult,
                     EXCEPINFO           *pexcepinfo,
                     IServiceProvider    *pSrvProvider);
    HRESULT DeleteMemberByName(long lCollectionIndex, BSTR bstr,DWORD grfdex);
    HRESULT DeleteMemberByDispID(long lCollectionIndex, DISPID id);
    HRESULT GetMemberProperties(long lCollectionIndex, DISPID id, DWORD grfdexFetch, DWORD *pgrfdex);
    HRESULT GetMemberName(long lCollectionIndex, DISPID id, BSTR *pbstrName);
    HRESULT GetNextDispID(long lCollectionIndex, DWORD grfdex, DISPID id, DISPID *prgid);
    HRESULT GetNameSpaceParent(long lCollectionIndex, IUnknown **ppunk);
    
    //
    // Standard collection methods
    //
    HRESULT put_length(long lIndex, long retval);
    HRESULT get_length(long lIndex, long *retval);
    HRESULT get__newEnum(long lIndex, IUnknown **retval);
    HRESULT item(long lIndex, VARIANTARG varName, VARIANTARG varIndex, IDispatch **pDisp);
    HRESULT tags(long lIndex, VARIANT varName, IDispatch **pDisp);

private:
    // private functions
    HRESULT EnsureArray(long lCollectionIndex);
    void EnumStart(void);
    HRESULT EnumNextElement(long lCollectionIndex, CTIMEElementBase **pElem);

    HRESULT GetOuterDisp(long lCollectionIndex, CTIMEElementBase *pElem, IDispatch **ppDisp);
    HRESULT Remove(long lCollection, long lItemIndex);
    HRESULT CreateCollectionHelper(IDispatch **ppDisp, long lIndex);

    bool CompareName(CTIMEElementBase *pElem, const WCHAR *pwszName, bool fTagName, bool fCaseSensitive = false);

    HRESULT BuildNamedArray(long lCollectionIndex, const WCHAR *pwszName, bool fTagName, CPtrAry<CTIMEElementBase *> **prgNamed, bool fCaseSensitive = false);
    HRESULT GetUnknown(long lCollectionIndex, CTIMEElementBase *pElem, IUnknown **ppUnk);    
    
    HRESULT GetDisp(long lCollectionIndex, long lItemIndex, IDispatch **ppDisp);
    HRESULT GetDisp(long lCollectionIndex, const WCHAR *pwszName, long lItemIndex, IDispatch **ppDisp, bool fCaseSensitive = false);
    HRESULT GetDisp(long lCollectionIndex, const WCHAR *pwszName, bool fTagName, IDispatch **ppDisp, bool fCaseSensitive = false);

    HRESULT GetItemCount(long lIndex, long *plCount);
    HRESULT GetItemByIndex(long lIndex, long lElementIndex, CTIMEElementBase **pElem, bool fContinueFromPreviousSearch = false, long lLast = 0);
    HRESULT GetItemByName(long lIndex, const WCHAR *pwszName, long lElementIndex, CTIMEElementBase **pElem, bool fCaseSensitive = false);

    bool IsChildrenCollection(long lCollectionIndex);
    bool IsAllCollection(long lCollectionIndex);
    
    bool ValidateCollectionIndex(long lCollectionIndex);

    DISPID GetNamedMemberMin(long lCollectionIndex);
    DISPID GetNamedMemberMax(long lCollectionIndex);
    DISPID GetOrdinalMemberMin(long lCollectionIndex);
    DISPID GetOrdinalMemberMax(long lCollectionIndex);
    bool IsNamedCollectionMember(long lCollectionIndex, DISPID dispidMember);
    bool IsOrdinalCollectionMember(long lCollectionIndex, DISPID dispidMember);
    DISPID GetSensitiveNamedMemberMin (long lCollectionIndex);
    DISPID GetSensitiveNamedMemberMax(long lCollectionIndex);
    DISPID GetNotSensitiveNamedMemberMin(long lCollectionIndex);
    DISPID GetNotSensitiveNamedMemberMax(long lCollectionIndex);
    bool IsSensitiveNamedCollectionMember(long lCollectionIndex, DISPID dispidMember);
    bool IsNotSensitiveNamedCollectionMember( long lCollectionIndex, DISPID dispidMember);
    long GetNamedMemberOffset(long lCollectionIndex, DISPID id, bool *pfCaseSensitive = NULL);

private:
    CTIMEElementBase       *m_pElemEnum;        // Used as a place holder when we walk the tree
    long                    m_lEnumItem;        // Used as a place holder when we walk the tree
    long                    m_lReservedSize;    // number of CElementCollections that are reserved

    CPtrAry<CCacheItem *>  *m_rgItems;          // array of CCachItems

    long                    m_lCollectionVersion;
    long                    m_lDynamicCollectionVersion;

    CTIMEElementBase       *m_pBase;
    CAtomTable             *m_pAtomTable;       // array of named elements which we have DISPID's for
    
    // functions used to over ride default collection behavior                      
    PFN_CVOID_ENSURE        m_pfnEnsure;
    PFN_CVOID_REMOVEOBJECT  m_pfnRemoveObject; 
    PFN_CVOID_CREATECOL     m_pfnCreateCollection;
    PFN_CVOID_ADDNEWOBJECT  m_pfnAddNewObject;
}; // CCollectionCache

//
// CTIMEElementCollection
//
class CTIMEElementCollection : 
    public IDispatchEx,
    public ITIMEElementCollection,
    public ISupportErrorInfoImpl<&IID_ITIMEElementCollection>
{
public:
    CTIMEElementCollection(CCollectionCache *pCollectionCache, long lIndex);

    //
    // IUnknown Methods
    //
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID, void**);

    //
    // IDispatch methods
    //
    STDMETHOD(GetTypeInfoCount)(UINT FAR *pctinfo);
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHOD(GetIDsOfNames)(REFIID                riid,
                             LPOLESTR             *rgszNames,
                             UINT                  cNames,
                             LCID                  lcid,
                             DISPID FAR           *rgdispid);
    STDMETHOD(Invoke)(DISPID          dispidMember,
                      REFIID          riid,
                      LCID            lcid,
                      WORD            wFlags,
                      DISPPARAMS     *pdispparams,
                      VARIANT        *pvarResult,
                      EXCEPINFO      *pexcepinfo,
                      UINT           *puArgErr);

    //
    // IDispatchEx methods
    //
    STDMETHOD(GetDispID)(BSTR bstrName, DWORD grfdex, DISPID *pid);
    STDMETHOD(InvokeEx)(DISPID               dispidMember,
                       LCID                 lcid,
                       WORD                 wFlags,
                       DISPPARAMS          *pdispparams,
                       VARIANT             *pvarResult,
                       EXCEPINFO           *pexcepinfo,
                       IServiceProvider    *pSrvProvider);
    STDMETHOD(DeleteMemberByName)(BSTR bstr,DWORD grfdex);
    STDMETHOD(DeleteMemberByDispID)(DISPID id);
    STDMETHOD(GetMemberProperties)(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex);
    STDMETHOD(GetMemberName)(DISPID id, BSTR *pbstrName);
    STDMETHOD(GetNextDispID)(DWORD grfdex, DISPID id, DISPID *prgid);
    STDMETHOD(GetNameSpaceParent)(IUnknown **ppunk);
    
    //
    // Standard collection methods
    //
    STDMETHOD(put_length)(long retval);
    STDMETHOD(get_length)(long *retval);
    STDMETHOD(get__newEnum)(IUnknown **retval);
    STDMETHOD(item)(VARIANTARG varName, VARIANTARG varIndex, IDispatch **pDisp);
    STDMETHOD(tags)(VARIANT varName, IDispatch **pDisp);

private:
    virtual ~CTIMEElementCollection();
    HRESULT GetTI(ITypeInfo **pptinfo);

private:
    CCollectionCache *m_pCollectionCache;  // pointer to the cache
    long              m_lCollectionIndex;  // denotes which collection we are
    ULONG             m_cRef;
    ITypeInfo        *m_pInfo;             // our TypeInfo Interface
}; // CTIMEElementCollection

//************************************************************
// inline's for CCollectionCache
//************************************************************
inline void CCollectionCache::Invalidate()
{
    m_lCollectionVersion        = 0;
    m_lDynamicCollectionVersion = 0;        
} // Invalidate

inline void CCollectionCache::BumpVersion()
{
    m_lCollectionVersion++;
} // BumpVersion

inline bool CCollectionCache::ValidateCollectionIndex(long lCollectionIndex)
{
    if ((lCollectionIndex >= 0) && (lCollectionIndex < m_rgItems->Size()))
        return true;
    return false;
} // ValidateCollectionIndex

inline DISPID CCollectionCache::GetNamedMemberMin(long lCollectionIndex) 
{
    return (*m_rgItems)[lCollectionIndex]->m_dispidMin; 
} // GetNamedMemberMin

inline DISPID CCollectionCache::GetNamedMemberMax(long lCollectionIndex)
{ 
    return ((*m_rgItems)[lCollectionIndex]->m_dispidMin + 
            (((*m_rgItems)[lCollectionIndex]->m_dispidMax - (*m_rgItems)[lCollectionIndex]->m_dispidMin) / 2));
} // GetNamedMemberMax

inline DISPID CCollectionCache::GetOrdinalMemberMin(long lCollectionIndex)
{
    return GetNamedMemberMax(lCollectionIndex) + 1;
} // GetOrdinalMemberMin

inline DISPID CCollectionCache::GetOrdinalMemberMax(long lCollectionIndex)
{
    return (*m_rgItems)[lCollectionIndex]->m_dispidMax;
} // GetOrdinalMemberMax

inline bool CCollectionCache::IsNamedCollectionMember(long lCollectionIndex, DISPID dispidMember)
{
    return ((dispidMember >= GetNamedMemberMin(lCollectionIndex)) &&
            (dispidMember <= GetNamedMemberMax(lCollectionIndex)));
} // IsNamedCollectionMember

inline bool CCollectionCache::IsOrdinalCollectionMember(long lCollectionIndex, DISPID dispidMember)
{
    return ((dispidMember >= GetOrdinalMemberMin(lCollectionIndex)) && 
            (dispidMember <= GetOrdinalMemberMax(lCollectionIndex)));
} // IsOrdinalCollectionMember

inline DISPID CCollectionCache::GetSensitiveNamedMemberMin (long lCollectionIndex)
{
    return GetNamedMemberMin(lCollectionIndex);
} // GetSensitiveNamedMemberMin

inline DISPID CCollectionCache::GetSensitiveNamedMemberMax(long lCollectionIndex)
{ 
    return (GetNamedMemberMin(lCollectionIndex) + 
            ((GetNamedMemberMax(lCollectionIndex) - GetNamedMemberMin(lCollectionIndex)) / 2));
} // GetSensitiveNamedMemberMax

inline DISPID CCollectionCache::GetNotSensitiveNamedMemberMin(long lCollectionIndex)
{
    return GetSensitiveNamedMemberMax(lCollectionIndex) + 1;
} // GetNotSensitiveNamedMemberMin
 
inline DISPID CCollectionCache::GetNotSensitiveNamedMemberMax(long lCollectionIndex)
{ 
    return GetNamedMemberMax(lCollectionIndex);
} // GetNotSensitiveNamedMemberMax

inline bool CCollectionCache::IsSensitiveNamedCollectionMember(long lCollectionIndex, DISPID dispidMember)
{
    return ((dispidMember >= GetSensitiveNamedMemberMin(lCollectionIndex)) && 
            (dispidMember <= GetSensitiveNamedMemberMax(lCollectionIndex))) ;
} // IsSensitiveNamedCollectionMember

inline bool CCollectionCache::IsNotSensitiveNamedCollectionMember( long lCollectionIndex, DISPID dispidMember)
{
    return ((dispidMember >= GetNotSensitiveNamedMemberMin(lCollectionIndex)) && 
            (dispidMember <= GetNotSensitiveNamedMemberMax(lCollectionIndex))) ;
} // IsNotSensitiveNamedCollectionMember

#endif //__COLLECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\containerobj.h ===
#ifndef _CONTAINEROBJ_H_
#define _CONTAINEROBJ_H_

//************************************************************
//
// FileName:        containerobj.h
//
// Created:         10/08/98
//
// Author:          TWillie
// 
// Abstract:        Declaration of CContainerObj
//
//************************************************************


#include "containersite.h"

// forward declaration
class CContainerSite;

class CContainerObj :
    public IDispatch,
    public IConnectionPointContainer
{
    public: 
        CContainerObj();
        virtual ~CContainerObj();
        HRESULT Init(REFCLSID clsid, CTIMEElementBase *pElem);
        HRESULT DetachFromHostElement (void);

        // IUnknown Methods
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
        STDMETHODIMP QueryInterface(REFIID refiid, void** ppunk);

        // IDispatch Methods
        STDMETHODIMP GetTypeInfoCount(UINT *pctInfo);
        STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptInfo);
        STDMETHODIMP GetIDsOfNames(REFIID  riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID);
        STDMETHODIMP Invoke(DISPID disIDMember, REFIID riid, LCID lcid, unsigned short wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr);

        // IConnectionPointContainer methods
        STDMETHOD(EnumConnectionPoints)(IEnumConnectionPoints **ppEnum);
        STDMETHOD(FindConnectionPoint)(REFIID riid, IConnectionPoint **ppCP);

        // methods for hosting site
        HRESULT Start();
        HRESULT Stop();
        HRESULT Pause();
        HRESULT Resume();

        HRESULT Render(HDC hdc, RECT *prc);
        HRESULT SetMediaSrc(WCHAR * pwszSrc);
        HRESULT SetRepeat(long lRepeat);
        HRESULT SetSize(RECT *prect);

        HRESULT Invalidate(const RECT *prc);

        HRESULT GetControlDispatch(IDispatch **ppDisp);

        HRESULT clipBegin(VARIANT var);
        HRESULT clipEnd(VARIANT var);

        // event methods that can be fired on the container
        void onbegin();
        void onend();
        void onresume();
        void onpause();
        void onmediaready();
        void onmediaslip();
        void onmedialoadfailed();
        void onreadystatechange(long readystate);

        HRESULT Seek(double dblTime);
        double GetCurrentTime();
        CTIMEElementBase *GetTimeElem() { return m_pElem;}
        HRESULT GetMediaLength(double &dblLength);
        HRESULT CanSeek(bool &fcanSeek);

    private:
        HRESULT ProcessEvent(DISPID dispid);
        bool isFileNameAsfExt(WCHAR * pwszSrc);

    private:
        ULONG               m_cRef;
        CContainerSite     *m_pSite;
        CTIMEElementBase   *m_pElem;
        bool                m_fStarted;
        bool                m_fUsingWMP;
        bool                m_bPauseOnPlay;
        bool                m_bFirstOnMediaReady;
        bool                m_bSeekOnPlay;
        double              m_dblSeekTime;
        bool                m_bIsAsfFile;
}; // CContainerObj

#endif //_CONTAINEROBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\containersite.cpp ===
//************************************************************
//
// FileName:        containersite.cpp
//
// Created:         10/08/98
//
// Author:          TWillie
// 
// Abstract:        container site implementation.
//
//************************************************************

#include "headers.h"
#include "containersite.h"

DeclareTag(tagContainerSite, "API", "CContainerSite methods");

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        constructor
//************************************************************

CContainerSite::CContainerSite(CContainerObj *pHost) :
    m_cRef(0),
    m_pObj(NULL),
    m_pIOleObject(NULL),
    m_pInPlaceObject(NULL),
    m_pViewObject(NULL),
    m_dwEventsCookie(0),
    m_pcpEvents(NULL),
    m_dwAdviseCookie(0),
    m_osMode(OS_PASSIVE),
    m_fWindowless(false),
    m_pHTMLDoc(NULL),
    m_pTIMEElem(NULL),
    m_pPlayer(NULL),
    m_pHost(pHost),
    m_fAutosize(false),
    m_fStarted(false),
    m_fMediaReady(false)
{
    TraceTag((tagContainerSite, "CContainerSite::CContainerSite"));
    Assert(pHost != NULL);
} // CContainerSite

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        destructor
//************************************************************

CContainerSite::~CContainerSite()
{
    TraceTag((tagContainerSite, "CContainerSite::~CContainerSite"));
} // ~CContainerSite

//************************************************************
// Author:          twillie
// Created:         10/08/98
// Abstract:        Init
//************************************************************

HRESULT
CContainerSite::Init(REFCLSID clsid, CTIMEElementBase *pElem)
{
    TraceTag((tagContainerSite, "CContainerSite::Init"));

    IDispatch *pDisp = NULL;
    IConnectionPointContainer *pcpc = NULL;
    HRESULT hr = S_OK;

    Assert(pElem != NULL);
    m_pTIMEElem = pElem;

    // Weak reference.
    IHTMLElement *pHTMLElem = m_pTIMEElem->GetElement();
    
    if (NULL == pHTMLElem)
    {
        TraceTag((tagError, "CContainerSite::Init - unable to get element pointer from time behavior!!!"));
        hr = E_UNEXPECTED;
        goto error_cleanup;
    }

    hr = pHTMLElem->get_document(&pDisp);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to get document pointer from element!!!"));
        goto error_cleanup;
    }

    Assert(pDisp != NULL);
    Assert(m_pHTMLDoc == NULL);
    hr = pDisp->QueryInterface(IID_TO_PPV(IHTMLDocument2, &m_pHTMLDoc));
    ReleaseInterface(pDisp);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to QI for document pointer!!!"));
        goto error_cleanup;
    }

    Assert(m_pHTMLDoc != NULL);

    // Create given a clsid
    hr = CoCreateInstance(clsid,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IUnknown,
                          (void **)&m_pObj);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - Unable to find instance of MSHTML.DLL!!!"));
        goto error_cleanup;
    }

    // before we try anything, see if it supports ITIMEMediaPlayer
    hr = m_pObj->QueryInterface(IID_TO_PPV(ITIMEMediaPlayer, &m_pPlayer));
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to find IID_ITIMEMediaPlayer"));
        goto error_cleanup;
    }

    Assert(m_pPlayer != NULL);

    hr = m_pPlayer->Init();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - Init() failed on ITIMEMediaPlayer"));
        goto error_cleanup;
    }

    // We need an IOleObject most of the time, so get one here.
    hr = m_pObj->QueryInterface(IID_TO_PPV(IOleObject, &m_pIOleObject));
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to find IID_IOleObject"));
        goto error_cleanup;
    }

    Assert(m_pIOleObject != NULL);

    hr = m_pIOleObject->QueryInterface(IID_TO_PPV(IViewObject2, &m_pViewObject));
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to find IID_IViewObject2!!!"));
        goto error_cleanup;
    }

    Assert(m_pViewObject != NULL);

    // SetClientSite is critical for DocObjects
    hr = m_pIOleObject->SetClientSite(SAFECAST(this, IOleClientSite*));
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to IOleObject->SetClientSite() failed!!!"));
        goto error_cleanup;
    }

    m_dwAdviseCookie = 0;
    hr = m_pIOleObject->Advise(SAFECAST(this, IAdviseSink*), &m_dwAdviseCookie);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to IOleObject->Advise() failed!!!"));
        goto error_cleanup;
    }

    Assert(m_dwAdviseCookie != 0);

    // establish ConnectionPoint for Events
    hr = m_pIOleObject->QueryInterface(IID_TO_PPV(IConnectionPointContainer, &pcpc));
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to find IID_IConnectionPointContainer!!!"));
        goto error_cleanup;
    }
    
    Assert(pcpc != NULL);

    hr = pcpc->FindConnectionPoint(DIID_TIMEMediaPlayerEvents, &m_pcpEvents);
    ReleaseInterface(pcpc);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - FindConnectionPoint() failed!!!"));
        goto error_cleanup;
    }

    Assert(m_pcpEvents != NULL);

    hr = m_pcpEvents->Advise((IUnknown *)(IDispatch*)m_pHost, &m_dwEventsCookie);
    if (FAILED(hr))
    {
        ReleaseInterface(m_pcpEvents);
        m_dwEventsCookie = 0;
        TraceTag((tagError, "CContainerSite::Init - Advise() failed on connection point!!!"));
        goto error_cleanup;
    }

    Assert(m_dwEventsCookie != 0);

    // Put the object in the running state
    hr = OleRun(m_pIOleObject);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - OleRun() failed!!!"));
        goto error_cleanup;
    }
    
    m_osMode = OS_RUNNING;
    return S_OK;

error_cleanup:
    Close();
    return hr;
} // Init

//************************************************************
// Author:          pauld
// Created:         3/2/99
// Abstract:        DetachFromHostElement
//************************************************************
HRESULT 
CContainerSite::DetachFromHostElement (void)
{
    TraceTag((tagContainerSite, "CContainerSite::Detach(%lx)", this));

    Close();
    m_pTIMEElem = NULL;
    return S_OK;
} // DetachFromHostElement

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        AddRef
//************************************************************
void CContainerSite::Close()
{
    TraceTag((tagContainerSite, "CContainerSite::Close(%lx)", this));

    // Deactivate InPlace Object (Interface is released as a result of this call)
    if (m_pInPlaceObject != NULL)
    {
        m_pInPlaceObject->InPlaceDeactivate();
        ReleaseInterface(m_pInPlaceObject);
    }

    ReleaseInterface(m_pViewObject);

    // disconnect events
    if ((m_pcpEvents != NULL) && (m_dwEventsCookie != 0))
    {
        m_pcpEvents->Unadvise(m_dwEventsCookie);
        ReleaseInterface(m_pcpEvents);
        m_dwEventsCookie = 0;
    }

    if (m_pIOleObject != NULL)
    {
        m_pIOleObject->Close(OLECLOSE_NOSAVE);

        Assert(m_dwAdviseCookie != 0);

        m_pIOleObject->Unadvise(m_dwAdviseCookie);
        m_pIOleObject->SetClientSite(NULL);
        ReleaseInterface(m_pIOleObject);
    }

    m_osMode = OS_LOADED;

    ReleaseInterface(m_pObj);

    m_osMode = OS_PASSIVE;

    // local book keeping
    m_pTIMEElem = NULL;
    ReleaseInterface(m_pHTMLDoc);
    ReleaseInterface(m_pPlayer);
} // Close

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        Validate call
//************************************************************

bool
CContainerSite::IllegalSiteCall(DWORD dwFlags)
{
    // check ref count
    if (m_cRef == 0)
        return true;
    
    // check object state
    switch (dwFlags)
    {
        case VALIDATE_WINDOWLESSINPLACE:
            if (!m_fWindowless)
            {
                Assert(0 && "Illegal call to windowless interface by ActiveX control (not a hosting bug)");
                return true;
            }
            break;

        case VALIDATE_INPLACE:
            if (m_osMode < OS_INPLACE)
                return true;
            break;

        case VALIDATE_LOADED:
            if (m_osMode < OS_LOADED)
                return true;
            break;
    }

    return false;
} // IllegalSiteCall

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        AddRef
//************************************************************

STDMETHODIMP_(ULONG)
CContainerSite::AddRef(void)
{
    return ++m_cRef;
} // AddRef

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        Release
//************************************************************

STDMETHODIMP_(ULONG)
CContainerSite::Release(void)
{
    if (m_cRef == 0)
    {
        TraceTag((tagError, "CContainerSite::Release - YIKES! Trying to decrement when Ref count is zero!!!"));
        return m_cRef;
    }

    if (0 != --m_cRef)
    {
        return m_cRef;
    }

    delete this;
    return 0;
} // Release

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        QI
//************************************************************

STDMETHODIMP
CContainerSite::QueryInterface(REFIID riid, void **ppv)
{
    if( NULL == ppv )
    {
        Assert(false);
        return E_POINTER;
    }

    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
    {
        // SAFECAST macro doesn't work with IUnknown
        *ppv = this;
    }
    else if (IsEqualIID(riid, IID_IServiceProvider))
    {
        *ppv = SAFECAST(this, IServiceProvider*);
    }
    else if (IsEqualIID(riid, IID_IOleClientSite))
    {
        *ppv = SAFECAST(this, IOleClientSite*);
    }
    else if (IsEqualIID(riid, IID_IAdviseSink) ||
             IsEqualIID(riid, IID_IAdviseSinkEx))
    {
        *ppv = SAFECAST(this, IAdviseSinkEx*);
    }
    else if (IsEqualIID(riid, IID_IOleWindow) ||
             IsEqualIID(riid, IID_IOleInPlaceSite) ||
             IsEqualIID(riid, IID_IOleInPlaceSiteEx) ||
             IsEqualIID(riid, IID_IOleInPlaceSiteWindowless))
    {
        *ppv = SAFECAST(this, IOleInPlaceSiteWindowless*);
    }
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
    {
        *ppv = SAFECAST(this, IOleCommandTarget*);
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppv = SAFECAST(this, IDispatch*);
    }
    else if (IsEqualIID(riid, IID_IOleControlSite))
    {
        *ppv = SAFECAST(this, IOleControlSite*);
    }
    else if (IsEqualIID(riid, IID_IOleInPlaceUIWindow) || 
             IsEqualIID(riid, IID_IOleInPlaceFrame))
    {
        *ppv = SAFECAST(this, IOleInPlaceFrame*);
    }

    if (NULL != *ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
} // QueryInterface

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        IService Provider method
//************************************************************

STDMETHODIMP
CContainerSite::QueryService(REFGUID sid, REFIID riid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    IServiceProvider *psp = NULL;

    if( NULL == ppv )
    {
        Assert( false );
        return E_POINTER;
    }

    *ppv = NULL;

    // check to see if this is something we support locally
    // in the container.
    if (IsEqualGUID(sid, IID_IUnknown))
    {
        // SAFECAST macro doesn't work with IUnknown
        *ppv = this;
        ((IUnknown*)*ppv)->AddRef();
        hr = S_OK;
        goto done;
    }

   
    // Fall back to TIME Element if we still have one.

    // We have the supporting Service Provider cached (at init() time) for 
    // the behavior over in CBaseBvr which CTIMEElementBase inherits from.
    Assert(m_pTIMEElem != NULL);
    if (m_pTIMEElem != NULL)
    {
        psp = m_pTIMEElem->GetServiceProvider();
        if (psp != NULL)
        {
            hr = psp->QueryService(sid, riid, ppv);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CContainerSite::QueryService - query failed!!! [%08X]", hr));
            }
        }
    }
    else
    {
        hr = E_UNEXPECTED;
        goto done;
    }

done:
    return hr;
} // QueryService

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:
//************************************************************
HRESULT
CContainerSite::begin()
{
    HRESULT hr;

    // always call end before begin.
    // NOTE: we don't care about the return.
    if (GetMediaReadyFlag() == true)
        m_pPlayer->end();

    if (!m_fStarted)
    {
        RECT rc;
        HWND hWnd;

        // Lets get it InPlace Activated before we say begin
        Assert(m_pTIMEElem != NULL);
        if (m_pTIMEElem != NULL)
        {
            hr = m_pTIMEElem->GetSize(&rc);
            if (FAILED(hr))
            {
                TraceTag((tagError, "CContainerSite::begin - GetSize() failed!!!"));
                goto done;
            }
        }
        else
        {
            hr = E_UNEXPECTED;
            goto done;
        }
    
        hr = GetWindow(&hWnd);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CContainerSite::begin - GetWindow() failed!!!"));
            goto done;
        }

        // if the width or height of the element is zero, allow the control
        // to renegotiate for size.
        if ( ((rc.right - rc.left) == 0) ||
             ((rc.bottom - rc.top) == 0) )
        {
            m_fAutosize = true;
        } else if( m_pTIMEElem->IsDocumentInEditMode())
        {
            DAComPtr<IHTMLStyle> s;
            VARIANT styleWidth, styleHeight;
            VariantInit(&styleWidth);
            VariantInit(&styleHeight);

            if (m_pTIMEElem->GetElement())
            {
                if(SUCCEEDED(THR(m_pTIMEElem->GetElement()->get_style(&s))))
                {
                    if(SUCCEEDED(s -> get_width( &styleWidth))
                        && SUCCEEDED(s -> get_height( &styleHeight)))
                    {
                        if(styleWidth.vt == VT_BSTR && styleWidth.bstrVal == NULL
                           && styleHeight.vt == VT_BSTR && styleHeight.bstrVal == NULL)
                            m_fAutosize = true;
                    }
                }
            }
            VariantClear(&styleWidth);
            VariantClear(&styleHeight);
        }

        Assert(m_pIOleObject != NULL);
        TraceTag((tagContainerSite, "CContainerSite::begin - InPlaceActivate [hwnd=%08X, rect=(%d, %d, %d, %d)]", hWnd, rc.left, rc.top, rc.right, rc.bottom));
        hr = m_pIOleObject->DoVerb(OLEIVERB_INPLACEACTIVATE,
                                   NULL, 
                                   SAFECAST(this, IOleClientSite*), 
                                   0, 
                                   hWnd, 
                                   &rc);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CContainerSite::begin - DoVerb() failed!!! [%08X]", hr));
            goto done;
        }
    }

    Assert(m_pPlayer != NULL);

    hr = m_pPlayer->begin();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::begin - begin() failed on ITIMEMediaPlayer!!! [%08X]", hr));
        goto done;
    }
    
    m_fStarted = true;
done:
    return hr;
}

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:
//************************************************************
HRESULT
CContainerSite::end()
{
    HRESULT hr;

    m_fStarted = false;
    if (GetMediaReadyFlag() != true)
    {
        hr = S_OK;
        goto done;
    }

    if (m_pInPlaceObject == NULL)
    {
        hr = S_OK;
        goto done;
    }
    hr = m_pInPlaceObject->InPlaceDeactivate();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::end - InPlaceDeactivate() failed!!! [%08X]", hr));
        goto done;
    }

    hr =  m_pPlayer->end();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::end - end() failed on ITIMEMediaPlayer!!! [%08X]", hr));
        goto done;
    }

done:
    return hr;
}

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:
//************************************************************
HRESULT
CContainerSite::pause()
{
    return m_pPlayer->pause();
}

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:
//************************************************************
HRESULT
CContainerSite::resume()
{
    return m_pPlayer->resume();
}

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Abstract:        Requests that the container call OleSave 
//                  for the object that lives here.  Typically
//                  this happens on server shutdown.
//************************************************************

HRESULT
CContainerSite::draw(HDC hdc, RECT *prc)
{
    if (prc == NULL)
        TraceTag((tagContainerSite, "CContainerSite::draw(%08X, NULL)", hdc));
    else
        TraceTag((tagContainerSite, "CContainerSite::draw(%08X, (%d, %d, %d, %d))", hdc, prc->left, prc->top, prc->right, prc->bottom));

    Assert(m_pViewObject != NULL);
    
    // repack rect into RECTL.
    RECTL  rcl;
    RECTL *prcl;
    
    if (prc == NULL)
    {
        prcl = NULL;
    }
    else
    {
        rcl.left = prc->left;
        rcl.top = prc->top;
        rcl.right = prc->right;
        rcl.bottom = prc->bottom;
        prcl = &rcl;
    }

    return m_pViewObject->Draw(DVASPECT_CONTENT,
                               0,
                               NULL,
                               NULL,
                               NULL,
                               hdc,
                               prcl,
                               NULL,
                               NULL,
                               0);
} // render

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        SaveObject, IOleClientSite 
// Abstract:        Requests that the container call OleSave 
//                  for the object that lives here.  Typically
//                  this happens on server shutdown.
//************************************************************

HRESULT
CContainerSite::SaveObject(void)
{
    TraceTag((tagContainerSite, "CContainerSite::SaveObject"));

    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;

    RRETURN(E_NOTIMPL);
} // SaveObject

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetMoniker, IOleClientSite 
// Abstract:        
//************************************************************

HRESULT
CContainerSite::GetMoniker(DWORD dwAssign, DWORD dwWhich, IMoniker **ppmk)
{
    TraceTag((tagContainerSite, "CContainerSite::GetMoniker"));
    return E_NOTIMPL;
} // GetMoniker

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetContainer, IOleClientSite 
// Abstract:        
//************************************************************

HRESULT
CContainerSite::GetContainer(IOleContainer **ppContainer)
{
    TraceTag((tagContainerSite, "CContainerSite::GetContainer"));

    *ppContainer = NULL;
    return E_NOINTERFACE;
} // GetContainer

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        RequestNewObjectLayout, IOleClientSite 
// Abstract:        
//************************************************************

HRESULT
CContainerSite::RequestNewObjectLayout(void)
{
    TraceTag((tagContainerSite, "CContainerSite::RequestNewObjectLayout"));

    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;

    return E_NOTIMPL;
} // RequestNewObjectLayout

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnShowWindow, IOleClientSite 
// Abstract:        
//************************************************************

HRESULT
CContainerSite::OnShowWindow(BOOL fShow)
{
    TraceTag((tagContainerSite, "CContainerSite::OnShowWindow"));

    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;

    return S_OK;
} // OnShowWindow

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        ShowObject, IOleClientSite 
// Abstract:        
//************************************************************

HRESULT
CContainerSite::ShowObject(void)
{
    TraceTag((tagContainerSite, "CContainerSite::ShowObject"));
    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;

    return S_OK;
} // ShowObject

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        OnControlInfoChanged, IOleControlSite 
// Abstract:        
//************************************************************

HRESULT
CContainerSite::OnControlInfoChanged(void)
{
    TraceTag((tagContainerSite, "CContainerSite::OnControlInfoChanged"));
    return S_OK;
} // OnControlInfoChanged

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        LockInPlaceActive, IOleControlSite 
// Abstract:        
//************************************************************

HRESULT
CContainerSite::LockInPlaceActive(BOOL fLock)
{
    TraceTag((tagContainerSite, "CContainerSite::LockInPlaceActive"));
    if (IllegalSiteCall(VALIDATE_INPLACE))
        return E_UNEXPECTED;
    return S_OK;
} // LockInPlaceActive

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        GetExtendedControl, IOleControlSite 
// Abstract:        
//************************************************************

HRESULT
CContainerSite::GetExtendedControl(IDispatch **ppDisp)
{
    TraceTag((tagContainerSite, "CContainerSite::GetExtendedControl"));
    
    return m_pHost->QueryInterface(IID_TO_PPV(IDispatch, ppDisp));
} // TransformCoords

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        TransformCoords, IOleControlSite 
// Abstract:        
//************************************************************

HRESULT
CContainerSite::TransformCoords(POINTL *pPtlHiMetric,
                       POINTF *pPtfContainer,
                       DWORD   dwFlags)
{
    TraceTag((tagContainerSite, "CContainerSite::TransformCoords"));
    return E_NOTIMPL;
} // TransformCoords

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        TranslateAccelerator, IOleControlSite 
// Abstract:        
//************************************************************

HRESULT
CContainerSite::TranslateAccelerator(MSG *pmsg, DWORD grfModifiers)
{
    TraceTag((tagContainerSite, "CContainerSite::TranslateAccelerator"));
    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;
    return S_FALSE;
} // TranslateAccelerator

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        OnFocus, IOleControlSite 
// Abstract:        
//************************************************************

HRESULT
CContainerSite::OnFocus(BOOL fGotFocus)
{
    TraceTag((tagContainerSite, "CContainerSite::OnFocus"));
    return S_OK;
} // OnFocus

//************************************************************
// Author:          twillie
// Created:         05/04/98
// Function:        ShowPropertyFrame, IOleControlSite 
// Abstract:        
//************************************************************

HRESULT
CContainerSite::ShowPropertyFrame(void)
{
    TraceTag((tagContainerSite, "CContainerSite::ShowPropertyFrame"));
    return S_OK;
} // ShowPropertyFrame

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetWindow, IOleWindow 
// Abstract:        Retrieves the handle of the window 
//                  associated with the object on which this 
//                  interface is implemented.
//************************************************************

HRESULT
CContainerSite::GetWindow(HWND *phWnd)
{
    TraceTag((tagContainerSite, "CContainerSite::GetWindow"));

    if (phWnd == NULL)
    {
        TraceTag((tagError, "CContainerSite::GetWindow - invalid arg"));
        return E_POINTER;
    }
        
    Assert(m_pHTMLDoc != NULL);

    IOleWindow *pow = NULL;
    HRESULT hr = m_pHTMLDoc->QueryInterface(IID_TO_PPV(IOleWindow, &pow));
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::GetWindow - unable to QI for IOleWindow on hosting Document"));
        return hr;
    }

    Assert(pow != NULL);

    hr = pow->GetWindow(phWnd);
    Assert(*phWnd != NULL);
    ReleaseInterface(pow);
    return hr;
} // GetWindow

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        ContextSensitiveHelp, IOleWindow 
// Abstract:        Instructs the object on which this 
//                  interface is implemented to enter or leave 
//                  a context-sensitive help mode.
//************************************************************

HRESULT
CContainerSite::ContextSensitiveHelp(BOOL fEnterMode)
{
    TraceTag((tagContainerSite, "CContainerSite::ContextSensitiveHelp"));

    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;
    
    // BUGBUG - reach back to document and forward on call to it's InplaceSite!
    return NOERROR;
} // ContextSensitiveHelp

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        CanInPlaceActivate, IOleInPlaceSite
// Abstract:        Answers the server whether or not we can 
//                  currently in-place activate its object.  
//                  By implementing this interface we say
//                  that we support in-place activation, but 
//                  through this function we indicate whether 
//                  the object can currently be activated
//                  in-place.  Iconic aspects, for example, 
//                  cannot, meaning we return S_FALSE.
//************************************************************

HRESULT
CContainerSite::CanInPlaceActivate(void)
{    
    TraceTag((tagContainerSite, "CContainerSite::CanInPlaceActivate"));
    return S_OK;
} // CanInPlaceActivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnInPlaceActivate, IOleInPlaceSite
// Abstract:        Informs the container that an object is 
//                  being activated in-place such that the 
//                  container can prepare appropriately.  The
//                  container does not, however, make any user 
//                  interface changes at this point.
//                  See OnUIActivate.
//************************************************************

HRESULT
CContainerSite::OnInPlaceActivate(void)
{
    TraceTag((tagContainerSite, "CContainerSite::OnInPlaceActivate"));
    return OnInPlaceActivateEx(NULL, 0);
} // OnInPlaceActivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnInPlaceDeactivate, IOleInPlaceSite
// Abstract:        Notifies the container that the object has 
//                  deactivated itself from an in-place state.  
//                  Opposite of OnInPlaceActivate.  The 
//                  container does not change any UI at this 
//                  point.
//************************************************************

HRESULT
CContainerSite::OnInPlaceDeactivate(void)
{
    TraceTag((tagContainerSite, "CContainerSite::OnInPlaceDeactivate"));

    if (m_osMode == OS_UIACTIVE)
        OnUIDeactivate(false);
    
    Assert(m_pInPlaceObject != NULL);
    ReleaseInterface(m_pInPlaceObject);

    m_fWindowless = false;
    m_osMode = OS_RUNNING;

    return S_OK;
} // OnInPlaceDeactivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnUIActivate, IOleInPlaceSite
// Abstract:        Informs the container that the object is 
//                  going to start munging around with user 
//                  interface, like replacing the menu.  The
//                  container should remove any relevant UI in 
//                  preparation.
//************************************************************

HRESULT
CContainerSite::OnUIActivate(void)
{
    TraceTag((tagContainerSite, "CContainerSite::OnUIActivate"));
    if (IllegalSiteCall(VALIDATE_LOADED) ||
        (m_osMode < OS_RUNNING))
    {
        TraceTag((tagError, "Object is not inplace yet!!!"));
        return E_UNEXPECTED;
    }

    m_osMode = OS_UIACTIVE;
    return S_OK;
} // OnUIActivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnUIDeactivate, IOleInPlaceSite
// Abstract:        Informs the container that the object is 
//                  deactivating its in-place user interface 
//                  at which time the container may reinstate 
//                  its own.  Opposite of OnUIActivate.
//************************************************************

HRESULT
CContainerSite::OnUIDeactivate(BOOL fUndoable)
{
    TraceTag((tagContainerSite, "CContainerSite::OnUIDeactivate"));
    if (IllegalSiteCall(VALIDATE_INPLACE))
        return E_UNEXPECTED;
    
    m_osMode = OS_INPLACE;
    return S_OK;
} // OnUIDeactivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        DeactivateAndUndo, IOleInPlaceSite
// Abstract:        If immediately after activation the object 
//                  does an Undo, the action being undone is 
//                  the activation itself, and this call
//                  informs the container that this is, in 
//                  fact, what happened.
//************************************************************

HRESULT
CContainerSite::DeactivateAndUndo(void)
{
    TraceTag((tagContainerSite, "CContainerSite::DeactivateAndUndo"));
    if (IllegalSiteCall(VALIDATE_INPLACE))
        return E_UNEXPECTED;
    return E_NOTIMPL;
} // DeactivateAndUndo

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        DiscardUndoState, IOleInPlaceSite
// Abstract:        Informs the container that something 
//                  happened in the object that means the 
//                  container should discard any undo 
//                  information it currently maintains for the 
//                  object.
//************************************************************

HRESULT
CContainerSite::DiscardUndoState(void)
{
    TraceTag((tagContainerSite, "CContainerSite::DiscardUndoState"));
    if (IllegalSiteCall(VALIDATE_INPLACE))
        return E_UNEXPECTED;
    return S_OK;
} // DiscardUndoState

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetWindowContext, IOleInPlaceSite
// Abstract:        Provides an in-place object with pointers 
//                  to the frame and document level in-place 
//                  interfaces (IOleInPlaceFrame and 
//                  IOleInPlaceUIWindow) such that the object 
//                  can do border negotiation and so forth.  
//                  Also requests the position and clipping 
//                  rectangles of the object in the container 
//                  and a pointer to an OLEINPLACEFRAME info 
//                  structure which contains accelerator 
//                  information.
//
//                  NOTE: that the two interfaces this call 
//                  returns are not available through 
//                  QueryInterface on IOleInPlaceSite since 
//                  they live with the frame and document, but 
//                  not the site.
//************************************************************

HRESULT
CContainerSite::GetWindowContext(IOleInPlaceFrame    **ppFrame,
                                 IOleInPlaceUIWindow **ppUIWindow, 
                                 RECT                 *prcPos, 
                                 RECT                 *prcClip, 
                                 OLEINPLACEFRAMEINFO  *pFI)
{
    TraceTag((tagContainerSite, "CContainerSite::GetWindowContext"));
    HRESULT hr;

    if ( (ppFrame == NULL) ||
         (ppUIWindow == NULL) ||
         (prcPos == NULL) ||
         (prcClip == NULL) ||
         (pFI == NULL) )
    {
        TraceTag((tagError, "CContainerSite::GetWindowContext - invalid arg"));
        return E_POINTER;
    }

    *ppFrame = NULL;
    *ppUIWindow = NULL;
    SetRectEmpty(prcPos);
    SetRectEmpty(prcClip);
    memset(pFI, 0, sizeof(OLEINPLACEFRAMEINFO));

    if (IllegalSiteCall(VALIDATE_LOADED))
    {
        Assert(0 && "Unexpected call to client site.");
        hr = E_UNEXPECTED;
        goto done;
    }
    
    // return pointers to ourselves
    // NOTE: these are stubbed out
    hr = THR(this->QueryInterface(IID_IOleInPlaceFrame, (void**)ppFrame));
    if (FAILED(hr))
        goto done;

    hr = THR(this->QueryInterface(IID_IOleInPlaceUIWindow, (void**)ppUIWindow));
    if (FAILED(hr))
        goto done;

    // get position rect
    Assert(m_pTIMEElem != NULL);
    if (m_pTIMEElem != NULL)
    {
        hr = m_pTIMEElem->GetSize(prcPos);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CContainerSite::GetWindowContext - GetSize() failed"));
            goto done;
        }
    }
    else
    {
        hr = E_UNEXPECTED;
        goto done;
    }
    
    // Note that Clip and Pos are the same.
    // BUGBUG - Need to provide correct clipping rect.
    ::CopyRect(prcClip, prcPos);

    hr = S_OK;

done:
    return hr;
} // GetWindowContext

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        Scroll, IOleInPlaceSite
// Abstract:        Asks the container to scroll the document, 
//                  and thus the object, by the given amounts 
//                  in the sz parameter.
//************************************************************

HRESULT
CContainerSite::Scroll(SIZE sz)
{
    // Not needed for DocObjects
    TraceTag((tagContainerSite, "CContainerSite::Scroll"));
    if (IllegalSiteCall(VALIDATE_INPLACE))
        return E_UNEXPECTED;
    return E_NOTIMPL;
} // Scroll

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnPosRectChange, IOleInPlaceSite
// Abstract:        Informs the container that the in-place 
//                  object was resized.  This does not change 
//                  the site's rectangle in any case.
//************************************************************

HRESULT
CContainerSite::OnPosRectChange(const RECT *prcPos)
{
    if (prcPos == NULL)
        TraceTag((tagContainerSite, "CContainerSite::OnPosRectChange(NULL)"));
    else
        TraceTag((tagContainerSite, "CContainerSite::OnPosRectChange((%d, %d, %d, %d))", prcPos->left, prcPos->top, prcPos->right, prcPos->bottom));
    
    HRESULT hr;
    IHTMLStyle *pStyle = NULL;

    Assert(m_pTIMEElem != NULL);
    if (m_pTIMEElem == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    if (prcPos == NULL)
    {
        TraceTag((tagError, "CContainerSite::OnPosRectChange - invalidarg"));
        hr = E_POINTER;
        goto done;
    }

    if (IllegalSiteCall(VALIDATE_INPLACE))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    if (!m_fAutosize)
    {
        // clamp the bouinding rect if we have width/height defined
        RECT rc;

        hr = m_pTIMEElem->GetSize(&rc);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CContainerSite::OnPosRectChange - GetSize() failed"));
            goto done;
        }

        // BUGBUG - need to provide correct clipping rect
        hr = m_pInPlaceObject->SetObjectRects(&rc, &rc);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CContainerSite::OnPosRectChange - SetObjectRects() failed [AutoSize]"));
            goto done;
        }

        // exit.
        goto done;
    }

    hr = m_pTIMEElem->SetSize(prcPos);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::OnPosRectChange - SetSize() failed"));
        goto done;
    }

    // notify object that change has occured.
    // Note: that I assume the clipping rect to be the same as the pos rect.
    hr = m_pInPlaceObject->SetObjectRects(prcPos, prcPos);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::OnPosRectChange - SetObjectRects() failed"));
        goto done;
    }
done:
    ReleaseInterface(pStyle);
    return hr;
} // OnPosRectChange

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnInPlaceActivateEx, IOleInPlaceSiteEx
// Abstract:        
//************************************************************

HRESULT
CContainerSite::OnInPlaceActivateEx(BOOL *pfNoRedraw, DWORD dwFlags)
{
    HRESULT hr;

    TraceTag((tagContainerSite, "CContainerSite::OnInPlaceActivateEx"));

    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;

    Assert(m_pInPlaceObject == NULL);

    // Make Sure we are Windowless
    if (dwFlags == ACTIVATE_WINDOWLESS)
    {
        hr = m_pObj->QueryInterface(IID_IOleInPlaceObjectWindowless, (void**)&m_pInPlaceObject);
        if (FAILED(hr))
        {
            TraceTag((tagError, "QI failed for windowless interface"));
            return hr;
        }
        m_fWindowless = true;
    }
    else
    {
        hr = m_pObj->QueryInterface(IID_IOleInPlaceObject, (void**)&m_pInPlaceObject);
        if (FAILED(hr))
        {
            TraceTag((tagError, "QI failed for windowless interface"));
            return hr;
        }
    }

    if (pfNoRedraw != NULL)
        *pfNoRedraw = m_fWindowless ? true : false;

    m_osMode = OS_INPLACE;

    return S_OK;
} // OnInPlaceActivateEx

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnInPlaceDeactivateEx, IOleInPlaceSiteEx
// Abstract:        
//************************************************************

HRESULT
CContainerSite::OnInPlaceDeactivateEx(BOOL fNoRedraw)
{
    TraceTag((tagContainerSite, "CContainerSite::OnInPlaceDeactivateEx"));
    
    // BUGBUG - may need to Invalidate if fNoRedraw is false and we are windowed...
    
    return OnInPlaceDeactivate();
} // OnInPlaceDeactivateEx

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        RequestUIActivate, IOleInPlaceSiteEx
// Abstract:        
//************************************************************

HRESULT
CContainerSite::RequestUIActivate(void)
{
    TraceTag((tagContainerSite, "CContainerSite::RequestUIActivate"));

    if (IllegalSiteCall(VALIDATE_LOADED))
        return E_UNEXPECTED;

    return S_OK;
} // RequestUIActivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        CanWindowlessActivate, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

HRESULT
CContainerSite::CanWindowlessActivate(void)
{
    TraceTag((tagContainerSite, "CContainerSite::CanWindowlessActivate"));
    return S_OK;
} // CanWindowlessActivate

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetCapture, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

HRESULT
CContainerSite::GetCapture(void)
{
    TraceTag((tagContainerSite, "CContainerSite::GetCapture"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    return E_NOTIMPL;
} // GetCapture

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        SetCapture, IOleInPlaceSiteWindowless
// Abstract:        Enables an in-place active, windowless 
//                  object to capture all mouse messages.
//                  If TRUE, the container should capture the 
//                  mouse for the object. If FALSE, the container 
//                  should release mouse capture for the object. 
//************************************************************

HRESULT
CContainerSite::SetCapture(BOOL fCapture)
{
    TraceTag((tagContainerSite, "CContainerSite::SetCapture"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    return E_NOTIMPL;
} // SetCapture

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetFocus, IOleInPlaceSiteWindowless
// Abstract:        Called by an in-place active, windowless 
//                  object to determine if it still has the 
//                  keyboard focus or not.
//************************************************************

HRESULT
CContainerSite::GetFocus(void)
{
    TraceTag((tagContainerSite, "CContainerSite::GetFocus"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    return S_FALSE;
} // GetFocus

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        SetFocus, IOleInPlaceSiteWindowless
// Abstract:        Sets the keyboard focus for a UI-active, 
//                  windowless object.  If TRUE, sets the 
//                  keyboard focus to the calling object. If FALSE, 
//                  removes the keyboard focus from the calling object, 
//                  provided that the object has the focus.
//************************************************************

HRESULT
CContainerSite::SetFocus(BOOL fFocus)
{
    TraceTag((tagContainerSite, "CContainerSite::SetFocus"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    return E_NOTIMPL;
 } // SetFocus

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetDC, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

HRESULT
CContainerSite::GetDC(const RECT *prc, DWORD dwFlags, HDC *phDC)
{
    TraceTag((tagContainerSite, "CContainerSite::GetDC"));
    HRESULT hr;
    HWND hWnd;

    if (phDC == NULL)
    {
        TraceTag((tagError, "CContainerSite::GetDC - invalid arg"));
        hr = E_POINTER;
        goto done;
    }

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = GetWindow(&hWnd);
    if (FAILED(hr) || (hWnd == NULL))
    {
        // BUGBUG: at some point in the future, we may need to support
        //         Documents which are windowless...
        TraceTag((tagError, "CContainerSite::GetDC - GetWindow() failed"));
        hr = E_FAIL;
        goto done;
    }

    *phDC = ::GetDC(hWnd);
    if (*phDC == NULL)
    {
        TraceTag((tagError, "CContainerSite::GetDC - Win32 GetDC returned NULL!"));
        hr = E_FAIL;
    }
    else
    {
        hr = S_OK;
    }

done:
    return hr;
} // GetDC

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        ReleaseDC, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

HRESULT
CContainerSite::ReleaseDC(HDC hDC)
{
    TraceTag((tagContainerSite, "CContainerSite::ReleaseDC"));

    HRESULT hr;
    HWND    hWnd;

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    hr = GetWindow(&hWnd);
    Assert(SUCCEEDED(hr) && (hWnd != NULL));
    
    Assert(hDC != NULL);

    ::ReleaseDC(hWnd, hDC);

    return S_OK;
} // ReleaseDC

//*******************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        InvalidateRect, IOleInPlaceSiteWindowless
// Abstract:
//*******************************************************************

HRESULT
CContainerSite::InvalidateRect(const RECT *prc, BOOL fErase)
{
    if (prc == NULL)
        TraceTag((tagContainerSite, "CContainerSite::InvalidateRect(NULL)"));
    else
        TraceTag((tagContainerSite, "CContainerSite::InvalidateRect(%d, %d, %d, %d)", prc->left, prc->top, prc->right, prc->bottom));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    // reach back to the time element and invalidate
    Assert(m_pHost != NULL);
    return m_pHost->Invalidate(prc);
} // InvalidateRect

//*******************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        InvalidateRgn, IOleInPlaceSiteWindowless
// Abstract:
//*******************************************************************

HRESULT
CContainerSite::InvalidateRgn(HRGN hRGN, BOOL fErase)
{
    TraceTag((tagContainerSite, "CContainerSite::InvalidateRgn"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    HRESULT hr = S_OK;
    return hr;
} // InvalidateRgn

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        ScrollRect, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

HRESULT
CContainerSite::ScrollRect(INT dx, INT dy, const RECT *prcScroll, const RECT *prcClip)
{
    // Not needed for DocObjects
    TraceTag((tagContainerSite, "CContainerSite::ScrollRect"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    return E_NOTIMPL;
} // ScrollRect

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        AdjustRect, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

HRESULT
CContainerSite::AdjustRect(RECT *prc)
{
    // Not needed for DocObjects
    TraceTag((tagContainerSite, "CContainerSite::AdjustRect"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    return E_NOTIMPL;
} // AdjustRect

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnDefWindowMessage, IOleInPlaceSiteWindowless
// Abstract:        
//************************************************************

HRESULT
CContainerSite::OnDefWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    TraceTag((tagContainerSite, "CContainerSite::OnDefWindowMessage"));

    if (IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        return E_UNEXPECTED;

    // Return that the message was not handled.
    // BUGBUG:  eventually, this might need to be bubbled out.

    // release focus for the document.
// BUGBUG: we don't handle focus right now
//    if (msg == WM_KILLFOCUS)
//        return SetFocus(false);

    switch (msg)
    {
// BUGBUG: we don't handle focus right now
//        case WM_SETFOCUS:
//            return SetFocus(true);
//        case WM_KILLFOCUS:
//            return SetFocus(false);

        case WM_MOUSEMOVE:
        case WM_KEYDOWN:
        case WM_KEYUP:
        case WM_CHAR:
        case WM_DEADCHAR:
        case WM_SYSKEYUP:
        case WM_SYSCHAR:
        case WM_SYSDEADCHAR:
        case WM_LBUTTONDOWN:
        case WM_MBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_LBUTTONUP:
        case WM_MBUTTONUP:
        case WM_RBUTTONUP:
        case WM_LBUTTONDBLCLK:
        case WM_MBUTTONDBLCLK:
        case WM_RBUTTONDBLCLK:
            return S_OK;

        case WM_SETCURSOR:
        case WM_CONTEXTMENU:
        case WM_HELP:
            return S_FALSE;

        case WM_MOUSEHOVER:
        case WM_MOUSELEAVE:
        case 0x8004: //  WM_MOUSEOVER
            return S_OK;

        case WM_CAPTURECHANGED:
            return S_OK;
    }

    return S_FALSE;
} // OnDefWindowMessage

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnDataChange, IAdviseSink
// Abstract:        
//************************************************************

void
CContainerSite::OnDataChange(FORMATETC *pFEIn, STGMEDIUM *pSTM)
{
    TraceTag((tagContainerSite, "CContainerSite::OnDataChange"));
} // OnDataChange

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnViewChange, IAdviseSink
// Abstract:        
//************************************************************

void 
CContainerSite::OnViewChange(DWORD dwAspect, LONG lindex)
{    
    TraceTag((tagContainerSite, "CContainerSite::OnViewChange"));
} // OnViewChange

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnRename, IAdviseSink
// Abstract:        
//************************************************************

void 
CContainerSite::OnRename(IMoniker *pmk)
{
    TraceTag((tagContainerSite, "CContainerSite::OnRename"));
} // OnRename

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnSave, IAdviseSink
// Abstract:        
//************************************************************

void 
CContainerSite::OnSave(void)
{
    TraceTag((tagContainerSite, "CContainerSite::OnSave"));
} // OnSave

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnClose, IAdviseSink
// Abstract:        
//************************************************************

void 
CContainerSite::OnClose(void)
{
    TraceTag((tagContainerSite, "CContainerSite::OnClose"));
} // OnClose

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        OnViewStatusChange, IAdviseSink
// Abstract:        
//************************************************************

void 
CContainerSite::OnViewStatusChange(DWORD dwViewStatus)
{
    TraceTag((tagContainerSite, "CContainerSite::OnViewStatusChange"));
} // OnViewStatusChange

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetTypeInfoCount, IDispatch
// Abstract:        Returns the number of tyep information 
//                  (ITypeInfo) interfaces that the object 
//                  provides (0 or 1).
//************************************************************

HRESULT
CContainerSite::GetTypeInfoCount(UINT *pctInfo) 
{
    TraceTag((tagContainerSite, "CContainerSite::GetTypeInfoCount"));
    return E_NOTIMPL;
} // GetTypeInfoCount

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetTypeInfo, IDispatch
// Abstract:        Retrieves type information for the 
//                  automation interface. 
//************************************************************

HRESULT
CContainerSite::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptInfo) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::GetTypeInfo"));
    return E_NOTIMPL;
} // GetTypeInfo

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        GetIDsOfNames, IDispatch
// Abstract:        constructor
//************************************************************

HRESULT
CContainerSite::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID)
{
    TraceTag((tagContainerSite, "CContainerSite::GetIDsOfNames"));
    return E_NOTIMPL;
} // GetIDsOfNames

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        Invoke, IDispatch
// Abstract:        get entry point given ID
//************************************************************

HRESULT
CContainerSite::Invoke(DISPID dispIDMember, REFIID riid, LCID lcid, unsigned short wFlags, 
              DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr) 
{

#ifdef DEBUG
    // Here the key to wFlags:
    //
    // #define DISPATCH_METHOD         0x1
    // #define DISPATCH_PROPERTYGET    0x2
    // #define DISPATCH_PROPERTYPUT    0x4
    // #define DISPATCH_PROPERTYPUTREF 0x8

    switch (dispIDMember)
    {
        case DISPID_AMBIENT_USERMODE:
            TraceTag((tagContainerSite, "CContainerSite::Invoke(DISPID_AMBIENT_USERMODE, %04X)", wFlags));
            break;

        default:
            TraceTag((tagContainerSite, "CContainerSite::Invoke(%08X, %04X)", dispIDMember, wFlags));
            break;
    }
#endif

    return E_NOTIMPL;
} // Invoke

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        QueryStatus, IOleCommandTarget
// Abstract:        
//************************************************************

HRESULT
CContainerSite::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{ 
    TraceTag((tagContainerSite, "CContainerSite::QueryStatus"));
    return E_NOTIMPL;
} // QueryStatus

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        Exec, IOleCommandTarget
// Abstract:        
//************************************************************

HRESULT
CContainerSite::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{ 
    TraceTag((tagContainerSite, "CContainerSite::Exec"));
    return E_NOTIMPL;
} // Exec
//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        GetBorder, IOleUIWindow
// Abstract:        Returns the rectangle in which the 
//                  container is willing to negotiate about an 
//                  object's adornments. 
//************************************************************

HRESULT
CContainerSite::GetBorder(LPRECT prcBorder)
{ 
    TraceTag((tagContainerSite, "CContainerSite::GetBorder"));
    return NOERROR; 
} // GetBorder

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        RequestBorderSpace, IOleUIWindow
// Abstract:        Asks the container if it can surrender the
//                  amount of space in pBW that the object 
//                  would like for it's adornments.  The 
//                  container does nothing but validate the 
//                  spaces on this call. 
//************************************************************

HRESULT
CContainerSite::RequestBorderSpace(LPCBORDERWIDTHS pBW)
{ 
    TraceTag((tagContainerSite, "CContainerSite::RequestBorderSpace"));
    return NOERROR; 
} // RequestBorderSpace

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        SetBorderSpace, IOleUIWindow
// Abstract:        Called when the object now officially 
//                  requests that the container surrender 
//                  border space it previously allowed in 
//                  RequestBorderSpace.  The container should 
//                  resize windows appropriately to surrender 
//                  this space. 
//************************************************************

HRESULT
CContainerSite::SetBorderSpace(LPCBORDERWIDTHS pBW) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::SetBorderSpace"));
    return NOERROR; 
} // SetBorderSpace

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        SetActiveObject, IOleUIWindow
// Abstract:        Provides the container with the object's 
//                  IOleInPlaceActiveObject pointer and a name 
//                  of the object to show in the container's 
//                  caption. 
//************************************************************

HRESULT
CContainerSite::SetActiveObject(LPOLEINPLACEACTIVEOBJECT pIIPActiveObj, LPCOLESTR pszObj) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::SetActiveObject(%08X, %08X)", pIIPActiveObj, pszObj));
    return S_OK; 
} // SetActiveObject

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        InsertMenus, IOleInPlaceFrame
// Abstract:        Instructs the container to place its 
//                  in-place menu items where necessary in the 
//                  given menu and to fill in elements 0, 2, 
//                  and 4 of the OLEMENUGROUPWIDTHS array to 
//                  indicate how many top-level items are in 
//                  each group. 
//************************************************************

HRESULT
CContainerSite::InsertMenus(HMENU hMenu, LPOLEMENUGROUPWIDTHS pMGW) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::InsertMenus"));
    return NOERROR; 
} // InsertMenus

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        SetMenu, IOleInPlaceFrame
// Abstract:        Instructs the container to replace 
//                  whatever menu it's currently using with 
//                  the given menu and to call 
//                  OleSetMenuDescritor so OLE knows to whom 
//                  to dispatch messages. 
//************************************************************

HRESULT
CContainerSite::SetMenu(HMENU hMenu, HOLEMENU hOLEMenu, HWND hWndObj) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::SetMenu"));
    return NOERROR; 
} // SetMenu

//************************************************************
// Author:          twillie
// Created:         01/20/98
// Function:        RemoveMenus, IOleInPlaceFrame
// Abstract:        Asks the container to remove any menus it 
//                  put into hMenu in InsertMenus.
//************************************************************

HRESULT
CContainerSite::RemoveMenus(HMENU hMenu) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::RemoveMenus"));
    return NOERROR; 
} // RemoveMenus

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        SetStatusText, IOleInPlaceFrame
// Abstract:        Asks the container to place some text in a 
//                  status line, if one exists.  If the 
//                  container does not have a status line it 
//                  should return E_FAIL here in which case 
//                  the object could display its own. 
//************************************************************

HRESULT
CContainerSite::SetStatusText(LPCOLESTR pszText) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::SetStatusText"));
    return E_FAIL; 
} // SetStatusText

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        EnableModeless, IOleInPlaceFrame
// Abstract:        Instructs the container to show or hide 
//                  any modeless popup windows that it may be 
//                  using. 
//************************************************************

HRESULT
CContainerSite::EnableModeless(BOOL fEnable) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::EnableModeless - %s", fEnable ? "TRUE" : "FALSE"));
    return NOERROR; 
} // EnableModeless

//************************************************************
// Author:          twillie
// Created:         01/19/99
// Function:        TranslateAccelerator, IOleInPlaceFrame
// Abstract:        When dealing with an in-place object from 
//                  an EXE server, this is called to give the 
//                  container a chance to process accelerators 
//                  after the server has looked at the message. 
//************************************************************

HRESULT
CContainerSite::TranslateAccelerator(LPMSG pMSG, WORD wID) 
{ 
    TraceTag((tagContainerSite, "CContainerSite::TranslateAccelerator"));
    return S_FALSE; 
} // TranslateAccelerator

#define DISPID_DURATION 1003
#define LCID_SCRIPTING 0x0409
#define DISPID_ISDURATIONVALID 1059
#define DISPID_CANSEEK 1012

HRESULT
CContainerSite::GetMediaLength(double &dblLength)
{
    HRESULT hr;
    DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
    DAComPtr<IDispatch> pdisp;
    CComVariant _retVar;
    CComVariant vIsValid;
    hr = m_pObj->QueryInterface(IID_TO_PPV(IDispatch, &pdisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pdisp->Invoke(DISPID_ISDURATIONVALID,
                       IID_NULL,
                       LCID_SCRIPTING,
                       DISPATCH_PROPERTYGET,
                       &dispparamsNoArgs,
                       &vIsValid, NULL, NULL);
    if (FAILED(hr))
    {
        goto done;
    }
    if (!vIsValid.boolVal)
    {
        hr = E_FAIL;
        goto done;
    }


    hr = pdisp->Invoke(DISPID_DURATION,
                       IID_NULL,
                       LCID_SCRIPTING,
                       DISPATCH_PROPERTYGET,
                       &dispparamsNoArgs,
                       &_retVar, NULL, NULL);
    if (FAILED(hr))
    {
        goto done;
    }


    hr = _retVar.ChangeType(VT_R8, NULL);
    if (FAILED(hr))
    {
        goto done;
    }
    dblLength = _retVar.dblVal;

    //hr = m_pMPlayer->get_Duration(&dblLength);

done:
    return hr;
}

HRESULT
CContainerSite::CanSeek(bool &fcanSeek)
{
    HRESULT hr;
    DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
    DAComPtr<IDispatch> pdisp;
    CComVariant vIsValid;
    hr = m_pObj->QueryInterface(IID_TO_PPV(IDispatch, &pdisp));
    if (FAILED(hr))
    {
        fcanSeek = false;
        goto done;
    }

    hr = pdisp->Invoke(DISPID_CANSEEK,
                       IID_NULL,
                       LCID_SCRIPTING,
                       DISPATCH_PROPERTYGET,
                       &dispparamsNoArgs,
                       &vIsValid, NULL, NULL);
    if (FAILED(hr))
    {
        fcanSeek = false;
        goto done;
    }
    if (vIsValid.boolVal)
    {
        fcanSeek = true;
    }
    else
    {
        fcanSeek = false;
    }

done:
    return hr;
}


//************************************************************
// End of file
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\clock.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: clock.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _CLOCK_H
#define _CLOCK_H

#include <ocmm.h>
#include <htmlfilter.h>

// This needs to be implemented by the object that wants to be called
// back on timer ticks

class ClockSink
{
  public:
    virtual void OnTimer(double time)=0;
};

// This is the base clock implementation

enum ClockState
{
    CS_STARTED,
    CS_PAUSED,
    CS_STOPPED,
};

class Clock
    : public ITimerSink
{
  public :
    Clock();
    virtual ~Clock();

    HRESULT SetITimer(IServiceProvider * sp, ULONG iInterval);
    void SetSink(ClockSink *pClockSink)
    {
        m_pClockSink = pClockSink;
    }

    HRESULT Start();
    HRESULT Pause();
    HRESULT Resume();
    HRESULT Stop();

    // For the timer sink.
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);
    STDMETHOD_(ULONG, AddRef) (void);
    STDMETHOD_(ULONG, Release) (void);
    STDMETHOD(OnTimer) (VARIANT varTimeAdvise);

    // For the starvation sniffer
    void WINAPI StarvationCallback (void);
    static LRESULT __stdcall StarveWndProc (HWND hWnd, UINT uiMessage, WPARAM wParam, LPARAM lParam);

    double GetCurrentTime() { return m_curTime; }
    ClockState GetCurrentState() { return m_state; }
  protected :
    ULONG                      m_ulRefs;
    ClockState                 m_state;
    DAComPtr<ITimer>           m_timer;
    DWORD                      m_cookie;
    ClockSink                 *m_pClockSink;
    ULONG                      m_interval;
    double                     m_lastTime;
    double                     m_curTime;
    UINT                       m_uStarveTimerID;
    HWND                       m_hWndStarveTimer;
    ULONG                      m_ulLastStarvationCallback;
    ULONG                      m_ulConsectiveStarvedTicks;
    bool                       m_fAllowOnTimer;
    bool                       m_fAllowStarvationCallback;

    HRESULT StartITimer();
    HRESULT StopITimer();

    void CreateStarveTimerWindow (void);
    void SetStarveTimer (void);
    
    ULONG GetNextInterval (void);
    HRESULT SetNextTimerInterval (ULONG ulNextInterval);

    double GetITimerTime();
    double GetGlobalTime() { return GetITimerTime(); }

    void ProcessCB(double time);
};


#endif /* _CLOCK_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\daelm.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: daelm.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "daelm.h"
#include "bodyelm.h"

// static class data.
CPtrAry<BSTR> CTIMEDAElement::ms_aryPropNames;
DWORD CTIMEDAElement::ms_dwNumTimeDAElems = 0;

// These must align with the class PROPERTY_INDEX enumeration.
LPWSTR CTIMEDAElement::ms_rgwszTDAPropNames[] = {
    L"renderMode",
};

DeclareTag(tagDATimeElm, "API", "CTIMEDAElement methods");

CTIMEDAElement::CTIMEDAElement()
: m_renderMode(REPLACE_TOKEN),
  m_fPropertiesDirty(true),
  m_cookieValue(1)
{
    TraceTag((tagDATimeElm,
              "CTIMEDAElement(%lx)::CTIMEDAElement()",
              this));

    CTIMEDAElement::ms_dwNumTimeDAElems++;
}

CTIMEDAElement::~CTIMEDAElement()
{
    CTIMEDAElement::ms_dwNumTimeDAElems--;

    if (0 == CTIMEDAElement::ms_dwNumTimeDAElems)
    {
        int iNames = CTIMEDAElement::ms_aryPropNames.Size();

        for (int i = iNames - 1; i >= 0; i--)
        {
            BSTR bstrName = CTIMEDAElement::ms_aryPropNames[i];
            CTIMEDAElement::ms_aryPropNames.DeleteItem(i);
            ::SysFreeString(bstrName);
        }
    }
}


HRESULT
CTIMEDAElement::Notify(LONG event, VARIANT * pVar)
{
    TraceTag((tagDATimeElm,
              "CTIMEDAElement(%lx)::Notify(%lx)",
              this,
              event));

    THR(CBaseBvr::Notify(event, pVar));
    
    HRESULT hr = S_OK;
    if (BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE == event)
    {
        DAComPtr<IHTMLElement> spHTMLEle;
        hr = m_pHTMLEle->get_parentElement(&spHTMLEle);
        if (FAILED(hr))
        {
            goto done;
        }
        if (NULL == spHTMLEle.p)
        {
            if (NULL != m_body.p)
            {
                std::map<long, ITIMEMMBehavior*>::iterator iter;
                iter = m_cookieMap.begin();
                
                while (iter != m_cookieMap.end())
                {
                    ITIMEMMBehavior *bvr;
                    
                    bvr = (*iter).second;
                    
                    ITIMEMMTimeline * tl;
                    
                    MMPlayer *player = &(m_body->GetPlayer());
                    if (NULL == player)
                    {
                        goto done;
                    }
                    
                    MMTimeline *timeline =  &(player->GetTimeline());
                    if (NULL == timeline)
                    {
                        goto done;
                    }
                    
                    tl = timeline->GetMMTimeline();
                    if (NULL == tl)
                    {
                        goto done;
                    }
                    
                    hr = THR(tl->RemoveBehavior(bvr));
                    
                    std::map<long, ITIMEMMBehavior*>::iterator olditer=iter;
                    iter++;
                    m_cookieMap.erase(olditer);            
                } // while
                m_cookieMap.clear();
            }
        }
    }

done:
    return S_OK;
}

HRESULT
CTIMEDAElement::Init(IElementBehaviorSite * pBehaviorSite)
{
    TraceTag((tagDATimeElm,
              "CTIMEDAElement(%lx)::Init(%#lx)",
              this,
              pBehaviorSite));

    HRESULT hr;

    hr = THR(CBaseBvr::Init(pBehaviorSite));
    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = m_pBvrSite->RegisterNotification(BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_pBvrSiteOM->RegisterName(WZ_REGISTERED_NAME_DAELM);
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(GetBehaviorTypeAsURN());
    
    MMFactory::AddRef();
    
    if (MMFactory::GetFactory() == NULL)
    {
        hr = E_FAIL;
        goto done;
    }
    
    hr = THR(AddBodyBehavior(GetElement()));
    
    if (FAILED(hr))
    {
        goto done;
    }
    
    {
        CRLockGrabber __gclg;
        
        m_image = (CRImagePtr) CRModifiableBvr((CRBvrPtr) CREmptyImage(),0);
        
        if (!m_image)
        {
            TraceTag((tagError,
                      "CTIMEDAElement(%lx)::Init(): Failed to create image switcher - %hr, %ls",
                      this,
                      CRGetLastError(),
                      CRGetLastErrorString()));
            
            hr = CRGetLastError();
            goto done;
        }
        
        m_sound = (CRSoundPtr) CRModifiableBvr((CRBvrPtr) CRSilence(),0);
        
        if (!m_sound)
        {
            TraceTag((tagError,
                      "CTIMEDAElement(%lx)::Init(): Failed to create sound switcher - %hr, %ls",
                      this,
                      CRGetLastError(),
                      CRGetLastErrorString()));
            
            hr = CRGetLastError();
            goto done;
        }
    }
    
    if (!m_view.Init(NULL,
                     m_image,
                     m_sound,
                     (ITIMEMMViewSite *) this))
    {
        TraceTag((tagError,
                  "CTIMEDAElement(%lx)::Init(): Failed to init mmview - %hr, %ls",
                  this,
                  CRGetLastError(),
                  CRGetLastErrorString()));
            
        hr = CRGetLastError();
        goto done;
    }

    if (!RegisterWithBody())
    {
        TraceTag((tagError,
                  "CTIMEDAElement(%lx)::Init(): Failed to register with body - %hr, %ls",
                  this,
                  CRGetLastError(),
                  CRGetLastErrorString()));
            
        hr = CRGetLastError();
        goto done;
    }
    
    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEDAElement::Detach()
{
    TraceTag((tagDATimeElm,
              "CTIMEDAElement(%lx)::Detach()",
              this));

    RemoveFromBody();
    
    m_view.Deinit();

    MMFactory::Release();
    
    m_body.Release();
    m_renderSite.Release();
    
    THR(CBaseBvr::Detach());

    return S_OK;
}

HRESULT
CTIMEDAElement::get_image(VARIANT * img)
{
    bool ok = false;
    
    ok = CRBvrToVARIANT((CRBvrPtr) m_image.p, img);
    
    return ok?S_OK:Error();
}

HRESULT
CTIMEDAElement::put_image(VARIANT img)
{
    bool ok = false;

    CRBvrPtr bvr;
    
    bvr = VARIANTToCRBvr(img, CRIMAGE_TYPEID);
        
    if (bvr == NULL)
    {
        goto done;
    }
        
    Assert(m_image);
    if (m_image)
    {
        CRLockGrabber __gclg;
        
        if (!CRSwitchTo((CRBvrPtr) m_image.p,
                        bvr,
                        false,
                        CRContinueTimeline,
                        0.0))
        {
            TraceTag((tagError,
                      "CTIMEDAElement(%lx)::put_image(): Failed to switch image  - %hr, %ls",
                      this,
                      CRGetLastError(),
                      CRGetLastErrorString()));
            
            goto done;
        }
    }
    else
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok?S_OK:Error();
}

    
HRESULT
CTIMEDAElement::get_sound(VARIANT * snd)
{
    bool ok = false;
    
    ok = CRBvrToVARIANT((CRBvrPtr) m_sound.p, snd);

    return ok?S_OK:Error();
}

HRESULT
CTIMEDAElement::put_sound(VARIANT snd)
{
    bool ok = false;

    CRBvrPtr bvr;

    bvr = VARIANTToCRBvr(snd, CRSOUND_TYPEID);
    
    if (bvr == NULL)
    {
        goto done;
    }
    
    {
        CRLockGrabber __gclg;

        if (!CRSwitchTo((CRBvrPtr) m_sound.p,
                        bvr,
                        false,
                        CRContinueTimeline,
                        0.0))
        {
            TraceTag((tagError,
                      "CTIMEDAElement(%lx)::put_sound(): Failed to switch sound  - %hr, %ls",
                      this,
                      CRGetLastError(),
                      CRGetLastErrorString()));
            
            goto done;
        }
    }
        
    ok = true;
  done:
    return ok?S_OK:Error();
}

HRESULT
CTIMEDAElement::get_renderMode(VARIANT * mode)
{
    HRESULT hr;
    
    if (mode == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(mode))))
    {
        goto done;
    }
    
    V_VT(mode) = VT_BSTR;
    V_BSTR(mode) = SysAllocString(TokenToString(m_renderMode));

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEDAElement::put_renderMode(VARIANT mode)
{
    CComVariant v;
    HRESULT hr;
  
    hr = v.ChangeType(VT_BSTR, &mode);

    if (FAILED(hr))
    {
        goto done;
    }
  
    TOKEN newmode;

    newmode = StringToToken(V_BSTR(&v));
    if (m_renderMode != newmode)
    {
        m_renderMode = newmode;
        InvalidateRect(NULL);
        InvalidateRenderInfo();
    }
    
    hr = S_OK;
  done:
    return hr;
}

    
HRESULT
CTIMEDAElement::addDABehavior(VARIANT var,
                              LONG * cookie)
{
    bool ok = false;
 
    HRESULT hr;
    DAComPtr<IDABehavior> dabvr;
    DAComPtr<IUnknown> punk;
    DAComPtr<ITIMEMMBehavior> mmbvr;

    CHECK_RETURN_SET_NULL(cookie);
    
    CComVariant newvar;

    std::map<long, ITIMEMMBehavior*>::iterator iterator;
    std::pair<std::map<long, ITIMEMMBehavior*>::iterator, bool> pair;

    if (!m_body)
    {
        hr = E_FAIL;
        goto done;
    }
    
    hr = THR(newvar.ChangeType(VT_UNKNOWN, &var));

    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = THR(V_UNKNOWN(&newvar)->QueryInterface(IID_IDABehavior,
                                                (void **)&dabvr));
        

    if (FAILED(hr))
    {
        goto done;
    }
    
    Assert(MMFactory::GetFactory());
    
    hr = THR(MMFactory::GetFactory()->CreateBehavior(NULL, dabvr, &punk));

    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = THR(punk->QueryInterface(IID_ITIMEMMBehavior, (void**)&mmbvr));

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }
    
    Assert(m_body);

    ITIMEMMTimeline * tl;
    
    tl = m_body->GetPlayer().GetTimeline().GetMMTimeline();

    hr = THR(tl->AddBehavior(mmbvr, MM_START_ABSOLUTE, NULL));

    if (FAILED(hr))
    {
        goto done;
    }

    
    {
        // if m_cookieValue wraps then simple incrementing may overlap two cookie values
        // this code could spin forever if all of the objects places are taken in the map
        iterator = m_cookieMap.find(m_cookieValue);
        while ( false == m_cookieMap.empty() && iterator != m_cookieMap.end() )
        {
            m_cookieValue++;
            if (0 == m_cookieValue)
                m_cookieValue++;
            iterator = m_cookieMap.find(m_cookieValue);
        }
        
        std::pair<const long, ITIMEMMBehavior*> *ppairInsert;
        ppairInsert = new std::pair<const long, ITIMEMMBehavior*>(m_cookieValue, mmbvr);
        if (NULL == ppairInsert)
        {
            // purposely drop the result, we are out of memory already.
            tl->RemoveBehavior(mmbvr);

            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
        pair = m_cookieMap.insert(*ppairInsert);
        delete ppairInsert;
        
        if (false == pair.second)
        {
            // purposely drop the result, we are out of memory already.
            tl->RemoveBehavior(mmbvr);

            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
        
        *cookie = m_cookieValue;
        m_cookieValue++;  
        if (0 == m_cookieValue)
            m_cookieValue++;
    }

    ok = true;
  done:
    return ok?S_OK:Error();
}

HRESULT
CTIMEDAElement::removeDABehavior(LONG cookie)
{
    bool ok = false;
    
    HRESULT hr = E_FAIL;

    ITIMEMMBehavior * bvr = NULL;

    std::map<long, ITIMEMMBehavior*>::iterator iterator;

    if (!m_body)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }

    iterator = m_cookieMap.find(cookie);

    if ( iterator == m_cookieMap.end() )
    {
        // cookie wasn't found!
        CRSetLastError(E_INVALIDARG, NULL);
        goto done;
    }
    Assert( cookie == (*iterator).first);
    
    bvr = (*iterator).second;
    
    m_cookieMap.erase(iterator);

    ITIMEMMTimeline * tl;
    
    tl = m_body->GetPlayer().GetTimeline().GetMMTimeline();

    hr = THR(tl->RemoveBehavior(bvr));

    if (FAILED(hr))
    {
        goto done;
    }

    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CTIMEDAElement::get_renderObject(ITIMEDAElementRender ** p)
{
    return QueryInterface(IID_ITIMEDAElementRender, (void **) p);
}

STDMETHODIMP
CTIMEDAElement::Tick()
{
    bool ok = false;

    if (!m_body)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    if (!m_view.Tick())
    {
        goto done;
    }

    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CTIMEDAElement::Draw(HDC dc, LPRECT prc)
{
    bool ok = false;

    if (!m_body)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    if (!m_view.Render(dc, prc))
    {
        goto done;
    }

    ok = true;
  done:
    return ok?S_OK:Error();
}

STDMETHODIMP
CTIMEDAElement::get_RenderSite(ITIMEDAElementRenderSite ** ppSite)
{
    CHECK_RETURN_SET_NULL(ppSite);

    *ppSite = m_renderSite;

    if (*ppSite)
    {
        (*ppSite)->AddRef();
    }
    
    return S_OK;
}

STDMETHODIMP
CTIMEDAElement::put_RenderSite(ITIMEDAElementRenderSite * pSite)
{
    m_renderSite = pSite;

    return S_OK;
}

//
//
//

bool
CTIMEDAElement::AddToBody(CTIMEBodyElement & body)
{
    if (m_body)
    {
        CRSetLastError(E_FAIL, NULL);
        return false;
    }
    
    m_body = &body;
    return body.GetPlayer().AddView(m_view);
}

void
CTIMEDAElement::RemoveFromBody()
{
    if (m_body)
    {
        m_body->GetPlayer().RemoveView(m_view);
        m_body.Release();
    }
}

bool
CTIMEDAElement::RegisterWithBody()
{
    DAComPtr<IHTMLElement> pHTMLElem;
    DAComPtr<ITIMEElement> pTIMEElem;
    DAComPtr<ITIMEBodyElement> pTIMEBody;
    bool rc = false;
    HRESULT hr;

    Assert(!m_body);
    
    hr = THR(GetBodyElement(GetElement(), IID_IHTMLElement, (void **)&pHTMLElem));
    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    Assert(pHTMLElem.p != NULL);

    hr = THR(FindTIMEInterface(pHTMLElem, &pTIMEElem));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(pTIMEElem.p != NULL);

    hr = THR(pTIMEElem->QueryInterface(IID_ITIMEBodyElement, (void**)&pTIMEBody));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(pTIMEBody.p != NULL);

    hr = THR(pTIMEBody->addTIMEDAElement(this));
    if (FAILED(hr))
    {
        TraceTag((tagError, "CTIMEDAElement::RegisterWithBody - failed to invoke addTIMEDAElement"));
        goto done;
    }

    rc = true;

done:
    return rc;
}

STDMETHODIMP
CTIMEDAElement::get_statics(IDispatch **ppDisp)
{
    TraceTag((tagDATimeElm,
          "CTIMEDAElement(%lx)::get_Statics()",
          this));

    DAComPtr<IDAStatics> pStatics;
 
    CHECK_RETURN_SET_NULL(ppDisp);

    HRESULT hr = S_OK;

    // Do not need to deal with NULLing pointer since CoCreateInstance
    // does this
    hr = CoCreateInstance(CLSID_DAStatics,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IDAStatics,
                          (void **)&pStatics);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pStatics->put_ClientSite((IOleClientSite *) this);
    if (FAILED(hr))
    {
        goto done;
    }

    // Make assignment for return value, convert to IDispatch
    // Note that we forward the addref on
    hr = pStatics->QueryInterface(IID_IDispatch, (void**)ppDisp);

  done:
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ITIMEMMViewSite

//////////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CTIMEDAElement::Invalidate(LPRECT prc)
{
    TraceTag((tagDATimeElm,
              "CTIMEDAElement(%lx)::Invalidate()",
              this));

    if (m_renderMode != NONE_TOKEN)
    {
        InvalidateRect(prc);
    }

    if (m_renderSite)
    {
        IGNORE_HR(m_renderSite->Invalidate(prc));
    }
    
    return S_OK;
}

// THESE ARE HERE TEMPORARILY UNTIL TRIDENT UPDATES MSHTML.H
#ifndef BEHAVIORRENDERINFO_SURFACE
#define BEHAVIORRENDERINFO_SURFACE    0x100000
#endif

#ifndef BEHAVIORRENDERINFO_3DSURFACE
#define BEHAVIORRENDERINFO_3DSURFACE  0x200000;
#endif

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IElementBehaviorRender

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEDAElement::GetRenderInfo(LONG *pdwRenderInfo)
{
    TraceTag((tagDATimeElm,
              "CTIMEDAElement(%lx)::GetRenderInfo()",
              this));
    
    // Return the layers we are interested in drawing

    // We do not do any rendering so return 0
    
    *pdwRenderInfo = 0;

    if (m_renderMode != NONE_TOKEN)
    {
        *pdwRenderInfo |= BEHAVIORRENDERINFO_AFTERCONTENT;
        
        // For surface from DC
        *pdwRenderInfo |= BEHAVIORRENDERINFO_SURFACE;
        *pdwRenderInfo |= BEHAVIORRENDERINFO_3DSURFACE;
    }

    return S_OK;
}

 
STDMETHODIMP
CTIMEDAElement::Draw(HDC hdc, LONG dwLayer, LPRECT prc, IUnknown * pParams)
{
    TraceTag((tagDATimeElm,
              "CTIMEDAElement(%lx)::Draw(%#x, %#x, (%d, %d, %d, %d), %#x)",
              this,
              hdc,
              dwLayer,
              prc->left,
              prc->top,
              prc->right,
              prc->bottom,
              pParams));

	return Draw( hdc, prc );
}

STDMETHODIMP
CTIMEDAElement::HitTestPoint(LPPOINT point,
                             IUnknown *pReserved,
                             BOOL *hit)
{
    TraceTag((tagDATimeElm,
              "CTIMEDAElement(%lx)::HitTestPoint()",
              this));

    *hit = FALSE;

    return S_OK;
}

HRESULT
CTIMEDAElement::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    if (str)
        return CComCoClass<CTIMEDAElement, &__uuidof(CTIMEDAElement)>::Error(str, IID_ITIMEDAElement, hr);
    else
        return hr;
}

//*****************************************************************************

HRESULT 
CTIMEDAElement::SetPropertyByIndex(unsigned uIndex, VARIANT *pvarprop)
{
    HRESULT hr = E_FAIL;

    CComVariant var;
    
    if (tme_maxTIMEDAProp > uIndex)
    {
        switch (uIndex)
        {
          case tda_renderMode :
            hr = put_renderMode(*pvarprop);
            break;
        };
    }

    return hr;
} // SetPropertyByIndex

//*****************************************************************************

HRESULT 
CTIMEDAElement::GetPropertyByIndex(unsigned uIndex, VARIANT *pvarprop)
{
    HRESULT hr = E_FAIL;

    if (tme_maxTIMEDAProp > uIndex)
    {
        Assert(VT_EMPTY == V_VT(pvarprop));
        switch (uIndex)
        {
          case tda_renderMode :
            hr = get_renderMode(pvarprop);
            break;
        };
    }

    return hr;
} // GetPropertyByIndex

//*****************************************************************************

HRESULT
CTIMEDAElement::BuildPropertyNameList(CPtrAry<BSTR> *paryPropNames)
{
    HRESULT hr = S_OK;
    
    for (int i = 0; 
         (i < tme_maxTIMEDAProp) && (SUCCEEDED(hr));
         i++)
    {
        Assert(NULL != ms_rgwszTDAPropNames[i]);
        BSTR bstrNewName = CreateTIMEAttrName(ms_rgwszTDAPropNames[i]);
        Assert(NULL != bstrNewName);
        if (NULL != bstrNewName)
        {
            hr = paryPropNames->Append(bstrNewName);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
} // BuildPropertyNameList

//*****************************************************************************

HRESULT 
CTIMEDAElement::GetPropertyBagInfo(CPtrAry<BSTR> **pparyPropNames)
{
    HRESULT hr = S_OK;

    // If we haven't built this yet, build it now.
    if (0 == ms_aryPropNames.Size())
    {
        hr = BuildPropertyNameList(&(CTIMEDAElement::ms_aryPropNames));
    }

    if (SUCCEEDED(hr))
    {
        *pparyPropNames = &(CTIMEDAElement::ms_aryPropNames);
    }

    return hr;
} // GetPropertyBagInfo

//*****************************************************************************
//IPersistPropertyBag2 methods
STDMETHODIMP 
CTIMEDAElement::Load(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog)
{
    if (NULL == pPropBag)
    {
        return E_INVALIDARG;
    }

    CPtrAry<BSTR> *paryPropNames = NULL;
    HRESULT hr = GetPropertyBagInfo(&paryPropNames);

    if (hr == E_NOTIMPL)
    {
        return S_OK;
    }
    else if (FAILED(hr))
    {
        return hr;
    }

    // Unfortunately Load takes an array of Variants and not
    // Variant pointers.  We therefor need to loop through
    // each one and get the correct property this way.
    unsigned uNumProps = static_cast<unsigned>(paryPropNames->Size());
    for (unsigned uProperties = 0; uProperties < uNumProps; uProperties++)
    {
        HRESULT hrres = S_OK;
        PROPBAG2 propbag;
        VARIANT var;
        VariantInit(&var);
        propbag.vt = VT_BSTR;
        propbag.pstrName = (*paryPropNames)[uProperties];
        hr = pPropBag->Read(1,
                            &propbag,
                            pErrorLog,
                            &var,
                            &hrres);
        if (SUCCEEDED(hr))
        {
            // Skip over failures ... why would we want to 
            // allow that to abort all persistance?
            hr = SetPropertyByIndex(uProperties, &var);
            VariantClear(&var);
        }
    }

    // We return error codes not specific to properties 
    // by early-outing.
    return S_OK;
} // Load

//*****************************************************************************

STDMETHODIMP 
CTIMEDAElement::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    if (NULL == pPropBag)
    {
        return E_INVALIDARG;
    }

    if (fClearDirty)
    {
        m_fPropertiesDirty = false;
    }

    CPtrAry<BSTR> *paryPropNames = NULL;
    HRESULT hr = GetPropertyBagInfo(&paryPropNames);

    if (hr == E_NOTIMPL)
    {
        return S_OK;
    }
    else if (FAILED(hr))
    {
        return hr;
    }

    VARIANT var;
    VariantInit(&var);
    unsigned uNumProps = static_cast<unsigned>(paryPropNames->Size());
    for (unsigned uProperties = 0; uProperties < uNumProps; uProperties++)
    {
        PROPBAG2 propbag;

        Assert(NULL != (*paryPropNames)[uProperties]);
        if (NULL != (*paryPropNames)[uProperties])
        {
            propbag.vt = VT_BSTR;
            propbag.pstrName = (*paryPropNames)[uProperties];
            
            hr = GetPropertyByIndex(uProperties, &var);
            
            // Skip over failures ... why would we want to 
            // allow that to abort all persistance?
            if ((SUCCEEDED(hr)) && (var.vt != VT_EMPTY) && (var.vt != VT_NULL))
            {
                hr = pPropBag->Write(1, &propbag, &var);
                VariantClear(&var);
            }
        }
    }

    // We return error codes not specific to properties 
    // by early-outing.
    return S_OK;
} // Save

//*****************************************************************************

STDMETHODIMP 
CTIMEDAElement::GetClassID(CLSID* pclsid)
{
    if (NULL != pclsid)
    {
        return E_POINTER;
    }
    *pclsid = __uuidof(CTIMEDAElement);
    return S_OK;
} // GetClassID

//*****************************************************************************

STDMETHODIMP 
CTIMEDAElement::InitNew(void)
{
    return S_OK;
} // InitNew

//
//
//

class __declspec(uuid("e74afe10-927b-11d2-80ba-00c04fa32195"))
DAElmGuid {};

HRESULT WINAPI
CTIMEDAElement::InternalQueryInterface(CTIMEDAElement* pThis,
                                       const _ATL_INTMAP_ENTRY* pEntries,
                                       REFIID iid,
                                       void** ppvObject)
{
    // Do not do an addref but return the original this pointer to
    // give access to the class pointer itself.
    
    if (InlineIsEqualGUID(iid, __uuidof(DAElmGuid)))
    {
        *ppvObject = pThis;
        return S_OK;
    }
    
    return CComObjectRootEx<CComSingleThreadModel>::InternalQueryInterface(pThis,
                                                                           pEntries,
                                                                           iid,
                                                                           ppvObject);
}
        
CTIMEDAElement *
GetDAElementFromInterface(IUnknown * pv)
{
    // This is a total hack to get the original class data.  The QI is
    // implemented above and does NOT do a addref so we do not need to
    // release it
    
    CTIMEDAElement * daelm = NULL;

    if (pv)
    {
        pv->QueryInterface(__uuidof(DAElmGuid),(void **)&daelm);
    }
    
    if (daelm == NULL)
    {
        CRSetLastError(E_INVALIDARG, NULL);
    }
                
    return daelm;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\daelm.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: daelm.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _DAELM_H
#define _DAELM_H

#include "daelmbase.h"
#include "mmutil.h"

class CTIMEBodyElement;

/////////////////////////////////////////////////////////////////////////////
// CTIMEDAElement

class
ATL_NO_VTABLE
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CTIMEDAElement :
    public CBaseBvr,
    public CComCoClass<CTIMEDAElement, &__uuidof(CTIMEDAElement)>,
    public IDispatchImpl<ITIMEDAElement, &IID_ITIMEDAElement, &LIBID_TIME>,
    public ISupportErrorInfoImpl<&IID_ITIMEDAElement>,
    public IConnectionPointContainerImpl<CTIMEDAElement>,
    public IPersistPropertyBag2,
    public IPropertyNotifySinkCP<CTIMEDAElement>,
    public ITIMEMMViewSite,
    public ITIMEDAElementRender
{
  public:
    CTIMEDAElement();
    ~CTIMEDAElement();
        
#if _DEBUG
    const _TCHAR * GetName() { return __T("CTIMEDAElement"); }
#endif

    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) = 0;


    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);
    STDMETHOD(Notify)(LONG event, VARIANT * pVar);
    STDMETHOD(Detach)();
    
    //
    // IElementBehaviorRender
    //
    STDMETHOD(Draw)(HDC hdc, LONG dwLayer, LPRECT prc, IUnknown * pParams);
    STDMETHOD(GetRenderInfo)(LONG *pdwRenderInfo);
    STDMETHOD(HitTestPoint)(LPPOINT point,
                            IUnknown *pReserved,
                            BOOL *hit);

    //
    // ITIMEMMViewSite
    //
    
    STDMETHOD(Invalidate)(LPRECT prc);

    MMView & GetView() { return m_view; }

    //
    // ITIMEDAElement
    //
    
    STDMETHOD(get_image)(VARIANT * img);
    STDMETHOD(put_image)(VARIANT img);
    
    STDMETHOD(get_sound)(VARIANT * snd);
    STDMETHOD(put_sound)(VARIANT snd);
    
    STDMETHOD(get_renderMode)(VARIANT * mode);
    STDMETHOD(put_renderMode)(VARIANT mode);
    
    STDMETHOD(addDABehavior)(VARIANT bvr,
                             LONG * cookie);
    STDMETHOD(removeDABehavior)(LONG cookie);
    
    STDMETHOD(get_statics)(IDispatch **ppStatics);

    STDMETHOD(get_renderObject)(ITIMEDAElementRender **);
    
    //
    // ITIMEDAElementRender
    //
    
    STDMETHOD(Tick)();
    STDMETHOD(Draw)(HDC dc, LPRECT prc);

    STDMETHOD(get_RenderSite)(ITIMEDAElementRenderSite ** ppSite);
    STDMETHOD(put_RenderSite)(ITIMEDAElementRenderSite * pSite);
    
    // QI Map
    
    BEGIN_COM_MAP(CTIMEDAElement)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ITIMEDAElement)
        COM_INTERFACE_ENTRY(ITIMEDAElementRender)
        COM_INTERFACE_ENTRY(ITIMEMMViewSite)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IPersistPropertyBag2)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
        COM_INTERFACE_ENTRY_CHAIN(CBaseBvr)
    END_COM_MAP();

    // Connection Point to allow IPropertyNotifySink 
    BEGIN_CONNECTION_POINT_MAP(CTIMEDAElement)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP();

    static HRESULT WINAPI
        InternalQueryInterface(CTIMEDAElement* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject);
    // Needed by CBvrBase
    
    void * GetInstance()
    { return (ITIMEDAElement *) this ; }
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }
    
    virtual WCHAR* GetBehaviorTypeAsURN() { return L"DIRECTANIMATION_BEHAVIOR_URN"; }

    //
    //IPersistPropertyBag2
    // 
    STDMETHOD(GetClassID)(CLSID* pclsid);
    STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void)
        {return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    enum PROPERTY_INDEX
    {
        tda_renderMode = 0,
        tme_maxTIMEDAProp,
    };

    bool AddToBody(CTIMEBodyElement & body);
    void RemoveFromBody();
  protected:
    HRESULT Error();


    HRESULT BuildPropertyNameList (CPtrAry<BSTR> *paryPropNames);
    HRESULT SetPropertyByIndex(unsigned uIndex, VARIANT *pvarProp);
    HRESULT GetPropertyByIndex(unsigned uIndex, VARIANT *pvarProp);
    HRESULT GetPropertyBagInfo(CPtrAry<BSTR> **pparyPropNames);

    bool RegisterWithBody();
    
  protected:
    static LPWSTR ms_rgwszTDAPropNames[];
    static CPtrAry<BSTR> ms_aryPropNames;
    static DWORD ms_dwNumTimeDAElems;
    
    bool                 m_fPropertiesDirty;
    TOKEN                m_renderMode;

    MMView               m_view;
    CRPtr<CRImage>       m_image;
    CRPtr<CRSound>       m_sound;
    DAComPtr<CTIMEBodyElement> m_body;
    DAComPtr<ITIMEDAElementRenderSite> m_renderSite;

  private:
	std::map<long, ITIMEMMBehavior*>    m_cookieMap;
	long                                m_cookieValue;

};

CTIMEDAElement * GetDAElementFromInterface(IUnknown * pv);

#endif /* _DAELM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\containersite.h ===
#ifndef _CONTAINERSITE_H_
#define _CONTAINERSITE_H_

//************************************************************
//
// FileName:        containersite.h
//
// Created:         10/08/98
//
// Author:          TWillie
// 
// Abstract:        Declaration of the CContainerSite
//
//************************************************************

#include <docobj.h>
#include <mshtml.h>
#include "timeelmbase.h"
#include "containerobj.h"

// forward class declarations
class CContainerObj;

enum ObjectState
{
    OS_PASSIVE,
    OS_LOADED,
    OS_RUNNING,
    OS_INPLACE,
    OS_UIACTIVE,
};

class CContainerSite :
    public IDispatch,
    public IServiceProvider,
    public IOleClientSite,
    public IAdviseSinkEx,
    public IOleInPlaceSiteWindowless,
    public IOleInPlaceFrame,
    public IOleCommandTarget,
    public IOleControlSite
{
    public:
        CContainerSite(CContainerObj *pHost);
        virtual ~CContainerSite();

        //
        // IUnknown Methods
        //
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
        STDMETHODIMP QueryInterface(REFIID, void**);

        //
        // IServiceProvider methods
        //
        STDMETHODIMP QueryService(REFGUID guid, REFIID iid, void **ppv);

        //
        // IOleClientSite methods
        //
        STDMETHODIMP SaveObject(void);
        STDMETHODIMP GetMoniker(DWORD dwAssign, DWORD dwWhich, IMoniker **ppmk);
        STDMETHODIMP GetContainer(IOleContainer **ppContainer);
        STDMETHODIMP ShowObject(void);
        STDMETHODIMP OnShowWindow(BOOL fShow);
        STDMETHODIMP RequestNewObjectLayout(void);

        //
        // IAdviseSink Methods
        //
        STDMETHODIMP_(void) OnDataChange(FORMATETC *pFEIn, STGMEDIUM *pSTM);
        STDMETHODIMP_(void) OnViewChange(DWORD dwAspect, LONG lindex);
        STDMETHODIMP_(void) OnRename(IMoniker *pmk);
        STDMETHODIMP_(void) OnSave(void);
        STDMETHODIMP_(void) OnClose(void);

        //
        // IAdviseSinkEx Methods
        //
        STDMETHODIMP_(void) OnViewStatusChange(DWORD dwViewStatus);

        //
        // IOleWindow Methods
        //
        STDMETHODIMP GetWindow(HWND *phWnd);
        STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

        //
        // IOleInPlaceSite Methods
        //
        STDMETHODIMP CanInPlaceActivate(void);
        STDMETHODIMP OnInPlaceActivate(void);
        STDMETHODIMP OnUIActivate(void);
        STDMETHODIMP GetWindowContext(IOleInPlaceFrame **ppFrame, IOleInPlaceUIWindow **ppUIWin, RECT *prc, RECT *prcClip, OLEINPLACEFRAMEINFO *pFI);
        STDMETHODIMP Scroll(SIZE sz);
        STDMETHODIMP OnUIDeactivate(BOOL fUndoable);
        STDMETHODIMP OnInPlaceDeactivate(void);
        STDMETHODIMP DiscardUndoState(void);
        STDMETHODIMP DeactivateAndUndo(void);
        STDMETHODIMP OnPosRectChange(const RECT * prc);

        //
        // IOleInPlaceSiteEx Methods
        //
        STDMETHODIMP OnInPlaceActivateEx(BOOL * pfNoRedraw, DWORD dwFlags);
        STDMETHODIMP OnInPlaceDeactivateEx(BOOL fNoRedraw);
        STDMETHODIMP RequestUIActivate(void);

        //
        // IOleInPlaceSiteWindowless Methods
        //
        STDMETHODIMP CanWindowlessActivate(void);
        STDMETHODIMP GetCapture(void);
        STDMETHODIMP SetCapture(BOOL fCapture);
        STDMETHODIMP GetFocus(void);
        STDMETHODIMP SetFocus(BOOL fFocus);
        STDMETHODIMP GetDC(const RECT *pRect, DWORD dwFlags, HDC* phDC);
        STDMETHODIMP ReleaseDC(HDC hDC);
        STDMETHODIMP InvalidateRect(const RECT *pRect, BOOL fErase);
        STDMETHODIMP InvalidateRgn(HRGN hRGN, BOOL fErase);
        STDMETHODIMP ScrollRect(INT dx, INT dy, const RECT *prcScroll, const RECT *prcClip);
        STDMETHODIMP AdjustRect(RECT *prc);
        STDMETHODIMP OnDefWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* plResult);

        //
        // IOleUIWindow
        //
        STDMETHODIMP GetBorder(LPRECT prcBorder);
        STDMETHODIMP RequestBorderSpace(LPCBORDERWIDTHS pBW);
        STDMETHODIMP SetBorderSpace(LPCBORDERWIDTHS pBW);
        STDMETHODIMP SetActiveObject(LPOLEINPLACEACTIVEOBJECT pIIPActiveObj, LPCOLESTR pszObj);

        //
        // IOleInPlaceFrame Methods
        //
        STDMETHODIMP InsertMenus(HMENU hMenu, LPOLEMENUGROUPWIDTHS pMGW);
        STDMETHODIMP SetMenu(HMENU hMenu, HOLEMENU hOLEMenu, HWND hWndObj);
        STDMETHODIMP RemoveMenus(HMENU hMenu);
        STDMETHODIMP SetStatusText(LPCOLESTR pszText);
        STDMETHODIMP EnableModeless(BOOL fEnable);
        STDMETHODIMP TranslateAccelerator(LPMSG pMSG, WORD wID);

        //
        // IDispatch Methods
        //
        STDMETHODIMP GetTypeInfoCount(UINT *pctInfo);
        STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptInfo);
        STDMETHODIMP GetIDsOfNames(REFIID  riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID);
        STDMETHODIMP Invoke(DISPID disIDMember, REFIID riid, LCID lcid, unsigned short wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr);

        //
        // IOleCommandTarget
        //
        STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText);
        STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);

        //
        // IOleControlSite methods
        //
        STDMETHOD(OnControlInfoChanged)(void);
        STDMETHOD(LockInPlaceActive)(BOOL fLock);
        STDMETHOD(GetExtendedControl)(IDispatch **ppDisp);
        STDMETHOD(TransformCoords)(POINTL *pPtlHiMetric, POINTF *pPtfContainer, DWORD dwFlags);
        STDMETHOD(TranslateAccelerator)(MSG *pmsg, DWORD grfModifiers);
        STDMETHOD(OnFocus)(BOOL fGotFocus);
        STDMETHOD(ShowPropertyFrame)(void);

        // internal
        HRESULT Init(REFCLSID clsid, CTIMEElementBase *pElem);
        HRESULT DetachFromHostElement (void);
        void Close();
        HRESULT draw(HDC hdc, RECT *prc);
        HRESULT begin();
        HRESULT end();
        HRESULT pause();
        HRESULT resume();
        ITIMEMediaPlayer *GetPlayer();
        IOleInPlaceObject *GetIOleInPlaceObject() { return m_pInPlaceObject;}
        HRESULT GetMediaLength(double &dblLength);
        HRESULT CanSeek(bool &fcanSeek);
        void ClearAutosizeFlag() { m_fAutosize = false;}
        void SetMediaReadyFlag() { m_fMediaReady = true;}
        bool GetMediaReadyFlag() { return m_fMediaReady;}

    private:
        enum
        {
            VALIDATE_ATTACHED = 1,
            VALIDATE_LOADED   = 2,
            VALIDATE_INPLACE  = 3,
            VALIDATE_WINDOWLESSINPLACE = 4,
        };

        bool IllegalSiteCall(DWORD dwFlags);

    private:
        ULONG                            m_cRef;
        DWORD                            m_dwAdviseCookie;
        DWORD                            m_dwEventsCookie;
        ObjectState                      m_osMode;
        IConnectionPoint                *m_pcpEvents;
        IViewObject2                    *m_pViewObject;
        IOleObject                      *m_pIOleObject;
        IUnknown                        *m_pObj;
        IOleInPlaceObject               *m_pInPlaceObject;
        IHTMLDocument2                  *m_pHTMLDoc;
        ITIMEMediaPlayer                *m_pPlayer;
        CTIMEElementBase                *m_pTIMEElem;
        CContainerObj                   *m_pHost;
        bool                             m_fWindowless;
        bool                             m_fAutosize;
        bool                             m_fStarted;
        bool                             m_fMediaReady;

}; // CContainerSite

inline ITIMEMediaPlayer *
CContainerSite::GetPlayer()
{
    Assert(m_pPlayer != NULL);
    return m_pPlayer;
} // GetPlayer

#endif //_CONTAINERSITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\daelmbase.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: daelmbase.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _DAELMBASE_H
#define _DAELMBASE_H

#include "timeelmbase.h"

#include <map>

class HTMLImage;

/////////////////////////////////////////////////////////////////////////////
// CDAElementBase

class ATL_NO_VTABLE
CDAElementBase : 
    public CTIMEElementBase,
    public ITIMEMMViewSite
{
  public:
    CDAElementBase();
    ~CDAElementBase();
        
#if _DEBUG
    const _TCHAR * GetName() { return __T("CDAElementBase"); }
#endif

    BEGIN_COM_MAP(CDAElementBase)
        COM_INTERFACE_ENTRY(ITIMEMMViewSite)
        COM_INTERFACE_ENTRY_CHAIN(CBaseBvr)
    END_COM_MAP();

    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);
    STDMETHOD(Detach)();

    //
    // IElementBehaviorRender
    //
    STDMETHOD(Draw)(HDC hdc, LONG dwLayer, LPRECT prc, IUnknown * pParams);
    STDMETHOD(GetRenderInfo)(LONG *pdwRenderInfo);

    //
    // ITIMEMMViewSite
    //
    
    STDMETHOD(Invalidate)(LPRECT prc);

    MMView * GetView() { return &m_view; }

    bool SetImage(CRImagePtr newimg);
    bool SetSound(CRSoundPtr newsnd);
    bool SeekImage(double dblTime);

    HRESULT StartRootTime(MMTimeline * tl);
    void StopRootTime(MMTimeline * tl);
    bool Update();
    LPOLESTR GetURLOfClientSite();

  protected:
    bool AddViewToPlayer();

  protected:
    MMView               m_view;
    TOKEN                m_renderMode;
    CRPtr<CRImage>       m_image;
    CRPtr<CRSound>       m_sound;
    bool                 m_contentSet;
    bool                 m_addedToView;
    LPOLESTR             m_clientSiteURL;
    std::map<long,MMBvr *> m_cookieMap;
    long m_cookieValue;
};

#endif /* _DAELMBASE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\daelmbase.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: timeelm.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "daelmbase.h"
#include "htmlimg.h"
#include "bodyelm.h"

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

DeclareTag(tagDATimeElmBase, "API", "CDAElementBase methods");

CDAElementBase::CDAElementBase()
: m_renderMode(INVALID_TOKEN),
  m_contentSet(false),
  m_addedToView(false),
  m_clientSiteURL(NULL),
  m_cookieValue(1)

{
    TraceTag((tagDATimeElmBase,
              "CDAElementBase(%lx)::CDAElementBase()",
              this));
}

CDAElementBase::~CDAElementBase()
{
    TraceTag((tagDATimeElmBase,
              "CDAElementBase(%lx)::~CDAElementBase()",
              this));

    delete m_clientSiteURL;
    m_clientSiteURL = NULL;
}


HRESULT
CDAElementBase::Init(IElementBehaviorSite * pBehaviorSite)
{
    TraceTag((tagDATimeElmBase,
              "CDAElementBase(%lx)::Init(%lx)",
              this,
              pBehaviorSite));
    
    HRESULT hr;

    hr = THR(CTIMEElementBase::Init(pBehaviorSite));

    if (FAILED(hr))
    {
        goto done;
    }

    {
        CRLockGrabber __gclg;
        
        m_image = (CRImagePtr) CRModifiableBvr((CRBvrPtr) CREmptyImage(),0);
        
        if (!m_image)
        {
            TraceTag((tagError,
                      "CDAElementBase(%lx)::Init(): Failed to create image switcher - %hr, %ls",
                      this,
                      CRGetLastError(),
                      CRGetLastErrorString()));
            
            hr = CRGetLastError();
            goto done;
        }
        
        m_sound = (CRSoundPtr) CRModifiableBvr((CRBvrPtr) CRSilence(),0);
        
        if (!m_sound)
        {
            TraceTag((tagError,
                      "CDAElementBase(%lx)::Init(): Failed to create sound switcher - %hr, %ls",
                      this,
                      CRGetLastError(),
                      CRGetLastErrorString()));
            
            hr = CRGetLastError();
            goto done;
        }
    }
    
    if (!m_view.Init(m_id,
                     m_image,
                     m_sound,
                     (ITIMEMMViewSite *) this))
    {
        TraceTag((tagError,
                  "CDAElementBase(%lx)::Init(): Failed to init mmview - %hr, %ls",
                  this,
                  CRGetLastError(),
                  CRGetLastErrorString()));
            
        hr = CRGetLastError();
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

STDMETHODIMP
CDAElementBase::Detach()
{
    TraceTag((tagDATimeElmBase,
              "CDAElementBase(%lx)::Detach()",
              this));
    
    HRESULT hr;

    if (m_addedToView && GetPlayer() != NULL)
    {
        GetPlayer()->RemoveView(m_view);
    }
    
    m_addedToView = false;
    
    m_view.Deinit();

    THR(CTIMEElementBase::Detach());

    hr = S_OK;

    return hr;
}

HRESULT
CDAElementBase::StartRootTime(MMTimeline * tl)
{
    TraceTag((tagDATimeElmBase,
              "CDAElementBase(%lx)::StartRootTime(%lx)",
              this,
              tl));
    
    HRESULT hr;  

    hr = THR(CTIMEElementBase::StartRootTime(tl));

    if (FAILED(hr))
    {
        goto done;
    }

    // Need to add to the player since these need to be rooted at the
    // top

    Assert(GetBody());
    
    if(m_contentSet)
    {
        if (!AddViewToPlayer())
        {
            hr = CRGetLastError();
            goto done;
        }
    }

    hr = S_OK;
  done:
    return hr;
}

bool 
CDAElementBase::AddViewToPlayer()
{
    TraceTag((tagDATimeElmBase,
              "CDAElementBase(%lx)::AddViewToPlayer()",
              this));
    
    bool ok = false;  
    
    if (!m_addedToView)
    {
        if (!GetBody()->GetPlayer().AddView(m_view))
        {
            goto done;
        }

        m_addedToView = true;
    }
    
    ok = true;
  done:
    return ok;
}


void
CDAElementBase::StopRootTime(MMTimeline * tl)
{
    TraceTag((tagDATimeElmBase,
              "CDAElementBase(%lx)::StopRootTime(%lx)",
              this,
              tl));
    
    CTIMEElementBase::StopRootTime(tl);
    
    Assert(GetBody());
    
    if (m_addedToView)
    {
        GetBody()->GetPlayer().RemoveView(m_view);
        m_addedToView = false;
    }
    
    return;
}

bool
CDAElementBase::Update()
{
    TraceTag((tagDATimeElmBase,
              "CDAElementBase(%lx)::Update()",
              this));
    
    bool ok = false;
    
    if (!CTIMEElementBase::Update())
    {
        goto done;
    }

    ok = true;
    
  done:
    return ok;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ITIMEMMViewSite

//////////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CDAElementBase::Invalidate(LPRECT prc)
{
    TraceTag((tagDATimeElmBase,
              "CDAElementBase(%lx)::Invalidate()",
              this));

    InvalidateRect(prc);

    return S_OK;
}

// THESE ARE HERE TEMPORARILY UNTIL TRIDENT UPDATES MSHTML.H
#ifndef BEHAVIORRENDERINFO_SURFACE
#define BEHAVIORRENDERINFO_SURFACE    0x100000
#endif

#ifndef BEHAVIORRENDERINFO_3DSURFACE
#define BEHAVIORRENDERINFO_3DSURFACE  0x200000;
#endif

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IElementBehaviorRender

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT
CDAElementBase::GetRenderInfo(LONG *pdwRenderInfo)
{
    TraceTag((tagDATimeElmBase,
              "CDAElementBase(%lx)::GetRenderInfo()",
              this));
    
    // Return the layers we are interested in drawing

    *pdwRenderInfo = 0;

    *pdwRenderInfo |= BEHAVIORRENDERINFO_AFTERCONTENT;
    
    // For surface from DC
    *pdwRenderInfo |= BEHAVIORRENDERINFO_SURFACE;
    *pdwRenderInfo |= BEHAVIORRENDERINFO_3DSURFACE;

    return S_OK;
}


HRESULT
CDAElementBase::Draw(HDC hdc, LONG dwLayer, LPRECT prc, IUnknown * pParams)
{
    TraceTag((tagDATimeElmBase,
              "CDAElementBase(%lx)::Draw(%#x, %#x, (%d, %d, %d, %d), %#x)",
              this,
              hdc,
              dwLayer,
              prc->left,
              prc->top,
              prc->right,
              prc->bottom,
              pParams));
    
    THR(m_view.Render(hdc, prc));

    return S_OK;
}

bool
CDAElementBase::SetImage(CRImagePtr newimg)
{
    bool ok = false;

    CRLockGrabber __gclg;

    if (!CRSwitchTo((CRBvrPtr) m_image.p,
                    (CRBvrPtr) newimg,
                    false,
                    CRContinueTimeline,
                    0.0))
    {
        TraceTag((tagError,
                  "CDAElementBase(%lx)::SetImage(): Failed to switch image  - %hr, %ls",
                  this,
                  CRGetLastError(),
                  CRGetLastErrorString()));
          
        goto done;
    }
    
    m_contentSet = true;

    if (!AddViewToPlayer())
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok;
}

bool
CDAElementBase::SetSound(CRSoundPtr newsnd)
{
    bool ok = false;

    CRLockGrabber __gclg;

    if (!CRSwitchTo((CRBvrPtr) m_sound.p,
                    (CRBvrPtr) newsnd,
                    false,
                    CRContinueTimeline,
                    0.0))
    {
        TraceTag((tagError,
                  "CDAElementBase(%lx)::SetSound(): Failed to switch sound  - %hr, %ls",
                  this,
                  CRGetLastError(),
                  CRGetLastErrorString()));
          
        goto done;
    }
    
    m_contentSet = true;

    if (!AddViewToPlayer())
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok;
}

bool 
CDAElementBase::SeekImage(double dblSeekTime)
{
    bool ok = false;
/*    CRLockGrabber __gclg;

    CRPtr<CRNumber> pSeekTime = CRCreateNumber(dblSeekTime);
    CRPtr<CRNumber> pNewLocalTme = CRAdd(pSeekTime, m_image.p->CRLocalTime());

    CRSubstituteTime(m_image.p.CRLocalTime(), pNewLocalTime);
*/
    ok = true;
//done:
    return ok;
}

//*******
// Below code is taken from DA
//*******


LPOLESTR
CDAElementBase::GetURLOfClientSite()
{
    CRLockGrabber __gclg;

    if (!m_clientSiteURL) {
        
        DAComPtr<IHTMLElementCollection> pElementCollection;
 
        if (FAILED(GetDocument()->get_all(&pElementCollection)))
            goto done;
        
        {
            CComVariant baseName;
            baseName.vt = VT_BSTR;
            baseName.bstrVal = SysAllocString(L"BASE");

            DAComPtr<IDispatch> pDispatch;
            if (FAILED(pElementCollection->tags(baseName, &pDispatch)))
                goto done;
            
            pElementCollection.Release();
            
            if (FAILED(pDispatch->QueryInterface(IID_IHTMLElementCollection,
                                                 (void **)&pElementCollection)))
                goto done;
        }

        {
            BSTR tempBstr = NULL;
            CComVariant index;
            index.vt = VT_I2;
            index.iVal = 0;
            DAComPtr<IDispatch> pDispatch;

            if (FAILED(pElementCollection->item(index,
                                                index,
                                                &pDispatch)) || !pDispatch)
            {
                if (FAILED(GetDocument()->get_URL(&tempBstr)))
                    goto done;
            }
            else
            {
                DAComPtr<IHTMLBaseElement> pBaseElement;
                if (FAILED(pDispatch->QueryInterface(IID_IHTMLBaseElement, (void **)&pBaseElement)))
                    goto done;
                
                if (FAILED(pBaseElement->get_href(&tempBstr)))
                    goto done;
            }

            m_clientSiteURL = CopyString(tempBstr);
            SysFreeString(tempBstr);
        }
    }

  done:
    if (m_clientSiteURL == NULL)
        m_clientSiteURL = CopyString(L"");
        
    return m_clientSiteURL;
} 


//*******
// Above code is taken from DA
//*******
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\eventmgr.cpp ===
///////////////////////////////////////////////////////////////
// Copyright (c) 1998 Microsoft Corporation
//
// File: EventMgr.cpp
//
// Abstract:  
//
///////////////////////////////////////////////////////////////

#include "headers.h"
#include "eventmgr.h"
#include "mshtmdid.h"
#include "eventsync.h"
#include "tokens.h"
#include "mmapi.h"
#include "axadefs.h"
#include "timeelmbase.h"
#include "bodyelm.h"

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

#define ATTACH              TRUE
#define DETACH              FALSE

DeclareTag(tagEventMgr, "API", "Event Manager methods");

struct {
    TIME_EVENT event;
    wchar_t * wsz_name;
} g_EventNames[] =
{
    { TE_ONBEGIN,           L"onbegin"            },
    { TE_ONPAUSE,           L"onpause"            },
    { TE_ONRESUME,          L"onresume"           },
    { TE_ONEND,             L"onend"              },
    { TE_ONRESYNC,          L"onresync"           },
    { TE_ONREPEAT,          L"onrepeat"           },
    { TE_ONREVERSE,         L"onreverse"          },
    { TE_ONMEDIACOMPLETE,   L"onmediacomplete"    },
    { TE_ONMEDIASLIP,       L"onmediaslip"        },
    { TE_ONMEDIALOADFAILED, L"onmedialoadfailed"  },
    { TE_ONRESET,           NULL                  },
    { TE_ONSCRIPTCOMMAND,   L"onscriptcommand"    },
    { TE_GENERIC,           NULL                  },
};

OLECHAR *g_szEventName = L"TE_EventName";
OLECHAR *g_szRepeatCount = L"Iteration";

#define GENERIC_TYPE_PARAM 1

///////////////////////////////////////////////////////////////
//  Name: CEventMgr
//  Parameters:
//    CTIMEElement  & elm
//                               This parameter must be passed
//                               to the constructor so that 
//                               we can get info from elm
//
//  Abstract:
//    Stash away the element so we can get the OM when we need it
///////////////////////////////////////////////////////////////
CEventMgr::CEventMgr(CTIMEElementBase & elm)
: m_elm(elm),
  m_dwWindowEventConPtCookie(0),
  m_dwDocumentEventConPtCookie(0),
  m_pElement(NULL),
  m_pWindow(NULL),
  m_pWndConPt(NULL),
  m_pDocConPt(NULL),
  m_refCount(0),
  m_pEventSync(NULL),
  m_lastKeyMod(0),
  m_lastKey(0),
  m_lastKeyCount(0),
  m_hwndCurWnd(0),
  m_lastX(0),
  m_lastY(0),
  m_lastButton(0),
  m_lastMouseMod(0),
  m_pBeginElement(NULL),
  m_pEndElement(NULL),
  m_lBeginEventCount(0),
  m_lEndEventCount(0),
  m_bAttached(FALSE),
  m_lRepeatCount(0),
  m_dispDocBeginEventIDs(NULL),
  m_dispDocEndEventIDs(NULL), 
  m_lastEventTime(0),
  m_pScriptCommandBegin(NULL),
  m_pScriptCommandEnd(NULL),
  m_bLastEventClick(false)
{
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::EventMgr(%lx)",
              this,
              &elm));

    // Zero out the cookies
    memset(m_cookies, 0, sizeof(m_cookies));

}

///////////////////////////////////////////////////////////////
//  Name: ~CEventMgr
//
//  Abstract:
//    Cleanup
///////////////////////////////////////////////////////////////
CEventMgr::~CEventMgr()
{
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::~EventMgr()",
              this));
}


///////////////////////////////////////////////////////////////
//  Name: Fire_Event
//  Parameters:
//    TIME_EVENT TimeEvent     An enumeration value to indicate 
//                             which event should be fired.
//    long Count               The count of parameters to use
//    LPWSTR szParamNames[]    The names of the parameters to create.
//    VARIANT varParams[]      An array of VARIANTS that can
//                             be used to indicate the parameters
//                             to pass to an event.  
//
//  Abstract:
//
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::FireEvent(TIME_EVENT TimeEvent, 
                             long lCount, 
                             LPWSTR szParamNames[], 
                             VARIANT varParams[])
{
    HRESULT hr = S_OK;
    DAComPtr <IHTMLEventObj> pEventObj;
    DAComPtr <IHTMLEventObj2> pEventObj2;
    IElementBehaviorSiteOM * pBvrSiteOM = m_elm.GetBvrSiteOM();
    WCHAR *pwszGenericName = NULL;
    long lGenericCookie = 0;

    Assert(TimeEvent < ARRAY_SIZE(g_EventNames));
    
    // This is not a fireable event - skip
    if ((g_EventNames[TimeEvent].wsz_name == NULL) && (TE_GENERIC != TimeEvent))
    {
        goto done;
    }

    // It better be valid
    Assert (pBvrSiteOM);
    
    if (!pBvrSiteOM) //this is possible in a multi-refresh condition.
    {
        goto done;
    }

    // if this is a generic event, see if we have already registered it.
    // if so, use that cookie.  Otherwise, register this.
    if (TE_GENERIC == TimeEvent)
    {
        if (varParams[GENERIC_TYPE_PARAM].bstrVal == NULL)
        {
            hr = E_INVALIDARG;
            goto done;
        }

        // build string name - "on" + scType + NULL
        pwszGenericName = NEW WCHAR[lstrlenW(varParams[GENERIC_TYPE_PARAM].bstrVal)+(2*sizeof(WCHAR))+sizeof(WCHAR)];
        if (pwszGenericName == NULL)
        {
            TraceTag((tagError, "CEventMgr::FireEvent - unable to alloc mem for string"));
            hr = E_OUTOFMEMORY;
            goto done;
        }
        lstrcpyW(pwszGenericName, L"on");
        lstrcatW(pwszGenericName, varParams[GENERIC_TYPE_PARAM].bstrVal);

        hr = THR(pBvrSiteOM->GetEventCookie(pwszGenericName, &lGenericCookie));
        if (FAILED(hr))
        {
            hr = THR(pBvrSiteOM->RegisterEvent(pwszGenericName, 0, &lGenericCookie));
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }
    
    hr = THR(pBvrSiteOM->CreateEventObject(&pEventObj));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void**)&pEventObj2));
    if (FAILED(hr))
    {
        goto done;
    }
	
	//hack to work around event naming problem
    //this sets an attribute so that we can sync to it
    VARIANT bstrTemp;
    VariantInit(&bstrTemp);
    bstrTemp.vt = VT_BSTR;
    if (TE_GENERIC != TimeEvent)
    {
        bstrTemp.bstrVal = SysAllocString(g_EventNames[TimeEvent].wsz_name);
    }
    else
    {
        bstrTemp.bstrVal = SysAllocString(pwszGenericName);
    }

    if (bstrTemp.bstrVal == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    IGNORE_HR(pEventObj2->setAttribute(g_szEventName, bstrTemp));
    VariantClear(&bstrTemp);
    ////////////////////////////////////////////////////

    // unload param list into the setAttribute
    if (lCount > 0)
    {
        for (long i = 0; i < lCount; i++)
        {
            hr = THR(pEventObj2->setAttribute(szParamNames[i], varParams[i]));
            if (FAILED(hr))
            {
                goto done;
            }
        }
    } 

    //if this is a TE_REPEAT event, add support for current repeat count
    if (TimeEvent == TE_ONREPEAT)
    {
        VARIANT vRepCount;
        VariantInit (&vRepCount);
        vRepCount.vt = VT_I4;
        m_lRepeatCount++;
        vRepCount.lVal = m_lRepeatCount;       

        IGNORE_HR(pEventObj2->setAttribute(g_szRepeatCount, vRepCount));
    }
    else if (TimeEvent == TE_ONBEGIN || TimeEvent == TE_ONRESET) //reset the repeat count on begin
    {
        m_lRepeatCount = 0;
    }

    {
        //set the event object type
        BSTR bstrType = NULL;
        
        if (TE_GENERIC != TimeEvent)
        {
            // remove the "on" from the event name
            bstrType = SysAllocString(g_EventNames[TimeEvent].wsz_name + 2);
        }
        else
        {
            Assert(varParams[GENERIC_TYPE_PARAM].vt == VT_BSTR);
            bstrType = SysAllocString(varParams[GENERIC_TYPE_PARAM].bstrVal);
        }

        if (bstrType != NULL)
        {
            IGNORE_HR(pEventObj2->put_type(bstrType));
            SysFreeString(bstrType);
        }
        else 
        {
            // we were unable to set the type, bail!
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    {
        long lCookie = 0;

        if (TE_GENERIC != TimeEvent)
        {
            Assert(TimeEvent < ARRAY_SIZE(m_cookies));
            lCookie = m_cookies[TimeEvent];
        }
        else
        {
            lCookie = lGenericCookie;
        }

        hr = THR(pBvrSiteOM->FireEvent(lCookie, pEventObj));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    // if this is a ScriptCommand event, call FireEvent again
    // with the generic event.
    if (TimeEvent == TE_ONSCRIPTCOMMAND)
    {
        hr = FireEvent(TE_GENERIC, lCount, szParamNames, varParams);
        if (FAILED(hr))
            goto done;
    }

    hr = S_OK;

  done:
    delete pwszGenericName; 
    pwszGenericName = NULL;
    return hr;
}
   
///////////////////////////////////////////////////////////////
//  Name:  Init
//  Parameters:  None
//
//  Abstract:
//    Initializes the object
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::Init()
{
    HRESULT hr;
    DAComPtr <IDispatch> pDisp;
    DAComPtr <IHTMLDocument2> pDoc;

    m_pElement = m_elm.GetElement();
    m_pElement->AddRef();

    m_pEventSync = NEW CEventSync(m_elm, this);
    if (NULL == m_pEventSync)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    m_pEventSync->Init();

    hr = THR(RegisterEvents());

    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = THR(ConnectToContainerConnectionPoint());

    if (FAILED(hr))
    {
        goto done;
    }

    //get a pointer to the window
    hr = THR(m_pElement->get_document(&pDisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDisp->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDoc->get_parentWindow(&m_pWindow));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

  done:
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name:  Deinit
//  Parameters:  None
//
//  Abstract:
//    Cleans up the object
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::Deinit()
{
    THR(DetachEvents());

    if (m_dwWindowEventConPtCookie != 0 && m_pWndConPt)
    {
        m_pWndConPt->Unadvise (m_dwWindowEventConPtCookie);
    }

    if (m_dwDocumentEventConPtCookie != 0 && m_pDocConPt)
    {
        m_pDocConPt->Unadvise (m_dwDocumentEventConPtCookie);
    }

    if (m_pScriptCommandBegin)
    {
        delete [] m_pScriptCommandBegin;
    }
    if (m_pScriptCommandEnd)
    {
        delete [] m_pScriptCommandEnd;
    }
    if (m_pEventSync)
    {
        m_pEventSync->Deinit();
        delete m_pEventSync;
        m_pEventSync = NULL;
    }

    m_dwWindowEventConPtCookie = 0;
    m_dwDocumentEventConPtCookie = 0;

    // Zero out the cookies
    memset(m_cookies, 0, sizeof(m_cookies));
    
    if (m_pElement)
    {
        m_pElement->Release();
        m_pElement = NULL;
    }

    //cleanup memory
    if (m_pBeginElement)
    {
        // Cycle through the elements and release the interfaces
        // NOTE: this should be cleaned up in DetachEvents.
        for (int i = 0; i < m_lBeginEventCount; i++)
        {
            if (m_pBeginElement[i] != NULL)
                m_pBeginElement[i]->Release();
        }

        delete [] m_pBeginElement;
        m_pBeginElement = NULL;

        m_lBeginEventCount = 0;
    }
    if (m_pEndElement)
    {
        // Cycle through the elements and release the interfaces
        // NOTE: this should be cleaned up in DetachEvents.
        for (int i = 0; i < m_lEndEventCount; i++)
        {
            if (m_pEndElement[i] != NULL)
                m_pEndElement[i]->Release();
        }
        
        delete [] m_pEndElement;
        m_pEndElement = NULL;

        m_lEndEventCount = 0;
    }

    if (m_dispDocBeginEventIDs)
    {
        delete [] m_dispDocBeginEventIDs;
    }
    if (m_dispDocEndEventIDs)
    {
        delete [] m_dispDocEndEventIDs;
    }

    // Release all references to trident.
    m_pDocConPt.Release();
    m_pWndConPt.Release();
    m_pWindow.Release();

    return S_OK;
}

///////////////////////////////////////////////////////////////
//  Name:  RegisterEvents
//  Parameters:  None
//
//  Abstract:
//    Registers the events that will be used by this class.
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::RegisterEvents()
{
    HRESULT hr = S_OK;

    IElementBehaviorSiteOM * pBvrSiteOM = m_elm.GetBvrSiteOM();

    // It better be valid
    Assert (pBvrSiteOM);
    
    for (int i = 0; i < ARRAY_SIZE(g_EventNames); i++)
    {
        if (g_EventNames[i].wsz_name != NULL)
        {
            Assert(g_EventNames[i].event < ARRAY_SIZE(m_cookies));
            
            hr = THR(pBvrSiteOM->RegisterEvent(g_EventNames[i].wsz_name,
                                               0,
                                               (long *) &m_cookies[g_EventNames[i].event]));
            
            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

  done:
    return hr;
}


///////////////////////////////////////////////////////////////
//  Name: AttachEvents
// 
//  Abstract:
//    Gets and caches the begin event and end events for this
//    behavior.  It then calls attach to hook the events
//    specified in BeginEvent and EndEvent.
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::AttachEvents()
{
    //Determine the current Ready State of the document.
    DAComPtr <IHTMLElement2> pEle2;
    VARIANT vReadyState;
    HRESULT hr = S_OK;

    VariantInit(&vReadyState);
    Assert (m_pElement);
    hr = THR(m_pElement->QueryInterface(IID_IHTMLElement2, (void**)&pEle2));
    if (SUCCEEDED(hr))
    {
        hr = THR(pEle2->get_readyState(&vReadyState));
        if (SUCCEEDED(hr))
        {
            TOKEN CurReadyState = StringToToken(vReadyState.bstrVal);
            if (CurReadyState == READYSTATE_COMPLETE_TOKEN)
            {                         
                //if the ready state is "complete" then attach to the events.
                m_bAttached = TRUE;
            } 
            else
            {
                goto done;
            }
        }
    }

    if (m_elm.GetBeginEvent())
    {
        BSTR bstr = SysAllocString(m_elm.GetBeginEvent());

        if (bstr)
        {
            m_lBeginEventCount = GetEventCount(bstr);
            m_dispDocBeginEventIDs = NEW DISPID [m_lBeginEventCount];
            m_pBeginElement = NEW IHTMLElement2* [m_lBeginEventCount];
            if (m_pScriptCommandBegin)
            {
                delete [] m_pScriptCommandBegin;
            }
            m_pScriptCommandBegin = NEW bool [m_lBeginEventCount];

            if (m_pBeginElement == NULL || m_pScriptCommandBegin == NULL)
            {
                m_lBeginEventCount = 0;
                hr = E_FAIL;
                goto done;
            }
            ZeroMemory(m_pBeginElement, sizeof(IHTMLElement2 *) * m_lBeginEventCount);

            hr = THR(Attach(bstr, ATTACH, m_pBeginElement, m_lBeginEventCount, TRUE, m_dispDocBeginEventIDs, m_pScriptCommandBegin));
        }

        SysFreeString(bstr);
    }
    
    if (m_elm.GetEndEvent())
    {
        BSTR bstr = SysAllocString(m_elm.GetEndEvent());

        if (bstr)
        {
            m_lEndEventCount = GetEventCount(bstr);
            m_dispDocEndEventIDs = NEW DISPID [m_lEndEventCount];
            m_pEndElement = NEW IHTMLElement2* [m_lEndEventCount];
            if (m_pScriptCommandEnd)
            {
                delete [] m_pScriptCommandEnd;
            }
            m_pScriptCommandEnd = NEW bool [m_lEndEventCount];

            if (m_pEndElement == NULL || m_pScriptCommandEnd == NULL)
            {
                m_lEndEventCount = 0;
                hr = E_FAIL;
                goto done;
            }
            ZeroMemory(m_pEndElement, sizeof(IHTMLElement2 *) * m_lEndEventCount);

            hr = THR(Attach(bstr, ATTACH, m_pEndElement, m_lEndEventCount, FALSE, m_dispDocEndEventIDs, m_pScriptCommandEnd));
        }

        SysFreeString(bstr);
    }
  done:
    VariantClear(&vReadyState);
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: Attach
// 
//  Parameters:
//    BSTR Event        The element and event to sink to.  This
//                      parameter is in the form "Element.Event"
//                      where element is "this" if an event from
//                      the current element is to be attached to.
//    BOOL bAttach      True to indicate Attach to this event, and
//                      false to indicate Detach from this event.
//
//    BOOL bAttachAll   True indicates that all events in the list 
//                      should be attached to.  False indicates that
//                      only those events that differ from the beginEvent
//                      list should be attached to.
//
//  Abstract:
//    This is a generic routine that allows both attaching to
//    and detaching from Trident events.  This function decodes
//    the event name to find the correct element
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::Attach(BSTR Event, 
                          BOOL bAttach, 
                          IHTMLElement2 *pEventElement[], 
                          long Count, 
                          BOOL bAttachAll,
                          DISPID *dispIDList,
                          bool ScriptCommandAttach[])
{
    VARIANT_BOOL bSuccess = FALSE;
    HRESULT hr = S_OK;
    BSTR *EventName = NULL;
    BSTR *ElementName = NULL;
    int i = 0;
    BSTR EventList = SysAllocString(m_elm.GetBeginEvent());

    hr = THR(GetEventName(Event, &ElementName, &EventName, Count));
    if (FAILED(hr))
    {
        goto done;
    }

    for (i = 0; i < Count; i++)
    {
        dispIDList[i] = -1; //invalid dispid
        int nInList = IsEventInList(ElementName[i], EventName[i], m_lBeginEventCount, EventList);
        if (bAttachAll || (nInList == -1))
        {
            if (bAttach == ATTACH)
            {
                DAComPtr <IHTMLElement2> pSrcEle;
                DAComPtr <IHTMLDocument2> pDoc2;
                DAComPtr <IHTMLElementCollection> pEleCol;
                DAComPtr <IDispatch> pSrcDisp;
                DAComPtr <IDispatch> pDocDisp;
                DAComPtr <IDispatchEx> pDispEx;

                //get the document
                hr = THR(m_pElement->get_document(&pDocDisp));
                if (FAILED(hr))
                {
                    continue;
                }

                hr = THR(pDocDisp->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc2));
                if (FAILED(hr))
                {
                    continue;
                }

                if (StrCmpIW(ElementName[i], L"document") == 0)
                {

                    DISPID dispid;
                    DAComPtr <ITypeLib> pTypeLib;
                    DAComPtr <ITypeInfo> pTypeInfo;
                    DAComPtr <ITypeInfo> pTypeInfoEvents;
                    DAComPtr <IDispatch> pDispatch;
                    unsigned int index = 0;

                    //This code loads the typelib for the IHTMLDocument2 interface,
                    //and gets the ID for the event from the type info for the
                    //HTMLDocumentEvents dispinterface.
                    hr = THR(pDoc2->QueryInterface(IID_IDispatch, (void**)&pDispatch));
                    if (FAILED(hr))
                    {
                        continue;
                    }

                    hr = THR(pDispatch->GetTypeInfo(0, LCID_SCRIPTING, &pTypeInfo));
                    if (FAILED(hr))
                    {
                        continue;
                    }

                    hr = THR(pTypeInfo->GetContainingTypeLib(&pTypeLib, &index));
                    if (FAILED(hr))
                    {
                        continue;
                    }

                    hr = THR(pTypeLib->GetTypeInfoOfGuid(DIID_HTMLDocumentEvents, &pTypeInfoEvents));
                    if (FAILED(hr))
                    {
                        continue;
                    }

                    hr = THR(pTypeInfoEvents->GetIDsOfNames(&EventName[i], 1, &dispid));
                    if (FAILED(hr))
                    {
                        continue;
                    }

                    dispIDList[i] = dispid; 
                    continue; 
                }

                //get all elements in the document
                hr = THR(pDoc2->get_all(&pEleCol));
                if (FAILED(hr))
                {
                    continue;
                }

                //find the element with the correct name
                VARIANT vName;
                VARIANT vIndex;

                VariantInit(&vName);
                vName.vt = VT_BSTR;
                vName.bstrVal = SysAllocString(ElementName[i]);

                VariantInit(&vIndex);
                vIndex.vt = VT_I2;
                vIndex.iVal = 0;

                hr = THR(pEleCol->item(vName, vIndex, &pSrcDisp));
                if (FAILED(hr))
                {
                    VariantClear(&vName);
                    VariantClear(&vIndex);
                    continue;
                }
                VariantClear(&vName);
                VariantClear(&vIndex);

                if (!pSrcDisp) //will be NULL if the vName is invalid element.
                {
                    pEventElement[i] = NULL;
                    continue;
                }

                hr = THR(pSrcDisp->QueryInterface(IID_IHTMLElement2, (void**)&pSrcEle));
                if (FAILED(hr))
                {
                    continue;
                }

                //cache the IHTMLElement2 pointer for use on detach
                pEventElement[i] = pSrcEle;
                pEventElement[i]->AddRef();

                hr = THR(pSrcDisp->QueryInterface(IID_IDispatchEx, (void**)&pDispEx));
                if (SUCCEEDED(hr))
                {
                    //determine if this is a valid event
                    DISPID temp;

                    hr = THR(pDispEx->GetDispID(EventName[i], fdexNameCaseSensitive, &temp));
                    if (SUCCEEDED(hr))
                    {
                        ScriptCommandAttach[i] = false;
                        hr = THR(pSrcEle->attachEvent(EventName[i], (IDispatch *)this, &bSuccess));
                    }
                    else //this is not currently a valid event, but it could be a custom event.
                    {    //so TIME needs to attach to the onScriptCommand event to be able to catch custom events.
                        ScriptCommandAttach[i] = true;
                        BSTR ScriptEvent = SysAllocString(g_EventNames[TE_ONSCRIPTCOMMAND].wsz_name);
                        IGNORE_HR(pSrcEle->attachEvent(ScriptEvent, (IDispatch *)this, &bSuccess));
                        SysFreeString (ScriptEvent);
                    }
                }
            }
            else
            {
                if (pEventElement[i])
                {
                    DAComPtr <IDispatchEx> pDispEx;

                    hr = THR(pEventElement[i]->QueryInterface(IID_IDispatchEx, (void**)&pDispEx));
                    if (SUCCEEDED(hr))
                    {
                        //determine if this is a valid event
                        DISPID temp;
                        if (ScriptCommandAttach[i] == true)
                        {
                            BSTR ScriptEvent = SysAllocString(g_EventNames[TE_ONSCRIPTCOMMAND].wsz_name);
                            IGNORE_HR(pEventElement[i]->detachEvent(ScriptEvent, (IDispatch *)this));
                            SysFreeString(ScriptEvent);
                        }
                        else
                        {
                            hr = THR(pDispEx->GetDispID(EventName[i], fdexNameCaseSensitive, &temp));
                            if (SUCCEEDED(hr))
                            {
                                hr = THR(pEventElement[i]->detachEvent(EventName[i], (IDispatch *)this));
                            }
                        }
                    }
                    pEventElement[i]->Release();
                    pEventElement[i] = NULL;
                }
            }
        }
        else //this is an EndEvent with the event already in the beginEvent list
        {
            if (m_dispDocEndEventIDs && m_dispDocBeginEventIDs)
            {
                m_dispDocEndEventIDs[i] = m_dispDocBeginEventIDs[nInList];
            }
        }
    }
  done:

    if (EventList)
    {
        SysFreeString(EventList);
    }
    if (EventName)
    {
        for (i = 0; i < Count; i++)
        {
            SysFreeString(EventName[i]);
            SysFreeString(ElementName[i]);
        }
        delete [] EventName;
        delete [] ElementName;
    }
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: DetachEvents
// 
//  Abstract:
//    Simply checks the cached begin and end event strings and
//    calls Attach with the detach parameter to release the
//    events.
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::DetachEvents()
{
    HRESULT hr = S_OK;

    
    //if this is called before to object is loaded ignore the call
    if (!m_bAttached)
    {
        goto done;
    }

    if (m_elm.GetBeginEvent())
    {
        BSTR bstr = SysAllocString(m_elm.GetBeginEvent());


        if (bstr)
        {
            hr = THR(Attach(bstr, DETACH, m_pBeginElement, m_lBeginEventCount, TRUE, m_dispDocBeginEventIDs, m_pScriptCommandBegin));
        }

        SysFreeString(bstr);
    }

    if (m_pBeginElement)
    {
        delete [] m_pBeginElement;
        m_pBeginElement = NULL;
        m_lBeginEventCount = 0;
    }
    
    if (m_elm.GetEndEvent())
    {
        BSTR bstr = SysAllocString(m_elm.GetEndEvent());

        if (bstr)
        {
            hr = THR(Attach(bstr, DETACH, m_pEndElement, m_lEndEventCount, FALSE, m_dispDocEndEventIDs, m_pScriptCommandEnd));
        }

        SysFreeString(bstr);
    }

    if (m_pEndElement)
    {
        delete [] m_pEndElement;
        m_pEndElement = NULL;
        m_lEndEventCount = 0;
    }
  done:
    return hr;
}


///////////////////////////////////////////////////////////////
//  Name: ConnectToContainerConnectionPoint
// 
//  Abstract:
//    Finds a connection point on the HTMLDocument interface
//    and passes this as an event handler.
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::ConnectToContainerConnectionPoint()
{
    // Get a connection point to the container
    DAComPtr<IConnectionPointContainer> pWndCPC;
    DAComPtr<IConnectionPointContainer> pDocCPC; 
    DAComPtr<IHTMLDocument> pDoc; 
    DAComPtr<IDispatch> pDocDispatch;
    DAComPtr<IDispatch> pScriptDispatch;

    HRESULT hr;

    hr = THR(m_pElement->get_document(&pDocDispatch));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //get the document and cache it.
    hr = THR(pDocDispatch->QueryInterface(IID_IHTMLDocument, (void**)&pDoc));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //hook the documents events
    hr = THR(pDoc->QueryInterface(IID_IConnectionPointContainer, (void**)&pDocCPC));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(pDocCPC->FindConnectionPoint( DIID_HTMLDocumentEvents, &m_pDocConPt ));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    
    hr = THR(m_pDocConPt->Advise((IUnknown *)this, &m_dwDocumentEventConPtCookie));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    //hook the windows events
    hr = THR(pDoc->get_Script (&pScriptDispatch));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(pScriptDispatch->QueryInterface(IID_IConnectionPointContainer, (void**)&pWndCPC));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    } 

    hr = THR(pWndCPC->FindConnectionPoint( DIID_HTMLWindowEvents, &m_pWndConPt ));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_pWndConPt->Advise((IUnknown *)this, &m_dwWindowEventConPtCookie));
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;  
}


///////////////////////////////////////////////////////////////
//  Name: QueryInterface
// 
//  Abstract:
//    This QI only handles the IDispatch for HTMLWindowEvents
//    and returns this as the interface.
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::QueryInterface( REFIID riid, void **ppv )
{
    if (NULL == ppv)
        return E_POINTER;

    *ppv = NULL;

    if ( InlineIsEqualGUID(riid, IID_IDispatch) || InlineIsEqualGUID(riid, DIID_HTMLWindowEvents))
    {
        *ppv = this;
    }
        
    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;
}

///////////////////////////////////////////////////////////////
//  Name: AddRef
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch  
///////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CEventMgr::AddRef(void)
{
        return m_elm.InternalAddRef();
}

///////////////////////////////////////////////////////////////
//  Name: Release
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CEventMgr::Release(void)
{
        return m_elm.InternalRelease();
}



///////////////////////////////////////////////////////////////
//  Name: GetTypeInfoCount
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: GetTypeInfo
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
                                   /* [in] */ LCID /*lcid*/,
                                   /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: GetIDsOfNames
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::GetIDsOfNames(
    /* [in] */ REFIID /*riid*/,
    /* [size_is][in] */ LPOLESTR* /*rgszNames*/,
    /* [in] */ UINT /*cNames*/,
    /* [in] */ LCID /*lcid*/,
    /* [size_is][out] */ DISPID* /*rgDispId*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: Invoke
// 
//  Abstract:
//    This switches on the dispid looking for dispid's of events
//    that it should handle.  Note, this is called for all events
//    fired from the window, only the selected events are handled.
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventMgr::Invoke(
    /* [in] */ DISPID dispIdMember,
    /* [in] */ REFIID /*riid*/,
    /* [in] */ LCID /*lcid*/,
    /* [in] */ WORD /*wFlags*/,
    /* [out][in] */ DISPPARAMS* pDispParams,
    /* [out] */ VARIANT* pVarResult,
    /* [out] */ EXCEPINFO* /*pExcepInfo*/,
    /* [out] */ UINT* puArgErr)
{
    // Listen for the two events we're interested in, and call back if necessary
    HRESULT hr = S_OK;
    bool bBeginEventMatch = false;
    bool bEndEventMatch = false;
    int i = 0;

    for (i = 0; i < m_lBeginEventCount; i++)
    {
        if (m_dispDocBeginEventIDs[i] == dispIdMember)
        {
            bool fShouldFire;
            hr = ShouldFireThisEvent(&fShouldFire);
            if (FAILED(hr))
            {
                goto done;
            }

            if (!fShouldFire)
            {
                continue;
            }
            
            bBeginEventMatch = true;
        }
    }
    
    for (i = 0; i < m_lEndEventCount; i++)
    {
        if (m_dispDocEndEventIDs[i] == dispIdMember)
        {
            bool fShouldFire;
            hr = ShouldFireThisEvent(&fShouldFire);
            if (FAILED(hr))
            {
                goto done;
            }
            
            if (!fShouldFire)
            {
                continue;
            }

            bEndEventMatch = true;                        
        }
    }       


    if (bBeginEventMatch || bEndEventMatch)
    {
        if (dispIdMember == DISPID_HTMLDOCUMENTEVENTS_ONMOUSEOUT)
        {
            if (RequireEventValidation())
            {
                // In the case of a mouse out from the document, the toElement should be NULL
                // If is not, set matches to false
                DAComPtr <IHTMLEventObj> pEventObj;
                hr = THR(m_pWindow->get_event(&pEventObj));
                if (SUCCEEDED(hr))
                {
                    DAComPtr <IHTMLElement> pToElement;
                    hr = THR(pEventObj->get_toElement(&pToElement));
                    if (SUCCEEDED(hr) && pToElement)
                    {
                            bBeginEventMatch = bEndEventMatch = false;
                    }
                }
            }
        }
        else if (dispIdMember == DISPID_HTMLDOCUMENTEVENTS_ONMOUSEOVER)
        {
            if (RequireEventValidation())
            {
                // In the case of a mouse over from the document, the fromElement should be NULL
                // If it is not, set matches to false
                DAComPtr <IHTMLEventObj> pEventObj;
                hr = THR(m_pWindow->get_event(&pEventObj));
                if (SUCCEEDED(hr))
                {
                    DAComPtr <IHTMLElement> pFromElement;
                    hr = THR(pEventObj->get_fromElement(&pFromElement));
                    if (SUCCEEDED(hr) && pFromElement)
                    {
                        bBeginEventMatch = bEndEventMatch = false;
                    }
                }
            }
        }
    }

    switch (dispIdMember)
    {
        case 0: //this is the case for events that have been hooked using attachEvent
        {
            DAComPtr <IHTMLEventObj> pEventObj;
            BSTR bstrEventName;

            if ((NULL != pDispParams) && (NULL != pDispParams->rgvarg) &&
                (V_VT(&(pDispParams->rgvarg[0])) == VT_DISPATCH))
            {
                hr = THR((pDispParams->rgvarg[0].pdispVal)->QueryInterface(IID_IHTMLEventObj, (void**)&pEventObj));
                if (FAILED(hr))
                {
                    goto done;
                }
            }
            else
            {
                Assert(0 && "Unexpected dispparam values passed to CEventMgr::Invoke(dispid = 0)");
                hr = E_UNEXPECTED;
                goto done;
            }
            
            hr = THR(pEventObj->get_type(&bstrEventName));
            //
            // #40194 -- in paused state don't allow mouse or click events to fire
            //
            if (m_elm.GetBody() != NULL)
            {
                if (m_elm.GetBody()->IsPaused() )
                {
                    if (!IsValidEventInPausedAndEditMode(bstrEventName))
                    {
                        break;
                    }
                }
            }

            m_bLastEventClick = false;
            if (SUCCEEDED(hr))
            {
                if (StrCmpIW(bstrEventName, L"click") == 0)
                {
                    m_bLastEventClick = true;       
                }
            }
            SysFreeString(bstrEventName);

            //determine if this is the beginEvent
            if (m_elm.GetBeginEvent())
            {
                BSTR bstr = SysAllocString(m_elm.GetBeginEvent());
                
                if (bstr)
                {
                    bBeginEventMatch = MatchEvent(bstr, pEventObj, m_lBeginEventCount, m_pScriptCommandBegin);
                }
                
                SysFreeString(bstr);
            }

            //determine if this is the endEvent
            if (m_elm.GetEndEvent())
            {
                BSTR bstr = SysAllocString(m_elm.GetEndEvent());
                
                if (bstr)
                {
                    bEndEventMatch = MatchEvent(bstr, pEventObj, m_lEndEventCount, m_pScriptCommandEnd);
                }
                
                SysFreeString(bstr);
            }        
            break;
        }
        
        case DISPID_EVPROP_ONPROPERTYCHANGE:
        case DISPID_EVMETH_ONPROPERTYCHANGE:
            break;

        case DISPID_EVPROP_ONMOUSEMOVE:
        case DISPID_EVMETH_ONMOUSEMOVE:
            if (m_hwndCurWnd != 0 && m_pWindow)
            {
                DAComPtr <IHTMLEventObj> pEventObj;
                long x, y, button;
                VARIANT_BOOL bMove, bUp, bShift, bAlt, bCtrl;

                hr = THR(m_pWindow->get_event(&pEventObj));
                if (FAILED (hr))
                {
                    break;
                }
                
                bMove = TRUE;
                bUp = FALSE;
                hr = THR(pEventObj->get_x(&x));
                hr = THR(pEventObj->get_y(&y));
                hr = THR(pEventObj->get_shiftKey(&bShift));
                hr = THR(pEventObj->get_altKey(&bAlt));
                hr = THR(pEventObj->get_ctrlKey(&bCtrl));
                hr = THR(pEventObj->get_button(&button));
                MouseEvent(x, y, bMove, bUp, bShift, bAlt, bCtrl, button);
                
                VariantInit(pVarResult);
                pVarResult->vt = VT_BOOL;
                pVarResult->boolVal = VARIANT_TRUE;
            }
            break;

        case DISPID_EVPROP_ONMOUSEUP:
        case DISPID_EVMETH_ONMOUSEUP:
            if (m_hwndCurWnd != 0 && m_pWindow)
            {
                DAComPtr <IHTMLEventObj> pEventObj;
                long x, y, button;
                VARIANT_BOOL bMove, bUp, bShift, bAlt, bCtrl;

                hr = THR(m_pWindow->get_event(&pEventObj));
                if (FAILED (hr))
                {
                    break;
                }
                
                bMove = FALSE;
                bUp = TRUE;
                hr = THR(pEventObj->get_x(&x));
                hr = THR(pEventObj->get_y(&y));
                hr = THR(pEventObj->get_shiftKey(&bShift));
                hr = THR(pEventObj->get_altKey(&bAlt));
                hr = THR(pEventObj->get_ctrlKey(&bCtrl));
                hr = THR(pEventObj->get_button(&button));
                MouseEvent(x, y, bMove, bUp, bShift, bAlt, bCtrl, button);
                
                VariantInit(pVarResult);
                pVarResult->vt = VT_BOOL;
                pVarResult->boolVal = VARIANT_TRUE;
            }
            break;

 
        case DISPID_EVPROP_ONMOUSEOUT:
        case DISPID_EVMETH_ONMOUSEOUT:
            if (m_hwndCurWnd != 0 && m_pWindow)
            {
                DAComPtr <IHTMLEventObj> pEventObj;
                
                hr = THR(m_pWindow->get_event(&pEventObj));
                if (FAILED (hr))
                {
                    break;
                }
                
                MouseEvent(m_lastX, 
                           m_lastY, 
                           FALSE, 
                           TRUE, 
                           m_lastMouseMod & AXAEMOD_SHIFT_MASK, 
                           m_lastMouseMod & AXAEMOD_ALT_MASK, 
                           m_lastMouseMod & AXAEMOD_CTRL_MASK, 
                           m_lastButton);

                VariantInit(pVarResult);
                pVarResult->vt = VT_BOOL;
                pVarResult->boolVal = VARIANT_TRUE;
            }
        
            break;

        case DISPID_EVPROP_ONLOAD:
        case DISPID_EVMETH_ONLOAD:
            m_elm.OnLoad();
            if (m_pEventSync)
            {
                IGNORE_HR(m_pEventSync->InitMouse());
            }
            break;

        case DISPID_EVPROP_ONUNLOAD:
        case DISPID_EVMETH_ONUNLOAD:
            m_elm.OnBeforeUnload();  //signal that the element is unloading now.  No further events
                                     //will be fired.
            m_elm.OnUnload();    
            break;

        case DISPID_EVPROP_ONSTOP:
        case DISPID_EVMETH_ONSTOP:
            // if we are the Body, call pause
            if (m_elm.IsBody())
                THR(m_elm.base_pause());

            // BUGBUG - need to turn clock services off.
            break;
            
        case DISPID_EVPROP_ONREADYSTATECHANGE:
        case DISPID_EVMETH_ONREADYSTATECHANGE:
            //have to detach here because it is possible that the events have been attach before this
            //event is received.
            IGNORE_HR(DetachEvents());
            IGNORE_HR(AttachEvents());            
            break;

    }

    //handle a begin or end Event.
    if (bBeginEventMatch || bEndEventMatch)
    {
        BeginEndFired(bBeginEventMatch, bEndEventMatch, dispIdMember);
    }
        
  done:
    return S_OK;
}




///////////////////////////////////////////////////////////////
//  Name: GetEventCount
// 
//  Abstract:
//    Counts the number of events in an EventString where events
//    are separated by ';' or NULL terminated.
///////////////////////////////////////////////////////////////
long CEventMgr::GetEventCount(BSTR bstrEvent)
{
    long curCount = 0;
    OLECHAR *curChar;
    UINT strLen = 0;

    strLen = SysStringLen(bstrEvent);
    OLECHAR *szEvent = NEW OLECHAR [strLen + 1];
    if (szEvent == NULL)
    {
        return 0;
    }

    curChar = bstrEvent;

    //strip out ' '
    while (*curChar != '\0' && curCount < strLen)
    {
        if (*curChar != ' ')
        {
            szEvent[curCount] = *curChar;
            curCount++;
        }
        curChar++;
    }
    szEvent[curCount] = '\0';

    curCount = 0;
    curChar = szEvent;
    while (*curChar != '\0')
    {
        curChar++;
        if ((*curChar == ';') || ((*curChar == '\0') && ((*curChar - 1) != ';')))
        {
            curCount++;
        }
    }
    //determine if the end character was a ';'.
    if (*(curChar - 1) == ';')
    {
        curCount--;
    }   

    delete [] szEvent;
    return curCount;
}


///////////////////////////////////////////////////////////////
//  Name: GetEventName
// 
//  Abstract:
//    This gets the event names from a string that has the format
//    EventName()  It only handles strings like 
//    ElementName.EventName().  It can also handle the OR'ing of
//    event names using ";".  So Element1.Event1();Element2.Event2();...
//    can be handled.
///////////////////////////////////////////////////////////////
HRESULT CEventMgr::GetEventName(BSTR bstrEvent, BSTR **pElementName, BSTR **pEventName, long Count)
{
    BSTR bstrEventName;
    UINT strLen = 0;
    OLECHAR *curChar;
    int i = 0, j = 0;
    HRESULT hr = S_OK;
    BSTR bstrTempEvent = NULL;
    BSTR bstrTempElement = NULL;

    BSTR *bstrEventList = NULL;
    BSTR *bstrElementList = NULL;

    strLen = SysStringLen(bstrEvent);
    OLECHAR *sTemp = NEW OLECHAR [strLen + 1];
    if (sTemp == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    bstrElementList = NEW BSTR [Count];
    if (bstrElementList == NULL)
    {
        hr = E_FAIL;
        goto done;
    }
    
    bstrEventList = NEW BSTR [Count];
    if (bstrEventList == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    curChar = bstrEvent;
    for (j = 0; j < Count; j++)
    {
        //get the element name
        ZeroMemory(sTemp, sizeof(OLECHAR) * strLen);
        
        i = 0;
        //step through the bstr looking for \0 or the '.' or ';'
        while (i < strLen - 1 && *curChar != '\0' && *curChar != '.' && *curChar != ';')
        {
            if (*curChar != ' ')  //need to strip out spaces.
            {
                sTemp[i] = *curChar;
                i++;
            }
            curChar++;
        }
        
        if (*curChar != '.')
        {
            hr = E_FAIL;
            goto done;
        }
                
        bstrTempElement = SysAllocString(sTemp);
        if (NULL == bstrTempElement)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        bstrElementList[j] = bstrTempElement; 

        //get the event name
        ZeroMemory(sTemp, sizeof(OLECHAR) * strLen);

        curChar++;
        i = 0;
        //step through the bstr looking for \0 or the ';'
        while (i < strLen - 1 && *curChar != ';' && *curChar != '\0')
        {
            sTemp[i] = *curChar;
            i++;
            curChar++;
        }
        
        //strip out trailing spaces
        i--;
        while (sTemp[i] == ' ' && i > 0)
        {
            sTemp[i] = '\0';
            i--;
        }

        bstrTempEvent = SysAllocString(sTemp);
        if (NULL == bstrTempEvent)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        bstrEventList[j] = bstrTempEvent;

        //advance curChar to the next element or the end of the string
        if (j < Count - 1)
        {
            while (*curChar != ';' && *curChar != '\0')
            {
                curChar++;
            }
            if (*curChar == ';') 
            {
                curChar++;
            }
            if (*curChar == '\0')
            {
                goto done;
            }
        }
    }

  done:

    delete [] sTemp;
    if (SUCCEEDED(hr))
    {
        *pElementName = bstrElementList;
        *pEventName = bstrEventList;
    }
    else //cleanup code
    {
        for (i = 0; i < j; i++)
        {
            if (bstrEventList)
            {
                SysFreeString(bstrEventList[i]);
            }
            if (bstrElementList)
            {
                SysFreeString(bstrElementList[i]);
            }
        }
        if (bstrElementList)
        {
            delete [] bstrElementList;
        }
        if (bstrEventList)
        {
            delete [] bstrEventList;
        }
    }
    return hr;   
}

///////////////////////////////////////////////////////////////
//  Name: MatchEvent
// 
//  Parameters:
//    BSTR bstrEvent            The cached event name in the format
//                              "Elementname.EventName".
//    IHTMLEventObj *pEventObj  A pointer to the event object that is
//                              passed into IDispatch::Invoke.
//
//  Abstract:
//    Determines if the event that was just hooked matches
//    the event specified in bstrEvent.
///////////////////////////////////////////////////////////////
bool CEventMgr::MatchEvent(BSTR bstrEvent, IHTMLEventObj *pEventObj, long Count, bool ScriptCommandAttach[])
{
    bool bMatch = false;
    BSTR *bstrExpEventName = NULL; 
    BSTR *bstrExpElementName = NULL;
    BSTR bstrEventName = NULL;
    BSTR bstrElementName = NULL;
    HRESULT hr = S_OK;
    DAComPtr <IHTMLEventObj2> pEventObj2;
    int i = 0;

    hr = THR(pEventObj->get_type(&bstrEventName));
    
    hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void**)&pEventObj2));
    if (FAILED(hr))
    {
        goto done;
    }

	//hack to work around eventobject problems
	if (!bstrEventName)
    {
        VARIANT vTemp;
        VariantInit(&vTemp);
        pEventObj2->getAttribute(g_szEventName, 0, &vTemp);
        SysFreeString(bstrEventName );
        bstrEventName  = SysAllocString(vTemp.bstrVal);
        VariantClear(&vTemp);
    }

    hr = THR(GetEventName(bstrEvent, &bstrExpElementName, &bstrExpEventName, Count));
    if (FAILED(hr))
    {
        goto done;
    }
    
    for (i = 0; i < Count; i++)
    {
        if ((StrCmpIW(g_EventNames[TE_ONSCRIPTCOMMAND].wsz_name + 2, bstrEventName) == 0) && 
            (ScriptCommandAttach[i] == true))
        {
            //if this is a script command event and we attached to the script command event by default
            //then reset the event name to match the value of the "scType" parameter.
            VARIANT vTemp;
            VariantInit(&vTemp);
            pEventObj2->getAttribute(L"scType", 0, &vTemp);
            SysFreeString(bstrEventName);
            bstrEventName  = SysAllocString(vTemp.bstrVal);
            VariantClear(&vTemp);            
        }

        //check that the event names match
        if ((StrCmpIW(bstrExpEventName[i] + 2, bstrEventName) == 0) || (StrCmpIW(bstrExpEventName[i], bstrEventName) == 0))
        {
            //check that the Element name matches
            DAComPtr <IHTMLElement> pEle;

            hr = THR(pEventObj->get_srcElement(&pEle));
            if (FAILED(hr))
            {
                goto done;
            }
            if (NULL == pEle.p)
            {
                goto done;
            }
         
            //get the source element name
            THR(pEle->get_id(&bstrElementName));
        
            //handle the "this" string as an element name
            if (StrCmpIW(bstrExpElementName[i], L"this") == 0)
            {
                BSTR bstrName;
                hr = THR(m_pElement->get_id(&bstrName));
                if (FAILED(hr))
                {
                    SysFreeString(bstrName);
                    goto done;
                }

                if (StrCmpIW(bstrElementName, bstrName) == 0 &&
                    ValidateEvent(bstrEventName, pEventObj, m_pElement))
                {
                    bMatch = true;          
                    SysFreeString(bstrName);
                    SysFreeString(bstrElementName);
                    goto done;
                }

            }
            else if (StrCmpIW(bstrExpElementName[i], bstrElementName) == 0)
            {
                if (ValidateEvent(bstrEventName, pEventObj, pEle))
                {
                    bMatch = true;          
                    SysFreeString(bstrElementName);
                    goto done;
                }
            }
            else // may have to check the elements parents
            {
                DAComPtr<IHTMLElement> pCurEle;
                DAComPtr<IHTMLElement> pParentEle;
                bool bDone = false;

                //determine if this is a time event
                VARIANT vTemp;
                VARTYPE vType = VT_NULL;

                VariantInit(&vTemp);
                IGNORE_HR(pEventObj2->getAttribute(g_szEventName, 0, &vTemp));
                vType = vTemp.vt; //vType will be VT_NULL if this is not a time event.
                VariantClear(&vTemp);

                //if this is not a time event, check the parents.
                if (vType == VT_NULL) 
                {
                    IGNORE_HR(pEle->get_parentElement(&pParentEle));
                    while (pParentEle && !bDone)
                    {
                        if (pCurEle)
                        {
                            pCurEle->Release();
                        }
                        pCurEle = pParentEle;
                        pParentEle = NULL;
                    
                        //get the source element name
                        SysFreeString(bstrElementName);
                        IGNORE_HR(pCurEle->get_id(&bstrElementName));
                        if (StrCmpIW(bstrExpElementName[i], bstrElementName) == 0)
                        {
                            if (ValidateEvent(bstrEventName, pEventObj, pCurEle))
                            {
                                bMatch = true;
                            }
                                                
                            SysFreeString(bstrElementName);
                            bDone = true;
                        }
                        if (!bDone)
                        {
                            IGNORE_HR(pCurEle->get_parentElement(&pParentEle));
                        }
                    }
                }
            }
        }
        if (bstrElementName)
        {
            SysFreeString(bstrElementName);
        }
    }

  done:
    if (bstrExpEventName)
    {
        for (i = 0; i < Count; i++)
        {
            if (bstrExpEventName)
            {
                SysFreeString(bstrExpEventName[i]);
            }
            if (bstrExpElementName)
            {
                SysFreeString(bstrExpElementName[i]);
            }
        }
        if (bstrExpEventName)
        {
            delete [] bstrExpEventName;
        }
        if (bstrExpElementName)
        {
            delete [] bstrExpElementName;
        }
    }
    return bMatch;
}

///////////////////////////////////////////////////////////////
//  Name: ValidateEvent
// 
//  Parameters:
//    BSTR bstrEventName        The cached event name (e.g. "mouseover")
//    IHTMLEventObj *pEventObj  A pointer to the event object
//    IHTMLElement  *pElement   The element on which the event is occurring
//
//  Abstract:
//    Determines if the event is valid - used to filter out mouseover and mouseout events
//    happening on child elements, if the appropriate flag is set.
///////////////////////////////////////////////////////////////

bool CEventMgr::ValidateEvent(BSTR bstrEventName, IHTMLEventObj *pEventObj, IHTMLElement *pElement)
{
        HRESULT hr;

        if (StrCmpIW(bstrEventName, L"mouseout") == 0)
        {
                if (RequireEventValidation())
                {
                        // Check that event.toElement is NOT contained in pElement
                        DAComPtr <IHTMLElement> pToElement;
                        hr = pEventObj->get_toElement(&pToElement);
                        if (SUCCEEDED(hr) && pToElement)
                        {
                                VARIANT_BOOL varContained;
                                hr = pElement->contains(pToElement, &varContained);

                                if (SUCCEEDED(hr) && varContained != VARIANT_FALSE)
                                        return false;
                        }
                }
        }
        else if (StrCmpIW(bstrEventName, L"mouseover") == 0)
        {
                if (RequireEventValidation())
                {
                        // Check that event.fromElement is NOT contained in pElement
                        DAComPtr <IHTMLElement> pFromElement;
                        hr = pEventObj->get_fromElement(&pFromElement);
                        if (SUCCEEDED(hr) && pFromElement)
                        {
                                VARIANT_BOOL varContained;
                                hr = pElement->contains(pFromElement, &varContained);

                                if (SUCCEEDED(hr) && varContained != VARIANT_FALSE)
                                        return false;
                        }
                }
        }

        return true;
}

///////////////////////////////////////////////////////////////
//  Name: RequireEventValidation
// 
//  Parameters:
//
//  Abstract:
//    Determines whether event validation on mouseover and mouseout is required
//    by checking an attribute on m_pElement.
///////////////////////////////////////////////////////////////

bool CEventMgr::RequireEventValidation()
{
        bool result = false;

        if (m_pElement != NULL)
        {
                DAComPtr <IDispatch> pDispatch;
                HRESULT hr = m_pElement->QueryInterface(IID_TO_PPV(IDispatch, &pDispatch));
                if (SUCCEEDED(hr))
                {
                        DISPID dispid;
                        OLECHAR *attrName = L"an:filterMInOut";

                        hr = pDispatch->GetIDsOfNames(IID_NULL, &attrName, 1, LCID_SCRIPTING, &dispid);

                        if (SUCCEEDED(hr))
                        {
                                DISPPARAMS  params;
                                VARIANT     varResult;
                                EXCEPINFO   excepInfo;
                                UINT        nArgErr;

                                VariantInit(&varResult);

                                params.rgvarg             = NULL;
                                params.rgdispidNamedArgs  = NULL;
                                params.cArgs              = 0;
                                params.cNamedArgs         = 0;

        
                                hr = pDispatch->Invoke(dispid,
                                                       IID_NULL,
                                                       LCID_SCRIPTING,
                                                       DISPATCH_PROPERTYGET,
                                                       &params,
                                                       &varResult,
                                                       &excepInfo,
                                                       &nArgErr );

                                if (SUCCEEDED(hr))
                                {
                                        hr = VariantChangeTypeEx(&varResult, &varResult, LCID_SCRIPTING, 0, VT_BOOL);
                                        if (SUCCEEDED(hr))
                                        {
                                                if (V_BOOL(&varResult) == VARIANT_TRUE)
                                                        result = true;
                                        }

                                        VariantClear(&varResult);
                                }
                        }
                }
        }

        return result;
}

///////////////////////////////////////////////////////////////
//  Name: ReadyStateChange
// 
//  Parameters:
//      BSTR ReadyState             a string containing the 
//                                  current ready state.  Possible
//                                  values are "complete" or
//                                  "interactive".  Only "complete"
//                                  is currently used.
//
//  Abstract:
//    This method is called from the EventSync class to 
//    notify the event manager that the readystatechange
//    event has occured.
///////////////////////////////////////////////////////////////
void CEventMgr::ReadyStateChange(BSTR ReadyState)
{   
    TOKEN tokReadyState;

    tokReadyState = StringToToken(ReadyState);

    if (tokReadyState != INVALID_TOKEN)
    {
        m_elm.OnReadyStateChange(tokReadyState);
    }
}



///////////////////////////////////////////////////////////////
//  Name: PropertyChange
// 
//  Parameters:
//      BSTR PropertyName           The name of the property
//                                  that has changed.
//
//  Abstract:
//    This method is called from the EventSync class to 
//    notify the event manager that a propertychange event 
//    has occured.
///////////////////////////////////////////////////////////////
void CEventMgr::PropertyChange(BSTR PropertyName)
{
    TraceTag((tagEventMgr,
              "EventMgr(%lx)::PropertyChanged(%ls)",
              this,
              PropertyName));
    //////////////////////////////////////
    //UNDONE:
    // do something to notify the element
    // that the a property has changed
    //
    // QUESTION: 
    // should this look for t:propertyname,
    // t_propertyname, or just propertyname?
    //////////////////////////////////////
}

///////////////////////////////////////////////////////////////
//  Name: MouseEvent
// 
//  Parameters:
//    long x                    The current x coordinate 
//    long y                    The current y coordinate
//    VARIANT_BOOL bMove        True if this is a mouse move event
//    VARIANT_BOOL bUp          True if this is a mouse up event
//    VARIANT_BOOL bShift       True if the Shift key is down
//    VARIANT_BOOL bAlt         True if the Alt key is down
//    VARIANT_BOOL bCtrl        True if the Control key is down
//    long button               Mousebutton that triggered the
//                              event. Possible values are:
//                                  1 for left
//                                  2 for right
//                                  4 for middle
// 
//  Abstract:
//    This method is called from the EventSync class to 
//    notify the event manager that a Mouse event
//    has occured on the element.
///////////////////////////////////////////////////////////////
void CEventMgr::MouseEvent(long x, 
                           long y, 
                           VARIANT_BOOL bMove,
                           VARIANT_BOOL bUp,
                           VARIANT_BOOL bShift, 
                           VARIANT_BOOL bAlt,
                           VARIANT_BOOL bCtrl,
                           long button)
{
    MMView *view;
    double time;
    BYTE bButton;
    long offsetX, offsetY;
    HRESULT hr;
    
    view = m_elm.GetView();

    if (m_elm.GetPlayer())
    {
        time = m_elm.GetPlayer()->GetCurrentTime();
    }
    else
    {
        time = 0;
    }
    
    if (view == NULL || time == 0.0)
    {
        goto done;
    }
    
    hr = THR(m_pElement->get_offsetTop(&offsetY));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = THR(m_pElement->get_offsetLeft(&offsetX));
    if (FAILED(hr))
    {
        goto done;
    }


    if (bMove)
    {
        view->OnMouseMove(time,
                          x - offsetX,
                          y - offsetY,
                          GetModifiers(bShift, bCtrl, bAlt));
        m_lastX = x;
        m_lastY = y;
    }
    else
    {
        BYTE mod;
        bButton = (button == 4) ? (BYTE)(button - 2) : (BYTE)(button - 1);

        if (!bUp)                       //if the button is a mouse down message
        {                               //capture the mouse and send the message.
            m_hwndCurWnd = GetFocus();    
            SetCapture(m_hwndCurWnd);
                
            mod = GetModifiers(bShift, bCtrl, bAlt);
            view->OnMouseButton(time,
                                x - offsetX,
                                y - offsetY,
                                bButton,
                                (bUp) ? AXA_STATE_UP : AXA_STATE_DOWN,
                                mod) ;

            m_lastButton = button;
            m_lastX = 0;
            m_lastY = 0;
            m_lastMouseMod = mod;
        }        
        else  //this is a mouse up
        {
            if (m_hwndCurWnd != 0)  //if there was a previous mouse down message
            {
                ReleaseCapture();
                m_hwndCurWnd = 0;
                    
                view->OnMouseButton(time,
                                    x - offsetX,
                                    y - offsetY,
                                    bButton,
                                    (bUp) ? AXA_STATE_UP : AXA_STATE_DOWN,
                                    GetModifiers(bShift, bCtrl, bAlt)) ;
                m_lastButton = 0;
                m_lastMouseMod = 0;
            }
            
        } 
    }

  done:
    return;
}
    

///////////////////////////////////////////////////////////////
//  Name: KeyEvent
// 
//  Parameters:
//    VARIANT_BOOL bLostFocus   True if there was a lost focus event
//    VARIANT_BOOL bUp          True if this is a KeyUp Event
//    VARIANT_BOOL bShift       True if the Shift key is down
//    VARIANT_BOOL bAlt         True if the Alt key is down
//    VARIANT_BOOL bCtrl        True if the Control key is down
//    long KeyCode              The unicode keycode for the key
// 
//  Abstract:
//    This method is called from the EventSync class to 
//    notify the event manager that a KeyBoard event
//    has occured on the element.
///////////////////////////////////////////////////////////////
void CEventMgr::KeyEvent(VARIANT_BOOL bLostFocus,
                         VARIANT_BOOL bUp,
                         VARIANT_BOOL bShift, 
                         VARIANT_BOOL bAlt,
                         VARIANT_BOOL bCtrl,
                         long KeyCode, 
                         long RepeatCount)
{
    MMView *view;
    double time;
    BYTE mod;

    // ignore repeated keys
    if (RepeatCount > 0)
    {
        goto done;
    }

    //get the view stuff
    view = m_elm.GetView();

    if (m_elm.GetPlayer())
    {
        time = m_elm.GetPlayer()->GetCurrentTime();
    }
    else
    {
        time = 0;
    }
    
    if (view == NULL || time == 0.0)
    {
        goto done;
    }
    
    mod = GetModifiers(bShift, bCtrl, bAlt);

    //if this is a lost focus event, only fire the keyup with the last keycode value
    if (bLostFocus)
    {
        if (m_lastKey != 0)
        {
            view->OnKey(time, 
                        m_lastKey,
                        false,
                        m_lastKeyMod);
        
            m_lastKey = 0;
        }
        goto done;
    }

    // See if we got a keydown before a keyup for the last
    // known keydown
    if (m_lastKey != 0 && !bUp) 
    {
        view->OnKey(time, 
                    m_lastKey,
                    false,
                    m_lastKeyMod);
        
        m_lastKey = 0 ;
    }

    //if this is a special key, convert it
    if (AXAIsSpecialVK(KeyCode)) 
    {
        KeyCode = VK_TO_AXAKEY(KeyCode);
    }

    if (bUp)
    {
        view->OnKey(time, 
                    KeyCode,
                    false,
                    mod);
        
        m_lastKey = 0;
        m_lastKeyMod = 0;  
    }
    else
    {
        view->OnKey(time, 
                    KeyCode,
                    true,
                    mod);
        
        m_lastKey = KeyCode ;
        m_lastKeyMod = mod ;  
    }

  done:
    return;
}  

///////////////////////////////////////////////////////////////
//  Name: GetModifiers
// 
//  Parameters:
//    VARIANT_BOOL bShift       True if the Shift key is down
//    VARIANT_BOOL bAlt         True if the Alt key is down
//    VARIANT_BOOL bCtrl        True if the Control key is down
// 
//  Abstract:
///////////////////////////////////////////////////////////////
BYTE CEventMgr::GetModifiers(VARIANT_BOOL bShift, VARIANT_BOOL bCtrl, VARIANT_BOOL bAlt)
{
    BYTE mod = AXAEMOD_NONE;

    if (bShift) mod |= AXAEMOD_SHIFT_MASK ;
    if (bCtrl) mod |= AXAEMOD_CTRL_MASK ;
    if (bAlt) mod |= AXAEMOD_ALT_MASK ;

    return mod;
}


int CEventMgr::IsEventInList(BSTR ElementName, BSTR EventName, long ListCount, BSTR Events)
{
    int nInList = -1;
    LPOLESTR curEvent;
    BSTR *EventList = NULL;
    BSTR *ElementList = NULL;
    HRESULT hr = S_OK;
    int i;

    hr = THR(GetEventName(Events, &ElementList, &EventList, ListCount));
    if (FAILED(hr))
    {
        goto done;
    } 

    for (i = 0; i < ListCount; i++)
    {
        if ((StrCmpIW(ElementName, ElementList[i]) == 0) &&
            (StrCmpIW(EventName, EventList[i]) == 0))
        {
            nInList = i;
            goto done;
        }
    }


  done:
    if (EventList)
    {
        for (i = 0; i < ListCount; i++)
        {
            SysFreeString(EventList[i]);
            SysFreeString(ElementList[i]);
        }
        delete [] EventList;
        delete [] ElementList;
    }
    return nInList;
}


///////////////////////////////////////////////////////////////
//  Name: BeginEndFired
// 
//  Parameters:
//    bBeginEventMatch          True if a beginEvent occurred
//    bEndEventMatch          True if an endEvent occurred
// 
//  Abstract:
//    This method determines how to handle the beginEvent/endEvent
//    occurrences.
///////////////////////////////////////////////////////////////
void CEventMgr::BeginEndFired(bool bBeginEventMatch, bool bEndEventMatch, DISPID EventDispId)
{
    float CurTime = 0;
    SYSTEMTIME sysTime;

    GetSystemTime(&sysTime); 
    CurTime = sysTime.wSecond * 1000 + sysTime.wMilliseconds;

    if (EventDispId == DISPID_HTMLDOCUMENTEVENTS_ONCLICK && 
        m_bLastEventClick == true) 
    {
        //this ignores the case of the document.onclick that immediately
        //follows all element.onclick events.
        m_bLastEventClick = false;
        goto done;
    }

    if ((CurTime != m_lastEventTime) ||
        (bBeginEventMatch != bEndEventMatch))
    {
        MM_STATE curMMState = m_elm.GetPlayState();

        if (bEndEventMatch && bBeginEventMatch)
        {
            if (m_elm.GetEventRestart() ||
                curMMState == MM_STOPPED_STATE)
            {
                m_elm.base_beginElement(false);
            }
            else if (curMMState == MM_PAUSED_STATE ||
                     curMMState == MM_PLAYING_STATE )
            {
                m_elm.base_endElement();
            }
        }
        else if  (bBeginEventMatch)
        {
            if (m_elm.GetEventRestart() ||
                curMMState == MM_STOPPED_STATE)
            {
                m_elm.base_beginElement(false);
            }
        }
        else if (bEndEventMatch)
        {
            if (curMMState == MM_PAUSED_STATE ||
                curMMState == MM_PLAYING_STATE )
            {
                m_elm.base_endElement();   
            }
        }
        m_lastEventTime = CurTime;
    }
  done:
    return;
}

HRESULT 
CEventMgr::ShouldFireThisEvent(bool *pfShouldFire)
{
    HRESULT hr = S_OK;

    *pfShouldFire = true;

    if (m_elm.GetBody() != NULL)
    {
        if (m_elm.GetBody()->IsPaused())
        {
            DAComPtr <IHTMLEventObj> pEventObj;
            Assert(NULL != m_pWindow.p);
            hr = THR(m_pWindow->get_event(&pEventObj));
            if (SUCCEEDED(hr))
            {
                BSTR bstrEventName;
                hr = THR(pEventObj->get_type(&bstrEventName));
                if (SUCCEEDED(hr))
                {
                    *pfShouldFire = IsValidEventInPausedAndEditMode(bstrEventName); 
                }
                SysFreeString(bstrEventName);                        
            }                
        }
    }
    return hr;
}

bool
CEventMgr::IsValidEventInPausedAndEditMode(BSTR bstrEventName)
{
    Assert(NULL != bstrEventName);
    if (wcsstr( bstrEventName, L"mouse" ) != NULL || wcsstr(bstrEventName, L"click") != NULL)
    {
        return false;
    }
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\eventmgr.h ===
///////////////////////////////////////////////////////////////
// Copyright (c) 1998 Microsoft Corporation
//
// File: EventMgr.h
//
// Abstract:
//
///////////////////////////////////////////////////////////////

#ifndef _EVENTMGR_H
#define _EVENTMGR_H

enum TIME_EVENT
{
    TE_ONBEGIN = 0,
    TE_ONPAUSE, 
    TE_ONRESUME, 
    TE_ONEND,
    TE_ONRESYNC,
    TE_ONREPEAT,
    TE_ONREVERSE,
    TE_ONMEDIACOMPLETE,
    TE_ONMEDIASLIP,
    TE_ONMEDIALOADFAILED,
    TE_ONRESET,
    TE_ONSCRIPTCOMMAND,
    TE_GENERIC,
    TE_MAX
};

class CTIMEElementBase;
class CEventSync;

class CEventMgr
    : public IDispatch
{
  public:
    CEventMgr(CTIMEElementBase & elm);
    ~CEventMgr();

    //methods
    HRESULT Init();
    HRESULT Deinit();
    HRESULT AttachEvents();
    HRESULT DetachEvents();
    
    //  Parameters needed to be packed into Variants by the caller
    HRESULT FireEvent(TIME_EVENT TimeEvent, 
                      long Count, 
                      LPWSTR szParamNames[], 
                      VARIANT varParams[]); 

    void ReadyStateChange(BSTR ReadyState);
    void PropertyChange(BSTR PropertyName);

    void MouseEvent(long x, 
                    long y, 
                    VARIANT_BOOL bMove,
                    VARIANT_BOOL bUp,
                    VARIANT_BOOL bShift, 
                    VARIANT_BOOL bAlt,
                    VARIANT_BOOL bCtrl,
                    long button);
    
    void KeyEvent(VARIANT_BOOL bLostFocus,
                  VARIANT_BOOL bUp,
                  VARIANT_BOOL bShift, 
                  VARIANT_BOOL bAlt,
                  VARIANT_BOOL bCtrl,
                  long KeyCode,
                  long RepeatCount);

    //QueryInterface 
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
    STDMETHODIMP GetTypeInfo(/* [in] */ UINT iTInfo,
                             /* [in] */ LCID lcid,
                             /* [out] */ ITypeInfo** ppTInfo);
    STDMETHODIMP GetIDsOfNames(
        /* [in] */ REFIID riid,
        /* [size_is][in] */ LPOLESTR *rgszNames,
        /* [in] */ UINT cNames,
        /* [in] */ LCID lcid,
        /* [size_is][out] */ DISPID *rgDispId);
    STDMETHODIMP Invoke(
        /* [in] */ DISPID dispIdMember,
        /* [in] */ REFIID riid,
        /* [in] */ LCID lcid,
        /* [in] */ WORD wFlags,
        /* [out][in] */ DISPPARAMS  *pDispParams,
        /* [out] */ VARIANT  *pVarResult,
        /* [out] */ EXCEPINFO *pExcepInfo,
        /* [out] */ UINT *puArgErr);

  private:
      HRESULT ShouldFireThisEvent(bool *pfShouldFire);
      bool  IsValidEventInPausedAndEditMode(BSTR bstrEventName);

  protected:
    //Cookie for the Window ConnectionPoint
    CTIMEElementBase &                m_elm;
    CEventSync *                      m_pEventSync;
    DAComPtr<IConnectionPoint>        m_pWndConPt;
    DAComPtr<IConnectionPoint>        m_pDocConPt;
    DAComPtr<IHTMLWindow2>            m_pWindow;
    
    IHTMLElement *                    m_pElement;
    IHTMLElement2 **                  m_pBeginElement;
    IHTMLElement2 **                  m_pEndElement;
    long                              m_lBeginEventCount;
    long                              m_lEndEventCount;
    long                              m_lRepeatCount;
    BOOL                              m_bAttached;
    bool                              m_bLastEventClick;

    //Cookies
    long                              m_cookies[TE_MAX];
    DWORD                             m_dwWindowEventConPtCookie;
    DWORD                             m_dwDocumentEventConPtCookie;
    DISPID                           *m_dispDocBeginEventIDs;
    DISPID                           *m_dispDocEndEventIDs;
    
    //reference goo
    long                              m_refCount;
    
    HRESULT                           RegisterEvents();
    HRESULT                           Attach(BSTR Event, BOOL bAttach, IHTMLElement2 *pEventElement[], long Count, BOOL bAttachAll, DISPID *dispIDList,bool ScriptCommandAttach[]);
    HRESULT                           ConnectToContainerConnectionPoint();
    HRESULT                           GetEventName(BSTR bstrEvent, BSTR **pElementName, BSTR **pEventName, long Count);
    long                              GetEventCount(BSTR bstrEvent);
    bool                              MatchEvent(BSTR bstrEvent, IHTMLEventObj *pEventObj, long Count, bool ScriptCommandAttach[]);
	bool							  ValidateEvent(BSTR bstrEventName, IHTMLEventObj *pEventObj, IHTMLElement *pElement);
	bool							  RequireEventValidation();
    BYTE                              GetModifiers(VARIANT_BOOL bShift, VARIANT_BOOL bCtrl, VARIANT_BOOL bAlt);
    int                               IsEventInList(BSTR ElementName, BSTR EventName, long ListCount, BSTR Events);
    void                              BeginEndFired(bool bBeginEventMatch, bool bEndeventMatch, DISPID EventDispId);
    
        //input event parameters
    BYTE                              m_lastKeyMod;
    DWORD                             m_lastKey;
    int                               m_lastKeyCount;
    HWND                              m_hwndCurWnd;    
    long                              m_lastX;
    long                              m_lastY;
    long                              m_lastButton;
    BYTE                              m_lastMouseMod;
    double                            m_lastEventTime;
    bool                             *m_pScriptCommandBegin;
    bool                             *m_pScriptCommandEnd;
};

#endif /* _EVENTMGR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\eventsync.h ===
///////////////////////////////////////////////////////////////
// Copyright (c) 1998 Microsoft Corporation
//
// File: EventSync.h
//
// Abstract:  
//
///////////////////////////////////////////////////////////////

#ifndef _EVENTSYNC_H
#define _EVENTSYNC_H



enum ELEMENT_EVENT
{
    EE_ONPROPCHANGE = 0,
    //add non-input related events to hook here
    EE_ONREADYSTATECHANGE, 
    EE_ONMOUSEMOVE,
    EE_ONMOUSEDOWN,
    EE_ONMOUSEUP,
    EE_ONKEYDOWN,
    EE_ONKEYUP,
    EE_ONBLUR,
    //add input related events here
    EE_MAX
};

class CEventSync
    : public IDispatch
{
  public:
    CEventSync(CTIMEElementBase & elm, CEventMgr *pEventMgr);
    ~CEventSync();

    //methods
    HRESULT Init();
    HRESULT Deinit();
    HRESULT InitMouse();

    //QueryInterface 
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
    STDMETHODIMP GetTypeInfo(/* [in] */ UINT iTInfo,
                             /* [in] */ LCID lcid,
                             /* [out] */ ITypeInfo** ppTInfo);
    STDMETHODIMP GetIDsOfNames(
        /* [in] */ REFIID riid,
        /* [size_is][in] */ LPOLESTR *rgszNames,
        /* [in] */ UINT cNames,
        /* [in] */ LCID lcid,
        /* [size_is][out] */ DISPID *rgDispId);
    STDMETHODIMP Invoke(
        /* [in] */ DISPID dispIdMember,
        /* [in] */ REFIID riid,
        /* [in] */ LCID lcid,
        /* [in] */ WORD wFlags,
        /* [out][in] */ DISPPARAMS  *pDispParams,
        /* [out] */ VARIANT  *pVarResult,
        /* [out] */ EXCEPINFO *pExcepInfo,
        /* [out] */ UINT *puArgErr);


  protected:
    //methods
    HRESULT                           AttachEvents();
    HRESULT                           DetachEvents();
    HRESULT                           NotifyReadyState(IHTMLEventObj *pEventObj);
    HRESULT                           NotifyPropertyChange(IHTMLEventObj *pEventObj);
    HRESULT                           NotifyMouseMove(IHTMLEventObj *pEventObj);
    HRESULT                           NotifyMouseUp(IHTMLEventObj *pEventObj);
    HRESULT                           NotifyMouseDown(IHTMLEventObj *pEventObj);
    HRESULT                           NotifyKeyDown(IHTMLEventObj *pEventObj);
    HRESULT                           NotifyKeyUp(IHTMLEventObj *pEventObj);

    //properties
    IHTMLElement *                    m_pElement;
    CTIMEElementBase &                m_elm;
    long                              m_refCount;
    DWORD                             m_dwElementEventConPtCookie;
    DAComPtr<IConnectionPoint>        m_pElementConPt;
    CEventMgr *                       m_pEventMgr;

};

#endif /* _EVENTSYNC_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\eventsync.cpp ===
///////////////////////////////////////////////////////////////
// Copyright (c) 1998 Microsoft Corporation
//
// File: EventSync.cpp
//
// Abstract:  
//
///////////////////////////////////////////////////////////////


#include "headers.h"
#include "eventmgr.h"
#include "mshtmdid.h"
#include "timeelm.h"
#include "eventsync.h"

DeclareTag(tagEventSync, "API", "Event Sync methods");

struct {
    ELEMENT_EVENT event;
    wchar_t * wsz_name;
} g_ElementEventNames[] =
{
    { EE_ONPROPCHANGE,         L"onpropertychange" },
    //add non-input related events to hook here
    { EE_ONREADYSTATECHANGE,   L"onreadystatechange" },
    { EE_ONMOUSEMOVE,          L"onmousemove" },
    { EE_ONMOUSEDOWN,          L"onmousedown" },
    { EE_ONMOUSEUP,            L"onmouseup" },
    { EE_ONKEYDOWN,            L"onkeydown" }, 
    { EE_ONKEYUP,              L"onkeyup" },
    { EE_ONBLUR,               L"onblur" }
    //add input events here
};

///////////////////////////////////////////////////////////////
//  Name: CEventSync
//  Parameters:
//    CTIMEElement  & elm
//                               This parameter must be passed
//                               to the constructor so that 
//                               we can get info from elm
//    CEventMgr *    pEventMgr
//                               This parameter is passed so 
//                               the eventsync can notify then
//                               parent EventMgr when events
//                               have occured.
//  Abstract:
//    Stash away the element so we can get the OM when we need it
///////////////////////////////////////////////////////////////
CEventSync::CEventSync(CTIMEElementBase & elm, CEventMgr *pEventMgr)
: m_elm(elm),
  m_pElement(NULL),
  m_refCount(0),
  m_pEventMgr(NULL)
{
    TraceTag((tagEventSync,
              "EventSync(%lx)::EventSync(%lx)",
              this,
              &elm));

    m_pEventMgr = pEventMgr;
}

///////////////////////////////////////////////////////////////
//  Name: ~CEventSync
//
//  Abstract:
//    Cleanup
///////////////////////////////////////////////////////////////
CEventSync::~CEventSync()
{
    TraceTag((tagEventSync,
              "EventSync(%lx)::~EventSync()",
              this));


}


///////////////////////////////////////////////////////////////
//  Name:  Init
//  Parameters:  None
//
//  Abstract:
//    Initializes the object
///////////////////////////////////////////////////////////////
HRESULT CEventSync::Init()
{
    HRESULT hr = S_OK;

    m_pElement = m_elm.GetElement();
    m_pElement->AddRef();
    
    hr = THR(AttachEvents());
    if (FAILED(hr))
    {
        goto done;
    }

  done:
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name:  Init
//  Parameters:  None
//
//  Abstract:
//    Attaches to mouse and keyboard events
///////////////////////////////////////////////////////////////
HRESULT CEventSync::InitMouse()
{
    DAComPtr <IHTMLElement2> pElement2;
    HRESULT hr = S_OK;
    VARIANT_BOOL bSuccess;
    int i = 0;

    if (!m_pElement)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_pElement->QueryInterface(IID_IHTMLElement2, (void**)&pElement2));
    if (FAILED(hr))
    {
        goto done;
    }

    //attach to mouse events
    if (m_elm.GetView() && !m_elm.IsBody())
    {
        for (i = EE_ONREADYSTATECHANGE + 1; i < EE_MAX; i++)
        {
            hr = THR(pElement2->attachEvent(g_ElementEventNames[i].wsz_name, (IDispatch *)this, &bSuccess)) ;
            if (FAILED(hr))
            {
                goto done;
            }
        }   
    }
    
  done:
    return hr;
}

///////////////////////////////////////////////////////////////
//  Name:  Deinit
//  Parameters:  None
//
//  Abstract:
//    Cleans up the object
///////////////////////////////////////////////////////////////
HRESULT CEventSync::Deinit()
{
    HRESULT hr = S_OK;

    hr = THR(DetachEvents());

    if (m_pElement)
    {
        m_pElement->Release();
        m_pElement = NULL;
    }

    if (m_dwElementEventConPtCookie != 0 && m_pElementConPt)
    {
        m_pElementConPt->Unadvise(m_dwElementEventConPtCookie);
    }

    return hr;
}


///////////////////////////////////////////////////////////////
//  Name: AddRef
// 
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CEventSync::AddRef(void)
{
    return m_elm.InternalAddRef();
}

///////////////////////////////////////////////////////////////
//  Name: Release
// 
//  Abstract:
//    
///////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CEventSync::Release(void)
{
    return m_elm.InternalRelease();
}



///////////////////////////////////////////////////////////////
//  Name: GetTypeInfoCount
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventSync::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: GetTypeInfo
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventSync::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
                                   /* [in] */ LCID /*lcid*/,
                                   /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: GetIDsOfNames
// 
//  Abstract:
//    Stubbed to allow this object to inherit for IDispatch
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventSync::GetIDsOfNames(
    /* [in] */ REFIID /*riid*/,
    /* [size_is][in] */ LPOLESTR* /*rgszNames*/,
    /* [in] */ UINT /*cNames*/,
    /* [in] */ LCID /*lcid*/,
    /* [size_is][out] */ DISPID* /*rgDispId*/)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////
//  Name: Invoke
// 
//  Abstract:
//     dispIdMember is always 0 so this Invoke switches on the
//     name of the event that causes the callback.
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventSync::Invoke(
    /* [in] */ DISPID dispIdMember,
    /* [in] */ REFIID /*riid*/,
    /* [in] */ LCID /*lcid*/,
    /* [in] */ WORD /*wFlags*/,
    /* [out][in] */ DISPPARAMS* pDispParams,
    /* [out] */ VARIANT* pvarResult,
    /* [out] */ EXCEPINFO* /*pExcepInfo*/,
    /* [out] */ UINT* puArgErr)
{
    // Listen for the two events we're interested in, and call back if necessary
    HRESULT hr = S_OK;
    DAComPtr <IHTMLEventObj> pEventObj;
    BSTR bstrEventName;

    //get the event object from the IDispatch passed in
    hr = THR((pDispParams->rgvarg[0].pdispVal)->QueryInterface(IID_IHTMLEventObj, (void**)&pEventObj));
    if (FAILED(hr))
    {
        goto done;
    }
    
    //get the event name
    hr = THR(pEventObj->get_type(&bstrEventName));
    if (FAILED(hr))
    {
        goto done;
    }

    //handle the MouseMove event
    if (StrCmpIW (bstrEventName, g_ElementEventNames[EE_ONMOUSEMOVE].wsz_name + 2) == 0)
    {
        NotifyMouseMove(pEventObj);
    }
    //handle the MouseDown event
    else if (StrCmpIW (bstrEventName, g_ElementEventNames[EE_ONMOUSEDOWN].wsz_name + 2) == 0)
    {
        NotifyMouseDown(pEventObj);
    }
    //handle the MouseUp event
    else if (StrCmpIW (bstrEventName, g_ElementEventNames[EE_ONMOUSEUP].wsz_name + 2) == 0)
    {
        NotifyMouseUp(pEventObj);
    }
    //handle the KeyDown event
    else if (StrCmpIW (bstrEventName, g_ElementEventNames[EE_ONKEYDOWN].wsz_name + 2) == 0)
    {
        NotifyKeyDown(pEventObj);
    }
    //handle the KeyUp event
    else if (StrCmpIW (bstrEventName, g_ElementEventNames[EE_ONKEYUP].wsz_name + 2) == 0)
    {
        NotifyKeyUp(pEventObj);
    }
    //handle the Blur event
    else if (StrCmpIW (bstrEventName, g_ElementEventNames[EE_ONBLUR].wsz_name + 2) == 0)
    {
        m_pEventMgr->KeyEvent(TRUE, TRUE, FALSE, FALSE, FALSE, 0, 0);
    }
    //handle the PropertyChange event
    else if (StrCmpIW(bstrEventName, g_ElementEventNames[EE_ONPROPCHANGE].wsz_name + 2) == 0)
    {
        NotifyPropertyChange(pEventObj);
    }
    //handle the OnReadyStateChange event
    else if (StrCmpIW(bstrEventName, g_ElementEventNames[EE_ONREADYSTATECHANGE].wsz_name + 2) == 0)
    {
        NotifyReadyState(pEventObj);
    }
    
    //return TRUE
    VARIANT vReturnVal;
    VariantInit(&vReturnVal);
    vReturnVal.vt = VT_BOOL;
    vReturnVal.boolVal = VARIANT_TRUE;
    pEventObj->put_returnValue(vReturnVal);

    SysFreeString(bstrEventName);

  done:
    return S_OK;
}

///////////////////////////////////////////////////////////////
//  Name: QueryInterface
// 
//  Abstract:
//    This QI only handles the IDispatch for HTMLElementEvents
//    and returns this as the interface.
///////////////////////////////////////////////////////////////
STDMETHODIMP CEventSync::QueryInterface( REFIID riid, void **ppv )
{
    if (NULL == ppv)
        return E_POINTER;

    *ppv = NULL;

    if ( InlineIsEqualGUID(riid, IID_IDispatch))
    {
        *ppv = this;
    }
        
    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;
}


///////////////////////////////////////////////////////////////
//  Name: AttachEvents
// 
//  Abstract:
//    Hooks all the trident events that we are interested in.
//    automatically hooks non-mouse events.  Only hooks the mouse
//    events if they are relevant to the behavior.
///////////////////////////////////////////////////////////////
HRESULT CEventSync::AttachEvents()
{
    DAComPtr <IHTMLElement2> pElement2;
    HRESULT hr = S_OK;
    VARIANT_BOOL bSuccess;
    int i = 0;

    if (!m_pElement)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_pElement->QueryInterface(IID_IHTMLElement2, (void**)&pElement2));
    if (FAILED(hr))
    {
        goto done;
    }

    //register for events that all sync's need.
    for (i = 0; i <= EE_ONREADYSTATECHANGE; i++)
    {
        hr = THR(pElement2->attachEvent(g_ElementEventNames[i].wsz_name, (IDispatch *)this, &bSuccess)) ;
        if (FAILED(hr))
        {
            goto done;
        }
    }

  done:
    return hr;  
}


///////////////////////////////////////////////////////////////
//  Name: DetachEvents
// 
//  Abstract:
//    Detaches from all events to allow clean shutdown.
///////////////////////////////////////////////////////////////
HRESULT CEventSync::DetachEvents()
{
    DAComPtr <IHTMLElement2> pElement2;
    HRESULT hr = S_OK;
    int i = 0;

    if (!m_pElement)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(m_pElement->QueryInterface(IID_IHTMLElement2, (void**)&pElement2));
    if (FAILED(hr))
    {
        goto done;
    }

    
    //detach from events that all sync's need.
    for (i = 0; i <= EE_ONREADYSTATECHANGE; i++)
    {
        //attach to the onreadystatechangeevent
        hr = THR(pElement2->detachEvent(g_ElementEventNames[i].wsz_name, (IDispatch *)this)) ;
        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    //detach from mouse events
    if (m_elm.GetView() && !m_elm.IsBody())
    {
        for (i = EE_ONREADYSTATECHANGE + 1; i < EE_MAX; i++)
        {
            //attach to the onreadystatechangeevent
            hr = THR(pElement2->detachEvent(g_ElementEventNames[i].wsz_name, (IDispatch *)this));
            if (FAILED(hr))
            {
                goto done;
            }
        }   
    }

  done:
    return hr;  
}


///////////////////////////////////////////////////////////////
//  Name: NotifyReadyState
// 
//  Parameters
//    IHTMLEventObj *pEventObj    A pointer to the event object
//                                that was passed to IDispatch::Invoke.
//
//  Abstract:
//    Determines the ready state that caused the ReadyStateChange
//    event and calls the EventManager to handle the new ready
//    state.
///////////////////////////////////////////////////////////////
HRESULT CEventSync::NotifyReadyState(IHTMLEventObj *pEventObj)
{
    HRESULT hr = S_OK;
    DAComPtr <IHTMLElement> pElement;
    DAComPtr <IHTMLElement2> pElement2;
    DAComPtr <IHTMLEventObj2> pEventObj2;
    VARIANT vReadyState;
    
    hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void **)&pEventObj2));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pEventObj2->get_srcElement(&pElement));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pElement->QueryInterface(IID_IHTMLElement2, (void **)&pElement2));
    if (FAILED(hr))
    {
        goto done;
    }
    
    VariantInit(&vReadyState);
    hr = THR(pElement2->get_readyState(&vReadyState));
    if (FAILED(hr))
    {
        goto done;
    }

    //if this is not a valid ready state, get the parent element's readystate.
    if (vReadyState.vt != VT_BSTR)
    {
        DAComPtr <IHTMLElement> pParentEle;
        DAComPtr <IHTMLElement2> pParentEle2;

        hr = THR(pElement->get_parentElement(&pParentEle));
        if (FAILED (hr))
        {
            goto done;
        }

        hr = THR(pParentEle->QueryInterface(IID_IHTMLElement2, (void **)&pParentEle2));
        if (FAILED (hr))
        {
            goto done;
        }

        VariantClear(&vReadyState);
        hr = THR(pParentEle2->get_readyState(&vReadyState));
        if (FAILED(hr))
        {
            goto done;
        }

    }
    m_pEventMgr->ReadyStateChange(vReadyState.bstrVal);
    VariantClear(&vReadyState);

  done:
    return hr;
}



///////////////////////////////////////////////////////////////
//  Name: NotifyPropertyChange
// 
//  Parameters
//    IHTMLEventObj *pEventObj    A pointer to the event object
//                                that was passed to IDispatch::Invoke.
//
//  Abstract:
//    Determines the ready state that caused the PropertyChange
//    event and calls the EventManager to handle the property
//    change.
///////////////////////////////////////////////////////////////
HRESULT CEventSync::NotifyPropertyChange(IHTMLEventObj *pEventObj)
{
    HRESULT hr = S_OK;

    DAComPtr <IHTMLEventObj2> pEventObj2;
    DAComPtr <IHTMLElement> pElement;
    BSTR bstrPropertyName;

    hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void **)&pEventObj2));
    if (FAILED(hr))
    {
        goto done;
    }
    
    //get the property name
    hr = THR(pEventObj2->get_propertyName(&bstrPropertyName));
    if (FAILED(hr))
    {
        goto done;
    }

    m_pEventMgr->PropertyChange(bstrPropertyName);
    SysFreeString(bstrPropertyName);
  
  done:
    return hr;

}


///////////////////////////////////////////////////////////////
//  Name: NotifyMouseMove
// 
//  Abstract:
//    This functions gets all the relevent information 
//    about a mouse move event from the event object
//    and notifies the event manager ofthe event.  
///////////////////////////////////////////////////////////////
HRESULT CEventSync::NotifyMouseMove(IHTMLEventObj *pEventObj)
{
    long x;
    long y;
    VARIANT_BOOL bShiftKeyPressed;
    VARIANT_BOOL bAltKeyPressed;
    VARIANT_BOOL bCtrlKeyPressed;
    HRESULT hr = S_OK;

    hr = THR(pEventObj->get_x(&x));
    hr = THR(pEventObj->get_y(&y));
    hr = THR(pEventObj->get_shiftKey(&bShiftKeyPressed));
    hr = THR(pEventObj->get_altKey(&bAltKeyPressed));
    hr = THR(pEventObj->get_ctrlKey(&bCtrlKeyPressed));

    m_pEventMgr->MouseEvent(x, 
                            y, 
                            TRUE,
                            FALSE,
                            bShiftKeyPressed, 
                            bAltKeyPressed, 
                            bCtrlKeyPressed,
                            0);

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: NotifyMouseUp
// 
//  Abstract:
//    This functions gets all the relevent information 
//    about a mouse up event from the event object
//    and notifies the event manager ofthe event.
///////////////////////////////////////////////////////////////
HRESULT CEventSync::NotifyMouseUp(IHTMLEventObj *pEventObj)
{
    
    long x;
    long y;
    VARIANT_BOOL bShiftKeyPressed;
    VARIANT_BOOL bAltKeyPressed;
    VARIANT_BOOL bCtrlKeyPressed;
    long Button;
    HRESULT hr = S_OK;

    hr = THR(pEventObj->get_x(&x));
    hr = THR(pEventObj->get_y(&y));
    hr = THR(pEventObj->get_shiftKey(&bShiftKeyPressed));
    hr = THR(pEventObj->get_altKey(&bAltKeyPressed));
    hr = THR(pEventObj->get_ctrlKey(&bCtrlKeyPressed));
    hr = THR(pEventObj->get_button(&Button));
    
    m_pEventMgr->MouseEvent(x, 
                            y, 
                            FALSE,
                            TRUE,
                            bShiftKeyPressed, 
                            bAltKeyPressed, 
                            bCtrlKeyPressed,
                            Button);

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: NotifyMouseDown
// 
//  Abstract:
//    This functions gets all the relevent information 
//    about a mouse down event from the event object
//    and notifies the event manager ofthe event.
///////////////////////////////////////////////////////////////
HRESULT CEventSync::NotifyMouseDown(IHTMLEventObj *pEventObj)
{
    
    long x;
    long y;
    VARIANT_BOOL bShiftKeyPressed;
    VARIANT_BOOL bAltKeyPressed;
    VARIANT_BOOL bCtrlKeyPressed;
    long Button;
    HRESULT hr = S_OK;

    hr = THR(pEventObj->get_x(&x));
    hr = THR(pEventObj->get_y(&y));
    hr = THR(pEventObj->get_shiftKey(&bShiftKeyPressed));
    hr = THR(pEventObj->get_altKey(&bAltKeyPressed));
    hr = THR(pEventObj->get_ctrlKey(&bCtrlKeyPressed));
    hr = THR(pEventObj->get_button(&Button));

    m_pEventMgr->MouseEvent(x, 
                            y, 
                            FALSE,
                            FALSE,
                            bShiftKeyPressed, 
                            bAltKeyPressed, 
                            bCtrlKeyPressed,
                            Button);

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: NotifyKeyDown
// 
//  Abstract:
//    This functions gets all the relevent information 
//    about a key down event from the event object
//    and notifies the event manager ofthe event.
///////////////////////////////////////////////////////////////
HRESULT CEventSync::NotifyKeyDown(IHTMLEventObj *pEventObj)
{
    DAComPtr <IHTMLEventObj2> pEventObj2;
    VARIANT_BOOL bShiftKeyPressed;
    VARIANT_BOOL bAltKeyPressed;
    VARIANT_BOOL bCtrlKeyPressed;
    long KeyCode;
    long RepeatCount = 0;
    HRESULT hr = S_OK;

    hr = THR(pEventObj->get_shiftKey(&bShiftKeyPressed));
    hr = THR(pEventObj->get_altKey(&bAltKeyPressed));
    hr = THR(pEventObj->get_ctrlKey(&bCtrlKeyPressed));
    hr = THR(pEventObj->get_keyCode(&KeyCode));
    
    //determine if this is a repeat keypress.
    hr = THR(pEventObj->QueryInterface(IID_IHTMLEventObj2, (void **)&pEventObj2));
    if (SUCCEEDED(hr))
    {
        VARIANT_BOOL bRepeat;
        hr = THR(pEventObj2->get_repeat(&bRepeat));
        if (SUCCEEDED(hr) && bRepeat)
        {
            RepeatCount = 1;
        }
    }
    
    m_pEventMgr->KeyEvent(FALSE,
                          FALSE,
                          bShiftKeyPressed,
                          bAltKeyPressed,
                          bCtrlKeyPressed,
                          KeyCode,
                          RepeatCount);

    return hr;
}

///////////////////////////////////////////////////////////////
//  Name: NotifyKeyUp
// 
//  Abstract:
//    This functions gets all the relevent information 
//    about a key up event from the event object
//    and notifies the event manager ofthe event.
///////////////////////////////////////////////////////////////
HRESULT CEventSync::NotifyKeyUp(IHTMLEventObj *pEventObj)
{
    VARIANT_BOOL bShiftKeyPressed;
    VARIANT_BOOL bAltKeyPressed;
    VARIANT_BOOL bCtrlKeyPressed;
    long KeyCode;

    HRESULT hr = S_OK;

    hr = THR(pEventObj->get_shiftKey(&bShiftKeyPressed));
    hr = THR(pEventObj->get_altKey(&bAltKeyPressed));
    hr = THR(pEventObj->get_ctrlKey(&bCtrlKeyPressed));
    hr = THR(pEventObj->get_keyCode(&KeyCode));
    
    m_pEventMgr->KeyEvent(FALSE,
                          TRUE,
                          bShiftKeyPressed,
                          bAltKeyPressed,
                          bCtrlKeyPressed,
                          KeyCode,
                          0);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\htmlimg.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: htmlimg.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "htmlimg.h"

DeclareTag(tagHTMLImg, "API", "HTML Image methods");

HTMLImage::HTMLImage()
{
    TraceTag((tagHTMLImg,
              "HTMLImage(%lx)::HTMLImage()",
              this));
}

HTMLImage::~HTMLImage()
{
    TraceTag((tagHTMLImg,
              "HTMLImage(%lx)::~HTMLImage()",
              this));
}

HRESULT
HTMLImage::Init()
{
    TraceTag((tagHTMLImg,
              "HTMLImage(%lx)::Init()",
              this));
    
    HRESULT hr;
    
    // Create the basic DAImage as an empty image and wait for the
    // first draw to do something with it.
    
    {
        CRLockGrabber __gclg;
        m_image = (CRImagePtr) CRModifiableBvr((CRBvrPtr) CREmptyImage(),0);
        
        if (!m_image)
        {
            TraceTag((tagError,
                      "HTMLImage(%lx)::Init(): Failed to create image switcher - %hr, %ls",
                      this,
                      CRGetLastError(),
                      CRGetLastErrorString()));
            
            hr = CRGetLastError();
            goto done;
        }
    }

    hr = S_OK;
    
  done:
    return hr;
}


HRESULT
HTMLImage::SetSize(DWORD width, DWORD height)
{
    HRESULT hr;

    if (!m_ddsurf ||
        width != m_width ||
        height != m_height)
    {
        m_ddsurf.Release();

        hr = THR(CreateOffscreenSurface(NULL,
                                        &m_ddsurf,
                                        NULL,
                                        false,
                                        width,
                                        height));

        if (FAILED(hr))
        {
            TraceTag((tagError,
                      "HTMLImage(%lx)::Update: CreateOffscreenSurface failed - %hr",
                      this,
                      hr));

            goto done;
        }

        m_width = width;
        m_height = height;
    }
    
    hr = S_OK;
  done:
    return hr;
}


HRESULT
HTMLImage::Paint(HDC hdc, LPRECT prc)
{
    TraceTag((tagHTMLImg,
              "HTMLImage(%lx)::Paint(%lx, (%d, %d, %d, %d))",
              this,
              hdc,
              prc->left,
              prc->top,
              prc->right,
              prc->bottom));
    
    HRESULT hr;

    RECT destRect = { 0, 0, m_width, m_height };

    TraceTag((tagHTMLImg,
              "HTMLImage(%lx)::Paint - clipbox(%d, %d, %d, %d)",
              this,
              destRect.left,destRect.top,destRect.right,destRect.bottom));
    
    hr = CopyDCToDdrawSurface(hdc,
                              prc,
                              m_ddsurf,
                              &destRect);
                              
    if (FAILED(hr))
    {
        TraceTag((tagError,
                  "HTMLImage(%lx)::Paint: CopyDCToDdrawSurface failed - %hr",
                  this,
                  hr));
        
        goto done;
    }

    hr = Update();
  done:
    return hr;
}


HRESULT
HTMLImage::Update()
{
    TraceTag((tagHTMLImg,
              "HTMLImage(%lx)::Update()",
              this));
    
    HRESULT hr;

    CRImagePtr newimg;

    {
        CRLockGrabber __gclg;
        
        newimg = CRImportDirectDrawSurface (m_ddsurf, NULL);
        
        if (newimg == NULL)
        {
            TraceTag((tagError,
                      "HTMLImage(%lx)::Update(): Failed to import ddraw surface - %hr, %ls",
                      this,
                      CRGetLastError(),
                      CRGetLastErrorString()));
            
            hr = CRGetLastError();
            goto done;
        }
        
        if (!CRSwitchTo((CRBvrPtr) m_image.p,
                        (CRBvrPtr) newimg,
                        false,
                        0,
                        0.0))
        {
            TraceTag((tagError,
                      "HTMLImage(%lx)::Update(): Failed to switch import ddraw surface - %hr, %ls",
                      this,
                      CRGetLastError(),
                      CRGetLastErrorString()));
            
            hr = CRGetLastError();
            goto done;
        }
    }
                    
    hr = S_OK;
  done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include "include/headers.h"
#include "datime.h"
#include "comutil.h"
#include "dartapi.h"
#include "mmapi.h"
#include "util.h"
#include <list>
#include "array.h"


#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\factory.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _FACTORY_H
#define _FACTORY_H

#define LIBID __T("TIME")

#include "timeman.h"

class ATL_NO_VTABLE CTIMEFactory
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CComCoClass<CTIMEFactory, &CLSID_TIMEFactory>,
      public IDispatchImpl<ITIMEFactory, &IID_ITIMEFactory, &LIBID_TIME>,
      public ISupportErrorInfoImpl<&IID_ITIMEFactory>,
      public IElementBehaviorFactory,
      public IObjectSafety
{
  public:
    CTIMEFactory();
    ~CTIMEFactory();

    DA_DECLARE_NOT_AGGREGATABLE(CTIMEFactory);

    HRESULT FinalConstruct();
#if _DEBUG
    const _TCHAR * GetName() { return __T("CTIMEFactory"); }
#endif

    // IElementBehaviorFactory
    
    STDMETHOD(FindBehavior)(LPOLESTR pchNameSpace,
                            LPOLESTR pchTagName,
                            IElementBehaviorSite * pUnkArg,
                            IElementBehavior ** ppBehavior)
    {
        return FindBehavior(pchNameSpace, pchTagName, (IUnknown *) pUnkArg, ppBehavior);
    }

    STDMETHOD(FindBehavior)(LPOLESTR pchNameSpace,
                            LPOLESTR pchTagName,
                            IUnknown * pUnkArg,
                            IElementBehavior ** ppBehavior);

        // IObjectSafetyImpl
        STDMETHOD(SetInterfaceSafetyOptions)(
                                                        /* [in] */ REFIID riid,
                                                        /* [in] */ DWORD dwOptionSetMask,
                                                        /* [in] */ DWORD dwEnabledOptions);
        STDMETHOD(GetInterfaceSafetyOptions)(
                                                        /* [in] */ REFIID riid, 
                                                        /* [out] */DWORD *pdwSupportedOptions, 
                                                        /* [out] */DWORD *pdwEnabledOptions);

    // ITIMEFactory

    STDMETHOD(CreateTIMEElement)(REFIID riid, LPUNKNOWN pUnkElement, void ** ppOut);
    STDMETHOD(CreateTIMEBodyElement)(REFIID riid, void ** ppOut);
    STDMETHOD(CreateTIMEDAElement)(REFIID riid, void ** ppOut);
    STDMETHOD(CreateTIMEMediaElement)(REFIID riid, MediaType type, void ** ppOut);
    
    DECLARE_REGISTRY(CLSID_TIMEFactory,
                     LIBID __T(".TIMEFactory.1"),
                     LIBID __T(".TIMEFactory"),
                     0,
                     THREADFLAGS_BOTH);
    
    BEGIN_COM_MAP(CTIMEFactory)
        COM_INTERFACE_ENTRY(ITIMEFactory)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IObjectSafety)
        COM_INTERFACE_ENTRY(IElementBehaviorFactory)
    END_COM_MAP();

    HRESULT Error();

    
  protected:

    HRESULT GetHostElement (LPUNKNOWN pUnk, IHTMLElement **ppelHost);
    HRESULT GetScopeName (LPUNKNOWN pUnk, BSTR *pbstrScopeName);
    HRESULT CreateHostedTimeElement(REFIID riid, void **ppOut);
    HRESULT CreateTIMENamespaceElement (REFIID riid, LPUNKNOWN pUnk, LPWSTR wszTagSpecific, 
                                          void **ppBehavior);
    TimeManagerMap *m_tMMap;
    long m_dwSafety;
  private:
      bool IsBodyElementWithoutTime(IUnknown *pUnkArg);

};


#endif /* _FACTORY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\factory.cpp ===
/*******************************************************************************
 *                                                                              
 * Copyright (c) 1998 Microsoft Corporation
 *
 * Abstract:
 *
 *******************************************************************************/

#include "headers.h"
#include "factory.h"
#include "timeelm.h"
#include "daelm.h"
#include "bodyelm.h"
#include "mediaelm.h"

DeclareTag(tagFactory, "API", "CTIMEFactory methods");

CTIMEFactory::CTIMEFactory() :m_tMMap(NULL)
{
    TraceTag((tagFactory,
              "CTIMEFactory(%lx)::CTIMEFactory()",
              this));
}

CTIMEFactory::~CTIMEFactory()
{
    TraceTag((tagFactory,
              "CTIMEFactory(%lx)::~CTIMEFactory()",
              this));
}


HRESULT
CTIMEFactory::FinalConstruct()
{
    TraceTag((tagFactory,
              "CTIMEFactory(%lx)::FinalConstruct()",
              this));

    if (bFailedLoad)
        return E_FAIL;
    return S_OK;
}

HRESULT
CTIMEFactory::Error()
{
    TraceTag((tagFactory,
              "CTIMEFactory(%lx)::Error()",
              this));

    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    if (str)
        return CComCoClass<CTIMEFactory, &CLSID_TIMEFactory>::Error(str, IID_ITIMEFactory, hr);
    else
        return hr;
}

HRESULT
CTIMEFactory::GetHostElement (LPUNKNOWN pUnk, IHTMLElement **ppelHost)
{
    HRESULT hr = E_INVALIDARG;
        
    if (NULL != pUnk)
    {
        IElementBehaviorSite *piBvrSite = NULL;
        hr = THR(pUnk->QueryInterface(IID_IElementBehaviorSite, 
                                      reinterpret_cast<void **>(&piBvrSite)));
        if (SUCCEEDED(hr))
        {
            hr = THR(piBvrSite->GetElement(ppelHost));
            piBvrSite->Release();
            if(SUCCEEDED(hr))
            {
                if (NULL == *ppelHost)
                {
                    hr = E_FAIL;
                }
            }
        }
    }

    return hr;
} // GetHostElement

HRESULT
CTIMEFactory::GetScopeName (LPUNKNOWN pUnk, BSTR *pbstrScope)
{
    IHTMLElement *pelHost = NULL;
    HRESULT hr = GetHostElement(pUnk, &pelHost);

    if (SUCCEEDED(hr))
    {
        IHTMLElement2 *pel2Host = NULL;
        hr = THR(pelHost->QueryInterface(IID_IHTMLElement2, 
                                         reinterpret_cast<void **>(&pel2Host)));
        pelHost->Release();
        if (SUCCEEDED(hr))
        {
            hr = THR(pel2Host->get_scopeName(pbstrScope));
        }

        pel2Host->Release();
    }

    return hr;
} // GetScopeName

HRESULT
CTIMEFactory::CreateHostedTimeElement(REFIID riid, void **ppOut)
{

    DAComObject<CTIMEElement> *pNew;
    HRESULT hr = DAComObject<CTIMEElement>::CreateInstance(&pNew);

    if (!pNew) 
    {
        THR(hr = E_OUTOFMEMORY);
    } 
    else 
    {
        if (SUCCEEDED(hr)) 
        {
            THR(hr = pNew->QueryInterface(riid, ppOut));
        }
    }

    if (FAILED(hr))
    {
        delete pNew;
    }

    return hr;
} // CreateHostedTimeElement

HRESULT
CTIMEFactory::CreateTIMENamespaceElement (REFIID riid, LPUNKNOWN pUnk, LPWSTR wszTagSpecific, 
                                          void **ppBehavior)
{
    // The scope qualifier must be present.  It will not be present when 
    // the namespace is not declared in the page header.  In that case,
    // any code dependent on a proper scope name will silently fail.
    // We have no recourse against this happening.
    BSTR bstrScope = NULL;
    HRESULT hr = GetScopeName(pUnk, &bstrScope);

    if (0 == StrCmpIW(wszTagSpecific, WZ_MEDIA))
    {
        hr = CreateTIMEMediaElement(riid, MT_Media, ppBehavior);
    }
    else if (0 == StrCmpIW(wszTagSpecific, WZ_IMG) &&
            (0 != StrCmpIW(bstrScope, WZ_DEFAULT_SCOPE_NAME)))
    {
        hr = CreateTIMEMediaElement(riid, MT_Image, ppBehavior);
    }
    else if (0 == StrCmpIW(wszTagSpecific, WZ_AUDIO))
    {
        hr = CreateTIMEMediaElement(riid, MT_Audio, ppBehavior);
    }
    else if (0 == StrCmpIW(wszTagSpecific, WZ_VIDEO))
    {
        hr = CreateTIMEMediaElement(riid, MT_Video, ppBehavior);
    }
    else if (0 == StrCmpIW(wszTagSpecific, WZ_BODY))
    {
        hr = CreateTIMEBodyElement(riid, ppBehavior);
    }
    // By default, we glom onto an externally-created element.
    // This will work with html and other xml tags.
    else
    {
        hr = CreateHostedTimeElement(riid, ppBehavior);
    }

    ::SysFreeString(bstrScope);

    return hr;
} // CreateTIMENamespaceElement

STDMETHODIMP
CTIMEFactory::CreateTIMEElement(REFIID riid, LPUNKNOWN pUnk, void ** ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    IHTMLElement *pelmHost = NULL;
    HRESULT hr = GetHostElement(pUnk, &pelmHost);

    if (SUCCEEDED(hr))
    {
        BSTR bstrTag = NULL;
        
        hr = THR(pelmHost->get_tagName(&bstrTag));
        pelmHost->Release();
        if (SUCCEEDED(hr))
        {
            if (NULL != bstrTag)
            {
                hr = CreateTIMENamespaceElement(riid, pUnk, bstrTag, ppOut);
                ::SysFreeString(bstrTag);
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }
    }

    return hr;
} // CreateTIMEElement

STDMETHODIMP
CTIMEFactory::CreateTIMEBodyElement(REFIID riid, void ** ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    DAComObject<CTIMEBodyElement> *pNew;
    hr = DAComObject<CTIMEBodyElement>::CreateInstance(&pNew);

    if (!pNew) {
        THR(hr = E_OUTOFMEMORY);
    } else {
        if (SUCCEEDED(hr)) {
            THR(hr = pNew->QueryInterface(riid,
                                          ppOut));
        }
    }

    if (FAILED(hr))
        delete pNew;

    return hr;
}

STDMETHODIMP
CTIMEFactory::CreateTIMEDAElement(REFIID riid, void ** ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    DAComObject<CTIMEDAElement> *pNew;
    hr = DAComObject<CTIMEDAElement>::CreateInstance(&pNew);

    if (!pNew) {
        THR(hr = E_OUTOFMEMORY);
    } else {
        if (SUCCEEDED(hr)) {
            THR(hr = pNew->QueryInterface(riid,
                                          ppOut));
        }
    }

    if (FAILED(hr))
        delete pNew;

    return hr;
}

STDMETHODIMP
CTIMEFactory::CreateTIMEMediaElement(REFIID riid, MediaType type, void ** ppOut)
{
    CHECK_RETURN_SET_NULL(ppOut);
    
    HRESULT hr;
    
    DAComObject<CTIMEMediaElement> *pNew;
    hr = DAComObject<CTIMEMediaElement>::CreateInstance(&pNew);

    if (!pNew) {
        THR(hr = E_OUTOFMEMORY);
    } else {
        pNew->SetMediaType(type);
        if (SUCCEEDED(hr)) {
            THR(hr = pNew->QueryInterface(riid,
                                          ppOut));
        }
    }

    if (FAILED(hr))
        delete pNew;

    return hr;
}

// returns true if IUnknown contains a body element without a time behavior attatched.
bool CTIMEFactory::IsBodyElementWithoutTime(IUnknown *pUnkArg)
{
    bool fIsBody = false;

    HRESULT hr = E_FAIL;

    DAComPtr<IElementBehaviorSite>      pTempBehaviorSite;
    DAComPtr<IHTMLElement>              pTempElement;
    DAComPtr<IHTMLBodyElement>          pTempBody;
    
    hr = pUnkArg->QueryInterface(IID_IElementBehaviorSite, (void**)&pTempBehaviorSite);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pTempBehaviorSite->GetElement(&pTempElement);
    if (FAILED(hr))
    {
        goto done;
    }

    if (IsTIMEBodyElement(pTempElement))
    {
        goto done;
    }

    hr = pTempElement->QueryInterface(IID_IHTMLBodyElement, (void**)&pTempBody);
    if (FAILED(hr))
    {
        goto done;
    }
    
    fIsBody = true;
done:
    return fIsBody;
}


STDMETHODIMP 
CTIMEFactory::FindBehavior(LPOLESTR pchNameSpace,
                           LPOLESTR pchTagName,
                           IUnknown * pUnkArg,
                           IElementBehavior ** ppBehavior)
{
    TraceTag((tagFactory,
              "CTIMEFactory(%lx)::FindBehavior(%ls, %ls, %#x)",
              this, pchNameSpace, pchTagName, pUnkArg));

    // if we are in 16 or less color mode on the Primary Device, bail
    // Note: Multi-monitor API are currently unavailable in this build
    HWND hwndDesktop = NULL;
    hwndDesktop = GetDesktopWindow();
    if (NULL != hwndDesktop)
    {
        HDC hdcPrimaryDevice = NULL;
        hdcPrimaryDevice = GetDC(NULL);
        if (NULL != hdcPrimaryDevice)
        {
            int bpp = 32;
            bpp = GetDeviceCaps(hdcPrimaryDevice, BITSPIXEL);
            ReleaseDC(hwndDesktop, hdcPrimaryDevice);
            if (bpp <= 4)
            {
                // This prevents time bvrs from being created
                return E_FAIL;
            }
        }
    }

    CHECK_RETURN_SET_NULL(ppBehavior);

    HRESULT hr;

    if (IsBodyElementWithoutTime(pUnkArg))
    {
        hr = CreateTIMEBodyElement(IID_IElementBehavior,
                                   (void **) ppBehavior);
    }
    else if ((StrCmpIW(pchTagName, WZ_TIME_STYLE_PREFIX) == 0) ||
             (StrCmpIW(pchTagName, WZ_DEFAULT_TIME_STYLE_PREFIX) == 0))
    {
        hr = CreateTIMEElement(IID_IElementBehavior, pUnkArg,
                               (void **) ppBehavior);
    }
    else if ((StrCmpIW(pchTagName, WZ_TIMEDA_STYLE_PREFIX) == 0)  ||
             (StrCmpIW(pchTagName, WZ_DEFAULT_TIMEDA_STYLE_PREFIX) == 0))
    {
        hr = CreateTIMEDAElement(IID_IElementBehavior, (void **) ppBehavior);
    }
    else if ((StrCmpIW(pchTagName, WZ_TIMEMEDIA_STYLE_PREFIX) == 0)  ||
             (StrCmpIW(pchTagName, WZ_DEFAULT_TIMEMEDIA_STYLE_PREFIX) == 0))
    {
        hr = CreateTIMEMediaElement(IID_IElementBehavior,
                                   MT_Media,
                                   (void **) ppBehavior);
    }
    else
    {
        hr = E_NOTIMPL;
    }

    return hr;
}

STDMETHODIMP 
CTIMEFactory::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
    if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
        return E_POINTER;
    HRESULT hr = S_OK;

    if (riid == IID_IDispatch)
    {
        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
        *pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
    }
    else if (riid == IID_IPersistPropertyBag2 )
    {
        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
        *pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_DATA;
    }
    else
    {
        *pdwSupportedOptions = 0;
        *pdwEnabledOptions = 0;
        hr = E_NOINTERFACE;
    }
    return hr;
}

STDMETHODIMP
CTIMEFactory::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{       
        // If we're being asked to set our safe for scripting or
        // safe for initialization options then oblige
        if (riid == IID_IDispatch || riid == IID_IPersistPropertyBag2 )
        {
                // Store our current safety level to return in GetInterfaceSafetyOptions
                m_dwSafety = dwEnabledOptions & dwOptionSetMask;
                return S_OK;
        }

        return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\htmlimg.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: htmlimg.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _HTMLIMG_H
#define _HTMLIMG_H

/////////////////////////////////////////////////////////////////////////////
// HTMLImage

class HTMLImage
{
  public:
    HTMLImage();
    ~HTMLImage();
    
    HRESULT Init();
    HRESULT SetSize(DWORD width, DWORD height);
    HRESULT Paint(HDC hdc, LPRECT rect);
    HRESULT Update();

    CRImagePtr GetImage() { return m_image; }
    
  protected:
    CRPtr<CRImage>               m_image;
    DWORD                        m_width;
    DWORD                        m_height;
    DAComPtr<IDirectDrawSurface> m_ddsurf; 
};

#endif /* _HTMLIMG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\init.cpp ===
// Init.cpp : Implementation of CTIMEInit
#include "headers.h"
#include "init.h"

CTIMEInit::CTIMEInit(REFGUID iid) :
m_iid(iid)
{
}



STDMETHODIMP CTIMEInit::Init(IElementBehaviorSite * pBehaviorSite)
{
    HRESULT hRes = S_OK; 
    char **params;
    int  numParams;

    // save off the site..
    m_pBehaviorSite = pBehaviorSite;

    GetParamArray(params, numParams);

    IHTMLElement *element = NULL;
    // Get IHTMLElement so we can read off the tag info.
    if(SUCCEEDED(hRes)) {
        
        pBehaviorSite->GetElement(&element);
        
        // now run though the elements....

        // We know what tags we support, so get the data from them.
        USES_CONVERSION;
        CComVariant v;

        for(int i=0; i< numParams; i++) {
            BSTR bstrRet = SysAllocString( A2W(params[i]) );
            if(SUCCEEDED(element->getAttribute(bstrRet,0,&v))) {
                // we were able to get the element data so set it
                DISPID rgdispid;                
                if(SUCCEEDED(GetIDsOfNames(m_iid,
                                           &bstrRet,
                                           1,
                                           GetUserDefaultLCID(),
                                           &rgdispid))) {
                
                    UINT* puArgErr = 0;
                    DISPID propPutDispid = DISPID_PROPERTYPUT;
                    DISPPARAMS dispparams;
                
                    dispparams.rgvarg = &v;
                    dispparams.rgdispidNamedArgs = &propPutDispid;
                    dispparams.cArgs = 1;
                    dispparams.cNamedArgs = 1;

                    Invoke(rgdispid,
                            m_iid,
                            GetUserDefaultLCID(),
                            DISPATCH_PROPERTYPUT,
                            &dispparams,
                            NULL,
                            NULL,
                            puArgErr);
                }
            }
            SysFreeString(bstrRet);
        }   // end of for
    }
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\mmutil.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmutil.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "mmutil.h"
#include "timeelm.h"
#include "bodyelm.h"

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

DeclareTag(tagMMUTILBvr, "API", "MMBvr methods");
DeclareTag(tagMMUTILBaseBvr, "API", "MMBaseBvr methods");
DeclareTag(tagMMUTILPlayer, "API", "MMPlayer methods");
DeclareTag(tagMMUTILFactory, "API", "MMFactory methods");
DeclareTag(tagMMUTILTimeline, "API", "MMTimeline methods");
DeclareTag(tagMMUTILView, "API", "MMView methods");

ITIMEMMFactory * MMFactory::s_factory = NULL;
LONG MMFactory::s_refcount = 0;

MMBaseBvr::MMBaseBvr(CTIMEElementBase & elm, bool bFireEvents)
: m_elm(elm),
  m_bFireEvents(bFireEvents)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%lx)::MMBaseBvr(%lx,%d)",
              this,
              &elm,
              bFireEvents));

    MMFactory::AddRef();
}

MMBaseBvr::~MMBaseBvr()
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%lx)::~MMBaseBvr()",
              this));

    if (m_eventCB)
    {
        m_eventCB->SetMMBvr(NULL);
        m_eventCB.Release();
    }

    MMFactory::Release();
}

bool
MMBaseBvr::Init()
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%lx)::Init()",
              this));

    bool ok = false;
    
    if (MMFactory::GetFactory() == NULL)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    if (m_bFireEvents)
    {
        m_eventCB = NEW TIMEEventCB;
        
        if (!m_eventCB)
        {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }
        
        m_eventCB->SetMMBvr(this);
    }
    
    ok = true;
  done:
    return ok;
}

bool
MMBaseBvr::Begin(bool bAfterOffset)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%lx)::Begin(%d)",
              this,
              bAfterOffset));

    bool ok = false;
    HRESULT hr;
    
    Assert(m_bvr);
    
    hr = THR(m_bvr->Begin(bAfterOffset?VARIANT_TRUE:VARIANT_FALSE));

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

bool
MMBaseBvr::Reset(DWORD fCause)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%lx)::Begin(%d)",
              this));

    bool ok = false;
    HRESULT hr;
    
    Assert(m_bvr);
    
    hr = THR(m_bvr->Reset(fCause));

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

bool
MMBaseBvr::End()
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%lx)::End()",
              this));

    bool ok = false;
    HRESULT hr;
    
    if (m_bvr)
    {
        // Do not put a THR since this will fail a lot since we call
        // end to do all cleanup
        hr = m_bvr->End();
        
        if (FAILED(hr))
        {
            CRSetLastError(hr, NULL);
            goto done;
        }
    }

    ok = true;
  done:
    return ok;
}

bool
MMBaseBvr::Pause()
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%lx)::Pause()",
              this));

    bool ok = false;
    HRESULT hr;
    
    Assert(m_bvr);
    hr = THR(m_bvr->Pause());

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

bool
MMBaseBvr::Resume()
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%lx)::Resume()",
              this));

    bool ok = false;
    HRESULT hr;
    
    Assert(m_bvr);
    hr = THR(m_bvr->Run());

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

bool
MMBaseBvr::Seek(double time)
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%lx)::Seek(%g)",
              this));

    bool ok = false;
    HRESULT hr;
    
    Assert(m_bvr);
    hr = THR(m_bvr->Seek(time));

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

double
MMBaseBvr::GetLocalTime()
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%lx)::GetLocalTime()",
              this));

    double d = 0;
    
    if (m_bvr)
    {
        THR(m_bvr->get_LocalTime(&d));
    }

    return d;
}

double
MMBaseBvr::GetSegmentTime()
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%lx)::GetSegmentTime()",
              this));

    double d = 0;
    
    if (m_bvr)
    {
        THR(m_bvr->get_SegmentTime(&d));
    }

    return d;
}

MM_STATE
MMBaseBvr::GetPlayState()
{
    TraceTag((tagMMUTILBaseBvr,
              "MMBaseBvr(%lx)::GetPlayState()",
              this));

    MM_STATE s = MM_STOPPED_STATE;
    
    if (m_bvr)
    {
        THR(m_bvr->get_PlayState(&s));
    }

    return s;
}

bool
MMBaseBvr::Update()
{
    TraceTag((tagMMUTILBvr,
              "MMBaseBvr(%lx)::Update()",
              this));

    bool ok = false;
    // TODO: For now comment out - we need to get reset working otherwise this
    // never gets reset
    // End();
        
    // Now update the properties
    IGNORE_HR(m_bvr->put_StartOffset(m_elm.GetRealBeginTime()));
    IGNORE_HR(m_bvr->put_Duration(m_elm.GetRealDuration()));

    // Calc a decent number of repeats
    int reps;

    if (m_elm.GetRealRepeatTime() == HUGE_VAL)
    {
        reps = 0;
    }
    else if (m_elm.GetRealDuration() == HUGE_VAL)
    {
        reps = 1;
    }
    else
    {
        reps = ceil(m_elm.GetRealRepeatTime() /
                    m_elm.GetRealIntervalDuration());
    }
    
    IGNORE_HR(m_bvr->put_Repeat(reps));
    IGNORE_HR(m_bvr->put_RepeatDur(m_elm.GetRealRepeatTime()));

    // BUGBUG : Eventually change the corresponding names on mmapi.
    IGNORE_HR(m_bvr->put_EaseIn(m_elm.GetFractionalAcceleration()));
    IGNORE_HR(m_bvr->put_EaseOut(m_elm.GetFractionalDeceleration()));
    // Force defaults on the start/end values.
    IGNORE_HR(m_bvr->put_EaseInStart(0));
    IGNORE_HR(m_bvr->put_EaseOutEnd(0));

    IGNORE_HR(m_bvr->put_AutoReverse(m_elm.GetAutoReverse()));

    DWORD syncflags;

    syncflags = 0;

    if (m_elm.IsLocked())
    {
        syncflags |= MM_LOCKED;
    }
    
    if (m_elm.NeedSyncCB())
    {
        syncflags |= MM_CLOCKSOURCE;
    }
    
    IGNORE_HR(m_bvr->put_SyncFlags(syncflags));
    
    float fltEndOffset = 0.0f;
    if (m_elm.GetEndHold())
    {
        fltEndOffset = HUGE_VAL;
    }
    IGNORE_HR(m_bvr->put_EndOffset(fltEndOffset));

    // Get the total time from the behavior
    IGNORE_HR(m_bvr->get_TotalTime(&m_totalTime));
    
    // Add my callback
    IGNORE_HR(m_bvr->put_EventCB(m_eventCB));
    
    ok = true;

    return ok;
}

MMBaseBvr::TIMEEventCB::TIMEEventCB()
: m_mmbvr(NULL),
  m_cRef(0)
{
}

MMBaseBvr::TIMEEventCB::~TIMEEventCB()
{
    Assert (m_cRef == 0);
}
        
STDMETHODIMP_(ULONG)
MMBaseBvr::TIMEEventCB::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
MMBaseBvr::TIMEEventCB::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
MMBaseBvr::TIMEEventCB::QueryInterface(REFIID riid, void **ppv)
{
    CHECK_RETURN_SET_NULL(ppv);

    if (InlineIsEqualUnknown(riid))
    {
        *ppv = (void *)(IUnknown *)this;
    }
    else if (InlineIsEqualGUID(riid, IID_ITIMEMMEventCB))
    {
        *ppv = (void *)(ITIMEMMEventCB *)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

STDMETHODIMP
MMBaseBvr::TIMEEventCB::OnEvent(double dblLocalTime,
                                ITIMEMMBehavior * mmbvr,
                                MM_EVENT_TYPE et,
                                DWORD flags)
{
    if (!m_mmbvr)
    {
        goto done;
    }

    Assert(m_mmbvr->m_bFireEvents);
    
    TIME_EVENT newet;
        
    switch(et)
    {
      case MM_PLAY_EVENT:
        newet = TE_ONBEGIN;
        break;
      case MM_STOP_EVENT:
        newet = TE_ONEND;
        break;
      case MM_REPEAT_EVENT:
        newet = TE_ONREPEAT;
        break;
      case MM_AUTOREVERSE_EVENT:
        newet = TE_ONREVERSE;
        break;
      case MM_PAUSE_EVENT:
        newet = TE_ONPAUSE;
        break;
      case MM_RESUME_EVENT:
        newet = TE_ONRESUME;
        break;
      case MM_RESET_EVENT:
        newet = TE_ONRESET;
        break;
      default:
        goto done;
    }
        
    m_mmbvr->m_elm.FireEvent(newet, dblLocalTime, flags);
    
  done:
    return S_OK;
}

STDMETHODIMP
MMBaseBvr::TIMEEventCB::OnTick(double lastTime,
                               double nextTime,
                               ITIMEMMBehavior *,
                               double * newTime)
{
    CHECK_RETURN_NULL(newTime);

    // Initialize to the same time
    
    *newTime = nextTime;

    if (!m_mmbvr)
    {
        goto done;
    }
    
    m_mmbvr->m_elm.OnSync(lastTime, *newTime);
    
  done:
    return S_OK;
}

/////////////////////////////////////////////////////////////////////
// MMBvr
/////////////////////////////////////////////////////////////////////

MMBvr::MMBvr(CTIMEElementBase & elm, bool bFireEvents, bool fNeedSyncCB)
: MMBaseBvr(elm,bFireEvents),
   m_fNeedSyncCB(fNeedSyncCB)

{
    TraceTag((tagMMUTILBvr,
              "MMBvr(%lx)::MMBvr(%lx,%d)",
              this,
              &elm,
              bFireEvents));
}

MMBvr::~MMBvr()
{
    TraceTag((tagMMUTILBvr,
              "MMBvr(%lx)::~MMBvr()",
              this));
}

bool
MMBvr::Init(CRBvrPtr bvr)
{
    TraceTag((tagMMUTILBvr,
              "MMBvr(%lx)::Init(%#lx)",
              this,
              bvr));

    bool ok = false;
    HRESULT hr;
    DAComPtr<IDABehavior> dabvr;
    DAComPtr<IUnknown> punk;

    if (!MMBaseBvr::Init())
    {
        hr = CRGetLastError();
        goto done;
    }
    
    if (!CRBvrToCOM(bvr,
                    IID_IDABehavior,
                    (void **) &dabvr))
    {
        goto done;
    }
        
    hr = THR(MMFactory::GetFactory()->CreateBehavior(m_elm.GetID(), dabvr, &punk));
    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }
    
    hr = THR(punk->QueryInterface(IID_ITIMEMMBehavior, (void**)&m_bvr));
    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

//
// MMFactory
//

// TODO: Need to add a critsect
LONG
MMFactory::AddRef()
{
    if (s_refcount == 0)
    {
        if (s_factory)
        {
            s_factory->Release();
            s_factory = NULL;
        }
        
        HRESULT hr;
        hr = THR(CoCreateInstance(CLSID_TIMEMMFactory,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_ITIMEMMFactory,
                                  (void **) &s_factory));

        if(FAILED(hr))
        {
            goto done;
        }
    }

    s_refcount++;
    
  done:
    return s_refcount;
}

LONG
MMFactory::Release()
{
    s_refcount--;

    if (s_refcount == 0)
    {
        s_factory->Release();
        s_factory = NULL;
    }

    return s_refcount;
}

// =======================================================================
//
// MMTimeline
//
// =======================================================================

MMTimeline::MMTimeline(CTIMEElementBase & elm, bool bFireEvents)
: MMBaseBvr(elm,bFireEvents),
    m_player(NULL)
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%lx)::MMTimeline(%lx,%d)",
              this,
              &elm,
              bFireEvents));
}

MMTimeline::~MMTimeline()
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%lx)::~MMTimeline()",
              this));
    if (m_player != NULL)
    {
        m_player->ClearTimeline();
        m_player = NULL;
    }
}

bool
MMTimeline::Init()
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%lx)::Init()",
              this));

    bool ok = false;
    DAComPtr<IUnknown> punk;
    HRESULT hr;
    
    if (!MMBaseBvr::Init())
    {
        goto done;
    }
    
    hr = THR(MMFactory::GetFactory()->CreateTimeline(m_elm.GetID(), &punk));
    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }
    
    hr = THR(punk->QueryInterface(IID_ITIMEMMTimeline, (void**)&m_timeline));

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }
    
    m_bvr = m_timeline;
    
    ok = true;
  done:
    return ok;
}

bool
MMTimeline::AddBehavior(MMBaseBvr & bvr)
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%lx)::AddBehavior(%#lx)",
              this,
              &bvr));

    bool ok = false;
    HRESULT hr;
    MM_START_TYPE st;
    LPOLESTR id;
    bool fHasDependent = false;
    CTIMEElementBase *pelm = &bvr.GetElement();
    CTIMEElementBase *pParent = pelm->GetParent();
    bool fInSequence = ((pParent != NULL) && pParent->IsSequence());
    int nIndex = 0;
    CPtrAry<MMBaseBvr *> notSolvedFromPending;


    if (!bvr.GetMMBvr())
    {
        TraceTag((tagError,
                  "MMTimeline::AddBehavior: Invalid bvr passed in - ITIMEMMBehavior NULL"));
                  
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    // Figure out if we have dependents or an event - store the start
    // type in st
    // if we are in a sequence, we ignore all of the dependents
    if (!fInSequence)
    {
        if (pelm->GetBeginWith() != NULL)
        {
            if (pelm->GetBeginAfter() != NULL ||
                pelm->GetBeginEvent() != NULL)
            {
                CRSetLastError(E_INVALIDARG, NULL);
                goto done;
            }

            st = MM_START_WITH;
            id = pelm->GetBeginWith();
            fHasDependent = true;
        }
        else if (pelm->GetBeginAfter() != NULL)
        {
            if (pelm->GetBeginWith() != NULL ||
                pelm->GetBeginEvent() != NULL)
            {
                CRSetLastError(E_INVALIDARG, NULL);
                goto done;
            }

            st = MM_START_AFTER;
            id = pelm->GetBeginAfter();
            fHasDependent = true;
        }
        else if (pelm->GetBeginEvent() != NULL)
        {
            if (pelm->GetBeginWith() != NULL ||
                pelm->GetBeginAfter() != NULL)
            {
                CRSetLastError(E_INVALIDARG, NULL);
                goto done;
            }

            st = MM_START_EVENT;
            id = NULL;
        }
        else
        {
            st = MM_START_ABSOLUTE;
            id = NULL;
        }
    }
    else
    {
        // get index of current child from parent
        Assert(pParent != NULL);
        nIndex = pParent->GetTimeChildIndex(pelm);
        if (nIndex == 0)
        {
            st = MM_START_ABSOLUTE;
            id = NULL;
        }
        else
        {
            st = MM_START_AFTER;
            fHasDependent = true;
        }
    }

    MMBaseBvr * base;
    
    // Now determine if we can get our base if we need it
    if (fHasDependent)
    {
        int i;

        if (!fInSequence)
            i = FindID(id, m_children);
        else
            i = FindID(pParent->GetChild(nIndex-1), m_children);

        if (i == -1)
        {
            hr = THR(m_pending.Append(&bvr));
            
            if (FAILED(hr))
            {
                CRSetLastError(hr, NULL);
                goto done;
            }
            
            ok = true;
            goto done;
        }
        else
        {
            base = m_children[i];
        }
    }
    else
    {
        base = NULL;
    }
    
    hr = THR(m_children.Append(&bvr));

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }
    
    hr = THR(m_timeline->AddBehavior(bvr.GetMMBvr(),
                                     st,
                                     base?base->GetMMBvr():NULL));
    
    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    // Now that we have added the child we need to make sure all any
    // pending children who were waiting for this behavior have also
    // been added

    LPOLESTR curid;
    MMBaseBvr *testAgainstBvr;
    testAgainstBvr = &bvr;
    THR(notSolvedFromPending.Append(testAgainstBvr));

    while(notSolvedFromPending.Size() > 0)
    {
        testAgainstBvr = notSolvedFromPending.Item(0);
        curid = testAgainstBvr->GetElement().GetID();

        // If my id is NULL then no one could be a dependent
        if (curid == NULL)
        {
            //ok = true;
            //goto done;
            notSolvedFromPending.DeleteItem(0);
            continue;
        }

        int    i;
        MMBaseBvr **ppBvr;

        i = 0;
        ppBvr = m_pending;

        while (i < m_pending.Size())
        {
            LPOLESTR dep;
            MM_START_TYPE st;

            if ((*ppBvr)->GetElement().GetBeginWith() != NULL)
            {
                Assert((*ppBvr)->GetElement().GetBeginAfter() == NULL);
            
                dep = (*ppBvr)->GetElement().GetBeginWith();
                st = MM_START_WITH;
            }
            else
            {
                dep = (*ppBvr)->GetElement().GetBeginAfter();
                st = MM_START_AFTER;
            }
        
            Assert(dep != NULL);

            if (StrCmpIW(dep, curid) == 0)
            {
                hr = THR(m_timeline->AddBehavior((*ppBvr)->GetMMBvr(),
                                                st,
                                                testAgainstBvr->GetMMBvr()));
            
                hr = THR(m_children.Append((*ppBvr)));

                // Not sure what to do on failure
                // TODO: Need to figure out how to handle this error
                // condition
            
                notSolvedFromPending.Append(m_pending.Item(i));
                m_pending.DeleteItem(i);

                // Do not increment the pointers since the elements have
                // been shifted down
            }
            else
            {
                i++;
                ppBvr++;
            }
        }
        notSolvedFromPending.DeleteItem(0);
    }

    ok = true;
  done:

    if (!ok)
    {
        RemoveBehavior(bvr);
    }
    
    return ok;
}

void
MMTimeline::RemoveBehavior(MMBaseBvr & bvr)
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%lx)::RemoveBehavior(%#lx)",
              this,
              &bvr));

    if (bvr.GetMMBvr())
    {
        m_timeline->RemoveBehavior(bvr.GetMMBvr());
    }

    m_children.DeleteByValue(&bvr);
    m_pending.DeleteByValue(&bvr);

    // TODO:
    // We should recalc dependents on this behavior and move them from
    // children to pending but not right now.
    MoveDependentsToPending(&bvr);
}

void 
MMTimeline::MoveDependentsToPending(MMBaseBvr * bvr)
{
    Assert(NULL != bvr);
    HRESULT hr = S_OK;
    
    // If id is NULL then "bvr" can't have dependents
    if (NULL == bvr->GetElement().GetID())
    {
        return;
    }

    // Dependents are found by traversing the dependency graph rooted at "bvr".
    // A temporary Array is used as a "queue" for traversing the graph breadth-first. 
    // Siblings directly or indirectly dependent on "bvr" will be stored in this Array
    CPtrAry<MMBaseBvr *> tempArray;

    // Initialization: insert "bvr" into temp Array
    hr = THR(tempArray.Append(bvr));
    Assert(SUCCEEDED(hr));

    int iCurBvr = 0;

    // iterate through temp Array and push dependents of CurBvr onto the back of temp Array
    while (iCurBvr < tempArray.Size())
    {
        // get id of current bvr
        LPOLESTR curid;
        curid = (tempArray[iCurBvr])->GetElement().GetID();

        Assert(NULL != curid);
        
        int i = 0;
        MMBaseBvr **ppChildBvr = m_children;

        // search for children that are dependents of CurBvr
        while (i < m_children.Size())
        {
            LPOLESTR dep = NULL;
            MM_START_TYPE st;

            // Get id of this child's start sibling
            if ((*ppChildBvr)->GetElement().GetBeginWith() != NULL)
            {
                Assert((*ppChildBvr)->GetElement().GetBeginAfter() == NULL);
            
                dep = (*ppChildBvr)->GetElement().GetBeginWith();
                st = MM_START_WITH;
            }
            else
            {
                dep = (*ppChildBvr)->GetElement().GetBeginAfter();
                st = MM_START_AFTER;
            }
        
            // if this child depends on CurBvr
            if ((NULL != dep) && (StrCmpIW(dep, curid) == 0))
            {
                // move it to the temp Array
                hr = THR(tempArray.Append((*ppChildBvr)));
                Assert(SUCCEEDED(hr));

                // Not sure what to do on failure
                // TODO: Need to figure out how to handle this error
                // condition
            
                m_children.DeleteItem(i);

                // Do not increment the pointers since the elements have
                // been shifted down
            }
            else
            {
                // continue to next child
                i++;
                ppChildBvr++;
            }
        } // while (m_children loop)

        iCurBvr++;

    } // while (tempArray loop)

    // Remove first element, i.e. "bvr",  from temp Array because it was put there to simplify
    // the traversal code
    tempArray.DeleteItem(0);

    // Call End() on all bvrs in temp Array
    MMBaseBvr **ppCurBvr = NULL;
    for (iCurBvr = 0, ppCurBvr = tempArray; iCurBvr < tempArray.Size(); iCurBvr++, ppCurBvr++)
    {
        if (true != (*ppCurBvr)->End())
        {
            // TODO: put trace or handle error code
        }
        // Remove the behavior from MMAPI because the rule we are enforcing is that
        // if a bvr is in the pending list in MMUTILS then it should not exist in MMAPI.
        // This avoids maintaining a separate copy of the pending list in MMAPI. 
        m_timeline->RemoveBehavior((*ppCurBvr)->GetMMBvr());
        // Append to m_pending
        hr = THR(m_pending.Append(*ppCurBvr));
        Assert(SUCCEEDED(hr));
    }
    
    // destroy temp Array
    tempArray.DeleteAll();
}

void
MMTimeline::Clear()
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%lx)::Clear()",
              this));

    // TODO: Need to flesh this out
}

int
MMTimeline::FindID(LPOLESTR id,
                    CPtrAry<MMBaseBvr *> & arr)
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline::FindID(%ls, %#lx)",
              id,
              &arr));

    int    i;
    MMBaseBvr **ppBvr;

    for (i = 0, ppBvr = arr; (unsigned)i < arr.Size(); i++, ppBvr++)
    {
        if (StrCmpIW((*ppBvr)->GetElement().GetID(), id) == 0)
        {
            return i;
        }
    }

    return -1;
}

int
MMTimeline::FindID(CTIMEElementBase *pelm,
                    CPtrAry<MMBaseBvr *> & arr)
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline::FindID(%ls, %#lx)",
              pelm,
              &arr));

    int    i;
    MMBaseBvr **ppBvr;
    
    if (pelm == NULL)
        return -1;

    for (i = 0, ppBvr = arr; (unsigned)i < arr.Size(); i++, ppBvr++)
    {
        // compare MMBaseBvr pointers
        if (&(pelm->GetMMBvr()) == *ppBvr)
        {
            return i;
        }
    }

    return -1;
}

bool
MMTimeline::Update()
{
    TraceTag((tagMMUTILTimeline,
              "MMTimeline(%lx)::Update()",
              this));

    bool ok = false;
        
    // Now update the timeline properties

    // Handle endsync
    LPOLESTR str = m_elm.GetEndSync();
    DWORD endSyncFlag = MM_ENDSYNC_NONE;
    
    if (str == NULL ||
        StrCmpIW(str, WZ_NONE) == 0)
    {
        endSyncFlag = MM_ENDSYNC_NONE;
    }
    else if (StrCmpIW(str, WZ_LAST) == 0)
    {
        endSyncFlag = MM_ENDSYNC_LAST;
    }
    else if (StrCmpIW(str, WZ_FIRST) == 0)
    {
        endSyncFlag = MM_ENDSYNC_FIRST;
    }

    IGNORE_HR(m_timeline->put_EndSync(endSyncFlag));

    if (!MMBaseBvr::Update())
    {
        goto done;
    }
    
    ok = true;
  done:
    return ok;
}

// ================================================================
//
// MMView
//
// ================================================================

MMView::MMView()
{
    TraceTag((tagMMUTILView,
              "MMView(%lx)::MMView()",
              this));

    MMFactory::AddRef();
}

MMView::~MMView()
{
    TraceTag((tagMMUTILView,
              "MMView(%lx)::~MMView()",
              this));

    Deinit();
    MMFactory::Release();
}

bool
MMView::Init(LPWSTR id,
             CRImagePtr img,
             CRSoundPtr snd,
             ITIMEMMViewSite * site)
{
    TraceTag((tagMMUTILView,
              "MMView(%lx)::Init(%ls, %lx, %lx, %lx)",
              this,
              id,
              img,
              snd,
              site));

    bool ok = false;
    HRESULT hr;
    DAComPtr<IUnknown> punk;
    DAComPtr<IDAImage> daimg;
    DAComPtr<IDASound> dasnd;
    
    if (MMFactory::GetFactory() == NULL)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    {
        CRLockGrabber __gclg;
        
        if (img)
        {
            if (!CRBvrToCOM((CRBvrPtr) img,
                            IID_IDAImage,
                            (void **) &daimg))
            {
                goto done;
            }
        }
        
        if (snd)
        {
            if (!CRBvrToCOM((CRBvrPtr) snd,
                            IID_IDASound,
                            (void **) &dasnd))
            {
                goto done;
            }
        }
    }
    
    hr = THR(MMFactory::GetFactory()->CreateView(id,
                                                 daimg,
                                                 dasnd,
                                                 (IUnknown *) site,
                                                 &punk));
    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }
    
    hr = THR(punk->QueryInterface(IID_ITIMEMMView, (void**)&m_view));
        
    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }
    
    ok = true;
  done:
    if (!ok)
    {
        m_view.Release();
    }
    
    return ok;
}

void
MMView::Deinit()
{
    TraceTag((tagMMUTILView,
              "MMView(%lx)::Deinit()",
              this));

    if(m_view)
        m_view.Release();
}

bool
MMView::Render(HDC hdc, LPRECT rect)
{
    TraceTag((tagMMUTILView,
              "MMView(%lx)::Render(%lx,[%lx,%lx,%lx,%lx])",
              this,
              hdc,
              rect->left,
              rect->right,
              rect->top,
              rect->bottom));

    bool ok = false;
    HRESULT hr;

    Assert(m_view);

    hr = THR(m_view->Draw(hdc, rect));

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}
    
bool
MMView::Tick()
{
    TraceTag((tagMMUTILView,
              "MMView(%lx)::Tick()",
              this));

    bool ok = false;
    HRESULT hr;

    Assert(m_view);

    hr = THR(m_view->Tick());

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

void
MMView::OnMouseMove(double when,
                    LONG xPos,LONG yPos,
                    BYTE modifiers)
{
    Assert(m_view);

    THR(m_view->OnMouseMove(when,
                            xPos,yPos,
                            modifiers));
}

void
MMView::OnMouseButton(double when,
                      LONG xPos, LONG yPos,
                      BYTE button,
                      VARIANT_BOOL bPressed,
                      BYTE modifiers)
{
    Assert(m_view);

    THR(m_view->OnMouseButton(when,
                              xPos,yPos,
                              button,
                              bPressed,
                              modifiers));
}

void
MMView::OnKey(double when,
              LONG key,
              VARIANT_BOOL bPressed,
              BYTE modifiers)
{
    Assert(m_view);

    THR(m_view->OnKey(when,
                      key,
                      bPressed,
                      modifiers));
}
    
void
MMView::OnFocus(VARIANT_BOOL bHasFocus)
{
    Assert(m_view);

    THR(m_view->OnFocus(bHasFocus));
}

//
// MMPlayer
//

MMPlayer::MMPlayer(CTIMEBodyElement & elm)
: m_elm(elm),
  m_timeline(NULL)
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%lx)::MMPlayer(%lx)",
              this,
              &elm));

    MMFactory::AddRef();
}

MMPlayer::~MMPlayer()
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%lx)::~MMPlayer()",
              this));

    if (m_timeline)
    {
        m_timeline->put_Player(NULL);
    }

    Deinit();
    MMFactory::Release();
}

bool
MMPlayer::Init(MMTimeline & tl)
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%lx)::Init(%lx)",
              this,
              &tl));

    bool ok = false;
    HRESULT hr;
    DAComPtr<IUnknown> punk;
    
    if (MMFactory::GetFactory() == NULL)
    {
        CRSetLastError(E_FAIL, NULL);
        goto done;
    }
    
    m_timeline = &tl;
    if (m_timeline != NULL)
    {
        m_timeline->put_Player(this);
    }

    hr = THR(MMFactory::GetFactory()->CreatePlayer(m_elm.GetID(),
                                                   m_timeline->GetMMTimeline(),
                                                   &m_elm,
                                                   &punk));
    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }
    
    hr = THR(punk->QueryInterface(IID_ITIMEMMPlayer, (void**)&m_player));
        
    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }
    
    m_clock.SetSink(this);
    
    hr = THR(m_clock.SetITimer(&m_elm, 33));
    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }
    
    ok = true;
  done:
    if (!ok)
    {
        m_player.Release();
    }
    
    return ok;
}

void
MMPlayer::Deinit()
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%lx)::Deinit()",
              this));

    if(m_player)
        m_player -> Shutdown();
    m_player.Release();
    m_clock.Stop();
}

bool
MMPlayer::Play()
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%lx)::Play()",
              this));

    bool ok = false;
    
    HRESULT hr;

    hr = THR(m_player->Play());

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    hr = THR(m_clock.Start());

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    // Tick the view at 0
    hr = THR(m_player->Tick(0.0));

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    if (!ok)
    {
        m_player->Stop();
        m_clock.Stop();
    }
    
    return ok;
}

bool
MMPlayer::Pause()
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%lx)::Pause()",
              this));

    bool ok = false;
    
    HRESULT hr;

    hr = THR(m_player->Pause());

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    hr = THR(m_clock.Pause());

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

bool
MMPlayer::Resume()
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%lx)::Resume()",
              this));

    bool ok = false;
    
    HRESULT hr;

    hr = THR(m_player->Resume());

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    hr = THR(m_clock.Resume());

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

bool
MMPlayer::Stop()
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%lx)::Stop()",
              this));

    bool ok = false;

    if (m_player)
        IGNORE_HR(m_player->Stop());
    IGNORE_HR(m_clock.Stop());
    
    ok = true;

    return ok;
}

bool
MMPlayer::Tick(double gTime)
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%lx)::Tick(%g)",
              this,
              gTime));

    bool ok = false;
    
    HRESULT hr;

    hr = THR(m_player->Tick(gTime));

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

bool 
MMPlayer::TickOnceWhenPaused()
{
    // DBL_EPSILON is defined in float.h such that
    // 1.0 + DBL_EPSILON != 1.0
    return Tick(GetCurrentTime() + DBL_EPSILON);
}


void
MMPlayer::OnTimer(double time)
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%lx)::OnTimer(%g)",
              this,
              time));

    Tick(time);
}

bool
MMPlayer::AddView(MMView & v)
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%lx)::AddView(%lx)",
              this,
              &v));

    HRESULT hr;
    bool ok = false;

    Assert(m_player);
    Assert(v.GetView());
    
    hr = THR(m_player->AddView(v.GetView()));

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok;
}

bool
MMPlayer::RemoveView(MMView & v)
{
    TraceTag((tagMMUTILPlayer,
              "MMPlayer(%lx)::RemoveView(%lx)",
              this,
              &v));

    HRESULT hr;
    bool ok = false;

    if (m_player && v.GetView())
    {
        hr = THR(m_player->RemoveView(v.GetView()));
        
        if (FAILED(hr))
        {
            CRSetLastError(hr, NULL);
            goto done;
        }
    }

    ok = true;
  done:
    return ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\init.h ===
// init.h : Declaration of the CTIMEInit

#ifndef __TIMEINIT_H_
#define __TIMEINIT_H_

/////////////////////////////////////////////////////////////////////////////
// CTIMEInit


class CTIMEInit :   
    public IElementBehavior,
    public IElementBehaviorRender
{
  public:
    CTIMEInit(REFGUID iid);
    STDMETHOD(Init)(IElementBehaviorSite * pBehaviorSite);
    IElementBehaviorSite *GetElementBehaviorSite(){return m_pBehaviorSite;};

    // virtual functions 
    STDMETHOD(GetIDsOfNames)(
        REFIID      riid,
        LPOLESTR *  rgszNames,
        UINT        cNames,
        LCID        lcid,
        DISPID *    rgdispid) = 0;

    STDMETHOD(Invoke)(
        DISPID          dispid, 
        REFIID          riid, 
        LCID            lcid, 
        WORD            wFlags, 
        DISPPARAMS *    pDispParams, 
        VARIANT *       pVarResult, 
        EXCEPINFO *     pExcepInfo, 
        unsigned int *  puArgErr) = 0;

     virtual void GetParamArray(char **&params, int &numParams)=0;

  public:
    REFGUID m_iid;
    DAComPtr<IElementBehaviorSite> m_pBehaviorSite;
};


#endif //__TIMEINIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\mediaelm.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mediaelm.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _MEDIAELM_H
#define _MEDIAELM_H

#include "daelmbase.h"
#include "containerobj.h"
#include "player.h"


/////////////////////////////////////////////////////////////////////////////
// CTIMEMediaElement

class
ATL_NO_VTABLE
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CTIMEMediaElement :
    public CDAElementBase,
    public CComCoClass<CTIMEMediaElement, &__uuidof(CTIMEMediaElement)>,
    public IDispatchImpl<ITIMEMediaElement, &IID_ITIMEMediaElement, &LIBID_TIME>,
    public ISupportErrorInfoImpl<&IID_ITIMEMediaElement>,
    public IConnectionPointContainerImpl<CTIMEMediaElement>,
    public IPersistPropertyBag2,
    public IPropertyNotifySinkCP<CTIMEMediaElement>,
    public IPropertyNotifySink
{
  public:
    CTIMEMediaElement();
    ~CTIMEMediaElement();
    void SetMediaType(MediaType mt);
        
#if _DEBUG
    const _TCHAR * GetName() { return __T("CTIMEMediaElement"); }
#endif

    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);
    STDMETHOD(Draw)(HDC hdc, LONG dwLayer, LPRECT prc, IUnknown * pParams);
    STDMETHOD(GetRenderInfo)(LONG *pdwRenderInfo); 
    STDMETHOD(Notify)(LONG event, VARIANT * pVar);
    STDMETHOD(Detach)();

    STDMETHOD(get_src)(VARIANT * url);
    STDMETHOD(put_src)(VARIANT url);

    STDMETHOD(get_img)(VARIANT * url);
    STDMETHOD(put_img)(VARIANT url);
        
    STDMETHOD(get_player)(VARIANT * clsid);
    STDMETHOD(put_player)(VARIANT clsid);
    
    STDMETHOD(get_type)(VARIANT * type);
    STDMETHOD(put_type)(VARIANT type);
    
    STDMETHOD(get_playerObject)(IDispatch **ppDisp);

    STDMETHOD(get_clockSource)(VARIANT_BOOL *fClockSource);
    STDMETHOD(put_clockSource)(VARIANT_BOOL fClockSource);

    STDMETHOD(get_clipBegin)(VARIANT * pvar);
    STDMETHOD(put_clipBegin)(VARIANT var);
    STDMETHOD(get_clipEnd)(VARIANT * pvar);
    STDMETHOD(put_clipEnd)(VARIANT var);

    //
    //IPersistPropertyBag2
    // 
    STDMETHOD(GetClassID)(CLSID* pclsid);
    STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void)
        {return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);


    // IPropertyNotifySink methods
    STDMETHOD(OnChanged)(DISPID dispID);
    STDMETHOD(OnRequestEdit)(DISPID dispID);
    STDMETHODIMP Invoke( DISPID id,
            REFIID riid,
            LCID lcid,
            WORD wFlags,
            DISPPARAMS *pDispParams,
            VARIANT *pvarResult,
            EXCEPINFO *pExcepInfo,
            UINT *puArgErr);

    //
    // ITIMEElement
    //

    STDMETHOD(get_begin)(VARIANT * time)
    { return base_get_begin(time); }
    STDMETHOD(put_begin)(VARIANT time)
    { return base_put_begin(time); }

    STDMETHOD(get_beginWith)(VARIANT * time)
    { return base_get_beginWith(time); }
    STDMETHOD(put_beginWith)(VARIANT time)
    { return base_put_beginWith(time); }

    STDMETHOD(get_beginAfter)(VARIANT * time)
    { return base_get_beginAfter(time); }
    STDMETHOD(put_beginAfter)(VARIANT time)
    { return base_put_beginAfter(time); }

    STDMETHOD(get_beginEvent)(VARIANT * time)
    { return base_get_beginEvent(time); }
    STDMETHOD(put_beginEvent)(VARIANT time)
    { return base_put_beginEvent(time); }

    STDMETHOD(get_dur)(VARIANT * time)
    { return base_get_dur(time); }
    STDMETHOD(put_dur)(VARIANT time)
    { clearNaturalDuration(); return base_put_dur(time); }

    STDMETHOD(get_end)(VARIANT * time)
    { return base_get_end(time); }
    STDMETHOD(put_end)(VARIANT time)
    { clearNaturalDuration(); return base_put_end(time); }

    STDMETHOD(get_endWith)(VARIANT * time)
    { return base_get_endWith(time); }
    STDMETHOD(put_endWith)(VARIANT time)
    { return base_put_endWith(time); }

    STDMETHOD(get_endEvent)(VARIANT * time)
    { return base_get_endEvent(time); }
    STDMETHOD(put_endEvent)(VARIANT time)
    { return base_put_endEvent(time); }

    STDMETHOD(get_endSync)(VARIANT * time)
    { return base_get_endSync(time); }
    STDMETHOD(put_endSync)(VARIANT time)
    { return base_put_endSync(time); }

    STDMETHOD(get_repeat)(VARIANT * time)
    { return base_get_repeat(time); }
    STDMETHOD(put_repeat)(VARIANT time)
    { return base_put_repeat(time); }

    STDMETHOD(get_repeatDur)(VARIANT * time)
    { return base_get_repeatDur(time); }
    STDMETHOD(put_repeatDur)(VARIANT time)
    { return base_put_repeatDur(time); }

    STDMETHOD(get_accelerate)(int * time)
    { return base_get_accelerate(time); }
    STDMETHOD(put_accelerate)(int time)
    { return base_put_accelerate(time); }

    STDMETHOD(get_decelerate)(int * time)
    { return base_get_decelerate(time); }
    STDMETHOD(put_decelerate)(int time)
    { return base_put_decelerate(time); }

    STDMETHOD(get_autoReverse)(VARIANT_BOOL * b)
    { return base_get_autoReverse(b); }
    STDMETHOD(put_autoReverse)(VARIANT_BOOL b)
    { return base_put_autoReverse(b); }

    STDMETHOD(get_endHold)(VARIANT_BOOL * b)
    { return base_get_endHold(b); }
    STDMETHOD(put_endHold)(VARIANT_BOOL b)
    { return base_put_endHold(b); }

    STDMETHOD(get_eventRestart)(VARIANT_BOOL * b)
    { return base_get_eventRestart(b); }
    STDMETHOD(put_eventRestart)(VARIANT_BOOL b)
    { return base_put_eventRestart(b); }

    STDMETHOD(get_timeAction)(LPOLESTR * time)
    { return base_get_timeAction(time); }
    STDMETHOD(put_timeAction)(LPOLESTR time)
    { return base_put_timeAction(time); }

    STDMETHOD(beginElement)()
    { return base_beginElement(true); }
    STDMETHOD(endElement)()
    { return base_endElement(); }
    STDMETHOD(pause)()
    { return base_pause(); }
    STDMETHOD(resume)()
    { return base_resume(); }
    STDMETHOD(cue)()
    { return base_cue(); }

    STDMETHOD(get_timeline)(BSTR *pbstrTimeLine)
    { return base_get_timeline(pbstrTimeLine); }
    STDMETHOD(put_timeline)(BSTR bstrTimeLine)
    { return base_put_timeline(bstrTimeLine); }

    STDMETHOD(get_currTime)(float * time)
    { return base_get_currTime(time); }
    STDMETHOD(put_currTime)(float time)
    { return base_put_currTime(time); }

    STDMETHOD(get_localTime)(float * time)
    { return base_get_localTime(time); }
    STDMETHOD(put_localTime)(float time)
    { return base_put_localTime(time); }

    STDMETHOD(get_currState)(LPOLESTR * state)
    { return base_get_currState(state); }
    STDMETHOD(put_currState)(LPOLESTR state)
    { return base_put_currState(state); }

    STDMETHOD(get_syncBehavior)(LPOLESTR * sync)
    { return base_get_syncBehavior(sync); }
    STDMETHOD(put_syncBehavior)(LPOLESTR sync)
    { return base_put_syncBehavior(sync); }

    STDMETHOD(get_syncTolerance)(VARIANT * tol)
    { return base_get_syncTolerance(tol); }
    STDMETHOD(put_syncTolerance)(VARIANT tol)
    { return base_put_syncTolerance(tol); }

    STDMETHOD(get_parentTIMEElement)(ITIMEElement **bvr)
    { return base_get_parentTIMEElement(bvr); }
    STDMETHOD(put_parentTIMEElement)(ITIMEElement *bvr)
    { return base_put_parentTIMEElement(bvr); }

    STDMETHOD(get_allTIMEElements)(/*[out, retval]*/ ITIMEElementCollection **ppDisp);
    STDMETHOD(get_childrenTIMEElements)(/*[out, retval]*/ ITIMEElementCollection **ppDisp);
    STDMETHOD(get_allTIMEInterfaces)(/*[out, retval]*/ ITIMEElementCollection **ppDisp);
    STDMETHOD(get_childrenTIMEInterfaces)(/*[out, retval]*/ ITIMEElementCollection **ppDisp);

    STDMETHOD(get_timelineBehavior)(IDispatch ** bvr)
    { return base_get_timelineBehavior(bvr); }
    STDMETHOD(get_progressBehavior)(IDispatch ** bvr)
    { return base_get_progressBehavior(bvr); }
    STDMETHOD(get_onOffBehavior)(IDispatch ** bvr)
    { return base_get_onOffBehavior(bvr); }

    virtual void OnLoad();
    virtual void OnBegin(double dblLocalTime, DWORD flags);
    virtual void OnEnd(double dblLocalTime);
    virtual void OnReset(double dblLocalTime, DWORD flags);
    virtual void OnPause(double dblLocalTime);
    virtual void OnResume(double dblLocalTime);
    virtual void OnSync(double dbllastTime, double & dblnewTime);
    virtual void OnRepeat(double dblLocalTime);

    virtual void OnUnload();

    // QI Map
    BEGIN_COM_MAP(CTIMEMediaElement)
        COM_INTERFACE_ENTRY(ITIMEMediaElement)
        COM_INTERFACE_ENTRY(ITIMEElement)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
        COM_INTERFACE_ENTRY(IPersistPropertyBag2)
        COM_INTERFACE_ENTRY_CHAIN(CDAElementBase)
        COM_INTERFACE_ENTRY(IPropertyNotifySink)
    END_COM_MAP();

    // Connection Point to allow IPropertyNotifySink
    BEGIN_CONNECTION_POINT_MAP(CTIMEMediaElement)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP();

    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    static inline HRESULT WINAPI
        InternalQueryInterface(CTIMEMediaElement* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject)
    { return BaseInternalQueryInterface(pThis,
                                        (void *) pThis,
                                        pEntries,
                                        iid,
                                        ppvObject); }

    // Needed by CBvrBase
    void * GetInstance()
    { return (ITIMEMediaElement *) this ; }
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }

    bool isNaturalDuration() { return m_fDurationIsNatural;}
    void clearNaturalDuration() { m_fDurationIsNatural = false;}
    void setNaturalDuration() { m_fDurationIsNatural = true;}
    
  protected:
    HRESULT Error();

    enum PROPERTY_INDEX
    {
        tme_src = teb_maxTIMEElementBaseProp, tme_img, 
        tme_player, tme_type, tme_clipBegin, tme_clipEnd, tme_clockSource,
        tme_maxTIMEMediaProp,
    };

    virtual HRESULT BuildPropertyNameList (CPtrAry<BSTR> *paryPropNames);
    virtual HRESULT SetPropertyByIndex(unsigned uIndex, VARIANT *pvarProp);
    virtual HRESULT GetPropertyByIndex(unsigned uIndex, VARIANT *pvarProp);
    virtual void SetPropertyFlag(DWORD uIndex);
    virtual void ClearPropertyFlag(DWORD uIndex);
    virtual bool IsPropertySet(DWORD uIndex);

    HRESULT GetPropertyBagInfo(CPtrAry<BSTR> **pparyPropNames);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);
    HRESULT GetNotifyConnection(IConnectionPoint **ppConnection);
    HRESULT InitPropertySink();
    HRESULT UnInitPropertySink();

    virtual bool NeedSyncCB();

    static LPWSTR ms_rgwszTMediaPropNames[];
    static CPtrAry<BSTR> ms_aryPropNames;
    static DWORD ms_dwNumTimeMediaElems;

    virtual HRESULT GetSize(RECT *prcPos);
    virtual HRESULT SetSize(const RECT *prcPos);

  private:
    HRESULT CalculateSeekTime(double *pdblTime);
    HRESULT RecreatePlayer();
    HRESULT CreatePlayer();

    LPOLESTR                    m_src;
    LPOLESTR                    m_img;
    LPOLESTR                    m_srcType;
    DAComPtr<IServiceProvider>  m_sp;
    MediaType                   m_type;
    CLSID                       m_playerCLSID;
    CTIMEPlayer                *m_Player;
    bool                        m_fClockSource;
    bool                        m_fLoaded;
    bool                        m_fExternalPlayer;
    DWORD                       m_mediaElementPropertyAccesFlags;
    RECT                        m_rcOrigSize;
    RECT                        m_rcMediaSize;
    bool                        m_fMediaSizeSet;
    DWORD                       m_dwAdviseCookie;
    bool                        m_fInOnChangedFlag;
    bool                        m_fDurationIsNatural;

};

inline HRESULT CTIMEMediaElement::get_allTIMEElements(ITIMEElementCollection **ppDisp)
{
    return base_get_collection(ciAllElements, ppDisp);
} // get_all

inline HRESULT CTIMEMediaElement::get_childrenTIMEElements(ITIMEElementCollection **ppDisp)
{
    return base_get_collection(ciChildrenElements, ppDisp);
} // get_children

inline HRESULT CTIMEMediaElement::get_allTIMEInterfaces(ITIMEElementCollection **ppDisp)
{
    return base_get_collection(ciAllInterfaces, ppDisp);
} // get_time_all

inline HRESULT CTIMEMediaElement::get_childrenTIMEInterfaces(ITIMEElementCollection **ppDisp)
{
    return base_get_collection(ciChildrenInterfaces, ppDisp);
} // get_time_children

inline bool 
CTIMEMediaElement::NeedSyncCB()
{   
    return true;
} // NeedSyncCB

#endif /* _MEDIAELM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\notify.h ===
#ifndef _NOTIFY_H
#define _NOTIFY_H


#include "daelmbase.h"
#include "containerobj.h"

class CTIMENotifyer : public CRUntilNotifier
{

  public:
    CTIMENotifyer(CTIMEElementBase *pelem) : m_cRef(1) , m_pTIMEElem(pelem){}

    ~CTIMENotifyer(){};
    
    
    CRSTDAPICB_(ULONG) AddRef() { return InterlockedIncrement(&m_cRef); }
    CRSTDAPICB_(ULONG) Release() {
        ULONG ul = InterlockedDecrement(&m_cRef) ;
        if (ul == 0) delete this;
        return ul;
    }

    virtual CRSTDAPICB_(CRBvrPtr) Notify(CRBvrPtr eventData,
                                         CRBvrPtr curRunningBvr,
                                         CRViewPtr curView) {
        
        RECT rc;
        Assert(m_pTIMEElem);
    
        if(SUCCEEDED(m_pTIMEElem->GetSize(&rc))) 
        {
            if( (rc.right  - rc.left == 0)  ||
                (rc.bottom - rc.top  == 0))
            {
                // need to pull out the size of the image..
                CRVector2Ptr crv2;
                double x;
                double y;

                crv2 = CRSub(CRMax((CRBbox2Ptr)eventData),CRMin((CRBbox2Ptr)eventData) );

                x = CRExtract(CRGetX(crv2));
                y = CRExtract(CRGetY(crv2));

                // need to convert to pixels from meters.
                HDC hdc = ::GetDC(NULL);
                if(hdc) {
                    int width  = ::GetDeviceCaps(hdc,LOGPIXELSX) * ((x * 100) / 2.54);
                    int height = ::GetDeviceCaps(hdc,LOGPIXELSY) * ((y * 100) / 2.54);
                    rc.bottom = height + rc.top;
                    rc.right  = width  + rc.left;
                    m_pTIMEElem->SetSize(&rc);
                    ::ReleaseDC(NULL,hdc);
                }
            }
        }

        m_pTIMEElem->InvalidateRect(NULL);

        return curRunningBvr ;
    }

  private:
    CTIMEElementBase   *m_pTIMEElem;
    long                m_cRef;

};

#endif /* _NOTIFY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\mmutil.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mmutil.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _MMUTIL_H
#define _MMUTIL_H

#include "mmapi.h"
#include "clock.h"
#include "float.h"

class CTIMEElementBase;
class MMPlayer;

class MMFactory
{
  public:
    static ITIMEMMFactory * GetFactory()
    { return s_factory; }

    // TODO: Might need a critsect
    static LONG AddRef();
    static LONG Release();
    static ITIMEMMFactory * s_factory;
    static LONG s_refcount;
};

class MMBaseBvr
{
  public:
    MMBaseBvr(CTIMEElementBase & elm, bool bFireEvents);
    virtual ~MMBaseBvr();

    bool Init();
    
    bool Begin(bool bAfterOffset);
    bool End();
    bool Pause();
    bool Resume();
    bool Reset(DWORD fCause = 0);

    bool Seek(double time);

    virtual bool Update();

    double GetLocalTime();
    double GetSegmentTime();
    double GetTotalTime()
    { return (double) m_totalTime; }
    MM_STATE GetPlayState();

    ITIMEMMBehavior * GetMMBvr()
    { return m_bvr; }
    CTIMEElementBase & GetElement()
    { return m_elm; }
  protected:
    CTIMEElementBase & m_elm;
    DAComPtr<ITIMEMMBehavior> m_bvr;
    float m_totalTime;
    bool m_bFireEvents;

    class TIMEEventCB :
        public ITIMEMMEventCB
    {
      public:
        TIMEEventCB();
        ~TIMEEventCB();
        
        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
        STDMETHOD(OnEvent)(double eventTime,
                           ITIMEMMBehavior *,
                           MM_EVENT_TYPE et,
                           DWORD flags);
        STDMETHOD(OnTick)(double lastTime,
                          double nextTime,
                          ITIMEMMBehavior *,
                          double * newTime);
    
        void SetMMBvr(MMBaseBvr * t) { m_mmbvr = t; }

      protected:
        // This is a weak pointer and it is our parent's responsibility to
        // NULL this out before it goes away
        MMBaseBvr * m_mmbvr;
        long m_cRef;
    };

    friend TIMEEventCB;

    DAComPtr<TIMEEventCB> m_eventCB;
};

class MMBvr
    : public MMBaseBvr
{
  public:
    MMBvr(CTIMEElementBase & elm, bool bFireEvents, bool fNeedSyncCB);
    ~MMBvr();

    bool Init(CRBvrPtr bvr);
  protected:
    bool m_fNeedSyncCB;
};

class MMTimeline :
    public MMBaseBvr
{
  public:
    MMTimeline(CTIMEElementBase & elm, bool bFireEvents);
    ~MMTimeline();
    
    bool Init();
    
    bool AddBehavior(MMBaseBvr & bvr);
    void RemoveBehavior(MMBaseBvr & bvr);
    void MoveDependentsToPending(MMBaseBvr * bvr);
    void Clear();
    
    virtual bool Update();

    ITIMEMMBehavior * GetMMBvr()
    { return m_timeline; }
    ITIMEMMTimeline * GetMMTimeline()
    { return m_timeline; }
    void put_Player(MMPlayer *player)
    { m_player = player; }

  protected:
    DAComPtr<ITIMEMMTimeline> m_timeline;

    // These are the children we have already added because we found
    // their base
    CPtrAry<MMBaseBvr *> m_children;

    // These are the children we have not added since we do not know
    // their base
    CPtrAry<MMBaseBvr *> m_pending;

    // Return -1 if it is not found
    static int FindID(LPOLESTR id, CPtrAry<MMBaseBvr *> & arr);
    static int FindID(CTIMEElementBase *pelm, CPtrAry<MMBaseBvr *> & arr);
  private:
     MMPlayer * m_player;
};

class MMView
{
  public:
    MMView();
    ~MMView();
    
    bool Init(LPWSTR id,
              CRImagePtr img,
              CRSoundPtr snd,
              ITIMEMMViewSite * site);
    
    void Deinit();

    bool Tick();
    bool Render(HDC hdc, LPRECT rect);
    
    void OnMouseMove(double when,
                     LONG xPos,LONG yPos,
                     BYTE modifiers);

    void OnMouseButton(double when,
                       LONG xPos, LONG yPos,
                       BYTE button,
                       VARIANT_BOOL bPressed,
                       BYTE modifiers);

    void OnKey(double when,
               LONG key,
               VARIANT_BOOL bPressed,
               BYTE modifiers);
    
    void OnFocus(VARIANT_BOOL bHasFocus);

    ITIMEMMView * GetView() { return m_view; }
  protected:
    DAComPtr<ITIMEMMView> m_view;
};

class CTIMEBodyElement;

class MMPlayer
    : public ClockSink
{
  public:
    MMPlayer(CTIMEBodyElement & elm);
    ~MMPlayer();
    
    bool Init(MMTimeline & tl);
    void Deinit();

    bool Play();
    bool Stop();
    bool Pause();
    bool Resume();
    bool Tick(double gTime);
    // This forces one tick, so updates will be drawn even 
    // when the clock and player are paused (used for editing)
    bool TickOnceWhenPaused(void);
    
    inline bool AddBehavior(MMBaseBvr & bvr)
    { return m_timeline->AddBehavior(bvr); }
    inline void RemoveBehavior(MMBaseBvr & bvr)
    { m_timeline->RemoveBehavior(bvr); }

    bool AddView(MMView & v);
    bool RemoveView(MMView & v);
    
    inline void Clear()
    { m_timeline->Clear(); }
    
    inline bool Update()
    { return m_timeline->Update(); }
    
    ITIMEMMPlayer * GetMMPlayer()
    { return m_player; }
    MMTimeline & GetTimeline()
    { return *m_timeline; }

    double GetCurrentTime()
    { return m_clock.GetCurrentTime(); }

    void ClearTimeline()
    { m_timeline = NULL; }

  protected:
    void OnTimer(double time);

  protected:
    CTIMEBodyElement & m_elm;
    MMTimeline * m_timeline;
    DAComPtr<ITIMEMMPlayer> m_player;
    Clock                   m_clock;
};

#endif /* _MMUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\mediaelm.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: mediaelm.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "mediaelm.h"
#include "bodyelm.h"
#include <mshtmdid.h>

// static class data.
CPtrAry<BSTR> CTIMEMediaElement::ms_aryPropNames;
DWORD CTIMEMediaElement::ms_dwNumTimeMediaElems = 0;

// These must align with the class PROPERTY_INDEX enumeration.
LPWSTR CTIMEMediaElement::ms_rgwszTMediaPropNames[] = {
    L"src", L"img", L"player", L"type", L"clipBegin", L"clipEnd", L"clockSource"
};

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  
DeclareTag(tagMediaTimeElm, "API", "CTIMEMediaElement methods");
DeclareTag(tagMediaElementOnChanged, "API", "CTIMEMediaElement OnChanged method");

#define DEFAULT_M_SRC NULL
#define DEFAULT_M_IMG NULL
#define DEFAULT_M_SRCTYPE NULL

// BUGBUG : jeffwall 04/03/99 the frame rate is a big assumption
// 1/24th of a second is the assumed frame rate.
#define WMP_FRAME_RATE 1.0/24.0

CTIMEMediaElement::CTIMEMediaElement()
: m_src(DEFAULT_M_SRC),
  m_img(DEFAULT_M_IMG),
  m_srcType(DEFAULT_M_SRCTYPE),
  m_Player(NULL),
  m_fClockSource(false),
  m_fLoaded(false),
  m_fExternalPlayer(false),
  m_mediaElementPropertyAccesFlags(0),
  m_fMediaSizeSet(false),
  m_dwAdviseCookie(0),
  m_fInOnChangedFlag(false),
  m_fDurationIsNatural(false)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::CTIMEMediaElement()",
              this));

    m_clsid = __uuidof(CTIMEMediaElement);
    CTIMEMediaElement::ms_dwNumTimeMediaElems++;
    
    m_rcOrigSize.bottom = m_rcOrigSize.left = m_rcOrigSize.right = m_rcOrigSize.top = 0;
    m_rcMediaSize.bottom = m_rcMediaSize.left = m_rcMediaSize.right = m_rcMediaSize.top = 0;
}

CTIMEMediaElement::~CTIMEMediaElement()
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::~CTIMEMediaElement()",
              this));
    
    delete m_src;
    delete m_img;
    delete m_srcType;
    if(m_Player)
    {
        m_Player->Stop();
        delete m_Player;
    }

    CTIMEMediaElement::ms_dwNumTimeMediaElems--;

    if (0 == CTIMEMediaElement::ms_dwNumTimeMediaElems)
    {
        int iNames = CTIMEMediaElement::ms_aryPropNames.Size();

        for (int i = iNames - 1; i >= 0; i--)
        {
            BSTR bstrName = CTIMEMediaElement::ms_aryPropNames[i];
            CTIMEMediaElement::ms_aryPropNames.DeleteItem(i);
            ::SysFreeString(bstrName);
        }
    }
}

void 
CTIMEMediaElement::SetMediaType(MediaType mt)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::SetMediaType()",
              this));
    m_type = mt;
}

HRESULT
CTIMEMediaElement::Init(IElementBehaviorSite * pBehaviorSite)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::Init()",
              this));

    HRESULT hr = E_FAIL; 
    DAComPtr<IHTMLElement2> pElem2;
    VARIANT_BOOL varboolSuccess;


    hr = THR(CDAElementBase::Init(pBehaviorSite));    
    if (FAILED(hr))
    {
        goto done;
    }    

    m_sp = GetServiceProvider();
    if (!m_sp)
    {
        TraceTag((tagError, "CTIMEMediaElement::Init - unable get QS"));
        hr = TIMESetLastError(DISP_E_TYPEMISMATCH, NULL);   
        goto done;
    }

    hr = CreatePlayer();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CTIMEElementBase::GetSize(&m_rcOrigSize);
    if (FAILED(hr))
        goto done;

    hr = InitPropertySink();
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(GetElement() != NULL);
    hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pElem2->attachEvent( L"onresize", this, &varboolSuccess);
    if (FAILED(hr))
    {
        goto done;
    }



    
    hr = S_OK;

done:
    return hr;
}

HRESULT
CTIMEMediaElement::CreatePlayer()
{
    Assert(NULL == m_Player);

    HRESULT hr = E_FAIL;
    m_Player = NEW CTIMEPlayer(this);
    if (m_Player == NULL)
    {
        TraceTag((tagError, "CTIMEMediaElement::Init - unable to alloc mem for CTIMEPlayer"));
        hr = TIMESetLastError(E_OUTOFMEMORY, NULL);
        goto done;
    }

    hr = m_Player->Init();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CTIMEMediaElement::Init - Init failed on CTIMEPlayer"));
        hr = TIMESetLastError(hr, NULL);
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEMediaElement::Error()
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::Error()",
              this));
    
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    if (str)
        return CComCoClass<CTIMEMediaElement, &__uuidof(CTIMEMediaElement)>::Error(str, IID_ITIMEMediaElement, hr);
    else
        return hr;
}


HRESULT
CTIMEMediaElement::Notify(LONG event, VARIANT * pVar)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::Notify()",
              this));

    THR(CDAElementBase::Notify(event, pVar));

    switch (event)
    {
      case BEHAVIOREVENT_DOCUMENTREADY:
        break;
    }

    return S_OK;
}

HRESULT
CTIMEMediaElement::Detach()
{
    DAComPtr<IHTMLElement2> pElem2;
    HRESULT hr;
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::Detach()",
              this));

    THR(UnInitPropertySink());
    Assert(GetElement() != NULL);
    hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
    if (SUCCEEDED(hr))
    {
        THR(pElem2->detachEvent(L"onresize", this));
    }

    if (NULL != m_Player)
    {
        m_Player->Stop();
        THR(m_Player->DetachFromHostElement());
    }

    THR(CDAElementBase::Detach());
    
    return S_OK;
}

HRESULT
CTIMEMediaElement::get_src(VARIANT * url)
{
    HRESULT hr;
    
    if (url == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(url))))
    {
        goto done;
    }
    
    V_VT(url) = VT_BSTR;
    V_BSTR(url) = SysAllocString(m_src);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEMediaElement::put_src(VARIANT url)
{
    CComVariant v;
    HRESULT hr;
    
    bool clearFlag = false;


    if(V_VT(&url) == VT_NULL)
    {
        clearFlag = true;
    }
    else
    {
        hr = v.ChangeType(VT_BSTR, &url);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    delete [] m_src;

    //processing the attribute change should be done here

    if(!clearFlag)
    {
        m_src = CopyString(V_BSTR(&v));
        SetPropertyFlagAndNotify(DISPID_TIMEMEDIAELEMENT_SRC, tme_src);
    }
    else
    {
        m_src = DEFAULT_M_SRC;
        ClearPropertyFlagAndNotify(DISPID_TIMEMEDIAELEMENT_SRC, tme_src);
    }

    if (m_fLoaded)
    {
        hr = RecreatePlayer();
        if (FAILED(hr))
            goto done;
    }
    VARIANT varMediaLength;
    VariantInit(&varMediaLength);

    if (isNaturalDuration() == true)
    {
        V_VT(&varMediaLength) = VT_NULL;
        put_dur(varMediaLength);
        put_end(varMediaLength);
    }

    hr = S_OK;

  done:

    return hr;
}

HRESULT
CTIMEMediaElement::RecreatePlayer()
{
    HRESULT hr = E_FAIL;

    Assert(m_Player != NULL);

    // need to get the time
    double dblTime;

    hr = CalculateSeekTime(&dblTime);
    if (FAILED(hr))
    {
        goto done;
    }

    m_Player->Stop();
    THR(m_Player->DetachFromHostElement());

    delete m_Player;
    m_Player = NULL;

    hr = CreatePlayer();
    if (FAILED(hr))
        goto done;

    m_Player->SetClockSource(m_fClockSource);
    
    hr = THR(m_Player->OnLoad(m_src, m_img, m_type));
    if (FAILED(hr))
        goto done;
    
    m_Player->Seek(dblTime);
    // turn on/off the behavior as appropriate
    m_mmbvr->Reset(MM_EVENT_PROPERTY_CHANGE);        


    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEMediaElement::CalculateSeekTime(double *pdblTime)
{
    HRESULT hr = E_FAIL;

    Assert(pdblTime != NULL);
    *pdblTime = 0;

    double dblTime;
    
    m_mmbvr->GetMMBvr()->get_SegmentTime(&dblTime);
    
    CTIMEElementBase *pBase = this;
    
    float flAdditionalOffset;
    
    m_mmbvr->GetMMBvr()->get_StartOffset(&flAdditionalOffset);
    
    while (HUGE_VAL == dblTime)
    {
        // End has been called on this element already -- we need to calculate where we should be                       
        if (pBase->GetParent() == NULL)
        {
            hr = S_OK;
            goto done;
        }

        Assert(pBase->GetParent() != NULL);
        
        MMBaseBvr& pMMbvr = pBase->GetParent()->GetMMBvr();
        ITIMEMMBehavior* pbvr = pMMbvr.GetMMBvr();
        
        Assert(pbvr != NULL);
        
        double dblLocalTime;            
        pbvr->get_LocalTime(&dblLocalTime);
        if (HUGE_VAL == dblLocalTime)
        {
            float flStartOffset;
            pbvr->get_StartOffset(&flStartOffset);
            if (flStartOffset != HUGE_VAL)
                flAdditionalOffset += flStartOffset;
        }
        else
        {
            dblTime = dblLocalTime - flAdditionalOffset ;
        }
        
        if (pBase->IsBody())
        {
            Assert(dblTime != HUGE_VAL);
            break;
        }

        pBase = pBase->GetParent();
    }
    
    if (dblTime < 0)
    {
        // the element hasn't even begun yet!
        dblTime = 0;
    }

    *pdblTime = dblTime;
    hr = S_OK;
done:
    return hr;
}
    
HRESULT
CTIMEMediaElement::get_img(VARIANT * url)
{
    HRESULT hr;
    
    if (url == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(url))))
    {
        goto done;
    }
    
    V_VT(url) = VT_BSTR;
    V_BSTR(url) = SysAllocString(m_img);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEMediaElement::put_img(VARIANT url)
{
    CComVariant v;
    HRESULT hr;
    bool clearFlag = false;


    if(V_VT(&url) == VT_NULL)
    {
        clearFlag = true;
    }
    else
    {
        hr = v.ChangeType(VT_BSTR, &url);

        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    
    delete [] m_img;
    //processing the attribute change should be done here

    if(!clearFlag)
    {
        m_img = CopyString(V_BSTR(&v));
        SetPropertyFlagAndNotify(DISPID_TIMEMEDIAELEMENT_IMG, tme_img);
    }
    else
    {
        m_img = DEFAULT_M_IMG;
        ClearPropertyFlagAndNotify(DISPID_TIMEMEDIAELEMENT_IMG, tme_img);
    }

    hr = S_OK;

  done:
    return hr;
}


HRESULT
CTIMEMediaElement::get_player(VARIANT  * clsid)
{
    HRESULT hr = E_FAIL;
    
    if (clsid == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(clsid))))
    {
        goto done;
    }
    
    V_VT(clsid) = VT_BSTR;
    LPOLESTR ppsz;
        
    if(FAILED(StringFromCLSID(m_playerCLSID, &ppsz)))
    {
        goto done;
    }

    V_BSTR(clsid) = SysAllocString(ppsz);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEMediaElement::put_player(VARIANT clsid)
{
    CComVariant v;
    HRESULT hr;
    bool clearFlag = false;
    
    if(V_VT(&clsid) == VT_NULL)
    {
        clearFlag = true;
    }
    else
    {
        hr = v.ChangeType(VT_BSTR, &clsid);
        if (FAILED(hr))
        {
            goto done;
        }
    
        if(FAILED(CLSIDFromString(V_BSTR(&v), &m_playerCLSID)))
        {
            // either not valid format or not in registry
            CRSetLastError(DISP_E_TYPEMISMATCH,NULL);   
            goto done;
        }
    }

    if(!clearFlag)
    {
        Assert(m_Player != NULL);
        m_Player->SetCLSID(m_playerCLSID);
        m_fExternalPlayer = true;
        SetPropertyFlagAndNotify(DISPID_TIMEMEDIAELEMENT_PLAYER, tme_player);
    }

    hr = S_OK;
    
  done:

    return hr;
}


HRESULT
CTIMEMediaElement::get_type(VARIANT * type)
{
    HRESULT hr;
    
    if (type == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(type))))
    {
        goto done;
    }
    
    V_VT(type) = VT_BSTR;
    V_BSTR(type) = SysAllocString(m_srcType);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEMediaElement::put_type(VARIANT type)
{
    CComVariant v;
    HRESULT hr;
    bool clearFlag = false;


    if(V_VT(&type) == VT_NULL)
    {
        clearFlag = true;
    }
    else
    {
        hr = v.ChangeType(VT_BSTR, &type);

        if (FAILED(hr))
        {
            goto done;
        }
    }
    
    
    delete [] m_srcType;
    //processing the attribute change should be done here

    if(!clearFlag)
    {
        m_srcType = CopyString(V_BSTR(&v));
        SetPropertyFlagAndNotify(DISPID_TIMEMEDIAELEMENT_SRCTYPE, tme_type);
    }
    else
    {
        m_srcType = DEFAULT_M_SRCTYPE;
        ClearPropertyFlagAndNotify(DISPID_TIMEMEDIAELEMENT_SRCTYPE, tme_type);
    }

    hr = S_OK;
    
  done:

    return hr;
}

HRESULT
CTIMEMediaElement::get_playerObject(IDispatch **ppDisp)
{
    TraceTag((tagMediaTimeElm, "CTIMEMediaElement::get_playerObject"));
    HRESULT hr;

    if (ppDisp == NULL)
    {
        TraceTag((tagError, "CTIMEMediaElement::get_playerObject - invalidarg"));
        return TIMESetLastError(E_POINTER, NULL);
    }

    *ppDisp = NULL;

    if (!m_fExternalPlayer)
    {
        TraceTag((tagError, "CTIMEMediaElement::get_playerObject - no external player set"));
        return TIMESetLastError(E_UNEXPECTED, NULL);
    }

    Assert(m_Player != NULL);
    
    hr = m_Player->GetExternalPlayerDispatch(ppDisp);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CTIMEMediaElement::get_playerObject - GetExternalPlayerDispatch() failed"));
        TIMESetLastError(hr, NULL);
    }
    return hr;    
}

HRESULT
CTIMEMediaElement::get_clockSource(VARIANT_BOOL *pfClockSource)
{
    TraceTag((tagMediaTimeElm, "CTIMEMediaElement::get_clockSource"));
    HRESULT hr = E_FAIL;

    if (pfClockSource == NULL)
    {
        TraceTag((tagError, "CTIMEMediaElement::get_clockSource - invalidarg"));
        hr = E_POINTER;
        goto done;
    }

    *pfClockSource = m_fClockSource ? VARIANT_TRUE : VARIANT_FALSE;
    hr = S_OK;

done:
    return hr;
}

HRESULT
CTIMEMediaElement::put_clockSource(VARIANT_BOOL fClockSource)
{
    TraceTag((tagMediaTimeElm, "CTIMEMediaElement::put_clockSource"));
    HRESULT hr;
    
    m_fClockSource = fClockSource ? true : false;
    
    m_Player->SetClockSource(m_fClockSource);

    if (NULL != m_mmbvr)
    {
        m_mmbvr->Update();
    }

    hr = S_OK;

    SetPropertyFlagAndNotify(DISPID_TIMEMEDIAELEMENT_CLOCKSOURCE, tme_clockSource);
    return hr;
}

void 
CTIMEMediaElement::OnLoad()
{
    if (!m_fLoaded)
    {
        m_Player->OnLoad(m_src, m_img, m_type);
        m_fLoaded = true;
    }
}

void
CTIMEMediaElement::OnSync(double dbllastTime, double & dblnewTime)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::OnSync() dbllastTime = %g dblnewTime = %g",
              this, dbllastTime, dblnewTime));

    if (m_fLoaded)
    {
        Assert(NULL != m_mmbvr);
        Assert(NULL != m_mmbvr->GetMMBvr());

        double dblSegTime = dbllastTime;
        int offset = 0;
        // copied from CMMBaseBvr::LocalTimeToSegmentTime
        if (m_realIntervalDuration != HUGE_VAL)
        {
            // we want the previous boundary, unless we are or a boundary then we want this repeat count
            offset = floor(dblSegTime / m_realIntervalDuration);
            if (offset < 0)
            {
                offset = 0;
            }
            
            dblSegTime = dblSegTime - (offset * m_realIntervalDuration);
        }

        double dblSavedNewTime = dblnewTime;
        m_Player->OnSync(dblSegTime, dblnewTime);
        if (m_fClockSource && m_realIntervalDuration != HUGE_VAL && dblnewTime != dblSavedNewTime)
        {
            dblnewTime = dblnewTime + offset * m_realIntervalDuration;
        }
    }
}

void
CTIMEMediaElement::OnBegin(double dblLocalTime, DWORD flags)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::OnBegin()",
              this));

    CDAElementBase::OnBegin(dblLocalTime, flags);

    Assert(NULL != m_mmbvr);
    Assert(NULL != m_mmbvr->GetMMBvr());

    double dblSegmentTime = 0;
    HRESULT hr = S_OK;
    hr = THR(m_mmbvr->GetMMBvr()->get_SegmentTime(&dblSegmentTime));
    if (FAILED(hr))
    {
        return;
    }

    // Check if this event was fired by our hack to make endhold work correctly
    // when seeking forward (over our lifespan) 
    if ((flags & MM_EVENT_SEEK) && HUGE_VAL == dblSegmentTime)
    {
        // if endhold isn't set, we shouldn't start the player, so bail
        if (!CTIMEElementBase::GetEndHold())
        {
            return;
        }
        // else we should, and show the last frame (below)
    }
    
    
    Assert(m_Player != NULL);

    //In the case of begin=0, it is possible for this to be called 
    //before the OnLoad method.  In this case we will initialize here
    //instead of in the onload event.
    if (!m_fLoaded)
    {
        m_Player->OnLoad(m_src, m_img, m_type);
        m_fLoaded = true;
    }
    
   
    double dblMediaLength = 0;
    if (NULL != m_Player->GetContainerObj())
    {
        hr = THR(m_Player->GetContainerObj()->GetMediaLength(dblMediaLength));
        if (FAILED(hr))
        {
            // if the media is not yet loaded or is infinite, we don't know the duration, so set the length forward enough.
            dblMediaLength = HUGE_VAL;
        }

        if (dblMediaLength >= dblSegmentTime)
        {        
            m_Player->Start(dblSegmentTime);
    
            hr = THR(m_Player->Seek(dblSegmentTime));
            if (FAILED(hr))
            {    
                return;
            }
        }
        else
        {
            m_Player->Start(dblMediaLength - WMP_FRAME_RATE);

            hr = THR(m_Player->Seek(dblMediaLength - WMP_FRAME_RATE));
            if (FAILED(hr))
            {
                return;
            }
        }
    }
    else
    {
        m_Player->Start(dblSegmentTime);
    }

    MM_STATE curState = GetBody()->GetPlayState();
    if (MM_PAUSED_STATE == curState)
    {
        OnPause(dblSegmentTime);
    }
}

void
CTIMEMediaElement::OnEnd(double dblLocalTime)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::OnEnd()",
              this));

    CDAElementBase::OnEnd(dblLocalTime);
    
    Assert(m_Player != NULL);
    m_Player->Stop();
}

void
CTIMEMediaElement::OnReset(double dblLocalTime, DWORD flags)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::OnReset()",
              this));

    CDAElementBase::OnReset(dblLocalTime, flags);
    
    Assert(m_Player != NULL);
    m_Player->Stop();
}

void
CTIMEMediaElement::OnPause(double dblLocalTime)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::OnPause()",
              this));

    CDAElementBase::OnPause(dblLocalTime);

    Assert(NULL != m_Player);
    m_Player->Pause();

}

void
CTIMEMediaElement::OnResume(double dblLocalTime)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::OnResume()",
              this));

    CDAElementBase::OnResume(dblLocalTime);
    
    Assert(NULL != m_mmbvr);
    Assert(NULL != m_mmbvr->GetMMBvr());
    Assert(NULL != m_Player);

    // If we can't get either segment time or media length, resume unconditionally,
    // else use the information to decide whether to pause 
    double dblSegmentTime = 0.0f;
    if (FAILED(THR(m_mmbvr->GetMMBvr()->get_SegmentTime(&dblSegmentTime))) 
        || NULL == m_Player->GetContainerObj())
    {
        m_Player->Resume();
    }
    else
    {
        HRESULT hr = S_OK;
        double dblMediaLength = 0.0f;
        hr = THR(m_Player->GetContainerObj()->GetMediaLength(dblMediaLength));
        if (FAILED(hr))
        {
            // if the media is not yet loaded or is infinite, we don't know the duration, so set the length forward enough.
            dblMediaLength = HUGE_VAL;
        }

        if (dblSegmentTime <= dblMediaLength)
        {        
             m_Player->Resume();
        }
    } 

} // OnResume

void CTIMEMediaElement::OnRepeat(double dblLocalTime)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::OnRepeat()",
              this));

    CDAElementBase::OnRepeat(dblLocalTime);
    Assert(m_Player != NULL);

    m_Player->Start(0);
}

void
CTIMEMediaElement::OnUnload()
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediaElement(%lx)::OnUnload()",
              this));

    if (m_Player)
    {
        m_Player->Stop();
    }

    CTIMEElementBase::OnUnload();
}

HRESULT
CTIMEMediaElement::get_clipBegin(VARIANT *pvar)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::get_clipBegin()",
              this));
    HRESULT hr;

    if (pvar == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    Assert(m_Player != NULL);
    hr = THR(m_Player->getClipBegin(pvar));

done:
    return hr;
}

HRESULT
CTIMEMediaElement::put_clipBegin(VARIANT var)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::put_clipBegin()",
              this));
    HRESULT hr;

    Assert(m_Player != NULL);
    hr = THR(m_Player->putClipBegin(var));

    SetPropertyFlagAndNotify(DISPID_TIMEMEDIAELEMENT_CLIPBEGIN, tme_clipBegin);
    return hr;
}

HRESULT
CTIMEMediaElement::get_clipEnd(VARIANT *pvar)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::get_clipEnd()",
              this));
    HRESULT hr;

    if (pvar == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    Assert(m_Player != NULL);
    hr = THR(m_Player->getClipEnd(pvar));

done:
    return hr;
}

HRESULT
CTIMEMediaElement::put_clipEnd(VARIANT var)
{
    TraceTag((tagMediaTimeElm,
              "CTIMEMediElement(%lx)::put_clipEnd()",
              this));
    HRESULT hr;

    Assert(m_Player != NULL);
    hr = THR(m_Player->putClipEnd(var));

    SetPropertyFlagAndNotify(DISPID_TIMEMEDIAELEMENT_CLIPEND, tme_clipEnd);
    return hr;
}

static bool IsEqual(RECT lhs, RECT rhs)
{
    bool equal = false;

    if (lhs.bottom != rhs.bottom)
        goto done;
    if (lhs.left != rhs.left)
        goto done;
    if (lhs.right != rhs.right)
        goto done;
    if (lhs.top != rhs.top)
        goto done;

    equal = true;

done:
    return equal;
}

HRESULT
CTIMEMediaElement::GetSize(RECT *prcPos)
{
    return CTIMEElementBase::GetSize(prcPos);
#if 0
    HRESULT hr = E_FAIL;
    
    RECT rcPos;
    hr = CTIMEElementBase::GetSize(&rcPos);
    if (FAILED(hr))
    {
        goto done;
    }

    if (IsEqual(rcPos, m_rcOrigSize) || ( m_fMediaSizeSet && IsEqual(rcPos, m_rcMediaSize) ) )
    {
        *prcPos = m_rcOrigSize;
    }
    else
    {
        // style must have changed -- use this as the new size
        m_rcOrigSize = rcPos;
        m_fMediaSizeSet = false;
        *prcPos = rcPos;
    }
    hr = S_OK;
done:
    return hr;
#endif
}

static void Sub(RECT *prcPos, RECT rcDelta)
{
    Assert(NULL != prcPos);
    (*prcPos).bottom -= rcDelta.bottom;
    (*prcPos).left -= rcDelta.left;
    (*prcPos).right -= rcDelta.right;
    (*prcPos).top -= rcDelta.top;
}

HRESULT 
CTIMEMediaElement::SetSize(const RECT *prcPos)
{
    HRESULT hr;
    //BUGBUG this ca be done without disconnecting the Notification

    hr = THR(UnInitPropertySink());
    if (FAILED(hr))
        goto done;
    hr = CTIMEElementBase::SetSize(prcPos);
    if (FAILED(hr))
        goto done;
    hr = THR(InitPropertySink());
    if (FAILED(hr))
        goto done;

done:
    return hr;
#if 0
    HRESULT hr = E_FAIL;
    
    RECT rcTemp = *prcPos;

    if (m_fMediaSizeSet)
    {
        // subtract the previous rect from this new rect
        Sub(&rcTemp, m_rcMediaSize); // rcTemp = rcTemp - m_rcMediaSize;
    }

    hr = CTIMEElementBase::SetSize(&rcTemp);

    m_fMediaSizeSet = true;
    
    hr = CTIMEElementBase::GetSize(&m_rcMediaSize);

    return hr;
#endif
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IElementBehaviorRender

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CTIMEMediaElement::GetRenderInfo(LONG *pdwRenderInfo)
{
    // Return the layers we are interested in drawing
//    *pdwRenderInfo = BEHAVIORRENDERINFO_BEFORECONTENT; //BEHAVIORRENDERINFO_AFTERCONTENT;
    // BUGBUG - need to provide user schema of setting this.
    // Note that we do the same thing daelm does.
    *pdwRenderInfo = BEHAVIORRENDERINFO_AFTERCONTENT;
    return S_OK;
}


HRESULT
CTIMEMediaElement::Draw(HDC hdc, LONG dwLayer, LPRECT prc, IUnknown * pParams)
{
    HRESULT hr = S_OK;

    if (m_fLoaded)
        hr = THR(m_Player->Render(hdc, prc));
    return hr;        
}


//*****************************************************************************

HRESULT 
CTIMEMediaElement::SetPropertyByIndex(unsigned uIndex, VARIANT *pvarprop)
{
    HRESULT hr = E_FAIL;
    // copy variant for conversion type
    VARIANT varTemp;
    VariantInit(&varTemp);
    hr = VariantCopyInd(&varTemp, pvarprop);
    if (FAILED(hr))
        return hr;

    // Rely on the enumeration interval to determine where to look for the property.
    if (teb_maxTIMEElementBaseProp > uIndex)
    {
        hr = CTIMEElementBase::SetPropertyByIndex(uIndex, pvarprop);
    }
    else if (tme_maxTIMEMediaProp > uIndex)
    {
        switch (uIndex)
        {
            case tme_src :
                hr = put_src(*pvarprop);
                break;
            case tme_img :
                hr = put_img(*pvarprop);
                break;
            case tme_player :
                hr = put_player(*pvarprop);
                break;
            case tme_type : 
                hr = put_type(*pvarprop);
                break;
            case tme_clipBegin :
                hr = put_clipBegin(*pvarprop);
                break;
            case tme_clipEnd :
                hr = put_clipEnd(*pvarprop);
                break;
            case tme_clockSource :
                hr = VariantChangeTypeEx(&varTemp, &varTemp, LCID_SCRIPTING, NULL, VT_BOOL);
                if (SUCCEEDED(hr))
                    hr = put_clockSource(V_BOOL(&varTemp));
                break;
        };
    }

    return hr;
} // SetPropertyByIndex

//*****************************************************************************

HRESULT 
CTIMEMediaElement::GetPropertyByIndex(unsigned uIndex, VARIANT *pvarprop)
{
    HRESULT hr = E_FAIL;

    // Rely on the enumeration interval to determine where to look for the property.
    if (teb_maxTIMEElementBaseProp > uIndex)
    {
        hr = CTIMEElementBase::GetPropertyByIndex(uIndex, pvarprop);
    }
    else if (tme_maxTIMEMediaProp > uIndex)
    {
        Assert(VT_EMPTY == V_VT(pvarprop));
        switch (uIndex)
        {
            case tme_src :
                hr = get_src(pvarprop);
                break;
            case tme_img :
                hr = get_img(pvarprop);
                break;
            case tme_player :
                hr = get_player(pvarprop);
                break;
            case tme_type : 
                hr = get_type(pvarprop);
                break;
            case tme_clipBegin :
                hr = get_clipBegin(pvarprop);
                break;
            case tme_clipEnd :
                hr = get_clipEnd(pvarprop);
                break;
            case tme_clockSource :
                hr = get_clockSource(&(V_BOOL(pvarprop)));
                if (SUCCEEDED(hr))
                {
                    V_VT(pvarprop) = VT_BOOL;
                }
                break;
        };
    }

    return hr;
} // GetPropertyByIndex

//*****************************************************************************

void CTIMEMediaElement::SetPropertyFlag(DWORD uIndex)
{
    DWORD relIndex;
    if (teb_maxTIMEElementBaseProp > uIndex)
    {
        CTIMEElementBase::SetPropertyFlag(uIndex);
        return;
    }

    relIndex = uIndex - teb_maxTIMEElementBaseProp;
    DWORD bitPosition = 1 << relIndex;
    m_mediaElementPropertyAccesFlags =  m_mediaElementPropertyAccesFlags | bitPosition;
}

void CTIMEMediaElement::ClearPropertyFlag(DWORD uIndex)
{
    DWORD relIndex;
    if (teb_maxTIMEElementBaseProp > uIndex)
    {
        CTIMEElementBase::ClearPropertyFlag(uIndex);
        return;
    }

    relIndex = uIndex - teb_maxTIMEElementBaseProp;
    DWORD bitPosition = 1 << relIndex;
    m_mediaElementPropertyAccesFlags =  m_mediaElementPropertyAccesFlags & (~bitPosition);
}

bool CTIMEMediaElement::IsPropertySet(DWORD uIndex)
{
    DWORD relIndex;

    if (teb_maxTIMEElementBaseProp > uIndex)
    {
        return CTIMEElementBase::IsPropertySet( uIndex);
    }

    relIndex = uIndex - teb_maxTIMEElementBaseProp;
    if( relIndex >= 32) return true;
    if( relIndex >= tme_maxTIMEMediaProp - teb_maxTIMEElementBaseProp) return true;
    DWORD bitPosition = 1 << relIndex;
    if(m_mediaElementPropertyAccesFlags & bitPosition)
        return true;
    return false;
}

HRESULT
CTIMEMediaElement::BuildPropertyNameList(CPtrAry<BSTR> *paryPropNames)
{
    // Start from the base class.
    HRESULT hr = CTIMEElementBase::BuildPropertyNameList(paryPropNames);

    if (SUCCEEDED(hr))
    {
        for (int i = teb_maxTIMEElementBaseProp; 
             (i < tme_maxTIMEMediaProp) && (SUCCEEDED(hr)); i++)
        {
            int iRelative = i - teb_maxTIMEElementBaseProp;
            Assert(NULL != ms_rgwszTMediaPropNames[iRelative]);
            BSTR bstrNewName = CreateTIMEAttrName(ms_rgwszTMediaPropNames[iRelative]);
            Assert(NULL != bstrNewName);
            if (NULL != bstrNewName)
            {
                hr = paryPropNames->Append(bstrNewName);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
} // BuildPropertyNameList

//*****************************************************************************

HRESULT 
CTIMEMediaElement::GetPropertyBagInfo(CPtrAry<BSTR> **pparyPropNames)
{
    HRESULT hr = S_OK;

    // If we haven't built this yet, build it now.
    if (0 == ms_aryPropNames.Size())
    {
        hr = BuildPropertyNameList(&(CTIMEMediaElement::ms_aryPropNames));
    }

    if (SUCCEEDED(hr))
    {
        *pparyPropNames = &(CTIMEMediaElement::ms_aryPropNames);
    }

    return hr;
} // GetPropertyBagInfo

//*****************************************************************************

HRESULT 
CTIMEMediaElement::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint

STDMETHODIMP
CTIMEMediaElement::OnRequestEdit(DISPID dispID)
{
    return S_OK;
}

STDMETHODIMP
CTIMEMediaElement::OnChanged(DISPID dispID)
{
    DAComPtr<IHTMLStyle> pStyle2;
    DAComPtr<IHTMLElement2> pElem2;
    DAComPtr<IHTMLStyle> s;
    VARIANT varStyleWidth, varStyleHeight;
    HRESULT hr = S_OK;

    if( m_fInOnChangedFlag == true)
        return S_OK;

    m_fInOnChangedFlag = true;

    switch(dispID)
    {
    case DISPID_IHTMLCURRENTSTYLE_TOP:
        TraceTag((tagMediaElementOnChanged,
                "CTIMEMediaElement(%lx)::OnChanged():TOP", this));
        break;

    case DISPID_IHTMLCURRENTSTYLE_LEFT:
        TraceTag((tagMediaElementOnChanged,
                "CTIMEMediaElement(%lx)::OnChanged():LEFT", this));
        break;

    case DISPID_IHTMLCURRENTSTYLE_WIDTH:
    case DISPID_IHTMLCURRENTSTYLE_HEIGHT:
        TraceTag((tagMediaElementOnChanged,
                "CTIMEMediaElement(%lx)::OnChanged():WIDTH or HEIGHT", this));
        long pixelWidth, pixelHeight;
#ifdef _DEBUG
        bool gotWidth = false;
        bool gotHeight = false;
#endif
        VariantInit(&varStyleWidth);
        VariantInit(&varStyleHeight);

        if (GetElement())
        {
            hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
            if (FAILED(hr))
            {
                break;
            }
    
            hr = THR(pElem2->get_runtimeStyle(&pStyle2));
            if (FAILED(hr))
            {
                break;
            }    

            hr = THR(GetElement()->get_style(&s));
            if (FAILED(hr))
            {
                break;
            }    

            if (SUCCEEDED(s -> get_width( &varStyleWidth)))
            {
                if (varStyleWidth.vt == VT_BSTR && varStyleWidth.bstrVal != NULL) //check that width was set
                {
                    if (SUCCEEDED(s -> get_pixelWidth( &pixelWidth)))
                    {
#ifdef _DEBUG
                        gotWidth = true;
#endif
                        pStyle2 -> put_pixelWidth(pixelWidth);
                     }
                }
            }



            if (SUCCEEDED(s -> get_height( &varStyleHeight)))
            {
                if (varStyleHeight.vt == VT_BSTR && varStyleHeight.bstrVal != NULL) //check that height was set
                {
                    if (SUCCEEDED(s -> get_pixelHeight( &pixelHeight)))
                    {
#ifdef _DEBUG
                        gotHeight = true;
#endif
                        pStyle2 -> put_pixelHeight(pixelHeight);
                    }
                }
            }
        }
#ifdef _DEBUG
            if ( gotWidth)
            {
                TraceTag((tagMediaElementOnChanged,
                        "CTIMEMediaElement(%lx):: WIDTH %d - %ls", this, pixelWidth, varStyleWidth.bstrVal));
            }
            if ( gotHeight)
            {
                TraceTag((tagMediaElementOnChanged,
                        "CTIMEMediaElement(%lx)::HEIGHT %d - %ls", this, pixelHeight, varStyleHeight.bstrVal));
            }
#endif

        VariantClear(&varStyleWidth);
        VariantClear(&varStyleHeight);
        break;
    }
    m_fInOnChangedFlag = false;
    return hr;
}


HRESULT
CTIMEMediaElement::GetNotifyConnection(IConnectionPoint **ppConnection)
{
    HRESULT hr = S_OK;

    Assert(ppConnection != NULL);
    *ppConnection = NULL;

    IConnectionPointContainer *pContainer = NULL;
    IHTMLElement *pElement = GetElement();

    // Get connection point container
    hr = pElement->QueryInterface(IID_TO_PPV(IConnectionPointContainer, &pContainer));
    if(FAILED(hr))
        goto end;
    
    // Find the IPropertyNotifySink connection
    hr = pContainer->FindConnectionPoint(IID_IPropertyNotifySink, ppConnection);
    if(FAILED(hr))
        goto end;

end:
    ReleaseInterface( pContainer );

    return hr;
}

//*****************************************************************************

/**
* Initializes a property sink on the current style of the animated element so that
* can observe changes in width, height, visibility, zIndex, etc.
*/
HRESULT
CTIMEMediaElement::InitPropertySink()
{
    HRESULT hr = S_OK;

    // Get connection point
    IConnectionPoint *pConnection = NULL;
    hr = GetNotifyConnection(&pConnection);
    if (FAILED(hr))
        return hr;

    // Advise on it
    hr = pConnection->Advise(GetUnknown(), &m_dwAdviseCookie);
    ReleaseInterface(pConnection);
    if (FAILED(hr))
        return hr;

    return S_OK;
}

HRESULT
CTIMEMediaElement::UnInitPropertySink()
{
    HRESULT hr = S_OK;

    if (m_dwAdviseCookie == 0)
        return S_OK;

    // Get connection point
    IConnectionPoint *pConnection = NULL;
    hr = GetNotifyConnection(&pConnection);
    if (FAILED(hr) || pConnection == NULL )
        return hr;

    // Unadvise on it
    hr = pConnection->Unadvise(m_dwAdviseCookie);
    ReleaseInterface(pConnection);
    if (FAILED(hr))
        return hr;

    m_dwAdviseCookie = 0;

    return S_OK;
}

STDMETHODIMP
CTIMEMediaElement::Invoke( DISPID id,
                           REFIID riid,
                           LCID lcid,
                           WORD wFlags,
                           DISPPARAMS *pDispParams,
                           VARIANT *pvarResult,
                           EXCEPINFO *pExcepInfo,
                           UINT *puArgErr)
{
    DAComPtr<IDispatch> pDisp;
    DAComPtr<IHTMLDocument2> pDoc;
    DAComPtr<IHTMLWindow2> pWindow;
    DAComPtr<IHTMLEventObj> pEventObj;
    DAComPtr<IHTMLElement2> pElem2;
    HRESULT hr = S_OK;
    BSTR bstrEventName;
    BSTR bstrQualifier;
    RECT elementRect;
    IHTMLRect *pRect = NULL;


    if (id != 0) // we are only proccesing the onresize event. For other event we call the parent method.
    {
        hr = IDispatchImpl<ITIMEMediaElement, &IID_ITIMEMediaElement, &LIBID_TIME>::Invoke(
                            id, riid, lcid, wFlags, pDispParams, pvarResult, pExcepInfo, puArgErr);
        goto done; //BUGBUG call the other one
    }

    hr = THR(GetElement()->get_document(&pDisp));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDisp->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDoc->get_parentWindow(&pWindow));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = THR(pWindow->get_event(&pEventObj));
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pEventObj->get_type(&bstrEventName);
    if (FAILED(hr))
    {
        goto done;
    }

    if (StrCmpIW(bstrEventName, L"resize") != 0)
    {
        goto done;
    }

    hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
    if (FAILED(hr))
    {
        goto done;       
    }
    hr = pElem2->getBoundingClientRect(&pRect);
    if (FAILED(hr) || pRect == NULL )
    {
        goto done;
    }

    long pixelWidth, pixelHeight;
    long pixelRight, pixelLeft;
    long pixelBottom, pixelTop;
    hr = pRect->get_right(&pixelRight);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pRect->get_left(&pixelLeft);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pRect->get_bottom(&pixelBottom);
    if (FAILED(hr))
    {
        goto done;
    }
    hr = pRect->get_top(&pixelTop);
    if (FAILED(hr))
    {
        goto done;
    }

    elementRect.top = elementRect.left = 0.0;
    elementRect.right = pixelRight - pixelLeft;
    elementRect.bottom = pixelBottom - pixelTop;

    hr = THR(m_Player -> SetSize(&elementRect));

    hr = S_OK;
done:
    return hr;
}



//*****************************************************************************
#undef THIS
#define THIS CTIMEMediaElement
#define SUPER CTIMEElementBase

#include "pbagimp.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\player.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "player.h"

// Suppress new warning about NEW without corresponding DELETE 
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )  

DeclareTag(tagMediaTimePlayer, "API", "CTIMEPlayer methods");

CTIMEPlayer::CTIMEPlayer(CDAElementBase *pelem)
: m_fExternalPlayer(false),
  m_pContainer(NULL),
  m_pDAElementBase(pelem),
  m_fClockSource(false),
  m_fRunning(false),
  m_dblStart(0.0)
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::CTIMEPlayer()",
              this));

    VariantInit(&m_varClipBegin);
    VariantInit(&m_varClipEnd);
}

CTIMEPlayer::~CTIMEPlayer()
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::~CTIMEPlayer()",
              this));

    if (m_pContainer != NULL)
    {
        m_pContainer->Release();
    }

    VariantClear(&m_varClipBegin);
    VariantClear(&m_varClipEnd);
}

HRESULT
CTIMEPlayer::Init()
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::Init)",
              this));   

    Assert(m_pDAElementBase->GetView() != NULL);
    
    return S_OK;
}

HRESULT
CTIMEPlayer::DetachFromHostElement (void)
{
    HRESULT hr = S_OK;

    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::DetachFromHostElement)",
              this));   

    if (NULL != m_pContainer)
    {
        // Propogating this error wouldn't mean much 
        // to the caller since it is shutting down.
        THR(m_pContainer->Stop());
        THR(m_pContainer->DetachFromHostElement());
    }

    return hr;
}

HRESULT
CTIMEPlayer::OnLoad(LPOLESTR src, LPOLESTR img, MediaType type)
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::OnLoad()",
              this));
    
    m_type = type;
    UseMediaPlayer(src);

    if(m_fExternalPlayer)
    {
        HRESULT hr;

        Assert(m_pContainer == NULL);
        m_pContainer = NEW CContainerObj();
        if (m_pContainer == NULL)
        {
            TraceTag((tagError, "CTIMEPlayer::Init - unable to alloc mem for container services!!!"));
            hr = E_OUTOFMEMORY;
            goto error_cleanup;
        }

        // NOTE: we hold a ref count to this object because it acts as a COM object we cannot delete it!
        m_pContainer->AddRef();

        hr = m_pContainer->Init(m_playerCLSID, m_pDAElementBase);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEPlayer::Init - init failed"));
            goto error_cleanup;
        }

        hr = m_pContainer->SetMediaSrc(src);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEPlayer::Init - unable set media src on player"));
            goto error_cleanup;
        }

        hr = m_pContainer->clipBegin(m_varClipBegin);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEPlayer::Init - unable set ClipBegin on player"));
            goto error_cleanup;
        }

        hr = m_pContainer->clipEnd(m_varClipEnd);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEPlayer::Init - unable set ClipEnd on player"));
            goto error_cleanup;
        }

        goto done;

// if we got an error, drop back
error_cleanup:
        if (m_pContainer != NULL)
        {
            delete m_pContainer;
            m_pContainer = NULL;
            m_fExternalPlayer = false;
        }
    }

    LoadMedia(src,img);

done:
    return S_OK;
}

void
CTIMEPlayer::OnSync(double dbllastTime, double & dblnewTime)
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::OnSync(%g, %g)",
              this,
              dbllastTime,
              dblnewTime));
    
    // if we are not the external player and not running, go away
    if (!m_fExternalPlayer)
    {
        goto done;
    }

    if (m_fRunning)
    {
        // get current time from player and
        // sync to this time
        double dblCurrentTime;
        dblCurrentTime = m_pContainer->GetCurrentTime();

        TraceTag((tagMediaTimePlayer,
                  "CTIMEPlayer(%lx)::OnSync - player returned %g",
                  this,
                  dblCurrentTime));
    
        // If the current time is -1 then the player is not ready and we
        // should sync to the last time.  We also should not respect the
        // tolerance since the behavior has not started.
    
        if (dblCurrentTime < 0)
        {
            TraceTag((tagMediaTimePlayer,
                      "CTIMEPlayer(%lx)::OnSync - player returned -1 - setting to dbllastTime (%g)",
                      this,
                      dbllastTime));
    
            dblCurrentTime = 0;
            // When we want this to actually hold at the begin value then enable
            // this code
            // dblCurrentTime = -HUGE_VAL;
        }
        else if (dblnewTime == HUGE_VAL)
        {
            if (dblCurrentTime >= (m_pDAElementBase->GetRealRepeatTime() - m_pDAElementBase->GetRealSyncTolerance()))
            {
                TraceTag((tagMediaTimePlayer,
                          "CTIMEPlayer(%lx)::OnSync - new time is ended and player w/i sync tolerance of end",
                          this));
    
                goto done;
            }
        }
        else if (fabs(dblnewTime - dblCurrentTime) <= m_pDAElementBase->GetRealSyncTolerance())
        {
            TraceTag((tagMediaTimePlayer,
                      "CTIMEPlayer(%lx)::OnSync - player w/i sync tolerance (new:%g, curr:%g, diff:%g, tol:%g)",
                      this,
                      dblnewTime,
                      dblCurrentTime,
                      fabs(dblnewTime - dblCurrentTime),
                      m_pDAElementBase->GetRealSyncTolerance()));
    
            goto done;
        }
        
        if (m_fClockSource)
        {
            dblnewTime = dblCurrentTime;
        }
    }
    else if (!m_fRunning && m_pDAElementBase->IsDocumentInEditMode())
    {
        // if we are paused and in edit mode, make sure
        // WMP has the latest time.
        double dblMediaLen = 0.0f;
        TraceTag((tagMediaTimePlayer,
                "CTIMEPlayer(%lx)::OnSync(SeekTo=%g m_fRunning=%d)",
                this,
                dbllastTime, m_fRunning));
        // GetMediaLength fails if duration is indefinite (e.g. live stream).
        if (FAILED(m_pContainer->GetMediaLength(dblMediaLen)))
        {
            goto done;
        }

        // Don't seek beyond duration of media clip. 
        if (dbllastTime > dblMediaLen)
        {
            goto done;
        }

        if (m_pContainer != NULL)
            THR(m_pContainer->Seek(dbllastTime));
    }
  done:
    return ;
}    

void 
CTIMEPlayer::UseMediaPlayer(LPOLESTR src)
{
    LPOLESTR    MimeType = NULL;

    if(m_fExternalPlayer)
        return;

    if(SUCCEEDED(IsValidURL(NULL, src, 0)))
    {
        FindMimeFromData(NULL,src,NULL,NULL,NULL,0,&MimeType,0);
        // see if we have a valid URL and MIME type
        if(MimeType != NULL)
        {
            // pass to Windows Media Player is video or sound
            if((wcsncmp(L"audio", MimeType , 5 ) == 0) ||
               (wcsncmp(L"video", MimeType , 5 ) == 0) )
            {
               CLSID clsid;
               if(SUCCEEDED(CLSIDFromString(MediaPlayer, &clsid)))
               {
                    SetCLSID(clsid);
               }
            }
        }
    }

}

void
CTIMEPlayer::SetCLSID(REFCLSID clsid) 
{
    m_playerCLSID = clsid; 
    m_fExternalPlayer = true;
}


void
CTIMEPlayer::Start(double dblLocalTime)
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::Start()",
              this));

    m_dblStart = dblLocalTime;

    if(m_fExternalPlayer && (NULL != m_pContainer))
        m_pContainer->Start();

    m_fRunning = true;
}

void
CTIMEPlayer::Stop()
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::Stop()",
              this));
    
    m_fRunning = false;
    m_dblStart = 0.0;

    if(m_fExternalPlayer && (NULL != m_pContainer))
        m_pContainer->Stop();
}

void
CTIMEPlayer::Pause()
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::Pause()",
              this));

    m_fRunning = false;

    if(m_fExternalPlayer && (NULL != m_pContainer))
        m_pContainer->Pause();
}

void
CTIMEPlayer::Resume()
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::Resume()",
              this));

    if(m_fExternalPlayer && (NULL != m_pContainer))
        m_pContainer->Resume();

    m_fRunning = true;
}
    
HRESULT
CTIMEPlayer::Render(HDC hdc, LPRECT prc)
{
    TraceTag((tagMediaTimePlayer,
              "CTIMEPlayer(%lx)::Render()",
              this));
    HRESULT hr;

    if (m_fExternalPlayer)
    {
        if (NULL != m_pContainer)
        {
            hr = THR(m_pContainer->Render(hdc, prc));
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }
    else
    {
        if (!m_pDAElementBase->GetView()->Render(hdc, prc))
        {
            hr = CRGetLastError();
        }
    }

    return hr;
}


void
CTIMEPlayer::LoadImage(LPOLESTR szURL)
{
    // we have an image 
    CRImagePtr pImage;
    CREventPtr pEvent;
    CRNumberPtr pProgress;
    CRNumberPtr pSize;
    CREventPtr pev;

    if((szURL != NULL) && UseImage(m_type))
    {

        Assert(m_pDAElementBase);

        CRLockGrabber __gclg;
        CRImportImage(m_pDAElementBase->GetURLOfClientSite(), szURL, NULL, 
                           NULL, false, 0, 0,
                           0, CREmptyImage(),&pImage,
                           &pEvent,&pProgress, &pSize);

        RECT rc;
        CTIMENotifyer *notifyier = NEW CTIMENotifyer(m_pDAElementBase);
        if(SUCCEEDED(m_pDAElementBase->GetSize(&rc))) {
            if( (rc.right  - rc.left == 0) ||
                (rc.bottom - rc.top  == 0)) {
                // we need to set the size..
                pev = CRNotify(CRSnapshot(pEvent,(CRBvrPtr)CRBoundingBox(pImage)), notifyier);
            }
            else {
                // size is set for us..
                pev = CRNotify(pEvent,notifyier);
            }
            m_pDAElementBase->SetImage((CRImagePtr)CRUntil((CRBvrPtr)pImage,pev,(CRBvrPtr)pImage));
        }
    }
}

void
CTIMEPlayer::LoadAudio(LPOLESTR szURL)
{
    CRSoundPtr pSound;
    CRNumberPtr pDuration;

    if((szURL != NULL) && UseAudio(m_type))
    {
        CRLockGrabber __gclg;

        CRImportSound(m_pDAElementBase->GetURLOfClientSite(), szURL, NULL, 
                           NULL, true, CRSilence(),
                           &pSound, &pDuration,
                           NULL, NULL, NULL);

        m_pDAElementBase->SetSound(pSound);
    }
}

void
CTIMEPlayer::LoadVideo(LPOLESTR szURL)
{
    CRImagePtr pImage;
    CRSoundPtr pSound;
    CRNumberPtr pDuration;

    if(szURL != NULL)
    {
        CRLockGrabber __gclg;

        CRImportMovie(m_pDAElementBase->GetURLOfClientSite(), szURL, NULL, 
                           NULL, true, NULL, NULL,
                           &pImage, &pSound,
                           &pDuration, NULL,
                           NULL, NULL);

        if(UseImage(m_type)) m_pDAElementBase->SetImage(pImage);
        if(UseAudio(m_type)) m_pDAElementBase->SetSound(pSound);
    }
}

void
CTIMEPlayer::LoadMedia(LPOLESTR src, LPOLESTR img)
{   
    LPOLESTR    szURL;
    LPOLESTR    MimeType = NULL;
    bool        bSecondAttempt = false;

    szURL = CopyString(src);

try_imgURL:
    if(SUCCEEDED(IsValidURL(NULL, szURL, 0)))
    {
        FindMimeFromData(NULL,szURL,NULL,NULL,NULL,0,&MimeType,0);
        // see if we have a valid URL and MIME type
        if(MimeType != NULL)
        {
            // Load the correct media...
            if(wcsncmp(L"image", MimeType , 5 ) == 0)
            {
                LoadImage(szURL); // we have an image 
                goto done;
            }
            else if(wcsncmp(L"audio", MimeType , 5 ) == 0)
            {
                LoadAudio(szURL); // we have an sound
                goto done;
            }
            else if(wcsncmp(L"video", MimeType , 5 ) == 0)
            {
                LoadVideo(szURL); // we have an movie
                goto done;
            }
        }
    }
    if(!bSecondAttempt && img != NULL)
    {
        // We were unable to get the MIME type from the src URL ... we should just
        // display the URL specified in the img URL.
        szURL = CopyString(img);
        m_type = MT_Image;          // Only valid for visual types.
        bSecondAttempt = true;
        goto try_imgURL;
    }
    CRSetLastError(DISP_E_TYPEMISMATCH,NULL);

done:
    return;
}

HRESULT
CTIMEPlayer::GetExternalPlayerDispatch(IDispatch **ppDisp)
{
    // check to see if player is being used
    if (!m_fExternalPlayer || (m_pContainer == NULL))
        return E_UNEXPECTED;

    return m_pContainer->GetControlDispatch(ppDisp);
}

HRESULT 
CTIMEPlayer::getClipBegin(VARIANT *pvar)
{
    HRESULT hr = S_OK;

    Assert(pvar != NULL);

    // prepare var for copy
    hr = THR(VariantClear(pvar));
    if (FAILED(hr))
        goto done;

    // copy contents over
    if (m_varClipBegin.vt != VT_EMPTY)
    {
        hr = THR(VariantCopy(pvar, &m_varClipBegin));
        if (FAILED(hr))
            goto done;
    }

done:
    return hr;
}

HRESULT 
CTIMEPlayer::putClipBegin(VARIANT var)
{
    HRESULT hr = S_OK;
    VARIANT varTemp;

    VariantInit(&varTemp);

    // if cached var is not empty, save off contents
    // so we can undo if error occurs
    if (m_varClipBegin.vt != VT_EMPTY)
    {
        hr = THR(VariantCopy(&varTemp, &m_varClipBegin));
        // if this failed, exit with out trying to recover.
        if (FAILED(hr))
            goto done;
    }

    // copy the contents over
    hr = THR(VariantClear(&m_varClipBegin));
    if (FAILED(hr))
        goto error;

    hr = THR(VariantCopy(&m_varClipBegin, &var));
    if (FAILED(hr))
        goto error;

    // Eat the HRESULT as we have updated the var
    THR(VariantClear(&varTemp));

    goto done;

error:
    if (varTemp.vt != VT_EMPTY)
        THR(VariantCopy(&m_varClipBegin, &varTemp));
    else
        VariantInit(&m_varClipBegin);

    THR(VariantClear(&varTemp));

done:
    return hr;

}

HRESULT 
CTIMEPlayer::getClipEnd(VARIANT *pvar)
{
    HRESULT hr = S_OK;

    Assert(pvar != NULL);

    // prepare var for copy
    hr = THR(VariantClear(pvar));
    if (FAILED(hr))
        goto done;

    // copy contents over
    if (m_varClipEnd.vt != VT_EMPTY)
    {
        hr = THR(VariantCopy(pvar, &m_varClipEnd));
        if (FAILED(hr))
            goto done;
    }

done:
    return hr;
}

HRESULT 
CTIMEPlayer::putClipEnd(VARIANT var)
{
    HRESULT hr = S_OK;
    VARIANT varTemp;

    VariantInit(&varTemp);

    // if cached var is not empty, save off contents
    // so we can undo if error occurs
    if (m_varClipEnd.vt != VT_EMPTY)
    {
        hr = THR(VariantCopy(&varTemp, &m_varClipEnd));
        // if this failed, exit with out trying to recover.
        if (FAILED(hr))
            goto done;
    }

    // copy the contents over
    hr = THR(VariantClear(&m_varClipEnd));
    if (FAILED(hr))
        goto error;

    hr = THR(VariantCopy(&m_varClipEnd, &var));
    if (FAILED(hr))
        goto error;

    // Eat the HRESULT as we have updated the var
    THR(VariantClear(&varTemp));
    
    goto done;    

error:
    if (varTemp.vt != VT_EMPTY)
        THR(VariantCopy(&m_varClipEnd, &varTemp));
    else
        VariantInit(&m_varClipEnd);

    THR(VariantClear(&varTemp));

done:
    return hr;

}

// Helper functions..

bool UseAudio(MediaType m_type)
{
    return (m_type != MT_Image);
}

bool UseImage(MediaType m_type)
{
    return (m_type != MT_Audio);
}

double 
CTIMEPlayer::GetCurrentTime()
{
    double dblCurrentTime = 0;
    
    if (m_pContainer != NULL)
    {
        dblCurrentTime = m_pContainer->GetCurrentTime();
    }
    
    return dblCurrentTime;
}

HRESULT
CTIMEPlayer::Seek(double dblTime)
{
    HRESULT hr = S_FALSE;

    if (m_pContainer != NULL)
    {
        hr = m_pContainer->Seek(dblTime);
    }
    else
    {
        // time transform the da image
        this->m_pDAElementBase->SeekImage(dblTime);
    }

    return hr;
}

HRESULT
CTIMEPlayer::SetSize(RECT *prect)
{
    if(m_pContainer == NULL) return E_FAIL;
    return m_pContainer -> SetSize(prect);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\pbagimp.cpp ===
//*****************************************************************************
//
// File: pbagimp.cpp
// Author: jeff ort
// Date Created: Sept 26, 1998
//
// Abstract: Implementation of IPersistPropertyBag2 interface
//           for all objects to call to base class.
//
// Modification List:
// Date		Author		Change
// 11/21/98	jeffort		Created this file
//
//*****************************************************************************

STDMETHODIMP 
THIS::GetClassID(CLSID* pclsid)
{
    return SUPER::GetClassID(pclsid);
} // GetClassID

//*****************************************************************************

STDMETHODIMP 
THIS::InitNew(void)
{
    return SUPER::InitNew();
} // InitNew

//*****************************************************************************

STDMETHODIMP 
THIS::Load(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog)
{
    return SUPER::Load(pPropBag, pErrorLog);
} // Load

//*****************************************************************************

STDMETHODIMP 
THIS::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    return SUPER::Save(pPropBag, fClearDirty, fSaveAllProperties);

} // Save 

//*****************************************************************************

//*****************************************************************************
//
// End of File
//
//*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\timeelm.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: timeelm.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "timeelm.h"

DeclareTag(tagTimeElm, "API", "CTIMEElement methods");

// static class data.
CPtrAry<BSTR> CTIMEElement::ms_aryPropNames;
DWORD CTIMEElement::ms_dwNumTimeElems = 0;

CTIMEElement::CTIMEElement()
{
    m_clsid = __uuidof(CTIMEElement);
    TraceTag((tagTimeElm,
              "CTIMEElement(%lx)::CTIMEElement()",
              this));
    CTIMEElement::ms_dwNumTimeElems++;
}

CTIMEElement::~CTIMEElement()
{
    CTIMEElement::ms_dwNumTimeElems--;

    if (0 == CTIMEElement::ms_dwNumTimeElems)
    {
        int iNames = CTIMEElement::ms_aryPropNames.Size();

        for (int i = iNames - 1; i >= 0; i--)
        {
            BSTR bstrName = CTIMEElement::ms_aryPropNames[i];
            CTIMEElement::ms_aryPropNames.DeleteItem(i);
            ::SysFreeString(bstrName);
        }
    }
}


HRESULT
CTIMEElement::Error()
{
    LPCWSTR str = CRGetLastErrorString();
    HRESULT hr = CRGetLastError();
    
    if (str)
        return CComCoClass<CTIMEElement, &__uuidof(CTIMEElement)>::Error(str, IID_ITIMEElement, hr);
    else
        return hr;
}

//*****************************************************************************

HRESULT 
CTIMEElement::GetPropertyBagInfo(CPtrAry<BSTR> **pparyPropNames)
{
    HRESULT hr = S_OK;

    // If we haven't built this yet, build it now.
    if (0 == ms_aryPropNames.Size())
    {
        hr = BuildPropertyNameList(&(CTIMEElement::ms_aryPropNames));
    }

    if (SUCCEEDED(hr))
    {
        *pparyPropNames = &(CTIMEElement::ms_aryPropNames);
    }

    return hr;
} // GetPropertyBagInfo

//*****************************************************************************

HRESULT 
CTIMEElement::GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
{
    return FindConnectionPoint(riid, ppICP);
} // GetConnectionPoint


//*****************************************************************************
#undef THIS
#define THIS CTIMEElement
#define SUPER CTIMEElementBase

#include "pbagimp.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\timeman.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: TimeMan.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "timeman.h"
#include "timeelm.h"

DeclareTag(tagTimeMan, "API", "CTIMETimeManager methods");

CTIMETimeManager::CTIMETimeManager()
{
    TraceTag((tagTimeMan,
              "CTIMETimeManager(%lx)::CTIMETimeManager()",
              this));
}

CTIMETimeManager::~CTIMETimeManager()
{
    TraceTag((tagTimeMan,
              "CTIMETimeManager(%lx)::~CTIMETimeManager()",
              this));

}

void
CTIMETimeManager::Add(CTIMEElement *pTimeElement)
{
    TraceTag((tagTimeMan,
              "CTIMETimeManager(%lx)::Add()",
              this));

    float       fBeginTime;
    bool        bWith=false;
    CComVariant var;
    TimeLineMap::iterator i;
    USES_CONVERSION;
    
    char * tagName =  W2A(pTimeElement->GetTagName());
    pTimeElement->get_beginWith(&var);
    if(var.bstrVal != NULL)
    {
        bWith = true;
    }
    else
    {
        pTimeElement->get_beginAfter(&var);
    }

    fBeginTime = pTimeElement->GetBeginTime();
    if(var.bstrVal == NULL)
    {
        // we should add this to the begin list.
        pTimeElement->SetRealTime(fBeginTime);
        m_TimeLine[tagName] = pTimeElement;
    }
    else
    {
        char * dependantName =  W2A(var.bstrVal);
        i = m_TimeLine.find(dependantName);
        if (i != m_TimeLine.end())
        {
            // found it....
            CTIMEElement *pTimeEle;
            pTimeEle = (*i).second;
            if(bWith)
            {
                pTimeElement->SetRealTime(pTimeEle->GetRealTime() + fBeginTime);
            }
            else
            {
                float dur = CalculateDuration(pTimeEle);
                if(dur == valueNotSet) // no duration ...default to forever. 
                    goto AddToWaitList;
                pTimeElement->SetRealTime(pTimeEle->GetRealTime() + dur + fBeginTime);

            }
            m_TimeLine[tagName] = pTimeElement;
        }
        else
        {
            // not found....
AddToWaitList:
            m_NotFinishedList.push_back(pTimeElement);
        }
    }
    // Check the ones that are not in the map 
    InsertElements();

/*
    // this is for debugging only...
    char buf[256];
    for (i = m_TimeLine.begin(); i != m_TimeLine.end(); i++) 
    {
        CTIMEElement *pTimeEle;
        pTimeEle = (*i).second;
        char * tagName =  W2A(pTimeEle->GetTagName());
        wsprintf(buf,"name %s, time %d\n",tagName,(int)pTimeEle->GetRealTime());
        OutputDebugString(buf);
    }
*/
}


void
CTIMETimeManager::Remove(CTIMEElement *pTimeElement)
{
    TraceTag((tagTimeMan,
              "CTIMETimeManager(%lx)::Remove()",
              this));

    TimeLineMap::iterator i;
    USES_CONVERSION;

    char * tagName =  W2A(pTimeElement->GetTagName());
    m_TimeLine.erase(tagName);
}


void
CTIMETimeManager::Recalc()
{
    TraceTag((tagTimeMan,
              "CTIMETimeManager(%lx)::Recalc()",
              this));
    
    USES_CONVERSION;

    // Need to recalc the timeline....
    
    TimeLineMap::iterator i;
    CComVariant var;

    for (i = m_TimeLine.begin(); i != m_TimeLine.end(); i++) 
    {
        CTIMEElement *pTimeEle;
        pTimeEle = (*i).second;
        pTimeEle->get_beginWith(&var);
        if(var.bstrVal == NULL)
        {
            pTimeEle->get_beginAfter(&var);
        }
        if(var.bstrVal != NULL)
        {
            // this needs to be taken out and recalced...
            pTimeEle->SetRealTime(0.0);
            m_NotFinishedList.push_back(pTimeEle);
            m_TimeLine.erase(i);
        }
        else 
        {
            // just make sure that the RealTime is set correctly..
            pTimeEle->SetRealTime(pTimeEle->GetBeginTime());
        }
    }
    InsertElements();
}


void
CTIMETimeManager::InsertElements()
{
    TraceTag((tagTimeMan,
              "CTIMETimeManager(%lx)::InsertElements()",
              this));

    TimeLineMap::iterator i;
    bool        bWith;
    CComVariant var; 
    USES_CONVERSION;

       // we also need to run though the temp ones to see if they can be moved to the map...
startProcess:
    for (std::list<CTIMEElement *>::iterator j = m_NotFinishedList.begin(); j != m_NotFinishedList.end(); j++) 
    {
        bWith = false; 
        (*j)->get_beginWith(&var);
        if(var.bstrVal != NULL)
        {
            bWith = true;
        }
        else
        {
            (*j)->get_beginAfter(&var);
        }
        char * dependantName =  W2A(var.bstrVal);
        i = m_TimeLine.find(dependantName);
        if (i != m_TimeLine.end())
        {
            // found it....
            CTIMEElement *pTimeEle;
            pTimeEle = (*i).second;
            if(bWith) 
            {
                (*j)->SetRealTime(pTimeEle->GetRealTime() + (*j)->GetBeginTime());
            }
            else
            {
                float dur = CalculateDuration(pTimeEle);
                if(dur == valueNotSet) // no duration ...default to forever. 
                    continue;
                (*j)->SetRealTime(pTimeEle->GetRealTime() + dur + (*j)->GetBeginTime());
            }
        
            char * tagName =  W2A((*j)->GetTagName());
            m_TimeLine[tagName] = (*j);
            m_NotFinishedList.erase(j); // remove from notFinished List..
            goto startProcess;          // the data has changed start over....
        }      
    }
}


float 
CTIMETimeManager::CalculateDuration(CTIMEElement *pTimeEle)
{
    TraceTag((tagTimeMan,
              "CTIMETimeManager(%lx)::CalculateDuration()",
              this));

    float repeatCount;
    float dur = pTimeEle->GetDuration();
    if(dur == valueNotSet) // no duration ...default to forever. 
        goto done;
    
    repeatCount = pTimeEle->GetRepeat();
    if(repeatCount != valueNotSet)
        dur *= repeatCount;
    else
    {
        if(valueNotSet != pTimeEle->GetRepeatDur())
            dur = pTimeEle->GetRepeatDur();
    }
done:
    return dur;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\timeelmbase.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: timeelmbase.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _TIMEELMBASE_H
#define _TIMEELMBASE_H

#include "resource.h"
#include "basebvr.h"
#include "tokens.h"
#include "eventmgr.h"
#include "mmutil.h"
#include "collect.h"

class CCollectionCache;

/////////////////////////////////////////////////////////////////////////////
// CTIMEElementBase

class
ATL_NO_VTABLE
CTIMEElementBase : 
    public CBaseBvr
{
  public:
    CTIMEElementBase();
    ~CTIMEElementBase();
        
#if _DEBUG
    const _TCHAR * GetName() { return __T("CTIMEElementBase"); }
#endif

    STDMETHOD(Init)(IElementBehaviorSite * pBvrSite);
    STDMETHOD(Notify)(LONG event, VARIANT * pVar);
    STDMETHOD(Detach)();

    // We cannot put the real one here since the typecast causes it to
    // get the wrong vtables
    static HRESULT WINAPI
        BaseInternalQueryInterface(CTIMEElementBase* pThis,
                                   void * pv,
                                   const _ATL_INTMAP_ENTRY* pEntries,
                                   REFIID iid,
                                   void** ppvObject);

    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    // Add a dummy one to assert just in case the derived class does
    // not add one
    static inline HRESULT WINAPI
        InternalQueryInterface(CTIMEElementBase* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject)
    {
        AssertStr(false, "InternalQueryInterface not defined in base class");
        return E_FAIL;
    }


    virtual void OnLoad() { m_bLoaded = true; }
    virtual void OnUnload() { }
    virtual void OnBeforeUnload (void) 
        { m_bUnloading = true; }

    virtual void OnPropChange(LPOLESTR propname) {}
    virtual void OnReadyStateChange(TOKEN state) {}

    virtual void OnBegin(double dblLocalTime, DWORD flags);
    virtual void OnEnd(double dblLocalTime);
    virtual void OnPause(double dblLocalTime);
    virtual void OnResume(double dblLocalTime);
    virtual void OnReset(double dblLocalTime, DWORD flags);
    virtual void OnSync(double dbllastTime, double & dblnewTime);
    virtual void OnRepeat(double dbllastTime) {};

    virtual MMView *GetView() { return NULL; }
    
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppv) = 0;


    //
    // ITIMEElement
    //
    
    HRESULT base_get_begin(VARIANT * time);
    HRESULT base_put_begin(VARIANT time);

    HRESULT base_get_beginWith(VARIANT * time);
    HRESULT base_put_beginWith(VARIANT time);

    HRESULT base_get_beginAfter(VARIANT * time);
    HRESULT base_put_beginAfter(VARIANT time);

    HRESULT base_get_beginEvent(VARIANT * time);
    HRESULT base_put_beginEvent(VARIANT time);

    HRESULT base_get_dur(VARIANT * time);
    HRESULT base_put_dur(VARIANT time);

    HRESULT base_get_end(VARIANT * time);
    HRESULT base_put_end(VARIANT time);

    HRESULT base_get_endWith(VARIANT * time);
    HRESULT base_put_endWith(VARIANT time);

    HRESULT base_get_endEvent(VARIANT * time);
    HRESULT base_put_endEvent(VARIANT time);
    
    HRESULT base_get_endSync(VARIANT * time);
    HRESULT base_put_endSync(VARIANT time);

    HRESULT base_get_repeat(VARIANT * time);
    HRESULT base_put_repeat(VARIANT time);

    HRESULT base_get_repeatDur(VARIANT * time);
    HRESULT base_put_repeatDur(VARIANT time);

    HRESULT base_get_accelerate(int * time);
    HRESULT base_put_accelerate(int time);

    HRESULT base_get_decelerate(int * time);
    HRESULT base_put_decelerate(int time);

    HRESULT base_get_autoReverse(VARIANT_BOOL * b);
    HRESULT base_put_autoReverse(VARIANT_BOOL b);

    HRESULT base_get_endHold(VARIANT_BOOL * b);
    HRESULT base_put_endHold(VARIANT_BOOL b);

    HRESULT base_get_eventRestart(VARIANT_BOOL * b);
    HRESULT base_put_eventRestart(VARIANT_BOOL b);

    HRESULT base_get_timeAction(LPOLESTR * time);
    HRESULT base_put_timeAction(LPOLESTR time);

    HRESULT base_beginElement(bool bAfterOffset);
    HRESULT base_endElement();
    virtual HRESULT base_pause();
    virtual HRESULT base_resume();
    HRESULT base_cue();

    HRESULT base_get_timeline(BSTR *);
    HRESULT base_put_timeline(BSTR);

    HRESULT base_get_currTime(float * time);
    HRESULT base_put_currTime(float time);
    
    HRESULT base_get_localTime(float * time);
    HRESULT base_put_localTime(float time);

    HRESULT base_get_currState(LPOLESTR * state);
    HRESULT base_put_currState(LPOLESTR state);

    HRESULT base_get_syncBehavior(LPOLESTR * sync);
    HRESULT base_put_syncBehavior(LPOLESTR sync);

    HRESULT base_get_syncTolerance(VARIANT * tol);
    HRESULT base_put_syncTolerance(VARIANT tol);

    HRESULT AddTIMEElement(CTIMEElementBase *bvr);
    HRESULT RemoveTIMEElement(CTIMEElementBase *bvr);

    HRESULT base_get_parentTIMEElement(ITIMEElement **bvr);
    HRESULT base_put_parentTIMEElement(ITIMEElement *bvr);

    HRESULT base_get_timelineBehavior(IDispatch ** bvr);
    HRESULT base_get_progressBehavior(IDispatch ** bvr);
    HRESULT base_get_onOffBehavior(IDispatch ** bvr);

    //
    // Accessors
    //

    CEventMgr & GetEventMgr() { return m_eventMgr; } 

    float    GetBeginTime() { return m_begin;};
    float    GetEndTime() { return m_end;};
    LPOLESTR GetBeginWith() { return m_beginWith; }
    LPOLESTR GetBeginAfter() { return m_beginAfter; }
    float    GetDuration() {return m_dur;};
    float    GetRepeat() {return m_repeat;};
    float    GetRepeatDur() {return m_repeatDur;};
    float        GetFractionalAcceleration() 
                {return static_cast<float>(m_accelerate) / 100.0f;};
    float        GetFractionalDeceleration() 
                {return static_cast<float>(m_decelerate) / 100.0f;};
    bool     GetAutoReverse() 
                {return m_bautoreverse;};
    bool     GetEndHold () 
                {return m_bendHold;};
    bool     GetEventRestart() {return m_beventrestart;};
    TOKEN    GetTimeAction() { return m_timeAction; }
    LPOLESTR GetBeginEvent() {return m_beginEvent;};
    LPOLESTR GetEndEvent() {return m_endEvent;};
    LPOLESTR GetEndSync() {return m_endSync;};

    virtual bool IsGroup() { return (m_TimelineType == ttPar) || (m_TimelineType == ttSeq); }
    bool IsGroup(IHTMLElement *pElement); // determine if elem passed in is a group
    bool IsPar() { return (m_TimelineType == ttPar); }
    bool IsSequence() { return (m_TimelineType == ttSeq); }
    virtual bool IsBody() { return false; }
    
    // Be aware that this can return NULL if no ID was set on the
    // element
    LPOLESTR GetID() { return m_id; };
  
    float    GetRealBeginTime() 
        {return m_realBeginTime; };
    float    GetRealDuration() 
        {return m_realDuration; };
    float    GetRealRepeatTime() 
        {return m_realRepeatTime; };
    float    GetRealRepeatCount() 
        {return m_realRepeatCount; };
    float    GetRealIntervalDuration (void)
        { return m_realIntervalDuration; }
    float    GetRealSyncTolerance();
    TOKEN    GetRealSyncBehavior();

    bool     IsLocked();

    MM_STATE GetPlayState();

    bool IsStarted() { return m_bStarted; }
    bool IsUnloading (void)
        {return m_bUnloading; }

    virtual bool Update();

    virtual HRESULT InitTimeline(void);

    virtual CRBvr * GetBaseBvr();

    bool FireEvent(TIME_EVENT TimeEvent, double dblLocalTime, DWORD flags);

    // internal methods
    HRESULT getTagString(BSTR *pbstrID);
    HRESULT getIDString(BSTR *pbstrTag);

    // Collection
    typedef enum COLLECTION_INDEX
    {
        ciAllElements,
        ciChildrenElements,
        ciAllInterfaces,
        ciChildrenInterfaces,
        NUM_COLLECTIONS
    };

    HRESULT base_get_collection(COLLECTION_INDEX index, ITIMEElementCollection **ppDisp);
    HRESULT EnsureCollectionCache();
    HRESULT InvalidateCollectionCache();
    CCollectionCache *GetCollectionCache();

    long GetImmediateChildCount();
    long GetAllChildCount();
    CTIMEElementBase *GetChild(long i);
    CTIMEElementBase *GetParent();
    CTIMEBodyElement *GetBody();
    MMPlayer *GetPlayer();
    int GetTimeChildIndex(CTIMEElementBase *pelm);

    MMBaseBvr & GetMMBvr()
    {
        Assert(m_mmbvr);
        return *m_mmbvr;
    }
    MMTimeline * GetMMTimeline() { return m_timeline; }

    virtual HRESULT GetSize(RECT * prcPos);
    virtual HRESULT SetSize(const RECT * prcPos);
    HRESULT ClearSize();

    enum TimelineType
    {
        ttUninitialized,
        ttNone,
        ttPar,
        ttSeq
    };

    virtual bool NeedSyncCB();

    bool IsDocumentInEditMode();

    bool IsPaused() { return m_fPaused; }
    virtual bool isNaturalDuration() { return false;}
    virtual void clearNaturalDuration() { return;}
    virtual void setNaturalDuration() { return;}

  protected:

    //IPersistPropertyBag2 methods
    STDMETHOD(GetClassID)(CLSID* pclsid);
    STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void)
        {return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);
    HRESULT NotifyPropertyChanged(DISPID dispid);
    // Persistance helper methods

    enum PROPERTY_INDEX
    {
        teb_begin = 0, teb_beginWith, teb_beginAfter, teb_beginEvent, 
        teb_dur, teb_end, teb_endWith, teb_endEvent, teb_endSync, teb_endHold,
        teb_eventRestart, teb_repeat, teb_repeatDur, teb_autoReverse,
        teb_accelerate, teb_decelerate, teb_timeAction, teb_timeline,
        teb_syncBehavior, teb_syncTolerance, teb_maxTIMEElementBaseProp,
    };

    virtual HRESULT GetPropertyBagInfo(CPtrAry<BSTR> **pparyPropNames)
        {return E_NOTIMPL;}
    virtual HRESULT SetPropertyByIndex(unsigned uIndex, VARIANT *pvarProp);
    virtual HRESULT GetPropertyByIndex(unsigned uIndex, VARIANT *pvarProp);
    virtual bool IsPropertySet(DWORD uIndex);
    virtual void SetPropertyFlag(DWORD uIndex);
    virtual void ClearPropertyFlag(DWORD uIndex);
    void SetPropertyFlagAndNotify(DISPID dispid, DWORD uindex);
    void ClearPropertyFlagAndNotify(DISPID dispid, DWORD uindex);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP)
    {
        return E_NOTIMPL;
    }

    virtual HRESULT Error(void) = 0;
    virtual HRESULT StartRootTime(MMTimeline * tl);
    virtual void StopRootTime(MMTimeline * tl);

    void CalcTimes();
    bool AddTimeAction();
    bool RemoveTimeAction();
    bool ToggleTimeAction(bool on);

    virtual HRESULT BuildPropertyNameList (CPtrAry<BSTR> *paryPropNames);

    virtual WCHAR* GetBehaviorTypeAsURN() { return L"TIME_BEHAVIOR_URN"; }

  protected:
    // Settable properties
    float           m_begin;
    LPOLESTR        m_beginWith;
    LPOLESTR        m_beginAfter;
    LPOLESTR        m_beginEvent;
    float           m_dur;
    float           m_end;
    LPOLESTR        m_endWith;
    LPOLESTR        m_endEvent;
    LPOLESTR        m_endSync;
    float           m_repeat;
    float           m_repeatDur;
    int             m_accelerate;
    int             m_decelerate;
    bool            m_bautoreverse;
    bool            m_bendHold;
    bool            m_beventrestart;
    TOKEN           m_timeAction;
    TOKEN           m_syncBehavior;
    float           m_syncTolerance;
    bool            m_bLoaded;
    bool            m_bUnloading;
    bool            m_fTimelineInitialized;
    TimelineType    m_TimelineType;

    // internal variables
    float           m_realBeginTime;
    float           m_realDuration;
    float           m_realRepeatTime;
    float           m_realRepeatCount;
    float           m_realIntervalDuration;
    LPOLESTR        m_id;
    CEventMgr       m_eventMgr;
    MMBaseBvr      *m_mmbvr;
    
    LPOLESTR        m_origAction;

    bool            m_bStarted;
    bool            m_fPropertiesDirty;
    CLSID           m_clsid;
        
    CTIMEElementBase            *m_pTIMEParent;
    CTIMEBodyElement            *m_pTIMEBody;
    CPtrAry<CTIMEElementBase*>   m_pTIMEChildren;
    MMTimeline                  *m_timeline;
  
    CRPtr<CRNumber> m_datimebvr;
    CRPtr<CRNumber> m_progress;
    CRPtr<CRBoolean> m_onoff;

    bool m_fPaused;

  private:
    HRESULT SetParent(ITIMEElement *pelem, bool fReparentChildren = true);
    HRESULT UnparentElement();
    HRESULT ParentElement();
    HRESULT ReparentChildren(ITIMEElement *pTIMEParent, IHTMLElement *pelem);
    HRESULT UpdateMMAPI();
    void    UpdateProgressBvr();

    HRESULT InitAtomTable();
    void ReleaseAtomTable();
    CAtomTable *GetAtomTable();

    static LPWSTR ms_rgwszTEBasePropNames[];

    CCollectionCache  *m_pCollectionCache;
    static CAtomTable *s_pAtomTable;
    static DWORD s_cAtomTableRef;
    DWORD m_propertyAccesFlags;
};


CTIMEElementBase * GetTIMEElementBase(IUnknown *);

inline CAtomTable *
CTIMEElementBase::GetAtomTable()
{
    Assert(s_pAtomTable != NULL);
    return s_pAtomTable;
} // GetAtomTable

inline long 
CTIMEElementBase::GetImmediateChildCount()
{
    return m_pTIMEChildren.Size();
} // GetImmediateChildCount

inline long 
CTIMEElementBase::GetAllChildCount()
{
    long lSize = m_pTIMEChildren.Size();
    long lCount = 0;
    for (long i=0; i < lSize; i++)
        lCount += m_pTIMEChildren[i]->GetAllChildCount();
    return lCount + lSize;
} // GetAllChildCount

inline CTIMEElementBase * 
CTIMEElementBase::GetChild(long i)
{
    Assert(i >= 0);
    return m_pTIMEChildren[i];
} // GetChild

inline CTIMEElementBase * 
CTIMEElementBase::GetParent()
{
    return m_pTIMEParent;
} // GetParent

inline CTIMEBodyElement *
CTIMEElementBase::GetBody()
{
    return m_pTIMEBody;
}

inline CCollectionCache * 
CTIMEElementBase::GetCollectionCache()
{
    return m_pCollectionCache;
} // GetCollectionCache

inline bool 
CTIMEElementBase::NeedSyncCB()
{   
    return false;
} // NeedSyncCB

inline bool
CTIMEElementBase::IsLocked()
{
    return GetRealSyncBehavior() == LOCKED_TOKEN;
}


#define valueNotSet -1

#endif /* _TIMEELMBASE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\player.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: player.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _PLAYER_H
#define _PLAYER_H

#include "daelmbase.h"
#include "containerobj.h"
#include "notify.h"


#define MediaPlayer L"{22d6f312-b0f6-11d0-94ab-0080c74c7e95}"
#define MP_INFINITY -1

/////////////////////////////////////////////////////////////////////////////
// CTTIMEPlayer

class CTIMEPlayer 
{
  public:
    CTIMEPlayer(CDAElementBase *pTIMEElem);
    ~CTIMEPlayer();

    HRESULT Init();
    HRESULT DetachFromHostElement (void);

    HRESULT OnLoad(LPOLESTR src, LPOLESTR img, MediaType type);
    void OnSync(double dbllastTime, double & dblnewTime);
    void SetCLSID(REFCLSID clsid);
    void Start(double dblLocalTime);
    void Stop();
    void Pause();
    void Resume();
    HRESULT Render(HDC hdc, LPRECT prc);

    HRESULT GetExternalPlayerDispatch(IDispatch **ppDisp);

    HRESULT getClipBegin(VARIANT *pvar);
    HRESULT putClipBegin(VARIANT var);
    HRESULT getClipEnd(VARIANT *pvar);
    HRESULT putClipEnd(VARIANT var);

    bool SetClockSource(bool fClockSource);
    HRESULT SetSize(RECT *prect);

    double GetCurrentTime();
    HRESULT Seek(double dblTime);

    CContainerObj* GetContainerObj() { return m_pContainer; }

  protected:

    void LoadAudio(LPOLESTR szURL);
    void LoadVideo(LPOLESTR szURL);
    void LoadImage(LPOLESTR szURL);
    void LoadMedia(LPOLESTR src, LPOLESTR img);
    void UseMediaPlayer(LPOLESTR src);
    
    CLSID               m_playerCLSID;
    CContainerObj      *m_pContainer;
    bool                m_fExternalPlayer;
    MediaType           m_type;
    CDAElementBase     *m_pDAElementBase;
    VARIANT             m_varClipBegin;
    VARIANT             m_varClipEnd;
    bool                m_fClockSource;
    bool                m_fRunning;
    double              m_dblStart;
};

inline bool
CTIMEPlayer::SetClockSource(bool fClockSource)
{
    m_fClockSource = fClockSource;
    return true;
} // SetClockSource

bool UseAudio(MediaType m_type);
bool UseImage(MediaType m_type);

#endif /* _PLAYER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\timeelm.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: timeelm.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _TIMEELM_H
#define _TIMEELM_H

#include "timeelmbase.h"

/////////////////////////////////////////////////////////////////////////////
// CTIMEElement

class
ATL_NO_VTABLE
__declspec(uuid("efbad7f8-3f94-11d2-b948-00c04fa32195")) 
CTIMEElement :
    public CTIMEElementBase,
    public CComCoClass<CTIMEElement, &__uuidof(CTIMEElement)>,
    public IDispatchImpl<ITIMEElement, &IID_ITIMEElement, &LIBID_TIME>,
    public ISupportErrorInfoImpl<&IID_ITIMEElement>,
    public IConnectionPointContainerImpl<CTIMEElement>,
    public IPersistPropertyBag2,
    public IPropertyNotifySinkCP<CTIMEElement>
{
  public:
    CTIMEElement();
    ~CTIMEElement();
        
#if _DEBUG
    const _TCHAR * GetName() { return __T("CTIMEElement"); }
#endif

    //
    //IPersistPropertyBag2
    // 
    STDMETHOD(GetClassID)(CLSID* pclsid);
    STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void)
        {return S_OK;};
    STDMETHOD(Load)(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog);
    STDMETHOD(Save)(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);

    //
    // ITIMEElement
    //
    
    STDMETHOD(get_begin)(VARIANT * time)
    { return base_get_begin(time); }
    STDMETHOD(put_begin)(VARIANT time)
    { return base_put_begin(time); }

    STDMETHOD(get_beginWith)(VARIANT * time)
    { return base_get_beginWith(time); }
    STDMETHOD(put_beginWith)(VARIANT time)
    { return base_put_beginWith(time); }

    STDMETHOD(get_beginAfter)(VARIANT * time)
    { return base_get_beginAfter(time); }
    STDMETHOD(put_beginAfter)(VARIANT time)
    { return base_put_beginAfter(time); }

    STDMETHOD(get_beginEvent)(VARIANT * time)
    { return base_get_beginEvent(time); }
    STDMETHOD(put_beginEvent)(VARIANT time)
    { return base_put_beginEvent(time); }

    STDMETHOD(get_dur)(VARIANT * time)
    { return base_get_dur(time); }
    STDMETHOD(put_dur)(VARIANT time)
    { return base_put_dur(time); }

    STDMETHOD(get_end)(VARIANT * time)
    { return base_get_end(time); }
    STDMETHOD(put_end)(VARIANT time)
    { return base_put_end(time); }

    STDMETHOD(get_endWith)(VARIANT * time)
    { return base_get_endWith(time); }
    STDMETHOD(put_endWith)(VARIANT time)
    { return base_put_endWith(time); }

    STDMETHOD(get_endEvent)(VARIANT * time)
    { return base_get_endEvent(time); }
    STDMETHOD(put_endEvent)(VARIANT time)
    { return base_put_endEvent(time); }

    STDMETHOD(get_endSync)(VARIANT * time)
    { return base_get_endSync(time); }
    STDMETHOD(put_endSync)(VARIANT time)
    { return base_put_endSync(time); }

    STDMETHOD(get_repeat)(VARIANT * time)
    { return base_get_repeat(time); }
    STDMETHOD(put_repeat)(VARIANT time)
    { return base_put_repeat(time); }

    STDMETHOD(get_repeatDur)(VARIANT * time)
    { return base_get_repeatDur(time); }
    STDMETHOD(put_repeatDur)(VARIANT time)
    { return base_put_repeatDur(time); }

    STDMETHOD(get_accelerate)(int * time)
    { return base_get_accelerate(time); }
    STDMETHOD(put_accelerate)(int time)
    { return base_put_accelerate(time); }

    STDMETHOD(get_decelerate)(int * time)
    { return base_get_decelerate(time); }
    STDMETHOD(put_decelerate)(int time)
    { return base_put_decelerate(time); }

    STDMETHOD(get_autoReverse)(VARIANT_BOOL * b)
    { return base_get_autoReverse(b); }
    STDMETHOD(put_autoReverse)(VARIANT_BOOL b)
    { return base_put_autoReverse(b); }

    STDMETHOD(get_endHold)(VARIANT_BOOL * b)
    { return base_get_endHold(b); }
    STDMETHOD(put_endHold)(VARIANT_BOOL b)
    { return base_put_endHold(b); }

    STDMETHOD(get_eventRestart)(VARIANT_BOOL * b)
    { return base_get_eventRestart(b); }
    STDMETHOD(put_eventRestart)(VARIANT_BOOL b)
    { return base_put_eventRestart(b); }

    STDMETHOD(get_timeAction)(LPOLESTR * time)
    { return base_get_timeAction(time); }
    STDMETHOD(put_timeAction)(LPOLESTR time)
    { return base_put_timeAction(time); }

    STDMETHOD(beginElement)()
    { return base_beginElement(true); }
    STDMETHOD(endElement)()
    { return base_endElement(); }
    STDMETHOD(pause)()
    { return base_pause(); }
    STDMETHOD(resume)()
    { return base_resume(); }
    STDMETHOD(cue)()
    { return base_cue(); }

    STDMETHOD(get_timeline)(BSTR * pbstrTimeLine)
    { return base_get_timeline(pbstrTimeLine); }
    STDMETHOD(put_timeline)(BSTR bstrTimeLine)
    { return base_put_timeline(bstrTimeLine); }

    STDMETHOD(get_currTime)(float * time)
    { return base_get_currTime(time); }
    STDMETHOD(put_currTime)(float time)
    { return base_put_currTime(time); }

    STDMETHOD(get_localTime)(float * time)
    { return base_get_localTime(time); }
    STDMETHOD(put_localTime)(float time)
    { return base_put_localTime(time); }

    STDMETHOD(get_currState)(LPOLESTR * state)
    { return base_get_currState(state); }
    STDMETHOD(put_currState)(LPOLESTR state)
    { return base_put_currState(state); }

    STDMETHOD(get_syncBehavior)(LPOLESTR * sync)
    { return base_get_syncBehavior(sync); }
    STDMETHOD(put_syncBehavior)(LPOLESTR sync)
    { return base_put_syncBehavior(sync); }

    STDMETHOD(get_syncTolerance)(VARIANT * tol)
    { return base_get_syncTolerance(tol); }
    STDMETHOD(put_syncTolerance)(VARIANT tol)
    { return base_put_syncTolerance(tol); }

    STDMETHOD(get_parentTIMEElement)(ITIMEElement **bvr)
    { return base_get_parentTIMEElement(bvr); }
    STDMETHOD(put_parentTIMEElement)(ITIMEElement *bvr)
    { return base_put_parentTIMEElement(bvr); }

    STDMETHOD(get_allTIMEElements)(/*[out, retval]*/ ITIMEElementCollection **ppDisp);
    STDMETHOD(get_childrenTIMEElements)(/*[out, retval]*/ ITIMEElementCollection **ppDisp);
    STDMETHOD(get_allTIMEInterfaces)(/*[out, retval]*/ ITIMEElementCollection **ppDisp);
    STDMETHOD(get_childrenTIMEInterfaces)(/*[out, retval]*/ ITIMEElementCollection **ppDisp);

    STDMETHOD(get_timelineBehavior)(IDispatch ** bvr)
    { return base_get_timelineBehavior(bvr); }
    STDMETHOD(get_progressBehavior)(IDispatch ** bvr)
    { return base_get_progressBehavior(bvr); }
    STDMETHOD(get_onOffBehavior)(IDispatch ** bvr)
    { return base_get_onOffBehavior(bvr); }

    // QI Map
    
    BEGIN_COM_MAP(CTIMEElement)
        COM_INTERFACE_ENTRY(ITIMEElement)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IPersistPropertyBag2)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
        COM_INTERFACE_ENTRY_CHAIN(CBaseBvr)
    END_COM_MAP();

    // Connection Point to allow IPropertyNotifySink
    BEGIN_CONNECTION_POINT_MAP(CTIMEElement)
        CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    END_CONNECTION_POINT_MAP();

    // This must be in the derived class and not the base class since
    // the typecast down to the base class messes things up
    static inline HRESULT WINAPI
        InternalQueryInterface(CTIMEElement* pThis,
                               const _ATL_INTMAP_ENTRY* pEntries,
                               REFIID iid,
                               void** ppvObject)
    { return BaseInternalQueryInterface(pThis,
                                        (void *) pThis,
                                        pEntries,
                                        iid,
                                        ppvObject); }

    // Needed by CBvrBase
    
    void * GetInstance()
    { return (ITIMEElement *) this ; }
    HRESULT GetTypeInfo(ITypeInfo ** ppInfo)
    { return GetTI(GetUserDefaultLCID(), ppInfo); }
    
  protected:
    
    HRESULT Error();
    HRESULT GetPropertyBagInfo(CPtrAry<BSTR> **pparyPropNames);
    virtual HRESULT GetConnectionPoint(REFIID riid, IConnectionPoint **ppICP);

    static CPtrAry<BSTR> ms_aryPropNames;
    static DWORD ms_dwNumTimeElems;

};

//************************************************************

inline HRESULT CTIMEElement::get_allTIMEElements(ITIMEElementCollection **ppDisp)
{
    return base_get_collection(ciAllElements, ppDisp);
} // get_all

inline HRESULT CTIMEElement::get_childrenTIMEElements(ITIMEElementCollection **ppDisp)
{
    return base_get_collection(ciChildrenElements, ppDisp);
} // get_children

inline HRESULT CTIMEElement::get_allTIMEInterfaces(ITIMEElementCollection **ppDisp)
{
    return base_get_collection(ciAllInterfaces, ppDisp);
} // get_time_all

inline HRESULT CTIMEElement::get_childrenTIMEInterfaces(ITIMEElementCollection **ppDisp)
{
    return base_get_collection(ciChildrenInterfaces, ppDisp);
} // get_time_children

#endif /* _TIMEELM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\timeelmbase.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: timeelmbase.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "timeelmbase.h"
#include "array.h"
#include "htmlimg.h"
#include "bodyelm.h"


// Suppress new warning about NEW without corresponding DELETE
// We expect GCs to cleanup values.  Since this could be a useful
// warning, we should disable this on a file by file basis.
#pragma warning( disable : 4291 )

DeclareTag(tagTimeElmBase, "API", "CTIMEElementBase methods");

// These must align with the class PROPERTY_INDEX enumeration.
LPWSTR CTIMEElementBase::ms_rgwszTEBasePropNames[] = {
    L"begin", L"beginWith", L"beginAfter", L"beginEvent",
    L"dur", L"end", L"endWith", L"endEvent", L"endSync", L"endHold",
    L"eventRestart", L"repeat", L"repeatDur", L"autoReverse",
    L"accelerate", L"decelerate", L"timeAction", L"timeline",
    L"syncBehavior", L"syncTolerance",
};

// init static variables
DWORD CTIMEElementBase::s_cAtomTableRef = 0;
CAtomTable *CTIMEElementBase::s_pAtomTable = NULL;

#define DEFAULT_M_BEGIN 0
#define DEFAULT_M_BEGINWITH NULL
#define DEFAULT_M_BEGINAFTER NULL
#define DEFAULT_M_BEGINEVENT NULL
#define DEFAULT_M_DUR valueNotSet
#define DEFAULT_M_END valueNotSet
#define DEFAULT_M_ENDWITH NULL
#define DEFAULT_M_ENDEVENT NULL
#define DEFAULT_M_ENDSYNC NULL
#define DEFAULT_M_REPEAT 1
#define DEFAULT_M_REPEATDUR valueNotSet
#define DEFAULT_M_TIMEACTION VISIBILITY_TOKEN
#define DEFAULT_M_TIMELINETYPE ttUninitialized
#define DEFAULT_M_SYNCBEHAVIOR INVALID_TOKEN
#define DEFAULT_M_SYNCTOLERANCE valueNotSet
#define DEFAULT_M_PTIMEPARENT NULL
#define DEFAULT_M_PTIMEBODY NULL
#define DEFAULT_M_ID NULL
#define DEFAULT_M_EVENTMGR *this
#define DEFAULT_M_MMBVR NULL
#define DEFAULT_M_ORIGINACTION NULL
#define DEFAULT_M_BSTARTED false
#define DEFAULT_M_PCOLLECTIONCACHE NULL
#define DEFAULT_M_TIMELINE NULL
#define DEFAULT_M_ACCELERATE 0
#define DEFAULT_M_DECELERATE 0
#define DEFAULT_M_BAUTOREVERSE false
#define DEFAULT_M_BEVENTRESTART true
#define DEFAULT_M_BLOADED false,
#define DEFAULT_M_FPROPERTIESDIRTY true
#define DEFAULT_M_BENDHOLD false
#define DEFAULT_M_FTIMELINEINITIALIZED false
#define DEFAULT_M_REALBEGINTIME valueNotSet
#define DEFAULT_M_REALDURATION valueNotSet
#define DEFAULT_M_REALREPEATTIME valueNotSet
#define DEFAULT_M_REALREPEATCOUNT valueNotSet
#define DEFAULT_M_REALREPEATINTERVALDURATION valueNotSet
#define DEFAULT_M_PROPERTYACCESFLAGS 0
#define DEFAULT_M_MLOFFSETWIDTH 0

CTIMEElementBase::CTIMEElementBase() :
    m_begin(DEFAULT_M_BEGIN),
    m_beginWith(NULL),
    m_beginAfter(NULL),
    m_beginEvent(DEFAULT_M_BEGINEVENT),
    m_dur(DEFAULT_M_DUR),
    m_end(DEFAULT_M_END),
    m_endWith(NULL),
    m_endEvent(DEFAULT_M_ENDEVENT),
    m_endSync(NULL),
    m_repeat(DEFAULT_M_REPEAT),
    m_repeatDur(DEFAULT_M_REPEATDUR),
    m_timeAction(DEFAULT_M_TIMEACTION),
    m_TimelineType(ttUninitialized),
    m_syncBehavior(INVALID_TOKEN),
    m_syncTolerance(valueNotSet),
    m_pTIMEParent(NULL),
    m_pTIMEBody(NULL),
    m_id(NULL),
    m_eventMgr(*this),
    m_mmbvr(NULL),
    m_origAction(NULL),
    m_bStarted(false),
    m_pCollectionCache(NULL),
    m_timeline(NULL),
    m_accelerate(0),
    m_decelerate(0),
    m_bautoreverse(false),
    m_beventrestart(true),
    m_bLoaded(false),
    m_bUnloading(false),
    m_fPropertiesDirty(true),
    m_bendHold(false),
    m_fTimelineInitialized(false),
    m_realBeginTime(valueNotSet),
    m_realDuration(valueNotSet),
    m_realRepeatTime(valueNotSet),
    m_realRepeatCount(valueNotSet),
    m_realIntervalDuration(valueNotSet),
    m_propertyAccesFlags(0),
    m_fPaused(false)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::CTIMEElementBase()",
              this));
}

CTIMEElementBase::~CTIMEElementBase()
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::~CTIMEElementBase()",
              this));

    delete m_beginWith;
    delete m_beginAfter;
    delete m_beginEvent;
    delete m_endWith;
    delete m_endEvent;
    delete m_endSync;
    delete m_id;
    delete m_origAction;
    delete m_mmbvr;
    // !!! Do not delete m_timeline since m_mmbvr points to the same
    // object
    m_timeline = NULL;

    if (m_pCollectionCache != NULL)
    {
        delete m_pCollectionCache;
        m_pCollectionCache = NULL;
    }

    // double check the children list
    Assert(m_pTIMEChildren.Size() == 0);
}


HRESULT
CTIMEElementBase::Init(IElementBehaviorSite * pBehaviorSite)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::Init(%lx)",
              this,
              pBehaviorSite));

    HRESULT hr;
    BSTR bstrID = NULL;
    BSTR bstrTagName = NULL;

    hr = THR(CBaseBvr::Init(pBehaviorSite));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(GetBehaviorTypeAsURN());

    bool fBehaviorExists;

    fBehaviorExists = false;

    hr = CheckElementForBehaviorURN(m_pHTMLEle, GetBehaviorTypeAsURN(), &fBehaviorExists);
    if (FAILED(hr))
    {
        goto done;
    }

    if (fBehaviorExists)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    // we did not find a match, so set our urn on the behavior site
    hr = m_pBvrSiteOM->RegisterUrn(GetBehaviorTypeAsURN());

    if (FAILED(hr))
    {
        goto done;
    }

    // since we support t:par and t:sequence, get tag name and
    // see if we are one of the above.  By default, we are ttNone.
    hr = THR(GetElement()->get_tagName(&bstrTagName));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(m_TimelineType == ttUninitialized);

    if (StrCmpIW(bstrTagName, WZ_PAR) == 0)
    {
        m_TimelineType = ttPar;
    }
    else if (StrCmpIW(bstrTagName, WZ_SEQUENCE) == 0)
    {
        m_TimelineType = ttSeq;
    }
    else if (StrCmpIW(bstrTagName, WZ_BODY) == 0)
    {
        m_TimelineType = ttPar;
    }

    SysFreeString(bstrTagName);

    // get ID of element and cache it
    hr = THR(GetElement()->get_id(&bstrID));
    if (SUCCEEDED(hr) && bstrID)
    {
        m_id = CopyString(bstrID);
        if (m_id == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    SysFreeString(bstrID);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(m_eventMgr.Init());
    if (FAILED(hr))
    {
        goto done;
    }

    if (!AddTimeAction())
    {
        hr = CRGetLastError();
        goto done;
    }

    if (!ToggleTimeAction(false))
    {
        hr = CRGetLastError();
        goto done;
    }

    // init atom table for collections
    hr = THR(InitAtomTable());
    if (FAILED(hr))
    {
        goto done;
    }

    if (!IsBody())
    {
        hr = THR(AddBodyBehavior(GetElement()));
        if (FAILED(hr))
        {
            goto done;
        }
    }

    // Create the behaviors

    {
        CRLockGrabber __gclg;

        m_datimebvr = CRModifiableNumber(0.0);

        if (!m_datimebvr)
        {
            hr = CRGetLastError();
            goto done;
        }

        m_progress = CRModifiableNumber(0.0);

        if (!m_progress)
        {
            hr = CRGetLastError();
            goto done;
        }

        m_onoff = (CRBooleanPtr) CRModifiableBvr((CRBvrPtr) CRFalse(), 0);

        if (!m_onoff)
        {
            hr = CRGetLastError();
            goto done;
        }
    }

    // if we are not a body element, walk up the HTML tree looking for our TIME parent.
    if (!IsBody())
    {
        hr = ParentElement();
        if (FAILED(hr))
        {
            goto done;
        }
    }
    hr = S_OK;

done:
    return hr;
}

HRESULT
CTIMEElementBase::Notify(LONG event, VARIANT * pVar)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::Notify(%lx)",
              this,
              event));

    THR(CBaseBvr::Notify(event, pVar));

    return S_OK;
}

HRESULT
CTIMEElementBase::Detach()
{
    TraceTag((tagTimeElmBase, "CTIMEElementBase(%lx)::Detach()", this));

    // TraceTag((tagError, "CTIMEElementBase(%lx)::Detach() - %08X, %S", this, m_pTIMEParent, m_id ));

    DAComPtr<ITIMEElement> pTIMEParent = NULL;
    if (GetParent() != NULL)
    {
        THR(GetParent()->QueryInterface(IID_TO_PPV(ITIMEElement, &pTIMEParent)));
    }

    THR(UnparentElement());

    // clear all children from holding a reference to ourselves
    // NOTE: this is a weak reference
    while (m_pTIMEChildren.Size() > 0)
    {
        CTIMEElementBase *pChild = m_pTIMEChildren[0];
        pChild->SetParent(pTIMEParent, false);
        // TraceTag((tagError, "CTIMEElementBase(%lx)::Detach() - setting parent to %08X, %S", m_pTIMEChildren[0], m_pTIMEChildren[0]->m_pTIMEParent, m_pTIMEChildren[0]->m_id ));

        // if we found a parent and it's timeline is present,
        // kick-start our root time.
        CTIMEElementBase *pElemNewParent = pChild->GetParent();
        if (pElemNewParent != NULL)
        {
            MMTimeline *tl = pElemNewParent->GetMMTimeline();
            if (tl != NULL)
            {
                if(!IsUnloading())
                {
                    pChild->StartRootTime(tl);
                }
            }
        }
    }
    m_pTIMEChildren.DeleteAll();

    delete m_mmbvr;
    m_mmbvr = NULL;

    // Do not delete m_timeline since it is the same object as
    // m_timeline
    m_timeline = NULL;

    RemoveTimeAction();

    THR(m_eventMgr.Deinit());

    THR(CBaseBvr::Detach());

    ReleaseAtomTable();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////
// ITIMEElement base interfaces
/////////////////////////////////////////////////////////////////////

HRESULT
CTIMEElementBase::base_get_begin(VARIANT * time)
{
    HRESULT hr;
    VARIANT fTemp, bstrTemp;
    if (time == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(time))))
    {
        goto done;
    }

    VariantInit(&fTemp);
    VariantInit(&bstrTemp);
    fTemp.vt = VT_R4;
    fTemp.fltVal = m_begin;

    hr = THR(VariantChangeTypeEx(&bstrTemp, &fTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
    if (SUCCEEDED(hr))
    {
        time->vt = VT_BSTR;
        time->bstrVal = SysAllocString(bstrTemp.bstrVal);
    }
    else
    {
        time->vt = VT_R4;
        time->fltVal = fTemp.fltVal;
    }

    VariantClear(&fTemp);
    SysFreeString(bstrTemp.bstrVal);
    VariantClear(&bstrTemp);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::UpdateMMAPI()
{
    HRESULT hr = E_FAIL;
    if (NULL != m_mmbvr)
    {
        if (!Update())
        {
            hr = TIMEGetLastError();
            goto done;
        }

        Assert(m_mmbvr != NULL);

        if (!m_mmbvr->Reset(MM_EVENT_PROPERTY_CHANGE))
        {
            hr = TIMEGetLastError();
            goto done;
        }

        UpdateProgressBvr();
    }
    hr = S_OK;

done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_begin(VARIANT time)
{
    TraceTag((tagTimeElmBase,
        "CTIMEElementBase::(%lx)::base_put_begin()",
        this));

    float fOldBegin = m_begin;

    HRESULT hr = E_FAIL;
    bool isClear = false;

    if(V_VT(&time) != VT_NULL)
    {
        hr = VariantToTime(time, &m_begin);
        if (FAILED(hr))
            goto done;
    }
    else
    {
        m_begin = DEFAULT_M_BEGIN;
        isClear = true;
    }

    hr = UpdateMMAPI();
    if (FAILED(hr))
        goto done;

    hr = S_OK;

    if(!isClear)
    {
        SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_BEGIN, teb_begin);
    }
    else
    {
        ClearPropertyFlagAndNotify(DISPID_TIMEELEMENT_BEGIN, teb_begin);
    }
done:
    if (FAILED(hr))
    {
        // return this object to its original state.
        m_begin = fOldBegin;
        if (NULL != m_mmbvr)
            Update();
    }
    return hr;
}

HRESULT
CTIMEElementBase::base_get_beginWith(VARIANT * time)
{
    HRESULT hr;

    if (time == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(time))))
    {
        goto done;
    }

    V_VT(time) = VT_BSTR;
    V_BSTR(time) = SysAllocString(m_beginWith);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_beginWith(VARIANT time)
{
    CComVariant v;
    HRESULT hr;


    hr = v.ChangeType(VT_BSTR, &time);

    if (FAILED(hr))
    {
        goto done;
    }

    delete[] m_beginWith;
    m_beginWith = CopyString(V_BSTR(&v));
    hr = S_OK;


    SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_BEGINWITH, teb_beginWith);
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_get_beginAfter(VARIANT * time)
{
    HRESULT hr;

    if (time == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(time))))
    {
        goto done;
    }

    V_VT(time) = VT_BSTR;
    V_BSTR(time) = SysAllocString(m_beginAfter);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_beginAfter(VARIANT time)
{


    CComVariant v;
    HRESULT hr;

    hr = v.ChangeType(VT_BSTR, &time);

    if (FAILED(hr))
    {
        goto done;
    }

    delete [] m_beginAfter;
    m_beginAfter = CopyString(V_BSTR(&v));
    hr = S_OK;

    SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_BEGINAFTER, teb_beginAfter);
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_get_beginEvent(VARIANT * time)
{
    HRESULT hr;

    if (time == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(time))))
    {
        goto done;
    }

    V_VT(time) = VT_BSTR;
    V_BSTR(time) = SysAllocString(m_beginEvent);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_beginEvent(VARIANT time)
{
    CComVariant v;
    HRESULT hr;
    BOOL bAttach = FALSE;
    bool clearFlag = false;

    if(V_VT(&time) == VT_NULL)
    {
        clearFlag = true;
    }
    else
    {
        hr = v.ChangeType(VT_BSTR, &time);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    IGNORE_HR(m_eventMgr.DetachEvents());

    delete [] m_beginEvent;

    //processing the attribute change should be done here

    if(!clearFlag)
    {
        m_beginEvent = CopyString(V_BSTR(&v));
        if (m_mmbvr != NULL)
        {
            hr = m_mmbvr->GetMMBvr()->ResetOnEventChanged(VARIANT_TRUE);
            if (FAILED(hr))
            {
                goto done;
            }
            UpdateProgressBvr();
        }
        SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_BEGINEVENT, teb_beginEvent);
    }
    else
    {
        m_beginEvent = DEFAULT_M_BEGINEVENT;
        if (m_mmbvr != NULL)
        {
            Assert(NULL != m_mmbvr->GetMMBvr());
            hr = m_mmbvr->GetMMBvr()->put_StartType(MM_START_ABSOLUTE);
            if (FAILED(hr))
            {
                goto done;
            }

            hr = UpdateMMAPI();
            if (FAILED(hr))
            {
                goto done;
            }
        }
        ClearPropertyFlagAndNotify(DISPID_TIMEELEMENT_BEGINEVENT, teb_beginEvent);
    }

    hr = S_OK;
    IGNORE_HR(m_eventMgr.AttachEvents());

  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_get_dur(VARIANT * time)
{
    HRESULT hr;
    VARIANT fTemp;
    if (time == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(time))))
    {
        goto done;
    }

    VariantInit(&fTemp);
    fTemp.vt = VT_R4;
    fTemp.fltVal = m_dur;

    if( m_dur != INDEFINITE)
    {
        hr = THR(VariantChangeTypeEx(time, &fTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
        if (!SUCCEEDED(hr))
        {
            VariantClear(&fTemp);
            goto done;
        }
    }
    else
    {
        V_VT(time) = VT_BSTR;
        V_BSTR(time) = SysAllocString(WZ_INDEFINITE);
    }


    VariantClear(&fTemp);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_dur(VARIANT time)
{
    TraceTag((tagTimeElmBase,
        "CTIMEElementBase::(%lx)::base_put_dur()",
        this));

    float fOldDur = m_dur;
    HRESULT hr = E_FAIL;
    float CurTime = 0;
    bool isClear = false;

    if(V_VT(&time) != VT_NULL)
    {
        hr = VariantToTime(time, &m_dur);
        if (FAILED(hr))
            goto done;
    }
    else
    {
        m_dur = DEFAULT_M_DUR;
        isClear = true;
    }

    hr = UpdateMMAPI();
    if (FAILED(hr))
        goto done;

    hr = S_OK;

    if(!isClear)
    {
        SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_DUR, teb_dur);
    }
    else
    {
        ClearPropertyFlagAndNotify(DISPID_TIMEELEMENT_DUR, teb_dur);
    }

done:
    if (FAILED(hr))
    {
        // return this object to its original state.
        m_dur = fOldDur;
        if (NULL != m_mmbvr)
        {
            Update();
        }
    }
    return hr;
}

HRESULT
CTIMEElementBase::base_get_end(VARIANT * time)
{
    HRESULT hr;
    VARIANT fTemp, bstrTemp;
    if (time == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(time))))
    {
        goto done;
    }

    if(m_end != INDEFINITE)
    {
        if (m_end == valueNotSet)
        {
            time->vt = VT_R4;
            time->fltVal = HUGE_VAL;
        }
        else
        {
            VariantInit(&fTemp);
            VariantInit(&bstrTemp);
            fTemp.vt = VT_R4;
            fTemp.fltVal = m_end;

            hr = THR(VariantChangeTypeEx(&bstrTemp, &fTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
            if (SUCCEEDED(hr))
            {
                time->vt = VT_BSTR;
                time->bstrVal = SysAllocString(bstrTemp.bstrVal);
            }
            else
            {
                time->vt = VT_R4;
                time->fltVal = fTemp.fltVal;
            }
            VariantClear(&fTemp);
            SysFreeString(bstrTemp.bstrVal);
            VariantClear(&bstrTemp);
        }
    }
    else
    {
        V_VT(time) = VT_BSTR;
        V_BSTR(time) = SysAllocString(WZ_INDEFINITE);
    }

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_end(VARIANT time)
{
    float fOldEnd = m_end;
    HRESULT hr = E_FAIL;
    float CurTime = 0;
    bool isClear = false;

    if(V_VT(&time) != VT_NULL)
    {
        hr = VariantToTime(time, &m_end);
        if (FAILED(hr))
            goto done;
    }
    else
    {
        m_end = DEFAULT_M_END;
        isClear = true;
    }

    hr = UpdateMMAPI();
    if (FAILED(hr))
        goto done;

    hr = S_OK;

    if(!isClear)
    {
        SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_END, teb_end);
    }
    else
    {
        ClearPropertyFlagAndNotify(DISPID_TIMEELEMENT_END, teb_end);
    }

done:
    if (FAILED(hr))
    {
        m_end = fOldEnd;
        if (NULL != m_mmbvr)
        {
            Update();
        }
    }

    return hr;
}

HRESULT
CTIMEElementBase::base_get_endWith(VARIANT * time)
{
    HRESULT hr;

    if (time == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(time))))
    {
        goto done;
    }

    V_VT(time) = VT_BSTR;
    V_BSTR(time) = SysAllocString(m_endWith);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_endWith(VARIANT time)
{
    CComVariant v;
    HRESULT hr;

    hr = v.ChangeType(VT_BSTR, &time);

    if (FAILED(hr))
    {
        goto done;
    }

    delete [] m_endWith;
    m_endWith = CopyString(V_BSTR(&v));
    hr = S_OK;

    SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_ENDWITH, teb_endWith);
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_get_endEvent(VARIANT * time)
{
    HRESULT hr;

    if (time == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(time))))
    {
        goto done;
    }

    V_VT(time) = VT_BSTR;
    V_BSTR(time) = SysAllocString(m_endEvent);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_endEvent(VARIANT time)
{
    CComVariant v;
    HRESULT hr;
    BOOL bAttach = FALSE;
    bool clearFlag = false;

    // only interested in the value -- not the contents.
    BSTR bstrPreviousEndEvent = m_endEvent;

    if(V_VT(&time) == VT_NULL)
    {
        clearFlag = true;
    }
    else
    {
        hr = v.ChangeType(VT_BSTR, &time);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    //if we have already attached to events then
    //detach from the events
    IGNORE_HR(m_eventMgr.DetachEvents());
    delete [] m_endEvent;

    if(!clearFlag)
    {
        m_endEvent = CopyString(V_BSTR(&v));
        SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_ENDEVENT, teb_endEvent);
    }
    else
    {
        m_endEvent = DEFAULT_M_ENDEVENT;
        ClearPropertyFlagAndNotify(DISPID_TIMEELEMENT_ENDEVENT, teb_endEvent);
    }

    hr = S_OK;

    IGNORE_HR(m_eventMgr.AttachEvents());

    if (m_mmbvr && bstrPreviousEndEvent != NULL)
    {
        hr = m_mmbvr->GetMMBvr()->ResetOnEventChanged(VARIANT_FALSE);
        UpdateProgressBvr();
    }
    else
    {
        if (NULL != m_mmbvr)
            hr = Update();
    }

  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_get_endSync(VARIANT * time)
{
    HRESULT hr;

    if (time == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(time))))
    {
        goto done;
    }

    V_VT(time) = VT_BSTR;
    V_BSTR(time) = SysAllocString(m_endSync);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_endSync(VARIANT time)
{
    CComVariant v;
    HRESULT hr;

    hr = v.ChangeType(VT_BSTR, &time);

    if (FAILED(hr))
    {
        goto done;
    }

    delete [] m_endSync;
    m_endSync = CopyString(V_BSTR(&v));
    hr = S_OK;

    SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_ENDSYNC, teb_endSync);
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_get_repeat(VARIANT * time)
{
    HRESULT hr;
    // Still need to take in to consideration "infinite"

    if (time == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(time))))
    {
        goto done;
    }

    if(m_repeat != INDEFINITE)
    {
        V_VT(time) = VT_R4;
        V_R4(time) = m_repeat;
    }
        else
    {
        V_VT(time) = VT_BSTR;
        V_BSTR(time) = SysAllocString(WZ_INDEFINITE);
    }

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_repeat(VARIANT time)
{
    VARIANT v;
    VARIANT vTemp;
    float fOldRepeat = m_repeat;

	VariantInit(&v);
	VariantInit(&vTemp);

    HRESULT hr = THR(VariantChangeTypeEx(&vTemp, &time, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
    bool isClear = false;

    if (SUCCEEDED(hr) && IsIndefinite(V_BSTR(&vTemp)))
    {
        m_repeat = INDEFINITE;
    }
    else if(V_VT(&time) != VT_NULL)
    {
        hr = THR(VariantChangeTypeEx(&v, &time, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R4));
        if (FAILED(hr))
        {
            goto done;
        }

        if (0.0f >= V_R4(&v))
        {
            hr = E_INVALIDARG;
            goto done;
        }

        m_repeat = V_R4(&v);
    }
    else
    {
        m_repeat = DEFAULT_M_REPEAT;
        isClear = true;
    }

    hr = UpdateMMAPI();
    if (FAILED(hr))
        goto done;

    hr = S_OK;

    if(!isClear)
    {
        SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_REPEAT, teb_repeat);
    }
    else
    {
        ClearPropertyFlagAndNotify(DISPID_TIMEELEMENT_REPEAT, teb_repeat);
    }

  done:
	VariantClear(&vTemp);
	VariantClear(&v);

	if (FAILED(hr))
    {
        m_repeat = fOldRepeat;
        if (NULL != m_mmbvr)
        {
            Update();
        }
    }

    return hr;
}

HRESULT
CTIMEElementBase::base_get_repeatDur(VARIANT * time)
{
    HRESULT hr;
    VARIANT fTemp, bstrTemp;
    if (time == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(time))))
    {
        goto done;
    }

    if(m_repeatDur != INDEFINITE)
    {
        VariantInit(&fTemp);
        VariantInit(&bstrTemp);
        fTemp.vt = VT_R4;
        fTemp.fltVal = m_repeatDur;

        hr = THR(VariantChangeTypeEx(&bstrTemp, &fTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
        if (SUCCEEDED(hr))
        {
            time->vt = VT_BSTR;
            time->bstrVal = SysAllocString(bstrTemp.bstrVal);
        }
        else
        {
            time->vt = VT_R4;
            time->fltVal = fTemp.fltVal;
        }
        VariantClear(&fTemp);
        SysFreeString(bstrTemp.bstrVal);
        VariantClear(&bstrTemp);
    }
    else
    {
        V_VT(time) = VT_BSTR;
        V_BSTR(time) = SysAllocString(WZ_INDEFINITE);
    }


    hr = S_OK;

  done:

    return hr;
}

HRESULT
CTIMEElementBase::base_put_repeatDur(VARIANT time)
{
    HRESULT hr = E_FAIL;

    bool isClear = false;
    float fOldRepeatDur = m_repeatDur;

    if(V_VT(&time) != VT_NULL)
    {
        hr = VariantToTime(time, &m_repeatDur);
        if (FAILED(hr))
            goto done;
    }
    else
    {
        m_repeatDur = DEFAULT_M_REPEATDUR;
        isClear = true;
    }

    hr = UpdateMMAPI();
    if (FAILED(hr))
        goto done;

    if(!isClear)
    {
        SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_REPEATDUR, teb_repeatDur);
    }
    else
    {
        ClearPropertyFlagAndNotify(DISPID_TIMEELEMENT_REPEATDUR, teb_repeatDur);
    }
    hr = S_OK;

done:
    if (FAILED(hr))
    {
        m_repeatDur = fOldRepeatDur;
        if (NULL != m_mmbvr)
        {
            Update();
        }
    }
    return hr;
}

HRESULT
CTIMEElementBase::base_get_accelerate(int * e)
{
    HRESULT hr;

    if (e == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    *e = m_accelerate;

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_accelerate(int e)
{
    HRESULT hr;

    if (e < 0 || e > 100)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    m_accelerate = e;

    hr = S_OK;

    SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_ACCELERATE, teb_accelerate);
  done:

    return hr;
}

HRESULT
CTIMEElementBase::base_get_decelerate(int * e)
{
    HRESULT hr;

    if (e == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    *e = m_decelerate;

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_decelerate(int e)
{
    HRESULT hr;

    if (e < 0 || e > 100)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    m_decelerate = e;

    hr = S_OK;

    SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_DECELERATE, teb_decelerate);
  done:

    return hr;
}

HRESULT
CTIMEElementBase::base_get_autoReverse(VARIANT_BOOL * b)
{
    CHECK_RETURN_NULL(b);

    *b = m_bautoreverse?VARIANT_TRUE:VARIANT_FALSE;

    return S_OK;
}

HRESULT
CTIMEElementBase::base_put_autoReverse(VARIANT_BOOL b)
{
    HRESULT hr;
    bool bOldAutoreverse = m_bautoreverse;

    m_bautoreverse = b?true:false;

    hr = UpdateMMAPI();
    if (FAILED(hr))
        goto done;

    hr = S_OK;

    SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_AUTOREVERSE, teb_autoReverse);
done:
    if (FAILED(hr))
    {
        m_bautoreverse = bOldAutoreverse;
        if (NULL != m_mmbvr)
        {
            Update();
        }
    }
    return hr;
}

HRESULT
CTIMEElementBase::base_get_endHold(VARIANT_BOOL * b)
{
    CHECK_RETURN_NULL(b);

    *b = m_bendHold?VARIANT_TRUE:VARIANT_FALSE;

    return S_OK;
}

HRESULT
CTIMEElementBase::base_put_endHold(VARIANT_BOOL b)
{
    HRESULT hr;

    bool bOldEndHold = m_bendHold;

    m_bendHold = b?true:false;

    hr = UpdateMMAPI();
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;

    SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_ENDHOLD, teb_endHold);
done:
    if (FAILED(hr))
    {
        m_bendHold = bOldEndHold;
        if (NULL != m_mmbvr)
        {
            Update();
        }
    }

    return hr;
}

HRESULT
CTIMEElementBase::base_get_eventRestart(VARIANT_BOOL * b)
{
    CHECK_RETURN_NULL(b);

    *b = m_beventrestart?VARIANT_TRUE:VARIANT_FALSE;

    return S_OK;
}

HRESULT
CTIMEElementBase::base_put_eventRestart(VARIANT_BOOL b)
{
    HRESULT hr;

    m_beventrestart = b?true:false;

    hr = S_OK;

    SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_EVENTRESTART, teb_eventRestart);
    return hr;
}

HRESULT
CTIMEElementBase::base_get_timeAction(LPOLESTR * action)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(action);

    *action = SysAllocString(TokenToString(m_timeAction));

    if (*action == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_timeAction(LPOLESTR action)
{
    HRESULT hr;
    bool clearFlag = false;
    TOKEN tok_action;

    if( action == NULL)
    {
        tok_action = DEFAULT_M_TIMEACTION;
        clearFlag = true;
    }
    else
    {
        tok_action = StringToToken(action);
    }
    if (tok_action != DISPLAY_TOKEN &&
        tok_action != VISIBILITY_TOKEN &&
        tok_action != ONOFF_TOKEN &&
        tok_action != STYLE_TOKEN &&
        tok_action != NONE_TOKEN)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (m_timeAction != tok_action)
    {
        if (!RemoveTimeAction())
        {
            hr = CRGetLastError();
            goto done;
        }

        m_timeAction = tok_action;

        if (!AddTimeAction())
        {
            hr = CRGetLastError();
            goto done;
        }

        // If we've not yet started or we've stopped, make sure to toggle the time action accordingly.
        if ((NULL == m_mmbvr) || (HUGE_VAL == m_mmbvr->GetLocalTime()))
        {
            if (!ToggleTimeAction(false))
            {
                hr = CRGetLastError();
                goto done;
            }
        }
    }

    hr = S_OK;

    if(!clearFlag)
    {
        SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_TIMEACTION, teb_timeAction);
    }
    else
    {
        ClearPropertyFlagAndNotify(DISPID_TIMEELEMENT_TIMEACTION, teb_timeAction);
    }
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_beginElement(bool bAfterOffset)
{
    bool ok = false;

    if (!Update())
    {
        goto done;
    }

    Assert(NULL != m_mmbvr);
    if (NULL != m_mmbvr)
    {
        MM_STATE mmstate = m_mmbvr->GetPlayState();

        if (m_beventrestart || (MM_STOPPED_STATE == mmstate))
        {
            if (MM_PLAYING_STATE == mmstate)
            {
                float time = m_mmbvr->GetLocalTime();
                if (time == 0)
                {
                    goto done;
                }
            }

            MMTimeline *timeline = GetMMTimeline();
            if (NULL != timeline)
            {
                if (!timeline->Begin(bAfterOffset))
                {
                    goto done;
                }
            }
            else if (!m_mmbvr->Begin(bAfterOffset))
            {
                goto done;
            }
        }

        ok = true;
    }

  done:
    return ok?S_OK:Error();
}

HRESULT
CTIMEElementBase::base_endElement()
{
    bool ok = false;


    Assert(NULL != m_mmbvr);
    if (NULL != m_mmbvr)
    {
        if (!m_mmbvr->End())
        {
            goto done;
        }

        ok = true;
    }


  done:
    return ok?S_OK:Error();
}

HRESULT
CTIMEElementBase::base_pause()
{
    bool ok = false;

    Assert(NULL != m_mmbvr);
    if (NULL != m_mmbvr)
    {
        if (!m_mmbvr->Pause())
        {
            goto done;
        }

        ok = true;
    }

  done:
    return ok?S_OK:Error();
}

HRESULT
CTIMEElementBase::base_resume()
{
    bool ok = false;

    Assert(NULL != m_mmbvr);
    if (NULL != m_mmbvr)
    {
        if (!m_mmbvr->Resume())
        {
            goto done;
        }

        ok = true;
    }

  done:
    return ok?S_OK:Error();
}

HRESULT
CTIMEElementBase::base_cue()
{
    bool ok = false;

    ok = true;

    return ok?S_OK:Error();
}

HRESULT
CTIMEElementBase::base_get_timeline(BSTR * pbstrTimeLine)
{
    HRESULT hr = S_OK;
    CHECK_RETURN_NULL(pbstrTimeLine);
        LPWSTR wszTimelineString = WZ_NONE;

        switch(m_TimelineType)
        {
            case ttPar :
                    wszTimelineString = WZ_PAR;
                    break;
            case ttSeq :
                    wszTimelineString = WZ_SEQUENCE;
                    break;
        }

    *pbstrTimeLine = SysAllocString(wszTimelineString);
    if (NULL == *pbstrTimeLine)
        hr = E_OUTOFMEMORY;

    return hr;
}

HRESULT
CTIMEElementBase::base_put_timeline(BSTR bstrNewTimeline)
{
    CHECK_RETURN_NULL(bstrNewTimeline);
    HRESULT hr = S_OK;
    BSTR bstrTagName = NULL;
    TimelineType newTimelineType;
    TimelineType oldTimelineType;

    oldTimelineType = m_TimelineType;

    hr = THR(GetElement()->get_tagName(&bstrTagName));
    if (FAILED(hr))
    {
        goto done;
    }

    if (StrCmpIW(bstrTagName, WZ_PAR) == 0 || StrCmpIW(bstrTagName, WZ_SEQUENCE) == 0)
    {
        hr = E_FAIL;
        goto done;
    }

    if (0 == StrCmpIW(WZ_PAR, bstrNewTimeline))
    {
        newTimelineType = ttPar;
    }
    else if (0 == StrCmpIW(WZ_SEQUENCE, bstrNewTimeline))
    {
        newTimelineType = ttSeq;
    }
    else if ((0 == StrCmpIW(WZ_NONE, bstrNewTimeline)) &&
        !IsBody() )
    {
        newTimelineType = ttNone;
    }
    else
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (m_TimelineType == ttUninitialized)
    {
        m_TimelineType = newTimelineType;
    }

    if (oldTimelineType != newTimelineType && newTimelineType != ttSeq)
    {
        DAComPtr<ITIMEElement> pTimeElement;


        MMTimeline* pTimeline;
        if (NULL == GetParent())
        {
            hr = E_FAIL;
            goto done;
        }

        bool doTimeline = m_bStarted;
        if(doTimeline)
        {
            pTimeline = GetParent()->GetMMTimeline();

            Assert(pTimeline != NULL);
            this->StopRootTime(pTimeline);
        }
        m_TimelineType = newTimelineType;

        if (ttPar == m_TimelineType)
        {
            THR(this->QueryInterface(IID_TO_PPV(ITIMEElement, &pTimeElement)));

            hr = ReparentChildren(pTimeElement, m_pHTMLEle);
            if (FAILED(hr))
                // what to do?
                goto done;
        }
        else
        {
            Assert(ttNone == m_TimelineType);

            for(int i = this->GetAllChildCount(); i > 0; i--)
            {
                CTIMEElementBase *pChild = this->GetChild(i - 1);

                if (NULL != GetParent())
                    THR(GetParent()->QueryInterface(IID_TO_PPV(ITIMEElement, &pTimeElement)));

                hr = THR(pChild->SetParent(pTimeElement, false));
                if (FAILED(hr))
                    goto done;

                if (NULL != GetParent() && doTimeline)
                    // ignore the result if startroottime fails
                    (void) THR(pChild->StartRootTime(GetParent()->GetMMTimeline()));
                pTimeElement.Release();
            }
        }

        if(doTimeline)
        {
            m_fTimelineInitialized = false;
            delete m_mmbvr;
            m_mmbvr = NULL;
            m_timeline = NULL;
            hr = this->InitTimeline();
            if (FAILED(hr))
                goto done;
            if (!m_mmbvr->Reset())
            {
                hr = TIMEGetLastError();
                goto done;
            }
        }
    }
    else
    {
        if( oldTimelineType != ttUninitialized)
            if (ttSeq == oldTimelineType || ttSeq == newTimelineType)
            {
                hr = E_FAIL;
                goto done;
            }

    }

    SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_TIMELINE, teb_timeline);
done:
    if (FAILED(hr))
        m_TimelineType = oldTimelineType;

    SysFreeString(bstrTagName);
    return hr;
}

HRESULT
CTIMEElementBase::base_get_currTime(float * time)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::base_get_currTime(%lx)",
              this,
              time));

    HRESULT hr = E_FAIL;

    CHECK_RETURN_SET_NULL(time);

    Assert(NULL != m_mmbvr);
    if (NULL != m_mmbvr)
    {
        *time = m_mmbvr->GetSegmentTime();
        hr = S_OK;
    }

    return hr;
}

HRESULT
CTIMEElementBase::base_put_currTime(float time)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::base_put_currTime(%g)",
              this,
              time));
    return E_NOTIMPL;
}


HRESULT
CTIMEElementBase::base_get_localTime(float * time)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::base_get_localTime(%lx)",
              this,
              time));

    HRESULT hr = E_FAIL;

    CHECK_RETURN_SET_NULL(time);

    Assert(NULL != m_mmbvr);
    if (NULL != m_mmbvr)
    {
        *time = m_mmbvr->GetLocalTime();
        hr = S_OK;
    }

    return hr;
}

HRESULT
CTIMEElementBase::base_put_localTime(float time)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::base_put_localTime(%g)",
              this,
              time));

    bool ok = false;

    Assert(NULL != m_mmbvr);
    if (NULL != m_mmbvr)
    {
        // seeking when paused is enforced in MMAPI
        if (!m_mmbvr->Seek(time))
        {
            goto done;
        }
        // Make sure we have a player
        if (!GetPlayer())
        {
            goto done;
        }
        // Force a tick to render updates.
        if (!(GetPlayer()->TickOnceWhenPaused()))
        {
            goto done;
        }
    }

    ok = true;
  done:
    return ok?S_OK:Error();
}

HRESULT
CTIMEElementBase::base_get_currState(LPOLESTR * state)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(state);

    hr = E_NOTIMPL;

    return hr;
}

HRESULT
CTIMEElementBase::base_put_currState(LPOLESTR state)
{
    return E_NOTIMPL;
}

HRESULT
CTIMEElementBase::base_get_syncBehavior(LPOLESTR * sync)
{
    HRESULT hr;

    CHECK_RETURN_SET_NULL(sync);

    *sync = SysAllocString(TokenToString(m_syncBehavior));

    if (*sync == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_syncBehavior(LPOLESTR sync)
{
    HRESULT hr;

    TOKEN tok_sync = StringToToken(sync);

    if( (tok_sync != CANSLIP_TOKEN) &&
        (tok_sync != LOCKED_TOKEN))
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (m_syncBehavior != tok_sync)
    {
        m_syncBehavior = tok_sync;
    }

    if (NULL != m_mmbvr)
    {
        m_mmbvr->Update();
    }

    hr = S_OK;


    SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_SYNCBEHAVIOR, teb_syncBehavior);
  done:
    return hr;
}


HRESULT
CTIMEElementBase::base_get_syncTolerance(VARIANT * time)
{
    HRESULT hr;
    VARIANT fTemp, bstrTemp;
    if (time == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (FAILED(hr = THR(VariantClear(time))))
    {
        goto done;
    }

    VariantInit(&fTemp);
    VariantInit(&bstrTemp);
    fTemp.vt = VT_R4;
    fTemp.fltVal = m_syncTolerance;

    hr = THR(VariantChangeTypeEx(&bstrTemp, &fTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR));
    if (SUCCEEDED(hr))
    {
        time->vt = VT_BSTR;
        time->bstrVal = SysAllocString(bstrTemp.bstrVal);
    }
    else
    {
        time->vt = VT_R4;
        time->fltVal = fTemp.fltVal;
    }

    VariantClear(&fTemp);
    SysFreeString(bstrTemp.bstrVal);
    VariantClear(&bstrTemp);

    hr = S_OK;
  done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_syncTolerance(VARIANT time)
{
    VariantToTime(time, &m_syncTolerance);

    SetPropertyFlagAndNotify(DISPID_TIMEELEMENT_SYNCTOLERANCE, teb_syncTolerance);
    return S_OK;
}

HRESULT
CTIMEElementBase::AddTIMEElement(CTIMEElementBase *elm)
{
    HRESULT hr = S_OK;

    hr = THR(m_pTIMEChildren.Append(elm));
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

HRESULT
CTIMEElementBase::RemoveTIMEElement(CTIMEElementBase *elm)
{
    HRESULT hr = S_OK;

    bool bFound = m_pTIMEChildren.DeleteByValue(elm);
    if (bFound == false)
    {
        // no real error returned.  should fix up the array code...
        goto done;
    }

done:
    return hr;
}


HRESULT
CTIMEElementBase::base_get_parentTIMEElement(ITIMEElement **ppElem)
{
    HRESULT hr = S_OK;
    if (ppElem == NULL)
    {
        TraceTag((tagError, "CTIMEElementBase::base_get_parentTIMEElement - invalid arg"));
        hr = E_POINTER;
        goto done;
    }

    *ppElem = NULL;

    if (m_pTIMEParent != NULL)
    {
        hr = THR(m_pTIMEParent->QueryInterface(IID_ITIMEElement, (void**)ppElem));
    }

done:
    return hr;
}

HRESULT
CTIMEElementBase::base_put_parentTIMEElement(ITIMEElement *pElem)
{
    return E_NOTIMPL;
}

//*****************************************************************************
// method:   ReparentChildren()
//
// abstract: this method walks down an HTML tree, reparenting children that
//           have TIME behaviors to this TIME element.
//           Note:  if we find a TIME element that is a group, we need to stop.
//*****************************************************************************
HRESULT
CTIMEElementBase::ReparentChildren(ITIMEElement *pTIMEParent, IHTMLElement *pElem)
{
    DAComPtr<IDispatch>               pChildrenDisp;
    DAComPtr<IHTMLElementCollection>  pChildrenCollection;
    VARIANT varName;
    VARIANT varIndex;
    HRESULT hr;
    long    lChildren = 0;
    long    i;

    if (pElem == NULL)
    {
        hr = E_FAIL;
        Assert(false && "CTIMEElementBase::ReparentChildren was passed a NULL!");
        goto done;
    }

    // get pointer to children
    hr = THR(pElem->get_children(&pChildrenDisp));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(pChildrenDisp.p != NULL);

    // move to collection interface
    hr = THR(pChildrenDisp->QueryInterface(IID_IHTMLElementCollection, (void**)&pChildrenCollection));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(pChildrenCollection.p != NULL);

    // get length
    hr = THR(pChildrenCollection->get_length(&lChildren));
    if (FAILED(hr))
    {
        goto done;
    }

    // Variants for IHTMLElementCollection->item() call.
    // NOTE: we are using first Variant as an index.  The second variant
    //       is along for the ride.  The second variant only comes into play
    //       when you use the first variant as a name and multiple names exist.
    //       Then, the second can act as a index.
    VariantInit(&varName);
    varName.vt = VT_I4;
    varName.lVal = 0;

    VariantInit(&varIndex);

    // loop thru children
    for (i = 0; i < lChildren; i++)
    {
        DAComPtr<IDispatch>       pChildDisp;
        DAComPtr<ITIMEElement>    pTIMEElem;
        DAComPtr<IHTMLElement>    pChildElement;
        CTIMEElementBase *pTempTEB = NULL;

        varName.lVal = i;

        // get indexed child
        hr = THR(pChildrenCollection->item(varName, varIndex, &pChildDisp));
        if (FAILED(hr))
        {
            goto done;
        }

        Assert(pChildDisp.p != NULL);

        // get IHTMLElement
        hr = THR(pChildDisp->QueryInterface(IID_IHTMLElement, (void**)&pChildElement));
        if (FAILED(hr))
        {
            goto done;
        }

        // Is there a TIME behavior on this element
        pTIMEElem = NULL;
        hr = FindTIMEInterface(pChildElement, &pTIMEElem);
        if (SUCCEEDED(hr))
        {
            Assert(pTIMEElem.p != NULL);
            pTempTEB = GetTIMEElementBase(pTIMEElem);

            Assert(pTempTEB != NULL);

            // set parent.  do not set children
            hr = pTempTEB->SetParent(pTIMEParent, false);
            if (FAILED(hr))
            {
                goto done;
            }
        }

        // if NO TIME was found or the TIME element is not a group
        // continue walking down the tree
        if ( (pTIMEElem.p == NULL) ||
             ((pTempTEB != NULL) && !pTempTEB->IsGroup()) )
        {
            hr = ReparentChildren(pTIMEParent, pChildElement);
            if (FAILED(hr))
            {
                goto done;
            }
        }
    } // for loop

    hr = S_OK;
done:
    return hr;
}

//*****************************************************************************
// method:   UnparentElement()
//
// abstract: this is a centralized method that knows how to detach a TIME element
//           from it's parent (if it has one).  There only two cases when this is
//           called.  Either you are shutting down (ie ::detach()) or you are being
//           reparented (ie SetParent() with new parent).
//*****************************************************************************
HRESULT
CTIMEElementBase::UnparentElement()
{
    HRESULT hr;

    // stop timeline
    if (m_bStarted)
    {
        MMTimeline * tl = NULL;
        if (m_pTIMEParent != NULL)
            tl = m_pTIMEParent->GetMMTimeline();
        StopRootTime(tl);
    }

    if (m_pTIMEParent != NULL)
    {
        // if the parent is around, traverse back up, invalidating the collection cache.
        THR(InvalidateCollectionCache());

        // clear ourselves from our parents list
        hr = THR(m_pTIMEParent->RemoveTIMEElement(this));
        if (FAILED(hr))
        {
            goto done;
        }

        // these are both week references and we should NULL them since
        // we have no parent and are not associated with the inner TIME
        // heirarchy.
        m_pTIMEParent = NULL;
        m_pTIMEBody = NULL;
    }

    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEElementBase::SetParent(ITIMEElement *pElem, bool fReparentChildren /* true */)
{
    HRESULT hr = S_OK;
    CTIMEElementBase *pTempTEB = NULL;

    // for the body return with an error
    if (IsBody())
    {
        TraceTag((tagError, "CTIMEElementBase::SetParent - error trying to parent a body element"));
        hr = E_UNEXPECTED;
        goto done;
    }

    // if we already have a parent, remove ourselves from it's child list
    if (m_pTIMEParent != NULL)
    {
        DAComPtr<ITIMEElement> pParent;

        // PERF: if the parent coming in is equal to current parent, make it a nop
        // NOTE: this can never fail!
        THR(m_pTIMEParent->QueryInterface(IID_ITIMEElement, (void**)&pParent));
        if (pParent == pElem)
        {
            hr = S_OK;
            goto done;
        }

        // need to unparent element.
        hr = UnparentElement();
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementBase::SetParent(%lx) - UnparentElement() failed", this));
            goto done;
        }
    }

    Assert(m_pTIMEParent == NULL);

    // if NULL was passed in, our work is done
    if (pElem == NULL)
    {
        hr = S_OK;
        goto done;
    }

    // move from the interface pointer to the class pointer
    pTempTEB = GetTIMEElementBase(pElem);
    if (pTempTEB == NULL)
    {
        TraceTag((tagError, "CTIMEElementBase::SetParent - GetTIMEElementBase() failed"));
        hr = E_INVALIDARG;
        goto done;
    }

    // add ourselves as a child
    hr = THR(pTempTEB->AddTIMEElement(this));
    if (FAILED(hr))
    {
        goto done;
    }

    // cache the parent
    // BUGBUG: this is a weak reference
    m_pTIMEParent = pTempTEB;

    // cache the designated Body
    // BUGBUG: this is a weak reference
    Assert(pTempTEB->GetBody());
    m_pTIMEBody = pTempTEB->GetBody();

    // reparent any children of this HTML element that have children, if we
    // are a group.
    if (fReparentChildren && IsGroup())
    {
        DAComPtr<ITIMEElement> pTIMEElem;

        // This should ALWAYS work
        THR(QueryInterface(IID_ITIMEElement, (void**)&pTIMEElem));
        Assert(pTIMEElem.p != NULL);
        hr = ReparentChildren(pTIMEElem, GetElement());
        if (FAILED(hr))
        {
            goto done;
        }
    }
    hr = S_OK;
done:
    return hr;
}

HRESULT
CTIMEElementBase::ParentElement()
{
    TraceTag((tagTimeElmBase, "CTIMEElementBase::ParentElement"));
    // Loop thru parents until one is found with TIME on it
    bool fFound = false;
    bool fBehaviorExists = false;
    DAComPtr<IHTMLElement> pElem = GetElement();
    DAComPtr<IHTMLElement> pElemParent = NULL;
    DAComPtr<ITIMEElement> pTIMEElem = NULL;
    HRESULT hr = S_FALSE;

    Assert(!IsBody());

    // walk up the HTML tree, looking for element's with TIME behaviors on them
    while (!fFound)
    {
        hr = THR(pElem->get_parentElement(&pElemParent));
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementBase::ParentElement - get_parentElement() failed"));
            goto done;
        }

        // see if we have a parent
        // If not, this is an orphaned case
        if (pElemParent.p == NULL)
        {
            TraceTag((tagTimeElmBase, "CTIMEElementBase::ParentElement - orphaned node!!!"));
            hr = S_FALSE;
            goto done;
        }

        // see if TIME behavior exists on parent
        fBehaviorExists = false;
        hr = CheckElementForBehaviorURN(pElemParent, GetBehaviorTypeAsURN(), &fBehaviorExists);
        if (FAILED(hr))
        {
            goto done;
        }

        // if this element has a TIME behavior and is either a
        // par or seq, then we have found our parent.
        if (fBehaviorExists && IsGroup(pElemParent))
        {
            fFound = true;
        }
        else
        {
            // continue walking up the tree
            pElem = pElemParent;
            pElemParent.Release();
        }
    }

    // if we found a parent with TIME, add our selves to it's children
    if (fFound && (pElemParent.p != NULL))
    {
        // get TIME interface
        hr = FindTIMEInterface(pElemParent, &pTIMEElem);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementBase::ParentElement - FindTIMEInterface() failed"));
            goto done;
        }

        Assert(pTIMEElem.p != NULL);

        // set our parent
        hr = THR(SetParent(pTIMEElem));
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementBase::ParentElement - SetParent() failed"));
            goto done;
        }
        hr = S_OK;
    }

done:
    return hr;
}

HRESULT
CTIMEElementBase::base_get_timelineBehavior(IDispatch **ppDisp)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::base_get_timelineBehavior()",
              this));

    CHECK_RETURN_SET_NULL(ppDisp);
    DAComPtr<IDANumber> bvr;
    bool ok = false;
    HRESULT hr;

    Assert(m_datimebvr);

    if (!CRBvrToCOM((CRBvrPtr) m_datimebvr.p,
                    IID_IDANumber,
                    (void **) &bvr.p))
    {
        goto done;
    }

    // make assignment.  keep ref count.
    hr = THR(bvr->QueryInterface(IID_IDispatch, (void**)ppDisp));
    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok?S_OK:Error();
}

HRESULT
CTIMEElementBase::base_get_progressBehavior(IDispatch **ppDisp)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::base_get_progressBehavior()",
              this));

    CHECK_RETURN_SET_NULL(ppDisp);
    DAComPtr<IDANumber> bvr;
    bool ok = false;
    HRESULT hr;

    Assert(m_progress);

    if (!CRBvrToCOM((CRBvrPtr) m_progress.p,
                    IID_IDANumber,
                    (void **) &bvr.p))
    {
        goto done;
    }

    // make assignment.  keep ref count.
    hr = THR(bvr->QueryInterface(IID_IDispatch, (void**)ppDisp));
    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }

    ok = true;
  done:
    return ok?S_OK:Error();
}

HRESULT
CTIMEElementBase::base_get_onOffBehavior(IDispatch **ppDisp)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::base_get_onOffBehavior()",
              this));

    CHECK_RETURN_SET_NULL(ppDisp);
    DAComPtr<IDABoolean> bvr;
    bool ok = false;
    HRESULT hr;

    Assert(m_onoff);

    if (!CRBvrToCOM((CRBvrPtr) m_onoff.p,
                    IID_IDABoolean,
                    (void **) &bvr.p))
    {
        goto done;
    }

    // make assignment.  keep ref count.
    hr = THR(bvr->QueryInterface(IID_IDispatch, (void**)ppDisp));
    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }
    ok = true;
  done:
    return ok?S_OK:Error();
}

HRESULT
CTIMEElementBase::StartRootTime(MMTimeline * tl)
{
    HRESULT hr = E_FAIL;

    Assert(!m_bStarted);

    if (!Update())
    {
        hr = CRGetLastError();
        goto done;
    }

    Assert(tl || m_timeline);
    Assert(NULL != m_mmbvr);
    if (NULL != m_mmbvr)
    {

        // Need to make sure the timeline passed in
        if (tl != NULL && !tl->AddBehavior(*m_mmbvr))
        {
            hr = CRGetLastError();
            goto done;
        }

        // is this element a par or seq
        if (IsGroup())
        {
            CTIMEElementBase **ppElm;
            int i;

            for (i = m_pTIMEChildren.Size(), ppElm = m_pTIMEChildren;
                 i > 0;
                 i--, ppElm++)
            {
                Assert(m_timeline);

                hr = THR((*ppElm)->StartRootTime(m_timeline));
                if (FAILED(hr))
                {
                    goto done;
                }
            }
        }
        else
        {
            // If we are not par then we should not have children
            Assert(m_pTIMEChildren.Size() == 0);
        }

        m_bStarted = true;
        hr = S_OK;
    }
  done:
    return hr;
}

void
CTIMEElementBase::StopRootTime(MMTimeline * tl)
{
    Assert(NULL != m_mmbvr);
    if (NULL != m_mmbvr)
    {
        if (tl != NULL)
        {
            tl->RemoveBehavior(*m_mmbvr);
        }

        // if this a par or seq, then process children
        if (IsGroup())
        {
            CTIMEElementBase **ppElm;
            int i;

            for (i = m_pTIMEChildren.Size(), ppElm = m_pTIMEChildren;
                 i > 0;
                 i--, ppElm++)
            {
                Assert(m_timeline);
                (*ppElm)->StopRootTime(m_timeline);
            }
        }
        else
        {
            // If we are not par then we should not have children
            Assert(m_pTIMEChildren.Size() == 0);
        }
    }

    m_bStarted = false;

    return;
}

bool
CTIMEElementBase::Update()
{
    bool ok = false;
    CRBvr * bvr;

    CRLockGrabber __gclg;

    CalcTimes();

    // Force updating of the timing structures

    Assert(NULL != m_mmbvr);
    if (NULL != m_mmbvr)
    {
        if (!m_mmbvr->Update())
        {
            goto done;
        }

        if (m_timeline && !m_timeline->Update())
        {
            goto done;
        }

        ok = true;
    }

  done:
    return ok;
}

void
CTIMEElementBase::CalcTimes()
{
    m_realBeginTime = m_begin;
    m_realRepeatCount = m_repeat;

    if (m_dur != valueNotSet)
    {
        m_realDuration = m_dur;
    }
    else if (m_end != valueNotSet)
    {
        if (m_end < m_begin)
        {
            m_realDuration = HUGE_VAL;
        }
        else
        {
            m_realDuration = m_end - m_begin;
        }
    }
    else
    {
        m_realDuration = HUGE_VAL;
    }

    if (m_realDuration == 0.0f)
    {
        m_realDuration = HUGE_VAL;
    }

    if (m_bautoreverse && (HUGE_VAL != m_realDuration))
    {
        m_realIntervalDuration = m_realDuration * 2;
    }
    else
    {
        m_realIntervalDuration = m_realDuration;
    }

    if (m_repeatDur != valueNotSet)
    {
        m_realRepeatTime = m_repeatDur;
    }
    else
    {
        m_realRepeatTime = m_repeat * m_realIntervalDuration;
    }

    if (m_realRepeatTime == 0.0f)
    {
        m_realRepeatTime = HUGE_VAL;
    }
}

TOKEN
GetActionPropertyToken(TOKEN action)
{
    TOKEN token;

    Assert(action != NONE_TOKEN);

    if (action == ONOFF_TOKEN)
    {
        token = ONOFF_PROPERTY_TOKEN;
    }
    else if (action == STYLE_TOKEN)
    {
        token = STYLE_PROPERTY_TOKEN;
    }
    else if (action == DISPLAY_TOKEN)
    {
        token = DISPLAY_PROPERTY_TOKEN;
    }
    else
    {
        token = VISIBILITY_PROPERTY_TOKEN;
    }

    return token;
}

bool
CTIMEElementBase::AddTimeAction()
{
    bool ok = false;

    if (m_timeAction == NONE_TOKEN)
    {
        ok = true;
        goto done;
    }
    else if (m_timeAction == ONOFF_TOKEN)
    {
        CComVariant v;
        BSTR bstr;

        bstr = SysAllocString(TokenToString(ONOFF_PROPERTY_TOKEN));

        // Need to free bstr
        if (bstr == NULL)
        {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }

        // We do not care if this succeeds
        THR(GetElement()->getAttribute(bstr,0,&v));

        SysFreeString(bstr);

        if (SUCCEEDED(THR(v.ChangeType(VT_BSTR))))
        {
            m_origAction = CopyString(V_BSTR(&v));
        }

    }
    else if (m_timeAction == STYLE_TOKEN)
    {
        DAComPtr<IHTMLStyle> s;

        if ((!GetElement()) || FAILED(THR(GetElement()->get_style(&s))))
        {
            goto done;
        }

        BSTR bstr = NULL;

        if (FAILED(THR(s->get_cssText(&bstr))))
        {
            goto done;
        }

        m_origAction = CopyString(bstr);

        SysFreeString(bstr);
    }
    else if (m_timeAction == DISPLAY_TOKEN)
    {
        DAComPtr<IHTMLStyle> s;

        if ((!GetElement()) || FAILED(THR(GetElement()->get_style(&s))))
        {
            goto done;
        }

        BSTR bstr = NULL;

        if (FAILED(THR(s->get_display(&bstr))))
        {
            goto done;
        }

        m_origAction = CopyString(bstr);

        SysFreeString(bstr);
    }
    else
    {
        DAComPtr<IHTMLStyle> s;

        if ((!GetElement()) || FAILED(THR(GetElement()->get_style(&s))))
        {
            goto done;
        }

        BSTR bstr = NULL;

        if (FAILED(THR(s->get_visibility(&bstr))))
        {
            goto done;
        }

        m_origAction = CopyString(bstr);

        SysFreeString(bstr);
    }

    ok = true;
  done:
    return ok;
}

bool
CTIMEElementBase::RemoveTimeAction()
{
    bool ok = false;
    HRESULT hr = S_OK;

    if (m_timeAction == NONE_TOKEN)
    {
        ok = true;
        goto done;
    }
    else if (m_timeAction == ONOFF_TOKEN)
    {
        CComVariant v(m_origAction);

        BSTR bstr;

        bstr = SysAllocString(TokenToString(ONOFF_PROPERTY_TOKEN));

        // Need to free bstr
        if (bstr == NULL)
        {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }

        // We do not care if this succeeds
        THR(GetElement()->setAttribute(bstr,v,0));

        SysFreeString(bstr);

        delete [] m_origAction;
        m_origAction = NULL;
    }
    else if (m_timeAction == STYLE_TOKEN)
    {
        DAComPtr<IHTMLStyle> s;

        if ((!GetElement()) || FAILED(THR(GetElement()->get_style(&s))))
        {
            goto done;
        }

        BSTR bstr;

        bstr = SysAllocString(m_origAction);

        // Need to free bstr
        if (bstr == NULL)
        {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }

        THR(s->put_cssText(bstr));

        SysFreeString(bstr);

        delete [] m_origAction;
        m_origAction = NULL;
    }
    else if (m_timeAction == DISPLAY_TOKEN)
    {
        DAComPtr<IHTMLStyle> s;
        DAComPtr<IHTMLElement2> pElement2;

        if (!GetElement())
        {
            goto done;
        }

        hr = THR(GetElement()->QueryInterface(IID_IHTMLElement2, (void **)&pElement2));
        if (FAILED(hr))
        {
            goto done;
        }

        if (!pElement2 || FAILED(THR(pElement2->get_runtimeStyle(&s))))
        {
            goto done;
        }

        BSTR bstr;

        bstr = SysAllocString(m_origAction);

        // Need to free bstr
        if (bstr == NULL)
        {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }

        THR(s->put_display(bstr));

        SysFreeString(bstr);

        delete [] m_origAction;
        m_origAction = NULL;
    }
    else
    {
        DAComPtr<IHTMLStyle> s;
        DAComPtr<IHTMLElement2> pElement2;

        if (!GetElement())
        {
            goto done;
        }

        hr = THR(GetElement()->QueryInterface(IID_IHTMLElement2, (void **)&pElement2));
        if (FAILED(hr))
        {
            goto done;
        }

        if (!pElement2 || FAILED(THR(pElement2->get_runtimeStyle(&s))))
        {
            goto done;
        }

        BSTR bstr;

        bstr = SysAllocString(m_origAction);

        // Need to free bstr
        if (bstr == NULL)
        {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }

        THR(s->put_visibility(bstr));

        SysFreeString(bstr);

        delete [] m_origAction;
        m_origAction = NULL;
    }

    ok = true;
  done:
    return ok;
}

bool
CTIMEElementBase::ToggleTimeAction(bool on)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::ToggleTimeAction(%d) id=%ls",
              this,
              on,
              m_id?m_id:L"unknown"));

    bool ok = false;
    BSTR bstr = NULL;

    if (m_timeAction == NONE_TOKEN)
    {
        ok = true;
        goto done;
    }
    else if (m_timeAction == ONOFF_TOKEN)
    {
        CComVariant v(TokenToString(on?TRUE_TOKEN:FALSE_TOKEN));
        BSTR bstr;

        bstr = SysAllocString(TokenToString(ONOFF_PROPERTY_TOKEN));

        // Need to free bstr
        if (bstr == NULL)
        {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }

        // We do not care if this succeeds
        THR(GetElement()->setAttribute(bstr,v,0));

        SysFreeString(bstr);
    }
    else if (m_timeAction == STYLE_TOKEN)
    {
        DAComPtr<IHTMLStyle> s;

        if ((!GetElement()) || FAILED(THR(GetElement()->get_style(&s))))
        {
            goto done;
        }

        BSTR bstr;

        bstr = SysAllocString(on?m_origAction:TokenToString(NONE_TOKEN));

        // Need to free bstr
        if (bstr == NULL)
        {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }

        THR(s->put_cssText(bstr));

        SysFreeString(bstr);
    }
    else if (m_timeAction == DISPLAY_TOKEN)
    {
        DAComPtr<IHTMLStyle> s;
        DAComPtr<IHTMLElement2> pElement2;

        if ((!GetElement()) || FAILED(THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2)))))
        {
            goto done;
        }

        if (!pElement2 || FAILED(THR(pElement2->get_runtimeStyle(&s))))
        {
            goto done;
        }

        BSTR bstr;

        bstr = SysAllocString(on?m_origAction:TokenToString(NONE_TOKEN));

        // Need to free bstr
        if (bstr == NULL)
        {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }

        THR(s->put_display(bstr));

        SysFreeString(bstr);
    }
    else
    {
        HRESULT hr = S_OK;

        DAComPtr<IHTMLStyle> s;
        DAComPtr<IHTMLElement2> pElement2;

        if (!GetElement())
        {
            goto done;
        }

        hr = THR(GetElement()->QueryInterface(IID_IHTMLElement2, (void **)&pElement2));
        if (FAILED(hr))
        {
            goto done;
        }


        if (!pElement2 || FAILED(THR(pElement2->get_runtimeStyle(&s))))
        {
            goto done;
        }

        BSTR bstr;

        bstr = SysAllocString(on?m_origAction:TokenToString(HIDDEN_TOKEN));

        // Need to free bstr
        if (bstr == NULL)
        {
            CRSetLastError(E_OUTOFMEMORY, NULL);
            goto done;
        }

        THR(s->put_visibility(bstr));

        SysFreeString(bstr);
    }

    ok = true;
  done:
    return ok;
}


CRBvr *
CTIMEElementBase::GetBaseBvr()
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::GetBaseBvr()",
              this));

    return (CRBvr *) CRLocalTime();
}

bool
CTIMEElementBase::FireEvent(TIME_EVENT TimeEvent,
                            double dblLocalTime,
                            DWORD flags)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::FireEvent(%d)",
              this,
              TimeEvent));

    bool ok = false;
    HRESULT hr;

    switch(TimeEvent)
    {
      case TE_ONBEGIN:
        OnBegin(dblLocalTime, flags);
        break;
      case TE_ONEND:
        OnEnd(dblLocalTime);
        break;
      case TE_ONPAUSE:
        OnPause(dblLocalTime);
        break;
      case TE_ONRESUME:
        OnResume(dblLocalTime);
        break;
      case TE_ONRESET:
        OnReset(dblLocalTime, flags);
        break;
      case TE_ONREPEAT:
        OnRepeat(dblLocalTime);
        break;
    }

    // If we are not seeking then fire the event out

    if ((flags & MM_EVENT_SEEK) == 0)
    {
        if (!IsUnloading())
        {
            LPWSTR wzParamNames[] = {WZ_EVENT_CAUSE_IS_RESTART,};
            VARIANT varParamValue;

            VariantInit(&varParamValue);
            V_VT(&varParamValue) = VT_BOOL;

            // Do we need to indicate a reset here?
            if (0 == (flags & MM_EVENT_PROPERTY_CHANGE))
            {
                V_BOOL(&varParamValue) = VARIANT_FALSE;
            }
            else
            {
                V_BOOL(&varParamValue) = VARIANT_TRUE;
            }

            hr = THR(m_eventMgr.FireEvent(TimeEvent,
                                          1,
                                          wzParamNames,
                                          &varParamValue));

            VariantClear(&varParamValue);

            if (FAILED(hr))
            {
                CRSetLastError(hr, NULL);
                goto done;
            }
        }
    }

    ok = true;
  done:
    return ok;
}

void
CTIMEElementBase::UpdateProgressBvr()
{
    CRLockGrabber __gclg;

    HRESULT hr;

    // Get the resultant behavior

    DAComPtr<IUnknown> unk;

    hr = THR(m_mmbvr->GetMMBvr()->GetResultantBehavior(IID_IUnknown,
        (void **) &unk));

    if (FAILED(hr))
    {
        goto done;
    }

    Assert(unk);

    CRNumberPtr resBvr;

    resBvr = (CRNumberPtr) COMToCRBvr(unk);

    if (!resBvr)
    {
        TraceTag((tagError,
            "CTIMEDAElement::OnBegin - Error getting da number"));
        hr = CRGetLastError();
        goto done;
    }

    if (!CRSwitchTo((CRBvrPtr) m_datimebvr.p,
        (CRBvrPtr) resBvr,
        true,
        CRContinueTimeline,
        0.0))
    {
        goto done;
    }

    CRNumberPtr n;

    if ((n = CRCreateNumber(m_realDuration)) == NULL)
    {
        TraceTag((tagError,
            "CTIMEDAElement::OnBegin - Error creating duration behavior"));
        goto done;
    }

    if ((n = CRDiv(resBvr, n)) == NULL)
    {
        TraceTag((tagError,
            "CTIMEDAElement::OnBegin - Error creating div"));
        goto done;
    }

    if (!CRSwitchTo((CRBvrPtr) m_progress.p,
        (CRBvrPtr) n,
        true,
        CRContinueTimeline,
        0.0))
    {
        goto done;
    }

    // Make sure we have a player
    if (!GetPlayer())
    {
        goto done;
    }

    // Force a tick to render updates.
    if (!(GetPlayer()->Tick(GetPlayer()->GetCurrentTime())))
    {
        goto done;
    }

done:
    return;
}

void
CTIMEElementBase::OnBegin(double dblLocalTime, DWORD flags)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::OnBegin()",
              this));

    Assert(NULL != m_mmbvr);
    Assert(NULL != m_mmbvr->GetMMBvr());

    double dblSegmentTime = 0;
    HRESULT hr = S_OK;
    hr = THR(m_mmbvr->GetMMBvr()->get_SegmentTime(&dblSegmentTime));
    if (FAILED(hr))
    {
        return;
    }

    // Check if this event was fired by our hack to make endhold work correctly
    // when seeking forward (over our lifespan)
    if ((flags & MM_EVENT_SEEK) && HUGE_VAL == dblSegmentTime)
    {
        // if endhold isn't set, we shouldn't toggle TimeAction or the OnOff bvr, so bail
        if (!GetEndHold())
        {
            return;
        }
        // else we should (below)
    }

    ToggleTimeAction(true);


    CRLockGrabber __gclg;

    CRSwitchTo((CRBvrPtr) m_onoff.p,
        (CRBvrPtr) CRTrue(),
        false,
        0,
        0.0);

    UpdateProgressBvr();

    return;
}

#define MM_INFINITE HUGE_VAL


void
CTIMEElementBase::OnEnd(double dblLocalTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::OnEnd()",
              this));

    HRESULT hr = S_OK;
    double dblTime = 0.0;

    Assert(m_mmbvr != NULL);
    Assert(m_mmbvr->GetMMBvr() != NULL);

    hr = THR(m_mmbvr->GetMMBvr()->get_LocalTimeEx(&dblTime));
    if (FAILED(hr))
    {
        // what to do?  just try to be reasonable
        dblTime = 0.0;
    }
    // we compare with -MM_INFINITE to avoid doing an end hold
    // when seeking backwards beyond the beginning of the element.
    if (!GetEndHold() || dblTime == -MM_INFINITE)
    {
        ToggleTimeAction(false);

        {
            CRLockGrabber __gclg;
            CRSwitchTo((CRBvrPtr) m_onoff.p,
                       (CRBvrPtr) CRFalse(),
                       false,
                       0,
                       0.0);
        }
    }
}


void
CTIMEElementBase::OnPause(double dblLocalTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::OnPause()",
              this));
    m_fPaused = true;
}

void
CTIMEElementBase::OnResume(double dblLocalTime)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::OnResume()",
              this));
    m_fPaused = false;
}

void
CTIMEElementBase::OnReset(double dblLocalTime, DWORD flags)
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::OnReset()",
              this));

    HRESULT hr = S_OK;
    double dblTime = 0.0;

    Assert(m_mmbvr != NULL);
    Assert(m_mmbvr->GetMMBvr() != NULL);

    hr = THR(m_mmbvr->GetMMBvr()->get_LocalTimeEx(&dblTime));
    if (FAILED(hr))
    {
        // what to do?  just try to be reasonable
        dblTime = 0.0;
    }

    if (!GetEndHold() || dblTime < m_realDuration)
    {
        ToggleTimeAction(false);

        CRLockGrabber __gclg;

        CRSwitchTo((CRBvrPtr) m_onoff.p, (CRBvrPtr) CRFalse(), false, 0, 0.0);
        if ((flags & MM_EVENT_SEEK) == 0)
        {
            CRSwitchToNumber(m_progress.p, 0.0);
            CRSwitchToNumber(m_datimebvr.p, 0.0);
        }
    }
}

void
CTIMEElementBase::OnSync(double dbllastTime, double & dblnewTime)
{
}

MM_STATE
CTIMEElementBase::GetPlayState()
{
    TraceTag((tagTimeElmBase,
              "CTIMEElementBase(%lx)::GetPlayState()",
              this));

    MM_STATE retState = MM_STOPPED_STATE;

    Assert(NULL != m_mmbvr);
    if (NULL != m_mmbvr)
    {
        retState = m_mmbvr->GetPlayState();
    }

    return retState;
}

//
// Sneaky way to get a CTIMEElementBase out of an ITIMEElement:
//

class __declspec(uuid("AED49AA3-5C7A-11d2-AF2D-00A0C9A03B8C"))
TIMEElementBaseGUID {};

HRESULT WINAPI
CTIMEElementBase::BaseInternalQueryInterface(CTIMEElementBase* pThis,
                                             void * pv,
                                             const _ATL_INTMAP_ENTRY* pEntries,
                                             REFIID iid,
                                             void** ppvObject)
{
    if (InlineIsEqualGUID(iid, __uuidof(TIMEElementBaseGUID)))
    {
        *ppvObject = pThis;
        return S_OK;
    }

    return CComObjectRootEx<CComSingleThreadModel>::InternalQueryInterface(pv,
                                                                           pEntries,
                                                                           iid,
                                                                           ppvObject);
}

CTIMEElementBase *
GetTIMEElementBase(IUnknown * pInputUnknown)
{
    CTIMEElementBase * pTEB = NULL;

    if (pInputUnknown)
    {
        pInputUnknown->QueryInterface(__uuidof(TIMEElementBaseGUID),(void **)&pTEB);
    }

    if (pTEB == NULL)
    {
        CRSetLastError(E_INVALIDARG, NULL);
    }

    return pTEB;
}


//************************************************************
// Author:      twillie
// Created:     10/07/98
// Abstract:    get Tag string from HTML element
//************************************************************

HRESULT
CTIMEElementBase::getTagString(BSTR *pbstrID)
{
    return GetElement()->get_id(pbstrID);
} // getTagString

//************************************************************
// Author:      twillie
// Created:     10/07/98
// Abstract:    get ID string from HTML element
//************************************************************

HRESULT
CTIMEElementBase::getIDString(BSTR *pbstrTag)
{
    return GetElement()->get_id(pbstrTag);
}  // getIDString

//************************************************************
// Author:      twillie
// Created:     10/07/98
// Abstract:    helper function to wade thru cache.
//************************************************************

HRESULT
CTIMEElementBase::base_get_collection(COLLECTION_INDEX index, ITIMEElementCollection ** ppDisp)
{
    HRESULT hr;

    // validate out param
    if (ppDisp == NULL)
        return TIMESetLastError(E_POINTER);

    *ppDisp = NULL;

    hr = EnsureCollectionCache();
    if (FAILED(hr))
    {
        TraceTag((tagError, "CTIMEElementBase::GetCollection - EnsureCollectionCache() failed"));
        return hr;
    }

    // call in
    return m_pCollectionCache->GetCollectionDisp(index, (IDispatch **)ppDisp);
} // GetCollection

//************************************************************
// Author:      twillie
// Created:     10/07/98
// Abstract:    Make sure collection cache is up
//************************************************************

HRESULT
CTIMEElementBase::EnsureCollectionCache()
{
    // check to see if collection cache has been created
    if (m_pCollectionCache == NULL)
    {
        // bring up collection cache
        // NOTE: we need to handle CRSetLastError here as
        // cache object doesn't have that concept.
        m_pCollectionCache = NEW CCollectionCache(this, GetAtomTable());
        if (m_pCollectionCache == NULL)
        {
            TraceTag((tagError, "CTIMEElementBase::EnsureCollectionCache - Unable to create Collection Cache"));
            return TIMESetLastError(E_OUTOFMEMORY);
        }

        HRESULT hr = m_pCollectionCache->Init(NUM_COLLECTIONS);
        if (FAILED(hr))
        {
            TraceTag((tagError, "CTIMEElementBase::EnsureCollectionCache - collection cache init failed"));
            delete m_pCollectionCache;
            return TIMESetLastError(hr);
        }

        // set collection types
        m_pCollectionCache->SetCollectionType(ciAllElements, ctAll, true);
        m_pCollectionCache->SetCollectionType(ciChildrenElements, ctChildren, true);
        m_pCollectionCache->SetCollectionType(ciAllInterfaces, ctAll);
        m_pCollectionCache->SetCollectionType(ciChildrenInterfaces, ctChildren);
    }

    return S_OK;
} // EnsureCollectionCache

//************************************************************
// Author:      twillie
// Created:     10/07/98
// Abstract:    invalidate all collection cache's that might
//              reference this object.
//************************************************************

HRESULT
CTIMEElementBase::InvalidateCollectionCache()
{
    CTIMEElementBase *pelem = this;

    // walk up tree, invalidating CollectionCache's
    // we skip if the collection is not initialized
    // we walk until we run out of parent's.  In this
    // manner, we keep the collectioncache fresh, even
    // if the object branch is orphaned.
    while (pelem != NULL)
    {
        // not everybody will have the collection cache
        // initialized
        CCollectionCache *pCollCache = pelem->GetCollectionCache();
        if (pCollCache != NULL)
            pCollCache->BumpVersion();

        // move to parent
        pelem = pelem->GetParent();
    }

    return S_OK;
} // InvalidateCollectionCache

//************************************************************
// Author:      twillie
// Created:     10/07/98
// Abstract:    init Atom Table
//              Note:  this is only done once and then addref'd.
//************************************************************

HRESULT
CTIMEElementBase::InitAtomTable()
{
    if (s_cAtomTableRef == 0)
    {
        Assert(s_pAtomTable == NULL);

        s_pAtomTable = NEW CAtomTable();
        if (s_pAtomTable == NULL)
        {
            TraceTag((tagError, "CElement::InitAtomTable - alloc failed for CAtomTable"));
            return TIMESetLastError(E_OUTOFMEMORY);
        }
    }

    s_cAtomTableRef++;
    return S_OK;
} // InitAtomTable

//************************************************************
// Author:      twillie
// Created:     10/07/98
// Abstract:    release Atom Table
//              Note: this decrement's until zero and then
//              releases the Atom table.
//************************************************************

void
CTIMEElementBase::ReleaseAtomTable()
{
    Assert(s_pAtomTable != NULL);
    Assert(s_cAtomTableRef > 0);
    if (s_cAtomTableRef > 0)
    {
        s_cAtomTableRef--;
        if (s_cAtomTableRef == 0)
        {
            if (s_pAtomTable != NULL)
            {
                delete s_pAtomTable;
                s_pAtomTable = NULL;
            }
        }
    }
    return;
} // ReleaseAtomTable


bool
CTIMEElementBase::IsGroup(IHTMLElement *pElement)
{
    HRESULT hr;
    bool    rc = false;
    DAComPtr<ITIMEElement> pTIMEElem;
    DAComPtr<ITIMEBodyElement> pTIMEBody;
    BSTR  bstrTimeline = NULL;
    BSTR  bstrTagName = NULL;

    hr = FindTIMEInterface(pElement, &pTIMEElem);
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(pTIMEElem.p != NULL);

    hr = pTIMEElem->get_timeline(&bstrTimeline);
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(bstrTimeline != NULL);

    // Check to see what the contents of the BSTR are.
    // If it is a seq or par, we want to return true.
    if ( (bstrTimeline != NULL) &&
         ((StrCmpIW(bstrTimeline, WZ_PAR) == 0) ||
          (StrCmpIW(bstrTimeline, WZ_SEQUENCE) == 0)) )
    {
         rc = true;
         goto done;
    }

    // check to see if it is the body element.
    // if so, then the element is *always" a group.
    hr = pTIMEElem->QueryInterface(IID_ITIMEBodyElement, (void**)&pTIMEBody);
    if (SUCCEEDED(hr))
    {
         rc = true;
         goto done;
    }

    // see if the tag name is <t:par> or <t:seq>
    hr = THR(pElement->get_tagName(&bstrTagName));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(bstrTagName != NULL);

    if ( (StrCmpIW(bstrTagName, WZ_PAR) == 0) ||
         (StrCmpIW(bstrTagName, WZ_SEQUENCE) == 0) )
    {
         rc = true;
         goto done;
    }

done:
    if (bstrTagName != NULL)
        SysFreeString(bstrTagName);
    if (bstrTimeline != NULL)
        SysFreeString(bstrTimeline);
    return rc;
}

bool
CTIMEElementBase::IsDocumentInEditMode()
{
    HRESULT hr;
    bool fRC = false;
    BSTR bstrMode = NULL;
    IDispatch *pDisp = NULL;
    IHTMLDocument2 *pDoc = NULL;
    IHTMLElement *pElem = GetElement();

    // if there is no pElem, we are not attached to an HTML element, and can't give any information.
    if (NULL == pElem)
        return false;

    hr = pElem->get_document(&pDisp);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to get document pointer from element!!!"));
        goto done;
    }

    Assert(pDisp != NULL);

    hr = pDisp->QueryInterface(IID_TO_PPV(IHTMLDocument2, &pDoc));
    ReleaseInterface(pDisp);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to QI for document pointer!!!"));
        goto done;
    }

    Assert(pDoc != NULL);

    hr = pDoc->get_designMode(&bstrMode);
    ReleaseInterface(pDoc);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CContainerSite::Init - unable to QI for document pointer!!!"));
        goto done;
    }

    if (StrCmpIW(bstrMode, L"On") == 0)
    {
        fRC = true;
    }

    SysFreeString(bstrMode);

done:
    return fRC;
}

//************************************************************
// Author:          twillie
// Created:         11/24/98
// Abstract:        return left,top,width,height of element
//************************************************************
HRESULT
CTIMEElementBase::GetSize(RECT *prcPos)
{
    HRESULT hr;
    long lWidth = 0;
    long lHeight = 0;
    IHTMLElement *pElem = GetElement();
    DAComPtr<IHTMLElement2> pElem2;

    if (prcPos == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (pElem == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = THR(pElem->QueryInterface(IID_IHTMLElement2, (void **)&pElem2));
    if (FAILED(hr))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    hr = THR(pElem2->get_clientWidth(&lWidth));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pElem2->get_clientHeight(&lHeight));
    if (FAILED(hr))
    {
        goto done;
    }


    // fill in rect
    prcPos->left = prcPos->top = 0;
    prcPos->right = lWidth;
    prcPos->bottom = lHeight;

    TraceTag((tagTimeElmBase, "CTIMEElementBase::GetSize(%d, %d, %d, %d)", prcPos->left, prcPos->top, prcPos->right, prcPos->bottom));
    hr = S_OK;

done:
    return hr;
}

HRESULT
CTIMEElementBase::ClearSize()
{
    DAComPtr<IHTMLStyle> pStyle;
    DAComPtr<IHTMLElement2> pElement2;

    HRESULT hr = E_FAIL;

    if (!GetElement())
    {
        goto done;
    }

    hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pElement2->get_runtimeStyle(&pStyle));
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(pStyle);

    hr = pStyle->put_pixelWidth(0);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pStyle->put_pixelHeight(0);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

HRESULT
CTIMEElementBase::SetSize(const RECT *prcPos)
{
    DAComPtr<IHTMLStyle> pStyle;
    DAComPtr<IHTMLElement2> pElem2;
    IHTMLElement *pElem = GetElement();

    HRESULT hr;
    long lLeft = 0;
    long lTop = 0;
    long lCurWidth = 0;
    long lCurHeight = 0;
    long lClientWidth = 0;
    long lClientHeight = 0;
    int i = 0;

    if (prcPos == NULL)
    {
        hr = E_POINTER;
        goto done;
    }

    if (pElem == NULL)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    // negative size is unexpected
    Assert((prcPos->right - prcPos->left) >= 0);
    Assert((prcPos->bottom - prcPos->top) >= 0);

    // if width or height is zero or less, bail
    if ( ((prcPos->right - prcPos->left) <= 0) ||
         ((prcPos->bottom - prcPos->top) <= 0) )
    {
        hr = ClearSize();
        goto done;
    }

    hr = THR(GetElement()->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElem2)));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pElem2->get_runtimeStyle(&pStyle));
    if (FAILED(hr))
    {
        goto done;
    }

    // get offset into document.
    hr = THR(pElem->get_offsetLeft(&lLeft));
    if (FAILED(hr))
        goto done;

    hr = THR(pElem->get_offsetTop(&lTop));
    if (FAILED(hr))
        goto done;

    Assert(pStyle);


    lClientWidth = prcPos->right - prcPos->left;
    lClientHeight = prcPos->bottom - prcPos->top;

    // Request increasingly larger total size (pixel width) until we get the correct client size.
    // This iterative solution is to avoid having to parse the border size etc. (strings sith dimensions)
    // that Trident returns.
    i = 0;
    while (((lCurWidth != lClientWidth) ||
           (lCurHeight != lClientHeight)) &&
           i < 5)   // the i < 5 condition limits the loop to 5 times through
                    // this causes the case of bordersize > 5 * the size of the element
                    // to fail.  In this case the default will be to ignore the border and
                    // simply set the size.
    {
        // if we got more than what we requested in the last iteration, might have infinite loop
        Assert((lCurWidth <= lClientWidth) && (lCurHeight <= lClientHeight));

        i++;
        if (lCurWidth == 0)
        {
            lCurWidth = lClientWidth * i; //increase in mutiples in case the first size is not larger than the border width
        }
        else if (lCurWidth != lClientWidth)  // != 0 and != Requested width
        {
            lCurWidth =  lClientWidth * (i - 1) + (lClientWidth - lCurWidth);
        }
        if (lCurHeight == 0)
        {
            lCurHeight = lClientHeight * i; //increase in mutiples incase the first size is not larger than the border width
        }
        else if (lCurHeight != lClientHeight)  // != 0 and != Requested width
        {
            lCurHeight =  lClientHeight * (i - 1) + (lClientHeight - lCurHeight);
        }

        // Set the total size (client size + borders etc.)
        hr = THR(pStyle->put_pixelWidth(lCurWidth));
        if (FAILED(hr))
            goto done;

        hr = THR(pStyle->put_pixelHeight(lCurHeight));
        if (FAILED(hr))
            goto done;

        //get the current client size
        hr = THR(pElem2->get_clientWidth(&lCurWidth));
        if (FAILED(hr))
        {
            goto done;
        }

        hr = THR(pElem2->get_clientHeight(&lCurHeight));
        if (FAILED(hr))
        {
            goto done;
        }
    } // while

    if (((lCurWidth != lClientWidth) ||
           (lCurHeight != lClientHeight)) &&
           (i == 5))  // if the max count has been reached, then simply set the element
    {                 // size to the requested size without trying to compensate for a border.
        hr = THR(pStyle->put_pixelWidth(lClientWidth));
        if (FAILED(hr))
            goto done;

        hr = THR(pStyle->put_pixelHeight(lClientHeight));
        if (FAILED(hr))
            goto done;
    }

    hr = S_OK;

done:
    TraceTag((tagTimeElmBase, "CTIMEElementBase::SetSize(%d, %d, %d, %d) [pos(%d, %d)]", prcPos->left, prcPos->top, prcPos->right, prcPos->bottom, lLeft, lTop));
    return hr;
} // SetSize

//*****************************************************************************

HRESULT
CTIMEElementBase::BuildPropertyNameList (CPtrAry<BSTR> *paryPropNames)
{
    HRESULT hr = S_OK;

    Assert(NULL != paryPropNames);

    for (int i = 0; (i < teb_maxTIMEElementBaseProp) && (SUCCEEDED(hr)); i++)
    {
        Assert(NULL != ms_rgwszTEBasePropNames[i]);
        BSTR bstrNewName = CreateTIMEAttrName(ms_rgwszTEBasePropNames[i]);
        Assert(NULL != bstrNewName);
        if (NULL != bstrNewName)
        {
            hr = paryPropNames->Append(bstrNewName);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

//*****************************************************************************

HRESULT
CTIMEElementBase::SetPropertyByIndex(unsigned uIndex, VARIANT *pvarProp)
{
    Assert(NULL != pvarProp);

    HRESULT hr = E_FAIL;
    // copy variant for conversion type
    VARIANT varTemp;
    VariantInit(&varTemp);
    hr = VariantCopyInd(&varTemp, pvarProp);
    if (FAILED(hr))
        return hr;

    Assert(teb_maxTIMEElementBaseProp > uIndex);
    if (teb_maxTIMEElementBaseProp > uIndex)
    {
        switch (uIndex)
        {
          case teb_begin :
            hr = base_put_begin(*pvarProp);
            break;
          case teb_beginWith :
            hr = base_put_beginWith(*pvarProp);
            break;
          case teb_beginAfter :
            hr = base_put_beginAfter(*pvarProp);
            break;
          case teb_beginEvent :
            hr = base_put_beginEvent(*pvarProp);
            break;
          case teb_dur :
            hr = base_put_dur(*pvarProp);
            break;
          case teb_end :
            hr = base_put_end(*pvarProp);
            break;
          case teb_endWith :
            hr = base_put_endWith(*pvarProp);
            break;
          case teb_endEvent :
            hr = base_put_endEvent(*pvarProp);
            break;
          case teb_endSync :
            hr = base_put_endSync(*pvarProp);
            break;
          case teb_endHold :
            hr = VariantChangeTypeEx(&varTemp, &varTemp, LCID_SCRIPTING, NULL, VT_BOOL);
            if (SUCCEEDED(hr))
                hr = base_put_endHold(V_BOOL(&varTemp));
            break;
          case teb_eventRestart :
            hr = VariantChangeTypeEx(&varTemp, &varTemp, LCID_SCRIPTING, NULL, VT_BOOL);
            if (SUCCEEDED(hr))
                hr = base_put_eventRestart(V_BOOL(&varTemp));
            break;
          case teb_repeat :
            hr = base_put_repeat(*pvarProp);
            break;
          case teb_repeatDur :
            hr = base_put_repeatDur(*pvarProp);
            break;
          case teb_autoReverse :
            hr = VariantChangeTypeEx(&varTemp, &varTemp, LCID_SCRIPTING, NULL, VT_BOOL);
            if (SUCCEEDED(hr))
                hr = base_put_autoReverse(V_BOOL(&varTemp));
            break;
          case teb_accelerate :
            hr = VariantChangeTypeEx(&varTemp, &varTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_INT);
            if (SUCCEEDED(hr))
                hr = base_put_accelerate(V_INT(&varTemp));
            break;
          case teb_decelerate :
            hr = VariantChangeTypeEx(&varTemp, &varTemp, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_INT);
            if (SUCCEEDED(hr))
                hr = base_put_decelerate(V_INT(&varTemp));
            break;
          case teb_timeAction :
            hr = VariantChangeTypeEx(&varTemp, &varTemp, LCID_SCRIPTING, NULL, VT_BSTR);
            if (SUCCEEDED(hr))
                hr = base_put_timeAction(V_BSTR(&varTemp));
            break;
          case teb_timeline :
            hr = VariantChangeTypeEx(&varTemp, &varTemp, LCID_SCRIPTING, NULL, VT_BSTR);
            if (SUCCEEDED(hr))
                hr = base_put_timeline(V_BSTR(&varTemp));
            break;
          case teb_syncBehavior :
            hr = VariantChangeTypeEx(&varTemp, &varTemp, LCID_SCRIPTING, NULL, VT_BSTR);
            if (SUCCEEDED(hr))
                hr = base_put_syncBehavior(V_BSTR(&varTemp));
            break;
          case teb_syncTolerance :
            hr = base_put_syncTolerance(*pvarProp);
            break;
        };
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    // Cleanup
    VariantClear(&varTemp);

    return hr;
}

//*****************************************************************************

HRESULT
CTIMEElementBase::InitTimeline (void)
{
    HRESULT hr = S_OK;

    if (!m_fTimelineInitialized)
    {
        if (IsGroup())
        {
            m_timeline = NEW MMTimeline(*this, true);

            if (m_timeline == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            // Immediately assign to m_mmbvr so we ensure that we clean it
            // up on destruction since the m_timeline is ignored
            m_mmbvr = m_timeline;

            if (!m_timeline->Init())
            {
                hr = CRGetLastError();
                goto done;
            }

        }
        else
        {
            MMBvr * b;
            b = NEW MMBvr(*this, true, NeedSyncCB());

            if (b == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            // Immediately assign to m_mmbvr so we ensure that we clean it
            // up on destruction
            m_mmbvr = b;

            if (!b->Init((CRBvrPtr) CRLocalTime()))
            {
                hr = CRGetLastError();
                goto done;
            }
        }
        m_fTimelineInitialized = true;
    }

    // if we are not the body, have a cached body element pointer, and it is started (i.e. StartRootTimte)
    // then we should start ourselves and do not wait for notification.
    if (!IsBody() && (GetBody() != NULL) && GetBody()->IsRootStarted())
    {
        // being extra careful.  If we have a body cached, we know we are parented and that we can reach
        // back.
        if (GetParent() != NULL)
        {
            HRESULT hr = THR(StartRootTime(GetParent()->GetMMTimeline()));
            if (FAILED(hr))
            {
                TraceTag((tagError, "CTIMEBodyElement::InitTimeline - StartRootTime() failed!"));
                goto done;
            }
        }
    }

done :
    return hr;
}


//IPersistPropertyBag2 methods
STDMETHODIMP
CTIMEElementBase::Load(IPropertyBag2 *pPropBag,IErrorLog *pErrorLog)
{
    if (NULL == pPropBag)
    {
        return E_INVALIDARG;
    }

    CPtrAry<BSTR> *paryPropNames = NULL;
    HRESULT hr = GetPropertyBagInfo(&paryPropNames);

    if (hr == E_NOTIMPL)
    {
        return S_OK;
    }
    else if (FAILED(hr))
    {
        return hr;
    }

    // Unfortunately Load takes an array of Variants and not
    // Variant pointers.  We therefor need to loop through
    // each one and get the correct property this way.
    unsigned uNumProps = static_cast<unsigned>(paryPropNames->Size());
    for (unsigned uProperties = 0; uProperties < uNumProps; uProperties++)
    {
        HRESULT hrres = S_OK;
        PROPBAG2 propbag;
        VARIANT var;
        VariantInit(&var);
        propbag.vt = VT_BSTR;
        propbag.pstrName = (*paryPropNames)[uProperties];
        hr = pPropBag->Read(1,
                            &propbag,
                            pErrorLog,
                            &var,
                            &hrres);
        if (SUCCEEDED(hr))
        {
            // Skip over failures ... why would we want to
            // allow that to abort all persistance?
            hr = SetPropertyByIndex(uProperties, &var);
            VariantClear(&var);
        }
    }


    // Once we've read the properties in,
    // set up the timeline.  This is immutable
    // in script.
    hr = InitTimeline();

    // We return error codes not specific to properties
    // by early-outing.
    return S_OK;
} // Load

//*****************************************************************************

HRESULT
CTIMEElementBase::GetPropertyByIndex(unsigned uIndex, VARIANT *pvarProp)
{
    HRESULT hr = E_FAIL;

    Assert(teb_maxTIMEElementBaseProp > uIndex);
    Assert(VT_EMPTY == V_VT(pvarProp));
    if (teb_maxTIMEElementBaseProp > uIndex)
    {
        switch (uIndex)
        {
            case teb_begin :
                hr = base_get_begin(pvarProp);
                break;
            case teb_beginWith :
                hr = base_get_beginWith(pvarProp);
                break;
            case teb_beginAfter :
                hr = base_get_beginAfter(pvarProp);
                break;
            case teb_beginEvent :
                hr = base_get_beginEvent(pvarProp);
                break;
            case teb_dur :
                hr = base_get_dur(pvarProp);
                break;
            case teb_end :
                hr = base_get_end(pvarProp);
                break;
            case teb_endWith :
                hr = base_get_endWith(pvarProp);
                break;
            case teb_endEvent :
                hr = base_get_endEvent(pvarProp);
                break;
            case teb_endSync :
                hr = base_get_endSync(pvarProp);
                break;
            case teb_endHold :
                hr = base_get_endHold(&(V_BOOL(pvarProp)));
                if (SUCCEEDED(hr))
                {
                    V_VT(pvarProp) = VT_BOOL;
                }
                break;
            case teb_eventRestart :
                hr = base_get_eventRestart(&(V_BOOL(pvarProp)));
                if (SUCCEEDED(hr))
                {
                    V_VT(pvarProp) = VT_BOOL;
                }
                break;
            case teb_repeat :
                hr = base_get_repeat(pvarProp);
                break;
            case teb_repeatDur :
                hr = base_get_repeatDur(pvarProp);
                break;
            case teb_autoReverse :
                hr = base_get_autoReverse(&(V_BOOL(pvarProp)));
                if (SUCCEEDED(hr))
                {
                    V_VT(pvarProp) = VT_BOOL;
                }
                break;
            case teb_accelerate :
                hr = base_get_accelerate(&(V_INT(pvarProp)));
                if (SUCCEEDED(hr))
                {
                    V_VT(pvarProp) = VT_INT;
                }
                break;
            case teb_decelerate :
                hr = base_get_decelerate(&(V_INT(pvarProp)));
                if (SUCCEEDED(hr))
                {
                    V_VT(pvarProp) = VT_INT;
                }
                break;
            case teb_timeAction :
                hr = base_get_timeAction(&(V_BSTR(pvarProp)));
                if (SUCCEEDED(hr) && (NULL != V_BSTR(pvarProp)))
                {
                    V_VT(pvarProp) = VT_BSTR;
                }
                break;
            case teb_timeline :
                hr = base_get_timeline(&(V_BSTR(pvarProp)));
                if (SUCCEEDED(hr))
                {
                    V_VT(pvarProp) = VT_BSTR;
                }
                break;
            case teb_syncBehavior :
                if (INVALID_TOKEN != m_syncBehavior)
                {
                    hr = base_get_syncBehavior(&(V_BSTR(pvarProp)));
                    if (SUCCEEDED(hr) && (NULL != V_BSTR(pvarProp)))
                    {
                        V_VT(pvarProp) = VT_BSTR;
                    }
                }
                else
                {
                    // Unset property, but not an error.
                    // The pvarProp remains empty and
                    // nothing gets persisted.
                    hr = S_OK;
                }
                break;
            case teb_syncTolerance :
                if (valueNotSet != m_syncTolerance)
                {
                    hr = base_get_syncTolerance(pvarProp);
                }
                else
                {
                    // Unset property, but not an error.
                    // The pvarProp remains empty and
                    // nothing gets persisted.
                    hr = S_OK;
                }
                break;
        };
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    // No need to propogate a NULL string back.  A number of our
    // get methods return NULL strings.
    if ((VT_BSTR == V_VT(pvarProp)) && (NULL == V_BSTR(pvarProp)))
    {
        hr = VariantClear(pvarProp);
    }

    return hr;
}

void CTIMEElementBase::SetPropertyFlag(DWORD uIndex)
{
    DWORD bitPosition = 1 << uIndex;
    m_propertyAccesFlags =  m_propertyAccesFlags | bitPosition;
}

void CTIMEElementBase::ClearPropertyFlag(DWORD uIndex)
{
    DWORD bitPosition = 1 << uIndex;
    m_propertyAccesFlags =  m_propertyAccesFlags & (~bitPosition);
}


void CTIMEElementBase::SetPropertyFlagAndNotify(DISPID dispid, DWORD uIndex)
{
    SetPropertyFlag(uIndex);
    IGNORE_HR(NotifyPropertyChanged(dispid));
}

void CTIMEElementBase::ClearPropertyFlagAndNotify(DISPID dispid, DWORD uIndex)
{
    ClearPropertyFlag(uIndex);
    IGNORE_HR(NotifyPropertyChanged(dispid));
}

bool CTIMEElementBase::IsPropertySet(DWORD uIndex)
{
    if( uIndex >= 32) return true;
    if( uIndex >= teb_maxTIMEElementBaseProp) return true;
    DWORD bitPosition = 1 << uIndex;
    if(m_propertyAccesFlags & bitPosition)
        return true;
    return false;
}


//*****************************************************************************

STDMETHODIMP
CTIMEElementBase::Save(IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    if (NULL == pPropBag)
    {
        return E_INVALIDARG;
    }

    if (fClearDirty)
    {
        m_fPropertiesDirty = false;
    }

    CPtrAry<BSTR> *paryPropNames = NULL;
    HRESULT hr = GetPropertyBagInfo(&paryPropNames);

    if (hr == E_NOTIMPL)
    {
        return S_OK;
    }
    else if (FAILED(hr))
    {
        return hr;
    }

    VARIANT var;
    VariantInit(&var);
    unsigned uNumProps = static_cast<unsigned>(paryPropNames->Size());
    for (unsigned uProperties = 0; uProperties < uNumProps; uProperties++)
    {
        PROPBAG2 propbag;

        Assert(NULL != (*paryPropNames)[uProperties]);
        if (NULL != (*paryPropNames)[uProperties])
        {
            propbag.vt = VT_BSTR;
            propbag.pstrName = (*paryPropNames)[uProperties];


            hr = GetPropertyByIndex(uProperties, &var);

            // Skip over failures ... why would we want to
            // allow that to abort all persistance?
            if ((SUCCEEDED(hr)) && (var.vt != VT_EMPTY) && (var.vt != VT_NULL))
            {
                if(IsPropertySet(uProperties))
                    hr = pPropBag->Write(1, &propbag, &var);
                VariantClear(&var);
            }
        }
    }

    // We return error codes not specific to properties
    // by early-outing.
    return S_OK;
} // Save

//*****************************************************************************

STDMETHODIMP
CTIMEElementBase::GetClassID(CLSID* pclsid)
{
    if (NULL != pclsid)
    {
        return E_POINTER;
    }
    *pclsid = m_clsid;
    return S_OK;
} // GetClassID

//*****************************************************************************

STDMETHODIMP
CTIMEElementBase::InitNew(void)
{
    return S_OK;
} // InitNew

//*****************************************************************************
// if elment doesn't exist in child list, make return -1.
int
CTIMEElementBase::GetTimeChildIndex(CTIMEElementBase *pelm)
{
    if (pelm == NULL)
        return -1;

    long lSize = m_pTIMEChildren.Size();
    for (long i=0; i < lSize; i++)
    {
        if (m_pTIMEChildren[i] == pelm)
             return i;
    }

    // didn't find it
    return -1;
} // GetTimeChildIndex

MMPlayer *
CTIMEElementBase::GetPlayer()
{
    if (m_pTIMEBody)
    {
        return &(m_pTIMEBody->GetPlayer());
    }
    else
    {
        return NULL;
    }
}

float
CTIMEElementBase::GetRealSyncTolerance()
{
    if (m_syncTolerance == valueNotSet)
    {
        return GetBody()->GetDefaultSyncTolerance();
    }
    else
    {
        return m_syncTolerance;
    }
}

TOKEN
CTIMEElementBase::GetRealSyncBehavior()
{
    if (GetParent() != NULL && GetParent()->IsSequence())
    {
        return LOCKED_TOKEN;
    }

    if (m_syncBehavior == INVALID_TOKEN)
    {
        return GetBody()->GetDefaultSyncBehavior();
    }
    else
    {
        return m_syncBehavior;
    }
}

HRESULT
CTIMEElementBase::NotifyPropertyChanged(DISPID dispid)
{
    HRESULT hr;

    IConnectionPoint *pICP;
    IEnumConnections *pEnum = NULL;

    m_fPropertiesDirty = true;
    hr = GetConnectionPoint(IID_IPropertyNotifySink,&pICP);
    if (SUCCEEDED(hr) && pICP != NULL)
    {
        hr = pICP->EnumConnections(&pEnum);
        ReleaseInterface(pICP);
        if (FAILED(hr))
        {
            //DPF_ERR("Error finding connection enumerator");
            //return SetErrorInfo(hr);
            TIMESetLastError(hr);
            goto done;
        }
        CONNECTDATA cdata;
        hr = pEnum->Next(1, &cdata, NULL);
        while (hr == S_OK)
        {
            // check cdata for the object we need
            IPropertyNotifySink *pNotify;
            hr = cdata.pUnk->QueryInterface(IID_TO_PPV(IPropertyNotifySink, &pNotify));
            cdata.pUnk->Release();
            if (FAILED(hr))
            {
                //DPF_ERR("Error invalid object found in connection enumeration");
                //return SetErrorInfo(hr);
                TIMESetLastError(hr);
                goto done;
            }
            hr = pNotify->OnChanged(dispid);
            ReleaseInterface(pNotify);
            if (FAILED(hr))
            {
                //DPF_ERR("Error calling Notify sink's on change");
                //return SetErrorInfo(hr);
                TIMESetLastError(hr);
                goto done;
            }
            // and get the next enumeration
            hr = pEnum->Next(1, &cdata, NULL);
        }
    }
done:
    if (NULL != pEnum)
    {
        ReleaseInterface(pEnum);
    }

    return hr;
} // NotifyPropertyChanged
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\tokens.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: tokens.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _TOKENS_H
#define _TOKENS_H

//
// Good place to put general string expansion macros that are not tokens:
//
#define WZ_PARENTTIMEELEMENT            L"ParentTIMEElement"
#define WZ_TIMELINE                     L"timeline"
#define WZ_PAR                          L"par"
#define WZ_SEQUENCE                     L"seq"
#define WZ_TIMESTARTRULE                L"timeStartRule"
#define WZ_ADDTIMEDAELEMENT             L"addTIMEDAElement"

#define WZ_LAST                         L"last"
#define WZ_FIRST                        L"first"
#define WZ_NONE                         L"none"
#define WZ_INDEFINITE                   L"indefinite"

#define WZ_MEDIA                        L"media"
#define WZ_IMG                          L"img"
#define WZ_AUDIO                        L"audio"
#define WZ_VIDEO                        L"video"
#define WZ_DA                           L"da"
#define WZ_BODY                         L"body"

#define WZ_DEFAULT_SCOPE_NAME           L"HTML"

#define WZ_TIME_STYLE_PREFIX            L"#time"
#define WZ_TIMEDA_STYLE_PREFIX          L"#time#"##WZ_DA
#define WZ_TIMEMEDIA_STYLE_PREFIX       L"#time#"##WZ_MEDIA

#define WZ_DEFAULT_TIME_STYLE_PREFIX        L"#default#time"
#define WZ_DEFAULT_TIMEDA_STYLE_PREFIX      L"#default#time#"##WZ_DA
#define WZ_DEFAULT_TIMEMEDIA_STYLE_PREFIX   L"#default#time#"##WZ_MEDIA

#define WZ_REGISTERED_NAME                  L"HTMLTIME"
#define WZ_REGISTERED_NAME_DAELM            L"HTMLTIMEDAELM"

#define WZ_EVENT_CAUSE_IS_RESTART           L"restart"

// This is to save on string storage space and to avoid unnecessary
// string comparisons

typedef void * TOKEN;

TOKEN StringToToken(wchar_t * str);
inline wchar_t * TokenToString(TOKEN token) { return (wchar_t *) token; }

extern TOKEN NONE_TOKEN;
extern TOKEN FILTER_TOKEN;
extern TOKEN REPLACE_TOKEN;
extern TOKEN INVALID_TOKEN;
extern TOKEN ONOFF_TOKEN;
extern TOKEN STYLE_TOKEN;
extern TOKEN DISPLAY_TOKEN;
extern TOKEN VISIBILITY_TOKEN;

extern TOKEN ONOFF_PROPERTY_TOKEN;
extern TOKEN STYLE_PROPERTY_TOKEN;
extern TOKEN DISPLAY_PROPERTY_TOKEN;
extern TOKEN VISIBILITY_PROPERTY_TOKEN;

extern TOKEN TRUE_TOKEN;
extern TOKEN FALSE_TOKEN;
extern TOKEN HIDDEN_TOKEN;

extern TOKEN CANSLIP_TOKEN;
extern TOKEN LOCKED_TOKEN;

extern TOKEN STARTRULE_IMMEDIATE_TOKEN;
extern TOKEN STARTRULE_ONDOCLOAD_TOKEN;
extern TOKEN STARTRULE_ONDOCCOMPLETE_TOKEN;

extern TOKEN READYSTATE_COMPLETE_TOKEN;
#endif /* _TOKENS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\types\idl\makefile.inc ===
$(SDKDIR)\danim.tlb : $(O)\danim.tlb
    copy $? $@

$(SDKDIR)\danim.h : $(O)\danim.h danim.pl makefile.inc
    perl danim.pl <$(O)\danim.h >$@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\tokens.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: token.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#include "headers.h"
#include "tokens.h"

TOKEN NONE_TOKEN          = L"none";
TOKEN FILTER_TOKEN        = L"filter";
TOKEN REPLACE_TOKEN       = L"replace";
TOKEN ONOFF_TOKEN         = L"onoff";
TOKEN STYLE_TOKEN         = L"style";
TOKEN VISIBILITY_TOKEN    = L"visibility";
TOKEN DISPLAY_TOKEN       = L"display";
TOKEN INVALID_TOKEN       = L"";

TOKEN ONOFF_PROPERTY_TOKEN         = L"on";
TOKEN STYLE_PROPERTY_TOKEN         = L"style";
TOKEN DISPLAY_PROPERTY_TOKEN       = L"display";
TOKEN VISIBILITY_PROPERTY_TOKEN    = L"visibility";

TOKEN TRUE_TOKEN   = L"true";
TOKEN FALSE_TOKEN  = L"false";
TOKEN HIDDEN_TOKEN  = L"hidden";

TOKEN READYSTATE_COMPLETE_TOKEN = L"complete";

TOKEN CANSLIP_TOKEN  = L"canSlip";
TOKEN LOCKED_TOKEN   = L"locked";

TOKEN STARTRULE_IMMEDIATE_TOKEN = L"immediate";
TOKEN STARTRULE_ONDOCLOAD_TOKEN = L"onDocLoad";
TOKEN STARTRULE_ONDOCCOMPLETE_TOKEN = L"onDocComplete";

// TODO: Need to make this much faster

TOKEN tokenArray[] =
{
    NONE_TOKEN,
    FILTER_TOKEN,
    REPLACE_TOKEN,
    ONOFF_TOKEN,
    STYLE_TOKEN,
    VISIBILITY_TOKEN,
    DISPLAY_TOKEN,
    ONOFF_PROPERTY_TOKEN,
    STYLE_PROPERTY_TOKEN,
    DISPLAY_PROPERTY_TOKEN,
    VISIBILITY_PROPERTY_TOKEN,
    TRUE_TOKEN,
    FALSE_TOKEN,
    HIDDEN_TOKEN,
    READYSTATE_COMPLETE_TOKEN,
    CANSLIP_TOKEN,
    LOCKED_TOKEN,
    STARTRULE_IMMEDIATE_TOKEN,
    STARTRULE_ONDOCLOAD_TOKEN,
    STARTRULE_ONDOCCOMPLETE_TOKEN,
    NULL
};

TOKEN
StringToToken(wchar_t * str)
{
    for (int i = 0; i < ARRAY_SIZE(tokenArray); i++)
    {
        if (StrCmpIW(str, (wchar_t *) tokenArray[i]) == 0)
            return tokenArray[i];
    }

    return INVALID_TOKEN;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\types\idl\danimid.h ===
// Copyright (C) Microsoft Corporation, 1998
//
// IDs for DANIM Events
//
// Just follow the template when adding either DISPIDs or new interfaces.
//

#ifndef __DANIMDISPID_H__
#define __DANIMDISPID_H__

// Base offset:

#define DISPID_BASE                                             0x00000000

// Interface offsets:
#define DAVIEWERCONTROL_OFFSET                                  0x1000
#define DAVIEW_OFFSET                                           0x2000

// Interface bases:
#define DISPID_DANIMEVENT_BASE                                  (DISPID_BASE + DAVIEWERCONTROL_OFFSET)
#define DISPID_VIEWEVENT_BASE                                   (DISPID_BASE + DAVIEW_OFFSET)

// DAVIEWERCONTROL DISPIDs:
#define DISPID_DANIMEVENT_START                          (DISPID_DANIMEVENT_BASE + 0x01)
#define DISPID_DANIMEVENT_MOUSEUP                        (DISPID_DANIMEVENT_BASE + 0x02)
#define DISPID_DANIMEVENT_MOUSEDOWN                      (DISPID_DANIMEVENT_BASE + 0x03)
#define DISPID_DANIMEVENT_MOUSEMOVE                      (DISPID_DANIMEVENT_BASE + 0x04)
#define DISPID_DANIMEVENT_CLICK                          (DISPID_DANIMEVENT_BASE + 0x05)
#define DISPID_DANIMEVENT_KEYPRESS                       (DISPID_DANIMEVENT_BASE + 0x06)
#define DISPID_DANIMEVENT_KEYUP                          (DISPID_DANIMEVENT_BASE + 0x07)
#define DISPID_DANIMEVENT_KEYDOWN                        (DISPID_DANIMEVENT_BASE + 0x08)
#define DISPID_DANIMEVENT_ERROR                          (DISPID_DANIMEVENT_BASE + 0x09)
#define DISPID_DANIMEVENT_STOP                           (DISPID_DANIMEVENT_BASE + 0x0A)
#define DISPID_DANIMEVENT_PAUSE                          (DISPID_DANIMEVENT_BASE + 0x0B)
#define DISPID_DANIMEVENT_RESUME                         (DISPID_DANIMEVENT_BASE + 0x0C)

//VIEW DISPIDS
#define DISPID_VIEWEVENT_START                                  (DISPID_VIEWEVENT_BASE + 0x01)
#define DISPID_VIEWEVENT_STOP                                   (DISPID_VIEWEVENT_BASE + 0x02)
#define DISPID_VIEWEVENT_ONMOUSEMOVE                            (DISPID_VIEWEVENT_BASE + 0x03)
#define DISPID_VIEWEVENT_ONMOUSEBUTTON                          (DISPID_VIEWEVENT_BASE + 0x04)
#define DISPID_VIEWEVENT_ONKEY                                  (DISPID_VIEWEVENT_BASE + 0x05)
#define DISPID_VIEWEVENT_ONFOCUS                                (DISPID_VIEWEVENT_BASE + 0x06)
#define DISPID_VIEWEVENT_PAUSE                                  (DISPID_VIEWEVENT_BASE + 0x07)
#define DISPID_VIEWEVENT_RESUME                                 (DISPID_VIEWEVENT_BASE + 0x08)
#define DISPID_VIEWEVENT_ERROR                                  (DISPID_VIEWEVENT_BASE + 0x09)

#endif  //__DANIMDISPID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\timeman.h ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: timeman.h
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/


#ifndef _TIMEMAN_H
#define _TIMEMAN_H

#include "resource.h"
#include <string>
#include <map>
#include <list>

class CTIMEElement;

/////////////////////////////////////////////////////////////////////////////
// CTIMETimeManager

typedef std::map<std::wstring,CTIMEElement *> TimeLineMap;

class CTIMETimeManager 
{
  public:
    CTIMETimeManager();
    ~CTIMETimeManager();
    
#if _DEBUG
    const _TCHAR * GetName() { return __T("CTIMETimeManager"); }
#endif

    //
    // ITIMETimeManager
    //

    void Add(CTIMEElement *pTimeElement);
    void Remove(CTIMEElement *pTimeElement);
    void Recalc();

  private:
    void InsertElements();
    float CalculateDuration(CTIMEElement *pTimeEle);

    std::list<CTIMEElement *>m_NotFinishedList;
    TimeLineMap m_TimeLine;
   
};

typedef std::map<IUnknown*,CTIMETimeManager*> TimeManagerMap;

#endif /* _TIMEMAN_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\time\src\util.cpp ===
/*******************************************************************************
 *
 * Copyright (c) 1998 Microsoft Corporation
 *
 * File: util.cpp
 *
 * Abstract:
 *
 *
 *
 *******************************************************************************/

#include "headers.h"
#include "util.h"
#define INITGUID
#include <initguid.h>  // needed for precomp headers...
#define IUSEDDRAW
#include <ddrawex.h>
#include "tokens.h"

//defined for VariantToTime conversion function
#define SECPERMINUTE 60   //seconds per minute
#define SECPERHOUR   3600 //seconds per hour

IDirectDraw * g_directdraw = NULL;
CritSect * g_ddCS = NULL;

IDirectDraw *
GetDirectDraw()
{
    HRESULT hr;
    
    {
        CritSectGrabber _csg(*g_ddCS);
        
        if (g_directdraw == NULL)
        {
            DAComPtr<IDirectDrawFactory> lpDDF;
            
            hr = CoCreateInstance(CLSID_DirectDrawFactory,
                                  NULL, CLSCTX_INPROC_SERVER,
                                  IID_IDirectDrawFactory,
                                  (void **) & lpDDF);

            if (FAILED(hr))
            {
                Assert(FALSE && "Could not create DirectDrawFactory object");
                return NULL;
            }
            
            hr = lpDDF->CreateDirectDraw(NULL, NULL, DDSCL_NORMAL, 0, NULL, &g_directdraw);

            if (FAILED(hr))
            {
                Assert(FALSE && "Could not create DirectDraw object");
                return NULL;
            }

            hr = g_directdraw->SetCooperativeLevel(NULL,
                                                   DDSCL_NORMAL);

            if (FAILED(hr))
            {
                Assert(FALSE && "Could not set DirectDraw properties");
                g_directdraw->Release();
                g_directdraw = NULL;
                return NULL;
            }

        }
    }

    return g_directdraw;
}

HRESULT
CreateOffscreenSurface(IDirectDraw *ddraw,
                       IDirectDrawSurface **surfPtrPtr,
                       DDPIXELFORMAT * pf,
                       bool vidmem,
                       LONG width, LONG height)
{
    HRESULT hr = S_OK;
    DDSURFACEDESC       ddsd;
    ZeroMemory(&ddsd, sizeof(ddsd));

    ddsd.dwSize = sizeof( ddsd );
    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
    ddsd.dwWidth  = width;
    ddsd.dwHeight = height;

    if (pf)
    {
        // KEVIN: if you want the pixelformat of the surface tomatach the
        // screen, comment out this line.
        ddsd.dwFlags |= DDSD_PIXELFORMAT;
        
        ddsd.ddpfPixelFormat = *pf;
    }

    // DX3 bug workaround (bug 11166): StretchBlt doesn't always work
    // for hdc's we get from ddraw surfaces.  Need to specify OWNDC
    // in order for it to work.
    ddsd.ddsCaps.dwCaps =
        (DDSCAPS_3DDEVICE |
         DDSCAPS_OFFSCREENPLAIN |
         (vidmem ? DDSCAPS_VIDEOMEMORY : DDSCAPS_SYSTEMMEMORY | DDSCAPS_OWNDC));

    IDirectDraw * dd = ddraw;

    if (!dd)
    {
        dd = GetDirectDraw();
    
        if (!dd)
        {
            hr = E_FAIL;
            goto done;
        }
    }
    
    hr = dd->CreateSurface( &ddsd, surfPtrPtr, NULL );

    if (FAILED(hr))
    {
        *surfPtrPtr = NULL;
    }

  done:
    return hr;
}

inline Width(LPRECT r) { return r->right - r->left; }
inline Height(LPRECT r) { return r->bottom - r->top; }

HRESULT
CopyDCToDdrawSurface(HDC srcDC,
                     LPRECT prcSrcRect,
                     IDirectDrawSurface *DDSurf,
                     LPRECT prcDestRect)
{
    HRESULT hr;
    
    HDC destDC;
    hr = DDSurf->GetDC(&destDC);
    
    if (SUCCEEDED(hr))
    {
        HRGN hrgn;

        hrgn = CreateRectRgn(0,0,1,1);
        
        if (hrgn == NULL)
        {
            hr = GetLastError();
        }
        else
        {
            if (GetClipRgn(srcDC, hrgn) == ERROR)
            {
                hr = GetLastError();
            } 
            else
            {
                TraceTag((tagError,
                          "CopyDCToDdrawSurface - prcDestRect(%d, %d, %d, %d)",
                          prcDestRect->left,prcDestRect->top,prcDestRect->right,prcDestRect->bottom));

                RECT targetRect;
                RECT rgnRect;

                GetRgnBox(hrgn, &rgnRect);
                
                TraceTag((tagError,
                          "CopyDCToDdrawSurface - rgn box(%d, %d, %d, %d)",
                          rgnRect.left,rgnRect.top,rgnRect.right,rgnRect.bottom));
                
                if (IntersectRect(&targetRect, &rgnRect, prcDestRect))
                {
                    TraceTag((tagError,
                              "CopyDCToDdrawSurface - targetrect(%d, %d, %d, %d)",
                              targetRect.left,targetRect.top,targetRect.right,targetRect.bottom));
                
                    if (false && SelectClipRgn(destDC, hrgn) == ERROR)
                    {
                        hr = GetLastError();
                    }
                    else
                    {
                        BitBlt(destDC,
                               prcDestRect->left,
                               prcDestRect->top,
                               Width(prcDestRect),
                               Height(prcDestRect),
                               
                               srcDC,
                               prcSrcRect->left,
                               prcSrcRect->top,
                               SRCCOPY);
                        
                        //SelectClipRgn(destDC, NULL);
                    }
                }
            }
            
            DeleteObject(hrgn);
        }

        DDSurf->ReleaseDC(destDC);
    }

    return hr;
}

//////////////////////

CritSect::CritSect()
{
    InitializeCriticalSection(&_cs) ;
}

CritSect::~CritSect()
{
    DeleteCriticalSection(&_cs) ;
}

void
CritSect::Grab()
{
    EnterCriticalSection(&_cs) ;
}

void
CritSect::Release()
{
    LeaveCriticalSection(&_cs) ;
}

////// CritSect Grabber //////

CritSectGrabber::CritSectGrabber(CritSect& cs, bool grabIt)
: _cs(cs), grabbed(grabIt)
{
    if (grabIt) _cs.Grab();
}

CritSectGrabber::~CritSectGrabber()
{
    if (grabbed) _cs.Release();
}

//// Misc ///

bool
CRBvrToVARIANT(CRBvrPtr b, VARIANT * v)
{
    bool ok = false;
    
    if (v == NULL)
    {
        CRSetLastError(E_POINTER, NULL);
        goto done;
    }
    
    IUnknown * iunk;
    
    if (!CRBvrToCOM(b,
                    IID_IUnknown,
                    (void **) &iunk))
    {
        TraceTag((tagError,
                  "CRBvrToVARIANT: Failed to get create com pointer - %hr, %ls",
                  CRGetLastError(),
                  CRGetLastErrorString()));
            
        goto done;
    }
    
    V_VT(v) = VT_UNKNOWN;
    V_UNKNOWN(v) = iunk;

    ok = true;
  done:
    return ok;
}

CRBvrPtr
VARIANTToCRBvr(VARIANT var, CR_BVR_TYPEID tid)
{
    CRBvrPtr ret = NULL;
    HRESULT hr;
    CComVariant v;

    hr = v.ChangeType(VT_UNKNOWN, &var);

    if (FAILED(hr))
    {
        CRSetLastError(hr, NULL);
        goto done;
    }
    
    CRBvrPtr bvr;

    bvr = COMToCRBvr(V_UNKNOWN(&v));

    if (bvr == NULL)
    {
        goto done;
    }
    
    if (tid != CRINVALID_TYPEID &&
        CRGetTypeId(bvr) != tid)
    {
        CRSetLastError(DISP_E_TYPEMISMATCH, NULL);
        goto done;
    }
    
    ret = bvr;
    
  done:
    return ret;
}

const wchar_t * TIMEAttrPrefix = L"t:";

BSTR
CreateTIMEAttrName(LPCWSTR str)
{
    BSTR bstr = NULL;

    LPWSTR newstr = (LPWSTR) _alloca(sizeof(wchar_t) *
                                     (lstrlenW(str) +
                                      lstrlenW(TIMEAttrPrefix) +
                                      1));

    if (newstr == NULL)
    {
        goto done;
    }
    
    StrCpyW(newstr, TIMEAttrPrefix);
    StrCatW(newstr, str);

    bstr = SysAllocString(newstr);

  done:
    return bstr;
}

HRESULT
GetTIMEAttribute(IHTMLElement * elm,
                 LPCWSTR str,
                 LONG lFlags,
                 VARIANT * value)
{
    BSTR bstr;
    HRESULT hr;

    bstr = CreateTIMEAttrName(str);

    // Need to free bstr
    if (bstr == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = THR(elm->getAttribute(bstr,lFlags,value));
    
    SysFreeString(bstr);
    
  done:
    return hr;
}

HRESULT
SetTIMEAttribute(IHTMLElement * elm,
                 LPCWSTR str,
                 VARIANT value,
                 LONG lFlags)
{
    BSTR bstr;
    HRESULT hr;

    bstr = CreateTIMEAttrName(str);

    // Need to free bstr
    if (bstr == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    
    hr = THR(elm->setAttribute(bstr,value,lFlags));
    
    SysFreeString(bstr);
    
  done:
    return hr;
}

//
// Initialization
//

bool
InitializeModule_Util()
{
    g_ddCS = new CritSect;

    if (g_ddCS == NULL)
    {
        return false;
    }
    
    return true;
}

void
DeinitializeModule_Util(bool bShutdown)
{
    delete g_ddCS;
    g_ddCS = NULL;
}


///////////////////////////////////////////////////////////
// Name: VariantToBool
//
// Parameters:   VARIANT var      - a variant to convert to a 
//                                  BOOL value.
//
// Abstract:
//    This function coverts any VARIANT to a boolean value using
//    TRUE = 1 and FALSE = 0.  (COM uses TRUE = -1 and FALSE = 0).
//    Any VARIANT that can be coerced to a BOOL is and the coerced
//    value is returned.  If the VARIANT cannot be coerced, FALSE
//    is returned.
///////////////////////////////////////////////////////////
bool VariantToBool(VARIANT var)
{
    //if the value is already a bool return it.
    if (var.vt == VT_BOOL)
    {
        return var.boolVal == FALSE ? false : true;
    }
    else  //otherwise convert it to VT_BOOL
    {
        VARIANT vTemp;
        HRESULT hr;
        
        VariantInit(&vTemp);
        hr = VariantChangeTypeEx(&vTemp, &var, LCID_SCRIPTING, 0, VT_BOOL);
        if (SUCCEEDED(hr)) //if it can be converted return it
        {
            return vTemp.boolVal == FALSE ? false : true;
        }
        else //if it can't be converted return false
        {
            return false;
        }
    }

}


///////////////////////////////////////////////////////////
// Name: VariantToFloat
//
// Parameters:   VARIANT var      - a variant to convert to a 
//                                  float value.  This can contain
//                                  the special cases 'FOREVER' and
//                                  'INDEFINITE'.
//
// Abstract:
//
///////////////////////////////////////////////////////////
float VariantToFloat(VARIANT var, bool bAllowIndefinite, bool bAllowForever)
{
    float fResult = INVALID;

    if (var.vt == VT_R4)
    {
        fResult = var.fltVal;
        goto done;
    }

    VARIANT vTemp;
    HRESULT hr;

    VariantInit(&vTemp);
    hr = VariantChangeTypeEx(&vTemp, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_R4);
    if (SUCCEEDED(hr)) 
    {
        fResult = vTemp.fltVal;
        goto done;
    }

    //Check to see if it is 'FOREVER' and 'INDEFINITE
    //Should these be case sensitive?
    if (bAllowForever == TRUE)
    {
        if (var.vt == VT_BSTR)
        {
            if (StrCmpIW(var.bstrVal, L"FOREVER") == 0)
            {
                fResult = FOREVER;
                goto done;
            }
        }
    }
    if (bAllowIndefinite == TRUE)
    {
        if (var.vt == VT_BSTR)
        {
            if (StrCmpIW(var.bstrVal, WZ_INDEFINITE) == 0)
            {
                fResult = INDEFINITE;
                goto done;
            }
        }
    }

  done:
    return fResult;

}

///////////////////////////////////////////////////////////
// Name: VariantToTime
//
// Parameters:   VARIANT var      - a VARIANT to convert to a 
//                                  from a time value to seconds.\
//                                    this can take the form of
//                                    HH:MM:SS.DD
//                                    MM:SS.DD
//                                    SS.DD
//                                    DD.DDs
//                                    DD.DDm
//                                    DD.DDh
//                                    and may be preceeded by a + or -
//                                    
//                                    
// 
// Abstract:
//    Converts the incoming variant to a BSTR and parses for valid
//    clock values.  It passes the value back in retVal and returns
//    S_OK or E_INVALIDARG in the case of incorrect input. If the
//    return value is E_INVALIDARG, *retVal is passed back as
//    INDEFINITE.
///////////////////////////////////////////////////////////
HRESULT VariantToTime(VARIANT var, float *retVal)
{    

    HRESULT hr = S_OK;
    OLECHAR *szTime;
    bool bPositive = TRUE;
    int nHour = 0;
    int nMin = 0;
    int nSec = 0;
    float fFSec = 0;
    VARIANT vTemp;

    //convert the parameter to a BSTR
    VariantInit(&vTemp);
    if (var.vt != VT_BSTR)
    {
        hr = VariantChangeTypeEx(&vTemp, &var, LCID_SCRIPTING, VARIANT_NOUSEROVERRIDE, VT_BSTR);
        if (FAILED(hr))
        {
            *retVal = INVALID;
            goto done;
        }
    }
    else
    {
        hr = VariantCopy(&vTemp, &var);
        if (FAILED(hr))
        {
            *retVal = INVALID;
            goto done;
        }
    }

    hr = S_OK;

    //convert to a char array. If not possible, return error.
    szTime = vTemp.bstrVal;
    
    if (IsIndefinite(szTime))
    {
        *retVal = INDEFINITE;
        goto done;
    }

    //remove leading whitespace
    while (*szTime == ' ')
    {
        szTime++;
    }
    //check for +/- if none, assume +
    if (*szTime == '-')
    {
        bPositive = false;
        szTime++;
    }
    else if (*szTime == '+')
    {
        szTime++;
    }

    //check for invalid and err out
    if (*szTime == '\0')
    {
        *retVal = INVALID;
        goto done;
    }

    //get first set of numbers
    while (*szTime >= '0' && *szTime <= '9')
    {
        nSec = nSec * 10 + (*szTime - '0');
        szTime++;
    }
    if (*szTime == '\0')    //if none use time as seconds
    {
        *retVal = nSec * (bPositive ? 1 : -1); //this is the end so return;
        goto done;
    }
    else if (*szTime == '.')  //if it is a '.' treat this as the fractional part
    {
        float nDiv = 10.0;
        szTime++;
        while (*szTime >= '0' && *szTime <= '9')
        {
            fFSec = fFSec + (*szTime - '0') / nDiv;
            szTime++;
            nDiv *= 10;
        }        
        if (*szTime == '\0')
        {
            *retVal = (nSec + fFSec) * (bPositive? 1 : -1);
            goto done;
        }
    }
    
    if (*szTime == 'h') //if "h" use time as hours
    {
        nHour = nSec;
        nSec = 0;
        szTime++;
        if (*szTime != '\0') 
        {
            *retVal = INVALID;
        }
        else
        {
            *retVal = (((float)nHour + fFSec) * SECPERHOUR) * (bPositive? 1 : -1);
        }
        goto done;
    }
    else if (*szTime == 'm' && *(szTime + 1) == 'i' && *(szTime + 2) == 'n') //if "min" use time as minutes
    {
        nMin = nSec;
        nSec = 0;
        szTime += 3;
        if (*szTime != '\0') 
        {
            *retVal = INVALID;
        }
        else
        {
            *retVal = (((float)nMin + fFSec) * SECPERMINUTE)* (bPositive? 1 : -1); 
        }
        goto done;
    }
    else if (*szTime == 's') //if "s" use time as seconds
    {
        szTime++;
        if (*szTime != '\0')
        {
            *retVal = INVALID;
        }
        else
        {
            *retVal = (nSec + fFSec) * (bPositive? 1 : -1); 
        }
        goto done;
    }
    else if (*szTime == 'm' && *(szTime + 1) == 's') //if "ms" use time as milliseconds
    {
        fFSec = (fFSec + nSec) / 1000.0;
        szTime += 2;
        if (*szTime != '\0') 
        {
            *retVal = INVALID;
        }
        else
        {
            *retVal = fFSec * (bPositive? 1 : -1); //convert minutes to seconds
        }
        goto done;
    }
    else if (*szTime == ':' && fFSec == 0)
    {
        //handle the HH:MM:SS format here
        nMin = nSec;
        nSec = 0;
        
        //next part must be 2 digits
        szTime++;
        if (*szTime >= '0' && *szTime <= '9')
        {
            nSec = *szTime - '0';
        }
        else 
        {
            *retVal = INVALID;
            goto done;
        }
        szTime++;
        if (*szTime >= '0' && *szTime <= '9')
        {
            nSec = nSec * 10 + (*szTime - '0');
        }
        else 
        {
            *retVal = INVALID;
            goto done;
        }
        szTime++;
        if (*szTime == ':')
        {
            nHour = nMin;
            nMin = nSec;
            nSec = 0;
            //next part must be 2 digits
            szTime++;
            if (*szTime >= '0' && *szTime <= '9')
            {
                nSec = *szTime - '0';
            }
            else 
            {
                *retVal = INVALID;
                goto done;
            }
            szTime++;
            if (*szTime >= '0' && *szTime <= '9')
            {
                nSec = nSec * 10 + (*szTime - '0');
            }
            else 
            {
                *retVal = INVALID;
                goto done;
            }
            szTime++;
        }
        
        if (*szTime == '.') 
        {
            //handle fractional part
            float nDiv = 10.0;
            szTime++;
            while ((*szTime >= '0') && (*szTime <= '9'))
            {
                fFSec = fFSec + ((*szTime - '0') / nDiv);
                szTime++;
                nDiv *= 10;
            }
        }
        
        //check to be sure the string terminated
        if (*szTime != '\0')
        {
            *retVal = INVALID;
            goto done;
        }
    
        if (nSec < 00 || nSec > 59 || nMin < 00 || nMin > 59)
        {
            *retVal = INVALID;
            goto done;
        }
        *retVal = (((float)(nHour * SECPERHOUR + nMin * SECPERMINUTE + nSec) + fFSec)) * (bPositive? 1 : -1);
    }
    else
    {
        *retVal = INVALID;
    }
  done:

    if (vTemp.vt == VT_BSTR)
    {
        VariantClear(&vTemp);
    }

    if (*retVal == INVALID)
    {
        *retVal = INDEFINITE;
        hr = E_INVALIDARG;
    }

    return hr;

}

///////////////////////////////////////
// Name: IsIndefinite
//
// Abstract:
//   Determines in a case-insensitive manner
//   if the string szTime is 'INDEFINITE'.
///////////////////////////////////////
BOOL IsIndefinite(OLECHAR *szTime)
{
    BOOL bResult = FALSE;
    OLECHAR szTemp[11] = { 0 };
    
    for (int i = 0; i < 10; i++)
    {
        if (szTime[i] == '\0')
        {
            goto done;
        }
        szTemp[i] = towupper(szTime[i]);
    }

    if (szTime[10] != '\0')
    {
        goto done;
    }
 
    if (StrCmpIW(szTime, L"INDEFINITE") == 0)
    {
        bResult = TRUE;
    }

  done:
    return bResult;
}

HRESULT
CheckElementForBehaviorURN(IHTMLElement *pElement,
                           WCHAR *wzURN,
                           bool *pfReturn)
{
    Assert(pElement != NULL);
    Assert(wzURN != NULL);
    Assert(pfReturn != NULL);

    *pfReturn = false;
    HRESULT hr;
    IHTMLElement2 *pElement2;
    hr = pElement->QueryInterface(IID_TO_PPV(IHTMLElement2, &pElement2));
    if (SUCCEEDED(hr) && pElement2 != NULL)
    {
        // get a collection of urns from the element
        IDispatch *pDisp;
        hr = pElement2->get_behaviorUrns(&pDisp);
        ReleaseInterface(pElement2);
        if (FAILED(hr))
        {
            return hr;
        }
        IHTMLUrnCollection *pUrnCollection;
        hr = pDisp->QueryInterface(IID_TO_PPV(IHTMLUrnCollection, &pUrnCollection));
        ReleaseInterface(pDisp);
        if (FAILED(hr))
        {
            return hr;
        }
        long cUrns;
        hr = pUrnCollection->get_length(&cUrns);
        if (FAILED(hr))
        {
            ReleaseInterface(pUrnCollection);
            return hr;
        }
        for (long iUrns = 0; iUrns < cUrns; iUrns++)
        {
            // get the urn from the collection
            BSTR bstrUrn;
            hr = pUrnCollection->item(iUrns, &bstrUrn);
            if (FAILED(hr))
            {
                ReleaseInterface(pUrnCollection);
                return hr;
            }
            // now compare this urn with our behavior type
            if (bstrUrn != NULL && StrCmpIW(bstrUrn, wzURN) == 0)
            {
                // we have a match. . .get out of here 
                SysFreeString(bstrUrn);
                ReleaseInterface(pUrnCollection);
                *pfReturn = true;
                return S_OK;

            }
            if (bstrUrn != NULL)
                SysFreeString(bstrUrn);
        }
        ReleaseInterface(pUrnCollection);
    }
    return S_OK;
} // CheckElementForBehaviorURN



HRESULT 
AddBodyBehavior(IHTMLElement* pBaseElement)
{
    HRESULT hr = S_OK;

    DAComPtr<IHTMLElement2>     pElement2;
    DAComPtr<ITIMEFactory>      pTimeFactory;
    long nCookie;

    VARIANT varTIMEFactory;

    hr = THR(GetBodyElement(pBaseElement,
                            IID_IHTMLElement2,
                            (void **) &pElement2));
    if (FAILED(hr))
    {
        goto done;
    }

    {
        DAComPtr<IHTMLElement>      pElement;

        // Trident doesn't believe in inheritance:
        hr = THR(pElement2->QueryInterface(IID_IHTMLElement, (void **)&pElement));
        if (FAILED(hr))
        {
            goto done;
        }
        
        if (IsTIMEBodyElement(pElement))
        {
            // someone's already put a TIMEBody behavior on the time body.  bail out.
            goto done;
        }
    }

    hr = THR(CoCreateInstance(CLSID_TIMEFactory,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_ITIMEFactory,
                              (void**)&pTimeFactory));
    if (FAILED(hr))
    {
        goto done;
    }

    VariantInit(&varTIMEFactory);
    varTIMEFactory.vt = VT_UNKNOWN;
    varTIMEFactory.punkVal = (IUnknown*)pTimeFactory;

    hr = THR(pElement2->addBehavior(WZ_OBFUSCATED_TIMEBODY_URN, &varTIMEFactory, &nCookie));
    if (FAILED(hr))
    {
        goto done;
    }

    // pass thru:
  done:
    return hr;
}


bool
IsBodyElement(IHTMLElement* pElement)
{
    HRESULT hr = S_OK;
    bool rc = false;

    Assert(pElement);

    DAComPtr<IHTMLElement>      pBodyElement;

    hr = pElement->QueryInterface(IID_IHTMLBodyElement, (void**)&pBodyElement);
    if (FAILED(hr))
    {
        // not really an error, per se.
        goto done;
    }

    Assert(pBodyElement);       // The HTML document may (incorrectly) succeed and return NULL during early load

    // yup, they're a BODY element
    rc = true;

// pass thru:
  done:

    return rc;
}

HRESULT 
GetBodyElement(IHTMLElement* pElem, REFIID riid, void** ppBE)
{
    HRESULT hr = S_OK;

    DAComPtr<IDispatch>         pBodyDispatch;
    DAComPtr<IHTMLDocument2>    pDocument2;
    DAComPtr<IHTMLElement>      pBodyElement;

    if (!pElem)
    {
        TraceTag((tagError, "CTIMEElement::GetBody -- GetElement() failed."));
        hr = E_FAIL;
        goto done;
    }


    hr = THR(pElem->get_document(&pBodyDispatch));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pBodyDispatch->QueryInterface(IID_IHTMLDocument2, (void**)&pDocument2));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = THR(pDocument2->get_body(&pBodyElement));
    
    // We need to check the point aswell as the hr since we get lied to by Trident sometimes.
    if (FAILED(hr) || !pBodyElement)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = THR(pBodyElement->QueryInterface(riid, ppBE));
    if (FAILED(hr))
    {
        goto done;
    }

    // pass thru:
  done:
    return hr;
}

bool
IsTIMEBodyElement(IHTMLElement *pElement)
{
    HRESULT hr;
    bool rc = false;
    DAComPtr<ITIMEElement> pTIMEElem;
    DAComPtr<ITIMEBodyElement> pTIMEBody;
    
    // find TIME interface on element.
    hr = FindTIMEInterface(pElement, &pTIMEElem);
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(pTIMEElem.p != NULL);

    // QI for body.
    hr = pTIMEElem->QueryInterface(IID_ITIMEBodyElement, (void**)&pTIMEBody);
    if (FAILED(hr))
    {
        goto done;
    }
    
    Assert(pTIMEBody.p != NULL);
    rc = true;

done:
    return rc;
}

HRESULT
FindTIMEInterface(IHTMLElement *pHTMLElem, ITIMEElement **ppTIMEElem)
{
    HRESULT hr;
    DAComPtr<IDispatch> pDisp;

    if ( (pHTMLElem == NULL) || (ppTIMEElem == NULL) )
    {
        hr = E_POINTER;
        goto done;
    }

    *ppTIMEElem = NULL;


    // Get IDispatch for TIME behavior
    hr = FindTIMEBehavior(pHTMLElem, &pDisp);
    if (FAILED(hr))
    {
        goto done;
    }

    Assert(pDisp.p != NULL);

    // get ITIMEElement interface
    hr = THR(pDisp->QueryInterface(IID_ITIMEElement, (void**)ppTIMEElem));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = S_OK;
        
done:
    return hr;
}

HRESULT
FindTIMEBehavior(IHTMLElement *pHTMLElem, IDispatch **ppDisp)
{
    DISPID  dispid;
    DISPPARAMS dispparams = { NULL, NULL, 0, 0 };
    WCHAR   *wzName = WZ_REGISTERED_NAME;
    VARIANT varResult;
    HRESULT hr;
   
    VariantInit(&varResult);

    if ( (pHTMLElem == NULL) || (ppDisp == NULL) )
    {
        hr = E_POINTER;
        goto done;
    }

    *ppDisp = NULL;

    // Call GetIDsOfNames on element named "HTMLTIME"
    // which we registered the behavior with.
    hr = pHTMLElem->GetIDsOfNames(IID_NULL, &wzName, 1, LCID_SCRIPTING, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pHTMLElem->Invoke(dispid, 
                           IID_NULL, 
                           LCID_SCRIPTING, 
                           DISPATCH_PROPERTYGET,
                           &dispparams, 
                           &varResult, 
                           NULL, 
                           NULL);
    if (FAILED(hr))
    {
        goto done;
    }
    
    if ((varResult.vt != VT_DISPATCH) || (varResult.pdispVal == NULL))
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    // although this looks odd, this assigns the IDispatch we found and
    // takes care of the addref.    
    hr = varResult.pdispVal->QueryInterface(IID_IDispatch, (void**)ppDisp);

done:
    VariantClear(&varResult);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\src\types\idl\primfuns.h ===
HRESULT Pow ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDANumber * * ret_2) ;

        HRESULT Abs ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Sqrt ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Floor ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Round ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Ceiling ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Asin ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Acos ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Atan ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Sin ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Cos ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Tan ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Exp ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Ln ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Log10 ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT ToDegrees ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT ToRadians ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Mod ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDANumber * * ret_2) ;

        HRESULT Atan2 ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDANumber * * ret_2) ;

        HRESULT Add ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDANumber * * ret_2) ;

        HRESULT Sub ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDANumber * * ret_2) ;

        HRESULT Mul ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDANumber * * ret_2) ;

        HRESULT Div ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDANumber * * ret_2) ;

        HRESULT LT ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDABoolean * * ret_2) ;

        HRESULT LTE ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDABoolean * * ret_2) ;

        HRESULT GT ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDABoolean * * ret_2) ;

        HRESULT GTE ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDABoolean * * ret_2) ;

        HRESULT EQ ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDABoolean * * ret_2) ;

        HRESULT NE ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDABoolean * * ret_2) ;

        HRESULT Neg ([in] IDANumber * a_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT InterpolateAnim ([in] IDANumber * from_0, [in] IDANumber * to_1, [in] IDANumber * duration_2, [out, retval] IDANumber * * ret_3) ;

        HRESULT Interpolate ([in] double from_0, [in] double to_1, [in] double duration_2, [out, retval] IDANumber * * ret_3) ;

        HRESULT SlowInSlowOutAnim ([in] IDANumber * from_0, [in] IDANumber * to_1, [in] IDANumber * duration_2, [in] IDANumber * sharpness_3, [out, retval] IDANumber * * ret_4) ;

        HRESULT SlowInSlowOut ([in] double from_0, [in] double to_1, [in] double duration_2, [in] double sharpness_3, [out, retval] IDANumber * * ret_4) ;

        HRESULT SoundSource ([in] IDASound * snd_0, [out, retval] IDAGeometry * * ret_1) ;

        HRESULT Mix ([in] IDASound * left_0, [in] IDASound * right_1, [out, retval] IDASound * * ret_2) ;

        HRESULT And ([in] IDABoolean * a_0, [in] IDABoolean * b_1, [out, retval] IDABoolean * * ret_2) ;

        HRESULT Or ([in] IDABoolean * a_0, [in] IDABoolean * b_1, [out, retval] IDABoolean * * ret_2) ;

        HRESULT Not ([in] IDABoolean * a_0, [out, retval] IDABoolean * * ret_1) ;

        HRESULT Integral ([in] IDANumber * b_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT Derivative ([in] IDANumber * b_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT IntegralVector2 ([in] IDAVector2 * v_0, [out, retval] IDAVector2 * * ret_1) ;

        HRESULT IntegralVector3 ([in] IDAVector3 * v_0, [out, retval] IDAVector3 * * ret_1) ;

        HRESULT DerivativeVector2 ([in] IDAVector2 * v_0, [out, retval] IDAVector2 * * ret_1) ;

        HRESULT DerivativeVector3 ([in] IDAVector3 * v_0, [out, retval] IDAVector3 * * ret_1) ;

        HRESULT DerivativePoint2 ([in] IDAPoint2 * v_0, [out, retval] IDAVector2 * * ret_1) ;

        HRESULT DerivativePoint3 ([in] IDAPoint3 * v_0, [out, retval] IDAVector3 * * ret_1) ;

        HRESULT KeyState ([in] IDANumber * n_0, [out, retval] IDABoolean * * ret_1) ;

        HRESULT KeyUp ([in] LONG arg_0, [out, retval] IDAEvent * * ret_1) ;

        HRESULT KeyDown ([in] LONG arg_0, [out, retval] IDAEvent * * ret_1) ;

        HRESULT DANumber ([in] double num_0, [out, retval] IDANumber * * ret_1) ;

        HRESULT DAString ([in] BSTR str_0, [out, retval] IDAString * * ret_1) ;

        HRESULT DABoolean ([in] VARIANT_BOOL num_0, [out, retval] IDABoolean * * ret_1) ;

        HRESULT SeededRandom ([in] double arg_0, [out, retval] IDANumber * * ret_1) ;

        [propget] HRESULT MousePosition ([out, retval] IDAPoint2 * * ret_0) ;

        [propget] HRESULT LeftButtonState ([out, retval] IDABoolean * * ret_0) ;

        [propget] HRESULT RightButtonState ([out, retval] IDABoolean * * ret_0) ;

        [propget] HRESULT DATrue ([out, retval] IDABoolean * * ret_0) ;

        [propget] HRESULT DAFalse ([out, retval] IDABoolean * * ret_0) ;

        [propget] HRESULT LocalTime ([out, retval] IDANumber * * ret_0) ;

        [propget] HRESULT GlobalTime ([out, retval] IDANumber * * ret_0) ;

        [propget] HRESULT Pixel ([out, retval] IDANumber * * ret_0) ;

        HRESULT UserData ([in] IUnknown * data_0, [out, retval] IDAUserData * * ret_1) ;

        HRESULT UntilNotify ([in] IDABehavior * b0_0, [in] IDAEvent * event_1, [in] IDAUntilNotifier * notifier_2, [out, retval] IDABehavior * * ret_3) ;

        HRESULT Until ([in] IDABehavior * b0_0, [in] IDAEvent * event_1, [in] IDABehavior * b1_2, [out, retval] IDABehavior * * ret_3) ;

        HRESULT UntilEx ([in] IDABehavior * b0_0, [in] IDAEvent * event_1, [out, retval] IDABehavior * * ret_2) ;

        HRESULT Sequence ([in] IDABehavior * s1_0, [in] IDABehavior * s2_1, [out, retval] IDABehavior * * ret_2) ;

        HRESULT FollowPath ([in] IDAPath2 * path_0, [in] double duration_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT FollowPathAngle ([in] IDAPath2 * path_0, [in] double duration_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT FollowPathAngleUpright ([in] IDAPath2 * path_0, [in] double duration_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT FollowPathEval ([in] IDAPath2 * path_0, [in] IDANumber * eval_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT FollowPathAngleEval ([in] IDAPath2 * path_0, [in] IDANumber * eval_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT FollowPathAngleUprightEval ([in] IDAPath2 * path_0, [in] IDANumber * eval_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT FollowPathAnim ([in] IDAPath2 * obsoleted1_0, [in] IDANumber * obsoleted2_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT FollowPathAngleAnim ([in] IDAPath2 * obsoleted1_0, [in] IDANumber * obsoleted2_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT FollowPathAngleUprightAnim ([in] IDAPath2 * obsoleted1_0, [in] IDANumber * obsoleted2_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT ConcatString ([in] IDAString * s1_0, [in] IDAString * s2_1, [out, retval] IDAString * * ret_2) ;

        HRESULT PerspectiveCamera ([in] double focalDist_0, [in] double nearClip_1, [out, retval] IDACamera * * ret_2) ;

        HRESULT PerspectiveCameraAnim ([in] IDANumber * focalDist_0, [in] IDANumber * nearClip_1, [out, retval] IDACamera * * ret_2) ;

        HRESULT ParallelCamera ([in] double nearClip_0, [out, retval] IDACamera * * ret_1) ;

        HRESULT ParallelCameraAnim ([in] IDANumber * nearClip_0, [out, retval] IDACamera * * ret_1) ;

        HRESULT ColorRgbAnim ([in] IDANumber * red_0, [in] IDANumber * green_1, [in] IDANumber * blue_2, [out, retval] IDAColor * * ret_3) ;

        HRESULT ColorRgb ([in] double red_0, [in] double green_1, [in] double blue_2, [out, retval] IDAColor * * ret_3) ;

        HRESULT ColorRgb255 ([in] short red_0, [in] short green_1, [in] short blue_2, [out, retval] IDAColor * * ret_3) ;

        HRESULT ColorHsl ([in] double hue_0, [in] double saturation_1, [in] double lum_2, [out, retval] IDAColor * * ret_3) ;

        HRESULT ColorHslAnim ([in] IDANumber * hue_0, [in] IDANumber * saturation_1, [in] IDANumber * lum_2, [out, retval] IDAColor * * ret_3) ;

        [propget] HRESULT Red ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Green ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Blue ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Cyan ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Magenta ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Yellow ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Black ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT White ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Aqua ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Fuchsia ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Gray ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Lime ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Maroon ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Navy ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Olive ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Purple ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Silver ([out, retval] IDAColor * * ret_0) ;

        [propget] HRESULT Teal ([out, retval] IDAColor * * ret_0) ;

        HRESULT Predicate ([in] IDABoolean * b_0, [out, retval] IDAEvent * * ret_1) ;

        HRESULT NotEvent ([in] IDAEvent * event_0, [out, retval] IDAEvent * * ret_1) ;

        HRESULT AndEvent ([in] IDAEvent * e1_0, [in] IDAEvent * e2_1, [out, retval] IDAEvent * * ret_2) ;

        HRESULT OrEvent ([in] IDAEvent * e1_0, [in] IDAEvent * e2_1, [out, retval] IDAEvent * * ret_2) ;

        HRESULT ThenEvent ([in] IDAEvent * e1_0, [in] IDAEvent * e2_1, [out, retval] IDAEvent * * ret_2) ;

        [propget] HRESULT LeftButtonDown ([out, retval] IDAEvent * * ret_0) ;

        [propget] HRESULT LeftButtonUp ([out, retval] IDAEvent * * ret_0) ;

        [propget] HRESULT RightButtonDown ([out, retval] IDAEvent * * ret_0) ;

        [propget] HRESULT RightButtonUp ([out, retval] IDAEvent * * ret_0) ;

        [propget] HRESULT Always ([out, retval] IDAEvent * * ret_0) ;

        [propget] HRESULT Never ([out, retval] IDAEvent * * ret_0) ;

        HRESULT TimerAnim ([in] IDANumber * n_0, [out, retval] IDAEvent * * ret_1) ;

        HRESULT Timer ([in] double n_0, [out, retval] IDAEvent * * ret_1) ;

        HRESULT AppTriggeredEvent ([out, retval] IDAEvent * * ret_0) ;

        HRESULT ScriptCallback ([in] BSTR obsolete1_0, [in] IDAEvent * obsolete2_1, [in] BSTR obsolete3_2, [out, retval] IDAEvent * * ret_3) ;

        [propget] HRESULT EmptyGeometry ([out, retval] IDAGeometry * * ret_0) ;

        HRESULT UnionGeometry ([in] IDAGeometry * g1_0, [in] IDAGeometry * g2_1, [out, retval] IDAGeometry * * ret_2) ;

        HRESULT UnionGeometryArrayEx ([in] LONG imgs_0size, [in,size_is(imgs_0size)] IDAGeometry * imgs_0[], [out, retval] IDAGeometry * * ret_1) ;

        HRESULT UnionGeometryArray ([in] VARIANT imgs_0, [out, retval] IDAGeometry * * ret_1) ;

        [propget] HRESULT EmptyImage ([out, retval] IDAImage * * ret_0) ;

        [propget] HRESULT DetectableEmptyImage ([out, retval] IDAImage * * ret_0) ;

        HRESULT SolidColorImage ([in] IDAColor * col_0, [out, retval] IDAImage * * ret_1) ;

        HRESULT GradientPolygonEx ([in] LONG points_0size, [in,size_is(points_0size)] IDAPoint2 * points_0[], [in] LONG colors_1size, [in,size_is(colors_1size)] IDAColor * colors_1[], [out, retval] IDAImage * * ret_2) ;

        HRESULT GradientPolygon ([in] VARIANT points_0, [in] VARIANT colors_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT RadialGradientPolygonEx ([in] IDAColor * inner_0, [in] IDAColor * outer_1, [in] LONG points_2size, [in,size_is(points_2size)] IDAPoint2 * points_2[], [in] double fallOff_3, [out, retval] IDAImage * * ret_4) ;

        HRESULT RadialGradientPolygon ([in] IDAColor * inner_0, [in] IDAColor * outer_1, [in] VARIANT points_2, [in] double fallOff_3, [out, retval] IDAImage * * ret_4) ;

        HRESULT RadialGradientPolygonAnimEx ([in] IDAColor * inner_0, [in] IDAColor * outer_1, [in] LONG points_2size, [in,size_is(points_2size)] IDAPoint2 * points_2[], [in] IDANumber * fallOff_3, [out, retval] IDAImage * * ret_4) ;

        HRESULT RadialGradientPolygonAnim ([in] IDAColor * inner_0, [in] IDAColor * outer_1, [in] VARIANT points_2, [in] IDANumber * fallOff_3, [out, retval] IDAImage * * ret_4) ;

        HRESULT GradientSquare ([in] IDAColor * lowerLeft_0, [in] IDAColor * upperLeft_1, [in] IDAColor * upperRight_2, [in] IDAColor * lowerRight_3, [out, retval] IDAImage * * ret_4) ;

        HRESULT RadialGradientSquare ([in] IDAColor * inner_0, [in] IDAColor * outer_1, [in] double fallOff_2, [out, retval] IDAImage * * ret_3) ;

        HRESULT RadialGradientSquareAnim ([in] IDAColor * inner_0, [in] IDAColor * outer_1, [in] IDANumber * fallOff_2, [out, retval] IDAImage * * ret_3) ;

        HRESULT RadialGradientRegularPoly ([in] IDAColor * inner_0, [in] IDAColor * outer_1, [in] double numEdges_2, [in] double fallOff_3, [out, retval] IDAImage * * ret_4) ;

        HRESULT RadialGradientRegularPolyAnim ([in] IDAColor * inner_0, [in] IDAColor * outer_1, [in] IDANumber * numEdges_2, [in] IDANumber * fallOff_3, [out, retval] IDAImage * * ret_4) ;

        HRESULT GradientHorizontal ([in] IDAColor * start_0, [in] IDAColor * stop_1, [in] double fallOff_2, [out, retval] IDAImage * * ret_3) ;

        HRESULT GradientHorizontalAnim ([in] IDAColor * start_0, [in] IDAColor * stop_1, [in] IDANumber * fallOff_2, [out, retval] IDAImage * * ret_3) ;

        HRESULT HatchHorizontal ([in] IDAColor * lineClr_0, [in] double spacing_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT HatchHorizontalAnim ([in] IDAColor * lineClr_0, [in] IDANumber * spacing_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT HatchVertical ([in] IDAColor * lineClr_0, [in] double spacing_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT HatchVerticalAnim ([in] IDAColor * lineClr_0, [in] IDANumber * spacing_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT HatchForwardDiagonal ([in] IDAColor * lineClr_0, [in] double spacing_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT HatchForwardDiagonalAnim ([in] IDAColor * lineClr_0, [in] IDANumber * spacing_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT HatchBackwardDiagonal ([in] IDAColor * lineClr_0, [in] double spacing_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT HatchBackwardDiagonalAnim ([in] IDAColor * lineClr_0, [in] IDANumber * spacing_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT HatchCross ([in] IDAColor * lineClr_0, [in] double spacing_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT HatchCrossAnim ([in] IDAColor * lineClr_0, [in] IDANumber * spacing_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT HatchDiagonalCross ([in] IDAColor * lineClr_0, [in] double spacing_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT HatchDiagonalCrossAnim ([in] IDAColor * lineClr_0, [in] IDANumber * spacing_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT Overlay ([in] IDAImage * top_0, [in] IDAImage * bottom_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT OverlayArrayEx ([in] LONG imgs_0size, [in,size_is(imgs_0size)] IDAImage * imgs_0[], [out, retval] IDAImage * * ret_1) ;

        HRESULT OverlayArray ([in] VARIANT imgs_0, [out, retval] IDAImage * * ret_1) ;

        [propget] HRESULT AmbientLight ([out, retval] IDAGeometry * * ret_0) ;

        [propget] HRESULT DirectionalLight ([out, retval] IDAGeometry * * ret_0) ;

        [propget] HRESULT PointLight ([out, retval] IDAGeometry * * ret_0) ;

        HRESULT SpotLightAnim ([in] IDANumber * fullcone_0, [in] IDANumber * cutoff_1, [out, retval] IDAGeometry * * ret_2) ;

        HRESULT SpotLight ([in] IDANumber * fullcone_0, [in] double cutoff_1, [out, retval] IDAGeometry * * ret_2) ;

        [propget] HRESULT DefaultLineStyle ([out, retval] IDALineStyle * * ret_0) ;

        [propget] HRESULT EmptyLineStyle ([out, retval] IDALineStyle * * ret_0) ;

        [propget] HRESULT JoinStyleBevel ([out, retval] IDAJoinStyle * * ret_0) ;

        [propget] HRESULT JoinStyleRound ([out, retval] IDAJoinStyle * * ret_0) ;

        [propget] HRESULT JoinStyleMiter ([out, retval] IDAJoinStyle * * ret_0) ;

        [propget] HRESULT EndStyleFlat ([out, retval] IDAEndStyle * * ret_0) ;

        [propget] HRESULT EndStyleSquare ([out, retval] IDAEndStyle * * ret_0) ;

        [propget] HRESULT EndStyleRound ([out, retval] IDAEndStyle * * ret_0) ;

        [propget] HRESULT DashStyleSolid ([out, retval] IDADashStyle * * ret_0) ;

        [propget] HRESULT DashStyleDashed ([out, retval] IDADashStyle * * ret_0) ;

        [propget] HRESULT DefaultMicrophone ([out, retval] IDAMicrophone * * ret_0) ;

        [propget] HRESULT OpaqueMatte ([out, retval] IDAMatte * * ret_0) ;

        [propget] HRESULT ClearMatte ([out, retval] IDAMatte * * ret_0) ;

        HRESULT UnionMatte ([in] IDAMatte * m1_0, [in] IDAMatte * m2_1, [out, retval] IDAMatte * * ret_2) ;

        HRESULT IntersectMatte ([in] IDAMatte * m1_0, [in] IDAMatte * m2_1, [out, retval] IDAMatte * * ret_2) ;

        HRESULT DifferenceMatte ([in] IDAMatte * m1_0, [in] IDAMatte * m2_1, [out, retval] IDAMatte * * ret_2) ;

        HRESULT FillMatte ([in] IDAPath2 * p_0, [out, retval] IDAMatte * * ret_1) ;

        HRESULT TextMatte ([in] IDAString * str_0, [in] IDAFontStyle * fs_1, [out, retval] IDAMatte * * ret_2) ;

        [propget] HRESULT EmptyMontage ([out, retval] IDAMontage * * ret_0) ;

        HRESULT ImageMontage ([in] IDAImage * im_0, [in] double depth_1, [out, retval] IDAMontage * * ret_2) ;

        HRESULT ImageMontageAnim ([in] IDAImage * im_0, [in] IDANumber * depth_1, [out, retval] IDAMontage * * ret_2) ;

        HRESULT UnionMontage ([in] IDAMontage * m1_0, [in] IDAMontage * m2_1, [out, retval] IDAMontage * * ret_2) ;

        HRESULT Concat ([in] IDAPath2 * p1_0, [in] IDAPath2 * p2_1, [out, retval] IDAPath2 * * ret_2) ;

        HRESULT ConcatArrayEx ([in] LONG paths_0size, [in,size_is(paths_0size)] IDAPath2 * paths_0[], [out, retval] IDAPath2 * * ret_1) ;

        HRESULT ConcatArray ([in] VARIANT paths_0, [out, retval] IDAPath2 * * ret_1) ;

        HRESULT Line ([in] IDAPoint2 * p1_0, [in] IDAPoint2 * p2_1, [out, retval] IDAPath2 * * ret_2) ;

        HRESULT Ray ([in] IDAPoint2 * pt_0, [out, retval] IDAPath2 * * ret_1) ;

        HRESULT StringPathAnim ([in] IDAString * str_0, [in] IDAFontStyle * fs_1, [out, retval] IDAPath2 * * ret_2) ;

        HRESULT StringPath ([in] BSTR str_0, [in] IDAFontStyle * fs_1, [out, retval] IDAPath2 * * ret_2) ;

        HRESULT PolylineEx ([in] LONG points_0size, [in,size_is(points_0size)] IDAPoint2 * points_0[], [out, retval] IDAPath2 * * ret_1) ;

        HRESULT Polyline ([in] VARIANT points_0, [out, retval] IDAPath2 * * ret_1) ;

        HRESULT PolydrawPathEx ([in] LONG points_0size, [in,size_is(points_0size)] IDAPoint2 * points_0[], [in] LONG codes_1size, [in,size_is(codes_1size)] IDANumber * codes_1[], [out, retval] IDAPath2 * * ret_2) ;

        HRESULT PolydrawPath ([in] VARIANT points_0, [in] VARIANT codes_1, [out, retval] IDAPath2 * * ret_2) ;

        HRESULT ArcRadians ([in] double startAngle_0, [in] double endAngle_1, [in] double arcWidth_2, [in] double arcHeight_3, [out, retval] IDAPath2 * * ret_4) ;

        HRESULT ArcRadiansAnim ([in] IDANumber * startAngle_0, [in] IDANumber * endAngle_1, [in] IDANumber * arcWidth_2, [in] IDANumber * arcHeight_3, [out, retval] IDAPath2 * * ret_4) ;

        HRESULT ArcDegrees ([in] double startAngle_0, [in] double endAngle_1, [in] double arcWidth_2, [in] double arcHeight_3, [out, retval] IDAPath2 * * ret_4) ;

        HRESULT PieRadians ([in] double startAngle_0, [in] double endAngle_1, [in] double arcWidth_2, [in] double arcHeight_3, [out, retval] IDAPath2 * * ret_4) ;

        HRESULT PieRadiansAnim ([in] IDANumber * startAngle_0, [in] IDANumber * endAngle_1, [in] IDANumber * arcWidth_2, [in] IDANumber * arcHeight_3, [out, retval] IDAPath2 * * ret_4) ;

        HRESULT PieDegrees ([in] double startAngle_0, [in] double endAngle_1, [in] double arcWidth_2, [in] double arcHeight_3, [out, retval] IDAPath2 * * ret_4) ;

        HRESULT Oval ([in] double width_0, [in] double height_1, [out, retval] IDAPath2 * * ret_2) ;

        HRESULT OvalAnim ([in] IDANumber * width_0, [in] IDANumber * height_1, [out, retval] IDAPath2 * * ret_2) ;

        HRESULT Rect ([in] double width_0, [in] double height_1, [out, retval] IDAPath2 * * ret_2) ;

        HRESULT RectAnim ([in] IDANumber * width_0, [in] IDANumber * height_1, [out, retval] IDAPath2 * * ret_2) ;

        HRESULT RoundRect ([in] double width_0, [in] double height_1, [in] double cornerArcWidth_2, [in] double cornerArcHeight_3, [out, retval] IDAPath2 * * ret_4) ;

        HRESULT RoundRectAnim ([in] IDANumber * width_0, [in] IDANumber * height_1, [in] IDANumber * cornerArcWidth_2, [in] IDANumber * cornerArcHeight_3, [out, retval] IDAPath2 * * ret_4) ;

        HRESULT CubicBSplinePathEx ([in] LONG points_0size, [in,size_is(points_0size)] IDAPoint2 * points_0[], [in] LONG knots_1size, [in,size_is(knots_1size)] IDANumber * knots_1[], [out, retval] IDAPath2 * * ret_2) ;

        HRESULT CubicBSplinePath ([in] VARIANT points_0, [in] VARIANT knots_1, [out, retval] IDAPath2 * * ret_2) ;

        HRESULT TextPath ([in] IDAString * obsolete1_0, [in] IDAFontStyle * obsolete2_1, [out, retval] IDAPath2 * * ret_2) ;

        [propget] HRESULT Silence ([out, retval] IDASound * * ret_0) ;

        HRESULT MixArrayEx ([in] LONG snds_0size, [in,size_is(snds_0size)] IDASound * snds_0[], [out, retval] IDASound * * ret_1) ;

        HRESULT MixArray ([in] VARIANT snds_0, [out, retval] IDASound * * ret_1) ;

        [propget] HRESULT SinSynth ([out, retval] IDASound * * ret_0) ;

        [propget] HRESULT DefaultFont ([out, retval] IDAFontStyle * * ret_0) ;

        HRESULT FontAnim ([in] IDAString * str_0, [in] IDANumber * size_1, [in] IDAColor * col_2, [out, retval] IDAFontStyle * * ret_3) ;

        HRESULT Font ([in] BSTR str_0, [in] double size_1, [in] IDAColor * col_2, [out, retval] IDAFontStyle * * ret_3) ;

        HRESULT StringImageAnim ([in] IDAString * str_0, [in] IDAFontStyle * fs_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT StringImage ([in] BSTR str_0, [in] IDAFontStyle * fs_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT TextImageAnim ([in] IDAString * obsoleted1_0, [in] IDAFontStyle * obsoleted2_1, [out, retval] IDAImage * * ret_2) ;

        HRESULT TextImage ([in] BSTR obsoleted1_0, [in] IDAFontStyle * obsoleted2_1, [out, retval] IDAImage * * ret_2) ;

        [propget] HRESULT XVector2 ([out, retval] IDAVector2 * * ret_0) ;

        [propget] HRESULT YVector2 ([out, retval] IDAVector2 * * ret_0) ;

        [propget] HRESULT ZeroVector2 ([out, retval] IDAVector2 * * ret_0) ;

        [propget] HRESULT Origin2 ([out, retval] IDAPoint2 * * ret_0) ;

        HRESULT Vector2Anim ([in] IDANumber * x_0, [in] IDANumber * y_1, [out, retval] IDAVector2 * * ret_2) ;

        HRESULT Vector2 ([in] double x_0, [in] double y_1, [out, retval] IDAVector2 * * ret_2) ;

        HRESULT Point2Anim ([in] IDANumber * x_0, [in] IDANumber * y_1, [out, retval] IDAPoint2 * * ret_2) ;

        HRESULT Point2 ([in] double x_0, [in] double y_1, [out, retval] IDAPoint2 * * ret_2) ;

        HRESULT Vector2PolarAnim ([in] IDANumber * theta_0, [in] IDANumber * radius_1, [out, retval] IDAVector2 * * ret_2) ;

        HRESULT Vector2Polar ([in] double theta_0, [in] double radius_1, [out, retval] IDAVector2 * * ret_2) ;

        HRESULT Vector2PolarDegrees ([in] double theta_0, [in] double radius_1, [out, retval] IDAVector2 * * ret_2) ;

        HRESULT Point2PolarAnim ([in] IDANumber * theta_0, [in] IDANumber * radius_1, [out, retval] IDAPoint2 * * ret_2) ;

        HRESULT Point2Polar ([in] double theta_0, [in] double radius_1, [out, retval] IDAPoint2 * * ret_2) ;

        HRESULT DotVector2 ([in] IDAVector2 * v_0, [in] IDAVector2 * u_1, [out, retval] IDANumber * * ret_2) ;

        HRESULT NegVector2 ([in] IDAVector2 * v_0, [out, retval] IDAVector2 * * ret_1) ;

        HRESULT SubVector2 ([in] IDAVector2 * v1_0, [in] IDAVector2 * v2_1, [out, retval] IDAVector2 * * ret_2) ;

        HRESULT AddVector2 ([in] IDAVector2 * v1_0, [in] IDAVector2 * v2_1, [out, retval] IDAVector2 * * ret_2) ;

        HRESULT AddPoint2Vector ([in] IDAPoint2 * p_0, [in] IDAVector2 * v_1, [out, retval] IDAPoint2 * * ret_2) ;

        HRESULT SubPoint2Vector ([in] IDAPoint2 * p_0, [in] IDAVector2 * v_1, [out, retval] IDAPoint2 * * ret_2) ;

        HRESULT SubPoint2 ([in] IDAPoint2 * p1_0, [in] IDAPoint2 * p2_1, [out, retval] IDAVector2 * * ret_2) ;

        HRESULT DistancePoint2 ([in] IDAPoint2 * p_0, [in] IDAPoint2 * q_1, [out, retval] IDANumber * * ret_2) ;

        HRESULT DistanceSquaredPoint2 ([in] IDAPoint2 * p_0, [in] IDAPoint2 * q_1, [out, retval] IDANumber * * ret_2) ;

        [propget] HRESULT XVector3 ([out, retval] IDAVector3 * * ret_0) ;

        [propget] HRESULT YVector3 ([out, retval] IDAVector3 * * ret_0) ;

        [propget] HRESULT ZVector3 ([out, retval] IDAVector3 * * ret_0) ;

        [propget] HRESULT ZeroVector3 ([out, retval] IDAVector3 * * ret_0) ;

        [propget] HRESULT Origin3 ([out, retval] IDAPoint3 * * ret_0) ;

        HRESULT Vector3Anim ([in] IDANumber * x_0, [in] IDANumber * y_1, [in] IDANumber * z_2, [out, retval] IDAVector3 * * ret_3) ;

        HRESULT Vector3 ([in] double x_0, [in] double y_1, [in] double z_2, [out, retval] IDAVector3 * * ret_3) ;

        HRESULT Point3Anim ([in] IDANumber * x_0, [in] IDANumber * y_1, [in] IDANumber * z_2, [out, retval] IDAPoint3 * * ret_3) ;

        HRESULT Point3 ([in] double x_0, [in] double y_1, [in] double z_2, [out, retval] IDAPoint3 * * ret_3) ;

        HRESULT Vector3SphericalAnim ([in] IDANumber * xyAngle_0, [in] IDANumber * yzAngle_1, [in] IDANumber * radius_2, [out, retval] IDAVector3 * * ret_3) ;

        HRESULT Vector3Spherical ([in] double xyAngle_0, [in] double yzAngle_1, [in] double radius_2, [out, retval] IDAVector3 * * ret_3) ;

        HRESULT Point3SphericalAnim ([in] IDANumber * zxAngle_0, [in] IDANumber * xyAngle_1, [in] IDANumber * radius_2, [out, retval] IDAPoint3 * * ret_3) ;

        HRESULT Point3Spherical ([in] double zxAngle_0, [in] double xyAngle_1, [in] double radius_2, [out, retval] IDAPoint3 * * ret_3) ;

        HRESULT DotVector3 ([in] IDAVector3 * v_0, [in] IDAVector3 * u_1, [out, retval] IDANumber * * ret_2) ;

        HRESULT CrossVector3 ([in] IDAVector3 * v_0, [in] IDAVector3 * u_1, [out, retval] IDAVector3 * * ret_2) ;

        HRESULT NegVector3 ([in] IDAVector3 * v_0, [out, retval] IDAVector3 * * ret_1) ;

        HRESULT SubVector3 ([in] IDAVector3 * v1_0, [in] IDAVector3 * v2_1, [out, retval] IDAVector3 * * ret_2) ;

        HRESULT AddVector3 ([in] IDAVector3 * v1_0, [in] IDAVector3 * v2_1, [out, retval] IDAVector3 * * ret_2) ;

        HRESULT AddPoint3Vector ([in] IDAPoint3 * p_0, [in] IDAVector3 * v_1, [out, retval] IDAPoint3 * * ret_2) ;

        HRESULT SubPoint3Vector ([in] IDAPoint3 * p_0, [in] IDAVector3 * v_1, [out, retval] IDAPoint3 * * ret_2) ;

        HRESULT SubPoint3 ([in] IDAPoint3 * p1_0, [in] IDAPoint3 * p2_1, [out, retval] IDAVector3 * * ret_2) ;

        HRESULT DistancePoint3 ([in] IDAPoint3 * p_0, [in] IDAPoint3 * q_1, [out, retval] IDANumber * * ret_2) ;

        HRESULT DistanceSquaredPoint3 ([in] IDAPoint3 * p_0, [in] IDAPoint3 * q_1, [out, retval] IDANumber * * ret_2) ;

        [propget] HRESULT IdentityTransform3 ([out, retval] IDATransform3 * * ret_0) ;

        HRESULT Translate3Anim ([in] IDANumber * tx_0, [in] IDANumber * ty_1, [in] IDANumber * tz_2, [out, retval] IDATransform3 * * ret_3) ;

        HRESULT Translate3 ([in] double tx_0, [in] double ty_1, [in] double tz_2, [out, retval] IDATransform3 * * ret_3) ;

        HRESULT Translate3Rate ([in] double tx_0, [in] double ty_1, [in] double tz_2, [out, retval] IDATransform3 * * ret_3) ;

        HRESULT Translate3Vector ([in] IDAVector3 * delta_0, [out, retval] IDATransform3 * * ret_1) ;

        HRESULT Translate3Point ([in] IDAPoint3 * new_origin_0, [out, retval] IDATransform3 * * ret_1) ;

        HRESULT Scale3Anim ([in] IDANumber * x_0, [in] IDANumber * y_1, [in] IDANumber * z_2, [out, retval] IDATransform3 * * ret_3) ;

        HRESULT Scale3 ([in] double x_0, [in] double y_1, [in] double z_2, [out, retval] IDATransform3 * * ret_3) ;

        HRESULT Scale3Rate ([in] double x_0, [in] double y_1, [in] double z_2, [out, retval] IDATransform3 * * ret_3) ;

        HRESULT Scale3Vector ([in] IDAVector3 * scale_vec_0, [out, retval] IDATransform3 * * ret_1) ;

        HRESULT Scale3UniformAnim ([in] IDANumber * uniform_scale_0, [out, retval] IDATransform3 * * ret_1) ;

        HRESULT Scale3Uniform ([in] double uniform_scale_0, [out, retval] IDATransform3 * * ret_1) ;

        HRESULT Scale3UniformRate ([in] double uniform_scale_0, [out, retval] IDATransform3 * * ret_1) ;

        HRESULT Rotate3Anim ([in] IDAVector3 * axis_0, [in] IDANumber * angle_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT Rotate3 ([in] IDAVector3 * axis_0, [in] double angle_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT Rotate3Rate ([in] IDAVector3 * axis_0, [in] double angle_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT Rotate3Degrees ([in] IDAVector3 * axis_0, [in] double angle_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT Rotate3RateDegrees ([in] IDAVector3 * axis_0, [in] double angle_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT XShear3Anim ([in] IDANumber * a_0, [in] IDANumber * b_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT XShear3 ([in] double a_0, [in] double b_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT XShear3Rate ([in] double a_0, [in] double b_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT YShear3Anim ([in] IDANumber * c_0, [in] IDANumber * d_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT YShear3 ([in] double c_0, [in] double d_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT YShear3Rate ([in] double c_0, [in] double d_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT ZShear3Anim ([in] IDANumber * e_0, [in] IDANumber * f_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT ZShear3 ([in] double e_0, [in] double f_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT ZShear3Rate ([in] double e_0, [in] double f_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT Transform4x4AnimEx ([in] LONG m_0size, [in,size_is(m_0size)] IDANumber * m_0[], [out, retval] IDATransform3 * * ret_1) ;

        HRESULT Transform4x4Anim ([in] VARIANT m_0, [out, retval] IDATransform3 * * ret_1) ;

        HRESULT Compose3 ([in] IDATransform3 * a_0, [in] IDATransform3 * b_1, [out, retval] IDATransform3 * * ret_2) ;

        HRESULT Compose3ArrayEx ([in] LONG xfs_0size, [in,size_is(xfs_0size)] IDATransform3 * xfs_0[], [out, retval] IDATransform3 * * ret_1) ;

        HRESULT Compose3Array ([in] VARIANT xfs_0, [out, retval] IDATransform3 * * ret_1) ;

        HRESULT LookAtFrom ([in] IDAPoint3 * to_0, [in] IDAPoint3 * from_1, [in] IDAVector3 * up_2, [out, retval] IDATransform3 * * ret_3) ;

        [propget] HRESULT IdentityTransform2 ([out, retval] IDATransform2 * * ret_0) ;

        HRESULT Translate2Anim ([in] IDANumber * Tx_0, [in] IDANumber * Ty_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT Translate2 ([in] double Tx_0, [in] double Ty_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT Translate2Rate ([in] double Tx_0, [in] double Ty_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT Translate2Vector ([in] IDAVector2 * delta_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Translate2Point ([in] IDAPoint2 * pos_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Scale2Anim ([in] IDANumber * x_0, [in] IDANumber * y_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT Scale2 ([in] double x_0, [in] double y_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT Scale2Rate ([in] double x_0, [in] double y_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT Scale2Vector2 ([in] IDAVector2 * obsoleteMethod_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Scale2Vector ([in] IDAVector2 * scale_vec_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Scale2UniformAnim ([in] IDANumber * uniform_scale_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Scale2Uniform ([in] double uniform_scale_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Scale2UniformRate ([in] double uniform_scale_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Rotate2Anim ([in] IDANumber * angle_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Rotate2 ([in] double angle_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Rotate2Rate ([in] double angle_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Rotate2Degrees ([in] double angle_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Rotate2RateDegrees ([in] double angle_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT XShear2Anim ([in] IDANumber * arg_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT XShear2 ([in] double arg_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT XShear2Rate ([in] double arg_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT YShear2Anim ([in] IDANumber * arg_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT YShear2 ([in] double arg_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT YShear2Rate ([in] double arg_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Transform3x2AnimEx ([in] LONG m_0size, [in,size_is(m_0size)] IDANumber * m_0[], [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Transform3x2Anim ([in] VARIANT m_0, [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Compose2 ([in] IDATransform2 * a_0, [in] IDATransform2 * b_1, [out, retval] IDATransform2 * * ret_2) ;

        HRESULT Compose2ArrayEx ([in] LONG xfs_0size, [in,size_is(xfs_0size)] IDATransform2 * xfs_0[], [out, retval] IDATransform2 * * ret_1) ;

        HRESULT Compose2Array ([in] VARIANT xfs_0, [out, retval] IDATransform2 * * ret_1) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\tools\toolsrc\quadgrid\quadgrid.cpp ===
/*******************************************************************************
This program generates a gridded quadrilateral of given dimensions, and writes
the result as a VRML 1.0 or X-file formatted output stream.  The resultant
quadrilateral is in the XY plane, going from [-1,-1] to [+1,+1].
*******************************************************************************/

#include <stdio.h>
#include <stdlib.h>


void WriteVRML1 (int nrows, int ncols);
void WriteXFILE (int nrows, int ncols);

inline void print (char *string) { fputs (string, stdout); }



/*****************************************************************************
*****************************************************************************/

int main (int argc, char *argv[])
{
    enum { VRML, XFILE } filetype = VRML;

    int nrows = 0,
        ncols = 0;

    int argi;
    for (argi=1;  argi < argc;  ++argi)
    {
        if ((argv[argi][0] == '-') && (tolower(argv[argi][1]) == 'x'))
        {   filetype = XFILE;
            continue;
        }

        if (nrows == 0)
            nrows = atoi (argv[argi]);
        else
            ncols = atoi (argv[argi]);
    }

    if (nrows <= 0)
    {   fputs
        (   "quadgrid:  Generates VRML1 or X-file gridded quadrilateral\n"
            "Usage:     quadgrid [-x] <rows> [columns]\n"
            "\n"
            "If [columns] is omitted, quadgrid uses the number of rows.\n"
            "Use the -x option to generate X files.\n\n",
            stderr
        );
        exit (-1);
    }

    if (ncols == 0)
        ncols = nrows;

    if (filetype == VRML)
        WriteVRML1 (nrows, ncols);
    else
        WriteXFILE (nrows, ncols);

    return 0;
}



/*****************************************************************************
This procedure writes out a grid in VRML 1.0 format.
*****************************************************************************/

void WriteVRML1 (int nrows, int ncols)
{
    // VRML 1.0 Header

    printf (
        "#VRML V1.0 ascii\n\n"
        "Separator {\n"
        "Info { string "
            "\"%d x %d gridded quadrilateral generated by quadgrid.\""
        " }\n",
        nrows, ncols
    );

    // Write out the vertex coordinates.

    print ("\nCoordinate3 { point [\n");

    //   N   2N        3N     ... (N+1)(M+1)-1  This is the vertex indexing
    //   :    :         :              :        for the generated grid layout.
    //   3  (N+1)+3  2(N+1)+3 ...   M(N+1)+3    This contains (N+1)(M+1)
    //   2  (N+1)+2  2(N+1)+2 ...   M(N+1)+2    vertices, NM quadrilaterals,
    //   1  (N+1)+1  2(N+1)+1       M(N+1)+1    and 2NM triangles.
    //   0  (N+1)    2(N+1)   ...   M(N+1)

    int row, col;

    for (col=0;  col <= ncols;  ++col)
    {   for (row=0;  row <= nrows;  ++row)
        {   printf ("\t% g\t% g\t0,\n",
                (((col / double(ncols)) * 2) - 1),
                (((row / double(nrows)) * 2) - 1));
        }
    }

    print ("] } # Coordinate3\n");

    // Write out the texture coordinates.

    print ("\nTextureCoordinate2 { point [\n");

    for (col=0;  col <= ncols;  ++col)
    {   for (row=0;  row <= nrows;  ++row)
        {   printf ("\t%g\t%g,\n",
                (col / double (ncols)),
                (row / double (nrows)));
        }
    }

    print ("] } # TextureCoordinate2\n");

    // Write out the normal vectors.

    print
    (   "\nNormal { vector [0 0 1] }\n"
        "NormalBinding { value OVERALL }\n"
    );

    // Lay out triangles column by column.

    print ("\nIndexedFaceSet { coordIndex [\n");

    int left  = 0;         // Lower Left  Vertex Index
    int right = 1+nrows;   // Lower Right Vertex Index

    for (col=0;  col < ncols;  ++col, ++left, ++right)
    {   for (row=0;  row < nrows;  ++row, ++left, ++right)
        {   printf ("\t%d,\t%d,\t%d,\t-1,\n", left, right, right+1);
            printf ("\t%d,\t%d,\t%d,\t-1,\n", left, right+1, left+1);
        }
    }

    // Epilogue

    print
    (   "] } # IndexedFaceSet\n"
        "\n} # Separator\n"
    );
}



/*****************************************************************************
This procedure writes out a grid in X-file format.
*****************************************************************************/

void WriteXFILE (int nrows, int ncols)
{
    int nverts = (nrows+1) * (ncols+1);

    // Header

    printf
    (   "xof 0302txt 0032\n\n"
        "# %d x %d gridded quadrilateral generated by 'quadgrid'\n\n"
        "Header { 1;0;1; }\n\n"
        "Mesh {\n\n",
        nrows, ncols
    );

    // Write out the vertex coordinates.

    print ("# Vertex Coordinates\n\n");

    //   N   2N        3N     ... (N+1)(M+1)-1  This is the vertex indexing
    //   :    :         :              :        for the generated grid layout.
    //   3  (N+1)+3  2(N+1)+3 ...   M(N+1)+3    This contains (N+1)(M+1)
    //   2  (N+1)+2  2(N+1)+2 ...   M(N+1)+2    vertices, NM quadrilaterals,
    //   1  (N+1)+1  2(N+1)+1       M(N+1)+1    and 2NM triangles.
    //   0  (N+1)    2(N+1)   ...   M(N+1)

    printf ("%d;\n", nverts);

    int row, col;

    for (col=0;  col <= ncols;  ++col)
    {
        for (row=0;  row <= nrows;  ++row)
        {
            if (col || row) print (",\n");

            printf ("% f; % f; 0.0;",
                (((col / double(ncols)) * 2) - 1),
                (((row / double(nrows)) * 2) - 1));
        }
    }

    print (";\n\n");

    // Face Coordinate Indices

    printf ("# Faces\n\n%d;\n", 2 * nrows * ncols);

    int left  = 0;         // Lower Left  Vertex Index
    int right = 1+nrows;   // Lower Right Vertex Index

    for (col=0;  col < ncols;  ++col, ++left, ++right)
    {   for (row=0;  row < nrows;  ++row, ++left, ++right)
        {   if (row || col) print (",\n");
            printf ("3;%4d,%4d,%4d;,\n", left, right+1, right);
            printf ("3;%4d,%4d,%4d;",    left, left+1,  right+1);
        }
    }

    print (";\n\n");

    // Write out the texture coordinates.

    printf ("MeshTextureCoords { \n\t%d;\n", nverts);

    for (col=0;  col <= ncols;  ++col)
    {   for (row=0;  row <= nrows;  ++row)
        {   printf ("%s\t%.4f; %.4f;",
                ((row || col) ? ",\n" : ""),
                (col / double (ncols)),
                (row / double (nrows)));
        }
    }

    print (";\n}\n\n");

    // Write out default material

    print
    (   "MeshMaterialList {\n"
        "	# Diffuse White\n"
        "	1;1;0;;\n"
        "	Material {\n"
        "		1.0; 1.0; 1.0; 1.0;;\n"
        "		1.0;\n"
        "		0.0; 0.0; 0.0;\n"
        "		0.0; 0.0; 0.0;\n"
        "	}\n"
        "}\n\n"
    );

    // Write out the normal vectors.

    print ("MeshNormals {\n\t1;\n\t0.0; 0.0; -1.0;;\n\n");

    // Face Normal Indices

    printf ("\t%d;\n", 2 * nrows * ncols);

    int i;
    for (i=0;  i < (2*nrows*ncols);  ++i)
        printf ("%s\t3;0,0,0;", (i ? ",\n" : ""));

    print (";\n}\n");

    // Epilogue

    print ("\n}\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\tools\toolsrc\mkdep\mkdep.c ===
/*-----------------------------------------------------------------------------
Name:   mkdep.c

Description:
Determine file dependencies

To Build:
    cl /Ox /W3 mkdep.c

Revision History:
brendand (8/3/94) - Taken from GaryBu, merged files into a single unit
brendand (8/4/94) - Added .PCH and wild-card support
-----------------------------------------------------------------------------*/

// Includes -------------------------------------------------------------------
#define LINT_ARGS
#include    <assert.h>
#include    <ctype.h>
#include    <io.h>
#include    <malloc.h>
#include    <process.h>
#include    <stdlib.h>
#include    <stdio.h>
#include    <string.h>

// Types and Constants --------------------------------------------------------
#ifndef CDECL
#define CDECL
#endif
#ifndef CONST
#define CONST
#endif

#ifndef STATIC
#define STATIC static
#endif

#ifndef Assert
#define Assert(f)       assert(f)
#endif

#define TRUE 1
#define FALSE 0

#define FOREVER while(1)
#define BLOCK
#define VOID    void

#ifdef D86
#define szROText        "rt"
#define szRWText        "r+t"
#define szWOText        "wt"
#define szROBin         "rb"
#define szRWBin         "r+b"
#define szWOBin         "wb"
#endif

typedef int                             BOOL;
typedef char*                   SZ;
typedef unsigned char   BYTE;
typedef BYTE*                   PB;
typedef unsigned short  WORD;
typedef WORD*                   PW;
typedef unsigned long   LONG;

#define lpbNull ((PB) NULL)

#define LOWORD(l)       ((WORD)l)
#define HIWORD(l)       ((WORD)(((LONG)l >> 16) & 0xffff))
#define LOBYTE(w)       ((BYTE)w)
#define HIBYTE(w)       (((WORD)w >> 8) & 0xff)
#define MAKEWORD(l,h)   ((WORD)(l)|((WORD)(h)<<8))
#define MAKELONG(l,h)   ((long)(((unsigned)l)|((unsigned long)((unsigned)h))<<16))

/* Args Record - MarkArgs, UnmarkArgs */
typedef struct
    {
    int cargArr;
    SZ *pszArr;
    } ARR;

/* drive usage types - getdt */
#define dtNil           0
#define dtLocal         1
#define dtUserNet       2

/* File attributes  - getatr, setatr */
#define atrError                0xffff
#define atrReadOnly             FILE_READONLY
#define atrHidden               FILE_HIDDEN
#define atrSystem               FILE_SYSTEM
#define atrVolume               0x08
#define atrDirectory    FILE_DIRECTORY
#define atrArchive              FILE_ARCHIVED

/* Macro for defining Linked list inertion */
#define AddToList(new,head,tail,link,null) { if(head==null) head=new; else tail->link = new; tail=new; new->link=null; }

/* & deletion */
#define DeleteFromList(item,head,tail,link,null,prev) { if(prev==null) head=item->link; else prev->link = item->link; \
if (tail==item) tail = prev; }

/* for MtimeOfFile() */
typedef long MTIME;
#define mtimeError ((MTIME) -1L)

typedef enum
    {
    langUnknown,
    langC,
    langAsm,
    langRC
    } LANG;

typedef struct _di
    {
    struct _di      *pdiNext;       /* next in list */
    char            *szPath;        /* path name */
    char            *szName;        /* full name */
    BOOL            fPathIsStd; /* name from standard includes (-I) */
    } DI;   /* dir info */

typedef struct _lk
    {
    struct _lk      *plkNext;       /* next in list */
    struct _fi      *pfi;           /* file info for link */
    } LK;   /* File link */

typedef struct _fi
    {
    struct _fi      *pfiNext;       /* single link */
    char            *szPath;        /* path name */
    char            *szName;        /* full name */
    LANG            lang;           /* language */
    struct _lk      *plkHead;       /* included list */
    struct _lk      *plkTail;       /* included list */
    unsigned        fIgnore:1;      /* ignore: either -X and std include or -x <file> */
    unsigned        cout:15;        /* output count */
    } FI;   /* file info */

typedef VOID (*PFN_ENUM)(char *, char *);

#define iszIncMax 40
char*   szPrefix = "";
char*   szSuffix = ".$O";

#define rmj                     1
#define rmm                     1
#define rup                     0
#define szVerName       "Forms3 Version"

// Globals --------------------------------------------------------------------
DI*     pdiHead = NULL; /* stack of directories of files included */
FI*     pfiHead = NULL;
FI*     pfiTail = NULL;
WORD    coutCur = 0;
int     cchLine;

int     iszIncMac = 0;
char*   rgszIncPath[iszIncMax];     // actual path
char*   rgszIncName[iszIncMax];     // name to output

BOOL    fVerbose       = FALSE;
BOOL    fReplacePrefix = FALSE;
BOOL    fNoGenHeaders  = FALSE;      // True if all header files must be present
BOOL    fIgnoreStd = FALSE;          // True if std include files should be ignored
BOOL    fUseCurDir = FALSE;          // When True: if a file doesn't exist and
                                     //   we are going to print a dependency for
                                     //   it, use the current directory rather
                                     //   than the directory of the source file.
char*   szPrintDir = NULL;           // If set, only print files in this dir.
char*   szPCHFile = NULL;            // .H which marks end of .PCH


// Prototypes -----------------------------------------------------------------

int     main(int, char**);
VOID    Usage(void);

char*   SzIncludesC(char *, BOOL *), *SzIncludesAsm(char *), *SzIncludesRC(char *, BOOL *);
FI*     PfiDependFn(char *, char *, BOOL, LANG, BOOL);
FI*     PfiLookup(char *, char *, LANG);
FI*     PfiAlloc(char *, char *, BOOL, LANG);
VOID    FreeFi(FI *);
VOID    AllocLk(FI *, FI *);
VOID    FreeAllLk(FI *);
VOID    StartReport(void);
VOID    ContinueReport(void);
VOID    EndReport(void);
VOID    EndLine(void);
VOID    Indent(void);
VOID    Report(char *, char *);
VOID    PrReverse(char *, char *);
BOOL    FPrintFi(FI *);
VOID    EnumChildren(FI *, PFN_ENUM, char *);
VOID    Process(char *, BOOL);
VOID    Fatal(char *);
SZ      SzTransEnv(SZ);
VOID    NormalizePath(SZ);
VOID    MakeName(SZ, SZ, SZ);
VOID    CopyPath(SZ, SZ);
VOID    PushDir(char *, char *, BOOL);
VOID    PopDir(void);
DI*     PdiFromIdi(int);
int     AddIncludeDir(char *);

VOID
Fatal(sz)
char *sz;
    {
    fprintf(stderr, "mkdep: error: %s\n", sz);
    exit(1);
    }


VOID
Usage()
    {
    if (rup == 0)
        fprintf(stderr, "Mkdep V%d.%02d\n", rmj, rmm);
    else
        fprintf(stderr, "Mkdep V%d.%02d.%02d\n", rmj, rmm, rup);

    fprintf(stderr,
        "usage: mkdep [-v] [-r] [-n] [-X] [-C] [-I includeDir]*\n"
         "\t[-p prefix] [-P replace_prefix] [-s suffix] \n"
         "\t[-d file]* [-D printDir] files\n\n"
         "\t-v  Verbose\n"
         "\t-r  Reverse the dependencies that are output\n"
         "\t-n  Don't emit dependencies on files that don't now exist\n"
         "\t-X  Search, but don't print standard includes\n"
         "\t-C  If file doesn't exist, use .\\ not the directory of including file\n"
         "\t-I  Include directory to search for <> includes\n"
         // "\t-J  Search include directories from the INCLUDE environment variable\n"
         "\t-p  Prefix for all target-file names\n"
         "\t-P  Ditto, but first remove existing prefix from name\n"
         "\t-s  Suffix for all target-file names (default %s)\n"
         "\t-d  Search, but don't print named file\n"
         "\t-D  Only print files which are in named dir\n"
         "\t-h  Header which marks the end of the .PCH\n\n"
         "A response file can be used by specifying '@filename' as an option.\n"
             , szSuffix);
    exit(1);
    }


char **CmdArgs;
int    cArgs;
int    CurArg = 1;
FILE  *pfileResponse = NULL;
char   achBuf[256];
char * pBuf = NULL;

char *
GetNextArg()
{
    char *pszTokens = " \t\n";

    if (pfileResponse)
    {
        char * psz;

        if (pBuf)
        {
            pBuf = strtok(NULL, pszTokens);

            if (pBuf)
                return pBuf;
        }

        do
        {
            psz = fgets(achBuf, 256, pfileResponse);
            if (psz == NULL)
            {
                fclose(pfileResponse);
                pfileResponse = NULL;
            }
            else if (achBuf[strlen(achBuf)-1] != '\n')
            {
                fclose(pfileResponse);
                Fatal("Line too long in response file. Must be less "
                        "than 256 characters.");
            }
            else
            {
                pBuf = strtok(achBuf, pszTokens);

                if (pBuf)
                    return pBuf;
            }
        } while (psz && !pBuf);
    }

    if (CurArg >= cArgs)
        return NULL;

    return CmdArgs[CurArg++];
}

#define FSwitchCh(ch)   ((ch)=='-' || (ch) == '/' || (ch) == '@')

int
main(iszMax, rgsz)
int iszMax;
char *rgsz[];
    {
    BOOL    fReverse = FALSE;
    char   *pszArg;
    int i = 0;

    if (iszMax == 1)
        Usage();

    CmdArgs = rgsz;
    cArgs   = iszMax;

    /* Parse command line switches.
     */
    while (((pszArg = GetNextArg()) != NULL) && FSwitchCh(pszArg[0]))
        {
        char chSwitch = pszArg[1];

        if (pszArg[0] == '@')
        {
            if (pszArg[1] == '\0')
                Usage();

            pfileResponse = fopen(&pszArg[1], "rt");
            if (!pfileResponse)
            {
                fprintf(stderr, "mkdep: error: Could not open response file "
                        "'%s'.\n", &pszArg[1]);
                return(1);
            }

            continue;
        }

        // fprintf(stderr, "Arg %d: '%s' ", i++, pszArg);

        switch (chSwitch)
            {
        case 'v':
            fVerbose = TRUE;
            break;
        case 'r':
            fReverse = TRUE;
            break;
        case 'n':
            fNoGenHeaders = TRUE;
            break;
        case 'x':
        case 'X':
            fIgnoreStd = TRUE;
            break;
        case 'C':
            fUseCurDir = TRUE;
            break;

#if 0
        case 'J':
            {
            SZ szInc = getenv("INCLUDE");
            if (szInc)
                {
                char    rgszDir[iszIncMax][_MAX_FNAME];
                int     nDirs,i;
                char*   psz;

                // Convert embedded semicolons to blanks
                for (psz=szInc; *psz; psz++)
                    if (*psz == ';')
                        *psz = ' ';

                /* This is very bogus! a dynamic way of reading the dirs
                   should be done so up to iszIncMax dirs can be read. Also,
                   AddIncludeDir does not copy the strings and rgszDir is
                   an automatic variable!
                */
                fprintf(stderr, "-J option: only first 16 include dirs parsed.\n");
                nDirs =
                     sscanf(szInc,
                       "%s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s",
                       rgszDir[0],rgszDir[1],rgszDir[2],rgszDir[3],rgszDir[4],
                       rgszDir[5],rgszDir[6],rgszDir[7],rgszDir[8],rgszDir[9],
                       rgszDir[10],rgszDir[11],rgszDir[12],rgszDir[13],
                       rgszDir[14],rgszDir[15]);
                for (i = 0; i < nDirs; i++)
                    AddIncludeDir(rgszDir[i]);
                }
            else
                fprintf(stderr,"-J option: INCLUDE variable not set.\n");
            }
            break;
#endif

        case 's':
        case 'P':
        case 'p':
        case 'I':
        case 'd':
        case 'D':
        case 'h':
            {
            char *sz = &pszArg[2];

            if (sz[0] == '\0')
                {
                /* Allow "-I includefile"
                 * and   "-IincludeFile"
                 */
                pszArg = GetNextArg();
                if (!pszArg)
                    Usage();

                sz = pszArg;
                }

            // fprintf(stderr, "File: '%s'.", sz);

            sz = strdup(sz);

            switch (chSwitch)
                {
            case 's':
                szSuffix = sz;
                break;
            case 'P':
                fReplacePrefix = TRUE;
                // Drop through
            case 'p':
                szPrefix = sz;
                break;
            case 'I':
                AddIncludeDir(sz);
                break;
            case 'd':
                {
                FI *pfi;

                // exlude file given
                // NOTE: the -C option if given, must appear before now

                NormalizePath(sz);

                if ((pfi = PfiDependFn(SzTransEnv(sz), sz, FALSE, langUnknown, FALSE)) != NULL)
                    // file existed; ignore it
                    pfi->fIgnore = TRUE;
                else
                    // file doesn't exist, create FI
                    (void)PfiAlloc(SzTransEnv(sz), sz, TRUE, langUnknown);
                break;
                }
            case 'D':
                /* only print files from given directory */
                NormalizePath(sz);
                szPrintDir = sz;
                break;
            case 'h':
                szPCHFile = sz;
                break;
                }
            }
            break;

        default:
            Usage();
            break;
            }

        // fprintf(stderr, "\n");
        }

    while (pszArg)
        {
        long                hf;
        char                szPath[_MAX_DIR];
        char                szName[_MAX_PATH];
        struct _finddata_t  fd;

        // fprintf(stderr, "Reading path '%s' - ", pszArg);

        NormalizePath(pszArg);
        CopyPath(szPath, pszArg);

        // fprintf(stderr, "'%s\\%s'\n", szPath, pszArg);

        hf = _findfirst(pszArg, &fd);

        if (hf > -1)
            {
            do
                {
                MakeName(szName, szPath, fd.name);
                // fprintf(stderr, "     -- '%s'\n", szName);
                Process(szName, fReverse);
                }
            while (!_findnext(hf, &fd));
            _findclose(hf);
            }
//      else
//          fprintf(stderr, "Unable to find source file: %s\n", pszArg);

        pszArg = GetNextArg();
        }
    return( 0 );
    }

/*****************************************************************************/
/* standard dependency report */

VOID
StartReport()
/*
  -- prepare for a new line
*/
    {
    cchLine = 77;
    }

VOID
EndLine()
/*
  -- Make it so that the next Report starts on a new line.
 */
    {
    cchLine = 0;
    }


VOID
ContinueReport()
/*
  -- Output continuation character, new line, then indent.
 */
    {
    printf(" \\\n");
    StartReport();
    Indent();
    }

VOID
EndReport()
/*
  -- Finish off this line.
 */
    {
    printf("\n\n");
    }

VOID
Indent()
/*
  -- Indent a tab at the beginning of a line.
 */
    {
    printf("\t");
    cchLine -= 8;           /* for tab */
    }


VOID
Report(sz, szParm)
/*
  -- report string
  -- if too many characters extend line
*/
register char * sz;
char *  szParm;         /* ignored */
    {
    int cch = strlen(sz);

    if (cch > cchLine)
        {
        ContinueReport();
        while (isspace(sz[0]))
            {
            sz++;
            cch--;
            }
        }

    while (*sz != '\0')
        {
        if (*sz == '#')
            {
            putchar('\\');          /* escape any # in path */
            cch++;
            }
        putchar(*sz);
        sz++;
        }
    cchLine -= cch;
    }


/*****************************************************************************/
/* Reverse dependency printing */

VOID
PrReverse(szHdr, szSource)
/*
  -- report reverse dependency
*/
char *  szHdr;
char *  szSource;
    {
    printf("%s: %s\n", szHdr, szSource);
    }


/*****************************************************************************/

BOOL FPrintFi(pfi)
/*
  -- returns true if we should print this file; false if ignore; false if
     szPrintDir is != 0 and it is a prefix of szName.  The current directory
     is a zero length string and is handled specially
*/
FI *pfi;
    {
    if (pfi->fIgnore)
        return FALSE;

    if (szPrintDir == NULL)
        return TRUE;

    if (*szPrintDir == '\0')
        // only print current directory (check for / in name)
        return strchr(pfi->szName, '/') == 0;
    else
        // print if szPrintDir is prefix of name
        return strncmp(szPrintDir, pfi->szName, strlen(szPrintDir)) == 0;
    }


VOID
EnumChildren(pfi, pfnDo, szParm)
/*
  -- enumerate children, call *pfnDo for each element
*/
FI *    pfi;
PFN_ENUM pfnDo;
char *  szParm;
    {
    LK *plk;

    for (plk = pfi->plkHead; plk != NULL; plk = plk->plkNext)
        {
        FI *pfi = plk->pfi;

        if (pfi->cout < coutCur)
            {
            /* Mark that we've visited this node, to prevent
             * infinite recursion should we have a self referential
             * dependency graph.
             */
            pfi->cout = coutCur;

            if (FPrintFi(pfi))
                {
                if (szParm == NULL)
                    (*pfnDo)(" ", szParm);
                (*pfnDo)(pfi->szName, szParm);
                }

            // recurse on nested includes; may include a non-standard includes
            EnumChildren(pfi, pfnDo, szParm);
            }
        }
    }



VOID
Process(szPath, fReverse)
/*
  -- process a file
  -- reverse => show headers as depending on files
*/
char *  szPath;                 // path name to file
BOOL    fReverse;
    {
    FI *    pfi;

    strlwr(szPath);

    /* Build a list of all dependencies. */
    pfi = PfiDependFn(szPath, szPath, FALSE, langUnknown, FALSE);

    if (pfi == NULL)
        {
        if (fVerbose)
            fprintf(stderr, "mkdep: warning: file %s ignored\n", szPath);
        }
    else if (pfi->plkHead != NULL)
        {
        /* file depends on something */

        if (!fReverse)
            {
            /* normal dependencies */
            char *  pch;

            /* truncate any suffix */
            pch = strrchr(szPath, '.');
            if (pch)
                {
                if (strchr(pch, '/') || strchr(pch, '\\'))
                    pch = NULL;
                }
            if (pch != NULL)
                *pch = '\0';

            StartReport();

            Report(szPrefix, NULL);
            if (fReplacePrefix)
                {
                /* prefix replaces any name prefix */
                char *  szName = szPath;

                while (*szPath != '\0')
                    {
                    if (*szPath == '\\' || *szPath == '/')
                        szName = szPath+1;
                    szPath++;
                    }
                Report(szName, NULL);
                }
            else
                {
                Report(szPath, NULL);
                }
            Report(szSuffix, NULL);
            Report(" :", NULL);

            EndLine();

            coutCur++;
            EnumChildren(pfi, Report, NULL);

            EndReport();
            }
        else
            {
            /* reverse dependencies */
            coutCur++;
            EnumChildren(pfi, PrReverse, szPath);
            }
        }

    if (pfi != NULL)
        // free top level FI (presumably for .c/.asm file which won't be needed)
        FreeFi(pfi);
    }



FI *
PfiDependFn(szPath, szName, fPathIsStd, lang, fIsPCHFile)
/*
  -- given a file name & language, return a filled in FI
  -- return NULL if error
*/
char *  szPath;                 // path name to file
char *  szName;                 // official name of file
BOOL    fPathIsStd;             // path portion of szPath is from standard includes (-I)
LANG    lang;                   // propagate parent language
BOOL    fIsPCHFile;             // Is .PCH marker file
    {
    FILE *  pfile;
    char    rgch[256];
    char *  sz;
    char *  szSuffix;
    FI *    pfi;

    /* first check to see if already in list */
    if ((pfi = PfiLookup(szPath, szName, lang)) != NULL)
        return pfi;

    if (lang != langUnknown)
        {
            /* do nothing -- keep old language */
        }
    else if ((szSuffix = strrchr(szPath, '.')) == NULL)
        return NULL;
    else if (strcmp(szSuffix, ".asm") == 0 || strcmp(szSuffix, ".inc") == 0)
        lang = langAsm;
    else if (strcmp(szSuffix, ".rc") == 0)
        lang = langRC;
    else
        lang = langC;

    if ((pfile = fopen(szPath, "rt")) == NULL)
    {
        // fprintf(stderr, "Could not open file '%s'.\n", szPath);
        return NULL;
    }

    pfi = PfiAlloc(szPath, szName, fPathIsStd && fIgnoreStd, lang);

    if (lang == langRC)
    {
        //
        // Make sure we don't try to parse binary files - major waste of time!
        //
        static char *aszBinary[] = { ".ico", ".sqz", ".bmp", ".tlb", ".cur",
                                     ".odg", ".ppg", ".otb" };
        static int cBinary = sizeof(aszBinary)/sizeof(aszBinary[0]);
        int    i;

        if (!szSuffix)
        {
            if ((szSuffix = strrchr(szPath, '.')) == NULL)
                goto Cleanup;
        }

        for (i = cBinary; i && stricmp(szSuffix, aszBinary[i-1]); i--)
            ;

        if (i != 0)
            goto Cleanup;
    }

    // Don't search inside of the .PCH marker file
    if (!fIsPCHFile)
        {

        BLOCK
            {
            /* Push the directory of this file on the list of directories for
             * include searches.  Save an indication as to whether this include is
             * from a standard place.
             */
            char    szPathT[256];
            char    szNameT[256];

            CopyPath(szPathT, szPath);
            CopyPath(szNameT, szName);

            PushDir(szPathT, szNameT, fPathIsStd);
            }

        while ((sz = fgets(rgch, 256, pfile)) != NULL)
            {
            char *  szInc;
            BOOL    fThisDirNew = FALSE;    /* must be in this directory */
            int     cch = strlen(sz);

            if (cch < 2)
                continue;
            if (sz[cch-1] == '\n')
                sz[cch-1] = '\0';  /* note : will truncate long lines */

            if ((lang == langC && (szInc = SzIncludesC(sz, &fThisDirNew)) != NULL) ||
                (lang == langAsm && (szInc = SzIncludesAsm(sz)) != NULL) ||
                (lang == langRC && (szInc = SzIncludesRC(sz, &fThisDirNew)) != NULL))
                {
                FI *    pfiNew = NULL;
                char    szPathNew[256];
                char    szNameNew[256];
                BOOL    fIsPCH;

                fIsPCH = (szPCHFile && !_stricmp(szInc, szPCHFile));

                /* if file can be found in current directory, cycle
                 * through all current directories possible.
                 */
                if (fThisDirNew)
                    {
                    int     idi;
                    DI *    pdi;

                    for (idi = 0; (pdi = PdiFromIdi(idi)) != NULL; idi++)
                        {
                        MakeName(szPathNew, pdi->szPath, szInc);
                        MakeName(szNameNew, pdi->szName, szInc);

                        /* Do recursive call to include file */
                        pfiNew = PfiDependFn(szPathNew, szNameNew, pdi->fPathIsStd, lang, fIsPCH);

                        /* If we found it, get out of loop */
                        if (pfiNew != NULL)
                            break;
                        }
                    }

                /* If the file hasn't been found yet, look for it
                 * in the standard include directories.
                 */
                if (pfiNew == NULL)
                    {
                    int     isz;

                    for (isz = 0; isz < iszIncMac; isz++)
                        {
                        MakeName(szPathNew, rgszIncPath[isz], szInc);
                        MakeName(szNameNew, rgszIncName[isz], szInc);

                        /* Do recursive call to include file */
                        pfiNew = PfiDependFn(szPathNew, szNameNew, TRUE, lang, fIsPCH);

                        /* If we found it, mark it and get out of loop */
                        if (pfiNew != NULL)
                            break;
                        }
                    }

                /* The file doesn't exist anywhere.  If it was included
                 * with quote marks and the user didn't specify -n, we
                 * will pretend the file is in the same directory as
                 * the file that's including it.
                 */
                if (pfiNew == NULL && fThisDirNew && !fNoGenHeaders)
                    {
                    BOOL fPathIsStd;

                    if (fUseCurDir)
                        {
                        MakeName(szPathNew, ".\\", szInc);
                        MakeName(szNameNew, ".\\", szInc);
                        fPathIsStd = FALSE;

                        /* Look for -d names */
                        if ((pfiNew = PfiLookup(szPathNew, szNameNew,lang)) == NULL)
                            pfiNew = PfiAlloc(szPathNew, szNameNew, FALSE, lang);
                        }
                    else
                        {
                        DI *    pdi;

                        pdi = PdiFromIdi(0);
                        if (pdi == NULL)
                            Fatal("mkdep: internal error");
                        MakeName(szPathNew, pdi->szPath, szInc);
                        MakeName(szNameNew, pdi->szName, szInc);

                        // in this case we already look through existing FI list

                        pfiNew = PfiAlloc(szPathNew, szNameNew,
                            pdi->fPathIsStd && fIgnoreStd, lang);
                        }
                    }

                // If the .PCH marker file has been found, truncate all preceeding .H files
                if (pfiNew && fIsPCH)
                    {
                    FreeAllLk(pfi);
                    FreeFi(pfi->pfiNext);
                    pfi->pfiNext = NULL;
                    }

                /* If we found the file, add it to the list of files */
                if (pfiNew != NULL)
                    {
                    /* add if not already in list */
                    LK *    plk;
                    BOOL    fRedundant = FALSE;

                    for (plk = pfi->plkHead; plk != NULL;
                        plk = plk->plkNext)
                        {
                        if (plk->pfi == pfiNew)
                            {
                            fRedundant = TRUE;
                            break;
                            }
                        }
                    if (!fRedundant)
                        AllocLk(pfi, pfiNew);
                    }
                }
            }

        PopDir();
    }

Cleanup:
    fclose(pfile);
    return pfi;
    }



char *
SzIncludesC(sz, pfThisDir)
/*
  -- return file name of include file or NULL
  -- if returning non-NULL, set *pfThisDir if file should exist in this
    directory (i.e. #include "...").
*/
char *sz;
BOOL *pfThisDir;
    {
    char *szLine = sz;

    while (isspace(*sz))
        sz++;

    if (sz[0] == '#')
        {
        /* Allow space after '#' but before directive.
         */
        sz++;
        while (isspace(sz[0]))
            sz++;

        if (strncmp(sz, "include", 7) == 0)
            {
            /* found it */
            char *  pchEnd;

            sz += 7;
            while (isspace(*sz))
                sz++;
            if ((*sz == '<' && (pchEnd =strchr(sz+1,'>')) !=NULL) ||
                (*sz == '"' && (pchEnd =strchr(sz+1, '"')) !=NULL))
                {
                *pfThisDir = *sz == '"';
                *pchEnd = '\0';
                return sz+1;
                }
            else
                {
                fprintf(stderr, "mkdep: warning: ignoring line : %s\n", szLine);
                return NULL;
                }
            }
        }
    return NULL;
    }



char *
SzIncludesAsm(sz)
/*
  -- return file name of include file or NULL
*/
char *sz;
    {
    char *szLine = sz;

    strlwr(szLine);

    while (isspace(*sz))
        sz++;

    if (strncmp(sz, "include", 7) == 0)
        {
        /* found it */
        char *pchEnd;

        sz += 7;
        while (isspace(*sz))
            sz++;
        pchEnd = sz;
        while (*pchEnd && !isspace(*pchEnd) && *pchEnd != ';')
            pchEnd++;
        if (pchEnd == sz)
            {
            fprintf(stderr, "mkdep: warning: ignoring line : %s\n", szLine);
            return NULL;
            }
        *pchEnd = '\0';
        return sz;
        }
    return NULL;
    }

char *
SzIncludesRC(sz, pfThisDir)
/*
  -- return name of include file or resource file for an RC file
  -- if returning non-NULL, set *pfThisDir if file should exist in this
    directory (i.e. #include "...").
*/
char *sz;
BOOL *pfThisDir;
    {

    static char *aszValidTypes[] =
    {
        "CURSOR", "ICON", "RT_DOCFILE", "TYPELIB", "BITMAP"
    };
    static int cValidTypes = sizeof(aszValidTypes)/sizeof(aszValidTypes[0]);

    char   achIdent[255] = { 0 };
    char   achType[255]  = { 0 };
    char   achFile[255]  = { 0 };
    char * pch;
    int    cch;
    char * szC;
    int    n, i;

    szC = SzIncludesC(sz, pfThisDir);
    if (szC)
        return szC;

    *pfThisDir = TRUE;

    n = sscanf(sz, "%[a-zA-Z0-9_] %[a-zA-Z0-9_] %n%[a-zA-Z0-9.\"]",
               achIdent, achType, &cch, achFile);

    if (n < 3)
        return NULL;

    for (i = cValidTypes; i && stricmp(achType, aszValidTypes[i-1]); i--)
        ;

    if (i == 0)
        return NULL;

    sz += cch;

    while (isspace(*sz))
        sz++;

    sz[strlen(achFile)] = '\0';

    if (*sz == '\"')
        sz++;

    if ((pch = strrchr(sz, '\"')) != NULL)
        *pch = '\0';

    return sz;

    }



FI *
PfiLookup(szPath, szName, lang)
/*
  -- lookup name in current list of FI; if file is of an unknown language and
     lang is not, set the language of this file.
*/
char *  szPath;                 // path name to file
char *  szName;                 // official name of file
LANG    lang;                   // lang desired; langUnknown means any acceptible
    {
    FI *pfi;

    for (pfi = pfiHead; pfi != NULL; pfi = pfi->pfiNext)
        {
        if (strcmp(szPath, pfi->szPath) == 0)
            {
            /* got one */
            if (lang != langUnknown && lang != pfi->lang)
                {
                // want a specific language and that is not what the file is
                if (pfi->lang != langUnknown)
                    fprintf(stderr,
                        "mkdep: warning: language conflict for file %s\n",
                        pfi->szPath);
                else
                    pfi->lang = lang;               // was unknown, set to known
                }

            return pfi;
            }
        }

    return NULL;
    }



FI *
PfiAlloc(szPath, szName, fIgnore, lang)
/*
  -- allocate an FI
*/
char *  szPath;                 // path name to file
char *  szName;                 // official name of file
BOOL    fIgnore;                // true -> don't print this file
LANG    lang;                   // lang for file; can be langUnknown
    {
    FI *pfi;

    if ((pfi = (FI *) malloc(sizeof(FI))) == NULL ||
        (pfi->szName = strdup(szName)) == NULL ||
        (pfi->szPath = strdup(szPath)) == NULL)
        Fatal("out of memory");
    pfi->lang = lang;
    pfi->fIgnore = fIgnore;
    pfi->plkHead = pfi->plkTail = NULL;
    AddToList(pfi, pfiHead, pfiTail, pfiNext, NULL);
    pfi->cout = coutCur;
    return pfi;
    }


VOID
FreeFi(pfiFree)
/*
  -- free an FI and all associated LK and remove from FI list
*/
FI *pfiFree;
    {
    FI *pfiT, *pfiPrev;

    FreeAllLk(pfiFree);

    for (pfiT = pfiHead, pfiPrev = 0; pfiT != pfiFree; pfiPrev = pfiT, pfiT = pfiT->pfiNext)
        {
        // should find it on list
        // Assert(pfiT != NULL);
        }

    DeleteFromList(pfiFree, pfiHead, pfiTail, pfiNext, NULL, pfiPrev);

    free(pfiFree);
    }



VOID
AllocLk(pfiOwner, pfiNew)
/*
  -- allocate a LK - add to owner list - point to pfiNew
*/
FI *pfiOwner;
FI *pfiNew;
    {
    LK *plk;

    if ((plk = (LK *) malloc(sizeof(LK))) == NULL)
        Fatal("out of memory");
    plk->plkNext = NULL;
    AddToList(plk, pfiOwner->plkHead, pfiOwner->plkTail, plkNext, NULL);
    plk->pfi = pfiNew;
    }


VOID
FreeAllLk(pfi)
/*
  -- free all lk attached to FI
*/
FI *pfi;
    {
    LK *    plk;
    LK *    plkNext;

    for (plk = pfi->plkHead; plk != NULL; plk = plkNext)
        {
        plkNext = plk->plkNext;
        free(plk);
        }

    pfi->plkHead = NULL;
    pfi->plkTail = NULL;
    }



SZ
SzTransEnv(sz)
/*
  -- return a path string with optional $(...) in it
*/
SZ      sz;
    {
    SZ      szEnv;
    char *  pch;
    char    szT[256];

    if (sz[0] != '$' || sz[1] != '(')
        return sz;
    sz += 2;

    if ((pch = strchr(sz, ')')) == NULL)
        return sz;              // something wrong

    *pch = '\0';
    if ((szEnv = getenv(sz)) == NULL)
        {
        fprintf(stderr,
           "mkdep: warning: environment variable %s not defined\n");
        Fatal("incomplete path");
        }
    *pch = ')';             // restore string

    /* copy the environment variable into buffer */
    strcpy(szT, szEnv);
    strcat(szT, pch+1);             // and rest of string
    NormalizePath(szT);             // normalize again with new prefix
    return strdup(szT);
    }


VOID NormalizePath(sz)
/*
  -- convert path to a normal form in place: forward slashes, no ../, etc.
*/
char *sz;
    {
    char *pch, *pch2;

    /* change all backslashes to forward slashes */
    for (pch=sz; *pch; ++pch)
        if (*pch == '\\')
            *pch = '/';

    /* Remove ".." entries.  (The algorithm below doesn't find all
     * possible cases, but it's good enuff.)
     */
    while ((pch=strstr(sz, "/../")) != NULL)
        {
        *pch = '\0';
        pch2 = strrchr(sz, '/');
        if (pch2 != NULL && pch2[1] != '$' && pch2[1] != '.')
            memmove(pch2+1, pch+4, strlen(pch+1)+1);
        else
            {
            *pch = '/';
            break;
            }
        }

    // remove single . and leading ./
    if (sz[0] == '.')
        {
        if (sz[1] == '\0')
            sz[0] = '\0';

        else if (sz[1] == '/')
            memmove(sz, sz+2, strlen(sz)-2+1);
        }
    }


VOID
MakeName(szDest, szSrcPath, szSrcFile)
/*
  -- copy a path plus filename into a complete filename
  -- normalizes when done
*/
char *  szDest;                 // where to store complete filename
char *  szSrcPath;              // path
char *  szSrcFile;              // filename
    {
    if (szSrcFile[0] && szSrcFile[1]==':')
        {
        if (!(szSrcPath[0] && szSrcPath[1]==':') ||
            tolower(szSrcPath[0]) != tolower(szSrcFile[0]))
            {
            strcpy(szDest, szSrcFile);
            NormalizePath(szDest);
            return;
            }
        *szDest++ = *szSrcFile++;  *szDest++ = *szSrcFile++;
        }
    if (szSrcFile[0] == '/' || szSrcFile[0] == '\\')
        {
        strcpy(szDest, szSrcFile);
        NormalizePath(szDest);
        return;
        }

    strcpy(szDest, szSrcPath);
    if (szDest[0] != '\0')
        {
        char ch = szDest[strlen(szDest)-1];

        if (ch != ':' && ch != '/' && ch != '\\')
            strcat(szDest, "/");
        }
    strcat(szDest, szSrcFile);

    NormalizePath(szDest);
    }




VOID
CopyPath(szDestPath, szSrcFullName)
/*
  -- copy the path part of szSrcFullName into szDestPath
*/
char *  szDestPath;
char *  szSrcFullName;
    {
    int     ich;
    int     ichPathEnd;     // index to end of path part of szSrcFullName
    char    ch;

    /* Figure out where the path part of szSrcFullName ends and the
     * name part begins.
     */
    for (ich = ichPathEnd = 0; (ch=szSrcFullName[ich]) != 0; ++ich)
        if (ch == ':' || ch == '/' || ch == '\\')
            ichPathEnd = ich+1;

    /* Copy the path */
    for (ich = 0; ich < ichPathEnd; ++ich)
        szDestPath[ich] = szSrcFullName[ich];
    szDestPath[ich] = 0;
    }



VOID
PushDir(szPath, szName, fPathIsStd)
/*
  -- push a directory name on the stack of directories for all nested
     includes
*/
char *  szPath;                 // path name of file (e.g. "c:\foo\bar")
char *  szName;                 // official name of file (e.g. "$(INCL)")
BOOL    fPathIsStd;             // path portion of szPath is from standard includes (-I)
    {
    DI *    pdi;

    if ((pdi = malloc(sizeof(DI))) == NULL)
        Fatal("out of memory");
    pdi->szPath = strdup(szPath);
    pdi->szName = strdup(szName);
    pdi->fPathIsStd = fPathIsStd;
    /* Insert at head of list */
    pdi->pdiNext = pdiHead;
    pdiHead = pdi;
    }



VOID
PopDir(void)
/*
  -- pop a directory name from the stack of directories for all nested
     includes
*/
    {
    DI *pdiFree;

    if (pdiHead == NULL)
        Fatal("mkdep: internal error");

    pdiFree = pdiHead;
    pdiHead = pdiHead->pdiNext;

    free(pdiFree->szPath);
    free(pdiFree->szName);
    free(pdiFree);
    }



DI *
PdiFromIdi(idi)
/*
  -- return a pointer to one element from the stack, or NULL
*/
int     idi;                    // index of element to get (0 = top of stack)
    {
    DI *    pdi;

    for (pdi = pdiHead; pdi && idi; idi--)
        pdi = pdi->pdiNext;
    return pdi;
    }

int
AddIncludeDir(szFile)
char * szFile;
{
    if (iszIncMac+1 >= iszIncMax)
        {
        fprintf(stderr,
                "mkdep: warning"
                ": too many include directories"
                "; ignoring %s\n", szFile);
        return 0;
        }
    else
        {
        /* normal include */
        NormalizePath(szFile);
        rgszIncPath[iszIncMac] = SzTransEnv(szFile);
        rgszIncName[iszIncMac] = szFile;
        // fprintf(stderr,"Added include: %s\n",szFile);
        iszIncMac++;
        return 1;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\tools\x86\aactive\lib\msimus_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.00.44 */
/* at Fri Nov 08 14:45:43 1996
 */
/* Compiler settings for MSIMusic.odl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID LIBID_AudioActive = {0xBCE4CC3f,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAABand = {0xBCE4CC4e,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAAEventSink = {0xBCE4CC43,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAALoader = {0xBCE4CC5d,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAAMIDISink = {0xBCE4CC44,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAAMotif = {0xBCE4CC4b,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAANotifySink = {0xBCE4CC45,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAAMIDIExportNotifySink = {0xBCE4CC5f,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAAPattern = {0xBCE4CC50,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAAPersonality = {0xBCE4CC4d,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAARealTime = {0xBCE4CC42,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAASection = {0xBCE4CC49,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAASection2 = {0xBCE4CC60,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAASong = {0xBCE4CC4a,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAAStyle = {0xBCE4CC4c,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAATemplate = {0xBCE4CC4f,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IReferenceClock = {0x56a86897,0x0ad4,0x11ce,{0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70}};


const IID IID_IAAEngine = {0xBCE4CC41,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAAMIDIIn = {0xBCE4CC46,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const IID IID_IAAMIDIOut = {0xBCE4CC47,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const CLSID CLSID_CAAEngine = {0xBCE4CC51,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const CLSID CLSID_CAARealTime = {0xBCE4CC52,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const CLSID CLSID_CAAMIDIOut = {0xBCE4CC53,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const CLSID CLSID_CAASection = {0xBCE4CC55,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const CLSID CLSID_CAASong = {0xBCE4CC56,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const CLSID CLSID_CAAMotif = {0xBCE4CC57,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const CLSID CLSID_CAAStyle = {0xBCE4CC58,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const CLSID CLSID_CAAPersonality = {0xBCE4CC59,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const CLSID CLSID_CAABand = {0xBCE4CC5a,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const CLSID CLSID_CAATemplate = {0xBCE4CC5b,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const CLSID CLSID_CAAPattern = {0xBCE4CC5c,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


const CLSID CLSID_CAALoader = {0xBCE4CC5e,0x2F1A,0x11CF,{0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\danim\tools\x86\aactive\inc\msimusic.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Fri Nov 08 14:45:43 1996
 */
/* Compiler settings for MSIMusic.odl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __MSIMusic_h__
#define __MSIMusic_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IAABand_FWD_DEFINED__
#define __IAABand_FWD_DEFINED__
typedef interface IAABand IAABand;
#endif 	/* __IAABand_FWD_DEFINED__ */


#ifndef __IAAEventSink_FWD_DEFINED__
#define __IAAEventSink_FWD_DEFINED__
typedef interface IAAEventSink IAAEventSink;
#endif 	/* __IAAEventSink_FWD_DEFINED__ */


#ifndef __IAALoader_FWD_DEFINED__
#define __IAALoader_FWD_DEFINED__
typedef interface IAALoader IAALoader;
#endif 	/* __IAALoader_FWD_DEFINED__ */


#ifndef __IAAMIDISink_FWD_DEFINED__
#define __IAAMIDISink_FWD_DEFINED__
typedef interface IAAMIDISink IAAMIDISink;
#endif 	/* __IAAMIDISink_FWD_DEFINED__ */


#ifndef __IAAMotif_FWD_DEFINED__
#define __IAAMotif_FWD_DEFINED__
typedef interface IAAMotif IAAMotif;
#endif 	/* __IAAMotif_FWD_DEFINED__ */


#ifndef __IAANotifySink_FWD_DEFINED__
#define __IAANotifySink_FWD_DEFINED__
typedef interface IAANotifySink IAANotifySink;
#endif 	/* __IAANotifySink_FWD_DEFINED__ */


#ifndef __IAAMIDIExportNotifySink_FWD_DEFINED__
#define __IAAMIDIExportNotifySink_FWD_DEFINED__
typedef interface IAAMIDIExportNotifySink IAAMIDIExportNotifySink;
#endif 	/* __IAAMIDIExportNotifySink_FWD_DEFINED__ */


#ifndef __IAAPattern_FWD_DEFINED__
#define __IAAPattern_FWD_DEFINED__
typedef interface IAAPattern IAAPattern;
#endif 	/* __IAAPattern_FWD_DEFINED__ */


#ifndef __IAAPersonality_FWD_DEFINED__
#define __IAAPersonality_FWD_DEFINED__
typedef interface IAAPersonality IAAPersonality;
#endif 	/* __IAAPersonality_FWD_DEFINED__ */


#ifndef __IAARealTime_FWD_DEFINED__
#define __IAARealTime_FWD_DEFINED__
typedef interface IAARealTime IAARealTime;
#endif 	/* __IAARealTime_FWD_DEFINED__ */


#ifndef __IAASection_FWD_DEFINED__
#define __IAASection_FWD_DEFINED__
typedef interface IAASection IAASection;
#endif 	/* __IAASection_FWD_DEFINED__ */


#ifndef __IAASection2_FWD_DEFINED__
#define __IAASection2_FWD_DEFINED__
typedef interface IAASection2 IAASection2;
#endif 	/* __IAASection2_FWD_DEFINED__ */


#ifndef __IAASong_FWD_DEFINED__
#define __IAASong_FWD_DEFINED__
typedef interface IAASong IAASong;
#endif 	/* __IAASong_FWD_DEFINED__ */


#ifndef __IAAStyle_FWD_DEFINED__
#define __IAAStyle_FWD_DEFINED__
typedef interface IAAStyle IAAStyle;
#endif 	/* __IAAStyle_FWD_DEFINED__ */


#ifndef __IAATemplate_FWD_DEFINED__
#define __IAATemplate_FWD_DEFINED__
typedef interface IAATemplate IAATemplate;
#endif 	/* __IAATemplate_FWD_DEFINED__ */


#ifndef __IReferenceClock_FWD_DEFINED__
#define __IReferenceClock_FWD_DEFINED__
typedef interface IReferenceClock IReferenceClock;
#endif 	/* __IReferenceClock_FWD_DEFINED__ */


#ifndef __IAAEngine_FWD_DEFINED__
#define __IAAEngine_FWD_DEFINED__
typedef interface IAAEngine IAAEngine;
#endif 	/* __IAAEngine_FWD_DEFINED__ */


#ifndef __IAAMIDIIn_FWD_DEFINED__
#define __IAAMIDIIn_FWD_DEFINED__
typedef interface IAAMIDIIn IAAMIDIIn;
#endif 	/* __IAAMIDIIn_FWD_DEFINED__ */


#ifndef __IAAMIDIOut_FWD_DEFINED__
#define __IAAMIDIOut_FWD_DEFINED__
typedef interface IAAMIDIOut IAAMIDIOut;
#endif 	/* __IAAMIDIOut_FWD_DEFINED__ */


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __AudioActive_LIBRARY_DEFINED__
#define __AudioActive_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: AudioActive
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [version][lcid][helpstring][uuid] */ 


















typedef IAABand __RPC_FAR *LPAABAND;

typedef IAAEventSink __RPC_FAR *LPAAEVENTSINK;

typedef IAALoader __RPC_FAR *LPAALOADER;

typedef IAAMIDISink __RPC_FAR *LPAAMIDISINK;

typedef IAAMotif __RPC_FAR *LPAAMOTIF;

typedef IAANotifySink __RPC_FAR *LPAANOTIFYSINK;

typedef IAAMIDIExportNotifySink __RPC_FAR *LPAAMIDIEXPORTNOTIFYSINK;

typedef IAAPattern __RPC_FAR *LPAAPATTERN;

typedef IAAPersonality __RPC_FAR *LPAAPERSONALITY;

typedef IAARealTime __RPC_FAR *LPREALTIME;

typedef IAASection __RPC_FAR *LPAASECTION;

typedef IAASong __RPC_FAR *LPAASONG;

typedef IAAStyle __RPC_FAR *LPAASTYLE;

typedef IAATemplate __RPC_FAR *LPAATEMPLATE;

typedef struct  _ReferenceTime
    {
    LARGE_INTEGER RefTime;
    }	ReferenceTime;

typedef unsigned long TIME;

typedef unsigned long HEVENT;

typedef unsigned long HSEMAPHORE;

typedef struct  AAEVENT
    {
    WORD cbSize;
    WORD wType;
    DWORD dwTime;
    }	AAEVENT;

typedef struct  AAINSTRUMENT
    {
    WORD cbSize;
    WORD wType;
    DWORD dwFullPatch;
    LPCTSTR pszName;
    BYTE abNotesUsed[ 16 ];
    BYTE bGMPatch;
    BYTE bReserved;
    }	AAINSTRUMENT;

typedef struct  AASTYLEINFO
    {
    WORD cbSize;
    GUID guid;
    LPCTSTR pszName;
    LPCTSTR pszCategory;
    LPCTSTR pszFileName;
    DWORD dwTimeSignature;
    WORD wClicksPerBeat;
    }	AASTYLEINFO;

typedef struct  AAPERSONALITYINFO
    {
    WORD cbSize;
    GUID guid;
    LPCTSTR pszName;
    LPCTSTR pszUserName;
    LPCTSTR pszFileName;
    }	AAPERSONALITYINFO;

typedef struct  AAMETERS
    {
    WORD cbSize;
    WORD wMutes;
    BYTE abCurrentVolume[ 16 ];
    signed char achCurrentPan[ 16 ];
    WORD awCurrentLevel[ 16 ];
    WORD awAveragedCurrentLevel[ 16 ];
    }	AAMETERS;

typedef 
enum __MIDL___MIDL__intf_0000_0001
    {	AAS_FALLING	= 0,
	AAS_LEVEL	= AAS_FALLING + 1,
	AAS_LOOPABLE	= AAS_LEVEL + 1,
	AAS_LOUD	= AAS_LOOPABLE + 1,
	AAS_QUIET	= AAS_LOUD + 1,
	AAS_PEAKING	= AAS_QUIET + 1,
	AAS_RANDOM	= AAS_PEAKING + 1,
	AAS_RISING	= AAS_RANDOM + 1,
	AAS_SONG	= AAS_RISING + 1
    }	AAShape;

typedef 
enum __MIDL___MIDL__intf_0000_0002
    {	AAF_NONE	= 0,
	AAF_EXCLUSIVE_FLAGS	= 0x3f,
	AAF_NEXT_MEASURE	= 0,
	AAF_END_CONTINUOUS	= 0,
	AAF_NEXT_BEAT	= 0x1,
	AAF_NEXT_CLICK	= 0x2,
	AAF_IMMEDIATE	= 0x3,
	AAF_ASAP	= 0x3,
	AAF_NEXT_SECTION	= 0x4,
	AAF_QUEUE	= 0x5,
	AAF_FAIL_IF_PLAYING	= 0x6,
	AAF_ABSOLUTE_TIME	= 0x7,
	AAF_MEASURES_FROM_NOW	= 0x8,
	AAF_BEATS_FROM_NOW	= 0x9,
	AAF_CLICKS_FROM_NOW	= 0xa,
	AAF_NONEXCLUSIVE_FLAGS	= 0xffffffc0,
	AAF_ALLOW_OVERLAP	= 0x100,
	AAF_PLAY_WITH_STYLE	= 0x200,
	AAF_IGNORE_KEY	= 0x400,
	AAF_IGNORE_CHORD	= 0x800,
	AAF_MODULATE	= 0x1000,
	AAF_LONG	= 0x2000,
	AAF_IS_TRANSITION	= 0x4000,
	AAF_ENDED_EARLY	= 0x8000,
	AAF_IGNORE_STANDARD_LOCATION	= 0x10000,
	AAF_ENDING	= 0x20000,
	AAF_NOTIFY	= 0x40000,
	AAF_PLAY_METRONOME	= 0x80000,
	AAF_MEASURE_BOUNDARIES_ONLY	= 0x100000,
	AAF_CONTINUOUS	= 0x200000
    }	AAFlags;

typedef 
enum __MIDL___MIDL__intf_0000_0003
    {	AAC_NONE	= 0,
	AAC_FILL	= 0x1,
	AAC_INTRO	= 0x2,
	AAC_BREAK	= 0x20,
	AAC_END	= 0x40,
	AAC_INTRO_AND_END	= 0x42,
	AAC_EMBELLISHMENTS	= 0x63,
	AAC_GROOVE_A	= 0x80,
	AAC_GROOVE_B	= 0x100,
	AAC_GROOVE_C	= 0x200,
	AAC_GROOVE_D	= 0x400,
	AAC_GROOVES	= 0x780
    }	AACommands;

typedef IReferenceClock __RPC_FAR *PREFERENCECLOCK;

#ifdef __AUDIOACTIVE
#define AAEXPORT __declspec(dllexport)
#else
#define AAEXPORT __declspec(dllimport)
#endif

#ifdef __cplusplus
extern "C"
{
#endif

AAEXPORT HRESULT WINAPI AllocAAClock( IReferenceClock** ppClock );
AAEXPORT HRESULT WINAPI AllocAAEngine( IAAEngine** ppEngine );
AAEXPORT HRESULT WINAPI AllocAAMIDIIn( IAAMIDIIn** ppMIDIIn );
AAEXPORT HRESULT WINAPI AllocAAMIDIOut( IAAMIDIOut** ppMIDIOut );
AAEXPORT HRESULT WINAPI AllocAARealTime( IAARealTime** ppRealTime );
AAEXPORT HRESULT WINAPI MusicEngineSimpleInit( IAAEngine** ppEngine, IAANotifySink* pNotifySink, IAALoader* pLoader );
AAEXPORT HRESULT WINAPI MusicEngineSimpleInitNT( IAAEngine** ppEngine, IAANotifySink* pNotifySink, IAALoader* pLoader );
AAEXPORT HRESULT WINAPI MusicEngineSimpleInit95( IAAEngine** ppEngine, IAANotifySink* pNotifySink, IAALoader* pLoader );
AAEXPORT IAAMIDISink* WINAPI GetFinalMIDISink( IAAEngine* pEngine );
AAEXPORT HRESULT WINAPI LoadBandFile( IAAEngine* pEngine, LPCTSTR pszFileName, IAABand** ppBand );
AAEXPORT HRESULT WINAPI LoadMotifFile( IAAEngine* pEngine, LPCTSTR pszFileName, IAAMotif** ppMotif );
AAEXPORT HRESULT WINAPI LoadPatternFile( IAAEngine* pEngine, LPCTSTR pszFileName, IAAPattern** ppPattern );
AAEXPORT HRESULT WINAPI LoadPersonalityByName( IAAEngine* pEngine, LPCTSTR pszName, IAAPersonality** ppPersonality );
AAEXPORT HRESULT WINAPI LoadPersonalityFile( IAAEngine* pEngine, LPCTSTR pszFileName, IAAPersonality** ppPersonality );
AAEXPORT HRESULT WINAPI LoadPersonalityFromMemory( IAAEngine* pEngine, void* pMem, IAAPersonality** ppPersonality );
AAEXPORT HRESULT WINAPI LoadSectionFile( IAAEngine* pEngine, LPCTSTR pszFileName, IAASection** ppSection );
AAEXPORT HRESULT WINAPI SaveSectionFile( LPCTSTR pszFileName, IAASection* pSection );
AAEXPORT HRESULT WINAPI SaveSectionAsMIDIFile( LPCTSTR pszFileName, IAASection* pSection );
AAEXPORT HRESULT WINAPI LoadSongFile( IAAEngine* pEngine, LPCTSTR pszFileName, IAASong** ppSong );
AAEXPORT HRESULT WINAPI LoadStyleByName( IAAEngine* pEngine, LPCTSTR pszName, IAAStyle** ppStyle );
AAEXPORT HRESULT WINAPI LoadStyleFile( IAAEngine* pEngine, LPCTSTR pszFileName, IAAStyle** ppStyle );
AAEXPORT HRESULT WINAPI LoadStyleFromMemory( IAAEngine* pEngine, void* pMem, IAAStyle** ppStyle );
AAEXPORT HRESULT WINAPI LoadTemplateFile( IAAEngine* pEngine, LPCTSTR pszFileName, IAATemplate** ppTemplate );
AAEXPORT HRESULT WINAPI Panic( IAAEngine* pEngine );
AAEXPORT void WINAPI SetAADebug( WORD wDebugLevel );

#ifdef __cplusplus
}
#endif

// Error return values
#define AA_E_ALREADYPLAYING  0x80041000
#define AA_E_NOMUSICPLAYING  0x80041001
#define AA_W_MIDIINUSE       0x40041000

#define MAKE_TEMPO( bpm, fract ) ( (long)( ((DWORD)(WORD)bpm) | ( ((DWORD)(WORD)fract) << 16 ) ) )
#define TEMPO_BPM( tempo ) ( (short)tempo )
#define TEMPO_FRACT( tempo ) ( (WORD)( ((DWORD)tempo) >> 16 ) )

#define MAKE_TIMESIG( bpm, beat ) ( (long)( ((DWORD)(WORD)beat) | ( ((DWORD)(WORD)bpm) << 16 ) ) )
#define TIMESIG_BEAT( tsig ) ( (short)tsig )
#define TIMESIG_BPM( tsig ) ( (WORD)( ((DWORD)tsig) >> 16 ) )

#define MAKE_KEY( isflat, root ) ( (isflat) ? ( 0x8000 | (root) ) | (root) )
#define KEY_ROOT( key ) ( (key) & 0x1f )
#define KEY_ISFLAT( key ) ( ( (key) & 0x8000 ) != 0 )

#define MAKE_MIDIMSG( stat, not, vel ) \
    ( (DWORD)(((BYTE)(stat) | ((BYTE)(not)<<8)) | (((DWORD)(BYTE)(vel))<<16)) )

#define GET_MIDIMSG_STATUS( msg ) \
    ( (BYTE)(msg) )

#define GET_MIDIMSG_NOTE( msg ) \
    ( (BYTE)((msg) >> 8) )

#define GET_MIDIMSG_VELOCITY( msg ) \
    ( (BYTE)((msg) >> 16) )

#define NOW 0xfffffffful
#define MIN_TEMPO           10
#define MAX_TEMPO           350
#define SECTION_MAX_LENGTH  1000

#define AA_FINST_DRUM   0x80000000
#define AA_FINST_EMPTY  0x40000000
#define AA_FINST_USEGM  0x00400000
#define AA_FINST_USEGS  0x00200000

#ifdef _DEBUG
enum AAMEM_FLAGS
{
    AAMEM_RESET = 1,
    AAMEM_DEBUG = 2,
    AAMEM_BYTES = 4,
    AAMEM_ALLOC = 0,
};

typedef struct AAMemoryData
{
    DWORD                   dwSize;
    DWORD                   dwTotal;
    DWORD                   dwMaximum;
    DWORD                   dwCurrent;
} AAMEMORYDATA, *LPAAMEMORYDATA;

#ifdef __cplusplus
extern "C"
{
#endif

AAEXPORT HRESULT WINAPI AAMemoryAudit( LPAAMEMORYDATA pmd, DWORD fdwFlags );
AAEXPORT HRESULT WINAPI AASetMemoryFault( DWORD dwLimit, DWORD fdwFlags );

#ifdef __cplusplus
}
#endif

#endif

DEFINE_GUID(LIBID_AudioActive,0xBCE4CC3f,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#ifndef __IAABand_INTERFACE_DEFINED__
#define __IAABand_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAABand
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAABand,0xBCE4CC4e,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAABand : public IUnknown
    {
    public:
        virtual IAABand __RPC_FAR *STDMETHODCALLTYPE Clone( void) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetName( void) = 0;
        
        virtual short STDMETHODCALLTYPE GetOctave( 
            /* [in] */ WORD wInstrument) = 0;
        
        virtual short STDMETHODCALLTYPE GetPan( 
            /* [in] */ WORD wInstrument) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetPatch( 
            /* [in] */ WORD wInstrument) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetVolume( 
            /* [in] */ WORD wInstrument) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInstrument( 
            /* [in] */ WORD wInstrument,
            /* [in] */ AAINSTRUMENT __RPC_FAR *pInstrument) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Lock( 
            /* [in] */ VARIANT_BOOL fWait) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryState( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Send( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInstrument( 
            /* [in] */ WORD wInstrument,
            /* [in] */ AAINSTRUMENT __RPC_FAR *pInstrument) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ LPCTSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNoteRange( 
            /* [in] */ WORD wInstrument,
            /* [in] */ WORD wLowNote,
            /* [in] */ WORD wHighNote,
            /* [in] */ VARIANT_BOOL fOn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOctave( 
            /* [in] */ WORD wInstrument,
            /* [in] */ short nOctave) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPan( 
            /* [in] */ WORD wInstrument,
            /* [in] */ short nPan,
            /* [in] */ VARIANT_BOOL fSend) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPatch( 
            /* [in] */ WORD wInstrument,
            /* [in] */ WORD wPatch,
            /* [in] */ VARIANT_BOOL fSend) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVolume( 
            /* [in] */ WORD wInstrument,
            /* [in] */ WORD wVolume,
            /* [in] */ VARIANT_BOOL fSend) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unlock( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAABandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAABand __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAABand __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAABand __RPC_FAR * This);
        
        IAABand __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IAABand __RPC_FAR * This);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IAABand __RPC_FAR * This);
        
        short ( STDMETHODCALLTYPE __RPC_FAR *GetOctave )( 
            IAABand __RPC_FAR * This,
            /* [in] */ WORD wInstrument);
        
        short ( STDMETHODCALLTYPE __RPC_FAR *GetPan )( 
            IAABand __RPC_FAR * This,
            /* [in] */ WORD wInstrument);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetPatch )( 
            IAABand __RPC_FAR * This,
            /* [in] */ WORD wInstrument);
        
        WORD ( STDMETHODCALLTYPE __RPC_FAR *GetVolume )( 
            IAABand __RPC_FAR * This,
            /* [in] */ WORD wInstrument);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInstrument )( 
            IAABand __RPC_FAR * This,
            /* [in] */ WORD wInstrument,
            /* [in] */ AAINSTRUMENT __RPC_FAR *pInstrument);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Lock )( 
            IAABand __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fWait);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryState )( 
            IAABand __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Send )( 
            IAABand __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInstrument )( 
            IAABand __RPC_FAR * This,
            /* [in] */ WORD wInstrument,
            /* [in] */ AAINSTRUMENT __RPC_FAR *pInstrument);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IAABand __RPC_FAR * This,
            /* [in] */ LPCTSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNoteRange )( 
            IAABand __RPC_FAR * This,
            /* [in] */ WORD wInstrument,
            /* [in] */ WORD wLowNote,
            /* [in] */ WORD wHighNote,
            /* [in] */ VARIANT_BOOL fOn);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOctave )( 
            IAABand __RPC_FAR * This,
            /* [in] */ WORD wInstrument,
            /* [in] */ short nOctave);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPan )( 
            IAABand __RPC_FAR * This,
            /* [in] */ WORD wInstrument,
            /* [in] */ short nPan,
            /* [in] */ VARIANT_BOOL fSend);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPatch )( 
            IAABand __RPC_FAR * This,
            /* [in] */ WORD wInstrument,
            /* [in] */ WORD wPatch,
            /* [in] */ VARIANT_BOOL fSend);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVolume )( 
            IAABand __RPC_FAR * This,
            /* [in] */ WORD wInstrument,
            /* [in] */ WORD wVolume,
            /* [in] */ VARIANT_BOOL fSend);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unlock )( 
            IAABand __RPC_FAR * This);
        
        END_INTERFACE
    } IAABandVtbl;

    interface IAABand
    {
        CONST_VTBL struct IAABandVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAABand_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAABand_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAABand_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAABand_Clone(This)	\
    (This)->lpVtbl -> Clone(This)

#define IAABand_GetName(This)	\
    (This)->lpVtbl -> GetName(This)

#define IAABand_GetOctave(This,wInstrument)	\
    (This)->lpVtbl -> GetOctave(This,wInstrument)

#define IAABand_GetPan(This,wInstrument)	\
    (This)->lpVtbl -> GetPan(This,wInstrument)

#define IAABand_GetPatch(This,wInstrument)	\
    (This)->lpVtbl -> GetPatch(This,wInstrument)

#define IAABand_GetVolume(This,wInstrument)	\
    (This)->lpVtbl -> GetVolume(This,wInstrument)

#define IAABand_GetInstrument(This,wInstrument,pInstrument)	\
    (This)->lpVtbl -> GetInstrument(This,wInstrument,pInstrument)

#define IAABand_Lock(This,fWait)	\
    (This)->lpVtbl -> Lock(This,fWait)

#define IAABand_QueryState(This)	\
    (This)->lpVtbl -> QueryState(This)

#define IAABand_Send(This)	\
    (This)->lpVtbl -> Send(This)

#define IAABand_SetInstrument(This,wInstrument,pInstrument)	\
    (This)->lpVtbl -> SetInstrument(This,wInstrument,pInstrument)

#define IAABand_SetName(This,pszName)	\
    (This)->lpVtbl -> SetName(This,pszName)

#define IAABand_SetNoteRange(This,wInstrument,wLowNote,wHighNote,fOn)	\
    (This)->lpVtbl -> SetNoteRange(This,wInstrument,wLowNote,wHighNote,fOn)

#define IAABand_SetOctave(This,wInstrument,nOctave)	\
    (This)->lpVtbl -> SetOctave(This,wInstrument,nOctave)

#define IAABand_SetPan(This,wInstrument,nPan,fSend)	\
    (This)->lpVtbl -> SetPan(This,wInstrument,nPan,fSend)

#define IAABand_SetPatch(This,wInstrument,wPatch,fSend)	\
    (This)->lpVtbl -> SetPatch(This,wInstrument,wPatch,fSend)

#define IAABand_SetVolume(This,wInstrument,wVolume,fSend)	\
    (This)->lpVtbl -> SetVolume(This,wInstrument,wVolume,fSend)

#define IAABand_Unlock(This)	\
    (This)->lpVtbl -> Unlock(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



IAABand __RPC_FAR *STDMETHODCALLTYPE IAABand_Clone_Proxy( 
    IAABand __RPC_FAR * This);


void __RPC_STUB IAABand_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTSTR STDMETHODCALLTYPE IAABand_GetName_Proxy( 
    IAABand __RPC_FAR * This);


void __RPC_STUB IAABand_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


short STDMETHODCALLTYPE IAABand_GetOctave_Proxy( 
    IAABand __RPC_FAR * This,
    /* [in] */ WORD wInstrument);


void __RPC_STUB IAABand_GetOctave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


short STDMETHODCALLTYPE IAABand_GetPan_Proxy( 
    IAABand __RPC_FAR * This,
    /* [in] */ WORD wInstrument);


void __RPC_STUB IAABand_GetPan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAABand_GetPatch_Proxy( 
    IAABand __RPC_FAR * This,
    /* [in] */ WORD wInstrument);


void __RPC_STUB IAABand_GetPatch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


WORD STDMETHODCALLTYPE IAABand_GetVolume_Proxy( 
    IAABand __RPC_FAR * This,
    /* [in] */ WORD wInstrument);


void __RPC_STUB IAABand_GetVolume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAABand_GetInstrument_Proxy( 
    IAABand __RPC_FAR * This,
    /* [in] */ WORD wInstrument,
    /* [in] */ AAINSTRUMENT __RPC_FAR *pInstrument);


void __RPC_STUB IAABand_GetInstrument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAABand_Lock_Proxy( 
    IAABand __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fWait);


void __RPC_STUB IAABand_Lock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAABand_QueryState_Proxy( 
    IAABand __RPC_FAR * This);


void __RPC_STUB IAABand_QueryState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAABand_Send_Proxy( 
    IAABand __RPC_FAR * This);


void __RPC_STUB IAABand_Send_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAABand_SetInstrument_Proxy( 
    IAABand __RPC_FAR * This,
    /* [in] */ WORD wInstrument,
    /* [in] */ AAINSTRUMENT __RPC_FAR *pInstrument);


void __RPC_STUB IAABand_SetInstrument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAABand_SetName_Proxy( 
    IAABand __RPC_FAR * This,
    /* [in] */ LPCTSTR pszName);


void __RPC_STUB IAABand_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAABand_SetNoteRange_Proxy( 
    IAABand __RPC_FAR * This,
    /* [in] */ WORD wInstrument,
    /* [in] */ WORD wLowNote,
    /* [in] */ WORD wHighNote,
    /* [in] */ VARIANT_BOOL fOn);


void __RPC_STUB IAABand_SetNoteRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAABand_SetOctave_Proxy( 
    IAABand __RPC_FAR * This,
    /* [in] */ WORD wInstrument,
    /* [in] */ short nOctave);


void __RPC_STUB IAABand_SetOctave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAABand_SetPan_Proxy( 
    IAABand __RPC_FAR * This,
    /* [in] */ WORD wInstrument,
    /* [in] */ short nPan,
    /* [in] */ VARIANT_BOOL fSend);


void __RPC_STUB IAABand_SetPan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAABand_SetPatch_Proxy( 
    IAABand __RPC_FAR * This,
    /* [in] */ WORD wInstrument,
    /* [in] */ WORD wPatch,
    /* [in] */ VARIANT_BOOL fSend);


void __RPC_STUB IAABand_SetPatch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAABand_SetVolume_Proxy( 
    IAABand __RPC_FAR * This,
    /* [in] */ WORD wInstrument,
    /* [in] */ WORD wVolume,
    /* [in] */ VARIANT_BOOL fSend);


void __RPC_STUB IAABand_SetVolume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAABand_Unlock_Proxy( 
    IAABand __RPC_FAR * This);


void __RPC_STUB IAABand_Unlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAABand_INTERFACE_DEFINED__ */


#ifndef __IAAEventSink_INTERFACE_DEFINED__
#define __IAAEventSink_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAAEventSink
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAAEventSink,0xBCE4CC43,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAAEventSink : public IUnknown
    {
    public:
        virtual IAAEventSink __RPC_FAR *STDMETHODCALLTYPE GetEventSink( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueueEvent( 
            /* [in] */ AAEVENT __RPC_FAR *pEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEventSink( 
            /* [in] */ IAAEventSink __RPC_FAR *pEventSink) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAAEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAAEventSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAAEventSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAAEventSink __RPC_FAR * This);
        
        IAAEventSink __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *GetEventSink )( 
            IAAEventSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueueEvent )( 
            IAAEventSink __RPC_FAR * This,
            /* [in] */ AAEVENT __RPC_FAR *pEvent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEventSink )( 
            IAAEventSink __RPC_FAR * This,
            /* [in] */ IAAEventSink __RPC_FAR *pEventSink);
        
        END_INTERFACE
    } IAAEventSinkVtbl;

    interface IAAEventSink
    {
        CONST_VTBL struct IAAEventSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAAEventSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAAEventSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAAEventSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAAEventSink_GetEventSink(This)	\
    (This)->lpVtbl -> GetEventSink(This)

#define IAAEventSink_QueueEvent(This,pEvent)	\
    (This)->lpVtbl -> QueueEvent(This,pEvent)

#define IAAEventSink_SetEventSink(This,pEventSink)	\
    (This)->lpVtbl -> SetEventSink(This,pEventSink)

#endif /* COBJMACROS */


#endif 	/* C style interface */



IAAEventSink __RPC_FAR *STDMETHODCALLTYPE IAAEventSink_GetEventSink_Proxy( 
    IAAEventSink __RPC_FAR * This);


void __RPC_STUB IAAEventSink_GetEventSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEventSink_QueueEvent_Proxy( 
    IAAEventSink __RPC_FAR * This,
    /* [in] */ AAEVENT __RPC_FAR *pEvent);


void __RPC_STUB IAAEventSink_QueueEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAAEventSink_SetEventSink_Proxy( 
    IAAEventSink __RPC_FAR * This,
    /* [in] */ IAAEventSink __RPC_FAR *pEventSink);


void __RPC_STUB IAAEventSink_SetEventSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAAEventSink_INTERFACE_DEFINED__ */


#ifndef __IAALoader_INTERFACE_DEFINED__
#define __IAALoader_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAALoader
 * at Fri Nov 08 14:45:43 1996
 * using MIDL 3.00.44
 ****************************************/
/* [object][uuid] */ 



DEFINE_GUID(IID_IAALoader,0xBCE4CC5d,0x2F1A,0x11CF,0xBF,0x16,0x00,0xAA,0x00,0xC0,0x81,0x46);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAALoader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFirstPersonalityInfo( 
            /* [out][in] */ AAPERSONALITYINFO __RPC_FAR *pPersonalityInfo) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetFirstPersonalityName( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFirstStyleInfo( 
            /* [out][in] */ AASTYLEINFO __RPC_FAR *pStyleInfo) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetFirstStyleName( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextPersonalityInfo( 
            /* [out][in] */ AAPERSONALITYINFO __RPC_FAR *pPersonalityInfo) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetNextPersonalityName( 
            /* [in] */ LPCTSTR pszPrevPersonalityName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextStyleInfo( 
            /* [out][in] */ AASTYLEINFO __RPC_FAR *pStyleInfo) = 0;
        
        virtual LPCTSTR STDMETHODCALLTYPE GetNextStyleName( 
            /* [in] */ LPCTSTR pszPrevStyleName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadPersonality( 
            /* [in] */ IAAEngine __RPC_FAR *pEngine,
            /* [in] */ LPGUID pguid,
            /* [in] */ LPCTSTR pszFileName,
            /* [in] */ LPCTSTR pszPersonalityName,
            /* [retval][out] */ IAAPersonality __RPC_FAR *__RPC_FAR *ppPersonality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadStyle( 
            /* [in] */ IAAEngine __RPC_FAR *pEngine,
            /* [in] */ LPGUID pguid,
            /* [in] */ LPCTSTR pszFileName,
            /* [in] */ LPCTSTR pszStyleName,
            /* [retval][out] */ IAAStyle __RPC_FAR *__RPC_FAR *ppStyle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSearchDirectory( 
            /* [in] */ LPCTSTR pszDirectoryName,
            /* [in] */ AAFlags fFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAALoaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAALoader __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAALoader __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAALoader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFirstPersonalityInfo )( 
            IAALoader __RPC_FAR * This,
            /* [out][in] */ AAPERSONALITYINFO __RPC_FAR *pPersonalityInfo);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetFirstPersonalityName )( 
            IAALoader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFirstStyleInfo )( 
            IAALoader __RPC_FAR * This,
            /* [out][in] */ AASTYLEINFO __RPC_FAR *pStyleInfo);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetFirstStyleName )( 
            IAALoader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextPersonalityInfo )( 
            IAALoader __RPC_FAR * This,
            /* [out][in] */ AAPERSONALITYINFO __RPC_FAR *pPersonalityInfo);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetNextPersonalityName )( 
            IAALoader __RPC_FAR * This,
            /* [in] */ LPCTSTR pszPrevPersonalityName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextStyleInfo )( 
            IAALoader __RPC_FAR * This,
            /* [out][in] */ AASTYLEINFO __RPC_FAR *pStyleInfo);
        
        LPCTSTR ( STDMETHODCALLTYPE __RPC_FAR *GetNextStyleName )( 
            IAALoader __RPC_FAR * This,
            /* [in] */ LPCTSTR pszPrevStyleName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadPersonality )( 
            IAALoader __RPC_FAR * This,
            /* [in] */ IAAEngine __RPC_FAR *pEngine,
            /* [in] */ LPGUID pguid,
            /* [in] */ LPCTSTR pszFileName,
            /* [in] */ LPCTSTR pszPersonalityName,
            /* [retval][out] */ IAAPersonality __RPC_FAR *__RPC_FAR *ppPersonality);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadStyle )( 
            IAALoader __RPC_FAR * This,
            /* [in] */ IAAEngine __RPC_FAR *pEngine,
            /* [in] */ LPGUID pguid,
            /* [in] */ LPCTSTR pszFileName,
            /* [in] */ LPCTSTR pszStyleName,
            /* [retval][out] */ IAAStyle __RPC_FAR *__RPC_FAR *ppStyle);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSearchDirectory )( 
            IAALoader __RPC_FAR * This,
            /* [in] */ LPCTSTR pszDirectoryName,
            /* [in] */ AAFlags fFlags);
        
        END_INTERFACE
    } IAALoaderVtbl;

    interface IAALoader
    {
        CONST_VTBL struct IAALoaderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAALoader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAALoader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAALoader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAALoader_GetFirstPersonalityInfo(This,pPersonalityInfo)	\
    (This)->lpVtbl -> GetFirstPersonalityInfo(This,pPersonalityInfo)

#define IAALoader_GetFirstPersonalityName(This)	\
    (This)->lpVtbl -> GetFirstPersonalityName(This)

#define IAALoader_GetFirstStyleInfo(This,pStyleInfo)	\
    (This)->lpVtbl -> GetFirstStyleInfo(This,pStyleInfo)

#define IAALoader_GetFirstStyleName(This)	\
    (This)->lpVtbl -> GetFirstStyleName(This)

#define IAALoader_GetNextPersonalityInfo(This,pPersonalityInfo)	\
    (This)->lpVtbl -> GetNextPersonalityInfo(This,pPersonalityInfo)

#define IAALoader_GetNextPersonalityName(This,pszPrevPersonalityName)	\
    (This)->lpVtbl -> GetNextPersonalityName(This,pszPrevPersonalityName)

#define IAALoader_GetNextStyleInfo(This,pStyleInfo)	\
    (This)->lpVtbl -> GetNextStyleInfo(This,pStyleInfo)

#define IAALoader_GetNextStyleName(This,pszPrevStyleName)	\
    (This)->lpVtbl -> GetNextStyleName(This,pszPrevStyleName)

#define IAALoader_LoadPersonality(This,pEngine,pguid,pszFileName,pszPersonalityName,ppPersonality)	\
    (This)->lpVtbl -> LoadPersonality(This,pEngine,pguid,pszFileName,pszPersonalityName,ppPersonality)

#define IAALoader_LoadStyle(This,pEngine,pguid,pszFileName,pszStyleName,ppStyle)	\
    (This)->lpVtbl -> LoadStyle(This,pEngine,pguid,pszFileName,pszStyleName,ppStyle)

#define IAALoader_SetSearchDirectory(This,pszDirectoryName,fFlags)	\
    (This)->lpVtbl -> SetSearchDirectory(This,pszDirectoryName,fFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAALoader_GetFirstPersonalityInfo_Proxy( 
    IAALoader __RPC_FAR * This,
    /* [out][in] */ AAPERSONALITYINFO __RPC_FAR *pPersonalityInfo);


void __RPC_STUB IAALoader_GetFirstPersonalityInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTSTR STDMETHODCALLTYPE IAALoader_GetFirstPersonalityName_Proxy( 
    IAALoader __RPC_FAR * This);


void __RPC_STUB IAALoader_GetFirstPersonalityName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAALoader_GetFirstStyleInfo_Proxy( 
    IAALoader __RPC_FAR * This,
    /* [out][in] */ AASTYLEINFO __RPC_FAR *pStyleInfo);


void __RPC_STUB IAALoader_GetFirstStyleInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


LPCTST