e)/sizeof(LicenseRequest.szUserName[0])))
        {
            SetLastError(status = TLS_E_INTERNAL);
            goto cleanup;
        }
    }
    else
    {
        SAFESTRCPY(LicenseRequest.szMachineName, lpContext->m_Client);
        SAFESTRCPY(LicenseRequest.szUserName, lpContext->m_Client);
    }

    LicenseRequest.dwProductVersion = HYDRACERT_PRODUCT_VERSION;
    LicenseRequest.pszProductId = HYDRAPRODUCT_HS_CERTIFICATE_SKU;
    LicenseRequest.pszCompanyName = szCompanyName;

    LicenseRequest.dwLanguageID = GetSystemDefaultLangID(); // ignore
    LicenseRequest.dwPlatformID = CLIENT_PLATFORMID_WINDOWS_NT_FREE; // WINDOWS
    LicenseRequest.pbEncryptedHwid = lpHandle->pCertRequest->pbEncryptedHwid;
    LicenseRequest.cbEncryptedHwid = lpHandle->pCertRequest->cbEncryptedHwid;

    status=LicenseDecryptHwid(
                        &LicenseRequest.hWid, 
                        LicenseRequest.cbEncryptedHwid,
                        LicenseRequest.pbEncryptedHwid,
                        g_cbSecretKey,
                        g_pbSecretKey
                    );

    if(status != ERROR_SUCCESS)
    {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    LicenseRequest.pClientPublicKey = (PCERT_PUBLIC_KEY_INFO)lpHandle->pCertRequest->pSubjectPublicKeyInfo;
    LicenseRequest.clientCertRdn.type =  LSCERT_RDN_STRING_TYPE;
    LicenseRequest.clientCertRdn.szRdn = lpHandle->pCertRequest->szSubjectRdn;
    LicenseRequest.dwNumExtensions = lpHandle->pCertRequest->dwNumCertExtension;
    LicenseRequest.pExtensions = (PCERT_EXTENSION)lpHandle->pCertRequest->pCertExtensions;

    hClient = GenerateClientId();
    pPolicy = AcquirePolicyModule(NULL, NULL, FALSE);
    if(pPolicy == NULL)
    {
        SetLastError(status = TLS_E_INTERNAL);
        goto cleanup;
    }

    PMLicenseRequest.dwProductVersion = LicenseRequest.dwProductVersion;
    PMLicenseRequest.pszProductId = LicenseRequest.pszProductId;
    PMLicenseRequest.pszCompanyName = LicenseRequest.pszCompanyName;
    PMLicenseRequest.dwLanguageId = LicenseRequest.dwLanguageID;
    PMLicenseRequest.dwPlatformId = LicenseRequest.dwPlatformID;
    PMLicenseRequest.pszMachineName = LicenseRequest.szMachineName;
    PMLicenseRequest.pszUserName = LicenseRequest.szUserName;
    PMLicenseRequest.dwLicenseType = LICENSETYPE_LICENSE;

    //
    // Inform Policy module start of new license request
    //
    status = pPolicy->PMLicenseRequest(
                                hClient,
                                REQUEST_NEW,
                                (PVOID) &PMLicenseRequest,
                                (PVOID *) &pAdjustedRequest
                            );

    if(status != ERROR_SUCCESS)
    {
        goto cleanup;
    }
    
    LicenseRequest.pPolicy = pPolicy;
    LicenseRequest.hClient = hClient;

    LicenseRequest.pPolicyLicenseRequest = pAdjustedRequest;
    LicenseRequest.pClientLicenseRequest = &PMLicenseRequest;


    // Call issue new license from sepcific keypack
    if(!ALLOCATEDBHANDLE(pDbWkSpace, g_GeneralDbTimeout))
    {
        status = TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    CLEANUPSTMT;
    BEGIN_TRANSACTION(pDbWkSpace);

    try {
        status = TLSDBIssuePermanentLicense( 
                                    USEHANDLE(pDbWkSpace),
                                    &LicenseRequest,
                                    FALSE,      // bLatestVersion
                                    FALSE,      // bAcceptFewerLicenses
                                    &dwQuantity,
                                    &LicensedProduct,
                                    0
                                );
    } 
    catch( SE_Exception e ) {
        status = e.getSeNumber();
    }
    catch(...) {
        status = TLS_E_INTERNAL;
    }
    
    if(TLS_ERROR(status))
    {
        ROLLBACK_TRANSACTION(pDbWkSpace);
    }
    else
    {
        COMMIT_TRANSACTION(pDbWkSpace);
    }

    FREEDBHANDLE(pDbWkSpace);

    if(status == ERROR_SUCCESS)
    {
        LicensedProduct.pSubjectPublicKeyInfo = (PCERT_PUBLIC_KEY_INFO)lpHandle->pCertRequest->pSubjectPublicKeyInfo;

        //
        // Generate client certificate
        //
        status = TLSGenerateClientCertificate(
                                    g_hCryptProv,
                                    1,
                                    &LicensedProduct,
                                    LICENSE_DETAIL_DETAIL,
                                    &pbPkcs7,
                                    &cbPkcs7
                                );

        if(TLS_ERROR(status) == TRUE)
        {
            goto cleanup;
        }

        status = TLSChainProprietyCertificate(
                                    g_hCryptProv,
                                    (CanIssuePermLicense() == FALSE),
                                    pbPkcs7, 
                                    cbPkcs7, 
                                    ppbCert,
                                    pcbCert 
                                );

        if(status == ERROR_SUCCESS)
        {
            if(CanIssuePermLicense() == FALSE) 
            {
                status = TLS_W_SELFSIGN_CERTIFICATE;
            }
        }
    }

cleanup:

    FreeMemory(pbPkcs7);

    if(pPolicy)
    {
        ReleasePolicyModule(pPolicy);   
    }


    //
    // Free up Hydra Certificate Request handle, 
    // all_nodes attribute so single free.
    //
    if(lpHandle)
    {
        if(lpHandle->pCertRequest)
        {
            midl_user_free(lpHandle->pCertRequest);
        }
    
        if(lpHandle->pbChallengeData)
        {
            midl_user_free(lpHandle->pbChallengeData);
        }

        FreeMemory(lpHandle);
    }

    if(lpContext->m_ContextType == CONTEXTHANDLE_HYDRA_REQUESTCERT_TYPE)
    {
        //
        // force calling TLSRpcRequestTermServCert() again
        //
        lpContext->m_ContextType = CONTEXTHANDLE_EMPTY_TYPE;
        lpContext->m_ContextHandle = NULL;
    }

    InterlockedDecrement( &lpContext->m_RefCount );

    lpContext->m_LastError=status;

    #if DBG
    lpContext->m_LastCall = RPC_CALL_RETRIEVE_TERMSRV_CERT;
    #endif

    *pdwErrCode = TLSMapReturnCode(status);

    //
    // Reset SE translator
    //
    _set_se_translator(old_trans_se_func);

    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////
error_status_t 
TLSRpcAuditLicenseKeyPack(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwKeyPackId,
    /* [in] */ FILETIME ftStartTime,
    /* [in] */ FILETIME ftEndTime,
    /* [in] */ BOOL bResetCounter,
    /* [ref][out][in] */ LPTLSKeyPackAudit lplsAudit,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

    Not implemented yet!.

--*/
{
    *pdwErrCode = TLSMapReturnCode(TLS_E_NOTSUPPORTED);
    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcGetLSPKCS10CertRequest(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwCertType,
    /* [ref][out][in] */ PDWORD pcbData,
    /* [size_is][size_is][out] */ PBYTE __RPC_FAR *ppbData,
    /* [ref][out][in] */ PDWORD dwErrCode
    )
/*

Abstract:


Note:

    Only return our key at this time, not a PKCS10 request

*/
{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    DWORD status=ERROR_SUCCESS;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcGetLSPKCS10CertRequest\n"),
            lpContext->m_Client
        );


    InterlockedIncrement( &lpContext->m_RefCount );
    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_ADMIN))
    {
        status = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }

    if(AcquireAdministrativeLock(INFINITE) == TRUE)
    {
        status = RetrieveKey(
                        (dwCertType == TLSCERT_TYPE_EXCHANGE) ? 
                                LSERVER_LSA_PRIVATEKEY_EXCHANGE :
                                LSERVER_LSA_PRIVATEKEY_SIGNATURE,
                        ppbData,
                        pcbData
                    );

        ReleaseAdministrativeLock();
    }
    else
    {
        status = TLS_E_ALLOCATE_HANDLE;
    }

cleanup:
    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_GETPKCS10CERT_REQUEST;
    #endif

    *dwErrCode = TLSMapReturnCode(status);
    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////// 
//
// Replication function
//
////////////////////////////////////////////////////////////////////////////
error_status_t 
TLSRpcBeginReplication( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [string][in] */ LPTSTR pszLsSetupId,
    /* [string][in] */ LPTSTR pszLsServerName,
    /* [in] */ DWORD cbDomainSid,
    /* [size_is][in] */ PBYTE pbDomainSid,
    /* [ref][out][in] */ FILETIME __RPC_FAR *pftLastBackupTime,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

++*/
{
    *pdwErrCode = TLSMapReturnCode(TLS_E_NOTSUPPORTED);
    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcEndReplication( 
    /* [in] */ PCONTEXT_HANDLE phContext
    )
/*++

++*/
{
    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcReplicateRecord( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][in] */ PTLSReplRecord pReplRecord,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

++*/
{
    *pdwErrCode = TLSMapReturnCode(TLS_E_NOTSUPPORTED);
    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcTableEnumBegin( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwSearchParam,
    /* [ref][in] */ PTLSReplRecord pRecord,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

++*/
{
    *pdwErrCode = TLSMapReturnCode(TLS_E_NOTSUPPORTED);
    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcTableEnumNext( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [ref][out][in] */ PTLSReplRecord pRecord,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

++*/
{
    *pdwErrCode = TLSMapReturnCode(TLS_E_NOTSUPPORTED);
    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcTableEnumEnd( 
    /* [in] */ PCONTEXT_HANDLE phContext
    )
/*++

++*/
{
    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcInstallPolicyModule(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [string][in] */ LPTSTR pszCompanyName,
    /* [string][in] */ LPTSTR pszProductId,
    /* [string][in] */ LPTSTR pszPolicyDllName,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

++*/
{
    *pdwErrCode = TLSMapReturnCode(TLS_E_NOTSUPPORTED);
    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcAnnounceServer( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwAnnounceType,
    /* [in] */ FILETIME __RPC_FAR *pLastStartupTime,
    /* [string][in] */ LPTSTR pszSetupId,
    /* [string][in] */ LPTSTR pszDomainName,
    /* [string][in] */ LPTSTR pszLserverName,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

Abstract:

    Private routine for other license server to announce presence of
    itself.

Parameters:



Returns:


Note:


++*/
{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    DWORD status = ERROR_SUCCESS;
    BOOL bSuccess = TRUE;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcAnnounceServer\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    __try {
        //
        // Verify it is a license server
        //
        if(lpContext->m_ClientFlags != CLIENT_ACCESS_LSERVER)
        {
            status = TLS_E_ACCESS_DENIED;
        }

        if( status == ERROR_SUCCESS && 
            (dwAnnounceType == TLSANNOUNCE_TYPE_STARTUP || dwAnnounceType == TLSANNOUNCE_TYPE_RESPONSE) )
        {      
            status = TLSRegisterServerWithName(
                                        pszSetupId, 
                                        pszDomainName, 
                                        pszLserverName
                                    );
            if(status == TLS_E_DUPLICATE_RECORD)
            {
                status = ERROR_SUCCESS;
            }
        }

        if(status == ERROR_SUCCESS)
        {
            if(dwAnnounceType == TLSANNOUNCE_TYPE_STARTUP)
            {
                //
                // Prevent loop back, use job to response announce
                //
                status = TLSStartAnnounceResponseJob(
                                                pszSetupId,
                                                pszDomainName,
                                                pszLserverName,
                                                &g_ftLastShutdownTime
                                            );
            }

            if(status == ERROR_SUCCESS)
            {
                // Create a CSSync workobject to sync. local LKP
                status = TLSPushSyncLocalLkpToServer(
                                    pszSetupId,
                                    pszDomainName,
                                    pszLserverName,
                                    pLastStartupTime
                                );
            }
            else
            {
                // reset error code, can't connect back to server -
                // server might be available anymore.
                status = ERROR_SUCCESS;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
    }

    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_ANNOUNCE_SERVER;
    #endif

    *pdwErrCode = TLSMapReturnCode(status);
    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcLookupServer( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [string][in] */ LPTSTR pszLookupSetupId,
    /* [size_is][string][out][in] */ LPTSTR pszLsSetupId,
    /* [out][in] */ PDWORD pcbSetupId,
    /* [size_is][string][out][in] */ LPTSTR pszDomainName,
    /* [ref][out][in] */ PDWORD pcbDomainName,
    /* [size_is][string][out][in] */ LPTSTR pszMachineName,
    /* [ref][out][in] */ PDWORD pcbMachineName,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

Abstract:

    Look up a license server via a license server's setupId.


Parameters:


Returns:


Note:


++*/
{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcLookupServer\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    TLServerInfo ServerInfo;
    DWORD dwStatus = ERROR_SUCCESS;

    __try {

        if(_tcsicmp(pszLookupSetupId, g_pszServerPid) == 0)
        {
            _tcsncpy(
                    pszLsSetupId,
                    g_pszServerPid,
                    min(_tcslen(g_pszServerPid), *pcbSetupId)
                );

            if(*pcbSetupId <= _tcslen(g_pszServerPid))
            {
                dwStatus = TLS_E_INVALID_DATA;
            }
            else
            {
                pszLsSetupId[min(_tcslen(g_pszServerPid), *pcbSetupId - 1)] = _TEXT('\0');
            }
            *pcbSetupId = _tcslen(g_pszServerPid) + 1;

            //--------------------------------------------------------------
            _tcsncpy(
                    pszDomainName, 
                    g_szScope,
                    min(_tcslen(g_szScope), *pcbDomainName)
                );

            if(*pcbDomainName <= _tcslen(g_szScope))
            {
                dwStatus = TLS_E_INVALID_DATA;
            }
            else
            {
                pszDomainName[min(_tcslen(g_szScope), *pcbDomainName - 1)] = _TEXT('\0');
            }
            *pcbDomainName = _tcslen(g_szScope) + 1;

            //--------------------------------------------------------------
            _tcsncpy(
                    pszMachineName,
                    g_szComputerName,
                    min(_tcslen(g_szComputerName), *pcbMachineName)
                );

            if(*pcbMachineName <= _tcslen(g_szComputerName))
            {
                dwStatus = TLS_E_INVALID_DATA;
            }
            else
            {
                pszMachineName[min(_tcslen(g_szComputerName), *pcbMachineName - 1)] = _TEXT('\0');
            }
            *pcbMachineName = _tcslen(g_szComputerName) + 1;

        }
        else
        {
            dwStatus = TLSLookupRegisteredServer(
                                        pszLookupSetupId,
                                        NULL,
                                        pszMachineName,
                                        &ServerInfo
                                    );
            if(dwStatus == ERROR_SUCCESS)
            {
                _tcsncpy(
                        pszLsSetupId, 
                        ServerInfo.GetServerId(),
                        min(_tcslen(ServerInfo.GetServerId()), *pcbSetupId)
                    );

                if(*pcbSetupId <= _tcslen(ServerInfo.GetServerId()))
                {
                    dwStatus = TLS_E_INVALID_DATA;
                }
                else
                {
                    pszLsSetupId[min(_tcslen(ServerInfo.GetServerId()), *pcbSetupId - 1)] = _TEXT('\0');
                }

                *pcbSetupId = _tcslen(ServerInfo.GetServerId()) + 1;

                //--------------------------------------------------------------
                _tcsncpy(
                        pszDomainName, 
                        ServerInfo.GetServerDomain(),
                        min(_tcslen(ServerInfo.GetServerDomain()), *pcbDomainName)
                    );
                if(*pcbDomainName <= _tcslen(ServerInfo.GetServerDomain()))
                {
                    dwStatus = TLS_E_INVALID_DATA;
                }
                else
                {
                    pszDomainName[min(_tcslen(ServerInfo.GetServerDomain()), *pcbDomainName - 1)] = _TEXT('\0');
                }
                *pcbDomainName = _tcslen(ServerInfo.GetServerDomain()) + 1;

                //--------------------------------------------------------------
                _tcsncpy(
                        pszMachineName,
                        ServerInfo.GetServerName(),
                        min(_tcslen(ServerInfo.GetServerName()), *pcbMachineName)
                    );

                if(*pcbMachineName <= _tcslen(ServerInfo.GetServerName()))
                {
                    dwStatus = TLS_E_INVALID_DATA;
                }
                else
                {
                    pszMachineName[min(_tcslen(ServerInfo.GetServerName()), *pcbMachineName - 1)] = _TEXT('\0');
                }
                *pcbMachineName = _tcslen(ServerInfo.GetServerName()) + 1;
            } 
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        dwStatus = GetExceptionCode();
    }

    lpContext->m_LastError=dwStatus;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_SERVERLOOKUP;
    #endif

    *pdwErrCode = TLSMapReturnCode(dwStatus);
    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcAnnounceLicensePack( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ PTLSReplRecord pReplRecord,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

Abstract:

    Private routine for one license server to announce it has particular
    License Pack.

Parameters:



Returns:


++*/
{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    DWORD dwStatus=ERROR_SUCCESS;
    PTLSDbWorkSpace pDbWkSpace=NULL;

    _se_translator_function old_trans_se_func = NULL;
    old_trans_se_func = _set_se_translator( trans_se_func );


    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcAnnounceLicensePack\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    if(lpContext->m_ClientFlags != CLIENT_ACCESS_LSERVER)
    {
        dwStatus = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }

    if(pReplRecord->dwUnionType != UNION_TYPE_LICENSEPACK)
    {
        dwStatus = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    if(!ALLOCATEDBHANDLE(pDbWkSpace, g_GeneralDbTimeout))
    {
        dwStatus = TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    CLEANUPSTMT;
    BEGIN_TRANSACTION(pDbWkSpace);

    try {
        TLSLICENSEPACK LicPack;
        LicPack = pReplRecord->w.ReplLicPack;
        //
        // TODO - verify input parameters
        //
        dwStatus = TLSDBRemoteKeyPackAdd(
                                USEHANDLE(pDbWkSpace),
                                &LicPack
                            );
    }
    catch( SE_Exception e ) {
        dwStatus = e.getSeNumber();
    }
    catch(...) {
        dwStatus = TLS_E_INTERNAL;
    }

    if(TLS_ERROR(dwStatus) && dwStatus != TLS_E_DUPLICATE_RECORD)
    {
        ROLLBACK_TRANSACTION(pDbWkSpace);
    }
    else
    {
        COMMIT_TRANSACTION(pDbWkSpace);
    }

    FREEDBHANDLE(pDbWkSpace);
    
cleanup:

    lpContext->m_LastError=dwStatus;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_ANNOUNCELICENSEPACK;
    #endif

    *pdwErrCode = TLSMapReturnCode(dwStatus);

    //
    // Reset SE translator
    //
    _set_se_translator(old_trans_se_func);
    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcReturnLicensedProduct( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ PTLSLicenseToBeReturn pClientLicense,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++


++*/
{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    DWORD dwStatus=ERROR_SUCCESS;
    CTLSPolicy* pPolicy=NULL;
    PTLSDbWorkSpace pDbWorkSpace;
    PMHANDLE hClient;
   
    _se_translator_function old_trans_se_func = NULL;
    old_trans_se_func = _set_se_translator( trans_se_func );

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcReturnLicensedProduct\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    if(lpContext->m_ClientFlags != CLIENT_ACCESS_LSERVER)
    {
        dwStatus = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }


    pPolicy = AcquirePolicyModule(
                            pClientLicense->pszCompanyName,
                            pClientLicense->pszOrgProductId,
                            FALSE
                        );

    if(pPolicy == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    hClient = GenerateClientId();

    if(!ALLOCATEDBHANDLE(pDbWkSpace, g_GeneralDbTimeout))
    {
        dwStatus=TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    CLEANUPSTMT;
    BEGIN_TRANSACTION(pDbWorkSpace);

    try {
        dwStatus = TLSReturnClientLicensedProduct(
                                        USEHANDLE(pDbWkSpace),
                                        hClient,
                                        pPolicy,
                                        pClientLicense
                                    );
    } 
    catch( SE_Exception e ) {
        dwStatus = e.getSeNumber();
    }
    catch(...) {
        SetLastError(dwStatus = TLS_E_INTERNAL);
    }
    
    if(TLS_ERROR(dwStatus))
    {
        ROLLBACK_TRANSACTION(pDbWorkSpace);
    }
    else
    {
        COMMIT_TRANSACTION(pDbWorkSpace);
    }

    FREEDBHANDLE(pDbWorkSpace);
            

cleanup:

    lpContext->m_LastError=dwStatus;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_RETURNLICENSE;
    #endif

    *pdwErrCode = TLSMapReturnCode(dwStatus);

    if(pPolicy)
    {
        pPolicy->PMLicenseRequest(
                            hClient,
                            REQUEST_COMPLETE,
                            UlongToPtr (dwStatus),
                            NULL
                        );
        
        ReleasePolicyModule(pPolicy);
    }

    _set_se_translator(old_trans_se_func);

    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcChallengeServer(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwClientType,
    /* [in] */ PTLSCHALLENGEDATA pClientChallenge,
    /* [out][in] */ PTLSCHALLENGERESPONSEDATA* pServerResponse,
    /* [out][in] */ PTLSCHALLENGEDATA* pServerChallenge,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

Abstract:

    Private routine for client to challenge server in order for client 
    confirm server's identity. License Server, in addition to response to 
    client's challenge, also generate random challenge data based on 
    client's self-declare type back to client.

Parameter:

    phContext : Client's context handle.
    dwClientType : Client self-pronounce type, valid values are ...
    pClientChallenge : Client challenge data.
    pServerResponse : Server's responses to client's challenge.
    pServerChallenge : Server's challenge to client.
    pdwErrCode : Error code if failed.

Returns:


Notes:

    Private routine for LrWiz and License Server to identify itself.

--*/
{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    DWORD status=ERROR_SUCCESS;

    PTLSCHALLENGEDATA pChallenge=NULL;
    PTLSCHALLENGERESPONSEDATA pResponse = NULL;
    HCRYPTPROV hProv = NULL;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcChallengeServer\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    //if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_ADMIN))
    //{
    //    status = TLS_E_ACCESS_DENIED;
    //    goto cleanup;
    //}

    if(lpContext->m_ContextType != CONTEXTHANDLE_EMPTY_TYPE)
    {
        status = TLS_E_INVALID_SEQUENCE;
        goto cleanup;
    }

    //
    // Input parameters...
    //
    if( pClientChallenge == NULL || 
        pServerResponse == NULL ||
        pServerChallenge == NULL )
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    //
    // Verify Data send by client
    //
    if( pClientChallenge->dwVersion != TLS_CURRENT_CHALLENGE_VERSION ||
        pClientChallenge->cbChallengeData == 0 ||
        pClientChallenge->pbChallengeData == NULL )
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    pResponse = (PTLSCHALLENGERESPONSEDATA)midl_user_allocate(sizeof(TLSCHALLENGERESPONSEDATA));
    if(pResponse == NULL)
    {
        status = GetLastError();
        goto cleanup;
    }
                    
    pChallenge = (PTLSCHALLENGEDATA)AllocateMemory(sizeof(TLSCHALLENGEDATA));
    if(pChallenge == NULL)
    {
        status = GetLastError();
        goto cleanup;
    }

    *pServerChallenge = (PTLSCHALLENGEDATA)midl_user_allocate(sizeof(TLSCHALLENGEDATA));
    if(*pServerChallenge == NULL)
    {
        status = GetLastError();
        goto cleanup;
    }

    //
    // Generate Challenge response data
    //
    status = TLSGenerateChallengeResponseData(
                                        g_hCryptProv,
                                        dwClientType,
                                        pClientChallenge,
                                        &(pResponse->pbResponseData),
                                        &(pResponse->cbResponseData)
                                    );

    if(status != ERROR_SUCCESS)
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    //
    // Generate Server side challenge data
    //
    pChallenge->dwVersion = TLS_CURRENT_CHALLENGE_VERSION;

    if (CryptAcquireContext(&hProv,NULL,NULL,PROV_RSA_FULL,CRYPT_VERIFYCONTEXT)) {
        if (!CryptGenRandom(hProv,sizeof(pChallenge->dwRandom), (BYTE *) &pChallenge->dwRandom)) {
            status = TLS_E_INTERNAL;
            goto cleanup;
        }
    } else {
        status = TLS_E_INTERNAL;
        goto cleanup;
    }

    //
    // This must range from 1 to 128, as it's used as an offset into the
    // challenge data buffer
    //

    pChallenge->dwRandom %= RANDOM_CHALLENGE_DATASIZE;
    pChallenge->dwRandom++;

    status = TLSGenerateRandomChallengeData(
                                        g_hCryptProv,
                                        &(pChallenge->pbChallengeData),
                                        &(pChallenge->cbChallengeData)
                                    );

    // base on type, mark this handle...
    if(dwClientType == CLIENT_TYPE_LRWIZ)
    {
        lpContext->m_ContextType = CONTEXTHANDLE_CHALLENGE_LRWIZ_TYPE;
    }
    else
    {
        lpContext->m_ContextType = CONTEXTHANDLE_CHALLENGE_SERVER_TYPE;
    }

    (*pServerChallenge)->pbChallengeData = (PBYTE)midl_user_allocate(pChallenge->cbChallengeData);
    if((*pServerChallenge)->pbChallengeData == NULL)
    {
        status = GetLastError();
        goto cleanup;
    }

    (*pServerChallenge)->dwVersion = TLS_CURRENT_CHALLENGE_VERSION;
    (*pServerChallenge)->dwRandom = pChallenge->dwRandom;
    (*pServerChallenge)->cbChallengeData = pChallenge->cbChallengeData;
    memcpy(
            (*pServerChallenge)->pbChallengeData,
            pChallenge->pbChallengeData,
            pChallenge->cbChallengeData
        );

    lpContext->m_ContextHandle = (HANDLE)(pChallenge);
    *pServerResponse = pResponse;

cleanup:

    if(status != ERROR_SUCCESS)
    {
        if(pChallenge)
        {
            if(pChallenge->pbChallengeData)
            {
                FreeMemory(pChallenge->pbChallengeData);
            }
            
            if(pChallenge->pbReservedData)
            {
                FreeMemory(pChallenge->pbReservedData);
            }

            FreeMemory(pChallenge);
        }

        if(pResponse)
        {
            if(pResponse->pbResponseData)
            {
                FreeMemory(pResponse->pbResponseData);
            }

            if(pResponse->pbReservedData)
            {
                FreeMemory(pResponse->pbReservedData);
            }
            
            midl_user_free(pResponse);
        }
    }

    if (hProv)
        CryptReleaseContext(hProv,0);

    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_CHALLENGESERVER;
    #endif

    *pdwErrCode = TLSMapReturnCode(status);
    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcResponseServerChallenge(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ PTLSCHALLENGERESPONSEDATA pClientResponse,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

Abstract:

    Client's responses to Server challenge returned TLSRpcChallengeServer(),
    must have call TLSRpcChallengeServer().

Parameter:

    phContext:
    pClientResponses: Client's response to server's challenge.
    pdwErrCode : Return error code.


Returns:


Note:

--*/
{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    DWORD status=ERROR_SUCCESS;
    DWORD dwClientType;
    PTLSCHALLENGEDATA pServerToClientChallenge;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcResponseServerChallenge\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    //if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_ADMIN))
    //{
    //    status = TLS_E_ACCESS_DENIED;
    //    goto cleanup;
    //}

    if( pClientResponse == NULL ||
        pClientResponse->pbResponseData == NULL || 
        pClientResponse->cbResponseData == 0 )
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    if(lpContext->m_ContextType != CONTEXTHANDLE_CHALLENGE_SERVER_TYPE &&
       lpContext->m_ContextType != CONTEXTHANDLE_CHALLENGE_LRWIZ_TYPE)
    {
        status = TLS_E_INVALID_SEQUENCE;
        goto cleanup;
    }

    if(lpContext->m_ContextHandle == NULL)
    {
        status = TLS_E_INTERNAL;
        goto cleanup;
    }

    if(lpContext->m_ContextType == CONTEXTHANDLE_CHALLENGE_LRWIZ_TYPE)
    {
        dwClientType = CLIENT_TYPE_LRWIZ;
    }
    else
    {
        dwClientType = CLIENT_TYPE_TLSERVER;
    }

    pServerToClientChallenge = (PTLSCHALLENGEDATA)lpContext->m_ContextHandle; 

    //
    // base on client type, verify challenge response data
    //
    status = TLSVerifyChallengeResponse(
                                g_hCryptProv,
                                dwClientType,
                                pServerToClientChallenge,
                                pClientResponse
                            );

    if(status != ERROR_SUCCESS)
    {
        status = TLS_E_INVALID_DATA;
    }
    else
    {
        if(dwClientType == CLIENT_TYPE_LRWIZ)
        {
            lpContext->m_ClientFlags |= CLIENT_ACCESS_LRWIZ;
        }        
        else
        {
            lpContext->m_ClientFlags |= CLIENT_ACCESS_LSERVER;
        }
    }

    if(pServerToClientChallenge != NULL)
    {
        FreeMemory(pServerToClientChallenge->pbChallengeData);
        FreeMemory(pServerToClientChallenge);
    }
        
    lpContext->m_ContextHandle = NULL;
    lpContext->m_ContextType = CONTEXTHANDLE_EMPTY_TYPE;

cleanup:

    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_RESPONSESERVERCHALLENGE;
    #endif

    *pdwErrCode = TLSMapReturnCode(status);
    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcGetTlsPrivateData( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwPrivateDataType,
    /* [switch_is][in] */ PTLSPrivateDataUnion pSearchData,
    /* [ref][out][in] */ PDWORD pdwRetDataType,
    /* [switch_is][out] */ PTLSPrivateDataUnion __RPC_FAR *ppPrivateData,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )

/*++

Abstract:

    Retrieve license server's private data, this include Server's
    unique ID, PID, and registered SPK if any.

Parameters:

    phContext : Client's context handle.
    dwPrivateDataType : Type of private data interested.
    pSearchData : Type of data to search, currently ignore.
    pdwRetDataType : Return data type.
    ppPrivateData : License Server's private data.
    pdwErrCode : Error Code.

Returns:


Note:

    Only LrWiz and License Server can invoke this RPC call.

--*/

{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    DWORD status=ERROR_SUCCESS;
    DWORD cbSource=0;
    PBYTE pbSource=NULL;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcGetTlsPrivateData\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    //
    // relax restriction on who can get private data
    //
    if( dwPrivateDataType != TLS_PRIVATEDATA_PID && 
        dwPrivateDataType != TLS_PRIVATEDATA_UNIQUEID )
    {
        if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_LRWIZ))
        {
            status = TLS_E_ACCESS_DENIED;
            goto cleanup;
        }
    }

    if( dwPrivateDataType < TLS_PRIVATEDATA_MIN ||
        dwPrivateDataType > TLS_PRIVATEDATA_MAX )
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    //
    // Not supported yet...
    //
    if(dwPrivateDataType == TLS_PRIVATEDATA_INSTALLED_CERT)
    {
        status = TLS_E_NOTSUPPORTED;
        goto cleanup;
    }
        
    //
    // Don't really need this but we might need to support
    // re-generate of License Server ID
    //
    if(!AcquireAdministrativeLock(INFINITE))
    {
        status = TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    switch(dwPrivateDataType)
    {
        case TLS_PRIVATEDATA_UNIQUEID:
            pbSource = (PBYTE)g_pszServerUniqueId;
            cbSource = g_cbServerUniqueId;
            break;

        case TLS_PRIVATEDATA_PID:
            pbSource = (PBYTE)g_pszServerPid;
            cbSource = g_cbServerPid;
            break;

        case TLS_PRIVATEDATA_SPK:
            pbSource = g_pbServerSPK;
            cbSource = g_cbServerSPK;
    }

    //
    // Currently, what you ask is what you get.
    //
    *pdwRetDataType = dwPrivateDataType;

    if( (dwPrivateDataType != TLS_PRIVATEDATA_SYSTEMLANGID) && 
        (pbSource == NULL || cbSource == 0) )
    {
        status = TLS_E_RECORD_NOTFOUND;
    }
    else
    {
        *ppPrivateData = (PTLSPrivateDataUnion)midl_user_allocate(sizeof(TLSPrivateDataUnion));
        if(*ppPrivateData != NULL)
        {
            memset(
                    *ppPrivateData,
                    0,
                    sizeof(TLSPrivateDataUnion)
                );

            if(*pdwRetDataType == TLS_PRIVATEDATA_SYSTEMLANGID)
            {
                (*ppPrivateData)->systemLangId = GetSystemDefaultLangID();
            }
            else if(*pdwRetDataType == TLS_PRIVATEDATA_SPK)
            {
                (*ppPrivateData)->SPK.cbSPK = cbSource;
                (*ppPrivateData)->SPK.pbSPK = pbSource;
				(*ppPrivateData)->SPK.pCertExtensions = g_pCertExtensions;

                //(*ppPrivateData)->SPK.pCertExtensions = (PTLSCERT_EXTENSIONS)midl_user_allocate(g_cbCertExtensions);
                //memcpy(
                //        (*ppPrivateData)->SPK.pCertExtensions,
                //        g_pCertExtensions,
                //        g_cbCertExtensions
                //    );
            }
            else
            {
                (*ppPrivateData)->BinaryData.cbData = cbSource;
                (*ppPrivateData)->BinaryData.pbData = pbSource;
            }
        }
        else
        {
            status = ERROR_OUTOFMEMORY;
        }
    }

    ReleaseAdministrativeLock();

cleanup:
    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_GETPRIVATEDATA;
    #endif

    *pdwErrCode = TLSMapReturnCode(status);
    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcSetTlsPrivateData(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD dwPrivateDataType,
    /* [switch_is][in] */ PTLSPrivateDataUnion pPrivateData,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )

/*++

Abstract:

    Private routine for LrWiz to set license server's private data.

Parameter:

    phContext: Client context handle.
    dwPrivateDataType : Type of private data to set.
    pPrivateData : Private data to set/install.
    pdwErrCode : Server return code.
    
Returns:


Note:

    Only support installing of SPK/Extension at this time.

--*/
{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    DWORD status=ERROR_SUCCESS;
    DWORD dwSpkVerifyResult;

    _se_translator_function old_trans_se_func = NULL;
    old_trans_se_func = _set_se_translator( trans_se_func );



    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcDepositeSPK\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );

    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_LRWIZ))
    {
        status = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }

    //
    // Only support SPK at this time
    //
    if(dwPrivateDataType != TLS_PRIVATEDATA_SPK)
    {
        status = TLS_E_INVALID_DATA;
        goto cleanup;
    }

    //
    // Lock all RPC calls related to issuing certificate
    //
    if(!AcquireRPCExclusiveLock(INFINITE))
    {
        status = TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    do {
        //if(g_pbServerSPK != NULL && g_cbServerSPK != 0)
        //{
        //    status = TLS_E_SPKALREADYEXIST;
        //    break;
        //}

        if(AcquireAdministrativeLock(INFINITE))
        {
            try {
                status = TLSReGenSelfSignCert(
                                            g_hCryptProv,
                                            pPrivateData->SPK.pbSPK,
                                            pPrivateData->SPK.cbSPK,
                                            pPrivateData->SPK.pCertExtensions->cExtension,
                                            pPrivateData->SPK.pCertExtensions->rgExtension
                                        );
            }
            catch( SE_Exception e ) {
                status = e.getSeNumber();
            }
            catch(...) {
                status = TLS_E_INTERNAL;
            }

            ReleaseAdministrativeLock();
        }
        else
        {
            status = TLS_E_ALLOCATE_HANDLE;
        }            
    } while(FALSE);

    ReleaseRPCExclusiveLock();

cleanup:

    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_SETPRIVATEDATA;
    #endif

    *pdwErrCode = TLSMapReturnCode(status);

    //
    // Reset SE translator
    //
    _set_se_translator(old_trans_se_func);

    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcTriggerReGenKey(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ BOOL bRegenKey,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )

/*++

Abstract:

    Private routine to force license server to re-generate its
    public/private key pair, all installed certificates/SPK are
    deleted, User are required to re-register license server.

Parameters:

    phContext : Client context handle.
    bKeepSPKAndExtension : For future use only.
    pdwErrCode : Return error code.

Returns:


++*/

{
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    DWORD status=ERROR_SUCCESS;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcTriggerReGenKey\n"),
            lpContext->m_Client
        );

    _se_translator_function old_trans_se_func = NULL;
    old_trans_se_func = _set_se_translator( trans_se_func );

    InterlockedIncrement( &lpContext->m_RefCount );

    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_LRWIZ))
    {
        status = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }

    LPCTSTR pString[1];

    pString[0] = lpContext->m_Client;
    
    TLSLogEventString(
            EVENTLOG_INFORMATION_TYPE,
            TLS_I_TRIGGER_REGENKEY,
            1,
            pString
        );

    //
    // Block ALL RPC calls
    //
    if(!AcquireRPCExclusiveLock(INFINITE))
    {
        status=TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    do {
        if(!AcquireAdministrativeLock(INFINITE))
        {
            status = TLS_E_ALLOCATE_HANDLE;
            break;
        }

        try {
            status = TLSReGenKeysAndReloadServerCert(
                                bRegenKey
                            );
        }
        catch( SE_Exception e ) {
            status = e.getSeNumber();
        }
        catch(...) {
            status = TLS_E_INTERNAL;
        }

        ReleaseAdministrativeLock();

    } while(FALSE);

    ReleaseRPCExclusiveLock();

cleanup:
    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_TRIGGERREGENKEY;
    #endif

    *pdwErrCode = TLSMapReturnCode(status);

    //
    // Reset SE translator
    //
    _set_se_translator(old_trans_se_func);

    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcTelephoneRegisterLKP(
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ PBYTE pbData,
    /* [ref][out] */ PDWORD pdwErrCode
    )

/*++

--*/

{
    DWORD           status=ERROR_SUCCESS;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    PTLSDbWorkSpace  pDbWkSpace;
    LSKeyPack keypack;

    _se_translator_function old_trans_se_func = NULL;
    old_trans_se_func = _set_se_translator( trans_se_func );

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcTelephoneRegisterLKP\n"),
            lpContext->m_Client
        );


    InterlockedIncrement( &lpContext->m_RefCount );
    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_LRWIZ))
    {
        status = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }

    if(!ALLOCATEDBHANDLE(pDbWkSpace, g_GeneralDbTimeout))
    {
        status=TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    CLEANUPSTMT;
    BEGIN_TRANSACTION(pDbWkSpace);

    try {
        status = TLSDBTelephoneRegisterLicenseKeyPack(
                                            USEHANDLE(pDbWkSpace),
                                            g_pszServerPid,
                                            pbData,
                                            cbData,
                                            &keypack
                                        );
    }
    catch( SE_Exception e ) {
        status = e.getSeNumber();
    }
    catch(...) {
        status = TLS_E_INTERNAL;
    }

    if(TLS_ERROR(status)) 
    {
        ROLLBACK_TRANSACTION(pDbWkSpace);
    }
    else
    {
        COMMIT_TRANSACTION(pDbWkSpace);
    }

    FREEDBHANDLE(pDbWkSpace);

    //
    // Post a sync work object
    //
    if(status == ERROR_SUCCESS)
    {
        if(TLSAnnounceLKPToAllRemoteServer(
                                        keypack.dwKeyPackId,
                                        0
                                    ) != ERROR_SUCCESS)
        {
            TLSLogWarningEvent(TLS_W_ANNOUNCELKP_FAILED);
        }
    }

cleanup:


    lpContext->m_LastError=status;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_TELEPHONEREGISTERLKP;
    #endif


    *pdwErrCode = TLSMapReturnCode(status);

    //
    // Reset SE translator
    //
    _set_se_translator(old_trans_se_func);

    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcAllocateInternetLicense( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ const CHALLENGE_CONTEXT ChallengeContext,
    /* [in] */ const PTLSLICENSEREQUEST pRequest,
    /* [string][in] */ LPTSTR pMachineName,
    /* [string][in] */ LPTSTR pUserName,
    /* [in] */ const DWORD cbChallengeResponse,
    /* [size_is][in] */ const PBYTE pbChallengeResponse,
    /* [out] */ PDWORD pcbLicense,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *pbLicense,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++



--*/
{
    return TLSRpcRequestNewLicense(
                                phContext,
                                ChallengeContext,
                                pRequest,
                                pMachineName,
                                pUserName,
                                cbChallengeResponse,
                                pbChallengeResponse,
                                FALSE,
                                pcbLicense,
                                pbLicense,
                                pdwErrCode
                            );

}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcAllocateInternetLicenseEx( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ const CHALLENGE_CONTEXT ChallengeContext,
    /* [in] */ const PTLSLICENSEREQUEST pRequest,
    /* [string][in] */ LPTSTR pMachineName,
    /* [string][in] */ LPTSTR pUserName,
    /* [in] */ const DWORD cbChallengeResponse,
    /* [size_is][in] */ const PBYTE pbChallengeResponse,
    /* [ref][out] */ PTLSInternetLicense pInternetLicense,
    /* [ref][out] */ PDWORD pdwErrCode
    )
/*++

--*/
{
    PBYTE pbLicense = NULL;
    DWORD cbLicense = 0;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD index = 0;
    PLICENSEDPRODUCT pLicensedProduct = NULL;
    DWORD dwNumLicensedProduct = 0;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;

    if(lpContext == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcAllocateInternetLicenseEx\n"),
            lpContext->m_Client
        );

    //
    // Internally forward the request.
    //
    dwStatus = TLSRpcAllocateInternetLicense(
                                        phContext,
                                        ChallengeContext,
                                        pRequest,
                                        pMachineName,
                                        pUserName,
                                        cbChallengeResponse,
                                        pbChallengeResponse,
                                        &cbLicense,
                                        &pbLicense,
                                        pdwErrCode
                                    );

    if(*pdwErrCode >= LSERVER_ERROR_BASE)
    {
        goto cleanup;
    }

    //
    // decode the license.
    //
    dwStatus = LSVerifyDecodeClientLicense(
                            pbLicense, 
                            cbLicense, 
                            g_pbSecretKey, 
                            g_cbSecretKey,
                            &dwNumLicensedProduct,
                            pLicensedProduct
                        );

    //
    // Internet license can only have one licensed product
    //
    if(dwStatus != LICENSE_STATUS_OK || dwNumLicensedProduct == 0 || dwNumLicensedProduct > 1)
    {
        dwStatus = TLS_E_INTERNAL;
        goto cleanup;
    }

    pLicensedProduct = (PLICENSEDPRODUCT)AllocateMemory(
                                                    dwNumLicensedProduct * sizeof(LICENSEDPRODUCT)
                                                );
    if(pLicensedProduct == NULL)
    {
        dwStatus = TLS_E_ALLOCATE_MEMORY;
        goto cleanup;
    }

    dwStatus = LSVerifyDecodeClientLicense(
                            pbLicense, 
                            cbLicense, 
                            g_pbSecretKey, 
                            g_cbSecretKey,
                            &dwNumLicensedProduct,
                            pLicensedProduct
                        );

    if(dwStatus != LICENSE_STATUS_OK)
    {
        dwStatus = TLS_E_INTERNAL;
        goto cleanup;
    }

    //
    // Sets up returns. 
    //
    SAFESTRCPY(pInternetLicense->szServerId, pLicensedProduct->szIssuerId);
    SAFESTRCPY(pInternetLicense->szServerName, pLicensedProduct->szIssuer);
    pInternetLicense->ulSerialNumber = pLicensedProduct->ulSerialNumber;
    pInternetLicense->dwQuantity = pLicensedProduct->dwQuantity;

cleanup:

    lpContext->m_LastError=dwStatus;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_ALLOCATEINTERNETLICNESEEX;
    #endif

    if(*pdwErrCode == ERROR_SUCCESS)
    {
        *pdwErrCode = TLSMapReturnCode(dwStatus);
    }

    if(pLicensedProduct != NULL)
    {
        for(index =0; index < dwNumLicensedProduct; index++)
        {
            LSFreeLicensedProduct(pLicensedProduct+index);
        }

        FreeMemory(pLicensedProduct);
    }

    if(pbLicense != NULL)
    {
        midl_user_free(pbLicense);
    }

    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcReturnInternetLicenseEx( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ const PTLSLICENSEREQUEST pRequest,
    /* [in] */ const ULARGE_INTEGER __RPC_FAR *pulSerialNumber,
    /* [in] */ DWORD dwQuantity,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    TLSLicenseToBeReturn TobeReturn;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    PTLSDbWorkSpace pDbWorkSpace = NULL;
    CTLSPolicy* pPolicy = NULL;
    PMHANDLE hClient;

    PMLICENSEREQUEST PMLicenseRequest;
    PPMLICENSEREQUEST pAdjustedRequest;

    TCHAR szCompanyName[LSERVER_MAX_STRING_SIZE+2];
    TCHAR szProductId[LSERVER_MAX_STRING_SIZE+2];

    
    _se_translator_function old_trans_se_func = NULL;
    old_trans_se_func = _set_se_translator( trans_se_func );


    if(VerifyLicenseRequest(pRequest) == FALSE)
    {
        SetLastError(dwStatus = TLS_E_INVALID_DATA);
        goto cleanup;
    }

    if(lpContext == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcReturnInternetLicenseEx\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );
    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_REQUEST))
    {
        dwStatus = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }

    memset(szCompanyName, 0, sizeof(szCompanyName));
    memset(szProductId, 0, sizeof(szProductId));

    memcpy(
            szCompanyName,
            pRequest->ProductInfo.pbCompanyName,
            min(pRequest->ProductInfo.cbCompanyName, sizeof(szCompanyName)-sizeof(TCHAR))
        );

    memcpy(
            szProductId,
            pRequest->ProductInfo.pbProductID,
            min(pRequest->ProductInfo.cbProductID, sizeof(szProductId)-sizeof(TCHAR))
        );

    //
    // Allocate policy module, must have the right policy module to
    // return license.
    //
    pPolicy = AcquirePolicyModule(
                            szCompanyName,
                            szProductId,
                            TRUE
                        );

    if(pPolicy == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    hClient = GenerateClientId();


    //
    // Convert request to PMLICENSEREQUEST
    //
    TlsLicenseRequestToPMLicenseRequest(
                        LICENSETYPE_LICENSE,
                        pRequest,
                        _TEXT(""),
                        _TEXT(""),
                        0,
                        &PMLicenseRequest
                    );

    //
    // Ask policy module the actual product ID
    //
    dwStatus = pPolicy->PMLicenseRequest(
                                hClient,
                                REQUEST_NEW,
                                (PVOID) &PMLicenseRequest,
                                (PVOID *) &pAdjustedRequest
                            );

    memset(&TobeReturn, 0, sizeof(TobeReturn));

    TobeReturn.dwQuantity = dwQuantity;
    TobeReturn.dwKeyPackId = pulSerialNumber->HighPart;
    TobeReturn.dwLicenseId = pulSerialNumber->LowPart;
    TobeReturn.dwPlatformID = pAdjustedRequest->dwPlatformId;
    TobeReturn.cbEncryptedHwid = pRequest->cbEncryptedHwid;
    TobeReturn.pbEncryptedHwid = pRequest->pbEncryptedHwid;
    TobeReturn.dwProductVersion = pAdjustedRequest->dwProductVersion;
    TobeReturn.pszOrgProductId = szProductId;
    TobeReturn.pszCompanyName = szCompanyName;
    TobeReturn.pszProductId = pAdjustedRequest->pszProductId;

    //
    // Allocate DB handle
    //
    if(!ALLOCATEDBHANDLE(pDbWkSpace, g_GeneralDbTimeout))
    {
        dwStatus = TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    CLEANUPSTMT;
    BEGIN_TRANSACTION(pDbWorkSpace);

    try {
        dwStatus = TLSReturnClientLicensedProduct(
                                        USEHANDLE(pDbWkSpace),
                                        hClient,
                                        pPolicy,
                                        &TobeReturn
                                    );
    }
    catch( SE_Exception e ) {
        dwStatus = e.getSeNumber();
    }
    catch(...) {
        SetLastError(dwStatus = TLS_E_INTERNAL);
    }
    
    if(TLS_ERROR(dwStatus))
    {
        ROLLBACK_TRANSACTION(pDbWorkSpace);
    }
    else
    {
        COMMIT_TRANSACTION(pDbWorkSpace);
    }

    FREEDBHANDLE(pDbWorkSpace);
    
cleanup:

    lpContext->m_LastError=dwStatus;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_RETURNINTERNETLICENSEEX;
    #endif

    *pdwErrCode = TLSMapReturnCode(dwStatus);

    if(pPolicy)
    {
        pPolicy->PMLicenseRequest(
                            hClient,
                            REQUEST_COMPLETE,
                            UlongToPtr (dwStatus),
                            NULL
                        );
        
        ReleasePolicyModule(pPolicy);
    }

    //
    // Reset SE translator
    //
    _set_se_translator(old_trans_se_func);
    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////////////

error_status_t 
TLSRpcReturnInternetLicense( 
    /* [in] */ PCONTEXT_HANDLE phContext,
    /* [in] */ DWORD cbLicense,
    /* [size_is][in] */ PBYTE pbLicense,
    /* [ref][out][in] */ PDWORD pdwErrCode
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD index = 0;
    PLICENSEDPRODUCT pLicensedProduct = NULL;
    DWORD dwNumLicensedProduct = 0;
    TLSLicenseToBeReturn TobeReturn;
    LPCLIENTCONTEXT lpContext = (LPCLIENTCONTEXT)phContext;
    PTLSDbWorkSpace pDbWorkSpace = NULL;
    CTLSPolicy* pPolicy = NULL;
    PMHANDLE hClient;


    _se_translator_function old_trans_se_func = NULL;
    old_trans_se_func = _set_se_translator( trans_se_func );



    if(lpContext == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_RPC,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("%s : TLSRpcReturnInternetLicense\n"),
            lpContext->m_Client
        );

    InterlockedIncrement( &lpContext->m_RefCount );
    if(!(lpContext->m_ClientFlags & CLIENT_ACCESS_REQUEST))
    {
        dwStatus = TLS_E_ACCESS_DENIED;
        goto cleanup;
    }
    
    // -------------------------------------------------------
    // decode the license.
    // -------------------------------------------------------
    dwStatus = LSVerifyDecodeClientLicense(
                            pbLicense, 
                            cbLicense, 
                            g_pbSecretKey, 
                            g_cbSecretKey,
                            &dwNumLicensedProduct,
                            pLicensedProduct
                        );

    // -------------------------------------------------------
    // Internet license can only have one licensed product
    // -------------------------------------------------------
    if(dwStatus != LICENSE_STATUS_OK || dwNumLicensedProduct == 0 || dwNumLicensedProduct > 1)
    {
        dwStatus = TLS_E_INVALID_LICENSE;
        goto cleanup;
    }

    pLicensedProduct = (PLICENSEDPRODUCT)AllocateMemory(
                                                    dwNumLicensedProduct * sizeof(LICENSEDPRODUCT)
                                                );
    if(pLicensedProduct == NULL)
    {
        dwStatus = TLS_E_ALLOCATE_MEMORY;
        goto cleanup;
    }

    dwStatus = LSVerifyDecodeClientLicense(
                            pbLicense, 
                            cbLicense, 
                            g_pbSecretKey, 
                            g_cbSecretKey,
                            &dwNumLicensedProduct,
                            pLicensedProduct
                        );

    if(dwStatus != LICENSE_STATUS_OK)
    {
        dwStatus = TLS_E_INVALID_LICENSE;
        goto cleanup;
    }


    TobeReturn.dwQuantity = pLicensedProduct->dwQuantity;
    TobeReturn.dwKeyPackId = pLicensedProduct->ulSerialNumber.HighPart;
    TobeReturn.dwLicenseId = pLicensedProduct->ulSerialNumber.LowPart;
    TobeReturn.dwPlatformID = pLicensedProduct->LicensedProduct.dwPlatformID;
    TobeReturn.cbEncryptedHwid = pLicensedProduct->LicensedProduct.cbEncryptedHwid;
    TobeReturn.pbEncryptedHwid = pLicensedProduct->LicensedProduct.pbEncryptedHwid;
    TobeReturn.dwProductVersion = MAKELONG(
                                pLicensedProduct->pLicensedVersion->wMinorVersion,
                                pLicensedProduct->pLicensedVersion->wMajorVersion
                            );

    TobeReturn.pszOrgProductId = (LPTSTR) pLicensedProduct->pbOrgProductID;
    TobeReturn.pszCompanyName = (LPTSTR) pLicensedProduct->LicensedProduct.pProductInfo->pbCompanyName;
    TobeReturn.pszProductId = (LPTSTR) pLicensedProduct->LicensedProduct.pProductInfo->pbProductID;
    TobeReturn.pszUserName = (LPTSTR) pLicensedProduct->szLicensedUser;
    TobeReturn.pszMachineName = pLicensedProduct->szLicensedClient;


    //
    // Allocate policy module, must have the right policy module to
    // return license.
    //
    pPolicy = AcquirePolicyModule(
                            TobeReturn.pszCompanyName,
                            TobeReturn.pszOrgProductId,
                            TRUE
                        );

    if(pPolicy == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    hClient = GenerateClientId();

    //
    // Allocate DB handle
    //
    if(!ALLOCATEDBHANDLE(pDbWkSpace, g_GeneralDbTimeout))
    {
        dwStatus = TLS_E_ALLOCATE_HANDLE;
        goto cleanup;
    }

    CLEANUPSTMT;
    BEGIN_TRANSACTION(pDbWorkSpace);

    try {
        dwStatus = TLSReturnClientLicensedProduct(
                                        USEHANDLE(pDbWkSpace),
                                        hClient,
                                        pPolicy,
                                        &TobeReturn
                                    );
    }
    catch( SE_Exception e ) {
        dwStatus = e.getSeNumber();
    }
    catch(...) {
        SetLastError(dwStatus = TLS_E_INTERNAL);
    }
    
    if(TLS_ERROR(dwStatus))
    {
        ROLLBACK_TRANSACTION(pDbWorkSpace);
    }
    else
    {
        COMMIT_TRANSACTION(pDbWorkSpace);
    }

    FREEDBHANDLE(pDbWorkSpace);
    
cleanup:

    lpContext->m_LastError=dwStatus;
    InterlockedDecrement( &lpContext->m_RefCount );

    #if DBG
    lpContext->m_LastCall = RPC_CALL_RETURNINTERNETLICENSE;
    #endif

    *pdwErrCode = TLSMapReturnCode(dwStatus);

    if(pLicensedProduct != NULL)
    {
        for(index =0; index < dwNumLicensedProduct; index++)
        {
            LSFreeLicensedProduct(pLicensedProduct+index);
        }

        FreeMemory(pLicensedProduct);
    }

    if(pPolicy)
    {
        pPolicy->PMLicenseRequest(
                            hClient,
                            REQUEST_COMPLETE,
                            UlongToPtr (dwStatus),
                            NULL
                        );
        
        ReleasePolicyModule(pPolicy);
    }

    //
    // Reset SE translator
    //
    _set_se_translator(old_trans_se_func);
    return RPC_S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\utils.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        utils.cpp
//
// Contents:    Hydra License Server Service Control Manager Interface
//
// History:     12-09-97    HueiWang    Modified from MSDN RPC Service Sample
//
//---------------------------------------------------------------------------
#ifndef __LS_UTILS_H
#define __LS_UTILS_H

#include <windows.h>
#include <stdio.h>

#ifdef __cplusplus
extern "C" {
#endif

    void 
    TLSLogInfoEvent(
        DWORD
    );

    void 
    TLSLogWarningEvent(
        DWORD
    );

    void 
    TLSLogErrorEvent(
        DWORD
    );

    void 
    TLSLogEvent(
        DWORD, 
        DWORD,
        DWORD, ... 
    );

    void
    TLSLogEventString(
        IN DWORD dwType,
        IN DWORD dwEventId,
        IN WORD wNumString,
        IN LPCTSTR* lpStrings
    );

    BOOL 
    LoadResourceString(
        DWORD dwId, 
        LPTSTR szBuf, 
        DWORD dwBufSize
    );

    BOOL 
    APIENTRY
    TLSCheckTokenMembership(
        IN HANDLE TokenHandle OPTIONAL,
        IN PSID SidToCheck,
        OUT PBOOL IsMember
    );

    DWORD 
    IsAdmin(
        BOOL* bMember
    );

    void 
    UnixTimeToFileTime(
        time_t t, 
        LPFILETIME pft
    );

    BOOL
    FileTimeToLicenseDate(
        LPFILETIME pft,
        DWORD* t
    );

    BOOL
    TLSSystemTimeToFileTime(
        SYSTEMTIME* pSysTime,
        LPFILETIME pfTime
    );

    BOOL
    FileExists(
        IN  PCTSTR           FileName,
        OUT PWIN32_FIND_DATA FindData   OPTIONAL
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\utils.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        utils.cpp
//
// Contents:    Hydra License Server Service Control Manager Interface
//
// History:     12-09-97    HueiWang    Modified from MSDN RPC Service Sample
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include <lm.h>
#include <time.h>

#include "utils.h"


/////////////////////////////////////////////////////////////////////////////
BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATA findData;
    HANDLE FindHandle;
    DWORD Error;

    FindHandle = FindFirstFile(FileName,&findData);
    if(FindHandle == INVALID_HANDLE_VALUE) 
    {
        Error = GetLastError();
    } 
    else 
    {
        FindClose(FindHandle);
        if(FindData) 
        {
            *FindData = findData;
        }
        Error = NO_ERROR;
    }

     SetLastError(Error);
    return (Error == NO_ERROR);
}

/*----------------------------------------------------------------------------
Routine Description:

    This function checks to see whether the specified sid is enabled in
    the specified token.

Arguments:

    TokenHandle - If present, this token is checked for the sid. If not
        present then the current effective token will be used. This must
        be an impersonation token.

    SidToCheck - The sid to check for presence in the token

    IsMember - If the sid is enabled in the token, contains TRUE otherwise
        false.

Return Value:

    TRUE - The API completed successfully. It does not indicate that the
        sid is a member of the token.

    FALSE - The API failed. A more detailed status code can be retrieved
        via GetLastError()


Note : Code modified from 5.0 \\rastaman\ntwin\src\base\advapi\security.c
----------------------------------------------------------------------------*/
BOOL
TLSCheckTokenMembership(
    IN HANDLE TokenHandle OPTIONAL,
    IN PSID SidToCheck,
    OUT PBOOL IsMember
    )
{
    HANDLE ProcessToken = NULL;
    HANDLE EffectiveToken = NULL;
    DWORD  Status = ERROR_SUCCESS;
    PISECURITY_DESCRIPTOR SecDesc = NULL;
    ULONG SecurityDescriptorSize;
    GENERIC_MAPPING GenericMapping = { STANDARD_RIGHTS_READ,
                                       STANDARD_RIGHTS_EXECUTE,
                                       STANDARD_RIGHTS_WRITE,
                                       STANDARD_RIGHTS_ALL };
    //
    // The size of the privilege set needs to contain the set itself plus
    // any privileges that may be used. The privileges that are used
    // are SeTakeOwnership and SeSecurity, plus one for good measure
    //
    BYTE PrivilegeSetBuffer[sizeof(PRIVILEGE_SET) + 3*sizeof(LUID_AND_ATTRIBUTES)];
    PPRIVILEGE_SET PrivilegeSet = (PPRIVILEGE_SET) PrivilegeSetBuffer;
    ULONG PrivilegeSetLength = sizeof(PrivilegeSetBuffer);
    ACCESS_MASK AccessGranted = 0;
    BOOL AccessStatus = FALSE;
    PACL Dacl = NULL;

    #define MEMBER_ACCESS 1

    *IsMember = FALSE;

    //
    // Get a handle to the token
    //
    if (TokenHandle != NULL)
    {
        EffectiveToken = TokenHandle;
    }
    else
    {
        if(!OpenThreadToken(GetCurrentThread(),
                            TOKEN_QUERY,
                            FALSE,              // don't open as self
                            &EffectiveToken))
        {
            //
            // if there is no thread token, try the process token
            //
            if((Status=GetLastError()) == ERROR_NO_TOKEN)
            {
                if(!OpenProcessToken(GetCurrentProcess(),
                                     TOKEN_QUERY | TOKEN_DUPLICATE,
                                     &ProcessToken))
                {
                    Status = GetLastError();
                }

                //
                // If we have a process token, we need to convert it to an
                // impersonation token
                //
                if (Status == ERROR_SUCCESS)
                {
                    BOOL Result;
                    Result = DuplicateToken(ProcessToken,
                                            SecurityImpersonation,
                                            &EffectiveToken);
                    CloseHandle(ProcessToken);
                    if (!Result)
                    {
                        return(FALSE);
                    }
                }
            }

            if (Status != ERROR_SUCCESS)
            {
                goto Cleanup;
            }
        }
    }

    //
    // Construct a security descriptor to pass to access check
    //

    //
    // The size is equal to the size of an SD + twice the length of the SID
    // (for owner and group) + size of the DACL = sizeof ACL + size of the
    // ACE, which is an ACE + length of
    // ths SID.
    //

    SecurityDescriptorSize = sizeof(SECURITY_DESCRIPTOR) +
                                sizeof(ACCESS_ALLOWED_ACE) +
                                sizeof(ACL) +
                                3 * GetLengthSid(SidToCheck);

    SecDesc = (PISECURITY_DESCRIPTOR) LocalAlloc(LMEM_ZEROINIT, SecurityDescriptorSize );
    if (SecDesc == NULL)
    {
        Status = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    Dacl = (PACL) (SecDesc + 1);

    InitializeSecurityDescriptor(SecDesc, SECURITY_DESCRIPTOR_REVISION);

    //
    // Fill in fields of security descriptor
    //
    SetSecurityDescriptorOwner(SecDesc, SidToCheck, FALSE);
    SetSecurityDescriptorGroup(SecDesc, SidToCheck, FALSE);

    if(!InitializeAcl(  Dacl,
                        SecurityDescriptorSize - sizeof(SECURITY_DESCRIPTOR),
                        ACL_REVISION))
    {
        Status=GetLastError();
        goto Cleanup;
    }

    if(!AddAccessAllowedAce(Dacl, ACL_REVISION, MEMBER_ACCESS, SidToCheck))
    {
        Status=GetLastError();  
        goto Cleanup;
    }

    if(!SetSecurityDescriptorDacl(SecDesc, TRUE, Dacl, FALSE))
    {
        Status=GetLastError();
        goto Cleanup;
    }

    if(!AccessCheck(SecDesc,
                    EffectiveToken,
                    MEMBER_ACCESS,
                    &GenericMapping,
                    PrivilegeSet,
                    &PrivilegeSetLength,
                    &AccessGranted,
                    &AccessStatus))
    {
        Status=GetLastError();
        goto Cleanup;
    }

    //
    // if the access check failed, then the sid is not a member of the
    // token
    //
    if ((AccessStatus == TRUE) && (AccessGranted == MEMBER_ACCESS))
    {
        *IsMember = TRUE;
    }


Cleanup:
    if (TokenHandle == NULL && EffectiveToken != NULL)
    {
        CloseHandle(EffectiveToken);
    }

    if (SecDesc != NULL)
    {
        LocalFree(SecDesc);
    }

    return (Status == ERROR_SUCCESS) ? TRUE : FALSE;
}


/*------------------------------------------------------------------------

 BOOL IsAdmin(void)

  returns TRUE if user is an admin
          FALSE if user is not an admin
------------------------------------------------------------------------*/
DWORD 
IsAdmin(
    BOOL* bMember
    )
{
    PSID psidAdministrators;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    DWORD dwStatus=ERROR_SUCCESS;

    do {
        if(!AllocateAndInitializeSid(&siaNtAuthority, 
                                     2, 
                                     SECURITY_BUILTIN_DOMAIN_RID,
                                     DOMAIN_ALIAS_RID_ADMINS,
                                     0, 0, 0, 0, 0, 0,
                                     &psidAdministrators))
        {
            dwStatus=GetLastError();
            continue;
        }

        // assume that we don't find the admin SID.
        if(!TLSCheckTokenMembership(NULL,
                                   psidAdministrators,
                                   bMember))
        {
            dwStatus=GetLastError();
        }

        FreeSid(psidAdministrators);

    } while(FALSE);

    return dwStatus;
}

/////////////////////////////////////////////////////////////////////////////

BOOL 
LoadResourceString(
    DWORD dwId, 
    LPTSTR szBuf, 
    DWORD dwBufSize
    )
{
    int dwRet;

    dwRet=LoadString(GetModuleHandle(NULL), dwId, szBuf, dwBufSize);

    return (dwRet != 0);
}    

/////////////////////////////////////////////////////////////////////////////

HRESULT 
LogEvent(
    LPTSTR lpszSource,
    DWORD  dwEventType,
    DWORD  dwIdEvent,
    WORD   cStrings,
    TCHAR **apwszStrings
    )
/*++

--*/
{
    HANDLE hAppLog=NULL;
    BOOL bSuccess=FALSE;
    WORD wElogType;

    wElogType = (WORD) dwEventType;
    if(hAppLog=RegisterEventSource(NULL, lpszSource)) 
    {
        bSuccess = ReportEvent(
                            hAppLog,
                            wElogType,
                            0,
                            dwIdEvent,
                            NULL,
                            cStrings,
                            0,
                            (const TCHAR **) apwszStrings,
                            NULL
                        );

        DeregisterEventSource(hAppLog);
    }

    return((bSuccess) ? ERROR_SUCCESS : GetLastError());
}

/////////////////////////////////////////////////////////////////////////////

void 
TLSLogInfoEvent(
    IN DWORD code
    )
/*++

--*/
{
    LogEvent(
            _TEXT(SZSERVICENAME), 
            EVENTLOG_INFORMATION_TYPE, 
            code, 
            0, 
            NULL
        );
}

/////////////////////////////////////////////////////////////////////////////

void 
TLSLogWarningEvent(
    IN DWORD code
    )
/*++

--*/
{
    LogEvent(
            _TEXT(SZSERVICENAME), 
            EVENTLOG_WARNING_TYPE, 
            code, 
            0, 
            NULL
        );
}

/////////////////////////////////////////////////////////////////////////////

void 
TLSLogErrorEvent(
    IN DWORD errCode
    )
/*++

--*/
{
    LogEvent(
            _TEXT(SZSERVICENAME), 
            EVENTLOG_ERROR_TYPE, 
            errCode, 
            0, 
            NULL
        );
}

/////////////////////////////////////////////////////////////////////////////

void
TLSLogEventString(
    IN DWORD dwEventType,
    IN DWORD dwEventId,
    IN WORD wNumString,
    IN LPCTSTR* lpStrings
    )
/*++


--*/
{
    HANDLE hAppLog=NULL;
    BOOL bSuccess=FALSE;
    WORD wElogType = (WORD) dwEventType;

    __try {
        if(hAppLog=RegisterEventSource(NULL, _TEXT(SZSERVICENAME))) 
        {
            bSuccess = ReportEvent(
                                hAppLog,
                                wElogType,
                                0,
                                dwEventId,
                                NULL,
                                wNumString,
                                0,
                                (const TCHAR **) lpStrings,
                                NULL
                            );

            DeregisterEventSource(hAppLog);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
    }

    return;
}

/////////////////////////////////////////////////////////////////////////////

void 
TLSLogEvent(
    IN DWORD type, 
    IN DWORD EventId,
    IN DWORD code, ...
    )
/*
*/
{
    va_list marker;
    va_start( marker, code );
    DWORD dwRet;
    LPTSTR lpszTemp = NULL;

    __try {
        dwRet=FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE | 
                                    FORMAT_MESSAGE_FROM_SYSTEM,
                             NULL,
                             code,
                             LANG_NEUTRAL,
                             (LPTSTR)&lpszTemp,
                             0,
                             &marker);

        if(dwRet != 0)
        {
            LogEvent(_TEXT(SZSERVICENAME), type, EventId, 1, &lpszTemp);
            if(lpszTemp)
            {
                LocalFree((HLOCAL)lpszTemp);
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        // this is only for putting a break point here
        SetLastError(GetLastError());
    }

    va_end( marker );
    return;
}

///////////////////////////////////////////////////////////////////////

BOOL
TLSSystemTimeToFileTime(
    SYSTEMTIME* pSysTime,
    LPFILETIME pfTime
    )
/*++

--*/
{
DoConvert:

    if(SystemTimeToFileTime(pSysTime, pfTime) == FALSE)
    {
        if(GetLastError() != ERROR_INVALID_PARAMETER)
        {
            TLSASSERT(FALSE);
            return FALSE;
        }

        if(pSysTime->wMonth == 2)
        {
            if(pSysTime->wDay > 29)
            {
                pSysTime->wDay = 29;
                goto DoConvert;
            }   
            else if(pSysTime->wDay == 29)
            {
                pSysTime->wDay = 28;
                goto DoConvert;
            }
        }
        else if ((pSysTime->wMonth == 9) ||
                 (pSysTime->wMonth == 4) ||
                 (pSysTime->wMonth == 6) ||
                 (pSysTime->wMonth == 11))
        {
            if (pSysTime->wDay > 30)
            {
                pSysTime->wDay = 30;
                goto DoConvert;
            }
        }
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////
BOOL
FileTimeToLicenseDate(
    LPFILETIME pft,
    DWORD* t
    )
/*++

++*/
{
    SYSTEMTIME sysTime;
    struct tm gmTime;
    FILETIME localFt;
    time_t licenseTime;

    if(FileTimeToLocalFileTime(pft, &localFt) == FALSE)
    {
        return FALSE;
    }

    if(FileTimeToSystemTime(&localFt, &sysTime) == FALSE)
    {
        return FALSE;
    }

    if(sysTime.wYear >= 2038)
    {
        licenseTime = INT_MAX;
    }
    else
    {
        // Unix time support up to 2038/1/18
        // restrict any expiration data 
        memset(&gmTime, 0, sizeof(gmTime));
        gmTime.tm_sec = sysTime.wSecond;
        gmTime.tm_min = sysTime.wMinute;
        gmTime.tm_hour = sysTime.wHour;
        gmTime.tm_year = sysTime.wYear - 1900;
        gmTime.tm_mon = sysTime.wMonth - 1;
        gmTime.tm_mday = sysTime.wDay;
        gmTime.tm_isdst = -1;

        if((licenseTime = mktime(&gmTime)) == (time_t)-1)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
        }
    }

    *t = (DWORD)licenseTime;

    return licenseTime != (time_t)-1;
}
    

///////////////////////////////////////////////////////////////////////

void 
UnixTimeToFileTime(
    time_t t, 
    LPFILETIME pft
    )   
{
    LARGE_INTEGER li;

    li.QuadPart = Int32x32To64(t, 10000000) + 116444736000000000;

    pft->dwHighDateTime = li.HighPart;
    pft->dwLowDateTime = li.LowPart;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\wkspace.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       wkspace.cpp 
//
// Contents:   DB workspace 
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "TLSdef.h"
#include "server.h"
#include "wkspace.h"
#include "utils.h"
#include "globals.h"

/////////////////////////////////////////////////////////////
//
// Try to save some memory
//
//
JBInstance __TlsDbWorkSpace::g_JbInstance;
static TLSDbWorkSpacePool g_WorkSpacePool;

typedef map<PVOID, PVOID> ACQUIREDHANDLELIST;

CCriticalSection AcquiredHandleListLock;
ACQUIREDHANDLELIST AcquiredHandleList;

LONG g_lWorkSpacePoolDeleted = 0;

#if DBG
DWORD g_dwNumWorkSpaceAllocated = 0;
#endif

//-----------------------------------------------
// 
// Table for work item storage, 
//
//
JBSession g_WkItemSession(__TlsDbWorkSpace::g_JbInstance);
JBDatabase g_WkItemDatabase(g_WkItemSession);
WorkItemTable g_WkItemTable(g_WkItemDatabase);

//--------------------------------------------------------

BOOL
TLSGetESEError(
    const JET_ERR jetErrCode,
    LPTSTR* pszString
    )
/*++


--*/
{
    JBError jbError;

    return jbError.GetJBErrString( 
                            jetErrCode, 
                            pszString 
                        );
}

//--------------------------------------------------------

WorkItemTable*
GetWorkItemStorageTable()
{
    BOOL bSuccess = TRUE;

    //
    // verify session and database is correct.
    //
    if(g_WkItemSession.IsValid() == FALSE)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if(g_WkItemDatabase.IsValid() == FALSE)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if(g_WkItemTable.IsValid() == FALSE)
    {
        bSuccess = g_WkItemTable.OpenTable(
                                    TRUE,
                                    JET_bitTableUpdatable
                                );

        if(bSuccess == FALSE)
        {
            LPTSTR pString = NULL;

            SetLastError(SET_JB_ERROR(g_WkItemTable.GetLastJetError()));
            TLSGetESEError(g_WkItemTable.GetLastJetError(), &pString);

            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_SERVICEINIT,
                    TLS_E_JB_OPENTABLE,
                    g_WkItemTable.GetTableName(),
                    g_WkItemTable.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }
        }
    }

    return (bSuccess == TRUE) ? &g_WkItemTable : NULL;
}

//--------------------------------------------------------
DWORD
CloseWorkSpacePool()
{
    DWORD dwNumWkSpace = g_WorkSpacePool.GetNumberAvailable();
    TLSDbWorkSpace* jbWkSpace=NULL;
    DWORD dwErrCode=ERROR_SUCCESS;

    //
    // Mark workspace pool deleted, this is for backup/restore 
    // that it will close entire workspace pool but RPC context
    // rundown might happen after we close the workspace pool
    //
    InterlockedExchange(
                    &g_lWorkSpacePoolDeleted,
                    1
                );

    #if DBG
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_HANDLEPOOL,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("CloseWorkSpace() - Total %d, Num Available %d\n"),
            g_dwNumWorkSpaceAllocated,
            dwNumWkSpace
        );
    #endif

    while(dwNumWkSpace)
    {
        jbWkSpace = NULL;
        dwErrCode=g_WorkSpacePool.AcquireHandle(
                            &jbWkSpace,
                            INFINITE
                        );

        if(jbWkSpace)
            delete jbWkSpace;

        dwNumWkSpace--;

        #if DBG
        g_dwNumWorkSpaceAllocated--;
        #endif
    }

    AcquiredHandleListLock.Lock();

    if(AcquiredHandleList.empty() != TRUE)
    {
        ACQUIREDHANDLELIST::iterator it;

        for(it = AcquiredHandleList.begin(); it != AcquiredHandleList.end(); it++)
        {
            if((*it).second != NULL)
            {
                jbWkSpace = (TLSDbWorkSpace*) (*it).second;
                delete jbWkSpace;

                #if DBG
                g_dwNumWorkSpaceAllocated--;

                DBGPrintf(
                        DBG_INFORMATION,
                        DBG_FACILITY_HANDLEPOOL,
                        DBGLEVEL_FUNCTION_TRACE,
                        _TEXT("Close Allocated WorkSpace()...\n")
                    );
                #endif
            }
            else
            {
                TLSASSERT(FALSE);
            }
        }

        AcquiredHandleList.erase(AcquiredHandleList.begin(), AcquiredHandleList.end());
    }
        
    AcquiredHandleListLock.UnLock();
    g_WkItemTable.CloseTable();
    g_WkItemDatabase.CloseDatabase();
    g_WkItemSession.EndSession();

    #if DBG
    if( 0 != g_dwNumWorkSpaceAllocated )
    {
        TLSASSERT(FALSE);
    }
    #endif

    //
    // Delete log file so that to prevent long database recovery
    //
    __TlsDbWorkSpace::g_JbInstance.JBTerminate(
                            JET_bitTermComplete, 
                            TRUE
                        );
    return ERROR_SUCCESS;
}

//--------------------------------------------------------
BOOL
IsValidAllocatedWorkspace(
    PTLSDbWorkSpace p
    )
/*++

Abstract:

    Verify an allocated workspace handle is in our
    allocated list.

--*/
{
    BOOL bSuccess = TRUE;

    ACQUIREDHANDLELIST::iterator it;


    AcquiredHandleListLock.Lock();

    it = AcquiredHandleList.find(p);
    bSuccess = (it != AcquiredHandleList.end());
    AcquiredHandleListLock.UnLock();

    return bSuccess;
}


//--------------------------------------------------------
void
ReleaseWorkSpace(
    PTLSDbWorkSpace *p
    )
/*
*/
{
    if( g_lWorkSpacePoolDeleted == 1 )
    {
        //
        // DB workspace pool has been deleted, acquired workspace
        // handle will be deleted via AcquireHandleList
        // 

        // overactive assert here... there is a race condition possible,
        // this assert is to verify that this if statement handles it.
        TLSASSERT(FALSE);
        return;
    }

    TLSASSERT(p != NULL && *p != NULL);

    if(p != NULL)
    {
        ACQUIREDHANDLELIST::iterator it;

        AcquiredHandleListLock.Lock();

        it = AcquiredHandleList.find(*p);
        if(it != AcquiredHandleList.end())
        {
            AcquiredHandleList.erase(it);
        }
        else
        {
            TLSASSERT(FALSE);
        }

        AcquiredHandleListLock.UnLock();
    }

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_HANDLEPOOL,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("Releasing workspace 0x%08x...\n"),
            *p
        );   

    if(*p)
    {
        (*p)->Cleanup();
        g_WorkSpacePool.ReleaseHandle(*p);
        *p = NULL;
    }
}

//--------------------------------------------------------
TLSDbWorkSpace*
AllocateWorkSpace(
    DWORD dwWaitTime /* INFINITE */
    )
/*
*/
{
    TLSDbWorkSpace* jbWkSpace=NULL;
    BOOL bSuccess;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_HANDLEPOOL,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("Allocating a workspace...\n")
        );   
    
    bSuccess = g_WorkSpacePool.AcquireHandleEx(
                                    GetServiceShutdownHandle(),
                                    &jbWkSpace,
                                    dwWaitTime
                                );

    if(bSuccess == TRUE)
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_HANDLEPOOL,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("Allocated 0x%08x...\n"),
                jbWkSpace
            );

        AcquiredHandleListLock.Lock();
        AcquiredHandleList[jbWkSpace] = jbWkSpace;
        AcquiredHandleListLock.UnLock();
    }
    else
    {
        DBGPrintf(
                DBG_INFORMATION,
                DBG_FACILITY_HANDLEPOOL,
                DBGLEVEL_FUNCTION_TRACE,
                _TEXT("Can't allocate workspace - %d are in use...\n"),
                AcquiredHandleList.size()
            );
    }

    return jbWkSpace;
}


//--------------------------------------------------------
DWORD
GetNumberOfWorkSpaceHandle()
{
    return g_WorkSpacePool.GetNumberAvailable();
}

//--------------------------------------------------------
BOOL
TLSJbInitDatabaseEngine(
    IN JBSession& jbSession,
    IN JBDatabase& jbDatabase,
    IN LPCTSTR szDatabaseFile,
    IN LPCTSTR szUserName,
    IN LPCTSTR szPassword
    )
/*++

--*/
{
    BOOL bSuccess = TRUE;
    DWORD dwErrCode;

    if(jbSession.IsValid() == FALSE)
    {
        bSuccess = jbSession.BeginSession(
                                        szUserName, 
                                        szPassword
                                    );
        if(bSuccess == FALSE)
        {
            LPTSTR pString = NULL;

            TLSGetESEError(jbSession.GetLastJetError(), &pString);
            TLSLogEvent(
                    EVENTLOG_ERROR_TYPE,
                    TLS_E_DBGENERAL,
                    TLS_E_JB_BEGINSESSION,
                    jbSession.GetLastJetError(),
                    (pString != NULL) ? pString : _TEXT("")
                );

            if(pString != NULL)
            {
                LocalFree(pString);
            }

            DBGPrintf(
                    DBG_ERROR,
                    DBG_FACILITY_JETBLUE,
                    DBGLEVEL_FUNCTION_ERROR,
                    _TEXT("Error : Initialize JetBlue session  - error code %d\n"),
                    jbSession.GetLastJetError()
                );

            dwErrCode = SET_JB_ERROR(jbSession.GetLastJetError());
            SetLastError(dwErrCode);
            TLSASSERT(FALSE);

            goto cleanup;
        }
    }

    //
    // Open Database
    if(jbDatabase.IsValid() == FALSE)
    {
        bSuccess = jbDatabase.OpenDatabase(szDatabaseFile);
        if(bSuccess == FALSE)
        {
            JET_ERR errCode = jbDatabase.GetLastJetError();

            if(errCode != JET_errFileNotFound)
            {
                if(errCode == JET_errDatabaseCorrupted)
                {
                    TLSLogErrorEvent(TLS_E_CORRUPT_DATABASE);
                }
                else
                {
                    LPTSTR pString = NULL;

                    TLSGetESEError(errCode, &pString);

                    //
                    // other type of error
                    //
                    TLSLogEvent(
                            EVENTLOG_ERROR_TYPE,
                            TLS_E_DBGENERAL,
                            TLS_E_JB_OPENDATABASE,
                            szDatabaseFile,
                            errCode,
                            (pString != NULL) ? pString : _TEXT("")
                        );

                    if(pString != NULL)
                    {
                        LocalFree(pString);
                    }
                }

                DBGPrintf(
                        DBG_ERROR,
                        DBG_FACILITY_JETBLUE,
                        DBGLEVEL_FUNCTION_ERROR,
                        _TEXT("Error : Can't create database because OpenDatabase failed with %d\n"),
                        errCode
                    );

                dwErrCode = SET_JB_ERROR(errCode);
                SetLastError(dwErrCode);
                TLSASSERT(FALSE);

                return FALSE;
            }

            // create a new database file
            bSuccess = jbDatabase.CreateDatabase(szDatabaseFile);

            if(bSuccess == FALSE)
            {
                LPTSTR pString = NULL;

                TLSGetESEError(jbDatabase.GetLastJetError(), &pString);

                TLSLogEvent(
                        EVENTLOG_ERROR_TYPE,
                        TLS_E_DBGENERAL,
                        TLS_E_JB_CREATEDATABASE,
                        szDatabaseFile,
                        jbDatabase.GetLastJetError(),
                        (pString != NULL) ? pString : _TEXT("")
                    );

                if(pString != NULL)
                {
                    LocalFree(pString);
                }

                DBGPrintf(
                        DBG_ERROR,
                        DBG_FACILITY_JETBLUE,
                        DBGLEVEL_FUNCTION_ERROR,
                        _TEXT("Error : can't create new database - error code %d\n"),
                        jbDatabase.GetLastJetError()
                    );

                dwErrCode = SET_JB_ERROR(jbDatabase.GetLastJetError());
                SetLastError(dwErrCode);
            }
        }
    }

cleanup:

    return bSuccess;
}

//--------------------------------------------------------
BOOL
InitializeWorkSpacePool(
    IN int num_workspace,
    IN LPCTSTR szDatabaseFile,
    IN LPCTSTR szUserName,
    IN LPCTSTR szPassword,
    IN LPCTSTR szChkPointDirPath,
    IN LPCTSTR szTempDirPath,
    IN LPCTSTR szLogDirPath,
    IN BOOL bUpdatable
    )
/*
*/
{
    DWORD dwErrCode=ERROR_SUCCESS;
    int index=0;
    BOOL bSuccess=TRUE;
    BOOL bWkItemSuccess = TRUE;

    DBGPrintf(
            DBG_ERROR,
            DBG_FACILITY_JETBLUE,
            DBGLEVEL_FUNCTION_ERROR,
            _TEXT("InitializeWorkSpacePool()... %d\n"),
            num_workspace
        );

    if(__TlsDbWorkSpace::g_JbInstance.IsValid() == FALSE)
    {
        bSuccess = TLSJbInstanceInit(
                        __TlsDbWorkSpace::g_JbInstance,
                        szChkPointDirPath,
                        szTempDirPath,
                        szLogDirPath
                    );

        if(bSuccess != TRUE)
        {
            TLSASSERT(FALSE);
            goto cleanup;
        }
    }

    if(g_WkItemTable.IsValid() == FALSE)
    {
        //
        // Initialize session for WorkItemTable, critical 
        // error if this failed
        //
        bWkItemSuccess = TLSJbInitDatabaseEngine(
                                g_WkItemSession,
                                g_WkItemDatabase,
                                szDatabaseFile,
                                szUserName,
                                szPassword
                            );

        if(bWkItemSuccess == FALSE)
        {
            TLSASSERT(FALSE);
            goto cleanup;
        }
    }

    //
    // Allocate number of workspace
    //
    for(index=0; index < num_workspace; index++)
    {
        PTLSDbWorkSpace pJbWkSpace=NULL;

        pJbWkSpace = new TLSDbWorkSpace();
        if(pJbWkSpace == NULL)
        {
            break;
        }

        if(pJbWkSpace->InitWorkSpace(
                            TRUE, 
                            szDatabaseFile, 
                            szUserName, 
                            szPassword,
                            NULL,
                            NULL,
                            bUpdatable) == FALSE)
        {
            delete pJbWkSpace;
            break;
        }
                
        g_WorkSpacePool.ReleaseHandle(pJbWkSpace);

        #if DBG
        g_dwNumWorkSpaceAllocated++;
        #endif
    }

    //
    // WorkSpace pool has been initialized
    //
    InterlockedExchange(
                    &g_lWorkSpacePoolDeleted,
                    0
                );

cleanup:
    if(bWkItemSuccess == FALSE)
    {
        // critical error, can't initialize session for workitem table.
        SetLastError(TLS_E_INIT_WORKSPACE);
        return FALSE;
    }

    //
    // We need at least 3 workspace, one for update/insert
    // and two for enumeration
    //
    if(index < num_workspace)
    {           
        SetLastError(TLS_E_INIT_WORKSPACE);
    }

    return index >= num_workspace;
}


//--------------------------------------------------------
//
// Initialize DB workspace...
//
//--------------------------------------------------------
BOOL
TLSJbInstanceInit(
    IN OUT JBInstance& jbInstance,
    IN LPCTSTR szChkPointDirPath,
    IN LPCTSTR szTempDirPath,
    IN LPCTSTR szLogDirPath
    )
/*
*/ 
{
    //
    // Setup system parameters
    //
    BOOL bSuccess=TRUE;
    DWORD dwErrCode;


    if(jbInstance.IsValid() == TRUE)
    {
        jbInstance.SetLastJetError(JET_errAlreadyInitialized);
        goto cleanup;
    }

    //
    // Set JetBlue parameter and initialize it
    //
    if(szChkPointDirPath != NULL)
    {
        
        bSuccess =  jbInstance.SetSystemParameter(
                                        0,
                                        JET_paramSystemPath,
                                        0,
                                        (unsigned char *)szChkPointDirPath
                                    );

        if(bSuccess == FALSE)
        {
            dwErrCode = SET_JB_ERROR(jbInstance.GetLastJetError());
            SetLastError(dwErrCode);
            goto cleanup;
        }
    }                                       

    if(szTempDirPath != NULL)
    {
        bSuccess =  jbInstance.SetSystemParameter(
                                        0,
                                        JET_paramTempPath,
                                        0,
                                        (unsigned char *)szTempDirPath
                                    );

        if(bSuccess == FALSE)
        {
            dwErrCode = SET_JB_ERROR(jbInstance.GetLastJetError());
            SetLastError(dwErrCode);
            goto cleanup;
        }
    }                                       

    if(szLogDirPath != NULL)
    {
        
        bSuccess =  jbInstance.SetSystemParameter(
                                        0,
                                        JET_paramLogFilePath,
                                        0,
                                        (unsigned char *)szLogDirPath
                                    );

        if(bSuccess == FALSE)
        {
            dwErrCode = SET_JB_ERROR(jbInstance.GetLastJetError());
            SetLastError(dwErrCode);
            goto cleanup;
        }
    }                                       
   
    if( g_EsentMaxCacheSize != LSERVER_PARAMETERS_USE_ESENTDEFAULT )
    {
        //
        // Adjust memory usage, ESENT will failed on invalid parameter
        //
        bSuccess = jbInstance.SetSystemParameter(
                                            0,
                                            JET_paramCacheSizeMax,
                                            g_EsentMaxCacheSize,
                                            NULL
                                        );

        if(bSuccess == TRUE)
        {
            bSuccess = jbInstance.SetSystemParameter(
                                            0,
                                            JET_paramStartFlushThreshold,
                                            g_EsentStartFlushThreshold,
                                            NULL
                                        );

            if( bSuccess == TRUE )
            {
                bSuccess = jbInstance.SetSystemParameter(
                                                0,
                                                JET_paramStopFlushThreshold,
                                                g_EsentStopFlushThreadhold,
                                                NULL
                                            );
            }
        }

        #if DBG
        //
        // check build, assert.
        //
        if(bSuccess == FALSE)
        {
            dwErrCode = SET_JB_ERROR(jbInstance.GetLastJetError());
            TLSASSERT(FALSE);
        }
        #endif
    }

    bSuccess =  jbInstance.SetSystemParameter( 0, JET_paramDeleteOutOfRangeLogs, 1, NULL);

    if(bSuccess == FALSE)
    {
        dwErrCode = SET_JB_ERROR(jbInstance.GetLastJetError());
        SetLastError(dwErrCode);
        goto cleanup;
    }

    //
    // We only use single instance for all the work space.
    //
    if(jbInstance.JBInitJetInstance() == FALSE)
    {
        LPTSTR pString = NULL;

        TLSGetESEError(jbInstance.GetLastJetError(), &pString);
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_DBGENERAL,
                TLS_E_INIT_JETBLUE,
                jbInstance.GetLastJetError(),
                (pString != NULL) ? pString : _TEXT("")
            );

        if(pString != NULL)
        {
            LocalFree(pString);
        }
    
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_JETBLUE,
                DBGLEVEL_FUNCTION_ERROR,
                _TEXT("Init. JetBlue Instance return error code %d\n"),
                jbInstance.GetLastJetError()
            );

        SetLastError(SET_JB_ERROR(jbInstance.GetLastJetError()));
    }

cleanup:
    return jbInstance.IsSuccess();
}


//--------------------------------------------------------
//
// TLSDbWorkSpace implementation
//
//--------------------------------------------------------
BOOL
__TlsDbWorkSpace::InitWorkSpace(
    BOOL bCreateIfNotExist,
    LPCTSTR szDatabaseFile,
    LPCTSTR szUserName,
    LPCTSTR szPassword,
    IN LPCTSTR szChkPointDirPath,
    IN LPCTSTR szTempDirPath,
    IN BOOL bUpdatable
    )
/*
*/
{
    BOOL bSuccess;
    DWORD dwErrCode;

    //
    // Initialize JetBlue Instance 
    if(g_JbInstance.IsValid() == FALSE)
    {
        SetLastError(TLS_E_INTERNAL);
        bSuccess = FALSE;
        goto cleanup;
    }

    DBGPrintf(
            DBG_ERROR,
            DBG_FACILITY_JETBLUE,
            DBGLEVEL_FUNCTION_ERROR,
            _TEXT("InitWorkSpace()...\n")
        );

    bSuccess = TLSJbInitDatabaseEngine(
                            m_JetSession,
                            m_JetDatabase,
                            szDatabaseFile,
                            szUserName,
                            szPassword
                        );

    if(bSuccess == FALSE)
    {
        goto cleanup;
    }


    //
    // Open all table we need 
    //
    bSuccess = m_LicPackTable.OpenTable(
                                    TRUE,
                                    (bUpdatable) ? JET_bitTableUpdatable : JET_bitTableReadOnly
                                );

    if(bSuccess == FALSE)
    {
        SetLastError(SET_JB_ERROR(m_LicPackTable.GetLastJetError()));

        LPTSTR pString = NULL;

        TLSGetESEError(m_LicPackTable.GetLastJetError(), &pString);

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_DBGENERAL,
                TLS_E_JB_OPENTABLE,
                m_LicPackTable.GetTableName(),
                m_LicPackTable.GetLastJetError(),
                (pString != NULL) ? pString : _TEXT("")
            );

        if(pString != NULL)
        {
            LocalFree(pString);
        }

        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_JETBLUE,
                DBGLEVEL_FUNCTION_ERROR,
                _TEXT("Can't open table %s, error code %d\n"),
                m_LicPackTable.GetTableName(),
                m_LicPackTable.GetLastJetError()
            );

        goto cleanup;
    }


    bSuccess = m_LicPackDescTable.OpenTable(
                                    TRUE,
                                    (bUpdatable) ? JET_bitTableUpdatable : JET_bitTableReadOnly
                                );

    if(bSuccess == FALSE)
    {
        SetLastError(SET_JB_ERROR(m_LicPackDescTable.GetLastJetError()));

        LPTSTR pString = NULL;
        TLSGetESEError(m_LicPackDescTable.GetLastJetError(), &pString);

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_DBGENERAL,
                TLS_E_JB_OPENTABLE,
                m_LicPackDescTable.GetTableName(),
                m_LicPackDescTable.GetLastJetError(),
                (pString != NULL) ? pString : _TEXT("")
            );

        if(pString != NULL)
        {
            LocalFree(pString);
        }

        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_JETBLUE,
                DBGLEVEL_FUNCTION_ERROR,
                _TEXT("Can't open table %s, error code %d\n"),
                m_LicPackDescTable.GetTableName(),
                m_LicPackDescTable.GetLastJetError()
            );

        goto cleanup;
    }

    bSuccess = m_LicensedTable.OpenTable(
                                    TRUE,
                                    (bUpdatable) ? JET_bitTableUpdatable : JET_bitTableReadOnly
                                );

    if(bSuccess == FALSE)
    {
        SetLastError(SET_JB_ERROR(m_LicensedTable.GetLastJetError()));

        LPTSTR pString = NULL;

        TLSGetESEError(m_LicensedTable.GetLastJetError(), &pString);

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_DBGENERAL,
                TLS_E_JB_OPENTABLE,
                m_LicensedTable.GetTableName(),
                m_LicensedTable.GetLastJetError(),
                (pString != NULL) ? pString : _TEXT("")
            );

        if(pString != NULL)
        {
            LocalFree(pString);
        }

        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_JETBLUE,
                DBGLEVEL_FUNCTION_ERROR,
                _TEXT("Can't open table %s, error code %d\n"),
                m_LicensedTable.GetTableName(),
                m_LicensedTable.GetLastJetError()
            );

        goto cleanup;
    }

cleanup:
    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\wkspace.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       wkspace.h 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TLSDBWORKSPACE_H__
#define __TLSDBWORKSPACE_H__

#include "SrvDef.h"
//
// from TLSDb
//
#include "JBDef.h"
#include "JetBlue.h"
#include "TLSDb.h"
#include "backup.h"
#include "KPDesc.h"
#include "Licensed.h"
#include "licpack.h"
#include "version.h"
#include "workitem.h"

struct __TLSDbWorkSpace;

//
// Temporary define workspace to be 32
//
#define MAX_WORKSPACE   32

typedef CHandlePool<
    struct __TlsDbWorkSpace *, 
    MAX_WORKSPACE
> TLSDbWorkSpacePool;


//---------------------------------------------------------------------------
typedef struct __TlsDbWorkSpace {

    // one instance for all session
    static JBInstance g_JbInstance;

    //------------------------------------------------
    // 
    // JetBlue transaction is session based and no 
    // two thread can use same session
    //

    JBSession  m_JetSession;
    JBDatabase m_JetDatabase;

    //
    // These table should be kept open
    //
    LicPackTable            m_LicPackTable;
    LicensedTable           m_LicensedTable;

    //
    // LicPackDesc table is used by enumeration and 
    // adding license pack open as necessary.
    //
    LicPackDescTable        m_LicPackDescTable;


    //-----------------------------------------------
    BOOL
    BeginTransaction() 
    {
        BOOL bSuccess;

        try {                                
            bSuccess = m_JetDatabase.BeginTransaction();
        } catch( SE_Exception e ) {
            bSuccess = FALSE;
            SetLastError(e.getSeNumber());
        }
        catch(...) {
            bSuccess = FALSE;
            SetLastError(TLS_E_INTERNAL);
        }  

        return bSuccess;                     
    }

    //-----------------------------------------------
    BOOL
    CommitTransaction() 
    {
        BOOL bSuccess;

        try {                                
            bSuccess = m_JetDatabase.CommitTransaction();
        } catch( SE_Exception e ) {
            bSuccess = FALSE;
            SetLastError(e.getSeNumber());
        }
        catch(...) {
            bSuccess = FALSE;
            SetLastError(TLS_E_INTERNAL);
        }                       

        return bSuccess;
    }

    //-----------------------------------------------
    BOOL
    RollbackTransaction() 
    {
        BOOL bSuccess;

        try {
            bSuccess = m_JetDatabase.RollbackTransaction();
        } catch( SE_Exception e ) {
            bSuccess = FALSE;
            SetLastError(e.getSeNumber());
        }
        catch(...) {
            bSuccess = FALSE;
            SetLastError(TLS_E_INTERNAL);
        }                       

        return bSuccess;
    }

    //-----------------------------------------------
    void
    Cleanup() 
    {
        m_LicPackTable.Cleanup();
        m_LicPackDescTable.Cleanup();
        m_LicensedTable.Cleanup();
    }


    //------------------------------------------------
    __TlsDbWorkSpace() :
        m_JetSession(g_JbInstance),
        m_JetDatabase(m_JetSession),
        m_LicPackTable(m_JetDatabase),
        m_LicPackDescTable(m_JetDatabase),
        m_LicensedTable(m_JetDatabase)
    /*
    */
    {
        //
        // Force apps to call InitWorkSpace...
        //
    }

    //------------------------------------------------
    ~__TlsDbWorkSpace() 
    {
        m_LicPackTable.CloseTable();
        m_LicPackDescTable.CloseTable();
        m_LicensedTable.CloseTable();

        m_JetDatabase.CloseDatabase();
        m_JetSession.EndSession();
    }

    //------------------------------------------------
    BOOL
    InitWorkSpace(
        BOOL bCreateIfNotExist,
        LPCTSTR szDatabaseFile,
        LPCTSTR szUserName=NULL,
        LPCTSTR szPassword=NULL,
        IN LPCTSTR szChkPointDirPath=NULL,
        IN LPCTSTR szTempDirPath=NULL,
        IN BOOL bUpdatable = FALSE
    );
            
} TLSDbWorkSpace, *LPTLSDbWorkSpace, *PTLSDbWorkSpace;

#ifdef __cplusplus
extern "C" {
#endif

    BOOL
    TLSJbInstanceInit(
        IN OUT JBInstance& jbInstance,
        IN LPCTSTR pszChkPointDirPath,
        IN LPCTSTR pszTempDirPath,
        IN LPCTSTR pszLogDirPath
    );

    TLSDbWorkSpace* 
    AllocateWorkSpace(
        DWORD dwWaitTime
    );

    void
    ReleaseWorkSpace(
        PTLSDbWorkSpace *p
    );

    // 
    BOOL
    InitializeWorkSpacePool( 
        int num_workspace, 
        LPCTSTR szDatabaseFile, 
        LPCTSTR szUserName,
        LPCTSTR szPassword,
        LPCTSTR szChkPointDirPath,
        LPCTSTR szTempDirPath,
        LPCTSTR szLogDirPath,
        BOOL bUpdatable
    );

    DWORD
    CloseWorkSpacePool();

    WorkItemTable*
    GetWorkItemStorageTable();
    
    DWORD
    GetNumberOfWorkSpaceHandle();

    BOOL
    TLSGetESEError(
        const JET_ERR jetErrCode,
        LPTSTR* pszString
    );

    BOOL
    IsValidAllocatedWorkspace(
        PTLSDbWorkSpace p
    );

#ifdef __cplusplus
}
#endif
    

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\wkstore.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        wkstore.h   
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __WORKSTORAGE_H__
#define __WORKSTORAGE_H__

#include "tlsjob.h"

//--------------------------------------------------------------
//
// Work Object initialization function, each work object 
// must supply its own initialization routine to work 
// manager.
//
typedef CWorkObject* (WINAPI *PWorkObjectInitFunc)(
                                            CWorkManager* pWkMgr,
                                            PBYTE pbInitData, 
                                            DWORD cbInitData
                                        );   

typedef void (WINAPI *PWorkObjectDeleteFunc)(CWorkObject* ptr);
                    
//------------------------------------------------------
//
// Work object initialization routine
//
typedef struct _WorkObjectInitFunc {
    DWORD    m_WorkType;
    PWorkObjectInitFunc m_WorkInitFunc;
} WORKOBJECTINITFUNC;

typedef enum {
    WORKITEM_ADD=1,
    WORKITEM_BEGINPROCESSING,
    WORKITEM_RESCHEDULE,
    WORKITEM_DELETE
} WORKITEM_OPERATION;


class CPersistentWorkStorage : public CWorkStorage {
private:
    DWORD   m_dwStartupTime;
    CSafeCounter  m_dwNumJobs;
    CSafeCounter  m_dwJobsInProcesssing;


    //
    // m_hNextJobLock guard ...
    //
    CCriticalSection m_hTableLock;
    CSafeCounter      m_dwNextJobTime;
    CWorkObject*    m_pNextWorkObject;

    //PBYTE  m_pbCurrentBookmark;
    //DWORD  m_cbCurrentBookmark;

    //
    // Table must be updatable, 
    //
    WorkItemTable* m_pWkItemTable;

    void
    UpdateNextJobTime(DWORD dwTime) { m_dwNextJobTime=dwTime; }
    
    DWORD
    StartupUpdateExistingJobTime();

    //
    //
    //        
    BOOL 
    ReturnJobToQueue(
        IN DWORD dwTime,
        IN CWorkObject* ptr
    );

    //
    //
    //        
    BOOL
    DeleteErrorJob(
        IN CWorkObject* ptr
    );

    BOOL 
    UpdateJobEntry(
        IN WorkItemTable* pTable,
        IN PBYTE pbBookmark,
        IN DWORD cbBoolmark,
        IN WORKITEMRECORD& wkItem
    );

    BOOL
    AddJobEntry(
        IN WorkItemTable* pTable,
        IN WORKITEMRECORD& wkItem
    );

    BOOL
    DeleteJobEntry(
        IN WorkItemTable* pTable,
        IN PBYTE pbBookmark,
        IN DWORD cbBookmark,
        IN WORKITEMRECORD& wkItem
    );

    BOOL
    UpdateWorkItemEntry(
        IN WorkItemTable* pTable,
        IN WORKITEM_OPERATION opCode,
        IN PBYTE pbBookmark,
        IN DWORD cbBookmark,
        IN DWORD dwRestartTime,
        IN DWORD dwTime,
        IN DWORD dwJobType,
        IN PBYTE pbJobData,
        IN DWORD cbJobData
    );


    BOOL
    IsValidWorkObject(
        CWorkObject* ptr
    );

    DWORD
    GetCurrentBookmarkEx(
        IN WorkItemTable* pTable,
        IN OUT PBYTE* ppbData,
        IN OUT PDWORD pcbData
    );

    DWORD
    GetCurrentBookmark(
        IN WorkItemTable* pTable,
        IN PBYTE ppbData,
        IN OUT PDWORD pcbData
    );

    DWORD
    SetCurrentBookmark(
        IN WorkItemTable* pTable,
        IN PBYTE pbData, 
        IN DWORD cbData
    );

    BOOL
    RescheduleJob(
        CWorkObject* ptr
    );

    CWorkObject*
    GetCurrentJob(
        PDWORD pdwTime
    );

    DWORD
    FindNextJob();


    CWorkObject*
    InitializeWorkObject(
        DWORD dwWorkType,
        PBYTE pbData,
        DWORD cbData
    );

    BOOL
    DeleteWorkObject(
        CWorkObject* ptr
    );

public:
    CPersistentWorkStorage(
        WorkItemTable* pUpdateWkItemTable = NULL
    );

    ~CPersistentWorkStorage();

    //--------------------------------------------------------
    BOOL
    AttachTable(
        IN WorkItemTable* pWkTable
        )
    /*++

    --*/
    {
        if(pWkTable != NULL)
        {
            m_pWkItemTable = pWkTable;
        }
        else
        {
            SetLastError(ERROR_INVALID_PARAMETER);
        }

        return pWkTable != NULL;
    }

    //--------------------------------------------------------
    BOOL
    IsGood();

    //--------------------------------------------------------
    virtual BOOL 
    Startup(
        IN CWorkManager* pWkMgr
    );

    //--------------------------------------------------------
    virtual BOOL 
    Shutdown();

    //--------------------------------------------------------
    virtual BOOL
    AddJob(
        DWORD dwJobTime,
        CWorkObject* ptr
    );

    //--------------------------------------------------------
    virtual DWORD
    GetNextJobTime();

    //--------------------------------------------------------
    virtual CWorkObject*
    GetNextJob(
        PDWORD pdwTime
    );

    //--------------------------------------------------------
    virtual BOOL
    EndProcessingJob(
        IN ENDPROCESSINGJOB_CODE opCode,
        IN DWORD dwOriginalTime,
        IN CWorkObject* ptr
    );

    //--------------------------------------------------------
    virtual DWORD
    GetNumJobs() 
    { 
        return m_dwNumJobs; 
    }

    //-------------------------------------------------------
    virtual BOOL
    BeginProcessingJob(
        CWorkObject* pJob
    );
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\server\wkstore.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        wkstore.cpp
//
// Contents:    Persistent job store routine.    
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "server.h"
#include "jobmgr.h"
#include "tlsjob.h"
#include "wkstore.h"
#include "debug.h"


WORKOBJECTINITFUNC g_WorkObjectInitFunList[] = {
    {WORKTYPE_RETURN_LICENSE, InitializeCReturnWorkObject } 
};

DWORD g_NumWorkObjectInitFunList = sizeof(g_WorkObjectInitFunList) / sizeof(g_WorkObjectInitFunList[0]);



//---------------------------------------------------
//
CLASS_PRIVATE
CWorkObject* 
CPersistentWorkStorage::InitializeWorkObject(
    IN DWORD dwWorkType,
    IN PBYTE pbData,
    IN DWORD cbData
    )
/*++

--*/
{
    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_WORKMGR,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("CPersistentWorkStorage::InitializeWorkObject() initializing work %d\n"),
            dwWorkType
        );

    CWorkObject* ptr = NULL;
    DWORD dwStatus = ERROR_SUCCESS;

    try {
        for(DWORD index =0; index < g_NumWorkObjectInitFunList; index ++)
        {
            if(dwWorkType == g_WorkObjectInitFunList[index].m_WorkType)
            {
                ptr = (g_WorkObjectInitFunList[index].m_WorkInitFunc)(
                                                                GetWorkManager(),
                                                                pbData,
                                                                cbData
                                                            );

                break;
            }
        }

        if(index >= g_NumWorkObjectInitFunList)
        {
            SetLastError(dwStatus = TLS_E_WORKSTORAGE_UNKNOWNWORKTYPE);
        }
        else
        {
            TLSWorkManagerSetJobDefaults(ptr);
        }
    }
    catch( SE_Exception e ) {
        SetLastError(dwStatus = e.getSeNumber());

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_WORKMANAGERGENERAL,
                TLS_E_WORKSTORAGE_INITWORK,
                dwWorkType,
                dwStatus
            );

    }
    catch(...) {

        SetLastError(dwStatus = TLS_E_WORKSTORAGE_INITWORKUNKNOWN);

        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_WORKMANAGERGENERAL,
                TLS_E_WORKSTORAGE_INITWORKUNKNOWN,
                dwWorkType
            );
    }   


    if(dwStatus != ERROR_SUCCESS)
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_WORKMGR,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("CPersistentWorkStorage::InitializeWorkObject() return 0x%08x\n"),
                dwStatus
            );
    }

    return ptr;
}


//---------------------------------------------------
//
CLASS_PRIVATE BOOL
CPersistentWorkStorage::DeleteWorkObject(
    IN OUT CWorkObject* ptr
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwWorkType = 0;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_WORKMGR,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("CPersistentWorkStorage::DeleteWorkObject() deleting work %s\n"),
            ptr->GetJobDescription()
        );

    try {
        dwWorkType = ptr->GetWorkType();
        ptr->SelfDestruct();
    }
    catch( SE_Exception e ) {
        SetLastError(dwStatus = e.getSeNumber());
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_WORKMANAGERGENERAL,
                TLS_E_WORKSTORAGE_DELETEWORK,
                dwWorkType,
                dwStatus
            );
    }
    catch(...) {

        SetLastError(dwStatus = TLS_E_WORKSTORAGE_DELETEWORKUNKNOWN);
        TLSLogEvent(
                EVENTLOG_ERROR_TYPE,
                TLS_E_WORKMANAGERGENERAL,
                TLS_E_WORKSTORAGE_DELETEWORKUNKNOWN,
                dwWorkType
            );

    }   

    if(dwStatus != ERROR_SUCCESS)
    {
        DBGPrintf(
                DBG_ERROR,
                DBG_FACILITY_WORKMGR,
                DBGLEVEL_FUNCTION_DETAILSIMPLE,
                _TEXT("CPersistentWorkStorage::DeleteWorkObject() return 0x%08x\n"),
                dwStatus
            );
    }

    return dwStatus == ERROR_SUCCESS;
}

//---------------------------------------------------
//
CPersistentWorkStorage::CPersistentWorkStorage(
    IN WorkItemTable* pWkItemTable
    ) :
m_pWkItemTable(pWkItemTable),
m_dwNumJobs(0),
m_dwJobsInProcesssing(0),
m_dwNextJobTime(INFINITE),   
m_pNextWorkObject(NULL)
/*++

--*/
{
}

//---------------------------------------------------
//
CPersistentWorkStorage::~CPersistentWorkStorage()
{
    // just make sure we have shutdown
    // TLSASSERT(m_pWkItemTable == NULL); 
}

//---------------------------------------------------
//
BOOL
CPersistentWorkStorage::DeleteErrorJob(
    IN CWorkObject* ptr
    )
/*++

--*/
{
    BOOL bSuccess = TRUE;
    DWORD dwStatus = ERROR_SUCCESS;
    PBYTE pbBookmark;
    DWORD cbBookmark;
    DWORD dwTime;
    DWORD dwJobType;


    if(IsValidWorkObject(ptr) == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    bSuccess = ptr->GetJobId(&pbBookmark, &cbBookmark);
    if(bSuccess == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        goto cleanup;
    }

    dwJobType = ptr->GetWorkType();

    m_hTableLock.Lock();

    bSuccess = UpdateWorkItemEntry(
                            m_pWkItemTable,
                            WORKITEM_DELETE,
                            pbBookmark,
                            cbBookmark,
                            INFINITE,
                            INFINITE,
                            dwJobType,
                            NULL,
                            0
                        );

    if(bSuccess == FALSE)
    {
        dwStatus = GetLastError();
    }
    
    m_hTableLock.UnLock();
    DeleteWorkObject(ptr);

cleanup:

    return bSuccess;
}

//---------------------------------------------------
//
CLASS_PRIVATE DWORD
CPersistentWorkStorage::GetCurrentBookmark(
    IN WorkItemTable* pTable,
    IN PBYTE pbData,
    IN OUT PDWORD pcbData
    )
/*++

    
--*/
{
    BOOL bSuccess = TRUE;
    DWORD dwStatus = ERROR_SUCCESS;

    if(pTable != NULL)
    {
        JET_ERR jbError;
        
        bSuccess = pTable->GetBookmark(pbData, pcbData);
        if(bSuccess == FALSE)
        {
            jbError = pTable->GetLastJetError();
            if(jbError == JET_errNoCurrentRecord)
            {
                *pcbData = 0;
                SetLastError(dwStatus = ERROR_NO_DATA);
            }
            else if(jbError == JET_errBufferTooSmall)
            {
                SetLastError(dwStatus = ERROR_INSUFFICIENT_BUFFER);
            }
            else
            {
                SetLastError(dwStatus = SET_JB_ERROR(jbError));
            }
        }
    }
    else
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE); 
    }

    return dwStatus;
}

//-------------------------------------------------------------
//
CLASS_PRIVATE DWORD
CPersistentWorkStorage::GetCurrentBookmarkEx(
    IN WorkItemTable* pTable,
    IN OUT PBYTE* ppbData,
    IN OUT PDWORD pcbData
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSucess = TRUE;

    if(ppbData == NULL || pcbData == NULL || pTable == 0)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);   
        return dwStatus;
    }

    *ppbData = NULL;
    *pcbData = 0;

    dwStatus = GetCurrentBookmark(
                            pTable, 
                            *ppbData, 
                            pcbData
                        );
    

    if(dwStatus == ERROR_INSUFFICIENT_BUFFER)
    {
        *ppbData = (PBYTE)AllocateMemory(*pcbData);
        if(*ppbData != NULL)
        {
            dwStatus = GetCurrentBookmark(
                                    pTable, 
                                    *ppbData, 
                                    pcbData
                                );
        }
    }

    if(dwStatus != ERROR_SUCCESS)
    {
        if(*ppbData != NULL)
        {
            FreeMemory(*ppbData);
        }

        *ppbData = NULL;
        *pcbData = 0;
    }

    return dwStatus;
}

//------------------------------------------------------
CLASS_PRIVATE DWORD
CPersistentWorkStorage::SetCurrentBookmark(
    IN WorkItemTable* pTable,
    IN PBYTE pbData,
    IN DWORD cbData
    )
/*++

--*/
{
    BOOL bSuccess;
    DWORD dwStatus = ERROR_SUCCESS;

    if(pTable != NULL && pbData != NULL && cbData != 0)
    {
        bSuccess = pTable->GotoBookmark(pbData, cbData);
        if(bSuccess == FALSE)
        {
            if(pTable->GetLastJetError() == JET_errRecordDeleted)
            {
                SetLastError(dwStatus = ERROR_NO_DATA);
            }
            else
            {
                SetLastError(dwStatus = SET_JB_ERROR(pTable->GetLastJetError()));
            }
        }
    }
    else
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        TLSASSERT(FALSE);
    }

    return dwStatus;
}

//---------------------------------------------------
//
BOOL
CPersistentWorkStorage::Shutdown()
{
    BOOL bSuccess = TRUE;

    //
    // CWorkManager will make sure 
    // no job is in processing state before calling this
    // routine and no job can be scheduled.
    //
    m_hTableLock.Lock();

    //
    // Timing.
    //
    TLSASSERT(m_dwJobsInProcesssing == 0);

    if(m_pWkItemTable != NULL)
    {
        bSuccess = m_pWkItemTable->CloseTable();
        m_pWkItemTable = NULL;
    }

    TLSASSERT(bSuccess == TRUE);
    
    m_pWkItemTable = NULL;
    m_dwNumJobs = 0;
    m_dwNextJobTime = INFINITE;

    if(m_pNextWorkObject != NULL)
    {
        DeleteWorkObject( m_pNextWorkObject );
        m_pNextWorkObject = NULL;   
    }

    m_hTableLock.UnLock();
    return bSuccess;
}

//---------------------------------------------------
//
DWORD
CPersistentWorkStorage::StartupUpdateExistingJobTime()
{
    BOOL bSuccess;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwTime;
    DWORD dwMinTime = INFINITE;

    // CWorkObject* ptr = NULL;

    BOOL bValidJob = TRUE;
    DWORD dwCurrentTime;
    
    m_hTableLock.Lock();
    
    // 
    //
    bSuccess = m_pWkItemTable->MoveToRecord(JET_MoveFirst);
    if(bSuccess == FALSE)
    {
        SetLastError(dwStatus = SET_JB_ERROR(m_pWkItemTable->GetLastJetError()));
    }

    while(dwStatus == ERROR_SUCCESS)
    {
        WORKITEMRECORD wkItem;

        //if(ptr != NULL)
        //{
        //    DeleteWorkObject(ptr);
        //    ptr = NULL;
        //}
        bValidJob = FALSE;

        //
        // fetch the record
        //
        bSuccess = m_pWkItemTable->FetchRecord(wkItem);
        if(bSuccess == FALSE)
        {
            SetLastError(dwStatus = SET_JB_ERROR(m_pWkItemTable->GetLastJetError()));
            continue;
        }

        if(wkItem.dwRestartTime != INFINITE && wkItem.dwScheduledTime >= m_dwStartupTime)
        {
            if(wkItem.dwScheduledTime < dwMinTime)
            {
                dwMinTime = wkItem.dwScheduledTime;
            }

            break;
        }

        //
        // invalid data
        //
        if(wkItem.cbData != 0 && wkItem.pbData != NULL)
        {
            if(wkItem.dwRestartTime != INFINITE)
            {
                wkItem.dwScheduledTime = wkItem.dwRestartTime + time(NULL);
                wkItem.dwJobType &= ~WORKTYPE_PROCESSING;
                bSuccess = m_pWkItemTable->UpdateRecord(
                                                    wkItem, 
                                                    WORKITEM_PROCESS_JOBTIME | WORKITEM_PROCESS_JOBTYPE
                                                );
                if(bSuccess == FALSE)
                {
                    SetLastError(dwStatus = SET_JB_ERROR(m_pWkItemTable->GetLastJetError()));
                    break;
                }

                if(wkItem.dwScheduledTime < dwMinTime)
                {
                    dwMinTime = wkItem.dwScheduledTime;
                }

                bValidJob = TRUE;
            }
        }

        if(bValidJob == FALSE)
        {
            m_pWkItemTable->DeleteRecord();
        }

        // move the record pointer
        bSuccess = m_pWkItemTable->MoveToRecord();
        if(bSuccess == FALSE)
        {
            JET_ERR jetErrCode;

            jetErrCode = m_pWkItemTable->GetLastJetError();
            if(jetErrCode != JET_errNoCurrentRecord)
            {
                SetLastError(dwStatus = SET_JB_ERROR(jetErrCode));
            }

            break;
        }
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        bSuccess = m_pWkItemTable->MoveToRecord(JET_MoveFirst);
        if(bSuccess == FALSE)
        {
            SetLastError(dwStatus = SET_JB_ERROR(m_pWkItemTable->GetLastJetError()));
        }

        UpdateNextJobTime(dwMinTime); 
    }

    m_hTableLock.UnLock();

    //if(ptr != NULL)
    //{
    //    DeleteWorkObject(ptr);
    //    ptr = NULL;
    //}

    return dwStatus;
}

//---------------------------------------------------
//

BOOL
CPersistentWorkStorage::Startup(
    IN CWorkManager* pWkMgr
    )
/*++

--*/
{
    BOOL bSuccess;
    DWORD dwStatus = ERROR_SUCCESS;

    CWorkStorage::Startup(pWkMgr);

    if(IsGood() == TRUE)
    {
        //
        // loop thru all workitem and count number of job
        //
        m_hTableLock.Lock();

        try {
            m_dwStartupTime = time(NULL);


            //
            // Get number of job in queue
            //

            //
            // GetCount() will set index to time column
            m_dwNumJobs = m_pWkItemTable->GetCount(
                                            FALSE,
                                            0,
                                            NULL
                                        );
    
            if(m_dwNumJobs == 0)
            {
                UpdateNextJobTime(INFINITE);
            }
            else
            {   
                bSuccess = m_pWkItemTable->BeginTransaction();
                if(bSuccess == TRUE)
                {
                    dwStatus = StartupUpdateExistingJobTime();
                        
                    if(dwStatus == ERROR_SUCCESS)
                    {
                        m_pWkItemTable->CommitTransaction();
                    }
                    else
                    {
                        m_pWkItemTable->RollbackTransaction();
                    }
                }
                else
                {
                    dwStatus = GetLastError();
                }

                //
                // constructor set next job time to 0 so
                // work manager will immediately try to find next job
                //
                // Move to first record in table
                //bSuccess = m_pWkItemTable->MoveToRecord(JET_MoveFirst);
            }
        }
        catch( SE_Exception e ) {
            SetLastError(dwStatus = e.getSeNumber());
        }
        catch(...) {
            SetLastError(dwStatus = TLS_E_WORKMANAGER_INTERNAL);
        }   

        m_hTableLock.UnLock();
    }
    else
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
    }

    return (dwStatus == ERROR_SUCCESS);
}

//----------------------------------------------------
//
CLASS_PRIVATE BOOL
CPersistentWorkStorage::IsValidWorkObject(
    CWorkObject* ptr
    )
/*++

--*/
{
    BOOL bSuccess = FALSE;
    DWORD dwJobType;
    PBYTE pbData;
    DWORD cbData;

    //
    // Validate input parameter
    //
    if(ptr == NULL)
    {
        TLSASSERT(FALSE);
        goto cleanup;
    }

    dwJobType = ptr->GetWorkType();
    if(dwJobType == WORK_TYPE_UNKNOWN)
    {
        TLSASSERT(FALSE);
        goto cleanup;
    }
        
    ptr->GetWorkObjectData(&pbData, &cbData);
    if(pbData == NULL || cbData == 0)
    {
        TLSASSERT(pbData != NULL && cbData != NULL);
        goto cleanup;
    }

    bSuccess = TRUE;

cleanup:

    return bSuccess;
}

//----------------------------------------------------
//
BOOL
CPersistentWorkStorage::IsGood()
{
    if( m_pWkItemTable == NULL || 
        m_hTableLock.IsGood() == FALSE ||
        GetWorkManager() == NULL )
    {
        return FALSE;
    }

    return m_pWkItemTable->IsValid();
}

//----------------------------------------------------
//
CLASS_PRIVATE BOOL
CPersistentWorkStorage::UpdateJobEntry(
    IN WorkItemTable* pTable,
    IN PBYTE pbBookmark,
    IN DWORD cbBookmark,
    IN WORKITEMRECORD& wkItem
    )
/*++

--*/
{
    BOOL bSuccess = TRUE;
    DWORD dwStatus = ERROR_SUCCESS;

    dwStatus = SetCurrentBookmark(
                            pTable,
                            pbBookmark,
                            cbBookmark
                        );


    if(dwStatus == ERROR_SUCCESS)
    {
        bSuccess = pTable->UpdateRecord(wkItem);
    }
    else
    {
        bSuccess = FALSE;
        TLSASSERT(dwStatus == ERROR_SUCCESS);
    }

    return bSuccess;
}

//----------------------------------------------------
//

CLASS_PRIVATE BOOL
CPersistentWorkStorage::AddJobEntry(
    IN WorkItemTable* pTable,
    IN WORKITEMRECORD& wkItem
    )
/*++


--*/
{
    BOOL bSuccess;

    bSuccess = pTable->InsertRecord(wkItem);
    if(bSuccess == TRUE)
    {
        m_dwNumJobs++;
    }

    return bSuccess;
}

//----------------------------------------------------
//

CLASS_PRIVATE BOOL
CPersistentWorkStorage::DeleteJobEntry(
    IN WorkItemTable* pTable,
    IN PBYTE pbBookmark,
    IN DWORD cbBookmark,
    IN WORKITEMRECORD& wkItem
    )
/*++


--*/
{
    BOOL bSuccess = TRUE;
    DWORD dwStatus = ERROR_SUCCESS;


    dwStatus = SetCurrentBookmark(
                            pTable,
                            pbBookmark,
                            cbBookmark
                        );


    if(dwStatus == ERROR_SUCCESS)
    {
        bSuccess = pTable->DeleteRecord();

        if(bSuccess == TRUE)
        {
            m_dwNumJobs--;
        }
    }
    else
    {
        bSuccess = FALSE;
        TLSASSERT(dwStatus == ERROR_SUCCESS);
    }

    return bSuccess;
}
                                 
//----------------------------------------------------
//
CLASS_PRIVATE BOOL
CPersistentWorkStorage::UpdateWorkItemEntry(
    IN WorkItemTable* pTable,
    IN WORKITEM_OPERATION opCode,
    IN PBYTE pbBookmark,
    IN DWORD cbBookmark,
    IN DWORD dwRestartTime,
    IN DWORD dwTime,
    IN DWORD dwJobType,
    IN PBYTE pbJobData,
    IN DWORD cbJobData
    )
/*++


--*/
{
    BOOL bSuccess = TRUE;
    DWORD dwStatus = ERROR_SUCCESS;
    WORKITEMRECORD item;
    PBYTE   pbCurrentBookmark=NULL;
    DWORD  cbCurrentBookmark=0;


    m_hTableLock.Lock();

    dwStatus = GetCurrentBookmarkEx(
                                pTable,
                                &pbCurrentBookmark,
                                &cbCurrentBookmark
                            );

    if(dwStatus != ERROR_SUCCESS && dwStatus != ERROR_NO_DATA)
    {
        goto cleanup;
    }

    bSuccess = pTable->BeginTransaction();
    if(bSuccess == FALSE)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }


    item.dwScheduledTime = dwTime;
    item.dwRestartTime = dwRestartTime;
    item.dwJobType = dwJobType;
    item.cbData = cbJobData;
    item.pbData = pbJobData;

    switch(opCode)
    {
        case WORKITEM_ADD:
            TLSASSERT(cbJobData != 0 && pbJobData != NULL);
            m_pWkItemTable->SetInsertRepositionBookmark(
                                                (dwTime < (DWORD)m_dwNextJobTime)
                                            );

            bSuccess = AddJobEntry(
                                pTable,
                                item
                            );

            break;

        case WORKITEM_BEGINPROCESSING:
            item.dwJobType |= WORKTYPE_PROCESSING;
            //
            // FALL THRU
            //
            
        case WORKITEM_RESCHEDULE:
            TLSASSERT(cbJobData != 0 && pbJobData != NULL);
            bSuccess = UpdateJobEntry(
                                pTable,
                                pbBookmark,
                                cbBookmark,
                                item
                            );
            break;

        case WORKITEM_DELETE:
            bSuccess = DeleteJobEntry(
                                pTable,
                                pbBookmark,
                                cbBookmark,
                                item
                            );
            break;

        default:

            TLSASSERT(FALSE);
            bSuccess = FALSE;
    }

    if(bSuccess == TRUE)
    {
        pTable->CommitTransaction();
        dwStatus = ERROR_SUCCESS;

        //
        // constructor set time to first job 0 so that work manager can immediate kick off
        //
        if( (opCode != WORKITEM_ADD && opCode != WORKITEM_RESCHEDULE) || dwTime > (DWORD)m_dwNextJobTime ) 
        {
            if(pbCurrentBookmark != NULL && cbCurrentBookmark != 0)
            {
                dwStatus = SetCurrentBookmark(
                                    pTable,
                                    pbCurrentBookmark,
                                    cbCurrentBookmark
                                );

                if(dwStatus == ERROR_NO_DATA)
                {
                    // record already deleted
                    dwStatus = ERROR_SUCCESS;
                }
                else
                {
                    TLSASSERT(dwStatus == ERROR_SUCCESS);
                }
            }
        }
        else
        {
            UpdateNextJobTime(dwTime);
        }
    }
    else
    {
        SetLastError(dwStatus = SET_JB_ERROR(pTable->GetLastJetError()));
        pTable->RollbackTransaction();
        TLSASSERT(FALSE);
    }

cleanup:

    m_hTableLock.UnLock();

    if(pbCurrentBookmark != NULL)
    {
        FreeMemory(pbCurrentBookmark);
    }

    //
    // WORKITEMRECORD will try to cleanup memory
    //
    item.pbData = NULL;
    item.cbData = 0;

    return dwStatus == ERROR_SUCCESS;
}
  
//----------------------------------------------------
//
BOOL
CPersistentWorkStorage::AddJob(
    IN DWORD dwTime,
    IN CWorkObject* ptr
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSuccess = TRUE;
    PBYTE pbData;
    DWORD cbData;


    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_WORKMGR,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("CPersistentWorkStorage::AddJob() scheduling job %s at time %d\n"),
            ptr->GetJobDescription(),
            dwTime
        );

    if(IsValidWorkObject(ptr) == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    bSuccess = ptr->GetWorkObjectData(&pbData, &cbData);
    if(bSuccess == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    m_hTableLock.Lock();

    if(m_pWkItemTable != NULL)
    {
        bSuccess = UpdateWorkItemEntry(
                                m_pWkItemTable,
                                WORKITEM_ADD,
                                NULL,
                                0,
                                ptr->GetJobRestartTime(),
                                dwTime + time(NULL),
                                ptr->GetWorkType(),
                                pbData,
                                cbData
                            );

        if(bSuccess == FALSE)
        {
            dwStatus = GetLastError();
        }
    }
    
    m_hTableLock.UnLock();

cleanup:

    // Let Calling function delete it.
    // DeleteWorkObject(ptr);

    return dwStatus == ERROR_SUCCESS;
}

//----------------------------------------------------
//
BOOL
CPersistentWorkStorage::RescheduleJob(
    CWorkObject* ptr
    )
/*++

--*/
{
    BOOL bSuccess = TRUE;
    DWORD dwStatus = ERROR_SUCCESS;
    PBYTE pbData;
    DWORD cbData;
    PBYTE pbBookmark;
    DWORD cbBookmark;
    DWORD dwTime;
    DWORD dwJobType;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_WORKMGR,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("CPersistentWorkStorage::RescheduleJob() scheduling job %s\n"),
            ptr->GetJobDescription()
        );

    if(IsValidWorkObject(ptr) == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    bSuccess = ptr->GetWorkObjectData(&pbData, &cbData);
    if(bSuccess == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        goto cleanup;
    }

    bSuccess = ptr->GetJobId(&pbBookmark, &cbBookmark);
    if(bSuccess == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        goto cleanup;
    }
    
    dwTime = ptr->GetSuggestedScheduledTime();
    dwJobType = ptr->GetWorkType();

    m_hTableLock.Lock();

    if(m_pWkItemTable != NULL)
    {
        bSuccess = UpdateWorkItemEntry(
                                m_pWkItemTable,
                                (dwTime == INFINITE) ?  WORKITEM_DELETE : WORKITEM_RESCHEDULE,
                                pbBookmark,
                                cbBookmark,
                                ptr->GetJobRestartTime(),
                                (dwTime == INFINITE) ? dwTime : dwTime + time(NULL),
                                dwJobType,
                                pbData,
                                cbData
                            );

        if(bSuccess == FALSE)
        {
            dwStatus = GetLastError();
        }
    }
    
    m_hTableLock.UnLock();

cleanup:

    DeleteWorkObject(ptr);
    return dwStatus == ERROR_SUCCESS;
}

//----------------------------------------------------
//
CLASS_PRIVATE DWORD
CPersistentWorkStorage::FindNextJob()
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSuccess = TRUE;
    CWorkObject* ptr = NULL;
    JET_ERR jetErrCode;
    PBYTE pbBookmark = NULL;
    DWORD cbBookmark = 0;

    m_hTableLock.Lock();

    while(dwStatus == ERROR_SUCCESS)
    {
        WORKITEMRECORD wkItem;

        // move the record pointer
        bSuccess = m_pWkItemTable->MoveToRecord();
        if(bSuccess == FALSE)
        {
            jetErrCode = m_pWkItemTable->GetLastJetError();
            if(jetErrCode == JET_errNoCurrentRecord)
            {
                // end of table
                UpdateNextJobTime(INFINITE);
                SetLastError(dwStatus = ERROR_NO_DATA);
                continue;
            }
        }

        //
        // fetch the record
        //
        bSuccess = m_pWkItemTable->FetchRecord(wkItem);
        if(bSuccess == FALSE)
        {
            SetLastError(dwStatus = SET_JB_ERROR(m_pWkItemTable->GetLastJetError()));
            continue;
        }

        if(wkItem.dwJobType & WORKTYPE_PROCESSING)
        {
            // job is been processed, move to next one.
            continue;
        }

        dwStatus = GetCurrentBookmarkEx(
                                m_pWkItemTable,
                                &pbBookmark,
                                &cbBookmark
                            );

        if(dwStatus != ERROR_SUCCESS)
        {
            // Error...
            TLSASSERT(dwStatus == ERROR_SUCCESS);
            UpdateNextJobTime(INFINITE);
            break;
            
        }

        if(wkItem.dwScheduledTime > m_dwStartupTime)
        {
            if(pbBookmark != NULL && cbBookmark != 0)
            {
                FreeMemory( pbBookmark );
                pbBookmark = NULL;
                cbBookmark = 0;
            }       

            UpdateNextJobTime(wkItem.dwScheduledTime);
            break;
        }

        //
        // job is in queue before system startup, re-schedule
        //
        ptr = InitializeWorkObject(
                                wkItem.dwJobType,
                                wkItem.pbData,
                                wkItem.cbData
                            );

        
        if(ptr == NULL)
        {
            if(pbBookmark != NULL && cbBookmark != 0)
            {
                FreeMemory( pbBookmark );
                pbBookmark = NULL;
                cbBookmark = 0;
            }       

            //
            // something is wrong, delete this job
            // and move on to next job
            //
            m_pWkItemTable->DeleteRecord();
            continue;
        }

        //
        // Set Job's storage ID and re-schedule this job
        //
        ptr->SetJobId(pbBookmark, cbBookmark);
        bSuccess = RescheduleJob(ptr);
        if(bSuccess == FALSE)
        {
            dwStatus = GetLastError();
        }

        if(pbBookmark != NULL && cbBookmark != 0)
        {
            FreeMemory( pbBookmark );
            pbBookmark = NULL;
            cbBookmark = 0;
        }       
    }

    m_hTableLock.UnLock();

    return dwStatus;
}

//----------------------------------------------------
//
CLASS_PRIVATE CWorkObject*
CPersistentWorkStorage::GetCurrentJob(
    PDWORD pdwTime
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSuccess = TRUE;
    WORKITEMRECORD wkItem;
    CWorkObject* ptr = NULL;

    PBYTE pbBookmark=NULL;
    DWORD cbBookmark=0;


    TLSASSERT(IsGood() == TRUE);

    m_hTableLock.Lock();
    while(dwStatus == ERROR_SUCCESS)
    {
        //
        // fetch the record
        //
        bSuccess = m_pWkItemTable->FetchRecord(wkItem);
        TLSASSERT(bSuccess == TRUE);
        //TLSASSERT(!(wkItem.dwJobType & WORKTYPE_PROCESSING));

        if(bSuccess == FALSE)
        {
            SetLastError(dwStatus = SET_JB_ERROR(m_pWkItemTable->GetLastJetError()));
            break;
        }

        if( wkItem.dwScheduledTime < m_dwStartupTime || 
            wkItem.cbData == 0 || 
            wkItem.pbData == NULL )
        { 
            // FindNextJob() move record pointer one position down
            m_pWkItemTable->MoveToRecord(JET_MovePrevious);
            dwStatus = FindNextJob();

            continue;
        }

        if( wkItem.dwJobType & WORKTYPE_PROCESSING )
        {
            dwStatus = FindNextJob();
            continue;
        }

        ptr = InitializeWorkObject(
                                wkItem.dwJobType,
                                wkItem.pbData,
                                wkItem.cbData
                            );

        dwStatus = GetCurrentBookmarkEx(
                                m_pWkItemTable,
                                &pbBookmark,
                                &cbBookmark
                            );
        
        if(dwStatus != ERROR_SUCCESS)
        {
            // something is wrong, free up memory
            // and exit.
            SetLastError(dwStatus);

            // TLSASSERT(FALSE);

            DeleteWorkObject(ptr);  
            ptr = NULL;

            // grab next job
            dwStatus = FindNextJob();
            continue;
        }

        //
        // Set Job's storage ID
        //
        ptr->SetJobId(pbBookmark, cbBookmark);
        //ptr->SetScheduledTime(wkItem.dwScheduledTime);
        *pdwTime = wkItem.dwScheduledTime;

        if(pbBookmark != NULL && cbBookmark != 0)
        {
            FreeMemory( pbBookmark );
            pbBookmark = NULL;
            cbBookmark = 0;
        }       

        break;
    }

    m_hTableLock.UnLock();
    return ptr;
}
    
//-----------------------------------------------------
//
DWORD
CPersistentWorkStorage::GetNextJobTime()
{
    DWORD dwTime;
    dwTime = (DWORD)m_dwNextJobTime;

    return dwTime;
}

//-----------------------------------------------------
//
CWorkObject*
CPersistentWorkStorage::GetNextJob(
    PDWORD pdwTime
    )
/*++

--*/
{
    CWorkObject* ptr = NULL;

    if((DWORD)m_dwNextJobTime != INFINITE)
    {
        try {
            m_hTableLock.Lock();

            //
            // Fetch record where current bookmark points to,
            // it is possible that new job arrived after
            // WorkManager already calls GetNextJobTime(),
            // this is OK since in this case this new job 
            // needs immediate processing.
            //
            ptr = GetCurrentJob(pdwTime);

            //
            // reposition current record pointer
            //
            FindNextJob();
        }
        catch(...) {
            SetLastError(TLS_E_WORKMANAGER_INTERNAL);
            ptr = NULL;
        }
        
        m_hTableLock.UnLock();
    }

    return ptr;
}

//-----------------------------------------------------
//
BOOL
CPersistentWorkStorage::ReturnJobToQueue(
    IN DWORD dwTime,
    IN CWorkObject* ptr
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    PBYTE pbBookmark;
    DWORD cbBookmark;
    DWORD dwJobType;
    PBYTE pbData;
    DWORD cbData;

    if(IsValidWorkObject(ptr) == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    if(ptr->IsWorkPersistent() == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        TLSASSERT(FALSE);
        goto cleanup;
    }

    if(ptr->GetWorkObjectData(&pbData, &cbData) == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        goto cleanup;
    }

    if(ptr->GetJobId(&pbBookmark, &cbBookmark) == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        goto cleanup;
    }

    m_hTableLock.Lock();

    if(dwTime < (DWORD)m_dwNextJobTime)
    {
        // Position current record
        dwStatus = SetCurrentBookmark(
                                m_pWkItemTable,
                                pbBookmark,
                                cbBookmark
                            );

        TLSASSERT(dwStatus == ERROR_SUCCESS);
        if(dwStatus == ERROR_SUCCESS)
        {
            UpdateNextJobTime(dwTime);
        }
    }

    m_hTableLock.UnLock();

cleanup:

    DeleteWorkObject(ptr);

    return dwStatus == ERROR_SUCCESS;
}


//-----------------------------------------------------
//
BOOL
CPersistentWorkStorage::EndProcessingJob(
    IN ENDPROCESSINGJOB_CODE opCode,
    IN DWORD dwOriginalTime,
    IN CWorkObject* ptr
    )
/*++

Abstract:



Parameter:

    opCode : End Processing code.
    ptr : Job has completed processing or been 
          returned by workmanager due to time or 
          resource constraint.
    

Return:

    TRUE/FALSE

--*/
{
    BOOL bSuccess = TRUE;
    BYTE pbData = NULL;
    DWORD cbData = 0;

    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_WORKMGR,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("CPersistentWorkStorage::EndProcessingJob() - end processing %s opCode %d\n"),
            ptr->GetJobDescription(),
            opCode
        );

    if(ptr == NULL)
    {
        bSuccess = FALSE;
        SetLastError(ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    if(ptr->IsWorkPersistent() == FALSE)
    {
        SetLastError(ERROR_INVALID_DATA);
        TLSASSERT(FALSE);
        goto cleanup;
    }

    switch(opCode)
    {
        case ENDPROCESSINGJOB_SUCCESS:
            bSuccess = RescheduleJob(ptr);
            m_dwJobsInProcesssing--;
            break;

        case ENDPROCESSINGJOB_ERROR:
            bSuccess = DeleteErrorJob(ptr);
            m_dwJobsInProcesssing--;
            break;

        case ENDPROCESSINGJOB_RETURN:
            bSuccess = ReturnJobToQueue(dwOriginalTime, ptr);
            break;

        default:

            TLSASSERT(FALSE);
    }

cleanup:
    return bSuccess;
}

//-------------------------------------------------------
//
BOOL
CPersistentWorkStorage::BeginProcessingJob(
    IN CWorkObject* ptr
    )
/*++

Abstract:

    Work Manager call this to inform. storage that
    this job is about to be processed.


Parameter:

    ptr - Job to be process.

Return:

    TRUE/FALSE

--*/
{
    BOOL bSuccess = TRUE;
    DWORD dwStatus = ERROR_SUCCESS;
    PBYTE pbBookmark;
    DWORD cbBookmark;
    DWORD dwTime;
    PBYTE pbData;
    DWORD cbData;


    DBGPrintf(
            DBG_INFORMATION,
            DBG_FACILITY_WORKMGR,
            DBGLEVEL_FUNCTION_TRACE,
            _TEXT("CPersistentWorkStorage::BeginProcessingJob() - beginning processing %s\n"),
            ptr->GetJobDescription()
        );

    if(IsValidWorkObject(ptr) == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    if(ptr->IsWorkPersistent() == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        TLSASSERT(FALSE);
        goto cleanup;
    }

    bSuccess = ptr->GetWorkObjectData(&pbData, &cbData);
    if(bSuccess == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        goto cleanup;
    }

    bSuccess = ptr->GetJobId(&pbBookmark, &cbBookmark);
    if(bSuccess == FALSE)
    {
        SetLastError(dwStatus = ERROR_INVALID_DATA);
        goto cleanup;
    }

    m_hTableLock.Lock();

    bSuccess = UpdateWorkItemEntry(
                            m_pWkItemTable,
                            WORKITEM_BEGINPROCESSING,
                            pbBookmark,
                            cbBookmark,
                            ptr->GetJobRestartTime(),
                            ptr->GetScheduledTime(),
                            ptr->GetWorkType(),
                            pbData,
                            cbData
                        );

    if(bSuccess == TRUE)
    {
        m_dwJobsInProcesssing ++;
    }
    else
    {
        dwStatus = GetLastError();
    }
    
    m_hTableLock.UnLock();

cleanup:

    return dwStatus == ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\setup\licenoc.h ===
/*
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *  Module Name:
 *
 *      licenoc.h
 *
 *  Abstract:
 *
 *      This file contains the main OC code.
 *
 *  Author:
 *
 *      Breen Hagan (BreenH) Oct-02-98
 *
 *  Environment:
 *
 *      User Mode
 */

#ifndef _LSOC_LICENOC_H_
#define _LSOC_LICENOC_H_

#define     MESSAGE_SIZE  1024
#define     TITLE_SIZE   128
const DWORD     SECTIONSIZE = 256;
const TCHAR     COMPONENT_NAME[] = _T("LicenseServer");

typedef enum {
    kInstall,
    kUninstall,
    kDoNothing,
} EInstall;

typedef enum {
    ePlainServer        = 0,
    eEnterpriseServer,
    eMaxServers
} EServerType;

#endif // _LSOC_LICENOC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\setup\dir.h ===
/*
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *  Module Name:
 *
 *      dir.h
 *
 *  Abstract:
 *
 *      This file contains code to recursively create directories.
 *
 *  Author:
 *
 *      Breen Hagan (BreenH) Oct-02-98
 *
 *  Environment:
 *
 *      User Mode
 */

#ifndef _LSOC_DIR_H_
#define _LSOC_DIR_H_

/*
 *  Function Prototypes.
 */

DWORD
CheckDatabaseDirectory(
    IN LPCTSTR  pszDatabaseDir
    );

DWORD
CreateDatabaseDirectory(
    VOID
    );

LPCTSTR
GetDatabaseDirectory(
    VOID
    );

VOID
RemoveDatabaseDirectory(
    VOID
    );

VOID
SetDatabaseDirectory(
    IN LPCTSTR  pszDatabaseDir
    );

#endif // _LSOC_DIR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\setup\licever.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        licever.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// VERSION INFO
#include <ntverp.h>


#define	VER_FILETYPE	VFT_APP
#define	VER_FILESUBTYPE	VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "License Server Optional Component Setup"
#define VER_INTERNALNAME_STR        "licenoc"
#define VER_ORIGINALFILENAME_STR    "licenoc.dll"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\setup\licenoc.cpp ===
/*
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *  Module Name:
 *
 *      licenoc.cpp
 *
 *  Abstract:
 *
 *      This file contains the main OC code.
 *
 *  Author:
 *
 *      Breen Hagan (BreenH) Oct-02-98
 *
 *  Environment:
 *
 *      User Mode
 */

#include "stdafx.h"
#include "pages.h"
#include "..\common\svcrole.h"
#include "upgdef.h"
#include "logfile.h"

/*
 *  Constants.
 */

const TCHAR gszLogFile[]            = _T("%SystemRoot%\\LicenOc.log");
const TCHAR *gInstallSectionNames[] = {
    _T("LicenseServer.Install"),
    _T("LicenseServer.Uninstall"),
    _T("LicenseServer.DoNothing")
    };

/*
 *  Global variables.
 */

BOOL                    gNt4Upgrade         = FALSE;
BOOL                    gNtUpgrade;
BOOL                    gStandAlone;
BOOL                    gUnAttended;
EnablePage              *gEnableDlg         = NULL;
EServerType             gServerRole         = eEnterpriseServer;
HINSTANCE               ghInstance          = NULL;
PSETUP_INIT_COMPONENT   gpInitComponentData = NULL;

/*
 *  Function prototypes.
 */

HINF        GetComponentInfHandle(VOID);
DWORD       GetComponentVersion(VOID);
HINSTANCE   GetInstance(VOID);
EInstall    GetInstallSection(VOID);
LPCTSTR     GetInstallSectionName(VOID);
BOOL        GetSelectionState(UINT);
EServerType GetServerRole(VOID);
DWORD       OnPreinitialize(UINT_PTR);
DWORD       OnInitComponent(PSETUP_INIT_COMPONENT);
DWORD       OnSetLanguage(UINT_PTR);
DWORD       OnQueryImage(UINT_PTR, PDWORD);
DWORD       OnRequestPages(WizardPagesType, PSETUP_REQUEST_PAGES);
DWORD       OnWizardCreated(VOID);
DWORD       OnQueryState(UINT_PTR);
DWORD       OnQueryChangeSelState(UINT_PTR, UINT);
DWORD       OnCalcDiskSpace(LPCTSTR, UINT_PTR, HDSKSPC);
DWORD       OnQueueFileOps(LPCTSTR, HSPFILEQ);
DWORD       OnQueryStepCount(VOID);
DWORD       OnAboutToCommitQueue(VOID);
DWORD       OnCompleteInstallation(LPCTSTR);
DWORD       OnCleanup(VOID);
VOID        SetDatabaseDirectory(LPCTSTR);
DWORD       SetServerRole(UINT);

#define GetCurrentSelectionState()  GetSelectionState(OCSELSTATETYPE_CURRENT)
#define GetOriginalSelectionState() GetSelectionState(OCSELSTATETYPE_ORIGINAL)

/*
 *  Helper Functions.
 */

HINF
GetComponentInfHandle(
    VOID
    )
{
    return(gpInitComponentData->ComponentInfHandle);
}

DWORD
GetComponentVersion(
    VOID
    )
{
    return(OCMANAGER_VERSION);
}

HINSTANCE
GetInstance(
    VOID
    )
{
    return(ghInstance);
}


EInstall
GetInstallSection(
    VOID
    )
{
    BOOL    fCurrentState   = GetCurrentSelectionState();
    BOOL    fOriginalState  = GetOriginalSelectionState();

    //
    //  StandAlone Setup Matrix
    //
    //      Originally Selected, Currently Selected     ->  DoNothing
    //      Originally Selected, Currently Unselected   ->  Uninstall
    //      Originally Unselected, Currently Selected   ->  Install
    //      Originally Unselected, Currently Unselected ->  DoNothing
    //
    //  Gui Mode / Upgrade Matrix
    //
    //      Nt 4.0 any setup, Nt 5.0 w LS   ->  Install
    //      Nt 4.0 any setup, Nt 5.0 w/o LS ->  Uninstall
    //      Nt 5.0 w/ LS, Nt 5.0 w/ LS      ->  Install
    //      Nt 5.0 w/ LS, Nt 5.0 w/o LS     ->  Uninstall
    //      Nt 5.0 w/o LS, Nt 5.0 w/ LS     ->  Install
    //      Nt 5.0 w/o LS, Nt 5.0 w/o LS    ->  Uninstall
    //      Win9x, Nt5.0 w/ LS              ->  Install
    //      Win9x, Nt5.0 w/o LS             ->  Uninstall
    //

    //
    //  If this is a TS 4 installation, fOriginalState will be false,
    //  even though LS is installed. Handle this case first.
    //

    if (gNt4Upgrade) {
        if (fCurrentState) {
            return(kInstall);
        } else {
            return(kUninstall);
        }
    }

    if (gStandAlone && (fCurrentState == fOriginalState)) {
        return(kDoNothing);
    }

    if (fCurrentState) {
        return(kInstall);
    } else {
        return(kUninstall);
    }
}

LPCTSTR
GetInstallSectionName(
    VOID
    )
{
    LOGMESSAGE(
        _T("GetInstallSectionName: Returned %s"),
        gInstallSectionNames[(INT)GetInstallSection()]
        );

    return(gInstallSectionNames[(INT)GetInstallSection()]);
}

BOOL
GetSelectionState(
    UINT    StateType
    )
{
    return(gpInitComponentData->HelperRoutines.QuerySelectionState(
                gpInitComponentData->HelperRoutines.OcManagerContext,
                COMPONENT_NAME,
                StateType
                ));
}

EServerType
GetServerRole(
    VOID
    )
{
    return(gServerRole);
}

BOOL
InWin2000Domain(
    VOID
    )
{
    NET_API_STATUS dwErr;
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pDomainInfo = NULL;
    PDOMAIN_CONTROLLER_INFO pdcInfo = NULL;
    BOOL fRet = FALSE;

    //
    // Check if we're in a workgroup
    //
    dwErr = DsRoleGetPrimaryDomainInformation(NULL,
                                              DsRolePrimaryDomainInfoBasic,
                                              (PBYTE *) &pDomainInfo);

    if ((dwErr != NO_ERROR) || (pDomainInfo == NULL))
    {
        return FALSE;
    }

    switch (pDomainInfo->MachineRole)
    {
        case DsRole_RoleStandaloneWorkstation:
        case DsRole_RoleStandaloneServer:
            DsRoleFreeMemory(pDomainInfo);

            return FALSE;
            break;      // just in case
    }

    DsRoleFreeMemory(pDomainInfo);

    dwErr = DsGetDcName(NULL,   // Computer Name
                        NULL,   // Domain Name
                        NULL,   // Domain GUID
                        NULL,   // Site Name
                        DS_DIRECTORY_SERVICE_PREFERRED,
                        &pdcInfo);

    if ((dwErr != NO_ERROR) || (pdcInfo == NULL))
    {
        return FALSE;
    }

    if (pdcInfo->Flags & DS_DS_FLAG)
    {
        fRet = TRUE;
    }

    NetApiBufferFree(pdcInfo);

    return fRet;
}

DWORD
SetServerRole(
    IN UINT newType
    )
{
    switch(newType) {
    case ePlainServer:
    case eEnterpriseServer:
        gServerRole = (EServerType)newType;
        break;

    default:
        return(ERROR_INVALID_PARAMETER);
    }

    return(NO_ERROR);
}

/*
 *  DllMain
 *
 *  Initial entry point into the License Server OC dll.
 */

DWORD WINAPI
DllMain(
    IN HINSTANCE    hInstance,
    IN DWORD        dwReason,
    IN LPVOID       lpReserved
    )
{
    TCHAR   pszLogFile[MAX_PATH + 1];

    switch(dwReason) {
    case DLL_PROCESS_ATTACH:
        if (hInstance != NULL) {
            ghInstance = hInstance;
        } else {
            return(FALSE);
        }

        ExpandEnvironmentStrings(gszLogFile, pszLogFile, MAX_PATH);
        LOGINIT(pszLogFile, COMPONENT_NAME);
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_PROCESS_DETACH:
        break;

    case DLL_THREAD_DETACH:
        break;
    }

    UNREFERENCED_PARAMETER(lpReserved);
    return(TRUE);
}

/*
 *  EntryProc()
 *
 *  Entry point into OCBase class for OCManager.
 */

DWORD
EntryProc(
    IN LPCVOID      ComponentId,
    IN LPCVOID      SubcomponentId,
    IN UINT         Function,
    IN UINT_PTR     Param1,
    IN OUT PVOID    Param2
    )
{
    DWORD   dwRet;

    switch(Function) {
    case OC_PREINITIALIZE:
        LOGMESSAGE(_T("\r\nOnPreinitialize: Entered"));
        dwRet = OnPreinitialize(
                    Param1
                    );
        LOGMESSAGE(_T("OnPreinitialize: Returned"));
        break;

    case OC_INIT_COMPONENT:
        LOGMESSAGE(_T("\r\nOnInitComponent: Entered"));
        dwRet = OnInitComponent(
                    (PSETUP_INIT_COMPONENT)Param2
                    );
        LOGMESSAGE(_T("OnInitComponent: Returned"));
        break;

    case OC_SET_LANGUAGE:
        LOGMESSAGE(_T("\r\nOnSetLanguage: Entered"));
        dwRet = OnSetLanguage(
                    Param1
                    );
        LOGMESSAGE(_T("OnSetLanguage: Returned"));
        break;

    case OC_QUERY_IMAGE:
        LOGMESSAGE(_T("\r\nOnQueryImage: Entered"));
        dwRet = OnQueryImage(
                    Param1,
                    (PDWORD)Param2
                    );
        LOGMESSAGE(_T("OnQueryImage: Returned"));
        break;

    case OC_REQUEST_PAGES:
        LOGMESSAGE(_T("\r\nOnRequestPages: Entered"));
        dwRet = OnRequestPages(
                    (WizardPagesType)Param1,
                    (PSETUP_REQUEST_PAGES)Param2
                    );
        LOGMESSAGE(_T("OnRequestPages: Returned"));
        break;

    case OC_WIZARD_CREATED:
        LOGMESSAGE(_T("\r\nOnWizardCreated: Entered"));
        dwRet = OnWizardCreated();
        LOGMESSAGE(_T("OnWizardCreated: Returned"));
        break;

    case OC_QUERY_STATE:
        LOGMESSAGE(_T("\r\nOnQueryState: Entered"));
        dwRet = OnQueryState(
                    Param1
                    );
        LOGMESSAGE(_T("OnQueryState: Returned"));
        break;

    case OC_QUERY_CHANGE_SEL_STATE:
        LOGMESSAGE(_T("\r\nOnQueryChangeSelState: Entered"));
        dwRet = OnQueryChangeSelState(
                    Param1,
                    (UINT)((UINT_PTR)Param2)
                    );
        LOGMESSAGE(_T("OnQueryChangeSelState: Returned"));
        break;

    case OC_CALC_DISK_SPACE:
        LOGMESSAGE(_T("\r\nOnCalcDiskSpace: Entered"));
        dwRet = OnCalcDiskSpace(
                    (LPCTSTR)SubcomponentId,
                    Param1,
                    (HDSKSPC)Param2
                    );
        LOGMESSAGE(_T("OnCalcDiskSpace: Returned"));
        break;

    case OC_QUEUE_FILE_OPS:
        LOGMESSAGE(_T("\r\nOnQueueFileOps: Entered"));
        dwRet = OnQueueFileOps(
                    (LPCTSTR)SubcomponentId,
                    (HSPFILEQ)Param2
                    );
        LOGMESSAGE(_T("OnQueueFileOps: Returned"));
        break;

    case OC_QUERY_STEP_COUNT:
        LOGMESSAGE(_T("\r\nOnQueryStepCount: Entered"));
        dwRet = OnQueryStepCount();
        LOGMESSAGE(_T("OnQueryStepCount: Returned"));
        break;

    case OC_ABOUT_TO_COMMIT_QUEUE:
        LOGMESSAGE(_T("\r\nOnAboutToCommitQueue: Entered"));
        dwRet = OnAboutToCommitQueue();
        LOGMESSAGE(_T("OnAboutToCommitQueue: Returned"));
        break;

    case OC_COMPLETE_INSTALLATION:
        LOGMESSAGE(_T("\r\nOnCompleteInstallation: Entered"));
        dwRet = OnCompleteInstallation(
                    (LPCTSTR)SubcomponentId
                    );
        LOGMESSAGE(_T("OnCompleteInstallation: Returned"));
        break;

    case OC_CLEANUP:
        LOGMESSAGE(_T("\r\nOnCleanup: Entered"));
        dwRet = OnCleanup();
        break;

    default:
        LOGMESSAGE(_T("\r\nOC Manager calling for unknown function %ld\r\n"),
            Function);
        dwRet = 0;
    }

    UNREFERENCED_PARAMETER(ComponentId);
    return(dwRet);
}

/*
 *  OnPreinitialize()
 *
 *
 */

DWORD
OnPreinitialize(
    IN UINT_PTR Flags
    )
{

    UNREFERENCED_PARAMETER(Flags);
#ifdef UNICODE
    return(OCFLAG_UNICODE);
#else
    return(OCFLAG_ANSI);
#endif
}

/*
 *  OnInitComponent()
 *
 *
 */

DWORD
OnInitComponent(
    IN PSETUP_INIT_COMPONENT    pSetupInitComponent
    )
{
    BOOL        fErr;
    DWORDLONG   OperationFlags;

    if (pSetupInitComponent == NULL) {
        LOGMESSAGE(_T("OnInitComponent: Passed NULL PSETUP_INIT_COMPONENT"));
        return(ERROR_CANCELLED);
    }

    //
    //  Verify that the OC Manager and OC versions are compatible.
    //

    pSetupInitComponent->ComponentVersion = GetComponentVersion();
    if (pSetupInitComponent->ComponentVersion >
        pSetupInitComponent->OCManagerVersion)  {
        LOGMESSAGE(_T("OnInitComponent: Version mismatch."));
        return(ERROR_CALL_NOT_IMPLEMENTED);
    }

    //
    //  Copy setup data.
    //

    gpInitComponentData = (PSETUP_INIT_COMPONENT)LocalAlloc(
                                LPTR,
                                sizeof(SETUP_INIT_COMPONENT)
                                );
    if (gpInitComponentData == NULL) {
        LOGMESSAGE(_T("OnInitComponent: Can't allocate gpInitComponentData."));
        return(ERROR_CANCELLED);
    }

    CopyMemory(
        gpInitComponentData,
        pSetupInitComponent,
        sizeof(SETUP_INIT_COMPONENT)
        );

    //
    //  Open Inf file.
    //

    if (GetComponentInfHandle() == NULL) {
        return(ERROR_CANCELLED);
    }

    fErr = SetupOpenAppendInfFile(
                NULL,
                GetComponentInfHandle(),
                NULL
                );

    if (!fErr) {
        LOGMESSAGE(_T("OnInitComponent: SetupOpenAppendInfFile failed: %ld"),
            GetLastError());
        return(GetLastError());
    }

    //
    //  Set state variables.
    //

    OperationFlags  = gpInitComponentData->SetupData.OperationFlags;
    gStandAlone     = OperationFlags & SETUPOP_STANDALONE ? TRUE : FALSE;
    gUnAttended     = OperationFlags & SETUPOP_BATCH ? TRUE : FALSE;
    gNtUpgrade      = OperationFlags & SETUPOP_NTUPGRADE ? TRUE : FALSE;

    LOGMESSAGE(_T("OnInitComponent: gStandAlone = %s"),
        gStandAlone ? _T("TRUE") : _T("FALSE"));
    LOGMESSAGE(_T("OnInitComponent: gUnAttended = %s"),
        gUnAttended ? _T("TRUE") : _T("FALSE"));
    LOGMESSAGE(_T("OnInitComponent: gNtUpgrade = %s"),
        gNtUpgrade ? _T("TRUE") : _T("FALSE"));

    //
    //  Gather previous version's information from registry. If the role
    //  does not exist in the registry, SetServerRole will stay with the
    //  default, PlainServer.
    //

    SetServerRole(GetServerRoleFromRegistry());

    //
    //  Check for Nt4 Upgrade.
    //

    if (GetNT4DbConfig(NULL, NULL, NULL, NULL) == NO_ERROR) {
        LOGMESSAGE(_T("OnInitComponent: Nt4Upgrade"));
        gNt4Upgrade = TRUE;

        DeleteNT4ODBCDataSource();
    }

    //
    //  License Server will only use the directory in the registry during
    //  an Nt5 to Nt5 upgrade or stand alone setup from Add/Remove Programs.
    //

    if (gStandAlone || (gNtUpgrade && !gNt4Upgrade)) {
        LPCTSTR pszDbDirFromReg = GetDatabaseDirectoryFromRegistry();

        if (pszDbDirFromReg != NULL) {
            SetDatabaseDirectory(pszDbDirFromReg);
        }
    }

    return(NO_ERROR);
}

/*
 *  OnSetLanguage()
 *
 *
 */

DWORD
OnSetLanguage(
    IN UINT_PTR LanguageId
    )
{
    UNREFERENCED_PARAMETER(LanguageId);
    return((DWORD)FALSE);
}

/*
 *  OnQueryImage()
 *
 *
 */

DWORD
OnQueryImage(
    IN UINT_PTR     SubCompEnum,
    IN OUT PDWORD   Size
    )
{
    UNREFERENCED_PARAMETER(SubCompEnum);
    UNREFERENCED_PARAMETER(Size);
    return((DWORD)NULL);
}

/*
 *  OnRequestPages()
 *
 *
 */

DWORD
OnRequestPages(
    IN WizardPagesType          PageTypeEnum,
    IN OUT PSETUP_REQUEST_PAGES pRequestPages
    )
{
    const DWORD cUiPages = 1;
    BOOL        fErr;

    LOGMESSAGE(_T("OnRequestPages: Page Type %d"), PageTypeEnum);

    if (pRequestPages == NULL) {
        LOGMESSAGE(_T("OnRequestPages: pRequestPages == NULL"));
        return(0);
    }

    if ((!gStandAlone) || (PageTypeEnum != WizPagesEarly)) {
        return(0);
    }

    if (pRequestPages->MaxPages >= cUiPages) {
        gEnableDlg = new EnablePage;
        if (gEnableDlg == NULL) {
            goto CleanUp1;
        }

        fErr = gEnableDlg->Initialize();
        if (!fErr) {
            goto CleanUp1;
        }

        pRequestPages->Pages[0] = CreatePropertySheetPage(
                                    (LPPROPSHEETPAGE)gEnableDlg
                                    );

        if (pRequestPages->Pages[0] == NULL) {
            LOGMESSAGE(_T("OnRequestPages: Failed CreatePropertySheetPage!"));
            goto CleanUp0;
        }
    }

    return(cUiPages);

CleanUp0:
    delete gEnableDlg;

CleanUp1:
    SetLastError(ERROR_OUTOFMEMORY);
    LOGMESSAGE(_T("OnRequestPages: Out of Memory!"));
    return((DWORD)-1);
}

/*
 *  OnWizardCreated()
 *
 *
 */

DWORD
OnWizardCreated(
    VOID
    )
{
    return(NO_ERROR);
}

/*
 *  OnQueryState()
 *
 *
 */

DWORD
OnQueryState(
    IN UINT_PTR uState
    )
{
    UNREFERENCED_PARAMETER(uState);
    return(SubcompUseOcManagerDefault);
}

/*
 *  OnQueryChangeSelState()
 *
 *
 */

DWORD
OnQueryChangeSelState(
    IN UINT_PTR SelectionState,
    IN UINT     Flags
    )
{
    BOOL fDirectSelection;
    BOOL fRet;
    BOOL fSelect;

    UNREFERENCED_PARAMETER(Flags);

    if (Flags & OCQ_ACTUAL_SELECTION)
    {
        fDirectSelection = TRUE;
    }
    else
    {
        fDirectSelection = FALSE;
    }

    fRet = TRUE;
    fSelect = (SelectionState != 0);

    if (!fSelect && fDirectSelection && GetOriginalSelectionState())
    {
        DWORD dwStatus;
        HWND hWnd;
        int iRet;

        hWnd = gpInitComponentData->HelperRoutines.QueryWizardDialogHandle(gpInitComponentData->HelperRoutines.OcManagerContext);

        dwStatus = DisplayMessageBox(
                    hWnd,
                    IDS_STRING_LICENSES_GO_BYE_BYE,
                    IDS_MAIN_TITLE,
                    MB_YESNO,
                    &iRet
                    );

        if (dwStatus == ERROR_SUCCESS)
        {
            fRet = (iRet == IDYES);
        }
    }

    return((DWORD)fRet);
}

/*
 *  OnCalcDiskSpace()
 *
 *
 */

DWORD
OnCalcDiskSpace(
    IN LPCTSTR      SubcomponentId,
    IN UINT_PTR     AddComponent,
    IN OUT HDSKSPC  DiskSpaceHdr
    )
{
    BOOL        fErr;
    LPCTSTR     pSection;

    if ((SubcomponentId == NULL) ||
        (SubcomponentId[0] == NULL)) {
        return(0);
    }

    LOGMESSAGE(_T("OnCalcDiskSpace: %s"),
        AddComponent ? _T("Installing") : _T("Removing"));

    //
    //  There is no clear documentation on how this should work. If the
    //  size of the installation should be visible no matter what, then
    //  the section to install should be hardcoded, not determined by
    //  the current state.
    //

    pSection = gInstallSectionNames[kInstall];
    LOGMESSAGE(_T("OnCalcDiskSpace: Calculating for %s"), pSection);

    if (AddComponent != 0) {
        fErr = SetupAddInstallSectionToDiskSpaceList(
                    DiskSpaceHdr,
                    GetComponentInfHandle(),
                    NULL,
                    pSection,
                    NULL,
                    0
                    );
    } else {
        fErr = SetupRemoveInstallSectionFromDiskSpaceList(
                    DiskSpaceHdr,
                    GetComponentInfHandle(),
                    NULL,
                    pSection,
                    NULL,
                    0
                    );
    }

    if (fErr) {
        return(NO_ERROR);
    } else {
        LOGMESSAGE(_T("OnCalcDiskSpace: Error %ld"), GetLastError());
        return(GetLastError());
    }
}

/*
 *  OnQueueFileOps()
 *
 *
 */

DWORD
OnQueueFileOps(
    IN LPCTSTR      SubcomponentId,
    IN OUT HSPFILEQ FileQueueHdr
    )
{
    BOOL        fErr;
    DWORD       dwErr;
    EInstall    eInstallSection;
    LPCTSTR     pSection;

    if ((SubcomponentId == NULL) ||
        (SubcomponentId[0] == NULL)) {
        return(0);
    }

    pSection = GetInstallSectionName();
    LOGMESSAGE(_T("OnQueueFileOps: Queueing %s"), pSection);

    //
    //  Stop and remove the license server service, if needed. This must
    //  be done before queueing files for deletion.
    //

    eInstallSection = GetInstallSection();

    if (eInstallSection == kUninstall) {
        if (gServerRole == eEnterpriseServer) {
            if (UnpublishEnterpriseServer() != S_OK) {
                LOGMESSAGE(
                    _T("OnQueueFileOps: UnpublishEnterpriseServer() failed")
                    );
            }
        }

        dwErr = ServiceDeleteFromInfSection(
                    GetComponentInfHandle(),
                    pSection
                    );
        if (dwErr != ERROR_SUCCESS) {
            LOGMESSAGE(
                _T("OnQueueFileOps: Error deleting service: %ld"),
                dwErr
                );
        }
    }

    fErr = SetupInstallFilesFromInfSection(
                GetComponentInfHandle(),
                NULL,
                FileQueueHdr,
                pSection,
                NULL,
                eInstallSection == kUninstall ? 0 : SP_COPY_NEWER
                );

    if (fErr) {
        return(NO_ERROR);
    } else {
        LOGMESSAGE(_T("OnQueueFileOps: Error %ld"), GetLastError());
        return(GetLastError());
    }
}

/*
 *  OnQueryStepCount()
 *
 *  TODO: how many steps, when should we tick?
 */

DWORD
OnQueryStepCount(
    VOID
    )
{
    return(0);
}

/*
 *  OnAboutToCommitQueue()
 *
 *
 */

DWORD
OnAboutToCommitQueue(
    VOID
    )
{
    return(NO_ERROR);
}

/*
 *  OnCompleteInstallation()
 *
 *
 */

DWORD
OnCompleteInstallation(
    IN LPCTSTR  SubcomponentId
    )
{
    BOOL        fErr;
    DWORD       dwErr;
    EInstall    eInstallSection = GetInstallSection();
    LPCTSTR     pSection;
    TCHAR tchBuf[MESSAGE_SIZE] ={0};
    TCHAR tchTitle[TITLE_SIZE] = {0};

    if ((SubcomponentId == NULL) ||
        (SubcomponentId[0] == NULL)) {
        return(NO_ERROR);
    }

    if (eInstallSection == kDoNothing) {
        LOGMESSAGE(_T("OnCompleteInstallation: Nothing to do"));
        return(NO_ERROR);
    }

    pSection = GetInstallSectionName();

    //
    //  In GUI mode setup and in unattended StandAlone setup, the wizard
    //  page does not display, and therefore the directory is not created.
    //  Create the default directory here.
    //

    if (eInstallSection == kInstall) {
        if ((!gStandAlone) || (gUnAttended)) {
            CreateDatabaseDirectory();
        }
    }

    //
    //  SetupAPI correctly handles installing and removing files, and
    //  creating start menu links.
    //

    fErr = SetupInstallFromInfSection(
                NULL,
                GetComponentInfHandle(),
                pSection,
                SPINST_INIFILES | SPINST_REGISTRY | SPINST_PROFILEITEMS,
                NULL,
                NULL,
                0,
                NULL,
                NULL,
                NULL,
                NULL
                );
    if (!fErr) {
        LOGMESSAGE(_T("OnCompleteInstallation: InstallFromInf failed %ld"),
            GetLastError());
        return(GetLastError());
    }

    //
    //  Perform installation and upgrade-specific tasks.
    //

    if (eInstallSection == kInstall) {
        LOGMESSAGE(_T("OnCompleteInstallation: Installing"));

        //
        //  Set service settings first and install the service.
        //

        dwErr = CreateRegistrySettings(GetDatabaseDirectory(), gServerRole);
        if (dwErr != NO_ERROR) {
            LOGMESSAGE(
                _T("OnCompleteInstallation: CreateRegistrySettings: Error %ld"),
                dwErr
                );
            return(dwErr);
        }

        fErr = SetupInstallServicesFromInfSection(
                GetComponentInfHandle(),
                pSection,
                0
                );
        if (!fErr) {
            LOGMESSAGE(
                _T("OnCompleteInstallation: InstallServices: Error %ld"),
                GetLastError()
                );
            return(GetLastError());
        }

        if (gServerRole == eEnterpriseServer) {
            if (PublishEnterpriseServer() != S_OK) {                

                LOGMESSAGE(_T("OnCompleteInstallation: PublishEnterpriseServer() failed. Setup will still complete."));                               

                LOGMESSAGE(_T("PublishEnterpriseServer: Uninstall, try logging on as a member of the Enterprise Admins or Domain Admins group and then run setup again."));

                if (!gUnAttended)
                {
                    LoadString( GetInstance(), IDS_INSUFFICIENT_PERMISSION, tchBuf, sizeof(tchBuf)/sizeof(TCHAR));

                    LoadString( GetInstance(), IDS_MAIN_TITLE, tchTitle, sizeof(tchTitle)/sizeof(TCHAR));

                    MessageBox( NULL, tchBuf, tchTitle, MB_OK | MB_ICONWARNING | MB_SETFOREGROUND | MB_TOPMOST);
                }                

            }
        }

        if (gStandAlone) {
            dwErr = ServiceStartFromInfSection(
                        GetComponentInfHandle(),
                        pSection
                        );
            if (dwErr != ERROR_SUCCESS) {
                LOGMESSAGE(
                    _T("OnCompleteInstallation: Error starting service: %ld"),
                    dwErr
                    );
                return(dwErr);
            }
        }

    } else if (eInstallSection == kUninstall) {
        CleanLicenseServerSecret();
        RemoveDatabaseDirectory();
        RemoveRegistrySettings();
    }

    return(NO_ERROR);
}

/*
 *  OnCleanup()
 *
 *
 */

DWORD
OnCleanup(
    VOID
    )
{
    if (gpInitComponentData != NULL) {
        LocalFree(gpInitComponentData);
    }

    if (gEnableDlg != NULL) {
        delete gEnableDlg;
    }

    LOGMESSAGE(_T("OnCleanup: Returned"));
    LOGCLOSE();

    return(NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\setup\dir.cpp ===
/*
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *  Module Name:
 *
 *      dir.cpp
 *
 *  Abstract:
 *
 *      This file contains code to recursively create directories.
 *
 *  Author:
 *
 *      Breen Hagan (BreenH) Oct-02-98
 *
 *  Environment:
 *
 *      User Mode
 */

#include "stdafx.h"
#include "logfile.h"

/*
 *  Global variables.
 */

TCHAR   gszDatabaseDirectory[MAX_PATH + 1]  =
            _T("%SystemRoot%\\System32\\LServer");

/*
 *  Helper Functions.
 */

DWORD
CreateDirectoryRecursively(
    IN LPCTSTR  pszDirectory
    )
{
    TCHAR   Buffer[MAX_PATH + 1];
    PTCHAR  p,q;
    BOOL    fDone;
    DWORD   dwErr;

    if (_tcslen(pszDirectory) > (MAX_PATH)) {
        return(ERROR_BAD_PATHNAME);
    }

    if (ExpandEnvironmentStrings(pszDirectory, Buffer, MAX_PATH) > MAX_PATH) {
        return(ERROR_BAD_PATHNAME);
    }

    q = Buffer;

    if (q[1] == _T(':')) {

        //
        //  This is a "C:" style path. Put p past the colon and first
        //  backslash, if it exists.
        //

        if (q[2] == _T('\\')) {
            p = &(q[3]);
        } else {
            p = &(q[2]);
        }
    } else if (q[0] == _T('\\')) {

        //
        //  This path begins with a backslash. If the second character is
        //  also a backslash, this is a UNC path, which is not accepted.
        //

        if (q[1] == _T('\\')) {
            return(ERROR_BAD_PATHNAME);
        } else {
            p = &(q[1]);
        }
    } else {

        //
        //  This path is a relative path from the current directory.
        //

        p = q;
    }

    q = p;
    fDone = FALSE;

    do {

        //
        // Locate the next path sep char. If there is none then
        // this is the deepest level of the path.
        //

        p = _tcschr(q, _T('\\'));
        if (p) {
            *p = (TCHAR)NULL;
        } else {
            fDone = TRUE;
        }

        //
        // Create this portion of the path.
        //

        if (CreateDirectory(Buffer,NULL)) {
            dwErr = NO_ERROR;
        } else {
            dwErr = GetLastError();
            if(dwErr == ERROR_ALREADY_EXISTS) {
                dwErr = NO_ERROR;
            }
        }

        if(dwErr == NO_ERROR) {

            //
            // Put back the path sep and move to the next component.
            //

            if (!fDone) {
                *p = TEXT('\\');
                q = p + sizeof(TCHAR);
            }
        } else {
            fDone = TRUE;
        }

    } while(!fDone);

    return(dwErr);
}

BOOL
ConcatenatePaths(
    IN OUT LPTSTR   Target,
    IN     LPCTSTR  Path,
    IN     UINT     TargetBufferSize,
    OUT    LPUINT   RequiredSize          OPTIONAL
    )

{
    UINT TargetLength,PathLength;
    BOOL TrailingBackslash,LeadingBackslash;
    UINT EndingLength;

    TargetLength = lstrlen(Target);
    PathLength = lstrlen(Path);

    //
    // See whether the target has a trailing backslash.
    //
    if(TargetLength && (Target[TargetLength-1] == TEXT('\\'))) {
        TrailingBackslash = TRUE;
        TargetLength--;
    } else {
        TrailingBackslash = FALSE;
    }

    //
    // See whether the path has a leading backshash.
    //
    if(Path[0] == TEXT('\\')) {
        LeadingBackslash = TRUE;
        PathLength--;
    } else {
        LeadingBackslash = FALSE;
    }

    //
    // Calculate the ending length, which is equal to the sum of
    // the length of the two strings modulo leading/trailing
    // backslashes, plus one path separator, plus a nul.
    //
    EndingLength = TargetLength + PathLength + 2;
    if(RequiredSize) {
        *RequiredSize = EndingLength;
    }

    if(!LeadingBackslash && (TargetLength < TargetBufferSize)) {
        Target[TargetLength++] = TEXT('\\');
    }

    if(TargetBufferSize > TargetLength) {
        lstrcpyn(Target+TargetLength,Path,TargetBufferSize-TargetLength);
    }

    //
    // Make sure the buffer is nul terminated in all cases.
    //
    if (TargetBufferSize) {
        Target[TargetBufferSize-1] = 0;
    }

    return(EndingLength <= TargetBufferSize);
}

VOID
Delnode(
    IN LPCTSTR  Directory
    )
{
    TCHAR           pszDirectory[MAX_PATH + 1];
    TCHAR           pszPattern[MAX_PATH + 1];
    WIN32_FIND_DATA FindData;
    HANDLE          FindHandle;

    LOGMESSAGE(_T("Delnode: Entered"));

    //
    //  Delete each file in the given directory, then remove the directory
    //  itself. If any directories are encountered along the way recurse to
    //  delete them as they are encountered.
    //
    //  Start by forming the search pattern, which is <currentdir>\*.
    //

    ExpandEnvironmentStrings(Directory, pszDirectory, MAX_PATH);
    LOGMESSAGE(_T("Delnode: Deleting %s"), pszDirectory);

    lstrcpyn(pszPattern, pszDirectory, MAX_PATH);
    ConcatenatePaths(pszPattern, _T("*"), MAX_PATH, NULL);

    //
    // Start the search.
    //

    FindHandle = FindFirstFile(pszPattern, &FindData);
    if(FindHandle != INVALID_HANDLE_VALUE) {

        do {

            //
            // Form the full name of the file or directory we just found.
            //

            lstrcpyn(pszPattern, pszDirectory, MAX_PATH);
            ConcatenatePaths(pszPattern, FindData.cFileName, MAX_PATH, NULL);

            //
            // Remove read-only atttribute if it's there.
            //

            if (FindData.dwFileAttributes & FILE_ATTRIBUTE_READONLY) {
                SetFileAttributes(pszPattern, FILE_ATTRIBUTE_NORMAL);
            }

            if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                //
                // The current match is a directory.  Recurse into it unless
                // it's . or ...
                //

                if ((lstrcmp(FindData.cFileName,_T("."))) &&
                    (lstrcmp(FindData.cFileName,_T("..")))) {
                    Delnode(pszPattern);
                }

            } else {

                //
                // The current match is not a directory -- so delete it.
                //

                if (!DeleteFile(pszPattern)) {
                    LOGMESSAGE(_T("Delnode: %s not deleted: %d"), pszPattern,
                        GetLastError());
                }
            }

        } while(FindNextFile(FindHandle, &FindData));

        FindClose(FindHandle);
    }

    //
    // Remove the directory we just emptied out. Ignore errors.
    //

    RemoveDirectory(pszDirectory);
}

/*
 *  Exported Functions.
 */

/*
 *  CheckDatabaseDirectory()
 *
 *  CheckDatabaseDirectory is very hardcore about which paths it will accept.
 *
 *  Good Paths:
 *      <DriveLetter>:\AbsolutePathToDirectory
 *
 *  Bad Paths:
 *      Any path that is not like above, AND any path in the form above that
 *      is not on a fixed disk (e.g. no path to a floppy, CD-ROM, network
 *      share).
 */

DWORD
CheckDatabaseDirectory(
    IN LPCTSTR  pszDatabaseDir
    )
{
    BOOL    fBadChars;
    BOOL    fBadPath;
    UINT    DriveType;
    TCHAR   pszExpandedDir[MAX_PATH + 1];

    LOGMESSAGE(_T("CheckDatabaseDirectory: Entered"));
    LOGMESSAGE(_T("CheckDatabaseDirectory: Checking %s"), pszDatabaseDir);

    //
    //  NULL is not accepted.
    //

    if (pszDatabaseDir == NULL) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    //  A path greater than MAX_PATH will cause problems somewhere. This
    //  will also catch pathnames with no environment variables that are
    //  still too long.
    //

    if (ExpandEnvironmentStrings(pszDatabaseDir, pszExpandedDir, MAX_PATH) >
        MAX_PATH) {
        LOGMESSAGE(_T("CheckDatabaseDirectory: Path too long"));
        return(ERROR_BAD_PATHNAME);
    }

    //
    //  A path of less than three characters can't contain "<DriveLetter>:\".
    //  Also, don't allow anything but a letter, a colon, and a backslash.
    //

    fBadPath = FALSE;

    if (!fBadPath) {
        fBadPath = (_tcslen(pszExpandedDir) < 3);
    }
    if (!fBadPath) {
        fBadPath = !(_istalpha(pszExpandedDir[0]));
    }
    if (!fBadPath) {
        fBadPath = (pszExpandedDir[1] != _T(':'));
    }
    if (!fBadPath) {
        fBadPath = (pszExpandedDir[2] != _T('\\'));
    }

    if (fBadPath) {
        LOGMESSAGE(_T("CheckDatabaseDirectory: Not a C:\\ style directory"));
        return(ERROR_BAD_PATHNAME);
    }

    //
    //  Characters like < > * ? and , won't work. Check for that now.
    //  Also, check for additional colons after the first C:\....
    //

    fBadChars = FALSE;

    if (!fBadChars) {
        fBadChars = (_tcschr(pszExpandedDir, _T('<')) != NULL);
    }
    if (!fBadChars) {
        fBadChars = (_tcschr(pszExpandedDir, _T('>')) != NULL);
    }
    if (!fBadChars) {
        fBadChars = (_tcschr(pszExpandedDir, _T('*')) != NULL);
    }
    if (!fBadChars) {
        fBadChars = (_tcschr(pszExpandedDir, _T('?')) != NULL);
    }
    if (!fBadChars) {
        fBadChars = (_tcschr(&(pszExpandedDir[3]), _T(':')) != NULL);
    }

    if (fBadChars) {
        LOGMESSAGE(_T("CheckDatabaseDirectory: Invalid characters"));
        return(ERROR_BAD_PATHNAME);
    }

    //
    //  GetDriveType only works for paths in the form "C:\" or
    //  "C:\ExistingDir". As pszDatabaseDir probably doesn't exist, it can't
    //  be passed to GetDriveType. Set a NULL character passed the "C:\" to
    //  pass in only the drive letter.
    //

    pszExpandedDir[3] = (TCHAR)NULL;
    DriveType = GetDriveType(pszExpandedDir);

    if (DriveType == DRIVE_FIXED) {
        return(NO_ERROR);
    } else {
        LOGMESSAGE(_T("CheckDatabaseDirectory: Bad DriveType %d"), DriveType);
        return(ERROR_BAD_PATHNAME);
    }
}

/*
 *  CreateDatabaseDirectory()
 *
 *  Creates the specified database directory.
 */

DWORD
CreateDatabaseDirectory(
    VOID
    )
{
    return(CreateDirectoryRecursively(gszDatabaseDirectory));
}

/*
 *  GetDatabaseDirectory()
 *
 *  Returns the current database directory.
 */

LPCTSTR
GetDatabaseDirectory(
    VOID
    )
{
    return(gszDatabaseDirectory);
}

/*
 *  RemoveDatabaseDirectory()
 *
 *  Removes the entire database directory.
 */

VOID
RemoveDatabaseDirectory(
    VOID
    )
{
    Delnode(gszDatabaseDirectory);
}

/*
 *  SetDatabaseDirectory()
 *
 *  This function assumes pszDatabaseDir has been verified by a call to
 *  CheckDatabaseDir(), which verifies not NULL, within MAX_PATH, and on a
 *  fixed hard drive.
 */

VOID
SetDatabaseDirectory(
    IN LPCTSTR  pszDatabaseDir
    )
{
    _tcscpy(gszDatabaseDirectory, pszDatabaseDir);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\setup\logfile.h ===
/*
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *  Module Name:
 *
 *      logfile.h
 *
 *  Abstract:
 *
 *      This file contains code to log messages to a file.
 *
 *  Author:
 *
 *      Breen Hagan (BreenH) Oct-02-98
 *
 *  Environment:
 *
 *      User Mode
 */

#ifndef _LSOC_LOGFILE_H_
#define _LSOC_LOGFILE_H_

/*
 *  Constants.
 */

#define CRLF    "\r\n"

/*
 *  LogFile Class.
 */

class LogFile
{
public:

    //
    //  Constructor and destructor.
    //

LogFile(
    );

~LogFile(
    );

    //
    //  Standard functions.
    //

VOID
Close(
    VOID
    );

DWORD
Initialize(
    IN LPCTSTR  pszLogFile,
    IN LPCTSTR  pszLogModule
    );

DWORD
__cdecl
LogMessage(
    LPCTSTR pszFormat,
    ...
    );

private:
    BOOL    m_fInitialized;
    HANDLE  m_hFile;
    TCHAR   m_szLogFile[MAX_PATH + 1];
    TCHAR   m_szLogModule[MAX_PATH + 1];

};

    //
    //  The following permits a macro to reference a global variable for
    //  the log file without putting the 'extern ...' line in each source
    //  file. Because of this, however, logfile.h can not be included in
    //  a precompiled header.
    //

#ifndef _LSOC_LOGFILE_CPP_
extern LogFile  SetupLog;
#endif

#define LOGCLOSE        SetupLog.Close
#define LOGINIT(x, y)   SetupLog.Initialize(x, y)
#define LOGMESSAGE      SetupLog.LogMessage

#endif // _LSOC_LOGFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\setup\ocpage.cpp ===
/*
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *  Module Name:
 *
 *      ocpage.cpp
 *
 *  Abstract:
 *
 *      This file defines an OC Manager Wizard Page base class.
 *
 *  Author:
 *
 *      Breen Hagan (BreenH) Oct-02-98
 *
 *  Environment:
 *
 *      User Mode
 */

#include "stdafx.h"
#include "logfile.h"

/*
 *  External Function Prototypes.
 */

HINSTANCE GetInstance();

INT_PTR CALLBACK
OCPage::PropertyPageDlgProc(
    HWND    hwndDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    OCPage  *pDlg;

    if (uMsg == WM_INITDIALOG) {
        pDlg = reinterpret_cast<OCPage*>(LPPROPSHEETPAGE(lParam)->lParam);
    } else {
        pDlg = reinterpret_cast<OCPage*>(GetWindowLongPtr(hwndDlg, DWLP_USER));
    }

    if (pDlg == NULL) {
        return(0);
    }

    switch(uMsg) {
    case WM_INITDIALOG:
        pDlg->SetDlgWnd(hwndDlg);
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pDlg);
        return(pDlg->OnInitDialog(hwndDlg, wParam, lParam));

    case WM_NOTIFY:
        return(pDlg->OnNotify(hwndDlg, wParam, lParam));

    case WM_COMMAND:
        return(pDlg->OnCommand(hwndDlg, wParam, lParam));
    }

    return(0);
}


OCPage::OCPage ()
{
}

BOOL OCPage::Initialize ()
{
    dwFlags = PSP_USECALLBACK;

    pszHeaderTitle = MAKEINTRESOURCE(GetHeaderTitleResource());
    if (pszHeaderTitle) {
        dwFlags |= PSP_USEHEADERTITLE;
    }

    pszHeaderSubTitle = MAKEINTRESOURCE(GetHeaderSubTitleResource());
    if (pszHeaderSubTitle) {
        dwFlags |= PSP_USEHEADERSUBTITLE;
    }

    dwSize         = sizeof(PROPSHEETPAGE);
    hInstance      = GetInstance();
    pszTemplate    = MAKEINTRESOURCE(GetPageID());
    pfnDlgProc     = PropertyPageDlgProc;
    pfnCallback    = NULL;
    lParam         = (LPARAM)this;

    return(pszTemplate != NULL ? TRUE : FALSE);
}

OCPage::~OCPage()
{
}

BOOL
OCPage::OnNotify(
    HWND    hWndDlg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    NMHDR *pnmh = (LPNMHDR) lParam;

    switch(pnmh->code)
    {
        case PSN_SETACTIVE:
            SetWindowLongPtr(hWndDlg, DWLP_MSGRESULT, CanShow() ? 0 : -1);
            PropSheet_SetWizButtons(GetParent(hWndDlg),
                PSWIZB_NEXT | PSWIZB_BACK);
            break;

        case PSN_WIZNEXT:
            SetWindowLongPtr(hWndDlg, DWLP_MSGRESULT, ApplyChanges() ? 0 : -1);
            break;

        case PSN_WIZBACK:
            SetWindowLongPtr(hWndDlg, DWLP_MSGRESULT, 0);
            break;

        default:
            return(FALSE);

    }

    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(wParam);
    return(TRUE);
}

BOOL
OCPage::OnCommand(
    HWND    hWndDlg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(hWndDlg);
    return(TRUE);
}


BOOL OCPage::OnInitDialog(
    HWND    hWndDlg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(hWndDlg);
    return(TRUE);
}

BOOL OCPage::ApplyChanges(
    )
{
    return(TRUE);
}

DWORD
OCPage::DisplayMessageBox(
    UINT        resText,
    UINT        resTitle,
    UINT        uType,
    int         *mbRetVal
    )
{
    return(::DisplayMessageBox(m_hDlgWnd, resText, resTitle, uType, mbRetVal));
}

DWORD
DisplayMessageBox(
    HWND        hWnd,
    UINT        resText,
    UINT        resTitle,
    UINT        uType,
    int         *mbRetVal
    )
{
    int     iRet;
    TCHAR   szResText[1024];
    TCHAR   szResTitle[1024];

    if (mbRetVal == NULL) {
        return(ERROR_INVALID_PARAMETER);
    }

    iRet = LoadString(
                GetInstance(),
                resText,
                szResText,
                1024
                );
    if (iRet == 0) {
        return(GetLastError());
    }

    iRet = LoadString(
                GetInstance(),
                resTitle,
                szResTitle,
                1024
                );
    if (iRet == 0) {
        return(GetLastError());
    }

    *mbRetVal = MessageBox(
                    hWnd,
                    szResText,
                    szResTitle,
                    uType
                    );

    return(*mbRetVal == 0 ? ERROR_OUTOFMEMORY : ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\setup\ocpage.h ===
/*
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *  Module Name:
 *
 *      ocpage.h
 *
 *  Abstract:
 *
 *      This file defines an OC Manager Wizard Page base class.
 *
 *  Author:
 *
 *      Breen Hagan (BreenH) Oct-02-98
 *
 *  Environment:
 *
 *      User Mode
 */

#ifndef _LSOC_OCPAGE_H_
#define _LSOC_OCPAGE_H_


class OCPage : public PROPSHEETPAGE
{
public:

    //
    //  Constructor and destructor.
    //

OCPage(
    );


virtual
~OCPage(
    );

    //
    //  Standard functions.
    //

HWND
GetDlgWnd(
    )
{
    return m_hDlgWnd;
}

BOOL
Initialize(
    );

BOOL
OnNotify(
    HWND    hWndDlg,
    WPARAM  wParam,
    LPARAM  lParam
    );

    //
    //  Virtual functions.
    //

virtual BOOL
ApplyChanges(
    );

virtual BOOL
CanShow(
    ) = 0;

virtual UINT
GetPageID(
    ) = 0;

virtual UINT
GetHeaderTitleResource(
    ) = 0;

virtual UINT
GetHeaderSubTitleResource(
    ) = 0;

virtual BOOL
OnCommand(
    HWND    hWndDlg,
    WPARAM  wParam,
    LPARAM  lParam
    );

virtual BOOL
OnInitDialog(
    HWND    hWndDlg,
    WPARAM  wParam,
    LPARAM  lParam
    );

    //
    //  Callback functions.
    //

static INT_PTR CALLBACK
PropertyPageDlgProc(
    HWND    hWndDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    );

protected:
    HWND    m_hDlgWnd;

DWORD
DisplayMessageBox(
    UINT        resText,
    UINT        resTitle,
    UINT        uType,
    int         *mbRetVal
    );

VOID
SetDlgWnd(
    HWND    hwndDlg
    )
{
    m_hDlgWnd = hwndDlg;
}

};

DWORD
DisplayMessageBox(
    HWND        hWnd,
    UINT        resText,
    UINT        resTitle,
    UINT        uType,
    int         *mbRetVal
    );

#endif // _LSOC_OCPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\setup\pages.cpp ===
/*
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *  Module Name:
 *
 *      pages.cpp
 *
 *  Abstract:
 *
 *      This file defines the License Server Setup Wizard Page class.
 *
 *  Author:
 *
 *      Breen Hagan (BreenH) Oct-02-98
 *
 *  Environment:
 *
 *      User Mode
 */

#include "stdafx.h"
#include "pages.h"
#include "logfile.h"

extern BOOL gStandAlone;
extern BOOL gUnAttended;
TCHAR       gszInitialDir[MAX_PATH + 1];

BOOL        GetCurrentSelectionState(VOID);
BOOL        InWin2000Domain(VOID);
EInstall    GetInstallSection(VOID);
HINSTANCE   GetInstance(VOID);
EServerType GetServerRole(VOID);
DWORD       SetServerRole(UINT);

/*
 *  EnablePage::CanShow()
 *
 *  The page will only be displayed during standalone installations.
 */

BOOL
EnablePage::CanShow(
    )
{
    return((GetInstallSection() == kInstall) && gStandAlone && !gUnAttended);
}

/*
 *  EnablePage::OnInitDialog()
 *
 *  Initializes the wizard page controls. If the machine is not a domain
 *  controller, the server type is reduced to plain server only.
 */

BOOL
EnablePage::OnInitDialog(
    HWND    hWndDlg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    BOOL    fInDomain = InWin2000Domain();
    TCHAR   pszExpDir[MAX_PATH + 1];

    if (!fInDomain) {
        EnableWindow(
            GetDlgItem(GetDlgWnd(), IDC_RADIO_ENTERPRISE_SERVER),
            FALSE
            );
    }

    CheckRadioButton(
        GetDlgWnd(),
        IDC_RADIO_ENTERPRISE_SERVER,
        IDC_RADIO_PLAIN_SERVER,
        fInDomain ?
            (GetServerRole() == eEnterpriseServer ?
                IDC_RADIO_ENTERPRISE_SERVER :
                IDC_RADIO_PLAIN_SERVER
            ) :
            IDC_RADIO_PLAIN_SERVER
        );

    _tcscpy(gszInitialDir, GetDatabaseDirectory());
    ExpandEnvironmentStrings(gszInitialDir, pszExpDir, MAX_PATH);
    SetDlgItemText(GetDlgWnd(), IDC_EDIT_INSTALL_DIR, pszExpDir);

    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(hWndDlg);
    return(TRUE);
}

BOOL
EnablePage::OnCommand(
    HWND    hWndDlg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    int iRet;

    if ((LOWORD(wParam) == IDC_BUTTON_BROWSE_DIR) &&
        (HIWORD(wParam) == BN_CLICKED))
    {
        BROWSEINFO brInfo;
        ZeroMemory(&brInfo, sizeof(brInfo));

        brInfo.hwndOwner = hWndDlg;

        TCHAR strText[1024];
        iRet = LoadString(
                    GetInstance(),
                    IDS_STRING_DIRECTORY_SELECT,
                    strText,
                    1024
                    );

        brInfo.lpszTitle = strText;

        LPITEMIDLIST pidl = SHBrowseForFolder(&brInfo);
        if (pidl) {
            TCHAR szDir[MAX_PATH + 1];
            SHGetPathFromIDList (pidl, szDir);
            SetDlgItemText(hWndDlg, IDC_EDIT_INSTALL_DIR, szDir);
        }
    }

    UNREFERENCED_PARAMETER(lParam);
    return(TRUE);
}

BOOL
EnablePage::ApplyChanges(
    )
{
    BOOL    fDirExists              = FALSE;
    DWORD   dwErr;
    int     iRet;
    TCHAR   szTxt[MAX_PATH + 1]         = _T("");
    TCHAR   szSubDir[]              = _T("\\LServer");
    TCHAR   szExpDir[MAX_PATH + 1];
    TCHAR   szExpInitDir[MAX_PATH + 1];

    if (GetDlgItemText(GetDlgWnd(), IDC_EDIT_INSTALL_DIR, szTxt,
        MAX_PATH) == 0) {

        //
        //  Complain about blank entries.
        //

        DisplayMessageBox(
            IDS_STRING_INVLID_INSTALLATION_DIRECTORY,
            IDS_MAIN_TITLE,
            MB_OK,
            &iRet
            );

        return(FALSE);
    }

    //
    //  Verify the string is not too long, expanding environment strings
    //  in the process.
    //

    if (ExpandEnvironmentStrings(szTxt, szExpDir, MAX_PATH) > MAX_PATH) {
        DisplayMessageBox(
            IDS_STRING_INVLID_INSTALLATION_DIRECTORY,
            IDS_MAIN_TITLE,
            MB_OK,
            &iRet
            );

        return(FALSE);
    }

    //
    //  If the entry is still the original default directory, no more
    //  verification is necessary.
    //

    ExpandEnvironmentStrings(gszInitialDir, szExpInitDir, MAX_PATH);
    if (_tcsicmp(szExpDir, szExpInitDir) == 0) {
        goto DirCreation;
    }

    //
    //  Check for directory existance before appending a subdirectory.
    //  This will prevent the user chosen directory of "C:\", for
    //  example, from prompting the user to create the directory.
    //

    fDirExists = SetCurrentDirectory(szExpDir);

    //
    //  The user has chosen a different directory. To protect its
    //  contents during uninstall, the TLServer subdirectory will be
    //  used.
    //

    if ((_tcslen(szExpDir) + _tcslen(szSubDir) + 1) > MAX_PATH) {
        DisplayMessageBox(
            IDS_STRING_INVLID_INSTALLATION_DIRECTORY,
            IDS_MAIN_TITLE,
            MB_OK,
            &iRet
            );

        return(FALSE);
    }

    _tcscat(szExpDir, szSubDir);
    _tcscat(szTxt, szSubDir);

    //
    //  Verify the user's directory choice is valid, e.g. no floppy
    //  drives, CD-ROMs, network paths, etc.
    //

    if (CheckDatabaseDirectory(szExpDir) != ERROR_SUCCESS) {
        DisplayMessageBox(
            IDS_STRING_INVLID_INSTALLATION_DIRECTORY,
            IDS_MAIN_TITLE,
            MB_OK,
            &iRet
            );

        return(FALSE);
    }

    //
    //  Prompt to create the directory if necessary.
    //

    if (!fDirExists) {
        DisplayMessageBox(
            IDS_STRING_CREATE_INSTALLATION_DIRECTORY,
            IDS_MAIN_TITLE,
            MB_OKCANCEL,
            &iRet
            );

        if (iRet != IDOK) {
            return(FALSE);
        }
    }

    //
    //  The selected directory has passed all the tests, but it may
    //  still not be created. If creation fails, let the user know,
    //  and let s/he choose another directory.
    //

DirCreation:
    SetDatabaseDirectory(szTxt);

    dwErr = CreateDatabaseDirectory();
    if (dwErr != ERROR_SUCCESS) {
        DisplayMessageBox(
            IDS_STRING_CANT_CREATE_INSTALLATION_DIRECTORY,
            IDS_MAIN_TITLE,
            MB_OK,
            &iRet
            );

        return(FALSE);
    }

    SetServerRole(IsDlgButtonChecked (
                    GetDlgWnd(), IDC_RADIO_ENTERPRISE_SERVER) == BST_CHECKED ?
                    eEnterpriseServer : ePlainServer);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\setup\pages.h ===
/*
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *  Module Name:
 *
 *      pages.h
 *
 *  Abstract:
 *
 *      This file defines the License Server Setup Wizard Page class.
 *
 *  Author:
 *
 *      Breen Hagan (BreenH) Oct-02-98
 *
 *  Environment:
 *
 *      User Mode
 */

#ifndef __LSOC_PAGES_H__
#define __LSOC_PAGES_H__

#include "ocpage.h"

class EnablePage : public OCPage
{
private:

BOOL
CanShow(
    );

BOOL
OnInitDialog(
    HWND    hwndDlg,
    WPARAM  wParam,
    LPARAM  lParam
    );

BOOL
OnCommand(
    HWND    hWndDlg,
    WPARAM  wParam,
    LPARAM  lParam
    );

BOOL
ApplyChanges(
    );

UINT
GetPageID(
    )
{
    return(IDD_PROPPAGE_LICENSESERVICES);
}

UINT
GetHeaderTitleResource(
    )
{
    return(IDS_MAIN_TITLE);
}

UINT
GetHeaderSubTitleResource(
    )
{
    return(IDS_SUB_TITLE);
}

};

#endif // __LSOC_PAGES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\setup\logfile.cpp ===
/*
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *  Module Name:
 *
 *      logfile.cpp
 *
 *  Abstract:
 *
 *      This file contains code to log messages to a file.
 *
 *  Author:
 *
 *      Breen Hagan (BreenH) Oct-02-98
 *
 *  Environment:
 *
 *      User Mode
 */

#define _LSOC_LOGFILE_CPP_

#include "stdafx.h"
#include "logfile.h"

/*
 *  Globals.
 */

LogFile SetupLog;

/*
 *  Constants.
 */

const UINT        LOG_ENTRY_SIZE             = 1024;
const UINT        S_SIZE                     = 1024;

/*
 *  Function prototypes.
 */

DWORD TCharStringToAnsiString(LPCTSTR, LPSTR);

/*
 *  Class LogFile.
 */

LogFile::LogFile(
    )
{
    m_fInitialized      = FALSE;
    m_szLogFile[0]      = (TCHAR)NULL;
    m_szLogModule[0]    = (TCHAR)NULL;
}

LogFile::~LogFile(
    )
{
}

VOID
LogFile::Close(
    VOID
    )
{
    if (m_fInitialized) {
        LogMessage(_T(CRLF));
        LogMessage(_T("**"));
        LogMessage(_T("** Closing Message Log for %s"), m_szLogModule);
        LogMessage(_T("**"));
        LogMessage(_T(CRLF));
        LogMessage(_T(CRLF));
        CloseHandle(m_hFile);
        m_fInitialized = FALSE;
    }
}

DWORD
LogFile::Initialize(
    IN LPCTSTR  pszLogFile,
    IN LPCTSTR  pszLogModule
    )
{
    OSVERSIONINFO   osVersion;
    TCHAR           pszDate[S_SIZE];
    TCHAR           pszTime[S_SIZE];

    //
    //  Initializing the log file twice is "A Bad Thing."
    //

    if (m_fInitialized) {
        LogMessage(_T("LogFile::Initialize called twice!"));
        return(ERROR_SUCCESS);
    }

    //
    //  Sanity checks. Pointless in a limited setting, but useful if this
    //  file is copied to other projects.
    //

    if ((pszLogFile == NULL) || (pszLogFile[0] == (TCHAR)NULL)) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ((pszLogModule == NULL) || (pszLogModule[0] == (TCHAR)NULL)) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ((_tcslen(pszLogFile) > MAX_PATH) ||
        (_tcslen(pszLogModule) > MAX_PATH)) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    //  Save the log file and module name.
    //

    _tcscpy(m_szLogFile, pszLogFile);
    _tcscpy(m_szLogModule, pszLogModule);

    //
    //  Open or create the log file.
    //

    m_hFile = CreateFile(
                pszLogFile,
                GENERIC_WRITE,
                0,
                NULL,
                OPEN_ALWAYS,
                0,
                NULL
                );
    if (m_hFile == INVALID_HANDLE_VALUE) {
        return(GetLastError());
    }

    m_fInitialized = TRUE;
    SetFilePointer(m_hFile, 0, NULL, FILE_END);

    //
    //  Get the current date and time for the log file.
    //

    _tstrdate(pszDate);
    _tstrtime(pszTime);

    LogMessage(_T("**"));
    LogMessage(_T("** Initializing Message Log for %s"), m_szLogModule);
    LogMessage(_T("** Date: %s Time: %s"), pszDate, pszTime);
    LogMessage(_T("**"));
    LogMessage(_T(CRLF));

    //
    //  Log information on the OS version.
    //

    osVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (GetVersionEx(&osVersion) != 0) {

        LogMessage(
            _T("Version: %lu.%lu.%lu Platform: %lu, %s"),
            osVersion.dwMajorVersion,
            osVersion.dwMinorVersion,
            osVersion.dwBuildNumber,
            osVersion.dwPlatformId,
#ifdef DBG
            _T("Checked")
#else
            _T("Free")
#endif
            );
    }

    return(ERROR_SUCCESS);
}

/*
 *  LogFile::LogMessage()
 *
 *
 */

DWORD
__cdecl
LogFile::LogMessage(
    LPCTSTR pszFormat,
    ...
    )
{
    CHAR    cszOutput[LOG_ENTRY_SIZE];
    DWORD   cBytes;
    DWORD   cLength;
    TCHAR   tszOutput[LOG_ENTRY_SIZE];
    va_list vaList;

    if (!m_fInitialized) {
        return(ERROR_INVALID_HANDLE);
    }

    SetLastError(ERROR_SUCCESS);

    va_start(vaList, pszFormat);
    _vstprintf(tszOutput, pszFormat, vaList);
    va_end(vaList);

    cLength = TCharStringToAnsiString(tszOutput, cszOutput);

    if (cLength != (DWORD)-1) {
        WriteFile(m_hFile, cszOutput, cLength * sizeof(char), &cBytes, NULL);
        WriteFile(m_hFile, CRLF, strlen(CRLF) * sizeof(char), &cBytes, NULL);
    }

    return(GetLastError());
}

/*
 *
 *
 *
 */

DWORD
TCharStringToAnsiString(
    LPCTSTR tszStr,
    LPSTR   cszStr
    )
{
#ifdef UNICODE
    DWORD   cLength;

    cLength = WideCharToMultiByte(
                CP_ACP,
                0,
                tszStr,
                -1,
                NULL,
                0,
                NULL,
                NULL
                );

    if ((cLength == 0) || (cLength > S_SIZE)) {
        return((DWORD)-1);
    }

    cLength = WideCharToMultiByte(
                CP_ACP,
                0,
                tszStr,
                -1,
                cszStr,
                cLength,
                NULL,
                NULL
                );

    return(cLength);
#else
    _tcscpy(cszStr, tszStr);
    return(_tcslen(cszStr));
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\setup\services.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       services.h 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
/*
 */

#ifndef _LSOC_SERVICES_H_
#define _LSOC_SERVICES_H_

DWORD
ServiceDeleteFromInfSection(
    IN HINF     hInf,
    IN LPCTSTR  pszSection
    );

DWORD
ServiceStartFromInfSection(
    IN HINF     hInf,
    IN LPCTSTR  pszSection
    );

#endif // _LSOC_SERVICES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\setup\registry.h ===
/*
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *  Module Name:
 *
 *      registry.h
 *
 *  Abstract:
 *
 *      This file handles registry actions needed by License Server setup.
 *
 *  Author:
 *
 *      Breen Hagan (BreenH) Oct-02-98
 *
 *  Environment:
 *
 *      User Mode
 */

#ifndef _LSOC_REGISTRY_H_
#define _LSOC_REGISTRY_H_

/*
 *  Function Prototypes.
 */

DWORD
CreateRegistrySettings(
    LPCTSTR pszDatabaseDirectory,
    DWORD   dwServerRole
    );

LPCTSTR
GetDatabaseDirectoryFromRegistry(
    VOID
    );

DWORD
GetServerRoleFromRegistry(
    VOID
    );

DWORD
RemoveRegistrySettings(
    VOID
    );

#endif // _LSOC_REGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\setup\services.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       services.cpp 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "logfile.h"

/*
 *  Constants.
 */

const UINT  SECTION_SIZE        = 256;
const TCHAR SERVICE_DEL_KEY[]   = _T("DelService");
const UINT  SERVICE_DEL_NAME    = 1;
const TCHAR SERVICE_START_KEY[] = _T("StartService");
const UINT  SERVICE_START_NAME  = 1;

/*
 *  Helper Functions.
 */

VOID
ProcessDelService(
    IN SC_HANDLE    schSCManager,
    IN LPCTSTR      pszServiceName
    )
{
    SC_HANDLE       schService;
    SERVICE_STATUS  ssStatus;

    schService = OpenService(schSCManager, pszServiceName, SERVICE_ALL_ACCESS);
    if (!schService) {
        LOGMESSAGE(_T("ProcessDelService: Can't open service %s"),
            pszServiceName);
        return;
    }

    if (ControlService(schService, SERVICE_CONTROL_STOP, &ssStatus)) {
        Sleep(1000);

        while(QueryServiceStatus(schService, &ssStatus)) {
            if (ssStatus.dwCurrentState == SERVICE_STOP_PENDING) {
                Sleep(1000);
            } else {
                break;
            }
        }

        if (ssStatus.dwCurrentState != SERVICE_STOPPED) {
            LOGMESSAGE(_T("ProcessDelService: Couldn't stop service %s"),
                pszServiceName);
        }
    } else {
        LOGMESSAGE(_T("ProcessDelService: Couldn't control service %s"),
            pszServiceName);
    }

    if (DeleteService(schService)) {
        LOGMESSAGE(_T("ProcessDelService: %s deleted"), pszServiceName);
    } else {
        LOGMESSAGE(_T("ProcessDelService: Couldn't delete service %s"),
            pszServiceName);
    }

    CloseServiceHandle(schService);
}

VOID
ProcessStartService(
    IN SC_HANDLE    schSCManager,
    IN LPCTSTR      pszServiceName
    )
{
    SC_HANDLE       schService;
    SERVICE_STATUS  ssStatus;

    schService = OpenService(schSCManager, pszServiceName, SERVICE_ALL_ACCESS);
    if (!schService) {
        LOGMESSAGE(_T("ProcessStartService: Can't open service %s"),
            pszServiceName);
        return;
    }

    if (StartService(schService, 0, NULL)) {
        Sleep(1000);

        while(QueryServiceStatus(schService, &ssStatus)) {
            if (ssStatus.dwCurrentState == SERVICE_START_PENDING) {
                Sleep(1000);
            } else {
                break;
            }
        }

        if (ssStatus.dwCurrentState == SERVICE_RUNNING) {
            LOGMESSAGE(_T("ProcessStartService: %s started"),
                pszServiceName);
        } else {
            LOGMESSAGE(_T("ProcessStartService: Couldn't start service %s"),
                pszServiceName);
        }
    } else {
        LOGMESSAGE(_T("ProcessStartService: Couldn't control service %s"),
            pszServiceName);
    }

    CloseServiceHandle(schService);
}

/*
 *  ServiceDeleteFromInfSection()
 *
 *  Handles service deletion from inf sections in the form of:
 *
 *  [SectionName]
 *  DelService  = Service1
 *  DelService  = Service2
 *
 *  where Service1 and Service2 are service names.
 */

DWORD
ServiceDeleteFromInfSection(
    IN HINF     hInf,
    IN LPCTSTR  pszSection
    )
{
    BOOL        fErr;
    BOOL        fFound;
    INFCONTEXT  infContext;
    SC_HANDLE   schSCManager;

    schSCManager = OpenSCManager(
                        NULL,
                        NULL,
                        SC_MANAGER_ALL_ACCESS
                        );
    if (!schSCManager) {
        LOGMESSAGE(_T("ServiceDeleteFromInfSection: Failed to open SC Manager"));
        return(GetLastError());
    }

    fFound = SetupFindFirstLine(
                hInf,
                pszSection,
                SERVICE_DEL_KEY,
                &infContext
                );

    while (fFound) {
        TCHAR   pszServiceName[SECTION_SIZE];

        fErr = SetupGetStringField(
                    &infContext,
                    SERVICE_DEL_NAME,
                    pszServiceName,
                    SECTION_SIZE,
                    NULL
                    );
        if (fErr) {
            ProcessDelService(schSCManager, pszServiceName);
        } else {
            LOGMESSAGE(_T("ServiceDeleteFromInfSection: Could not get service section."));
        }

        fFound = SetupFindNextMatchLine(
                    &infContext,
                    SERVICE_DEL_KEY,
                    &infContext
                    );
    }

    CloseServiceHandle(schSCManager);
    return(ERROR_SUCCESS);
}

/*
 *  ServiceStartFromInfSection()
 *
 *  Starts a service that has been installed by setupapi.
 *
 */

DWORD
ServiceStartFromInfSection(
    IN HINF     hInf,
    IN LPCTSTR  pszSection
    )
{
    BOOL        fErr;
    BOOL        fFound;
    INFCONTEXT  infContext;
    SC_HANDLE   schSCManager;

    schSCManager = OpenSCManager(
                        NULL,
                        NULL,
                        SC_MANAGER_ALL_ACCESS
                        );
    if (!schSCManager) {
        LOGMESSAGE(_T("ServiceStartFromInfSection: Failed to open SC Manager"));
        return(GetLastError());
    }

    fFound = SetupFindFirstLine(
                hInf,
                pszSection,
                SERVICE_START_KEY,
                &infContext
                );

    while (fFound) {
        TCHAR   pszServiceName[SECTION_SIZE];

        fErr = SetupGetStringField(
                    &infContext,
                    SERVICE_START_NAME,
                    pszServiceName,
                    SECTION_SIZE,
                    NULL
                    );
        if (fErr) {
            ProcessStartService(schSCManager, pszServiceName);
        } else {
            LOGMESSAGE(_T("ServiceStartFromInfSection: Could not get service section."));
        }

        fFound = SetupFindNextMatchLine(
                    &infContext,
                    SERVICE_START_KEY,
                    &infContext
                    );
    }

    CloseServiceHandle(schSCManager);
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\setup\registry.cpp ===
/*
 *  Copyright (c) 1998  Microsoft Corporation
 *
 *  Module Name:
 *
 *      registry.cpp
 *
 *  Abstract:
 *
 *      This file handles registry actions needed by License Server setup.
 *
 *  Author:
 *
 *      Breen Hagan (BreenH) Oct-02-98
 *
 *  Environment:
 *
 *      User Mode
 */

#include "stdafx.h"
#include "logfile.h"

/*
 *  Global variables.
 */


/*
 *  Constants.
 */

const TCHAR gszLSParamKey[] =
    _T("System\\CurrentControlSet\\Services\\TermServLicensing\\Parameters");
const TCHAR gszDatabasePathValue[]  = _T("DBPath");
const TCHAR gszServerRoleValue[]    = _T("Role");

/*
 *  Function prototypes.
 */


/*
 *  Function implementations.
 */

DWORD
CreateRegistrySettings(
    LPCTSTR pszDatabaseDirectory,
    DWORD   dwServerRole
    )
{
    DWORD   dwErr, dwDisposition;
    HKEY    hLSParamKey;

    LOGMESSAGE(_T("CreateRegistrySettings: Entered with %s, %ld"),
        pszDatabaseDirectory, dwServerRole);

    dwErr = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                gszLSParamKey,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,
                &hLSParamKey,
                &dwDisposition
                );
    if (dwErr != ERROR_SUCCESS) {
        LOGMESSAGE(_T("CreateRegistrySettings: RegCreateKeyEx: Error %ld"),
            dwErr);
        return(dwErr);
    }

    dwErr = RegSetValueEx(
                hLSParamKey,
                gszDatabasePathValue,
                0,
                REG_EXPAND_SZ,
                (LPBYTE)pszDatabaseDirectory,
                (_tcslen(pszDatabaseDirectory) + 1) * sizeof(TCHAR)
                );
    if (dwErr != ERROR_SUCCESS) {
        RegCloseKey(hLSParamKey);
        LOGMESSAGE(_T("CreateRegistrySettings: RegSetValueEx: %s: Error %ld"),
            _T("DatabasePath"), dwErr);
        return(dwErr);
    }

    dwErr = RegSetValueEx(
                hLSParamKey,
                gszServerRoleValue,
                0,
                REG_DWORD,
                (LPBYTE)&dwServerRole,
                sizeof(DWORD)
                );
    if (dwErr != ERROR_SUCCESS) {
        RegCloseKey(hLSParamKey);
        LOGMESSAGE(_T("CreateRegistrySettings: RegSetValueEx: %s: Error %ld"),
            _T("ServerRole"), dwErr);
        return(dwErr);
    }

    RegCloseKey(hLSParamKey);
    return(ERROR_SUCCESS);
}

LPCTSTR
GetDatabaseDirectoryFromRegistry(
    VOID
    )
{
    static TCHAR    pRegValue[MAX_PATH + 1];
    DWORD           dwErr, cbRegValue = (MAX_PATH * sizeof(TCHAR));
    HKEY            hLSParamKey;

    dwErr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                gszLSParamKey,
                0,
                KEY_READ,
                &hLSParamKey
                );
    if (dwErr != ERROR_SUCCESS) {
        return(NULL);
    }

    dwErr = RegQueryValueEx(
                hLSParamKey,
                gszDatabasePathValue,
                NULL,
                NULL,
                (LPBYTE)pRegValue,
                &cbRegValue
                );
    if (dwErr != ERROR_SUCCESS) {
        return(NULL);
    }

    RegCloseKey(hLSParamKey);
    return(pRegValue);
}

DWORD
GetServerRoleFromRegistry(
    VOID
    )
{
    DWORD   dwErr, dwValue, cbValue = sizeof(DWORD);
    HKEY    hLSParamKey;

    dwErr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                gszLSParamKey,
                0,
                KEY_READ,
                &hLSParamKey
                );
    if (dwErr != ERROR_SUCCESS) {
        SetLastError(dwErr);
        return((DWORD)-1);
    }

    dwErr = RegQueryValueEx(
                hLSParamKey,
                gszServerRoleValue,
                NULL,
                NULL,
                (LPBYTE)&dwValue,
                &cbValue
                );
    if (dwErr != ERROR_SUCCESS) {
        SetLastError(dwErr);
        return((DWORD)-1);
    }

    RegCloseKey(hLSParamKey);
    return(dwValue);
}

DWORD
RemoveRegistrySettings(
    VOID
    )
{
    DWORD   dwErr;
    HKEY    hLSParamKey;

    dwErr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                gszLSParamKey,
                0,
                KEY_ALL_ACCESS,
                &hLSParamKey
                );
    if (dwErr != ERROR_SUCCESS) {
        return(dwErr);
    }

    dwErr = RegDeleteValue(
                hLSParamKey,
                gszDatabasePathValue
                );
    if (dwErr != ERROR_SUCCESS) {
        RegCloseKey(hLSParamKey);
        return(dwErr);
    }

    dwErr = RegDeleteValue(
                hLSParamKey,
                gszServerRoleValue
                );
    if (dwErr != ERROR_SUCCESS) {
        RegCloseKey(hLSParamKey);
        return(dwErr);
    }

    RegCloseKey(hLSParamKey);
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\setup\resource.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       resource.h 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include <ntverp.h>

#define	VER_FILETYPE	VFT_APP
#define	VER_FILESUBTYPE	VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "License Server Optional Component Setup"
#define VER_INTERNALNAME_STR        "licenoc"
#define VER_ORIGINALFILENAME_STR    "licenoc.dll"

#include "common.ver"

#define IDS_STRING_DIRECTORY_SELECT                     1
#define IDS_STRING_INVLID_INSTALLATION_DIRECTORY        2
#define IDS_STRING_CREATE_INSTALLATION_DIRECTORY        3
#define IDS_STRING_CANT_CREATE_INSTALLATION_DIRECTORY   4
#define IDS_MAIN_TITLE                                  5
#define IDS_SUB_TITLE                                   6
#define IDS_STRING_LICENSES_GO_BYE_BYE                  7
#define IDS_INSUFFICIENT_PERMISSION                     8

#define IDD_PROPPAGE_LICENSESERVICES    110
#define IDC_EDIT_INSTALL_DIR            1000
#define IDC_BUTTON_BROWSE_DIR           1001
#define IDC_RADIO_ENTERPRISE_SERVER     1002
#define IDC_RADIO_PLAIN_SERVER          1003
#define IDC_STATIC                      -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\setup\stdafx.h ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *
 *  Abstract:
 *
 *
 *  Author:
 *
 *
 *  Environment:
 *
 *    User Mode
 */

#include <windows.h>

#include <stdio.h>
#include <tchar.h>
#include <time.h>

#include <setupapi.h>
#include <ocmanage.h>

#include <shellapi.h>
#include <shlobj.h>

#include <commdlg.h>

#include <dsrole.h>
#include <dsgetdc.h>

#include <esetup.h>

#include "licenoc.h"
#include "resource.h"
#include "ocpage.h"
#include "pages.h"
#include "dir.h"
#include "registry.h"
#include "services.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\setup\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Makarand Patwardhan (makarp)

!ENDIF

TERMSRV_ROOT = ..\..\..\..
TL_SERVER_DIR = ..\..

INCLUDES=                                               \
        ..;                                             \
        $(TL_SERVER_DIR)\include;                    \
        $(TL_SERVER_DIR)\upg4to5;

MAJORCOMP=LicenOC

TARGETPATH=obj
TARGETTYPE=DYNLINK

DLLDEF=..\LicenOC.def
DLLBASE=0x2000000
DLLENTRY=_DllMainCRTStartup
USE_MSVCRT=1

C_DEFINES=$(C_DEFINES) -DLICENOC_SMALL_UPG

PRECOMPILED_INCLUDE = ..\stdafx.h
PRECOMPILED_SOURCEFILE = ..\stdafx.cpp
PRECOMPILED_CXX = 1

SOURCES=                    \
        ..\licenoc.cpp      \
        ..\licenoc.rc       \
        ..\registry.cpp     \
        ..\services.cpp     \
        ..\ocpage.cpp       \
        ..\pages.cpp        \
        ..\dir.cpp          \
        ..\logfile.cpp


TARGETLIBS=                                         \
        $(SDK_LIB_PATH)\activeds.lib    \
        $(SDK_LIB_PATH)\adsiid.lib      \
        $(SDK_LIB_PATH)\advapi32.lib    \
        $(SDK_LIB_PATH)\comctl32.lib    \
        $(SDK_LIB_PATH)\esent.lib       \
        $(SDK_LIB_PATH)\kernel32.lib    \
        $(SDK_LIB_PATH)\netapi32.lib    \
        $(SDK_LIB_PATH)\ntdsapi.lib     \
        $(SDK_LIB_PATH)\user32.lib      \
        $(SDK_LIB_PATH)\odbc32.lib      \
        $(SDK_LIB_PATH)\ole32.lib       \
        $(SDK_LIB_PATH)\oleaut32.lib    \
        $(SDK_LIB_PATH)\setupapi.lib    \
        $(SDK_LIB_PATH)\shell32.lib     \
        $(SDK_LIB_PATH)\uuid.lib        \
        $(TERMSRV_ROOT)\lib\$(O)\esetup.lib        \
        $(TERMSRV_ROOT)\lib\$(O)\upg4db.lib        \
        $(TERMSRV_ROOT)\lib\$(O)\common.lib


386_WARNING_LEVEL=-W4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\setup\stdafx.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//---------------------------------------------------------------------------
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\setup\inf\sources.inc ===
#
# Copyright (c) 1997-1999 Microsoft Corporation
#

#
# This file is designed to be included from 2 levels below
# (ie, daytona\srv, daytona\wks, cairo\srv, or cairo\wks).
#

SYNCHRONIZE_BLOCK=1

MAJORCOMP=setup
MINORCOMP=infs

TARGETNAME=inf
TARGETPATH=obj
TARGETTYPE=notarget

#
# No explicit sources because build doesn't understand .inf files.
#
SOURCES=

#
# Use NTTARGETFILE0 macros to cause the infs to get built during
# the compile phase. We do this so that we can disable MP build for
# this directory, using BLOCK and DRAIN.
#
NTTARGETFILE0=make_infs

NO_BROWSER_FILE=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\setup\inf\makefile.inc ===
#
# Copyright (c) 1997-1999 Microsoft Corporation
#
#
# For daytona, this file is designed to be included from 3 levels below
# ie, dayona\$(LANGUAGE)inf\srv, or daytona\$(LANGUAGE)inf\wks
#
# Note: NEC98 builds go through this file twice, the second time
# with "ALT_PROJECT"=="NEC_98".  These latter produce a subset
# of binaries which are only used on NEC98 machines.
#

!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

_LNG=..\..\$(LANGUAGE)
_INX=..\..
_INF=obj\$(TARGET_DIRECTORY)


make_infs:$(_INF)\licenoc.inf

$(_INF)\licenoc.inf: $(_INX)\licenoc.inx $(_LNG)\licenoc.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\setup\inf\daytona\chsinf\makefile.inc ===
LANGUAGE=CHS
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\setup\inf\daytona\jpninf\makefile.inc ===
LANGUAGE=JPN
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\setup\inf\daytona\chtinf\makefile.inc ===
LANGUAGE=CHT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\setup\inf\daytona\korinf\makefile.inc ===
LANGUAGE=KOR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\setup\inf\daytona\usainf\makefile.inc ===
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tls236\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1997
//
// File:        pch.cpp
//
// Contents:    TLS236 policy module precompiled header
//
//---------------------------------------------------------------------------
#pragma warning(disable: 4018)
#pragma warning(disable: 4244)

#include "tlsassrt.h"

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <wincrypt.h>
#include "license.h"
#include "tlsapip.h"
#include "tls236.h"
#include "messages.h"
#include "resource.h"
#include "licekpak.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tls236\resource.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       resource.h 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __RESOURCE_H__

#define IDS_COMPANYNAME             200
#define IDS_EX_PRODUCTNAME          201
#define IDS_EX_PRODUCTDESC          202
#define IDS_EX_PRODUCTDESC51        203

#define IDS_S_PRODUCTNAME           205
#define IDS_S_PRODUCTDESC           206
#define IDS_S_PRODUCTDESC51         211


#define IDS_I_PRODUCTNAME           212
#define IDS_I_PRODUCTDESC           213


#define IDS_C_PRODUCTNAME           214
#define IDS_C_PRODUCTDESC51         215


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tls236\dllmain.c ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include <windows.h>
#include "license.h"
#include "tlsapi.h"

extern void InitPolicyModule(HMODULE hModule);

BOOL WINAPI 
DllMain(
    IN HINSTANCE hInstance,
    IN DWORD     reason,
    IN LPVOID    reserved
    )
/*++

++*/
{
    BOOL b;

    UNREFERENCED_PARAMETER(reserved);
    b = TRUE;

    switch(reason)
    {
        case DLL_PROCESS_ATTACH:
            InitPolicyModule( hInstance );
            break;

        case DLL_THREAD_ATTACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_THREAD_DETACH:
            break;
    }

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tls236\request.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        request.cpp
//
// Contents:    TLS236 policy module routines 
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include <rpc.h>
#include <time.h>

extern CClientMgr* g_ClientMgr;
HMODULE g_hInstance;

#define NUMBER_PRODUCTSTRING_RESOURCE   3
#define INDEX_COMPANYNAME               0
#define INDEX_PRODUCTNAME               1
#define INDEX_PRODUCTDESC               2


#define NUMBER_OF_CLIENT_OS             4
#define NUMBER_OF_TERMSRV_OS            3

#define DENY_BUILTIN                    0
#define ALLOW_BUILTIN                   1  


static char LicenseTable[NUMBER_OF_CLIENT_OS][NUMBER_OF_TERMSRV_OS] = 
{
	    {DENY_BUILTIN,  DENY_BUILTIN, DENY_BUILTIN },
	    {ALLOW_BUILTIN, DENY_BUILTIN, DENY_BUILTIN },
        {ALLOW_BUILTIN, DENY_BUILTIN, DENY_BUILTIN },
	    {ALLOW_BUILTIN, DENY_BUILTIN, DENY_BUILTIN }
};

//
// Windows 2000
//
LPTSTR g_pszUSFreeKeyPackProductDesc[NUMBER_PRODUCTSTRING_RESOURCE] = {
    US_IDS_COMPANYNAME,
    US_IDS_EX_PRODUCTNAME,
    US_IDS_EX_PRODUCTDESC
};

LPTSTR g_pszLocalizedFreeKeyPackProductDesc[NUMBER_PRODUCTSTRING_RESOURCE] = {
    NULL,
    NULL,
    NULL
};
    
LPTSTR g_pszUSStandardKeyPackProductString[NUMBER_PRODUCTSTRING_RESOURCE] = {
    US_IDS_COMPANYNAME,
    US_IDS_S_PRODUCTNAME,
    US_IDS_S_PRODUCTDESC
};

LPTSTR g_pszLocalizedStandardKeyPackProductString[NUMBER_PRODUCTSTRING_RESOURCE] = {
    NULL,
    NULL,
    NULL
};


LPTSTR g_pszUSInternetKeyPackProductDesc [NUMBER_PRODUCTSTRING_RESOURCE] = {
    US_IDS_COMPANYNAME,
    US_IDS_I_PRODUCTNAME,
    US_IDS_I_PRODUCTDESC
};

LPTSTR g_pszLocalizedInternetKeyPackProductDesc [NUMBER_PRODUCTSTRING_RESOURCE] = {
    NULL,
    NULL,
    NULL,
};


//
// Whistler
//
   
LPTSTR g_pszUSStandardKeyPackProductString51[NUMBER_PRODUCTSTRING_RESOURCE] = {
    US_IDS_COMPANYNAME,
    US_IDS_S_PRODUCTNAME,
    US_IDS_S_PRODUCTDESC51
};

LPTSTR g_pszLocalizedStandardKeyPackProductString51[NUMBER_PRODUCTSTRING_RESOURCE] = {
    NULL,
    NULL,
    NULL
};


LPTSTR g_pszUSConcurrentKeyPackProductDesc51 [NUMBER_PRODUCTSTRING_RESOURCE] = {
    US_IDS_COMPANYNAME,
    US_IDS_C_PRODUCTNAME,
    US_IDS_C_PRODUCTDESC51
};

LPTSTR g_pszLocalizedConcurrentKeyPackProductDesc51 [NUMBER_PRODUCTSTRING_RESOURCE] = {
    NULL,
    NULL,
    NULL,
};




PMSUPPORTEDPRODUCT g_pszSupportedProduct[] = {
    { TERMSERV_PRODUCTID_CH, TERMSERV_PRODUCTID_SKU},
    { TERMSERV_INTERNET_CH, TERMSERV_INTERNET_SKU},
    { TERMSERV_CONCURRENT_CH, TERMSERV_CONCURRENT_SKU},
    { TERMSERV_WHISTLER_PRODUCTID_CH, TERMSERV_PRODUCTID_SKU}
};
    
DWORD g_dwNumSupportedProduct = sizeof(g_pszSupportedProduct)/sizeof(g_pszSupportedProduct[0]);

DWORD g_dwVersion=CURRENT_TLSA02_VERSION;

////////////////////////////////////////////////////////
LPTSTR
LoadProductDescFromResource(
    IN DWORD dwResId,
    IN DWORD dwMaxSize
    )
/*++

    Internal Routine

--*/
{
    LPTSTR pszString = NULL;

    pszString = (LPTSTR) MALLOC( sizeof(TCHAR) * (dwMaxSize + 1) );
    if(pszString != NULL)
    {
        if(LoadResourceString(dwResId, pszString, dwMaxSize + 1) == FALSE)
        {
            FREE(pszString);
        }
    }


    return pszString;
}

//-----------------------------------------------------
void
FreeProductDescString()
{
    for(int i=0; 
        i < sizeof(g_pszLocalizedFreeKeyPackProductDesc)/sizeof(g_pszLocalizedFreeKeyPackProductDesc[0]);
        i++)
    {
        if(g_pszLocalizedFreeKeyPackProductDesc[i] != NULL)
        {
            FREE(g_pszLocalizedFreeKeyPackProductDesc[i]);
            g_pszLocalizedFreeKeyPackProductDesc[i] = NULL;
        }
    }


    for(i=0; 
        i < sizeof(g_pszLocalizedStandardKeyPackProductString)/sizeof(g_pszLocalizedStandardKeyPackProductString[0]);
        i++)
    {
        if(g_pszLocalizedStandardKeyPackProductString[i] != NULL)
        {
            FREE(g_pszLocalizedStandardKeyPackProductString[i]);
            g_pszLocalizedStandardKeyPackProductString[i] = NULL;
        }
    }

    for(i=0; 
        i < sizeof(g_pszLocalizedInternetKeyPackProductDesc)/sizeof(g_pszLocalizedInternetKeyPackProductDesc[0]);
        i++)
    {
        if(g_pszLocalizedInternetKeyPackProductDesc[i] != NULL)
        {
            FREE(g_pszLocalizedInternetKeyPackProductDesc[i]);
            g_pszLocalizedInternetKeyPackProductDesc[i] = NULL;
        }
    }

    for(i=0; 
        i < sizeof(g_pszLocalizedConcurrentKeyPackProductDesc51)/sizeof(g_pszLocalizedConcurrentKeyPackProductDesc51[0]);
        i++)
    {
        if(g_pszLocalizedConcurrentKeyPackProductDesc51[i] != NULL)
        {
            FREE(g_pszLocalizedConcurrentKeyPackProductDesc51[i]);
            g_pszLocalizedConcurrentKeyPackProductDesc51[i] = NULL;
        }
    }

    return;
}


////////////////////////////////////////////////////////
void
InitPolicyModule(
    IN HMODULE hModule
    )
/*++

    Initialize policy module, ignore error if we can't find localized string, we always
    insert a english product desc.

--*/
{
    BOOL bSuccess = TRUE;
    g_hInstance = hModule;

    //
    // Build IN CAL product desc.
    //
    g_pszLocalizedFreeKeyPackProductDesc[INDEX_COMPANYNAME] = 
        LoadProductDescFromResource(
                                    IDS_COMPANYNAME,
                                    MAX_TERMSRV_PRODUCTID + 1
                                    );

    if(g_pszLocalizedFreeKeyPackProductDesc[INDEX_COMPANYNAME] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }

    g_pszLocalizedFreeKeyPackProductDesc[INDEX_PRODUCTNAME] =
        LoadProductDescFromResource(
                                    IDS_EX_PRODUCTNAME,
                                    MAX_TERMSRV_PRODUCTID + 1
                                    );

    if(g_pszLocalizedFreeKeyPackProductDesc[INDEX_PRODUCTNAME] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }


    g_pszLocalizedFreeKeyPackProductDesc[INDEX_PRODUCTDESC] = 
        LoadProductDescFromResource(
                                    IDS_EX_PRODUCTDESC,
                                    MAX_TERMSRV_PRODUCTID + 1
                                    );

    if(g_pszLocalizedFreeKeyPackProductDesc[INDEX_PRODUCTDESC] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }
    
    //
    // FULL CAL product Desc.
    //
    g_pszLocalizedStandardKeyPackProductString[INDEX_COMPANYNAME] =
        LoadProductDescFromResource(
                                    IDS_COMPANYNAME,
                                    MAX_TERMSRV_PRODUCTID + 1
                                    );

    if(g_pszLocalizedStandardKeyPackProductString[INDEX_COMPANYNAME] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }


    g_pszLocalizedStandardKeyPackProductString[INDEX_PRODUCTNAME] =
        LoadProductDescFromResource(
                                    IDS_S_PRODUCTNAME,
                                    MAX_TERMSRV_PRODUCTID + 1
                                    );

    if(g_pszLocalizedStandardKeyPackProductString[INDEX_PRODUCTNAME] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }

    g_pszLocalizedStandardKeyPackProductString[INDEX_PRODUCTDESC] =
        LoadProductDescFromResource(
                                    IDS_S_PRODUCTDESC,
                                    MAX_TERMSRV_PRODUCTID + 1
                                    );

    if(g_pszLocalizedStandardKeyPackProductString[INDEX_PRODUCTDESC] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }

    //
    // Internet CAL product Desc.
    //
    g_pszLocalizedInternetKeyPackProductDesc[INDEX_COMPANYNAME] =
        LoadProductDescFromResource(
                                    IDS_COMPANYNAME,
                                    MAX_TERMSRV_PRODUCTID + 1
                                    );

    if(g_pszLocalizedInternetKeyPackProductDesc[INDEX_COMPANYNAME] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }

    g_pszLocalizedInternetKeyPackProductDesc[INDEX_PRODUCTNAME] =
        LoadProductDescFromResource(
                                    IDS_I_PRODUCTNAME,
                                    MAX_TERMSRV_PRODUCTID + 1
                                    );

    if(g_pszLocalizedInternetKeyPackProductDesc[INDEX_PRODUCTNAME] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }


    g_pszLocalizedInternetKeyPackProductDesc[INDEX_PRODUCTDESC] =
        LoadProductDescFromResource(
                                    IDS_I_PRODUCTDESC,
                                    MAX_TERMSRV_PRODUCTID + 1
                                    );

    if(g_pszLocalizedInternetKeyPackProductDesc[INDEX_PRODUCTDESC] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }
                                                                           

    //
    // Whistler FULL CAL product Desc.
    //
    g_pszLocalizedStandardKeyPackProductString51[INDEX_COMPANYNAME] = LoadProductDescFromResource(
                                                                IDS_COMPANYNAME,
                                                                MAX_TERMSRV_PRODUCTID + 1
                                                            );

    if(g_pszLocalizedStandardKeyPackProductString51[INDEX_COMPANYNAME] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }


    g_pszLocalizedStandardKeyPackProductString51[INDEX_PRODUCTNAME] = LoadProductDescFromResource(
                                                                IDS_S_PRODUCTNAME,
                                                                MAX_TERMSRV_PRODUCTID + 1
                                                            );

    if(g_pszLocalizedStandardKeyPackProductString51[INDEX_PRODUCTNAME] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }

    g_pszLocalizedStandardKeyPackProductString51[INDEX_PRODUCTDESC] = LoadProductDescFromResource(
                                                                IDS_S_PRODUCTDESC51,
                                                                MAX_TERMSRV_PRODUCTID + 1
                                                            );

    if(g_pszLocalizedStandardKeyPackProductString51[INDEX_PRODUCTDESC] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }
    
                                                                        
    //
    // Whistler Concurrent CAL product Desc.
    //
    g_pszLocalizedConcurrentKeyPackProductDesc51[INDEX_COMPANYNAME] = LoadProductDescFromResource(
                                                                IDS_COMPANYNAME,
                                                                MAX_TERMSRV_PRODUCTID + 1
                                                            );

    if(g_pszLocalizedConcurrentKeyPackProductDesc51[INDEX_COMPANYNAME] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }

    g_pszLocalizedConcurrentKeyPackProductDesc51[INDEX_PRODUCTNAME] = LoadProductDescFromResource(
                                                                IDS_C_PRODUCTNAME,
                                                                MAX_TERMSRV_PRODUCTID + 1
                                                            );

    if(g_pszLocalizedConcurrentKeyPackProductDesc51[INDEX_PRODUCTNAME] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }


    g_pszLocalizedConcurrentKeyPackProductDesc51[INDEX_PRODUCTDESC] = LoadProductDescFromResource(
                                                                IDS_C_PRODUCTDESC51,
                                                                MAX_TERMSRV_PRODUCTID + 1
                                                            );

    if(g_pszLocalizedConcurrentKeyPackProductDesc51[INDEX_PRODUCTDESC] == NULL)
    {
        bSuccess = FALSE;
        goto cleanup;
    }


                                                                        
cleanup:

    if(bSuccess == FALSE)
    {
        FreeProductDescString();
    }
    
    return;
}

////////////////////////////////////////////////////////
BOOL
LoadResourceString(
    IN DWORD dwId,
    IN OUT LPTSTR szBuf,
    IN DWORD dwBufSize
    )
/*++

++*/
{
    int dwRet=0;
    EXCEPTION_RECORD ExceptionCode;

    __try {
        dwRet = LoadString(
                        g_hInstance, 
                        dwId, 
                        szBuf, 
                        dwBufSize
                    );
    }
    __except (
        ExceptionCode = *(GetExceptionInformation())->ExceptionRecord,
        EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ExceptionCode.ExceptionCode);
    }

    return (dwRet != 0);
}

  
////////////////////////////////////////////////////////
DWORD
AddA02KeyPack(
    IN LPCTSTR pszProductCode,
    IN DWORD dwVersion, // NT version
    IN BOOL bFreeOnly   // add free license pack only
    )
/*++

++*/
{
    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 2];
    DWORD dwSize = MAX_COMPUTERNAME_LENGTH+1;
    TCHAR pszProductId[MAX_TERMSRV_PRODUCTID+1];
    TLS_HANDLE tlsHandle=NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwLkpVersion=0;
    LPTSTR* pszDescs;
    LPTSTR* pszLocalizedDescs;

    

    //
    // Connect to license server
    //
    memset(szComputerName, 0, sizeof(szComputerName));    
    if(GetComputerName(szComputerName, &dwSize) == FALSE)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    tlsHandle = TLSConnectToLsServer( szComputerName );
    if(tlsHandle == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    //
    // Windows 2000 resource string
    //
    if(HIWORD(dwVersion) < WINDOWS_VERSION_NT5)
    {
        dwLkpVersion = HIWORD(dwVersion);
    }
    else
    {
        dwLkpVersion = WINDOWS_VERSION_BASE + (HIWORD(dwVersion) - WINDOWS_VERSION_NT5);
    }

    if(_tcsicmp(pszProductCode, TERMSERV_PRODUCTID_SKU) == 0)
    {
        //
        // Add a free keypack
        //
        if (HIWORD(dwVersion) == 5 && LOWORD(dwVersion) == 0)
        {
            _stprintf(
                    pszProductId, 
                    TERMSERV_PRODUCTID_FORMAT,
                    TERMSERV_PRODUCTID_SKU,
                    HIWORD(dwVersion),
                    0,
                    TERMSERV_FREE_TYPE
                );
        
            pszDescs = g_pszUSFreeKeyPackProductDesc;
            pszLocalizedDescs = g_pszLocalizedFreeKeyPackProductDesc;

            dwStatus = InsertLicensePack(
                        tlsHandle,
                        dwVersion,
                        dwLkpVersion,
                        PLATFORMID_FREE, 
                        LSKEYPACKTYPE_FREE,  // local license pack no replication
                        pszProductId,
                        pszProductId,
                        pszDescs,
                        pszLocalizedDescs
                    ); 
        }
        
        

        if(bFreeOnly)
        {
            goto cleanup;
        }

        //
        // Don't add this if enforce licenses.
        //
        #if !defined(ENFORCE_LICENSING) || defined(PRIVATE_DBG)

        //
        // Add a full version keypack, platform type is always 0xFF
        //        

        if (HIWORD(dwVersion) == 5 && LOWORD(dwVersion) == 1)
        {
            _stprintf(
                pszProductId, 
                TERMSERV_PRODUCTID_FORMAT,
                TERMSERV_PRODUCTID_SKU,
                HIWORD(dwVersion),
                0,
                TERMSERV_FULLVERSION_TYPE
            );

            pszDescs = g_pszUSStandardKeyPackProductString51;
            pszLocalizedDescs = g_pszLocalizedStandardKeyPackProductString51;
        }
        else if (HIWORD(dwVersion) == 5 && LOWORD(dwVersion) == 0)
        {
            _stprintf(
                pszProductId, 
                TERMSERV_PRODUCTID_FORMAT,
                TERMSERV_PRODUCTID_SKU,
                HIWORD(dwVersion),
                0,
                TERMSERV_FULLVERSION_TYPE
            );

            pszDescs = g_pszUSStandardKeyPackProductString;
            pszLocalizedDescs = g_pszLocalizedStandardKeyPackProductString;
        }
        else
        {
            dwStatus = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }



        dwStatus = InsertLicensePack(
                        tlsHandle,
                        dwVersion,
                        dwLkpVersion,
                        PLATFORMID_OTHERS,
                        LSKEYPACKTYPE_RETAIL,
                        pszProductId,
                        pszProductId,
                        pszDescs,
                        pszLocalizedDescs
                    );               
        #endif
    }
    else if(_tcsicmp(pszProductCode, TERMSERV_INTERNET_SKU) == 0)
    {
        //
        // Don't add this if enforce licenses.
        //
        #if !defined(ENFORCE_LICENSING) || defined(PRIVATE_DBG)
    
        //
        // Add internet package
        //

        if (HIWORD(dwVersion) == 5 && LOWORD(dwVersion) == 0)
        {
            _stprintf(
                    pszProductId,
                    TERMSERV_PRODUCTID_FORMAT,
                    TERMSERV_INTERNET_SKU,
                    HIWORD(dwVersion),
                    0,
                    TERMSERV_INTERNET_TYPE
                );
        
            pszDescs = g_pszUSInternetKeyPackProductDesc;
            pszLocalizedDescs = g_pszLocalizedInternetKeyPackProductDesc;
        }
        else
        {
            dwStatus = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }


        dwStatus = InsertLicensePack(
                        tlsHandle,
                        dwVersion,
                        dwLkpVersion,
                        PLATFORMID_OTHERS,
                        LSKEYPACKTYPE_RETAIL,
                        pszProductId,
                        pszProductId,
                        pszDescs,
                        pszLocalizedDescs
                    );    
        #endif
    }
    else if(_tcsicmp(pszProductCode, TERMSERV_CONCURRENT_SKU) == 0)
    {
        //
        // Don't add this if enforce licenses.
        //
        #if !defined(ENFORCE_LICENSING) || defined(PRIVATE_DBG)
    
        //
        // Add Concurrent package
        //
        
        if (HIWORD(dwVersion) == 5 && LOWORD(dwVersion) == 1)
        {
            _stprintf(
                    pszProductId,
                    TERMSERV_PRODUCTID_FORMAT,
                    TERMSERV_CONCURRENT_SKU,
                    HIWORD(dwVersion),
                    0,
                    TERMSERV_CONCURRENT_TYPE
                );
        
            pszDescs = g_pszUSConcurrentKeyPackProductDesc51;
            pszLocalizedDescs = g_pszLocalizedConcurrentKeyPackProductDesc51;
        }       
        else
        {
            dwStatus = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }

        dwStatus = InsertLicensePack(
                        tlsHandle,
                        dwVersion,
                        dwLkpVersion,
                        PLATFORMID_OTHERS,
                        LSKEYPACKTYPE_RETAIL,
                        pszProductId,
                        pszProductId,
                        pszDescs,
                        pszLocalizedDescs
                    );    
        #endif
    }

cleanup:

    if(tlsHandle != NULL)
    {
        TLSDisconnectFromServer(tlsHandle);
    }    

    return dwStatus;
}

////////////////////////////////////////////////////////
DWORD
InsertLicensePack(
    IN TLS_HANDLE tlsHandle,
    IN DWORD dwProdVersion,
    IN DWORD dwDescVersion,
    IN DWORD dwPlatformType,
    IN UCHAR ucAgreementType,
    IN LPTSTR pszProductId,
    IN LPTSTR pszKeyPackId,
    IN LPTSTR pszUsDesc[],
    IN LPTSTR pszLocalizedDesc[]
    )
/*++

pdwResourceId

    US Company Name
    US Product Name
    US Product Desc
    Localize Company Name
    Localize Product Name
    Localize Product Desc

++*/
{
    RPC_STATUS rpcStatus;
    BOOL bSuccess;
    DWORD dwStatus = ERROR_SUCCESS;
    TCHAR buffer[LSERVER_MAX_STRING_SIZE];
    struct tm expired_tm;
    LSKeyPack keypack;

    if(pszProductId == NULL || pszKeyPackId == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto cleanup;
    }
   
    memset(&keypack, 0, sizeof(keypack));
    keypack.ucKeyPackType = ucAgreementType;

    SAFESTRCPY(keypack.szKeyPackId, pszKeyPackId);
    SAFESTRCPY(keypack.szProductId, pszProductId);

    SAFESTRCPY(keypack.szCompanyName, pszUsDesc[INDEX_COMPANYNAME]);

    SAFESTRCPY(keypack.szProductName, pszUsDesc[INDEX_PRODUCTNAME]);
    SAFESTRCPY(keypack.szProductDesc, pszUsDesc[INDEX_PRODUCTDESC]);


    keypack.wMajorVersion = HIWORD(dwProdVersion);
    keypack.wMinorVersion = LOWORD(dwProdVersion);
    keypack.dwPlatformType = dwPlatformType;

    keypack.ucLicenseType = LSKEYPACKLICENSETYPE_NEW;
    keypack.dwLanguageId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
    keypack.ucChannelOfPurchase = LSKEYPACKCHANNELOFPURCHASE_RETAIL;
    SAFESTRCPY(
            keypack.szBeginSerialNumber, 
            _TEXT("0000001")
        );

    keypack.dwTotalLicenseInKeyPack = (ucAgreementType == LSKEYPACKTYPE_FREE) ? INT_MAX : 0;
    keypack.dwProductFlags = 0x00;

    keypack.ucKeyPackStatus = LSKEYPACKSTATUS_ACTIVE;
    keypack.dwActivateDate = (DWORD) time(NULL);

    memset(&expired_tm, 0, sizeof(expired_tm));
    expired_tm.tm_year = 2036 - 1900;     // expire on 2036/1/1
    expired_tm.tm_mday = 1;
    keypack.dwExpirationDate = mktime(&expired_tm);

    rpcStatus = TLSKeyPackAdd(
                        tlsHandle, 
                        &keypack, 
                        &dwStatus
                    );

    if(rpcStatus != RPC_S_OK)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if(GetSystemDefaultLangID() != keypack.dwLanguageId)
    {
        if( pszLocalizedDesc[INDEX_COMPANYNAME] != NULL &&
            pszLocalizedDesc[INDEX_PRODUCTNAME] != NULL &&
            pszLocalizedDesc[INDEX_PRODUCTDESC] != NULL
          )
        {
            //  
            // Insert localize license pack description
            //
            keypack.dwLanguageId = GetSystemDefaultLangID();

            SAFESTRCPY(keypack.szCompanyName, pszLocalizedDesc[INDEX_COMPANYNAME]);            
            SAFESTRCPY(keypack.szProductName, pszLocalizedDesc[INDEX_PRODUCTNAME]);
            SAFESTRCPY(keypack.szProductDesc, pszLocalizedDesc[INDEX_PRODUCTDESC]);


            keypack.ucKeyPackStatus = LSKEYPACKSTATUS_ADD_DESC;

            rpcStatus = TLSKeyPackAdd(
                                tlsHandle, 
                                &keypack, 
                                &dwStatus
                            );

            if(rpcStatus != RPC_S_OK)
            {
                dwStatus = GetLastError();
                goto cleanup;
            }

            if(dwStatus != ERROR_SUCCESS)
            {
                goto cleanup;
            }
        }
    }

    //
    // Activate keypack
    //
    keypack.ucKeyPackStatus = LSKEYPACKSTATUS_ACTIVE; 
    keypack.dwActivateDate = (DWORD) time(NULL);

    memset(&expired_tm, 0, sizeof(expired_tm));
    expired_tm.tm_year = 2036 - 1900;     // expire on 2036/1/1
    expired_tm.tm_mday = 1;
    keypack.dwExpirationDate = mktime(&expired_tm);

    rpcStatus = TLSKeyPackSetStatus(
                        tlsHandle,
                        LSKEYPACK_SET_KEYPACKSTATUS | LSKEYPACK_SET_ACTIVATEDATE | LSKEYPACK_SET_EXPIREDATE, 
                        &keypack,
                        &dwStatus
                    );

    if(rpcStatus != RPC_S_OK)
    {
        dwStatus = GetLastError();
    }
    
cleanup:

    return dwStatus;
}

////////////////////////////////////////////////////////

BOOL
LicenseTypeFromLookupTable(
    IN DWORD dwClientVer,
	IN DWORD dwTermSrvVer,
    OUT PDWORD pdwCALType
    )
{
	if (dwClientVer < NUMBER_OF_CLIENT_OS && dwTermSrvVer < NUMBER_OF_TERMSRV_OS)
	{
		*pdwCALType = LicenseTable[dwClientVer][dwTermSrvVer];
		return TRUE;
	}
	else
	{
		return FALSE;
	}    
}


////////////////////////////////////////////////////////
POLICYSTATUS
AdjustNewLicenseRequest(
    IN CClient* pClient,
    IN PPMLICENSEREQUEST pRequest,
    IN OUT PPMLICENSEREQUEST* pAdjustedRequest,
    IN UCHAR ucMarkedTemp,
    OUT PDWORD pdwErrCode
    )
/*++

Abstract:

    AdjustNewLicenseRequest fine tune license request for product 236

Parameter:

    pClient - Pointer to CClient object.
    pRequest - Original request from TermSrv.
    pAdjustedRequest - 'Fine tuned' license request.
    ucMarkedTemp - Flags on the temporary license passed in (if any)
    pdwErrCode - error code

Return:

    ERROR_SUCCESS or error code.

++*/
{
    POLICYSTATUS dwStatus = POLICY_SUCCESS;
    DWORD dwTermSrvOSId;
    DWORD dwTermSrvProductVersion;
    LPTSTR pszProductType=NULL;
    TCHAR  pszProductId[MAX_TERMSRV_PRODUCTID+1];
    BOOL bTryInsert=FALSE;
    DWORD dwClientOSId;	
    DWORD dwLicType;
    DWORD dwTermSrvIndex = 0;
    DWORD dwClientIndex = 0;

    //
    // Allocate memory for adjusted product ID
    //
    *pAdjustedRequest = (PPMLICENSEREQUEST) pClient->AllocateMemory(
                                    MEMORY_LICENSE_REQUEST,
                                    sizeof(PMLICENSEREQUEST)
                                );
    if(*pAdjustedRequest == NULL)
    {
        dwStatus = POLICY_CRITICAL_ERROR;
        SetLastError( *pdwErrCode = ERROR_OUTOFMEMORY );
        goto cleanup;
    }
   
    //
    // Fields we don't modify
    // 
    (*pAdjustedRequest)->dwProductVersion = pRequest->dwProductVersion;
    (*pAdjustedRequest)->pszCompanyName = pRequest->pszCompanyName;
    (*pAdjustedRequest)->dwLanguageId = pRequest->dwLanguageId;
    (*pAdjustedRequest)->pszMachineName = pRequest->pszMachineName;
    (*pAdjustedRequest)->pszUserName = pRequest->pszUserName;
    (*pAdjustedRequest)->dwSupportFlags = pRequest->dwSupportFlags;

    //
    // request platform ID is the OS ID
    //

    //
    // TermServ exists from NT40 so termsrv OS ID start 2, 
    // see platform.h
    //
    dwTermSrvOSId = HIWORD(pRequest->dwProductVersion) - 2; 

    if((HIWORD(pRequest->dwProductVersion) == 5) && (LOWORD(pRequest->dwProductVersion) == 0))
    {
	    dwTermSrvIndex = TERMSRV_OS_INDEX_WINNT_5_0;
    }
    else if((HIWORD(pRequest->dwProductVersion) == 5) && (LOWORD(pRequest->dwProductVersion) == 1))
    {
	    dwTermSrvIndex = TERMSRV_OS_INDEX_WINNT_5_1;
    }
    else if((HIWORD(pRequest->dwProductVersion) > 5) || ((HIWORD(pRequest->dwProductVersion) == 5) && (LOWORD(pRequest->dwProductVersion) > 1)))
    {
	    dwTermSrvIndex = TERMSRV_OS_INDEX_WINNT_POST_5_1;
    }
    else
    {
        dwStatus = POLICY_CRITICAL_ERROR;
    }

    dwClientOSId = GetOSId(pRequest->dwPlatformId);	
		

    (*pAdjustedRequest)->fTemporary = FALSE;

    if(_tcsicmp(pRequest->pszProductId, TERMSERV_PRODUCTID_SKU) == 0)
    {

        switch(GetOSId(pRequest->dwPlatformId))
        {
            case CLIENT_OS_ID_WINNT_351:                    
            case CLIENT_OS_ID_WINNT_40:
            case CLIENT_OS_ID_OTHER:                
	            dwClientIndex = CLIENT_OS_INDEX_OTHER;                    
                break;

            case CLIENT_OS_ID_WINNT_50:					
            {
                if((GetImageRevision(pRequest->dwPlatformId)) == 0)
                {
	                dwClientIndex = CLIENT_OS_INDEX_WINNT_50;
                }
                else if((GetImageRevision(pRequest->dwPlatformId)) == CLIENT_OS_ID_MINOR_WINNT_51)
                {
	                dwClientIndex = CLIENT_OS_INDEX_WINNT_51;
                }
                else
                {
                    dwClientIndex = CLIENT_OS_INDEX_WINNT_POST_51;
                }
            }
                break;  

            case CLIENT_OS_ID_WINNT_POST_51:                    
                dwClientIndex = CLIENT_OS_INDEX_WINNT_POST_51;
                break;

            default:  
                dwStatus = POLICY_CRITICAL_ERROR;
                break;
        }

        pszProductType = TERMSERV_FULLVERSION_TYPE;

        (*pAdjustedRequest)->dwPlatformId = PLATFORMID_OTHERS;

        dwTermSrvProductVersion = pRequest->dwProductVersion;

        if(LicenseTypeFromLookupTable(dwClientIndex, dwTermSrvIndex, &dwLicType))
        {	        			
	        if(dwLicType == ALLOW_BUILTIN)
	        {
		        pszProductType = TERMSERV_FREE_TYPE;
		        (*pAdjustedRequest)->dwPlatformId = PLATFORMID_FREE;
		        //
		        // Add license pack if necessary
		        //

		        if(HIWORD(pRequest->dwProductVersion) != CURRENT_TLSA02_VERSION)
		        {                  
			        AddA02KeyPack( TERMSERV_PRODUCTID_SKU, pRequest->dwProductVersion, TRUE );
		        }
	        }
        }        
        if ((*pAdjustedRequest)->dwPlatformId != PLATFORMID_FREE)
        {        	    
	        if (pRequest->dwSupportFlags & SUPPORT_PER_SEAT_POST_LOGON)
	        {
		        // We're doing the Per-Seat Post-Logon fix for DoS

		        if (!(ucMarkedTemp & MARK_FLAG_USER_AUTHENTICATED))
		        {
			        // No previous temporary, or temporary wasn't marked
			        // as authenticated

			        (*pAdjustedRequest)->fTemporary = TRUE;
		        }
	        }
        }        	
    }
    else
    {
        if (_tcsicmp(pRequest->pszProductId, TERMSERV_CONCURRENT_SKU) == 0)
        {
            pszProductType = TERMSERV_CONCURRENT_TYPE;
        }
        else if (_tcsicmp(pRequest->pszProductId, TERMSERV_INTERNET_SKU) == 0)
        {
            pszProductType = TERMSERV_INTERNET_TYPE;
        }
        else
        {
            dwStatus = POLICY_CRITICAL_ERROR;
            SetLastError( *pdwErrCode = ERROR_INVALID_PARAMETER );
            goto cleanup;
        }

        dwTermSrvProductVersion = pRequest->dwProductVersion;
        
        (*pAdjustedRequest)->dwPlatformId = PLATFORMID_OTHERS;
    }

    _sntprintf(pszProductId,
               MAX_TERMSRV_PRODUCTID,
               TERMSERV_PRODUCTID_FORMAT,
               pRequest->pszProductId,
               HIWORD(dwTermSrvProductVersion),
               LOWORD(dwTermSrvProductVersion),
               pszProductType);

    //
    // allocate memory for product Id
    //
    (*pAdjustedRequest)->pszProductId = (LPTSTR)pClient->AllocateMemory(
                                                        MEMORY_STRING,
                                                        (_tcslen(pszProductId) + 1) * sizeof(TCHAR)
                                                    );

    if((*pAdjustedRequest)->pszProductId == NULL)
    {
        dwStatus = POLICY_CRITICAL_ERROR;
        SetLastError( *pdwErrCode = ERROR_OUTOFMEMORY );
        goto cleanup;
    }

    _tcscpy(
            (*pAdjustedRequest)->pszProductId,
            pszProductId
        );

cleanup:

    return dwStatus;
}    

////////////////////////////////////////////////////////

POLICYSTATUS
ProcessLicenseRequest(
    PMHANDLE client,
    PPMLICENSEREQUEST pbRequest,
    PPMLICENSEREQUEST* pbAdjustedRequest,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    CClient* pClient;
    POLICYSTATUS dwStatus = POLICY_SUCCESS;

    //
    // find client's object, client handle manager will
    // create a new one.
    pClient = g_ClientMgr->FindClient((PMHANDLE)client);

    if(pClient == NULL)
    {
        dwStatus = POLICY_CRITICAL_ERROR;
        *pdwErrCode = TLSA02_E_INTERNALERROR;
        goto cleanup;
    }

    //
    // AdjustNewLicenseRequest
    //
    dwStatus = AdjustNewLicenseRequest(
                            pClient,
                            pbRequest,
                            pbAdjustedRequest,
                            NULL,       // no previous license
                            pdwErrCode
                        );

cleanup:

    return dwStatus;
}


//--------------------------------------------------------------

POLICYSTATUS
ProcessAllocateRequest(
    PMHANDLE client,
    DWORD dwSuggestType,
    PDWORD pdwKeyPackType,
    PDWORD pdwErrCode
    )    
/*++

    Default sequence is always FREE/RETAIL/OPEN/SELECT/TEMPORARY

++*/
{
    switch(dwSuggestType)
    {
        case LSKEYPACKTYPE_UNKNOWN:
            *pdwKeyPackType = LSKEYPACKTYPE_FREE;
            break;

        case LSKEYPACKTYPE_FREE:
            *pdwKeyPackType = LSKEYPACKTYPE_RETAIL;
            break;

        case LSKEYPACKTYPE_RETAIL:
            *pdwKeyPackType = LSKEYPACKTYPE_OPEN;
            break;

        case LSKEYPACKTYPE_OPEN:
            *pdwKeyPackType = LSKEYPACKTYPE_SELECT;
            break;

        case LSKEYPACKTYPE_SELECT:
            //
            // FALL THRU
            //
        default:
            //
            // No more keypack to look for, instruct license
            // server to terminate.
            //
            *pdwKeyPackType = LSKEYPACKTYPE_UNKNOWN;
            break;
    }        

    *pdwErrCode = ERROR_SUCCESS;
    return POLICY_SUCCESS;
}

//-------------------------------------------------------------
POLICYSTATUS WINAPI
ProcessKeyPackDesc(
    IN PMHANDLE client,
    IN PPMKEYPACKDESCREQ pDescReq,
    IN OUT PPMKEYPACKDESC* pDesc,
    IN OUT PDWORD pdwErrCode
    )
/*++

++*/
{
    CClient* pClient;
    POLICYSTATUS dwStatus=POLICY_SUCCESS;

    DWORD usLangId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
    BOOL bSuccess;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwDescVersion;

    TCHAR szPreFix[MAX_SKU_PREFIX];
    TCHAR szPostFix[MAX_SKU_POSTFIX];
    TCHAR szDesc[MAX_TERMSRV_PRODUCTID+1];

    DWORD i;

    LPTSTR* pszKeyPackDesc;
    LPTSTR* pszUSKeyPackDesc;


    if(pDescReq == NULL || pDesc == NULL)
    {
        dwStatus = POLICY_ERROR;
        *pdwErrCode = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // find client's object, client handle manager will
    // create a new one.
    pClient = g_ClientMgr->FindClient((PMHANDLE)client);

    if(pClient == NULL)
    {
        dwStatus = POLICY_CRITICAL_ERROR;
        *pdwErrCode = TLSA02_E_INTERNALERROR;
        goto cleanup;
    }

    for (i = 0; i < g_dwNumSupportedProduct; i++)
    {
        if(_tcsnicmp(
               pDescReq->pszProductId, 
               g_pszSupportedProduct[i].szTLSProductCode, 
               _tcslen(g_pszSupportedProduct[i].szTLSProductCode)) == 0)
        {
            break;
        }

    }

    if (i >= g_dwNumSupportedProduct)
    {
        //
        // This is not ours
        //
        dwStatus = POLICY_ERROR;
        SetLastError(*pdwErrCode = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    _stscanf(
            pDescReq->pszProductId,
            TERMSERV_PRODUCTID_FORMAT,
            szPreFix,
            &dwMajorVersion,
            &dwMinorVersion,
            szPostFix
        );

    if(dwMajorVersion < WINDOWS_VERSION_NT5)
    {
        dwDescVersion = dwMajorVersion;
    }
    else
    {
        dwDescVersion = WINDOWS_VERSION_BASE + dwMajorVersion - WINDOWS_VERSION_NT5;
    }

    //
    // Detemine which resource string we should load,
    // string dependency on resource ID.
    //
    if(_tcsicmp(szPreFix, TERMSERV_PRODUCTID_SKU) == 0)
    {
        if(_tcsicmp(szPostFix, TERMSERV_FULLVERSION_TYPE) == 0)
        {
            if (dwMajorVersion == 5 && dwMinorVersion == 1)
            {
                pszKeyPackDesc = g_pszLocalizedStandardKeyPackProductString51;
                pszUSKeyPackDesc = g_pszUSStandardKeyPackProductString51;
            }
            else if (dwMajorVersion == 5 && dwMinorVersion == 0)
            {
                pszKeyPackDesc = g_pszLocalizedStandardKeyPackProductString;
                pszUSKeyPackDesc = g_pszUSStandardKeyPackProductString;
            }
            else
            {
                dwStatus = POLICY_ERROR;
                SetLastError(*pdwErrCode = ERROR_INVALID_PARAMETER);
                goto cleanup;
            }


            if( pDescReq->dwLangId == usLangId ||
                pszKeyPackDesc[INDEX_COMPANYNAME] == NULL ||
                pszKeyPackDesc[INDEX_PRODUCTNAME] == NULL ||
                pszKeyPackDesc[INDEX_PRODUCTDESC] == NULL )
            {
                //
                // resource not found, use english desc.
                pszKeyPackDesc = pszUSKeyPackDesc;

            }
        }
        else if(_tcsicmp(szPostFix, TERMSERV_FREE_TYPE) == 0)
        {
            if (dwMajorVersion == 5 && dwMinorVersion == 0)
            {
                pszKeyPackDesc = g_pszLocalizedFreeKeyPackProductDesc;
                pszUSKeyPackDesc = g_pszUSFreeKeyPackProductDesc;
            }
            else
            {
                dwStatus = POLICY_ERROR;
                SetLastError(*pdwErrCode = ERROR_INVALID_PARAMETER);
                goto cleanup;
            }


            if( pDescReq->dwLangId == usLangId ||
                pszKeyPackDesc[INDEX_COMPANYNAME] == NULL ||
                pszKeyPackDesc[INDEX_PRODUCTNAME] == NULL ||
                pszKeyPackDesc[INDEX_PRODUCTDESC] == NULL )
            {
                //
                // resource not found, use english desc.
                pszKeyPackDesc = pszUSKeyPackDesc;
            }
        }
        else
        {
            //
            // Something wrong, this is not ours
            //
            SetLastError(*pdwErrCode = ERROR_INVALID_PARAMETER);
            dwStatus = POLICY_ERROR;
            goto cleanup;
        }
    }
    else if(_tcsicmp(szPreFix, TERMSERV_INTERNET_SKU) == 0 && _tcsicmp(szPostFix, TERMSERV_INTERNET_TYPE) == 0)
    {
        if (dwMajorVersion == 5 && dwMinorVersion == 0)
        {
            pszKeyPackDesc = g_pszLocalizedInternetKeyPackProductDesc;
            pszUSKeyPackDesc = g_pszUSInternetKeyPackProductDesc;
        }
        else
        {
            dwStatus = POLICY_ERROR;
            SetLastError(*pdwErrCode = ERROR_INVALID_PARAMETER);
            goto cleanup;
        }


        if( pDescReq->dwLangId == usLangId ||
            pszKeyPackDesc[INDEX_COMPANYNAME] == NULL ||
            pszKeyPackDesc[INDEX_PRODUCTNAME] == NULL ||
            pszKeyPackDesc[INDEX_PRODUCTDESC] == NULL )
        {
            //
            // resource not found, use english desc.
            pszKeyPackDesc = pszUSKeyPackDesc;
        }
    }        
    else if(_tcsicmp(szPreFix, TERMSERV_CONCURRENT_SKU) == 0 && _tcsicmp(szPostFix, TERMSERV_CONCURRENT_TYPE) == 0)
    {
        if (dwMajorVersion == 5 && dwMinorVersion == 1)
        {
            pszKeyPackDesc = g_pszLocalizedConcurrentKeyPackProductDesc51;
            pszUSKeyPackDesc = g_pszUSConcurrentKeyPackProductDesc51;
        }
        else
        {
            dwStatus = POLICY_ERROR;
            SetLastError(*pdwErrCode = ERROR_INVALID_PARAMETER);
            goto cleanup;
        }

        if( pDescReq->dwLangId == usLangId ||
            pszKeyPackDesc[INDEX_COMPANYNAME] == NULL ||
            pszKeyPackDesc[INDEX_PRODUCTNAME] == NULL ||
            pszKeyPackDesc[INDEX_PRODUCTDESC] == NULL )
        {
            //
            // resource not found, use english desc.
            pszKeyPackDesc = g_pszUSConcurrentKeyPackProductDesc51;
        }
    }        
    else
    {
        //
        // Something wrong, this is not ours
        //
        SetLastError(*pdwErrCode = ERROR_INVALID_PARAMETER);
        dwStatus = POLICY_ERROR;
        goto cleanup;
    }    
    
    *pDesc = (PPMKEYPACKDESC)pClient->AllocateMemory(
                                        MEMORY_KEYPACKDESC,
                                        sizeof(PMKEYPACKDESC)
                                    );

    if(*pDesc == NULL)
    {
        SetLastError(*pdwErrCode = ERROR_OUTOFMEMORY);
        dwStatus = POLICY_CRITICAL_ERROR;
        goto cleanup;
    }

    SAFESTRCPY((*pDesc)->szCompanyName, pszKeyPackDesc[INDEX_COMPANYNAME]);                    
    SAFESTRCPY((*pDesc)->szProductName, pszKeyPackDesc[INDEX_PRODUCTNAME]);
    SAFESTRCPY((*pDesc)->szProductDesc, pszKeyPackDesc[INDEX_PRODUCTDESC]);


cleanup:

    if(dwStatus != POLICY_SUCCESS)
    {
        *pDesc = NULL;
    }

    return dwStatus;
}

//-------------------------------------------------------------
POLICYSTATUS
ProcessGenLicenses(
    PMHANDLE client,
    PPMGENERATELICENSE pGenLicense,
    PPMCERTEXTENSION *pCertExtension,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    // No policy extension to return.
    *pCertExtension = NULL;
    *pdwErrCode = ERROR_SUCCESS;
    return POLICY_SUCCESS;
}

//--------------------------------------------------------------

POLICYSTATUS
ProcessComplete(
    PMHANDLE client,
    DWORD dwErrCode,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    //
    // We don't store any data so ignore 
    // error code from license server
    //
    UNREFERENCED_PARAMETER(dwErrCode);

    //
    // Free memory allocated for the client
    //
    g_ClientMgr->DestroyClient( client );
    *pdwErrCode = ERROR_SUCCESS;
    return POLICY_SUCCESS;
}

//--------------------------------------------------------------

POLICYSTATUS WINAPI
PMLicenseRequest(
    PMHANDLE client,
    DWORD dwProgressCode, 
    PVOID pbProgressData, 
    PVOID* pbNewProgressData,
    PDWORD pdwErrCode
    )
/*++


++*/
{
    POLICYSTATUS dwStatus = POLICY_SUCCESS;

    switch( dwProgressCode )
    {
        case REQUEST_NEW:
            //
            // License Server ask to fine tune the request.
            //
            dwStatus = ProcessLicenseRequest(
                                    client,
                                    (PPMLICENSEREQUEST) pbProgressData,
                                    (PPMLICENSEREQUEST *) pbNewProgressData,
                                    pdwErrCode
                                );
            break;

        case REQUEST_KEYPACKTYPE:
            //
            // License Server ask for the license pack type
            //
            dwStatus = ProcessAllocateRequest(
                                    client,
                                #ifdef _WIN64
                                    PtrToUlong(pbProgressData),
                                #else
                                    (DWORD) pbProgressData,
                                #endif
                                    (PDWORD) pbNewProgressData,
                                    pdwErrCode
                                );
            break;

        case REQUEST_TEMPORARY:
            //
            // License Server ask if temporary license should be issued
            //
            *(BOOL *)pbNewProgressData = TRUE;
            *pdwErrCode = ERROR_SUCCESS;
            break;

        case REQUEST_KEYPACKDESC:
            //
            // License Server is requesting a keypack description.
            //
            dwStatus = ProcessKeyPackDesc(
                                    client,
                                    (PPMKEYPACKDESCREQ) pbProgressData,
                                    (PPMKEYPACKDESC *) pbNewProgressData,
                                    pdwErrCode
                                );
            break;
            
        case REQUEST_GENLICENSE:
            //
            // License Server ask for certificate extension
            //
            dwStatus = ProcessGenLicenses(
                                    client,
                                    (PPMGENERATELICENSE) pbProgressData,
                                    (PPMCERTEXTENSION *) pbNewProgressData,
                                    pdwErrCode
                                );

            break;

        case REQUEST_COMPLETE:
            //
            // Request complete
            //
            dwStatus = ProcessComplete(
                                    client,
                                #ifdef _WIN64
                                    PtrToUlong(pbNewProgressData),
                                #else
                                    (DWORD) pbNewProgressData,
                                #endif
                                    pdwErrCode
                                );
            break;

        default:
            //
            // This tell License Server to use default value
            //
            *pbNewProgressData = NULL;
            dwStatus = POLICY_ERROR;
            *pdwErrCode = ERROR_INVALID_PARAMETER;
    }

    return dwStatus;
}

//------------------------------------------------------------
typedef enum {
    UPGRADELICENSE_ERROR=0,
    UPGRADELICENSE_INVALID_LICENSE,
    UPGRADELICENSE_NEWLICENSE,
    UPGRADELICENSE_UPGRADE,
    UPGRADELICENSE_ALREADYHAVE
} UPGRADELICENSE_STATUS;

////////////////////////////////////////////////////////
UPGRADELICENSE_STATUS
RequireUpgradeType(
    PPMUPGRADEREQUEST pUpgrade
    )
/*++


++*/
{
    UPGRADELICENSE_STATUS dwRetCode = UPGRADELICENSE_UPGRADE;
    DWORD index;
    DWORD dwClientOSId;
    DWORD dwTermSrvOSId;
    DWORD dwClientMinorOSId;

    //
    // Verify input parameters
    //
    if(pUpgrade == NULL || pUpgrade->dwNumProduct == 0 || pUpgrade->pProduct == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        dwRetCode = UPGRADELICENSE_ERROR;
        goto cleanup;
    }

    //
    // Make sure we only upgrade to same product
    //
    if(_tcsnicmp(pUpgrade->pUpgradeRequest->pszProductId, TERMSERV_PRODUCTID_SKU, _tcslen(TERMSERV_PRODUCTID_SKU)) != 0)
    {
        dwRetCode = UPGRADELICENSE_ERROR;
        goto cleanup;
    }

    //
    // simple licensed product verification, 
    // licensed product is in decending order
    //
    for(index=0; index < pUpgrade->dwNumProduct-1; index++)
    {
        if( pUpgrade->pProduct[index].bTemporary == FALSE &&
            pUpgrade->pProduct[index+1].bTemporary == TRUE )
        {
            dwRetCode = UPGRADELICENSE_INVALID_LICENSE;
            break;
        }
    }

    if(dwRetCode == UPGRADELICENSE_INVALID_LICENSE)
    {
        goto cleanup;
    }

    //
    // Skip licensed product that has later version
    //
    for(index=0; index < pUpgrade->dwNumProduct; index ++)
    {
        //
        // If Licensed product version is older than request

        if(CompareTLSVersions(pUpgrade->pProduct[index].LicensedProduct.dwProductVersion, pUpgrade->pUpgradeRequest->dwProductVersion) < 0)
        {
            
            break;
        }
      
        if( (CompareTLSVersions(pUpgrade->pProduct[index].LicensedProduct.dwProductVersion, pUpgrade->pUpgradeRequest->dwProductVersion) == 0) &&
	        (pUpgrade->pProduct[index].bTemporary))
        {            

	        // we want to break out of loop in the case where we have same version as request but is a temporary license         

            break;
        }

        if ((CompareTLSVersions(pUpgrade->pProduct[index].LicensedProduct.dwProductVersion,
                pUpgrade->pUpgradeRequest->dwProductVersion) >= 0) &&
            (!(pUpgrade->pProduct[index].bTemporary)))
        {
            // we already have a license.
            dwRetCode = UPGRADELICENSE_ALREADYHAVE;
            break;
        }

    }

    //
    // Win98 client connect to TS 5 to get a Full CAL, then upgrade to NT5, instruct 
    // license server to issue a Free CAL.
    //
    
    dwTermSrvOSId = HIWORD(pUpgrade->pUpgradeRequest->dwProductVersion) - 2;
    dwClientOSId = GetOSId(pUpgrade->pUpgradeRequest->dwPlatformId);	
    dwClientMinorOSId = GetImageRevision(pUpgrade->pUpgradeRequest->dwPlatformId);

    if(dwRetCode == UPGRADELICENSE_ALREADYHAVE)
    {
        //
        // do nothing.
    }
    else if(index >= pUpgrade->dwNumProduct || pUpgrade->pProduct[index].bTemporary == TRUE)
    {
        // all license is temp, ask for new license.
        dwRetCode = UPGRADELICENSE_NEWLICENSE;
    }
    else
    {
        // prev. licensed product is perm, ask for upgrade license
        // ClientOSId: HIBYTE(HIWORD) contains Major version and LOBYTE(LOWORD) contains Minor version
        // TermsrvOSId: LOBYTE(HIWORD) contains Major version and LOBYTE(LOWORD) contains Minor version

        if((HIBYTE(HIWORD(dwClientOSId)) == LOBYTE(HIWORD(dwTermSrvOSId)) ? LOBYTE(LOWORD(dwClientMinorOSId)) - LOBYTE(LOWORD(dwTermSrvOSId)) : \
            HIBYTE(HIWORD(dwClientOSId)) - LOBYTE(HIWORD(dwTermSrvOSId))) >= 0)

        { 
            dwRetCode = UPGRADELICENSE_NEWLICENSE;
        }
        else
        {
            dwRetCode = UPGRADELICENSE_UPGRADE;
        }
    }
    
cleanup:

    return dwRetCode;
}

////////////////////////////////////////////////////////
POLICYSTATUS
AdjustUpgradeLicenseRequest(
    IN CClient* pClient,
    IN PPMUPGRADEREQUEST pUpgradeRequest,
    IN PPMLICENSEREQUEST* pAdjustedRequest,
    OUT PDWORD pdwErrCode
    )
/*++


++*/
{
    POLICYSTATUS dwStatus = POLICY_SUCCESS;
    PPMLICENSEREQUEST pRequest;
    TCHAR  pszProductId[MAX_TERMSRV_PRODUCTID+1];

    if(pUpgradeRequest == NULL || pUpgradeRequest->pUpgradeRequest == NULL)
    {
        SetLastError(*pdwErrCode = ERROR_INVALID_PARAMETER);
        dwStatus = POLICY_ERROR;
        goto cleanup;
    }

    *pAdjustedRequest = (PPMLICENSEREQUEST) pClient->AllocateMemory(
                                                    MEMORY_LICENSE_REQUEST,
                                                    sizeof(PMLICENSEREQUEST)
                                                    );
    if(*pAdjustedRequest == NULL)
    {
        SetLastError(*pdwErrCode = ERROR_OUTOFMEMORY);
        dwStatus = POLICY_CRITICAL_ERROR;
        goto cleanup;
    }

    pRequest = pUpgradeRequest->pUpgradeRequest;

    //
    // Fields we don't modify
    // 
    (*pAdjustedRequest)->dwProductVersion = pRequest->dwProductVersion;
    (*pAdjustedRequest)->pszCompanyName = pRequest->pszCompanyName;
    (*pAdjustedRequest)->dwLanguageId = pRequest->dwLanguageId;
    (*pAdjustedRequest)->pszMachineName = pRequest->pszMachineName;
    (*pAdjustedRequest)->pszUserName = pRequest->pszUserName;
    (*pAdjustedRequest)->dwSupportFlags = pRequest->dwSupportFlags;

    //
    // Change Request platform ID for upgrade
    //
    (*pAdjustedRequest)->dwPlatformId = PLATFORMID_OTHERS;

    if (pRequest->dwSupportFlags & SUPPORT_PER_SEAT_POST_LOGON)
    {
        // We're doing the Per-Seat Post-Logon fix for DoS

        (*pAdjustedRequest)->fTemporary = TRUE;
    }

    _sntprintf(
            pszProductId,
            MAX_TERMSRV_PRODUCTID,
            TERMSERV_PRODUCTID_FORMAT,
            TERMSERV_PRODUCTID_SKU,
            HIWORD(pRequest->dwProductVersion),
            LOWORD(pRequest->dwProductVersion),
            TERMSERV_FULLVERSION_TYPE //PLATFORMID_OTHERS
        );

    //
    // allocate memory for product Id
    //
    (*pAdjustedRequest)->pszProductId = (LPTSTR)pClient->AllocateMemory(
                                                        MEMORY_STRING,
                                                        (_tcslen(pszProductId) + 1) * sizeof(TCHAR)
                                                    );

    if((*pAdjustedRequest)->pszProductId == NULL)
    {
        SetLastError( *pdwErrCode = ERROR_OUTOFMEMORY );
        dwStatus = POLICY_CRITICAL_ERROR;
        goto cleanup;
    }

    _tcscpy(
            (*pAdjustedRequest)->pszProductId,
            pszProductId
        );

cleanup:

    return dwStatus;
}


////////////////////////////////////////////////////////
POLICYSTATUS
ProcessUpgradeRequest(
    PMHANDLE hClient,
    PPMUPGRADEREQUEST pUpgrade,
    PPMLICENSEREQUEST* pbAdjustedRequest,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    POLICYSTATUS dwStatus = POLICY_SUCCESS;
    CClient* pClient;
    UPGRADELICENSE_STATUS upgradeStatus;

    //
    // find client's object, client handle manager will
    // create a new one.
    pClient = g_ClientMgr->FindClient(hClient);
    if(pClient == NULL)
    {
        *pdwErrCode = TLSA02_E_INTERNALERROR;
        dwStatus = POLICY_CRITICAL_ERROR;
        goto cleanup;
    }
    
    upgradeStatus = RequireUpgradeType(pUpgrade);

    switch(upgradeStatus)
    {
        case UPGRADELICENSE_NEWLICENSE:
            dwStatus = AdjustNewLicenseRequest(
                                    pClient,
                                    pUpgrade->pUpgradeRequest,
                                    pbAdjustedRequest,
                                    pUpgrade->pProduct[0].ucMarked,
                                    pdwErrCode
                                );
            break;

        case UPGRADELICENSE_UPGRADE:
            dwStatus = AdjustUpgradeLicenseRequest(
                                    pClient,
                                    pUpgrade,
                                    pbAdjustedRequest,
                                    pdwErrCode
                                );
            break;

        case UPGRADELICENSE_ALREADYHAVE:
            *pbAdjustedRequest = &(pUpgrade->pProduct->LicensedProduct);
            *pdwErrCode = ERROR_SUCCESS;
            break;

        default:
            SetLastError(*pdwErrCode = TLSA02_E_INVALIDDATA);
            dwStatus = POLICY_ERROR;
            
    }
    
cleanup:

    return dwStatus;
}

////////////////////////////////////////////////////////
POLICYSTATUS WINAPI
PMLicenseUpgrade(
    PMHANDLE hClient,
    DWORD dwProgressCode,
    PVOID pbProgressData,
    PVOID *ppbReturnData,
    PDWORD pdwErrCode
    )
/*++

++*/
{   
    POLICYSTATUS dwStatus = POLICY_SUCCESS;

    switch(dwProgressCode)
    {
        case REQUEST_UPGRADE:
                dwStatus = ProcessUpgradeRequest(
                                        hClient,
                                        (PPMUPGRADEREQUEST) pbProgressData,
                                        (PPMLICENSEREQUEST *) ppbReturnData,
                                        pdwErrCode
                                    );

                break;

        case REQUEST_COMPLETE:
                dwStatus = ProcessComplete(
                                        hClient,
                                    #ifdef _WIN64
                                        PtrToUlong(pbProgressData),
                                    #else
                                        (DWORD) (pbProgressData),
                                    #endif
                                        pdwErrCode
                                    );

                break;

        default:
            //
            // use default
            //
            *ppbReturnData = NULL;
            *pdwErrCode = ERROR_SUCCESS;
    }
        
    return dwStatus;
}


////////////////////////////////////////////////////////
POLICYSTATUS
PMReturnLicense(
	IN PMHANDLE hClient,
	IN ULARGE_INTEGER* pLicenseSerialNumber,
    IN PPMLICENSETOBERETURN pLicenseTobeReturn,
	OUT PDWORD pdwLicenseStatus,
    OUT PDWORD pdwErrCode
    )
/*++

Abstract

    Return module specific license return policy.

Parameters

    hClient - Client handle, assign by License Server.
    pLicenseSerialNumber - client license serial number.
    LicensePackId - License Pack where license was allocated from.
    LicensePackLicenseId - License serial number in license pack.
    pdwLicenseStatus - return what license server should
                       do with the license
    
Returns:

    Function returns ERROR_SUCCESS or any policy module specific
    error code, pdwLicenseStatus returns license return policy

    Currently defined code:

    LICENSE_RETURN_KEEP - keep license, no return to license pack
    LICENSE_RETURN_DELETE - delete license and return to license pack.

++*/
{
    POLICYSTATUS dwStatus = POLICY_SUCCESS;
    *pdwErrCode = ERROR_SUCCESS;

    if ((_tcsicmp(pLicenseTobeReturn->pszOrgProductId,
                  TERMSERV_INTERNET_SKU) == 0)
        || (_tcsicmp(pLicenseTobeReturn->pszOrgProductId,
                     TERMSERV_CONCURRENT_SKU) == 0))
    {
        *pdwLicenseStatus = LICENSE_RETURN_DELETE;
    }
    else if(_tcsicmp(pLicenseTobeReturn->pszOrgProductId,
                     TERMSERV_PRODUCTID_SKU) == 0)
    {
        // Always return license back to license pack
        *pdwLicenseStatus = (pLicenseTobeReturn->bTemp == TRUE) ?
            LICENSE_RETURN_DELETE : LICENSE_RETURN_KEEP;
    }
    else
    {
        *pdwErrCode = ERROR_INVALID_DATA;
        dwStatus = POLICY_ERROR;
    }

    return dwStatus;
}

////////////////////////////////////////////////////////

POLICYSTATUS WINAPI
PMInitialize(
    IN DWORD dwVersion,
    IN LPCTSTR pszCompanyName,
    IN LPCTSTR pszProductCode,
    IN OUT PDWORD pdwNumProduct,
    IN OUT PPMSUPPORTEDPRODUCT* ppszProduct,
    OUT PDWORD pdwErrCode
    )
/*++

Abstract:

    Initialize internal data use by this policy module.  License 
    Server calls PMInitialize() after all API is available.

Parameters:

    dwVersion - License Server version
    pszCompanyName : Name of the company as listed in license server's registry key.
    pszProductCode : Name of the product that license server assume this product supported.
    pdwNumProduct : Pointer to DWORD, on return, ploicy module will set product supported.
    ppszProduct : Pointer array to list of product supported by this policy module.

Returns:

    ERROR_SUCCESS or error code.

++*/
{
    POLICYSTATUS dwStatus = POLICY_SUCCESS;
    EXCEPTION_RECORD ExceptionCode;

    //
    // Initialize internal data here
    //

    if (CURRENT_TLSERVER_VERSION(dwVersion) < CURRENT_TLSA02_VERSION)
    {
        dwStatus = POLICY_CRITICAL_ERROR;
        *pdwErrCode = TLSA02_E_INVALIDDATA;
        goto cleanup;
    }

    try {
        g_ClientMgr = new CClientMgr;   
        if(g_ClientMgr != NULL)
        {
            g_dwVersion = dwVersion;

            if(pdwNumProduct != NULL && ppszProduct != NULL)
            {
                *pdwNumProduct = g_dwNumSupportedProduct;
                *ppszProduct = g_pszSupportedProduct;
            }
            else
            {
                //
                // Stop processing since this might be license server critical error.
                //
                dwStatus = POLICY_CRITICAL_ERROR;
                *pdwErrCode = TLSA02_E_INVALIDDATA;
            }
        }
        else
        {
            dwStatus = POLICY_CRITICAL_ERROR;
            *pdwErrCode = ERROR_OUTOFMEMORY;
        }  
    }
    catch( SE_Exception e )
    {
        dwStatus = POLICY_CRITICAL_ERROR;
        *pdwErrCode = e.getSeNumber();

    }
    catch( ... )
    {
        dwStatus = POLICY_CRITICAL_ERROR;
        *pdwErrCode = TLSA02_E_INTERNALERROR;
    }

cleanup:
    return dwStatus;
}


////////////////////////////////////////////////////////
void WINAPI
PMTerminate()
/*++

Abstract:

    Free all internal data allocated by this policy module.  License
    Server calls PMTerminate() before it unload this policy module.

Parameter:

    None.

Returns:

    None.

++*/
{
    if(g_ClientMgr)
    {
        //
        // Free internal data here
        //
        delete g_ClientMgr;
        g_ClientMgr = NULL;
    }

    FreeProductDescString();

    return;
}


////////////////////////////////////////////////////////

POLICYSTATUS WINAPI
PMInitializeProduct(
    IN LPCTSTR pszCompanyName,
    IN LPCTSTR pszCHProductCode,
    IN LPCTSTR pszTLSProductCode,
    OUT PDWORD pdwErrCode
    )
/*++

Abstract:

    Return list of product code that this policy module supported

Parameters:


Returns:

    ERROR_SUCCESS or error code.

Note:

    License Server will not free the memory, policy module will need to
    keep track.

++*/
{
    POLICYSTATUS dwStatus = POLICY_SUCCESS;

    for(DWORD index = 0; index < g_dwNumSupportedProduct; index ++)
    {
        if( _tcsicmp(pszCHProductCode, g_pszSupportedProduct[index].szCHSetupCode) == 0 &&
            _tcsicmp(pszTLSProductCode, g_pszSupportedProduct[index].szTLSProductCode) == 0)
        {
            break;
        }
    }

    if(index >= g_dwNumSupportedProduct)
    {
        *pdwErrCode = ERROR_INVALID_PARAMETER;
        dwStatus = POLICY_ERROR;
    }
    else
    {

        //
        // Ignore error here
        //
        AddA02KeyPack(
                pszTLSProductCode,
                MAKELONG(0, CURRENT_TLSERVER_VERSION(g_dwVersion)),
                FALSE
            );
    }

    *pdwErrCode = ERROR_SUCCESS;
    return dwStatus;
}

////////////////////////////////////////////////////////

POLICYSTATUS WINAPI
PMUnloadProduct(
    IN LPCTSTR pszCompanyName,
    IN LPCTSTR pszCHProductCode,
    IN LPCTSTR pszTLSProductCode,
    OUT PDWORD pdwErrCode
    )
/*++

Abstract:

    Return list of product code that this policy module supported

Parameters:


Returns:

    ERROR_SUCCESS or error code.

Note:

    License Server will not free the memory, policy module will need to
    keep track.

++*/
{
    *pdwErrCode = ERROR_SUCCESS;
    return POLICY_SUCCESS;
}

////////////////////////////////////////////////////////
POLICYSTATUS
ProcessRegisterLicensePack(
    IN PMHANDLE client,
    IN PPMREGISTERLICENSEPACK pmLicensePack,
    IN OUT PPMLSKEYPACK pmLsKeyPack,
    OUT PDWORD pdwErrCode
    )
/*++


--*/
{
    TCHAR* szUuid = NULL;
    BOOL bInternetPackage=FALSE;
    BOOL bConcurrentPackage=FALSE;

    CClient* pClient;
    POLICYSTATUS dwStatus = POLICY_SUCCESS;

    if( pmLicensePack->SourceType != REGISTER_SOURCE_INTERNET &&
        pmLicensePack->SourceType != REGISTER_SOURCE_PHONE )
    {
        dwStatus = POLICY_NOT_SUPPORTED;
        *pdwErrCode = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if( pmLicensePack->SourceType == REGISTER_SOURCE_INTERNET &&
        (pmLicensePack->dwDescriptionCount == 0 || pmLicensePack->pDescription == NULL) )
    {
        dwStatus = POLICY_ERROR;
        *pdwErrCode = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if(CompareFileTime(&pmLicensePack->ActiveDate, &pmLicensePack->ExpireDate) > 0)
    {
        dwStatus = POLICY_ERROR;
        *pdwErrCode = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // find client's object, client handle manager will
    // create a new one.
    pClient = g_ClientMgr->FindClient((PMHANDLE)client);

    if(pClient == NULL)
    {
        dwStatus = POLICY_CRITICAL_ERROR;
        *pdwErrCode = TLSA02_E_INTERNALERROR;
        goto cleanup;
    }

    bInternetPackage = (_tcsicmp(pmLicensePack->szProductId, TERMSERV_INTERNET_SKU) == 0);

    if (!bInternetPackage)
    {
        bConcurrentPackage = (_tcsicmp(pmLicensePack->szProductId, TERMSERV_CONCURRENT_SKU) == 0);
    }

    switch(pmLicensePack->dwKeyPackType)
    {
        case LICENSE_KEYPACK_TYPE_SELECT:
            pmLsKeyPack->keypack.ucKeyPackType = LSKEYPACKTYPE_SELECT;
            break;

        case LICENSE_KEYPACK_TYPE_MOLP:
            pmLsKeyPack->keypack.ucKeyPackType = LSKEYPACKTYPE_OPEN;
            break;

        case LICENSE_KEYPACK_TYPE_RETAIL:
            pmLsKeyPack->keypack.ucKeyPackType = LSKEYPACKTYPE_RETAIL;
            break;

        default:
            dwStatus = POLICY_ERROR;
            *pdwErrCode = ERROR_INVALID_PARAMETER;
            goto cleanup;
    }


    // we only use 0xFF

    pmLsKeyPack->keypack.dwPlatformType = PLATFORMID_OTHERS;
    pmLsKeyPack->keypack.ucLicenseType = (UCHAR)pmLicensePack->dwLicenseType;
    pmLsKeyPack->keypack.dwLanguageId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);  // field ignore by license server.
    pmLsKeyPack->keypack.ucChannelOfPurchase = (pmLicensePack->dwDistChannel == LICENSE_DISTRIBUTION_CHANNEL_OEM) ? 
                                                    LSKEYPACKCHANNELOFPURCHASE_OEM : 
                                                    LSKEYPACKCHANNELOFPURCHASE_RETAIL;

    pmLsKeyPack->keypack.dwProductFlags = LSKEYPACKPRODUCTFLAG_UNKNOWN;

    pmLsKeyPack->IssueDate = pmLicensePack->IssueDate;
    pmLsKeyPack->ActiveDate = pmLicensePack->ActiveDate;
    pmLsKeyPack->ExpireDate = pmLicensePack->ExpireDate;

    //
    // Tel. registration does not pass us any begin serial number, ignore this field
    //
    _stprintf(
            pmLsKeyPack->keypack.szBeginSerialNumber, 
            _TEXT("%ld"), 
            0 // pmLicensePack->dwBeginSerialNum
        );

    pmLsKeyPack->keypack.wMajorVersion = HIWORD(pmLicensePack->dwProductVersion);
    pmLsKeyPack->keypack.wMinorVersion = LOWORD(pmLicensePack->dwProductVersion);
    _tcscpy(
        pmLsKeyPack->keypack.szCompanyName, 
        pmLicensePack->szCompanyName
    );


    //
    // KeyPackId, tel. registration does not pass any begin license serial number so to be able
    // to track duplicate, pmLicensePack->KeypackSerialNum.Data1 is the actual license pack 
    // serial number, all other field are ignored.
    //
    _sntprintf(
            pmLsKeyPack->keypack.szKeyPackId,
            sizeof(pmLsKeyPack->keypack.szKeyPackId)/sizeof(pmLsKeyPack->keypack.szKeyPackId[0]),
            TERMSERV_KEYPACKID_FORMAT,
            pmLicensePack->szProductId,
            pmLsKeyPack->keypack.wMajorVersion,
            pmLsKeyPack->keypack.wMinorVersion,
            pmLsKeyPack->keypack.dwPlatformType,
            pmLicensePack->KeypackSerialNum.Data1
        );
            

    _sntprintf(
            pmLsKeyPack->keypack.szProductId,
            sizeof(pmLsKeyPack->keypack.szProductId)/sizeof(pmLsKeyPack->keypack.szProductId[0]),
            TERMSERV_PRODUCTID_FORMAT,
            pmLicensePack->szProductId,
            pmLsKeyPack->keypack.wMajorVersion,
            pmLsKeyPack->keypack.wMinorVersion,
            (!bInternetPackage)
                ? ((!bConcurrentPackage) ? TERMSERV_FULLVERSION_TYPE : TERMSERV_CONCURRENT_TYPE)
                : TERMSERV_INTERNET_TYPE
        );


    pmLsKeyPack->keypack.dwTotalLicenseInKeyPack = pmLicensePack->dwQuantity;
    pmLsKeyPack->keypack.dwNumberOfLicenses = pmLicensePack->dwQuantity;  

    //
    // Fill in list of product description
    //
    if( pmLicensePack->SourceType == REGISTER_SOURCE_INTERNET )
    {
        pmLsKeyPack->dwDescriptionCount = pmLicensePack->dwDescriptionCount;
        pmLsKeyPack->pDescription = pmLicensePack->pDescription;
    }
    else
    {
        LPTSTR *pszDescs;
        LPTSTR *pszLocalizedDescs;

        //
        // Verify version first...
        //

        if (pmLsKeyPack->keypack.wMajorVersion == 5 &&
            pmLsKeyPack->keypack.wMinorVersion == 1)
        {
            if (bConcurrentPackage)
            {
                pszDescs = g_pszUSConcurrentKeyPackProductDesc51;
                pszLocalizedDescs = g_pszLocalizedConcurrentKeyPackProductDesc51;
            }
            else if (bInternetPackage)
            {
                *pdwErrCode = ERROR_INVALID_PARAMETER;
                dwStatus = POLICY_CRITICAL_ERROR;
                goto cleanup;
            }
            else
            {
                pszDescs = g_pszUSStandardKeyPackProductString51;
                pszLocalizedDescs = g_pszLocalizedStandardKeyPackProductString51;
            }
        }
        else if (pmLsKeyPack->keypack.wMajorVersion == 5 &&
                 pmLsKeyPack->keypack.wMinorVersion == 0)
        {
            if (bInternetPackage)
            {
                pszDescs = g_pszUSInternetKeyPackProductDesc;
                pszLocalizedDescs = g_pszLocalizedInternetKeyPackProductDesc;
            }            
            else if (bConcurrentPackage)
            {
                *pdwErrCode = ERROR_INVALID_PARAMETER;
                dwStatus = POLICY_CRITICAL_ERROR;
                goto cleanup;
            }
            else
            {
                pszDescs = g_pszUSStandardKeyPackProductString;
                pszLocalizedDescs = g_pszLocalizedStandardKeyPackProductString;
            }
        }
        else
        {
            *pdwErrCode = ERROR_INVALID_PARAMETER;
            dwStatus = POLICY_CRITICAL_ERROR;
            goto cleanup;
        }


        // one for english and one for localized version
        pmLsKeyPack->dwDescriptionCount = (GetSystemDefaultLangID() != MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US)) ? 2 : 1;

        pmLsKeyPack->pDescription =
            (PPMREGISTERLKPDESC) pClient->AllocateMemory(
                                        MEMORY_LICENSEREGISTRATION,
                                        sizeof(PMREGISTERLKPDESC) * pmLsKeyPack->dwDescriptionCount
                                        );

        if(pmLsKeyPack->pDescription == NULL)
        {
            *pdwErrCode = ERROR_OUTOFMEMORY;
            dwStatus = POLICY_CRITICAL_ERROR;
            goto cleanup;
        }

        pmLsKeyPack->pDescription->Locale = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);

        if (bInternetPackage && (pmLsKeyPack->keypack.wMajorVersion == 5 &&
                 pmLsKeyPack->keypack.wMinorVersion == 0))
        {
            _tcscpy(
                    pmLsKeyPack->pDescription->szProductName, 
                    g_pszUSInternetKeyPackProductDesc[INDEX_PRODUCTNAME]
                    );

            _tcscpy(
                    pmLsKeyPack->pDescription->szProductDesc, 
                    pszDescs[INDEX_PRODUCTDESC]
                    );

        }
        else if (bConcurrentPackage && (pmLsKeyPack->keypack.wMajorVersion == 5 &&
                 pmLsKeyPack->keypack.wMinorVersion == 1))
        {
            _tcscpy(
                    pmLsKeyPack->pDescription->szProductName, 
                    g_pszUSConcurrentKeyPackProductDesc51[INDEX_PRODUCTNAME]
                    );

            _tcscpy(
                    pmLsKeyPack->pDescription->szProductDesc, 
                    pszDescs[INDEX_PRODUCTDESC]                    
                    );
        }
        else
        {
            if(bInternetPackage || bConcurrentPackage)
            {
                *pdwErrCode = ERROR_INVALID_PARAMETER;
                dwStatus = POLICY_CRITICAL_ERROR;
                goto cleanup;
            }

            if (pmLsKeyPack->keypack.wMajorVersion == 5 &&
                 pmLsKeyPack->keypack.wMinorVersion == 0)
            {

                _tcscpy(
                        pmLsKeyPack->pDescription->szProductName, 
                        g_pszUSStandardKeyPackProductString[INDEX_PRODUCTNAME]
                        );

                _tcscpy(
                        pmLsKeyPack->pDescription->szProductDesc, 
                        pszDescs[INDEX_PRODUCTDESC]                    
                        );
            }
            else if(pmLsKeyPack->keypack.wMajorVersion == 5 &&
                 pmLsKeyPack->keypack.wMinorVersion == 1)
            {
                 _tcscpy(
                        pmLsKeyPack->pDescription->szProductName, 
                        g_pszUSStandardKeyPackProductString51[INDEX_PRODUCTNAME]
                        );

                _tcscpy(
                        pmLsKeyPack->pDescription->szProductDesc, 
                        pszDescs[INDEX_PRODUCTDESC]                    
                        );
            }

        }        



        if(GetSystemDefaultLangID() != MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US))
        {
            pmLsKeyPack->pDescription[1].Locale = GetSystemDefaultLangID();

            if (bInternetPackage  && (pmLsKeyPack->keypack.wMajorVersion == 5 &&
                 pmLsKeyPack->keypack.wMinorVersion == 0))
            {

                _tcscpy(
                    pmLsKeyPack->pDescription[1].szProductName, 
                    g_pszLocalizedInternetKeyPackProductDesc[INDEX_PRODUCTNAME]
                    );
        
                _tcscpy(
                    pmLsKeyPack->pDescription[1].szProductDesc, 
                    pszDescs[INDEX_PRODUCTDESC]
                    );
            }
            else if (bConcurrentPackage && (pmLsKeyPack->keypack.wMajorVersion == 5 &&
                 pmLsKeyPack->keypack.wMinorVersion == 1))
            {
                _tcscpy(
                    pmLsKeyPack->pDescription[1].szProductName, 
                    g_pszLocalizedConcurrentKeyPackProductDesc51[INDEX_PRODUCTNAME]
                    );
        
                _tcscpy(
                    pmLsKeyPack->pDescription[1].szProductDesc, 
                    pszDescs[INDEX_PRODUCTDESC]
                   );
            }
            else
            {
                if(bInternetPackage || bConcurrentPackage)
                {
                    *pdwErrCode = ERROR_INVALID_PARAMETER;
                    dwStatus = POLICY_CRITICAL_ERROR;
                    goto cleanup;
                }
                else if (pmLsKeyPack->keypack.wMajorVersion == 5 &&
                 pmLsKeyPack->keypack.wMinorVersion == 0)
                {
                    _tcscpy(
                        pmLsKeyPack->pDescription[1].szProductName, 
                        g_pszLocalizedStandardKeyPackProductString[INDEX_PRODUCTNAME]
                        );

                    _tcscpy(
                        pmLsKeyPack->pDescription[1].szProductDesc, 
                        pszDescs[INDEX_PRODUCTDESC]
                        );
                }
                else if (pmLsKeyPack->keypack.wMajorVersion == 5 &&
                 pmLsKeyPack->keypack.wMinorVersion == 1)
                {
                     _tcscpy(
                            pmLsKeyPack->pDescription->szProductName, 
                            g_pszUSStandardKeyPackProductString51[INDEX_PRODUCTNAME]
                            );

                    _tcscpy(
                            pmLsKeyPack->pDescription->szProductDesc, 
                            pszDescs[INDEX_PRODUCTDESC]                    
                            );
                }
            }
        }
    }

cleanup:

    return dwStatus;
}

////////////////////////////////////////////////////////
POLICYSTATUS
CompleteRegisterLicensePack(
    IN PMHANDLE client,
    IN DWORD dwErrCode,
    OUT PDWORD pdwErrCode
    )
/*++

--*/
{
    UNREFERENCED_PARAMETER(dwErrCode);

    //
    // Free memory allocated for the client
    //
    g_ClientMgr->DestroyClient( client );
    *pdwErrCode = ERROR_SUCCESS;
    return POLICY_SUCCESS;
}

////////////////////////////////////////////////////////

POLICYSTATUS WINAPI
PMRegisterLicensePack(
    PMHANDLE client,
    DWORD dwProgressCode,
    PVOID pbProgressData,
    PVOID pbReturnData,
    PDWORD pdwErrCode
    )
/*++

--*/
{
    POLICYSTATUS dwStatus = POLICY_SUCCESS;

    switch(dwProgressCode)
    {
        case REGISTER_PROGRESS_NEW:
            dwStatus = ProcessRegisterLicensePack(
                                       client,
                                       (PPMREGISTERLICENSEPACK) pbProgressData,
                                       (PPMLSKEYPACK)pbReturnData,
                                       pdwErrCode
                                       );
            break;

        case REGISTER_PROGRESS_END:
            dwStatus = CompleteRegisterLicensePack(
                                       client,
                                       #ifdef _WIN64
                                           PtrToUlong(pbProgressData),
                                       #else
                                           (DWORD) pbProgressData,
                                       #endif
                                       pdwErrCode
                                       );
            break;

        default:
            *pdwErrCode = ERROR_INVALID_PARAMETER;
            dwStatus = POLICY_ERROR;

    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tls236\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:


NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

!include $(LSERVER_ROOT)\lserver.mk

USE_MSVCRT=1
USE_STL=1

MAJORCOMP=hydra
MINORCOMP=tls236

TARGETNAME=$(MINORCOMP)
TARGETPATH=obj
TARGETTYPE=DYNLINK

SOURCES_OPTIONS=-c0

UMTYPE=windows

DLLDEF=..\tls236.def
COFFBASE=usermode
DLLENTRY=_DllMainCRTStartup
PRECOMPILED_INCLUDE=..\pch.cpp

PASS0_HEADERDIR=$(O)
MC_SOURCEDIR=$(O)

SOURCES= \
    ..\messages.mc \
    ..\tls236.rc \
    ..\dllmain.c \
    ..\request.cpp \
    ..\tls236.cpp \
    ..\tlsbkupc.cpp \
    ..\tlsbkup-c.c


TARGETLIBS=\
    $(TERMSRV_ROOT)\lib\$(O)\trust.lib \
    $(TERMSRV_ROOT)\lib\$(O)\tlsapip.lib \
    $(SDK_LIB_PATH)\rpcrt4.lib \
    $(SDK_LIB_PATH)\rpcns4.lib \
    $(SDK_LIB_PATH)\netapi32.lib \
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDK_LIB_PATH)\comctl32.lib \
    $(SDK_LIB_PATH)\gdi32.lib \
    $(SDK_LIB_PATH)\user32.lib \
    $(SDK_LIB_PATH)\shell32.lib \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\msvcprt.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tls236\tlsbkup-c.c ===
#include <tlsbkup_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tls236\tls236.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       tls236.cpp
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"

CClientMgr* g_ClientMgr=NULL;


////////////////////////////////////////////////////////
// 
// CClient Class
//
////////////////////////////////////////////////////////
CClient::CClient(
    IN PMHANDLE hClient
    ) :
    m_hClient(hClient)
/*++

Abstract:

    Constructor for CClient class.

Parameter:

    hClient : client handle

Return:

    None.

++*/
{
}


//------------------------------------------------------
CClient::~CClient()
/*++

Abstract:

    Destructor for CClient class

Parameter:

    None

Return:

    None

++*/
{
    for(list<PointerType>::iterator it = m_AllocatedMemory.begin(); 
        it != m_AllocatedMemory.end();
        it++)
    {
        HLOCAL ptr = (*it).GetPointer(); 
        FREE(ptr);
    }

    // m_AllocatedMemory.erase(m_AllocatedMemory.begin(), m_AllocatedMemory.end());
}

//------------------------------------------------------
HLOCAL
CClient::AllocateMemory(
    IN MEMORYPOINTERTYPE ptrType,
    IN DWORD dwSize
    )
/*++

Abstract:

    Allocate/store memory allocated into memory list.

Parameter:

    dwSize - Number of byte to allocate.

Return:

    Same as from LocalAlloc().

++*/
{
    HLOCAL ptr = NULL;
    DWORD dwStatus = ERROR_SUCCESS;

    try {

        ptr = MALLOC(dwSize);

        if(ptr != NULL)
        {
            //
            // Append to allocated list.
            //
            m_AllocatedMemory.push_back( PointerType(ptrType, ptr) );
        }
    }
    catch( SE_Exception e )
    {
        SetLastError(dwStatus = e.getSeNumber());
    }
    catch( ... )
    {
        SetLastError(dwStatus = TLSA02_E_INTERNALERROR);
    }

    if(dwStatus != ERROR_SUCCESS)
    {
        if(ptr != NULL)
        {
            FREE(ptr);
            ptr = NULL;
        }
    }

    return ptr;
}


////////////////////////////////////////////////////////
// 
// CClientMgr
//
////////////////////////////////////////////////////////
CClientMgr::~CClientMgr()
{
    Cleanup();
}

//------------------------------------------------------
void
CClientMgr::Cleanup()
/*++

++*/
{
    MapHandleToClient::iterator it;
    m_HandleMapLock.Lock();

    try {
        for(it = m_HandleMap.begin(); it != m_HandleMap.end(); it++)
        {
            assert( ((*it).second)->GetRefCount() == 1 );
        }
    }
    catch(...) {
    }

    m_HandleMapLock.UnLock();
    //
    // Always perform cleanup
    //
    // m_HandleMap.erase(m_HandleMap.begin(), m_HandleMap.end());
}

//------------------------------------------------------
CClient*
CClientMgr::FindClient(
    IN PMHANDLE hClient
    )
/*++

Abstract:

    Routine to find client object, add client object if not found.

Parameter:

    hClient - Client handle

Return:

++*/
{
    EXCEPTION_RECORD ExceptionCode;
    MapHandleToClient::iterator it;
    CClient*ptr = NULL;
    DWORD dwStatus = ERROR_SUCCESS;

    m_HandleMapLock.Lock();

    try {
        it = m_HandleMap.find(hClient);
        if( it == m_HandleMap.end() )
        {
            CClient* pClient;
            pClient = new CClient(hClient);
            if(pClient != NULL)
            {
                m_HandleMap[hClient] = pClient;

                // pair<PMHANDLE, CClient*> m(hClient, pClient);
                //m_HandleMap.insert( m );

                // m_HandleMap.insert( pair<PMHANDLE, CClient*>(hClient, pClient) );
                it = m_HandleMap.find(hClient);
                assert(it != m_HandleMap.end());
            }
        }

        if(it != m_HandleMap.end())
        {
            ptr = (*it).second;
        }
    }
    catch( SE_Exception e )
    {
        dwStatus = e.getSeNumber();
    }
    catch( ... )
    {
        dwStatus = TLSA02_E_INTERNALERROR;
    }

    m_HandleMapLock.UnLock();
    return ptr;
}

//------------------------------------------------------
BOOL
CClientMgr::DestroyClient(
    IN PMHANDLE hClient
    )
/*++


++*/
{
    MapHandleToClient::iterator it;
    BOOL bSuccess = FALSE;

    m_HandleMapLock.Lock();

    try {    
        it = m_HandleMap.find(hClient);
        if(it != m_HandleMap.end())
        {
            delete (*it).second;
            m_HandleMap.erase(it);
            bSuccess = TRUE;
        }
    }
    catch(...) {
    }

    m_HandleMapLock.UnLock();
    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tls236\tls236.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       tls236.h 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TLSA02_H__
#define __TLSA02_H__

#include "tlsstl.h"    // STL

#include <stdio.h>
#include <tchar.h>
#include <assert.h>
#include "tlsapi.h"
#include "tlspol.h"
#include "ntverp.h"
#include "locks.h"


#define US_IDS_COMPANYNAME          _TEXT("Microsoft Corporation")

#define US_IDS_EX_PRODUCTNAME       _TEXT("Existing Windows License Token")
#define US_IDS_EX_PRODUCTDESC       _TEXT("Existing Windows 2000 License Token")
#define US_IDS_EX_PRODUCTDESC51     _TEXT("Existing Windows Whistler License Token")

#define US_IDS_S_PRODUCTNAME        _TEXT("Full Windows Terminal Services Client Access License Token")
#define US_IDS_S_PRODUCTDESC        _TEXT("Windows 2000 Terminal Services Client Access License Token")
#define US_IDS_S_PRODUCTDESC51      _TEXT("Windows Whistler Terminal Services Client Access License Token")

#define US_IDS_I_PRODUCTNAME        _TEXT("Windows Terminal Services Internet Connector License Token")
#define US_IDS_I_PRODUCTDESC        _TEXT("Windows 2000 Terminal Services Internet Connector License Token")


#define US_IDS_C_PRODUCTNAME        _TEXT("Windows Terminal Services Per Session License Token")
#define US_IDS_C_PRODUCTDESC51      _TEXT("Windows Whistler Terminal Services Per Session License Token")


//
// A02 Product ID
//
#define PLATFORMID_UPGRADE  1
#define PLATFORMID_FREE     2
#define PLATFORMID_OTHERS   0xFF    // also used for Concurrent and Internet

#define LSKEYPACK_LOCAL_TYPE    0x40 

//
// 236 is for NT4 TS client.
//
#define TERMSERV_PRODUCTID_CH       _TEXT("001")
#define TERMSERV_PRODUCTID_SKU      _TEXT("A02")
#define TERMSERV_FULLVERSION_TYPE   _TEXT("S")
#define TERMSERV_FREE_TYPE          _TEXT("EX")

//
// Internet Package
//
#define TERMSERV_INTERNET_CH        _TEXT("002")
#define TERMSERV_INTERNET_SKU       _TEXT("B96")
#define TERMSERV_INTERNET_TYPE      _TEXT("I")

//
// Concurrent Package
//
#define TERMSERV_CONCURRENT_CH     _TEXT("003")
#define TERMSERV_CONCURRENT_SKU    _TEXT("C50")
#define TERMSERV_CONCURRENT_TYPE   _TEXT("C")

//
// Whistler Package
//
#define TERMSERV_WHISTLER_PRODUCTID_CH      _TEXT("004")



#define TERMSERV_PRODUCTID_FORMAT   _TEXT("%3s-%ld.%02ld-%s")
#define MAX_TERMSRV_PRODUCTID       LSERVER_MAX_STRING_SIZE

//
// keypack ID is ProductID+MajorVersion+MinorVersion+SerialNumber
//
#define TERMSERV_KEYPACKID_FORMAT   _TEXT("%s%02d%02d%02d%d")

#define TLSA02_VERSION (MAKELONG(MAKEWORD(0, HIBYTE(VER_PRODUCTVERSION_W)), 0))

#define CURRENT_TLSA02_VERSION  HIBYTE(LOWORD(TLSA02_VERSION))

#define WINDOWS_VERSION_NT5         5
#define WINDOWS_VERSION_BASE        2000

#define MAX_SKU_PREFIX              10
#define MAX_SKU_POSTFIX             10

#define MALLOC(size)    LocalAlloc(LPTR, size)

#define FREE(ptr) \
    if(ptr)             \
    {                   \
        LocalFree(ptr); \
        ptr=NULL;       \
    }

#define SAFESTRCPY(dest, source) \
    {                               \
        _tcsncpy(dest, source, min(_tcslen(source), sizeof(dest)/sizeof(TCHAR))); \
        dest[min(_tcslen(source), (sizeof(dest)/sizeof(TCHAR) - 1))] = _TEXT('\0'); \
    }

#define STRBUFSIZE(x)   (sizeof(x) / sizeof(x[0]))

//---------------------------------------------------
typedef enum {
    MEMORY_UNKNOWN,
    MEMORY_GENERAL,
    MEMORY_STRING,
    MEMORY_KEYPACKDESC,
    MEMORY_LICENSE_REQUEST,
    MEMORY_CERTEXTENSION,
    MEMORY_LICENSEREGISTRATION
} MEMORYPOINTERTYPE;

//----------------------------------------------------
typedef struct __PointerType {
    MEMORYPOINTERTYPE m_MemoryType;
    HLOCAL m_Ptr;

    //-----------------------------------------
    __PointerType() : 
        m_MemoryType(MEMORY_UNKNOWN), 
        m_Ptr(NULL)
    {
    }
    
    //--------------------------------------
    __PointerType(
        MEMORYPOINTERTYPE ptrType,
        HLOCAL ptr
        ) :
        m_MemoryType(ptrType),
        m_Ptr(ptr)
    /*++
    ++*/
    {
    }

    //---------------------------------------
    PVOID
    GetPointer() 
    { 
        return m_Ptr; 
    }
} PointerType;

//----------------------------------------------
class CRefCounter {
private:

    long    m_RefCounter;

public:

    CRefCounter() : m_RefCounter(0) {}
    ~CRefCounter() 
    {
        if(DecRef() == 0)
        {
            delete this;
        }
    }

    long
    AddRef() { 
        return InterlockedIncrement(&m_RefCounter); 
    }

    long
    DecRef() { 
        return InterlockedDecrement(&m_RefCounter); 
    }
};
    
//---------------------------------------------
class CClient {
private:

    PMHANDLE  m_hClient;       // client handle

    //
    // list of memory allocated
    list<PointerType> m_AllocatedMemory;

public:

    CClient(PMHANDLE hClient);
    ~CClient();

    //-----------------------------------------
    HLOCAL 
    AllocateMemory(
        MEMORYPOINTERTYPE ptrType, 
        DWORD dwSize
    );

    //-----------------------------------------
    PMHANDLE
    GetPMHANDLE() {
        return m_hClient;
    }
};   

//------------------------------------------------------

class CClientMgr {
private:

    CCriticalSection m_HandleMapLock;
    typedef map<PMHANDLE, CClient*, less<PMHANDLE> > MapHandleToClient;
    MapHandleToClient m_HandleMap;

public:

    CClientMgr() {}
    ~CClientMgr();

    void
    Cleanup();

    CClient*
    FindClient(PMHANDLE hClient);

    BOOL
    DestroyClient(PMHANDLE hClient);
};

#ifdef __cplusplus
extern "C" {
#endif

void
InitPolicyModule(
    IN HMODULE
);
    
BOOL
LoadResourceString(
    IN DWORD dwId,
    IN OUT LPTSTR szBuf,
    IN DWORD dwBufSize
);

DWORD
AddA02KeyPack(
    DWORD dwVersion
);

DWORD
InsertLicensePack(
    IN TLS_HANDLE tlsHandle,
    IN DWORD dwProdVersion,
    IN DWORD dwDescVersion,
    IN DWORD dwPlatformType,
    IN UCHAR ucAgreementType,
    IN LPTSTR pszProductId,
    IN LPTSTR pszKeyPackId,
    IN LPTSTR pszUsDesc[],
    IN LPTSTR pszLocalizedDesc[]
);

POLICYSTATUS
ProcessUpgradeRequest(
    PMHANDLE hClient,
    PPMUPGRADEREQUEST pUpgrade,
    PPMLICENSEREQUEST* pbAdjustedRequest,
    PDWORD pdwErrCode
);


BOOL LicenseTypeFromLookupTable(
	IN DWORD dwClientVer,
	IN DWORD dwTermSrvVer,
	OUT PDWORD pdwCALType
);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tlsapi\dllmain.c ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include <windows.h>

BOOL WINAPI _CRT_INIT(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved);

void TLSShutdown();

BOOL WINAPI DllMain(IN HINSTANCE hinstance,
                    IN DWORD     reason,
                    IN LPVOID    reserved)
{
    switch(reason)
    {
        case DLL_PROCESS_ATTACH:
            if (!_CRT_INIT(hinstance, reason, reserved))
            {
                return(FALSE);
            }

            DisableThreadLibraryCalls(hinstance);
            break;

        case DLL_PROCESS_DETACH:
            TLSShutdown();

            if (!_CRT_INIT(hinstance, reason, reserved))
            {
                return(FALSE);
            }
            break;

    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tlsapi\csp.c ===
/*++

File name:      

    csp.c

Description:    
    
    Contains routines to support cryptographic routines for termserv

Copyright:

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1991-1998
    All rights reserved

History:

    Frederick Chong( FredCh )   07/29/98    Added functions to install
                                            X509 certificate.
   
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <ntlsa.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>

#include <tchar.h>
#include <stdio.h>

#include "license.h"
#include "cryptkey.h"
#include "rng.h"
#include "lscsp.h"
#include "tlsapip.h"
#include "certutil.h"
#include "hydrakey.h"

#include <md5.h>
#include <sha.h>
#include <rsa.h>

#include <secdbg.h>
#include "global.h"

#ifdef OS_WIN16
#include <string.h>
#endif // OS_WIN16

#include "licecert.h"

#define LS_DISCOVERY_TIMEOUT (1*1000)

//-----------------------------------------------------------------------------
//
// Internal Functions
//
//-----------------------------------------------------------------------------

NTSTATUS
OpenPolicy(
    LPWSTR      ServerName,
    DWORD       DesiredAccess,
    PLSA_HANDLE PolicyHandle );

void
InitLsaString(
    PLSA_UNICODE_STRING LsaString,
    LPWSTR String );

LICENSE_STATUS
GenerateRsaKeyPair(
    LPBYTE *     ppbPublicKey,
    LPDWORD      pcbPublicKey,
    LPBYTE *     ppbPrivateKey,
    LPDWORD      pcbPrivateKey,
    DWORD        dwKeyLen );

LICENSE_STATUS
Bsafe2CapiPubKey(
    PCERT_PUBLIC_KEY_INFO   pCapiPubKeyInfo,
    LPBYTE                  pbBsafePubKey,
    DWORD                   cbBsafePubKey );

VOID
FreeCapiPubKey(
    PCERT_PUBLIC_KEY_INFO   pCapiPubKeyInfo );

LICENSE_STATUS
RequestCertificate(     
    TLS_HANDLE              hServer,
    PCERT_PUBLIC_KEY_INFO   pPubKeyInfo,
    LPBYTE *                ppbCertificate,
    LPDWORD                 pcbCertificate,
    HWID *                  pHwid );

LICENSE_STATUS
GetSubjectRdn(
    LPTSTR   * ppSubjectRdn );

LICENSE_STATUS
GenerateMachineHWID(
    PHWID    pHwid );


LICENSE_STATUS
ReloadCSPCertificateAndData();

LICENSE_STATUS
CreateProprietaryKeyAndCert(
    PBYTE *ppbPrivateKey,
    DWORD *pcbPrivateKey,
    PBYTE *ppbServerCert,
    DWORD *pcbServerCert);

BOOL IsSystemService();

/*++

Function:

    LsCsp_ValidateServerCert

Routine Description:

    This function validate the server public key.

Arguments:

    pSserverCert - pointer to a server certificate.

Return Value:

    TRUE - if the server public key is valid.
    FALSE - otherwise.

--*/

BOOL
LsCsp_ValidateServerCert(
    PHydra_Server_Cert pServerCert
    )
{
    BOOL    bResult = TRUE;
    DWORD dwLen;
    LPBYTE pbSignature;
    MD5_CTX HashState;
    BYTE SignHash[0x48];
    DWORD buff[64];
    LPBYTE pbScan;

    //
    // pack the certificate data into a byte blob excluding the signature info.
    //

    dwLen =
        3 * sizeof(DWORD) +
        2 * sizeof(WORD) +
        pServerCert->PublicKeyData.wBlobLen;

    //
    // allocated space for the binary blob.
    //
    if (dwLen < sizeof(buff)) {

        pbSignature = (PBYTE)buff;

    } else {
        pbSignature = LocalAlloc( LPTR, (UINT)dwLen );
        if( pbSignature == NULL ) {
#if DBG
    DbgPrint("LSCSP: LsCsp_ValidateServerCert buffer alloc failed.\n");
#endif
            bResult = FALSE;
            goto vsc_done;
        }
    }

    pbScan = pbSignature;

    memcpy( pbScan, &pServerCert->dwVersion, sizeof(DWORD));
    pbScan += sizeof(DWORD);

    memcpy( pbScan, &pServerCert->dwSigAlgID, sizeof(DWORD));
    pbScan += sizeof(DWORD);

    memcpy( pbScan, &pServerCert->dwKeyAlgID, sizeof(DWORD));
    pbScan += sizeof(DWORD);

    memcpy( pbScan, &pServerCert->PublicKeyData.wBlobType, sizeof(WORD));
    pbScan += sizeof(WORD);

    memcpy( pbScan, &pServerCert->PublicKeyData.wBlobLen, sizeof(WORD));
    pbScan += sizeof(WORD);

    memcpy(
        pbScan,
        pServerCert->PublicKeyData.pBlob,
        pServerCert->PublicKeyData.wBlobLen);

    //
    // generate the hash on the data.
    //
    MD5Init( &HashState );
    MD5Update( &HashState, pbSignature, dwLen );
    MD5Final( &HashState );

    //
    // free the signature blob, we don't need it anymore.
    //

    if (pbSignature != (LPBYTE)buff) {
        LocalFree( pbSignature );
    }

    //
    // decrypt the signature.
    //

    memset(SignHash, 0x00, 0x48);
    BSafeEncPublic( csp_pRootPublicKey, pServerCert->SignatureBlob.pBlob, SignHash);

    //
    // compare the hash value.
    //

    if( memcmp( SignHash, HashState.digest, 16 )) {
        bResult = FALSE;
    } else {
         bResult = TRUE;
    }

vsc_done:

    return( bResult );
}


/*++

Function:

    LsCsp_UnpackServerCert

Routine Description:

    This function unpacks the blob of server certicate to server certificate
    structure.

Arguments:

    pbCert - pointer to the server public key blob.

    dwCertLen - length of the above server public key.

    pServerCert - pointer to a server certificate structure.

Return Value:

    TRUE - if successfully unpacked.
    FALSE - otherwise.

--*/

BOOL
LsCsp_UnpackServerCert(
    LPBYTE pbCert,
    DWORD dwCertLen,
    PHydra_Server_Cert pServerCert
    )
{
    LPBYTE  pbScan;
    BOOL    bResult = TRUE;

    ASSERT(pbCert != NULL);
    ASSERT(dwCertLen < (3 * sizeof(DWORD) + 4 * sizeof(WORD)));
    ASSERT(pServerCert != NULL);

    pbScan = pbCert;

    //
    // Assign dwVersion
    //

    pServerCert->dwVersion = *(DWORD UNALIGNED FAR *)pbScan;
    pbScan += sizeof(DWORD);
    ASSERT(pServerCert->dwVersion == 0x01);

    //
    // Assign dwSigAlgID
    //

    pServerCert->dwSigAlgID = *(DWORD UNALIGNED FAR *)pbScan;
    pbScan += sizeof(DWORD);

    //
    // Assign dwSignID
    //

    pServerCert->dwKeyAlgID  = *(DWORD UNALIGNED FAR *)pbScan;
    pbScan += sizeof(DWORD);

    //
    // Assign PublicKeyData
    //

    pServerCert->PublicKeyData.wBlobType = *(WORD UNALIGNED FAR *)pbScan;
    pbScan += sizeof(WORD);

    if( pServerCert->PublicKeyData.wBlobType != BB_RSA_KEY_BLOB ) {
#if DBG
    DbgPrint("LSCSP: LsCsp_UnpackServerCert PublicKey not BB_RSA_KEY_BLOB\n");
#endif
        bResult = FALSE;
        goto usc_done;
    }

    pServerCert->PublicKeyData.wBlobLen = *(WORD UNALIGNED FAR *)pbScan;
    pbScan += sizeof(WORD);

    if( pServerCert->PublicKeyData.wBlobLen > 0 ) {
        pServerCert->PublicKeyData.pBlob = pbScan;
        pbScan += pServerCert->PublicKeyData.wBlobLen;
    }
    else {
        pServerCert->PublicKeyData.pBlob = NULL;
    }

    //
    // Assign SignatureBlob
    //

    pServerCert->SignatureBlob.wBlobType = *(WORD UNALIGNED *)pbScan;
    pbScan += sizeof(WORD);

    if( pServerCert->SignatureBlob.wBlobType != BB_RSA_SIGNATURE_BLOB ) {
#if DBG
    DbgPrint("LSCSP: LsCsp_UnpackServerCert Signature Blob not BB_RSA_SIGNATURE_BLOB\n");
#endif
        bResult = FALSE;
        goto usc_done;
    }

    pServerCert->SignatureBlob.wBlobLen = *(WORD UNALIGNED FAR *)pbScan;
    pbScan += sizeof(WORD);

    if( pServerCert->SignatureBlob.wBlobLen > 0 ) {
        pServerCert->SignatureBlob.pBlob = pbScan;
        pbScan += pServerCert->SignatureBlob.wBlobLen;
    }
    else {
        pServerCert->SignatureBlob.pBlob = NULL;
    }

usc_done:

    return( bResult );
}


/*++

Function:

    LsCsp_DecryptEnvelopedData

Routine Description:

    Decrypt the client random that is encrypted by the server public key.

Arguments:

    dwCertType - The type of certificate that is used in the encryption.

    pbEnvelopedData - pointer to a buffer where the encrypted random key is
    passed in.

    cbEnvelopedDataLen - length of the random key passed in/out.

    pbData - pointer to a buffer where the decrypted data returned.

    pcbDataLen - pointer a DWORD location where the length of the above
    buffer is passed in and the length of the decrypted data is returned.

Return Value:

    TRUE - if the key is decrypted successfully.
    FALSE - otherwise.

--*/

BOOL
LsCsp_DecryptEnvelopedData(
    CERT_TYPE   CertType,
    LPBYTE      pbEnvelopedData,
    DWORD       cbEnvelopedDataLen,
    LPBYTE      pbData,
    LPDWORD     pcbDataLen
    )
{
    LPBSAFE_PRV_KEY pSrvPrivateKey = NULL;
    BOOL    bResult = TRUE;

    ACQUIRE_EXCLUSIVE_ACCESS(csp_hMutex);

    //
    // determine the correct private key to use for the decryption operation
    //

    if( CERT_TYPE_PROPRIETORY == CertType )
    {        
        pSrvPrivateKey = (LPBSAFE_PRV_KEY)csp_abServerPrivateKey;
    }
    else if( CERT_TYPE_X509 == CertType )
    {
        if( csp_abX509CertPrivateKey == NULL )
        {
            if( ReloadCSPCertificateAndData() != LICENSE_STATUS_OK )
            {
                ASSERT( FALSE );
            }
        }

        pSrvPrivateKey = (LPBSAFE_PRV_KEY)csp_abX509CertPrivateKey;
    }
    else
    {
        bResult = FALSE;
        goto ded_done;
    }
    
    if( NULL == pSrvPrivateKey )
    {
        bResult = FALSE;
        goto ded_done;
    }

    //
    // check to see the output buffer length pointer is valid.
    //

    if( pcbDataLen == NULL ) {
        bResult = FALSE;
        goto ded_done;
    }

    //
    // check to see the output buffer is valid and its length is sufficient.
    //

    if( (pbData == NULL) || (*pcbDataLen < pSrvPrivateKey->keylen) ) {
        *pcbDataLen = pSrvPrivateKey->keylen;
        bResult = FALSE;
        goto ded_done;
    }

    //
    // encrypted data length should be equal to server private key length.
    //

    if( cbEnvelopedDataLen != pSrvPrivateKey->keylen ) {
        *pcbDataLen = 0;
        bResult = FALSE;
        goto ded_done;
    }

    ASSERT( pbData != NULL );

    //
    // init the output buffer.
    //

    memset( pbData, 0x0, (UINT)pSrvPrivateKey->keylen );

    if( !BSafeDecPrivate(
            pSrvPrivateKey,
            pbEnvelopedData,
            pbData) ) {
        *pcbDataLen = 0;
        bResult = FALSE;
        goto ded_done;
    }

    //
    // successfully decrypted the client random.
    // set the encrypted data length before returning.
    //

    *pcbDataLen = pSrvPrivateKey->keylen;

ded_done:

    RELEASE_EXCLUSIVE_ACCESS( csp_hMutex ); 

    return( bResult );
}


BOOL
LsCsp_EncryptEnvelopedData(
    LPBYTE  pbData,
    DWORD   cbDataLen,
    LPBYTE  pbEnvelopedData,
    LPDWORD pcbEnvelopedDataLen
    )
{
    return FALSE;
}


/*++

Function:

    LsCsp_DumpBinaryData

Description:

    Display the binary data in the given buffer at the debugger output screen

Arguments:

    pBuffer - Buffer containing the binary data to be displayed.
    uLen - Length of th binary data

Return:

    Nothing.

--*/

#if DBG
#ifdef DUMP
VOID LsCsp_DumpBinaryData( PBYTE pBuffer, ULONG uLen )
{
    UNALIGNED CHAR  *p = (UNALIGNED CHAR *)pBuffer;
    CHAR     c;
    DWORD    dw;
    UINT     i = 0;

    DbgPrint("{\n  ");
    while( i < uLen ) {
        c = *p;
        dw = (DWORD)(c);
        DbgPrint( "0x%02X, ", dw & 0xFF );
        i++;
        p++;
        if ((i % 8) == 0)
            DbgPrint( "\n  " );
    }
    DbgPrint( "\n}\n" );
}
#endif
#endif


/*++

Function:

    LsCsp_GetBinaryData

Description:

    Retrieve binary data from the registry

Arguments:

    hKey - Handle to the registry key
    szValue - The registry value to read
    ppBuffer - Return pointer to the binary data
    pdwBufferLen - The length of the binary data.

Return:

    A LICENSE_STATUS return code.

--*/

LICENSE_STATUS
LsCsp_GetBinaryData( 
    HKEY        hKey, 
    LPTSTR      szValue, 
    LPBYTE *    ppBuffer, 
    LPDWORD     pdwBufferLen )
{
    LICENSE_STATUS Status = LICENSE_STATUS_OK;
    DWORD   dwType;
    DWORD   cbBuffer;
    LPBYTE  lpBuffer;

    ASSERT( ppBuffer != NULL );
    ASSERT( pdwBufferLen != NULL );
    ASSERT( szValue != NULL );
    ASSERT( hKey != NULL );

    *ppBuffer = NULL;
    cbBuffer = 0;

    if ( RegQueryValueEx(
                hKey,
                szValue,
                0,
                &dwType,
                (LPBYTE)NULL,
                &cbBuffer) != ERROR_SUCCESS ||
        dwType != REG_BINARY ||
        cbBuffer == 0 )
    {
        Status = LICENSE_STATUS_NO_CERTIFICATE;
        goto gbd_done;
    }
    lpBuffer = (LPBYTE)LocalAlloc( LPTR, cbBuffer );
    if (lpBuffer == NULL) {
        Status = LICENSE_STATUS_OUT_OF_MEMORY;
        goto gbd_done;
    }
    if ( RegQueryValueEx(
                hKey,
                szValue,
                0,
                &dwType,
                (LPBYTE)lpBuffer,
                &cbBuffer) != ERROR_SUCCESS ||
         dwType != REG_BINARY)
    {
        LocalFree( lpBuffer );
        Status = LICENSE_STATUS_NO_CERTIFICATE;
        goto gbd_done;
    }

    *ppBuffer = lpBuffer;
    *pdwBufferLen = cbBuffer;

gbd_done:

    return( Status );
}


/*++

Function:

    LsCsp_Initialize

Description:

    Initialize this library.

Arguments:

    Nothing.

Return:

    A LICENSE_STATUS return code.

--*/


LICENSE_STATUS
LsCsp_Initialize( void )
{
    DWORD   Status = LICENSE_STATUS_OK;
    DWORD   dwResult, dwDisp;

    if( InterlockedIncrement( &csp_InitCount ) > 1 )
    {
        //
        // already initialized
        //

        return( LICENSE_STATUS_OK );
    }

    //
    // Create a global mutex for sync.
    //
    csp_hMutex = CreateMutex(
                            NULL,
                            FALSE,
                            NULL
                        );

    if(NULL == csp_hMutex)
    {

#if DBG
    DbgPrint("LSCSP: CreateMutex() failed with error code %d\n", GetLastError());
#endif

        Status = LICENSE_STATUS_OUT_OF_MEMORY;
        goto ErrorExit;
    }

    //
    // initialize the Hydra Server Root Public key.
    //
    csp_pRootPublicKey = (LPBSAFE_PUB_KEY)csp_abPublicKeyModulus;
    csp_pRootPublicKey->magic = RSA1;
    csp_pRootPublicKey->keylen = 0x48;
    csp_pRootPublicKey->bitlen = 0x0200;
    csp_pRootPublicKey->datalen = 0x3f;
    csp_pRootPublicKey->pubexp = 0xc0887b5b;

#if DBG
#ifdef DUMP
    DbgPrint("Data0\n");
    LsCsp_DumpBinaryData( (LPBYTE)csp_pRootPublicKey, 92 );
#endif
#endif

    //
    // Initialize the proprietory certificate with the built in certificate
    //

    if( !LsCsp_UseBuiltInCert() )
    {
        Status = LICENSE_STATUS_NO_CERTIFICATE;
        goto ErrorExit;
    }

    //
    // Unpack and Validate the certificate
    //
    try {
        if (!LsCsp_UnpackServerCert(
                     csp_abServerCertificate,
                     csp_dwServerCertificateLen,
                     &csp_hscData )) {
            Status = LICENSE_STATUS_INVALID_CERTIFICATE;
            goto ErrorExit;
        }
        if (!LsCsp_ValidateServerCert( &csp_hscData )) {
            Status = LICENSE_STATUS_INVALID_CERTIFICATE;
        }
    } except( EXCEPTION_EXECUTE_HANDLER ) {
#if DBG
    DbgPrint("LSCSP: LsCsp_Initialize bad cert data!\n");
#endif
        Status = LICENSE_STATUS_INVALID_CERTIFICATE;
    }

    Status = ReloadCSPCertificateAndData();

    if (LICENSE_STATUS_NO_CERTIFICATE == Status)
    {
        //
        // No X509 certificate.  Not a failure, as the discovery 
        // thread will soon install it.
        //

        Status = LICENSE_STATUS_OK;
    }
    else if(LICENSE_STATUS_OUT_OF_MEMORY == Status)
    {
        //
        // out of memory at initialization time, 
        // this is critical error
        //
        goto ErrorExit;
    }

    //
    // Let initalization go thru if it can retrieve 
    // private key from LSA, this is OK since we will try to install
    // certificate again in LsCsp_InstallX509Certificate()
    //
    Status = LICENSE_STATUS_OK;
    goto i_done;

ErrorExit:

    LsCsp_Exit();

i_done:

    return( Status );
}


/*++

Function:

    LsCsp_Exit

Description:

    Free all resources used by this library.

Arguments:

    Nothing.

Return:

    A LICENSE_STATUS return code.

--*/

VOID LsCsp_Exit( void )
{
    if( InterlockedDecrement( &csp_InitCount ) > 0 )
    {
        //
        // someone is still using it.
        //

        return;
    }

    if ( csp_abServerPrivateKey)
    {
        LocalFree( csp_abServerPrivateKey );
    }
    csp_abServerPrivateKey = NULL;

    if ( csp_abServerCertificate )
    {
        LocalFree( csp_abServerCertificate );
    }
    csp_abServerCertificate = NULL;

    if( csp_abServerX509Cert )
    {
        LocalFree( csp_abServerX509Cert );
    }
    csp_abServerX509Cert = NULL;

    if( csp_abX509CertPrivateKey )
    {
        LocalFree( csp_abX509CertPrivateKey );
    }
    csp_abX509CertPrivateKey = NULL;

    if( csp_abX509CertID )
    {
        LocalFree( csp_abX509CertID );
    }
    csp_abX509CertID = NULL;

    if( csp_hMutex )
    {
        CloseHandle( csp_hMutex );
    }
    csp_hMutex = NULL;

    return;
}


/*++

Function:

   LsCsp_GetServerData

Routine Description:

   This function makes and return the microsoft terminal server certificate
   blob of data.

Arguments:

   dwInfoDesired - What type of information to return.

   pBlob - pointer to a location where the certificate blob data
   pointer is returned.

   pdwServerCertLen - pointer to a location where the length of the above data
   is returned.

Return Value:

   Windows Error Code.

--*/

LICENSE_STATUS
LsCsp_GetServerData(
    LSCSPINFO   Info,
    LPBYTE      pBlob,
    LPDWORD     pdwBlobLen
    )
{
    LICENSE_STATUS Status = LICENSE_STATUS_OK;
    DWORD  dwDataLen;
    LPBYTE pbData;

    ASSERT( pdwBlobLen != NULL );

    if ((Info == LsCspInfo_PrivateKey) || (Info == LsCspInfo_X509CertPrivateKey))
    {
        if (!IsSystemService())
        {
            return LICENSE_STATUS_NO_PRIVATE_KEY;
        }
    }

    ACQUIRE_EXCLUSIVE_ACCESS(csp_hMutex);

    switch (Info) {
    case LsCspInfo_Certificate:

        if( NULL == csp_abServerCertificate )
        {
            Status = LICENSE_STATUS_NO_CERTIFICATE;
            goto gsd_done;
        }

        pbData = csp_abServerCertificate;
        dwDataLen = csp_dwServerCertificateLen;
        break;

    case LsCspInfo_X509Certificate:

        //
        // We may not have an X509 certificate if the hydra server has not
        // requested one from the license server
        //

        if( NULL == csp_abServerX509Cert )
        {
            Status = LICENSE_STATUS_NO_CERTIFICATE;
            goto gsd_done;
        }

        pbData = csp_abServerX509Cert;
        dwDataLen = csp_dwServerX509CertLen;
        break;

    case LsCspInfo_X509CertID:

        //
        // we will not have a certificate ID if the X509 certificate is not present
        //

        if( NULL == csp_abX509CertID )
        {
            Status = LICENSE_STATUS_NO_CERTIFICATE;
            goto gsd_done;
        }

        pbData = csp_abX509CertID;
        dwDataLen = csp_dwX509CertIDLen;
        break;

    case LsCspInfo_PublicKey:
        pbData = csp_hscData.PublicKeyData.pBlob;
        dwDataLen = csp_hscData.PublicKeyData.wBlobLen;
        break;

    case LsCspInfo_PrivateKey:
        if( NULL == csp_abServerPrivateKey )
        {
            Status = LICENSE_STATUS_NO_PRIVATE_KEY;
            goto gsd_done;
        }

        pbData = csp_abServerPrivateKey;
        dwDataLen = csp_dwServerPrivateKeyLen;
        break;

    case LsCspInfo_X509CertPrivateKey:
        
        //
        // The X509 certificate private key may not have been created.
        //

        if( NULL == csp_abX509CertPrivateKey )
        {
            Status = LICENSE_STATUS_NO_PRIVATE_KEY;
            goto gsd_done;
        }

        pbData = csp_abX509CertPrivateKey;
        dwDataLen = csp_dwX509CertPrivateKeyLen;
        break;

    default:
        Status = LICENSE_STATUS_INVALID_INPUT;
        goto gsd_done;
    }

    if (pBlob != NULL) {
        if (*pdwBlobLen < dwDataLen) {
            *pdwBlobLen = dwDataLen;
            Status = LICENSE_STATUS_INSUFFICIENT_BUFFER;
        } else {
            memcpy(pBlob, pbData, dwDataLen);
            *pdwBlobLen = dwDataLen;
        }
    } else {
        *pdwBlobLen = dwDataLen;
    }

gsd_done:

    RELEASE_EXCLUSIVE_ACCESS( csp_hMutex ); 


    return( Status );
}

/*++

Function:

    LsCsp_ReadProprietaryDataFromStorage

Description:

    Read proprietary public/private info from registry/LSA secret
    
Arguments:

    None.
    
Return:

    LICENSE_STATUS
        
--*/

LICENSE_STATUS
LsCsp_ReadProprietaryDataFromStorage(PBYTE *ppbCert,
                                     DWORD *pcbCert,
                                     PBYTE *ppbPrivateKey,
                                     DWORD *pcbPrivateKey)
{
    LICENSE_STATUS Status;
    HKEY hKey = NULL;
    DWORD dwDisp;

    *ppbCert = *ppbPrivateKey = NULL;
    *pcbCert = *pcbPrivateKey = 0;

    //
    // Open the Registry
    //

    if( RegCreateKeyEx(
                       HKEY_LOCAL_MACHINE,
                       TEXT( HYDRA_CERT_REG_KEY ),
                       0,
                       NULL,
                       REG_OPTION_NON_VOLATILE,
                       KEY_READ,
                       NULL,
                       &hKey,
                       &dwDisp ) != ERROR_SUCCESS )
    {
        Status = LICENSE_STATUS_NO_CERTIFICATE;
        goto done;
    }

    if ( RegQueryValueEx(
                         hKey,
                         TEXT( HYDRA_CERTIFICATE_VALUE ),
                         NULL,  // lpReserved
                         NULL,  // lpType
                         NULL,  // lpData
                         pcbCert) != ERROR_SUCCESS )
    {
        Status = LICENSE_STATUS_NO_CERTIFICATE;
        goto done;
    }

    Status = LsCsp_RetrieveSecret(PRIVATE_KEY_NAME,
                                  NULL, // pbKey
                                  pcbPrivateKey);

    if (LICENSE_STATUS_OK != Status)
    {
        goto done;
    }

    *ppbCert = ( LPBYTE )LocalAlloc(LPTR,*pcbCert);

    if (NULL == *ppbCert)
    {
        Status = LICENSE_STATUS_OUT_OF_MEMORY;
        goto done;
    }

    *ppbPrivateKey = ( LPBYTE )LocalAlloc(LPTR,*pcbPrivateKey);
    if (NULL == *ppbPrivateKey)
    {
        Status = LICENSE_STATUS_OUT_OF_MEMORY;
        goto done;
    }

    if ( RegQueryValueEx(
                         hKey,
                         TEXT( HYDRA_CERTIFICATE_VALUE ),
                         NULL,  // lpReserved
                         NULL,  // lpType
                         *ppbCert,
                         pcbCert) != ERROR_SUCCESS )
    {
        Status = LICENSE_STATUS_NO_CERTIFICATE;
        goto done;
    }

    Status = LsCsp_RetrieveSecret(PRIVATE_KEY_NAME,
                                  *ppbPrivateKey,
                                  pcbPrivateKey);

done:
    if (NULL != hKey)
        RegCloseKey(hKey);

    if (Status != LICENSE_STATUS_OK)
    {
        if (NULL != *ppbCert)
        {
            LocalFree(*ppbCert);
            *ppbCert = NULL;
            *pcbCert = 0;
        }

        if (NULL != *ppbPrivateKey)
        {
            LocalFree(*ppbPrivateKey);
            *ppbPrivateKey = NULL;
            *pcbPrivateKey = 0;
        }
    }

    return Status;
}


/*++

Function:

    LsCsp_UseBuiltInCert

Description:

    Initialize the global variables with hardcoded certificate.
    
Arguments:

    None.
    
Return:

    TRUE if the initialization is successful.
        
--*/

BOOL
LsCsp_UseBuiltInCert( void )
{
    LICENSE_STATUS Status;

    ACQUIRE_EXCLUSIVE_ACCESS(csp_hMutex);

    //
    // Step 1, cleanup and initialization that happened
    //
    if (csp_abServerPrivateKey)
    {
        LocalFree( csp_abServerPrivateKey );
        csp_abServerPrivateKey = NULL;
    }

    if (csp_abServerCertificate)
    {
        LocalFree( csp_abServerCertificate );
        csp_abServerCertificate = NULL;
    }

    //
    // Step 2, check for stored key and certificate
    //
    Status = LsCsp_ReadProprietaryDataFromStorage(&csp_abServerCertificate, &csp_dwServerCertificateLen,&csp_abServerPrivateKey, &csp_dwServerPrivateKeyLen);

    if (LICENSE_STATUS_OK != Status)
    {
        PBYTE pbPrivateKey, pbCertificate;
        DWORD cbPrivateKey, cbCertificate;

        //
        // Step 3, if no stored info found, generate new info and store it
        //
        
        Status = CreateProprietaryKeyAndCert(&pbPrivateKey,&cbPrivateKey,&pbCertificate,&cbCertificate);
        
        if (LICENSE_STATUS_OK == Status)
        {
            LsCsp_SetServerData(LsCspInfo_PrivateKey,pbPrivateKey,cbPrivateKey);

            LsCsp_SetServerData(LsCspInfo_Certificate,pbCertificate,cbCertificate);
        }
    }

    RELEASE_EXCLUSIVE_ACCESS( csp_hMutex ); 
        
    return( Status == LICENSE_STATUS_OK );
}


/*++

Function:

    LsCsp_InstallX509Certificate

Routine Description:

   This function generates a private/public key pair and then finds a 
   license server to issue an X509 certificate for the public key.
   It then stores the private key and certificate.

Arguments:

   None.

Return Value:

   LSCSP return code.

--*/


LICENSE_STATUS
LsCsp_InstallX509Certificate(LPVOID lpParam)
{
    DWORD
        cbPubKey,
        cbPrivKey,
        cbCertificate;
    LICENSE_STATUS
        Status;
    LPBYTE
        pbPubKey = NULL,
        pbPrivKey = NULL,
        pbCertificate = NULL;
    CERT_PUBLIC_KEY_INFO   
        CapiPubKeyInfo;
    HWID
        Hwid;
    TLS_HANDLE
        hServer;

    //
    // before we go through the trouble of generating private and public
    // keys, check if the license server is available.
    //

    hServer = TLSConnectToAnyLsServer(LS_DISCOVERY_TIMEOUT);
    if (NULL == hServer)
    {
        return( LICENSE_STATUS_NO_LICENSE_SERVER );
    }

    memset(&CapiPubKeyInfo, 0, sizeof(CapiPubKeyInfo));

    //
    // acquire exclusive access
    //

    ACQUIRE_EXCLUSIVE_ACCESS(csp_hMutex);

    //
    // Try to reload the certificate again, some other thread might have
    // install the certificate already.
    //

    Status = ReloadCSPCertificateAndData();
    if( LICENSE_STATUS_OK == Status )
    {
        goto done;
    }

    //
    // Generate a private/public key pair
    //

    Status = GenerateRsaKeyPair( 
                        &pbPubKey, 
                        &cbPubKey, 
                        &pbPrivKey, 
                        &cbPrivKey, 
                        RSA_KEY_LEN );
    
    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LSCSP: LsCsp_InstallX509Certificate: cannot generate RSA keypair\n" );
#endif

        goto done;
    }

    //
    // convert the Bsafe public key into a CAPI public key
    //

    Status = Bsafe2CapiPubKey( &CapiPubKeyInfo, pbPubKey, cbPubKey );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LSCSP: LsCsp_InstallX509Certificate: cannot convert Bsafe Key to CAPI key\n" );
#endif
        goto done;
    }

    //
    // generate a new hardware ID
    //

    Status = GenerateMachineHWID( &Hwid );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LSCSP: LsCsp_InstallX509Certificate: cannot generate certificate ID\n" );
#endif
        goto done;
    }

    //
    // sends the certificate request to the license server
    //

    Status = RequestCertificate( hServer, &CapiPubKeyInfo, &pbCertificate, &cbCertificate, &Hwid );

    TLSDisconnectFromServer( hServer );
    hServer = NULL;

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LSCSP: LsCsp_InstallX509Certificate: error requesting terminal server certificate: %x\n", Status );
#endif
        goto done;
    }

    //
    // store the certificate identifier
    //
    
    Status = LsCsp_SetServerData( 
                        LsCspInfo_X509CertID, 
                        ( LPBYTE )&Hwid, 
                        sizeof( Hwid ) );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LSCSP: LsCsp_InstallX509Certificate: cannot store terminal server certificate ID : %d\n", Status );
#endif
        goto done;
    }
 
    //
    // Stores the certificate and resets the global variable pointing
    // to the X509 certificate.
    //

    Status = LsCsp_SetServerData( 
                        LsCspInfo_X509Certificate, 
                        pbCertificate, 
                        cbCertificate );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LSCSP: LsCsp_InstallX509Certificate: cannot store terminal server certificate : %d\n", Status );
#endif
        goto done;
    }

    //
    // Stores the private key and resets the global variable pointing to the
    // private key.
    //

    Status = LsCsp_SetServerData(
                        LsCspInfo_X509CertPrivateKey,
                        pbPrivKey,
                        cbPrivKey );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LSCSP: LsCsp_InstallX509Certificate: cannot store terminal server private key %d\n", Status );
#endif
        goto done;
    }

    //
    // Store the public key so we can verify at startup time
    //
    
    Status = LsCsp_StoreSecret(
                        X509_CERT_PUBLIC_KEY_NAME,
                        pbPubKey,
                        cbPubKey
                    );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LSCSP: LsCsp_InstallX509Certificate: cannot store terminal server public key : %d\n", Status );
#endif
    }


done:

    if (NULL != hServer)
    {
        TLSDisconnectFromServer( hServer );
        hServer = NULL;
    }

    //
    // release exclusive access
    //

    RELEASE_EXCLUSIVE_ACCESS( csp_hMutex ); 


    if( pbCertificate )
    {
        LocalFree(pbCertificate);
    }

    if( pbPrivKey )
    {
        LocalFree( pbPrivKey );
    }

    if( pbPubKey )
    {
        LocalFree( pbPubKey );
    }

    FreeCapiPubKey( &CapiPubKeyInfo );

    return( Status );
}


/*++

Function:

    RequestCertificate

Routine Description:

    Request a certificate from the license server

Arguments:

    hServer - handle to license server
    pPubKeyInfo - The public key info to be included in the certificate
    ppbCertificate - The new certificate
    pcbCertificate - size of the certificate
    pHwid - The hardware ID that is used to identify the certificate

Return:

    LICENSE_STATUS return code

--*/

LICENSE_STATUS
RequestCertificate(     
    TLS_HANDLE              hServer,
    PCERT_PUBLIC_KEY_INFO   pPubKeyInfo,
    LPBYTE *                ppbCertificate,
    LPDWORD                 pcbCertificate,
    HWID *                  pHwid )
{
    LSHydraCertRequest
        CertRequest;
    LICENSE_STATUS
        Status;
    DWORD
        dwRpcCode,
        dwResult,
        cbChallengeData;
    LPBYTE
        pbChallengeData = NULL;

    if( ( NULL == ppbCertificate ) || 
        ( NULL == hServer ) || 
        ( NULL == pPubKeyInfo ) || 
        ( NULL == pcbCertificate ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    *ppbCertificate = NULL;
    *pcbCertificate = 0;

    memset( &CertRequest, 0, sizeof( CertRequest ) );

    CertRequest.dwHydraVersion = 0x00050000;
    
    LsCsp_EncryptHwid( pHwid, NULL, &CertRequest.cbEncryptedHwid );

    CertRequest.pbEncryptedHwid = LocalAlloc( LPTR, CertRequest.cbEncryptedHwid );

    if( NULL == CertRequest.pbEncryptedHwid )
    {
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    Status = LsCsp_EncryptHwid( 
                    pHwid, 
                    CertRequest.pbEncryptedHwid, 
                    &CertRequest.cbEncryptedHwid );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }
    
    //
    // get the subject RDN
    //

    Status = GetSubjectRdn( &CertRequest.szSubjectRdn );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    CertRequest.SubjectPublicKeyInfo = pPubKeyInfo;

    //
    // request an X509 certificate from the license server
    //

    dwRpcCode = TLSRequestTermServCert(hServer,
                                       &CertRequest,
                                       &cbChallengeData,
                                       &pbChallengeData,
                                       &dwResult );

    if( ( RPC_S_OK != dwRpcCode ) || ( LSERVER_S_SUCCESS != dwResult ) )
    {
        Status = LICENSE_STATUS_CERTIFICATE_REQUEST_ERROR;
        goto done;
    }

    dwRpcCode = TLSRetrieveTermServCert(
                            hServer,
                            cbChallengeData,
                            pbChallengeData,
                            pcbCertificate,
                            ppbCertificate,
                            &dwResult );


    if( ( RPC_S_OK != dwRpcCode ) || ( LSERVER_ERROR_BASE <= dwResult ) )
    {

        Status = LICENSE_STATUS_CERTIFICATE_REQUEST_ERROR;
    }

done:

    if( CertRequest.pbEncryptedHwid )
    {
        LocalFree( CertRequest.pbEncryptedHwid );
    }

    if( CertRequest.szSubjectRdn )
    {
        LocalFree( CertRequest.szSubjectRdn );
    }

    if( pbChallengeData )
    {
        LocalFree( pbChallengeData );
    }

    return( Status );
}


/*++

Function:

    GetSubjectRdn

Routine Description:

    Construct the subject RDN for a certificate request

Argument:

    ppSubjectRdn - Return pointer to the subject RDN

Return:

    LICENSE_STATUS_OK if successful or a LICENSE_STATUS error code.

--*/

LICENSE_STATUS
GetSubjectRdn(
    LPTSTR   * ppSubjectRdn )
{
    TCHAR
        ComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    DWORD
        RdnLen = 0,
        ComputerNameLen = MAX_COMPUTERNAME_LENGTH + 1;

    //
    // use the computer name uas the common name
    //

    GetComputerName( ComputerName, &ComputerNameLen );

    RdnLen += wcslen( TEXT( RDN_COMMON_NAME ) );
    RdnLen += ComputerNameLen + 1;
    RdnLen = RdnLen * sizeof( TCHAR );

    *ppSubjectRdn = LocalAlloc( LPTR, RdnLen );

    if( NULL == *ppSubjectRdn )
    {
        return( LICENSE_STATUS_OUT_OF_MEMORY );
    }

    wsprintf( *ppSubjectRdn, L"%s%s", TEXT( RDN_COMMON_NAME ), ComputerName );
    
    return( LICENSE_STATUS_OK );
}


/*++

Function:

    GenerateMachineHWID

Routine Description:

    Generate a hardware ID for this machine

Arguments:

    pHwid - Return value of the HWID

Return:

    LICENSE_STATUS_OK if successful or a LICENSE_STATUS error code

--*/

LICENSE_STATUS
GenerateMachineHWID(
    PHWID    pHwid )    
{
    
    OSVERSIONINFO 
        osvInfo;
    DWORD
        cbCertId;
    LPBYTE
        pbCertId = NULL;

    if( NULL == pHwid )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // Create the HWID
    //

    memset( &osvInfo, 0, sizeof( OSVERSIONINFO ) );
    osvInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
    GetVersionEx( &osvInfo );

    pHwid->dwPlatformID = osvInfo.dwPlatformId;

    GenerateRandomBits( ( LPBYTE )&( pHwid->Data1 ), sizeof( DWORD ) );
    GenerateRandomBits( ( LPBYTE )&( pHwid->Data2 ), sizeof( DWORD ) );
    GenerateRandomBits( ( LPBYTE )&( pHwid->Data3 ), sizeof( DWORD ) );
    GenerateRandomBits( ( LPBYTE )&( pHwid->Data4 ), sizeof( DWORD ) );

    return( LICENSE_STATUS_OK );
}


/*++

Function:

    LsCsp_EncryptHwid

Routine Description:

    Encrypt the given hardward ID using the secret key shared by terminal
    and license servers.
    
Arguments:

    pHwid - The Hardware ID
    pbEncryptedHwid - The encrypted HWID
    pcbEncryptedHwid - Length of the encrypted HWID

Return:

    LICENSE_STATUS_OK if successful or a LICENSE_STATUS error code otherwise.

--*/

LICENSE_STATUS
LsCsp_EncryptHwid(
    PHWID       pHwid,
    LPBYTE      pbEncryptedHwid,
    LPDWORD     pcbEncryptedHwid )
{
    LICENSE_STATUS
        Status;
    LPBYTE 
        pbSecretKey = NULL;
    DWORD
        cbSecretKey = 0;

    if( NULL == pcbEncryptedHwid )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    if( ( NULL == pbEncryptedHwid ) || 
        ( sizeof( HWID ) > *pcbEncryptedHwid ) )
    {
        *pcbEncryptedHwid = sizeof( HWID );
        return( LICENSE_STATUS_INSUFFICIENT_BUFFER );
    }

    LicenseGetSecretKey( &cbSecretKey, NULL );

    pbSecretKey = LocalAlloc( LPTR, cbSecretKey );

    if( NULL == pbSecretKey )
    {
        return( LICENSE_STATUS_OUT_OF_MEMORY );
    }

    //
    // Get the secret key used for encrypting the HWID
    //

    Status = LicenseGetSecretKey( &cbSecretKey, pbSecretKey );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    Status = LicenseEncryptHwid(
                    pHwid,
                    pcbEncryptedHwid,
                    pbEncryptedHwid,
                    cbSecretKey,
                    pbSecretKey );

done:

    if( pbSecretKey )
    {
        LocalFree( pbSecretKey );
    }

    return( Status );

}


/*++

Function:

    LsCsp_DecryptHwid

Routine Description:

    Decrypt the given hardware ID

Arguments:

    pHwid - The decrypted hardware ID
    pbEncryptedHwid - The encrypted hardware ID
    cbEncryptedHwid - Length of the encrypted hardware ID

Return:

    LICENSE_STATUS_OK if successful or a LICENSE_STATUS error code.

--*/

LICENSE_STATUS
LsCsp_DecryptHwid(
    PHWID       pHwid,
    LPBYTE      pbEncryptedHwid,
    LPDWORD     pcbEncryptedHwid )
{
    return( LICENSE_STATUS_OK );
}


/*++

Function:

    LsCsp_StoreSecret

Description:

    Use LSA to store a secret private key.

Arguments:

    ptszKeyName - Name used to identify the secret private key.
    pbKey - Points to the secret private key.
    cbKey - Length of the private key.

Return:

    A LICENSE_STATUS return code.

--*/

LICENSE_STATUS
LsCsp_StoreSecret(
    PTCHAR  ptszKeyName,
    BYTE *  pbKey,
    DWORD   cbKey )
{
    LSA_HANDLE 
        PolicyHandle;
    UNICODE_STRING 
        SecretKeyName;
    UNICODE_STRING 
        SecretData;
    DWORD 
        Status;
    
    if( ( NULL == ptszKeyName ) || ( 0xffff < cbKey) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // setup the UNICODE_STRINGs for the call.
    //
    
    InitLsaString( &SecretKeyName, ptszKeyName );

    SecretData.Buffer = ( LPWSTR )pbKey;
    SecretData.Length = ( USHORT )cbKey;
    SecretData.MaximumLength = ( USHORT )cbKey;

    Status = OpenPolicy( NULL, POLICY_CREATE_SECRET, &PolicyHandle );

    if( ERROR_SUCCESS != Status )
    {
        return ( LICENSE_STATUS_CANNOT_OPEN_SECRET_STORE );
    }

    Status = LsaStorePrivateData(
                PolicyHandle,
                &SecretKeyName,
                &SecretData
                );

    LsaClose( PolicyHandle );

    Status = LsaNtStatusToWinError( Status );

    if( ERROR_SUCCESS != Status )
    {
        return( LICENSE_STATUS_CANNOT_STORE_SECRET );
    }
    
    return( LICENSE_STATUS_OK );
}


/*++

Function:

    LsCsp_RetrieveSecret

Description:

    Retrieve the secret private key that is stored by LSA.

Arguments:

    ptszKeyName - The name used to identify the secret private key.
    ppbKey - Return value of the private key
    pcbKey - Length of the private key.

Return:

    A LICENSE_STATUS return code.

--*/

LICENSE_STATUS
LsCsp_RetrieveSecret(
    PTCHAR      ptszKeyName,
    PBYTE       pbKey,
    DWORD *     pcbKey )
{
    LSA_HANDLE 
        PolicyHandle;
    UNICODE_STRING 
        SecretKeyName;
    UNICODE_STRING * 
        pSecretData = NULL;
    DWORD 
        Status;
    LICENSE_STATUS
        LicenseStatus = LICENSE_STATUS_OK;

    if( ( NULL == ptszKeyName ) || ( NULL == pcbKey ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // setup the UNICODE_STRINGs for the call.
    //

    InitLsaString( &SecretKeyName, ptszKeyName );

    Status = OpenPolicy( NULL, POLICY_GET_PRIVATE_INFORMATION, &PolicyHandle );

    if( ERROR_SUCCESS != Status )
    {
#if DBG
        DbgPrint( "LSCSP: cannot open LSA policy handle: %x\n", Status );
#endif
        return( LICENSE_STATUS_CANNOT_OPEN_SECRET_STORE );
    }

    Status = LsaNtStatusToWinError( LsaRetrievePrivateData(
                                            PolicyHandle,
                                            &SecretKeyName,
                                            &pSecretData ) );

    LsaClose( PolicyHandle );

    if (( ERROR_SUCCESS != Status ) || (NULL == pSecretData) || (pSecretData->Length == 0))
    {
#if DBG
        DbgPrint( "LSCSP: cannot retrieve LSA data: %x\n", Status );
#endif
        return( LICENSE_STATUS_CANNOT_RETRIEVE_SECRET );
    }

    if( NULL == pbKey )
    {
        *pcbKey = pSecretData->Length;
    }
    else
    {
        if( pSecretData->Length > *pcbKey )
        {
            LicenseStatus = LICENSE_STATUS_INSUFFICIENT_BUFFER;
        }
        else
        {
            CopyMemory( pbKey, pSecretData->Buffer, pSecretData->Length );
        }

        *pcbKey = pSecretData->Length;
    }

    ZeroMemory( pSecretData->Buffer, pSecretData->Length );
    LsaFreeMemory( pSecretData );

    return( LicenseStatus );
}


/*++

Function:

    OpenPolicy

Description:

    Obtain an LSA policy handle used to perform subsequent LSA operations.

Arguments:

    ServerName - The server which the handle should be obtained from.
    DesiredAccess - The access given to the handle
    PolicyHandle - The policy handle

Return:

    A Win32 return code.

--*/

NTSTATUS
OpenPolicy(
    LPWSTR ServerName,
    DWORD DesiredAccess,
    PLSA_HANDLE PolicyHandle )
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server;

    //
    // Always initialize the object attributes to all zeroes.
    //
 
    ZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    if( NULL != ServerName ) 
    {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //

        InitLsaString(&ServerString, ServerName);
        Server = &ServerString;

    } 
    else 
    {
        Server = NULL;
    }

    //
    // Attempt to open the policy.
    //
    
    return( LsaNtStatusToWinError( LsaOpenPolicy(
                                            Server,
                                            &ObjectAttributes,
                                            DesiredAccess,
                                            PolicyHandle ) ) );
}


/*++

Function:

    InitLsaString

Description:

    Initialize a UNICODE string to LSA UNICODE string format.

Arguments:

    LsaString - the LSA UNICODE string.
    String - UNICODE string

Return:

    Nothing.

--*/

void
InitLsaString(
    PLSA_UNICODE_STRING LsaString,
    LPWSTR String )
{
    DWORD StringLength;

    if( NULL == String ) 
    {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = lstrlenW( String );
    LsaString->Buffer = String;
    LsaString->Length = ( USHORT ) StringLength * sizeof( WCHAR );
    LsaString->MaximumLength=( USHORT )( StringLength + 1 ) * sizeof( WCHAR );
}


/*++

Function:

    LsCsp_SetServerData

Description:

    Saves the specified data.

Arguments:

    Info - The data type of the data to be saved.
    pBlob - Points to the data to be saved.
    dwBlobLen - Length of the data to be saved.

Return:

    A LICENSE_STATUS return code.

--*/

LICENSE_STATUS
LsCsp_SetServerData(
    LSCSPINFO   Info,
    LPBYTE      pBlob,
    DWORD       dwBlobLen )
{
    LICENSE_STATUS
        Status = LICENSE_STATUS_OK;
    DWORD
        dwResult,
        dwDisp,
        * pdwCspDataLen;
    LPTSTR
        lpRegValue;
    PWCHAR
        pwszKeyName;
    LPBYTE *
        ppCspData;
    HKEY
        hKey = NULL;

    ASSERT( dwBlobLen != 0 );
    ASSERT( pBlob != NULL );

    ACQUIRE_EXCLUSIVE_ACCESS(csp_hMutex);

        
    switch (Info) {

    case LsCspInfo_Certificate:

        //
        // set proprietory certificate data
        //

        lpRegValue = TEXT( HYDRA_CERTIFICATE_VALUE );
        ppCspData = &csp_abServerCertificate;
        pdwCspDataLen = &csp_dwServerCertificateLen;

        break;

    case LsCspInfo_X509Certificate:

        //
        // set X509 certificate data
        //

        lpRegValue = TEXT( HYDRA_X509_CERTIFICATE );
        ppCspData = &csp_abServerX509Cert;
        pdwCspDataLen = &csp_dwServerX509CertLen;

        break;
    
    case LsCspInfo_PrivateKey:

        //
        // set the private key that corresponds to the proprietory certificate
        //

        pwszKeyName = PRIVATE_KEY_NAME;
        ppCspData = &csp_abServerPrivateKey;
        pdwCspDataLen = &csp_dwServerPrivateKeyLen;

        break;

    case LsCspInfo_X509CertPrivateKey:

        //
        // set private key that corresponds to the X509 certificate
        //

        pwszKeyName = X509_CERT_PRIVATE_KEY_NAME;
        ppCspData = &csp_abX509CertPrivateKey;
        pdwCspDataLen = &csp_dwX509CertPrivateKeyLen;

        break;

    case LsCspInfo_X509CertID:

        //
        // Set the X509 certificate ID
        //

        lpRegValue = TEXT( HYDRA_X509_CERT_ID );
        ppCspData = &csp_abX509CertID;
        pdwCspDataLen = &csp_dwX509CertIDLen;

        break;

    default:

        Status = LICENSE_STATUS_INVALID_INPUT;
        goto i_done;
    }

    if( ( LsCspInfo_X509CertPrivateKey == Info ) ||
        ( LsCspInfo_PrivateKey == Info ) )
    {
        //
        // store secret key information
        //

        dwResult = LsCsp_StoreSecret( pwszKeyName, pBlob, dwBlobLen );

        if( ERROR_SUCCESS != dwResult )
        {
            Status = LICENSE_STATUS_WRITE_STORE_ERROR;
            goto i_done;
        }                   
    }
    else
    {
        //
        // Open the Registry
        //

        if( RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,
                    TEXT( HYDRA_CERT_REG_KEY ),
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_WRITE,
                    NULL,
                    &hKey,
                    &dwDisp ) != ERROR_SUCCESS )
        {
            Status = LICENSE_STATUS_WRITE_STORE_ERROR;
            goto i_done;
        }

        //
        // Sets the value in the registry
        //

        if( ERROR_SUCCESS != RegSetValueEx(
                                    hKey,
                                    lpRegValue,
                                    0,      
                                    REG_BINARY,
                                    pBlob,
                                    dwBlobLen ) )
        {
            Status = LICENSE_STATUS_WRITE_STORE_ERROR;
            goto i_done;
        }
    }
    
    //
    // reset the global data with the new data that we have just set
    //

    if ( *ppCspData )
    {
        LocalFree( *ppCspData );
    }
    
    *ppCspData = ( LPBYTE )LocalAlloc( LPTR, dwBlobLen );

    if( NULL == *ppCspData )
    {
        Status = LICENSE_STATUS_OUT_OF_MEMORY;
        goto i_done;
    }

    memcpy( *ppCspData, pBlob, dwBlobLen );
    *pdwCspDataLen = dwBlobLen;
    
i_done:

    RELEASE_EXCLUSIVE_ACCESS( csp_hMutex ); 


    if( hKey )
    {
        RegCloseKey( hKey );
    }

    return( Status );
}


/*++

Function:

    LsCsp_NukeServerData

Description:

    Permanently deletes the specified server data.

Arguments:

    Info - The type of data to nuke.

Returns:

    A LICENSE_STATUS return code.

--*/

LICENSE_STATUS
LsCsp_NukeServerData(
    LSCSPINFO   Info )
{
    LICENSE_STATUS
        Status = LICENSE_STATUS_OK; 
    LPTSTR
        lpRegValue;
    PWCHAR
        pwszKeyName;
    HKEY
        hKey = NULL;
    LPBYTE *
        ppCspData;
    DWORD * 
        pdwCspDataLen;
    DWORD
        dwResult;

    ACQUIRE_EXCLUSIVE_ACCESS(csp_hMutex);


    switch (Info) {

    case LsCspInfo_X509Certificate:

        //
        // delete X509 certificate data
        //

        lpRegValue = TEXT( HYDRA_X509_CERTIFICATE );
        ppCspData = &csp_abServerX509Cert;
        pdwCspDataLen = &csp_dwServerX509CertLen;

        break;
    
    case LsCspInfo_X509CertPrivateKey:

        //
        // delete the private key that corresponds to the X509 certificate
        //

        pwszKeyName = X509_CERT_PRIVATE_KEY_NAME;
        ppCspData = &csp_abX509CertPrivateKey;
        pdwCspDataLen = &csp_dwX509CertPrivateKeyLen;

        break;

    case LsCspInfo_X509CertID:

        //
        // delete the X509 certificate ID
        //

        lpRegValue = TEXT( HYDRA_X509_CERT_ID );
        ppCspData = &csp_abX509CertID;
        pdwCspDataLen = &csp_dwX509CertIDLen;

        break;

    default:

        Status = LICENSE_STATUS_INVALID_INPUT;
        goto i_done;        
    }

    if( (LsCspInfo_X509CertPrivateKey == Info ) ||
        ( LsCspInfo_PrivateKey == Info ) )
    {
        //
        // delete secret info stored by LSA
        //

        dwResult = LsCsp_StoreSecret( pwszKeyName, NULL, 0 );

        if( ERROR_SUCCESS != dwResult )
        {
            Status = LICENSE_STATUS_WRITE_STORE_ERROR;
            goto i_done;
        }                   
    }
    else
    {
        //
        // Delete the data kept in the registry
        //

        if( RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    TEXT( HYDRA_CERT_REG_KEY ),
                    0,
                    KEY_WRITE,
                    &hKey ) != ERROR_SUCCESS )
        {
            Status = LICENSE_STATUS_WRITE_STORE_ERROR;
            goto i_done;
        }

        //
        // Delete the value in the registry
        //

        if( ERROR_SUCCESS != RegDeleteValue( hKey, lpRegValue ) )  
        {
            Status = LICENSE_STATUS_WRITE_STORE_ERROR;
            goto i_done;
        }
    }

    if ( *ppCspData )
    {
        //
        // free the memory allocated for the global variable.
        //

        LocalFree( *ppCspData );
        *ppCspData = NULL;
        *pdwCspDataLen = 0;
    }
    
i_done:

    RELEASE_EXCLUSIVE_ACCESS( csp_hMutex ); 


    if( hKey )
    {
        RegCloseKey( hKey );
    }

    return( Status );
}


/*++

Function:

    GenerateKeyPair

Routine Description:

   This function generates a private/public key pair.

Arguments:

   ppbPublicKey - Return pointer to public Key
   pcbPublicKey - Size of public key
   ppbPrivateKey - Return pointer to private key
   pcbPrivateKey - size of private key
   dwKeyLen - Desired key length

Return Value:

   LICENSE_STATUS return code.

--*/

LICENSE_STATUS
GenerateRsaKeyPair(
    LPBYTE *     ppbPublicKey,
    LPDWORD      pcbPublicKey,
    LPBYTE *     ppbPrivateKey,
    LPDWORD      pcbPrivateKey,
    DWORD        dwKeyLen )
{
    DWORD
        dwBits = dwKeyLen;
    LICENSE_STATUS
        Status = LICENSE_STATUS_OK;

    *ppbPublicKey = NULL;
    *ppbPrivateKey = NULL;

    //
    // find out the size of the private and public key sizes and allocate
    // memory for them.
    //

    dwBits = BSafeComputeKeySizes( pcbPublicKey, pcbPrivateKey, &dwBits );

    *ppbPrivateKey = ( LPBYTE )LocalAlloc( LPTR, *pcbPrivateKey );

    if( NULL == *ppbPrivateKey )
    {
        Status = LICENSE_STATUS_OUT_OF_MEMORY;
        goto ErrorExit;
    }

    *ppbPublicKey = ( LPBYTE )LocalAlloc( LPTR, *pcbPublicKey );

    if( NULL == *ppbPublicKey )
    {
        Status = LICENSE_STATUS_OUT_OF_MEMORY;
        goto ErrorExit;
    }

    //
    // generate the private/public key pair
    //

    if( !BSafeMakeKeyPair( ( LPBSAFE_PUB_KEY )*ppbPublicKey,
                           ( LPBSAFE_PRV_KEY )*ppbPrivateKey,
                           dwKeyLen) )
    {
        Status = LICENSE_STATUS_CANNOT_MAKE_KEY_PAIR;
        goto ErrorExit;
    }

    return( Status ); 

ErrorExit:

    if( *ppbPublicKey )
    {
        LocalFree( *ppbPublicKey );
        *pcbPublicKey = 0;
        *ppbPublicKey = NULL;
    }

    if( *ppbPrivateKey )
    {
        LocalFree( *ppbPrivateKey );
        *pcbPrivateKey = 0;
        *ppbPrivateKey = NULL;
    }

    return( Status );
}


/*++

Function:

    Bsafe2CapiPubKey

Routine Description:

    Converts a Bsafe public key to a CAPI public key info structure

Arguments:

    pCapiPubKeyInfo - Pointer to the CAPI public key info structure
    pbBsafePubKey - Pointer to the Bsafe public key
    cbBsafePubKey - size of the Bsafe public key


Returns:

    LICENSE_STATUS return code.

--*/

LICENSE_STATUS
Bsafe2CapiPubKey(
    PCERT_PUBLIC_KEY_INFO   pCapiPubKeyInfo,
    LPBYTE                  pbBsafeKey,
    DWORD                   cbBsafeKey )
{
    PUBLICKEYSTRUC *
        pCapiPublicKey;
    RSAPUBKEY *
        pRsaPublicKey;
    LPBSAFE_PUB_KEY
        pBsafePubKey = ( LPBSAFE_PUB_KEY )pbBsafeKey;
    LPBYTE
        pbKeyMem = NULL,
        pbEncodedPubKey = NULL;
    DWORD
        cbKeyMem,
        dwError,
        cbEncodedPubKey = 0;
    LICENSE_STATUS
        Status;
    
    if( ( NULL == pbBsafeKey ) || ( 0 == cbBsafeKey ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    cbKeyMem = sizeof( PUBLICKEYSTRUC ) + sizeof( RSAPUBKEY ) + pBsafePubKey->keylen;
    pbKeyMem = ( LPBYTE )LocalAlloc( LPTR, cbKeyMem );

    if( NULL == pbKeyMem )
    {
        return( LICENSE_STATUS_OUT_OF_MEMORY );
    }

    //
    // convert the Bsafe public key to a crypto API public key structure.  
    // Note: make this a key exchange public key
    //

    pCapiPublicKey = ( PUBLICKEYSTRUC * )pbKeyMem;

    pCapiPublicKey->bType = PUBLICKEYBLOB;
    pCapiPublicKey->bVersion = CAPI_MAX_VERSION;
    pCapiPublicKey->reserved = 0;
    pCapiPublicKey->aiKeyAlg = CALG_RSA_KEYX;

    pRsaPublicKey = ( RSAPUBKEY * )( pbKeyMem + sizeof( PUBLICKEYSTRUC ) );
    
    pRsaPublicKey->magic = RSA1;
    pRsaPublicKey->bitlen = pBsafePubKey->bitlen;
    pRsaPublicKey->pubexp = pBsafePubKey->pubexp;

    memcpy( pbKeyMem + sizeof( PUBLICKEYSTRUC ) + sizeof( RSAPUBKEY ), 
            pbBsafeKey + sizeof( BSAFE_PUB_KEY ), 
            pBsafePubKey->keylen );

    //
    // encode the public key structure
    //

    __try
    {
        if( CryptEncodeObject( X509_ASN_ENCODING, RSA_CSP_PUBLICKEYBLOB , pbKeyMem, 
                               NULL, &cbEncodedPubKey ) )
        {
            pbEncodedPubKey = ( LPBYTE )LocalAlloc( LPTR, cbEncodedPubKey );

            if( NULL == pbEncodedPubKey )
            {
                Status = LICENSE_STATUS_OUT_OF_MEMORY;
                goto done;
            }

            memset( pbEncodedPubKey, 0, cbEncodedPubKey );

            if( !CryptEncodeObject( X509_ASN_ENCODING, RSA_CSP_PUBLICKEYBLOB , pbKeyMem, 
                                    pbEncodedPubKey, &cbEncodedPubKey ) )
            {
                Status = LICENSE_STATUS_ASN_ERROR;
                goto done;
            }    
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        DWORD dwExceptionCode = GetExceptionCode();

#if DBG
        DbgPrint( "LICECSP:  cannot encode server key pair: 0x%x\n", dwExceptionCode );
#endif
        Status = LICENSE_STATUS_ASN_ERROR;
        goto done;
    }

    //
    // now we can initialize the CAPI public key info structure
    //

    memset( pCapiPubKeyInfo, 0, sizeof( CERT_PUBLIC_KEY_INFO ) );
    
    pCapiPubKeyInfo->Algorithm.pszObjId = szOID_RSA_MD5RSA;
    pCapiPubKeyInfo->Algorithm.Parameters.cbData = 0;
    pCapiPubKeyInfo->Algorithm.Parameters.pbData = NULL;

    pCapiPubKeyInfo->PublicKey.cbData = cbEncodedPubKey;
    pCapiPubKeyInfo->PublicKey.pbData = pbEncodedPubKey;

    Status = LICENSE_STATUS_OK;

done:

    if( pbKeyMem )
    {
        LocalFree( pbKeyMem );
    }

    return( Status );
}


/*++

Function:

    FreeCapiPubKey

Routine Description:

    Free the memory in a capi pub key structure

Arguments:

    pCapiPubKeyInfo - Pointer to the CAPI public key info structure

Returns:

    Windows return code.

--*/

VOID
FreeCapiPubKey(
    PCERT_PUBLIC_KEY_INFO   pCapiPubKeyInfo )
{
    if( pCapiPubKeyInfo->Algorithm.Parameters.pbData )
    {
        LocalFree( pCapiPubKeyInfo->Algorithm.Parameters.pbData );
        pCapiPubKeyInfo->Algorithm.Parameters.pbData = NULL;
    }

    if( pCapiPubKeyInfo->PublicKey.pbData )
    {
        LocalFree( pCapiPubKeyInfo->PublicKey.pbData );
        pCapiPubKeyInfo->PublicKey.pbData = NULL;
    }

    return;
}

//////////////////////////////////////////////////////////////////

DWORD
VerifyTermServCertificate(
    DWORD cbCertLen,
    PBYTE pbCert,
    DWORD cbPrivateKeyLen,
    PBYTE pbPrivateKey
    )
/*++

Function :
    
    VerifyTermServCertificate

Routine Description:

    Verify TermSrv's X509 Certificate issued License Server, caller
    must protect this call with critical section or mutex.

Arguments:

    cbCertLen : size of TermSrv certificate.
    pbCertLen : Pointer to TermSrv certificate to be verify.
    cbPrivateKeyLen : Size of TermSrv private key.
    pbPrivateKey : pointer to TermSrv private key.

Returns:

    TRUE/FALSE

--*/
{
    LICENSE_STATUS dwStatus = LICENSE_STATUS_OK;
    PBYTE pbPublicKeyInLsa = NULL;
    DWORD cbPublicKeyInLsa = 0;

    PBYTE pbPublicKeyInCert = NULL;
    DWORD cbPublicKeyInCert = 0;
    DWORD pfDates;

    CERT_PUBLIC_KEY_INFO CapiPubKeyInfoLsa;
    CERT_PUBLIC_KEY_INFO CapiPubKeyInfoCert;


    if(0 == cbCertLen || NULL == pbCert || 0 == cbPrivateKeyLen || NULL == pbPrivateKey)
    {
        ASSERT( 0 != cbCertLen && NULL != pbCert && 0 != cbPrivateKeyLen && NULL != pbPrivateKey );
        return LICENSE_STATUS_INVALID_INPUT;
    }

    //
    // try except here is to prevent memory leak
    //
    __try {

        memset(&CapiPubKeyInfoLsa, 0, sizeof(CapiPubKeyInfoLsa));
        memset(&CapiPubKeyInfoCert, 0, sizeof(CapiPubKeyInfoCert));


        // 
        // Load the public key from LSA
        //
    
        dwStatus = LsCsp_RetrieveSecret(
                                X509_CERT_PUBLIC_KEY_NAME,
                                NULL,
                                &cbPublicKeyInLsa
                            );

        if( LICENSE_STATUS_OK != dwStatus || 0 == cbPublicKeyInLsa )
        {

            #if DBG
            DbgPrint( "LSCSP: VerifyTermServCertificate() No public key...\n" );
            #endif

            dwStatus = LICENSE_STATUS_CANNOT_RETRIEVE_SECRET;
            goto cleanup;
        }

        // allocate memory
        pbPublicKeyInLsa = (PBYTE)LocalAlloc(LPTR, cbPublicKeyInLsa);
        if(NULL == pbPublicKeyInLsa)
        {
            dwStatus = LICENSE_STATUS_OUT_OF_MEMORY;
            goto cleanup;
        }

        dwStatus = LsCsp_RetrieveSecret(
                                X509_CERT_PUBLIC_KEY_NAME,
                                pbPublicKeyInLsa,
                                &cbPublicKeyInLsa
                            );

        if( LICENSE_STATUS_OK != dwStatus || 0 == cbPublicKeyInLsa )
        {
            dwStatus = LICENSE_STATUS_CANNOT_RETRIEVE_SECRET;
            goto cleanup;
        }


        //
        // Verify certificate and compare public key
        //

        //
        // Try to avoid calling VerifyCertChain() twice.
        //
        cbPublicKeyInCert = 1024;
        pbPublicKeyInCert = (PBYTE)LocalAlloc(LPTR, cbPublicKeyInCert);
        if(NULL == pbPublicKeyInCert)
        {
            dwStatus = LICENSE_STATUS_OUT_OF_MEMORY;
            goto cleanup;
        }

        pfDates = CERT_DATE_DONT_VALIDATE;
        dwStatus = VerifyCertChain(
                                pbCert,
                                cbCertLen,
                                pbPublicKeyInCert,
                                &cbPublicKeyInCert,
                                &pfDates
                            );

        if(LICENSE_STATUS_OK != dwStatus && LICENSE_STATUS_INSUFFICIENT_BUFFER != dwStatus)   
        {

            #if DBG
            DbgPrint( "LSCSP: VerifyCertChain() failed with error code %d\n", dwStatus );
            #endif

            goto cleanup;
        }

        if( dwStatus == LICENSE_STATUS_INSUFFICIENT_BUFFER )
        {
            if( NULL != pbPublicKeyInCert )
            {
                LocalFree(pbPublicKeyInCert);
            }

            pbPublicKeyInCert = (PBYTE)LocalAlloc(LPTR, cbPublicKeyInCert);
            if(NULL == pbPublicKeyInCert)
            {
                dwStatus = LICENSE_STATUS_OUT_OF_MEMORY;
                goto cleanup;
            }

            pfDates = CERT_DATE_DONT_VALIDATE;
            dwStatus = VerifyCertChain(
                                    pbCert,
                                    cbCertLen,
                                    pbPublicKeyInCert,
                                    &cbPublicKeyInCert,
                                    &pfDates
                                );

            if(LICENSE_STATUS_OK != dwStatus)
            {
                goto cleanup;
            }
        }

        dwStatus = Bsafe2CapiPubKey(
                                &CapiPubKeyInfoCert, 
                                pbPublicKeyInCert, 
                                cbPublicKeyInCert 
                            );  

        if(LICENSE_STATUS_OK != dwStatus)
        {
            #if DBG
            DbgPrint( 
                    "LSCSP: Bsafe2CapiPubKey() on public key in certificate failed with %d\n", 
                    dwStatus
                );
            #endif

            goto cleanup;
        }

        dwStatus = Bsafe2CapiPubKey(
                                &CapiPubKeyInfoLsa, 
                                pbPublicKeyInLsa, 
                                cbPublicKeyInLsa 
                            );  

        if(LICENSE_STATUS_OK != dwStatus)
        {
            #if DBG
            DbgPrint( 
                    "LSCSP: Bsafe2CapiPubKey() on public key in LSA failed with %d\n", 
                    dwStatus
                );
            #endif

            goto cleanup;
        }


        //
        // compare public key
        //
        if( CapiPubKeyInfoCert.PublicKey.cbData != CapiPubKeyInfoLsa.PublicKey.cbData )
        {

            #if DBG
            DbgPrint( 
                    "LSCSP: public key length mismatched %d %d\n", 
                    CapiPubKeyInfoCert.PublicKey.cbData, 
                    CapiPubKeyInfoLsa.PublicKey.cbData 
                );
            #endif

            dwStatus = LICENSE_STATUS_INVALID_CERTIFICATE;
        }
        else if( memcmp(
                        CapiPubKeyInfoCert.PublicKey.pbData, 
                        CapiPubKeyInfoLsa.PublicKey.pbData, 
                        CapiPubKeyInfoLsa.PublicKey.cbData
                    ) != 0 )
        {

            #if DBG
            DbgPrint( "LSCSP: public mismatched\n" );
            #endif

            dwStatus = LICENSE_STATUS_INVALID_CERTIFICATE;
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
        dwStatus = LICENSE_STATUS_INVALID_INPUT;
    }

cleanup:

    FreeCapiPubKey( &CapiPubKeyInfoCert );
    FreeCapiPubKey( &CapiPubKeyInfoLsa );

    if( NULL != pbPublicKeyInLsa )
    {
        LocalFree( pbPublicKeyInLsa );
    }

    if( NULL != pbPublicKeyInCert )
    {
        LocalFree( pbPublicKeyInCert );
    }

    return dwStatus;
}

//////////////////////////////////////////////////////////////////

LICENSE_STATUS
ReloadCSPCertificateAndData()
{
    BOOL bSuccess;

    DWORD Status = LICENSE_STATUS_OK;
    LPBYTE i_csp_abServerX509Cert = NULL;
    DWORD  i_csp_dwServerX509CertLen = 0;
    
    DWORD i_csp_dwX509CertPrivateKeyLen = 0;
    LPBYTE i_csp_abX509CertPrivateKey = NULL;

    LPBYTE i_csp_abX509CertID = NULL;
    DWORD i_csp_dwX509CertIDLen = 0;

    HKEY    hKey = NULL;
    DWORD   dwResult, dwDisp;


    //
    // Acquire exclusive access
    //
    ACQUIRE_EXCLUSIVE_ACCESS( csp_hMutex );

    //
    // Prevent re-loading of same certificate/private key
    //
    if( NULL == csp_abServerX509Cert || 0 == csp_dwServerX509CertLen ||
        NULL == csp_abX509CertPrivateKey || 0 == csp_dwX509CertPrivateKeyLen || 
        NULL == csp_abX509CertID || 0 == csp_dwX509CertIDLen )
    {

        //
        // Open the Registry
        //
        if( RegCreateKeyEx(
                        HKEY_LOCAL_MACHINE,
                        TEXT( HYDRA_CERT_REG_KEY ),
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE,
                        NULL,
                        &hKey,
                        &dwDisp ) != ERROR_SUCCESS )
        {
            Status = LICENSE_STATUS_NO_CERTIFICATE;
        }
        else
        {
            __try {

                //
                // Get the X509 certificate from the registry. 
                //

                Status = LsCsp_GetBinaryData( 
                                    hKey,
                                    TEXT( HYDRA_X509_CERTIFICATE ),
                                    &i_csp_abServerX509Cert,
                                    &i_csp_dwServerX509CertLen 
                                );

                if( LICENSE_STATUS_OK == Status && 0 != i_csp_dwServerX509CertLen )
                {
                    //
                    // Get the corresponding private key from the store.
                    // It is not OK if we have the X509 certificate but not the
                    // private key that goes with it.
                    //

                    Status = LsCsp_RetrieveSecret( 
                                            X509_CERT_PRIVATE_KEY_NAME, 
                                            NULL,
                                            &i_csp_dwX509CertPrivateKeyLen 
                                        );

                    if( LICENSE_STATUS_OK == Status )
                    {
                        i_csp_abX509CertPrivateKey = LocalAlloc( LPTR, i_csp_dwX509CertPrivateKeyLen );

                        if( NULL != i_csp_abX509CertPrivateKey )
                        {
                            Status = LsCsp_RetrieveSecret( 
                                                    X509_CERT_PRIVATE_KEY_NAME, 
                                                    i_csp_abX509CertPrivateKey,
                                                    &i_csp_dwX509CertPrivateKeyLen 
                                                );

                            if(LICENSE_STATUS_OK == Status)
                            {
                                //
                                // Get the certificate ID for the X509 certificate
                                //

                                Status = LsCsp_GetBinaryData(
                                                    hKey,
                                                    TEXT( HYDRA_X509_CERT_ID ),
                                                    &i_csp_abX509CertID,
                                                    &i_csp_dwX509CertIDLen 
                                                );
                            }
                        }
                        else // memory allocate 
                        {
                            Status = LICENSE_STATUS_OUT_OF_MEMORY;
                        }
                    }
                }
                else
                {
                    Status = LICENSE_STATUS_NO_CERTIFICATE;
                }

            }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                Status = LICENSE_STATUS_INVALID_INPUT;
            }
        }


        //
        // verify our certificate
        //
        if(LICENSE_STATUS_OK == Status)
        {
            Status = VerifyTermServCertificate(
                                        i_csp_dwServerX509CertLen, 
                                        i_csp_abServerX509Cert, 
                                        i_csp_dwX509CertPrivateKeyLen, 
                                        i_csp_abX509CertPrivateKey
                                    );

            if( LICENSE_STATUS_OK != Status )
            {
                //
                // Deleting the X509 certificate is enough.
                //
                RegDeleteValue( hKey, TEXT( HYDRA_X509_CERTIFICATE ) );
            }
        }
            
        if(LICENSE_STATUS_OK != Status)
        {
            if( NULL != i_csp_abServerX509Cert )
            {
                LocalFree( i_csp_abServerX509Cert );
            }
       
            if( NULL != i_csp_abX509CertPrivateKey )
            {
                LocalFree( i_csp_abX509CertPrivateKey );
            }

            if( NULL != i_csp_abX509CertID )
            {
                LocalFree( i_csp_abX509CertID );
            }
        }
        else 
        {
            csp_abServerX509Cert = i_csp_abServerX509Cert;
            csp_dwServerX509CertLen = i_csp_dwServerX509CertLen;

            csp_dwX509CertPrivateKeyLen = i_csp_dwX509CertPrivateKeyLen;
            csp_abX509CertPrivateKey = i_csp_abX509CertPrivateKey;

            csp_abX509CertID = i_csp_abX509CertID;
            csp_dwX509CertIDLen = i_csp_dwX509CertIDLen;
        }
    }

    RELEASE_EXCLUSIVE_ACCESS( csp_hMutex );

    if (hKey)
    {
        RegCloseKey(hKey);
    }

    return Status;
}

LICENSE_STATUS
CreateProprietaryKeyAndCert(
    PBYTE *ppbPrivateKey,
    DWORD *pcbPrivateKey,
    PBYTE *ppbServerCert,
    DWORD *pcbServerCert
    )
{
#define     MD5RSA      0x01;
#define     RSAKEY      0x01;

    LPBSAFE_PRV_KEY		PRV;
    Hydra_Server_Cert   Cert;
    DWORD               KeyLen = 512;
    DWORD               bits, j;
    DWORD               dwPubSize, dwPrivSize;
    BYTE                *kPublic;
    BYTE                *kPrivate;
    MD5_CTX             HashState;
    PBYTE               pbData, pbTemp = NULL;
    DWORD               dwTemp = 0;
    BYTE                pbHash[0x48];
    BYTE                Output[0x48];
    unsigned char prvmodulus[] =
    {
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x3d, 0x3a, 0x5e, 0xbd,
        0x72, 0x43, 0x3e, 0xc9, 0x4d, 0xbb, 0xc1, 0x1e,
        0x4a, 0xba, 0x5f, 0xcb, 0x3e, 0x88, 0x20, 0x87,
        0xef, 0xf5, 0xc1, 0xe2, 0xd7, 0xb7, 0x6b, 0x9a,
        0xf2, 0x52, 0x45, 0x95, 0xce, 0x63, 0x65, 0x6b,
        0x58, 0x3a, 0xfe, 0xef, 0x7c, 0xe7, 0xbf, 0xfe,
        0x3d, 0xf6, 0x5c, 0x7d, 0x6c, 0x5e, 0x06, 0x09,
        0x1a, 0xf5, 0x61, 0xbb, 0x20, 0x93, 0x09, 0x5f,
        0x05, 0x6d, 0xea, 0x87, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x3f, 0xbd, 0x29, 0x20,
        0x57, 0xd2, 0x3b, 0xf1, 0x07, 0xfa, 0xdf, 0xc1,
        0x16, 0x31, 0xe4, 0x95, 0xea, 0xc1, 0x2a, 0x46,
        0x2b, 0xad, 0x88, 0x57, 0x55, 0xf0, 0x57, 0x58,
        0xc6, 0x6f, 0x95, 0xeb, 0x00, 0x00, 0x00, 0x00,
        0x83, 0xdd, 0x9d, 0xd0, 0x03, 0xb1, 0x5a, 0x9b,
        0x9e, 0xb4, 0x63, 0x02, 0x43, 0x3e, 0xdf, 0xb0,
        0x52, 0x83, 0x5f, 0x6a, 0x03, 0xe7, 0xd6, 0x78,
        0x45, 0x83, 0x6a, 0x5b, 0xc4, 0xcb, 0xb1, 0x93,
        0x00, 0x00, 0x00, 0x00, 0x65, 0x9d, 0x43, 0xe8,
        0x48, 0x17, 0xcd, 0x29, 0x7e, 0xb9, 0x26, 0x5c,
        0x79, 0x66, 0x58, 0x61, 0x72, 0x86, 0x6a, 0xa3,
        0x63, 0xad, 0x63, 0xb8, 0xe1, 0x80, 0x4c, 0x0f,
        0x36, 0x7d, 0xd9, 0xa6, 0x00, 0x00, 0x00, 0x00,
        0x75, 0x3f, 0xef, 0x5a, 0x01, 0x5f, 0xf6, 0x0e,
        0xd7, 0xcd, 0x59, 0x1c, 0xc6, 0xec, 0xde, 0xf3,
        0x5a, 0x03, 0x09, 0xff, 0xf5, 0x23, 0xcc, 0x90,
        0x27, 0x1d, 0xaa, 0x29, 0x60, 0xde, 0x05, 0x6e,
        0x00, 0x00, 0x00, 0x00, 0xc0, 0x17, 0x0e, 0x57,
        0xf8, 0x9e, 0xd9, 0x5c, 0xf5, 0xb9, 0x3a, 0xfc,
        0x0e, 0xe2, 0x33, 0x27, 0x59, 0x1d, 0xd0, 0x97,
        0x4a, 0xb1, 0xb1, 0x1f, 0xc3, 0x37, 0xd1, 0xd6,
        0xe6, 0x9b, 0x35, 0xab, 0x00, 0x00, 0x00, 0x00,
        0x87, 0xa7, 0x19, 0x32, 0xda, 0x11, 0x87, 0x55,
        0x58, 0x00, 0x16, 0x16, 0x25, 0x65, 0x68, 0xf8,
        0x24, 0x3e, 0xe6, 0xfa, 0xe9, 0x67, 0x49, 0x94,
        0xcf, 0x92, 0xcc, 0x33, 0x99, 0xe8, 0x08, 0x60,
        0x17, 0x9a, 0x12, 0x9f, 0x24, 0xdd, 0xb1, 0x24,
        0x99, 0xc7, 0x3a, 0xb8, 0x0a, 0x7b, 0x0d, 0xdd,
        0x35, 0x07, 0x79, 0x17, 0x0b, 0x51, 0x9b, 0xb3,
        0xc7, 0x10, 0x01, 0x13, 0xe7, 0x3f, 0xf3, 0x5f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00
    };

    PRV = (LPBSAFE_PRV_KEY)prvmodulus;
    PRV->magic = RSA2;
    PRV->keylen = 0x48;
    PRV->bitlen = 0x0200;
    PRV->datalen = 0x3f;
    PRV->pubexp = 0xc0887b5b;

    Cert.dwVersion = 0x01;
    Cert.dwSigAlgID = MD5RSA;
    Cert.dwKeyAlgID = RSAKEY;

    bits = KeyLen;

    if (!BSafeComputeKeySizes(&dwPubSize, &dwPrivSize, &bits))
    {
        return LICENSE_STATUS_INVALID_INPUT;
    }

    if ((kPrivate = (BYTE *)LocalAlloc(LPTR,dwPrivSize)) == NULL)
    {
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    if ((kPublic = (BYTE *)LocalAlloc(LPTR,dwPubSize)) == NULL)
    {
        LocalFree(kPrivate);
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    if (!BSafeMakeKeyPair((LPBSAFE_PUB_KEY)kPublic,
                          (LPBSAFE_PRV_KEY)kPrivate,
                          KeyLen))
    {
        LocalFree(kPrivate);
        LocalFree(kPublic);
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    // make proprietary format cert

    Cert.PublicKeyData.wBlobType = BB_RSA_KEY_BLOB;
    Cert.PublicKeyData.wBlobLen = (WORD)dwPubSize;
    if( NULL == (Cert.PublicKeyData.pBlob = (PBYTE)LocalAlloc(LPTR,dwPubSize) ) )
    {
        LocalFree(kPrivate);
        LocalFree(kPublic);
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    memcpy(Cert.PublicKeyData.pBlob, kPublic, dwPubSize);

    dwTemp = 3*sizeof(DWORD) + 2*sizeof(WORD) + dwPubSize;
    if( NULL == (pbData = (PBYTE)LocalAlloc(LPTR,dwTemp)) )
    {
        LocalFree(kPrivate);
        LocalFree(kPublic);
        LocalFree(Cert.PublicKeyData.pBlob);
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    pbTemp = pbData;
    memcpy(pbTemp, &Cert.dwVersion, sizeof(DWORD));
    pbTemp += sizeof(DWORD);
    memcpy(pbTemp, &Cert.dwSigAlgID, sizeof(DWORD));
    pbTemp += sizeof(DWORD);

	memcpy(pbTemp, &Cert.dwKeyAlgID, sizeof(DWORD));
    pbTemp += sizeof(DWORD);

    memcpy(pbTemp, &Cert.PublicKeyData.wBlobType, sizeof(WORD));
    pbTemp += sizeof(WORD);

    memcpy(pbTemp, &Cert.PublicKeyData.wBlobLen, sizeof(WORD));
    pbTemp += sizeof(WORD);

    memcpy(pbTemp, Cert.PublicKeyData.pBlob, Cert.PublicKeyData.wBlobLen);
    pbTemp += Cert.PublicKeyData.wBlobLen;

    // sign the cert

    MD5Init(&HashState);
    MD5Update(&HashState, pbData, dwTemp);
    MD5Final(&HashState);
	
    LocalFree(pbData);

	memset(pbHash, 0x00, 0x48);
	memset(pbHash, 0xff, 0x40);

    pbHash[0x40-1] = 0;
    pbHash[0x40-2] = 1;
    pbHash[16] = 0;
    memcpy(pbHash, HashState.digest, 16);

    BSafeDecPrivate(PRV, pbHash, Output);

	Cert.SignatureBlob.wBlobType = BB_RSA_SIGNATURE_BLOB;
    Cert.SignatureBlob.wBlobLen = 0x48;
    if( NULL == (Cert.SignatureBlob.pBlob = (PBYTE)LocalAlloc(LPTR,Cert.SignatureBlob.wBlobLen)) )
    {
        LocalFree(kPrivate);
        LocalFree(kPublic);
        LocalFree(Cert.PublicKeyData.pBlob);
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    memcpy(Cert.SignatureBlob.pBlob, Output, Cert.SignatureBlob.wBlobLen);

    // Pack the Hydra_Server_Cert

    dwTemp = 3*sizeof(DWORD) + 4*sizeof(WORD) + dwPubSize + 0x48;

	if( NULL == (pbData = (PBYTE)LocalAlloc(LPTR,dwTemp)) )
    {
        LocalFree(kPrivate);
        LocalFree(kPublic);
        LocalFree(Cert.PublicKeyData.pBlob);
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    pbTemp = pbData;
    memcpy(pbTemp, &Cert.dwVersion, sizeof(DWORD));
    pbTemp += sizeof(DWORD);

    memcpy(pbTemp, &Cert.dwSigAlgID, sizeof(DWORD));
    pbTemp += sizeof(DWORD);
    memcpy(pbTemp, &Cert.dwKeyAlgID, sizeof(DWORD));
    pbTemp += sizeof(DWORD);

	memcpy(pbTemp, &Cert.PublicKeyData.wBlobType, sizeof(WORD));
    pbTemp += sizeof(WORD);

    memcpy(pbTemp, &Cert.PublicKeyData.wBlobLen, sizeof(WORD));
    pbTemp += sizeof(WORD);

    memcpy(pbTemp, Cert.PublicKeyData.pBlob, Cert.PublicKeyData.wBlobLen);
    pbTemp += Cert.PublicKeyData.wBlobLen;

    memcpy(pbTemp, &Cert.SignatureBlob.wBlobType, sizeof(WORD));
    pbTemp += sizeof(WORD);

    memcpy(pbTemp, &Cert.SignatureBlob.wBlobLen, sizeof(WORD));
    pbTemp += sizeof(WORD);

    memcpy(pbTemp, Cert.SignatureBlob.pBlob, Cert.SignatureBlob.wBlobLen);

    *ppbPrivateKey = kPrivate;
    *pcbPrivateKey = dwPrivSize;

    *ppbServerCert = pbData;
    *pcbServerCert = dwTemp;

    LocalFree(kPublic);

    return LICENSE_STATUS_OK;
}

//***************************************************************************
//
//  IsSystemService
//
//  returns TRUE if we are running as local system
//
//***************************************************************************

BOOL IsSystemService()
{
    BOOL bOK = FALSE;

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Construct the local system SID
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    SID    LocalSystemSid = { SID_REVISION,
                              1,
                              SECURITY_NT_AUTHORITY,
                              SECURITY_LOCAL_SYSTEM_RID };

    if ( !CheckTokenMembership ( NULL, &LocalSystemSid, &bOK ) )
    {
        bOK = FALSE;
    }

	return bOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tlsapi\cert.c ===
//+----------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        cert.c
//
// Contents:    Centralized server certificate management
//
// History:     02-09-00    RobLeit  Created
//
//-----------------------------------------------------------------------------
#include <windows.h>
#include "license.h"
#include "lscsp.h"

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
TLSGetTSCertificate(
    CERT_TYPE       CertType,
    LPBYTE          *ppbCertificate,
    LPDWORD         pcbCertificate)
{
    LICENSE_STATUS  Status;
    DWORD           dwSize;
    LSCSPINFO       CspData;

    if( CERT_TYPE_PROPRIETORY == CertType )
    {
        CspData = LsCspInfo_Certificate;
    }
    else if( CERT_TYPE_X509 == CertType )
    {
        CspData = LsCspInfo_X509Certificate;
    }
    else
    {
        return( LICENSE_STATUS_NO_CERTIFICATE );
    }

    Status = LsCsp_GetServerData( CspData, NULL, &dwSize );

    if( LICENSE_STATUS_OK != Status )
    {
        return( Status );
    }

    if( 0 == dwSize )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    *ppbCertificate = LocalAlloc( LMEM_ZEROINIT, dwSize );

    if( NULL == *ppbCertificate )
    {
        return( LICENSE_STATUS_OUT_OF_MEMORY );
    }
    
    Status = LsCsp_GetServerData( CspData, *ppbCertificate, &dwSize );

    if( LICENSE_STATUS_OK != Status )
    {
        LocalFree( *ppbCertificate );
        return( Status );
    }

    *pcbCertificate = dwSize;

    return( LICENSE_STATUS_OK );
}

LICENSE_STATUS
TLSFreeTSCertificate(
    LPBYTE          pbCertificate)
{
    if (NULL != pbCertificate)
    {
        LocalFree(pbCertificate);

        return LICENSE_STATUS_OK;
    }
    else
    {
        return LICENSE_STATUS_INVALID_INPUT;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tlsapi\efind.cpp ===
/*
**	Copyright (c) 1998 Microsoft Corporation
**	All Rights Reserved
**
**
*/
#include <windows.h>
#include <objbase.h>
#include <winbase.h>
#include <wchar.h>

// Required by SSPI.H
#define SECURITY_WIN32
#include <sspi.h>

#include <dsgetdc.h>
#include <ntdsapi.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <activeds.h>
#include "lscommon.h"
#include "tlsrpc.h"
#include "tlsapi.h"
#include "tlsapip.h"

#define CWSTR_SIZE(x)       (sizeof(x) - (sizeof(WCHAR) * 2))
#define DWSTR_SIZE(x)       ((wcslen(x) + 1) * sizeof(WCHAR))

#define LICENSE_SETTINGS                L"TS-Enterprise-License-Server"
#define LICENSE_SETTINGS_FORMAT         L"LDAP://CN=%ws,CN=%ws,CN=%ws,%ws"
#define LICENSE_SETTINGS_SIZE           CWSTR_SIZE(LICENSE_SETTINGS)
#define LICENSE_SETTINGS_FORMAT_SIZE    CWSTR_SIZE(LICENSE_SETTINGS_FORMAT)
#define SITES               L"sites"
#define SITES_SIZE          CWSTR_SIZE(SITES)
#define CONFIG_CNTNR        L"ConfigurationNamingContext"
#define CONFIG_CNTNR_FORMAT L"LDAP://CN=%ws,%ws"
#define CONFIG_CNTNR_FORMAT_SIZE    CWSTR_SIZE(CONFIG_CNTNR_FORMAT)
#define ROOT_DSE_PATH       L"LDAP://RootDSE"
#define ADS_PATH            L"ADsPath"
#define SEARCH_FILTER       L"(CN=TS-Enterprise-LicenseServer)"
#define DNS_MACHINE_NAME    L"dNSHostName"
#define IS_DELETED          L"isDeleted"
#define SITE_SERVER         L"siteServer"

HRESULT GetLicenseServersFromReg(LPWSTR wszRegKey, LPWSTR *ppwszServerNames,DWORD *pcServers, LPWSTR **prgwszServers);

HRESULT
WriteLicenseServersToReg(LPWSTR wszRegKey, LPWSTR pwszServerNames,DWORD cchServers);

extern BOOL g_fInDomain;

extern "C" DWORD WINAPI 
TLSDisconnect( 
    TLS_HANDLE* pphContext
);

//
// Pre-fill the ADSI cache with only the attribute we want, then get it
// Only use if exactly one attribute is needed
//

HRESULT
GetWithGetInfoEx(
                 IADs *pADs,
                 LPWSTR wszAttribute,
                 VARIANT *pvar
                 )
{
    HRESULT hr;

    hr = ADsBuildVarArrayStr( &wszAttribute, 1, pvar );
    if( SUCCEEDED( hr ) )
    {
        hr = pADs->GetInfoEx( *pvar, 0L );
        VariantClear( pvar );

        if (SUCCEEDED(hr))
        {
            hr = pADs->Get( wszAttribute, pvar );
        }
    }

    return hr;
}

//
// Pre-fill the ADSI cache with only the attributes we want, then get them
// Only use if exactly two attributes are needed
//

HRESULT
GetWithGetInfoEx2(
                 IADs *pADs,
                 LPWSTR wszAttribute1,
                 LPWSTR wszAttribute2,
                 VARIANT *pvar1,
                 VARIANT *pvar2,
                 HRESULT *phr2
                 )
{
    HRESULT hr;
    LPWSTR rgwszAttributes[] = {wszAttribute1,wszAttribute2};

    hr = ADsBuildVarArrayStr( rgwszAttributes, 2, pvar1 );
    if( SUCCEEDED( hr ) )
    {
        hr = pADs->GetInfoEx( *pvar1, 0L );
        VariantClear( pvar1 );

        if (SUCCEEDED(hr))
        {
            hr = pADs->Get( wszAttribute1, pvar1 );

            if (SUCCEEDED(hr))
            {
                *phr2 = pADs->Get( wszAttribute2, pvar2 );
            }
        }
    }

    return hr;
}

HRESULT
GetExWithGetInfoEx(
                   IADs *pADs,
                   LPWSTR wszAttribute,
                   VARIANT *pvar
                   )
{
    HRESULT hr;

    hr = ADsBuildVarArrayStr( &wszAttribute, 1, pvar );
    if( SUCCEEDED( hr ) )
    {
        hr = pADs->GetInfoEx( *pvar, 0L );
        VariantClear( pvar );

        if (SUCCEEDED(hr))
        {
            hr = pADs->GetEx( wszAttribute, pvar );
        }
    }

    return hr;
}

HRESULT GetLicenseSettingsObject(VARIANT *pvar,
                                 LPWSTR *ppwszLicenseSettings,
                                 LPWSTR *ppwszSiteName,
                                 IADs **ppADs)
{
    HRESULT          hr;
    DWORD            dwErr = 0;
    LPWSTR           pwszConfigContainer;
    IADs *           pADs = NULL;
    IDirectorySearch *pADsSearch = NULL;
    ADS_SEARCH_HANDLE hSearch = NULL;
    ADS_SEARCH_COLUMN Column;
    LPWSTR           pwszAdsPath = ADS_PATH;
    LPWSTR           pwszSitesPath = NULL;
    BOOL             fInDomain;

    if (g_fInDomain == -1)
    {
        dwErr = TLSInDomain(&fInDomain,NULL);
        if (dwErr != NO_ERROR)
            return HRESULT_FROM_WIN32(dwErr);
    } else
    {
        fInDomain = g_fInDomain;
    }

    if (!fInDomain)
    {
        return HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN);
    }

    VariantInit(pvar);
    
    //
    // Obtain the path to the configuration container.
    //

    hr = ADsGetObject(ROOT_DSE_PATH, IID_IADs, (void **)&pADs);

    if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"ADsGetObject ROOT_DSE_PATH failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    hr = pADs->Get(CONFIG_CNTNR, pvar);

    if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"Get CONFIG_CNTNR failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    if (V_VT(pvar) != VT_BSTR) {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
#ifdef PRIVATEDEBUG
        wprintf(L"bad variant 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    pwszConfigContainer = pvar->bstrVal;  // For sake of readability.

    //
    // Get the site name, if possible
    //

    dwErr = DsGetSiteName(NULL, ppwszSiteName);

    if (dwErr == 0)
    {
        //
        // Build the X.500 path to the LicenseSettings object.
        //

        *ppwszLicenseSettings =
            (LPWSTR)LocalAlloc(
                               LPTR,
                               LICENSE_SETTINGS_FORMAT_SIZE
                               + LICENSE_SETTINGS_SIZE
                               + DWSTR_SIZE(*ppwszSiteName)
                               + SITES_SIZE
                               + DWSTR_SIZE(pwszConfigContainer)
                               + sizeof(TCHAR));

        if (*ppwszLicenseSettings == NULL) {
            hr = E_OUTOFMEMORY;
            goto CleanExit;
        }

        swprintf(*ppwszLicenseSettings,
                 LICENSE_SETTINGS_FORMAT,
                 LICENSE_SETTINGS,
                 *ppwszSiteName,
                 SITES,
                 pwszConfigContainer);
        
        hr = ADsGetObject(*ppwszLicenseSettings, IID_IADs, (void **)ppADs);

        if (SUCCEEDED(hr))
        {
            // return this object
            goto CleanExit;
        }
    } 

    //
    // None in our site (or we don't know our site)
    // Search all sites in GC, take first one
    //

    pwszSitesPath =
        (LPWSTR)LocalAlloc(
                           LPTR,
                           CONFIG_CNTNR_FORMAT_SIZE
                               + SITES_SIZE
                               + DWSTR_SIZE(pwszConfigContainer)
                               + sizeof(TCHAR));

        if (pwszSitesPath == NULL) {
            hr = E_OUTOFMEMORY;
            goto CleanExit;
        }

        swprintf(pwszSitesPath,
                 CONFIG_CNTNR_FORMAT,
                 SITES,
                 pwszConfigContainer);

    hr = ADsGetObject(pwszSitesPath,
                      IID_IDirectorySearch,
                      (void **)&pADsSearch);
    if (FAILED(hr))
    {
#ifdef PRIVATEDEBUG
        wprintf(L"ADsGetObject ConfigContainer (%s) failed 0x%lx\n",pwszConfigContainer,hr);
#endif
        goto CleanExit;
    }

    hr = pADsSearch->ExecuteSearch(SEARCH_FILTER,&pwszAdsPath,1,&hSearch);
    if (FAILED(hr))
    {
#ifdef PRIVATEDEBUG
        wprintf(L"ExecuteSearch failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    hr = pADsSearch->GetNextRow(hSearch);

    if (hr == S_ADS_NOMORE_ROWS)
        hr = E_ADS_PROPERTY_NOT_SET;

    if (FAILED(hr))
    {
#ifdef PRIVATEDEBUG
        wprintf(L"GetNextRow failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    hr = pADsSearch->GetColumn(hSearch,pwszAdsPath,&Column);
    if (FAILED(hr))
    {
#ifdef PRIVATEDEBUG
        wprintf(L"GetColumn (%ws) failed 0x%lx\n",pwszAdsPath,hr);
#endif
        goto CleanExit;
    }

    hr = ADsGetObject(Column.pADsValues->CaseIgnoreString,
                      IID_IADs,
                      (void **)ppADs);

    pADsSearch->FreeColumn(&Column);

CleanExit:
    if (NULL != pADs) {
        pADs->Release();
    }

    if (NULL != pADsSearch) {
        if (hSearch != NULL) {
            pADsSearch->CloseSearchHandle(hSearch);
        }

        pADsSearch->Release();
    }

    if (NULL != pwszSitesPath)
    {
        LocalFree(pwszSitesPath);
    }

    return hr;
}

HRESULT
GetRandomServer(IADs *pADs,
                VARIANT *pvar
                )
{
    HRESULT          hr;
    VARIANT          var;
    SAFEARRAY        *psaServers;
    LONG             lLower, lUpper, lPos;

    VariantInit(&var);

    hr = GetExWithGetInfoEx(pADs,SITE_SERVER,&var);
    if (FAILED(hr))
    {
#ifdef PRIVATEDEBUG
        wprintf(L"GetEx (%ws) failed 0x%lx\n",LICENSE_SETTINGS,hr);
#endif
        goto CleanExit;
    }

    psaServers = V_ARRAY(&var);
    if (NULL == psaServers)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
#ifdef PRIVATEDEBUG
        wprintf(L"GetEx no array failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    hr= SafeArrayGetLBound( psaServers, 1, &lLower );
    if (FAILED(hr))
    {
#ifdef PRIVATEDEBUG
        wprintf(L"SafeArrayGetLBound failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    hr= SafeArrayGetUBound( psaServers, 1, &lUpper );
    if (FAILED(hr))
    {
#ifdef PRIVATEDEBUG
        wprintf(L"SafeArrayGetUBound failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    srand(GetTickCount());

    lPos = (rand() % (lUpper - lLower + 1)) + lLower;

    hr = SafeArrayGetElement( psaServers, &lPos, pvar );
#ifdef PRIVATEDEBUG
        wprintf(L"SafeArrayGetElement (%d) failed? 0x%lx\n",lPos,hr);
#endif

CleanExit:
    VariantClear(&var);

    return hr;
}

HRESULT
GetAllServers(IADs *pADs,
              VARIANT *pvar
              )
{
    HRESULT          hr;

    hr = GetExWithGetInfoEx(pADs,SITE_SERVER,pvar);
    if (FAILED(hr))
    {
#ifdef PRIVATEDEBUG
        wprintf(L"GetEx (%ws) failed 0x%lx\n",LICENSE_SETTINGS,hr);
#endif
    }

    return hr;
}

HRESULT
DnToFqdn(LPWSTR pwszDN, LPWSTR pwszFqdn)
{
    LPWSTR           pwszBindPath;
    HRESULT          hr, hr2;
    IADs *           pADs2        = NULL;
    VARIANT          var2;
    VARIANT          var3;

    VariantInit(&var2);
    VariantInit(&var3);

    //
    // Bind to the computer object referenced by the Site-Server property.
    //

    // LDAP:// + pwszDN + 1
    pwszBindPath = (LPWSTR) LocalAlloc(LPTR,
                              (wcslen(pwszDN) + 8) * sizeof(WCHAR));

    if (pwszBindPath == NULL) {
        hr = E_OUTOFMEMORY;
#ifdef PRIVATEDEBUG
        wprintf(L"LocalAlloc failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    wsprintf(pwszBindPath, L"LDAP://%ws", pwszDN);

    hr = ADsOpenObject(pwszBindPath,
                       NULL,
                       NULL,
                       ADS_SERVER_BIND,
                       IID_IADs,
                       (void **)&pADs2);

    LocalFree(pwszBindPath);

    if (FAILED(hr))
    {
#ifdef PRIVATEDEBUG
        wprintf(L"ADsOpenObject failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    //
    // Fetch the Machine-DNS-Name property.
    //

    hr = GetWithGetInfoEx2(pADs2,DNS_MACHINE_NAME, IS_DELETED, &var3, &var2, &hr2);

    if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"Get failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    if (SUCCEEDED(hr2))
    {
        hr = VariantChangeType(&var2,&var2,0,VT_BOOL);
        
        if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
            wprintf(L"VariantChangeType failed 0x%lx\n",hr);
#endif

            goto CleanExit;
        }

        if (V_BOOL(&var2))
        {
            // object has been deleted - pretend it isn't set
            hr = E_ADS_PROPERTY_NOT_SET;
#ifdef PRIVATEDEBUG
            wprintf(L"Object deleted\n");
#endif
            goto CleanExit;
        }
    }

    if (V_VT(&var3) != VT_BSTR) {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
#ifdef PRIVATEDEBUG
        wprintf(L"Get bad data 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    wcscpy(pwszFqdn,V_BSTR(&var3));

CleanExit:
    VariantClear(&var2);
    VariantClear(&var3);

    if (NULL != pADs2) {
        pADs2->Release();
    }

    return hr;
}

//
// First call with fUseReg TRUE; if the returned server doesn't work
// call again with fUseReg FALSE
//

extern "C"
HRESULT
FindEnterpriseServer(TLS_HANDLE *phBinding)
{
    HRESULT             hr;
    LPWSTR              *rgwszServers = NULL;
    LPWSTR              pwszServerNames = NULL;
    DWORD               entriesread, i;

    if (phBinding == NULL)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto CleanExit;
    }

    *phBinding = NULL;

    hr = GetLicenseServersFromReg(ENTERPRISE_SERVER_MULTI,&pwszServerNames,&entriesread,&rgwszServers);
    if (FAILED(hr))
    {
        goto CleanExit;
    }

    for (i = 0; i < entriesread; i++)
    {
        TLS_HANDLE pContext=NULL;
        RPC_STATUS rpcStatus;
        DWORD dwVersion;

        if(!(pContext = TLSConnectToLsServer(rgwszServers[i])))
        {
            break;
        }

        rpcStatus = TLSGetVersion(pContext,&dwVersion);
        if (rpcStatus != RPC_S_OK)
        {
            TLSDisconnect(&pContext);
            continue;
        }

        //
        // No Beta <--> RTM server.
        //
        //
        // TLSIsBetaNTServer() returns TRUE if eval NT
        // IS_LSSERVER_RTM() returns TRUE if LS is an RTM.
        //
        if( TLSIsBetaNTServer() == IS_LSSERVER_RTM(dwVersion) )
        {
            continue;
        }

        if (!(dwVersion & TLS_VERSION_ENTERPRISE_BIT))
        {
            TLSDisconnect(&pContext);
            continue;
        }

        *phBinding = pContext;
        break;
    }

CleanExit:
    if (pwszServerNames)
        LocalFree(pwszServerNames);

    if (rgwszServers)
        LocalFree(rgwszServers);

    return hr;
}

extern "C"
HRESULT
GetAllEnterpriseServers(WCHAR ***ppszServers, DWORD *pdwCount)
{
    LPWSTR           pwszSiteName = NULL;
    IADs *           pADs         = NULL;
    VARIANT          var;
    VARIANT          var2;
    LPWSTR           pwszLicenseSettings = NULL;
    HRESULT          hr;
    VARIANT HUGEP    *pvar = NULL;
    LONG             lLower, lUpper;
    int              i;
    LPWSTR           pwszRegServers = NULL;
    LPWSTR           pwszRegServersTmp;
    DWORD            cchServer, cchServers;
    int              cServers = 0;

    if (ppszServers != NULL)
        *ppszServers = NULL;

	// We're going to use ADSI,  so initialize COM.  We don't
	// care about OLE 1.0 so disable OLE 1 DDE

	hr = CoInitialize(NULL);
    
    if (FAILED(hr))
    {
        return hr;
    }

    VariantInit(&var);
    VariantInit(&var2);
    
    hr = GetLicenseSettingsObject(&var,
                                  &pwszLicenseSettings,
                                  &pwszSiteName,
                                  &pADs);


    if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"GetLicenseSettingsObject failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    hr = GetAllServers(pADs,&var2);

    if (FAILED(hr))
    {
#ifdef PRIVATEDEBUG
        wprintf(L"GetAllServers failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    hr = SafeArrayGetLBound( V_ARRAY(&var2), 1, &lLower );
    if (FAILED(hr))
    {
#ifdef PRIVATEDEBUG
        wprintf(L"SafeArrayGetLBound failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    hr = SafeArrayGetUBound( V_ARRAY(&var2), 1, &lUpper );
    if (FAILED(hr))
    {
#ifdef PRIVATEDEBUG
        wprintf(L"SafeArrayGetUBound failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    // Get a pointer to the elements of the safearray.
    hr = SafeArrayAccessData(V_ARRAY(&var2), (void HUGEP* FAR*)&pvar);

    if (FAILED(hr)) {
        goto CleanExit;
    }

    if (ppszServers != NULL) {
        *ppszServers = (WCHAR * *) LocalAlloc(LPTR,(lUpper-lLower+1) * sizeof(WCHAR *));

        if (*ppszServers == NULL) {
            hr = E_OUTOFMEMORY;
#ifdef PRIVATEDEBUG
            wprintf(L"LocalAlloc failed 0x%lx\n",hr);
#endif
            goto CleanExit;
        }
    }

    pwszRegServers = (LPWSTR) LocalAlloc(LPTR,2*sizeof(WCHAR));
    if (NULL == pwszRegServers)
    {
#ifdef PRIVATEDEBUG
        wprintf(L"Out of memory\n");
#endif
        hr = E_OUTOFMEMORY;
        
        goto CleanExit;
    }

    cchServers = 2;
    pwszRegServers[0] = pwszRegServers[1] = L'\0';

    for (i = 0; i < lUpper-lLower+1; i++)
    {
        WCHAR *szServer = (WCHAR *) LocalAlloc(LPTR,MAX_PATH*2);

        if (szServer == NULL) {
            hr = E_OUTOFMEMORY;
#ifdef PRIVATEDEBUG
            wprintf(L"LocalAlloc failed 0x%lx\n",hr);
#endif

            if (ppszServers != NULL) {
                for (int j = 0; j < cServers; j++)
                {
                    LocalFree((*ppszServers)[j]);
                }
                LocalFree(*ppszServers);
            }

            goto CleanExit;
        }

        hr = DnToFqdn(V_BSTR(pvar+cServers),szServer);

        if (FAILED(hr))
        {
#ifdef PRIVATEDEBUG
            wprintf(L"DnToFqdn failed 0x%lx\n",hr);
#endif

            LocalFree(szServer);

            continue;
        }

        cchServer = wcslen(szServer);

        pwszRegServersTmp = (LPWSTR) LocalReAlloc(pwszRegServers,(cchServers+cchServer+1)*sizeof(TCHAR),LHND);
        if (NULL == pwszRegServersTmp)
        {
#ifdef PRIVATEDEBUG
            wprintf(L"LocalReAlloc failed 0x%lx\n",hr);
#endif
            hr = E_OUTOFMEMORY;

            if (ppszServers != NULL) {
                for (int j = 0; j < cServers; j++)
                {
                    LocalFree((*ppszServers)[j]);
                }
                LocalFree(*ppszServers);
            }
            LocalFree(szServer);

            goto CleanExit;
        }
                    
        pwszRegServers = pwszRegServersTmp;
                    
        if (cchServers == 2)
        {
            wcscpy(pwszRegServers,szServer);
                        
            cchServers += cchServer;
        } else
        {
            wcscpy(pwszRegServers+cchServers-1,szServer);
                        
            cchServers += cchServer + 1;
                        
        }
        pwszRegServers[cchServers-1] = L'\0';

        if (ppszServers != NULL)
        {
            (*ppszServers)[cServers] = szServer;
        }

        cServers++;
    }

    if (pdwCount != NULL)
        *pdwCount = cServers;

    WriteLicenseServersToReg(ENTERPRISE_SERVER_MULTI,pwszRegServers,cchServers);

CleanExit:
    VariantClear(&var);
    VariantClear(&var2);

    if (pwszSiteName != NULL) {         // Allocated from DsGetSiteName
        NetApiBufferFree(pwszSiteName);
    }

    if (pwszLicenseSettings != NULL) {
        LocalFree(pwszLicenseSettings);
    }

    if (pvar != NULL) {
        SafeArrayUnaccessData(V_ARRAY(&var2));
    }

    if (NULL != pADs) {
        pADs->Release();
    }

    if (pwszRegServers) {
        LocalFree(pwszRegServers);
    }

    CoUninitialize();

    if ((ppszServers != NULL) && (FAILED(hr)))
        *ppszServers = NULL;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tls236\tlsbkupc.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        tlsbkupc.cpp
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#include "locks.h"
#include "tlsbkup.h"

#define LSERVER_REGISTRY_BASE           _TEXT("SYSTEM\\CurrentControlSet\\Services\\")
#define LSERVER_PARAMETERS              _TEXT("Parameters")
#define LSERVER_PARAMETERS_DBPATH       _TEXT("DBPath")        // database file
#define LSERVER_PARAMETERS_DBFILE       _TEXT("DBFile")        // database file
#define SZSERVICENAME                   _TEXT("TermServLicensing")
#define LSERVER_DEFAULT_DBPATH          _TEXT("%SYSTEMROOT%\\SYSTEM32\\LSERVER\\")
#define LSERVER_DEFAULT_EDB             _TEXT("TLSLic.edb")
#define TLSBACKUP_EXPORT_DIR            _TEXT("Export")

TCHAR g_szDatabaseDir[MAX_PATH+1];
TCHAR g_szDatabaseFile[MAX_PATH+1];
TCHAR g_szExportedDb[MAX_PATH+1];
TCHAR g_szDatabaseFname[MAX_PATH+1];

CCriticalSection g_ImportExportLock;

DWORD GetDatabasePaths()
{
    DWORD Status;
    HKEY hKey = NULL;
    DWORD dwBuffer;
    TCHAR szDbPath[MAX_PATH+1];;

    //-------------------------------------------------------------------
    //
    // Open HKLM\system\currentcontrolset\sevices\termservlicensing\parameters
    //
    //-------------------------------------------------------------------
    Status = RegCreateKeyEx(
                        HKEY_LOCAL_MACHINE,
                        LSERVER_REGISTRY_BASE SZSERVICENAME _TEXT("\\") LSERVER_PARAMETERS,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        NULL
                    );

    if(Status != ERROR_SUCCESS)
    {
        return Status;
    }

    //-------------------------------------------------------------------
    //
    // Get database file location and file name
    //
    //-------------------------------------------------------------------
    dwBuffer = sizeof(szDbPath) / sizeof(szDbPath[0]);

    Status = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_DBPATH,
                        NULL,
                        NULL,
                        (LPBYTE)szDbPath,
                        &dwBuffer
                    );
    if(Status != ERROR_SUCCESS)
    {
        //
        // use default value, 
        //
        _tcscpy(
                szDbPath,
                LSERVER_DEFAULT_DBPATH
            );
    }

    //
    // Get database file name
    //
    dwBuffer = sizeof(g_szDatabaseFname) / sizeof(g_szDatabaseFname[0]);
    Status = RegQueryValueEx(
                        hKey,
                        LSERVER_PARAMETERS_DBFILE,
                        NULL,
                        NULL,
                        (LPBYTE)g_szDatabaseFname,
                        &dwBuffer
                    );
    if(Status != ERROR_SUCCESS)
    {
        //
        // Use default value.
        //
        _tcscpy(
                g_szDatabaseFname,
                LSERVER_DEFAULT_EDB
            );
    }

    RegCloseKey(hKey);

    //
    // Always expand DB Path.
    //
    
    Status = ExpandEnvironmentStrings(
                        szDbPath,
                        g_szDatabaseDir,
                        sizeof(g_szDatabaseDir) / sizeof(g_szDatabaseDir[0])
                    );

    if(Status == 0)
    {
        // can't expand environment variable, error out.
        return GetLastError();
    }

    Status = 0;

    if(g_szDatabaseDir[_tcslen(g_szDatabaseDir) - 1] != _TEXT('\\'))
    {
        // JetBlue needs this.
        _tcscat(g_szDatabaseDir, _TEXT("\\"));
    } 

    //
    // Full path to database file
    //
    _tcscpy(g_szDatabaseFile, g_szDatabaseDir);
    _tcscat(g_szDatabaseFile, g_szDatabaseFname);

    _tcscpy(g_szExportedDb,g_szDatabaseDir);
    _tcscat(g_szExportedDb,TLSBACKUP_EXPORT_DIR);

    return Status;
}

HRESULT WINAPI
I_ExportTlsDatabaseC()
{
    DWORD dwRet = 0;
    LPTSTR pszStringBinding;
    TCHAR pComputer[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwSize = sizeof(pComputer) / sizeof(TCHAR);
    RPC_STATUS Status = RPC_S_OK;

    if (!GetComputerName(pComputer,&dwSize))
    {
        return GetLastError();
    }

    Status = RpcStringBindingCompose(NULL,TEXT("ncalrpc"),pComputer,NULL,NULL,&pszStringBinding);
    if (Status)
    {
        return Status;
    }

    Status = RpcBindingFromStringBinding(pszStringBinding,
                                         &TermServLicensingBackup_IfHandle);
    if (Status)
    {
        RpcStringFree(&pszStringBinding);

        goto TryCopyFile;
    }

    RpcTryExcept {
        dwRet = ExportTlsDatabase();
    }
    RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
        Status = RpcExceptionCode();
    }
    RpcEndExcept;

    RpcStringFree(&pszStringBinding);
    RpcBindingFree(&TermServLicensingBackup_IfHandle);

#if DBG
    {
        char szStatusCode[256];
        sprintf( szStatusCode, "I_ExportTlsDatabaseC() returns %d\n", Status );
        OutputDebugStringA( szStatusCode );
    }
#endif
    
    //
    // Only actually touch file when server is not available
    //

    if ( RPC_S_OK == Status)
    {
        return dwRet;
    }

TryCopyFile:

    Status = GetDatabasePaths();
    if (Status != 0)
    {
        return Status;
    }

    CreateDirectoryEx(g_szDatabaseDir,
                      g_szExportedDb,
                      NULL);     // Ignore errors, they'll show up in CopyFile

    _tcscat(g_szExportedDb, _TEXT("\\"));
    _tcscat(g_szExportedDb,g_szDatabaseFname);

    // Copy database file
    if (!CopyFile(g_szDatabaseFile,g_szExportedDb,FALSE))
    {
        return GetLastError();
    }

    return 0;   // Success
}

HRESULT WINAPI
ExportTlsDatabaseC()
{
    // avoid compiler error C2712
    // no need for multi-process save.
    CCriticalSectionLocker lock( g_ImportExportLock );

    return I_ExportTlsDatabaseC();
}

HRESULT WINAPI
I_ImportTlsDatabaseC()
{
    DWORD dwRet = 0;
    LPTSTR pszStringBinding;
    TCHAR pComputer[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwSize = sizeof(pComputer) / sizeof(TCHAR);
    RPC_STATUS Status = RPC_S_OK;
    HANDLE hFile;
    SYSTEMTIME systime;
    FILETIME ft;

    if (!GetComputerName(pComputer,&dwSize))
    {
        return GetLastError();
    }

    Status = RpcStringBindingCompose(NULL,TEXT("ncalrpc"),pComputer,NULL,NULL,&pszStringBinding);
    if (Status)
    {
        return Status;
    }

    Status = RpcBindingFromStringBinding(pszStringBinding,
                                         &TermServLicensingBackup_IfHandle);
    if (Status)
    {
        RpcStringFree(&pszStringBinding);

        goto TouchFile;
    }

    RpcTryExcept {
        dwRet = ImportTlsDatabase();
    }
    RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
        Status = RpcExceptionCode();
    }
    RpcEndExcept;

    RpcStringFree(&pszStringBinding);
    RpcBindingFree(&TermServLicensingBackup_IfHandle);

#if DBG
    {
        char szStatusCode[256];
        sprintf( szStatusCode, "I_ImportTlsDatabaseC() returns %d\n", Status );
        OutputDebugStringA( szStatusCode );
    }
#endif

    //
    // Only actually touch file when server is not available
    //

    if ( RPC_S_OK == Status )
    {
        return(dwRet);
    }

TouchFile:

    Status = GetDatabasePaths();
    if (Status != 0)
    {
        return Status;
    }

    _tcscat(g_szExportedDb, _TEXT("\\"));
    _tcscat(g_szExportedDb,g_szDatabaseFname);

    GetSystemTime(&systime);

    if (!SystemTimeToFileTime(&systime,&ft))
    {
        return GetLastError();
    }

    hFile = CreateFile(g_szExportedDb,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
        return GetLastError();
    }

    if (!SetFileTime(hFile,
                     NULL,      // Creation time
                     NULL,      // Last access time
                     &ft))      // Last write time
    {
        CloseHandle(hFile);

        return GetLastError();
    }


    CloseHandle(hFile);

    return 0;   // Success
}

HRESULT WINAPI
ImportTlsDatabaseC()
{
    // avoid compiler error C2712
    // no need for multi-process save.
    CCriticalSectionLocker lock( g_ImportExportLock );

    return I_ImportTlsDatabaseC();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tlsapi\global.c ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    glodata.c

Abstract:

    Global data definitions for tshare security.

Author:

    Madan Appiah (madana)  24-Jan-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <ntlsa.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>

#include <tchar.h>
#include <stdio.h>

#include "license.h"
#include "cryptkey.h"
#include "rng.h"
#include "lscsp.h"
#include "tlsapip.h"
#include "certutil.h"
#include "hydrakey.h"

#include <md5.h>
#include <sha.h>
#include <rsa.h>

#include <secdbg.h>
#include "global.h"

#ifdef OS_WIN16
#include <string.h>
#endif // OS_WIN16

//
// global data definitions.
//


BYTE csp_abPublicKeyModulus[92] = HYDRA_ROOT_PUBLIC_KEY;

LPBSAFE_PUB_KEY csp_pRootPublicKey = NULL;
LPBYTE          csp_abServerCertificate = NULL;
DWORD           csp_dwServerCertificateLen = 0;
LPBYTE          csp_abServerX509Cert = NULL;
DWORD           csp_dwServerX509CertLen = 0;
LPBYTE          csp_abX509CertID = NULL;
DWORD           csp_dwX509CertIDLen = 0;

HANDLE          csp_hMutex = NULL;

LONG            csp_InitCount = 0;

Hydra_Server_Cert   csp_hscData;
HINSTANCE       g_hinst;

LPBYTE          csp_abServerPrivateKey = NULL;
DWORD           csp_dwServerPrivateKeyLen = 0;
LPBYTE          csp_abX509CertPrivateKey = NULL;
DWORD           csp_dwX509CertPrivateKeyLen = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tlsapi\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:


NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MISC_SOURCES=\
    ..\tlsapi.rc \
    ..\tlsapi.c \
    ..\efind.cpp \
    ..\tlsrpc-c.c \
    ..\cert.c \
    ..\tlsapip.c \
    ..\csp.c \
    ..\global.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tlsapi\global.h ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    global.h

Abstract:

    Global data definitions for tshare security.

Author:

    Madan Appiah (madana)  24-Jan-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _GLOBAL_H_
#define _GLOBAL_H_

//-----------------------------------------------------------------------------
//
// global data definitions.
//
//-----------------------------------------------------------------------------

#define CSP_MUTEX_NAME  L"Global\\LSCSPMUTEX658fe2e8"


extern LPBSAFE_PUB_KEY csp_pRootPublicKey;

extern BYTE csp_abPublicKeyModulus[92];

extern LPBYTE csp_abServerCertificate;
extern DWORD  csp_dwServerCertificateLen;

extern LPBYTE csp_abServerX509Cert;
extern DWORD  csp_dwServerX509CertLen;

extern LPBYTE csp_abServerPrivateKey;
extern DWORD  csp_dwServerPrivateKeyLen;

extern LPBYTE csp_abX509CertPrivateKey;
extern DWORD  csp_dwX509CertPrivateKeyLen;

extern LPBYTE csp_abX509CertID;
extern DWORD  csp_dwX509CertIDLen;

extern Hydra_Server_Cert    csp_hscData;

extern HINSTANCE g_hinst;

extern HANDLE csp_hMutex;

extern LONG csp_InitCount;

//-----------------------------------------------------------------------------
// 
// Crypto-related  definitions
//
//-----------------------------------------------------------------------------

#define RSA_KEY_LEN             512
#define CAPI_MAX_VERSION        2

#define RDN_COMMON_NAME         "cn="

//-----------------------------------------------------------------------------
//
// Macros
//
//-----------------------------------------------------------------------------

#define ACQUIRE_EXCLUSIVE_ACCESS( x )  \
if( x ) \
{ \
    WaitForSingleObject(x, INFINITE); \
}

#define RELEASE_EXCLUSIVE_ACCESS( x ) \
if( x ) \
{ \
    ReleaseMutex(x); \
}

#endif // _GLOBAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tlsapi\secdbg.h ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    secdbg.h

Abstract:

    Debug macro definition file.

Author:

    Madan Appiah (madana)  24-Jan-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _SECDBG_H_
#define _SECDBG_H_

//
// assert macros.
//

#ifndef OS_WIN16

NTSYSAPI
VOID
NTAPI
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    DWORD LineNumber,
    PCHAR Message
    );

#define RTLASSERT( msg, exp)
//        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#define RTLASSERTMSG( msg, exp)
//        RtlAssert( #exp, __FILE__, __LINE__, msg )

#else // OS_WIN16

#define RTLASSERT( msg, exp)
#define RTLASSERTMSG( msg, exp)

#endif // OS_WIN16


#if DBG

#undef ASSERT
#undef ASSERTMSG

#define ASSERT( exp ) \
    if (!(exp)) { \
        RTLASSERT( msg, exp); \
    } \


#define ASSERTMSG( msg, exp ) \
    if (!(exp)) { \
        RTLASSERT( msg, exp); \
    } \

#else

#ifndef ASSERT
#define ASSERT( exp )
#endif

#ifndef ASSERTMSG
#define ASSERTMSG( msg, exp )
#endif

#endif // DBG

#endif // _SECDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tlsapi\tlsrpc-c.c ===
#include <tlsrpc_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tlsapi\enforce\makefile.inc ===
#
# Copyright (c) 1997-1999 Microsoft Corporation
#

TAGET_DIRECTORY=*

PRIVLIB=$(LSERVER_LIB_PATH)\$(ALT_PROJECT_TARGET)\$(O)\tlsapip.lib
$(LSERVER_LIB_PATH)\$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\tlsapi.lib : $(PRIVLIB)

$(PRIVLIB) $(PRIVLIB:.lib=.exp): $(O)\tlsapip.def $(LIBRARY_OBJS)
   -lib -out:$(PRIVLIB) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\tlsapip.def
$(LIBRARY_OBJS)
<<NOKEEP

$(O)\tlsapi.def: $(TLSAPI_ROOT)\tlsapi.def
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@

C_DEFINES=$(C_DEFINES) -DPRIVATE=
$(O)\tlsapip.def: $(O)\tlsapi.def
    $(C_PREPROCESSOR) $(O)\tlsapi.def > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tlsapi\tlsapi.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        tlsapi.cpp
//
// Contents:    
//
// History:     12-09-97    HueiWang    Created
//
//---------------------------------------------------------------------------
#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <rpc.h>
#include <ntsecapi.h>
#include <lmcons.h>
#include <lmserver.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <ntdsapi.h>
#include <dsrole.h>
#include <lmjoin.h>
#include <winldap.h>
#include <winsock2.h>
#include <dsgetdc.h>

#include "lscommon.h"
#include "tlsrpc.h"
#include "tlsapi.h"
#include "tlsapip.h"
#include "secstore.h"
#include "lscsp.h"
#include "license.h"

extern "C" DWORD WINAPI 
TLSConnect( 
    handle_t binding,
    TLS_HANDLE *pphContext
);

extern "C" DWORD WINAPI 
TLSDisconnect( 
    TLS_HANDLE* pphContext
);

#include <lmcons.h>         // Netxxx API includes
#include <lmserver.h>
#include <lmerr.h>
#include <lmapibuf.h>

#define DISCOVERY_INTERVAL (60 * 60 * 1000)

static HANDLE g_hCachingThreadExit = NULL;
static HANDLE g_hImmediateDiscovery = NULL;
static HANDLE g_hDiscoverySoon = NULL;

static BOOL g_fOffSiteLicenseServer = FALSE;

#define REG_DOMAIN_SERVER_MULTI L"DomainLicenseServerMulti"

#define TERMINAL_SERVICE_PARAM_DISCOVERY  "SYSTEM\\CurrentControlSet\\Services\\TermService\\Parameters\\LicenseServers"

// 2 second timeout
#define SERVER_NP_TIMEOUT (2 * 1000)

#define INSTALL_CERT_DELAY (5 * 1000)

BOOL g_fInDomain = -1;

LONG lLibUsage = 0;

typedef struct {
    TLS_HANDLE *hBinding;
    DWORD dwTimeout;            // In milliseconds - INFINITE for none
    LARGE_INTEGER timeInitial;  // As returned by QueryPerformanceCounter
} LS_ENUM_PARAM, *PLS_ENUM_PARAM;

void * MIDL_user_allocate(size_t size)
{
    return(HeapAlloc(GetProcessHeap(), HEAP_GENERATE_EXCEPTIONS, size));
}

void MIDL_user_free( void *pointer)
{
    HeapFree(GetProcessHeap(), 0, pointer);
}

#ifdef PRIVATEDEBUG
//
//  FUNCTIONS: StartTime()
//             EndTime()
//
//  USAGE:
//      StartTime();
//        // Do some work.
//      mseconds = EndTime();
//
//  RETURN VALUE:
//      Milliseconds between StartTime() and EndTime() calls.

LARGE_INTEGER TimeT;

void StartTimeT(void)
{
    QueryPerformanceCounter(&TimeT);
}

ULONG EndTimeT()
{
    LARGE_INTEGER liDiff;
    LARGE_INTEGER liFreq;

    QueryPerformanceCounter(&liDiff);

    liDiff.QuadPart -= TimeT.QuadPart;
    liDiff.QuadPart *= 1000; // Adjust to milliseconds, shouldn't overflow...

    (void)QueryPerformanceFrequency(&liFreq);

    return ((ULONG)(liDiff.QuadPart / liFreq.QuadPart));
}
#endif

//+------------------------------------------------------------------------
// Function:   ConnectToLsServer()
//
// Description:
//
//      Binding to sepecific hydra license server
//
// Arguments:
//
//      szLsServer - Hydra License Server name
//
// Return Value:
//
//      RPC binding handle or NULL if error, use GetLastError() to retrieve
//      error.
//-------------------------------------------------------------------------
static TLS_HANDLE WINAPI
ConnectLsServer( 
        LPTSTR szLsServer, 
        LPTSTR szProtocol, 
        LPTSTR szEndPoint, 
        DWORD dwAuthLevel )
{
    LPTSTR      szBindingString;
    RPC_BINDING_HANDLE hBinding=NULL;
    RPC_STATUS status;
    TLS_HANDLE pContext=NULL;
    BOOL       fSuccess;

#ifdef PRIVATEDEBUG
    if (NULL != szLsServer)
        wprintf(L"server=%s\n",szLsServer);
#endif

    //
    // If this isn't local
    //
    if ((NULL != szLsServer) && (NULL != szEndPoint))
    {
        TCHAR szPipeName[MAX_PATH+1];

        if (lstrlen(szLsServer) > ((sizeof(szPipeName) / sizeof(TCHAR)) - 26))
        {
#ifdef PRIVATEDEBUG
            wprintf(L"Server name too long\n");
#endif
            return NULL;
        }

        //
        // First check if license server named pipe exists
        //
        wsprintf(szPipeName,TEXT("\\\\%s\\pipe\\%s"),szLsServer,TEXT(SZSERVICENAME));

#ifdef PRIVATEDEBUG
        StartTimeT();
#endif

        fSuccess = WaitNamedPipe(szPipeName,SERVER_NP_TIMEOUT);

#ifdef PRIVATEDEBUG
        ULONG ulTime = EndTimeT();

        wprintf(L"WaitNamedPipe time == %lu\n",ulTime);
#endif

        if (!fSuccess)
        {
#ifdef PRIVATEDEBUG
            wprintf(L"WaitNamedPipe (%s) failed 0x%x\n",szPipeName,GetLastError());
#endif
            return NULL;
        }
    }
#ifdef PRIVATEDEBUG
    else
        wprintf(L"Not trying WaitNamedPipe\n");
#endif


    status = RpcStringBindingCompose(0,
                                     szProtocol,
                                     szLsServer,
                                     szEndPoint,
                                     0,
                                     &szBindingString);

    if(status!=RPC_S_OK)
    {
#ifdef PRIVATEDEBUG
        wprintf(L"RpcStringBindingCompose failed 0x%x\n",status);
#endif
        return NULL;
    }

    status=RpcBindingFromStringBinding( szBindingString, &hBinding);
    RpcStringFree( &szBindingString );
    if(status != RPC_S_OK)
    {
#ifdef PRIVATEDEBUG
        wprintf(L"RpcBindingFromStringBinding failed 0x%x\n",status);
#endif
        return NULL;
    }

    status = RpcMgmtSetComTimeout(hBinding,RPC_C_BINDING_MIN_TIMEOUT);
    if (status != RPC_S_OK)
    {
#ifdef PRIVATEDEBUG
        wprintf(L"RpcMgmtSetComTimeout failed 0x%x\n",status);
#endif
        return NULL;
    }   

    status=RpcBindingSetAuthInfo(hBinding,
                                 0,
                                 dwAuthLevel,
                                 RPC_C_AUTHN_WINNT,
                                 0,
                                 0);
    if(status == RPC_S_OK)
    {
        // Obtain context handle from server
        status = TLSConnect( hBinding, &pContext );

        if(status != ERROR_SUCCESS)
        {
            pContext = NULL;
        }
    }

    //
    // Memory leak
    //
    if(hBinding != NULL)
    {
        RpcBindingFree(&hBinding);
    }

    SetLastError((status == RPC_S_OK) ? ERROR_SUCCESS : status);
    return pContext;
}
//+------------------------------------------------------------------------
//-------------------------------------------------------------------------
DWORD WINAPI
TLSIsLicenseServer(
    LPWSTR szServerName
    )
/*++

++*/
{
    DWORD dwStatus=ERROR_SUCCESS;

    NET_API_STATUS      dwNetApiStatus;
    LPSERVER_INFO_101   lpServerInfo101=NULL;
    SC_HANDLE           schService=NULL;
    SC_HANDLE           schSCManager=NULL;
    SERVICE_STATUS      ServiceStatus;
    TLS_HANDLE          pContextHandle=NULL;

    //
    // verify system is NTS 
    //
    dwNetApiStatus=NetServerGetInfo(szServerName, 101, (LPBYTE*)&lpServerInfo101);
    if(dwNetApiStatus != NERR_Success)
        return dwNetApiStatus;

    do {

        //
        // Do we check version like 3.51??
        //
        if((lpServerInfo101->sv101_version_major & MAJOR_VERSION_MASK) < 4)
        {
            dwStatus = LSERVER_E_INVALID_NT_VERSION;
            break;
        }

        //
        // Verify it is NT Server
        //    
        if(!(lpServerInfo101->sv101_type & SV_TYPE_SERVER_NT))
        {
            dwStatus = LSERVER_E_NOT_NTSERVER;
            break;
        }

        //
        // Verify License Server is installed on machine
        //
        schSCManager = OpenSCManager(szServerName, NULL, SC_MANAGER_ALL_ACCESS);
        if(!schSCManager)
        {
            // Error return :
            //
            // ERROR_ACCESS_DENIED 
            // ERROR_DATABASE_DOES_NOT_EXIST
            // ERROR_INVALID_PARAMETER 
            dwStatus = GetLastError();
            break;
        }

        //
        // open CertSrv service
        // SZSERVICENAME defined in lscommon.h
        //
        schService = OpenService( schSCManager, _TEXT(SZSERVICENAME), SERVICE_ALL_ACCESS );
        if(!schService)
        {
            // Error return :
            //
            // ERROR_ACCESS_DENIED
            // ERROR_INVALID_HANDLE 
            // ERROR_INVALID_NAME
            // ERROR_SERVICE_DOES_NOT_EXIST 
            dwStatus = GetLastError();

            //
            // Simple checking on ERROR_SERVICE_DOES_NOT_EXIST is enough 
            // without mapping error code.
            //
            if(dwStatus == ERROR_SERVICE_DOES_NOT_EXIST)
                dwStatus = LSERVER_E_LS_NOTPRESENT;
            break;
        }

        //
        // Query License Service Status and make sure it is running
        //
        if(!QueryServiceStatus( schService, &ServiceStatus ))
        {
            // Error Return:
            // ERROR_ACCESS_DENIED
            // ERROR_INVALID_HANDLE 
            dwStatus = GetLastError();            
            break;
        }
        
        if(ServiceStatus.dwCurrentState != SERVICE_RUNNING)
        {
            dwStatus = LSERVER_E_LS_NOTRUNNING;
            break;
        }


        //
        // Should we make an RPC call to detemine if it is busy?
        //
        // Watch out for ANSI here...
        pContextHandle=TLSConnectToLsServer( szServerName );
        if(!pContextHandle)
        {
            dwStatus = GetLastError();
        }
    } while(FALSE);
    
    if(pContextHandle)
        TLSDisconnect(&pContextHandle);

    if(schService)
        CloseServiceHandle(schService);

    if(schSCManager)
        CloseServiceHandle(schSCManager);

    if(lpServerInfo101)
        NetApiBufferFree(lpServerInfo101);

    return dwStatus;
}


//+------------------------------------------------------------------------
// Function:   BindAnyServer()
//
// Description:
//
//          Call back routine for TLSConnectToAnyLsServer()
//
// Arguments:
//
//          See EnumerateTlsServer()
//
// Return Value:
//
//          Always TRUE to terminate server enumeration
//-------------------------------------------------------------------------
static BOOL 
BindAnyServer(
    TLS_HANDLE hRpcBinding, 
    LPCTSTR pszServerName,
    HANDLE dwUserData
    )
/*++

++*/
{
    
    PLS_ENUM_PARAM pParam = (PLS_ENUM_PARAM) dwUserData;
    TLS_HANDLE* hBinding = pParam->hBinding; 
    RPC_STATUS rpcStatus;
    HKEY hKey = NULL;
    DWORD dwBuffer = 0;
    DWORD cbBuffer = sizeof (DWORD);
    DWORD dwErrCode = 0;


    // Skip Windows 2000 License servers
        
    
    if (hRpcBinding != NULL)
    {        
        DWORD dwSupportFlags = 0;

        dwErrCode = TLSGetSupportFlags(
                hRpcBinding,
                &dwSupportFlags
        );

	    if ((dwErrCode == RPC_S_OK) && !(dwSupportFlags & SUPPORT_WHISTLER_CAL))
        {                    
            return FALSE;
        }            	                

        // If the call fails => Windows 2000 LS
        else if(dwErrCode != RPC_S_OK)
        {
            return FALSE;
        }

        *hBinding=hRpcBinding;

        return TRUE;
    }                         

    if (pParam->dwTimeout != INFINITE)
    {
        LARGE_INTEGER timeDiff;
        LARGE_INTEGER timeFreq;

        *hBinding=hRpcBinding;

        QueryPerformanceCounter(&timeDiff);

        timeDiff.QuadPart -= pParam->timeInitial.QuadPart;
        timeDiff.QuadPart *= 1000; // Adjust to milliseconds, shouldn't overflow

        (void)QueryPerformanceFrequency(&timeFreq);

        if (((ULONG)(timeDiff.QuadPart / timeFreq.QuadPart)) > pParam->dwTimeout)
        {
#ifdef PRIVATEDEBUG
            wprintf(L"BindAnyServer timed out\n");
#endif
            return TRUE;
        }
    }

    return FALSE;
}    

void
RandomizeArray(LPWSTR *rgwszServers, DWORD cServers)
{
    DWORD i;
    LPWSTR wszServerTmp;
    int val;

    if (cServers < 2)
        return;

    srand(GetTickCount());

    for (i = 0; i < cServers; i++)
    {
        val = rand() % (cServers - i);

        if (val == 0)
            continue;

        //
        // Swap # i with # (val+i)
        //
        wszServerTmp = rgwszServers[i];
        rgwszServers[i] = rgwszServers[val+i];
        rgwszServers[val+i] = wszServerTmp;
    }
}

HRESULT
GetLicenseServersFromReg(LPWSTR wszRegKey, LPWSTR *ppwszServerNames,DWORD *pcServers, LPWSTR **prgwszServers)
{
    HRESULT          hr = S_OK;
    HKEY             hKey = NULL;
    DWORD            dwType;
    DWORD            cbData = 0;
    LPWSTR           szServers=NULL, pchServer;
    DWORD            dwErr;
    DWORD            i,val;
    DWORD            iLocalComputer = (DWORD)(-1);
    WCHAR            szLocalComputerName[MAXCOMPUTERNAMELENGTH+1] = L"";
    DWORD            cbLocalComputerName=MAXCOMPUTERNAMELENGTH+1;

    *ppwszServerNames = NULL;
    *prgwszServers = NULL;

    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         TEXT(LSERVER_DISCOVERY_PARAMETER_KEY),
                         0,
                         KEY_READ,
                         &hKey);
    if (dwErr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto CleanErr;
    }

    dwErr = RegQueryValueEx(hKey,
                            wszRegKey,
                            NULL,
                            &dwType,
                            NULL,
                            &cbData);
    if (dwErr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto CleanErr;
    }

    if ((dwType != REG_MULTI_SZ) || (cbData < (2 * sizeof(WCHAR))))
    {
        hr = E_FAIL;
        goto CleanErr;
    }

    szServers = (LPWSTR) LocalAlloc(LPTR,cbData);
    if (NULL == szServers)
    {
        hr = E_OUTOFMEMORY;
        goto CleanErr;
    }

    dwErr = RegQueryValueEx(hKey,
                            wszRegKey,
                            NULL,
                            &dwType,
                            (PBYTE)szServers,
                            &cbData);
    if (dwErr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto CleanErr;
    }

    for (i = 0, pchServer = szServers; (pchServer != NULL) && (*pchServer != L'\0'); pchServer = wcschr(pchServer,L'\0')+1, i++)
        ;

    if (i == 0)
    {
        hr = E_FAIL;
        goto CleanErr;
    }

    *pcServers = i;

    *prgwszServers = (LPWSTR *)LocalAlloc(LPTR,sizeof(LPWSTR) * (*pcServers));
    if (*prgwszServers == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto CleanErr;
    }

    // Don't treat error from this function as fatal
    GetComputerName(szLocalComputerName, &cbLocalComputerName);

    for (i = 0, pchServer = szServers; (i < (*pcServers)) && (pchServer != NULL) && (*pchServer != L'\0'); pchServer = wcschr(pchServer,L'\0')+1, i++) {

        (*prgwszServers)[i] = pchServer;

        if ((iLocalComputer == (DWORD)(-1)) && (wcscmp(pchServer,szLocalComputerName) == 0))
        {
            iLocalComputer = i;
        }
    }

    //
    // Put local computer at head of list
    //
    if (iLocalComputer != (DWORD)(-1))
    {
        if (iLocalComputer != 0)
        {
            //
            // Swap # iLocalComputer with # 0
            //
            pchServer = (*prgwszServers)[iLocalComputer];
            (*prgwszServers)[iLocalComputer] = (*prgwszServers)[0];
            (*prgwszServers)[0] = pchServer;
        }

        RandomizeArray((*prgwszServers)+1,(*pcServers) - 1);
    }
    else
    {
        RandomizeArray((*prgwszServers),*pcServers);
    }

    *ppwszServerNames = szServers;

CleanErr:
    if (FAILED(hr))
    {
        if (NULL != szServers)
        {
            LocalFree(szServers);
        }

        if (NULL != *prgwszServers)
        {
            LocalFree(*prgwszServers);
        }
    }

    if (hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    return hr;
}

HRESULT
WriteLicenseServersToReg(LPWSTR wszRegKey, LPWSTR pwszServerNames,DWORD cchServers)
{
    HRESULT          hr;
    HKEY             hKey = NULL;
    DWORD            dwType = REG_MULTI_SZ;
    DWORD            dwErr;
    DWORD            dwDisp;

    if ((pwszServerNames == NULL) || (cchServers < 2))
    {
        //
        // Delete the value
        //

        dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             TEXT(LSERVER_DISCOVERY_PARAMETER_KEY),
                             0,
                             KEY_WRITE,
                             &hKey);
        if (dwErr != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(dwErr);
            goto CleanErr;
        }

        dwErr = RegDeleteValue(hKey,wszRegKey);
        if (dwErr != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(dwErr);
            goto CleanErr;
        }

        hr = S_OK;
        goto CleanErr;
    }

    dwErr = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                           TEXT(LSERVER_DISCOVERY_PARAMETER_KEY),
                           0,
                           TEXT(""),
                           REG_OPTION_NON_VOLATILE,
                           KEY_WRITE,
                           NULL,
                           &hKey,
                           &dwDisp);
    if (dwErr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto CleanErr;
    }

    dwErr = RegSetValueEx(hKey,
                          wszRegKey,
                          0,
                          dwType,
                          (CONST BYTE *)pwszServerNames,
                          cchServers*sizeof(WCHAR));
    if (dwErr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto CleanErr;
    }


CleanErr:
    if (hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    return hr;
}

//
// Free pszDomain using NetApiBufferFree
//

DWORD WINAPI
TLSInDomain(BOOL *pfInDomain, LPWSTR *pszDomain)
{
    NET_API_STATUS dwErr;
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pDomainInfo = NULL;
    PDOMAIN_CONTROLLER_INFO pdcInfo = NULL;

    if (pfInDomain == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *pfInDomain = FALSE;

    //
    // Check if we're in a workgroup
    //
    dwErr = DsRoleGetPrimaryDomainInformation(NULL,
                                              DsRolePrimaryDomainInfoBasic,
                                              (PBYTE *) &pDomainInfo);

    if ((dwErr != NO_ERROR) || (pDomainInfo == NULL))
    {
        return dwErr;
    }

    switch (pDomainInfo->MachineRole)
    {
        case DsRole_RoleStandaloneWorkstation:
        case DsRole_RoleStandaloneServer:
            DsRoleFreeMemory(pDomainInfo);

            if (NULL != pszDomain)
            {
                NETSETUP_JOIN_STATUS BufferType;

                dwErr = NetGetJoinInformation(NULL,pszDomain,&BufferType);
            }

            return dwErr;
            break;      // just in case
    }

    DsRoleFreeMemory(pDomainInfo);


    dwErr = DsGetDcName(NULL,   // Computer Name
                        NULL,   // Domain Name
                        NULL,   // Domain GUID
                        NULL,   // Site Name
                        DS_DIRECTORY_SERVICE_PREFERRED,
                        &pdcInfo);

    if ((dwErr != NO_ERROR) || (pdcInfo == NULL))
    {
        if (dwErr == ERROR_NO_SUCH_DOMAIN)
        {
            *pfInDomain = FALSE;
            return NO_ERROR;
        }
        else
        {
            if (pdcInfo == NULL)
                dwErr = ERROR_INTERNAL_ERROR;
            return dwErr;
        }
    }

    if (pdcInfo->Flags & DS_DS_FLAG)
    {
        *pfInDomain = TRUE;

    }

    if (pszDomain != NULL)
    {
        dwErr = NetApiBufferAllocate((wcslen(pdcInfo->DomainName)+1) * sizeof(WCHAR),
                                     (LPVOID *)pszDomain);

        if ((NERR_Success == dwErr) && (NULL != *pszDomain))
        {
            wcscpy(*pszDomain,pdcInfo->DomainName);
        }
    }

    if (pdcInfo != NULL)
        NetApiBufferFree(pdcInfo);

    return dwErr;
}

/*++

Function:

    LicenseServerCachingThread

Description:

    This is the thread that does the license server caching.

Arguments:

    lpParam - contains the exit event handle

Returns:

    Always 1

--*/

DWORD WINAPI
LicenseServerCachingThread(
    LPVOID lpParam )
{
    DWORD
        dwWaitStatus;
    HANDLE
        hExit = (HANDLE)lpParam;
    DWORD
        dwDiscoveryInterval = DISCOVERY_INTERVAL;
    HANDLE
        rgWaitHandles[] = {hExit,g_hImmediateDiscovery,g_hDiscoverySoon};
    BOOL
        bFoundServer;
    BOOL
        bSkipOne = FALSE;

    //
    // Yield our time slice to other threads now, so that the terminal server
    // service can start up quickly.  Refresh the license server cache when we
    // resume our time slice.
    //

    Sleep( 0 );

    while (1)
    {
        if (!bSkipOne)
        {
            bFoundServer = TLSRefreshLicenseServerCache(INFINITE);

            if ((!g_fOffSiteLicenseServer) && bFoundServer)
            {
                dwDiscoveryInterval = INFINITE;
            }
        }
        else
        {
            bSkipOne = FALSE;
        }

        dwWaitStatus = WaitForMultipleObjects(
                            sizeof(rgWaitHandles) / sizeof(HANDLE),
                            rgWaitHandles,
                            FALSE, // wait for any one event
                            dwDiscoveryInterval);

        if (WAIT_OBJECT_0 == dwWaitStatus)
        {
            // hExit was signalled
            goto done;
        }

        if ((WAIT_OBJECT_0+1) == dwWaitStatus)
        {
            // g_hImmediateDiscovery was signalled
            // reduce dwDiscoveryInterval

            dwDiscoveryInterval = DISCOVERY_INTERVAL;
        }

        if ((WAIT_OBJECT_0+2) == dwWaitStatus)
        {
            // g_hDiscoverySoon was signalled
            // reduce dwDiscoveryInterval, but wait one round

            dwDiscoveryInterval = DISCOVERY_INTERVAL;
            bSkipOne = TRUE;
        }

        // we timed out, or hImmediateDiscovery was signalled.  Re-start
        // discovery
    }

done:

    return 1;
}

extern "C" void
TLSShutdown()
{
    if (0 < InterlockedDecrement(&lLibUsage))
    {
        //
        // Someone else is using it
        //
        return;
    }

    TLSStopDiscovery();

    LsCsp_Exit();
}

extern "C" DWORD WINAPI
TLSInit()
{
    LICENSE_STATUS status;

    if (0 != InterlockedExchangeAdd(&lLibUsage,1))
    {
        //
        // Already been initialized
        //
        return ERROR_SUCCESS;
    }

    status = LsCsp_Initialize();
    if (LICENSE_STATUS_OK != status)
    {
        switch (status)
        {        
            case LICENSE_STATUS_OUT_OF_MEMORY:
                return ERROR_NOT_ENOUGH_MEMORY;

            case LICENSE_STATUS_NO_CERTIFICATE:
                return SCARD_E_CERTIFICATE_UNAVAILABLE;

            case LICENSE_STATUS_INVALID_CERTIFICATE:
                return CERT_E_MALFORMED;

            default:
                return E_FAIL;
        }
    }

    return ERROR_SUCCESS;
}

extern "C" DWORD WINAPI
TLSStartDiscovery()
{
    HANDLE hCachingThread = NULL;
    HANDLE hEvent;

    if (NULL != g_hCachingThreadExit)
    {
        // already started
        return ERROR_SUCCESS;
    }

    //
    // Create the event to signal thread exit
    //
        
    g_hCachingThreadExit = CreateEvent( NULL, FALSE, FALSE, NULL );
    
    if( NULL == g_hCachingThreadExit )
    {
        return GetLastError();
    }

    g_hImmediateDiscovery = CreateEvent(NULL,FALSE,FALSE,NULL);

    if (NULL == g_hImmediateDiscovery)
    {
        hEvent = g_hCachingThreadExit; 
        g_hCachingThreadExit = NULL;

        CloseHandle(hEvent);

        return GetLastError();
    }


    g_hDiscoverySoon = CreateEvent(NULL,FALSE,FALSE,NULL);

    if (NULL == g_hDiscoverySoon)
    {
        hEvent = g_hCachingThreadExit; 
        g_hCachingThreadExit = NULL;

        CloseHandle(hEvent);

        hEvent = g_hImmediateDiscovery; 
        g_hImmediateDiscovery = NULL;

        CloseHandle(hEvent);

        return GetLastError();
    }

    //
    // Create the caching thread
    //
        
    hCachingThread = CreateThread(
                                    NULL,
                                    0,
                                    LicenseServerCachingThread,
                                    ( LPVOID )g_hCachingThreadExit,
                                    0,
                                    NULL );

    if (hCachingThread == NULL)
    {
        hEvent = g_hCachingThreadExit; 
        g_hCachingThreadExit = NULL;

        CloseHandle(hEvent);

        hEvent = g_hImmediateDiscovery; 
        g_hImmediateDiscovery = NULL;

        CloseHandle(hEvent);

        hEvent = g_hDiscoverySoon; 
        g_hDiscoverySoon = NULL;

        CloseHandle(hEvent);

        return GetLastError();
    }

    CloseHandle(hCachingThread);

    return ERROR_SUCCESS;
}

extern "C" DWORD WINAPI
TLSStopDiscovery()
{
    HANDLE hEvent;

    //
    // Signal the thread to exit
    //

    if (NULL != g_hCachingThreadExit)
    {
        SetEvent( g_hCachingThreadExit );

        hEvent = g_hCachingThreadExit;
        g_hCachingThreadExit = NULL;

        CloseHandle(hEvent);

        hEvent = g_hImmediateDiscovery;
        g_hImmediateDiscovery = NULL;

        CloseHandle(hEvent);

        hEvent = g_hDiscoverySoon;
        g_hDiscoverySoon = NULL;

        CloseHandle(hEvent);
    }

    return ERROR_SUCCESS;
}

//
// Number of DCs to allocate space for at a time
//
#define DC_LIST_CHUNK   10

//+------------------------------------------------------------------------
// Function:   
//
//      EnumerateLsServer()
//
// Description:
//
//      Routine to enumerate all hydra license server in network
//
// Arguments:
//
//      szScope - Scope limit, NULL if doen't care.
//      dwPlatformType - verify if license server have licenses for this platform, 
//                       LSKEYPACKPLATFORMTYPE_UNKNOWN if doesn't care.
//      fCallBack - call back routine when EnumerateServer() founds any server,
//      dwUserData - data to be pass to call back routine
//    
// Return Value:
//
//      RPC_S_OK or any RPC specific error code.
//
// NOTE: 
//
//      Enumeration terminate when either there is no more server or call back
//      routine return TRUE.
//
//-------------------------------------------------------------------------
DWORD WINAPI
EnumerateTlsServerInDomain(  
    IN LPCTSTR szDomain,                           
    IN TLSENUMERATECALLBACK fCallBack, 
    IN HANDLE dwUserData,
    IN DWORD dwTimeOut,
    IN BOOL fRegOnly,
    IN OUT BOOL *pfOffSite
    )
/*++

++*/
{   
    DWORD entriesread = 0;
    BOOL bCancel=FALSE;
    DWORD dwErrCode;
    LPWSTR pwszServerTmp = NULL;
    LPWSTR pwszServer = NULL;
    HRESULT hr;
    LPWSTR pwszServers = NULL;
    LPWSTR pwszServersTmp = NULL;
    DWORD cchServers = 0;
    DWORD cchServer;
    LPWSTR *rgwszServers = NULL;
    LPWSTR *rgwszServersTmp;
    LPWSTR pwszServerNames = NULL;
    DWORD dwErr = ERROR_SUCCESS, i;
    HANDLE hDcOpen = NULL;
    LPWSTR szSiteName = NULL;
    BOOL fOffSiteIn;
    BOOL fFoundOne = FALSE;
    BOOL fFoundOneOffSite = FALSE;
    DWORD cChunks = 0;
    DWORD cServersOnSite = 0;   
    

    if (fRegOnly)
    {
        //
        // check for a license server in the registry
        //
        hr = GetLicenseServersFromReg(REG_DOMAIN_SERVER_MULTI,&pwszServerNames,&entriesread,&rgwszServers);
        if (FAILED(hr))
        {
            dwErr = hr;
            goto Cleanup;
        }
    } 
    else
    {
        if (NULL == pfOffSite)
        {
            return ERROR_INVALID_PARAMETER;
        }

        fOffSiteIn = *pfOffSite;

        *pfOffSite = FALSE;

        dwErr = DsGetSiteName(NULL,&szSiteName);
        if(dwErr != ERROR_SUCCESS)
        {
#ifdef PRIVATEDEBUG
            wprintf(L"DsGetSiteName failed %x\n",dwErr);
#endif
            goto Cleanup;
        }

        dwErr = DsGetDcOpenW(szDomain,
                             fOffSiteIn ? DS_NOTIFY_AFTER_SITE_RECORDS: DS_ONLY_DO_SITE_NAME,
                             szSiteName,
                             NULL,       // DomainGuid
                             NULL,       // DnsForestName
                             0,          // Flags
                             &hDcOpen
                             );

        if(dwErr != ERROR_SUCCESS)
        {
#ifdef PRIVATEDEBUG
            wprintf(L"DsGetDcOpen failed %x\n",dwErr);
#endif
            goto Cleanup;
        }

        rgwszServers = (LPWSTR *) LocalAlloc(LPTR,
                                             DC_LIST_CHUNK * sizeof(LPWSTR));
        if (NULL == rgwszServers)
        {
#ifdef PRIVATEDEBUG
            wprintf(L"Out of memory\n");
#endif
            dwErr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        cChunks = 1;

        //
        // Read the whole DC list
        //

        do
        {
            if (entriesread >= (cChunks * DC_LIST_CHUNK))
            {                
                cChunks++;

                rgwszServersTmp = (LPWSTR *)
                    LocalReAlloc(rgwszServers,
                                 DC_LIST_CHUNK * sizeof(LPWSTR) * cChunks,
                                 LHND);

                if (NULL == rgwszServersTmp)
                {
                    dwErr = E_OUTOFMEMORY;
                    goto Cleanup;
                }
                else
                {
                    rgwszServers = rgwszServersTmp;
                }
            }

            dwErr = DsGetDcNextW(hDcOpen,
                                 NULL,
                                 NULL,
                                 rgwszServers+entriesread);         

            
            if (ERROR_FILEMARK_DETECTED == dwErr)
            {                
                                
                // Now going off-site; use NULL ptr marker

                rgwszServers[entriesread] = NULL;

                cServersOnSite = entriesread;

                dwErr = ERROR_SUCCESS;

                fFoundOneOffSite = TRUE;
            }                  

            entriesread++;

        } while (ERROR_SUCCESS == dwErr);

        // don't count the final error
        entriesread--;

        if (!fFoundOneOffSite)
            cServersOnSite = entriesread;

        // Now randomize the two portions of the array

        RandomizeArray(rgwszServers,cServersOnSite);

        if (fFoundOneOffSite)
        {
            RandomizeArray(rgwszServers+cServersOnSite+1,
                           entriesread - cServersOnSite - 1);
        }

        // Now allocate memory for registry entry

        pwszServers = (LPWSTR) LocalAlloc(LPTR,2*sizeof(WCHAR));
        if (NULL == pwszServers)
        {
#ifdef PRIVATEDEBUG
            wprintf(L"Out of memory\n");
#endif
            dwErr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        cchServers = 2;
        pwszServers[0] = pwszServers[1] = L'\0';
    }

    for(i=0; bCancel == FALSE; i++)
    {
        PCONTEXT_HANDLE pContext=NULL;
        RPC_STATUS rpcStatus;

        if (!fRegOnly)
        {
            if (fFoundOneOffSite && i == cServersOnSite)
            {
                if (fFoundOne)
                    break;

                // Now going off-site

                i++;
                *pfOffSite = TRUE;
            }
        }

        if (i >= entriesread)
            break;

        pwszServerTmp = rgwszServers[i];

        bCancel=fCallBack(pContext, pwszServerTmp, dwUserData);
        if(bCancel == TRUE)
            continue;

        if(!(pContext = TLSConnectToLsServer(pwszServerTmp)))
        {
            //
            // could be access denied.
            //
#ifdef PRIVATEDEBUG
    wprintf(L"Can't connect to %s\n",pwszServerTmp);
#endif

            continue;
        }        

#ifdef PRIVATEDEBUG
    wprintf(L"!!!Connected to %s\n",pwszServerTmp);
#endif
        do {
            //
            // Skip enterprise server
            //
            DWORD dwVersion;
            rpcStatus = TLSGetVersion( pContext, &dwVersion );
            if(rpcStatus != RPC_S_OK)
            {
                break;
            }

#if ENFORCE_LICENSING

            //
            // W2K Beta 3 to RC1 upgrade, don't connect to any non-enforce
            // server 5.2 or older
            //
            if(IS_ENFORCE_LSSERVER(dwVersion) == FALSE)
            {
                if( GET_LSSERVER_MAJOR_VERSION(dwVersion) <= 5 &&
                    GET_LSSERVER_MINOR_VERSION(dwVersion) <= 2 )
                {
#if DBG
                    OutputDebugString(pwszServerTmp);
                    OutputDebugString(_TEXT(" old License Server\n"));
#endif
                    continue;
                }
            }


            //
            // Prevent beta <-> RTM server talking to each other
            //

            //
            // TLSIsBetaNTServer() returns TRUE if eval NT
            // IS_LSSERVER_RTM() returns TRUE if LS is an RTM.
            //

            if( TLSIsBetaNTServer() == IS_LSSERVER_RTM(dwVersion) )
            {
                continue;
            }
#endif

            if(dwVersion & TLS_VERSION_ENTERPRISE_BIT)
            {
                continue;
            }           

            bCancel=fCallBack(pContext, pwszServerTmp, dwUserData);    

            if (!fRegOnly)
            {
                // 
                // Add to list of servers
                //
                cchServer = wcslen(pwszServerTmp);
                
                pwszServersTmp = (LPWSTR) LocalReAlloc(pwszServers,(cchServers+cchServer+1)*sizeof(TCHAR),LHND);
                if (NULL == pwszServersTmp)
                {
                    break;
                }
                
                pwszServers = pwszServersTmp;
                
                if (cchServers == 2)
                {
                    wcscpy(pwszServers,pwszServerTmp);
                    
                    cchServers += cchServer;
                } else
                {
                    wcscpy(pwszServers+cchServers-1,pwszServerTmp);
                    
                    cchServers += cchServer + 1;
                    
                }
                pwszServers[cchServers-1] = L'\0';
            }

            fFoundOne = TRUE;

        } while (FALSE);

        if(bCancel == FALSE && pContext != NULL)
        {
            TLSDisconnect(&pContext);
        }

    } // for loop

    if (!fRegOnly)
    {
        WriteLicenseServersToReg(REG_DOMAIN_SERVER_MULTI,pwszServers,cchServers);
    }

Cleanup:
    if (NULL != hDcOpen)
        DsGetDcCloseW(hDcOpen);

    if (NULL != rgwszServers)
    {
        if (!fRegOnly)
        {
            for (i = 0; i < entriesread; i++)
            {
                if (NULL != rgwszServers[i])
                {
                    NetApiBufferFree(rgwszServers[i]);
                }
            }
        }
        LocalFree(rgwszServers);
    }

    if (szSiteName)
        NetApiBufferFree(szSiteName);

    if (pwszServerNames)
        LocalFree(pwszServerNames);

    if (pwszServers)
        LocalFree(pwszServers);

    if (pwszServer)
        LocalFree(pwszServer);

    return dwErr;
}

DWORD WINAPI
EnumerateTlsServerInWorkGroup(  
    IN TLSENUMERATECALLBACK pfCallBack, 
    IN HANDLE dwUserData,
    IN DWORD dwTimeOut,
    IN BOOL fRegOnly
    )
/*++


++*/
{   
    DWORD dwStatus=ERROR_SUCCESS;

    TCHAR szServerMailSlotName[MAX_PATH+1];
    TCHAR szLocalMailSlotName[MAX_PATH+1];

    HANDLE hClientSlot = INVALID_HANDLE_VALUE;
    HANDLE hServerSlot = INVALID_HANDLE_VALUE;

    TCHAR szDiscMsg[MAX_MAILSLOT_MSG_SIZE+1];
    TCHAR szComputerName[MAXCOMPUTERNAMELENGTH+1];
    TCHAR szRandomMailSlotName[MAXCOMPUTERNAMELENGTH+1];

    DWORD cbComputerName=MAXCOMPUTERNAMELENGTH+1;

    DWORD cbWritten=0;
    DWORD cbRead=0;    
    BOOL bCancel = FALSE;
    DWORD dwErrCode;
    HRESULT hr;
    LPWSTR pwszServers = NULL;
    LPWSTR pwszServersTmp = NULL;
    DWORD cchServers = 0;
    DWORD cchServer;
    LPWSTR *rgwszServers = NULL;
    LPWSTR pwszServerNames = NULL;
    DWORD cServers = 0;
    DWORD i = 0;
    LPWSTR pwszServerTmp = szComputerName;


    if (!fRegOnly)
    {
        if(!GetComputerName(szComputerName, &cbComputerName))
        {
            dwStatus = GetLastError();
            goto cleanup;
        }

        if (0 == (1 & GetSystemMetrics(SM_NETWORK)))
        {
            // No network; try local machine
#ifdef PRIVATEDEBUG
            wprintf(L"No network, trying local computer=%s\n",szComputerName);
#endif
            dwStatus = ERROR_SUCCESS;
            goto TryServer;
        }

        wsprintf(
                 szRandomMailSlotName,
                 _TEXT("%08x"),
                 GetCurrentThreadId()
                 );
            
        _stprintf(
                  szLocalMailSlotName, 
                  _TEXT("\\\\.\\mailslot\\%s"), 
                  szRandomMailSlotName
                  );

        // 
        // Create local mail slot for server's response
        //
        hClientSlot=CreateMailslot( 
                                   szLocalMailSlotName, 
                                   0,
                                   (dwTimeOut == MAILSLOT_WAIT_FOREVER) ? 5 * 1000: dwTimeOut,
                                   NULL
                                   );

        if(hClientSlot == INVALID_HANDLE_VALUE)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }

        //
        // Open server's mail slot
        //
        _stprintf(
                  szServerMailSlotName, 
                  _TEXT("\\\\%s\\mailslot\\%s"), 
                  _TEXT("*"), 
                  _TEXT(SERVERMAILSLOTNAME)
                  );

        hServerSlot=CreateFile(
                               szServerMailSlotName,
                               GENERIC_WRITE,             // only need write
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL
                               );
        if(hServerSlot == INVALID_HANDLE_VALUE)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }

        //
        // Formulate discovery message
        //
        _stprintf(
                  szDiscMsg, 
                  _TEXT("%s %c%s%c %c%s%c"), 
                  _TEXT(LSERVER_DISCOVERY), 
                  _TEXT(LSERVER_OPEN_BLK), 
                  szComputerName,
                  _TEXT(LSERVER_CLOSE_BLK),
                  _TEXT(LSERVER_OPEN_BLK), 
                  szRandomMailSlotName,
                  _TEXT(LSERVER_CLOSE_BLK)
                  );

        if (!WriteFile(hServerSlot, szDiscMsg, (_tcslen(szDiscMsg) + 1) * sizeof(TCHAR), &cbWritten, NULL) ||
            (cbWritten != (_tcslen(szDiscMsg) + 1 ) * sizeof(TCHAR)))
        {
            dwStatus = GetLastError();
            
            if (dwStatus == ERROR_NETWORK_UNREACHABLE)
            {
                // No network; try local machine
#ifdef PRIVATEDEBUG
                wprintf(L"No network, trying local computer=%s\n",szComputerName);
#endif
                dwStatus = ERROR_SUCCESS;
                goto TryServer;
            }
            else
            {
                goto cleanup;            
            }
        }

        // Allocate for registry entry

        pwszServers = (LPWSTR) LocalAlloc(LPTR,2*sizeof(WCHAR));
        if (NULL == pwszServers)
        {
#ifdef PRIVATEDEBUG
            wprintf(L"Out of memory\n");
#endif
            
            dwStatus = E_OUTOFMEMORY;
            goto cleanup;
        }
        
        cchServers = 2;
        pwszServers[0] = pwszServers[1] = L'\0';
    } else
    {
        //
        // check for a license server in the registry
        //

        hr = GetLicenseServersFromReg(REG_DOMAIN_SERVER_MULTI,&pwszServerNames,&cServers,&rgwszServers);
        if (FAILED(hr))
        {
            dwStatus = hr;
            goto cleanup;
        }
    }

    do {
        if(fRegOnly)
        {
            if (i >= cServers)
            {
                break;
            }

            pwszServerTmp = rgwszServers[i++];
        } else
        {
            memset(szComputerName, 0, sizeof(szComputerName));
            if(!ReadFile(hClientSlot, szComputerName, sizeof(szComputerName) - sizeof(TCHAR), &cbRead, NULL))
            {
                dwStatus=GetLastError();
                break;
            }

#ifdef PRIVATEDEBUG
            wprintf(L"Trying server=%s\n",szComputerName);
#endif

        }

TryServer:

        bCancel=pfCallBack(NULL, pwszServerTmp, dwUserData);
        if(bCancel == TRUE)
        {
            continue;
        }

        PCONTEXT_HANDLE pContext=NULL;
        RPC_STATUS rpcStatus;

        if(!(pContext = TLSConnectToLsServer(pwszServerTmp)))
        {
            //
            // could be access denied.
            //
            continue;
        }

        do {            
            //
            // Skip enterprise server
            //
            DWORD dwVersion;
            rpcStatus = TLSGetVersion( pContext, &dwVersion );
            if(rpcStatus != RPC_S_OK)
            {
                continue;
            }

#if ENFORCE_LICENSING

            //
            // W2K Beta 3 to RC1 upgrade, don't connect to any non-enforce
            // server 5.2 or older
            //
            if(IS_ENFORCE_LSSERVER(dwVersion) == FALSE)
            {
                if( GET_LSSERVER_MAJOR_VERSION(dwVersion) <= 5 &&
                    GET_LSSERVER_MINOR_VERSION(dwVersion) <= 2 )
                {
#if DBG
                    OutputDebugString(pwszServerTmp);
                    OutputDebugString(_TEXT(" old License Server\n"));
#endif
                    continue;
                }
            }
            
            //
            // No Beta <--> RTM server.
            //
            //
            // TLSIsBetaNTServer() returns TRUE if eval NT
            // IS_LSSERVER_RTM() returns TRUE if LS is an RTM.
            //
            if( TLSIsBetaNTServer() == IS_LSSERVER_RTM(dwVersion) )
            {
                continue;
            }

#endif

            if(dwVersion & TLS_VERSION_ENTERPRISE_BIT)
            {
                continue;
            }           
        
            bCancel=pfCallBack(pContext, pwszServerTmp, dwUserData);    
            
            if (!fRegOnly)
            {
                // 
                // Add to list of servers
                //
                cchServer = wcslen(pwszServerTmp);
                    
                pwszServersTmp = (LPWSTR) LocalReAlloc(pwszServers,(cchServers+cchServer+1)*sizeof(TCHAR),LHND);
                if (NULL == pwszServersTmp)
                {
                    continue;
                }
                
                pwszServers = pwszServersTmp;
                
                if (cchServers == 2)
                {
                    wcscpy(pwszServers,pwszServerTmp);
                
                    cchServers += cchServer;
                } else
                {
                    wcscpy(pwszServers+cchServers-1,pwszServerTmp);
                    
                    cchServers += cchServer + 1;
                
                }
                pwszServers[cchServers-1] = L'\0';
            }
        } while (FALSE);

        if(bCancel == FALSE && pContext != NULL)
        {
            TLSDisconnectFromServer(pContext);
        }

    } while(bCancel == FALSE);

    if (!fRegOnly)
    {
        WriteLicenseServersToReg(REG_DOMAIN_SERVER_MULTI,pwszServers,cchServers);
    }


cleanup:    

    if(hClientSlot != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hClientSlot);
    }

    if(hServerSlot != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hServerSlot);
    }

    if (pwszServerNames)
        LocalFree(pwszServerNames);

    if (pwszServers)
        LocalFree(pwszServers);

    if (rgwszServers)
        LocalFree(rgwszServers);

    return dwStatus;
}

DWORD 
GetServersFromRegistry(
                       LPWSTR wszRegKey,
                       LPWSTR **prgszServers,
                       DWORD  *pcCount
                       )
{
    HKEY hParamKey = NULL;
    DWORD dwValueType;
    DWORD cbValue = 0, dwDisp;
    LONG lReturn;
    DWORD cbServer;
    DWORD cServers;
    DWORD cchServerMax;
    LPWSTR *rgszServers;
    DWORD i, j;

    *prgszServers = NULL;
    *pcCount = 0;

    lReturn = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           wszRegKey,
                           0,
                           KEY_READ,
                           &hParamKey );

    if (ERROR_SUCCESS != lReturn)
        return lReturn;

    lReturn = RegQueryInfoKey(hParamKey,
                              NULL,
                              NULL,
                              NULL,
                              &cServers,
                              &cchServerMax,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL);

    if (ERROR_SUCCESS != lReturn)
    {
        RegCloseKey( hParamKey );
        return lReturn;
    }

    if (0 == cServers)
    {
        RegCloseKey( hParamKey );
        return ERROR_NO_MORE_ITEMS;
    }

    rgszServers = (LPWSTR *) LocalAlloc(LPTR,cServers*sizeof(LPWSTR));
    if (NULL == rgszServers)
    {
        RegCloseKey( hParamKey );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Add one for null terminator
    cchServerMax++;
    
    for (i = 0; i < cServers; i++)
    {
        rgszServers[i] = (LPWSTR) LocalAlloc(LPTR,cchServerMax * sizeof(WCHAR));

        if (NULL == rgszServers[i])
        {
            for (j = 0; j < i; j++)
            {
                LocalFree(rgszServers[j]);
            }
            LocalFree(rgszServers);

            RegCloseKey( hParamKey );
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        cbServer = cchServerMax * sizeof(WCHAR);

        lReturn = RegEnumKeyEx(hParamKey,
                               i,
                               rgszServers[i],
                               &cbServer,
                               NULL,
                               NULL,
                               NULL,
                               NULL);

        if (ERROR_SUCCESS != lReturn)
        {
            for (j = 0; j <= i; j++)
            {
                LocalFree(rgszServers[j]);
            }
            LocalFree(rgszServers);

            RegCloseKey( hParamKey );

            return lReturn;
        }
    }

    *prgszServers = rgszServers;
    *pcCount = cServers;

    return ERROR_SUCCESS;
}

DWORD WINAPI
EnumerateTlsServerInRegistry(
    IN TLSENUMERATECALLBACK pfCallBack, 
    IN HANDLE dwUserData,
    IN DWORD dwTimeOut,
    LPWSTR wszRegKey
    )
/*++


++*/
{
    BOOL bCancel=FALSE;
    DWORD dwIndex = 0;
    DWORD cServers = 0;
    LPWSTR *rgszServers = NULL;
    DWORD lReturn;

    lReturn = GetServersFromRegistry(wszRegKey,
                                     &rgszServers,
                                     &cServers
                                     );

    if (ERROR_SUCCESS != lReturn)
    {
        return lReturn;
    }

    RandomizeArray(rgszServers,cServers);

    for (;dwIndex < cServers; dwIndex++)
    {
        PCONTEXT_HANDLE pContext=NULL;
        RPC_STATUS rpcStatus;

        bCancel=pfCallBack(pContext, rgszServers[dwIndex], dwUserData);
        if(bCancel == TRUE)
            continue;

        if(!(pContext = TLSConnectToLsServer(rgszServers[dwIndex])))
        {
            //
            // could be access denied, or the machine is gone
            //

            continue;
        }

        do {            
            //
            // Skip enterprise server
            //
            DWORD dwVersion;
            rpcStatus = TLSGetVersion( pContext, &dwVersion );
            if(rpcStatus != RPC_S_OK)
            {
                break;
            }

#if ENFORCE_LICENSING

            //
            // W2K Beta 3 to RC1 upgrade, don't connect to any non-enforce
            // server 5.2 or older
            //
            if(IS_ENFORCE_LSSERVER(dwVersion) == FALSE)
            {
                if( GET_LSSERVER_MAJOR_VERSION(dwVersion) <= 5 &&
                    GET_LSSERVER_MINOR_VERSION(dwVersion) <= 2 )
                {
                    // old License Server
                    continue;
                }
            }


            //
            // Prevent beta <-> RTM server talking to each other
            //

            //
            // TLSIsBetaNTServer() returns TRUE if eval NT
            // IS_LSSERVER_RTM() returns TRUE if LS is an RTM.
            //

            if( TLSIsBetaNTServer() == IS_LSSERVER_RTM(dwVersion) )
            {
                continue;
            }
#endif

            if(dwVersion & TLS_VERSION_ENTERPRISE_BIT)
            {
                break;
            }            

            bCancel=pfCallBack(pContext, rgszServers[dwIndex], dwUserData);    

        } while (FALSE);

        if(bCancel == FALSE && pContext != NULL)
        {
            TLSDisconnect(&pContext);
        }

    } // for loop

    for (dwIndex = 0; dwIndex < cServers; dwIndex++)
    {
        LocalFree(rgszServers[dwIndex]);
    }
    LocalFree(rgszServers);

    return ERROR_SUCCESS;
}

DWORD WINAPI
EnumerateTlsServer(  
    IN TLSENUMERATECALLBACK pfCallBack, 
    IN HANDLE dwUserData,
    IN DWORD dwTimeOut,
    IN BOOL fRegOnly
    )
/*++


++*/
{
    DWORD dwErr;
    LPWSTR szDomain = NULL;
    BOOL fOffSite = FALSE;      // don't try to go off-site

    //
    // First check for a registry bypass of discovery
    //

    dwErr = EnumerateTlsServerInRegistry(
                                         pfCallBack,
                                         dwUserData,
                                         dwTimeOut,
                                         TEXT(TERMINAL_SERVICE_PARAM_DISCOVERY)
                                         );

    if ((!fRegOnly) || (g_fInDomain == -1))
    {
        //
        // Check even if set (for !fRegOnly), to get domain name
        //
        dwErr = TLSInDomain(&g_fInDomain, fRegOnly ? NULL : &szDomain);
        if (dwErr != NO_ERROR)
            return dwErr;
    }
    
    //
    // Reading registry failed, use full discovery
    //

    if(g_fInDomain)
    {
        dwErr = EnumerateTlsServerInDomain(
                                szDomain,
                                pfCallBack,
                                dwUserData,
                                dwTimeOut,
                                fRegOnly,
                                &fOffSite
                            );

        if ((dwErr == NO_ERROR) && !fRegOnly)
        {
            g_fOffSiteLicenseServer = fOffSite;
        }
    }
    else
    {
        dwErr = EnumerateTlsServerInWorkGroup(
                                              pfCallBack,
                                              dwUserData,
                                              dwTimeOut,
                                              fRegOnly
                                              );
    }

    if (NULL != szDomain)
    {
        NetApiBufferFree(szDomain);
    }

    if ((NULL != g_hImmediateDiscovery)
        && (dwErr != NO_ERROR) && fRegOnly)
    {
        SetEvent(g_hImmediateDiscovery);
    }

    if ((NULL != g_hDiscoverySoon)
        && (dwErr == NO_ERROR) && fOffSite && !fRegOnly)
    {
        SetEvent(g_hDiscoverySoon);
    }


    return dwErr;
}

TLS_HANDLE
ConnectAndCheckServer(LPWSTR szServer)
{
    TLS_HANDLE hBinding;
    DWORD dwVersion;
    RPC_STATUS rpcStatus;
    
    hBinding = TLSConnectToLsServer(szServer);

    if(hBinding == NULL)
    {
        goto done;
    }

    // Skip Windows 2000 License servers

        
    DWORD dwSupportFlags = 0;
    DWORD dwErrCode = 0;

        dwErrCode = TLSGetSupportFlags(
            hBinding,
            &dwSupportFlags
    );

	if ((dwErrCode == RPC_S_OK) && !(dwSupportFlags & SUPPORT_WHISTLER_CAL))
    {                    
        TLSDisconnect(&hBinding);
        goto done;
    }

    // If the call fails => Windows 2000 LS
    else if(dwErrCode != RPC_S_OK)
    {
        TLSDisconnect(&hBinding);
        goto done;
    }


    rpcStatus = TLSGetVersion( 
                              hBinding, 
                              &dwVersion 
                              );

    if(rpcStatus != RPC_S_OK)
    {
        TLSDisconnect(&hBinding);
        goto done;
    }
            
    if( TLSIsBetaNTServer() == IS_LSSERVER_RTM(dwVersion) )
    {
        TLSDisconnect(&hBinding);
        goto done;
    }

done:
    return hBinding;
}
 
//+------------------------------------------------------------------------
// Function:   TLSConnectToAnyLsServer()
//
// Description:
//
//      Routine to bind to any license server
//
// Arguments:
//      dwTimeout - INFINITE for going off-site
//
// Return Value:
//
//      RPC binding handle or NULL if error, use GetLastError() to retrieve
//      detail error.
//-------------------------------------------------------------------------
TLS_HANDLE WINAPI
TLSConnectToAnyLsServer(
    DWORD dwTimeout
    )
/*++

++*/
{
    TLS_HANDLE hBinding=NULL;
    HRESULT hr = S_OK;
    LPWSTR *rgszServers = NULL;
    DWORD cServers = 0;
    DWORD i;
    DWORD dwErr;
    BOOL fInDomain;
    LPWSTR szDomain = NULL;
    LPWSTR szServerFound = NULL;
    BOOL fRegOnly = (dwTimeout != INFINITE);
    LPWSTR pwszServerNames = NULL;
    BOOL fFreeServerNames = TRUE;

    // TODO: add error codes/handling to all of this

    //
    // First check for a registry bypass of discovery
    //

    dwErr = GetServersFromRegistry(
                                   TEXT(TERMINAL_SERVICE_PARAM_DISCOVERY),
                                   &rgszServers,
                                   &cServers
                                   );

    if (ERROR_SUCCESS == dwErr)
    {
        RandomizeArray(rgszServers,cServers);

        for (i = 0; i < cServers; i++)
        {
            hBinding = ConnectAndCheckServer(rgszServers[i]);

            if (NULL != hBinding)
            {
                szServerFound = rgszServers[i];
                goto found_one;
            }
        }

        if(NULL != rgszServers)
        {
            for (i = 0; i < cServers; i++)
            {
                LocalFree(rgszServers[i]);
            }
            LocalFree(rgszServers);
            
            rgszServers = NULL;
        }
    }
                                         
    //
    // Next try Site (Enterprise) license servers
    //

    if (!fRegOnly)
    {
        hr = GetAllEnterpriseServers(&rgszServers,&cServers);

        if (SUCCEEDED(hr))
        {
            RandomizeArray(rgszServers,cServers);
        }
    }
    else
    {
        // rgszServers[i] is an index into pwszServerNames; don't free
        fFreeServerNames = FALSE;

        hr = GetLicenseServersFromReg(ENTERPRISE_SERVER_MULTI,
                                      &pwszServerNames,
                                      &cServers,
                                      &rgszServers);
    }

    if (SUCCEEDED(hr))
    {
        for (i = 0; i < cServers; i++)
        {
            hBinding = ConnectAndCheckServer(rgszServers[i]);

            if (NULL != hBinding)
            {
                szServerFound = rgszServers[i];
                goto found_one;
            }
        }

        if(NULL != rgszServers)
        {
            if (fFreeServerNames)
            {
                for (i = 0; i < cServers; i++)
                {
                    LocalFree(rgszServers[i]);
                }
                LocalFree(rgszServers);
            }

            rgszServers = NULL;
        }
    }


    // 
    // No Site LS found, try Domain/Workgroup servers
    //

    dwErr = TLSInDomain(&fInDomain, &szDomain);
    if (dwErr != NO_ERROR)
        return NULL;

    LS_ENUM_PARAM param;

    param.hBinding = &hBinding;
    param.dwTimeout = INFINITE;
    QueryPerformanceCounter(&(param.timeInitial));

    fFreeServerNames = TRUE;

    if (fInDomain)
    {
        BOOL fOffSite = TRUE;

        dwErr = EnumerateTlsServerInDomain(
                                szDomain,
                                BindAnyServer,
                                &param,
                                INFINITE,
                                fRegOnly,
                                &fOffSite
                            );

        if (dwErr == NO_ERROR)
        {
            g_fOffSiteLicenseServer = fOffSite;
        }
    }
    else
    {
        dwErr = EnumerateTlsServerInWorkGroup(
                                              BindAnyServer,
                                              &param,
                                              MAILSLOT_WAIT_FOREVER,
                                              fRegOnly
                                              );        
    }

    if (NULL != szDomain)
    {
        NetApiBufferFree(szDomain);
    }

    if (hBinding != NULL)
        goto found_one;

    if (NULL != pwszServerNames)
    {
        LocalFree(pwszServerNames);
    }

    if ((NULL != g_hImmediateDiscovery)
        && fRegOnly)
    {
        SetEvent(g_hImmediateDiscovery);
    }
    else if ((NULL != g_hDiscoverySoon)
        && !fRegOnly && g_fOffSiteLicenseServer)
    {
        SetEvent(g_hDiscoverySoon);
    }

    return NULL;

found_one:

    if (NULL != pwszServerNames)
    {
        LocalFree(pwszServerNames);
    }

    if(NULL != rgszServers)
    {
        if (fFreeServerNames)
        {
            for (i = 0; i < cServers; i++)
            {
                LocalFree(rgszServers[i]);
            }
        }
        LocalFree(rgszServers);
    }

    return hBinding;
}

BOOL
TLSRefreshLicenseServerCache(
    IN DWORD dwTimeOut
    )
/*++

Abstract:

    Refresh license server cache in registry.

Parameter:

    dwTimeOut : Reserverd, should pass in INIFINITE for now

Returns:

    TRUE/FALSE

--*/
{
    BOOL bFoundServer = FALSE;
    TLS_HANDLE hBinding = NULL;

    hBinding = TLSConnectToAnyLsServer(dwTimeOut);

    if (NULL != hBinding)
    {
        bFoundServer = TRUE;

        TLSDisconnect(&hBinding);
    }

    return bFoundServer;
}

LICENSE_STATUS
InstallCertificate(LPVOID lpParam)
{
    Sleep(INSTALL_CERT_DELAY);

    return LsCsp_InstallX509Certificate(NULL);
}
   

//-------------------------------------------------------------------------

TLS_HANDLE WINAPI
TLSConnectToLsServer( 
    LPTSTR pszLsServer 
    )
/*++

++*/
{
    TCHAR szMachineName[MAX_COMPUTERNAME_LENGTH + 1] ;
    PCONTEXT_HANDLE pContext=NULL;
    DWORD cbMachineName=MAX_COMPUTERNAME_LENGTH;
    HANDLE hThread = NULL;
    static BOOL fLSFound = FALSE;

    memset(szMachineName, 0, sizeof(szMachineName));
    GetComputerName(szMachineName, &cbMachineName);
    if(pszLsServer == NULL || _tcsicmp(szMachineName, pszLsServer) == 0)
    {
        pContext=ConnectLsServer(
                            szMachineName, 
                            _TEXT(RPC_PROTOSEQLPC), 
                            NULL, 
                            RPC_C_AUTHN_LEVEL_DEFAULT
                        );
        if(GetLastError() >= LSERVER_ERROR_BASE)
        {
            return NULL;
        }
        // try to connect with TCP protocol, if local procedure failed
    }

    if(pContext == NULL)
    {
        pContext=ConnectLsServer(
                            pszLsServer, 
                            _TEXT(RPC_PROTOSEQNP), 
                            _TEXT(LSNAMEPIPE), 
                            RPC_C_AUTHN_LEVEL_NONE
                        );
    }

    if (!fLSFound && (NULL != pContext))
    {
        fLSFound = TRUE;

        // Now that someone's connected, we can install a license
        hThread = CreateThread(NULL,
                               0,
                               InstallCertificate,
                               NULL,
                               0,
                               NULL);

        if (hThread != NULL)
        {
            CloseHandle(hThread);
        }
        else
        {
            // Can't create the thread; try again later
            fLSFound = FALSE;
        }

    }

    return (TLS_HANDLE) pContext;
}
//-------------------------------------------------------------------------
void WINAPI
TLSDisconnectFromServer( 
    TLS_HANDLE pHandle 
    )
/*++

++*/
{
    if(pHandle != NULL)
    {
        TLSDisconnect( &pHandle );
    }
}

//----------------------------------------------------------------------------
DWORD WINAPI
TLSConnect( 
    handle_t binding,
    TLS_HANDLE *ppHandle 
    )
/*++

++*/
{
    return TLSRpcConnect(binding, ppHandle);
}

//----------------------------------------------------------------------------
DWORD WINAPI
TLSDisconnect(
    TLS_HANDLE* pphHandle
    )
/*++

++*/
{
    RPC_STATUS rpc_status;

    rpc_status = TLSRpcDisconnect( pphHandle );
    if(rpc_status != RPC_S_OK)
    {
        RpcSmDestroyClientContext(pphHandle);
    }

    *pphHandle = NULL;

    return ERROR_SUCCESS;
}

//-------------------------------------------------------------------------
DWORD WINAPI
TLSGetVersion (
    IN TLS_HANDLE hHandle,
    OUT PDWORD pdwVersion
    )
/*++

++*/
{
    return TLSRpcGetVersion( hHandle, pdwVersion );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSSendServerCertificate( 
     TLS_HANDLE hHandle,
     DWORD cbCert,
     PBYTE pbCert,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcSendServerCertificate(
                                hHandle, 
                                cbCert, 
                                pbCert, 
                                pdwErrCode
                            );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetServerName( 
     TLS_HANDLE hHandle,
     LPTSTR szMachineName,
     PDWORD pcbSize,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcGetServerName(
                            hHandle, 
                            szMachineName, 
                            pcbSize, 
                            pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetServerNameEx( 
     TLS_HANDLE hHandle,
     LPTSTR szMachineName,
     PDWORD pcbSize,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    RPC_STATUS rpc_status;

    rpc_status = TLSRpcGetServerNameEx(
                            hHandle, 
                            szMachineName, 
                            pcbSize, 
                            pdwErrCode
                        );

     if (rpc_status == RPC_S_PROCNUM_OUT_OF_RANGE)

    {
        rpc_status = TLSRpcGetServerName(
                            hHandle, 
                            szMachineName, 
                            pcbSize, 
                            pdwErrCode
                        );
    }

    return rpc_status;
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetServerScope( 
     TLS_HANDLE hHandle,
     LPTSTR szScopeName,
     PDWORD pcbSize,
     PDWORD pdwErrCode)
/*++

++*/
{
    return TLSRpcGetServerScope(
                            hHandle, 
                            szScopeName, 
                            pcbSize, 
                            pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSIssuePlatformChallenge( 
     TLS_HANDLE hHandle,
     DWORD dwClientInfo,
     PCHALLENGE_CONTEXT pChallengeContext,
     PDWORD pcbChallengeData,
     PBYTE* pChallengeData,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcIssuePlatformChallenge(
                                hHandle, 
                                dwClientInfo, 
                                pChallengeContext, 
                                pcbChallengeData, 
                                pChallengeData, 
                                pdwErrCode
                            );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSIssueNewLicense( 
     TLS_HANDLE hHandle,
     CHALLENGE_CONTEXT ChallengeContext,
     LICENSEREQUEST  *pRequest,
     LPTSTR pMachineName,
     LPTSTR pUserName,
     DWORD cbChallengeResponse,
     PBYTE pbChallengeResponse,
     BOOL bAcceptTemporaryLicense,
     PDWORD pcbLicense,
     PBYTE* ppbLicense,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    TLSLICENSEREQUEST rpcRequest;
    RequestToTlsRequest( pRequest, &rpcRequest );

    return TLSRpcRequestNewLicense(
                        hHandle, 
                        ChallengeContext, 
                        &rpcRequest, 
                        pMachineName, 
                        pUserName, 
                        cbChallengeResponse,
                        pbChallengeResponse,
                        bAcceptTemporaryLicense,
                        pcbLicense,
                        ppbLicense,
                        pdwErrCode
                    );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSIssueNewLicenseEx( 
     TLS_HANDLE hHandle,
     PDWORD pSupportFlags,
     CHALLENGE_CONTEXT ChallengeContext,
     LICENSEREQUEST  *pRequest,
     LPTSTR pMachineName,
     LPTSTR pUserName,
     DWORD cbChallengeResponse,
     PBYTE pbChallengeResponse,
     BOOL bAcceptTemporaryLicense,
     DWORD dwQuantity,
     PDWORD pcbLicense,
     PBYTE* ppbLicense,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    DWORD dwStatus;
    TLSLICENSEREQUEST rpcRequest;
    RequestToTlsRequest( pRequest, &rpcRequest );

    dwStatus = TLSRpcRequestNewLicenseEx(
                        hHandle,
                        pSupportFlags,
                        ChallengeContext, 
                        &rpcRequest, 
                        pMachineName, 
                        pUserName, 
                        cbChallengeResponse,
                        pbChallengeResponse,
                        bAcceptTemporaryLicense,
                        dwQuantity,
                        pcbLicense,
                        ppbLicense,
                        pdwErrCode
                    );

    if (dwStatus == RPC_S_PROCNUM_OUT_OF_RANGE)
    {
        *pSupportFlags = 0;

        dwStatus = TLSRpcRequestNewLicense(
                        hHandle,
                        ChallengeContext, 
                        &rpcRequest, 
                        pMachineName, 
                        pUserName, 
                        cbChallengeResponse,
                        pbChallengeResponse,
                        bAcceptTemporaryLicense,
                        pcbLicense,
                        ppbLicense,
                        pdwErrCode
                    );
    }

    return(dwStatus);
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSIssueNewLicenseExEx( 
     TLS_HANDLE hHandle,
     PDWORD pSupportFlags,
     CHALLENGE_CONTEXT ChallengeContext,
     LICENSEREQUEST  *pRequest,
     LPTSTR pMachineName,
     LPTSTR pUserName,
     DWORD cbChallengeResponse,
     PBYTE pbChallengeResponse,
     BOOL bAcceptTemporaryLicense,
     BOOL bAcceptFewerLicenses,
     DWORD *pdwQuantity,
     PDWORD pcbLicense,
     PBYTE* ppbLicense,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    DWORD dwStatus;
    TLSLICENSEREQUEST rpcRequest;
    RequestToTlsRequest( pRequest, &rpcRequest );

    dwStatus = TLSRpcRequestNewLicenseExEx(
                        hHandle,
                        pSupportFlags,
                        ChallengeContext, 
                        &rpcRequest, 
                        pMachineName, 
                        pUserName, 
                        cbChallengeResponse,
                        pbChallengeResponse,
                        bAcceptTemporaryLicense,
                        bAcceptFewerLicenses,
                        pdwQuantity,
                        pcbLicense,
                        ppbLicense,
                        pdwErrCode
                    );

    if (dwStatus == RPC_S_PROCNUM_OUT_OF_RANGE)
    {
        dwStatus = TLSRpcRequestNewLicenseEx(
                        hHandle,
                        pSupportFlags,
                        ChallengeContext, 
                        &rpcRequest, 
                        pMachineName, 
                        pUserName, 
                        cbChallengeResponse,
                        pbChallengeResponse,
                        bAcceptTemporaryLicense,
                        *pdwQuantity,
                        pcbLicense,
                        ppbLicense,
                        pdwErrCode
                        );

        if (dwStatus == RPC_S_PROCNUM_OUT_OF_RANGE)
        {
            *pSupportFlags = 0;

            dwStatus = TLSRpcRequestNewLicense(
                        hHandle,
                        ChallengeContext, 
                        &rpcRequest, 
                        pMachineName, 
                        pUserName, 
                        cbChallengeResponse,
                        pbChallengeResponse,
                        bAcceptTemporaryLicense,
                        pcbLicense,
                        ppbLicense,
                        pdwErrCode
                        );
        }
    }

    return(dwStatus);
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSUpgradeLicense( 
     TLS_HANDLE hHandle,
     LICENSEREQUEST *pRequest,
     CHALLENGE_CONTEXT ChallengeContext,
     DWORD cbChallengeResponse,
     PBYTE pbChallengeResponse,
     DWORD cbOldLicense,
     PBYTE pbOldLicense,
     PDWORD pcbNewLicense,
     PBYTE* ppbNewLicense,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    TLSLICENSEREQUEST rpcRequest;
    RequestToTlsRequest( pRequest, &rpcRequest );

    return TLSRpcUpgradeLicense(
                         hHandle,
                         &rpcRequest,
                         ChallengeContext,
                         cbChallengeResponse,
                         pbChallengeResponse,
                         cbOldLicense,
                         pbOldLicense,
                         pcbNewLicense,
                         ppbNewLicense,
                         pdwErrCode
                    );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSUpgradeLicenseEx( 
     TLS_HANDLE hHandle,
     PDWORD pSupportFlags,
     LICENSEREQUEST *pRequest,
     CHALLENGE_CONTEXT ChallengeContext,
     DWORD cbChallengeResponse,
     PBYTE pbChallengeResponse,
     DWORD cbOldLicense,
     PBYTE pbOldLicense,
     DWORD dwQuantity,
     PDWORD pcbNewLicense,
     PBYTE* ppbNewLicense,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    DWORD dwStatus;
    TLSLICENSEREQUEST rpcRequest;
    RequestToTlsRequest( pRequest, &rpcRequest );

    dwStatus = TLSRpcUpgradeLicenseEx(
                         hHandle,
                         pSupportFlags,
                         &rpcRequest,
                         ChallengeContext,
                         cbChallengeResponse,
                         pbChallengeResponse,
                         cbOldLicense,
                         pbOldLicense,
                         dwQuantity,
                         pcbNewLicense,
                         ppbNewLicense,
                         pdwErrCode
                    );

    if (dwStatus == RPC_S_PROCNUM_OUT_OF_RANGE)
    {
        *pSupportFlags = 0;

        dwStatus = TLSRpcUpgradeLicense(
                         hHandle,
                         &rpcRequest,
                         ChallengeContext,
                         cbChallengeResponse,
                         pbChallengeResponse,
                         cbOldLicense,
                         pbOldLicense,
                         pcbNewLicense,
                         ppbNewLicense,
                         pdwErrCode
                    );
    }

    return(dwStatus);
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSAllocateConcurrentLicense( 
     TLS_HANDLE hHandle,
     LPTSTR szHydraServer,
     LICENSEREQUEST  *pRequest,
     LONG  *dwQuantity,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    TLSLICENSEREQUEST rpcRequest;
    RequestToTlsRequest( pRequest, &rpcRequest );

    return TLSRpcAllocateConcurrentLicense(
                                     hHandle,
                                     szHydraServer,
                                     &rpcRequest,
                                     dwQuantity,
                                     pdwErrCode
                                );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetLastError( 
     TLS_HANDLE hHandle,
     DWORD cbBufferSize,
     LPTSTR pszBuffer,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcGetLastError( 
                            hHandle,
                            &cbBufferSize,
                            pszBuffer,
                            pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSKeyPackEnumBegin( 
     TLS_HANDLE hHandle,
     DWORD dwSearchParm,
     BOOL bMatchAll,
     LPLSKeyPackSearchParm lpSearchParm,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcKeyPackEnumBegin( 
                         hHandle,
                         dwSearchParm,
                         bMatchAll,
                         lpSearchParm,
                         pdwErrCode
                    );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSKeyPackEnumNext( 
    TLS_HANDLE hHandle,
    LPLSKeyPack lpKeyPack,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcKeyPackEnumNext( 
                    hHandle,
                    lpKeyPack,
                    pdwErrCode
                );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSKeyPackEnumEnd( 
     TLS_HANDLE hHandle,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcKeyPackEnumEnd(hHandle, pdwErrCode);
}


//----------------------------------------------------------------------------
DWORD WINAPI 
TLSLicenseEnumBegin( 
    TLS_HANDLE hHandle,
    DWORD dwSearchParm,
    BOOL bMatchAll,
    LPLSLicenseSearchParm lpSearchParm,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcLicenseEnumBegin( 
                            hHandle,
                            dwSearchParm,
                            bMatchAll,
                            lpSearchParm,
                            pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSLicenseEnumNext( 
    TLS_HANDLE hHandle,
    LPLSLicense lpLicense,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcLicenseEnumNext( 
                            hHandle,
                            lpLicense,
                            pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSLicenseEnumNextEx( 
    TLS_HANDLE hHandle,
    LPLSLicenseEx lpLicenseEx,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    DWORD dwRet;

    if (NULL == lpLicenseEx)
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwRet = TLSRpcLicenseEnumNextEx( 
                            hHandle,
                            lpLicenseEx,
                            pdwErrCode
                        );

    if (RPC_S_PROCNUM_OUT_OF_RANGE == dwRet)
    {
        LSLicense License;

        dwRet = TLSRpcLicenseEnumNext(
                            hHandle,
                            &License,
                            pdwErrCode
                            );

        if ((dwRet == RPC_S_OK)
            && (NULL != pdwErrCode)
            && (*pdwErrCode == ERROR_SUCCESS))
        {
            // older versions only support quantity == 1

            memcpy(lpLicenseEx,&License,sizeof(License));
            lpLicenseEx->dwQuantity = 1;
        }
    }

    return dwRet;
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSLicenseEnumEnd( 
    TLS_HANDLE hHandle,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcLicenseEnumEnd(hHandle, pdwErrCode);
}


//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetAvailableLicenses( 
    TLS_HANDLE hHandle,
    DWORD dwSearchParm,
    LPLSKeyPack lplsKeyPack,
    LPDWORD lpdwAvail,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcGetAvailableLicenses( 
                        hHandle,
                        dwSearchParm,
                        lplsKeyPack,
                        lpdwAvail,
                        pdwErrCode
                    );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetRevokeKeyPackList( 
    TLS_HANDLE hHandle,
    PDWORD pcbNumberOfRange,
    LPLSRange  *ppRevokeRange,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcGetRevokeKeyPackList( 
                             hHandle,
                             pcbNumberOfRange,
                             ppRevokeRange,
                             pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetRevokeLicenseList( 
    TLS_HANDLE hHandle,
    PDWORD pcbNumberOfRange,
    LPLSRange  *ppRevokeRange,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcGetRevokeLicenseList( 
                             hHandle,
                             pcbNumberOfRange,
                             ppRevokeRange,
                             pdwErrCode
                        );
}


//----------------------------------------------------------------------------
DWORD WINAPI
TLSMarkLicense(
    TLS_HANDLE hHandle,
    UCHAR ucFlags,
    DWORD cbLicense,
    PBYTE pLicense,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcMarkLicense(
                            hHandle,
                            ucFlags,
                            cbLicense,
                            pLicense,
                            pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI
TLSCheckLicenseMark(
    TLS_HANDLE hHandle,
    DWORD cbLicense,
    PBYTE pLicense,
    PUCHAR pucFlags,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcCheckLicenseMark(
                            hHandle,
                            cbLicense,
                            pLicense,
                            pucFlags,
                            pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI
TLSGetSupportFlags(
    TLS_HANDLE hHandle,
    DWORD *pdwSupportFlags
    )
/*++

++*/
{
    return TLSRpcGetSupportFlags(
                            hHandle,
                            pdwSupportFlags
                        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tlsapi\noenf\makefile.inc ===
#
# Copyright (c) 1997-1999 Microsoft Corporation
#

TAGET_DIRECTORY=*

PRIVLIB=$(LSERVER_LIB_PATH)\$(ALT_PROJECT_TARGET)\$(O)\tlsapip.lib
$(LSERVER_LIB_PATH)\$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\tlsapi.lib : $(PRIVLIB)

$(PRIVLIB) $(PRIVLIB:.lib=.exp): $(O)\tlsapip.def $(LIBRARY_OBJS)
   -lib -out:$(PRIVLIB) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\tlsapip.def
$(LIBRARY_OBJS)
<<NOKEEP

$(O)\tlsapi.def: $(TLSAPI_ROOT)\tlsapi.def
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@

C_DEFINES=$(C_DEFINES) -DPRIVATE=
$(O)\tlsapip.def: $(O)\tlsapi.def
    $(C_PREPROCESSOR) $(O)\tlsapi.def > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tlsdb\backup.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       backup.cpp 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include "backup.h"


LPCTSTR __BackupSourceIdxOnServerName::pszIndexName = BACKUPSOURCE_INDEX_LSERVERNAME_INDEXNAME;
LPCTSTR __BackupSourceIdxOnServerName::pszIndexKey = BACKUPSOURCE_INDEX_LSERVERNAME_INDEXKEY;

LPCTSTR __BackupSourceIdxOnSetupId::pszIndexName = BACKUPSOURCE_INDEX_LSSETUPID_INDEXNAME;
LPCTSTR __BackupSourceIdxOnSetupId::pszIndexKey = BACKUPSOURCE_INDEX_LSSETUPID_INDEXKEY;

LPCTSTR BackupSourceTable::pszTableName = BACKUPSOURCE_TABLE_NAME;

//----------------------------------------------------
CCriticalSection BackupSourceTable::g_TableLock;

//----------------------------------------------------
TLSJBIndex
BackupSourceTable::g_TableIndex[] =
{
    {
        BACKUPSOURCE_INDEX_LSERVERNAME_INDEXNAME,
        BACKUPSOURCE_INDEX_LSERVERNAME_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },

    {
        BACKUPSOURCE_INDEX_LSSETUPID_INDEXNAME,
        BACKUPSOURCE_INDEX_LSSETUPID_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    }
};

int 
BackupSourceTable::g_NumTableIndex = sizeof(BackupSourceTable::g_TableIndex) / sizeof(BackupSourceTable::g_TableIndex[0]);

TLSJBColumn
BackupSourceTable::g_Columns[] =
{
    {
        BACKUPSOURCE_COLUMN_LSERVERNAME,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        JBSTRING_NULL,
        _tcslen(JBSTRING_NULL),
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    {
        BACKUPSOURCE_COLUMN_LSSETUPID,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        JBSTRING_NULL,
        _tcslen(JBSTRING_NULL),
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    {
        BACKUPSOURCE_COLUMN_DOMAINSID,
        JET_coltypLongBinary,
        TLSTABLE_MAX_BINARY_LENGTH,
        0,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    {
        BACKUPSOURCE_COLUMN_DBFILENAME,
        JB_COLTYPE_TEXT,
        (MAX_PATH + 1)*sizeof(TCHAR),
        0,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    {
        BACKUPSOURCE_COLUMN_LASTBACKUPTIME,
        JET_coltypBinary,
        sizeof(FILETIME),
        JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    {
        BACKUPSOURCE_COLUMN_LASTRESTORETIME,
        JET_coltypBinary,
        sizeof(FILETIME),
        JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    }
};

int
BackupSourceTable::g_NumColumns=sizeof(BackupSourceTable::g_Columns) / sizeof(BackupSourceTable::g_Columns[0]);

//-------------------------------------------------------------
JBKeyBase* 
BackupSourceTable::EnumerationIndex( 
    BOOL bMatchAll,
    DWORD dwSearchParam,
    BACKUPSOURCERECORD* pRecord,
    BOOL* bCompareKey
    )
/*
*/
{
    JBKeyBase* index;

    if(dwSearchParam & BACKUPSOURCE_PROCESS_LSSETUPID)
    {
        index = new TLSBckSrcIdxSetupId(pRecord);
    }
    else
    {
        index = new TLSBckSrcIdxServerName(pRecord);
    }
           
    *bCompareKey = bMatchAll;
    return index;
}    

//------------------------------------------------------------
BOOL
BackupSourceTable::EqualValue(
    BACKUPSOURCERECORD& s1,
    BACKUPSOURCERECORD& s2,
    BOOL bMatchAll,
    DWORD dwParam
    )
/*
*/
{
    BOOL bRetCode = TRUE;


    if(dwParam & BACKUPSOURCE_PROCESS_LSSETUPID)
    {
        bRetCode = (_tcscmp(s1.szInstallId, s2.szInstallId) == 0);
        if(bRetCode != bMatchAll)
            goto cleanup;
    }

    if(dwParam & BACKUPSOURCE_PROCESS_SERVERNAME)
    {
        bRetCode = (_tcsicmp(s1.szTlsServerName, s2.szTlsServerName) == 0);
        if(bRetCode != bMatchAll)
            goto cleanup;
    }

    //if(dwParam & BACKUPSOURCE_PROCESS_DOMAINSID)
    //{
    //    bRetCode = EqualSid(s1.pbDomainSid, s2.pbDomainSid);
    //    if(bRetCode != bMatchAll)
    //        goto cleanup;
    //}

    if(dwParam & BACKUPSOURCE_PROCESS_FILENAME)
    {
        bRetCode = (_tcsicmp(s1.szFileName, s2.szFileName) == 0);
        if(bRetCode != bMatchAll)
            goto cleanup;
    }

    if(dwParam & BACKUPSOURCE_PROCESS_BACKUPTIME)
    {
        bRetCode = (CompareFileTime(&s1.ftLastBackupTime, &s2.ftLastBackupTime) == 0);
        if(bRetCode != bMatchAll)
            goto cleanup;
    }

    if(dwParam & BACKUPSOURCE_PROCESS_RESTORETIME)
    {
        bRetCode = (CompareFileTime(&s1.ftLastRestoreTime, &s2.ftLastRestoreTime) == 0);
    }

cleanup:
    return bRetCode;
}

//----------------------------------------------------
BOOL
BackupSourceTable::ResolveToTableColumn()
/*
*/
{
    m_JetErr = szInstallId.AttachToTable(
                            *this,
                            BACKUPSOURCE_COLUMN_LSSETUPID
                        );

    if(IsSuccess() == FALSE)
    {
        DebugOutput(
                _TEXT("Can't find column %s in table %s\n"),
                BACKUPSOURCE_COLUMN_LSSETUPID,
                GetTableName()
            );

        goto cleanup;
    }
    
    m_JetErr = szTlsServerName.AttachToTable(
                            *this,
                            BACKUPSOURCE_COLUMN_LSERVERNAME
                        );

    if(IsSuccess() == FALSE)
    {
        DebugOutput(
                _TEXT("Can't find column %s in table %s\n"),
                BACKUPSOURCE_COLUMN_LSERVERNAME,
                GetTableName()
            );

        goto cleanup;
    }

    m_JetErr = pbDomainSid.AttachToTable(
                            *this,
                            BACKUPSOURCE_COLUMN_DOMAINSID
                        );

    if(IsSuccess() == FALSE)
    {
        DebugOutput(
                _TEXT("Can't find column %s in table %s\n"),
                BACKUPSOURCE_COLUMN_DOMAINSID,
                GetTableName()
            );

        goto cleanup;
    }

    m_JetErr = szFileName.AttachToTable(
                            *this,
                            BACKUPSOURCE_COLUMN_DBFILENAME
                        );

    if(IsSuccess() == FALSE)
    {
        DebugOutput(
                _TEXT("Can't find column %s in table %s\n"),
                BACKUPSOURCE_PROCESS_FILENAME,
                GetTableName()
            );

        goto cleanup;
    }


    m_JetErr = ftLastBackupTime.AttachToTable(
                            *this,
                            BACKUPSOURCE_COLUMN_LASTBACKUPTIME
                        );

    if(IsSuccess() == FALSE)
    {
        DebugOutput(
                _TEXT("Can't find column %s in table %s\n"),
                BACKUPSOURCE_COLUMN_LASTBACKUPTIME,
                GetTableName()
            );

        goto cleanup;
    }

    m_JetErr = ftLastRestoreTime.AttachToTable(
                            *this,
                            BACKUPSOURCE_COLUMN_LASTRESTORETIME
                        );

    if(IsSuccess() == FALSE)
    {
        DebugOutput(
                _TEXT("Can't find column %s in table %s\n"),
                BACKUPSOURCE_COLUMN_LASTRESTORETIME,
                GetTableName()
            );
    }

cleanup:
    return IsSuccess();
}

//----------------------------------------------------
CLASS_PRIVATE BOOL
BackupSourceTable::ProcessSingleColumn(
    IN BOOL bFetch,
    IN TLSColumnBase& column,
    IN DWORD offset,
    IN PVOID pbData,
    IN DWORD cbData,
    IN PDWORD pcbDataReturn,
    IN LPCTSTR szColumnName
    )
/*

Abstract:

    Fetch/Insert/Update a particular column.

Parameter:

    bFetch - TRUE if fetch, FALSE if update/insert.
    column - Intended column for operation, reference pointer to TLSColumn
    szColumnName - name of the column, for debugging print purpose only

Returns:

    TRUE if successful, FALSE otherwise.
*/
{
    if(bFetch) 
    {
        m_JetErr = column.FetchColumnValue(
                                    pbData, 
                                    cbData, 
                                    offset, 
                                    pcbDataReturn
                                );
    }
    else
    {
        m_JetErr = column.InsertColumnValue(
                                    pbData, 
                                    cbData, 
                                    offset
                                );
    }

    REPORTPROCESSFAILED(
            bFetch,
            GetTableName(),
            szColumnName,
            m_JetErr
        );
    return IsSuccess();
}

//---------------------------------------------------------
CLASS_PRIVATE BOOL
BackupSourceTable::ProcessRecord(
    BACKUPSOURCERECORD* bkRecord,
    BOOL bFetch,
    DWORD dwParam,
    BOOL bUpdate
    )
/*
*/
{ 
    DWORD dwSize;

    if(bFetch == FALSE)
    {
        BeginUpdate(bUpdate);
    }
    else
    {
        SetLastJetError(JET_errSuccess);
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    if(dwParam & BACKUPSOURCE_PROCESS_LSSETUPID)
    {
        ProcessSingleColumn(
                    bFetch,
                    szInstallId,
                    0,
                    bkRecord->szInstallId,
                    sizeof(bkRecord->szInstallId),
                    &dwSize,
                    BACKUPSOURCE_COLUMN_LSSETUPID
                );

    }

    if(IsSuccess() == FALSE)
        goto cleanup;            
    
    if(dwParam & BACKUPSOURCE_PROCESS_SERVERNAME)
    {
        ProcessSingleColumn(
                    bFetch,
                    szTlsServerName,
                    0,
                    bkRecord->szTlsServerName,
                    sizeof(bkRecord->szTlsServerName),
                    &dwSize,
                    BACKUPSOURCE_COLUMN_LSERVERNAME
                );

    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

#if 0
    // no more domain SID
    if(dwParam & BACKUPSOURCE_PROCESS_DOMAINSID)
    {
        if(bFetch == TRUE)
        {
            DWORD size=0;

            m_JetErr = pbDomainSid.FetchColumnValue(
                                        NULL,
                                        0,
                                        0,
                                        &size
                                    );

            if(bkRecord->cbDomainSid < size || bkRecord->pbDomainSid == NULL)
            {
                FreeMemory(bkRecord->pbDomainSid);
                bkRecord->pbDomainSid = (PSID)AllocateMemory(bkRecord->cbDomainSid = size);
                if(bkRecord->pbDomainSid == NULL)
                {
                    SetLastJetError(JET_errOutOfMemory);
                    goto cleanup;
                }
            }

            m_JetErr = pbDomainSid.FetchColumnValue(
                                        bkRecord->pbDomainSid,
                                        bkRecord->cbDomainSid,
                                        0,
                                        &bkRecord->cbDomainSid
                                    );
        }
        else
        {
            ProcessSingleColumn(
                        bFetch,
                        pbDomainSid,
                        0,
                        bkRecord->pbDomainSid,
                        bkRecord->cbDomainSid,
                        &dwSize,
                        BACKUPSOURCE_COLUMN_DOMAINSID
                    );
        }
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            
#endif

    if(dwParam & BACKUPSOURCE_PROCESS_FILENAME)
    {
        ProcessSingleColumn(
                    bFetch,
                    szFileName,
                    0,
                    bkRecord->szFileName,
                    sizeof(bkRecord->szFileName),
                    &dwSize,
                    BACKUPSOURCE_COLUMN_DBFILENAME
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    if(dwParam & BACKUPSOURCE_PROCESS_BACKUPTIME)
    {
        ProcessSingleColumn(
                    bFetch,
                    ftLastBackupTime,
                    0,
                    &(bkRecord->ftLastBackupTime),
                    sizeof(bkRecord->ftLastBackupTime),
                    &dwSize,
                    BACKUPSOURCE_COLUMN_LASTBACKUPTIME
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    if(dwParam & BACKUPSOURCE_PROCESS_RESTORETIME)
    {
        ProcessSingleColumn(
                    bFetch,
                    ftLastRestoreTime,
                    0,
                    &(bkRecord->ftLastRestoreTime),
                    sizeof(bkRecord->ftLastRestoreTime),
                    &dwSize,
                    BACKUPSOURCE_COLUMN_LASTRESTORETIME
                );
    }

cleanup:
    // 
    // For inserting/updating record
    if(bFetch == FALSE)
    {
        JET_ERR jetErr;
        jetErr = GetLastJetError();

        EndUpdate(IsSuccess() == FALSE);

        if(jetErr != JET_errSuccess  && IsSuccess() == FALSE)
            SetLastJetError(jetErr);
    }

    return IsSuccess();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tlsdb\backup.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        backup.h
//
// Contents:    backupsource Table
//
// History:     
//              
//---------------------------------------------------------------------------
#ifndef __BACKUP_SOURCE_H__
#define __BACKUP_SOURCE_H__
#include "tlsdb.h"


//
// re-direct define using what's in tlsdef.h just for backward compatibility
//
#define BACKUPSOURCE_PROCESS_LSSETUPID          0x00000001
#define BACKUPSOURCE_PROCESS_SERVERNAME         (BACKUPSOURCE_PROCESS_LSSETUPID << 1)
#define BACKUPSOURCE_PROCESS_DOMAINSID          (BACKUPSOURCE_PROCESS_LSSETUPID << 2)
#define BACKUPSOURCE_PROCESS_FILENAME           (BACKUPSOURCE_PROCESS_LSSETUPID << 3)
#define BACKUPSOURCE_PROCESS_BACKUPTIME         (BACKUPSOURCE_PROCESS_LSSETUPID << 4)
#define BACKUPSOURCE_PROCESS_RESTORETIME        (BACKUPSOURCE_PROCESS_LSSETUPID << 5)

//
// Licensed KeyPack Table
//
#define BACKUPSOURCE_TABLE_NAME                     _TEXT("BackupSource")

#define BACKUPSOURCE_COLUMN_LSERVERNAME             _TEXT("ServerName")
#define BACKUPSOURCE_COLUMN_LSSETUPID               _TEXT("TLSSetupId")
#define BACKUPSOURCE_COLUMN_DOMAINSID               _TEXT("TLSDomainSetupId")
#define BACKUPSOURCE_COLUMN_DBFILENAME              _TEXT("DbFileName")
#define BACKUPSOURCE_COLUMN_LASTBACKUPTIME          _TEXT("LastBackupTime")
#define BACKUPSOURCE_COLUMN_LASTRESTORETIME         _TEXT("LastRestoreTime")

typedef struct __BackSourceRecord {
    TCHAR       szInstallId[MAX_JETBLUE_TEXT_LENGTH+1];
    TCHAR       szTlsServerName[MAX_JETBLUE_TEXT_LENGTH+1];
    PSID        pbDomainSid;
    DWORD       cbDomainSid;
    TCHAR       szFileName[MAX_PATH+1];
    FILETIME    ftLastBackupTime;       // last backup time
    FILETIME    ftLastRestoreTime;      // last restore time

    __BackSourceRecord() : pbDomainSid(NULL), cbDomainSid(0) {}

    ~__BackSourceRecord() 
    {
        if(pbDomainSid != NULL)
        {
            FreeMemory(pbDomainSid);
        }
    }

    __BackSourceRecord(
        const __BackSourceRecord& v
        )
    /*++
    ++*/
    {
        *this = v;
    }

    __BackSourceRecord&
    operator=(const __BackSourceRecord& v)
    {
        BOOL bSuccess;

        if(this == &v)
            return *this;

        _tcscpy(szInstallId, v.szInstallId);
        _tcscpy(szTlsServerName, v.szTlsServerName);
        _tcscpy(szFileName, v.szFileName);
        ftLastBackupTime = v.ftLastBackupTime;
        ftLastRestoreTime = v.ftLastRestoreTime;

        bSuccess = TLSDBCopySid(
                        v.pbDomainSid,
                        v.cbDomainSid,
                        &pbDomainSid,
                        &cbDomainSid
                    );

        JB_ASSERT(bSuccess == TRUE);

        return *this;
    }
    
} BACKUPSOURCERECORD, *LPBACKUPSOURCERECORD, *PBACKUPSOURCERECORD;


//
//
// Index structure for backupsource Table
//
//

////////////////////////////////////////////////////////////////
//
//  Index on szInstallId
//
////////////////////////////////////////////////////////////////

// KeyPack_KeyPackId_idx
//
#define BACKUPSOURCE_INDEX_LSERVERNAME_INDEXNAME \
    BACKUPSOURCE_TABLE_NAME SEPERATOR BACKUPSOURCE_COLUMN_LSERVERNAME SEPERATOR INDEXNAME

//
// Primary Index on KeyPack ID "+KeyPackId\0"
//
#define BACKUPSOURCE_INDEX_LSERVERNAME_INDEXKEY \
    INDEX_SORT_ASCENDING BACKUPSOURCE_COLUMN_LSERVERNAME INDEX_END_COLNAME

typedef struct __BackupSourceIdxOnServerName : public JBKeyBase {
    TCHAR szTlsServerName[MAX_JETBLUE_TEXT_LENGTH+1];

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //--------------------------------------------------------
    __BackupSourceIdxOnServerName(
        const BACKUPSOURCERECORD& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //--------------------------------------------------------
    __BackupSourceIdxOnServerName(
        const BACKUPSOURCERECORD* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //--------------------------------------------------------
    __BackupSourceIdxOnServerName&
    operator=(const BACKUPSOURCERECORD& v) 
    {
        _tcscpy(szTlsServerName, v.szTlsServerName);
        SetEmptyValue(FALSE);
        return *this;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() 
    { 
        return 1; 
    }

    //--------------------------------------------------------
    BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*++
    ++*/
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = szTlsServerName;
        *cbData = _tcslen(szTlsServerName) * sizeof(TCHAR);
        *grbit = JET_bitNewKey;
        return TRUE;
    }
} TLSBckSrcIdxServerName;


////////////////////////////////////////////////////////////////
//
//  Index on EntryLastModifyTime
//
//
////////////////////////////////////////////////////////////////

//
// Index name
//
#define BACKUPSOURCE_INDEX_LSSETUPID_INDEXNAME \
    BACKUPSOURCE_TABLE_NAME SEPERATOR BACKUPSOURCE_COLUMN_LSSETUPID SEPERATOR INDEXNAME

//
// Index key
//
#define BACKUPSOURCE_INDEX_LSSETUPID_INDEXKEY \
    INDEX_SORT_ASCENDING BACKUPSOURCE_COLUMN_LSSETUPID INDEX_END_COLNAME

typedef struct __BackupSourceIdxOnSetupId : public JBKeyBase {
    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    TCHAR szInstallId[MAX_JETBLUE_TEXT_LENGTH+1];

    //--------------------------------------------------------
    __BackupSourceIdxOnSetupId(
        const BACKUPSOURCERECORD& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //--------------------------------------------------------
    __BackupSourceIdxOnSetupId(
        const BACKUPSOURCERECORD* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //--------------------------------------------------------
    __BackupSourceIdxOnSetupId&
    operator=(const BACKUPSOURCERECORD& v) 
    {
        _tcscpy(szInstallId, v.szInstallId);
        SetEmptyValue(FALSE);
        return *this;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexKey() 
    {
        return pszIndexName;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() 
    { 
        return 1; 
    }

    //--------------------------------------------------------
    BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*++
    ++*/
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = szInstallId;
        *cbData = _tcslen(szInstallId)*sizeof(TCHAR);
        *grbit = JET_bitNewKey;
        return TRUE;
    }
} TLSBckSrcIdxSetupId;


// -----------------------------------------------------------
//
//  LicensedPackStatus Table
//
// -----------------------------------------------------------
class BackupSourceTable : public TLSTable<BACKUPSOURCERECORD>  {
private:
    static LPCTSTR pszTableName;

    BOOL
    ProcessSingleColumn(
        BOOL bFetch,
        TLSColumnBase& column,
        DWORD offset,
        PVOID pbData,
        DWORD cbData,
        PDWORD pcbDataReturn,
        LPCTSTR szColumnName
    );

    BOOL
    ProcessRecord(
        BACKUPSOURCERECORD* v,
        BOOL bFetch,        // TRUE - fetch, FALSE insert
        DWORD dwParam,
        BOOL bUpdate
    );    

public:
    TLSColumnText   szInstallId;
    TLSColumnText   szTlsServerName;
    TLSColumnBinary pbDomainSid;
    TLSColumnText   szFileName;
    TLSColumnFileTime ftLastBackupTime;
    TLSColumnFileTime ftLastRestoreTime;

    //-----------------------------------------------------
    virtual LPCTSTR
    GetTableName() 
    {
        return pszTableName;
    }
    

    //-----------------------------------------------------
    BackupSourceTable(JBDatabase& database) : TLSTable<BACKUPSOURCERECORD>(database)
    /*
    */
    {
    }

    //-----------------------------------------------------
    virtual BOOL
    ResolveToTableColumn();

    //-----------------------------------------------------
    virtual BOOL
    FetchRecord(
        BACKUPSOURCERECORD& v,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&v, TRUE, dwParam, FALSE);
    }

    //-----------------------------------------------------
    virtual BOOL
    InsertRecord(
        BACKUPSOURCERECORD& v,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&v, FALSE, dwParam, FALSE);
    }

    //-----------------------------------------------------
    virtual BOOL
    UpdateRecord(
        BACKUPSOURCERECORD& v,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&v, FALSE, dwParam, TRUE);
    }

    //-------------------------------------------------------
    virtual BOOL
    Initialize() 
    { 
        return TRUE; 
    }

    //-------------------------------------------------------
    virtual JBKeyBase*
    EnumerationIndex( 
        IN BOOL bMatchAll,
        IN DWORD dwParam,
        IN BACKUPSOURCERECORD* kp,
        IN OUT BOOL* bCompareKey
    );
    
    virtual BOOL
    EqualValue(
        BACKUPSOURCERECORD& s1,
        BACKUPSOURCERECORD& s2,
        BOOL bMatchAll,
        DWORD dwParam
    );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tlsapi\tlsapip.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        tlsapip.cpp
//
// Contents:    Private API
//
// History:     09-09-97    HueiWang    Created
//
//---------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <rpc.h>
#include "lscommon.h"
#include <wincrypt.h>
#include "tlsrpc.h"
#include "tlsapi.h"
#include "tlsapip.h"

//----------------------------------------------------------------------------
BOOL
TLSIsLicenseEnforceEnable()
/*++

--*/
{
    #if ENFORCE_LICENSING
    return TRUE;
    #else
    return FALSE;
    #endif
}

//----------------------------------------------------------------------------
BOOL
TLSIsBetaNTServer()
/*++

Abstract:

    Detemine if base NT is a beta or RTM version.

Parameter:

    None.

Return:

    TRUE/FALSE

--*/
{
    BOOL bBetaNt = FALSE;
    DWORD dwStatus;
    DWORD cbData;
    DWORD cbType;
    HKEY hKey = NULL;

    __try {
        LARGE_INTEGER Time = USER_SHARED_DATA->SystemExpirationDate;

        if(Time.QuadPart)
        {
            bBetaNt = TRUE;

            // check our special registry key - force
            // issuing a RTM license.
            dwStatus = RegOpenKeyEx(
                                HKEY_LOCAL_MACHINE,
                                L"SOFTWARE\\Microsoft\\TermServLicensing",
                                0,
                                KEY_ALL_ACCESS,
                                &hKey
                            );

            if(dwStatus == ERROR_SUCCESS)
            {
                dwStatus = RegQueryValueEx(
                                    hKey,
                                    _TEXT("RunAsRTM"),
                                    NULL,
                                    &cbType,
                                    NULL,
                                    &cbData
                                );

                // for testing, force it to run as RTM version.
                // key must exist and must be DWORD type
                if(dwStatus == ERROR_SUCCESS && cbType == REG_DWORD)
                {
                    bBetaNt = FALSE;
                }
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        ASSERT(FALSE);
    }

    if(hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    return bBetaNt;
}

//----------------------------------------------------------------------------
DWORD WINAPI
TLSAllocateInternetLicenseEx(
    IN TLS_HANDLE hHandle,
    IN const CHALLENGE_CONTEXT ChallengeContext,
    IN const LICENSEREQUEST* pRequest,
    IN LPTSTR pszMachineName,
    IN LPTSTR pszUserName,
    IN const DWORD cbChallengeResponse,
    IN const PBYTE pbChallengeResponse,
    OUT PTLSInternetLicense pInternetLicense,
    OUT PDWORD pdwErrCode
    )
/*++

--*/
{
    TLSLICENSEREQUEST rpcRequest;
    RequestToTlsRequest( pRequest, &rpcRequest );

    return TLSRpcAllocateInternetLicenseEx(
                                hHandle,
                                ChallengeContext,
                                &rpcRequest,
                                pszMachineName,
                                pszUserName,
                                cbChallengeResponse,
                                pbChallengeResponse,
                                pInternetLicense,
                                pdwErrCode
                            );
}
//----------------------------------------------------------------------------

DWORD WINAPI
TLSReturnInternetLicenseEx(
    IN TLS_HANDLE hHandle,
    IN const LICENSEREQUEST* pRequest,
    IN const ULARGE_INTEGER* pulSerialNumber,
    IN const DWORD dwQuantity,
    OUT PDWORD pdwErrCode
    )
/*++

--*/
{
    TLSLICENSEREQUEST rpcRequest;
    RequestToTlsRequest( pRequest, &rpcRequest );
    
    return TLSRpcReturnInternetLicenseEx(
                                hHandle,
                                &rpcRequest,
                                pulSerialNumber,
                                dwQuantity,
                                pdwErrCode
                            );
}

//----------------------------------------------------------------------------

DWORD WINAPI 
TLSRegisterLicenseKeyPack( 
    TLS_HANDLE hHandle,
    LPBYTE pbCHCertBlob,
    DWORD cbCHCertBlobSize,
    LPBYTE pbRootCertBlob,
    DWORD cbRootCertBlob,
    LPBYTE lpKeyPackBlob,
    DWORD dwKeyPackBlobLen,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcRegisterLicenseKeyPack( 
                                hHandle,
                                pbCHCertBlob,
                                cbCHCertBlobSize,
                                pbRootCertBlob,
                                cbRootCertBlob,
                                lpKeyPackBlob,
                                dwKeyPackBlobLen,
                                pdwErrCode
                            );
}

//----------------------------------------------------------------------------

DWORD WINAPI
TLSTelephoneRegisterLKP(
    IN TLS_HANDLE hHandle,
    IN DWORD cbData,
    IN PBYTE pbData,
    OUT PDWORD pdwErrCode
    )

/*++


--*/

{
    return TLSRpcTelephoneRegisterLKP(
                                hHandle,
                                cbData,
                                pbData,
                                pdwErrCode
                            );
}

//----------------------------------------------------------------------------

DWORD WINAPI
RequestToTlsRequest( 
    const LICENSEREQUEST* lpRequest, 
    TLSLICENSEREQUEST* lpRpcRequest 
    )
/*++

++*/
{
    if(lpRequest == NULL || lpRpcRequest == NULL || lpRequest->pProductInfo == NULL)
        return ERROR_INVALID_PARAMETER;

    //
    // NOTE : No memory allocation, DO NOT FREE ...
    //
    lpRpcRequest->cbEncryptedHwid = lpRequest->cbEncryptedHwid;
    lpRpcRequest->pbEncryptedHwid = lpRequest->pbEncryptedHwid;
    lpRpcRequest->dwLanguageID = lpRequest->dwLanguageID;
    lpRpcRequest->dwPlatformID = lpRequest->dwPlatformID;
    lpRpcRequest->ProductInfo.dwVersion = lpRequest->pProductInfo->dwVersion;
    lpRpcRequest->ProductInfo.cbCompanyName = lpRequest->pProductInfo->cbCompanyName;
    lpRpcRequest->ProductInfo.pbCompanyName = lpRequest->pProductInfo->pbCompanyName;
    lpRpcRequest->ProductInfo.cbProductID = lpRequest->pProductInfo->cbProductID;
    lpRpcRequest->ProductInfo.pbProductID = lpRequest->pProductInfo->pbProductID;
    return ERROR_SUCCESS;
}

//----------------------------------------------------------------------------

DWORD WINAPI 
TLSReturnLicense( 
     TLS_HANDLE hHandle,
     DWORD dwKeyPackId,
     DWORD dwLicenseId,
     DWORD dwRetrunReason,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcReturnLicense( 
                         hHandle,
                         dwKeyPackId,
                         dwLicenseId,
                         dwRetrunReason,
                         pdwErrCode
                    );
}

//----------------------------------------------------------------------------

DWORD WINAPI 
TLSGetLSPKCS10CertRequest(
    TLS_HANDLE hHandle,
    DWORD dwCertType,
    PDWORD pcbData,
    PBYTE* ppbData,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcGetLSPKCS10CertRequest(
                            hHandle,
                            dwCertType,
                            pcbData,
                            ppbData,
                            pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI
TLSRequestTermServCert( 
    TLS_HANDLE hHandle,
    LPLSHydraCertRequest pRequest,
    PDWORD cbChallengeData,
    PBYTE* pbChallengeData,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    TLSHYDRACERTREQUEST CertRequest;

    CertRequest.dwHydraVersion = pRequest->dwHydraVersion;
    CertRequest.pbEncryptedHwid = pRequest->pbEncryptedHwid;
    CertRequest.cbEncryptedHwid = pRequest->cbEncryptedHwid;
    CertRequest.szSubjectRdn = pRequest->szSubjectRdn;
    CertRequest.pSubjectPublicKeyInfo = (TLSCERT_PUBLIC_KEY_INFO *)pRequest->SubjectPublicKeyInfo;
    CertRequest.dwNumCertExtension = pRequest->dwNumCertExtension;
    CertRequest.pCertExtensions = (TLSCERT_EXTENSION *)pRequest->pCertExtensions;

    return TLSRpcRequestTermServCert(
                                hHandle,
                                &CertRequest,
                                cbChallengeData,
                                pbChallengeData,
                                pdwErrCode
                            );
}

//----------------------------------------------------------------------------
DWORD WINAPI
TLSRetrieveTermServCert( 
    TLS_HANDLE hHandle,
    DWORD cbResponseData,
    PBYTE pbResponseData,
    PDWORD pcbCert,
    PBYTE* ppbCert,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcRetrieveTermServCert(
                                hHandle,
                                cbResponseData,
                                pbResponseData,
                                pcbCert,
                                ppbCert,
                                pdwErrCode
                            );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSInstallCertificate( 
     TLS_HANDLE hHandle,
     DWORD dwCertType,
     DWORD dwCertLevel,
     DWORD cbSingnatureCert,
     PBYTE pbSingnatureCert,
     DWORD cbExchangeCert,
     PBYTE pbExchangeCert,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcInstallCertificate( 
                         hHandle,
                         dwCertType,
                         dwCertLevel,
                         cbSingnatureCert,
                         pbSingnatureCert,
                         cbExchangeCert,
                         pbExchangeCert,
                         pdwErrCode
                    );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetServerCertificate( 
    TLS_HANDLE hHandle,
    BOOL bSignCert,
    LPBYTE  *ppbCertBlob,
    LPDWORD lpdwCertBlobLen,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcGetServerCertificate( 
                             hHandle,
                             bSignCert,
                             ppbCertBlob,
                             lpdwCertBlobLen,
                             pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSKeyPackAdd( 
    TLS_HANDLE hHandle,
    LPLSKeyPack lpKeypack,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcKeyPackAdd( 
                    hHandle,
                    lpKeypack,
                    pdwErrCode
                );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSKeyPackSetStatus( 
    TLS_HANDLE hHandle,
    DWORD dwSetParm,
    LPLSKeyPack lpKeyPack,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcKeyPackSetStatus( 
                            hHandle,
                            dwSetParm,
                            lpKeyPack,
                            pdwErrCode
                        );
}

//-----------------------------------------------------------------

DWORD WINAPI
TLSAnnounceServer(
    IN TLS_HANDLE hHandle,
    IN DWORD dwType,
    IN FILETIME* pftTime,
    IN LPTSTR pszSetupId,
    IN LPTSTR pszDomainName,
    IN LPTSTR pszMachineName,
    OUT PDWORD pdwErrCode
    )
/*++


++*/
{
    return TLSRpcAnnounceServer(
                        hHandle,
                        dwType,
                        pftTime,
                        pszSetupId,
                        pszDomainName,
                        pszMachineName,
                        pdwErrCode
                    );
}

//-----------------------------------------------------------------

DWORD WINAPI
TLSLookupServer(
    IN TLS_HANDLE hHandle,
    IN LPTSTR pszLookupSetupId,
    OUT LPTSTR pszLsSetupId,
    IN OUT PDWORD pcbSetupId,
    OUT LPTSTR pszDomainName,
    IN OUT PDWORD pcbDomainName,
    IN LPTSTR pszLsName,
    IN OUT PDWORD pcbMachineName,
    OUT PDWORD pdwErrCode
    )
/*++


++*/
{
    return TLSRpcLookupServer(
                        hHandle,
                        pszLookupSetupId,
                        pszLsSetupId,
                        pcbSetupId,
                        pszDomainName,
                        pcbDomainName,
                        pszLsName,
                        pcbMachineName,
                        pdwErrCode
                    );
}

//-------------------------------------------------------

DWORD WINAPI
TLSAnnounceLicensePack(
    IN TLS_HANDLE hHandle,
    IN PTLSReplRecord pReplRecord,
    OUT PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcAnnounceLicensePack(
                            hHandle,
                            pReplRecord,
                            pdwErrCode
                        );
}

//-------------------------------------------------------

DWORD WINAPI
TLSReturnLicensedProduct(
    IN TLS_HANDLE hHandle,
    IN PTLSLicenseToBeReturn pClientLicense,
    OUT PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcReturnLicensedProduct(
                                hHandle,
                                pClientLicense,
                                pdwErrCode
                            );
}

//-------------------------------------------------------

DWORD WINAPI
TLSChallengeServer( 
    IN TLS_HANDLE hHandle,
    IN DWORD dwClientType,
    IN PTLSCHALLENGEDATA pClientChallenge,
    OUT PTLSCHALLENGERESPONSEDATA* ppServerResponse,
    OUT PTLSCHALLENGEDATA* ppServerChallenge,
    OUT PDWORD pdwErrCode
    )
/*++


--*/
{
    return TLSRpcChallengeServer(
                            hHandle,
                            dwClientType,
                            pClientChallenge,
                            ppServerResponse,
                            ppServerChallenge,
                            pdwErrCode
                        );
}

//-------------------------------------------------------

DWORD WINAPI
TLSResponseServerChallenge( 
    IN TLS_HANDLE hHandle,
    IN PTLSCHALLENGERESPONSEDATA pClientResponse,
    OUT PDWORD pdwErrCode
    )

/*++

--*/

{

    return TLSRpcResponseServerChallenge(
                                hHandle,
                                pClientResponse,
                                pdwErrCode
                            );
}

//------------------------------------------------------

DWORD WINAPI
TLSGetTlsPrivateData( 
    IN TLS_HANDLE hHandle,
    IN DWORD dwGetDataType,
    IN PTLSPrivateDataUnion pGetParm,
    OUT PDWORD pdwRetDataType,
    OUT PTLSPrivateDataUnion* ppRetData,
    OUT PDWORD pdwErrCode
    )
/*++

--*/
{
    return TLSRpcGetTlsPrivateData(
                                hHandle,
                                dwGetDataType,
                                pGetParm,
                                pdwRetDataType,
                                ppRetData,
                                pdwErrCode
                            );
}

//------------------------------------------------------

DWORD WINAPI
TLSTriggerReGenKey( 
    IN TLS_HANDLE hHandle,
    IN BOOL bKeepSPK,
    OUT PDWORD pdwErrCode
    )

/*++


--*/

{
    return TLSRpcTriggerReGenKey(
                            hHandle,
                            bKeepSPK,
                            pdwErrCode
                        );
}

//------------------------------------------------------
DWORD
GetPrivateBinaryDataFromServer(
    TLS_HANDLE hHandle,
    DWORD dwType,
    PDWORD pcbData,
    PBYTE* ppbData,
    PDWORD pdwErrCode
    )

/*++

--*/

{
    TLSPrivateDataUnion SearchParm;
    PTLSPrivateDataUnion pPrivateData = NULL;
    DWORD dwRetType;
    DWORD dwStatus;

    memset(
            &SearchParm, 
            0, 
            sizeof(TLSPrivateDataUnion)
        );

    dwStatus = TLSRpcGetTlsPrivateData(
                                hHandle,
                                dwType,
                                &SearchParm,
                                &dwRetType,
                                &pPrivateData,
                                pdwErrCode
                            );

    if(dwStatus != RPC_S_OK || *pdwErrCode != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if(dwRetType != dwType)
    {
        //
        // License Server error
        //
        *pdwErrCode = LSERVER_E_INVALID_RETURN;
        goto cleanup;
    }
     
    //
    // Copy over unique ID
    //
    *ppbData = (PBYTE)MIDL_user_allocate(pPrivateData->BinaryData.cbData);
    if(*ppbData != NULL)
    {
        memset(
                *ppbData, 
                0, 
                pPrivateData->BinaryData.cbData
            );

        *pcbData = pPrivateData->BinaryData.cbData;

        memcpy( 
            *ppbData,
            pPrivateData->BinaryData.pbData,
            pPrivateData->BinaryData.cbData
        );
    }
    else
    {
        *pdwErrCode = LSERVER_E_OUTOFMEMORY;
    }        

cleanup:

    if(pPrivateData != NULL)
    {
        midl_user_free(pPrivateData);
    }

    return dwStatus;
}  


//------------------------------------------------------

DWORD WINAPI
TLSGetServerPID(
    TLS_HANDLE hHandle,
    PDWORD pcbData,
    PBYTE* ppbData,
    PDWORD pdwErrCode
    )

/*++

--*/

{
    return GetPrivateBinaryDataFromServer(
                                        hHandle,
                                        TLS_PRIVATEDATA_PID,
                                        pcbData,
                                        ppbData,
                                        pdwErrCode
                                    );
}

//------------------------------------------------------

DWORD WINAPI
TLSGetServerSPK(
    TLS_HANDLE hHandle,
    PDWORD pcbData,
    PBYTE* ppbData,
    PDWORD pdwErrCode
    )

/*++

--*/

{
    TLSPrivateDataUnion SearchParm;
    PTLSPrivateDataUnion pPrivateData = NULL;
    DWORD dwRetType;
    DWORD dwStatus;

    memset(
            &SearchParm, 
            0, 
            sizeof(TLSPrivateDataUnion)
        );

    dwStatus = TLSRpcGetTlsPrivateData(
                                hHandle,
                                TLS_PRIVATEDATA_SPK,
                                &SearchParm,
                                &dwRetType,
                                &pPrivateData,
                                pdwErrCode
                            );

    if(dwStatus != RPC_S_OK || *pdwErrCode != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if(dwRetType != TLS_PRIVATEDATA_SPK)
    {
        //
        // License Server error
        //
        *pdwErrCode = LSERVER_E_INVALID_RETURN;
        goto cleanup;
    }
     
    //
    // Copy over Server's SPK.
    // Server never return CH's cert extension.
    //
    *ppbData = (PBYTE)MIDL_user_allocate(pPrivateData->SPK.cbSPK);
    if(*ppbData != NULL)
    {
        memset(
                *ppbData, 
                0, 
                pPrivateData->SPK.cbSPK
            );

        *pcbData = pPrivateData->SPK.cbSPK;

        memcpy( 
            *ppbData,
            pPrivateData->SPK.pbSPK,
            pPrivateData->SPK.cbSPK
        );
    }
    else
    {
        *pdwErrCode = LSERVER_E_OUTOFMEMORY;
    }        

cleanup:

    if(pPrivateData != NULL)
    {
        midl_user_free(pPrivateData);
    }

    return dwStatus;
}  


//-----------------------------------------------------------

DWORD WINAPI
TLSDepositeServerSPK(
    IN TLS_HANDLE hHandle,
    IN DWORD cbSPK,
    IN PBYTE pbSPK,
    IN PCERT_EXTENSIONS pCertExtensions,
    OUT PDWORD pdwErrCode
    )
/*++

--*/

{
    TLSPrivateDataUnion SetData;
    DWORD dwStatus;

    SetData.SPK.cbSPK = cbSPK;
    SetData.SPK.pbSPK = pbSPK;
    SetData.SPK.pCertExtensions = pCertExtensions;

    return TLSRpcSetTlsPrivateData( 
                            hHandle,
                            TLS_PRIVATEDATA_SPK,
                            &SetData,
                            pdwErrCode
                        );   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tlsdb\kpdesc.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        kpdesc.h
//
// Contents:    Licensed Pack Description Table
//
// History:     
//              
//---------------------------------------------------------------------------
#ifndef __TLS_KPDESC_H__
#define __TLS_KPDESC_H__

#include "JetBlue.h"
#include "TlsDb.h"

#define LICPACKDESCRECORD_TABLE_SEARCH_KEYPACKID      LSKEYPACK_SEARCH_KEYPACKID
#define LICPACKDESCRECORD_TABLE_SEARCH_LANGID         LSKEYPACK_SEARCH_LANGID
#define LICPACKDESCRECORD_TABLE_SEARCH_COMPANYNAME    LSKEYPACK_SEARCH_COMPANYNAME
#define LICPACKDESCRECORD_TABLE_SEARCH_PRODUCTNAME    LSKEYPACK_SEARCH_PRODUCTNAME
#define LICPACKDESCRECORD_TABLE_SEARCH_PRODUCTDESC    LSKEYPACK_SEARCH_PRODUCTDESC
 
#define LICPACKDESCRECORD_TABLE_PROCESS_KEYPACKID         LICPACKDESCRECORD_TABLE_SEARCH_KEYPACKID
#define LICPACKDESCRECORD_TABLE_PROCESS_LANGID            LICPACKDESCRECORD_TABLE_SEARCH_LANGID
#define LICPACKDESCRECORD_TABLE_PROCESS_COMPANYNAME       LICPACKDESCRECORD_TABLE_SEARCH_COMPANYNAME
#define LICPACKDESCRECORD_TABLE_PROCESS_PRODUCTNAME       LICPACKDESCRECORD_TABLE_SEARCH_PRODUCTNAME
#define LICPACKDESCRECORD_TABLE_PROCESS_PRODUCTDESC       LICPACKDESCRECORD_TABLE_SEARCH_PRODUCTDESC
#define LICPACKDESCRECORD_TABLE_PROCESS_LASTMODIFYTIME    0x80000000
#define LICPACKDESCRECORD_TABLE_PROCESS_ENTRYSTATUS       (LICPACKDESCRECORD_TABLE_PROCESS_LASTMODIFYTIME >> 1)
//
// Table definition for KeyPack Desc table
//
typedef TLSReplLicPackDesc LICPACKDESC;
typedef LICPACKDESC* LPLICPACKDESC;
typedef LICPACKDESC* PLICPACKDESC;

typedef LICPACKDESC LICPACKDESCRECORD;
typedef PLICPACKDESC PLICPACKDESCRECORD;
typedef LPLICPACKDESC LPLICPACKDESCRECORD;


#define LICPACKDESCRECORD_TABLE_NAME          _TEXT("LICPACKDESCRECORD")
#define LICPACKDESCRECORD_ID_COLUMN           _TEXT("InternalKeyPackId")
#define LICPACKDESCRECORD_LANGID              _TEXT("LangId")
#define LICPACKDESCRECORD_LASTMODIFYTIME      _TEXT("LastModifyTime")
#define LICPACKDESCRECORD_ENTRYSTATUS         _TEXT("EntryStatus")
#define LICPACKDESCRECORD_COMPANY_NAME        _TEXT("CompanyName")
#define LICPACKDESCRECORD_PRODUCT_NAME        _TEXT("ProductName")
#define LICPACKDESCRECORD_PRODUCT_DESC        _TEXT("ProductDesc")


//
// LICPACKDESCRECORD_KeyPackId_idx
//
#define LICPACKDESCRECORD_ID_INDEXNAME \
    LICPACKDESCRECORD_TABLE_NAME SEPERATOR LICPACKDESCRECORD_ID_COLUMN SEPERATOR INDEXNAME

//
// Primary Index on keyPack ID "+KeyPackId\0"
//
#define LICPACKDESCRECORD_ID_INDEXNAME_INDEXKEY \
    INDEX_SORT_ASCENDING LICPACKDESCRECORD_ID_COLUMN INDEX_END_COLNAME


//-------------------------------------------------------------
// Index structure for KeyPack description
//-------------------------------------------------------------
typedef struct __JBKPDescIndexKeyPackId : public JBKeyBase {
    //
    // Primay Index on KeyPack ID
    //
    DWORD dwKeyPackId;

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //-----------------------------------------------
    __JBKPDescIndexKeyPackId(
        const LICPACKDESCRECORD& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //-----------------------------------------------
    __JBKPDescIndexKeyPackId(
        const LICPACKDESCRECORD* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //-----------------------------------------------
    __JBKPDescIndexKeyPackId&
    operator=(const LICPACKDESCRECORD& v) {
        dwKeyPackId = v.dwKeyPackId;
        SetEmptyValue(FALSE);
        return *this;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() { return 1; }

    //--------------------------------------------------------
    BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*++
    ++*/
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(dwKeyPackId);
        *cbData = sizeof(dwKeyPackId);
        *grbit = JET_bitNewKey;
        return TRUE;
    }

} TLSKpDescIndexKpId;


//-------------------------------------------------------------
//
// LICPACKDESCRECORD_KeyPackId_LangId_idx
//
#define LICPACKDESCRECORD_ID_LANGID_INDEXNAME \
    LICPACKDESCRECORD_TABLE_NAME SEPERATOR LICPACKDESCRECORD_ID_COLUMN SEPERATOR LICPACKDESCRECORD_LANGID SEPERATOR INDEXNAME

//
// "+KeyPackId\0+LangId\0"
//
#define LICPACKDESCRECORD_ID_LANGID_INDEXNAME_INDEXKEY \
    INDEX_SORT_ASCENDING LICPACKDESCRECORD_ID_COLUMN INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICPACKDESCRECORD_LANGID INDEX_END_COLNAME

typedef struct __JBKPDescIndexKeyPackLangId : public JBKeyBase {
    //
    // Primary index on KeyPack and language Id
    //
    DWORD   dwKeyPackId;
    DWORD   dwLanguageId;

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //---------------------------------------------------
    __JBKPDescIndexKeyPackLangId(
        const LICPACKDESCRECORD* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //---------------------------------------------------
    __JBKPDescIndexKeyPackLangId(
        const LICPACKDESCRECORD& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //---------------------------------------------------
    __JBKPDescIndexKeyPackLangId&
    operator=(const LICPACKDESCRECORD& v) {
        dwKeyPackId = v.dwKeyPackId;
        dwLanguageId = v.dwLanguageId;

        SetEmptyValue(FALSE);
        return *this;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() { return 2; }

    //--------------------------------------------------------
    BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*++
    ++*/
    {
        BOOL retCode = TRUE;

        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *cbData = 0;
        switch(dwComponentIndex)
        {
            case 0:
                *pbData = &dwKeyPackId;
                *cbData = sizeof(dwKeyPackId);
                *grbit = JET_bitNewKey;
                break;

            case 1:
                *pbData = &dwLanguageId;
                *cbData = sizeof(dwLanguageId);
                *grbit = 0;
                break;

            default:
                JB_ASSERT(FALSE);
                retCode = FALSE;
                break;
        }

        return retCode;
    }

} TLSKpDescIndexKpLangId;


/////////////////////////////////////////////////////////////////////////

// KeyPack_LastModifyTime_idx
//
#define LICPACKDESCRECORD_LASTMODIFYTIME_INDEXNAME \
    LICPACKDESCRECORD_TABLE_NAME SEPERATOR LICPACKDESCRECORD_LASTMODIFYTIME SEPERATOR INDEXNAME

//
// Index  "+LastModifyTime\0"
//
#define LICPACKDESCRECORD_LASTMODIFYTIME_INDEXNAME_INDEXKEY \
    INDEX_SORT_ASCENDING LICPACKDESCRECORD_LASTMODIFYTIME INDEX_END_COLNAME

typedef struct __LICPACKDESCRECORDIdxOnModifyTime : public JBKeyBase {
    FILETIME ftLastModifyTime;

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //--------------------------------------------------------
    __LICPACKDESCRECORDIdxOnModifyTime(
        const LICPACKDESCRECORD& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //--------------------------------------------------------
    __LICPACKDESCRECORDIdxOnModifyTime(
        const LICPACKDESCRECORD* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //--------------------------------------------------------
    __LICPACKDESCRECORDIdxOnModifyTime&
    operator=(const LICPACKDESCRECORD& v) {
        ftLastModifyTime = v.ftLastModifyTime;
        SetEmptyValue(FALSE);
        return *this;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() { return 1; }

    //--------------------------------------------------------
    BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*++
    ++*/
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(ftLastModifyTime);
        *cbData = sizeof(ftLastModifyTime);
        *grbit = JET_bitNewKey;
        return TRUE;
    }
} TLSLICPACKDESCRECORDIndexLastModifyTime;


//
///////////////////////////////////////////////////////////////////////
//

//
///////////////////////////////////////////////////////////////////////
//
class LicPackDescTable : public TLSTable<LICPACKDESCRECORD>
{
private:

    static LPCTSTR pszTableName;
    
    TLSColumnUchar  ucEntryStatus;
    TLSColumnDword  dwKeyPackId;
    TLSColumnDword  dwLanguageId;    
    TLSColumnFileTime ftLastModifyTime;
    TLSColumnText   szCompanyName;
    TLSColumnText   szProductName;
    TLSColumnText   szProductDesc;

    BOOL
    ProcessSingleColumn(
        BOOL bFetch,
        TLSColumnBase& column,
        DWORD offset,
        PVOID pbData,
        DWORD cbData,
        PDWORD pcbDataReturn,
        LPCTSTR szColumnName
    );

    BOOL
    ProcessRecord(
        LICPACKDESCRECORD* v,
        BOOL bFetch,        // TRUE - fetch, FALSE insert
        DWORD dwParam,
        BOOL bUpdate
    );

public:
    virtual LPCTSTR
    GetTableName() 
    {
        return pszTableName;
    }

    //--------------------------------------------------------
    LicPackDescTable(
        JBDatabase& database
        ) : TLSTable<LICPACKDESCRECORD>(database)
    /*
    */
    {
    }

    //--------------------------------------------------------
    virtual BOOL
    ResolveToTableColumn();

    //--------------------------------------------------------
    virtual BOOL
    FetchRecord(
        LICPACKDESCRECORD& kpRecord,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&kpRecord, TRUE, dwParam, FALSE);
    }

    //--------------------------------------------------------
    virtual BOOL
    InsertRecord(
        LICPACKDESCRECORD& kpRecord,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&kpRecord, FALSE, dwParam, FALSE);
    }

    //-------------------------------------------------------
    virtual BOOL
    UpdateRecord(
        LICPACKDESCRECORD& kpRecord,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&kpRecord, FALSE, dwParam, TRUE);
    }

    //-------------------------------------------------------
    virtual BOOL
    Initialize() { return TRUE; }

    //-------------------------------------------------------
    virtual JBKeyBase*
    EnumerationIndex( 
        IN BOOL bMatchAll,
        IN DWORD dwParam,
        IN LICPACKDESCRECORD* kpDesc,
        IN OUT BOOL* bCompareKey
    );
    
    virtual BOOL
    EqualValue(
        LICPACKDESCRECORD& s1,
        LICPACKDESCRECORD& s2,
        BOOL bMatchAll,
        DWORD dwParam
    );
   
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tlsdb\kpdtab.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        kpdtab.cpp
//
// Contents:    Licensed Pack Description Table
//
// History:     
//              
//---------------------------------------------------------------------------
#include "KpDesc.h"


LPCTSTR __JBKPDescIndexKeyPackId::pszIndexName = LICPACKDESCRECORD_ID_INDEXNAME;
LPCTSTR __JBKPDescIndexKeyPackId::pszIndexKey = LICPACKDESCRECORD_ID_INDEXNAME_INDEXKEY;
LPCTSTR __JBKPDescIndexKeyPackLangId::pszIndexName = LICPACKDESCRECORD_ID_LANGID_INDEXNAME;
LPCTSTR __JBKPDescIndexKeyPackLangId::pszIndexKey = LICPACKDESCRECORD_ID_LANGID_INDEXNAME_INDEXKEY;
LPCTSTR __LICPACKDESCRECORDIdxOnModifyTime::pszIndexName = LICPACKDESCRECORD_LASTMODIFYTIME_INDEXNAME;
LPCTSTR __LICPACKDESCRECORDIdxOnModifyTime::pszIndexKey = LICPACKDESCRECORD_LASTMODIFYTIME_INDEXNAME_INDEXKEY;


LPCTSTR LicPackDescTable::pszTableName = LICPACKDESCRECORD_TABLE_NAME;
CCriticalSection LicPackDescTable::g_TableLock;
//----------------------------------------------------------

TLSJBIndex 
LicPackDescTable::g_TableIndex[] = 
{
    {
        LICPACKDESCRECORD_ID_INDEXNAME,
        LICPACKDESCRECORD_ID_INDEXNAME_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull, //JET_bitIndexUnique,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },        

    {
        LICPACKDESCRECORD_ID_LANGID_INDEXNAME,
        LICPACKDESCRECORD_ID_LANGID_INDEXNAME_INDEXKEY,
        -1,
        JET_bitIndexPrimary,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    }
};       

int LicPackDescTable::g_NumTableIndex = sizeof(LicPackDescTable::g_TableIndex) / sizeof(LicPackDescTable::g_TableIndex[0]);

TLSJBColumn 
LicPackDescTable::g_Columns[] = 
{
    {        
        LICPACKDESCRECORD_ENTRYSTATUS,
        JET_coltypUnsignedByte,
        0,
        JET_bitColumnFixed,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    {
        LICPACKDESCRECORD_ID_COLUMN,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },
   
    {
        LICPACKDESCRECORD_LASTMODIFYTIME,
        JET_coltypBinary,
        sizeof(FILETIME),
        JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    {
        LICPACKDESCRECORD_LANGID,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },
    
    {
        LICPACKDESCRECORD_COMPANY_NAME,
        //JET_coltypLongText,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        JBSTRING_NULL,
        _tcslen(JBSTRING_NULL),
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    {
        LICPACKDESCRECORD_PRODUCT_NAME,
        //JET_coltypLongText,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        JBSTRING_NULL,
        _tcslen(JBSTRING_NULL),
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },
    
    {
        LICPACKDESCRECORD_PRODUCT_DESC,
        //JET_coltypLongText,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        JBSTRING_NULL,
        _tcslen(JBSTRING_NULL),
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },
};

int 
LicPackDescTable::g_NumColumns = sizeof(LicPackDescTable::g_Columns) / sizeof(LicPackDescTable::g_Columns[0]);

//--------------------------------------------------------------------------
BOOL
LicPackDescTable::ResolveToTableColumn()
/*
*/
{
    if(IsValid() == FALSE)
    {
        DebugOutput( 
                _TEXT("Table %s is not valid...\n"),
                GetTableName()
            );

        JB_ASSERT(FALSE);
        SetLastJetError(JET_errNotInitialized);
        goto cleanup;
    }

    m_JetErr = ucEntryStatus.AttachToTable(
                        *this,
                        LICPACKDESCRECORD_ENTRYSTATUS
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwKeyPackId.AttachToTable(
                        *this,
                        LICPACKDESCRECORD_ID_COLUMN
                    );
    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwLanguageId.AttachToTable(
                        *this,
                        LICPACKDESCRECORD_LANGID
                    );
    if(IsSuccess() == FALSE)
        goto cleanup;

    
    m_JetErr = ftLastModifyTime.AttachToTable(
                        *this,
                        LICPACKDESCRECORD_LASTMODIFYTIME
                    );
    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = szCompanyName.AttachToTable(
                        *this,
                        LICPACKDESCRECORD_COMPANY_NAME
                    );
    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = szProductName.AttachToTable(
                        *this,
                        LICPACKDESCRECORD_PRODUCT_NAME
                    );
    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = szProductDesc.AttachToTable(
                        *this,
                        LICPACKDESCRECORD_PRODUCT_DESC
                    );

cleanup:
    return IsSuccess();
}

//-------------------------------------------------------------------------
CLASS_PRIVATE BOOL
LicPackDescTable::ProcessSingleColumn(
    BOOL bFetch,
    TLSColumnBase& column,
    DWORD offset,
    PVOID pbData,
    DWORD cbData,
    PDWORD pcbDataReturn,
    LPCTSTR szColumnName
    )
/*
*/
{
    if(bFetch) 
    {
        m_JetErr = column.FetchColumnValue(
                                    pbData, 
                                    cbData, 
                                    offset, 
                                    pcbDataReturn
                                );
    }
    else
    {
        m_JetErr = column.InsertColumnValue(
                                    pbData,     
                                    cbData, 
                                    offset
                                );
    }

    REPORTPROCESSFAILED(
            bFetch,
            GetTableName(),
            szColumnName,
            m_JetErr
        );
    return IsSuccess();
}

//--------------------------------------------------------------------------
CLASS_PRIVATE BOOL
LicPackDescTable::ProcessRecord(
    LICPACKDESCRECORD* record,
    BOOL bFetch,
    DWORD dwParam,
    BOOL bUpdate
    )
/*
*/
{
    DWORD dwSize;

    if(bFetch == FALSE)
    {
        //BeginTransaction();
        BeginUpdate(bUpdate);

        if(!(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_LASTMODIFYTIME))
        {
            JB_ASSERT(FALSE);
            dwParam |= LICPACKDESCRECORD_TABLE_PROCESS_LASTMODIFYTIME;
        }
    }
    else
    {
        SetLastJetError(JET_errSuccess);
    }

    if(IsSuccess() == FALSE)
        return FALSE;

    if(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_ENTRYSTATUS)
    {
        ProcessSingleColumn(
                        bFetch, 
                        ucEntryStatus, 
                        0,
                        &(record->ucEntryStatus),
                        sizeof(record->ucEntryStatus),
                        &dwSize,
                        LICPACKDESCRECORD_ENTRYSTATUS
                    );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    if(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_KEYPACKID)
    {
        ProcessSingleColumn(
                        bFetch, 
                        dwKeyPackId, 
                        0,
                        &(record->dwKeyPackId),
                        sizeof(record->dwKeyPackId),
                        &dwSize,
                        LICPACKDESCRECORD_ID_COLUMN
                    );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            
    
    if(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_LANGID)
    {
        ProcessSingleColumn(
                        bFetch, 
                        dwLanguageId, 
                        0,
                        &(record->dwLanguageId),
                        sizeof(record->dwLanguageId),
                        &dwSize,
                        LICPACKDESCRECORD_LANGID
                    );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    if(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_LASTMODIFYTIME)
    {
        ProcessSingleColumn(
                        bFetch, 
                        ftLastModifyTime, 
                        0,
                        &(record->ftLastModifyTime),
                        sizeof(record->ftLastModifyTime),
                        &dwSize,
                        LICPACKDESCRECORD_LASTMODIFYTIME
                    );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    if(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_COMPANYNAME)
    {
        ProcessSingleColumn(
                        bFetch, 
                        szCompanyName, 
                        0,
                        record->szCompanyName,
                        sizeof(record->szCompanyName),
                        &dwSize,
                        LICPACKDESCRECORD_COMPANY_NAME
                    );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    if(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_PRODUCTNAME)
    {
        ProcessSingleColumn(
                        bFetch, 
                        szProductName, 
                        0,
                        record->szProductName,
                        sizeof(record->szProductName),
                        &dwSize,
                        LICPACKDESCRECORD_PRODUCT_NAME
                    );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    if(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_PRODUCTDESC)
    {
        ProcessSingleColumn(
                        bFetch, 
                        szProductDesc, 
                        0,
                        record->szProductDesc,
                        sizeof(record->szProductDesc),
                        &dwSize,
                        LICPACKDESCRECORD_PRODUCT_DESC
                    );
    }

cleanup:


    // 
    // For inserting/updating record
    if(bFetch == FALSE)
    {
        JET_ERR jetErr;
        jetErr = GetLastJetError();

        EndUpdate(IsSuccess() == FALSE);

        if(jetErr != JET_errSuccess  && IsSuccess() == FALSE)
            SetLastJetError(jetErr);
    }

    return IsSuccess();
}

//----------------------------------------------------------------------------
JBKeyBase*
LicPackDescTable::EnumerationIndex(
    BOOL bMatchAll,
    DWORD dwSearchParam,
    LICPACKDESCRECORD* kpDesc,
    BOOL* bCompareKey
    )
/*
*/
{
    JBKeyBase* index=NULL;

    *bCompareKey = bMatchAll;

    // derive a index to use
    //
    if( bMatchAll == TRUE && 
        dwSearchParam & LICPACKDESCRECORD_TABLE_SEARCH_KEYPACKID && 
        dwSearchParam & LICPACKDESCRECORD_TABLE_SEARCH_LANGID)
    {
        index = new TLSKpDescIndexKpLangId(kpDesc);
    }
    else 
    {
        index = new TLSKpDescIndexKpId(kpDesc);

        *bCompareKey = (bMatchAll && (dwSearchParam & LICPACKDESCRECORD_TABLE_SEARCH_KEYPACKID));
    }

    return index;
}

//---------------------------------------------------------------------------
BOOL
LicPackDescTable::EqualValue(
    LICPACKDESCRECORD& src,
    LICPACKDESCRECORD& dest,
    BOOL bMatchAll,
    DWORD dwParam
    )
/*
*/
{
    BOOL bRetCode = TRUE;

    if(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_ENTRYSTATUS)
    {
        bRetCode = (src.ucEntryStatus == dest.ucEntryStatus);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_KEYPACKID)
    {
        bRetCode = (src.dwKeyPackId == dest.dwKeyPackId);

        //
        // bMatchAll == TRUE and bRetCode == FALSE -> return FALSE
        // bMatchAll == FALSE and bRetCode == TRUE -> return TRUE
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_LANGID)
    {
        bRetCode = (src.dwLanguageId == dest.dwLanguageId);

        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_COMPANYNAME)
    {
        bRetCode = (_tcscmp(src.szCompanyName, dest.szCompanyName) == 0);

        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_PRODUCTNAME)
    {
        bRetCode = (_tcscmp(src.szProductName, dest.szProductName) == 0);

        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICPACKDESCRECORD_TABLE_PROCESS_PRODUCTDESC)
    {
        bRetCode = (_tcscmp(src.szProductDesc, dest.szProductDesc) == 0);
    }

cleanup:

    return bRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tlsdb\licpack.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        LicPack.h
//
// Contents:    LicensedPack Table
//
// History:     
//              
//---------------------------------------------------------------------------
#ifndef __LICENSEDPACK_H__
#define __LICENSEDPACK_H__

#include "tlsdb.h"

//
// re-direct define using what's in tlsdef.h just for backward compatibility
//
#define LICENSEDPACK_PROCESS_DWINTERNAL          LSKEYPACK_EXSEARCH_DWINTERNAL
#define LICENSEDPACK_PROCESS_MODIFYTIME          (LSKEYPACK_EXSEARCH_AVAILABLE << 1)

//
// Basic LicensedPack PROCESS Parameter
//
#define LICENSEDPACK_PROCESS_SZKEYPACKID         LSKEYPACK_SEARCH_KEYPACKID          // szKeyPackId
#define LICENSEDPACK_PROCESS_AGREEMENTTYPE       LSKEYPACK_SEARCH_KEYPACKTYPE        // ucKeyPackType
#define LICENSEDPACK_PROCESS_PRODUCTID           LSKEYPACK_SEARCH_PRODUCTID          // szProductId
#define LICENSEDPACK_PROCESS_MAJORVERSION        LSKEYPACK_SEARCH_MAJORVERSION       // wMajorVersion
#define LICENSEDPACK_PROCESS_MINORVERSION        LSKEYPACK_SEARCH_MINORVERSION       // wMinorVersion
#define LICENSEDPACK_PROCESS_PLATFORMTYPE        LSKEYPACK_SEARCH_PLATFORMTYPE       // dwPlatformType
#define LICENSEDPACK_PROCESS_LICENSETYPE         LSKEYPACK_SEARCH_LICENSETYPE        // ucLicenseType
#define LICENSEDPACK_PROCESS_COP                 LSKEYPACK_SEARCH_COP                // ucChannelOfPurchase
#define LICENSEDPACK_PROCESS_BSERIALNUMBER       LSKEYPACK_SEARCH_BSERIALNUMBER      // szBeginSerialNumber
#define LICENSEDPACK_PROCESS_TOTALLICENSES       LSKEYPACK_SEARCH_TOTALLICENSES      // dwTotalLicenseInKeyPack
#define LICENSEDPACK_PROCESS_PRODUCTFLAGS        LSKEYPACK_SEARCH_PRODUCTFLAGS       // dwProductFlags
#define LICENSEDPACK_PROCESS_COMPANYNAME         LSKEYPACK_SEARCH_COMPANYNAME        // szCompanyName
#define LICENSEDPACK_PROCESS_EXPIREDATE          LSKEYPACK_EXSEARCH_EXPIREDATE       // dwExpirationDate

//
// Additional attribute for LicensedPack
//
#define LICENSEDPACK_PROCESS_ATTRIBUTE          (LSKEYPACK_EXSEARCH_AVAILABLE << 2)
#define LICENSEDPACK_PROCESS_KEYPACKSTATUS      LSKEYPACK_EXSEARCH_KEYPACKSTATUS    // ucKeyPackStatus
#define LICENSEDPACK_PROCESS_AVAILABLE          LSKEYPACK_EXSEARCH_AVAILABLE        // dwNumberOfLicenses
#define LICENSEDPACK_PROCESS_ACTIVATEDATE       LSKEYPACK_EXSEARCH_ACTIVATEDATE     // dwActivateDate
#define LICENSEDPACK_PROCESS_EXPIREDATE         LSKEYPACK_EXSEARCH_EXPIREDATE       // dwExpirationDate
#define LICENSEDPACK_PROCESS_DOMAINSID          (LSKEYPACK_EXSEARCH_AVAILABLE << 3)
#define LICENSEDPACK_PROCESS_LSSETUPID          (LSKEYPACK_EXSEARCH_AVAILABLE << 4)    
#define LICENSEDPACK_PROCESS_DOMAINNAME         (LSKEYPACK_EXSEARCH_AVAILABLE << 5)
#define LICENSEDPACK_PROCESS_SERVERNAME         (LSKEYPACK_EXSEARCH_AVAILABLE << 6)
#define LICENSEDPACK_PROCESS_NEXTSERIALNUMBER   (LSKEYPACK_EXSEARCH_AVAILABLE << 7)
#define LICENSEDPACK_PROCESS_ENTRYSTATUS        (LSKEYPACK_EXSEARCH_AVAILABLE << 8)

#define LICENSEDPACK_ALLOCATE_LICENSE_UPDATE_FIELD \
    (LICENSEDPACK_PROCESS_AVAILABLE | LICENSEDPACK_PROCESS_NEXTSERIALNUMBER | LICENSEDPACK_PROCESS_MODIFYTIME)

#define LICENSEDPACK_FIND_PRODUCT \
    (LSKEYPACK_SEARCH_KEYPACKID | LSKEYPACK_SEARCH_COMPANYNAME | \
     LSKEYPACK_SEARCH_PRODUCTID | LSKEYPACK_SEARCH_MAJORVERSION | \
     LSKEYPACK_SEARCH_MINORVERSION | LSKEYPACK_SEARCH_PLATFORMTYPE)

#define LICENSEDPACK_FIND_LICENSEPACK \
    (LSKEYPACK_SEARCH_KEYPACKTYPE | LSKEYPACK_SEARCH_MAJORVERSION | \
     LSKEYPACK_SEARCH_MINORVERSION | LSKEYPACK_SEARCH_COMPANYNAME | \
     LSKEYPACK_SEARCH_PLATFORMTYPE)

//
// Licensed KeyPack Property Table Name
//
#define LICENSEDPACK_TABLE_NAME                  _TEXT("LicensedPack")

//
// Additional LicensedPack Column
//
#define LICENSEDPACK_COLUMN_KEYPACKID            _TEXT("InternalKeyPackId")
#define LICENSEDPACK_COLUMN_LASTMODIFYTIME       _TEXT("LastModifyTime")

//
// KeyPack property as defined in backend doc.
//
#define LICENSEDPACK_COLUMN_LPID                  _TEXT("LPID")                   // license pack ID
#define LICENSEDPACK_COLUMN_AGREEMENTTYPE         _TEXT("AgreementType")          // SELECT/MOLP/FREE
#define LICENSEDPACK_COLUMN_COMPANYNAME           _TEXT("CompanyName")
#define LICENSEDPACK_COLUMN_PRODUCTID             _TEXT("ProductID")
#define LICENSEDPACK_COLUMN_MAJORVERSION          _TEXT("ProductMajorVersion")
#define LICENSEDPACK_COLUMN_MINORVERSION          _TEXT("ProductMinorVersion")
#define LICENSEDPACK_COLUMN_PLATFORMTYPE          _TEXT("PlatformType")
#define LICENSEDPACK_COLUMN_LICENSETYPE           _TEXT("LicenseType")
#define LICENSEDPACK_COLUMN_COP                   _TEXT("ChannelOfPurchase")
#define LICENSEDPACK_COLUMN_BSERIALNUMBER         _TEXT("BeginSerialNumber")
#define LICENSEDPACK_COLUMN_TOTALLICENSES         _TEXT("TotalLicenses")
#define LICENSEDPACK_COLUMN_PRODUCTFLAGS          _TEXT("ProductFlag")
#define LICENSEDPACK_COLUMN_EXPIREDATE            _TEXT("ExpirationDate")

#define LICENSEDPACK_COLUMN_ATTRIBUTE             _TEXT("KeyPackAttribute")
#define LICENSEDPACK_COLUMN_KEYPACKSTATUS         _TEXT("KeyPackStatus")
#define LICENSEDPACK_COLUMN_AVAILABLE             _TEXT("NumberLicenses")
#define LICENSEDPACK_COLUMN_NEXTSERIALNUMBER      _TEXT("NextSerialNumber")
#define LICENSEDPACK_COLUMN_ACTIVATEDATE          _TEXT("ActivationDate")
#define LICENSEDPACK_COLUMN_EXPIREDATE            _TEXT("ExpirationDate")
#define LICENSEDPACK_COLUMN_DOMAINSETUPID         _TEXT("TLSDomainSetupId")
#define LICENSEDPACK_COLUMN_LSSETUPID             _TEXT("TLSSetupId")
#define LICENSEDPACK_COLUMN_DOMAINNAME            _TEXT("DomainName")
#define LICENSEDPACK_COLUMN_LSERVERNAME           _TEXT("ServerName")
#define LICENSEDPACK_COLUMN_ENTRYSTATUS           _TEXT("EntryStatus")

typedef struct __LicensePack : public TLSReplLicensePack 
{
    void
    Cleanup() 
    { 
        if(pbDomainSid != NULL)
        {
            FreeMemory(pbDomainSid);
        }
    }
    
    __LicensePack() 
    {
        pbDomainSid = NULL;
        cbDomainSid = 0;
    }

    ~__LicensePack() 
    {
        Cleanup();
    }

    __LicensePack&
    operator=(
        const TLSReplLicensePack& v
        )
    /*++

    ++*/
    {
        BOOL bSuccess;
        PBYTE pbOldData=pbDomainSid;
        DWORD cbOldData=cbDomainSid;

        *(TLSReplLicensePack *)this = v;

        pbDomainSid = pbOldData;
        cbDomainSid = cbOldData;

        bSuccess = TLSDBCopySid(
                            (PSID)v.pbDomainSid,
                            v.cbDomainSid,
                            (PSID *)&pbDomainSid,
                            &cbDomainSid
                        );

        JB_ASSERT(bSuccess);

        return *this;
    }

    __LicensePack&
    operator=(const __LicensePack& v)
    /*++
    ++*/
    {
        BOOL bSuccess;
        PBYTE pbOldData=pbDomainSid;
        DWORD cbOldData=cbDomainSid;

        if(this == &v)
            return *this;

        *(TLSReplLicensePack *)this = *(TLSReplLicensePack *)&v;

        pbDomainSid = pbOldData;
        cbDomainSid = cbOldData;

        bSuccess = TLSDBCopySid(
                            (PSID)v.pbDomainSid,
                            v.cbDomainSid,
                            (PSID *)&pbDomainSid,
                            &cbDomainSid
                        );

        JB_ASSERT(bSuccess);

        return *this;
    }

} LICENSEPACK, *LPLICENSEPACK, *PLICENSEPACK;

typedef LICENSEPACK TLSLICENSEPACK;
typedef LPLICENSEPACK LPTLSLICENSEPACK;
typedef PLICENSEPACK PTLSLICENSEPACK;

////////////////////////////////////////////////////////////////
//
//  Primary Index on KeyPack ID (internal tracking number)
//
////////////////////////////////////////////////////////////////

//
// LicensedPack_KeyPackId_idx
//
#define LICENSEDPACK_INDEX_INTERNALKEYPACKID_INDEXNAME \
    LICENSEDPACK_TABLE_NAME SEPERATOR LICENSEDPACK_COLUMN_KEYPACKID SEPERATOR INDEXNAME

//
// Index Key "+KeyPackId\0"
//
#define LICENSEDPACK_INDEX_INTERNALKEYPACKID_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_KEYPACKID INDEX_END_COLNAME

typedef struct __LicensedPackIdxOnInternalKpId : public JBKeyBase {
    //
    // Primary Index on internal KeyPack tracking ID
    //
    DWORD dwKeyPackId;

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;
    

    //--------------------------------------------------------
    __LicensedPackIdxOnInternalKpId(
        const LICENSEPACK& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //--------------------------------------------------------
    __LicensedPackIdxOnInternalKpId(
        const LICENSEPACK* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //--------------------------------------------------------
    __LicensedPackIdxOnInternalKpId&
    operator=(const LICENSEPACK& v) 
    {
        dwKeyPackId = v.dwKeyPackId;
        SetEmptyValue(FALSE);
        return *this;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() { return 1; }

    //--------------------------------------------------------
    BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*++
    ++*/
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(dwKeyPackId);
        *cbData = sizeof(dwKeyPackId);
        *grbit = JET_bitNewKey;
        return TRUE;
    }
} TLSLicensedPackIdxInternalKpId;


////////////////////////////////////////////////////////////////
//
//  Index on EntryLastModifyTime
//
//
////////////////////////////////////////////////////////////////

//
// LicensedPack_LastModifyTime_idx
//
#define LICENSEDPACK_INDEX_LASTMODIFYTIME_INDEXNAME \
    LICENSEDPACK_TABLE_NAME SEPERATOR LICENSEDPACK_COLUMN_LASTMODIFYTIME SEPERATOR INDEXNAME

//
// Index key "+LastModifyTime\0"
//
#define LICENSEDPACK_INDEX_LASTMODIFYTIME_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_LASTMODIFYTIME INDEX_END_COLNAME

typedef struct __LicensedPackIdxOnModifyTime : public JBKeyBase {
    FILETIME ftLastModifyTime;

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //--------------------------------------------------------
    __LicensedPackIdxOnModifyTime(
        const LICENSEPACK& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //--------------------------------------------------------
    __LicensedPackIdxOnModifyTime(
        const LICENSEPACK* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //--------------------------------------------------------
    __LicensedPackIdxOnModifyTime&
    operator=(const LICENSEPACK& v) 
    {
        ftLastModifyTime = v.ftLastModifyTime;
        SetEmptyValue(FALSE);
        return *this;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() { return 1; }

    //--------------------------------------------------------
    BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*++
    ++*/
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(ftLastModifyTime);
        *cbData = sizeof(ftLastModifyTime);
        *grbit = JET_bitNewKey;
        return TRUE;
    }
} TLSLicensedPackIdxLastModifyTime;


////////////////////////////////////////////////////////////////
//
//  Index on Company name
//
//
////////////////////////////////////////////////////////////////

//
// KeyPack_CompanyName_idx
//
#define LICENSEDPACK_INDEX_COMPANYNAME_INDEXNAME \
    LICENSEDPACK_TABLE_NAME SEPERATOR LICENSEDPACK_COLUMN_COMPANYNAME SEPERATOR INDEXNAME

//
// Index on key "+CompanyName\0"
//
#define LICENSEDPACK_INDEX_COMPANYNAME_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_COMPANYNAME INDEX_END_COLNAME

typedef struct __LicensedPackIdxOnCompanyName : public JBKeyBase {
    TCHAR szCompanyName[ MAX_JETBLUE_TEXT_LENGTH + 1 ];

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //-------------------------------------------------
    __LicensedPackIdxOnCompanyName( 
        const LICENSEPACK& v
        ) : JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //-------------------------------------------------
    __LicensedPackIdxOnCompanyName( 
        const LICENSEPACK* v=NULL
        ) : JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //-------------------------------------------------
    __LicensedPackIdxOnCompanyName&
    operator=(const LICENSEPACK& v) {
        SetEmptyValue(FALSE);
        _tcscpy(szCompanyName, v.szCompanyName);
        return *this;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() { return 1; }


    //--------------------------------------------------------
    BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*++
    ++*/
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(szCompanyName[0]);
        *cbData = _tcslen(szCompanyName) * sizeof(TCHAR);
        *grbit = JET_bitNewKey;
        return TRUE;
    }

} TLSLicensedPackIdxCompany;


////////////////////////////////////////////////////////////////
//
//  Index on Product ID
//
//
////////////////////////////////////////////////////////////////
//
// LicensedPack_ProductId_idx
//
#define LICENSEDPACK_INDEX_PRODUCTID_INDEXNAME \
    LICENSEDPACK_TABLE_NAME SEPERATOR LICENSEDPACK_COLUMN_PRODUCTID SEPERATOR INDEXNAME

//
// Index on key "+ProductId\0"
//
#define LICENSEDPACK_INDEX_PRODUCTID_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_PRODUCTID INDEX_END_COLNAME

typedef struct __LicensedPackIdxOnProductId : public JBKeyBase {
    TCHAR szProductId[ MAX_JETBLUE_TEXT_LENGTH + 1 ];

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //--------------------------------------------------------
    __LicensedPackIdxOnProductId(
        const LICENSEPACK& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //--------------------------------------------------------
    __LicensedPackIdxOnProductId(
        const LICENSEPACK* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //--------------------------------------------------------
    __LicensedPackIdxOnProductId&
    operator=(const LICENSEPACK& v) {
        SetEmptyValue(FALSE);
        _tcscpy(szProductId, v.szProductId);
        return *this;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() { return 1; }


    //--------------------------------------------------------
    BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*++
    ++*/
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(szProductId[0]);
        *cbData = _tcslen(szProductId) * sizeof(TCHAR);
        *grbit = JET_bitNewKey;
        return TRUE;
    }

} TLSLicensedPackIdxProductId;


////////////////////////////////////////////////////////////////
//
//  Index on KeyPack ID
//
//
////////////////////////////////////////////////////////////////
//
// KeyPack_LPID_idx
//
#define LICENSEDPACK_INDEX_KEYPACKID_INDEXNAME \
    LICENSEDPACK_TABLE_NAME SEPERATOR LICENSEDPACK_COLUMN_LPID SEPERATOR INDEXNAME

//
// Index on key "+lpid\0"
//
#define LICENSEDPACK_INDEX_KEYPACKID_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_LPID INDEX_END_COLNAME

typedef struct __LicensedPackIdxOnKeyPackId : public JBKeyBase {

    TCHAR szKeyPackId[ MAX_JETBLUE_TEXT_LENGTH + 1 ];

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;


    //----------------------------------------------
    __LicensedPackIdxOnKeyPackId(
        const LICENSEPACK& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //----------------------------------------------
    __LicensedPackIdxOnKeyPackId(
        const LICENSEPACK* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //----------------------------------------------
    __LicensedPackIdxOnKeyPackId&
    operator=(const LICENSEPACK& v) {
        SetEmptyValue(FALSE);
        _tcscpy(szKeyPackId, v.szKeyPackId);
        return *this;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() { return 1; }

    //--------------------------------------------------------
    BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*++
    ++*/
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(szKeyPackId[0]);
        *cbData = _tcslen(szKeyPackId) * sizeof(TCHAR);
        *grbit = JET_bitNewKey;
        return TRUE;
    }
} TLSLicensedPackIdxKeyPackId;


//
////////////////////////////////////////////////////////////////
//

////////////////////////////////////////////////////////////////
//
//  Index for searching Installed License Pack
//  Max. 255 bytes per key so must looping 
//
////////////////////////////////////////////////////////////////

//
// Index name KeyPack_InstalledProduct_idx
// 
#define LICENSEDPACK_INDEX_INSTALLEDPRODUCT_INDEXNAME \
    LICENSEDPACK_TABLE_NAME SEPERATOR _TEXT("InstalledProduct") SEPERATOR INDEXNAME

//
// Number of Component in this key
#define LICENSEDPACK_INSTALLEDPRODUCT_KEY_COMPONENTS    6

//
//
// Index Key "+LPID\0+MajorVersion\0+MinorVersion\0+PlatformType\0+CompanyName\0+ProductId\0"
//
#define LICENSEDPACK_INDEX_INSTALLEDPRODUCT_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_LPID INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_MAJORVERSION INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_MINORVERSION INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_PLATFORMTYPE INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_COMPANYNAME INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_PRODUCTID INDEX_END_COLNAME 


typedef struct __LicensedPackIdxOnInstalledProduct : public JBKeyBase {
    //
    // Index for searching duplicate KeyPack
    //

    //
    // Adding or removing member must modify GetNumKeyComponents()
    //
    TCHAR szKeyPackId[LSERVER_MAX_STRING_SIZE + 1];

    WORD  wMajorVersion;
    WORD  wMinorVersion;
    DWORD dwPlatformType;

    TCHAR szCompanyName[LSERVER_MAX_STRING_SIZE + 1];
    TCHAR szProductId[LSERVER_MAX_STRING_SIZE + 1];

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //---------------------------------------------------------------
    __LicensedPackIdxOnInstalledProduct(
        const LICENSEPACK& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //---------------------------------------------------------------
    __LicensedPackIdxOnInstalledProduct(
        const LICENSEPACK* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //---------------------------------------------------------------
    __LicensedPackIdxOnInstalledProduct&
    operator=(const LICENSEPACK& v) {
        _tcscpy(szKeyPackId, v.szKeyPackId);
        _tcscpy(szCompanyName, v.szCompanyName);
        _tcscpy(szProductId, v.szProductId);
        wMajorVersion = v.wMajorVersion;
        wMinorVersion = v.wMinorVersion;
        dwPlatformType = v.dwPlatformType;
        SetEmptyValue(FALSE);
        return *this;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() { 
        return LICENSEDPACK_INSTALLEDPRODUCT_KEY_COMPONENTS;
    }

    //--------------------------------------------------------
    BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*++
    ++*/
    {
        BOOL retCode=TRUE;
        *cbData = 0;
        *grbit = 0;

        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        switch(dwComponentIndex)
        {
            case 0:
                //
                // hopefully, this will reduce the number of record needed to
                // loop thru.
                //
                *pbData = &(szKeyPackId[0]);
                *cbData = _tcslen(szKeyPackId) * sizeof(TCHAR);
                *grbit = JET_bitNewKey;
                break;

            case 1:
                *pbData = &(wMajorVersion);
                *cbData = sizeof(wMajorVersion);
                break;
        
            case 2:
                *pbData = &(wMinorVersion);
                *cbData = sizeof(wMinorVersion);
                break;

            case 3:
                *pbData = &(dwPlatformType);
                *cbData = sizeof(dwPlatformType);
                break;

            case 4:
                *pbData = &(szCompanyName[0]);
                *cbData = _tcslen(szCompanyName) * sizeof(TCHAR);
                break;

            case 5:
                *pbData = &(szProductId[0]);
                *cbData = _tcslen(szProductId) * sizeof(TCHAR);
                break;

            default:
                JB_ASSERT(FALSE);
                retCode = FALSE;
                break;
        }

        return retCode;
    }
} TLSLicensedPackIdxInstalledProduct;



////////////////////////////////////////////////////////////////
//
//  Index for Allocated license
//
////////////////////////////////////////////////////////////////

//
// Index name for allocating license - KeyPack_AllocateLicense_idx
//
#define LICENSEDPACK_INDEX_ALLOCATELICENSE_INDEXNAME \
    LICENSEDPACK_TABLE_NAME SEPERATOR _TEXT("AllocateLicense") SEPERATOR INDEXNAME

#define LICENSEDPACK_ALLOCATELICENSE_KEY_COMPONENTS 6

//
// Index key for allocating license
// "+KeyPackType\0+ProductMajorVersion\0+ProductMinorVersion\0+PlatformType+CompanyName\0+ProductID\0"
//
#define LICENSEDPACK_INDEX_ALLOCATELICENSE_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_AGREEMENTTYPE INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_MAJORVERSION INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_MINORVERSION INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_PLATFORMTYPE INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_COMPANYNAME INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSEDPACK_COLUMN_PRODUCTID INDEX_END_COLNAME 


typedef struct __LicensedPackIdxOnAllocLicense : public JBKeyBase {
    //
    // Index for allocating licenses
    //
    UCHAR ucAgreementType;
    WORD  wMajorVersion;
    WORD  wMinorVersion;
    DWORD dwPlatformType;

    TCHAR szCompanyName[LSERVER_MAX_STRING_SIZE + 1];
    TCHAR szProductId[LSERVER_MAX_STRING_SIZE + 1];

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //------------------------------------------------------
    __LicensedPackIdxOnAllocLicense(
        const LICENSEPACK* v=NULL
        ) : JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //------------------------------------------------------
    __LicensedPackIdxOnAllocLicense(
        const LICENSEPACK& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }
  
    __LicensedPackIdxOnAllocLicense&
    operator=(const LICENSEPACK& v) {
        ucAgreementType = v.ucAgreementType;
        _tcscpy(szCompanyName, v.szCompanyName);
        _tcscpy(szProductId, v.szProductId);
        wMajorVersion = v.wMajorVersion;
        wMinorVersion = v.wMinorVersion;
        dwPlatformType = v.dwPlatformType;

        SetEmptyValue(FALSE);
        return *this;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() { 
        return LICENSEDPACK_ALLOCATELICENSE_KEY_COMPONENTS;
    }
    

    //--------------------------------------------------------------
    inline BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*
    */
    {
        BOOL retCode=TRUE;

        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *cbData = 0;
        *grbit = 0;

        switch(dwComponentIndex)
        {
            case 0:
                *pbData = &(ucAgreementType);
                *cbData = sizeof(ucAgreementType);
                *grbit = JET_bitNewKey;
                break;

            case 1:
                *pbData = &(wMajorVersion);
                *cbData = sizeof(wMajorVersion);
                break;
        
            case 2:
                *pbData = &(wMinorVersion);
                *cbData = sizeof(wMinorVersion);
                break;

            case 3:
                *pbData = &(dwPlatformType);
                *cbData = sizeof(dwPlatformType);
                break;

            case 4:
                *pbData = &(szCompanyName[0]);
                *cbData = _tcslen(szCompanyName) * sizeof(TCHAR);
                break;

            case 5:
                *pbData = &(szProductId[0]);
                *cbData = _tcslen(szProductId) * sizeof(TCHAR);
                break;

            default:
                JB_ASSERT(FALSE);
                retCode = FALSE;
                break;
        }

        return retCode;
    }
} TLSLicensedPackIdxAllocateLicense;


//------------------------------------------------------------

// -----------------------------------------------------------
//  LicensedPack Table Structure
// -----------------------------------------------------------
class LicPackTable : public TLSTable<LICENSEPACK>  {
private:

    static LPCTSTR pszTableName;

    BOOL
    ProcessSingleColumn(
        BOOL bFetch,
        TLSColumnBase& column,
        DWORD offset,
        PVOID pbData,
        DWORD cbData,
        PDWORD pcbDataReturn,
        LPCTSTR szColumnName
    );

    BOOL
    ProcessRecord(
        LICENSEPACK* v,
        BOOL bFetch,        // TRUE - fetch, FALSE insert
        DWORD dwParam,
        BOOL bUpdate
    );    

public:
    TLSColumnUchar      ucEntryStatus;

    //
    // Additional License Pack Property.
    //
    TLSColumnDword      dwKeyPackId;
    TLSColumnFileTime   ftLastModifyTime;

    TLSColumnDword      dwAttribute;
    TLSColumnDword      dwNextSerialNumber;
    TLSColumnDword      dwActivateDate;
    TLSColumnDword      dwExpirationDate;
    TLSColumnDword      dwNumberOfLicenses;
    TLSColumnUchar      ucKeyPackStatus;
    TLSColumnBinary     pbDomainSid;
    TLSColumnText       szInstallId;
    TLSColumnText       szDomainName;
    TLSColumnText       szTlsServerName;

    //
    // Standard License Pack Property
    //
    TLSColumnText       szKeyPackId;
    TLSColumnUchar      ucAgreementType;
    TLSColumnText       szCompanyName;
    TLSColumnText       szProductId;
    TLSColumnShort      wMajorVersion;
    TLSColumnShort      wMinorVersion;
    TLSColumnDword      dwPlatformType;
    TLSColumnUchar      ucLicenseType;
    TLSColumnUchar      ucChannelOfPurchase;
    TLSColumnText       szBeginSerialNumber;
    TLSColumnDword      dwTotalLicenseInKeyPack;
    TLSColumnDword      dwProductFlags;

    //-----------------------------------------------------
    virtual LPCTSTR
    GetTableName() 
    {
        return pszTableName;
    }
    

    //-----------------------------------------------------
    LicPackTable(
        JBDatabase& database
        ) : 
        TLSTable<LICENSEPACK> (database)
    /*
    */
    {
    }

    //-----------------------------------------------------
    virtual BOOL
    ResolveToTableColumn();

    //-----------------------------------------------------
    virtual BOOL
    FetchRecord(
        LICENSEPACK& kp,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&kp, TRUE, dwParam, FALSE);
    }

    //-----------------------------------------------------
    virtual BOOL
    InsertRecord(
        LICENSEPACK& kp,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&kp, FALSE, dwParam, FALSE);
    }

    //-------------------------------------------------------
    virtual BOOL
    UpdateRecord(
        LICENSEPACK& kp,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&kp, FALSE, dwParam, TRUE);
    }

    //-------------------------------------------------------
    virtual BOOL
    Initialize() 
    { 
        return TRUE; 
    }

    //-------------------------------------------------------
    virtual JBKeyBase*
    EnumerationIndex( 
        IN BOOL bMatchAll,
        IN DWORD dwParam,
        IN LICENSEPACK* kp,
        IN OUT BOOL* bCompareKey
    );
    
    virtual BOOL
    EqualValue(
        LICENSEPACK& s1,
        LICENSEPACK& s2,
        BOOL bMatchAll,
        DWORD dwParam
    );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tlsdb\licensed.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       licensed.h 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TLS_LICENSED_H__
#define __TLS_LICENSED_H__

#include "JetBlue.h"
#include "TlsDb.h"

//
// Not exported - not defined in tlsdef.h
//
#define LICENSE_COLUMN_SEARCH_SYSTEMBOIS     0x00200000
#define LICENSE_COLUMN_SEARCH_VIDEOBIOS      0x00400000
#define LICENSE_COLUMN_SEARCH_FLOPPYBIOS     0x00800000
#define LICENSE_COLUMN_SEARCH_HARDDISKSIZE   0x01000000
#define LICENSE_COLUMN_SEARCH_RAMSIZE        0x02000000
#define LICENSE_COLUMN_SEARCH_HWID \
    (LICENSE_COLUMN_SEARCH_SYSTEMBOIS | LICENSE_COLUMN_SEARCH_VIDEOBIOS | \
     LICENSE_COLUMN_SEARCH_FLOPPYBIOS | LICENSE_COLUMN_SEARCH_HARDDISKSIZE | \
     LICENSE_COLUMN_SEARCH_RAMSIZE)

#define LICENSE_PROCESS_LICENSEID           LSLICENSE_SEARCH_LICENSEID
#define LICENSE_PROCESS_KEYPACKID           LSLICENSE_SEARCH_KEYPACKID          
#define LICENSE_PROCESS_MACHINENAME         LSLICENSE_SEARCH_MACHINENAME
#define LICENSE_PROCESS_USERNAME            LSLICENSE_SEARCH_USERNAME
#define LICENSE_PROCESS_ISSUEDATE           LSLICENSE_SEARCH_ISSUEDATE
#define LICENSE_PROCESS_EXPIREDATE          LSLICENSE_SEARCH_EXPIREDATE
#define LICENSE_PROCESS_NUMLICENSES         LSLICENSE_SEARCH_NUMLICENSES
#define LICENSE_PROCESS_LICENSESTATUS       LSLICENSE_EXSEARCH_LICENSESTATUS
#define LICENSE_PROCESS_SYSTEMBIOS          LICENSE_COLUMN_SEARCH_SYSTEMBOIS
#define LICENSE_PROCESS_VIDEOBIOS           LICENSE_COLUMN_SEARCH_VIDEOBIOS
#define LICENSE_PROCESS_FLOPPYBIOS          LICENSE_COLUMN_SEARCH_FLOPPYBIOS
#define LICENSE_PROCESS_HARDDISKSIZE        LICENSE_COLUMN_SEARCH_HARDDISKSIZE
#define LICENSE_PROCESS_RAMSIZE             LICENSE_COLUMN_SEARCH_RAMSIZE
#define LICENSE_PROCESS_MATCHHWID           0x04000000
#define LICENSE_PROCESS_HWID                LICENSE_COLUMN_SEARCH_HWID
#define LICENSE_PROCESS_LASTMODIFYTIME      0x08000000
#define LICENSE_PROCESS_KEYPACKLICENSEID    0x10000000
#define LICENSE_PROCESS_ENTRYSTATUS         LSLICENSE_SEARCH_ENTRY_STATUS

//
// Licensed table
//
#define LICENSE_TABLE_NAME                   _TEXT("IssuedLicense")
#define LICENSE_COLUMN_ID_COLUMN             _TEXT("InternalLicenseID")

#define LICENSE_COLUMN_KEYPACKID             _TEXT("InternalKeyPackId")
#define LICENSE_COLUMN_LICENSEID             _TEXT("KeyPackLicenseId")

#define LICENSE_COLUMN_LASTMODIFYTIME        _TEXT("LastModifyTime")

#define LICENSE_COLUMN_SYSTEMBIOS            _TEXT("SystemBIOS")
#define LICENSE_COLUMN_VIDEOBIOS             _TEXT("VideoBIOS")
#define LICENSE_COLUMN_FLOPPYBIOS            _TEXT("FloppyBIOS")
#define LICENSE_COLUMN_HARDDISKSIZE          _TEXT("HarddiskSize")
#define LICENSE_COLUMN_RAMSIZE               _TEXT("RAMSize")
#define LICENSE_COLUMN_MATCHHWID             _TEXT("MatchHint1")

#define LICENSE_COLUMN_MACHINENAME           _TEXT("MachineName")
#define LICENSE_COLUMN_USERNAME              _TEXT("UserName")
#define LICENSE_COLUMN_NUMLICENSES           _TEXT("NumLicenses")
#define LICENSE_COLUMN_ISSUEDATE             _TEXT("IssueDate")
#define LICENSE_COLUMN_EXPIREDATE            _TEXT("ExpireDate")
#define LICENSE_COLUMN_LICENSESTATUS         _TEXT("LicenseStatus")
#define LICENSE_COLUMN_ENTRYSTATUS           _TEXT("EntryStatus")

typedef TLSReplLicenseClient LICENSEDCLIENT;
typedef TLSReplLicenseClient* PLICENSEDCLIENT;
typedef TLSReplLicenseClient* LPLICENSEDCLIENT;

////////////////////////////////////////////////////////////
//
// Index structure for IssuedLicense table
//
////////////////////////////////////////////////////////////

// --------------------------------------------------------
//  Primary index on License ID - internal tracking number
// --------------------------------------------------------

//
// IssuedLicense_LicenseId_idx
//
#define LICENSE_ID_INDEXNAME \
    LICENSE_TABLE_NAME SEPERATOR LICENSE_COLUMN_ID_COLUMN SEPERATOR INDEXNAME

//
// Index key on license ID column - "+LicenseID"
//
#define LICENSE_ID_INDEXNAME_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSE_COLUMN_ID_COLUMN INDEX_END_COLNAME

typedef struct __LicensedIndexOnLicenseId : public JBKeyBase {
    DWORD dwLicenseId;

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //--------------------------------------------------------
    __LicensedIndexOnLicenseId(
        const LICENSEDCLIENT& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //-------------------------------------------------------
    __LicensedIndexOnLicenseId(
        const LICENSEDCLIENT* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //-------------------------------------------------------
    __LicensedIndexOnLicenseId&
    operator=(const LICENSEDCLIENT& v) {
        dwLicenseId = v.dwLicenseId;

        SetEmptyValue(FALSE);
        return *this;
    }

    //--------------------------------------------------------
    inline LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    inline LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    DWORD
    GetNumKeyComponents() { return 1; }

    inline BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*
    */
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(dwLicenseId);
        *cbData = sizeof(dwLicenseId);
        *grbit = JET_bitNewKey;
        return TRUE;
    }

} TLSLicensedIndexLicenseId;



// ----------------------------------------------------------
//  Index on Issued License Pack Id (internal tracking number)
// ----------------------------------------------------------

//
// IssuedLicense_KeyPackId_idx
//
#define LICENSE_KEYPACKID_INDEXNAME \
    LICENSE_TABLE_NAME SEPERATOR LICENSE_COLUMN_KEYPACKID SEPERATOR INDEXNAME

//
// Index key on License KeyPack ID - "+KeyPackId"
//
#define LICENSE_KEYPACKID_INDEXNAME_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSE_COLUMN_KEYPACKID INDEX_END_COLNAME   

typedef struct __LicensedIndexOnKeyPackId : public JBKeyBase{
    DWORD dwKeyPackId;

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //----------------------------------------------
    __LicensedIndexOnKeyPackId(
        const LICENSEDCLIENT& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //----------------------------------------------
    __LicensedIndexOnKeyPackId(
        const LICENSEDCLIENT* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    __LicensedIndexOnKeyPackId&
    operator=(const LICENSEDCLIENT& v) {
        dwKeyPackId = v.dwKeyPackId;

        SetEmptyValue(FALSE);
        return *this;
    }

    //----------------------------------------------
    inline LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    inline LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    DWORD
    GetNumKeyComponents() { return 1; }

    inline BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*
    */
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(dwKeyPackId);
        *cbData = sizeof(dwKeyPackId);
        *grbit = JET_bitNewKey;
        return TRUE;
    }

} TLSLicensedIndexKeyPackId;


// ----------------------------------------------------------
//  Index on LastModifyTime
// ----------------------------------------------------------

//
// IssuedLicense_LastModifyTime_idx
//
#define LICENSE_LASTMODIFY_INDEXNAME \
    LICENSE_TABLE_NAME SEPERATOR LICENSE_COLUMN_LASTMODIFYTIME SEPERATOR INDEXNAME

//
// Index key - "+LastModifyTime"
//
#define LICENSE_LASTMODIFY_INDEXNAME_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSE_COLUMN_LASTMODIFYTIME INDEX_END_COLNAME   

typedef struct __LicensedIndexOnLastModifyTime : public JBKeyBase {
    FILETIME ftLastModifyTime;

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //----------------------------------------------
    __LicensedIndexOnLastModifyTime(
        const LICENSEDCLIENT& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //----------------------------------------------
    __LicensedIndexOnLastModifyTime(
        const LICENSEDCLIENT* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    __LicensedIndexOnLastModifyTime&
    operator=(const LICENSEDCLIENT& v) {
        ftLastModifyTime = v.ftLastModifyTime;

        SetEmptyValue(FALSE);
        return *this;
    }

    //----------------------------------------------
    inline LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    inline LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    DWORD
    GetNumKeyComponents() { return 1; }

    inline BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*
    */
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(ftLastModifyTime);
        *cbData = sizeof(ftLastModifyTime);
        *grbit = JET_bitNewKey;
        return TRUE;
    }

} TLSLicensedIndexLastModifyTime;


// ----------------------------------------------------------
//  Index on ExpireDate
// ----------------------------------------------------------

//
// IssuedLicense_ExpireDate_idx
//
#define LICENSE_EXPIREDATE_INDEXNAME \
    LICENSE_TABLE_NAME SEPERATOR LICENSE_COLUMN_EXPIREDATE SEPERATOR INDEXNAME

//
// Index key - "+ExpireDate"
//
#define LICENSE_EXPIREDATE_INDEXNAME_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSE_COLUMN_EXPIREDATE INDEX_END_COLNAME   

typedef struct __LicensedIndexOnExpireDate : public JBKeyBase {
    DWORD ftExpireDate;

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //----------------------------------------------
    __LicensedIndexOnExpireDate(
        const LICENSEDCLIENT& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //----------------------------------------------
    __LicensedIndexOnExpireDate(
        const LICENSEDCLIENT* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    __LicensedIndexOnExpireDate&
    operator=(const LICENSEDCLIENT& v) {
        ftExpireDate = v.ftExpireDate;

        SetEmptyValue(FALSE);
        return *this;
    }

    //----------------------------------------------
    inline LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    inline LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    DWORD
    GetNumKeyComponents() { return 1; }

    inline BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*
    */
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(ftExpireDate);
        *cbData = sizeof(ftExpireDate);
        *grbit = JET_bitNewKey;
        return TRUE;
    }

} TLSLicensedIndexExpireDate;


//-------------------------------------------------------------
// Index on client machine name
//-------------------------------------------------------------
//
// IssuedLicense_MachineName_idx
//
#define LICENSE_CLIENT_MACHINENAME_INDEXNAME \
    LICENSE_TABLE_NAME SEPERATOR LICENSE_COLUMN_MACHINENAME SEPERATOR INDEXNAME

//
// "+MachineName\0"
#define LICENSE_CLIENT_MACHINENAME_INDEXNAME_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSE_COLUMN_MACHINENAME INDEX_END_COLNAME

typedef struct __LicensedIndexOnMachineName : public JBKeyBase {
    TCHAR szMachineName[ MAXCOMPUTERNAMELENGTH+1 ];

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //-------------------------------------------------------
    __LicensedIndexOnMachineName(
        const LICENSEDCLIENT* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //-------------------------------------------------------
    __LicensedIndexOnMachineName(
        const LICENSEDCLIENT& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //-------------------------------------------------------
    __LicensedIndexOnMachineName&
    operator=(const LICENSEDCLIENT& v) {
        _tcscpy(szMachineName, v.szMachineName);

        SetEmptyValue(FALSE);
        return *this;
    }

    //------------------------------------------
    inline LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    inline LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    DWORD
    GetNumKeyComponents() { return 1; }

    inline BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*
    */
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(szMachineName[0]);
        *cbData = _tcslen(szMachineName) * sizeof(TCHAR);
        *grbit = JET_bitNewKey;
        return TRUE;
    }

} TLSLicensedIndexMachineName;


//-------------------------------------------------------------
// Index on client UserName  name
//-------------------------------------------------------------
//
// IssuedLicense_UserName_idx
//
#define LICENSE_CLIENT_USERNAME_INDEXNAME \
    LICENSE_TABLE_NAME SEPERATOR LICENSE_COLUMN_USERNAME SEPERATOR INDEXNAME

//
// "+UserName\0"
#define LICENSE_CLIENT_USERNAME_INDEXNAME_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSE_COLUMN_USERNAME INDEX_END_COLNAME

typedef struct __LicensedIndexOnUserName : public JBKeyBase {
    TCHAR szUserName[ MAXUSERNAMELENGTH+1 ];

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //-------------------------------------------------------
    __LicensedIndexOnUserName(const LICENSEDCLIENT& v) : JBKeyBase() {
        *this = v;
    }

    //-------------------------------------------------------
    __LicensedIndexOnUserName(
        const LICENSEDCLIENT* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = *v;
    }

    //-------------------------------------------------------
    __LicensedIndexOnUserName&
    operator=(const LICENSEDCLIENT& v) {
        _tcscpy(szUserName, v.szUserName);
        SetEmptyValue(FALSE);
        return *this;
    }

    inline LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    inline LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    DWORD
    GetNumKeyComponents() { return 1; }

    inline BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*
    */
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(szUserName[0]);
        *cbData = _tcslen(szUserName) * sizeof(TCHAR);
        *grbit = JET_bitNewKey;
        return TRUE;
    }

} TLSLicensedIndexUserName;

  
//-------------------------------------------------------------
//  Index on client's HWID
//-------------------------------------------------------------
        
//
// IssuedLicense_Hwid_idx 
//
#define LICENSE_CLIENT_HWID_INDEXNAME \
    LICENSE_TABLE_NAME SEPERATOR _TEXT("ClientHwid") SEPERATOR INDEXNAME

//
// Index Key on Client Hwid - "+SystemBIOS\0+VideoBIOS\0+FloppyBIOS\0+HarddiskSize\0+RAMSize\0"
//
#define LICENSE_CLIENT_HWID_INDEXNAME_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSE_COLUMN_SYSTEMBIOS INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSE_COLUMN_VIDEOBIOS INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSE_COLUMN_FLOPPYBIOS INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSE_COLUMN_HARDDISKSIZE INDEX_END_COLNAME \
    INDEX_SORT_ASCENDING LICENSE_COLUMN_RAMSIZE INDEX_END_COLNAME

#define LICENSE_CLIENT_HWID_INDEXNAME_INDEXKEY_COMPONENTS 5

typedef struct __LicensedIndexOnHwid : public JBKeyBase {
    //
    // Need to change LICENSE_CLIENT_HWID_INDEXNAME_INDEXKEY_COMPONENTS
    // if add/remove from this structure
    //
    LONG   dwSystemBiosChkSum;
    LONG   dwVideoBiosChkSum;
    LONG   dwFloppyBiosChkSum;
    LONG   dwHardDiskSize;
    LONG   dwRamSize;

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    //------------------------------------------------
    __LicensedIndexOnHwid(
        const LICENSEDCLIENT* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //------------------------------------------------
    __LicensedIndexOnHwid(
        const LICENSEDCLIENT& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }
    
    //------------------------------------------------
    __LicensedIndexOnHwid&
    operator=(const LICENSEDCLIENT hwid) {
        dwSystemBiosChkSum = hwid.dwSystemBiosChkSum;
        dwVideoBiosChkSum = hwid.dwVideoBiosChkSum;
        dwFloppyBiosChkSum = hwid.dwFloppyBiosChkSum;
        dwHardDiskSize = hwid.dwHardDiskSize;
        dwRamSize = hwid.dwRamSize;

        SetEmptyValue(FALSE);
        return *this;
    }

    //------------------------------------------------
    inline LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    inline LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    DWORD
    GetNumKeyComponents() { 
        return LICENSE_CLIENT_HWID_INDEXNAME_INDEXKEY_COMPONENTS; 
    }

    inline BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParam
        )
    /*
    */
    {
        BOOL retCode=TRUE;

        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *cbData = 0;
        *grbit = 0;

        switch(dwComponentIndex)
        {
            case 0:
                *pbData = &(dwSystemBiosChkSum);
                *cbData = sizeof(dwSystemBiosChkSum);
                *grbit = JET_bitNewKey;
                break;

            case 1:
                *pbData = &(dwVideoBiosChkSum);
                *cbData = sizeof(dwVideoBiosChkSum);
                break;

            case 2:
                *pbData = &(dwFloppyBiosChkSum);
                *cbData = sizeof(dwFloppyBiosChkSum);
                break;

            case 3:
                *pbData = &(dwHardDiskSize);
                *cbData = sizeof(dwHardDiskSize);
                break;

            case 4:
                *pbData = &(dwRamSize);
                *cbData = sizeof(dwRamSize);
                break;
        
            default:
                JB_ASSERT(FALSE);
                retCode = FALSE;
        }

        return retCode;
    }            

} TLSLicensedIndexHwid;

    
//------------------------------------------------------
// Index for matching client HWID
//------------------------------------------------------
        
//
// IssuedLicense_MatchHwid_idx
//
#define LICENSE_MATCHHWID_INDEXNAME \
    LICENSE_TABLE_NAME SEPERATOR _TEXT("MatchHwid") SEPERATOR INDEXNAME

//
// Index key on search hint column "+MatchHint1\0"
//
#define LICENSE_MATCHHWID_INDEXNAME_INDEXKEY \
    INDEX_SORT_ASCENDING LICENSE_COLUMN_MATCHHWID INDEX_END_COLNAME

typedef struct __LicensedIndexOnMatchHwid : public JBKeyBase {
    double dbLowerBound;

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;

    static int __cdecl compare(const void *p1, const void* p2) {
        return *(DWORD *)p1 - *(DWORD *)p2;
    }

    //------------------------------------------------
    __LicensedIndexOnMatchHwid(
        const LICENSEDCLIENT* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //------------------------------------------------
    __LicensedIndexOnMatchHwid(
        const LICENSEDCLIENT& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //------------------------------------------------
    __LicensedIndexOnMatchHwid&
    operator=(const LICENSEDCLIENT& v) {
        //
        // Allow to mismatch, so lower bound of matching hint is 
        // Sum of all HWID minus two lagest value
        //
        LONG ptr[] = { 
            v.dwSystemBiosChkSum,
            v.dwVideoBiosChkSum,
            v.dwFloppyBiosChkSum,
            v.dwHardDiskSize,
            v.dwRamSize   
        };

        int count=sizeof(ptr) / sizeof(ptr[0]);
        qsort(ptr, count, sizeof(DWORD), __LicensedIndexOnMatchHwid::compare);

        dbLowerBound = (double) 0.0;

        for(int i=0; i < count - 2; i++)
        {
            dbLowerBound += (double)ptr[i];
        }

        SetEmptyValue(FALSE);
        return *this;
    }

    inline LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    inline LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    DWORD
    GetNumKeyComponents() { 
        return 1;
    }

    inline BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*
    */
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(dbLowerBound);
        *cbData = sizeof(dbLowerBound);
        *grbit = JET_bitNewKey;
        return TRUE;
    }

} TLSLicensedIndexMatchHwid;

    
//------------------------------------------------------------------------
class LicensedTable : public TLSTable<LICENSEDCLIENT> {
private:

    static LPCTSTR pszTableName;

    BOOL
    ProcessSingleColumn(
        BOOL bFetch,
        TLSColumnBase& column,
        DWORD offset,
        PVOID pbData,
        DWORD cbData,
        PDWORD pcbDataReturn,
        LPCTSTR szColumnName
    );

    BOOL
    ProcessRecord(
        LICENSEDCLIENT* v,
        BOOL bFetch,        // TRUE - fetch, FALSE insert
        DWORD dwParam,
        BOOL bUpdate
    );

public:
    TLSColumnUchar     ucEntryStatus;
    TLSColumnFileTime  ftLastModifyTime;

    TLSColumnDword  dwLicenseId;
    TLSColumnDword  dwKeyPackId;
    TLSColumnDword  dwKeyPackLicenseId;

    TLSColumnText   szMachineName;  
    TLSColumnText   szUserName;
    TLSColumnDword  ftIssueDate;
    TLSColumnDword  ftExpireDate;
    TLSColumnUchar  ucLicenseStatus;
    TLSColumnDword  dwNumLicenses;

    TLSColumnDword  dwSystemBiosChkSum;
    TLSColumnDword  dwVideoBiosChkSum;
    TLSColumnDword  dwFloppyBiosChkSum;
    TLSColumnDword  dwHardDiskSize;
    TLSColumnDword  dwRamSize;

    TLSColumnDouble dbLowerBound;

    //---------------------------------------------------------
    virtual LPCTSTR
    GetTableName() 
    {
        return pszTableName;
    }

    //-----------------------------------------------------
    LicensedTable(
        JBDatabase& database
        ) : TLSTable<LICENSEDCLIENT>(database) 
    /*
    */
    {
    }

    //-----------------------------------------------------
    virtual BOOL
    ResolveToTableColumn();

    //-----------------------------------------------------
    virtual BOOL
    FetchRecord(
        LICENSEDCLIENT& licensed,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&licensed, TRUE, dwParam, FALSE);
    }

    //-----------------------------------------------------
    virtual BOOL
    InsertRecord(
        LICENSEDCLIENT& licensed,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&licensed, FALSE, dwParam, FALSE);
    }

    //-------------------------------------------------------
    virtual BOOL
    UpdateRecord(
        LICENSEDCLIENT& licensed,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&licensed, FALSE, dwParam, TRUE);
    }

    //-------------------------------------------------------
    virtual BOOL
    Initialize() { return TRUE; }

    //-------------------------------------------------------
    virtual JBKeyBase*
    EnumerationIndex( 
        BOOL bMatchAll,
        DWORD dwParam,
        LICENSEDCLIENT* pLicensed,
        BOOL* bCompareKey
    );

    virtual BOOL
    EqualValue(
        LICENSEDCLIENT& s1,
        LICENSEDCLIENT& s2,
        BOOL bMatchAll,
        DWORD dwParam
    );

    virtual BOOL
    UpgradeTable(
        IN DWORD dwOldVersion,
        IN DWORD dwNewVersion
    );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tlsdb\misc.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       misc.cpp 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include "tlsdb.h"

//-----------------------------------------------------------
BOOL
TLSDBCopySid(
    PSID pbSrcSid,
    DWORD cbSrcSid, 
    PSID* pbDestSid, 
    DWORD* cbDestSid
    )
/*++

++*/
{
    if( *pbDestSid == NULL || pbSrcSid == NULL ||
        LocalSize(*pbDestSid) < cbSrcSid )
    {
        if(*pbDestSid != NULL)
        {
            FreeMemory(*pbDestSid);
            *pbDestSid = NULL;
        }

        if(cbSrcSid && pbSrcSid)
        {
            *pbDestSid = (PBYTE)AllocateMemory(cbSrcSid);
            if(*pbDestSid == NULL)
            {
                return FALSE;
            }
        }
    }        

    *cbDestSid = cbSrcSid;
    return (cbSrcSid) ? CopySid(*cbDestSid, *pbDestSid, pbSrcSid) : TRUE;
}

//-----------------------------------------------------------
BOOL
TLSDBCopyBinaryData(
    PBYTE pbSrcData,
    DWORD cbSrcData, 
    PBYTE* ppbDestData, 
    DWORD* pcbDestData
    )
/*++

++*/
{

    if( ppbDestData == NULL || pcbDestData == NULL )
    {
        return(FALSE);
    }

    if( pbSrcData == NULL || cbSrcData == 0 )
    {
        return(TRUE);
    }

    //
    // would be nice to get the actual size of memory allocated
    //

    if( *ppbDestData != NULL && LocalSize(*ppbDestData) < cbSrcData )
    {
        LocalFree(*ppbDestData);
        *ppbDestData = NULL;
    }

    if( *ppbDestData == NULL )
    {
        *ppbDestData = (PBYTE)AllocateMemory(cbSrcData);
        if( *ppbDestData == NULL )
        {
            return FALSE;
        }
    }

    *pcbDestData = cbSrcData;

    memcpy(*ppbDestData, pbSrcData, cbSrcData);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tlsdb\lictab.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       lictab.cpp 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include "Licensed.h"


LPCTSTR __LicensedIndexOnLicenseId::pszIndexName = LICENSE_ID_INDEXNAME;
LPCTSTR __LicensedIndexOnLicenseId::pszIndexKey = LICENSE_ID_INDEXNAME_INDEXKEY;

LPCTSTR __LicensedIndexOnKeyPackId::pszIndexName = LICENSE_KEYPACKID_INDEXNAME;
LPCTSTR __LicensedIndexOnKeyPackId::pszIndexKey = LICENSE_KEYPACKID_INDEXNAME_INDEXKEY;

LPCTSTR __LicensedIndexOnLastModifyTime::pszIndexName = LICENSE_KEYPACKID_INDEXNAME;
LPCTSTR __LicensedIndexOnLastModifyTime::pszIndexKey = LICENSE_KEYPACKID_INDEXNAME_INDEXKEY;

LPCTSTR __LicensedIndexOnMachineName::pszIndexName = LICENSE_CLIENT_MACHINENAME_INDEXNAME;
LPCTSTR __LicensedIndexOnMachineName::pszIndexKey = LICENSE_CLIENT_MACHINENAME_INDEXNAME_INDEXKEY;

LPCTSTR __LicensedIndexOnUserName::pszIndexName = LICENSE_CLIENT_USERNAME_INDEXNAME;
LPCTSTR __LicensedIndexOnUserName::pszIndexKey = LICENSE_CLIENT_USERNAME_INDEXNAME_INDEXKEY;

LPCTSTR __LicensedIndexOnHwid::pszIndexName = LICENSE_CLIENT_HWID_INDEXNAME;
LPCTSTR __LicensedIndexOnHwid::pszIndexKey = LICENSE_CLIENT_HWID_INDEXNAME_INDEXKEY;

LPCTSTR __LicensedIndexOnMatchHwid::pszIndexName = LICENSE_MATCHHWID_INDEXNAME;
LPCTSTR __LicensedIndexOnMatchHwid::pszIndexKey = LICENSE_MATCHHWID_INDEXNAME_INDEXKEY;

LPCTSTR __LicensedIndexOnExpireDate::pszIndexName = LICENSE_EXPIREDATE_INDEXNAME;
LPCTSTR __LicensedIndexOnExpireDate::pszIndexKey = LICENSE_EXPIREDATE_INDEXNAME_INDEXKEY;

CCriticalSection LicensedTable::g_TableLock;
LPCTSTR LicensedTable::pszTableName = LICENSE_TABLE_NAME;

//-------------------------------------------------------------------

TLSJBIndex
LicensedTable::g_TableIndex[] = 
{
    // Index on license ID.
    {
        LICENSE_ID_INDEXNAME,
        LICENSE_ID_INDEXNAME_INDEXKEY,
        -1,
        JET_bitIndexPrimary,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },

    //
    // Index on licensed keypack id.
    {
        LICENSE_KEYPACKID_INDEXNAME,
        LICENSE_KEYPACKID_INDEXNAME_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },

    // index on last modify time.
    {
        LICENSE_LASTMODIFY_INDEXNAME,
        LICENSE_LASTMODIFY_INDEXNAME_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },

    // Index on machine name
    {
        LICENSE_CLIENT_MACHINENAME_INDEXNAME,
        LICENSE_CLIENT_MACHINENAME_INDEXNAME_INDEXKEY,
        -1,
        0,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },

    // index on user name
    {
        LICENSE_CLIENT_USERNAME_INDEXNAME,
        LICENSE_CLIENT_USERNAME_INDEXNAME_INDEXKEY,
        -1,
        0,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },

    // index on client machine's hardware id
    {
        LICENSE_CLIENT_HWID_INDEXNAME,
        LICENSE_CLIENT_HWID_INDEXNAME_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },

    // index on client hardware id matching hint
    {
        LICENSE_MATCHHWID_INDEXNAME,
        LICENSE_MATCHHWID_INDEXNAME_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },

    // index on license expiration date
    {
        LICENSE_EXPIREDATE_INDEXNAME,
        LICENSE_EXPIREDATE_INDEXNAME_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },
};

int
LicensedTable::g_NumTableIndex = sizeof(LicensedTable::g_TableIndex) / sizeof(LicensedTable::g_TableIndex[0]);

TLSJBColumn
LicensedTable::g_Columns[] = 
{
    //
    // Entry status
    {
        LICENSE_COLUMN_ENTRYSTATUS,
        JET_coltypUnsignedByte,
        0,
        JET_bitColumnFixed,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // Licensed ID
    {
        LICENSE_COLUMN_ID_COLUMN,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    //  KeyPackId
    {
        LICENSE_COLUMN_KEYPACKID,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //  
    // KeyPackLicenseId
    {
        LICENSE_COLUMN_LICENSEID,
        JET_coltypLong,
        0,
        JET_bitColumnFixed,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // Last modify time
    {
        LICENSE_COLUMN_LASTMODIFYTIME,
        JET_coltypBinary,
        sizeof(FILETIME),
        JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },
        
    //
    // SystemBios
    {
        LICENSE_COLUMN_SYSTEMBIOS,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // Video Bios
    {
        LICENSE_COLUMN_VIDEOBIOS,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },
        
    //
    // Floppy Bios
    {
        LICENSE_COLUMN_FLOPPYBIOS,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // Harddisk size
    {
        LICENSE_COLUMN_HARDDISKSIZE,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // RAM size
    {
        LICENSE_COLUMN_RAMSIZE,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // Match HWID 
    {
        LICENSE_COLUMN_MATCHHWID,
        JET_coltypIEEEDouble,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // Machine name
    {
        LICENSE_COLUMN_MACHINENAME,
        //JET_coltypLongText,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        JBSTRING_NULL,
        _tcslen(JBSTRING_NULL),
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // User Name
    {
        LICENSE_COLUMN_USERNAME,
        //JET_coltypLongText,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        JBSTRING_NULL,
        _tcslen(JBSTRING_NULL),
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // Number of licenses for this client
    {
        LICENSE_COLUMN_NUMLICENSES,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // IssuedDate
    {
        LICENSE_COLUMN_ISSUEDATE,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // ExpireDate
    {
        LICENSE_COLUMN_EXPIREDATE,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // License Status
    {
        LICENSE_COLUMN_LICENSESTATUS,
        JET_coltypUnsignedByte,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    }
};

int
LicensedTable::g_NumColumns=sizeof(LicensedTable::g_Columns) / sizeof(LicensedTable::g_Columns[0]);

///////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------
BOOL
LicensedTable::ResolveToTableColumn()
/*
*/
{
    m_JetErr = ucEntryStatus.AttachToTable(
                            *this,
                            LICENSE_COLUMN_ENTRYSTATUS
                        );
    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwKeyPackLicenseId.AttachToTable(
                            *this,
                            LICENSE_COLUMN_LICENSEID
                        );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = ftLastModifyTime.AttachToTable(
                        *this,
                        LICENSE_COLUMN_LASTMODIFYTIME
                    );
    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwLicenseId.AttachToTable(
                        *this,
                        LICENSE_COLUMN_ID_COLUMN
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;
    
    m_JetErr = dwKeyPackId.AttachToTable(
                        *this,
                        LICENSE_COLUMN_KEYPACKID
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = szMachineName.AttachToTable(
                        *this,
                        LICENSE_COLUMN_MACHINENAME
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = szUserName.AttachToTable(
                        *this,
                        LICENSE_COLUMN_USERNAME
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = ftIssueDate.AttachToTable(
                        *this,
                        LICENSE_COLUMN_ISSUEDATE
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = ftExpireDate.AttachToTable(
                        *this,
                        LICENSE_COLUMN_EXPIREDATE
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = ucLicenseStatus.AttachToTable(
                        *this,
                        LICENSE_COLUMN_LICENSESTATUS
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwNumLicenses.AttachToTable(
                        *this,
                        LICENSE_COLUMN_NUMLICENSES
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwSystemBiosChkSum.AttachToTable(
                        *this,
                        LICENSE_COLUMN_SYSTEMBIOS
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwVideoBiosChkSum.AttachToTable(
                        *this,
                        LICENSE_COLUMN_VIDEOBIOS
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwFloppyBiosChkSum.AttachToTable(
                        *this,
                        LICENSE_COLUMN_FLOPPYBIOS
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwHardDiskSize.AttachToTable(
                        *this,
                        LICENSE_COLUMN_HARDDISKSIZE
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwRamSize.AttachToTable(
                        *this,
                        LICENSE_COLUMN_RAMSIZE
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dbLowerBound.AttachToTable(
                        *this,
                        LICENSE_COLUMN_MATCHHWID
                    );
cleanup:

    return IsSuccess();
}

//------------------------------------------------------------
inline CLASS_PRIVATE BOOL
LicensedTable::ProcessSingleColumn(
    BOOL bFetch,
    TLSColumnBase& column,
    DWORD offset,
    PVOID pbData,
    DWORD cbData,
    PDWORD pcbDataReturn,
    LPCTSTR szColumnName
    )
/*
*/
{
    if(bFetch) 
    {
        m_JetErr = column.FetchColumnValue(
                                    pbData, 
                                    cbData, 
                                    offset, 
                                    pcbDataReturn
                                );
    }
    else
    {
        m_JetErr = column.InsertColumnValue(
                                    pbData, 
                                    cbData, 
                                    offset
                                );
    }

    REPORTPROCESSFAILED(
            bFetch,
            GetTableName(),
            szColumnName,
            m_JetErr
        );
    return IsSuccess();
}

//------------------------------------------------------------
    
CLASS_PRIVATE BOOL
LicensedTable::ProcessRecord(
    LICENSEDCLIENT* licensed,
    BOOL bFetch,
    DWORD dwParam,
    BOOL bUpdate
    )
/*
*/
{
    DWORD dwSize;

    if(bFetch == FALSE)
    {
        BeginUpdate(bUpdate);

        // any update will require update on lastmodifytime column
        if(!(dwParam & LICENSE_PROCESS_LASTMODIFYTIME))
        {
            JB_ASSERT(FALSE);
            dwParam |= LICENSE_PROCESS_LASTMODIFYTIME;
        }
    }
    else
    {
        SetLastJetError(JET_errSuccess);
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    if(dwParam & LICENSE_PROCESS_KEYPACKLICENSEID)
    {
        ProcessSingleColumn(
                    bFetch, 
                    dwKeyPackLicenseId, 
                    0,
                    &(licensed->dwKeyPackLicenseId),
                    sizeof(licensed->dwKeyPackLicenseId),
                    &dwSize,
                    LICENSE_COLUMN_LICENSEID
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;


    if(dwParam & LICENSE_PROCESS_LASTMODIFYTIME)
    {
        ProcessSingleColumn(
                    bFetch, 
                    ftLastModifyTime, 
                    0,
                    &(licensed->ftLastModifyTime),
                    sizeof(licensed->ftLastModifyTime),
                    &dwSize,
                    LICENSE_COLUMN_LASTMODIFYTIME
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;


    if(dwParam & LICENSE_PROCESS_LICENSEID)
    {
        // primary index, can't change
        if(bUpdate == FALSE)
        {
            ProcessSingleColumn(
                    bFetch, 
                    dwLicenseId, 
                    0,
                    &(licensed->dwLicenseId),
                    sizeof(licensed->dwLicenseId),
                    &dwSize,
                    LICENSE_COLUMN_ID_COLUMN
                );
        }
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    if(dwParam & LICENSE_PROCESS_KEYPACKID)
    {
        ProcessSingleColumn(
                    bFetch, 
                    dwKeyPackId, 
                    0,
                    &(licensed->dwKeyPackId),
                    sizeof(licensed->dwKeyPackId),
                    &dwSize,
                    LICENSE_COLUMN_KEYPACKID
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSE_PROCESS_MACHINENAME)
    {
        ProcessSingleColumn(
                    bFetch, 
                    szMachineName, 
                    0,
                    licensed->szMachineName,
                    sizeof(licensed->szMachineName),
                    &dwSize,
                    LICENSE_COLUMN_MACHINENAME
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSE_PROCESS_USERNAME)
    {
        ProcessSingleColumn(
                    bFetch, 
                    szUserName, 
                    0,
                    licensed->szUserName,
                    sizeof(licensed->szUserName),
                    &dwSize,
                    LICENSE_COLUMN_USERNAME
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;


    if(dwParam & LICENSE_PROCESS_ISSUEDATE)
    {
        ProcessSingleColumn(
                    bFetch, 
                    ftIssueDate, 
                    0,
                    &(licensed->ftIssueDate),
                    sizeof(licensed->ftIssueDate),
                    &dwSize,
                    LICENSE_COLUMN_ISSUEDATE
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSE_PROCESS_EXPIREDATE)
    {
        ProcessSingleColumn(
                    bFetch, 
                    ftExpireDate, 
                    0,
                    &(licensed->ftExpireDate),
                    sizeof(licensed->ftExpireDate),
                    &dwSize,
                    LICENSE_COLUMN_EXPIREDATE
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSE_PROCESS_NUMLICENSES)
    {
        ProcessSingleColumn(
                    bFetch, 
                    dwNumLicenses, 
                    0,
                    &(licensed->dwNumLicenses),
                    sizeof(licensed->dwNumLicenses),
                    &dwSize,
                    LICENSE_COLUMN_NUMLICENSES
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSE_PROCESS_LICENSESTATUS)
    {
        ProcessSingleColumn(
                    bFetch, 
                    ucLicenseStatus, 
                    0,
                    &(licensed->ucLicenseStatus),
                    sizeof(licensed->ucLicenseStatus),
                    &dwSize,
                    LICENSE_COLUMN_LICENSESTATUS
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;


    if(dwParam & LICENSE_PROCESS_SYSTEMBIOS)
    {
        ProcessSingleColumn(
                    bFetch, 
                    dwSystemBiosChkSum, 
                    0,
                    &(licensed->dwSystemBiosChkSum),
                    sizeof(licensed->dwSystemBiosChkSum),
                    &dwSize,
                    LICENSE_COLUMN_SYSTEMBIOS
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSE_PROCESS_VIDEOBIOS)
    {
        ProcessSingleColumn(
                    bFetch, 
                    dwVideoBiosChkSum, 
                    0,
                    &(licensed->dwVideoBiosChkSum),
                    sizeof(licensed->dwVideoBiosChkSum),
                    &dwSize,
                    LICENSE_COLUMN_VIDEOBIOS
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSE_PROCESS_FLOPPYBIOS)
    {
        ProcessSingleColumn(
                    bFetch, 
                    dwFloppyBiosChkSum, 
                    0,
                    &(licensed->dwFloppyBiosChkSum),
                    sizeof(licensed->dwFloppyBiosChkSum),
                    &dwSize,
                    LICENSE_COLUMN_FLOPPYBIOS
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSE_PROCESS_HARDDISKSIZE)
    {
        ProcessSingleColumn(
                    bFetch, 
                    dwHardDiskSize, 
                    0,
                    &(licensed->dwHardDiskSize),
                    sizeof(licensed->dwHardDiskSize),
                    &dwSize,
                    LICENSE_COLUMN_HARDDISKSIZE
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSE_PROCESS_RAMSIZE)
    {
        ProcessSingleColumn(
                    bFetch, 
                    dwRamSize, 
                    0,
                    &(licensed->dwRamSize),
                    sizeof(licensed->dwRamSize),
                    &dwSize,
                    LICENSE_COLUMN_RAMSIZE
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSE_PROCESS_ENTRYSTATUS)
    {
        ProcessSingleColumn(
                    bFetch, 
                    ucEntryStatus, 
                    0,
                    &(licensed->ucEntryStatus),
                    sizeof(licensed->ucEntryStatus),
                    &dwSize,
                    LICENSE_COLUMN_ENTRYSTATUS
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSE_PROCESS_MATCHHWID)
    {
        ProcessSingleColumn(
                    bFetch, 
                    dbLowerBound, 
                    0,
                    &(licensed->dbLowerBound),
                    sizeof(licensed->dbLowerBound),
                    &dwSize,
                    LICENSE_COLUMN_MATCHHWID
                );
    }

cleanup:

    // 
    // For inserting/updating record
    if(bFetch == FALSE)
    {
        JET_ERR jetErr;
        jetErr = GetLastJetError();

        EndUpdate(IsSuccess() == FALSE);

        if(jetErr != JET_errSuccess  && IsSuccess() == FALSE)
            SetLastJetError(jetErr);
    }

    return IsSuccess();
}


//-------------------------------------------------------
JBKeyBase*
LicensedTable::EnumerationIndex( 
    BOOL bMatchAll,
    DWORD dwParam,
    LICENSEDCLIENT* pLicensed,
    BOOL* bCompareKey
    )
/*
*/
{
    JBKeyBase* index=NULL;

    *bCompareKey = bMatchAll;

    if(dwParam == LICENSE_COLUMN_SEARCH_HWID)
    {
        if(bMatchAll)
        {
            index = new TLSLicensedIndexHwid(pLicensed); 
        }
        else
        {
            index = new TLSLicensedIndexMatchHwid(pLicensed);
        }
    }
    else if(dwParam & LICENSE_PROCESS_KEYPACKID)
    {
        index = new TLSLicensedIndexKeyPackId(pLicensed);
    }
    else if(dwParam & LICENSE_PROCESS_MACHINENAME)
    {
        index = new TLSLicensedIndexMachineName(pLicensed);
    }
    else if(dwParam & LICENSE_PROCESS_USERNAME)
    {
        index = new TLSLicensedIndexUserName(pLicensed);
    }
    else if(dwParam & LICENSE_PROCESS_LASTMODIFYTIME)
    {
        index = new TLSLicensedIndexLastModifyTime(pLicensed);
    }
    else if(dwParam & LICENSE_PROCESS_EXPIREDATE)
    {
        index = new TLSLicensedIndexExpireDate(pLicensed);
    }
    else
    {
        // use default primary index for iteration, compare key
        // is depends on whether primary index column is in the 
        // field.
        index = new TLSLicensedIndexLicenseId(pLicensed);

        *bCompareKey = (bMatchAll && (dwParam & LICENSE_PROCESS_LICENSEID));
    }   

    return index;
}

//-------------------------------------------------------
BOOL
LicensedTable::EqualValue(
    LICENSEDCLIENT& s1,
    LICENSEDCLIENT& s2,
    BOOL bMatchAll,
    DWORD dwParam
    )  
/*
*/
{
    BOOL bRetCode = TRUE;

    if(dwParam & LICENSE_PROCESS_ENTRYSTATUS)
    {
        bRetCode = (s1.ucEntryStatus == s2.ucEntryStatus);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSE_PROCESS_KEYPACKLICENSEID)
    {
        bRetCode = (s1.dwKeyPackLicenseId == s2.dwKeyPackLicenseId);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSE_PROCESS_LASTMODIFYTIME)
    {
        bRetCode = (CompareFileTime(&s1.ftLastModifyTime, &s2.ftLastModifyTime) == 0);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSE_PROCESS_LICENSEID)
    {
        bRetCode = (s1.dwLicenseId == s2.dwLicenseId);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }


    if(dwParam & LICENSE_PROCESS_KEYPACKID)
    {
        bRetCode = (s1.dwKeyPackId == s2.dwKeyPackId);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }


    if(dwParam & LICENSE_PROCESS_MACHINENAME)
    {
        bRetCode = (_tcscmp(s1.szMachineName, s2.szMachineName) == 0);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }


    if(dwParam & LICENSE_PROCESS_USERNAME)
    {
        bRetCode = (_tcscmp(s1.szUserName, s2.szUserName) == 0);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }


    if(dwParam & LICENSE_PROCESS_ISSUEDATE)
    {
        bRetCode = (s1.ftIssueDate == s2.ftIssueDate);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }


    if(dwParam & LICENSE_PROCESS_EXPIREDATE)
    {
        bRetCode = (s1.ftExpireDate == s2.ftExpireDate);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }


    if(dwParam & LICENSE_PROCESS_NUMLICENSES)
    {
        bRetCode = (s1.dwNumLicenses == s2.dwNumLicenses);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }


    if(dwParam & LICENSE_PROCESS_LICENSESTATUS)
    {
        bRetCode = (s1.ucLicenseStatus == s2.ucLicenseStatus);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }


    if(dwParam & LICENSE_PROCESS_SYSTEMBIOS)
    {
        bRetCode = (s1.dwSystemBiosChkSum == s2.dwSystemBiosChkSum);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSE_PROCESS_VIDEOBIOS)
    {
        bRetCode = (s1.dwVideoBiosChkSum == s2.dwVideoBiosChkSum);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }


    if(dwParam & LICENSE_PROCESS_FLOPPYBIOS)
    {
        bRetCode = (s1.dwFloppyBiosChkSum == s2.dwFloppyBiosChkSum);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }


    if(dwParam & LICENSE_PROCESS_HARDDISKSIZE)
    {
        bRetCode = (s1.dwHardDiskSize == s2.dwHardDiskSize);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSE_PROCESS_RAMSIZE)
    {
        bRetCode = (s1.dwRamSize == s2.dwRamSize);
    }

    if(dwParam & LICENSE_PROCESS_MATCHHWID)
    {
        bRetCode = (s1.dbLowerBound == s2.dbLowerBound);
    }

cleanup:

    return bRetCode;
}

//--------------------------------------------------------
BOOL
LicensedTable::UpgradeTable(
        IN DWORD dwOldVersion,
        IN DWORD dwNewVersion
        )
/*++
 
++*/
{
    int nExpDate = g_NumTableIndex-1;
    unsigned long keylength;
    BOOL fRet = TRUE;

    if(dwOldVersion > dwNewVersion)
    {
        // We don't know how to handle later versions
        JB_ASSERT(FALSE);
        return FALSE;
    }

    if(OpenTable(TRUE, JET_bitTableUpdatable) == FALSE)
        return FALSE;

    //
    // check if expiration date index exists
    //

    if (DoesIndexExist(g_TableIndex[nExpDate].pszIndexName))
    {
        goto cleanup;
    }

    //
    // Insert new index for expiration date
    //

    if (g_TableIndex[nExpDate].cbKey == -1)
    {
        // calculate index key length
        keylength = 2;
        
        while(g_TableIndex[nExpDate].pszIndexKey[keylength-1] != _TEXT('\0') ||
              (g_TableIndex[nExpDate].pszIndexKey[keylength-2] != _TEXT('\0')))
        {
            keylength++;
        }

        if(keylength >= TLS_JETBLUE_MAX_INDEXKEY_LENGTH)
        {
            fRet = FALSE;
            goto cleanup;
        }
    }
    else
    {
        keylength = g_TableIndex[nExpDate].cbKey;
    }

    AddJetIndex(g_TableIndex[nExpDate].pszIndexName,
                g_TableIndex[nExpDate].pszIndexKey,
                keylength,
                g_TableIndex[nExpDate].jbGrbit,
                g_TableIndex[nExpDate].ulDensity
                );

cleanup:
    return CloseTable() && fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tlsdb\licpack.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        LicPack.cpp
//
// Contents:    LicensedPack Table
//
// History:     
//              
//---------------------------------------------------------------------------

#include "LicPack.h"

LPCTSTR __LicensedPackIdxOnInternalKpId::pszIndexName = LICENSEDPACK_INDEX_INTERNALKEYPACKID_INDEXNAME;
LPCTSTR __LicensedPackIdxOnInternalKpId::pszIndexKey = LICENSEDPACK_INDEX_INTERNALKEYPACKID_INDEXKEY;

LPCTSTR __LicensedPackIdxOnModifyTime::pszIndexName = LICENSEDPACK_INDEX_LASTMODIFYTIME_INDEXNAME;
LPCTSTR __LicensedPackIdxOnModifyTime::pszIndexKey = LICENSEDPACK_INDEX_LASTMODIFYTIME_INDEXKEY;

LPCTSTR __LicensedPackIdxOnCompanyName::pszIndexName = LICENSEDPACK_INDEX_COMPANYNAME_INDEXNAME;
LPCTSTR __LicensedPackIdxOnCompanyName::pszIndexKey = LICENSEDPACK_INDEX_COMPANYNAME_INDEXKEY;

LPCTSTR __LicensedPackIdxOnProductId::pszIndexName = LICENSEDPACK_INDEX_PRODUCTID_INDEXNAME;
LPCTSTR __LicensedPackIdxOnProductId::pszIndexKey = LICENSEDPACK_INDEX_PRODUCTID_INDEXKEY;

LPCTSTR __LicensedPackIdxOnKeyPackId::pszIndexName = LICENSEDPACK_INDEX_KEYPACKID_INDEXNAME;
LPCTSTR __LicensedPackIdxOnKeyPackId::pszIndexKey = LICENSEDPACK_INDEX_KEYPACKID_INDEXKEY;

LPCTSTR __LicensedPackIdxOnInstalledProduct::pszIndexName = LICENSEDPACK_INDEX_INSTALLEDPRODUCT_INDEXNAME;
LPCTSTR __LicensedPackIdxOnInstalledProduct::pszIndexKey = LICENSEDPACK_INDEX_INSTALLEDPRODUCT_INDEXKEY;

LPCTSTR __LicensedPackIdxOnAllocLicense::pszIndexName = LICENSEDPACK_INDEX_ALLOCATELICENSE_INDEXNAME;
LPCTSTR __LicensedPackIdxOnAllocLicense::pszIndexKey = LICENSEDPACK_INDEX_ALLOCATELICENSE_INDEXKEY;


//----------------------------------------------------
CCriticalSection LicPackTable::g_TableLock;
LPCTSTR LicPackTable::pszTableName = LICENSEDPACK_TABLE_NAME;

//////////////////////////////////////////////////////////////////////////
//
// Index definition for KeyPack table
//
TLSJBIndex
LicPackTable::g_TableIndex[] = 
{
    {
        LICENSEDPACK_INDEX_INTERNALKEYPACKID_INDEXNAME,
        LICENSEDPACK_INDEX_INTERNALKEYPACKID_INDEXKEY,
        -1,
        JET_bitIndexPrimary,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },        

    {
        LICENSEDPACK_INDEX_LASTMODIFYTIME_INDEXNAME,
        LICENSEDPACK_INDEX_LASTMODIFYTIME_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },
    
    {
        LICENSEDPACK_INDEX_COMPANYNAME_INDEXNAME,
        LICENSEDPACK_INDEX_COMPANYNAME_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },

    {
        LICENSEDPACK_INDEX_PRODUCTID_INDEXNAME,
        LICENSEDPACK_INDEX_PRODUCTID_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },

    {
        LICENSEDPACK_INDEX_KEYPACKID_INDEXNAME,
        LICENSEDPACK_INDEX_KEYPACKID_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },
        
    {
        LICENSEDPACK_INDEX_INSTALLEDPRODUCT_INDEXNAME,
        LICENSEDPACK_INDEX_INSTALLEDPRODUCT_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    },

    {                
        LICENSEDPACK_INDEX_ALLOCATELICENSE_INDEXNAME,
        LICENSEDPACK_INDEX_ALLOCATELICENSE_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    }
};

int
LicPackTable::g_NumTableIndex = sizeof(LicPackTable::g_TableIndex) / sizeof(LicPackTable::g_TableIndex[0]);

//////////////////////////////////////////////////////////////////////////
//
// Column Definition for KeyPack table
//
TLSJBColumn
LicPackTable::g_Columns[] = 
{
    {        
        LICENSEDPACK_COLUMN_ENTRYSTATUS,
        JET_coltypUnsignedByte,
        0,
        JET_bitColumnFixed,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // Internal tracking KeyPackID
    {
        LICENSEDPACK_COLUMN_KEYPACKID,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // Last Modify Time
    {
        LICENSEDPACK_COLUMN_LASTMODIFYTIME,
        JET_coltypBinary,
        sizeof(FILETIME),
        JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },


    //
    // LICENSEDPACK_COLUMN_ATTRIBUTE
    {
        LICENSEDPACK_COLUMN_ATTRIBUTE,
        JET_coltypLong,
        0,
        JET_bitColumnFixed,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },
        
    //
    // LICENSEDPACK_COLUMN_KEYPACKSTATUS
    {        
        LICENSEDPACK_COLUMN_KEYPACKSTATUS,
        JET_coltypUnsignedByte,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // LICENSEDPACK_COLUMN_AVAILABLE
    {
        LICENSEDPACK_COLUMN_AVAILABLE,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // LICENSEDPACK_COLUMN_NEXTSERIALNUMBER
    {
        LICENSEDPACK_COLUMN_NEXTSERIALNUMBER,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // LICENSEDPACK_COLUMN_ACTIVATEDATE
    {
        LICENSEDPACK_COLUMN_ACTIVATEDATE,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // LICENSEDPACK_COLUMN_EXPIREDATE
    {
        LICENSEDPACK_COLUMN_EXPIREDATE,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // LICENSEDPACK_COLUMN_DOMAINSETUPID
    {
        LICENSEDPACK_COLUMN_DOMAINSETUPID,
        JET_coltypLongBinary,
        TLSTABLE_MAX_BINARY_LENGTH,
        0,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // LICENSEDPACK_COLUMN_LSSETUPID
    {
        LICENSEDPACK_COLUMN_LSSETUPID,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // LICENSEDPACK_COLUMN_DOMAINNAME
    {
        LICENSEDPACK_COLUMN_DOMAINNAME,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // LICENSEDPACK_COLUMN_LSERVERNAME
    {
        LICENSEDPACK_COLUMN_LSERVERNAME,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },


    //
    // Standard License Pack Property.
    //

    //
    // License Pack ID
    {
        LICENSEDPACK_COLUMN_LPID,
        JB_COLTYPE_TEXT, 
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        JBSTRING_NULL,
        _tcslen(JBSTRING_NULL),
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // KeyPack type
    {
        LICENSEDPACK_COLUMN_AGREEMENTTYPE,
        JET_coltypUnsignedByte,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // CompanyName
    {
        LICENSEDPACK_COLUMN_COMPANYNAME,
        // JET_coltypLongText,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        JBSTRING_NULL,
        _tcslen(JBSTRING_NULL),
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // Product ID
    {
        LICENSEDPACK_COLUMN_PRODUCTID,
        //JET_coltypLongText,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        JBSTRING_NULL,
        _tcslen(JBSTRING_NULL),
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // Major Version
    {
        LICENSEDPACK_COLUMN_MAJORVERSION,
        JET_coltypShort,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },
    
    //
    // Minor Version
    {
        LICENSEDPACK_COLUMN_MINORVERSION,
        JET_coltypShort,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // Platform Type
    {
        LICENSEDPACK_COLUMN_PLATFORMTYPE,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },
 
    //
    // License Type
    {
        LICENSEDPACK_COLUMN_LICENSETYPE,
        JET_coltypUnsignedByte,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    // ChannelOfPurchase
    {
        LICENSEDPACK_COLUMN_COP,
        JET_coltypUnsignedByte,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    //  Begin Serial Number
    {
        LICENSEDPACK_COLUMN_BSERIALNUMBER,
        //JET_coltypLongText,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        JBSTRING_NULL,
        _tcslen(JBSTRING_NULL),
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    //   Total license in License Pack
    {
        LICENSEDPACK_COLUMN_TOTALLICENSES,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    //
    //  Product specific Flag   
    {
        LICENSEDPACK_COLUMN_PRODUCTFLAGS,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    }
};

int
LicPackTable::g_NumColumns = sizeof(LicPackTable::g_Columns) / sizeof(LicPackTable::g_Columns[0]);


//-----------------------------------------------------

BOOL
LicPackTable::ResolveToTableColumn()
/*
*/
{
    m_JetErr = ucEntryStatus.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_ENTRYSTATUS
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwKeyPackId.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_KEYPACKID
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = ftLastModifyTime.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_LASTMODIFYTIME
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwAttribute.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_ATTRIBUTE
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = ucKeyPackStatus.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_KEYPACKSTATUS
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwNumberOfLicenses.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_AVAILABLE
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwNextSerialNumber.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_NEXTSERIALNUMBER
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwActivateDate.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_ACTIVATEDATE
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwExpirationDate.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_EXPIREDATE
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = pbDomainSid.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_DOMAINSETUPID
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = szInstallId.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_LSSETUPID
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = szDomainName.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_DOMAINNAME
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = szTlsServerName.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_LSERVERNAME
                    );                    

    if(IsSuccess() == FALSE)
        goto cleanup;

    //----------------------------------------------------

    m_JetErr = szKeyPackId.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_LPID
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;
                        
    m_JetErr = ucAgreementType.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_AGREEMENTTYPE
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = szCompanyName.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_COMPANYNAME
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = szProductId.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_PRODUCTID
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = wMajorVersion.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_MAJORVERSION
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = wMinorVersion.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_MINORVERSION
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;
        
    m_JetErr = dwPlatformType.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_PLATFORMTYPE
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = ucLicenseType.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_LICENSETYPE
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = ucChannelOfPurchase.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_COP
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = szBeginSerialNumber.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_BSERIALNUMBER
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwTotalLicenseInKeyPack.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_TOTALLICENSES
                    );

    if(IsSuccess() == FALSE)
        goto cleanup;

    m_JetErr = dwProductFlags.AttachToTable(
                        *this,
                        LICENSEDPACK_COLUMN_PRODUCTFLAGS
                    );


cleanup:
    return IsSuccess();
}

//------------------------------------------------------------

CLASS_PRIVATE BOOL
LicPackTable::ProcessSingleColumn(
    IN BOOL bFetch,
    IN TLSColumnBase& column,
    IN DWORD offset,
    IN PVOID pbData,
    IN DWORD cbData,
    IN PDWORD pcbDataReturn,
    IN LPCTSTR szColumnName
    )
/*

Abstract:

    Fetch/Insert/Update a particular column.

Parameter:

    bFetch - TRUE if fetch, FALSE if update/insert.
    column - Intended column for operation, reference pointer to TLSColumn
    szColumnName - name of the column, for debugging print purpose only

Returns:

    TRUE if successful, FALSE otherwise.
*/
{
    if(bFetch) 
    {
        m_JetErr = column.FetchColumnValue(
                                    pbData, 
                                    cbData, 
                                    offset, 
                                    pcbDataReturn
                                );
    }
    else
    {
        m_JetErr = column.InsertColumnValue(
                                    pbData, 
                                    cbData, 
                                    offset
                                );
    }

    REPORTPROCESSFAILED(
            bFetch,
            GetTableName(),
            szColumnName,
            m_JetErr
        );
    return IsSuccess();
}

//--------------------------------------------------------------

CLASS_PRIVATE BOOL
LicPackTable::ProcessRecord(
    LICENSEPACK* kp,
    BOOL bFetch,
    DWORD dwParam,
    BOOL bUpdate
    )
/*++

    See comment on TLSTable<> template class

++*/
{
    DWORD dwSize;

    JB_ASSERT(kp != NULL);

    if(kp == NULL)
    {
        SetLastJetError(JET_errInvalidParameter);
        return FALSE;
    }

    if(bFetch == FALSE)
    {
        BeginUpdate(bUpdate);

        //
        // any update will require update on lastmodifytime column
        if(!(dwParam & LICENSEDPACK_PROCESS_MODIFYTIME))
        {
            #if DBG
            //  
            // This is for self-checking only, TLSColumnFileTime 
            // will automatically update the time.
            //
            JB_ASSERT(FALSE);
            #endif

            dwParam |= LICENSEDPACK_PROCESS_MODIFYTIME;
        }

    }
    else
    {
        SetLastJetError(JET_errSuccess);
    }

    if(IsSuccess() == FALSE)
    {
        JB_ASSERT(FALSE);
        goto cleanup;    
    }        


    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_SZKEYPACKID)
    {
        ProcessSingleColumn( 
                    bFetch, 
                    szKeyPackId, 
                    0,
                    kp->szKeyPackId,
                    sizeof(kp->szKeyPackId),
                    &dwSize,
                    LICENSEDPACK_COLUMN_LPID 
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_AGREEMENTTYPE)
    {
        ProcessSingleColumn( 
                    bFetch, 
                    ucAgreementType, 
                    0,
                    &(kp->ucAgreementType),
                    sizeof(kp->ucAgreementType),
                    &dwSize,
                    LICENSEDPACK_COLUMN_AGREEMENTTYPE 
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_PRODUCTID)
    {
        ProcessSingleColumn(
                    bFetch, 
                    szProductId, 
                    0,
                    kp->szProductId,
                    sizeof(kp->szProductId),
                    &dwSize,
                    LICENSEDPACK_COLUMN_PRODUCTID
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_MAJORVERSION)
    {
        ProcessSingleColumn( 
                    bFetch,
                    wMajorVersion,
                    0,
                    &(kp->wMajorVersion),
                    sizeof(kp->wMajorVersion),
                    &dwSize,
                    LICENSEDPACK_COLUMN_MAJORVERSION
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_MINORVERSION)
    {
        ProcessSingleColumn(
                    bFetch,
                    wMinorVersion,
                    0,
                    &(kp->wMinorVersion),
                    sizeof(kp->wMinorVersion),
                    &dwSize,
                    LICENSEDPACK_COLUMN_MINORVERSION
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_PLATFORMTYPE)
    {
        ProcessSingleColumn(
                    bFetch,
                    dwPlatformType,
                    0,
                    &(kp->dwPlatformType),
                    sizeof(kp->dwPlatformType),
                    &dwSize,
                    LICENSEDPACK_COLUMN_PLATFORMTYPE
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_LICENSETYPE)
    {
        ProcessSingleColumn(
                    bFetch,
                    ucLicenseType,
                    0,
                    &(kp->ucLicenseType),
                    sizeof(kp->ucLicenseType),
                    &dwSize,
                    LICENSEDPACK_COLUMN_LICENSETYPE
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_COP)
    {
        ProcessSingleColumn(
                    bFetch,
                    ucChannelOfPurchase,
                    0,
                    &(kp->ucChannelOfPurchase),
                    sizeof(kp->ucChannelOfPurchase),
                    &dwSize,
                    LICENSEDPACK_COLUMN_COP
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_BSERIALNUMBER)
    {
        ProcessSingleColumn(
                    bFetch,
                    szBeginSerialNumber,
                    0,
                    kp->szBeginSerialNumber,
                    sizeof(kp->szBeginSerialNumber),
                    &dwSize,
                    LICENSEDPACK_COLUMN_BSERIALNUMBER
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_TOTALLICENSES)
    {
        ProcessSingleColumn(
                    bFetch,
                    dwTotalLicenseInKeyPack,
                    0,
                    &(kp->dwTotalLicenseInKeyPack),
                    sizeof(kp->dwTotalLicenseInKeyPack),
                    &dwSize,
                    LICENSEDPACK_COLUMN_TOTALLICENSES
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //        
    if(dwParam & LICENSEDPACK_PROCESS_PRODUCTFLAGS)
    {
        ProcessSingleColumn(
                    bFetch,
                    dwProductFlags,
                    0,
                    &(kp->dwProductFlags),
                    sizeof(kp->dwProductFlags),
                    &dwSize,
                    LICENSEDPACK_COLUMN_PRODUCTFLAGS
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_COMPANYNAME)
    {
        ProcessSingleColumn(
                    bFetch,
                    szCompanyName,
                    0,
                    kp->szCompanyName,
                    sizeof(kp->szCompanyName),
                    &dwSize,
                    LICENSEDPACK_COLUMN_COMPANYNAME
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;


    //
    //    
    if(dwParam & LICENSEDPACK_PROCESS_DWINTERNAL)
    {
        // this is the primary index, can't be changed
        if(bUpdate == FALSE)
        {
            ProcessSingleColumn(
                    bFetch,
                    dwKeyPackId,
                    0,
                    &(kp->dwKeyPackId),
                    sizeof(kp->dwKeyPackId),
                    &dwSize,
                    LICENSEDPACK_COLUMN_KEYPACKID
                );
        }
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSEDPACK_PROCESS_MODIFYTIME)
    {
        ProcessSingleColumn(
                    bFetch,
                    ftLastModifyTime,
                    0,
                    &(kp->ftLastModifyTime),
                    sizeof(kp->ftLastModifyTime),
                    &dwSize,
                    LICENSEDPACK_COLUMN_LASTMODIFYTIME
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;


    if(dwParam & LICENSEDPACK_PROCESS_ATTRIBUTE)
    {
        ProcessSingleColumn(
                    bFetch,
                    dwAttribute,
                    0,
                    &(kp->dwAttribute),
                    sizeof(kp->dwAttribute),
                    &dwSize,
                    LICENSEDPACK_COLUMN_ATTRIBUTE
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;


    //
    //    
    if(dwParam & LICENSEDPACK_PROCESS_KEYPACKSTATUS)
    {
        ProcessSingleColumn(
                    bFetch,
                    ucKeyPackStatus,
                    0,
                    &(kp->ucKeyPackStatus),
                    sizeof(kp->ucKeyPackStatus),
                    &dwSize,
                    LICENSEDPACK_COLUMN_KEYPACKSTATUS
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_AVAILABLE)
    {
        ProcessSingleColumn(
                    bFetch,
                    dwNumberOfLicenses, 
                    0,
                    &(kp->dwNumberOfLicenses),
                    sizeof(kp->dwNumberOfLicenses),
                    &dwSize,
                    LICENSEDPACK_COLUMN_AVAILABLE
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_ACTIVATEDATE)
    {
        ProcessSingleColumn(
                    bFetch,
                    dwActivateDate,
                    0,
                    &(kp->dwActivateDate),
                    sizeof(kp->dwActivateDate),
                    &dwSize,
                    LICENSEDPACK_COLUMN_ACTIVATEDATE
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    //
    //
    if(dwParam & LICENSEDPACK_PROCESS_EXPIREDATE)
    {
        ProcessSingleColumn(
                    bFetch,
                    dwExpirationDate,
                    0,
                    &(kp->dwExpirationDate),
                    sizeof(kp->dwExpirationDate),
                    &dwSize,
                    LICENSEDPACK_COLUMN_EXPIREDATE
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

#if 0
    // no more domain sid.    
    if(dwParam & LICENSEDPACK_PROCESS_DOMAINSID)
    {
        if(bFetch == TRUE)
        {
            DWORD size;

            m_JetErr = pbDomainSid.FetchColumnValue(
                                        NULL,
                                        0,
                                        0,
                                        &size
                                    );
            if(IsSuccess() == FALSE)
                goto cleanup;

            if(size > kp->cbDomainSid || kp->pbDomainSid == NULL)
            {
                FreeMemory(kp->pbDomainSid);

                kp->pbDomainSid = (PBYTE)AllocateMemory(kp->cbDomainSid = size);
                if(kp->pbDomainSid == NULL)
                {
                    SetLastJetError(JET_errOutOfMemory);
                    goto cleanup;
                }
            }
        
            m_JetErr = pbDomainSid.FetchColumnValue(
                                        kp->pbDomainSid,
                                        kp->cbDomainSid,
                                        0,
                                        &kp->cbDomainSid
                                    );
        }
        else
        {
            ProcessSingleColumn(
                        bFetch,
                        pbDomainSid,
                        0,
                        kp->pbDomainSid,
                        kp->cbDomainSid,
                        &dwSize,
                        LICENSEDPACK_COLUMN_DOMAINSETUPID
                    );
        }
    }

    if(IsSuccess() == FALSE)
        goto cleanup;
#endif

    if(dwParam & LICENSEDPACK_PROCESS_LSSETUPID)
    {
        ProcessSingleColumn(
                    bFetch,
                    szInstallId,
                    0,
                    kp->szInstallId,
                    sizeof(kp->szInstallId),
                    &dwSize,
                    LICENSEDPACK_COLUMN_LSSETUPID
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSEDPACK_PROCESS_DOMAINNAME)
    {
        ProcessSingleColumn(
                    bFetch,
                    szDomainName,
                    0,
                    kp->szDomainName,
                    sizeof(kp->szDomainName),
                    &dwSize,
                    LICENSEDPACK_COLUMN_DOMAINNAME
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;

    if(dwParam & LICENSEDPACK_PROCESS_SERVERNAME)
    {
        ProcessSingleColumn(
                    bFetch,
                    szTlsServerName,
                    0,
                    &kp->szTlsServerName,
                    sizeof(kp->szTlsServerName),
                    &dwSize,
                    LICENSEDPACK_COLUMN_LSERVERNAME
                );
    }
    if(IsSuccess() == FALSE)
        goto cleanup;
        
    if(dwParam & LICENSEDPACK_PROCESS_NEXTSERIALNUMBER)
    {
        ProcessSingleColumn(
                    bFetch,
                    dwNextSerialNumber,
                    0,
                    &(kp->dwNextSerialNumber),
                    sizeof(kp->dwNextSerialNumber),
                    &dwSize,
                    LICENSEDPACK_COLUMN_NEXTSERIALNUMBER
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;


    if(dwParam & LICENSEDPACK_PROCESS_ENTRYSTATUS)
    {
        ProcessSingleColumn(
                    bFetch,
                    ucEntryStatus,
                    0,
                    &(kp->ucEntryStatus),
                    sizeof(kp->ucEntryStatus),
                    &dwSize,
                    LICENSEDPACK_COLUMN_ENTRYSTATUS
                );
    }

cleanup:

    // 
    // For inserting/updating record
    if(bFetch == FALSE)
    {
        JET_ERR jetErr;
        jetErr = GetLastJetError();

        //
        // End update will reset the error code
        //
        EndUpdate(IsSuccess() == FALSE);

        if(jetErr != JET_errSuccess  && IsSuccess() == FALSE)
            SetLastJetError(jetErr);
    }

    return IsSuccess();
}

//-------------------------------------------------------
JBKeyBase*
LicPackTable::EnumerationIndex( 
    IN BOOL bMatchAll,
    IN DWORD dwParam,
    IN LICENSEPACK* kp,
    IN OUT BOOL* pbCompareKey
    )
/*
*/
{
    BOOL bRetCode;
    JBKeyBase* index=NULL;

    //
    // if matching all value in field, set to compare key
    //
    *pbCompareKey = bMatchAll;

    if(dwParam == LICENSEDPACK_FIND_PRODUCT) 
    {
        index = new TLSLicensedPackIdxInstalledProduct(kp);
    }
    else if(dwParam == LICENSEDPACK_FIND_LICENSEPACK)
    {
        index = new TLSLicensedPackIdxAllocateLicense(kp);
    }
    else if(dwParam & LICENSEDPACK_PROCESS_SZKEYPACKID)
    {
        index = new TLSLicensedPackIdxKeyPackId(kp);
    }
    else if(dwParam & LICENSEDPACK_PROCESS_COMPANYNAME)
    {
        index = new TLSLicensedPackIdxCompany(kp);
    }
    else if(dwParam & LICENSEDPACK_PROCESS_PRODUCTID)
    {
        index = new TLSLicensedPackIdxProductId(kp);
    }
    else if(dwParam & LICENSEDPACK_PROCESS_MODIFYTIME)
    {
        index = new TLSLicensedPackIdxLastModifyTime(kp);
    }
    else
    {
        index = new TLSLicensedPackIdxInternalKpId(kp);

        //
        // default index, can't compare key even if 
        // bmatchall is set to true
        //
        *pbCompareKey = (bMatchAll && (dwParam & LICENSEDPACK_PROCESS_DWINTERNAL));
    }

    return index;
}

//-------------------------------------------------------
BOOL
LicPackTable::EqualValue(
    IN LICENSEPACK& s1,         // values to be compared
    IN LICENSEPACK& s2,
    IN BOOL bMatchAll,      // match all specified fields in structure 
    IN DWORD dwParam        // which fields in KEYPACK to be compared
    )
/*

Compare fields in two KEYPACK structure

s1 : first value
s2 : second value
bMatchAll : TRUE if match all field specified in dwParam, FALSE otherwise
dwParam : fields that will be in comparision
               

*/
{
    BOOL bRetCode = TRUE;

    if(dwParam & LICENSEDPACK_PROCESS_ENTRYSTATUS)
    {
        bRetCode = (s1.ucEntryStatus == s2.ucEntryStatus);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_SZKEYPACKID)
    {
        bRetCode = (_tcscmp(s1.szKeyPackId, s2.szKeyPackId) == 0);

        //
        // bMatchAll == TRUE and bRetCode == FALSE -> return FALSE
        // bMatchAll == FALSE and bRetCode == TRUE -> return TRUE
        if(bMatchAll != bRetCode)
            goto cleanup;
    }
    
    if(dwParam & LICENSEDPACK_PROCESS_AGREEMENTTYPE)
    {
        bRetCode = (s1.ucAgreementType == s2.ucAgreementType);

        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_PRODUCTID)
    {
        bRetCode = (_tcscmp(s1.szProductId, s2.szProductId) == 0);

        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_MAJORVERSION)
    {
        bRetCode = (s1.wMajorVersion == s2.wMajorVersion);

        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_MINORVERSION)
    {
        bRetCode = (s1.wMinorVersion == s2.wMinorVersion);

        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_PLATFORMTYPE)
    {
        bRetCode = (s1.dwPlatformType == s2.dwPlatformType);
    
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_LICENSETYPE)
    {
        bRetCode = (s1.ucLicenseType == s2.ucLicenseType);

        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_COP)
    {
        bRetCode = (s1.ucChannelOfPurchase == s2.ucChannelOfPurchase);

        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_BSERIALNUMBER)
    {
        bRetCode = (_tcscmp(s1.szBeginSerialNumber, s2.szBeginSerialNumber) == 0);

        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_TOTALLICENSES)
    {
        bRetCode = (s1.dwTotalLicenseInKeyPack == s2.dwTotalLicenseInKeyPack);

        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_PRODUCTFLAGS)
    {
        bRetCode = (s1.dwProductFlags == s2.dwProductFlags);

        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_COMPANYNAME)
    {
        bRetCode = (_tcscmp(s1.szCompanyName, s2.szCompanyName) == 0);

        if(bMatchAll != bRetCode)
            goto cleanup;
    }


    if(dwParam & LICENSEDPACK_PROCESS_DWINTERNAL)
    {
        bRetCode = (s1.dwKeyPackId == s2.dwKeyPackId);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_MODIFYTIME)
    {
        bRetCode = (CompareFileTime(&s1.ftLastModifyTime, &s2.ftLastModifyTime) == 0);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_ATTRIBUTE)
    {
        bRetCode = (s1.dwAttribute == s2.dwAttribute);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_KEYPACKSTATUS)
    {
        bRetCode = (s1.ucKeyPackStatus == s2.ucKeyPackStatus);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_AVAILABLE)
    {
        bRetCode = (s1.dwNumberOfLicenses == s2.dwNumberOfLicenses);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_ACTIVATEDATE)
    {
        bRetCode = (s1.dwActivateDate == s2.dwActivateDate);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_EXPIREDATE)
    {
        bRetCode = (s1.dwExpirationDate == s2.dwExpirationDate);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    //if(dwParam & LICENSEDPACK_PROCESS_DOMAINSID)
    //{
    //    bRetCode = EqualSid(s1.pbDomainSid, s2.pbDomainSid);
    //    if(bMatchAll != bRetCode)
    //        goto cleanup;
    //}

    if(dwParam & LICENSEDPACK_PROCESS_LSSETUPID)
    {
        bRetCode = (_tcsicmp(s1.szInstallId, s2.szInstallId) == 0);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_DOMAINNAME)
    {
        bRetCode = (_tcsicmp(s1.szDomainName, s2.szDomainName) == 0);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_SERVERNAME)
    {
        bRetCode = (_tcsicmp(s1.szTlsServerName, s2.szTlsServerName) == 0);
        if(bMatchAll != bRetCode)
            goto cleanup;
    }

    if(dwParam & LICENSEDPACK_PROCESS_NEXTSERIALNUMBER)
    {
        bRetCode = (s1.dwNextSerialNumber == s2.dwNextSerialNumber);
    }
 
cleanup:

    return bRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tlsdb\tlsdb.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        tlsdb.h
//
// Contents:    basic class for license table
//
// History:     
//              
//---------------------------------------------------------------------------
#ifndef __TLSDB_H__
#define __TLSDB_H__

#include "JetBlue.h"
#include "locks.h"
#include "tlsrpc.h"

#define ENUMERATE_COMPARE_NO_FIELDS         0x00000000
#define PROCESS_ALL_COLUMNS                 0xFFFFFFFF

#define TLSTABLE_INDEX_DEFAULT_DENSITY  TLS_TABLE_INDEX_DEFAULT_DENSITY
#define TLSTABLE_MAX_BINARY_LENGTH          8192

#define RECORD_ENTRY_DELETED                0x01

#if DBG

    #define REPORT_IF_FETCH_FAILED( Table, Column, ErrCode )                                          \
        if(ErrCode < JET_errSuccess) {                                                      \
            DebugOutput(_TEXT("Table %s, Column %s - fetch failed with error code %d\n"),   \
                        Table, Column, ErrCode );                                            \
        }

    #define REPORT_IF_INSERT_FAILED( Table, Column, ErrCode )                                          \
        if(ErrCode < JET_errSuccess) {                                                      \
            DebugOutput(_TEXT("Table %s, Column %s - insert failed with error code %d\n"),   \
                        Table, Column, ErrCode );                                           \
        }

    #define REPORTPROCESSFAILED(bFetch, tablename, columnname, jeterror) \
        if(bFetch)  \
        {           \
            REPORT_IF_FETCH_FAILED(tablename, columnname, jeterror);  \
        }           \
        else        \
        {           \
            REPORT_IF_INSERT_FAILED(tablename, columnname, jeterror); \
        }

#else

    #define REPORT_IF_FETCH_FAILED( a, b, c )
    #define REPORT_IF_INSERT_FAILED( a, b, c )
    #define REPORTPROCESSFAILED( a, b, c, d)

#endif

//
////////////////////////////////////////////////////////////////
//
// This is to force compiler to check for require member 
// function
//
struct TLSColumnBase  {
    virtual JET_ERR
    FetchColumnValue(
        PVOID pbData,
        DWORD cbData,
        DWORD offset,
        PDWORD pcbReturnData
    ) = 0;

    virtual JET_ERR
    InsertColumnValue(
        PVOID pbData,
        DWORD cbData,
        DWORD offset
    ) = 0;
};

//
////////////////////////////////////////////////////////////////
//
template<class Type, JET_COLTYP JetColType>
struct TLSColumn : public JBColumnBufferBase, TLSColumnBase {

private:
    JBColumn* m_JetColumn;    

    //--------------------------------------------
    JET_ERR
    RetrieveColumnValue(
        PVOID pbData,
        DWORD cbData,
        DWORD offset
        ) 
    /*
    */
    {
        JB_ASSERT(IsValid() == TRUE);

        if(m_JetColumn == NULL)
        {
            #ifdef DBG
            OutputDebugString(
                    _TEXT("Column buffer not attach to any table...\n")
                );
            #endif

            return JET_errNotInitialized;
        }

        //JB_ASSERT(pbData != NULL);

        //
        // TODO - supply conversion routine ???
        //
        if(m_JetColumn->GetJetColumnType() != JB_COLTYPE_TEXT)
        {
            // we are using long binary type as long text so ignore
            // this one
            if(m_JetColumn->GetJetColumnType() != JetColType)
            {
                //
                // this is an internal error
                //
                JB_ASSERT(m_JetColumn->GetJetColumnType() == JetColType);
                m_JetColumn->SetLastJetError(
                                    JET_errInvalidParameter
                                );
                return FALSE;
            }
        }

        BOOL bSuccess;

        bSuccess = m_JetColumn->FetchColumn(
                            pbData,
                            cbData,
                            offset
                        );

        return (bSuccess == TRUE) ? JET_errSuccess : m_JetColumn->GetLastJetError();
    }

public:

    //--------------------------------------------
    TLSColumn( 
        TLSColumn& src 
        ) : 
        m_JetColumn(src.m_JetColumn) 
    /*
    */        
    {
    }
    
    //--------------------------------------------
    TLSColumn(
        JBTable& jbTable,
        LPCTSTR pszColumnName
        )
    /*
    */
    {
        if(AttachToTable(jbTable, pszColumnName) == FALSE)
        {
            JB_ASSERT(FALSE);
        }
    }
            
    //--------------------------------------------
    TLSColumn() : m_JetColumn(NULL) {}

    //--------------------------------------------

    JET_ERR
    AttachToTable( 
        JBTable& jbTable, 
        LPCTSTR pszColumnName 
        )   
    /*
    */
    {
        m_JetColumn = jbTable.FindColumnByName(pszColumnName);
        return (m_JetColumn != NULL) ? JET_errSuccess : jbTable.GetLastJetError();
    }
    

    //--------------------------------------------
    BOOL 
    IsValid() 
    {
        return (m_JetColumn != NULL);
    }
                
    //--------------------------------------------
    virtual JET_ERR
    FetchColumnValue(
        PVOID pbData,           // buffer for returning data
        DWORD cbData,           // size of buffer
        DWORD offset,
        PDWORD pcbReturnData    // actual data returned.
        ) 
    /*
    */
    {
        JET_ERR jetErr;
        jetErr = RetrieveColumnValue(
                                pbData,
                                cbData,
                                offset
                            );

        if(pcbReturnData)
        {
            *pcbReturnData = GetActualDataSize();
        }
        return jetErr;
    }

    //--------------------------------------------
    virtual JET_ERR
    InsertColumnValue(
        PVOID pbData,
        DWORD cbData,
        DWORD offset
        )
    /*
    */
    {
        JB_ASSERT(IsValid() == TRUE);
        if(m_JetColumn == NULL)
        {
            #ifdef DBG
            OutputDebugString(
                    _TEXT("Column buffer not attach to any table...\n")
                );
            #endif

            return JET_errNotInitialized;
        }


        BOOL bSuccess;
        bSuccess = m_JetColumn->InsertColumn(
                                pbData,
                                cbData,
                                offset
                            );

        return (bSuccess == TRUE) ? JET_errSuccess : m_JetColumn->GetLastJetError();
    }

    //--------------------------------------------
    JET_ERR
    GetLastJetError() 
    {
        return (m_JetColumn) ? m_JetColumn->GetLastJetError() : JET_errNotInitialized;
    }

    //--------------------------------------------
    DWORD
    GetActualDataSize() 
    {
        return m_JetColumn->GetDataSize();
    }

    //-------------------------------------------
    JET_COLTYP
    GetJetColumnType() 
    {
        return JetColType;
    }


    //
    // Always require calling function to pass in buffer
    //
    PVOID
    GetInputBuffer() 
    { 
        JB_ASSERT(FALSE); 
        return NULL;
    }

    //-----------------------------------------
    PVOID
    GetOutputBuffer() 
    {
        JB_ASSERT(FALSE);
        return NULL;
    }

    //-----------------------------------------
    DWORD
    GetInputBufferLength() 
    { 
        return 0; 
    }

    //-----------------------------------------
    DWORD
    GetOutputBufferLength() 
    { 
        return 0; 
    }
};  


// ----------------------------------------------------------
//
// Out text is unicode, JetBlue only support fix length text up 
// to 255 characters so we use Long text instead.
//
// JET_coltypBinary
// JET_coltypText
// JET_coltypLongBinary
// JET_coltypLongText
//
// See esent.h
//
typedef TLSColumn<LPTSTR, JET_coltypLongText> TLSColumnText;
typedef TLSColumn<PVOID, JET_coltypLongBinary> TLSColumnBinary;

//
// unsigned byte
typedef TLSColumn<UCHAR, JET_coltypUnsignedByte> TLSColumnUchar;   

//
// 2-byte integer, signed
typedef TLSColumn<WORD, JET_coltypShort> TLSColumnShort;

//
// 4-byte integer, signed
typedef TLSColumn<LONG, JET_coltypLong> TLSColumnLong;

//
//
typedef TLSColumn<DWORD, JET_coltypLong> TLSColumnDword;


//
// 4-byte IEEE single precision
typedef TLSColumn<float, JET_coltypIEEESingle> TLSColumnFloat;

// 
// 8-byte IEEE double precision
typedef TLSColumn<double, JET_coltypIEEEDouble> TLSColumnDouble;


//
// File Time
typedef TLSColumn<FILETIME, JET_coltypBinary> TLSColumnFileTime;


//--------------------------------------------------------------    

JET_ERR
TLSColumnText::InsertColumnValue(
    PVOID pbData,
    DWORD cbData,
    DWORD offset
    )
/*
*/
{
    JB_ASSERT(IsValid() == TRUE);
    JET_ERR jetErr;

    jetErr = m_JetColumn->InsertColumn(
                            pbData,
                            _tcslen((LPTSTR) pbData) * sizeof(TCHAR),
                            offset
                        );

    return jetErr;
}

//--------------------------------------------------------------    

JET_ERR
TLSColumnText::FetchColumnValue(
    PVOID pbData,
    DWORD cbData,
    DWORD offset,
    PDWORD pcbDataReturn
    ) 
/*
*/
{
    PVOID pbBuffer = pbData;
    DWORD cbBuffer = cbData;

    // Cause recursive call - stack overflow
    // if(TLSColumn<Type>::FetchColumnValue(offset, pbData, cbData) == FALSE)
    //     return m_JetColumn->GetLastJetError();

    JET_ERR jetErr = RetrieveColumnValue( pbBuffer, cbBuffer, offset );
    if(jetErr == JET_errSuccess) 
    {
        ((LPTSTR)pbBuffer)[(min(cbBuffer, GetActualDataSize())) / sizeof(TCHAR)] = _TEXT('\0');
    }

    if(pcbDataReturn)
    {
        *pcbDataReturn = _tcslen((LPTSTR)pbBuffer);
    }

    return jetErr;
}

//---------------------------------------------------

JET_ERR
TLSColumnFileTime::InsertColumnValue(
    PVOID pbData,
    DWORD cbData,
    DWORD offset
    )
/*
*/
{
    FILETIME ft;
    SYSTEMTIME sysTime;

    JB_ASSERT(IsValid() == TRUE);
    JB_ASSERT(cbData == sizeof(FILETIME));
    JET_ERR jetErr;

    if(IsValid() == FALSE)
    {
        jetErr = JET_errNotInitialized;
    }
    else if(cbData != sizeof(FILETIME) || pbData == NULL)
    {
        m_JetColumn->SetLastJetError(jetErr = JET_errInvalidParameter);
    }
    else 
    {    

        memset(&ft, 0, sizeof(ft));
        if(CompareFileTime(&ft, (FILETIME *)pbData) == 0)
        {
            GetSystemTime(&sysTime);
            SystemTimeToFileTime(&sysTime, &ft);

            ((FILETIME *)pbData)->dwLowDateTime = ft.dwLowDateTime;
            ((FILETIME *)pbData)->dwHighDateTime = ft.dwHighDateTime;
        }
        else
        {
            ft.dwLowDateTime = ((FILETIME *)pbData)->dwLowDateTime;
            ft.dwHighDateTime = ((FILETIME *)pbData)->dwHighDateTime;
        }

        jetErr = m_JetColumn->InsertColumn(
                                (PVOID)&ft,
                                sizeof(ft),
                                0
                            );
    }

    return jetErr;
}

//---------------------------------------------------

JET_ERR
TLSColumnBinary::FetchColumnValue(
    PVOID pbData,
    DWORD cbData,
    DWORD offset,
    PDWORD pcbDataReturn
    )
/*
*/
{
    //
    // don't worry about buffer size, calling function 
    // should trap it.
    JET_ERR jetErr = RetrieveColumnValue( pbData, cbData, offset );
    if(jetErr == JET_errSuccess && pcbDataReturn != NULL) 
    {
        *pcbDataReturn = GetActualDataSize();
    }

    return jetErr;
}

//
/////////////////////////////////////////////////////////////
//
typedef enum {
    RECORD_ENUM_ERROR=0,
    RECORD_ENUM_MORE_DATA,
    RECORD_ENUM_END
} RECORD_ENUM_RETCODE;


template<class T>
class TLSTable : public JBTable {
/*
    Virtual base template class for table used in TLSLicensing 
    database, template is due to 

    1) Static member variable which include column and indexes 
       in the table.
    2) Type checking - KEYPACK structure only good for one
       table.

    Class derive from this template must define 

    1) static g_Columns, g_NumColumns.
    2) static g_TableIndex, g_NumTableIndex.
    3) static g_TableLock (Might not be necessary)
    4) GetTableName()
    5) FetchRecord
    6) InsertRecord
    7) ResolveToTableColumn()
    8) EnumerationBegin()
    9) EqualValue().

    See comment for each member function.
*/
protected:

    //
    // Class derive or inst. from TLSTable<> must define following
    //
    static TLSJBColumn g_Columns[];
    static int g_NumColumns;

    static TLSJBIndex g_TableIndex[];
    static int g_NumTableIndex;

    T m_EnumValue;
    BOOL m_EnumMatchAll;
    DWORD m_EnumParam;
    DWORD m_EnumState; // HIWORD - in enumeration, TRUE/FALSE 
                       // LOWORD - MoveToNext record before fetch.

    BYTE  m_Key[sizeof(T)];
    DWORD m_KeyLength;
    BOOL m_bCompareKey; // should we compare key?

    BOOL 
    IsInEnumeration() {
        return HIWORD(m_EnumState);
    }

    BOOL
    IsMoveBeforeFetch() {
        return LOWORD(m_EnumState);
    }

    void 
    SetInEnumeration(
        BOOL b
        ) 
    {
        m_EnumState = MAKELONG(LOWORD(m_EnumState), b);
    }

    void 
    SetMoveBeforeFetch(
        BOOL b
        ) 
    {
        m_EnumState = MAKELONG(b, HIWORD(m_EnumState));
    }
        

public:

    //
    // JetBlue has its own locking
    //
    static CCriticalSection g_TableLock;

    CCriticalSection&
    GetTableLock()
    {
        return g_TableLock;
    }

    //-------------------------------------------------------
    static void
    LockTable() 
    /*

        Lock table for exclusive access, JBTable provides
        ReadLock/WriteLock for current record

    */
    {
        g_TableLock.Lock();
    }

    //-------------------------------------------------------
    static void
    UnlockTable() 
    /*

        Unlock table.

    */
    {
        g_TableLock.UnLock();
    }

    //-------------------------------------------------------
    TLSTable(
        JBDatabase& database
        ) : 
        JBTable(database),
        m_EnumMatchAll(FALSE),
        m_EnumParam(0),
        m_EnumState(0),
        m_KeyLength(0)
    /*

        Constructor, must have JBDatabase object.

    */
    {
        memset(&m_EnumValue, 0, sizeof(T));
        memset(m_Key, 0, sizeof(m_Key));
    }

    
    //-------------------------------------------------------
    virtual BOOL
    CreateTable() 
    /*
        
        Create the table, must have g_Columns and g_NumColumns
        defined.
    
    */
    {
        DebugOutput(
                _TEXT("TLSTable - Creating Table %s...\n"),
                GetTableName()
            );

        if(BeginTransaction() == FALSE)
            return FALSE;
    
        if(CreateOpenTable(GetTableName()) == TRUE)
        {
            //
            // AddColumn() return num of col. created if successful
            //
            if(AddColumn(g_NumColumns, g_Columns) == g_NumColumns)
            {
                //
                // AddIndex() return 0 if success
                //
                AddIndex(g_NumTableIndex, g_TableIndex);
            }
        }

        if(IsSuccess() == TRUE)
        {
            CloseTable();
            CommitTransaction();
        }
        else
        {
            RollbackTransaction();
        }

        return IsSuccess();
    }

    //--------------------------------------------------------
    virtual BOOL
    UpgradeTable(
        IN DWORD dwOldVersion,
        IN DWORD dwNewVersion
        )
    /*++

    ++*/
    {
        if(dwOldVersion == 0)
        {
            if(OpenTable(TRUE, JET_bitTableUpdatable) == FALSE)
                return FALSE;

            return CloseTable();
        }
        else if(dwOldVersion == dwNewVersion)
        {
            return TRUE;
        }

        // We only have one version.
        JB_ASSERT(FALSE);
        return FALSE;
    }


    //--------------------------------------------------------
    virtual BOOL
    OpenTable(
        IN BOOL bCreateIfNotExist,
        IN JET_GRBIT grbit
        ) 
    /*

    Abstract:

        Open the table for access.

    Parameter:

        bCreateIfNoExist - TRUE, if table does not exist, create it,
                           FALSE return error if table not exist
    */
    {
        if( JBTable::OpenTable(GetTableName(), NULL, 0, grbit) == FALSE && 
            GetLastJetError() == JET_errObjectNotFound && 
            bCreateIfNotExist)
        {
            //
            // Close table after it created it
            //
            if( CreateTable() == FALSE || 
                JBTable::OpenTable(GetTableName(), NULL, 0, grbit) == FALSE ) 
            {
                return FALSE;
            }
        }

        if(IsSuccess() == TRUE)
        {
            ResolveToTableColumn();
        }

        return IsSuccess();
    }

    //---------------------------------------------------------
    //
    // pure virtual function to return table name
    //
    virtual LPCTSTR
    GetTableName() = 0;

    //---------------------------------------------------------
    virtual BOOL
    UpdateTable(
        IN DWORD dwOldVersion,  // unuse
        IN DWORD dwNewVersion
        )
    /*

    Abstract:

        Upgrade the table.

    Parameter:

        dwOldVersion - previous table version.
        dwNewVersion - current table version.

    */
    {
        // currently nothing to upgrade.

        return TRUE;
    }

    //
    // should have fetch/insert record with buffer passed in
    //
    //---------------------------------------------------------
    virtual BOOL
    InsertRecord(
        T& value,
        DWORD dwParam = PROCESS_ALL_COLUMNS
    ) = 0;

    virtual BOOL
    UpdateRecord(
        T& value,
        DWORD dwParam = PROCESS_ALL_COLUMNS
    ) = 0;

    //--------------------------------------------------------
    virtual BOOL
    FetchRecord(
        T& value,
        DWORD dwParam = PROCESS_ALL_COLUMNS
    ) = 0;

    //---------------------------------------------------------
    virtual BOOL
    Cleanup() 
    {
        EnumerateEnd();
        return TRUE;
    }  

    //---------------------------------------------------------
    virtual BOOL
    ResolveToTableColumn() = 0;

    //---------------------------------------------------------
    virtual JBKeyBase* 
    EnumerationIndex(
        BOOL bMatchAll,
        DWORD dwParam,
        T* value,
        BOOL* bCompareKey
    ) = 0;

    //------------------------------------------------------
    virtual BOOL
    EqualValue(
        T& src, 
        T& dest, 
        BOOL bMatchAll,
        DWORD dwMatchParam
    ) = 0;

    //-------------------------------------------------------
    //
    // Use user defined comparision function instead of calling
    // EqualValue() ???
    //
    virtual BOOL
    EnumerateBegin( 
        BOOL bMatchAll,
        DWORD dwParam,
        T* start_value
        )
    /*
    */
    {
        return EnumerateBegin(
                    bMatchAll,
                    dwParam,
                    start_value,
                    JET_bitSeekGE
                    );
    }

    virtual BOOL
    EnumerateBegin( 
        BOOL bMatchAll,
        DWORD dwParam,
        T* start_value,
        JET_GRBIT jet_seek_grbit
        )
    /*
    */
    {
        BOOL bRetCode = FALSE;
        
        if(dwParam != ENUMERATE_COMPARE_NO_FIELDS && start_value == NULL)
        {
            SetLastJetError(JET_errInvalidParameter);
            JB_ASSERT(FALSE);
            return FALSE;
        }

        if(IsInEnumeration() == TRUE)
        {
            SetLastJetError(JET_errInvalidObject);
            JB_ASSERT(FALSE);
            return FALSE;
        }

        JBKeyBase* index;

        index = EnumerationIndex(
                            bMatchAll, 
                            dwParam, 
                            start_value, 
                            &m_bCompareKey
                        );

        if(index == NULL)
        {
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        if(start_value == NULL || dwParam == ENUMERATE_COMPARE_NO_FIELDS)
        {
            //
            // position the cursor to first record
            // 
            bRetCode = JBTable::EnumBegin(index);

            m_EnumParam = ENUMERATE_COMPARE_NO_FIELDS;
            m_EnumMatchAll = FALSE;

            // enumerate all record
            m_bCompareKey = FALSE;
        }
        else
        {
            bRetCode = JBTable::SeekToKey(
                                    index, 
                                    dwParam, 
                                    jet_seek_grbit
                                );

            if(bRetCode == TRUE && m_bCompareKey)
            {
                bRetCode = JBTable::RetrieveKey(
                                        m_Key, 
                                        sizeof(m_Key), 
                                        &m_KeyLength
                                    );

                JB_ASSERT(bRetCode == TRUE);
            }

        }

        if(bRetCode == FALSE)
        {
            if(GetLastJetError() == JET_errRecordNotFound)
            {
                //
                // reset error code to provide same functionality as SQL
                //
                SetLastJetError(JET_errSuccess);
                bRetCode = TRUE;
            }
            else
            {
                DebugOutput(
                        _TEXT("Enumeration on table %s failed with error %d\n"),
                        GetTableName(),
                        GetLastJetError()
                    );

                JB_ASSERT(bRetCode);
            }
        }

        if(bRetCode == TRUE)
        {
            m_EnumParam = dwParam;
            m_EnumMatchAll = bMatchAll;

            if(start_value)
            {
                m_EnumValue = *start_value;
            }

            SetInEnumeration(TRUE);

            // cursor in on the the record we want.
            SetMoveBeforeFetch(FALSE);
        }

        delete index;
        return bRetCode;
    }

    //------------------------------------------------------
    virtual RECORD_ENUM_RETCODE
    EnumerateNext(
        IN OUT T& retBuffer,
        IN BOOL bReverse=FALSE,
        IN BOOL bAnyRecord = FALSE
        )
    /*
    */
    {
        if(IsInEnumeration() == FALSE)
        {
            SetLastJetError(JET_errInvalidParameter);
            return RECORD_ENUM_ERROR;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        RECORD_ENUM_RETCODE retCode=RECORD_ENUM_MORE_DATA;
        BYTE current_key[sizeof(T)];
        unsigned long current_key_length=0;
        //
        // Support for matching  
        //
        while(TRUE)
        {
            if(IsMoveBeforeFetch() == TRUE)
            {
                //
                // Position the cursor to next record for next fetch
                //
                JBTable::ENUM_RETCODE enumCode;
                enumCode = EnumNext(
                                    (bReverse == TRUE) ? JET_MovePrevious : JET_MoveNext
                                );

                switch(enumCode)
                {
                    case JBTable::ENUM_SUCCESS:
                        retCode = RECORD_ENUM_MORE_DATA;
                        break;
            
                    case JBTable::ENUM_ERROR:
                        retCode = RECORD_ENUM_ERROR;
                        break;

                    case JBTable::ENUM_END:
                        retCode = RECORD_ENUM_END;
                }

                if(retCode != RECORD_ENUM_MORE_DATA)
                    break;

            }

            // fetch entire record
            // TODO - fetch necessary fields for comparision, if
            //        equal then fetch remaining fields
            if(FetchRecord(retBuffer, PROCESS_ALL_COLUMNS) == FALSE)
            {
                retCode = (GetLastJetError() == JET_errNoCurrentRecord || 
                           GetLastJetError() == JET_errRecordNotFound) ? RECORD_ENUM_END : RECORD_ENUM_ERROR;
                break;
            }

            SetMoveBeforeFetch(TRUE);

            // compare the value
            if( bAnyRecord == TRUE ||
                m_EnumParam == ENUMERATE_COMPARE_NO_FIELDS ||
                EqualValue(retBuffer, m_EnumValue, m_EnumMatchAll, m_EnumParam) == TRUE )
            {
                break;
            }

            if(m_bCompareKey == TRUE)
            {
                // compare key to break out of loop
                if(JBTable::RetrieveKey(current_key, sizeof(current_key), &current_key_length) == FALSE)
                {
                    retCode = RECORD_ENUM_ERROR;
                    break;
                }

                if(memcmp(current_key, m_Key, min(m_KeyLength, current_key_length)) != 0)
                {
                    retCode = RECORD_ENUM_END;
                    break;
                }
            }
        }
    
        //
        // Terminate enumeration if end
        //
        //if(retCode != RECORD_ENUM_MORE_DATA)
        //{
        //    EnumerateEnd();
        //}

        return retCode;
    }

    //------------------------------------------------------
    virtual BOOL
    EnumerateEnd() {
        SetInEnumeration(FALSE);
        SetMoveBeforeFetch(FALSE);
        m_bCompareKey = FALSE;
        return TRUE;
    }

    //-------------------------------------------------------
    virtual DWORD
    GetCount(
        BOOL bMatchAll,
        DWORD dwParam,
        T* searchValue
        )
    /*
    */
    {
        DWORD count = 0;
        T value;
        RECORD_ENUM_RETCODE retCode;


        if(EnumerateBegin(bMatchAll, dwParam, searchValue) == TRUE)
        {
            while( (retCode=EnumerateNext(value)) == RECORD_ENUM_MORE_DATA )
            {
                count++;
            }

            if(retCode == RECORD_ENUM_ERROR)
            {
                DebugOutput(
                        _TEXT("GetCount for table %s : EnumerationNext() return %d\n"),
                        GetTableName(),
                        GetLastJetError()
                    );

                JB_ASSERT(FALSE);
            }

            EnumerateEnd();
        }
        else
        {
            DebugOutput(
                    _TEXT("GetCount for table %s : EnumerationBegin return %d\n"),
                    GetTableName(),
                    GetLastJetError()
                );

            JB_ASSERT(FALSE);
        }

        return count;
    }

    //-----------------------------------------------------
    virtual BOOL
    FindRecord(
        BOOL bMatchAll,
        DWORD dwParam,
        T& seachValue,
        T& retValue
        )
    /*
    */
    {
        RECORD_ENUM_RETCODE retCode;
        BOOL bSuccess=TRUE;

        //CCriticalSectionLocker Lock(GetTableLock());

        if(EnumerateBegin(bMatchAll, dwParam, &seachValue) == FALSE)
        {
            DebugOutput(
                    _TEXT("SearchValue for table %s : EnumerationBegin return %d\n"),
                    GetTableName(),
                    GetLastJetError()
                );

            JB_ASSERT(FALSE);

            bSuccess = FALSE;
            goto cleanup;
        }

        retCode = EnumerateNext(retValue);
        EnumerateEnd();

        if(retCode == RECORD_ENUM_ERROR)
        {
            DebugOutput(
                    _TEXT("SearchValue for table %s : EnumerationNext() return %d\n"),
                    GetTableName(),
                    GetLastJetError()
                );
        
            bSuccess = FALSE;
            JB_ASSERT(FALSE);
        }
        else if(retCode == RECORD_ENUM_END)
        {
            SetLastJetError(JET_errRecordNotFound);
            bSuccess = FALSE;
        }


    cleanup:

        return bSuccess;
    }

    //-------------------------------------------------
    virtual BOOL
    DeleteRecord()
    {
        //CCriticalSectionLocker Lock(GetTableLock());

        return JBTable::DeleteRecord();
    }

    //-------------------------------------------------
    virtual BOOL
    DeleteRecord(
        DWORD dwParam,
        T& value
        )
    /*
    */
    {
        BOOL bSuccess;
        T Dummy;

        //CCriticalSectionLocker Lock(GetTableLock());

        //
        // Position the current record
        bSuccess = FindRecord(
                            TRUE,
                            dwParam,
                            value,
                            Dummy
                        );

        if(bSuccess == FALSE)
            return FALSE;


        //
        // Delete the record
        bSuccess = JBTable::DeleteRecord();
        return bSuccess;
    }

    //----------------------------------------------
    virtual BOOL
    DeleteAllRecord(
        BOOL bMatchAll,
        DWORD dwParam,
        T& searchValue
        )
    /*
    */
    {
        int count=0;
        BOOL bSuccess;
        JET_ERR jetErr=JET_errSuccess;
        RECORD_ENUM_RETCODE retCode;
        T value;

        //CCriticalSectionLocker Lock(GetTableLock());

        if(EnumerateBegin(bMatchAll, dwParam, &searchValue) == TRUE)
        {
            while( (retCode=EnumerateNext(value)) == RECORD_ENUM_MORE_DATA )
            {
                count++;
                if(JBTable::DeleteRecord() == FALSE)
                {
                    DebugOutput(
                            _TEXT("DeleteAllRecord for table %s : return %d\n"),
                            GetTableName(),
                            GetLastJetError()
                        );

                    JB_ASSERT(FALSE);
                    jetErr = GetLastJetError();
                    break;
                }
            }

            //
            // End the enumeration
            //
            if(retCode == RECORD_ENUM_ERROR)
            {
                DebugOutput(
                        _TEXT("DeleteAllRecord for table %s : EnumerationNext() return %d\n"),
                        GetTableName(),
                        GetLastJetError()
                    );

                JB_ASSERT(FALSE);
            }

            if(EnumerateEnd() == TRUE)
            {
                // restore error code from DeleteRecord();
                SetLastJetError(jetErr);
            }
        }
        else
        {
            DebugOutput(
                    _TEXT("DeleteAllRecord for table %s : EnumerationBegin return %d\n"),
                    GetTableName(),
                    GetLastJetError()
                );
        }

        // return code is based on number of record deleted and its operation
        if(IsSuccess() == TRUE)
        {
            if(count == 0)
                SetLastJetError(JET_errRecordNotFound);
        }

        return IsSuccess();
    }
};


#ifdef __cplusplus
extern "C" {
#endif

    BOOL
    TLSDBCopySid(
        PSID pbSrcSid,
        DWORD cbSrcSid, 
        PSID* pbDestSid, 
        DWORD* cbDestSid
    );

    BOOL
    TLSDBCopyBinaryData(
        PBYTE pbSrcData,
        DWORD cbSrcData, 
        PBYTE* ppbDestData, 
        DWORD* pcbDestData
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tlsdb\version.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       version.h 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TLS_VERSION_H__
#define __TLS_VERSION_H__

#include "JetBlue.h"
#include "TlsDb.h"

#define VERSION_TABLE_PROCESS_VERSION   0x00000001
#define VERSION_TABLE_PROCESS_INSTALLID 0x00000002
#define VERSION_TABLE_PROCESS_DOMAINID  0x00000004

//
// Only one row in Version
//
#define VERSION_TABLE_NAME      _TEXT("Version")
#define VERSION_TABLE_VERSION   _TEXT("DataBaseVersion")
#define VERSION_TABLE_INSTALLID _TEXT("TLSSetupId")
#define VERSION_TABLE_DOMAINID  _TEXT("TLSDomainSetupId")


typedef struct __Version : public TLSReplVersion 
{
    //----------------------------------------------------
    __Version() 
    {
        pbDomainSid = NULL;
        dwVersion = 0;
        cbDomainSid = 0;
        memset(szInstallId, 0, sizeof(szInstallId));
    }


    //----------------------------------------------------
    ~__Version() 
    {
        if(pbDomainSid != NULL)
        {
            FreeMemory(pbDomainSid);
        }
    }

    //----------------------------------------------------
    __Version(const __Version& v) 
    {
        *this = v;
    }

    //----------------------------------------------------
    __Version&
    operator=(const TLSReplVersion& v)
    {
        BOOL bSuccess;

        dwVersion = v.dwVersion;
        _tcscpy(szInstallId, v.szInstallId);

        bSuccess = TLSDBCopySid(
                            v.pbDomainSid,
                            v.cbDomainSid,
                            (PSID *)&pbDomainSid,
                            &cbDomainSid
                        );

        JB_ASSERT(bSuccess == TRUE);        
        return *this;
    }

    __Version&
    operator=(const __Version& v)
    {
        BOOL bSuccess;

        if(this == &v)
            return *this;

        dwVersion = v.dwVersion;
        _tcscpy(szInstallId, v.szInstallId);

        bSuccess = TLSDBCopySid(
                            v.pbDomainSid,
                            v.cbDomainSid,
                            (PSID *)&pbDomainSid,
                            &cbDomainSid
                        );

        JB_ASSERT(bSuccess == TRUE);        
        return *this;
    }

} TLSVersion;


//
// Index on version ID
//
#define VERSION_ID_INDEXNAME \
    VERSION_TABLE_NAME SEPERATOR VERSION_TABLE_VERSION SEPERATOR INDEXNAME

//
// Primary index - "+DataBaseVersion\0"
//
#define VERSION_ID_INDEXNAME_INDEXKEY \
    INDEX_SORT_ASCENDING VERSION_TABLE_VERSION INDEX_END_COLNAME

typedef struct __VersionIndexOnVersionId : public JBKeyBase {

    static LPCTSTR pszIndexName;
    static LPCTSTR pszIndexKey;


    DWORD dwVersion;

    //-------------------------------------------------
    __VersionIndexOnVersionId(
        const TLSVersion* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //-------------------------------------------------
    __VersionIndexOnVersionId(
        const TLSVersion& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    __VersionIndexOnVersionId&
    operator=(const TLSVersion& v) {
        dwVersion = v.dwVersion;
        SetEmptyValue(FALSE);
        return *this;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() { return 1; }

    inline LPCTSTR
    GetIndexName() 
    {
        return pszIndexName;
    }

    inline LPCTSTR
    GetIndexKey() 
    {
        return pszIndexKey;
    }

    inline BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*
    */
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &(dwVersion);
        *cbData = sizeof(dwVersion);
        *grbit = JET_bitNewKey;
        return TRUE;
    }

} TLSVersionIndexVersionId;



//----------------------------------------------------------------------
class VersionTable : public TLSTable<TLSVersion> {

    static LPCTSTR pszTableName;

public:
    TLSColumnDword  dwVersion;
    TLSColumnText   szInstallId;
    TLSColumnBinary pbDomainSid;


    //------------------------------------------------
    virtual LPCTSTR
    GetTableName() {
        return pszTableName;
    }

    //------------------------------------------------
    VersionTable(
        JBDatabase& database
        ) : TLSTable<TLSVersion>(database)
    /*
    */
    {
    }

    //------------------------------------------------
    virtual BOOL
    ResolveToTableColumn();

    //----------------------------------------------------
    virtual BOOL
    FetchRecord(
        TLSVersion& v,
        DWORD dwParam=PROCESS_ALL_COLUMNS
    );

    //----------------------------------------------------
    BOOL
    InsertUpdateRecord(
        TLSVersion* v,
        DWORD dwParam=PROCESS_ALL_COLUMNS
    );
        
    //----------------------------------------------------
    virtual BOOL
    InsertRecord(
        TLSVersion& v,
        DWORD dwParam=PROCESS_ALL_COLUMNS
    );

    //----------------------------------------------------
    virtual BOOL
    UpdateRecord(
        TLSVersion& v,
        DWORD dwParam=PROCESS_ALL_COLUMNS
    );

    //----------------------------------------------------
    virtual BOOL
    Initialize() { return TRUE; }

    //----------------------------------------------------
    virtual JBKeyBase*    
    EnumerationIndex( 
        BOOL bMatchAll,
        DWORD dwParam,
        TLSVersion* pVersion,
        BOOL* bCompareKey
    );

    //----------------------------------------------------
    virtual BOOL
    EqualValue(
        TLSVersion& s1,
        TLSVersion& s2,
        BOOL bMatchAll,
        DWORD dwParam
    );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tlsdb\vertab.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       vertab.cpp 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include "version.h"

LPCTSTR __VersionIndexOnVersionId::pszIndexName = VERSION_ID_INDEXNAME;
LPCTSTR __VersionIndexOnVersionId::pszIndexKey = VERSION_ID_INDEXNAME_INDEXKEY;

//----------------------------------------------------
CCriticalSection VersionTable::g_TableLock;
LPCTSTR VersionTable::pszTableName = VERSION_TABLE_NAME;


//----------------------------------------------------
TLSJBIndex
VersionTable::g_TableIndex[] =
{
    {
        VERSION_ID_INDEXNAME,
        VERSION_ID_INDEXNAME_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    }
};

int 
VersionTable::g_NumTableIndex = sizeof(VersionTable::g_TableIndex) / sizeof(VersionTable::g_TableIndex[0]);

TLSJBColumn
VersionTable::g_Columns[] =
{
    {
        VERSION_TABLE_VERSION,
        JET_coltypLong,
        0,
        JET_bitColumnFixed | JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    {
        VERSION_TABLE_DOMAINID,
        JET_coltypLongBinary,
        TLSTABLE_MAX_BINARY_LENGTH,
        0,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    {
        VERSION_TABLE_INSTALLID,
        JB_COLTYPE_TEXT,
        (MAX_JETBLUE_TEXT_LENGTH + 1)*sizeof(TCHAR),
        0,
        JBSTRING_NULL,
        _tcslen(JBSTRING_NULL),
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    }
};

int
VersionTable::g_NumColumns=sizeof(VersionTable::g_Columns) / sizeof(VersionTable::g_Columns[0]);

//-------------------------------------------------------------
JBKeyBase* 
VersionTable::EnumerationIndex( 
    BOOL bMatchAll,
    DWORD dwSearchParam,
    TLSVersion* pVersion,
    BOOL* bCompareKey
    )
/*
*/
{
    // not expecting more than one row.
    *bCompareKey = (bMatchAll && (dwSearchParam & VERSION_TABLE_PROCESS_VERSION));
    
    return new TLSVersionIndexVersionId(pVersion);
}    

//------------------------------------------------------------
BOOL
VersionTable::EqualValue(
    TLSVersion& s1,
    TLSVersion& s2,
    BOOL bMatchAll,
    DWORD dwParam
    )
/*
*/
{
    BOOL bRetCode = TRUE;


    if(dwParam & VERSION_TABLE_PROCESS_VERSION)
    {
        bRetCode = (s1.dwVersion == s2.dwVersion);

        if(bRetCode != bMatchAll)
            goto cleanup;
    }

    if(dwParam & VERSION_TABLE_PROCESS_INSTALLID)
    {
        bRetCode = (_tcscmp(s1.szInstallId, s2.szInstallId) == 0);
        
        if(bRetCode != bMatchAll)
            goto cleanup;
    }

    //if(dwParam & VERSION_TABLE_PROCESS_DOMAINID)
    //{
    //    bRetCode = EqualSid(s1.pbDomainSid, s2.pbDomainSid);
    //}

cleanup:
    return bRetCode;
}

//----------------------------------------------------
BOOL
VersionTable::ResolveToTableColumn()
/*
*/
{
    m_JetErr = dwVersion.AttachToTable(
                            *this,
                            VERSION_TABLE_VERSION
                        );

    if(IsSuccess() == FALSE)
    {
        DebugOutput(
                _TEXT("Can't find column %s in table %s\n"),
                VERSION_TABLE_VERSION,
                GetTableName()
            );

        return FALSE;
    }
    
    m_JetErr = szInstallId.AttachToTable(
                            *this,
                            VERSION_TABLE_INSTALLID
                        );

    if(IsSuccess() == FALSE)
    {
        DebugOutput(
                _TEXT("Can't find column %s in table %s\n"),
                VERSION_TABLE_INSTALLID,
                GetTableName()
            );

        return FALSE;
    }

    m_JetErr = pbDomainSid.AttachToTable(
                            *this,
                            VERSION_TABLE_DOMAINID
                        );


    if(IsSuccess() == FALSE)
    {
        DebugOutput(
                _TEXT("Can't find column %s in table %s\n"),
                VERSION_TABLE_DOMAINID,
                GetTableName()
            );
    }


    return IsSuccess();
}

//----------------------------------------------------
BOOL
VersionTable::FetchRecord(
    TLSVersion& v,
    DWORD dwParam
    )
/*
*/
{    
    if(dwParam & VERSION_TABLE_PROCESS_VERSION)
    {
        m_JetErr = dwVersion.FetchColumnValue(
                                &(v.dwVersion),
                                sizeof(v.dwVersion),
                                0,
                                NULL
                            );
        REPORT_IF_FETCH_FAILED(GetTableName(),
                     VERSION_TABLE_VERSION,
                     m_JetErr);

        if(IsSuccess() == FALSE)
            goto cleanup;
    }

    if(dwParam & VERSION_TABLE_PROCESS_INSTALLID)
    {
        m_JetErr = szInstallId.FetchColumnValue(
                                v.szInstallId,
                                sizeof(v.szInstallId),
                                0,
                                NULL
                            );
        REPORT_IF_FETCH_FAILED(
                GetTableName(),
                VERSION_TABLE_INSTALLID,
                m_JetErr
            );

        if(IsSuccess() == FALSE)
            goto cleanup;
    }

#if 0
    if(dwParam & VERSION_TABLE_PROCESS_DOMAINID)
    {
        DWORD size;

        m_JetErr = pbDomainSid.FetchColumnValue(
                                NULL,
                                0,
                                0,
                                &size
                            );
        
        if(size > v.cbDomainSid || v.pbDomainSid == NULL)
        {
            FreeMemory(v.pbDomainSid);

            v.pbDomainSid = (PBYTE)AllocateMemory(v.cbDomainSid = size);
            if(v.pbDomainSid == NULL)
            {
                SetLastJetError(JET_errOutOfMemory);
                goto cleanup;
            }
        }

        m_JetErr = pbDomainSid.FetchColumnValue(
                                v.pbDomainSid,
                                v.cbDomainSid,
                                0,
                                &v.cbDomainSid
                            );

        REPORT_IF_FETCH_FAILED(
                GetTableName(),
                VERSION_TABLE_DOMAINID,
                m_JetErr
            );
    }
#endif

cleanup:
    return IsSuccess();
}

//----------------------------------------------------
BOOL
VersionTable::InsertUpdateRecord(
    TLSVersion* v,
    DWORD dwParam
    )
/*
*/
{
    if(dwParam & VERSION_TABLE_PROCESS_VERSION)
    {
        m_JetErr = dwVersion.InsertColumnValue(
                                    &(v->dwVersion),
                                    sizeof(v->dwVersion),
                                    0
                                );
        REPORT_IF_INSERT_FAILED(GetTableName(),
                     VERSION_TABLE_VERSION,
                     m_JetErr);

        if(IsSuccess() == FALSE)
            goto cleanup;
    }

    if(dwParam & VERSION_TABLE_PROCESS_INSTALLID)
    {
        m_JetErr = szInstallId.InsertColumnValue(
                                    v->szInstallId,
                                    _tcslen(v->szInstallId) * sizeof(TCHAR),
                                    0
                                );
        REPORT_IF_INSERT_FAILED(
                GetTableName(),
                VERSION_TABLE_INSTALLID,
                m_JetErr
            );

        if(IsSuccess() == FALSE)
            goto cleanup;
    }

    #if 0
    // no more domain SID
    if(dwParam & VERSION_TABLE_PROCESS_DOMAINID)
    {
        m_JetErr = pbDomainSid.InsertColumnValue(
                                    v->pbDomainSid,
                                    v->cbDomainSid,
                                    0
                                );

        REPORT_IF_INSERT_FAILED(
                GetTableName(),
                VERSION_TABLE_DOMAINID,
                m_JetErr
            );
    }
    #endif


cleanup:
    return IsSuccess();
}
    
//----------------------------------------------------
BOOL
VersionTable::InsertRecord(
    TLSVersion& v,
    DWORD dwParam
    )
/*
*/
{
    if(BeginUpdate(FALSE) == FALSE)
        return FALSE;

    InsertUpdateRecord(&v, dwParam);
    EndUpdate(IsSuccess() == FALSE);
    return IsSuccess();
}

//----------------------------------------------------
BOOL
VersionTable::UpdateRecord(
    TLSVersion& v,
    DWORD dwParam
    )
/*
*/
{
    if(BeginUpdate(TRUE) == FALSE)
        return FALSE;

    InsertUpdateRecord(&v, dwParam);

    EndUpdate(IsSuccess() == FALSE);
    return IsSuccess();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tlsdb\workitem.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        workitem.cpp
//
// Contents:    workitem Table
//
// History:     
//              
//---------------------------------------------------------------------------
#include "workitem.h"


//----------------------------------------------------
CCriticalSection WorkItemTable::g_TableLock;

//----------------------------------------------------
TLSJBIndex
WorkItemTable::g_TableIndex[] =
{
    {
        WORKITEM_INDEX_JOBTIME_INDEXNAME,
        WORKITEM_INDEX_JOBTIME_INDEXKEY,
        -1,
        JET_bitIndexIgnoreNull,
        TLSTABLE_INDEX_DEFAULT_DENSITY
    }
};

int 
WorkItemTable::g_NumTableIndex = sizeof(WorkItemTable::g_TableIndex) / sizeof(WorkItemTable::g_TableIndex[0]);

TLSJBColumn
WorkItemTable::g_Columns[] =
{
    {
        WORKITEM_COLUMN_JOBTIME,
        JET_coltypLong,
        sizeof(DWORD),
        JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    {
        WORKITEM_COLUMN_JOBRESTARTTIME,
        JET_coltypLong,
        sizeof(DWORD),
        JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    {
        WORKITEM_COLUMN_JOBTYPE,
        JET_coltypLong,
        0,
        JET_bitColumnNotNULL,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    },

    {
        WORKITEM_COLUMN_DATA,
        JET_coltypLongBinary,
        WORKITEM_MAX_DATA_SIZE, // 0x8FFFFFFF,     // no limit on data size.
        0,
        NULL,
        0,
        TLS_JETBLUE_COLUMN_CODE_PAGE,
        TLS_JETBLUE_COLUMN_COUNTRY_CODE,
        TLS_JETBLUE_COLUMN_LANGID
    }
};

int
WorkItemTable::g_NumColumns=sizeof(WorkItemTable::g_Columns) / sizeof(WorkItemTable::g_Columns[0]);

//-------------------------------------------------------------
JBKeyBase* 
WorkItemTable::EnumerationIndex( 
    BOOL bMatchAll,
    DWORD dwSearchParam,
    WORKITEMRECORD* pRecord,
    BOOL* bCompareKey
    )
/*
*/
{
    *bCompareKey = bMatchAll;
    return new TLSWorkItemIdxModifyTime(pRecord);
}    

//------------------------------------------------------------
BOOL
WorkItemTable::EqualValue(
    WORKITEMRECORD& s1,
    WORKITEMRECORD& s2,
    BOOL bMatchAll,
    DWORD dwParam
    )
/*
*/
{
    BOOL bRetCode = TRUE;


    if(dwParam & WORKITEM_PROCESS_JOBTIME)
    {
        bRetCode = (s1.dwScheduledTime == s2.dwScheduledTime);
        if(bRetCode != bMatchAll)
            goto cleanup;
    }

    if(dwParam & WORKITEM_PROCESS_JOBRESTARTTIME)
    {
        bRetCode = (s1.dwRestartTime == s2.dwRestartTime);
        if(bRetCode != bMatchAll)
            goto cleanup;
    }

    if(dwParam & WORKITEM_PROCESS_JOBTYPE)
    {
        bRetCode = (s1.dwJobType == s2.dwJobType);
        if(bRetCode != bMatchAll)
            goto cleanup;
    }

    //
    // process data must accompany by process data size.
    //
    if(dwParam & WORKITEM_PROCESS_DATA)
    {
        bRetCode = (s1.cbData == s2.cbData);
        if(bRetCode != bMatchAll)
            goto cleanup;

        bRetCode = (memcmp(s1.pbData, s2.pbData, s1.cbData) == 0);
    }

cleanup:
    return bRetCode;
}

//----------------------------------------------------
BOOL
WorkItemTable::ResolveToTableColumn()
/*
*/
{
    m_JetErr = dwScheduledTime.AttachToTable(
                            *this,
                            WORKITEM_COLUMN_JOBTIME
                        );

    if(IsSuccess() == FALSE)
    {
        DebugOutput(
                _TEXT("Can't find column %s in table %s\n"),
                WORKITEM_COLUMN_JOBTIME,
                GetTableName()
            );

        goto cleanup;
    }

    m_JetErr = dwRestartTime.AttachToTable(
                            *this,
                            WORKITEM_COLUMN_JOBRESTARTTIME
                        );

    if(IsSuccess() == FALSE)
    {
        DebugOutput(
                _TEXT("Can't find column %s in table %s\n"),
                WORKITEM_COLUMN_JOBRESTARTTIME,
                GetTableName()
            );

        goto cleanup;
    }
    
    m_JetErr = dwJobType.AttachToTable(
                            *this,
                            WORKITEM_COLUMN_JOBTYPE
                        );

    if(IsSuccess() == FALSE)
    {
        DebugOutput(
                _TEXT("Can't find column %s in table %s\n"),
                WORKITEM_COLUMN_JOBTYPE,
                GetTableName()
            );

        goto cleanup;
    }

    m_JetErr = pbData.AttachToTable(
                            *this,
                            WORKITEM_COLUMN_DATA
                        );

    if(IsSuccess() == FALSE)
    {
        DebugOutput(
                _TEXT("Can't find column %s in table %s\n"),
                WORKITEM_COLUMN_DATA,
                GetTableName()
            );
    }

cleanup:
    return IsSuccess();
}

//----------------------------------------------------
CLASS_PRIVATE BOOL
WorkItemTable::ProcessSingleColumn(
    IN BOOL bFetch,
    IN TLSColumnBase& column,
    IN DWORD offset,
    IN PVOID pbData,
    IN DWORD cbData,
    IN PDWORD pcbDataReturn,
    IN LPCTSTR szColumnName
    )
/*

Abstract:

    Fetch/Insert/Update a particular column.

Parameter:

    bFetch - TRUE if fetch, FALSE if update/insert.
    column - Intended column for operation, reference pointer to TLSColumn
    szColumnName - name of the column, for debugging print purpose only

Returns:

    TRUE if successful, FALSE otherwise.
*/
{
    if(bFetch) 
    {
        m_JetErr = column.FetchColumnValue(
                                    pbData, 
                                    cbData, 
                                    offset, 
                                    pcbDataReturn
                                );
    }
    else
    {
        m_JetErr = column.InsertColumnValue(
                                    pbData, 
                                    cbData, 
                                    offset
                                );
    }

    REPORTPROCESSFAILED(
            bFetch,
            GetTableName(),
            szColumnName,
            m_JetErr
        );
    return IsSuccess();
}

//---------------------------------------------------------
CLASS_PRIVATE BOOL
WorkItemTable::ProcessRecord(
    WORKITEMRECORD* pRecord,
    BOOL bFetch,
    DWORD dwParam,
    BOOL bUpdate
    )
/*
*/
{ 
    DWORD dwSize;

    if(bFetch == FALSE)
    {
        BeginUpdate(bUpdate);

        if(!(dwParam & WORKITEM_PROCESS_JOBTIME))
        {
            JB_ASSERT(FALSE);
            dwParam |= WORKITEM_PROCESS_JOBTIME;
        }
    }
    else
    {
        SetLastJetError(JET_errSuccess);
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    if(dwParam & WORKITEM_PROCESS_JOBTIME)
    {
        ProcessSingleColumn(
                    bFetch,
                    dwScheduledTime,
                    0,
                    &(pRecord->dwScheduledTime),
                    sizeof(pRecord->dwScheduledTime),
                    &dwSize,
                    WORKITEM_COLUMN_JOBTIME
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    if(dwParam & WORKITEM_PROCESS_JOBRESTARTTIME)
    {
        ProcessSingleColumn(
                    bFetch,
                    dwRestartTime,
                    0,
                    &(pRecord->dwRestartTime),
                    sizeof(pRecord->dwRestartTime),
                    &dwSize,
                    WORKITEM_COLUMN_JOBRESTARTTIME
                );
    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    
    if(dwParam & WORKITEM_PROCESS_JOBTYPE)
    {
        ProcessSingleColumn(
                    bFetch,
                    dwJobType,
                    0,
                    &(pRecord->dwJobType),
                    sizeof(pRecord->dwJobType),
                    &dwSize,
                    WORKITEM_COLUMN_JOBTYPE
                );

    }

    if(IsSuccess() == FALSE)
        goto cleanup;            

    if(dwParam & WORKITEM_PROCESS_DATA)
    {
        if(bFetch == TRUE)
        {
            m_JetErr = pbData.FetchColumnValue(
                                        NULL,
                                        0,
                                        0,
                                        &dwSize  // &pRecord->cbData
                                    );

            if( pRecord->pbData == NULL || pRecord->cbData < dwSize )
            {
                if( pRecord->pbData != NULL )
                {
                    FreeMemory(pRecord->pbData);
                    pRecord->pbData = NULL;
                }
                   
                pRecord->pbData = (PBYTE)AllocateMemory(dwSize);
                if(pRecord->pbData == NULL)
                {
                    pRecord->cbData = 0;
                    SetLastJetError(JET_errOutOfMemory);
                    goto cleanup;
                }

                pRecord->cbData = dwSize;
            }

            //
            // actual memory allocated might be bigger then pRecord->cbData
            //
            m_JetErr = pbData.FetchColumnValue(
                                        pRecord->pbData,
                                        pRecord->cbData,
                                        0,
                                        &pRecord->cbData
                                    );
        }
        else
        {
            ProcessSingleColumn(
                        bFetch,
                        pbData,
                        0,
                        pRecord->pbData,
                        pRecord->cbData,
                        &dwSize,
                        WORKITEM_COLUMN_DATA
                    );
        }
    }

cleanup:
    // 
    // For inserting/updating record
    if(bFetch == FALSE)
    {
        JET_ERR jetErr;
        jetErr = GetLastJetError();

        EndUpdate(IsSuccess() == FALSE);

        if(jetErr != JET_errSuccess  && IsSuccess() == FALSE)
            SetLastJetError(jetErr);
    }

    return IsSuccess();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\tlsdb\workitem.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        workitem.h
//
// Contents:    backupsource Table
//
// History:     
//              
//---------------------------------------------------------------------------
#ifndef __WORKITEM_H__
#define __WORKITEM_H__
#include "tlsdb.h"

//
//
#define WORKITEM_PROCESS_JOBTIME                0x00000001
#define WORKITEM_PROCESS_JOBRESTARTTIME         (WORKITEM_PROCESS_JOBTIME << 1)
#define WORKITEM_PROCESS_JOBTYPE                (WORKITEM_PROCESS_JOBTIME << 2)
#define WORKITEM_PROCESS_DATA                   (WORKITEM_PROCESS_JOBTIME << 3)

//
// Table structure
//
#define WORKITEM_TABLE_NAME                     _TEXT("WorkStorage")
#define WORKITEM_COLUMN_JOBTIME                 _TEXT("ScheduledTime")
#define WORKITEM_COLUMN_JOBRESTARTTIME          _TEXT("RestartTime")
#define WORKITEM_COLUMN_JOBTYPE                 _TEXT("JobType")
#define WORKITEM_COLUMN_DATA                    _TEXT("Data")

#define WORKITEM_MAX_DATA_SIZE                  16 * 1024  // max of 32 K 

typedef struct __WorkItemRecord : public TLSReplWorkItem 
{
    __WorkItemRecord&
    operator=(const __WorkItemRecord& v)
    {
        DWORD bSuccess;

        PBYTE pbOldData=pbData;
        DWORD cbOldData=cbData;

        if(this == &v)
            return *this;

        *(TLSReplWorkItem *)this = *(TLSReplWorkItem *)&v;
        
        pbData = pbOldData;
        cbData = cbOldData;

        bSuccess = TLSDBCopyBinaryData(
                        v.pbData,
                        v.cbData,
                        &pbData,
                        &cbData
                    );

        JB_ASSERT(bSuccess == TRUE);
        return *this;
    }        

    __WorkItemRecord&
    operator=(const TLSReplWorkItem& v)
    {
        DWORD bSuccess;

        PBYTE pbOldData=pbData;
        DWORD cbOldData=cbData;

        *(TLSReplWorkItem *)this = *(TLSReplWorkItem *)&v;
        
        pbData = pbOldData;
        cbData = cbOldData;

        bSuccess = TLSDBCopyBinaryData(
                        v.pbData,
                        v.cbData,
                        &pbData,
                        &cbData
                    );

        JB_ASSERT(bSuccess == TRUE);
        return *this;
    }        

    __WorkItemRecord() 
    {
        pbData = NULL;
        cbData = 0;
    }

    ~__WorkItemRecord() 
    {
        if(pbData)
        {
            FreeMemory(pbData);
        }
    }
} WORKITEMRECORD;

typedef WORKITEMRECORD* LPWORKITEMRECORD;
typedef WORKITEMRECORD* PWORKITEMRECORD;


/////////////////////////////////////////////////////////
//
// Index structure
//
/////////////////////////////////////////////////////////

// 
//
#define WORKITEM_INDEX_JOBTIME_INDEXNAME \
    WORKITEM_TABLE_NAME SEPERATOR WORKITEM_COLUMN_JOBTIME SEPERATOR INDEXNAME

//
// Primary Index on KeyPack ID "+KeyPackId\0"
//
#define WORKITEM_INDEX_JOBTIME_INDEXKEY \
    INDEX_SORT_ASCENDING WORKITEM_COLUMN_JOBTIME INDEX_END_COLNAME

typedef struct __WorkItemIdxOnJobTime : public JBKeyBase {
    DWORD dwScheduledTime;

    //--------------------------------------------------------
    __WorkItemIdxOnJobTime(
        const WORKITEMRECORD& v
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        *this = v;
    }

    //--------------------------------------------------------
    __WorkItemIdxOnJobTime(
        const WORKITEMRECORD* v=NULL
        ) : 
        JBKeyBase() 
    /*++
    ++*/
    {
        if(v)
        {
            *this = *v;
        }
    }

    //--------------------------------------------------------
    __WorkItemIdxOnJobTime&
    operator=(const WORKITEMRECORD& v) 
    {
        dwScheduledTime = v.dwScheduledTime;
        SetEmptyValue(FALSE);
        return *this;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexName() 
    {
        static LPTSTR pszIndexName=WORKITEM_INDEX_JOBTIME_INDEXNAME;
        return pszIndexName;
    }

    //--------------------------------------------------------
    LPCTSTR
    GetIndexKey() 
    {
        static LPTSTR pszIndexKey=WORKITEM_INDEX_JOBTIME_INDEXKEY;
        return pszIndexKey;
    }

    //--------------------------------------------------------
    DWORD
    GetNumKeyComponents() 
    { 
        return 1; 
    }

    //--------------------------------------------------------
    BOOL
    GetSearchKey(
        DWORD dwComponentIndex,
        PVOID* pbData,
        unsigned long* cbData,
        JET_GRBIT* grbit,
        DWORD dwSearchParm
        )
    /*++
    ++*/
    {
        if(dwComponentIndex >= GetNumKeyComponents())
        {
            JB_ASSERT(FALSE);
            return FALSE;
        }

        *pbData = &dwScheduledTime;
        *cbData = sizeof(dwScheduledTime);
        *grbit = JET_bitNewKey;
        return TRUE;
    }
} TLSWorkItemIdxModifyTime;

// -----------------------------------------------------------
//
//  LicensedPackStatus Table
//
// -----------------------------------------------------------
class WorkItemTable : public TLSTable<WORKITEMRECORD>  {
private:

    BOOL
    ProcessSingleColumn(
        BOOL bFetch,
        TLSColumnBase& column,
        DWORD offset,
        PVOID pbData,
        DWORD cbData,
        PDWORD pcbDataReturn,
        LPCTSTR szColumnName
    );

    BOOL
    ProcessRecord(
        WORKITEMRECORD* v,
        BOOL bFetch,        // TRUE - fetch, FALSE insert
        DWORD dwParam,
        BOOL bUpdate
    );    

public:
    TLSColumnDword      dwScheduledTime;
    TLSColumnDword      dwRestartTime;
    TLSColumnDword      dwJobType;
    TLSColumnBinary     pbData;

    //-----------------------------------------------------
    virtual LPCTSTR
    GetTableName() 
    {
        static LPTSTR pszTableName=WORKITEM_TABLE_NAME;
        return pszTableName;
    }
   

    //-----------------------------------------------------
    WorkItemTable(
        JBDatabase& database
        ) : 
        TLSTable<WORKITEMRECORD>(database)
    /*
    */
    {
    }

    //-----------------------------------------------------
    virtual BOOL
    ResolveToTableColumn();

    //-----------------------------------------------------
    virtual BOOL
    FetchRecord(
        WORKITEMRECORD& v,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&v, TRUE, dwParam, FALSE);
    }

    //-----------------------------------------------------
    virtual BOOL
    InsertRecord(
        WORKITEMRECORD& v,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&v, FALSE, dwParam, FALSE);
    }

    //-----------------------------------------------------
    virtual BOOL
    UpdateRecord(
        WORKITEMRECORD& v,
        DWORD dwParam=PROCESS_ALL_COLUMNS
        )
    /*
    */
    {
        if(IsValid() == FALSE)
        {
            DebugOutput( 
                    _TEXT("Table %s is not valid...\n"),
                    GetTableName()
                );

            JB_ASSERT(FALSE);
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }

        //CCriticalSectionLocker Lock(GetTableLock());

        return ProcessRecord(&v, FALSE, dwParam, TRUE);
    }

    //-------------------------------------------------------
    virtual BOOL
    Initialize() 
    { 
        return TRUE; 
    }

    //-------------------------------------------------------
    virtual JBKeyBase*
    EnumerationIndex( 
        IN BOOL bMatchAll,
        IN DWORD dwParam,
        IN WORKITEMRECORD* kp,
        IN OUT BOOL* bCompareKey
    );
    
    virtual BOOL
    EqualValue(
        WORKITEMRECORD& s1,
        WORKITEMRECORD& s2,
        BOOL bMatchAll,
        DWORD dwParam
    );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\upg4to5\hydra4db.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       hydra4db.h 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __HYDRA4_DB_H__
#define __HYDRA4_DB_H__

#include "license.h"

//----------------------------------------------------------------------
//
// NT4 Hydra specific
//
//
#define NT4SZSERVICENAME               _TEXT("TermServLicensing")

#define NT4LSERVER_DEFAULT_DSN         _TEXT("Hydra License")
#define NT4LSERVER_DEFAULT_USER        _TEXT("sa")
#define NT4LSERVER_DEFAULT_PWD         _TEXT("password")

//---------------------------------------------------------------------------
//
// Server specified Registry Entry
//
#define NT4LSERVER_REGISTRY_BASE  \
    _TEXT("SYSTEM\\CurrentControlSet\\Services")

#define NT4LSERVER_PARAMETERS \
    _TEXT("Parameters")

#define NT4LSERVER_REGKEY \
    NT4LSERVER_REGISTRY_BASE _TEXT("\\") NT4SZSERVICENAME _TEXT("\\") NT4LSERVER_PARAMETERS

#define NT4LSERVER_PARAMETERS_DSN       _TEXT("Dsn")
#define NT4LSERVER_PARAMETERS_USER      _TEXT("User")

#ifdef __cplusplus
extern "C" {
#endif

DWORD 
GetNT4DbConfig(
    LPTSTR pszDsn,
    LPTSTR pszUserName,
    LPTSTR pszPwd,
    LPTSTR pszMdbFile
);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\trust\trust.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       trust.cpp 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include <windows.h>
#include <wincrypt.h>
#include <tchar.h>
#include <stdlib.h>
#include "license.h"
#include "tlsapip.h"
#include "trust.h"


LPCTSTR g_pszServerGuid = _TEXT("d63a773e-6799-11d2-96ae-00c04fa3080d");
const DWORD g_cbServerGuid = (_tcslen(g_pszServerGuid) * sizeof(TCHAR));

LPCTSTR g_pszLrWizGuid = _TEXT("d46b4bf2-686d-11d2-96ae-00c04fa3080d");
const DWORD g_cbLrWizGuid = (_tcslen(g_pszLrWizGuid) * sizeof(TCHAR));

//----------------------------------------------------------------

DWORD
HashChallengeData(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwClientType,
    IN DWORD dwRandom,
    IN PBYTE pbChallengeData,
    IN DWORD cbChallengeData,
    IN PBYTE pbReserved,
    IN DWORD cbReserved,
    OUT PBYTE* ppbHashedData,
    OUT PDWORD pcbHashedData
    )

/*++


--*/

{
    DWORD dwStatus = ERROR_SUCCESS;
    HCRYPTHASH hCryptHash = NULL;

    PBYTE pbHashData = NULL;
    DWORD cbHashData = 0;

    DWORD cbHashGuidSize;
    LPCTSTR pszHashGuid;

    BOOL bSuccess;



    //
    // Generate MD5 hash
    //
    bSuccess = CryptCreateHash(
                            hCryptProv, 
                            CALG_MD5, 
                            0, 
                            0, 
                            &hCryptHash
                        );

    if(bSuccess == FALSE)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    //
    // Pick the right hash type
    //
    if(dwClientType == CLIENT_TYPE_LRWIZ)
    {
        pszHashGuid = g_pszLrWizGuid;
        cbHashGuidSize = g_cbLrWizGuid;
    }
    else
    {
        pszHashGuid = g_pszServerGuid;
        cbHashGuidSize = g_cbServerGuid;
    }

    //
    // TODO : Consider hash a few times...
    //
    bSuccess = CryptHashData(
                            hCryptHash,
                            (PBYTE) pbChallengeData,
                            dwRandom,
                            0
                        );

    if(bSuccess == FALSE)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }


    bSuccess = CryptHashData( 
                            hCryptHash,
                            (PBYTE) pszHashGuid,
                            cbHashGuidSize,
                            0
                        );
    
    if(bSuccess == FALSE)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }


    bSuccess = CryptHashData(
                            hCryptHash,
                            (PBYTE) pbChallengeData + dwRandom,
                            cbChallengeData - dwRandom,
                            0
                        );

    if(bSuccess == FALSE)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    
    //
    // Get the size of hased data
    //
    bSuccess = CryptGetHashParam(
                            hCryptHash,
                            HP_HASHVAL,
                            NULL,
                            &cbHashData,
                            0
                        ); 

    if(bSuccess == FALSE && GetLastError() != ERROR_MORE_DATA)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    pbHashData = (PBYTE)LocalAlloc(LPTR, cbHashData);
    if(pbHashData == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    bSuccess = CryptGetHashParam(
                            hCryptHash,
                            HP_HASHVAL,
                            pbHashData,
                            &cbHashData,
                            0
                        );

    if(bSuccess == FALSE)
    {
        dwStatus = GetLastError();
    }

cleanup:

    if(hCryptHash)
    {
        CryptDestroyHash( hCryptHash );
    }

    if(dwStatus == ERROR_SUCCESS)
    {
        *ppbHashedData = pbHashData;
        *pcbHashedData = cbHashData;
        pbHashData = NULL;
    }

    if(pbHashData != NULL)
    {
        LocalFree(pbHashData);
    }

    return dwStatus;

}

//----------------------------------------------------------------

DWORD WINAPI
TLSVerifyChallengeResponse(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwClientType,
    IN PTLSCHALLENGEDATA pClientChallengeData,
    IN PTLSCHALLENGERESPONSEDATA pServerChallengeResponseData
    )
/*++

--*/

{
    DWORD dwStatus = ERROR_SUCCESS;
    PBYTE pbData = NULL;
    DWORD cbData = 0;
    
    //
    // base on our challenge data, generate a corresponding
    // hash data
    //
    dwStatus = HashChallengeData(
                        hCryptProv,
                        dwClientType,
                        pClientChallengeData->dwRandom,
                        pClientChallengeData->pbChallengeData,
                        pClientChallengeData->cbChallengeData,
                        pClientChallengeData->pbReservedData,
                        pClientChallengeData->cbReservedData,
                        &pbData,
                        &cbData
                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

                        
    //
    // Compare our hash with response data
    //
    if(pServerChallengeResponseData->cbResponseData != cbData)
    {
        dwStatus = ERROR_INVALID_DATA;
    }

    if(memcmp(pServerChallengeResponseData->pbResponseData, pbData, cbData) != 0)
    {
        dwStatus = ERROR_INVALID_DATA;
    }

cleanup:

    if(pbData != NULL)
        LocalFree(pbData);        
    
    return dwStatus;
}


//----------------------------------------------------------------

DWORD
TLSGenerateChallengeResponseData(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwClientType,
    IN PTLSCHALLENGEDATA pChallengeData,
    OUT PBYTE* pbResponseData,
    OUT PDWORD cbResponseData
    )

/*++


--*/

{
    DWORD dwStatus = ERROR_SUCCESS;

    dwStatus = HashChallengeData(
                            hCryptProv,
                            dwClientType,
                            pChallengeData->dwRandom,
                            pChallengeData->pbChallengeData,
                            pChallengeData->cbChallengeData,
                            pChallengeData->pbReservedData,
                            pChallengeData->cbReservedData,
                            pbResponseData,
                            cbResponseData
                        );

    return dwStatus;
}


//----------------------------------------------------------------

DWORD WINAPI
TLSGenerateRandomChallengeData(
    IN HCRYPTPROV hCryptProv,
    IN PBYTE* ppbChallengeData,
    IN PDWORD pcbChallengeData
    )

/*++

Abstract:

    Generate two random 128 bit challenge data and concatenate it 
    before returning.

Parameters:

    hCryptProv : Crypto. provider.
    pcbChallengeData :  Pointer to DWORD receiving size 
                        of challenge data.
    ppbChallengeData :  Pointer to BYTE receiving randomly 
                        generated challege data.

Returns:

    ERROR_SUCCESS or error code.

Note:

    All memory allocation via LocalAlloc(). 

--*/

{
    DWORD dwLen = RANDOM_CHALLENGE_DATASIZE;
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bSuccess;
    PBYTE pbRandomData = NULL;

    if( ppbChallengeData == NULL || 
        pcbChallengeData == NULL ||
        hCryptProv == NULL )
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }
    
    pbRandomData = (PBYTE)LocalAlloc(LPTR, dwLen * 2);
    if(pbRandomData == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    //
    // generate two random 128 bit data
    //
    bSuccess = CryptGenRandom(
                            hCryptProv,
                            dwLen,
                            pbRandomData
                        );
        
    if(bSuccess == TRUE)
    {
        memcpy(
                pbRandomData + dwLen, 
                pbRandomData,
                dwLen
            );

        bSuccess = CryptGenRandom(
                                hCryptProv,
                                dwLen,
                                pbRandomData + dwLen
                            );
    }        

    if(bSuccess == FALSE)
    {
        dwStatus = GetLastError();
    }

cleanup:

    if(dwStatus == ERROR_SUCCESS)
    {
        *ppbChallengeData = pbRandomData;
        *pcbChallengeData = dwLen * 2;
    }
    else
    {
        if(pbRandomData != NULL)
        {
            LocalFree(pbRandomData);
        }
    }

    return dwStatus;
}

//----------------------------------------------------------------

DWORD WINAPI
TLSEstablishTrustWithServer(
    IN TLS_HANDLE hHandle,
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwClientType,
    OUT PDWORD pdwErrCode
    )
/*++

Abstract:

    Establish trust relationship with License Server, trust is 
    based on two way challenge/response.  License Server and LrWiz 
    can't use certificate-base trust verification as anyone can get 
    TermSrv certificate from registry and also be the administrator 
    of system to invoke server side administrative RPC call to mess 
    up license server setup.  This challenge/response scheme should be 
    kept secret (user can reverse engineer to figure out our algorithm
    but this user probably smart enough to alter executable to return 
    SUCCESS in all case too.)

Parameters:

    hHandle : Connection handle to License Server.
    hCryptProv : handle to CSP to do hashing.
    dwClientType : Caller type, License Server, LrWiz, or TermSrv.
    pdwErrCode : Pointer to DWORD to receive License Server return code.

Return:

    ERROR_SUCCESS or RPC error code. Caller should also verify pdwErrCode.

Note:

    TermSrv's certificate is issued by license server.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    PBYTE pbClientRandomChallengeData = NULL;
    DWORD cbClientRandomChallengeData = 0;

    PBYTE pbChallengeResponseData = NULL;
    DWORD cbChallengeResponseData = 0;
    
    TLSCHALLENGEDATA ClientChallengeData;
    TLSCHALLENGERESPONSEDATA* pServerChallengeResponseData=NULL;

    TLSCHALLENGEDATA* pServerChallengeData=NULL;
    TLSCHALLENGERESPONSEDATA ClientChallengeResponseData;

    //
    // Verify input parameters
    //
    if(hHandle == NULL || hCryptProv == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    //
    // Only three type supported
    //
    if( dwClientType != CLIENT_TYPE_TLSERVER &&
        dwClientType != CLIENT_TYPE_LRWIZ &&
        dwClientType != CLIENT_TYPE_TERMSRV )
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    //
    // Generate a random challenge data 
    //
    dwStatus = TLSGenerateRandomChallengeData(
                                    hCryptProv,
                                    &pbClientRandomChallengeData,
                                    &cbClientRandomChallengeData
                                );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    // 
    //
    memset(
            &ClientChallengeData,
            0,
            sizeof(TLSCHALLENGEDATA)
        );

    memset(
            &ClientChallengeResponseData,
            0,
            sizeof(TLSCHALLENGERESPONSEDATA)
        );

    //
    // Send this challenge data to server
    //
    ClientChallengeData.dwVersion = TLS_CURRENT_CHALLENGE_VERSION;

    if (!CryptGenRandom(hCryptProv,sizeof(ClientChallengeData.dwRandom), (BYTE *)&(ClientChallengeData.dwRandom))) {
        dwStatus = GetLastError();
        goto cleanup;
	}

    //
    // This must range from 1 to 128, as it's used as an offset into the
    // challenge data buffer
    //

    ClientChallengeData.dwRandom %= RANDOM_CHALLENGE_DATASIZE;
    ClientChallengeData.dwRandom++;

    ClientChallengeData.cbChallengeData = cbClientRandomChallengeData;
    ClientChallengeData.pbChallengeData = pbClientRandomChallengeData;

    dwStatus = TLSChallengeServer(
                                hHandle,
                                dwClientType,
                                &ClientChallengeData,
                                &pServerChallengeResponseData,
                                &pServerChallengeData,
                                pdwErrCode
                            );

    if(dwStatus != RPC_S_OK || *pdwErrCode >= LSERVER_ERROR_BASE)
    {
        goto cleanup;
    }

    if(pServerChallengeResponseData == NULL || pServerChallengeData == NULL)
    {
        dwStatus = LSERVER_E_INTERNAL_ERROR;
        goto cleanup;
    }

    //
    // Verify Server Challege Data.
    //
    dwStatus = TLSVerifyChallengeResponse(
                                    hCryptProv,
                                    dwClientType,
                                    &ClientChallengeData,
                                    pServerChallengeResponseData
                                );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    // Generate Client side responses data
    //
    dwStatus = TLSGenerateChallengeResponseData(
                                        hCryptProv,
                                        dwClientType,
                                        pServerChallengeData,
                                        &pbChallengeResponseData,
                                        &cbChallengeResponseData
                                    );
    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }


    //
    // Response to server's challenge
    //
    ClientChallengeResponseData.dwVersion = TLS_CURRENT_CHALLENGE_VERSION;
    ClientChallengeResponseData.cbResponseData = cbChallengeResponseData;
    ClientChallengeResponseData.pbResponseData = pbChallengeResponseData;

    dwStatus = TLSResponseServerChallenge(
                                    hHandle,
                                    &ClientChallengeResponseData,
                                    pdwErrCode
                                );

cleanup:
    //
    // Cleanup memory allocated.
    //
    if(pbClientRandomChallengeData != NULL)
    {
        LocalFree(pbClientRandomChallengeData);
    }

    if(pbChallengeResponseData != NULL)
    {
        LocalFree(pbChallengeResponseData);
    }

    if(pServerChallengeData != NULL)
    {
        if(pServerChallengeData->pbChallengeData)
        {
            midl_user_free(pServerChallengeData->pbChallengeData);
        }

        if(pServerChallengeData->pbReservedData)
        {
            midl_user_free(pServerChallengeData->pbReservedData);
        }

        midl_user_free(pServerChallengeData);
    }

    if(pServerChallengeResponseData != NULL)
    {
        if(pServerChallengeResponseData->pbResponseData)
        {
            midl_user_free(pServerChallengeResponseData->pbResponseData);
        }

        if(pServerChallengeResponseData->pbReservedData)
        {
            midl_user_free(pServerChallengeResponseData->pbReservedData);
        }
    
        midl_user_free(pServerChallengeResponseData);
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\upg4to5\dbsetup.c ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:
//
// Contents:    
//
// History:     
//---------------------------------------------------------------------------
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <odbcinst.h>



#define szSQLSetConfigMode              "SQLSetConfigMode"

//---------------------------------------------------------------------------
// various installation routine we use, can't link with library as it will
// cause 
#ifdef  UNICODE
#define  szSQLInstallDriver             "SQLInstallDriverW"
#define  szSQLGetInstalledDrivers       "SQLGetInstalledDriversW"
#define  szSQLConfigDataSource          "SQLConfigDataSourceW"
#define  szSQLGetPrivateProfileString   "SQLGetPrivateProfileStringW"
#define  szSQLConfigDriver              "SQLConfigDriverW"
#define  szSQLInstallerError            "SQLInstallerErrorW"
#else
#define  szSQLInstallDriver             "SQLInstallDriver"
#define  szSQLGetInstalledDrivers       "SQLGetInstalledDrivers"
#define  szSQLConfigDataSource          "SQLConfigDataSource"
#define  szSQLGetPrivateProfileString   "SQLGetPrivateProfileString"
#define  szSQLConfigDriver              "SQLConfigDriver"
#define  szSQLInstallerError            "SQLInstallerError"
#endif

//
// ODBC install functions - To prevent system to 'force' odbccp32.dll
// odbccp32 may not present on the system nor it is available at the 
// time setup got kick off.
//
typedef BOOL (* SQLCONFIGDATASOURCE)(HWND, WORD, LPCTSTR, LPCTSTR);

typedef SQLRETURN (* SQLINSTALLERERROR)(WORD , DWORD*, LPTSTR, WORD, WORD*);

typedef int (* SQLGETPRIVATEPROFILESTRING)( LPCTSTR lpszSection,
                                            LPCTSTR lpszEntry,
                                            LPCTSTR lpszDefault,
                                            LPTSTR  lpszRetBuffer,
                                            int    cbRetBuffer,
                                            LPCTSTR lpszFilename);

typedef BOOL (* SQLINSTALLDRIVER)(LPCTSTR  lpszInfFile,
                                  LPCTSTR  lpszDriver,
                                  LPTSTR   lpszPath,
                                  WORD     cbPathMax,
                                  WORD*    pcbPathOut);

typedef BOOL (* SQLGETINSTALLEDDRIVER)(LPTSTR  lpszBuf,
                                       WORD    cbBufMax,
                                       WORD*   pcbBufOut);

typedef BOOL (* SQLSETCONFIGMODE)(UWORD wConfigMode);

static SQLCONFIGDATASOURCE          fpSQLConfigDataSource=NULL;
static SQLINSTALLDRIVER             fpSQLInstallDriver=NULL;
static SQLINSTALLERERROR            fpSQLInstallerError=NULL;
static SQLGETPRIVATEPROFILESTRING   fpSQLGetPrivateProfileString=NULL;
static SQLSETCONFIGMODE             fpSQLSetConfigMode=NULL;
static SQLGETINSTALLEDDRIVER        fpSQLGetInstalledDriver=NULL;
static HINSTANCE                    hODBCCP32=NULL;

//------------------------------------------------------------

void
ReportError(
    IN HWND hWnd, 
    IN LPTSTR pszDefaultMsg
    )
/*++

Abstract:

    Popup a error message.

Parameters:

    hWnd - Parent window handle.
    pszDefaultMsg - ignore.

Returns:

    None.
    
++*/
{
#if DBG
    DWORD dwErrCode;
    TCHAR szErrMsg[2048];
    WORD  szErrMsgSize=sizeof(szErrMsg)/sizeof(szErrMsg[0]);
    WORD  cbErrMsg;

    fpSQLInstallerError(
                    1, 
                    &dwErrCode, 
                    szErrMsg, 
                    szErrMsgSize, 
                    &cbErrMsg
                );

    MessageBox(hWnd, szErrMsg, _TEXT("Setup Error"), MB_OK);
#else
    return;
#endif
}


//------------------------------------------------------------

BOOL 
InitODBCSetup()
/*++


++*/
{
    hODBCCP32 = LoadLibrary(_TEXT("odbccp32"));
    if(hODBCCP32)
    {
        fpSQLConfigDataSource=(SQLCONFIGDATASOURCE)GetProcAddress(
                                                            hODBCCP32, 
                                                            szSQLConfigDataSource
                                                        );

        fpSQLInstallDriver=(SQLINSTALLDRIVER)GetProcAddress(
                                                            hODBCCP32, 
                                                            szSQLInstallDriver
                                                        );

        fpSQLInstallerError=(SQLINSTALLERERROR)GetProcAddress(
                                                            hODBCCP32, 
                                                            szSQLInstallerError
                                                        );

        fpSQLGetPrivateProfileString=(SQLGETPRIVATEPROFILESTRING)GetProcAddress(
                                                                        hODBCCP32, 
                                                                        szSQLGetPrivateProfileString
                                                                    );

        fpSQLSetConfigMode=(SQLSETCONFIGMODE)GetProcAddress(
                                                        hODBCCP32, 
                                                        szSQLSetConfigMode
                                                    );

        fpSQLGetInstalledDriver=(SQLGETINSTALLEDDRIVER)GetProcAddress(
                                                                hODBCCP32, 
                                                                szSQLGetInstalledDrivers
                                                            );
    }

    if( hODBCCP32 == NULL || fpSQLConfigDataSource == NULL || 
        fpSQLInstallDriver == NULL || fpSQLInstallerError == NULL || 
        fpSQLGetPrivateProfileString == NULL || fpSQLSetConfigMode == NULL ||
        fpSQLGetInstalledDriver == NULL)
    {
        ReportError(NULL, _TEXT("Can't load odbccp32.dll "));
        return FALSE;
    } 

    return TRUE;
}

//------------------------------------------------------------

void 
CleanupODBCSetup()
/*++

++*/
{
    if(hODBCCP32)
        FreeLibrary(hODBCCP32);

    fpSQLConfigDataSource=NULL;
    fpSQLInstallDriver=NULL;
    fpSQLInstallerError=NULL;
    fpSQLGetPrivateProfileString=NULL;
    fpSQLSetConfigMode=NULL;
    fpSQLGetInstalledDriver=NULL;
    hODBCCP32=NULL;

    return;
}

//---------------------------------------------------------------------------
//
// Access Driver installation
//
LPTSTR szAccessDriver=_TEXT("Microsoft Access Driver (*.mdb)\0")
                      _TEXT("Driver=odbcjt32.dll\0")
                      _TEXT("Setup=odbcjt32.dll\0")
                      _TEXT("Name=Microsoft Access Driver (*.mdb)\0")
                      _TEXT("APILevel=1\0")
                      _TEXT("ConnectFunctions=YYN\0")
                      _TEXT("DriverODBCVer=02.50\0")
                      //_TEXT("FileUsage=2\0")
                      _TEXT("FileExtns=*.mdb\0")
                      _TEXT("SQLLevel=0\0");


//---------------------------------------------------------------------------

BOOL 
IsDriverInstalled( 
    IN LPTSTR szDriverName 
    )
/*++

Abstract:

    Check if a ODBC driver installed on system.

Parameters:

    szDriveName - Name of the drive.

Returns:

    TRUE if driver installed, FALSE otherwise.

++*/
{
    TCHAR szBuf[8096];  // this got to be enough
    WORD cbBufMax=sizeof(szBuf)/sizeof(szBuf[0]);
    WORD cbBufOut;
    LPTSTR pszBuf=szBuf;

    if(hODBCCP32 == NULL && !InitODBCSetup())
        return FALSE;

    if(fpSQLGetInstalledDriver(szBuf, cbBufMax, &cbBufOut))
    {
        ReportError(NULL, _TEXT("SQLGetInstalledDrivers"));
    }
    else
    {
        do {
            if(_tcsnicmp(szDriverName, pszBuf, min(lstrlen(szDriverName), lstrlen(pszBuf))) == 0)
                break;

            pszBuf += lstrlen(pszBuf) + 1;
        } while(pszBuf[1] != _TEXT('\0'));
    }

    return (pszBuf[1] != _TEXT('\0'));
}
    
//---------------------------------------------------------------------------

BOOL 
IsDataSourceInstalled( 
    IN LPTSTR pszDataSource, 
    IN UWORD wConfigMode, 
    IN OUT LPTSTR pszDbFile, 
    IN DWORD cbBufSize 
    )

/*++

Abstract:

    Check if a ODBC datasource are installed.

Parameters:

    pszDataSource - name of data source.
    wConfigMode - configuration mode, refer to ODBC for detail, 
                  license server uses ODBC_SYSTEM_DSN.
    pszDbFile - Pointer to buffer for receving full path to database file 
                if data source is installed.
    cbBufSize - size of buffer in characters.

    
Returns:

    TRUE if datasource is installed, FALSE otherwise.

++*/

{
    BOOL bSuccess = TRUE;

    if(hODBCCP32 == NULL && !InitODBCSetup())
    {
        bSuccess = FALSE;
        goto cleanup;
    }

    if(fpSQLSetConfigMode(wConfigMode) == FALSE)
    {
        ReportError(NULL, _TEXT("SQLSetConfigMode failed"));
        bSuccess = FALSE;
        goto cleanup;
    }

    if(fpSQLGetPrivateProfileString(
                    pszDataSource, 
                    _TEXT("DBQ"), 
                    _TEXT(""), 
                    pszDbFile, 
                    cbBufSize, 
                    _TEXT("ODBC.INI")
                ) == 0)
    {
        bSuccess = FALSE;
    }

cleanup:

    return bSuccess;
}

//---------------------------------------------------------------------------

BOOL
ConfigDataSource( 
    HWND     hWnd, 
    BOOL     bInstall,       // TRUE to install FALSE to remove
    LPTSTR   pszDriver,       // driver
    LPTSTR   pszDsn,          // DSN
    LPTSTR   pszUser,         // User
    LPTSTR   pszPwd,          // Password
    LPTSTR   pszMdbFile       // MDB file
    )

/*++

Abstract:

    Routine to add/remove ODBC data source.

Parameters:

    hWnd - Parent window handle.
    bInstall - TRUE if installing ODBC data source, FALSE otherwise.
    pszDrive - Name of the ODBC drive to be used on data source.
    pszDsn - ODBC Data Source Name.
    pszUser - Login use name.
    pszPwd - Login password.
    pszMdbFile - Name of the Database file.
    
Returns:

    TRUE if successfule, FALSE otherwise.

++*/

{
    TCHAR   szAttributes[MAX_PATH*6+1];
    BOOL    bConfig=TRUE;
    TCHAR*  pAttribute;

    if(hODBCCP32 == NULL && !InitODBCSetup())
        return FALSE;

    //
    // for attribute string
    //
    pAttribute=szAttributes;
    memset(szAttributes, 0, sizeof(szAttributes));
    wsprintf(pAttribute, _TEXT("DSN=%s"), pszDsn);
    pAttribute += lstrlen(pAttribute) + 1;

    wsprintf(pAttribute, _TEXT("UID=%s"), pszUser);
    pAttribute += lstrlen(pAttribute) + 1;

    if(pszPwd)
    {
        wsprintf(pAttribute, _TEXT("PASSWORD=%s"), pszPwd);
        pAttribute += lstrlen(pAttribute) + 1;
    }

    _stprintf(pAttribute, _TEXT("DBQ=%s"), pszMdbFile);
    bConfig=fpSQLConfigDataSource(NULL,
                                  (WORD)((bInstall) ? ODBC_ADD_SYS_DSN : ODBC_REMOVE_SYS_DSN),
                                  pszDriver,
                                  szAttributes);
    // ignore error on uninstall
    if(!bConfig && bInstall)
    {
        ReportError(hWnd, _TEXT("Can't config data source"));
    }

    return bConfig;
}


BOOL
RepairDataSource( 
    HWND     hWnd, 
    LPTSTR   pszDriver,
    LPTSTR   pszDsn,          // DSN
    LPTSTR   pszUser,         // User
    LPTSTR   pszPwd,          // Password
    LPTSTR   pszMdbFile       // MDB file
    )

/*++

Abstract:

    Routine to Compact/Repair a database file

Parameters:

    hWnd - Parent window handle.
    pszDsn - ODBC Data Source Name.
    pszUser - Login use name.
    pszPwd - Login password.
    pszMdbFile - Name of the Database file.
    
Returns:

    TRUE if successfule, FALSE otherwise.

++*/

{
    TCHAR   szAttributes[MAX_PATH*6+1];
    BOOL    bConfig=TRUE;
    TCHAR*  pAttribute;

    if(hODBCCP32 == NULL && !InitODBCSetup())
        return FALSE;

    //
    // for attribute string
    //
    pAttribute=szAttributes;
    memset(szAttributes, 0, sizeof(szAttributes));
    wsprintf(pAttribute, _TEXT("DSN=%s"), pszDsn);
    pAttribute += lstrlen(pAttribute) + 1;

    wsprintf(pAttribute, _TEXT("UID=%s"), pszUser);
    pAttribute += lstrlen(pAttribute) + 1;

    if(pszPwd)
    {
        wsprintf(pAttribute, _TEXT("PASSWORD=%s"), pszPwd);
        pAttribute += lstrlen(pAttribute) + 1;
    }

    _stprintf(pAttribute, _TEXT("DBQ=%s"), pszMdbFile);

    pAttribute += lstrlen(pAttribute) + 1;
    _stprintf(pAttribute, _TEXT("REPAIR_DB=%s"), pszMdbFile);
   
    bConfig=fpSQLConfigDataSource(
                            NULL,
                            (WORD)ODBC_CONFIG_SYS_DSN,
                            pszDriver,
                            szAttributes
                        );

    // ignore error on uninstall
    if(bConfig == FALSE)
    {
        ReportError(hWnd, _TEXT("Can't repair data source"));
    }

    return bConfig;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\upg4to5\misc.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       misc.cpp 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include "upg.h"
#include <lm.h>

//-----------------------------------------------------------

void 
DBGPrintf(
    IN LPTSTR format, ... 
    )

/*

Abstract:

    Similar to printf() except it goes to debugger and messages 
    is limited to 8K

Parameters:

    format - format string, refer to printf.

Returns:

    None

*/

{
    va_list marker;
    TCHAR  buf[8096];
    DWORD  dump;

    va_start(marker, format);

    __try {
        memset(buf, 0, sizeof(buf));
        _vsntprintf(
                buf, 
                sizeof(buf) / sizeof(buf[0]) - 1, 
                format, 
                marker
            );

        OutputDebugString(buf);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
    }

    va_end(marker);

    return;
}


//--------------------------------------------------------------------

BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATA findData;
    HANDLE FindHandle;
    DWORD Error;

    FindHandle = FindFirstFile(FileName,&findData);
    if(FindHandle == INVALID_HANDLE_VALUE) 
    {
        Error = GetLastError();
    } 
    else 
    {
        FindClose(FindHandle);
        if(FindData) 
        {
            *FindData = findData;
        }
        Error = NO_ERROR;
    }

     SetLastError(Error);
    return (Error == NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\upg4to5\upg.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       upg.cpp 
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include "upg.h"
#include <time.h>

//----------------------------------------------------
//
// Global variables
//
//
#ifndef LICENOC_SMALL_UPG

JBInstance      g_JbInstance;
JBSession       g_JetSession(g_JbInstance);
JBDatabase      g_JetDatabase(g_JetSession);

PBYTE           g_pbSetupId=NULL;
DWORD           g_cbSetupId=0;

PBYTE           g_pbDomainSid=NULL;
DWORD           g_cbDomainSid=0;

TCHAR           g_szComputerName[MAX_COMPUTERNAME_LENGTH + 1];

#endif

TCHAR           g_szOdbcDsn[128]=NT4LSERVER_DEFAULT_DSN;   // ODBC DSN
TCHAR           g_szOdbcUser[128]=NT4LSERVER_DEFAULT_USER;  // ODBC User Name
TCHAR           g_szOdbcPwd[128]=NT4LSERVER_DEFAULT_PWD;   // ODBC Password
TCHAR           g_szMdbFile[MAX_PATH+1];


//--------------------------------------------------------------------------

#ifndef LICENOC_SMALL_UPG

DWORD
UpgradeIssuedLicenseTable(
    CSQLStmt* lpSqlStmt,
    JBDatabase& jbDatabase
    )
/*++


Note:

    Transaction must be active 

++*/
{

    DWORD dwStatus = ERROR_SUCCESS;
    NT4LICENSE nt4License;
    NT4LICENSERECORD nt4LicenseRecord(&nt4License);

    LICENSEDCLIENT LicensedClient;
    LicensedTable LicensedTable(jbDatabase);

    TLSLicensedIndexMatchHwid hwidHint;
 
    BOOL bSuccess;


    bSuccess = LicensedTable.OpenTable(
                                        TRUE,
                                        JET_bitTableUpdatable
                                    );

    if(bSuccess == FALSE)
    {
        dwStatus = SET_JB_ERROR(LicensedTable.GetLastJetError());
        SetLastError(dwStatus);
        goto cleanup;
    }

    lpSqlStmt->Cleanup();

    dwStatus = NT4LicenseEnumBegin(
                            lpSqlStmt,
                            &nt4LicenseRecord
                        );

    if(dwStatus != ERROR_SUCCESS)
        goto cleanup;

    while( (dwStatus = NT4RecordEnumNext(lpSqlStmt)) == ERROR_SUCCESS )
    {
        memset(&LicensedClient, 0, sizeof(LicensedClient));

        LicensedClient.ucEntryStatus = 0;
        LicensedClient.dwLicenseId = nt4License.dwLicenseId;
        LicensedClient.dwKeyPackId = nt4License.dwKeyPackId;

        LicensedClient.dwKeyPackLicenseId = 0;

        // LicensedClient.ftLastModifyTime;

        SAFESTRCPY(LicensedClient.szMachineName, nt4License.szMachineName);
        SAFESTRCPY(LicensedClient.szUserName, nt4License.szUserName);

        LicensedClient.ftIssueDate = nt4License.ftIssueDate;
        LicensedClient.ftExpireDate = nt4License.ftExpireDate;
        LicensedClient.ucLicenseStatus = nt4License.ucLicenseStatus;
        LicensedClient.dwNumLicenses = nt4License.dwNumLicenses;

        LicensedClient.dwSystemBiosChkSum = nt4LicenseRecord.checkSum.dwSystemBiosChkSum;
        LicensedClient.dwVideoBiosChkSum = nt4LicenseRecord.checkSum.dwVideoBiosChkSum;
        LicensedClient.dwFloppyBiosChkSum = nt4LicenseRecord.checkSum.dwFloppyBiosChkSum;
        LicensedClient.dwHardDiskSize = nt4LicenseRecord.checkSum.dwHardDiskSize;
        LicensedClient.dwRamSize = nt4LicenseRecord.checkSum.dwRamSize;

        hwidHint = LicensedClient;

        LicensedClient.dbLowerBound = hwidHint.dbLowerBound;

        //
        if(LicensedTable.InsertRecord(LicensedClient) == FALSE)
        {
            dwStatus = SET_JB_ERROR(LicensedTable.GetLastJetError());
            goto cleanup;
        }
    }

    NT4RecordEnumEnd(lpSqlStmt);

    if(dwStatus != ERROR_ODBC_NO_DATA_FOUND)
    {
        // something wrong in fetch().
        goto cleanup;
    }
    
    dwStatus = ERROR_SUCCESS;

cleanup:

    lpSqlStmt->Cleanup();
    LicensedTable.CloseTable();

    return dwStatus;
}

//--------------------------------------------------------------------------

DWORD
UpgradeLicensePackDescTable(
    CSQLStmt* lpSqlStmt,
    JBDatabase& jbDatabase
    )
/*++


Note:

    Transaction must be active 

++*/
{

    DWORD dwStatus = ERROR_SUCCESS;
    NT4KEYPACKDESC nt4KpDesc;
    NT4KEYPACKDESCRECORD nt4KpDescRecord(&nt4KpDesc);

    LICPACKDESC LicPackDesc;
    LicPackDescTable LicPackDescTable(jbDatabase);

    BOOL bSuccess;


    bSuccess = LicPackDescTable.OpenTable(
                                        TRUE,
                                        JET_bitTableUpdatable
                                    );

    if(bSuccess == FALSE)
    {
        dwStatus = SET_JB_ERROR(LicPackDescTable.GetLastJetError());
        SetLastError(dwStatus);
        goto cleanup;
    }

    lpSqlStmt->Cleanup();

    dwStatus = NT4KeyPackDescEnumBegin(
                            lpSqlStmt,
                            &nt4KpDescRecord
                        );

    if(dwStatus != ERROR_SUCCESS)
        goto cleanup;

    while( (dwStatus = NT4RecordEnumNext(lpSqlStmt)) == ERROR_SUCCESS )
    {
        memset(&LicPackDesc, 0, sizeof(LicPackDesc));

        LicPackDesc.ucEntryStatus = 0;
        LicPackDesc.dwKeyPackId = nt4KpDesc.dwKeyPackId;
        LicPackDesc.dwLanguageId = nt4KpDesc.dwLanguageId;
        // LicPackDesc.ftLastModifyTime = 0;

        SAFESTRCPY(LicPackDesc.szCompanyName, nt4KpDesc.szCompanyName);
        SAFESTRCPY(LicPackDesc.szProductName, nt4KpDesc.szProductName);
        SAFESTRCPY(LicPackDesc.szProductDesc, nt4KpDesc.szProductDesc);
        //
        if(LicPackDescTable.InsertRecord(LicPackDesc) == FALSE)
        {
            dwStatus = SET_JB_ERROR(LicPackDescTable.GetLastJetError());
            goto cleanup;
        }
    }

    NT4RecordEnumEnd(lpSqlStmt);

    if(dwStatus != ERROR_ODBC_NO_DATA_FOUND)
    {
        // something wrong in fetch().
        goto cleanup;
    }
    
    dwStatus = ERROR_SUCCESS;

cleanup:

    lpSqlStmt->Cleanup();
    LicPackDescTable.CloseTable();

    return dwStatus;
}

   
//--------------------------------------------------------------------------

DWORD
UpgradeLicensePackTable(
    CSQLStmt* lpSqlStmt,
    JBDatabase& jbDatabase
    )
/*++


Note:

    Transaction must be active 

++*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    
    NT4KEYPACK nt4KeyPack;
    NT4KEYPACKRECORD nt4KeyPackRecord(&nt4KeyPack);

    LICENSEPACK LicPack;
    LicPackTable LicPackTable(jbDatabase);
    BOOL bSuccess=TRUE;
    //FILETIME ftCurTime;
    //SYSTEMTIME sysTime;

    //GetSystemTime(&sysTime);

    //if(SystemTimeToFileTime(&sysTime, &ftCurTime) == FALSE)
    //{
    //    dwStatus = GetLastError();
    //    goto cleanup;
    //}

    //
    // Open License KeyPack table
    //
    bSuccess = LicPackTable.OpenTable(
                                    TRUE,
                                    JET_bitTableUpdatable
                                );
    if(bSuccess == FALSE)
    {
        dwStatus = SET_JB_ERROR(LicPackTable.GetLastJetError());

        SetLastError(dwStatus);
        goto cleanup;
    }


    lpSqlStmt->Cleanup();

    dwStatus = NT4KeyPackEnumBegin(
                            lpSqlStmt,
                            &nt4KeyPackRecord
                        );

    if(dwStatus != ERROR_SUCCESS)
        goto cleanup;


    while( (dwStatus = NT4RecordEnumNext(lpSqlStmt)) == ERROR_SUCCESS )
    {
        memset(&LicPack, 0, sizeof(LicPack));

        //
        // Copy over license pack information.
        //
        LicPack.ucEntryStatus = 0; 
        LicPack.dwKeyPackId = nt4KeyPack.dwKeyPackId;

        //LicPack.ftLastModifyTime = 0;   // don't want this license pack to 
                                        // be populated to other server
        LicPack.dwAttribute = 0;

        if( nt4KeyPack.ucKeyPackType > LSKEYPACKTYPE_LAST || 
            nt4KeyPack.ucKeyPackType < LSKEYPACKTYPE_FIRST)
        {
            //
            // This is an invalid key pack, ignore
            //
            continue;
        }

        if( nt4KeyPack.ucKeyPackType == LSKEYPACKTYPE_SELECT ||
            nt4KeyPack.ucKeyPackType == LSKEYPACKTYPE_TEMPORARY ||
            nt4KeyPack.ucKeyPackType == LSKEYPACKTYPE_FREE)
        {
            LicPack.dwNextSerialNumber = nt4KeyPack.dwNumberOfLicenses + 1;
        }
        else
        {
            LicPack.dwNextSerialNumber = nt4KeyPack.dwTotalLicenseInKeyPack - nt4KeyPack.dwNumberOfLicenses + 1;
        }

        LicPack.dwActivateDate = nt4KeyPack.dwActivateDate;
        LicPack.dwExpirationDate = nt4KeyPack.dwExpirationDate;
        LicPack.dwNumberOfLicenses = nt4KeyPack.dwNumberOfLicenses;
        LicPack.ucKeyPackStatus = nt4KeyPack.ucKeyPackStatus;

        LicPack.pbDomainSid = NULL;
        LicPack.cbDomainSid = 0;

        memcpy(
                LicPack.szInstallId,
                g_pbSetupId,
                min(sizeof(LicPack.szInstallId)/sizeof(LicPack.szInstallId[0]) - 1, g_cbSetupId)
            );


        // LicPack.szDomainName

        SAFESTRCPY(LicPack.szTlsServerName, g_szComputerName);

        //
        // Standard KeyPack Property..
        //

        LicPack.ucAgreementType = nt4KeyPack.ucKeyPackType;
        SAFESTRCPY(LicPack.szCompanyName, nt4KeyPack.szCompanyName)
        SAFESTRCPY(LicPack.szProductId, nt4KeyPack.szProductId);
        LicPack.wMajorVersion = nt4KeyPack.wMajorVersion;
        LicPack.wMinorVersion = nt4KeyPack.wMinorVersion;

        //
        // TermSrv specific code
        //
        if(_tcsicmp(LicPack.szProductId, NT4HYDRAPRODUCT_FULLVERSION_SKU) == 0)
        {
            LicPack.dwPlatformType = 0xFF;
            SAFESTRCPY(LicPack.szKeyPackId, nt4KeyPack.szProductId);
        }
        else if(_tcsicmp(LicPack.szProductId, NT4HYDRAPRODUCT_UPGRADE_SKU) == 0)
        {
            LicPack.dwPlatformType = 0x1;
            SAFESTRCPY(LicPack.szKeyPackId, nt4KeyPack.szProductId);
        }
        else if(_tcsicmp(LicPack.szProductId, NT4HYDRAPRODUCT_EXISTING_SKU) == 0)
        {
            LicPack.dwPlatformType = 0x2;
            SAFESTRCPY(LicPack.szKeyPackId, nt4KeyPack.szProductId);
        }
        else
        {    
            SAFESTRCPY(LicPack.szKeyPackId, nt4KeyPack.szKeyPackId);
            LicPack.dwPlatformType = nt4KeyPack.dwPlatformType;
        }

        LicPack.ucLicenseType = nt4KeyPack.ucLicenseType;
        LicPack.ucChannelOfPurchase = nt4KeyPack.ucChannelOfPurchase;
        SAFESTRCPY(LicPack.szBeginSerialNumber, nt4KeyPack.szBeginSerialNumber);
        LicPack.dwTotalLicenseInKeyPack = nt4KeyPack.dwTotalLicenseInKeyPack;
        LicPack.dwProductFlags = nt4KeyPack.dwProductFlags;

        //
        if(LicPackTable.InsertRecord(LicPack) == FALSE)
        {
            dwStatus = SET_JB_ERROR(LicPackTable.GetLastJetError());
            goto cleanup;
        }
    }

    NT4RecordEnumEnd(lpSqlStmt);

    if(dwStatus != ERROR_ODBC_NO_DATA_FOUND)
    {
        // something wrong in fetch().
        goto cleanup;
    }
    
    dwStatus = ERROR_SUCCESS;

cleanup:

    lpSqlStmt->Cleanup();
    LicPackTable.CloseTable();

    return dwStatus;
}

#endif

//--------------------------------------------------------------------------

DWORD 
GetNT4DbConfig(
    LPTSTR pszDsn,
    LPTSTR pszUserName,
    LPTSTR pszPwd,
    LPTSTR pszMdbFile
    )
/*++

++*/
{
    HKEY hKey = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    TCHAR szOdbcDsn[128]=NT4LSERVER_DEFAULT_DSN;   // ODBC DSN
    TCHAR szOdbcUser[128]=NT4LSERVER_DEFAULT_USER;  // ODBC User Name
    TCHAR szOdbcPwd[128]=NT4LSERVER_DEFAULT_PWD;   // ODBC Password

    TCHAR szMdbFile[MAX_PATH+1];
    DWORD dwBuffer=0;

    PBYTE pbData = NULL;
    DWORD cbData = 0;

    BOOL bSuccess;


    //
    // Open NT4 license server specific registry key
    //
    dwStatus = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        NT4LSERVER_REGKEY,
                        0,
                        KEY_ALL_ACCESS,    
                        &hKey
                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        dwStatus = ERROR_INVALID_NT4_SETUP;
        goto cleanup;
    }

    //
    // Load ODBC DSN and User name from registry,
    // ignore error return and use default value.
    //
    dwBuffer = sizeof(szOdbcDsn);
    dwStatus = RegQueryValueEx(
                        hKey,
                        NT4LSERVER_PARAMETERS_DSN,
                        NULL,
                        NULL,
                        (LPBYTE)szOdbcDsn,
                        &dwBuffer
                    );
    if(dwStatus == ERROR_SUCCESS && pszDsn)
    {
        lstrcpy(pszDsn, szOdbcDsn);
    }

    dwBuffer = sizeof(szOdbcUser);
    dwStatus = RegQueryValueEx(
                        hKey,
                        NT4LSERVER_PARAMETERS_USER,
                        NULL,
                        NULL,
                        (LPBYTE)szOdbcUser,
                        &dwBuffer
                    );

    if(dwStatus == ERROR_SUCCESS && pszUserName)
    {
        lstrcpy(pszUserName, szOdbcUser);
    }

   
    //
    // Load database password from LSA
    //
    dwStatus = RetrieveKey(
                        LSERVER_LSA_PASSWORD_KEYNAME,
                        &pbData,
                        &cbData
                    );

#ifndef PRIVATE_DBG
    if(dwStatus != ERROR_SUCCESS)
    {
        //
        // Invalid NT4 license server setup or hydra beta2 
        // license server which we don't support.
        //
        dwStatus = ERROR_INVALID_NT4_SETUP;
        goto cleanup;
    }
#endif

    dwStatus = ERROR_SUCCESS;
    memset(szOdbcPwd, 0, sizeof(szOdbcPwd));
    memcpy(
            (PBYTE)szOdbcPwd,
            pbData,
            min(cbData, sizeof(szOdbcPwd) - sizeof(TCHAR))
        );

    if(pszPwd != NULL)
    {
        lstrcpy(pszPwd, szOdbcPwd);
    }

    //
    // Verify data source is properly installed
    //
    bSuccess = IsDataSourceInstalled(
                            szOdbcDsn,
                            ODBC_SYSTEM_DSN,
                            szMdbFile,
                            MAX_PATH
                        );

    if(bSuccess == FALSE)
    {
        dwStatus = ERROR_INVALID_NT4_SETUP;
        goto cleanup;
    }        

    if(pszMdbFile != NULL)
    {
        _tcscpy(pszMdbFile, szMdbFile);
    }

cleanup:

    if(hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    if(pbData != NULL)
    {
        LocalFree(pbData);
    }

    return dwStatus;
}

//--------------------------------------------------------------------------
DWORD
DeleteNT4ODBCDataSource()
/*++

--*/
{
    BOOL bSuccess;
    DWORD dwStatus = ERROR_SUCCESS;

    //
    // Get Hydra 4 DB configuration, make sure 
    // data source is properly config.
    //
    dwStatus = GetNT4DbConfig(
                            g_szOdbcDsn,
                            g_szOdbcUser,
                            g_szOdbcPwd,
                            g_szMdbFile
                        );

    if(dwStatus == ERROR_SUCCESS)
    {
        bSuccess = ConfigDataSource( 
                                NULL,
                                FALSE,
                                _TEXT(SZACCESSDRIVERNAME),
                                g_szOdbcDsn,
                                g_szOdbcUser,
                                g_szOdbcPwd,
                                g_szMdbFile
                            );

        if(bSuccess == FALSE)
        {
            dwStatus = ERROR_DELETE_ODBC_DSN;
        }
    }

    return dwStatus;
}    

//--------------------------------------------------------------------------

#ifndef LICENOC_SMALL_UPG

DWORD
UpgradeNT4Database(
    IN DWORD dwServerRole,
    IN LPCTSTR pszDbFilePath,
    IN LPCTSTR pszDbFileName,
    IN BOOL bAlwaysDeleteDataSource
    )
/*++

Abstract:

    This routine is to upgrade Hydra4 Terminal Licensing Server database to
    NT5.  Hydra4 uses ODBC/Jet while NT5 uses JetBlue as database engine, 
    other changes includes table structure and additional table.

Parameters:

    dwServerRole - Server role in enterprise, 0 - ordinaly server, 1 - enterprise server
    pszDbFilePath - Directory for NT5 Terminal Licensing Server Database.  License
                    Server uses this directory as JetBlue instance's log/temp/system path.
    pszDbFileName - Database file name, default to TlsLic.edb if NULL.


Returns:

    ERROR_SUCCESS or error code, see upg.h for list of error code and description

++*/
{
    DWORD   dwStatus=ERROR_SUCCESS;
    TCHAR   szFileName[MAX_PATH+1];
    CSQLStmt sqlStmt;
    UUID uuid;
    unsigned short *szUuid=NULL;
    BOOL bSuccess;
    DWORD dwNt4DbVersion;
    DWORD dwComputerName = sizeof(g_szComputerName)/sizeof(g_szComputerName[0]);
    BOOL bNT4LserverExists = FALSE;


    memset(g_szComputerName, 0, sizeof(g_szComputerName));
    GetComputerName(g_szComputerName, &dwComputerName);

    //
    // Verify input parameter.  pszDbFilePath must not have '\' as last 
    // character.
    //
    if(pszDbFilePath == NULL || *pszDbFilePath == _TEXT('0'))
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    if(pszDbFilePath[_tcslen(pszDbFilePath) - 1] == _TEXT('\\'))
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    //
    // Make sure target directory exist.
    //
    if(FileExists(pszDbFilePath, NULL) == FALSE)
    {
        dwStatus = ERROR_TARGETFILE_NOT_FOUND;
        goto cleanup;
    }

    //
    // Database file can't exist, we have no idea what it is.
    //
    wsprintf(
            szFileName,
            _TEXT("%s\\%s"),
            pszDbFilePath,
            (pszDbFileName) ? pszDbFileName : LSERVER_DEFAULT_EDB
        );

    //
    // Verify File does not exist, this file might
    // not be a valid JetBlue database file, setup 
    // should verify and prompt user for different
    // file name
    //
    if(FileExists(szFileName, NULL) == TRUE)
    {
        dwStatus = ERROR_DEST_FILE_EXIST;
        goto cleanup;
    }

    //
    // Get Hydra 4 DB configuration, make sure 
    // data source is properly config.
    //
    dwStatus = GetNT4DbConfig(
                            g_szOdbcDsn,
                            g_szOdbcUser,
                            g_szOdbcPwd,
                            g_szMdbFile
                        );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    bNT4LserverExists = TRUE;

    //
    // Generate License Server Setup Id
    //
    dwStatus = RetrieveKey(
                        LSERVER_LSA_SETUPID, 
                        &g_pbSetupId,
                        &g_cbSetupId
                    );

#ifndef PRIVATE_DBG
    if(dwStatus == ERROR_SUCCESS)
    {
        //
        // NT4 Hydra does not use this setup ID.
        //
        dwStatus = ERROR_INVALID_NT4_SETUP;
        goto cleanup;
    }
#endif

    //
    // Generate License Server Unique Setup ID
    //
    UuidCreate(&uuid);
    UuidToString(&uuid, &szUuid);    

    g_pbSetupId = (PBYTE)AllocateMemory((_tcslen(szUuid)+1)*sizeof(TCHAR));
    if(g_pbSetupId == NULL)
    {
        dwStatus = GetLastError();
        goto cleanup;
    }

    memcpy(
            g_pbSetupId, 
            szUuid, 
            (_tcslen(szUuid) + 1)*sizeof(TCHAR)
        );

    g_cbSetupId = (_tcslen(szUuid) + 1)*sizeof(TCHAR);

    RpcStringFree(&szUuid);
    szUuid = NULL;
   
   
    //
    // Open one SQL handle to Hydra data source
    //
    dwStatus = OpenSqlStmtHandle(
                            &sqlStmt, 
                            g_szOdbcDsn,
                            g_szOdbcUser,
                            g_szOdbcPwd,
                            g_szMdbFile
                        );
                            
    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    // Verify this is latest Hydra 4
    //
    dwStatus = GetNt4DatabaseVersion(
                                &sqlStmt, 
                                (LONG *)&dwNt4DbVersion
                            );
    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if(dwNt4DbVersion != HYDRA_DATABASE_NT40_VERSION)
    {
        //
        // Only support release database version
        //
        dwStatus = ERROR_NOTSUPPORT_DB_VERSION;
        goto cleanup;
    }

    //
    // Initialize JetBlue and create an empty database
    //
    dwStatus = JetBlueInitAndCreateEmptyDatabase(
                                pszDbFilePath,
                                (pszDbFileName) ? pszDbFileName : LSERVER_DEFAULT_EDB,
                                g_szOdbcUser,
                                g_szOdbcPwd,
                                g_JbInstance,
                                g_JetSession,
                                g_JetDatabase
                            );
    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    // Begin JetBlue Transaction, 
    // JetBlue Transaction is session based.
    //
    g_JetSession.BeginTransaction();

    //
    // Copy over licensed key pack table
    //
    dwStatus = UpgradeLicensePackTable(
                                &sqlStmt,
                                g_JetDatabase
                            );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    // Copy over licensed key pack desc. table
    //
    dwStatus = UpgradeLicensePackDescTable(
                                &sqlStmt,
                                g_JetDatabase
                            );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    // Copy over issued license table
    //
    dwStatus = UpgradeIssuedLicenseTable(
                                &sqlStmt,
                                g_JetDatabase
                            );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    // Write License Server Setup ID to LSA
    //
    dwStatus = StoreKey(
                    LSERVER_LSA_SETUPID, 
                    g_pbSetupId, 
                    g_cbSetupId
                );

    //
    // TODO : if we could not write setup ID to LSA
    //
cleanup:

    if(dwStatus == ERROR_SUCCESS)
    {
        g_JetSession.CommitTransaction();
    }
    else
    {
        g_JetSession.RollbackTransaction();
    }
    

    //
    // Close ODBC handle
    //
    sqlStmt.Close();
    CSQLStmt::Shutdown();

    g_JetDatabase.CloseDatabase();
    g_JetSession.EndSession();

    if(dwStatus != ERROR_SUCCESS)
    {
        //
        // Reset last run status, password is not use on JetBlue,
        // LSERVER_LSA_SETUPID will not get setup if error.
        //
        TLServerLastRunState lastRun;

        memset(&lastRun, 0, sizeof(TLServerLastRunState));
        lastRun.dwVersion = LSERVER_LSA_STRUCT_VERSION;

        StoreKey(
                LSERVER_LSA_LASTRUN, 
                (PBYTE)&lastRun, 
                sizeof(TLServerLastRunState)
            );
    }

    if( (dwStatus == ERROR_SUCCESS) || 
        (bAlwaysDeleteDataSource == TRUE && bNT4LserverExists == TRUE) )
    {
        //
        // Remove "Hydra License" from data source.
        // Non-critical error if we can't remove data source.
        //
        ConfigDataSource( 
                        NULL,
                        FALSE,
                        _TEXT(SZACCESSDRIVERNAME),
                        g_szOdbcDsn,
                        g_szOdbcUser,
                        g_szOdbcPwd,
                        g_szMdbFile
                    );
    }

    FreeMemory(g_pbSetupId);
    return dwStatus;
}

#endif

//---------------------------------------------------

//
// License Server secret key info.
//
#define LSERVER_LSA_PRIVATEKEY_SIGNATURE    _TEXT("TermServLiceningSignKey-12d4b7c8-77d5-11d1-8c24-00c04fa3080d")
#define LSERVER_LSA_PRIVATEKEY_EXCHANGE     _TEXT("TermServLicensingExchKey-12d4b7c8-77d5-11d1-8c24-00c04fa3080d")

#define LSERVER_LSA_LSERVERID               _TEXT("TermServLicensingServerId-12d4b7c8-77d5-11d1-8c24-00c04fa3080d")

#define LSERVER_SOFTWARE_REGBASE \
    _TEXT("SOFTWARE\\Microsoft\\") _TEXT(SZSERVICENAME)

#define LSERVER_CERTIFICATE_STORE           _TEXT("Certificates")

#define LSERVER_SELFSIGN_CERTIFICATE_REGKEY \
    LSERVER_REGISTRY_BASE _TEXT(SZSERVICENAME) _TEXT("\\") LSERVER_SECRET

#define LSERVER_SERVER_CERTIFICATE_REGKEY \
    LSERVER_SOFTWARE_REGBASE _TEXT("\\") LSERVER_CERTIFICATE_STORE

#define LSERVER_CLIENT_CERTIFICATE_ISSUER   _TEXT("Parm0")
#define LSERVER_SIGNATURE_CERT_KEY          _TEXT("Parm1")
#define LSERVER_EXCHANGE_CERT_KEY           _TEXT("Parm2")


void
CleanLicenseServerSecret()

/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    HKEY hKey = NULL;
    
    //
    // Wipe out SPK in LSA
    //
    dwStatus = StoreKey(
                    LSERVER_LSA_LSERVERID,
                    (PBYTE) NULL,
                    0
                );

    dwStatus = StoreKey(
                    LSERVER_LSA_LASTRUN, 
                    (PBYTE) NULL,
                    0
                );

    dwStatus = StoreKey(
                    LSERVER_LSA_PRIVATEKEY_EXCHANGE, 
                    (PBYTE) NULL,
                    0
                );


    dwStatus = StoreKey(
                    LSERVER_LSA_PRIVATEKEY_SIGNATURE, 
                    (PBYTE) NULL,
                    0
                );

    dwStatus=RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    LSERVER_SERVER_CERTIFICATE_REGKEY,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                );
    if(dwStatus == ERROR_SUCCESS)
    {
        //
        // Ignore error
        RegDeleteValue(
                    hKey,
                    LSERVER_SIGNATURE_CERT_KEY
                );

        RegDeleteValue(
                    hKey,
                    LSERVER_EXCHANGE_CERT_KEY
                );

        RegDeleteValue(
                    hKey,
                    LSERVER_CLIENT_CERTIFICATE_ISSUER
                );
    }

    if(hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\upg4to5\upg.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        upg.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TLSUPG4TO5_H__
#define __TLSUPG4TO5_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>

#include <stdio.h>
#include <tchar.h>
#include <esent.h>

#include "lscommon.h"
#include "secstore.h"
#include "odbcinst.h"

#include "hydra4db.h"

#ifndef LICENOC_SMALL_UPG

#include "JBDef.h"
#include "TLSDb.h"

#endif

#include "backup.h"
#include "KPDesc.h"
#include "Licensed.h"
#include "licpack.h"
#include "version.h"
#include "workitem.h"
#include "upgdef.h"

//
//
//
#define AllocateMemory(size) \
    LocalAlloc(LPTR, size)

#define FreeMemory(ptr) \
    if(ptr)             \
    {                   \
        LocalFree(ptr); \
        ptr=NULL;       \
    }

#define SAFESTRCPY(dest, source) \
    _tcsncpy(dest, source, min(_tcslen(source), sizeof(dest)/sizeof(TCHAR))); \
    dest[min(_tcslen(source), (sizeof(dest)/sizeof(TCHAR) -1))] = _TEXT('\0');

//---------------------------------------------------------------------------
//
// Global variable
//
#ifndef LICENOC_SMALL_UPG

extern JBInstance   g_JbInstance;
extern JBSession    g_JetSession;
extern JBDatabase   g_JetDatabase;

extern PBYTE    g_pbSetupId;
extern DWORD    g_cbSetupId;
extern PBYTE    g_pbDomainSid;
extern DWORD    g_cbDomainSid;

#endif

//--------------------------------------------------------------------------
//
// Upgrade Error Code, should move into resource file.
//
#define UPGRADE_SETUP_ERROR_BASE    0xD0000000

//
// File not exist or directory not exist
//
#define ERROR_TARGETFILE_NOT_FOUND      (UPGRADE_SETUP_ERROR_BASE)

//
// Destination file already exist
//
#define ERROR_DEST_FILE_EXIST           (UPGRADE_SETUP_ERROR_BASE + 1)    

//
// Source database file does not exist
//
#define ERROR_SRC_FILE_NOT_EXIST        (UPGRADE_SETUP_ERROR_BASE + 2)


//
// Hydra ODBC datasource not exist
//
#define ERROR_ODBC_DATASOURCE_NOTEXIST  (UPGRADE_SETUP_ERROR_BASE + 3)

//
// Invalid setup or unsupported version
//
#define ERROR_INVALID_NT4_SETUP         (UPGRADE_SETUP_ERROR_BASE + 4)

//
// Internal Error in upgrade
//
#define ERROR_INTERNAL                  (UPGRADE_SETUP_ERROR_BASE + 5)

//
// Unsupport NT4 database version, for example, beta 2
//
#define ERROR_NOTSUPPORT_DB_VERSION     (UPGRADE_SETUP_ERROR_BASE + 6)

//
// JetBlue database file exists
//
#define ERROR_JETBLUE_DBFILE_ALREADY_EXISTS (UPGRADE_SETUP_ERROR_BASE + 1)

//
// JetBlue database file exists and corrupted
//
#define ERROR_CORRUPT_JETBLUE_DBFILE        (UPGRADE_SETUP_ERROR_BASE + 2)

//
// Can't delete ODBC datasource
//
#define ERROR_DELETE_ODBC_DSN               (UPGRADE_SETUP_ERROR_BASE + 7)

#ifndef LICENOC_SMALL_UPG

//---------------------------------------------------
//
// JetBlue error code.
//
#define UPGRADE_JETBLUE_ERROR_BASE  0xD4000000

#define SET_JB_ERROR(err)   (UPGRADE_JETBLUE_ERROR_BASE + abs(err))

#endif


//---------------------------------------------------
//
// ODBC related error code
//
//---------------------------------------------------
#define UPGRADE_ODBC_ERROR_BASE    0xD8000000

//
// General ODBC error
//
#define ERROR_ODBC_GENERAL              (UPGRADE_ODBC_ERROR_BASE + 1)

//
// ODBC class internal error
//
#define ERROR_ODBC_INTERNAL             (UPGRADE_ODBC_ERROR_BASE + 2)

//
// ODBC Record not found
//
#define ERROR_ODBC_NO_DATA_FOUND        (UPGRADE_ODBC_ERROR_BASE + 3)

//
// SQLConnect() failed.
//
#define ERROR_ODBC_CONNECT              (UPGRADE_ODBC_ERROR_BASE + 4)

//
// SQLAllocConnect() failed
//
#define ERROR_ODBC_ALLOC_CONNECT        (UPGRADE_ODBC_ERROR_BASE + 5)

//
// SQLAllocEnv() failed
//
#define ERROR_ODBC_ALLOC_ENV            (UPGRADE_ODBC_ERROR_BASE + 6)

//
// SQLAllocStmt() failed.
//
#define ERROR_ODBC_ALLOC_STMT           (UPGRADE_ODBC_ERROR_BASE + 7)

//
// SQTransact() failed on commit
//
#define ERROR_ODBC_COMMIT               (UPGRADE_ODBC_ERROR_BASE + 8)

//
// SQTransact() failed on rollback
//
#define ERROR_ODBC_ROLLBACK             (UPGRADE_ODBC_ERROR_BASE + 9)

//
// Cant' allocate ODBC handle, all handle are in use.
//
#define ERROR_ODBC_ALLOCATE_HANDLE      (UPGRADE_ODBC_ERROR_BASE + 10)

//
// SQLPrepare() failed
//
#define ERROR_ODBC_PREPARE              (UPGRADE_ODBC_ERROR_BASE + 11)

//
// Execute() failed
//
#define ERROR_ODBC_EXECUTE              (UPGRADE_ODBC_ERROR_BASE + 12)

//
// ExecDirect() failed
//
#define ERROR_ODBC_EXECDIRECT           (UPGRADE_ODBC_ERROR_BASE + 13)

//
// BindCol failed.
//
#define ERROR_ODBC_BINDCOL              (UPGRADE_ODBC_ERROR_BASE + 14)

//
// BindInputParm() failed.
//
#define ERROR_ODBC_BINDINPUTPARM        (UPGRADE_ODBC_ERROR_BASE + 15)

//
// GetData() failed.
//
#define ERROR_ODBC_GETDATA              (UPGRADE_ODBC_ERROR_BASE + 16)

//
// ParmData() failed.
//
#define ERROR_ODBC_PARMDATA             (UPGRADE_ODBC_ERROR_BASE + 17)

//
// PutData() failed.
//
#define ERROR_ODBC_PUTDATA              (UPGRADE_ODBC_ERROR_BASE + 18)

//
// Corrupted database
//
#define ERROR_ODBC_CORRUPTDATABASEFILE  (UPGRADE_ODBC_ERROR_BASE + 19)   

//
// SQLFtch() failed.
//
#define ERROR_ODBC_FETCH                (UPGRADE_ODBC_ERROR_BASE + 20)   

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\upg4to5\exe\test.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:       test.cpp 
//
// Contents:   Test TS4 license server database upgrade to TS5 
//
// History:     
//
//---------------------------------------------------------------------------
#include <windows.h>
#include <shellapi.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include "upg.h"


void
PrintUsage(
    LPCTSTR pszExeName
    )
/*++

++*/
{
    _tprintf(
            _TEXT("Usage : %s -D <Directory> -F <Db File name>\n"),
            pszExeName
        );

    exit(0);
}

//--------------------------------------------------------------------------

int 
main(
    int argc,
    char* argv[]
    )
/*++


++*/
{
    int     dwArgc;
    LPTSTR  *lpszArgv;
    LPTSTR  pszPath=NULL;
    LPTSTR  pszFile=NULL;

    #ifdef UNICODE
    lpszArgv = CommandLineToArgvW(GetCommandLineW(), &(dwArgc) );
    #else
    dwArgc   = (DWORD) argc;
    lpszArgv = argv;
    #endif


    if(argc < 2)
    {
        PrintUsage(lpszArgv[0]);
    }

    for(int i=1; i < dwArgc; i+=2)
    {
        if(i+1 >= dwArgc || lpszArgv[i][0] != _TEXT('-') || lpszArgv[i+1][0] ==_TEXT('-'))
        {
            // missing argument.
            PrintUsage(lpszArgv[0]);
        }

        switch(lpszArgv[i][1])
        {
            case _TEXT('D') :
            case _TEXT('d') :
                pszPath = lpszArgv[i+1];
                break;

            case _TEXT('F') :
            case _TEXT('f') :
                pszFile = lpszArgv[i+1];
                break;

            default:
                PrintUsage(lpszArgv[0]);
        }
    }

    if(pszPath == NULL)
    {
        PrintUsage(lpszArgv[0]);
    }

     
    DWORD dwStatus;
    dwStatus = UpgradeNT4Database(
                            0,
                            pszPath,
                            pszFile
                        );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\perfts\datats.c ===
/*++ 

Copyright (c) 1997-1998 Microsoft Corporation

Module Name:

    datats.c

Abstract:
       
    Constant data structures used by the Performance Monitor data for the
    Terminal Server User and WinStation performance data objects

Created:

    Erik Mavrinac  25-Nov-1998

Revision History:

    30-Mar-1998 - Last revision of original Terminal Server 4.0
                  counter code base.

--*/

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "datats.h"


// Dummy variables for field sizing.
static PROCESS_COUNTER_DATA pcd;
static WINSTATION_COUNTER_DATA wsd;


//
// We need to define our own counter for ThinWire display.
//

#define PERF_COUNTER_TS_PERCENT        \
            (PERF_SIZE_DWORD | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL |\
             PERF_DISPLAY_NO_SUFFIX)


// Default TS scaling factor for the raw counts.
#define TS_SCALE_FACTOR   (-10000)


#define FIELDSIZE(type, field)   (sizeof(((type *)1)->field))
#define FIELDOFFSET(type, field) ((UINT_PTR)(&((type *)0)->field))


// Note that we set the counter names and descriptions as the offset counters
// from tslabels.h. Later when we load we will read the registry start offset
// and add it into each of the slots below to create the resulting
// real indices. See tslbl009.ini for descriptions.
WINSTATION_DATA_DEFINITION WinStationDataDefinition =
{
    {   sizeof(WINSTATION_DATA_DEFINITION) + sizeof(WINSTATION_COUNTER_DATA),
        sizeof(WINSTATION_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        WINSTATION_OBJECT,
        0,
        WINSTATION_OBJECT + 1,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(WINSTATION_DATA_DEFINITION) - sizeof(PERF_OBJECT_TYPE)) / 
            sizeof(PERF_COUNTER_DEFINITION),
        0,
        0,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {10000000L,0L}
    },

    // Process counters totaled on a per-WinStation basis.
    {   sizeof(PERF_COUNTER_DEFINITION),
        6,
        0,
        189,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_100NSEC_TIMER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.ProcessorTime),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.ProcessorTime)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        142,
        0,
        157,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.UserTime),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.UserTime)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        144,
        0,
        159,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.KernelTime),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.KernelTime)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        172,
        0,
        173,
        0,
        -6,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_LARGE_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.PeakVirtualSize),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.PeakVirtualSize)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        174,
        0,
        175,
        0,
        -6,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_LARGE_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.VirtualSize),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.VirtualSize)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        28,
        0,
        177,
        0,
        -1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.PageFaults),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.PageFaults)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        178,
        0,
        179,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.PeakWorkingSet),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.PeakWorkingSet)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        180,
        0,
        181,
        0,
        -5,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_LARGE_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.TotalWorkingSet),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.TotalWorkingSet)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        182,
        0,
        183,
        0,
        -6,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.PeakPageFile),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.PeakPageFile)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        184,
        0,
        185,
        0,
        -6,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.PageFile),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.PageFile)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        186,
        0,
        187,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.PrivatePages),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.PrivatePages)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        680,
        0,
        681,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.ThreadCount),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.ThreadCount)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        56,
        0,
        57,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.PagedPool),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.PagedPool)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        58,
        0,
        59,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.NonPagedPool),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.NonPagedPool)
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        952,
        0,
        953,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, pcd.HandleCount),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, pcd.HandleCount)
    },


    // Input counters for WinStation protocols

    {   sizeof(PERF_COUNTER_DEFINITION),
        INWDBYTES,
        0,
        INWDBYTES + 1,
        0,
        -2,  // scale
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.WdBytes),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Input.WdBytes),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        INWDFRAMES,
        0,
        INWDFRAMES + 1,
        0,
        0, // no scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.WdFrames),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Input.WdFrames),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        INWAITFOROUTBUF,
        0,
        INWAITFOROUTBUF + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.WaitForOutBuf),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Input.WaitForOutBuf),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        INFRAMES,
        0,
        INFRAMES + 1,
        0,
        0, // no scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.Frames),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Input.Frames),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        INBYTES,
        0,
        INBYTES + 1,
        0,
        -2,  // scale
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.Bytes),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Input.Bytes),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        INCOMPBYTES,
        0,
        INCOMPBYTES + 1,
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.CompressedBytes),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA,
            Input.CompressedBytes),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        INCOMPFLUSHES,
        0,
        INCOMPFLUSHES + 1,
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.CompressFlushes),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA,
            Input.CompressFlushes),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        INERRORS,
        0,
        INERRORS + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.Errors),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Input.Errors),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        INTIMEOUTS,
        0,
        INTIMEOUTS + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.Timeouts),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Input.Timeouts),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        INASYNCFRAMEERR,
        0,
        INASYNCFRAMEERR + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.AsyncFramingError),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Input.AsyncFramingError),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        INASYNCOVERRUN,
        0,
        INASYNCOVERRUN + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.AsyncOverrunError),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Input.AsyncOverrunError),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        INASYNCOVERFLOW,
        0,
        INASYNCOVERFLOW + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.AsyncOverflowError),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Input.AsyncOverflowError),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        INASYNCPARITY,
        0,
        INASYNCPARITY + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.AsyncParityError),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Input.AsyncParityError),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        INTDERRORS,
        0,
        INTDERRORS + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Input.TdErrors),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Input.TdErrors),
    },


    // Output counters for WinStation protocols

    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTWDBYTES,
        0,
        OUTWDBYTES + 1,
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.WdBytes),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.WdBytes),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTWDFRAMES,
        0,
        OUTWDFRAMES + 1,
        0,
        0, // no scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.WdFrames),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.WdFrames),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTWAITFOROUTBUF,
        0,
        OUTWAITFOROUTBUF + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.WaitForOutBuf),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.WaitForOutBuf),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTFRAMES,
        0,
        OUTFRAMES + 1,
        0,
        0, // no scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.Frames),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.Frames),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTBYTES,
        0,
        OUTBYTES + 1,
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.Bytes),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.Bytes),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTCOMPBYTES,
        0,
        OUTCOMPBYTES + 1,
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.CompressedBytes),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.CompressedBytes),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTCOMPFLUSHES,
        0,
        OUTCOMPFLUSHES + 1,
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.CompressFlushes),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.CompressFlushes),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTERRORS,
        0,
        OUTERRORS + 1,
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.Errors),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.Errors),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTTIMEOUTS,
        0,
        OUTTIMEOUTS + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.Timeouts),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.Timeouts),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTASYNCFRAMEERR,
        0,
        OUTASYNCFRAMEERR + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.AsyncFramingError),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.AsyncFramingError),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTASYNCOVERRUN,
        0,
        OUTASYNCOVERRUN + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.AsyncOverrunError),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.AsyncOverrunError),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTASYNCOVERFLOW,
        0,
        OUTASYNCOVERFLOW + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.AsyncOverflowError),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.AsyncOverflowError),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTASYNCPARITY,
        0,
        OUTASYNCPARITY + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.AsyncParityError),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.AsyncParityError),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTTDERRORS,
        0,
        OUTTDERRORS + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Output.TdErrors),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Output.TdErrors),
    },


    // Totals counters

    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALWDBYTES,
        0,
        TOTALWDBYTES + 1,
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.WdBytes),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.WdBytes),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALWDFRAMES,
        0,
        TOTALWDFRAMES + 1,
        0,
        0, // no scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.WdFrames),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.WdFrames),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALWAITFOROUTBUF,
        0,
        TOTALWAITFOROUTBUF + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.WaitForOutBuf),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.WaitForOutBuf),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALFRAMES,
        0,
        TOTALFRAMES + 1,
        0,
        0, // no scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.Frames),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.Frames),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALBYTES,
        0,
        TOTALBYTES + 1,
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.Bytes),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.Bytes),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALCOMPBYTES,
        0,
        TOTALCOMPBYTES + 1,
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.CompressedBytes),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.CompressedBytes),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALCOMPFLUSHES,
        0,
        TOTALCOMPFLUSHES + 1,
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.CompressFlushes),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.CompressFlushes),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALERRORS,
        0,
        TOTALERRORS + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.Errors),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.Errors),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALTIMEOUTS,
        0,
        TOTALTIMEOUTS + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.Timeouts),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.Timeouts),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALASYNCFRAMEERR,
        0,
        TOTALASYNCFRAMEERR + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.AsyncFramingError),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.AsyncFramingError),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALASYNCOVERRUN,
        0,
        TOTALASYNCOVERRUN + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.AsyncOverrunError),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.AsyncOverrunError),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALASYNCOVERFLOW,
        0,
        TOTALASYNCOVERFLOW + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.AsyncOverflowError),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.AsyncOverflowError),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALASYNCPARITY,
        0,
        TOTALASYNCPARITY + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.AsyncParityError),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.AsyncParityError),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALTDERRORS,
        0,
        TOTALTDERRORS + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, Total.TdErrors),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, Total.TdErrors),
    },


    // Display driver statistics -- these are set up the same way for
    // both ICA and RDP.
    {   sizeof(PERF_COUNTER_DEFINITION),
        DDCACHEREAD,
        0,
        DDCACHEREAD + 1,
        0,
        TS_SCALE_FACTOR,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDTotal.CacheReads),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDTotal.CacheReads),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        DDCACHEHIT,
        0,
        DDCACHEHIT + 1,
        0,
        TS_SCALE_FACTOR,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDTotal.CacheHits),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDTotal.CacheHits),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        DDCACHEPERCENT,
        0,
        DDCACHEPERCENT + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_TS_PERCENT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDTotal.HitRatio),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDTotal.HitRatio),
    },


    // Bitmap cache

    {   sizeof(PERF_COUNTER_DEFINITION),
        DDBITMAPCACHEREAD,
        0,
        DDBITMAPCACHEREAD + 1,
        0,
        TS_SCALE_FACTOR,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDBitmap.CacheReads),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDBitmap.CacheReads),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        DDBITMAPCACHEHIT,
        0,
        DDBITMAPCACHEHIT + 1,
        0,
        TS_SCALE_FACTOR,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDBitmap.CacheHits),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDBitmap.CacheHits),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        DDBITMAPCACHEPERCENT,
        0,
        DDBITMAPCACHEPERCENT + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_TS_PERCENT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDBitmap.HitRatio),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDBitmap.HitRatio),
    },

    // Glyph cache

    {   sizeof(PERF_COUNTER_DEFINITION),
        DDGLYPHCACHEREAD,
        0,
        DDGLYPHCACHEREAD + 1,
        0,
        TS_SCALE_FACTOR,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDGlyph.CacheReads),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDGlyph.CacheReads),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        DDGLYPHCACHEHIT,
        0,
        DDGLYPHCACHEHIT + 1,
        0,
        TS_SCALE_FACTOR,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDGlyph.CacheHits),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDGlyph.CacheHits),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        DDGLYPHCACHEPERCENT,
        0,
        DDGLYPHCACHEPERCENT + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_TS_PERCENT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDGlyph.HitRatio),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDGlyph.HitRatio),
    },

    // Brush cache

    {   sizeof(PERF_COUNTER_DEFINITION),
        DDBRUSHCACHEREAD,
        0,
        DDBRUSHCACHEREAD + 1,
        0,
        TS_SCALE_FACTOR,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDBrush.CacheReads),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDBrush.CacheReads),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        DDBRUSHCACHEHIT,
        0,
        DDBRUSHCACHEHIT + 1,
        0,
        TS_SCALE_FACTOR,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDBrush.CacheHits),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDBrush.CacheHits),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        DDBRUSHCACHEPERCENT,
        0,
        DDBRUSHCACHEPERCENT + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_TS_PERCENT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDBrush.HitRatio),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDBrush.HitRatio),
    },

    // Save screen bitmap cache

    {   sizeof(PERF_COUNTER_DEFINITION),
        DDSAVESCRCACHEREAD,
        0,
        DDSAVESCRCACHEREAD + 1,
        0,
        TS_SCALE_FACTOR,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDSaveScr.CacheReads),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDSaveScr.CacheReads),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        DDSAVESCRCACHEHIT,
        0,
        DDSAVESCRCACHEHIT + 1,
        0,
        TS_SCALE_FACTOR,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDSaveScr.CacheHits),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDSaveScr.CacheHits),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        DDSAVESCRCACHEPERCENT,
        0,
        DDSAVESCRCACHEPERCENT + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_TS_PERCENT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, DDSaveScr.HitRatio),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, DDSaveScr.HitRatio),
    },


    // Compression ratios

    {   sizeof(PERF_COUNTER_DEFINITION),
        INCOMPRESS_PERCENT,
        0,
        INCOMPRESS_PERCENT + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_TS_PERCENT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, InputCompressionRatio),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, InputCompressionRatio),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        OUTCOMPRESS_PERCENT,
        0,
        OUTCOMPRESS_PERCENT + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_TS_PERCENT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, OutputCompressionRatio),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, OutputCompressionRatio),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALCOMPRESS_PERCENT,
        0,
        TOTALCOMPRESS_PERCENT + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_TS_PERCENT,
        FIELDSIZE(WINSTATION_COUNTER_DATA, TotalCompressionRatio),
        (DWORD)FIELDOFFSET(WINSTATION_COUNTER_DATA, TotalCompressionRatio),
    },
};



// Counter descriptions for overall data.
TERMSERVER_DATA_DEFINITION TermServerDataDefinition =
{
    {   sizeof(TERMSERVER_DATA_DEFINITION) + sizeof(TERMSERVER_COUNTER_DATA),
        sizeof(TERMSERVER_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        TERMSERVER_OBJECT,
        0,
        TERMSERVER_OBJECT + 1,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(TERMSERVER_DATA_DEFINITION) - sizeof(PERF_OBJECT_TYPE)) / 
            sizeof(PERF_COUNTER_DEFINITION),
        0,
        -1,  // No instances
        UNICODE_CODE_PAGE,
        {0L,0L},
        {10000000L,0L}
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        NUMSESSIONS,
        0,
        NUMSESSIONS + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(TERMSERVER_COUNTER_DATA, NumSessions),
        (DWORD)FIELDOFFSET(TERMSERVER_COUNTER_DATA, NumSessions),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        NUMACTIVESESSIONS,
        0,
        NUMACTIVESESSIONS + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(TERMSERVER_COUNTER_DATA, NumActiveSessions),
        (DWORD)FIELDOFFSET(TERMSERVER_COUNTER_DATA, NumActiveSessions),
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        NUMINACTIVESESSIONS,
        0,
        NUMINACTIVESESSIONS + 1,
        0,
        0,         // No scaling
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        FIELDSIZE(TERMSERVER_COUNTER_DATA, NumInactiveSessions),
        (DWORD)FIELDOFFSET(TERMSERVER_COUNTER_DATA, NumInactiveSessions),
    },
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\tlserver\upg4to5\upgdef.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        upgdef.h
//
// Contents:
//
// History:
//
//---------------------------------------------------------------------------
#ifndef __TLSUPG4TO5DEF_H__
#define __TLSUPG4TO5DEF_H__

#ifndef LICENOC_SMALL_UPG

#include "JetBlue.h"

#endif

#ifdef __cplusplus
extern "C" {
#endif

void
__cdecl
DBGPrintf(
    LPTSTR format, ...
);


BOOL
IsDataSourceInstalled(
    LPTSTR szDataSource,
    unsigned short wConfigMode,
    LPTSTR szDbFile,
    DWORD cbBufSize
);


BOOL
ConfigDataSource(
    HWND     hWnd,
    BOOL     bInstall,
    LPTSTR   szDriver,
    LPTSTR   szDsn,
    LPTSTR   szUser,
    LPTSTR   szPwd,
    LPTSTR   szMdbFile
);

BOOL
RepairDataSource(
    HWND     hWnd,
    LPTSTR   pszDriver,
    LPTSTR   pszDsn,
    LPTSTR   pszUser,
    LPTSTR   pszPwd,
    LPTSTR   pszMdbFile
);


BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData
);

#ifndef LICENOC_SMALL_UPG

DWORD
JetBlueInitAndCreateEmptyDatabase(
    IN LPCTSTR pszDbFilePath,
    IN LPCTSTR pszDbFileName,
    IN LPCTSTR pszUserName,
    IN LPCTSTR pszPassword,
    IN JBInstance& jbInstance,
    IN JBSession& jbSession,
    IN JBDatabase& jbDatabase
);

#endif

DWORD
GetNT4DbConfig(
    LPTSTR pszDsn,
    LPTSTR pszUserName,
    LPTSTR pszPwd,
    LPTSTR pszMdbFile
);

#ifndef LICENOC_SMALL_UPG

DWORD
UpgradeNT4Database(
    IN DWORD dwServerRole,
    IN LPCTSTR pszDbFilePath,
    IN LPCTSTR pszDbFileName,
    IN BOOL bAlwaysDeleteDataSource
);

#endif

void
CleanLicenseServerSecret();

DWORD
DeleteNT4ODBCDataSource();

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\perfts\dataproc.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATAPROC.h

Abstract:

    Header file for the Windows NT Processor Process counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/
#ifndef _DATAPROC_H_
#define _DATAPROC_H_

#ifdef	_DATAPROC_PRIVATE_WS_
#undef	_DATAPROC_PRIVATE_WS_
#endif

//
//  Process data object definitions.
//
//
//  This is the counter structure presently returned by NT.  The
//  Performance Monitor MUST *NOT* USE THESE STRUCTURES!
//

typedef struct _PROCESS_DATA_DEFINITION {
    PERF_OBJECT_TYPE		    ProcessObjectType;
    PERF_COUNTER_DEFINITION	    cdProcessorTime;
    PERF_COUNTER_DEFINITION	    cdUserTime;
    PERF_COUNTER_DEFINITION	    cdKernelTime;
    PERF_COUNTER_DEFINITION	    cdPeakVirtualSize;
    PERF_COUNTER_DEFINITION	    cdVirtualSize;
    PERF_COUNTER_DEFINITION	    cdPageFaults;
    PERF_COUNTER_DEFINITION	    cdPeakWorkingSet;
    PERF_COUNTER_DEFINITION	    cdTotalWorkingSet;
#ifdef _DATAPROC_PRIVATE_WS_
	PERF_COUNTER_DEFINITION		cdPrivateWorkingSet;
	PERF_COUNTER_DEFINITION		cdSharedWorkingSet;
#endif
	PERF_COUNTER_DEFINITION	    cdPeakPageFile;
    PERF_COUNTER_DEFINITION	    cdPageFile;
    PERF_COUNTER_DEFINITION	    cdPrivatePages;
    PERF_COUNTER_DEFINITION     cdThreadCount;
    PERF_COUNTER_DEFINITION     cdBasePriority;
    PERF_COUNTER_DEFINITION     cdElapsedTime;
    PERF_COUNTER_DEFINITION     cdProcessId;
    PERF_COUNTER_DEFINITION     cdCreatorProcessId;
    PERF_COUNTER_DEFINITION     cdPagedPool;
    PERF_COUNTER_DEFINITION     cdNonPagedPool;
    PERF_COUNTER_DEFINITION     cdHandleCount;
    PERF_COUNTER_DEFINITION     cdReadOperationCount;
    PERF_COUNTER_DEFINITION     cdWriteOperationCount;
    PERF_COUNTER_DEFINITION     cdDataOperationCount;
    PERF_COUNTER_DEFINITION     cdOtherOperationCount;
    PERF_COUNTER_DEFINITION     cdReadTransferCount;
    PERF_COUNTER_DEFINITION     cdWriteTransferCount;
    PERF_COUNTER_DEFINITION     cdDataTransferCount;
    PERF_COUNTER_DEFINITION     cdOtherTransferCount;
} PROCESS_DATA_DEFINITION, * PPROCESS_DATA_DEFINITION;

typedef struct _PROCESS_COUNTER_DATA {
    PERF_COUNTER_BLOCK          CounterBlock;
    DWORD                  	    PageFaults;
    LONGLONG                    ProcessorTime;
    LONGLONG                    UserTime;
    LONGLONG                    KernelTime;
    LONGLONG              	    PeakVirtualSize;
    LONGLONG                    VirtualSize;
    LONGLONG               	    PeakWorkingSet;
    LONGLONG               	    TotalWorkingSet;
#ifdef _DATAPROC_PRIVATE_WS_
	LONGLONG			        PrivateWorkingSet;
	LONGLONG			        SharedWorkingSet;
#endif
    LONGLONG                    PeakPageFile;
    LONGLONG                    PageFile;
    LONGLONG                    PrivatePages;
    DWORD                       ThreadCount;
    DWORD                       BasePriority;
    LONGLONG                    ElapsedTime;
    DWORD                       ProcessId;
    DWORD                       CreatorProcessId;
    DWORD                       PagedPool;
    DWORD                       NonPagedPool;
    DWORD                       HandleCount;
    DWORD                       Reserved;   // for alignment
    LONGLONG                    ReadOperationCount;
    LONGLONG                    WriteOperationCount;
    LONGLONG                    DataOperationCount;
    LONGLONG                    OtherOperationCount;
    LONGLONG                    ReadTransferCount;
    LONGLONG                    WriteTransferCount;
    LONGLONG                    DataTransferCount;
    LONGLONG                    OtherTransferCount;
} PROCESS_COUNTER_DATA, * PPROCESS_COUNTER_DATA;

extern PROCESS_DATA_DEFINITION ProcessDataDefinition;

#endif // _DATAPROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\perfts\perfts.c ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation

Module Name:

    perfts.c

Description:
    DLL entry point and support code for Terminal Server performance counters.

Author:

    Erik Mavrinac  24-Nov-1998

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>

#include <winsta.h>
#include <utildll.h>

#include <stdlib.h>

#include "datats.h"


#if DBG
#define DBGPRINT(x) DbgPrint x
#else
#define DBGPRINT(x)
#endif


#define MAX_SESSION_NAME_LENGTH 50


typedef struct _WinStationInfo
{
    LIST_ENTRY HashBucketList;
    LIST_ENTRY UsedList;
    ULONG SessionID;
    WINSTATIONSTATECLASS LastState;
    void *pInstanceInfo;
    WINSTATIONNAMEW WinStationName;
} WinStationInfo;


/****************************************************************************/
// Globals
/****************************************************************************/

// Default hash bucket list to remove having to check for
// pWinStationHashBuckets == NULL on perf path. This array contains the
// default number for one WinStationInfo.
#define NumDefaultWinStationHashBuckets 4
LIST_ENTRY DefaultWinStationHashBuckets[NumDefaultWinStationHashBuckets];

HANDLE hEventLog = NULL;
HANDLE hLibHeap = NULL;
PBYTE pProcessBuffer = NULL;

static DWORD dwOpenCount = 0;
static DWORD ProcessBufSize = LARGE_BUFFER_SIZE;
static DWORD NumberOfCPUs = 0;
static DWORD FirstCounterIndex = 0;

LIST_ENTRY UsedList;
LIST_ENTRY UnusedList;
LIST_ENTRY *pWinStationHashBuckets = DefaultWinStationHashBuckets;
unsigned NumWinStationHashBuckets = NumDefaultWinStationHashBuckets;
ULONG WinStationHashMask = 0x3;
unsigned NumCachedWinStations = 0;

SYSTEM_TIMEOFDAY_INFORMATION SysTimeInfo = {{0,0},{0,0},{0,0},0,0};



/****************************************************************************/
// Prototypes
/****************************************************************************/
BOOL DllProcessAttach(void);
BOOL DllProcessDetach(void);
DWORD GetNumberOfCPUs(void);
NTSTATUS GetDescriptionOffset(void);
void SetupCounterIndices(void);

DWORD APIENTRY OpenWinStationObject(LPWSTR);
DWORD APIENTRY CloseWinStationObject(void);
DWORD APIENTRY CollectWinStationObjectData(IN LPWSTR, IN OUT LPVOID *,
        IN OUT LPDWORD, OUT LPDWORD);

DWORD GetSystemProcessData(void);
void SetupWinStationCounterBlock(WINSTATION_COUNTER_DATA *,
        PWINSTATIONINFORMATIONW);
void UpdateWSProcessCounterBlock(WINSTATION_COUNTER_DATA *,
        PSYSTEM_PROCESS_INFORMATION);

void CreateNewHashBuckets(unsigned);


// Declares these exported functions as PerfMon entry points.
PM_OPEN_PROC    OpenTSObject;
PM_COLLECT_PROC CollectTSObjectData;
PM_CLOSE_PROC   CloseTSObject;



/****************************************************************************/
// DLL system load/unload entry point.
/****************************************************************************/
BOOL __stdcall DllInit(
    IN HANDLE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused)
{
    ReservedAndUnused;

    // This will prevent the DLL from getting
    // the DLL_THREAD_* messages
    DisableThreadLibraryCalls(DLLHandle);

    switch(Reason) {
        case DLL_PROCESS_ATTACH:
            return DllProcessAttach();

        case DLL_PROCESS_DETACH:
            return DllProcessDetach();

        default:
            return TRUE;
    }
}


/****************************************************************************/
// DLL instance load time initialization.
/****************************************************************************/
BOOL DllProcessAttach(void)
{
    unsigned i;
    NTSTATUS Status;

//    DBGPRINT(("PerfTS: ProcessAttach\n"));

    // Create the local heap
    hLibHeap = HeapCreate(0, 1, 0);
    if (hLibHeap == NULL)
        return FALSE;

    // Open handle to the event log
    if (hEventLog == NULL) {
        hEventLog = MonOpenEventLog(L"PerfTS");
        if (hEventLog == NULL)
            goto PostCreateHeap;
    }

    // Get the counter index value and init the WinStationDataDefinition
    // counter values.
    Status = GetDescriptionOffset();
    if (!NT_SUCCESS(Status))
        goto PostOpenEventLog;
    SetupCounterIndices();

    // Pre-determine the number of system CPUs.
    NumberOfCPUs = GetNumberOfCPUs();

    // UsedList is used as a skip-list through all valid entries in the
    // hash table to allow us to iterate all entries without having to have
    // a second, low-performance loop that looks through each hash bucket
    // list.
    InitializeListHead(&UsedList);
    InitializeListHead(&UnusedList);
    for (i = 0; i < NumDefaultWinStationHashBuckets; i++)
        InitializeListHead(&DefaultWinStationHashBuckets[i]);
        
    return TRUE;


// Error handling.

PostOpenEventLog:
    MonCloseEventLog();
    hEventLog = NULL;

PostCreateHeap:
    HeapDestroy(hLibHeap);
    hLibHeap = NULL;

    return FALSE;
}


/****************************************************************************/
// DLL unload cleanup.
/****************************************************************************/
BOOL DllProcessDetach(void)
{
//    DBGPRINT(("PerfTS: ProcessDetach\n"));

    if (dwOpenCount > 0) {
        // the Library is being unloaded before it was
        // closed so close it now as this is the last
        // chance to do it before the library is tossed.
        // if the value of dwOpenCount is > 1, set it to
        // one to insure everything will be closed when
        // the close function is called.
        if (dwOpenCount > 1)
            dwOpenCount = 1;
        CloseTSObject();
    }

    if (hEventLog != NULL) {
        MonCloseEventLog();
        hEventLog = NULL;
    }

    if (hLibHeap != NULL && HeapDestroy(hLibHeap))
        hLibHeap = NULL;

    return TRUE;
}


/****************************************************************************/
// Utility function used at startup.
/****************************************************************************/
DWORD GetNumberOfCPUs(void)
{
    NTSTATUS Status;
    DWORD ReturnLen;
    SYSTEM_BASIC_INFORMATION Info;

    Status = NtQuerySystemInformation(
                 SystemBasicInformation,
                 &Info,
                 sizeof(Info),
                 &ReturnLen
                 );

    if (NT_SUCCESS(Status)) {
        return Info.NumberOfProcessors;
    }
    else {
        DBGPRINT(("GetNumberOfCPUs Error 0x%x returning CPU count\n",Status));
        // Return 1 CPU
        return 1;
    }
}


/****************************************************************************/
// Gets the offset index of the first text description from the
// TermService\Performance key. This value was created by Lodctr /
// LoadPerfCounterTextStrings() during setup.
/****************************************************************************/
NTSTATUS GetDescriptionOffset(void)
{
    HKEY              hTermServiceKey;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS          Status;
    UNICODE_STRING    TermServiceSubKeyString;
    UNICODE_STRING    ValueNameString;
    LONG              ResultLength;
    PKEY_VALUE_PARTIAL_INFORMATION pValueInformation;
    BYTE ValueInfo[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD) - 1];

    // Initialize UNICODE_STRING structures used in this function
    RtlInitUnicodeString(&TermServiceSubKeyString,
            L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\TermService\\Performance");
    RtlInitUnicodeString(&ValueNameString, L"First Counter");

    // Initialize the OBJECT_ATTRIBUTES structure and open the key.
    InitializeObjectAttributes(&Obja, &TermServiceSubKeyString,
            OBJ_CASE_INSENSITIVE, NULL, NULL);
    Status = NtOpenKey(&hTermServiceKey, KEY_READ, &Obja);

    if (NT_SUCCESS(Status)) {
        // read value of desired entry

        pValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)ValueInfo;
        ResultLength = sizeof(ValueInfo);

        Status = NtQueryValueKey(hTermServiceKey, &ValueNameString,
                KeyValuePartialInformation, pValueInformation,
                sizeof(ValueInfo), &ResultLength);

        if (NT_SUCCESS(Status)) {
            // Check to see if it's a DWORD.
            if (pValueInformation->DataLength == sizeof(DWORD) &&
                   pValueInformation->Type == REG_DWORD) {
                FirstCounterIndex = *((DWORD *)(pValueInformation->Data));
            }
            else {
                DBGPRINT(("PerfTS: Len %u not right or type %u not DWORD\n",
                        pValueInformation->DataLength,
                        pValueInformation->Type));
            }
        }
        else {
            DBGPRINT(("PerfTS: Could not read counter value (status=%X)\n",
                    Status));
        }

        // close the registry key
        NtClose(hTermServiceKey);
    }
    else {
        DBGPRINT(("PerfTS: Unable to open TermService\\Performance key "
                "(status=%x)\n", Status));
    }

    return Status;
}


/****************************************************************************/
// Initializes the WinStation and TermServer counter descriptions with the
// loaded counter index offset.
/****************************************************************************/
void SetupCounterIndices(void)
{
    unsigned i;
    unsigned NumCounterDefs;
    PERF_COUNTER_DEFINITION *pCounterDef;

    // First index goes to the WinStation object description and help.
    WinStationDataDefinition.WinStationObjectType.ObjectNameTitleIndex +=
            FirstCounterIndex;
    WinStationDataDefinition.WinStationObjectType.ObjectHelpTitleIndex +=
            FirstCounterIndex;

    // We need to add the FirstCounterIndex value directly into the
    // description and help indices in the WinStation counters in
    // WinStationDataDefinition.
    pCounterDef = &WinStationDataDefinition.InputWdBytes;
    NumCounterDefs = (sizeof(WinStationDataDefinition) -
            (unsigned)((BYTE *)pCounterDef -
            (BYTE *)&WinStationDataDefinition)) /
            sizeof(PERF_COUNTER_DEFINITION);

    for (i = 0; i < NumCounterDefs; i++) {
        pCounterDef->CounterNameTitleIndex += FirstCounterIndex;
        pCounterDef->CounterHelpTitleIndex += FirstCounterIndex;
        pCounterDef++;
    }

    // We need to add the FirstCounterIndex value directly into the
    // description and help indices in the TermServer counters.
    TermServerDataDefinition.TermServerObjectType.ObjectNameTitleIndex +=
            FirstCounterIndex;
    TermServerDataDefinition.TermServerObjectType.ObjectHelpTitleIndex +=
            FirstCounterIndex;
    pCounterDef = &TermServerDataDefinition.NumSessions;
    NumCounterDefs = (sizeof(TermServerDataDefinition) -
            (unsigned)((BYTE *)pCounterDef -
            (BYTE *)&TermServerDataDefinition)) /
            sizeof(PERF_COUNTER_DEFINITION);
    for (i = 0; i < NumCounterDefs; i++) {
        pCounterDef->CounterNameTitleIndex += FirstCounterIndex;
        pCounterDef->CounterHelpTitleIndex += FirstCounterIndex;
        pCounterDef++;
    }
}


/****************************************************************************/
// PerfMon open entry point.
// DeviceNames is ptr to object ID of each device to be opened.
/****************************************************************************/
DWORD APIENTRY OpenTSObject(LPWSTR DeviceNames)
{
//    DBGPRINT(("PerfTS: Open() called\n"));

    dwOpenCount++;

    // Allocate the first process info buffer.
    if (pProcessBuffer == NULL) {
        pProcessBuffer = ALLOCMEM(hLibHeap, HEAP_ZERO_MEMORY, ProcessBufSize);
        if (pProcessBuffer == NULL)
            return ERROR_OUTOFMEMORY;
    }

    return ERROR_SUCCESS;
}


/****************************************************************************/
// PerfMon close entry point.
/****************************************************************************/
DWORD APIENTRY CloseTSObject(void)
{
    PLIST_ENTRY pEntry;
    WinStationInfo *pWSI;

//    DBGPRINT(("PerfTS: Close() called\n"));

    if (--dwOpenCount == 0) {
        if (hLibHeap != NULL) {
            // Free the WinStation cache entries.
            pEntry = UsedList.Flink;
            while (!IsListEmpty(&UsedList)) {
                pEntry = RemoveHeadList(&UsedList);
                pWSI = CONTAINING_RECORD(pEntry, WinStationInfo, UsedList);
                RemoveEntryList(&pWSI->HashBucketList);
                FREEMEM(hLibHeap, 0, pWSI);
            }
            if (pWinStationHashBuckets != DefaultWinStationHashBuckets) {
                FREEMEM(hLibHeap, 0, pWinStationHashBuckets);
                pWinStationHashBuckets = DefaultWinStationHashBuckets;
                NumWinStationHashBuckets = NumDefaultWinStationHashBuckets;
            }

            // Free the proc info buffer.
            if (pProcessBuffer != NULL) {
                FREEMEM(hLibHeap, 0, pProcessBuffer);
                pProcessBuffer = NULL;
            }
        }
    }

    return ERROR_SUCCESS;
}


/****************************************************************************/
// Grabs system process information into global buffer.
/****************************************************************************/
__inline DWORD GetSystemProcessData(void)
{
    DWORD dwReturnedBufferSize;
    NTSTATUS Status;

    // Get process data from system.
    while ((Status = NtQuerySystemInformation(SystemProcessInformation,
            pProcessBuffer, ProcessBufSize, &dwReturnedBufferSize)) ==
            STATUS_INFO_LENGTH_MISMATCH) {
        BYTE *pNewProcessBuffer;

        // Expand buffer & retry. ReAlloc does not free the original mem
        // on error, so alloc into a temp pointer.
        ProcessBufSize += INCREMENT_BUFFER_SIZE;
        pNewProcessBuffer = REALLOCMEM(hLibHeap, 0, pProcessBuffer,
                ProcessBufSize);

        if (pNewProcessBuffer != NULL)
            pProcessBuffer = pNewProcessBuffer;
        else
            return ERROR_OUTOFMEMORY;
    }

    if (NT_SUCCESS(Status)) {
        // Get system time.
        Status = NtQuerySystemInformation(SystemTimeOfDayInformation,
                &SysTimeInfo, sizeof(SysTimeInfo), &dwReturnedBufferSize);
        if (!NT_SUCCESS(Status))
            Status = (DWORD)RtlNtStatusToDosError(Status);
    }
    else {
        // Convert to Win32 error.
        Status = (DWORD)RtlNtStatusToDosError(Status);
    }

    return Status;
}


/****************************************************************************/
// Creates a WinStation name based on the WinStation state.
// Assumes the cache lock is held.
/****************************************************************************/
void ConstructSessionName(
        WinStationInfo *pWSI,
        WINSTATIONINFORMATIONW *pQueryData)
{
    WCHAR *SrcName, *DstName;
    LPCTSTR pState = NULL;

    // Update active/inactive counts and create UI names for sessions.
    if (pQueryData->WinStationName[0] != '\0') {
        // We have a problem with WinStation names --
        // the '#' sign is not allowed. So, replace them
        // with spaces during name copy.
        SrcName = pQueryData->WinStationName;
        DstName = pWSI->WinStationName;
        while (*SrcName != L'\0') {
            if (*SrcName != L'#')
                *DstName = *SrcName;
            else
                *DstName = L' ';
            SrcName++;
            DstName++;
        }
        *DstName = L'\0';
    }
    else {
        // Create a fake session name based on the session ID and
        // an indication of the session state.
        _ltow(pWSI->SessionID, pWSI->WinStationName, 10);
        wcsncat(pWSI->WinStationName, L" ",1);
        pState = StrConnectState(pQueryData->ConnectState, TRUE);
        if(pState)
        {
            wcsncat(pWSI->WinStationName, (const wchar_t *)pState,    
                    (MAX_SESSION_NAME_LENGTH - 1) -
                    wcslen(pWSI->WinStationName));
        }
    }
}


/****************************************************************************/
// Adds a WinStationInfo block (with session ID already filled out) into
// the cache.
// Assumes the cache lock is held.
/****************************************************************************/
void AddWinStationInfoToCache(WinStationInfo *pWSI)
{
    unsigned i;
    unsigned Temp, NumHashBuckets;

    // Add to the hash table.
    InsertHeadList(&pWinStationHashBuckets[pWSI->SessionID &
            WinStationHashMask], &pWSI->HashBucketList);
    NumCachedWinStations++;

    // Check to see if we need to increase the hash table size.
    // If so, allocate a new one and populate it.
    // Hash table size is the number of entries * 4 rounded down
    // to the next lower power of 2, for easy key masking and higher
    // probability of having a low hash bucket list count.
    Temp = 4 * NumCachedWinStations;

    // Find the highest bit set in the hash bucket value.
    for (i = 0; Temp > 1; i++)
        Temp >>= 1;
    NumHashBuckets = 1 << i;
    if (NumWinStationHashBuckets < NumHashBuckets)
        CreateNewHashBuckets(NumHashBuckets);
}


/****************************************************************************/
// Common code for Add and RemoveWinStationInfo.
// Assumes the cache lock is held.
/****************************************************************************/
void CreateNewHashBuckets(unsigned NumHashBuckets)
{
    unsigned i, HashMask;
    PLIST_ENTRY pLI, pEntry, pTempEntry;
    WinStationInfo *pTempWSI;

    if (NumHashBuckets != NumDefaultWinStationHashBuckets)
        pLI = ALLOCMEM(hLibHeap, 0, NumHashBuckets * sizeof(LIST_ENTRY));
    else
        pLI = DefaultWinStationHashBuckets;

    if (pLI != NULL) {
        for (i = 0; i < NumHashBuckets; i++)
            InitializeListHead(&pLI[i]);

        HashMask = NumHashBuckets - 1;

        // Move the old hash table entries into the new table.
        // Have to enumerate all entries in used and unused lists
        // since we are likely to have entries scattered in both places.
        pEntry = UsedList.Flink;
        while (pEntry != &UsedList) {
            pTempWSI = CONTAINING_RECORD(pEntry, WinStationInfo,
                    UsedList);
            InsertHeadList(&pLI[pTempWSI->SessionID &
                    HashMask], &pTempWSI->HashBucketList);
            pEntry = pEntry->Flink;
        }
        pEntry = UnusedList.Flink;
        while (pEntry != &UnusedList) {
            pTempWSI = CONTAINING_RECORD(pEntry, WinStationInfo,
                    UsedList);
            InsertHeadList(&pLI[pTempWSI->SessionID &
                    HashMask], &pTempWSI->HashBucketList);
            pEntry = pEntry->Flink;
        }

        if (pWinStationHashBuckets != DefaultWinStationHashBuckets)
            FREEMEM(hLibHeap, 0, pWinStationHashBuckets);

        NumWinStationHashBuckets = NumHashBuckets;
        WinStationHashMask = HashMask;
        pWinStationHashBuckets = pLI;
    }
    else {
        // On failure, we just leave the hash table alone until next time.
        DBGPRINT(("PerfTS: Could not alloc new hash buckets\n"));
    }
}


/****************************************************************************/
// Removes a WSI from the hash table.
// Assumes the cache lock is held.
/****************************************************************************/
void RemoveWinStationInfoFromCache(WinStationInfo *pWSI)
{
    unsigned i;
    unsigned Temp, NumHashBuckets, HashMask;

    // Remove from the hash table.
    RemoveEntryList(&pWSI->HashBucketList);
    NumCachedWinStations--;

    // Check to see if we need to decrease the hash table size.
    // If so, allocate a new one and populate it.
    // Hash table size is the number of entries * 4 rounded down
    // to the next lower power of 2, for easy key masking and higher
    // probability of having a low hash bucket list count.
    Temp = 4 * NumCachedWinStations;

    // Find the highest bit set in the hash bucket value.
    for (i = 0; Temp > 1; i++)
        Temp >>= 1;
    NumHashBuckets = 1 << i;
    if (NumWinStationHashBuckets < NumHashBuckets &&
            NumWinStationHashBuckets >= 4)
        CreateNewHashBuckets(NumHashBuckets);
}


/****************************************************************************/
// PerfMon collect entry point.
// Args:
//   ValueName: Registry name.
//   ppData: Passes in pointer to the address of the buffer to receive the
//       completed PerfDataBlock and subordinate structures. This routine will
//       append its data to the buffer starting at the point referenced by
//       *ppData. Passes out pointer to the first byte after the data structure
//       added by this routine.
//   pTotalBytes: Passes in ptr to size in bytes of the buf at *ppdata. Passes
//       out number of bytes added if *ppData is changed.
//   pNumObjectTypes: Passes out the number of objects added by this routine.
//
//   Returns: Win32 error code.
/****************************************************************************/
#define WinStationInstanceSize (sizeof(PERF_INSTANCE_DEFINITION) +  \
        (MAX_WINSTATION_NAME_LENGTH + 1) * sizeof(WCHAR) +  \
        2 * sizeof(DWORD) +  /* Allow for QWORD alignment space. */  \
        sizeof(WINSTATION_COUNTER_DATA))

DWORD APIENTRY CollectTSObjectData(
        IN     LPWSTR  ValueName,
        IN OUT LPVOID  *ppData,
        IN OUT LPDWORD pTotalBytes,
        OUT    LPDWORD pNumObjectTypes)
{
    DWORD Result;
    DWORD TotalLen;  //  Length of the total return block
    PERF_INSTANCE_DEFINITION *pPerfInstanceDefinition;
    PSYSTEM_PROCESS_INFORMATION pProcessInfo;
    ULONG NumWinStationInstances;
    NTSTATUS Status;
    ULONG ProcessBufferOffset;
    WINSTATION_DATA_DEFINITION *pWinStationDataDefinition;
    WINSTATION_COUNTER_DATA *pWSC;
    TERMSERVER_DATA_DEFINITION *pTermServerDataDefinition;
    TERMSERVER_COUNTER_DATA *pTSC;
    ULONG SessionId;
    WinStationInfo *pWSI;
    LIST_ENTRY *pEntry;
    unsigned i;
    unsigned ActiveWS, InactiveWS;
    WCHAR *InstanceName;
    ULONG AmountRet;
    WCHAR StringBuf[MAX_SESSION_NAME_LENGTH];
    WINSTATIONINFORMATIONW *pPassedQueryBuf;
    WINSTATIONINFORMATIONW QueryBuffer;

#ifdef COLLECT_TIME
    DWORD StartTick = GetTickCount();
#endif

//    DBGPRINT(("PerfTS: Collect() called\n"));

    pWinStationDataDefinition = (WINSTATION_DATA_DEFINITION *)*ppData;

    // Check for sufficient space for base WinStation object info and
    // as many instances as we currently have in our WinStation database.
    // Add in DWORD sizes for potential QWORD alignments.
    TotalLen = sizeof(WINSTATION_DATA_DEFINITION) + sizeof(DWORD) +
            sizeof(TERMSERVER_DATA_DEFINITION) +
            sizeof(TERMSERVER_COUNTER_DATA) + sizeof(DWORD) +
            NumCachedWinStations * WinStationInstanceSize;
    if (*pTotalBytes >= TotalLen) {
        // Grab the latest system process information.
        Result = GetSystemProcessData();
        if (Result == ERROR_SUCCESS) {
            // Copy WinStation counter definitions.
            memcpy(pWinStationDataDefinition, &WinStationDataDefinition,
                    sizeof(WINSTATION_DATA_DEFINITION));
            pWinStationDataDefinition->WinStationObjectType.PerfTime =
                    SysTimeInfo.CurrentTime;
        }
        else {
            DBGPRINT(("PerfTS: Failed to get process data\n"));
            goto ErrorExit;
        }
    }
    else {
        DBGPRINT(("PerfTS: Not enough space for base WinStation information\n"));
        Result = ERROR_MORE_DATA;
        goto ErrorExit;
    }

    // Before we start, we have to transfer each WinStationInfo in the
    // cache from the used list into an unused list to detect closed
    // WinStations. Also, we need to zero each WSI's pInstanceInfo to detect
    // whether we have retrieved the current I/O data for the WinStation.
    pEntry = UsedList.Blink;
    (UsedList.Flink)->Blink = &UnusedList;  // Patch up head links to UnusedList.
    pEntry->Flink = &UnusedList;
    UnusedList = UsedList;
    InitializeListHead(&UsedList);
    pEntry = UnusedList.Flink;
    while (pEntry != &UnusedList) {
        pWSI = CONTAINING_RECORD(pEntry, WinStationInfo, UsedList);
        pWSI->pInstanceInfo = NULL;
        pEntry = pEntry->Flink;
    }

    // Now collect data for each process, summing it for each unique SessionId.
    ActiveWS = InactiveWS = 0;
    NumWinStationInstances = 0;
    ProcessBufferOffset = 0;
    pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pProcessBuffer;
    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
            &pWinStationDataDefinition[1];

    while (TRUE) {
        // Check for live process (having a name, one or more threads, or
        // not the Idle process (PID==0)). For WinStations we don't want to
        // charge the Idle process to the console (session ID == 0).
        if (pProcessInfo->ImageName.Buffer != NULL &&
                pProcessInfo->NumberOfThreads > 0 &&
                pProcessInfo->UniqueProcessId != 0) {
            // Get the session ID from the process. This is the same as the
            // LogonID in TS4.
            SessionId = pProcessInfo->SessionId;

            // Find the session ID in the cache.
            // We sum all processes seen for a given SessionId into the
            // same WinStation instance data block.
            pEntry = pWinStationHashBuckets[SessionId & WinStationHashMask].
                    Flink;
            while (pEntry != &pWinStationHashBuckets[SessionId &
                    WinStationHashMask]) {
                pWSI = CONTAINING_RECORD(pEntry, WinStationInfo,
                        HashBucketList);
                if (pWSI->SessionID == SessionId) {
                    // Found it. Now check that we've retrieved the WS info.
                    if (pWSI->pInstanceInfo != NULL) {
                        // Context is the WINSTATION_COUNTER_DATA entry
                        // for this SessionId.
                        pWSC = (WINSTATION_COUNTER_DATA *)pWSI->pInstanceInfo;

                        // Now add the values to the existing counter block.
                        UpdateWSProcessCounterBlock(pWSC, pProcessInfo);
                        goto NextProcess;
                    }
                    break;
                }
                else {
                    pEntry = pEntry->Flink;
                }
            }

            // We have a new entry or one for which we have not gathered
            // current information. First grab the info.
            if (WinStationQueryInformationW(SERVERNAME_CURRENT, SessionId,
                    WinStationInformation, &QueryBuffer,
                    sizeof(QueryBuffer), &AmountRet)) {
                if (QueryBuffer.ConnectState == State_Active)
                    ActiveWS++;
                else
                    InactiveWS++;

                // Check for a pre-cached WSI with no stats.
                if (pEntry != &pWinStationHashBuckets[SessionId &
                        WinStationHashMask]) {
                    // Verify the cached state (and thereby the name).
                    if (pWSI->LastState != QueryBuffer.ConnectState) {
                        pWSI->LastState = QueryBuffer.ConnectState;

                        ConstructSessionName(pWSI, &QueryBuffer);
                    }

                    // Remove the entry from the unused list, place on the
                    // used list.
                    RemoveEntryList(&pWSI->UsedList);
                    InsertHeadList(&UsedList, &pWSI->UsedList);
                }
                else {
                    // Alloc a new entry.
                    pWSI = ALLOCMEM(hLibHeap, 0, sizeof(WinStationInfo));
                    if (pWSI != NULL) {
                        pWSI->SessionID = SessionId;
                        pWSI->LastState = QueryBuffer.ConnectState;
                        pWSI->pInstanceInfo = NULL;
                        ConstructSessionName(pWSI, &QueryBuffer);

                        // Add to the used list.
                        InsertHeadList(&UsedList, &pWSI->UsedList);

                        // Add new entry. We may have to increase the
                        // number of hash buckets.
                        AddWinStationInfoToCache(pWSI);
                    }
                    else {
                        DBGPRINT(("PerfTS: Could not alloc new "
                                "WinStationInfo\n"));
                        goto NextProcess;
                    }
                }

                InstanceName = pWSI->WinStationName;
                pPassedQueryBuf = &QueryBuffer;
            }
            else {
                // We have a WinStation Query problem.
                DBGPRINT(("PerfTS: Failed WSQueryInfo(SessID=%u), error=%u\n",
                        SessionId, GetLastError()));

                // We could not open this WinStation, so we will identify
                // it as "ID Unknown" using -1 to StrConnectState.
                _ltow(SessionId, StringBuf, 10);
                wcsncat(StringBuf, L" ", 1);
                wcsncat(StringBuf, 
                        (const wchar_t *)StrConnectState(-1, TRUE),
                        (MAX_SESSION_NAME_LENGTH - 1) - wcslen(StringBuf));
                InstanceName = StringBuf;

                pPassedQueryBuf = NULL;
            }

            // Add space for new instance header, name, and set of counters
            // to TotalLen and see if this instance will fit.
            TotalLen += WinStationInstanceSize;
            if (*pTotalBytes >= TotalLen) {
                NumWinStationInstances++;
            }
            else {
                DBGPRINT(("PerfTS: Not enough space for a new instance "
                        "(cur inst = %u)\n", NumWinStationInstances));
                Result = ERROR_MORE_DATA;
                goto ErrorExitFixupUsedList;
            }

            // MonBuildInstanceDefinition will create an instance of
            // the given supplied name inside of the callers buffer
            // supplied in pPerfInstanceDefinition. Our counter location
            // (the next memory after the instance header and name) is
            // returned in pWSC.
            // By remembering this pointer, and its counter size, we
            // can revisit it to add to the counters.
            MonBuildInstanceDefinition(pPerfInstanceDefinition,
                    (PVOID *)&pWSC, 0, 0, (DWORD)-1, InstanceName);

            // Initialize the new counter block.
            SetupWinStationCounterBlock(pWSC, pPassedQueryBuf);

            // Now set the Context to this counter block so if we
            // see any more processes with this SessionId we
            // can add to the existing counter block.
            pWSI->pInstanceInfo = pWSC;

            // Now load the values into the counter block
            UpdateWSProcessCounterBlock(pWSC, pProcessInfo);

            // set perfdata pointer to next byte if its a new entry
            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)(pWSC + 1);
        }

NextProcess:
        // Exit if this was the last process in list
        if (pProcessInfo->NextEntryOffset != 0) {
            // point to next buffer in list
            ProcessBufferOffset += pProcessInfo->NextEntryOffset;
            pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
                    &pProcessBuffer[ProcessBufferOffset];
        }
        else {
            break;
        }
    }

    // Check for unused WinStations and remove.
    while (!IsListEmpty(&UnusedList)) {
        pEntry = RemoveHeadList(&UnusedList);
        pWSI = CONTAINING_RECORD(pEntry, WinStationInfo, UsedList);
        RemoveWinStationInfoFromCache(pWSI);
        FREEMEM(hLibHeap, 0, pWSI);
    }

    // Note number of WinStation instances.
    pWinStationDataDefinition->WinStationObjectType.NumInstances =
            NumWinStationInstances;

    // Now we know how large an area we used for the
    // WinStation definition, so we can update the offset
    // to the next object definition. Align size on QWORD.
    pTermServerDataDefinition = (TERMSERVER_DATA_DEFINITION *)(
            ALIGN_ON_QWORD(pPerfInstanceDefinition));
    pWinStationDataDefinition->WinStationObjectType.TotalByteLength =
            (DWORD)((PCHAR)pTermServerDataDefinition -
            (PCHAR)pWinStationDataDefinition);

    // Now we set up and fill in the data for the TermServer object,
    // starting at the end of the WinStation instances.
    // No instances here, just fill in headers.
    memcpy(pTermServerDataDefinition, &TermServerDataDefinition,
            sizeof(TERMSERVER_DATA_DEFINITION));
    pTermServerDataDefinition->TermServerObjectType.PerfTime =
            SysTimeInfo.CurrentTime;
    pTSC = (TERMSERVER_COUNTER_DATA *)(pTermServerDataDefinition + 1);
    pTSC->CounterBlock.ByteLength = sizeof(TERMSERVER_COUNTER_DATA);
    pTSC->NumActiveSessions = ActiveWS;
    pTSC->NumInactiveSessions = InactiveWS;
    pTSC->NumSessions = ActiveWS + InactiveWS;

    // Return final sizes. Align final address on a QWORD size.
    *ppData = ALIGN_ON_QWORD((LPVOID)(pTSC + 1));
    pTermServerDataDefinition->TermServerObjectType.TotalByteLength =
            (DWORD)((PBYTE)*ppData - (PBYTE)pTermServerDataDefinition);
    *pTotalBytes = (DWORD)((PBYTE)*ppData - (PBYTE)pWinStationDataDefinition);
    *pNumObjectTypes = 2;

#if DBG
    if (*pTotalBytes > TotalLen)
        DbgPrint ("PerfTS: Perf ctr. instance size underestimated: "
                "Est.=%u, Actual=%u", TotalLen, *pTotalBytes);
#endif


#ifdef COLLECT_TIME
    DbgPrint("*** Elapsed msec=%u\n", GetTickCount() - StartTick);
#endif

    return ERROR_SUCCESS;


// Error handling.

ErrorExitFixupUsedList:
    // We have to return the UnusedList entries to the used list and exit the
    // cache lock.
    while (!IsListEmpty(&UnusedList)) {
        pEntry = RemoveHeadList(&UnusedList);
        InsertHeadList(&UsedList, pEntry);
    }

ErrorExit:
    *pNumObjectTypes = 0;
    *pTotalBytes = 0;
    return Result;
}


#define CalculatePercent(count, hits) ((count) ? (hits) * 100 / (count) : 0)

/****************************************************************************/
// SetupWinStationCounterBlock
//
// Initializes a new WinStation counter block.
//
// Args:
//   pCounters (input)
//     pointer to WinStation performance counter block
//
//   pInfo (input)
//     Pointer to WINSTATIONINFORMATION structure to extract counters from
//
//   pNextByte (output)
//     Returns the pointer to the byte beyound the end of the buffer.
/****************************************************************************/
void SetupWinStationCounterBlock(
        WINSTATION_COUNTER_DATA *pCounters,
        PWINSTATIONINFORMATIONW pInfo)
{
    // Fill in the WinStation information if available.
    if (pInfo != NULL) {
        PPROTOCOLCOUNTERS pi, po;
        PTHINWIRECACHE    p;
        ULONG TotalReads = 0, TotalHits = 0;
        int i;

        // Set all members of pCounters->pcd to zero since we are not going to
        // init at this time. Then set the included PERF_COUNTER_BLOCK
        // byte length.
        memset(&pCounters->pcd, 0, sizeof(pCounters->pcd));
        pCounters->pcd.CounterBlock.ByteLength = sizeof(
                WINSTATION_COUNTER_DATA);

        pi = &pInfo->Status.Input;
        po = &pInfo->Status.Output;

        // Copy input and output counters.
        memcpy(&pCounters->Input, pi, sizeof(PROTOCOLCOUNTERS));
        memcpy(&pCounters->Output, po, sizeof(PROTOCOLCOUNTERS));

        // Calculate I/O totals.
        pCounters->Total.WdBytes = pi->WdBytes + po->WdBytes;
        pCounters->Total.WdFrames = pi->WdFrames + po->WdFrames;
        pCounters->Total.Frames = pi->Frames + po->Frames;
        pCounters->Total.Bytes = pi->Bytes + po->Bytes;
        pCounters->Total.CompressedBytes = pi->CompressedBytes +
                po->CompressedBytes;
        pCounters->Total.CompressFlushes = pi->CompressFlushes +
                po->CompressFlushes;
        pCounters->Total.Errors = pi->Errors + po->Errors;
        pCounters->Total.Timeouts = pi->Timeouts + po->Timeouts;
        pCounters->Total.AsyncFramingError = pi->AsyncFramingError +
                po->AsyncFramingError;
        pCounters->Total.AsyncOverrunError = pi->AsyncOverrunError +
                po->AsyncOverrunError;
        pCounters->Total.AsyncOverflowError = pi->AsyncOverflowError +
                po->AsyncOverflowError;
        pCounters->Total.AsyncParityError = pi->AsyncParityError +
                po->AsyncParityError;
        pCounters->Total.TdErrors = pi->TdErrors + po->TdErrors;

        // Display driver cache info.

        // Bitmap cache.
        p = &pInfo->Status.Cache.Specific.IcaCacheStats.ThinWireCache[0];
        pCounters->DDBitmap.CacheReads = p->CacheReads;
        pCounters->DDBitmap.CacheHits = p->CacheHits;
        pCounters->DDBitmap.HitRatio = CalculatePercent(p->CacheReads,
                p->CacheHits);
        TotalReads += p->CacheReads;
        TotalHits += p->CacheHits;

        // Glyph cache.
        p = &pInfo->Status.Cache.Specific.IcaCacheStats.ThinWireCache[1];
        pCounters->DDGlyph.CacheReads = p->CacheReads;
        pCounters->DDGlyph.CacheHits = p->CacheHits;
        pCounters->DDGlyph.HitRatio = CalculatePercent(p->CacheReads,
                p->CacheHits);
        TotalReads += p->CacheReads;
        TotalHits += p->CacheHits;

        // Brush cache.
        p = &pInfo->Status.Cache.Specific.IcaCacheStats.ThinWireCache[2];
        pCounters->DDBrush.CacheReads = p->CacheReads;
        pCounters->DDBrush.CacheHits = p->CacheHits;
        pCounters->DDBrush.HitRatio = CalculatePercent(p->CacheReads,
                p->CacheHits);
        TotalReads += p->CacheReads;
        TotalHits += p->CacheHits;

        // Save screen bitmap cache.
        p = &pInfo->Status.Cache.Specific.IcaCacheStats.ThinWireCache[3];
        pCounters->DDSaveScr.CacheReads = p->CacheReads;
        pCounters->DDSaveScr.CacheHits = p->CacheHits;
        pCounters->DDSaveScr.HitRatio = CalculatePercent(p->CacheReads,
                p->CacheHits);
        TotalReads += p->CacheReads;
        TotalHits += p->CacheHits;

        // Cache totals.
        pCounters->DDTotal.CacheReads = TotalReads;
        pCounters->DDTotal.CacheHits = TotalHits;
        pCounters->DDTotal.HitRatio = CalculatePercent(TotalReads,
                TotalHits);

        // Compression PD ratios
        pCounters->InputCompressionRatio = CalculatePercent(
                pi->CompressedBytes, pi->Bytes);
        pCounters->OutputCompressionRatio = CalculatePercent(
                po->CompressedBytes, po->Bytes);
        pCounters->TotalCompressionRatio = CalculatePercent(
                pi->CompressedBytes + po->CompressedBytes,
                pi->Bytes + po->Bytes);
    }
    else {
        // Set all the counters to zero and then the perf block length.
        memset(pCounters, 0, sizeof(*pCounters));
        pCounters->pcd.CounterBlock.ByteLength = sizeof(
                WINSTATION_COUNTER_DATA);
    }
}


/****************************************************************************/
// UpdateWSProcessCounterBlock
//
// Add the entries for the given process to the supplied counter block
//
// Args:
//   pCounters (input)
//     pointer to WS performance counter block
//
//   ProcessInfo (input)
//     pointer to an NT SYSTEM_PROCESS_INFORMATION block
/****************************************************************************/
void UpdateWSProcessCounterBlock(
        WINSTATION_COUNTER_DATA *pCounters,
        PSYSTEM_PROCESS_INFORMATION pProcessInfo)
{
    pCounters->pcd.PageFaults += pProcessInfo->PageFaultCount;

    // User, Kernel and Processor Time counters need to be scaled by the
    // number of processors.
    pCounters->pcd.ProcessorTime += (pProcessInfo->KernelTime.QuadPart +
            pProcessInfo->UserTime.QuadPart) / NumberOfCPUs;
    pCounters->pcd.UserTime += pProcessInfo->UserTime.QuadPart /
            NumberOfCPUs;
    pCounters->pcd.KernelTime += pProcessInfo->KernelTime.QuadPart /
            NumberOfCPUs;

    pCounters->pcd.PeakVirtualSize += pProcessInfo->PeakVirtualSize;
    pCounters->pcd.VirtualSize += pProcessInfo->VirtualSize;
    pCounters->pcd.PeakWorkingSet += pProcessInfo->PeakWorkingSetSize;
    pCounters->pcd.TotalWorkingSet += pProcessInfo->WorkingSetSize;
    pCounters->pcd.PeakPageFile += pProcessInfo->PeakPagefileUsage;
    pCounters->pcd.PageFile += pProcessInfo->PagefileUsage;
    pCounters->pcd.PrivatePages += pProcessInfo->PrivatePageCount;
    pCounters->pcd.ThreadCount += pProcessInfo->NumberOfThreads;
    // BasePriority, ElapsedTime, ProcessId, CreatorProcessId not totaled.
    pCounters->pcd.PagedPool += (DWORD)pProcessInfo->QuotaPagedPoolUsage;
    pCounters->pcd.NonPagedPool += (DWORD)pProcessInfo->QuotaNonPagedPoolUsage;
    pCounters->pcd.HandleCount += (DWORD)pProcessInfo->HandleCount;
    // I/O counts not totaled at this time.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\perfts\perfmsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1995 Microsoft Corporation

Module Name:

    perfmsg.h  

Abstract:

    This file provides the macros and definitions used by the extensible
    counters for reporting events to the event logging facility

Author:

    Bob Watson  28-Jul-1995

Revision History:


--*/
#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_
//
// Report error message ID's for Counters
//

#define APP_NAME    (TEXT("Perflib"))

//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//    Levels:  LOG_NONE = No event log messages ever
//             LOG_USER = User event log messages (e.g. errors)
//             LOG_DEBUG = Minimum Debugging 
//             LOG_VERBOSE = Maximum Debugging 
//

#define  LOG_NONE     0
#define  LOG_USER     1
#define  LOG_DEBUG    2
#define  LOG_VERBOSE  3

#define  MESSAGE_LEVEL_DEFAULT  LOG_USER

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//    REPORT_xxx (message_value, message_level)
//       where:   
//          xxx is the severity to be displayed in the event log
//          message_value is the numeric ID from above
//          message_level is the "filtering" level of error reporting
//             using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the 
// 
//    REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//

//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could 
// (should) be changed  in the future
//


#define REPORT_SUCCESS(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_WARNING(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_ERROR(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_WARNING_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_ERROR_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

// External Variables

extern HANDLE hEventLog;   // handle to event log
extern DWORD  dwLogUsers;  // counter of event log using routines
extern DWORD  MESSAGE_LEVEL; // event logging detail level

#endif //_PERFMSG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\perfts\datats.h ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation

Module Name:

      datats.h

Abstract:

    Header file for the Windows NT Terminal Server performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry. Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Erik Mavrinac 25-Nov-1998

Revision History:

    30-Mar-1998 - Last revision of original Terminal Server 4.0
                  counter code base.

--*/

#ifndef __DATATS_H
#define __DATATS_H

#include <winsta.h>

#include "tslabels.h"

#include "dataproc.h"


// The WinStation data object shows the system resource usage of a
// given WinStation instance (SessionID).
//
// A Terminal Server WinStation instance is a CSRSS process and its
// client applications and subsystems. It represents a unique session
// on the Terminal Server system, and is addressed by a SessionID.
typedef struct _WINSTATION_DATA_DEFINITION
{
    PERF_OBJECT_TYPE            WinStationObjectType;

    // Summation of Process information for all WinStation processes
    PERF_COUNTER_DEFINITION     ProcessorTime;
    PERF_COUNTER_DEFINITION     UserTime;
    PERF_COUNTER_DEFINITION     KernelTime;
    PERF_COUNTER_DEFINITION     PeakVirtualSize;
    PERF_COUNTER_DEFINITION     VirtualSize;
    PERF_COUNTER_DEFINITION     PageFaults;
    PERF_COUNTER_DEFINITION     PeakWorkingSet;
    PERF_COUNTER_DEFINITION     WorkingSet;
    PERF_COUNTER_DEFINITION     PeakPageFile;
    PERF_COUNTER_DEFINITION     PageFile;
    PERF_COUNTER_DEFINITION     PrivatePages;
    PERF_COUNTER_DEFINITION     ThreadCount;
    PERF_COUNTER_DEFINITION     PagedPool;
    PERF_COUNTER_DEFINITION     NonPagedPool;
    PERF_COUNTER_DEFINITION     HandleCount;

    // Input counters for WinStation protocols
    PERF_COUNTER_DEFINITION     InputWdBytes;
    PERF_COUNTER_DEFINITION     InputWdFrames;
    PERF_COUNTER_DEFINITION     InputWaitForOutBuf;
    PERF_COUNTER_DEFINITION     InputFrames;
    PERF_COUNTER_DEFINITION     InputBytes;
    PERF_COUNTER_DEFINITION     InputCompressedBytes;
    PERF_COUNTER_DEFINITION     InputCompressedFlushes;
    PERF_COUNTER_DEFINITION     InputErrors;
    PERF_COUNTER_DEFINITION     InputTimeouts;
    PERF_COUNTER_DEFINITION     InputAsyncFramingError;
    PERF_COUNTER_DEFINITION     InputAsyncOverrunError;
    PERF_COUNTER_DEFINITION     InputAsyncOverFlowError;
    PERF_COUNTER_DEFINITION     InputAsyncParityError;
    PERF_COUNTER_DEFINITION     InputTdErrors;

    // Output counters for WinStation protocols
    PERF_COUNTER_DEFINITION     OutputWdBytes;
    PERF_COUNTER_DEFINITION     OutputWdFrames;
    PERF_COUNTER_DEFINITION     OutputWaitForOutBuf;
    PERF_COUNTER_DEFINITION     OutputFrames;
    PERF_COUNTER_DEFINITION     OutputBytes;
    PERF_COUNTER_DEFINITION     OutputCompressedBytes;
    PERF_COUNTER_DEFINITION     OutputCompressedFlushes;
    PERF_COUNTER_DEFINITION     OutputErrors;
    PERF_COUNTER_DEFINITION     OutputTimeouts;
    PERF_COUNTER_DEFINITION     OutputAsyncFramingError;
    PERF_COUNTER_DEFINITION     OutputAsyncOverrunError;
    PERF_COUNTER_DEFINITION     OutputAsyncOverFlowError;
    PERF_COUNTER_DEFINITION     OutputAsyncParityError;
    PERF_COUNTER_DEFINITION     OutputTdErrors;

    // Totals counters for WinStation protocols
    PERF_COUNTER_DEFINITION     TotalWdBytes;
    PERF_COUNTER_DEFINITION     TotalWdFrames;
    PERF_COUNTER_DEFINITION     TotalWaitForOutBuf;
    PERF_COUNTER_DEFINITION     TotalFrames;
    PERF_COUNTER_DEFINITION     TotalBytes;
    PERF_COUNTER_DEFINITION     TotalCompressedBytes;
    PERF_COUNTER_DEFINITION     TotalCompressedFlushes;
    PERF_COUNTER_DEFINITION     TotalErrors;
    PERF_COUNTER_DEFINITION     TotalTimeouts;
    PERF_COUNTER_DEFINITION     TotalAsyncFramingError;
    PERF_COUNTER_DEFINITION     TotalAsyncOverrunError;
    PERF_COUNTER_DEFINITION     TotalAsyncOverFlowError;
    PERF_COUNTER_DEFINITION     TotalAsyncParityError;
    PERF_COUNTER_DEFINITION     TotalTdErrors;

    // Cumulative display driver cache stats.
    PERF_COUNTER_DEFINITION     DDCacheReadsTotal;
    PERF_COUNTER_DEFINITION     DDCacheHitsTotal;
    PERF_COUNTER_DEFINITION     DDCachePercentTotal;

    PERF_COUNTER_DEFINITION     DDBitmapCacheReads;
    PERF_COUNTER_DEFINITION     DDBitmapCacheHits;
    PERF_COUNTER_DEFINITION     DDBitmapCachePercent;

    PERF_COUNTER_DEFINITION     DDGlyphCacheReads;
    PERF_COUNTER_DEFINITION     DDGlyphCacheHits;
    PERF_COUNTER_DEFINITION     DDGlyphCachePercent;

    PERF_COUNTER_DEFINITION     DDBrushCacheReads;
    PERF_COUNTER_DEFINITION     DDBrushCacheHits;
    PERF_COUNTER_DEFINITION     DDBrushCachePercent;

    PERF_COUNTER_DEFINITION     DDSaveBitmapCacheReads;
    PERF_COUNTER_DEFINITION     DDSaveBitmapCacheHits;
    PERF_COUNTER_DEFINITION     DDSaveBitmapCachePercent;

    // Compression percentage on compression PD.
    PERF_COUNTER_DEFINITION     InputCompressPercent;
    PERF_COUNTER_DEFINITION     OutputCompressPercent;
    PERF_COUNTER_DEFINITION     TotalCompressPercent;
} WINSTATION_DATA_DEFINITION, *PWINSTATION_DATA_DEFINITION;


typedef struct {
    ULONG CacheReads;
    ULONG CacheHits;
    ULONG HitRatio;
} DisplayDriverCacheInfo;

typedef struct _WINSTATION_COUNTER_DATA
{
    // From ..\process\dataproc.h. Contains a PERF_COUNTER_BLOCK header.
    // NOTE: Needs to be first for the COUNTER_BLOCK to be first.
    PROCESS_COUNTER_DATA pcd;

    // From winsta.h
    PROTOCOLCOUNTERS Input;
    PROTOCOLCOUNTERS Output;
    PROTOCOLCOUNTERS Total;

    // Cache statistics.
    DisplayDriverCacheInfo DDTotal;
    DisplayDriverCacheInfo DDBitmap;
    DisplayDriverCacheInfo DDGlyph;
    DisplayDriverCacheInfo DDBrush;
    DisplayDriverCacheInfo DDSaveScr;

    // Protocol statistics.
    ULONG InputCompressionRatio;
    ULONG OutputCompressionRatio;
    ULONG TotalCompressionRatio;
} WINSTATION_COUNTER_DATA, *PWINSTATION_COUNTER_DATA;



// Overall data for Terminal Services.
typedef struct _TERMSERVER_DATA_DEFINITION
{
    PERF_OBJECT_TYPE            TermServerObjectType;

    PERF_COUNTER_DEFINITION     NumSessions;
    PERF_COUNTER_DEFINITION     NumActiveSessions;
    PERF_COUNTER_DEFINITION     NumInactiveSessions;
} TERMSERVER_DATA_DEFINITION, *PTERMSERVER_DATA_DEFINITION;

typedef struct
{
    PERF_COUNTER_BLOCK CounterBlock;
    DWORD NumSessions;
    DWORD NumActiveSessions;
    DWORD NumInactiveSessions;
} TERMSERVER_COUNTER_DATA;


// Other defines.
#define MAX_PROCESS_NAME_LENGTH    (MAX_PATH * sizeof(WCHAR))
#define MAX_USER_NAME_LENGTH       MAX_PROCESS_NAME_LENGTH
#define MAX_WINSTATION_NAME_LENGTH MAX_PROCESS_NAME_LENGTH


// Externs
extern WINSTATION_DATA_DEFINITION WinStationDataDefinition;
extern TERMSERVER_DATA_DEFINITION TermServerDataDefinition;



#endif // __DATATS_H


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\perfts\tslabels.h ===
/* (C) 1997-1998 Microsoft Corp.
 *
 * tslabels.h
 *
 * PerfMon Lodctr utility offsets for TS perf objects.
 */

// TS defined counter names and explain text defines
#define WINSTATION_OBJECT             0

// Input
#define INWDBYTES                     2
#define INWDFRAMES                    4
#define INWAITFOROUTBUF               6
#define INFRAMES                      8
#define INBYTES                       10
#define INCOMPBYTES                   12
#define INCOMPFLUSHES                 14
#define INERRORS                      16
#define INTIMEOUTS                    18
#define INASYNCFRAMEERR               20
#define INASYNCOVERRUN                22
#define INASYNCOVERFLOW               24
#define INASYNCPARITY                 26
#define INTDERRORS                    28

// Output
#define OUTWDBYTES                    30
#define OUTWDFRAMES                   32
#define OUTWAITFOROUTBUF              34
#define OUTFRAMES                     36
#define OUTBYTES                      38
#define OUTCOMPBYTES                  40
#define OUTCOMPFLUSHES                42
#define OUTERRORS                     44
#define OUTTIMEOUTS                   46
#define OUTASYNCFRAMEERR              48
#define OUTASYNCOVERRUN               50
#define OUTASYNCOVERFLOW              52
#define OUTASYNCPARITY                54
#define OUTTDERRORS                   56

// Totals
#define TOTALWDBYTES                  58
#define TOTALWDFRAMES                 60
#define TOTALWAITFOROUTBUF            62
#define TOTALFRAMES                   64
#define TOTALBYTES                    66
#define TOTALCOMPBYTES                68
#define TOTALCOMPFLUSHES              70
#define TOTALERRORS                   72
#define TOTALTIMEOUTS                 74
#define TOTALASYNCFRAMEERR            76
#define TOTALASYNCOVERRUN             78
#define TOTALASYNCOVERFLOW            80
#define TOTALASYNCPARITY              82
#define TOTALTDERRORS                 84

// Display driver cache counter entries
// Totals
#define DDCACHEREAD                   86
#define DDCACHEHIT                    88
#define DDCACHEPERCENT                90

// Bitmap cache
#define DDBITMAPCACHEREAD             92
#define DDBITMAPCACHEHIT              94
#define DDBITMAPCACHEPERCENT          96

// Glyph cache
#define DDGLYPHCACHEREAD              98
#define DDGLYPHCACHEHIT               100
#define DDGLYPHCACHEPERCENT           102

// Brush cache
#define DDBRUSHCACHEREAD              104
#define DDBRUSHCACHEHIT               106
#define DDBRUSHCACHEPERCENT           108

// Save screen bitmap cache
#define DDSAVESCRCACHEREAD            110
#define DDSAVESCRCACHEHIT             112
#define DDSAVESCRCACHEPERCENT         114

// Compression PD ratio
#define INCOMPRESS_PERCENT            116
#define OUTCOMPRESS_PERCENT           118
#define TOTALCOMPRESS_PERCENT         120

#define LAST_WINSTATION_COUNTER_OFFSET TOTALCOMPRESS_PERCENT



// TermServer object definitions.
#define TERMSERVER_OBJECT             122
#define NUMSESSIONS                   124
#define NUMACTIVESESSIONS             126
#define NUMINACTIVESESSIONS           128

#define LAST_TERMSERVER_COUNTER_OFFSET NUMINACTIVESESSIONS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\perfts\perfutil.c ===
/*++

Copyright (c) 1995-6  Microsoft Corporation

Module Name:

    perfutil.c

Abstract:

    This file implements the utility routines used to construct the
    common parts of a PERF_INSTANCE_DEFINITION (see winperf.h) and
    perform event logging functions.

Created:

    Bob Watson  28-Jul-1995

Revision History:

--*/
//
//  include files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <string.h>
#include <winperf.h>
#include "perfutil.h"
#include "perfmsg.h"

//
// Global data definitions.
//

ULONG ulInfoBufferSize = 0;

extern HANDLE hEventLog;      // event log handle for reporting events
                              // initialized in Open... routines
DWORD  dwLogUsers = 0;        // count of functions using event log

DWORD MESSAGE_LEVEL = 0;

const WCHAR GLOBAL_STRING[] = L"Global";
const WCHAR FOREIGN_STRING[] = L"Foreign";
const WCHAR COSTLY_STRING[] = L"Costly";

const WCHAR NULL_STRING[] = L"\0";    // pointer to null string

const WCHAR  szTotalValue[] = L"TotalInstanceName";
const WCHAR  szDefaultTotalString[] = L"_Total";

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


LONG
GetPerflibKeyValue (
    LPCWSTR szItem,
    DWORD   dwRegType,
    DWORD   dwMaxSize,      // ... of pReturnBuffer in bytes
    LPVOID  pReturnBuffer,
    DWORD   dwDefaultSize,  // ... of pDefault in bytes
    LPVOID  pDefault
)
/*++

    read and return the current value of the specified value
    under the Perflib registry key. If unable to read the value
    return the default value from the argument list.

    the value is returned in the pReturnBuffer.

--*/
{

    HKEY                    hPerflibKey;
    OBJECT_ATTRIBUTES       Obja;
    NTSTATUS                Status;
    UNICODE_STRING          PerflibSubKeyString;
    UNICODE_STRING          ValueNameString;
    LONG                    lReturn;
    PKEY_VALUE_PARTIAL_INFORMATION  pValueInformation;
    DWORD                   ValueBufferLength;
    DWORD                   ResultLength;
    BOOL                    bUseDefault = TRUE;

    // initialize UNICODE_STRING structures used in this function

    RtlInitUnicodeString (
        &PerflibSubKeyString,
        L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib");

    RtlInitUnicodeString (
        &ValueNameString,
        (LPWSTR)szItem);

    //
    // Initialize the OBJECT_ATTRIBUTES structure and open the key.
    //
    InitializeObjectAttributes(
            &Obja,
            &PerflibSubKeyString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

    Status = NtOpenKey(
                &hPerflibKey,
                KEY_READ,
                &Obja
                );

    if (NT_SUCCESS( Status )) {
        // read value of desired entry

        ValueBufferLength = ResultLength = 1024;
        pValueInformation = ALLOCMEM(RtlProcessHeap(), 0, ResultLength);

        if (pValueInformation != NULL) {
            while ( (Status = NtQueryValueKey(hPerflibKey,
                                            &ValueNameString,
                                            KeyValuePartialInformation,
                                            pValueInformation,
                                            ValueBufferLength,
                                            &ResultLength))
                    == STATUS_BUFFER_OVERFLOW ) {

                pValueInformation = REALLOCMEM(RtlProcessHeap(), 0,
                                                        pValueInformation,
                                                        ResultLength);
                if ( pValueInformation == NULL) {
                    break;
                } else {
                    ValueBufferLength = ResultLength;
                }
            }

            if (NT_SUCCESS(Status)) {
                // check to see if it's the desired type
                if (pValueInformation->Type == dwRegType) {
                    // see if it will fit
                    if (pValueInformation->DataLength <= dwMaxSize) {
                        memcpy (pReturnBuffer, &pValueInformation->Data[0],
                            pValueInformation->DataLength);
                        bUseDefault = FALSE;
                        lReturn = STATUS_SUCCESS;
                    }
                }
            } else {
                // return the default value
                lReturn = Status;
            }

            // Release temp buffer. Check pValueInfo again since
            // the realloc may have failed above.
            if (pValueInformation != NULL) {
                FREEMEM (RtlProcessHeap(), 0, pValueInformation);
            }
        } else {
            // unable to allocate memory for this operation so
            // just return the default value
        }

        // close the registry key
        NtClose(hPerflibKey);
    } else {
        // return default value
    }

    if (bUseDefault) {
        memcpy (pReturnBuffer, pDefault, dwDefaultSize);
        lReturn = STATUS_SUCCESS;
    }

    return lReturn;
}


HANDLE
MonOpenEventLog (
    IN  LPWSTR  szAppName
)
/*++

Routine Description:

    Reads the level of event logging from the registry and opens the
        channel to the event logger for subsequent event log entries.

Arguments:

      None

Return Value:

    Handle to the event log for reporting events.
    NULL if open not successful.

--*/
{
    HKEY hAppKey;
    TCHAR LogLevelKeyName[] = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib");
    TCHAR LogLevelValueName[] = TEXT("EventLogLevel");

    LONG lStatus;

    DWORD dwLogLevel;
    DWORD dwValueType;
    DWORD dwValueSize;

    // if global value of the logging level not initialized or is disabled,
    //  check the registry to see if it should be updated.

    if (!MESSAGE_LEVEL) {

       lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                               LogLevelKeyName,
                               0,
                               KEY_READ,
                               &hAppKey);

       dwValueSize = sizeof (dwLogLevel);

       if (lStatus == ERROR_SUCCESS) {
            lStatus = RegQueryValueEx (hAppKey,
                               LogLevelValueName,
                               (LPDWORD)NULL,
                               &dwValueType,
                               (LPBYTE)&dwLogLevel,
                               &dwValueSize);

            if (lStatus == ERROR_SUCCESS) {
               MESSAGE_LEVEL = dwLogLevel;
            } else {
               MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
            }
            RegCloseKey (hAppKey);
       } else {
         MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
       }
    }

    if (hEventLog == NULL){
         hEventLog = RegisterEventSourceW (
            (LPWSTR)NULL,            // Use Local Machine
            szAppName);               // event log app name to find in registry
    }

    if (hEventLog != NULL) {
         dwLogUsers++;           // increment count of perfctr log users
    }
    return (hEventLog);
}


VOID
MonCloseEventLog (
)
/*++

Routine Description:

      Closes the handle to the event logger if this is the last caller

Arguments:

      None

Return Value:

      None

--*/
{
    if (hEventLog != NULL) {
        dwLogUsers--;         // decrement usage
        if (dwLogUsers <= 0) {    // and if we're the last, then close up log
            DeregisterEventSource (hEventLog);
        }
    }
}

DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = (LPWSTR)GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = (LPWSTR)FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = (LPWSTR)COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }
    return FALSE;
}   // IsNumberInUnicodeList


BOOL
MonBuildInstanceDefinition(
    PERF_INSTANCE_DEFINITION *pBuffer,
    PVOID *pBufferNext,
    DWORD ParentObjectTitleIndex,
    DWORD ParentObjectInstance,
    DWORD UniqueID,
    LPWSTR Name
    )
/*++

    MonBuildInstanceDefinition  -   Build an instance of an object

        Inputs:

            pBuffer         -   pointer to buffer where instance is to
                                be constructed

            pBufferNext     -   pointer to a pointer which will contain
                                next available location, DWORD aligned

            ParentObjectTitleIndex
                            -   Title Index of parent object type; 0 if
                                no parent object

            ParentObjectInstance
                            -   Index into instances of parent object
                                type, starting at 0, for this instances
                                parent object instance

            UniqueID        -   a unique identifier which should be used
                                instead of the Name for identifying
                                this instance

            Name            -   Name of this instance
--*/
{
    DWORD NameLength;
    LPWSTR pName;
    //
    //  Include trailing null in name size
    //

    NameLength = (lstrlenW(Name) + 1) * sizeof(WCHAR);

    pBuffer->ByteLength = sizeof(PERF_INSTANCE_DEFINITION) +
                            NameLength;

    pBuffer->ParentObjectTitleIndex = ParentObjectTitleIndex;
    pBuffer->ParentObjectInstance = ParentObjectInstance;
    pBuffer->UniqueID = UniqueID;
    pBuffer->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
    pBuffer->NameLength = NameLength;

    // copy name to name buffer
    pName = (LPWSTR)&pBuffer[1];
    memcpy(pName,Name,NameLength);

    // update "next byte" pointer
    *pBufferNext = (PVOID) ((PCHAR) pBuffer + pBuffer->ByteLength);

    // round up to put next buffer on a QUADWORD boundry
    *pBufferNext = ALIGN_ON_QWORD (*pBufferNext);
    // adjust length value to match new length
    pBuffer->ByteLength = (ULONG)((ULONG_PTR)*pBufferNext - (ULONG_PTR)pBuffer);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\perfts\perfutil.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1995 Microsoft Corporation

Module Name:

    perfutil.h  

Abstract:

    This file supports routines used to parse and
    create Performance Monitor Data Structures.
    It actually supports Performance Object types with
    multiple instances

Author:

    Bob Watson  28-Jul-1995

Revision History:


--*/
#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

#include <windows.h>
#include <winperf.h>

#define MAX_INSTANCE_NAME   32
#define SMALL_BUFFER_SIZE   ((DWORD)4096)
#define MEDIUM_BUFFER_SIZE  ((DWORD)(4096*8))
#define LARGE_BUFFER_SIZE   ((DWORD)(4096*16))
#define INCREMENT_BUFFER_SIZE ((DWORD)(4096*2))

#define MAX_VALUE_NAME_LENGTH 256*sizeof(WCHAR)
#define MAX_VALUE_DATA_LENGTH 256*sizeof(WCHAR)
//
//  Until USER supports Unicode, we have to work in ASCII:
//

#define DEFAULT_NT_CODE_PAGE 437
#define UNICODE_CODE_PAGE      0

// enable this define to log process heap data to the event log
#ifdef PROBE_HEAP_USAGE
#undef PROBE_HEAP_USAGE
#endif
//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//
#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))
#define QWORD_MULTIPLE(x) (((x+sizeof(LONGLONG)-1)/sizeof(LONGLONG))*sizeof(LONGLONG))

#define ALIGN_ON_DWORD(x) ((VOID *) (((ULONG_PTR) (x) + 3) & ~0x3))
#define ALIGN_ON_QWORD(x) ((VOID *) (((ULONG_PTR) (x) + 7) & ~0x7))

extern const    WCHAR  GLOBAL_STRING[];      // Global command (get all local ctrs)
extern const    WCHAR  FOREIGN_STRING[];           // get data from foreign computers
extern const    WCHAR  COSTLY_STRING[];      
extern const    WCHAR  NULL_STRING[];

extern const    WCHAR  szTotalValue[];
extern const    WCHAR  szDefaultTotalString[];
#define DEFAULT_TOTAL_STRING_LEN    14

extern DWORD  MESSAGE_LEVEL;

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

// function prototypes for data collection routines
typedef DWORD (APIENTRY PM_LOCAL_COLLECT_PROC) (LPVOID *, LPDWORD, LPDWORD);

typedef struct _POS_FUNCTION_INFO {
    DWORD   dwObjectId;
    DWORD   dwCollectFunctionBit;
    DWORD   dwDataFunctionBit;
    PM_LOCAL_COLLECT_PROC *pCollectFunction;
} POS_FUNCTION_INFO, * PPOS_FUNCTION_INFO;

//
// The definition of the only routine of perfutil.c, It builds part of a 
// performance data instance (PERF_INSTANCE_DEFINITION) as described in 
// winperf.h
//

HANDLE MonOpenEventLog (IN LPWSTR);
VOID MonCloseEventLog ();
DWORD GetQueryType (IN LPWSTR);
BOOL IsNumberInUnicodeList (DWORD, LPWSTR);

BOOL
MonBuildInstanceDefinition(
    PERF_INSTANCE_DEFINITION *pBuffer,
    PVOID *pBufferNext,
    DWORD ParentObjectTitleIndex,
    DWORD ParentObjectInstance,
    DWORD UniqueID,
    LPWSTR Name
    );

LONG
GetPerflibKeyValue (
    LPCWSTR szItem,
    DWORD   dwRegType,
    DWORD   dwMaxSize,      // ... of pReturnBuffer in bytes
    LPVOID  pReturnBuffer,
    DWORD   dwDefaultSize,  // ... of pDefault in bytes
    LPVOID  pDefault
);

//
//  Memory Probe macro
//
#ifdef PROBE_HEAP_USAGE

typedef struct _LOCAL_HEAP_INFO_BLOCK {
    DWORD   AllocatedEntries;
    DWORD   AllocatedBytes;
    DWORD   FreeEntries;
    DWORD   FreeBytes;
} LOCAL_HEAP_INFO, *PLOCAL_HEAP_INFO;

#define HEAP_PROBE()    { \
    DWORD   dwHeapStatus[5]; \
    NTSTATUS CallStatus; \
    dwHeapStatus[4] = __LINE__; \
    if (!(CallStatus = memprobe (dwHeapStatus, 16L, NULL))) { \
        REPORT_INFORMATION_DATA (TCP_HEAP_STATUS, LOG_DEBUG,    \
            &dwHeapStatus, sizeof(dwHeapStatus));  \
    } else {  \
        REPORT_ERROR_DATA (TCP_HEAP_STATUS_ERROR, LOG_DEBUG, \
            &CallStatus, sizeof (DWORD)); \
    } \
}

#else

#define HEAP_PROBE()    ;

#endif


#define ALLOCMEM(heap, flags, size)     HeapAlloc (heap, flags, size)
#define REALLOCMEM(heap, flags, pointer, newsize) \
                                    HeapReAlloc (heap, flags, pointer, newsize)
#define FREEMEM(heap, flags, pointer)   HeapFree (heap, flags, pointer)

#endif  //_PERFUTIL_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\publish\makefile.inc ===
$(PROJECT_INC_PATH)\tschannl.h : $(O)\tschannl.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\tschannl.h : inc\tschannl.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\rdpdr.h : $(O)\rdpdr.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\rdpdr.h : inc\rdpdr.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\utildll.h : $(O)\utildll.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\utildll.h : inc\utildll.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\verall.h : $(O)\verall.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\verall.h : inc\verall.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\versome.h : $(O)\versome.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\versome.h : inc\versome.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\wfregupg.h : $(O)\wfregupg.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\wfregupg.h : inc\wfregupg.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\winddits.h : $(O)\winddits.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\winddits.h : inc\winddits.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\winsta.h : $(O)\winsta.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\winsta.h : inc\winsta.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\winstaw.h : $(O)\winstaw.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\winstaw.h : inc\winstaw.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\wstmsg.h : $(O)\wstmsg.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\wstmsg.h : inc\wstmsg.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\allproc.h : $(O)\allproc.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\allproc.h : inc\allproc.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\cchannel.h : $(O)\cchannel.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\cchannel.h : inc\cchannel.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\cdtapi.h : $(O)\cdtapi.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\cdtapi.h : inc\cdtapi.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\ctxdd.h : $(O)\ctxdd.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\ctxdd.h : inc\ctxdd.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\ctxdef.h : $(O)\ctxdef.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\ctxdef.h : inc\ctxdef.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\ctxver.h : $(O)\ctxver.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\ctxver.h : inc\ctxver.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\cxmsgsvc.h : $(O)\cxmsgsvc.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\cxmsgsvc.h : inc\cxmsgsvc.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\execsrv.h : $(O)\execsrv.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\execsrv.h : inc\execsrv.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\hydrix.h : $(O)\hydrix.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\hydrix.h : inc\hydrix.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\icaapi.h : $(O)\icaapi.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\icaapi.h : inc\icaapi.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\icadd.h : $(O)\icadd.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\icadd.h : inc\icadd.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\icaipx.h : $(O)\icaipx.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\icaipx.h : inc\icaipx.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\oemtdapi.h : $(O)\oemtdapi.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\oemtdapi.h : inc\oemtdapi.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\pchannel.h : $(O)\pchannel.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\pchannel.h : inc\pchannel.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\regapi.h : $(O)\regapi.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\regapi.h : inc\regapi.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\regsam.h : $(O)\regsam.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\regsam.h : inc\regsam.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\syslib.h : $(O)\syslib.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\syslib.h : inc\syslib.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\tscfgex.h : $(O)\tscfgex.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\tscfgex.h : inc\tscfgex.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\tsappcmp.h : $(O)\tsappcmp.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\tsappcmp.h : inc\tsappcmp.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\tserrs.h : $(O)\tserrs.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\tserrs.h : inc\tserrs.w
    $(CLEANSE_PUBLISHED_HDR) $? $@
    
$(PROJECT_INC_PATH)\tsperf.h : $(O)\tsperf.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\tsperf.h : inc\tsperf.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(PROJECT_INC_PATH)\rdfilter.h : $(O)\rdfilter.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\rdfilter.h : inc\rdfilter.w
    $(CLEANSE_PUBLISHED_HDR) $? $@

$(SDK_INC_PATH)\wtsapi32.h : $(O)\wtsapi32.h
    $(PUBLISH_CMD) {$?=$@}

$(O)\wtsapi32.h : inc\wtsapi32.w
    $(CLEANSE_PUBLISHED_HDR) $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\rdfilter\unittest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by unittest.rc
//
#define ID_QUIT                         3
#define IDD_DISABLEDIALOG               101
#define IDC_DISABLEBACKGROUND           1000
#define ID_APPLYFILTER                  1001
#define ID_REMOVEFILTER                 1002
#define IDC_CHECK6                      1008
#define IDC_DISABLETHEMES               1008
#define IDC_DISABLEFULLWINDOWDRAG       1009
#define IDC_DISABLEMENUFADEANDSLIDE     1010
#define IDC_STATIC1                     1011
#define IDC_STATIC2                     1012
#define IDC_STATIC3                     1013
#define IDC_STATIC4                     1014

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\rdfilter\rdfilter.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RDFilter

Abstract:

    API's for filtering desktop visual elements for remote connections of
    varying connection speeds for performance reasons.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#include <windows.h>
#include <windowsx.h>
#include <winuser.h>
#include <winuserp.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <ocidl.h>
#include <uxthemep.h>
#include "rdfilter.h"

#if DBG
#include <stdio.h>
#include <stdarg.h>
#include <tchar.h>
#endif

//
//  Toggle Unit-Test
//
//#define UNIT_TEST

#ifdef UNIT_TEST
#include <winsta.h>
#endif

#ifdef UNIT_TEST
#include "resource.h"
#endif

//
//  Internal Defines
//
#define REFRESHTHEMESFORTS_ORDINAL  36
#define NUM_TSPERFFLAGS             9


////////////////////////////////////////////////////////////
//
//  SystemParametersInfo UserPreferences manipulation macros
//  stolen from userk.h.
//
#define UPBOOLIndex(uSetting) \
    (((uSetting) - SPI_STARTBOOLRANGE) / 2)
#define UPBOOLPointer(pdw, uSetting)    \
    (pdw + (UPBOOLIndex(uSetting) / 32))
#define UPBOOLMask(uSetting)    \
    (1 << (UPBOOLIndex(uSetting) - ((UPBOOLIndex(uSetting) / 32) * 32)))
#define ClearUPBOOL(pdw, uSetting)    \
    (*UPBOOLPointer(pdw, uSetting) &= ~(UPBOOLMask(uSetting)))


////////////////////////////////////////////////////////////
//
//  Debugging
//

#if DBG
extern "C" ULONG DbgPrint(PCH Format, ...);
#define DBGMSG(MsgAndArgs) \
{                                   \
    DbgPrint MsgAndArgs;      \
}
#else
#define DBGMSG
#endif

//
//  Route ASSERT.
//
#undef ASSERT
#if DBG
#define ASSERT(expr) if (!(expr)) \
    { DBGMSG(("Failure at Line %d in %s\n",__LINE__, TEXT##(__FILE__)));  \
    DebugBreak(); }
#else
#define ASSERT(expr)
#endif

//
//  Internal Prototypes
//
DWORD NotifyThemes();
DWORD NotifyGdiPlus();
DWORD CreateSystemSid(PSID *ppSystemSid);
DWORD SetRegKeyAcls(HANDLE hTokenForLoggedOnUser, HKEY hKey);

//
//  Internal Types
//
typedef struct
{
    BOOL pfEnabled;
    LPCTSTR pszRegKey;
    LPCTSTR pszRegValue;
    LPCTSTR pszRegData;
    DWORD cbSize;
    DWORD dwType;
} TSPERFFLAG;

//
//  Globals
//
const LPTSTR g_ActiveDesktopKey = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Remote\\%d");
const LPTSTR g_ThemesKey        = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\ThemeManager\\Remote\\%d");
const LPTSTR g_UserKey          = TEXT("Remote\\%d\\Control Panel\\Desktop");
const LPTSTR g_GdiPlusKey       = TEXT("Remote\\%d\\GdiPlus");

UINT g_GdiPlusNotifyMsg = 0;
const LPTSTR g_GdiPlusNotifyMsgStr = TS_GDIPLUS_NOTIFYMSG_STR;

static const DWORD g_dwZeroValue = 0;

static const DWORD g_dwFontTypeStandard = 1; //Cleartype is 2


DWORD 
SetPerfFlagInReg(
    HANDLE hTokenForLoggedOnUser, 
    HKEY userHiveKey,
    DWORD sessionID,
    LPCTSTR pszRegKey, 
    LPCTSTR pszRegValue, 
    DWORD dwType, 
    void * pData, 
    DWORD cbSize, 
    BOOL fEnable
    )
/*++

Routine Description:


    Set a single perf flag, if enabled.

Arguments:

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    TCHAR szRegKey[MAX_PATH+64]; // 64 characters for the session ID, just to be safe.
    DWORD result = ERROR_SUCCESS;
    HKEY hKey = NULL;
    DWORD disposition;

    if (!fEnable) {
        goto CLEANUPANDEXIT;
    }

    //
    //  Create or open the key.
    //
    wsprintf(szRegKey, pszRegKey, sessionID);
    result = RegCreateKeyEx(userHiveKey, szRegKey, 0, L"",
                            REG_OPTION_VOLATILE, KEY_ALL_ACCESS, NULL, 
                            &hKey, &disposition);
    if (result != ERROR_SUCCESS) {
        DBGMSG(("RegCreateKeyEx:  %08X\n", result));
        goto CLEANUPANDEXIT;
    }

#ifdef UNIT_TEST
    goto CLEANUPANDEXIT;
#endif

    //
    //  Make it available to SYSTEM, only.
    //
    if (disposition == REG_CREATED_NEW_KEY) {
        result = SetRegKeyAcls(hTokenForLoggedOnUser, hKey);
        if (result != ERROR_SUCCESS) {
	        DBGMSG(("RegAcls:  %08X\n", result));
            goto CLEANUPANDEXIT;
        }
    }

    //
    //  Set the reg value.
    //
    result = RegSetValueEx(hKey, pszRegValue, 0, dwType, (PBYTE)pData, cbSize);
    if (result != ERROR_SUCCESS) {
        DBGMSG(("RegSetValue:  %08X\n", result));
    }

CLEANUPANDEXIT:

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return result;
}

DWORD 
SetPerfFlags(
    HANDLE hTokenForLoggedOnUser,
    HKEY userHiveKey,
    DWORD sessionID,
    DWORD filter,
    TSPERFFLAG flags[],
    DWORD count
    )
/*++

Routine Description:

    Set all perf flags.

Arguments:

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    DWORD nIndex;
    DWORD result = ERROR_SUCCESS;

    for (nIndex = 0; (result==ERROR_SUCCESS) && (nIndex<count); nIndex++) {
        result = SetPerfFlagInReg(
                            hTokenForLoggedOnUser,
                            userHiveKey,
                            sessionID,
                            flags[nIndex].pszRegKey, flags[nIndex].pszRegValue, 
                            flags[nIndex].dwType, (void *) flags[nIndex].pszRegData, 
                            flags[nIndex].cbSize, flags[nIndex].pfEnabled
                            );
    }

    return result;
}

DWORD 
BuildPerfFlagArray(
    HKEY hkcu,
    DWORD filter,
    OUT TSPERFFLAG **flagArray,
    OUT DWORD *count,
    DWORD **userPreferencesMask
    )
/*++

Routine Description:

    Generate the perf flag array from the filter.

Arguments:

    hkcu                 -   Logged on user's HKCU.
    filter               -   Filter
    flagArray            -   Array returned here.  Should be free'd with LocalFree
    count                -   Number of elements in returned array.
    userPreferencesMask  -   User preferences mask buffer.

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    DWORD result = ERROR_SUCCESS;
    DWORD ofs;
    HKEY hkey = NULL;
    DWORD sz;

    // 
    //  Need to increase this if any new elements are added!
    //
    *flagArray = (TSPERFFLAG *)LocalAlloc(LPTR, sizeof(TSPERFFLAG) * NUM_TSPERFFLAGS);
    if (*flagArray == NULL) {
        result = GetLastError();
        DBGMSG(("LocalAlloc:  %08X\n", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Active Desktop
    //
    ofs = 0;
    (*flagArray)[ofs].pfEnabled    = filter & TS_PERF_DISABLE_WALLPAPER;
    (*flagArray)[ofs].pszRegKey    = g_ActiveDesktopKey;
    (*flagArray)[ofs].pszRegValue  = TEXT("ActiveDesktop");
    (*flagArray)[ofs].pszRegData   = TEXT("Force Blank");  
    (*flagArray)[ofs].cbSize       = sizeof(TEXT("Force Blank"));
    (*flagArray)[ofs].dwType       = REG_SZ; ofs++;

    //
    //  TaskbarAnimations
    //
    (*flagArray)[ofs].pfEnabled    = filter & TS_PERF_DISABLE_MENUANIMATIONS;
    (*flagArray)[ofs].pszRegKey    = g_ActiveDesktopKey;
    (*flagArray)[ofs].pszRegValue  = TEXT("TaskbarAnimations");
    (*flagArray)[ofs].pszRegData   = (LPWSTR)&g_dwZeroValue;
    (*flagArray)[ofs].cbSize       = sizeof(DWORD);
    (*flagArray)[ofs].dwType       = REG_DWORD; ofs++;

    //
    //  Wallpaper
    //
    (*flagArray)[ofs].pfEnabled    = filter & TS_PERF_DISABLE_WALLPAPER;
    (*flagArray)[ofs].pszRegKey    = g_UserKey;
    (*flagArray)[ofs].pszRegValue  = TEXT("Wallpaper");
    (*flagArray)[ofs].pszRegData   = TEXT("");  
    (*flagArray)[ofs].cbSize       = sizeof(TEXT(""));
    (*flagArray)[ofs].dwType       = REG_SZ; ofs++;

    //
    //  Themes
    //
    (*flagArray)[ofs].pfEnabled    = filter & TS_PERF_DISABLE_THEMING;
    (*flagArray)[ofs].pszRegKey    = g_ThemesKey;
    (*flagArray)[ofs].pszRegValue  = TEXT("ThemeActive");
    (*flagArray)[ofs].pszRegData   = TEXT("0");  
    (*flagArray)[ofs].cbSize       = sizeof(TEXT("0"));
    (*flagArray)[ofs].dwType       = REG_SZ; ofs++;

    //
    //  Full Window Drag
    //
    (*flagArray)[ofs].pfEnabled    = filter & TS_PERF_DISABLE_FULLWINDOWDRAG;
    (*flagArray)[ofs].pszRegKey    = g_UserKey;
    (*flagArray)[ofs].pszRegValue  = TEXT("DragFullWindows");
    (*flagArray)[ofs].pszRegData   = TEXT("0");  
    (*flagArray)[ofs].cbSize       = sizeof(TEXT("0"));
    (*flagArray)[ofs].dwType       = REG_SZ; ofs++;

    //
    //  Smooth Scroll
    //
    (*flagArray)[ofs].pfEnabled    = filter & TS_PERF_DISABLE_MENUANIMATIONS;
    (*flagArray)[ofs].pszRegKey    = g_UserKey;
    (*flagArray)[ofs].pszRegValue  = TEXT("SmoothScroll");
    (*flagArray)[ofs].pszRegData   = TEXT("No");  
    (*flagArray)[ofs].cbSize       = sizeof(TEXT("No"));
    (*flagArray)[ofs].dwType       = REG_SZ; ofs++;

    //
    //  Font smoothing type
    //
    (*flagArray)[ofs].pfEnabled    = filter & TS_PERF_DISABLE_CURSOR_SHADOW;
    (*flagArray)[ofs].pszRegKey    = g_UserKey;
    (*flagArray)[ofs].pszRegValue  = TEXT("FontSmoothingType");
    (*flagArray)[ofs].pszRegData   = (LPWSTR)&g_dwFontTypeStandard;  
    (*flagArray)[ofs].cbSize       = sizeof(DWORD);
    (*flagArray)[ofs].dwType       = REG_DWORD; ofs++;

    //
    //  Enhanced graphics rendering
    //
    (*flagArray)[ofs].pfEnabled    = filter & TS_PERF_ENABLE_ENHANCED_GRAPHICS;
    (*flagArray)[ofs].pszRegKey    = g_GdiPlusKey;
    (*flagArray)[ofs].pszRegValue  = TEXT("HighQualityRender");
    (*flagArray)[ofs].pszRegData   = TEXT("Yes");  
    (*flagArray)[ofs].cbSize       = sizeof(TEXT("Yes"));
    (*flagArray)[ofs].dwType       = REG_SZ; ofs++;

    //
    //  Set the User Preference Mask
    //  (We won't consider any failures to read reg keys, etc. below to be fatal.)
    //
    if ((filter & TS_PERF_DISABLE_MENUANIMATIONS) || (filter & TS_PERF_DISABLE_CURSOR_SHADOW)) {
        DWORD err = RegOpenKey(
                        hkcu, 
                        TEXT("Control Panel\\Desktop"),
                        &hkey
                        );
        if (err != ERROR_SUCCESS) {
            DBGMSG(("RegOpenKey:  %08X\n", err));
            goto CLEANUPANDEXIT;
        }

        //
        //  Get the size of the UserPreferences mask
        //
        err = RegQueryValueEx(
                        hkey,
                        TEXT("UserPreferencesMask"),
                        NULL,
                        NULL,
                        NULL,
                        &sz
                        );
        if (err != ERROR_SUCCESS) {
            DBGMSG(("RegQueryValue:  %08X\n", err));
            goto CLEANUPANDEXIT;
        }

        //
        //  Allocate the mask.
        //
        *userPreferencesMask = (DWORD *)LocalAlloc(LPTR, sz);
        if (*userPreferencesMask == NULL) {
            err = GetLastError();
            DBGMSG(("LocalAlloc:  %08X\n", result));
            goto CLEANUPANDEXIT;
        }

        //
        //  Fetch it.
        //
        err = RegQueryValueEx(
                        hkey,
                        TEXT("UserPreferencesMask"),
                        NULL,
                        NULL,
                        (LPBYTE)*userPreferencesMask,
                        &sz
                        );
        if (err != ERROR_SUCCESS) {
            DBGMSG(("RegQueryValue:  %08X\n", err));
            goto CLEANUPANDEXIT;
        }

        //
        //  Modify the existing User Preference Mask
        //
        if (filter & TS_PERF_DISABLE_CURSOR_SHADOW) {
            ClearUPBOOL(*userPreferencesMask, SPI_GETCURSORSHADOW);
            ClearUPBOOL(*userPreferencesMask, SPI_SETCURSORSHADOW);
        }
        
        if (filter & TS_PERF_DISABLE_MENUANIMATIONS) {
            ClearUPBOOL(*userPreferencesMask, SPI_GETMENUANIMATION);
            ClearUPBOOL(*userPreferencesMask, SPI_SETMENUANIMATION);
            ClearUPBOOL(*userPreferencesMask, SPI_GETMENUFADE);
            ClearUPBOOL(*userPreferencesMask, SPI_SETMENUFADE);
            ClearUPBOOL(*userPreferencesMask, SPI_GETTOOLTIPANIMATION);
            ClearUPBOOL(*userPreferencesMask, SPI_SETTOOLTIPANIMATION);
            ClearUPBOOL(*userPreferencesMask, SPI_GETTOOLTIPFADE);
            ClearUPBOOL(*userPreferencesMask, SPI_SETTOOLTIPFADE);
            ClearUPBOOL(*userPreferencesMask, SPI_GETCOMBOBOXANIMATION);
            ClearUPBOOL(*userPreferencesMask, SPI_SETCOMBOBOXANIMATION);
            ClearUPBOOL(*userPreferencesMask, SPI_GETLISTBOXSMOOTHSCROLLING);
            ClearUPBOOL(*userPreferencesMask, SPI_SETLISTBOXSMOOTHSCROLLING);
        }

        (*flagArray)[ofs].pfEnabled    = TRUE;
        (*flagArray)[ofs].pszRegKey    = g_UserKey;
        (*flagArray)[ofs].pszRegValue  = TEXT("UserPreferencesMask");
        (*flagArray)[ofs].pszRegData   = (LPWSTR)*userPreferencesMask;  
        (*flagArray)[ofs].cbSize       = sz;
        (*flagArray)[ofs].dwType       = REG_BINARY; ofs++;
    }

CLEANUPANDEXIT:

    if (hkey != NULL) {
        RegCloseKey(hkey);
    }

    *count = ofs;

    return result;    
}

DWORD
RDFilter_ApplyRemoteFilter(
    HANDLE hLoggedOnUserToken,
    DWORD filter,
    BOOL userLoggingOn,
    DWORD flags
    )
/*++

Routine Description:


    Applies specified filter for the active TS session by adjusting visual 
    desktop settings.  Also notifies shell, etc. that a remote filter is in place.  
    Any previous filter settings will be destroyed and overwritten.

    The context for this call should be that of the logged on user and the call
    should be made within the session for which the filter is intended to be 
    applied.

Arguments:

    hLoggedOnUserToken  -   Token for the logged on user.
    filter              -   Visual desktop filter bits as defined in tsperf.h
    userLoggingOn       -   True if this being called in the context of a user
                            logging on to a session.
    flags               -   Flags

Return Value:

    ERROR_SUCCESS on success.

 --*/
{
    DWORD result = ERROR_SUCCESS;
    HRESULT hr;
    DWORD ourSessionID;
    IPropertyBag *propBag = NULL;
    VARIANT vbool;
    DWORD tmp;
    TSPERFFLAG *flagArray = NULL;
    DWORD flagCount;
    TCHAR szRegKey[MAX_PATH + 64]; // For the session ID ... to be safe.
    HKEY hParentKey = NULL;
    BOOL impersonated = FALSE;
    DWORD *userPreferencesMask = NULL;

    HRESULT hrCoInit = CoInitialize(0);

    //
    //  Get our session ID.
    //
    if (!ProcessIdToSessionId(GetCurrentProcessId(), &ourSessionID)) {
        result = GetLastError();
        DBGMSG(("ProcessIdToSessionId:  %08X\n", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Impersonate the logged on user.
    //
    if (!ImpersonateLoggedOnUser(hLoggedOnUserToken)) {
        result = GetLastError();
        DBGMSG(("ImpersonateUser1:  %08X.\n", result));
        goto CLEANUPANDEXIT;
    }
    impersonated = TRUE;

    //
    //  Open the current user's reg key.
    //
    result = RegOpenCurrentUser(KEY_ALL_ACCESS, &hParentKey);
    RevertToSelf();
    impersonated = FALSE;
    if (result != ERROR_SUCCESS) {
        DBGMSG(("RegOpenCurrentUser:  %08X\n", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Delete all existing filters for our session.
    //
    wsprintf(szRegKey, g_ActiveDesktopKey, ourSessionID);
    RegDeleteKey(hParentKey, szRegKey);
    wsprintf(szRegKey, g_ThemesKey, ourSessionID);
    RegDeleteKey(hParentKey, szRegKey);
    wsprintf(szRegKey, g_UserKey, ourSessionID);
    RegDeleteKey(hParentKey, szRegKey);
    wsprintf(szRegKey, g_GdiPlusKey, ourSessionID);
    RegDeleteKey(hParentKey, szRegKey);

    //
    //  Skip setting the reg keys if there is no filter, as an optimization.
    //
    if (filter) {
        //
        //  Convert the filter into reg keys and reg settings.
        //
        result = BuildPerfFlagArray(hParentKey, filter, &flagArray, &flagCount, &userPreferencesMask);
        if (result != ERROR_SUCCESS) {
            goto CLEANUPANDEXIT;
        }

        //
        //  Apply it.
        //
        result = SetPerfFlags(hLoggedOnUserToken, hParentKey, ourSessionID, 
			      filter, flagArray, flagCount);
        if (result != ERROR_SUCCESS) {
            goto CLEANUPANDEXIT;
        }
    }

    //
    //  Impersonate the logged on user.
    //
    if (!ImpersonateLoggedOnUser(hLoggedOnUserToken)) {
        result = GetLastError();
        DBGMSG(("ImpersonateUser2:  %08X.\n", result));
        goto CLEANUPANDEXIT;
    }
    impersonated = TRUE;

    //
    //  Notify USER that we are remote.
    //
    if (!(flags & RDFILTER_SKIPUSERREFRESH)) {
        DWORD userFlags = UPUSP_REMOTESETTINGS;
        if (userLoggingOn) {
            //  USER needs to refresh all settings.
            userFlags|= UPUSP_USERLOGGEDON;
        }
        else {
            //  USER should avoid a complete refresh.
            userFlags |= UPUSP_POLICYCHANGE;
        }
        if (!UpdatePerUserSystemParameters(NULL, userFlags)) {
            result = GetLastError();
            DBGMSG(("UpdatePerUserSystemParameters1:  %08X\n", result));
            goto CLEANUPANDEXIT;
        }
    }

    //
    //  Notify Themes that we are remote.
    //
    if (!(flags & RDFILTER_SKIPTHEMESREFRESH)) {
        result = NotifyThemes();
        if (result != ERROR_SUCCESS) {
            goto CLEANUPANDEXIT;
        }
    }

    //
    //  Notify Active Desktop that we are remote.
    //
    if (!(flags & RDFILTER_SKIPSHELLREFRESH)) {
        hr = CoCreateInstance(
                        CLSID_ActiveDesktop, NULL, 
                        CLSCTX_ALL, IID_IPropertyBag, 
                        (LPVOID*)&propBag
                        );
        if (hr != S_OK) {
            DBGMSG(("CoCreateInstance:  %08X\n", hr));
            DBGMSG(("Probably didn't call CoInitialize.\n"));
            result = HRESULT_CODE(hr);
            goto CLEANUPANDEXIT;
        }
        vbool.vt = VT_BOOL;
        vbool.boolVal = VARIANT_TRUE;
        hr = propBag->Write(L"TSConnectEvent", &vbool);
        if (hr != S_OK) {
            DBGMSG(("propBag->Write:  %08X\n", hr));
            result = HRESULT_CODE(hr);
            goto CLEANUPANDEXIT;
        }
    }

CLEANUPANDEXIT:

    if (impersonated) {
        RevertToSelf();
    }

    if (propBag != NULL) {
        propBag->Release();
    }

    if (flagArray != NULL) {
        LocalFree(flagArray);
    }

    if (hParentKey != NULL) {
        RegCloseKey(hParentKey);
    }

    if (userPreferencesMask != NULL) {
        LocalFree(userPreferencesMask);
    }

    //
    //  On failure, we need to clear any remote filter settings that may
    //  have succeeded.
    //
    if (result != ERROR_SUCCESS) {
        RDFilter_ClearRemoteFilter(hLoggedOnUserToken, userLoggingOn, flags);
    }

    if ((hrCoInit == S_OK) || (hrCoInit == S_FALSE)) {
        CoUninitialize();
    }

    return result;
}

VOID 
RDFilter_ClearRemoteFilter(
    HANDLE hLoggedOnUserToken,
    BOOL userLoggingOn,
    DWORD flags
    )
/*++

Routine Description:

    Removes existing remote filter settings and notifies shell, etc. that
    a remote filter is no longer in place for the active TS session.  

    The context for this call should be that of the session for which the 
    filter is intended to be applied.

Arguments:

    hLoggedOnUserToken  -   Token for logged fon user.
    userLoggingOn       -   True if the user is actively logging on.

Return Value:

    This function will continuing attempting to clear the filter for 
    all associated components even on failure cases, so we cannot 
    say definitively whether we have failed or succeeded to clear the 
    filter.

 --*/
{
    DWORD result = ERROR_SUCCESS;
    HRESULT hr;
    IPropertyBag *propBag = NULL;
    VARIANT vbool;
    DWORD ourSessionID;
    TCHAR szRegKey[MAX_PATH + 64]; // +64 for the session ID to be safe.
    HKEY hParentKey = NULL;
    HANDLE hImp = NULL;
    BOOL impersonated = FALSE;

    HRESULT hrCoInit = CoInitialize(0);

    //
    //  Get our session ID.
    //
    if (!ProcessIdToSessionId(GetCurrentProcessId(), &ourSessionID)) {
        result = GetLastError();
        DBGMSG(("ProcessIdToSessionId:  %08X\n", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Impersonate the logged on user.
    //
    if (!ImpersonateLoggedOnUser(hLoggedOnUserToken)) {
        result = GetLastError();
        DBGMSG(("ImpersonateUser3:  %08X.\n", result));
        goto CLEANUPANDEXIT;
    }
    impersonated = TRUE;

    //
    //  Open the current user's reg key.
    //
    result = RegOpenCurrentUser(KEY_ALL_ACCESS, &hParentKey);
    RevertToSelf();
    impersonated = FALSE;
    if (result != ERROR_SUCCESS) {
        DBGMSG(("RegOpenCurrentUser:  %08X\n", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Whack the relevant remote key.
    //
    wsprintf(szRegKey, g_ActiveDesktopKey, ourSessionID);
    RegDeleteKey(hParentKey, szRegKey);
    wsprintf(szRegKey, g_ThemesKey, ourSessionID);
    RegDeleteKey(hParentKey, szRegKey);
    wsprintf(szRegKey, g_UserKey, ourSessionID);
    RegDeleteKey(hParentKey, szRegKey);
    wsprintf(szRegKey, g_GdiPlusKey, ourSessionID);
    RegDeleteKey(hParentKey, szRegKey);

    //
    //  Impersonate the logged on user.
    //
    if (!ImpersonateLoggedOnUser(hLoggedOnUserToken)) {
        result = GetLastError();
        DBGMSG(("ImpersonateUser4:  %08X.\n", result));
        goto CLEANUPANDEXIT;
    }
    impersonated = TRUE;

    //
    //  Notify USER that we are not remote.  The Policy Change flag indicates that
    //  a complete refresh should not be performed.  
    //
    if (!(flags & RDFILTER_SKIPUSERREFRESH)) {
        DWORD userFlags = UPUSP_REMOTESETTINGS;
        if (userLoggingOn) {
            //  USER needs to refresh all settings.
            userFlags |= UPUSP_USERLOGGEDON;
        }
        else {
            //  USER should avoid a complete refresh.
            userFlags |= UPUSP_POLICYCHANGE;
        }
        if (!UpdatePerUserSystemParameters(NULL, userFlags)) {
            result = GetLastError();
            DBGMSG(("UpdatePerUserSystemParameters2:  %08X\n", result));
        }
    }

    //
    //  Notify Themes that we are not remote.
    //
    if (!(flags & RDFILTER_SKIPTHEMESREFRESH)) {
        NotifyThemes();
    }

    //
    //  Notify Active Desktop that we are not remote.
    //
    if (!(flags & RDFILTER_SKIPSHELLREFRESH)) {
        hr = CoCreateInstance(
                        CLSID_ActiveDesktop, NULL, 
                        CLSCTX_ALL, IID_IPropertyBag, 
                        (LPVOID*)&propBag
                        );
        if (hr != S_OK) {
            DBGMSG(("CoCreateInstance:  %08X\n", hr));
            DBGMSG(("Probably didn't call CoInitialize.\n"));
            result = HRESULT_CODE(hr);
            goto CLEANUPANDEXIT;
        }
        vbool.vt = VT_BOOL;
        vbool.boolVal = VARIANT_FALSE;
        hr = propBag->Write(L"TSConnectEvent", &vbool);
        if (hr != S_OK) {
            DBGMSG(("propBag->Write:  %08X\n", hr));
        }
    }
    
CLEANUPANDEXIT:

    if (impersonated) {
        RevertToSelf();
    }

    if (propBag != NULL) {
        propBag->Release();
    }

    if (hParentKey != NULL) {
        RegCloseKey(hParentKey);
    }

    if ((hrCoInit == S_OK) || (hrCoInit == S_FALSE)) {
        CoUninitialize();
    }
}

DWORD
NotifyThemes()
/*++

Routine Description:

    Notify themes that our remote state has changed.

Arguments:

Return Value:

 --*/
{
    HMODULE uxthemeLibHandle = NULL;
    FARPROC func;
    DWORD result = ERROR_SUCCESS;
    HRESULT hr;
    LPSTR procAddress;

    uxthemeLibHandle = LoadLibrary(L"uxtheme.dll");
    if (uxthemeLibHandle == NULL) {
        result = GetLastError();
        DBGMSG(("LoadLibrary:  %08X\n", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Pass the RefreshThemeForTS func id as an ordinal since it's private.
    //
    procAddress = (LPSTR)REFRESHTHEMESFORTS_ORDINAL;
    func = GetProcAddress(uxthemeLibHandle, (LPCSTR)procAddress);
    if (func != NULL) {
        hr = (HRESULT) func();
        if (hr != S_OK) {
            DBGMSG(("RefreshThemeForTS:  %08X\n", hr));
            result = HRESULT_CODE(hr);
        }   
    }
    else {
        result = GetLastError();
        DBGMSG(("GetProcAddress:  %08X\n", result));              
    }
    FreeLibrary(uxthemeLibHandle);

CLEANUPANDEXIT:

    return result;
}

DWORD
NotifyGdiPlus()
/*++

Routine Description:

    Notify GdiPlus that our remote state has changed.

Arguments:

    filter  -   

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    DWORD result = ERROR_SUCCESS;
    
    if (g_GdiPlusNotifyMsg != 0) {
        g_GdiPlusNotifyMsg = RegisterWindowMessage(g_GdiPlusNotifyMsgStr);
    }

    if (g_GdiPlusNotifyMsg != 0) {
        PostMessage(HWND_BROADCAST, g_GdiPlusNotifyMsg, 0, 0);
    }
    else {
        result = GetLastError();
    }

    return result;
}

PSID
GetUserSid(
    IN HANDLE hTokenForLoggedOnUser
    )
{
/*++

Routine Description:

    Allocates memory for psid and returns the psid for the current user
    The caller should call FREEMEM to free the memory.

Arguments:

    Access Token for the User

Return Value:

    if successful, returns the PSID
    else, returns NULL

--*/
    TOKEN_USER * ptu = NULL;
    BOOL bResult;
    PSID psid = NULL;

    DWORD defaultSize = sizeof(TOKEN_USER);
    DWORD Size;
    DWORD dwResult;

    ptu = (TOKEN_USER *)LocalAlloc(LPTR, defaultSize);
    if (ptu == NULL) {
        goto CLEANUPANDEXIT;
    }

    bResult = GetTokenInformation(
                    hTokenForLoggedOnUser,  // Handle to Token
                    TokenUser,              // Token Information Class
                    ptu,                    // Buffer for Token Information
                    defaultSize,            // Size of Buffer
                    &Size);                 // Return length

    if (bResult == FALSE) {
        dwResult = GetLastError();
        if (dwResult == ERROR_INSUFFICIENT_BUFFER) {

            //
            //Allocate required memory
            //
            LocalFree(ptu);
            ptu = (TOKEN_USER *)LocalAlloc(LPTR, Size);

            if (ptu == NULL) {
                goto CLEANUPANDEXIT;
            }
            else {
                defaultSize = Size;
                bResult = GetTokenInformation(
                                hTokenForLoggedOnUser,
                                TokenUser,
                                ptu,
                                defaultSize,
                                &Size);

                if (bResult == FALSE) {  //Still failed
                    DBGMSG(("UMRDPDR:GetTokenInformation Failed, Error: %ld\n", GetLastError()));
                    goto CLEANUPANDEXIT;
                }
            }
        }
        else {
            DBGMSG(("UMRDPDR:GetTokenInformation Failed, Error: %ld\n", dwResult));
            goto CLEANUPANDEXIT;
        }
    }

    Size = GetLengthSid(ptu->User.Sid);

    //
    // Allocate memory. This will be freed by the caller.
    //

    psid = (PSID) LocalAlloc(LPTR, Size);

    if (psid != NULL) {         // Make sure the allocation succeeded
        CopySid(Size, psid, ptu->User.Sid);
    }

CLEANUPANDEXIT:
    if (ptu != NULL)
        LocalFree(ptu);

    return psid;
}

DWORD
CreateSystemSid(
    PSID *ppSystemSid
    )
/*++

Routine Description:

    Create a SYSTEM SID.

Arguments:

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    PSID pSid;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;

    if(AllocateAndInitializeSid(
            &SidAuthority,
            1,
            SECURITY_LOCAL_SYSTEM_RID,
            0, 0, 0, 0, 0, 0, 0,
            &pSid)) {
        *ppSystemSid = pSid;
    }
    else {
        dwStatus = GetLastError();
    }
    return dwStatus;
}

DWORD 
SetRegKeyAcls(
    HANDLE hTokenForLoggedOnUser,
    HKEY hKey
    )
/*++

Routine Description:

    Set a reg key so that only SYSTEM can modify.

Arguments:

    hTokenForLoggedOnUser   -   Logged on use token.
    hKey    -   Key to set.

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    PACL pAcl=NULL;
    DWORD result = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    DWORD cbAcl = 0;
    PSID  pSidSystem = NULL;
    PSID  pUserSid = NULL;

    pSecurityDescriptor = (PSECURITY_DESCRIPTOR)LocalAlloc(
                                            LPTR, sizeof(SECURITY_DESCRIPTOR)
                                            );
    if (pSecurityDescriptor == NULL) {
        DBGMSG(("Can't alloc memory for SECURITY_DESCRIPTOR\n"));
        result = GetLastError();
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the security descriptor.
    //
    if (!InitializeSecurityDescriptor(
                    pSecurityDescriptor,
                    SECURITY_DESCRIPTOR_REVISION
                    )) {
        result = GetLastError();
        DBGMSG(("InitializeSecurityDescriptor:  %08X\n", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Create the system SID.
    //
    result = CreateSystemSid(&pSidSystem);
    if (result != ERROR_SUCCESS) {
        DBGMSG(("CreateSystemSid:  %08X\n", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Get the user's SID.
    //
    pUserSid = GetUserSid(hTokenForLoggedOnUser);
    if (pUserSid == NULL) {
        goto CLEANUPANDEXIT;
    }

    //
    //  Get size of memory needed for new DACL.
    //
    cbAcl = sizeof(ACL);
    cbAcl += 1 * (sizeof(ACCESS_ALLOWED_ACE) -          // For SYSTEM ACE
            sizeof(DWORD) + GetLengthSid(pSidSystem));
    cbAcl += 1 * (sizeof(ACCESS_ALLOWED_ACE) -          // For User ACE
            sizeof(DWORD) + GetLengthSid(pUserSid));
    pAcl = (PACL) LocalAlloc(LPTR, cbAcl);
    if (pAcl == NULL) {
        DBGMSG(("Can't alloc memory for ACL\n"));
        result = GetLastError();
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the ACL.
    //
    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        result = GetLastError();
        DBGMSG(("InitializeAcl():  %08X\n", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Add the ACE's.
    //
    if (!AddAccessAllowedAceEx(pAcl,
                        ACL_REVISION,
                        //INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
                        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
                        GENERIC_READ | GENERIC_WRITE | GENERIC_ALL,
                        pSidSystem
                        )) {
        result = GetLastError();
        DBGMSG(("AddAccessAllowedAce:  %08X\n", result));
        goto CLEANUPANDEXIT;
    }
    if (!AddAccessAllowedAceEx(pAcl,
                        ACL_REVISION,
                        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
                        KEY_READ,
                        pUserSid
                        )) {
        result = GetLastError();
        DBGMSG(("AddAccessAllowedAce2:  %08X\n", result));
        goto CLEANUPANDEXIT;
    }

    //
    //  Add the DACL to the SD
    //
    if (!SetSecurityDescriptorDacl(pSecurityDescriptor,
                                  TRUE, pAcl, FALSE)) {
        result = GetLastError();
        DBGMSG(("SetSecurityDescriptorDacl:  %08X\n", result));
        goto CLEANUPANDEXIT;
    }   


    //
    // Set the registry DACL
    //
    result = RegSetKeySecurity(
                            hKey,
                            DACL_SECURITY_INFORMATION, 
                            pSecurityDescriptor
                        );
    if (result != ERROR_SUCCESS) {
        DBGMSG(("RegSetKeySecurity:  %08X\n", result));
        goto CLEANUPANDEXIT;

    }

CLEANUPANDEXIT:

    if (pUserSid != NULL) {
        LocalFree(pUserSid);
    }

    if (pSidSystem != NULL) {
        FreeSid(pSidSystem);
    }

    if (pAcl != NULL) {
        LocalFree(pAcl);
    }

    if (pSecurityDescriptor != NULL) {
        LocalFree(pSecurityDescriptor);
    }

    return result;
}

#if DBG
ULONG
DbgPrint(
    LPTSTR Format,
    ...
    )
{
    va_list arglist;
    WCHAR Buffer[512];
    INT cb;

    //
    // Format the output into a buffer and then print it.
    //

    va_start(arglist, Format);

    cb = _vsntprintf(Buffer, sizeof(Buffer), Format, arglist);
    if (cb == -1) {             // detect buffer overflow
        Buffer[sizeof(Buffer) - 3] = 0;
    }

    wcscat(Buffer, L"\r\n");

    OutputDebugString(Buffer);

    va_end(arglist);

    return 0;
}
#endif

////////////////////////////////////////////////////////////////////////////////
//
//  Unit-Test
//

#ifdef UNIT_TEST

BOOL 
GetCheckBox(
    HWND hwndDlg, 
    UINT idControl
    )
{
    return (BST_CHECKED == SendMessage((HWND)GetDlgItem(hwndDlg, idControl), BM_GETCHECK, 0, 0));
}

INT_PTR OnCommand(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = FALSE;   // Not handled
    UINT idControl = LOWORD(wParam);
    UINT idAction = HIWORD(wParam);
    DWORD result;
    DWORD filter;
    static HANDLE tokenHandle = NULL;

    if (tokenHandle == NULL) {
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, 
                            &tokenHandle)) {
            ASSERT(FALSE);
            return FALSE;
        }
    }

    switch(idControl)
    {
    case ID_QUIT:
        RDFilter_ClearRemoteFilter(tokenHandle, FALSE);
        EndDialog(hDlg, 0);
        break;

    case ID_APPLYFILTER:
        filter = 0;
        if (GetCheckBox(hDlg, IDC_DISABLEBACKGROUND)) {
            filter |= TS_PERF_DISABLE_WALLPAPER;
        }
        if (GetCheckBox(hDlg, IDC_DISABLEFULLWINDOWDRAG)) {
            filter |= TS_PERF_DISABLE_FULLWINDOWDRAG;
        }
        if (GetCheckBox(hDlg, IDC_DISABLEMENUFADEANDSLIDE)) {
            filter |= TS_PERF_DISABLE_MENUANIMATIONS;
        }
        if (GetCheckBox(hDlg, IDC_DISABLETHEMES)) {
            filter |= TS_PERF_DISABLE_THEMING;
        }
        result = RDFilter_ApplyRemoteFilter(tokenHandle, filter, FALSE);
        ASSERT(result == ERROR_SUCCESS);
        break;

    case ID_REMOVEFILTER:
        RDFilter_ClearRemoteFilter(tokenHandle, FALSE);
        break;

    default:
        break;
    }

    return fHandled;
}


INT_PTR 
TSPerfDialogProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    INT_PTR fHandled = TRUE;   // handled
    DWORD result;
    static HANDLE tokenHandle = NULL;

    if (tokenHandle == NULL) {
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, 
                            &tokenHandle)) {
            ASSERT(FALSE);
            return FALSE;
        }
    }


    switch (wMsg)
    {
    case WM_INITDIALOG:
        break;

    case WM_COMMAND:
        fHandled = OnCommand(hDlg, wMsg, wParam, lParam);
        break;

    case WM_CLOSE:
        RDFilter_ClearRemoteFilter(tokenHandle, FALSE);
        EndDialog(hDlg, 0);
        fHandled = TRUE;
        break;

    default:
        fHandled = FALSE;   // Not handled
        break;
    }

    return fHandled;
}

int PASCAL WinMain(
    HINSTANCE hInstCurrent, 
    HINSTANCE hInstPrev, 
    LPSTR pszCmdLine, 
    int nCmdShow
    )
{
    WINSTATIONCLIENT ClientData;
    DWORD Length;
    DWORD result;
    WCHAR buf[MAX_PATH];

    //
    //  Get the Remote Desktop (TS) visual filter, if it is defined.
    //
    if (!WinStationQueryInformationW(
                       SERVERNAME_CURRENT,
                       LOGONID_CURRENT,
                       WinStationClient,
                       &ClientData,
                       sizeof(ClientData),
                       &Length)) {
        MessageBox(NULL, L"WinStationQueryInformation failed.", L"Message", MB_OK);
    }
    else {
        wsprintf(buf, L"Filter for this TS session is:  %08X", ClientData.PerformanceFlags);
        MessageBox(NULL, buf, L"Message", MB_OK);
    }


    INT_PTR nResult = DialogBox(hInstCurrent, 
                            MAKEINTRESOURCE(IDD_DISABLEDIALOG), 
                            NULL, TSPerfDialogProc);

    return 0;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\regapi\create.c ===
/*************************************************************************
*
* Create.c
*
* Create Register APIs
*
* Copyright (c) 1998 Microsoft Corporation
*
* $Author:
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>

#include <ntddkbd.h>
#include <ntddmou.h>
#include <winstaw.h>
#include <regapi.h>


/*
 *  Procedures defined
 */
VOID CreateWinStaCreate( HKEY, PWINSTATIONCREATE );
VOID CreateUserConfig( HKEY, PUSERCONFIG );
VOID CreateConfig( HKEY, PWINSTATIONCONFIG );
VOID CreateNetwork( BOOLEAN, HKEY, PNETWORKCONFIG );
VOID CreateNasi( BOOLEAN, HKEY, PNASICONFIG );
VOID CreateAsync( BOOLEAN, HKEY, PASYNCCONFIG );
VOID CreateOemTd( BOOLEAN, HKEY, POEMTDCONFIG );
VOID CreateFlow( BOOLEAN, HKEY, PFLOWCONTROLCONFIG );
VOID CreateConnect( BOOLEAN, HKEY, PCONNECTCONFIG );
VOID CreateCd( HKEY, PCDCONFIG );
VOID CreateWd( HKEY, PWDCONFIG );
VOID CreatePdConfig( BOOLEAN, HKEY, PPDCONFIG, ULONG );
VOID CreatePdConfig2( BOOLEAN, HKEY, PPDCONFIG2, ULONG );
VOID CreatePdConfig3( HKEY, PPDCONFIG3, ULONG );
VOID CreatePdParams( BOOLEAN, HKEY, SDCLASS, PPDPARAMS );

VOID SetWallPaperDisabled( HKEY, BOOLEAN );

/*
 * procedures used
 */
LONG SetNumValue( BOOLEAN, HKEY, LPWSTR, DWORD );
LONG SetNumValueEx( BOOLEAN, HKEY, LPWSTR, DWORD, DWORD );
LONG SetStringValue( BOOLEAN, HKEY, LPWSTR, LPWSTR );
LONG SetStringValueEx( BOOLEAN, HKEY, LPWSTR, DWORD, LPWSTR );


/*******************************************************************************
 *
 *  CreateWinStaCreate
 *
 *     Create WINSTATIONCREATE structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pCreate (input)
 *       pointer to WINSTATIONCREATE structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreateWinStaCreate( HKEY Handle,
                    PWINSTATIONCREATE pCreate )
{
    SetNumValue( TRUE, Handle,
                 WIN_ENABLEWINSTATION, pCreate->fEnableWinStation );
    SetNumValue( TRUE, Handle,
                 WIN_MAXINSTANCECOUNT, pCreate->MaxInstanceCount );
}


/*******************************************************************************
 *
 *  CreateUserConfig
 *
 *     Create USERCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pUser (input)
 *       pointer to USERCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreateUserConfig( HKEY Handle,
                  PUSERCONFIG pUser )
{
    UCHAR seed;
    UNICODE_STRING UnicodePassword;
    WCHAR encPassword[ PASSWORD_LENGTH + 2 ];


    SetNumValue( TRUE, Handle,
                 WIN_INHERITAUTOLOGON, pUser->fInheritAutoLogon );

    SetNumValue( TRUE, Handle,
                 WIN_INHERITRESETBROKEN, pUser->fInheritResetBroken );

    SetNumValue( TRUE, Handle,
                 WIN_INHERITRECONNECTSAME, pUser->fInheritReconnectSame );

    SetNumValue( TRUE, Handle,
                 WIN_INHERITINITIALPROGRAM, pUser->fInheritInitialProgram );


	


    SetNumValue( TRUE, Handle, WIN_INHERITCALLBACK, pUser->fInheritCallback );

    SetNumValue( TRUE, Handle,
                 WIN_INHERITCALLBACKNUMBER, pUser->fInheritCallbackNumber );

    SetNumValue( TRUE, Handle, WIN_INHERITSHADOW, pUser->fInheritShadow );

    SetNumValue( TRUE, Handle,
                 WIN_INHERITMAXSESSIONTIME, pUser->fInheritMaxSessionTime );

    SetNumValue( TRUE, Handle,
                 WIN_INHERITMAXDISCONNECTIONTIME, pUser->fInheritMaxDisconnectionTime );

    SetNumValue( TRUE, Handle,
                 WIN_INHERITMAXIDLETIME, pUser->fInheritMaxIdleTime );

    SetNumValue( TRUE, Handle,
                 WIN_INHERITAUTOCLIENT, pUser->fInheritAutoClient );

    SetNumValue( TRUE, Handle,
                 WIN_INHERITSECURITY, pUser->fInheritSecurity );

    SetNumValue( TRUE, Handle,
                 WIN_PROMPTFORPASSWORD, pUser->fPromptForPassword );

	//NA 2/23/01
    SetNumValue( TRUE, Handle,
                 WIN_INHERITCOLORDEPTH, pUser->fInheritColorDepth );

    SetNumValue( TRUE, Handle, WIN_RESETBROKEN, pUser->fResetBroken );

    SetNumValue( TRUE, Handle, WIN_RECONNECTSAME, pUser->fReconnectSame );

    SetNumValue( TRUE, Handle, WIN_LOGONDISABLED, pUser->fLogonDisabled );

    SetNumValue( TRUE, Handle, WIN_AUTOCLIENTDRIVES, pUser->fAutoClientDrives );

    SetNumValue( TRUE, Handle, WIN_AUTOCLIENTLPTS, pUser->fAutoClientLpts );

    SetNumValue( TRUE, Handle, WIN_FORCECLIENTLPTDEF, pUser->fForceClientLptDef );

    SetNumValue( TRUE, Handle, WIN_DISABLEENCRYPTION, pUser->fDisableEncryption );

    SetNumValue( TRUE, Handle, WIN_HOMEDIRECTORYMAPROOT, pUser->fHomeDirectoryMapRoot );

    SetNumValue( TRUE, Handle, WIN_USEDEFAULTGINA, pUser->fUseDefaultGina );

    SetNumValue( TRUE, Handle, WIN_DISABLECPM, pUser->fDisableCpm );

    SetNumValue( TRUE, Handle, WIN_DISABLECDM, pUser->fDisableCdm );

    SetNumValue( TRUE, Handle, WIN_DISABLECCM, pUser->fDisableCcm );

    SetNumValue( TRUE, Handle, WIN_DISABLELPT, pUser->fDisableLPT );

    SetNumValue( TRUE, Handle, WIN_DISABLECLIP, pUser->fDisableClip );

    SetNumValue( TRUE, Handle, WIN_DISABLEEXE, pUser->fDisableExe );

    SetNumValue( TRUE, Handle, WIN_DISABLECAM, pUser->fDisableCam );

    SetStringValue( TRUE, Handle, WIN_USERNAME, pUser->UserName );

    SetStringValue( TRUE, Handle, WIN_DOMAIN, pUser->Domain );

    //  check for password if there is one then encrypt it
    if ( wcslen( pUser->Password ) ) {

        //  generate unicode string
        RtlInitUnicodeString( &UnicodePassword, pUser->Password );

        //  encrypt password in place
        seed = 0;
        RtlRunEncodeUnicodeString( &seed, &UnicodePassword );

        //  pack seed and encrypted password
        encPassword[0] = seed;
        RtlMoveMemory( &encPassword[1], pUser->Password, sizeof(pUser->Password) );

        //  store encrypted password
        SetStringValue( TRUE, Handle, WIN_PASSWORD, encPassword );
    }
    else {

        //  store empty password
        SetStringValue( TRUE, Handle, WIN_PASSWORD, pUser->Password );
    }

    SetStringValue( TRUE, Handle, WIN_WORKDIRECTORY, pUser->WorkDirectory );

    SetStringValue( TRUE, Handle, WIN_INITIALPROGRAM, pUser->InitialProgram );

    SetStringValue( TRUE, Handle, WIN_CALLBACKNUMBER, pUser->CallbackNumber );

    SetNumValue( TRUE, Handle, WIN_CALLBACK, pUser->Callback );

    SetNumValue( TRUE, Handle, WIN_SHADOW, pUser->Shadow );

    SetNumValue( TRUE, Handle, WIN_MAXCONNECTIONTIME, pUser->MaxConnectionTime );

    SetNumValue( TRUE, Handle,
                 WIN_MAXDISCONNECTIONTIME, pUser->MaxDisconnectionTime );

    SetNumValue( TRUE, Handle, WIN_MAXIDLETIME, pUser->MaxIdleTime );

    SetNumValue( TRUE, Handle, WIN_KEYBOARDLAYOUT, pUser->KeyboardLayout );

    SetNumValue( TRUE, Handle, WIN_MINENCRYPTIONLEVEL, pUser->MinEncryptionLevel );

	//NA 2/23/01
    SetNumValue( TRUE, Handle,
                 POLICY_TS_COLOR_DEPTH, pUser->ColorDepth );

    if ( pUser->fWallPaperDisabled )
        SetWallPaperDisabled( Handle, TRUE );
    else
        SetWallPaperDisabled( Handle, FALSE );

    SetStringValue( TRUE, Handle, WIN_NWLOGONSERVER, pUser->NWLogonServer);

    SetStringValue( TRUE, Handle, WIN_WFPROFILEPATH, pUser->WFProfilePath);
}


/*******************************************************************************
 *
 *  CreateConfig
 *
 *     Create WINSTATIONCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pConfig (input)
 *       pointer to WINSTATIONCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreateConfig( HKEY Handle,
              PWINSTATIONCONFIG pConfig )
{
    SetStringValue( TRUE, Handle, WIN_COMMENT, pConfig->Comment );

    CreateUserConfig( Handle, &pConfig->User );
}


/*******************************************************************************
 *
 *  CreateNetwork
 *
 *     Create NETWORKCONFIG structure
 *
 * ENTRY:
 *
 *    bSetValue (input)
 *       TRUE to set value; FALSE to delete from registry
 *    Handle (input)
 *       registry handle
 *    pNetwork (input)
 *       pointer to NETWORKCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreateNetwork( BOOLEAN bSetValue,
               HKEY Handle,
               PNETWORKCONFIG pNetwork )
{
    SetNumValue( bSetValue, Handle, WIN_LANADAPTER, pNetwork->LanAdapter );
}

/*******************************************************************************
 *
 *  CreateNasi
 *
 *     Create NASICONFIG structure
 *
 * ENTRY:
 *
 *    bSetValue (input)
 *       TRUE to set value; FALSE to delete from registry
 *    Handle (input)
 *       registry handle
 *    pNetwork (input)
 *       pointer to NETWORKCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreateNasi( BOOLEAN bSetValue,
            HKEY Handle,
            PNASICONFIG pNasi )
{
    UCHAR seed;
    UNICODE_STRING UnicodePassword;
    WCHAR encPassword[ NASIPASSWORD_LENGTH + 2 ];

    //  check for password if there is one then encrypt it
    if ( wcslen( pNasi->PassWord ) ) {

        //  generate unicode string
        RtlInitUnicodeString( &UnicodePassword, pNasi->PassWord );

        //  encrypt password in place
        seed = 0;
        RtlRunEncodeUnicodeString( &seed, &UnicodePassword );

        //  pack seed and encrypted password
        encPassword[0] = seed;
        RtlMoveMemory( &encPassword[1], pNasi->PassWord, sizeof(pNasi->PassWord) );

        //  store encrypted password
        SetStringValue( TRUE, Handle, WIN_NASIPASSWORD, encPassword );
    }
    else {

        //  store empty password
        SetStringValue( TRUE, Handle, WIN_NASIPASSWORD, pNasi->PassWord );
    }

    SetStringValue( bSetValue, Handle, WIN_NASISPECIFICNAME, pNasi->SpecificName );
    SetStringValue( bSetValue, Handle, WIN_NASIUSERNAME, pNasi->UserName );


    SetStringValue( bSetValue, Handle, WIN_NASISESSIONNAME, pNasi->SessionName );
    SetStringValue( bSetValue, Handle, WIN_NASIFILESERVER, pNasi->FileServer );

    SetNumValue( bSetValue, Handle, WIN_NASIGLOBALSESSION, pNasi->GlobalSession );
}

/*******************************************************************************
 *
 *  CreateAsync
 *
 *     Create ASYNCCONFIG structure
 *
 * ENTRY:
 *
 *    bSetValue (input)
 *       TRUE to set value; FALSE to delete from registry
 *    Handle (input)
 *       registry handle
 *    pAsync (input)
 *       pointer to ASYNCCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreateAsync( BOOLEAN bSetValue,
             HKEY Handle,
             PASYNCCONFIG pAsync )
{
    SetStringValue( bSetValue, Handle, WIN_DEVICENAME, pAsync->DeviceName );

    SetStringValue( bSetValue, Handle, WIN_MODEMNAME, pAsync->ModemName );

    SetNumValue( bSetValue, Handle, WIN_BAUDRATE, pAsync->BaudRate );

    SetNumValue( bSetValue, Handle, WIN_PARITY, pAsync->Parity );

    SetNumValue( bSetValue, Handle, WIN_STOPBITS, pAsync->StopBits );

    SetNumValue( bSetValue, Handle, WIN_BYTESIZE, pAsync->ByteSize );

    SetNumValue( bSetValue, Handle, WIN_ENABLEDSRSENSITIVITY, pAsync->fEnableDsrSensitivity );

    SetNumValue( bSetValue, Handle, WIN_CONNECTIONDRIVER, pAsync->fConnectionDriver );

    CreateFlow( bSetValue, Handle, &pAsync->FlowControl );

    CreateConnect( bSetValue, Handle, &pAsync->Connect );
}

/*******************************************************************************
 *
 *  CreateOemTd
 *
 *     Create OEMTDCONFIG structure
 *
 * ENTRY:
 *
 *    bSetValue (input)
 *       TRUE to set value; FALSE to delete from registry
 *    Handle (input)
 *       registry handle
 *    pOemTd (input)
 *       pointer to OEMTDCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreateOemTd( BOOLEAN bSetValue,
             HKEY Handle,
             POEMTDCONFIG pOemTd )
{
    SetNumValue( bSetValue, Handle, WIN_OEMTDADAPTER, pOemTd->Adapter );

    SetStringValue( bSetValue, Handle, WIN_OEMTDDEVICENAME, pOemTd->DeviceName );

    SetNumValue( bSetValue, Handle, WIN_OEMTDFLAGS, pOemTd->Flags );
}

/*******************************************************************************
 *
 *  CreateFlow
 *
 *     Create FLOWCONTROLCONFIG structure
 *
 * ENTRY:
 *
 *    bSetValue (input)
 *       TRUE to set value; FALSE to delete from registry
 *    Handle (input)
 *       registry handle
 *    pFlow (input)
 *       pointer to FLOWCONTROLCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreateFlow( BOOLEAN bSetValue,
            HKEY Handle,
            PFLOWCONTROLCONFIG pFlow )
{
    SetNumValue( bSetValue, Handle, WIN_FLOWSOFTWARERX, pFlow->fEnableSoftwareRx );

    SetNumValue( bSetValue, Handle, WIN_FLOWSOFTWARETX, pFlow->fEnableSoftwareTx );

    SetNumValue( bSetValue, Handle, WIN_ENABLEDTR, pFlow->fEnableDTR );

    SetNumValue( bSetValue, Handle, WIN_ENABLERTS, pFlow->fEnableRTS );

    SetNumValue( bSetValue, Handle, WIN_XONCHAR, pFlow->XonChar );

    SetNumValue( bSetValue, Handle, WIN_XOFFCHAR, pFlow->XoffChar );

    SetNumValue( bSetValue, Handle, WIN_FLOWTYPE, pFlow->Type );

    SetNumValue( bSetValue, Handle, WIN_FLOWHARDWARERX, pFlow->HardwareReceive );

    SetNumValue( bSetValue, Handle, WIN_FLOWHARDWARETX, pFlow->HardwareTransmit );
}


/*******************************************************************************
 *
 *  CreateConnect
 *
 *     Create CONNECTCONFIG structure
 *
 * ENTRY:
 *
 *    bSetValue (input)
 *       TRUE to set value; FALSE to delete from registry
 *    Handle (input)
 *       registry handle
 *    pConnect (input)
 *       pointer to CONNECTCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreateConnect( BOOLEAN bSetValue,
               HKEY Handle,
               PCONNECTCONFIG pConnect )
{
    SetNumValue( bSetValue, Handle, WIN_CONNECTTYPE, pConnect->Type );

    SetNumValue( bSetValue, Handle, WIN_ENABLEBREAKDISCONNECT, pConnect->fEnableBreakDisconnect );
}


/*******************************************************************************
 *
 *  CreateCd
 *
 *     Create CDCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pCdConfig (input)
 *       pointer to CDCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreateCd( HKEY Handle,
          PCDCONFIG pCdConfig )
{
    SetNumValue( TRUE, Handle, WIN_CDCLASS, pCdConfig->CdClass );

    SetStringValue( TRUE, Handle, WIN_CDNAME, pCdConfig->CdName );

    SetStringValue( TRUE, Handle, WIN_CDDLL, pCdConfig->CdDLL );

    SetNumValue( TRUE, Handle, WIN_CDFLAG, pCdConfig->CdFlag );
}


/*******************************************************************************
 *
 *  CreateWd
 *
 *     Create WDCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pWd (input)
 *       pointer to WDCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreateWd( HKEY Handle,
          PWDCONFIG pWd )
{
    SetStringValue( TRUE, Handle, WIN_WDNAME, pWd->WdName );

    SetStringValue( TRUE, Handle, WIN_WDDLL, pWd->WdDLL );

    SetStringValue( TRUE, Handle, WIN_WSXDLL, pWd->WsxDLL );

    SetNumValue( TRUE, Handle, WIN_WDFLAG, pWd->WdFlag );

    SetNumValue( TRUE, Handle, WIN_INPUTBUFFERLENGTH, pWd->WdInputBufferLength );

    SetStringValue( TRUE, Handle, WIN_CFGDLL, pWd->CfgDLL );

    SetStringValue( TRUE, Handle, WIN_WDPREFIX, pWd->WdPrefix );

}


/*******************************************************************************
 *
 *  CreatePdConfig
 *
 *     Create PDCONFIG structure
 *
 * ENTRY:
 *
 *    bCreate (input)
 *       TRUE for create; FALSE for update.
 *    Handle (input)
 *       registry handle
 *    pConfig (input)
 *       pointer to array of PDCONFIG structures
 *    Count (input)
 *       number of elements in PDCONFIG array
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreatePdConfig( BOOLEAN bCreate,
                HKEY Handle,
                PPDCONFIG pConfig,
                ULONG Count )
{
    ULONG i;

    for ( i=0; i<Count; i++ ) {
        if ( !bCreate || (pConfig[i].Create.SdClass != SdNone) ) {

            CreatePdConfig2( bCreate, Handle, &pConfig[i].Create, i );

            CreatePdParams( bCreate, Handle,
                            pConfig[i].Create.SdClass,
                            &pConfig[i].Params );
        }
    }
}


/*******************************************************************************
 *
 *  CreatePdConfig2
 *
 *     Create PDCONFIG2 structure
 *
 * ENTRY:
 *
 *    bCreate (input)
 *       TRUE for create; FALSE for update.
 *    Handle (input)
 *       registry handle
 *    pPd (input)
 *       pointer to PDCONFIG2 structure
 *    Index (input)
 *       Index (array index)
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreatePdConfig2( BOOLEAN bCreate,
                 HKEY Handle,
                 PPDCONFIG2 pPd2,
                 ULONG Index )
{
    BOOLEAN bSetValue = bCreate ?
                            TRUE :
                            ((pPd2->SdClass == SdNone) ?
                                FALSE : TRUE);

    SetStringValueEx( bSetValue, Handle, WIN_PDNAME, Index, pPd2->PdName );

    SetNumValueEx( bSetValue, Handle, WIN_PDCLASS, Index, pPd2->SdClass );

    SetStringValueEx( bSetValue, Handle, WIN_PDDLL, Index, pPd2->PdDLL );

    SetNumValueEx( bSetValue, Handle, WIN_PDFLAG, Index, pPd2->PdFlag );

    if ( Index == 0 ) {
        SetNumValue( bSetValue, Handle, WIN_OUTBUFLENGTH, pPd2->OutBufLength );

        SetNumValue( bSetValue, Handle, WIN_OUTBUFCOUNT, pPd2->OutBufCount );

        SetNumValue( bSetValue, Handle, WIN_OUTBUFDELAY, pPd2->OutBufDelay );

        SetNumValue( bSetValue, Handle, WIN_INTERACTIVEDELAY, pPd2->InteractiveDelay );

        SetNumValue( bSetValue, Handle, WIN_PORTNUMBER, pPd2->PortNumber );

        SetNumValue( bSetValue, Handle, WIN_KEEPALIVETIMEOUT, pPd2->KeepAliveTimeout );
    }
}


/*******************************************************************************
 *
 *  CreatePdConfig3
 *
 *     Create PDCONFIG3 structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pPd (input)
 *       pointer to PDCONFIG3 structure
 *    Index (input)
 *       Index (array index)
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreatePdConfig3( HKEY Handle,
                  PPDCONFIG3 pPd3,
                  ULONG Index )
{
    CreatePdConfig2( TRUE, Handle, &pPd3->Data, Index );

    SetStringValue( TRUE, Handle, WIN_SERVICENAME,
                    pPd3->ServiceName );

    SetStringValue( TRUE, Handle, WIN_CONFIGDLL,
                    pPd3->ConfigDLL );
}


/*******************************************************************************
 *
 *  CreatePdParams
 *
 *     create PDPARAMS structure
 *
 * ENTRY:
 *
 *    bCreate (input)
 *       TRUE for create; FALSE for update.
 *    Handle (input)
 *       registry handle
 *    SdClass (input)
 *       type of PD
 *    pParams (input)
 *       pointer to PDPARAMS structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
CreatePdParams( BOOLEAN bCreate,
                HKEY Handle,
                SDCLASS SdClass,
                PPDPARAMS pParams )
{
    BOOLEAN bSetValue = bCreate ?
                            TRUE :
                            ((SdClass == SdNone) ?
                                FALSE : TRUE);

    switch ( SdClass ) {
        case SdNetwork :
            CreateNetwork( bSetValue, Handle, &pParams->Network );
            break;
        case SdNasi :
            CreateNasi( bSetValue, Handle, &pParams->Nasi );
            break;
        case SdAsync :
            CreateAsync( bSetValue, Handle, &pParams->Async );
            break;
        case SdOemTransport :
            CreateOemTd( bSetValue, Handle, &pParams->OemTd );
            break;
    }
}

#define CONTROL_PANEL L"Control Panel"
#define DESKTOP       L"Desktop"
#define WALLPAPER     L"Wallpaper"
#define NONE          L"(None)"

/*******************************************************************************
 *
 *  SetWallPaperDisabled
 *
 *    Disable desktop wallpaper
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    DisableWallPaper (input)
 *       flag to disable wall paper
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/
void
SetWallPaperDisabled( HKEY Handle, BOOLEAN bDisableWallPaper ) {

    HKEY Handle1;
    HKEY Handle2;
    HKEY Handle3;
    DWORD Disp;

    if ( bDisableWallPaper ) {
        if ( RegCreateKeyEx( Handle, WIN_USEROVERRIDE, 0, NULL,
                             REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                             NULL, &Handle1, &Disp ) != ERROR_SUCCESS ) {
                goto error;
        }
        if ( RegCreateKeyEx( Handle1, CONTROL_PANEL, 0, NULL,
                             REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                             NULL, &Handle2, &Disp ) != ERROR_SUCCESS ) {
                RegCloseKey( Handle1 );
                goto error;
        }
        RegCloseKey( Handle1 );
        if ( RegCreateKeyEx( Handle2, DESKTOP, 0, NULL,
                             REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                             NULL, &Handle3, &Disp ) != ERROR_SUCCESS ) {
                RegCloseKey( Handle2 );
                goto error;
        }
        RegCloseKey( Handle2 );
        (void)RegSetValueEx( Handle3, WALLPAPER, 0, REG_SZ,
                             (BYTE *)NONE, (wcslen(NONE) + 1 ) << 1);
        RegCloseKey( Handle3 );
    }
    else {
        if ( RegOpenKeyEx( Handle, WIN_USEROVERRIDE, 0, KEY_ALL_ACCESS,
                           &Handle1 ) != ERROR_SUCCESS ) {
                goto error;
        }
        if ( RegOpenKeyEx( Handle1, CONTROL_PANEL, 0, KEY_ALL_ACCESS,
                           &Handle2 ) != ERROR_SUCCESS ) {
                RegCloseKey( Handle1 );
                goto error;
        }
        if ( RegDeleteKey( Handle2, DESKTOP ) != ERROR_SUCCESS ) {
                RegCloseKey( Handle2 );
                RegCloseKey( Handle1 );
                goto error;
        }
        RegCloseKey( Handle2 );
        if ( RegDeleteKey( Handle1, CONTROL_PANEL ) != ERROR_SUCCESS ) {
                RegCloseKey( Handle1 );
                goto error;
        }
        RegCloseKey( Handle1 );
        if ( RegDeleteKey( Handle, WIN_USEROVERRIDE ) != ERROR_SUCCESS ) {
                goto error;
        }
    }
error:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\regapi\gpdata.cpp ===
/*                     
 *  Includes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <lm.h>
#include <winsta.h>

#include <rpc.h>
#include <rpcdce.h>
#include <ntdsapi.h>
// For more info, check out \\index1\src\nt\private\security\tools\delegate\ldap.c

#include "usrprop.h"
#include "regapi.h"


extern "C" {
    BOOLEAN     RegGetUserPolicy(    LPWSTR userSID , PPOLICY_TS_USER pPolicy , PUSERCONFIGW pData );
    void        RegGetMachinePolicy( PPOLICY_TS_MACHINE pPolicy );
    void        RegMergeMachinePolicy( PPOLICY_TS_MACHINE pPolicy, USERCONFIGW *pMachineConfigData , 
                           WINSTATIONCREATE   * pCreate  );
    BOOLEAN     RegDenyTSConnectionsPolicy();
    DWORD       WaitForTSConnectionsPolicyChanges( BOOLEAN bWaitForAccept, HANDLE  hExtraEvent);

    BOOLEAN     RegGetMachinePolicyEx( 
                BOOLEAN             forcePolicyRead,
                FILETIME            *pTime ,    
                PPOLICY_TS_MACHINE  pPolicy );
    BOOLEAN     RegIsMachineInHelpMode();
}

extern "C"
{
//
HKEY g_hTSPolicyKey = NULL;//handle to TS_POLICY_SUB_TREE key
HKEY g_hTSControlKey = NULL;//handle to REG_CONTROL_TSERVER key
}


/******************************************************************
*                                                                 *
* Check to see if the policy is set to stop accepting connections *
*                                                                 *
******************************************************************/
BOOLEAN     RegDenyTSConnectionsPolicy()
{
    LONG  errorCode = ERROR_SUCCESS;
    DWORD ValueType;
    DWORD ValueSize = sizeof(DWORD);
    DWORD valueData ;

    //
    // first check the policy tree, 
    //
    if( !g_hTSPolicyKey )
    {
        errorCode = RegOpenKeyEx( HKEY_LOCAL_MACHINE, TS_POLICY_SUB_TREE, 0,
                                KEY_READ, &g_hTSPolicyKey );

        //If error code is ERROR_FILE_NOT_FOUND, this is not an error.
        if( !g_hTSPolicyKey && errorCode != ERROR_FILE_NOT_FOUND )
        {
            //we could not open policy key for some reason other 
            //than key not found.
            //return TRUE  to be on the safe side
            return TRUE;
        }
    }
    if ( g_hTSPolicyKey )
    {
        errorCode = RegQueryValueEx( g_hTSPolicyKey, POLICY_DENY_TS_CONNECTIONS , NULL, &ValueType,
                          (LPBYTE) &valueData, &ValueSize );
         
        switch( errorCode )
        {
            case ERROR_SUCCESS :
                return ( valueData ? TRUE : FALSE ) ;       // we have data from the policyKey handle to return
            break;

            case   ERROR_KEY_DELETED:
                    // Group policy must have deleted this key, close it
                    // Then, below we check for the local machine key
                    RegCloseKey( g_hTSPolicyKey );
                    g_hTSPolicyKey = NULL;
            break;

            case ERROR_FILE_NOT_FOUND:
                // there is no policy from GP, so see (below) what the local machine
                // value has.
                break;

            default:
                // if we are having any other kind of a problem, claim TRUE and
                // stop connections to be on the safe side (a security angle).
                return TRUE;
            break;
        }
    }

    // if we got this far, then no policy was set. Check the local machine now.
    if( !g_hTSControlKey )
    {
        errorCode = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                                    KEY_READ, &g_hTSControlKey );
    }

    if ( g_hTSControlKey )
    {
        errorCode = RegQueryValueEx( g_hTSControlKey, POLICY_DENY_TS_CONNECTIONS , NULL, &ValueType,
                          (LPBYTE) &valueData, &ValueSize );
    
        if (errorCode == ERROR_SUCCESS )
        {
            return ( valueData ? TRUE : FALSE ) ;       // we have data from the policyKey handle to return
        }

    }

    // if no localKey, gee... the registry is missing data... return TRUE  to be on the safe side

    return TRUE;
    
}

/******************************************************************
*                                                                 *
* Wait until POLICY_DENY_TS_CONNECTIONS is changed                *
*                                                                 *
* Parameters:                                                     *
*   bWaitForAccept                                                *
*       if TRUE, test if connections are accepted and wait for    *
*       them to be accepted if they are not currently accepted.   *
*       if FALSE, test if connections are not accepted and wait   *
*       for them to be denied if they are currently accepted.     *
*                                                                 *
*   hExtraEvent                                                   *
*       optional handle to an event to wait for.                  *
*                                                                 *
* Returns:                                                        *
*   WAIT_OBJECT_0                                                 *
*       if a change in TS connections policy occurred             *
*                                                                 *
*   WAIT_OBJECT_0 + 1                                             *
*       if the extra event is present and signaled                *
*                                                                 *
******************************************************************/
//
// Note that opening the global g_hTSControlKey without protection
// can cause the key to be opened twice.
//

// This macro is TRUE if the TS connections are denied
#define TSConnectionsDenied (RegDenyTSConnectionsPolicy() && \
                             !(RegIsMachinePolicyAllowHelp() && RegIsMachineInHelpMode()))

DWORD WaitForTSConnectionsPolicyChanges(
    BOOLEAN bWaitForAccept,
    HANDLE  hExtraEvent
    )
{
    //
    // Wait for a policy change if
    // we want TS connections and they are denied OR
    // we don't want TS connections and they are accepted
    //
    if((bWaitForAccept && TSConnectionsDenied) ||
       (!bWaitForAccept && !TSConnectionsDenied))
    {
        DWORD errorCode = ERROR_SUCCESS;
         
        if( !g_hTSControlKey )
        {
            errorCode = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                                        KEY_READ, &g_hTSControlKey );
        
            if( !g_hTSControlKey )
            {
                SetLastError( errorCode );
                return WAIT_FAILED;
            }
        }
        
        HKEY hPoliciesKey = NULL;
        //We cannot wait for g_hTSPolicyKey because it can be deleted and created
        //Instead we wait for HKLM\Policies key
        errorCode = RegOpenKeyEx( HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Policies"), 0,
                                    KEY_READ, &hPoliciesKey );
        
        if( !hPoliciesKey )
        {
            SetLastError( errorCode );
            return WAIT_FAILED;
        }
        
        HANDLE hEvents[3] = { NULL, NULL, NULL }; 
        hEvents[0] = CreateEvent(NULL,FALSE,FALSE,NULL);
        hEvents[1] = CreateEvent(NULL,FALSE,FALSE,NULL);
        hEvents[2] = hExtraEvent;

        if( !hEvents[0] || !hEvents[1] )
        {
            errorCode = GetLastError();

            RegCloseKey(hPoliciesKey);

            SetLastError( errorCode );
            return WAIT_FAILED;
        }
        
       
        BOOLEAN key1NeedsToBeNotified = TRUE;
        BOOLEAN key2NeedsToBeNotified = TRUE;

        DWORD   whichObject;

        for( ;; )
        {
            if (key1NeedsToBeNotified)
            {
                 errorCode = RegNotifyChangeKeyValue(g_hTSControlKey,
                                FALSE,REG_NOTIFY_CHANGE_LAST_SET,
                                hEvents[0], TRUE );
                if( errorCode != ERROR_SUCCESS )
                {
                    CloseHandle( hEvents[0] );
                    CloseHandle( hEvents[1] );
                    RegCloseKey(hPoliciesKey);
    
                    SetLastError( errorCode );
                    return WAIT_FAILED;
                }
                else
                {
                    key1NeedsToBeNotified = FALSE;
                }
            }
        
            if (key2NeedsToBeNotified)
            {
                errorCode = RegNotifyChangeKeyValue(hPoliciesKey,
                                    TRUE,REG_NOTIFY_CHANGE_LAST_SET | REG_NOTIFY_CHANGE_NAME,
                                    hEvents[1], TRUE );
    
                if( errorCode != ERROR_SUCCESS )
                {
                    CloseHandle( hEvents[0] );
                    CloseHandle( hEvents[1] );
                    RegCloseKey(hPoliciesKey);
    
                    SetLastError( errorCode );
                    return WAIT_FAILED;
                }
                else
                {
                    key2NeedsToBeNotified = FALSE;
                }
            }

            if ( hExtraEvent == NULL )
            {
                whichObject = WaitForMultipleObjects(2,hEvents,FALSE,INFINITE);
            }
            else
            {
                whichObject = WaitForMultipleObjects(3,hEvents,FALSE,INFINITE);
            }

            if(whichObject == WAIT_FAILED)
            {
                errorCode = GetLastError();

                CloseHandle( hEvents[0] );
                CloseHandle( hEvents[1] );
                RegCloseKey(hPoliciesKey);

                SetLastError( errorCode );
                return WAIT_FAILED;
            }
            else
            {
                if ( whichObject == WAIT_OBJECT_0  )
                {
                    key1NeedsToBeNotified = TRUE;
                }
                else if ( whichObject == WAIT_OBJECT_0 + 1 )
                {
                     key2NeedsToBeNotified = TRUE;
                }
                else if ( (whichObject == WAIT_OBJECT_0 + 2) && hExtraEvent )
                {
                    CloseHandle( hEvents[0] );
                    CloseHandle( hEvents[1] );
                    RegCloseKey(hPoliciesKey);

                    return WAIT_OBJECT_0 + 1;
                }
                else
                {
                     KdPrint(("ERROR : WaitForTSConnectionsPolicyChanges()'s WaitForMultipleObjects() returned 0x%lx\n", whichObject ));
                }


                /*
                if((bWaitForAccept && TSConnectionsDenied) ||
                    (!bWaitForAccept && !TSConnectionsDenied))
                {
                    continue;
                }
                else
                {
                     break;
                }
                */

                // always return, the tests will be done by the caller
                break;

            }
        }
        
        CloseHandle( hEvents[0] );
        CloseHandle( hEvents[1] );
        RegCloseKey(hPoliciesKey);
    }
    
    return WAIT_OBJECT_0;
}

/********************************************************************************
*
* GPGetNumValue()
*
* Params
*   [in]  policyKey : hkey to the policy reg tree where values are stored
*   [in]  ValueName : name of the value (which is the policy) we are looking for
*   [out] pValueData: the data for the policy
*
* Return:
*   if the policy defined by the passed in valuename is present, then
*   return TRUE. Else, return FALSE
*
********************************************************************************/
BOOLEAN GPGetNumValue( 
                HKEY    policyKey,
                LPWSTR  ValueName,
                DWORD   *pValueData )
{
    LONG  Status = ERROR_SUCCESS;
    DWORD ValueType;
    DWORD ValueSize = sizeof(DWORD);
    
    // init data value to zero, just to get Prefix off our backs. This is a wasted OP
    // since unless policy is set, value is not used.
    *pValueData = 0;

    //
    // See if any values are present from the policyKey .
    //

    if ( policyKey )
    {
        Status = RegQueryValueEx( policyKey, ValueName, NULL, &ValueType,
                          (LPBYTE) pValueData, &ValueSize );
    
        if (Status == ERROR_SUCCESS )
        {
            return TRUE;       // we have data from the policyKey handle to return
        }
    }
    // else, no key means policy is not set


    return FALSE;
 
}
/********************************************************************************
* 
* GPGetStringValue()
*
* same as GPGetNumValue() but for policies that have a string value
*
*
********************************************************************************/

BOOLEAN
GPGetStringValue( HKEY policyKey,
                LPWSTR ValueName,
                LPWSTR pValueData,
                DWORD MaxValueSize )
{
    LONG Status;
    DWORD ValueType;
    DWORD ValueSize = MaxValueSize << 1;

    if (policyKey )
    {
        Status = RegQueryValueEx( policyKey, ValueName, NULL, &ValueType,
                                  (LPBYTE) pValueData, &ValueSize );
    
        if ( Status != ERROR_SUCCESS || ValueSize == sizeof(UNICODE_NULL) ) 
        {
            return FALSE;   // no data found.
        } 
        else 
        {
            if ( ValueType != REG_SZ ) 
            {
                return FALSE; // bad data, pretend we have no data.
            }
        }
        // we did get data
        return( TRUE );
    }

    return FALSE;

}






/*******************************************************************************
 *
 *  GPQueryUserConfig
 *
 *     query USERCONFIG structure
 *
 * Params:
 *    policyKey : hkey to the HKCU policy tree
 *    pPolicy   : points to the user policy struct which has flags for any policy 
 *                  value that is present in the policy tree
 *    pUser     : pointer to a userconfigw struct used as a sracth pad to hold the
 *                  policy values (if present).
 * Return:
 *    void
 *
 ******************************************************************************/

VOID
GPQueryUserConfig( HKEY policyKey, PPOLICY_TS_USER pPolicy , PUSERCONFIGW pUser )
{
    UCHAR seed;
    UNICODE_STRING UnicodePassword;
    WCHAR encPassword[ PASSWORD_LENGTH + 2 ];
    DWORD   dwTmpValue;

    // ----------------
    pPolicy->fPolicyInitialProgram = GPGetStringValue( policyKey, WIN_INITIALPROGRAM, 
                    pUser->InitialProgram,
                    INITIALPROGRAM_LENGTH + 1 );
    GPGetStringValue( policyKey, WIN_WORKDIRECTORY, 
                    pUser->WorkDirectory,
                    DIRECTORY_LENGTH + 1 );

    // ----------------
    pPolicy->fPolicyResetBroken =
       GPGetNumValue( policyKey,WIN_RESETBROKEN , & dwTmpValue ); 
    pUser->fResetBroken = (BOOLEAN) dwTmpValue;


    // ----------------
    pPolicy->fPolicyReconnectSame = 
       GPGetNumValue( policyKey,WIN_RECONNECTSAME , &dwTmpValue ); 
    pUser->fReconnectSame = (BOOLEAN) dwTmpValue;

    // ----------------
    pPolicy->fPolicyShadow = 
        GPGetNumValue( policyKey, WIN_SHADOW, &dwTmpValue ); 
    pUser->Shadow = (SHADOWCLASS) dwTmpValue;

    // ----------------
    pPolicy->fPolicyMaxSessionTime =
        GPGetNumValue( policyKey, WIN_MAXCONNECTIONTIME , &dwTmpValue ); 
    pUser->MaxConnectionTime = dwTmpValue;

    // ----------------
    pPolicy->fPolicyMaxDisconnectionTime = 
        GPGetNumValue( policyKey,WIN_MAXDISCONNECTIONTIME ,&dwTmpValue ); 
    pUser->MaxDisconnectionTime = dwTmpValue;

    // ----------------
    pPolicy->fPolicyMaxIdleTime =
       GPGetNumValue( policyKey,WIN_MAXIDLETIME , &dwTmpValue ); 
    pUser->MaxIdleTime = dwTmpValue;

    // ----------------
    pPolicy->fPolicyCallback =
        GPGetNumValue( policyKey, WIN_CALLBACK, &dwTmpValue ); 
    pUser->Callback = (CALLBACKCLASS ) dwTmpValue;

    // ----------------
    pPolicy->fPolicyCallbackNumber = 
        GPGetStringValue( policyKey, WIN_CALLBACKNUMBER, 
                    pUser->CallbackNumber,
                    CALLBACK_LENGTH + 1 );

    // ----------------
    pPolicy->fPolicyAutoClientDrives =
       GPGetNumValue( policyKey,WIN_AUTOCLIENTDRIVES , &dwTmpValue ); 
    pUser->fAutoClientDrives = (BOOLEAN) dwTmpValue;

    // ----------------
    pPolicy->fPolicyAutoClientLpts =
       GPGetNumValue( policyKey,WIN_AUTOCLIENTLPTS ,   &dwTmpValue ); 
    pUser->fAutoClientLpts  = (BOOLEAN) dwTmpValue;

    // ----------------
    pPolicy->fPolicyForceClientLptDef =
       GPGetNumValue( policyKey,WIN_FORCECLIENTLPTDEF , &dwTmpValue ); 
    pUser->fForceClientLptDef = (BOOLEAN) dwTmpValue;

    
}



/*******************************************************************************
* RegGetUserPolicy()
*
* Params:
*     [in]  userSID : user sid in a text format
*     [out] pPolicy : user policy struct
*     [out] pUser   : policy values
*
* Return:
*     BOOLEAN   : TRUE  if user policy was found
*                 FALSE if there was a problem getting user policy
*******************************************************************************/
BOOLEAN    RegGetUserPolicy( 
            LPWSTR userSID  ,
            PPOLICY_TS_USER pPolicy,
            PUSERCONFIGW pUser )
{
    DWORD  status=  ERROR_SUCCESS;

    HKEY    policyKey; 
    WCHAR   userHive [MAX_PATH];


    if (userSID)    // this would never happen, but Master Prefix complains and we must server him!
    {
        wcscpy(userHive, userSID);
        wcscat(userHive, L"\\");
        wcscat(userHive, TS_POLICY_SUB_TREE );
        
        status = RegOpenKeyEx( HKEY_USERS, userHive , 0,
                                KEY_READ, &policyKey );
    
        if (status == ERROR_SUCCESS )
        {
            GPQueryUserConfig( policyKey, pPolicy,  pUser );
    
            RegCloseKey( policyKey );

            return TRUE;
        }
    }

    return FALSE;

}

/*******************************************************************************
*  GPQueryMachineConfig()
*
*  Params:
*     [in]  policyKey  : key to the policy tree under hklm
*     [out] pPolicy    : pointer to a machine policy data that is filled up by this function
*
*  Return:
*     void
*
*
* !!! WARNING !!!   
*
*   All TS related values MUST be in the flat TS-POLICY-TREE, no sub keys.
*   This is due to the fact that time-stamp checks by the caller of RegGetMachinePolicyEx() will
*   check the time stamp on the TS-POLICY key, which is NOT updated when a value in a sub-key is
*   altered.
*
*
*******************************************************************************/
void GPQueryMachineConfig( HKEY policyKey, PPOLICY_TS_MACHINE pPolicy )
{
    DWORD   dwTmpValue;

    // ---------------- SessionDirectoryActive

    pPolicy->fPolicySessionDirectoryActive =
               GPGetNumValue( policyKey,WIN_SESSIONDIRECTORYACTIVE, &dwTmpValue );
    pPolicy->SessionDirectoryActive = (BOOLEAN) dwTmpValue;

    // ---------------- SessionDirectoryLocation

    
    pPolicy->fPolicySessionDirectoryLocation = GPGetStringValue( policyKey, WIN_SESSIONDIRECTORYLOCATION , 
                    pPolicy->SessionDirectoryLocation,
                    DIRECTORY_LENGTH + 1 );
 

    // ---------------- SessionDirectoryClusterName

    pPolicy->fPolicySessionDirectoryClusterName = GPGetStringValue( policyKey, WIN_SESSIONDIRECTORYCLUSTERNAME , 
                    pPolicy->SessionDirectoryClusterName,
                    DIRECTORY_LENGTH + 1 );
 

    // ---------------- SessionDirectoryAdditionalParams

    pPolicy->fPolicySessionDirectoryAdditionalParams = GPGetStringValue( policyKey, WIN_SESSIONDIRECTORYADDITIONALPARAMS , 
                    pPolicy->SessionDirectoryAdditionalParams,
                    DIRECTORY_LENGTH + 1 );
    

    // ---------------- Clipboard
    pPolicy->fPolicyDisableClip =
               GPGetNumValue( policyKey,WIN_DISABLECLIP, &dwTmpValue ); 
    pPolicy->fDisableClip = (BOOLEAN) dwTmpValue;

    // ---------------- Audio
    pPolicy->fPolicyDisableCam =
               GPGetNumValue( policyKey,WIN_DISABLECAM , &dwTmpValue ); 
    pPolicy->fDisableCam = (BOOLEAN) dwTmpValue;

    // ---------------- Comport
    pPolicy->fPolicyDisableCcm =
               GPGetNumValue( policyKey,WIN_DISABLECCM , &dwTmpValue ); 
    pPolicy->fDisableCcm = (BOOLEAN) dwTmpValue;

    // ---------------- LPT
    pPolicy->fPolicyDisableLPT =
               GPGetNumValue( policyKey,WIN_DISABLELPT , &dwTmpValue ); 
    pPolicy->fDisableLPT = (BOOLEAN) dwTmpValue;

    // ---------------- PRN
    pPolicy->fPolicyDisableCpm =
               GPGetNumValue( policyKey,WIN_DISABLECPM , &dwTmpValue ); 
    pPolicy->fDisableCpm = (BOOLEAN) dwTmpValue;


    // ---------------- Password
    pPolicy->fPolicyPromptForPassword =
               GPGetNumValue( policyKey, WIN_PROMPTFORPASSWORD , &dwTmpValue ); 
    pPolicy->fPromptForPassword = (BOOLEAN) dwTmpValue;

    // ---------------- Max Instance Count
    pPolicy->fPolicyMaxInstanceCount =
               GPGetNumValue( policyKey,WIN_MAXINSTANCECOUNT , &dwTmpValue ); 
    pPolicy->MaxInstanceCount = dwTmpValue;

    // ---------------- Min Encryption Level
    pPolicy->fPolicyMinEncryptionLevel =
               GPGetNumValue( policyKey, WIN_MINENCRYPTIONLEVEL , &dwTmpValue ); 
    pPolicy->MinEncryptionLevel =  (BYTE) dwTmpValue;

    // ---------------- AutoReconect
    pPolicy->fPolicyDisableAutoReconnect =
               GPGetNumValue( policyKey, WIN_DISABLEAUTORECONNECT , &dwTmpValue ); 
    pPolicy->fDisableAutoReconnect = (BOOLEAN) dwTmpValue;


    // New machine wide profile, home dir and home drive
    pPolicy->fPolicyWFProfilePath = GPGetStringValue( policyKey, WIN_WFPROFILEPATH, 
                    pPolicy ->WFProfilePath,
                    DIRECTORY_LENGTH + 1 );

    pPolicy->fPolicyWFHomeDir = GPGetStringValue( policyKey, WIN_WFHOMEDIR , 
                    pPolicy->WFHomeDir,
                    DIRECTORY_LENGTH + 1 );

    pPolicy->fPolicyWFHomeDirDrive =GPGetStringValue( policyKey, WIN_WFHOMEDIRDRIVE, 
                    pPolicy->WFHomeDirDrive,
                    4 );

    // if home dir is of the form "driveletter:\path" (such as c:\foo), null out the dir-drive to 
    // eliminate any confusion.
    if ( pPolicy->WFHomeDir[1] == L':' )
    {
        pPolicy->WFHomeDirDrive[0] = L'\0';
    }


    // --------------- deny connection policy, this is directly read by RegDenyTSConnectionsPolicy() too
    pPolicy->fPolicyDenyTSConnections =
                GPGetNumValue( policyKey, POLICY_DENY_TS_CONNECTIONS , &dwTmpValue ); 
    pPolicy->fDenyTSConnections  = (BOOLEAN) dwTmpValue;

    // track the rest of all possivle GP policies 
    // even thou not all are used by term-srv's USERCONFIGW . A good example is the 
    // delete tmp folders that Winlogon/wlnotify uses.

    // --------------- Per session tmp folders, WARNING : GINA reads policy tree directly for the sake of lower overhead during login
    pPolicy->fPolicyTempFoldersPerSession =
                GPGetNumValue( policyKey, REG_TERMSRV_PERSESSIONTEMPDIR  , &dwTmpValue ); 
    pPolicy-> fTempFoldersPerSession   = (BOOLEAN) dwTmpValue;


    // -------------- delete per session folders on exit, WARNING : GINA reads policy tree directly for the sake of lower overhead during login
    pPolicy->fPolicyDeleteTempFoldersOnExit =
            GPGetNumValue( policyKey, REG_CITRIX_DELETETEMPDIRSONEXIT , &dwTmpValue ); 
    pPolicy->fDeleteTempFoldersOnExit = (BOOLEAN) dwTmpValue;

    pPolicy->fPolicyPreventLicenseUpgrade =
            GPGetNumValue( policyKey, REG_POLICY_PREVENT_LICENSE_UPGRADE , &dwTmpValue ); 
    pPolicy->fPreventLicenseUpgrade = (BOOLEAN) dwTmpValue;


    
    // -------------- Color Depth
    pPolicy->fPolicyColorDepth =
            GPGetNumValue( policyKey, POLICY_TS_COLOR_DEPTH  , &dwTmpValue ); 
    // disabled policy will set value to zero, which we will force it
    // to be the min color depth of 8 bits.
    if ( dwTmpValue < TS_8BPP_SUPPORT ) 
    {
        pPolicy->ColorDepth = TS_8BPP_SUPPORT ;
    }
    else if ( dwTmpValue == TS_CLIENT_COMPAT_BPP_SUPPORT )
    {
        pPolicy->ColorDepth =  TS_24BPP_SUPPORT;    // our current max, may change in teh future.
    }
    else
    {
        pPolicy->ColorDepth =  dwTmpValue;
    }

    // ---------------- TSCC's permissions TAB
    pPolicy->fPolicyWritableTSCCPermissionsTAB =
               GPGetNumValue( policyKey, POLICY_TS_TSCC_PERM_TAB_WRITABLE , &dwTmpValue ); 
    pPolicy->fWritableTSCCPermissionsTAB= (BOOLEAN) dwTmpValue;

    // ----------------
    // Ritu has folded the user policy into machine policy for the drive re-direction.
    pPolicy->fPolicyDisableCdm =
       GPGetNumValue( policyKey, WIN_DISABLECDM , &dwTmpValue ); 
    pPolicy->fDisableCdm = (BOOLEAN) dwTmpValue;

    // ----------------
    // fold user config policy into machine config policy
    pPolicy->fPolicyForceClientLptDef =
       GPGetNumValue( policyKey,WIN_FORCECLIENTLPTDEF , &dwTmpValue ); 
    pPolicy->fForceClientLptDef = (BOOLEAN) dwTmpValue;

    // for user config policy into machine config policy
    // ----------------
    pPolicy->fPolicyShadow = 
        GPGetNumValue( policyKey, WIN_SHADOW, &dwTmpValue ); 
    pPolicy->Shadow = (SHADOWCLASS) dwTmpValue;

    //
    // ---- Sessions Policy
    // 

    // ----------------
    pPolicy->fPolicyResetBroken =
       GPGetNumValue( policyKey,WIN_RESETBROKEN , & dwTmpValue ); 
    pPolicy->fResetBroken = (BOOLEAN) dwTmpValue;

    // ----------------
    pPolicy->fPolicyReconnectSame = 
       GPGetNumValue( policyKey,WIN_RECONNECTSAME , &dwTmpValue ); 
    pPolicy->fReconnectSame = (BOOLEAN) dwTmpValue;

    // ----------------
    pPolicy->fPolicyMaxSessionTime =
        GPGetNumValue( policyKey, WIN_MAXCONNECTIONTIME , &dwTmpValue ); 
    pPolicy->MaxConnectionTime = dwTmpValue;

    // ----------------
    pPolicy->fPolicyMaxDisconnectionTime = 
        GPGetNumValue( policyKey,WIN_MAXDISCONNECTIONTIME ,&dwTmpValue ); 
    pPolicy->MaxDisconnectionTime = dwTmpValue;

    // ----------------
    pPolicy->fPolicyMaxIdleTime =
       GPGetNumValue( policyKey,WIN_MAXIDLETIME , &dwTmpValue ); 
    pPolicy->MaxIdleTime = dwTmpValue;


    // ---------------- Start program policy
    pPolicy->fPolicyInitialProgram = GPGetStringValue( policyKey, WIN_INITIALPROGRAM, 
                    pPolicy->InitialProgram,
                    INITIALPROGRAM_LENGTH + 1 );
    GPGetStringValue( policyKey, WIN_WORKDIRECTORY, 
                    pPolicy->WorkDirectory,
                    DIRECTORY_LENGTH + 1 );

    // ---------------- single session per user
    pPolicy->fPolicySingleSessionPerUser=
       GPGetNumValue( policyKey,POLICY_TS_SINGLE_SESSION_PER_USER, &dwTmpValue ); 
    pPolicy->fSingleSessionPerUser = dwTmpValue;

    pPolicy->fPolicySessionDirectoryExposeServerIP =
        GPGetNumValue( policyKey, REG_TS_SESSDIR_EXPOSE_SERVER_ADDR , &dwTmpValue );
    pPolicy->SessionDirectoryExposeServerIP = dwTmpValue;

    // policy for disabling wallpaper in remote desktop
    pPolicy->fPolicyDisableWallpaper =
        GPGetNumValue( policyKey, POLICY_TS_NO_REMOTE_DESKTOP_WALLPAPER, &dwTmpValue );
    pPolicy->fDisableWallpaper = dwTmpValue;


    // policy to enable disable keep alive
    pPolicy->fPolicyKeepAlive = 
        GPGetNumValue( policyKey, KEEP_ALIVE_ENABLE_KEY , &dwTmpValue );
    pPolicy->fKeepAliveEnable = dwTmpValue;
    GPGetNumValue( policyKey, KEEP_ALIVE_INTERVAL_KEY , &dwTmpValue );
    pPolicy->KeepAliveInterval = dwTmpValue;


}

/*******************************************************************************
*  RegGetMachinePolicy()
*
*  Params:
*     [out]   pPolicy : the machine policy used by ts session's userconfig
*
*  Return:
*     void
*
*******************************************************************************/
void    RegGetMachinePolicy( 
            PPOLICY_TS_MACHINE pPolicy )
{
    NTSTATUS  status=  STATUS_SUCCESS;

    HKEY  policyKey; 


    status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, TS_POLICY_SUB_TREE, 0,
                            KEY_READ, &policyKey );

    if ( status != ERROR_SUCCESS)
    {
        policyKey = NULL;   // prefix complains.
    }

    // ok to call this with policyKey=NULL since func will init pPolicy using default values for the case of NULL key.
    GPQueryMachineConfig( policyKey, pPolicy );

    if ( policyKey )
    {
        RegCloseKey( policyKey );
    }

}



/*******************************************************************************
*  RegGetMachinePolicyiEx()
*
*  This func is identical to RegGetMachinePolicy() , and provides the time stampt for
*   the last write time of the policy key, and if the time of the key is the same as the
*   time for the last read, then it will not bother with any reads and return false
* 
*  Params:
*     [in ]      forcePolicyRead   : 1st time around, you want to init all vars so force a read.
*     [in/out]   pTime             : caller passes in the last write time for the machine policy key. 
*                                       if key is missing, then time is set to zero.
*                                       On return, this param is updated to reflect  the most recent
*                                       update time, which could be zero if the policy key was deleted
*
*     [out]      pPolicy           : the machine policy struct updated
*
*  Return:
*     TRUE  : means there was a real change present
*     FALSE : means no values had changed.
*******************************************************************************/
BOOLEAN    RegGetMachinePolicyEx( 
            BOOLEAN             forcePolicyRead,
            FILETIME            *pTime ,    
            PPOLICY_TS_MACHINE  pPolicy )
{
    HKEY        policyKey; 
    FILETIME    newTime;
    NTSTATUS    status=  STATUS_SUCCESS;
    BOOLEAN     rc = FALSE;

    status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, TS_POLICY_SUB_TREE, 0,
                            KEY_READ, &policyKey );

    if ( status != ERROR_SUCCESS)
    {
        policyKey = NULL;   // prefix complains.
    }

    // if we have a policy key, get the time for that key
    if (policyKey)
    {
        RegQueryInfoKey( policyKey, NULL, NULL, NULL, NULL, NULL,
                        NULL, NULL, NULL, NULL, NULL, &newTime );
    }
    else    // else, init time to the current system time
    {
        SYSTEMTIME  currentTimeOnSystemInSystemTimeUnits;
        GetSystemTime( &currentTimeOnSystemInSystemTimeUnits   );
        SystemTimeToFileTime(  & currentTimeOnSystemInSystemTimeUnits ,    & newTime  );
    }


    if ( forcePolicyRead || 
         ( (pTime->dwHighDateTime < newTime.dwHighDateTime ) ||
             ( ( pTime->dwHighDateTime == newTime.dwHighDateTime ) && pTime->dwLowDateTime < newTime.dwLowDateTime ) ) )
    {
        // this call will init struct memebers even if the policy key in null, so it
        // is required to make this call on startup, with or without an actual reg key being present
        GPQueryMachineConfig( policyKey, pPolicy );

        rc = TRUE;
    }

    pTime->dwHighDateTime = newTime.dwHighDateTime;
    pTime->dwLowDateTime = newTime.dwLowDateTime;

    if ( policyKey )
    {
        RegCloseKey( policyKey );
    }

    return rc;
}

/*******************************************************************************
*  RegMergeMachinePolicy()
*
*  Params:
*     [in]        pPolicy   : policy data to use to override userconfig
*     [in/out]    pWSConfig : userconfig data that is modified based on the policy data
*
*  Return:
*     void
*
********************************************************************************/
void    RegMergeMachinePolicy( 
            PPOLICY_TS_MACHINE     pPolicy,    // the policy override data 
            USERCONFIGW *       pWSConfig,     // the machine config data represented thru a USERCONFIGW data struct (mostly)
            PWINSTATIONCREATE   pCreate        // some of winstation data is stored here
    )
{
    // ---------------------------------------------- Clipboard
    if ( pPolicy->fPolicyDisableClip )
    {
        pWSConfig->fDisableClip = pPolicy->fDisableClip;
    }

    // ---------------------------------------------- Audio
    if ( pPolicy->fPolicyDisableCam )
    {
        pWSConfig->fDisableCam = pPolicy->fDisableCam;
    }

    // ---------------------------------------------- Comport
    if ( pPolicy->fPolicyDisableCcm )
    {
        pWSConfig->fDisableCcm = pPolicy->fDisableCcm;
    }

    // ---------------------------------------------- LPT
    if ( pPolicy->fPolicyDisableLPT )
    {
        pWSConfig->fDisableLPT = pPolicy->fDisableLPT;
    }

    // ---------------------------------------------- PRN
    if ( pPolicy->fPolicyDisableCpm )
    {
        pWSConfig->fDisableCpm = pPolicy->fDisableCpm;
    }

    // ---------------------------------------------- Password
    if ( pPolicy->fPolicyPromptForPassword )
    {
        pWSConfig->fPromptForPassword = pPolicy->fPromptForPassword;
    }

    // ---------------------------------------------- Max Instance
    if ( pPolicy->fPolicyMaxInstanceCount )
    {
        pCreate->MaxInstanceCount = pPolicy->MaxInstanceCount;
    }

    // ---------------------------------------------- Min Encryption Level
    if ( pPolicy->fPolicyMinEncryptionLevel )
    {
        pWSConfig->MinEncryptionLevel = pPolicy->MinEncryptionLevel;
    }

    // ---------------------------------------------- Auto Reconnect disable
    if ( pPolicy->fPolicyDisableAutoReconnect )
    {
        pWSConfig->fDisableAutoReconnect = pPolicy->fDisableAutoReconnect;
    }

    // ---------------------------------------------- 
    if (pPolicy->fPolicyWFProfilePath )
    {
        wcscpy( pWSConfig->WFProfilePath, pPolicy->WFProfilePath );
    }
    else
    {
        pWSConfig->WFProfilePath[0] = L'\0';
    }

    // ---------------------------------------------- 
    if ( pPolicy->fPolicyWFHomeDir )
    {
        wcscpy( pWSConfig->WFHomeDir, pPolicy->WFHomeDir );
    }
    else
    {
        pWSConfig->WFHomeDir[0] = L'\0';
    }

    // ---------------------------------------------- 
    if ( pPolicy->fPolicyWFHomeDirDrive )
    {
        wcscpy( pWSConfig->WFHomeDirDrive, pPolicy->WFHomeDirDrive );
    }
    else
    {
        pWSConfig->WFHomeDirDrive[0] = L'\0';
    }

    if ( pPolicy->fPolicyColorDepth)
    {                              
        pWSConfig->ColorDepth = pPolicy->ColorDepth ;

		//NA 2/23/01
        pWSConfig->fInheritColorDepth = FALSE;
    }

    // 
    if ( pPolicy->fPolicyDisableCdm)
    {
        pWSConfig->fDisableCdm = pPolicy->fDisableCdm;
    }

    // 
    if ( pPolicy->fPolicyForceClientLptDef )
    {
        pWSConfig->fForceClientLptDef = pPolicy->fForceClientLptDef;
    }


    // Shadow
    if ( pPolicy->fPolicyShadow)
    {
        pWSConfig->Shadow = pPolicy->Shadow;
        pWSConfig->fInheritShadow = FALSE;
    }


    if (pPolicy->fPolicyResetBroken )
    {
        pWSConfig->fResetBroken = pPolicy->fResetBroken;
        pWSConfig->fInheritResetBroken = FALSE;
    }

    if (pPolicy->fPolicyReconnectSame )
    {
        pWSConfig->fReconnectSame = pPolicy->fReconnectSame;
        pWSConfig->fInheritReconnectSame = FALSE;  
    }

    if (pPolicy->fPolicyMaxSessionTime )
    {
        pWSConfig->MaxConnectionTime = pPolicy->MaxConnectionTime;
        pWSConfig->fInheritMaxSessionTime = FALSE;
    }

    if (pPolicy->fPolicyMaxDisconnectionTime)
    {
        pWSConfig->MaxDisconnectionTime = pPolicy->MaxDisconnectionTime;
        pWSConfig->fInheritMaxDisconnectionTime = FALSE;
    }

    if (pPolicy->fPolicyMaxIdleTime)
    {
       pWSConfig->MaxIdleTime = pPolicy->MaxIdleTime;
       pWSConfig->fInheritMaxIdleTime = FALSE;
    }

    if (pPolicy->fPolicyInitialProgram)
    {
        wcscpy( pWSConfig->InitialProgram, pPolicy->InitialProgram );
        wcscpy( pWSConfig->WorkDirectory,  pPolicy->WorkDirectory );
        pWSConfig->fInheritInitialProgram = FALSE;
    }

    if ( pPolicy->fPolicyDisableWallpaper )
    {
        pWSConfig->fWallPaperDisabled = pPolicy->fDisableWallpaper ;
    }

    // ---------------------------------------------- 
    //      There is no UI for setting these... So it's probably never used
    //
        //     if ( pPolicy->fPolicytSecurity )
        //     {
        //         pWSConfig->fDisableEncryption = pPolicy->fDisableEncryption;
        //         pWSConfig->MinEncryptionLevel = pPolicy->MinEncryptionLevel;
        //     }
        //     else
        //     {
        //         if ( pWSConfig->fInheritSecurity )
        //         {
        //             pWSConfig->fDisableEncryption = pPolicy->fDisableEncryption;
        //             pWSConfig->MinEncryptionLevel = pPolicy->MinEncryptionLevel;
        //         }
        //     }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\regapi\query.c ===
/*************************************************************************
*
* query.c
*
* Query Register APIs
*
* Copyright (c) 1998 Microsoft Corporation
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

#include <ntddkbd.h>
#include <ntddmou.h>
#include <winstaw.h>
#include <regapi.h>


/*
 *  Procedures defined
 */
VOID QueryWinStaCreate( HKEY, PWINSTATIONCREATE );
VOID QueryUserConfig( HKEY, PUSERCONFIG );
VOID QueryConfig( HKEY, PWINSTATIONCONFIG );
VOID QueryNetwork( HKEY, PNETWORKCONFIG );
VOID QueryNasi( HKEY, PNASICONFIG );
VOID QueryAsync( HKEY, PASYNCCONFIG );
VOID QueryOemTd( HKEY, POEMTDCONFIG );
VOID QueryFlow( HKEY, PFLOWCONTROLCONFIG );
VOID QueryConnect( HKEY, PCONNECTCONFIG );
VOID QueryCd( HKEY, PCDCONFIG );
VOID QueryWd( HKEY, PWDCONFIG );
VOID QueryPdConfig( HKEY, PPDCONFIG, PULONG );
VOID QueryPdConfig2( HKEY, PPDCONFIG2, ULONG );
VOID QueryPdConfig3( HKEY, PPDCONFIG3, ULONG );
VOID QueryPdParams( HKEY, SDCLASS, PPDPARAMS );
BOOLEAN WINAPI RegBuildNumberQuery( PULONG );
BOOLEAN RegQueryOEMId( PBYTE, ULONG );
BOOLEAN WINAPI RegGetCitrixVersion(WCHAR *, PULONG);

BOOLEAN IsWallPaperDisabled( HKEY );

/*
 * procedures used
 */
DWORD GetNumValue( HKEY, LPWSTR, DWORD );
DWORD GetNumValueEx( HKEY, LPWSTR, DWORD, DWORD );
LONG GetStringValue( HKEY, LPWSTR, LPWSTR, LPWSTR, DWORD );
LONG GetStringValueEx( HKEY, LPWSTR, DWORD, LPWSTR, LPWSTR, DWORD );
VOID UnicodeToAnsi( CHAR *, ULONG, WCHAR * );


/*******************************************************************************
 *
 *  QueryWinStaCreate
 *
 *     query WINSTATIONCREATE structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pCreate (output)
 *       address to return WINSTATIONCREATE structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryWinStaCreate( HKEY Handle,
                   PWINSTATIONCREATE pCreate )
{
    pCreate->fEnableWinStation = (BOOLEAN) GetNumValue( Handle,
                                                       WIN_ENABLEWINSTATION,
                                                       TRUE );
    pCreate->MaxInstanceCount = GetNumValue( Handle,
                                                                     WIN_MAXINSTANCECOUNT,
                                                                     1 );
}


/*******************************************************************************
 *
 *  QueryUserConfig
 *
 *     query USERCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pUser (input)
 *       pointer to USERCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryUserConfig( HKEY Handle,
                 PUSERCONFIG pUser )
{
    UCHAR seed;
    UNICODE_STRING UnicodePassword;
    WCHAR encPassword[ PASSWORD_LENGTH + 2 ];

    pUser->fInheritAutoLogon =
       (BOOLEAN) GetNumValue( Handle, WIN_INHERITAUTOLOGON, TRUE );

    pUser->fInheritResetBroken =
       (BOOLEAN) GetNumValue( Handle, WIN_INHERITRESETBROKEN, TRUE );

    pUser->fInheritReconnectSame =
       (BOOLEAN) GetNumValue( Handle, WIN_INHERITRECONNECTSAME, TRUE );

    pUser->fInheritInitialProgram =
       (BOOLEAN) GetNumValue( Handle, WIN_INHERITINITIALPROGRAM, TRUE );

    pUser->fInheritCallback =
       (BOOLEAN) GetNumValue( Handle, WIN_INHERITCALLBACK, FALSE );

    pUser->fInheritCallbackNumber =
       (BOOLEAN) GetNumValue( Handle, WIN_INHERITCALLBACKNUMBER, TRUE );

    pUser->fInheritShadow =
       (BOOLEAN) GetNumValue( Handle, WIN_INHERITSHADOW, TRUE );

    pUser->fInheritMaxSessionTime =
       (BOOLEAN) GetNumValue( Handle, WIN_INHERITMAXSESSIONTIME, TRUE );

    pUser->fInheritMaxDisconnectionTime =
       (BOOLEAN) GetNumValue( Handle, WIN_INHERITMAXDISCONNECTIONTIME, TRUE );

    pUser->fInheritMaxIdleTime =
       (BOOLEAN) GetNumValue( Handle, WIN_INHERITMAXIDLETIME, TRUE );

    pUser->fInheritAutoClient =
       (BOOLEAN) GetNumValue( Handle, WIN_INHERITAUTOCLIENT, TRUE );

    pUser->fInheritSecurity =
       (BOOLEAN) GetNumValue( Handle, WIN_INHERITSECURITY, FALSE );

	//NA 2/23/01
    pUser->fInheritColorDepth =
       (BOOLEAN) GetNumValue( Handle, WIN_INHERITCOLORDEPTH, TRUE );

    pUser->fPromptForPassword =
       (BOOLEAN) GetNumValue( Handle, WIN_PROMPTFORPASSWORD, FALSE );

    pUser->fResetBroken =
       (BOOLEAN) GetNumValue( Handle, WIN_RESETBROKEN, FALSE );

    pUser->fReconnectSame =
       (BOOLEAN) GetNumValue( Handle, WIN_RECONNECTSAME, FALSE );

    pUser->fLogonDisabled =
       (BOOLEAN) GetNumValue( Handle, WIN_LOGONDISABLED, FALSE );

    pUser->fAutoClientDrives =
       (BOOLEAN) GetNumValue( Handle, WIN_AUTOCLIENTDRIVES, TRUE );

    pUser->fAutoClientLpts =
       (BOOLEAN) GetNumValue( Handle, WIN_AUTOCLIENTLPTS, TRUE );

    pUser->fForceClientLptDef =
       (BOOLEAN) GetNumValue( Handle, WIN_FORCECLIENTLPTDEF, TRUE );

    pUser->fDisableEncryption =
       (BOOLEAN) GetNumValue( Handle, WIN_DISABLEENCRYPTION, TRUE );

    pUser->fHomeDirectoryMapRoot =
       (BOOLEAN) GetNumValue( Handle, WIN_HOMEDIRECTORYMAPROOT, FALSE );

    pUser->fUseDefaultGina =
       (BOOLEAN) GetNumValue( Handle, WIN_USEDEFAULTGINA, FALSE );

    pUser->fDisableCpm =
       (BOOLEAN) GetNumValue( Handle, WIN_DISABLECPM, FALSE );

    pUser->fDisableCdm =
       (BOOLEAN) GetNumValue( Handle, WIN_DISABLECDM, FALSE );

    pUser->fDisableCcm =
       (BOOLEAN) GetNumValue( Handle, WIN_DISABLECCM, FALSE );

    pUser->fDisableLPT =
       (BOOLEAN) GetNumValue( Handle, WIN_DISABLELPT, FALSE );

    pUser->fDisableClip =
       (BOOLEAN) GetNumValue( Handle, WIN_DISABLECLIP, FALSE );

    pUser->fDisableExe =
       (BOOLEAN) GetNumValue( Handle, WIN_DISABLEEXE, FALSE );

    pUser->fDisableCam =
       (BOOLEAN) GetNumValue( Handle, WIN_DISABLECAM, FALSE );

    GetStringValue( Handle, WIN_USERNAME, NULL, pUser->UserName,
                    USERNAME_LENGTH + 1 );

    GetStringValue( Handle, WIN_DOMAIN, NULL, pUser->Domain,
                    DOMAIN_LENGTH + 1 );

    //  pull encrypted password out of registry
    GetStringValue( Handle, WIN_PASSWORD, NULL, encPassword,
                    PASSWORD_LENGTH + 2 );

    //  check for password if there is one then decrypt it
    if ( wcslen( encPassword ) ) {

        //  generate unicode string
        RtlInitUnicodeString( &UnicodePassword, &encPassword[1] );

        //  decrypt password in place
        seed = (UCHAR) encPassword[0];
        RtlRunDecodeUnicodeString( seed, &UnicodePassword );

        //  pull clear text password
        RtlMoveMemory( pUser->Password, &encPassword[1], sizeof(pUser->Password) );
    }
    else {

        //  set to null
        pUser->Password[0] = (WCHAR) NULL;
    }

    GetStringValue( Handle, WIN_WORKDIRECTORY, NULL, pUser->WorkDirectory,
                    DIRECTORY_LENGTH + 1 );

    GetStringValue( Handle, WIN_INITIALPROGRAM, NULL, pUser->InitialProgram,
                    INITIALPROGRAM_LENGTH + 1 );

    GetStringValue( Handle, WIN_CALLBACKNUMBER, NULL, pUser->CallbackNumber,
                    CALLBACK_LENGTH + 1 );

    pUser->Callback = GetNumValue( Handle, WIN_CALLBACK, Callback_Disable );

    pUser->Shadow = GetNumValue( Handle, WIN_SHADOW, Shadow_EnableInputNotify );

    pUser->MaxConnectionTime = GetNumValue( Handle, WIN_MAXCONNECTIONTIME, 0 );

    pUser->MaxDisconnectionTime = GetNumValue( Handle,
                                               WIN_MAXDISCONNECTIONTIME, 0 );

    pUser->MaxIdleTime = GetNumValue( Handle, WIN_MAXIDLETIME, 0 );

    pUser->KeyboardLayout = GetNumValue( Handle, WIN_KEYBOARDLAYOUT, 0 );

    pUser->MinEncryptionLevel = (BYTE) GetNumValue( Handle, WIN_MINENCRYPTIONLEVEL, 1 );

    pUser->fWallPaperDisabled = (BOOLEAN) IsWallPaperDisabled( Handle );

    GetStringValue( Handle, WIN_NWLOGONSERVER, NULL, pUser->NWLogonServer,
                    NASIFILESERVER_LENGTH + 1 );

    GetStringValue( Handle, WIN_WFPROFILEPATH, NULL, pUser->WFProfilePath,
                    DIRECTORY_LENGTH + 1 );

    GetStringValue( Handle, WIN_WFHOMEDIR, NULL, pUser->WFHomeDir,
                    DIRECTORY_LENGTH + 1 );

    GetStringValue( Handle, WIN_WFHOMEDIRDRIVE, NULL, pUser->WFHomeDirDrive,
                    4 );

    pUser->ColorDepth = GetNumValue( Handle, POLICY_TS_COLOR_DEPTH, TS_8BPP_SUPPORT  );



}


/*******************************************************************************
 *
 *  QueryConfig
 *
 *     query WINSTATIONCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pConfig (output)
 *       address to return WINSTATIONCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryConfig( HKEY Handle,
             PWINSTATIONCONFIG pConfig )
{
    GetStringValue( Handle, WIN_COMMENT, NULL, pConfig->Comment,
                    WINSTATIONCOMMENT_LENGTH + 1 );

    QueryUserConfig( Handle, &pConfig->User );

    (void) RegQueryOEMId( pConfig->OEMId, sizeof(pConfig->OEMId) );
}


/*******************************************************************************
 *
 *  QueryNetwork
 *
 *     Query NETWORKCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pNetwork (output)
 *       address to return NETWORKCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryNetwork( HKEY Handle,
              PNETWORKCONFIG pNetwork )
{
    pNetwork->LanAdapter = GetNumValue( Handle, WIN_LANADAPTER, 0 );
}


/*******************************************************************************
 *
 *  QueryNasi
 *
 *     Query NASICONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pNasi (output)
 *       address to return NASICONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryNasi( HKEY Handle,
           PNASICONFIG pNasi )
{
    UCHAR seed;
    UNICODE_STRING UnicodePassword;
    WCHAR encPassword[ NASIPASSWORD_LENGTH + 2 ];

    //  pull encrypted password out of registry
    GetStringValue( Handle, WIN_NASIPASSWORD, NULL, encPassword,
                    NASIPASSWORD_LENGTH + 1 );

    //  check for password if there is one then decrypt it
    if ( wcslen( encPassword ) ) {

        //  generate unicode string
        RtlInitUnicodeString( &UnicodePassword, &encPassword[1] );

        //  decrypt password in place
        seed = (UCHAR) encPassword[0];
        RtlRunDecodeUnicodeString( seed, &UnicodePassword );

        //  pull clear text password
        RtlMoveMemory( pNasi->PassWord, &encPassword[1], sizeof(pNasi->PassWord) );
    }
    else {

        //  set to null
        pNasi->PassWord[0] = (WCHAR) NULL;
    }

    GetStringValue( Handle, WIN_NASISPECIFICNAME, NULL, pNasi->SpecificName,
                    NASISPECIFICNAME_LENGTH + 1 );
    GetStringValue( Handle, WIN_NASIUSERNAME, NULL, pNasi->UserName,
                    NASIUSERNAME_LENGTH + 1 );
    GetStringValue( Handle, WIN_NASISESSIONNAME, NULL, pNasi->SessionName,
                    NASISESSIONNAME_LENGTH + 1 );
    GetStringValue( Handle, WIN_NASIFILESERVER, NULL, pNasi->FileServer,
                    NASIFILESERVER_LENGTH + 1 );
    pNasi->GlobalSession = (BOOLEAN)GetNumValue( Handle, WIN_NASIGLOBALSESSION, 0 );
}


/*******************************************************************************
 *
 *  QueryAsync
 *
 *     query ASYNCCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pAsync (output)
 *       address to return ASYNCCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryAsync( HKEY Handle,
            PASYNCCONFIG pAsync )
{
    GetStringValue( Handle, WIN_DEVICENAME, NULL, pAsync->DeviceName,
                    DEVICENAME_LENGTH + 1 );

    GetStringValue( Handle, WIN_MODEMNAME, NULL, pAsync->ModemName,
                    MODEMNAME_LENGTH + 1 );

    pAsync->BaudRate = GetNumValue( Handle, WIN_BAUDRATE, 9600 );

    pAsync->Parity = GetNumValue( Handle, WIN_PARITY, NOPARITY );

    pAsync->StopBits = GetNumValue( Handle, WIN_STOPBITS, ONESTOPBIT );

    pAsync->ByteSize = GetNumValue( Handle, WIN_BYTESIZE, 8 );

    pAsync->fEnableDsrSensitivity = (BOOLEAN) GetNumValue( Handle,
                                                      WIN_ENABLEDSRSENSITIVITY,
                                                      FALSE );

    pAsync->fConnectionDriver = (BOOLEAN) GetNumValue( Handle,
                                                       WIN_CONNECTIONDRIVER,
                                                       FALSE );

    QueryFlow( Handle, &pAsync->FlowControl );

    QueryConnect( Handle, &pAsync->Connect );
}

/*******************************************************************************
 *
 *  QueryOemTd
 *
 *     Query OEMTDCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pOemTd (output)
 *       address to return OEMTDCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryOemTd( HKEY Handle,
            POEMTDCONFIG pOemTd )
{
    pOemTd->Adapter = GetNumValue( Handle, WIN_OEMTDADAPTER, 0 );

    GetStringValue( Handle, WIN_OEMTDDEVICENAME, NULL, pOemTd->DeviceName,
                    DEVICENAME_LENGTH + 1 );

    pOemTd->Flags = GetNumValue( Handle, WIN_OEMTDFLAGS, 0 );
}


/*******************************************************************************
 *
 *  QueryFlow
 *
 *     query FLOWCONTROLCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pFlow (output)
 *       address to return FLOWCONTROLCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryFlow( HKEY Handle,
           PFLOWCONTROLCONFIG pFlow )
{
    pFlow->fEnableSoftwareRx = (BOOLEAN) GetNumValue( Handle,
                                                      WIN_FLOWSOFTWARERX,
                                                      FALSE );

    pFlow->fEnableSoftwareTx = (BOOLEAN) GetNumValue( Handle,
                                                      WIN_FLOWSOFTWARETX,
                                                      TRUE );

    pFlow->fEnableDTR = (BOOLEAN) GetNumValue( Handle, WIN_ENABLEDTR, TRUE );

    pFlow->fEnableRTS = (BOOLEAN) GetNumValue( Handle, WIN_ENABLERTS, TRUE );

    pFlow->XonChar = (UCHAR) GetNumValue( Handle, WIN_XONCHAR, 0 );

    pFlow->XoffChar = (UCHAR) GetNumValue( Handle, WIN_XOFFCHAR, 0 );

    pFlow->Type = GetNumValue( Handle, WIN_FLOWTYPE, FlowControl_Hardware );

    pFlow->HardwareReceive = GetNumValue( Handle, WIN_FLOWHARDWARERX,
                                          ReceiveFlowControl_RTS );

    pFlow->HardwareTransmit = GetNumValue( Handle, WIN_FLOWHARDWARETX,
                                           TransmitFlowControl_CTS );
}


/*******************************************************************************
 *
 *  QueryConnect
 *
 *     query CONNECTCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pConnect (output)
 *       address to return CONNECTCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryConnect( HKEY Handle,
              PCONNECTCONFIG pConnect )
{
    pConnect->Type = GetNumValue( Handle, WIN_CONNECTTYPE, Connect_DSR );

    pConnect->fEnableBreakDisconnect = (BOOLEAN) GetNumValue( Handle,
                                                    WIN_ENABLEBREAKDISCONNECT,
                                                    FALSE );
}


/*******************************************************************************
 *
 *  QueryCd
 *
 *     query CDCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pCdConfig (output)
 *       address to return CDCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryCd( HKEY Handle,
         PCDCONFIG pCdConfig )
{
    pCdConfig->CdClass = GetNumValue( Handle, WIN_CDCLASS, CdNone );

    GetStringValue( Handle, WIN_CDNAME, NULL, pCdConfig->CdName,
                    CDNAME_LENGTH + 1 );

    GetStringValue( Handle, WIN_CDDLL, L"", pCdConfig->CdDLL,
                    DLLNAME_LENGTH + 1 );

    pCdConfig->CdFlag = GetNumValue( Handle, WIN_CDFLAG, 0 );
}


/*******************************************************************************
 *
 *  QueryWd
 *
 *     query WDCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pWd (output)
 *       address to return WDCONFIG structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryWd( HKEY Handle,
         PWDCONFIG pWd )
{
    GetStringValue( Handle, WIN_WDNAME, NULL, pWd->WdName, WDNAME_LENGTH + 1 );
    GetStringValue( Handle, WIN_WDDLL, L"", pWd->WdDLL, DLLNAME_LENGTH + 1 );
    GetStringValue( Handle, WIN_WSXDLL, NULL, pWd->WsxDLL, DLLNAME_LENGTH + 1 );
    pWd->WdFlag = GetNumValue( Handle, WIN_WDFLAG, 0 );
    pWd->WdInputBufferLength = GetNumValue( Handle, WIN_INPUTBUFFERLENGTH, 2048 );
    GetStringValue( Handle, WIN_CFGDLL, NULL, pWd->CfgDLL, DLLNAME_LENGTH + 1 );
    GetStringValue( Handle, WIN_WDPREFIX, NULL, pWd->WdPrefix, WDPREFIX_LENGTH + 1 );
}


/*******************************************************************************
 *
 *  QueryPdConfig
 *
 *     query PDCONFIG structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pConfig (output)
 *       address to return array of PDCONFIG structures
 *    pCount (input/output)
 *       pointer to number of PDCONFIG array elements
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryPdConfig( HKEY Handle,
                PPDCONFIG pConfig,
                PULONG pCount )
{
    ULONG i;

    for ( i=0; i < *pCount; i++ ) {

        QueryPdConfig2( Handle, &pConfig[i].Create, i );

        QueryPdParams( Handle,
                        pConfig[i].Create.SdClass,
                        &pConfig[i].Params );
    }

    *pCount = MAX_PDCONFIG;
}


/*******************************************************************************
 *
 *  QueryPdConfig2
 *
 *     query PDCONFIG2 structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pPd2 (output)
 *       address to return PDCONFIG2 structure
 *    Index (input)
 *       Index (array index)
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryPdConfig2( HKEY Handle,
                PPDCONFIG2 pPd2,
                ULONG Index )
{
    GetStringValueEx( Handle, WIN_PDNAME, Index,
                      NULL, pPd2->PdName, PDNAME_LENGTH + 1 );

    pPd2->SdClass = GetNumValueEx( Handle, WIN_PDCLASS, Index, Index==0 ? SdAsync : SdNone );

    GetStringValueEx( Handle, WIN_PDDLL, Index,
                      NULL, pPd2->PdDLL, DLLNAME_LENGTH + 1 );

    pPd2->PdFlag = GetNumValueEx( Handle, WIN_PDFLAG, Index, 0 );

    /* 
     *  The following data is the same for all pds
     */
    pPd2->OutBufLength =  GetNumValue( Handle, WIN_OUTBUFLENGTH, 530 );

    pPd2->OutBufCount = GetNumValue( Handle, WIN_OUTBUFCOUNT, 10 );

    pPd2->OutBufDelay = GetNumValue( Handle, WIN_OUTBUFDELAY, 100 );

    pPd2->InteractiveDelay = GetNumValue( Handle, WIN_INTERACTIVEDELAY, 10 );

    pPd2->KeepAliveTimeout = GetNumValue( Handle, WIN_KEEPALIVETIMEOUT, 0 );

    pPd2->PortNumber = GetNumValue( Handle, WIN_PORTNUMBER, 0 );
}

/*******************************************************************************
 *
 *  QueryPdConfig3
 *
 *     query PDCONFIG3 structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    pPd (output)
 *       address to return PDCONFIG3 structure
 *    Index (input)
 *       Index (array index)
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryPdConfig3( HKEY Handle,
                 PPDCONFIG3 pPd3,
                 ULONG Index )
{
    int i;
    ULONG Length;
    LPWSTR tmp;
    WCHAR PdName[ MAX_PDCONFIG * ( PDNAME_LENGTH + 1 ) + 1 ];
    ULONG ValueType;

    QueryPdConfig2( Handle, &pPd3->Data, Index );

    GetStringValue( Handle, WIN_SERVICENAME, NULL,
                    pPd3->ServiceName,
                    PDNAME_LENGTH + 1 );

    GetStringValue( Handle, WIN_CONFIGDLL, NULL,
                    pPd3->ConfigDLL,
                    DLLNAME_LENGTH + 1 );
    
    Length = sizeof(PdName);
    pPd3->RequiredPdCount = 0;
    if ( RegQueryValueEx( Handle, WIN_REQUIREDPDS, NULL, &ValueType,
                          (LPBYTE)PdName, &Length ) == ERROR_SUCCESS ) {
        tmp = PdName;
        i = 0;
        while ( *tmp != UNICODE_NULL ) {
            pPd3->RequiredPdCount++;
            wcscpy( pPd3->RequiredPds[i], tmp );
            i++;
            tmp += wcslen(tmp) + 1;
        }
    }
}

/*******************************************************************************
 *
 *  QueryPdParams
 *
 *     query PDPARAMS structure
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    SdClass (input)
 *       type of PD
 *    pParams (output)
 *       address to return PDPARAMS structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
QueryPdParams( HKEY Handle,
                SDCLASS SdClass,
                PPDPARAMS pParams )
{
    pParams->SdClass = SdClass;
    switch ( SdClass ) {
        case SdNetwork :
            QueryNetwork( Handle, &pParams->Network );
            break;
        case SdNasi :
            QueryNasi( Handle, &pParams->Nasi );
            break;
        case SdAsync :
            QueryAsync( Handle, &pParams->Async );
            break;
        case SdOemTransport :
            QueryOemTd( Handle, &pParams->OemTd );
            break;
    }
}

#define CONTROL_PANEL L"Control Panel"
#define DESKTOP       L"Desktop"
#define WALLPAPER     L"Wallpaper"
#define NONE          L"(None)"

/*******************************************************************************
 *
 *  IsWallPaperDisabled
 *
 *     Is the wall paper disabled?
 *
 * ENTRY:
 *    Handle (input)
 *       registry handle
 * EXIT:
 *    TRUE or FALSE (returns FALSE as default)
 *
 ******************************************************************************/
BOOLEAN IsWallPaperDisabled( HKEY Handle )
{
    HKEY Handle1;
    WCHAR KeyString[256];

    wcscpy( KeyString, WIN_USEROVERRIDE );
    wcscat( KeyString, L"\\" );
    wcscat( KeyString, CONTROL_PANEL );
    wcscat( KeyString, L"\\" );
    wcscat( KeyString, DESKTOP );

    if ( RegOpenKeyEx( Handle, KeyString, 0, KEY_READ,
                       &Handle1 ) != ERROR_SUCCESS )
        return FALSE;


    GetStringValue( Handle1, WALLPAPER, NULL, KeyString, 256 );
    RegCloseKey( Handle1 );

    if( KeyString[0] == 0 ||  ( _wcsicmp( NONE, KeyString ) == 0 ) )
    {
        return TRUE;
    }
    
    return FALSE;
}


/*****************************************************************************
 *
 *  RegBuildNumberQuery
 *
 *   Query the current build number from the registry.
 *
 *   HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\Current Version\
 *       CurrentBuildNumber:REG_SZ:129
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
RegBuildNumberQuery(
    PULONG pBuildNum
    )
{
    ULONG  Result, Value;
    HKEY   hKey;
    WCHAR  Buf[256];

    Result = RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 BUILD_NUMBER_KEY,
                 0, // Reserved
                 KEY_READ,
                 &hKey
                 );

    if( Result != ERROR_SUCCESS ) {
#if DBG
        DbgPrint("RegBuildNumberQuery: Failed to open key %ws\n",BUILD_NUMBER_KEY);
#endif
        return( FALSE );
    }

    Result = GetStringValue(
                 hKey,
                 BUILD_NUMBER_VALUE,
                 L"0",
                 Buf,
                 sizeof(Buf)
                 );

    if( Result != ERROR_SUCCESS ) {
#if DBG
        DbgPrint("RegBuildNumberQuery: Failed to query value %ws\n",BUILD_NUMBER_VALUE);
#endif
        RegCloseKey( hKey );
        return( FALSE );
    }

    RegCloseKey( hKey );

    //
    // Now must convert it into a number
    //
    Value = 0;
    swscanf( Buf, L"%d", &Value );

    *pBuildNum = Value;

    return( TRUE );
}


/*******************************************************************************
 *
 *  RegQueryOEMId
 *
 *    query oem id
 *
 * ENTRY:
 *
 *    pOEMId (output)
 *       pointer to buffer to return oem id
 *    Length (input)
 *       length of buffer
 *
 * EXIT:
 *
 *    TRUE  -- The operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
RegQueryOEMId( PBYTE pOEMId, ULONG Length )
{
    HKEY Handle2;
    WCHAR OEMIdW[10];

    /*
     *  Open registry (LOCAL_MACHINE\....\Terminal Server)
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                       KEY_READ, &Handle2 ) == ERROR_SUCCESS ) {
        
        GetStringValue( Handle2, REG_CITRIX_OEMID, NULL, OEMIdW, 10 );
        UnicodeToAnsi( pOEMId, Length, OEMIdW );
        pOEMId[3] = '\0';

        RegCloseKey( Handle2 );
    }

    return( TRUE );
}


/*******************************************************************************
 *
 *  RegGetTServerVersion (UNICODE)
 *
 *    Get the Terminal Server version number from the specified server.
 *
 *    This version number is changed by Microsoft, and not OEM's.
 *
 * ENTRY:
 *    pServerName (input)
 *       Points to string of server to check.
 *
 * EXIT:
 *    TRUE if Hydra Terminal Server; FALSE otherwise
 *
 ******************************************************************************/

BOOLEAN WINAPI
RegGetTServerVersion(
    WCHAR * pServerName,
    PULONG  pVersionNumber
    )
{
    LONG Error;
    HKEY ServerHandle, UserHandle;
    ULONG Value;

    /*
     * Connect to registry of specified server.
     */
    if ( (Error = RegConnectRegistry( pServerName,
                                      HKEY_LOCAL_MACHINE,
                                      &ServerHandle )) != ERROR_SUCCESS )
        return( FALSE );

    /*
     * Open the Terminal Server key and get the Version value.
     */
    if ( (Error = RegOpenKeyEx( ServerHandle, REG_CONTROL_TSERVER, 0,
                                KEY_READ, &UserHandle )) != ERROR_SUCCESS ) {

        RegCloseKey( ServerHandle );
        return( FALSE );
    }

    Value = GetNumValue(
                UserHandle,
                REG_CITRIX_VERSION,
                0 );

    /*
     *  Close registry handles.
     */
    RegCloseKey( UserHandle );
    RegCloseKey( ServerHandle );

    *pVersionNumber = Value;

    return( TRUE );
}


/*******************************************************************************
 *
 *  RegQueryUtilityCommandList (UNICODE)
 *
 *    Allocate and build an array of PROGRAMCALL structures for the specified
 *    MultiUser utility.
 *
 * ENTRY:
 *    pUtilityKey (input)
 *       Points to string containing the utility's command registry key.
 *    ppProgramCall (output)
 *       Points to a PPROGRAMCALL variable that will be set to the API-allocated
 *       array of PROGRAMCALL structures, containing n elements, where n = 
 *       number of commands supported by the utility (as specified in the 
 *       registry).  The pFirst item of array element 0 will point to the 
 *       first command (sorted alphabetically by command name).  The pNext items
 *       are then used to walk the list, till pNext is NULL.
 *
 * EXIT:
 *      ERROR_SUCCESS if all goes well;
 *      An error code is returned if failure.
 *
 *      If success, the caller must call RegFreeUtilityCommandList with the
 *      ppProgramCall variable to free the PROGRAMCALL structure array when
 *      finished using the array.
 *
 *  The format of the REG_MULTI_SZ command item in the registry is as follows:
 *
 *      string 1: "0" or "1" (required)
 *
 *                  0 specifies that the command is a normal command which will
 *                  be presented as an option by the utility USAGE help.  1
 *                  indicates a command alias (hidden option), which won't 
 *                  appear in USAGE help.
 *
 *      string 2: "number" (required)
 *
 *                  Specifies the minimum number of characters that must be
 *                  typed for the command to be recognized (base 10).
 *
 *      string 3: "command" (required)
 *
 *                  This is the actual command that will be recognized and
 *                  displayed in the USAGE help (if not an aliased command).
 *
 *      string 4: "program" (required)
 *
 *                  The file name of the program that will be executed.  This
 *                  should be a standard name.extension filename, and can 
 *                  include a full path, although this is not necessary since
 *                  the utilities will normally reside in the standard SYSTEM32
 *                  directory, which is a part of the standard PATH.
 *
 *      string 5: "extra args" (optional)
 *
 *                  If specified, this string will be passed along to the
 *                  utilsub.lib ExecProgram API to specify additional
 *                  hard-coded arguments that will be used, in addition to any
 *                  other arguments that were specified by the user on the
 *                  command line.
 *
 *  Note: If the command item is not a REG_MULTI_SZ value, or the command item 
 *        is a REG_MULTI_SZ item but there is an error in its format, that 
 *        command will be omitted from the command list.  The return value 
 *        from this function will still be ERROR_SUCCESS, but the command in 
 *        error will be ignored by the utilities.
 *
 ******************************************************************************/

LONG WINAPI
RegQueryUtilityCommandList(
    LPWSTR pUtilityKey,
    PPROGRAMCALL * ppProgramCall
    )
{
    HKEY Handle = NULL;
    LONG status = ERROR_SUCCESS;
    DWORD iValue, cValues, ccValueName, cbValueData,
          ccTmpValueName, cbTmpValueData, dwType;
    LPWSTR pValueName = NULL, pValueData = NULL, pString;
    PPROGRAMCALL pProg = NULL, pProgNext, pProgPrev;
    ULONG ulCommandLen;
    PWCHAR pEndptr;
    int iCompare;

    *ppProgramCall = NULL;

    /*
     * Open specified utility key and determine number of values and maximum
     * value name and data length.
     */
    if ( status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
                                pUtilityKey, 
                                0,
                                    KEY_READ, 
                                &Handle ) != ERROR_SUCCESS ) {
#if DBG
        DbgPrint("RegQueryUtilityCommandList: Can't open command list utility key %ws; error = %d\n", pUtilityKey, status);
#endif
        goto error;
    }

    if ( status = RegQueryInfoKey( Handle, 
                                   NULL,            // lpClass
                                   NULL,            // lpcbClass
                                   NULL,            // lpReserved
                                   NULL,            // lpcSubKeys
                                   NULL,            // lpcbMaxSubKeyLen
                                   NULL,            // lpcbMaxClassLen
                                   &cValues,        // lpcValues
                                   &ccValueName,    // lpcbMaxValueNameLen
                                   &cbValueData,    // lpcbMaxValueLen
                                   NULL,            // lpcbSecurityDescriptor
                                   NULL             // lpftLastWriteTime
                                   ) != ERROR_SUCCESS ) {
#if DBG
        DbgPrint("RegQueryUtilityCommandList: Can't query info for utility %ws; error = %d\n", pUtilityKey, status);
#endif
        goto error;
    }

    /*
     * Allocate space for #values + 1 PROGRAMCALL elements and value name and
     * data buffers.
     */
    if ( ((*ppProgramCall = (PPROGRAMCALL)LocalAlloc( LPTR, (sizeof(PROGRAMCALL) * (cValues+1)) )) == NULL) ||
         ((pValueName = (LPWSTR)LocalAlloc( LPTR, (int)(++ccValueName * sizeof(WCHAR)) )) == NULL) ||
         ((pValueData = (LPWSTR)LocalAlloc( LPTR, (int)cbValueData )) == NULL) ) {

        status = GetLastError();
#if DBG
        DbgPrint("RegQueryUtilityCommandList: Can't allocate memory buffer(s) for utility %ws; error = %d\n", pUtilityKey, status);
#endif
        goto error;
    }

    /*
     * Enumerate and parse each value into the PROGRAMCALL components.
     */
    for ( iValue = 0, pProg = *ppProgramCall; 
          iValue < cValues; 
          iValue++, pProg++ ) {

        ccTmpValueName = ccValueName;
        cbTmpValueData = cbValueData;
        if ( (status = RegEnumValue( Handle,
                                     iValue,
                                     pValueName,
                                     &ccTmpValueName,
                                     NULL,
                                     &dwType,
                                     (LPBYTE)pValueData,
                                     &cbTmpValueData )) != ERROR_SUCCESS ) {
#if DBG
            DbgPrint("RegQueryUtilityCommandList: Can't enumerate command (index = %d) for utility %ws; error = %d\n", iValue, pUtilityKey, status);
#endif

            goto error;
        }

        /*
         * If the data is not REG_MULTI_SZ, ignore it.
         */
        if ( dwType != REG_MULTI_SZ )
            goto CommandInError;

        /*
         * Allocate data storage for this command, then parse and assign 
         * to the PROGRAMCALL structure items.
         */
        if ( (pProg->pRegistryMultiString = LocalAlloc(LPTR, cbTmpValueData)) == NULL ) {

            status = GetLastError();
#if DBG
            DbgPrint("RegQueryUtilityCommandList: Can't allocate memory buffer for utility %ws; error = %d\n", pUtilityKey, status);
#endif
            goto error;
        }

        memcpy(pProg->pRegistryMultiString, pValueData, cbTmpValueData);
        pString = pProg->pRegistryMultiString;

        /*
         * Parse alias flag.
         */
        if ( !wcscmp(pString, L"1") )
            pProg->fAlias = TRUE;
        else if ( !wcscmp(pString, L"0") )
            pProg->fAlias = FALSE;
        else
            goto CommandInError;
        pString += (wcslen(pString) + 1);

        /*
         * Parse command length.
         */
        if ( *pString == L'\0' )
            goto CommandInError;
        ulCommandLen = wcstoul(pString, &pEndptr, 10);
        if ( *pEndptr != L'\0' )
            goto CommandInError;
        pProg->CommandLen = (USHORT)ulCommandLen;
        pString += (wcslen(pString) + 1);

        /*
         * Parse command string.
         */
        if ( *pString == L'\0' )
            goto CommandInError;
        pProg->Command = pString;
        pString += (wcslen(pString) + 1);

        /*
         * Parse program string.
         */
        if ( *pString == L'\0' )
            goto CommandInError;
        pProg->Program = pString;
        pString += (wcslen(pString) + 1);

        /*
         * Parse (optional) Args string.
         */
        if ( *pString != L'\0' )
            pProg->Args = pString;

        /*
         * Walk the command list to link this item in it's proper
         * sorted place.
         */
        if ( pProg == *ppProgramCall ) {

            pProg->pFirst = pProg;  // first item in the list

        } else for ( pProgPrev = pProgNext = (*ppProgramCall)->pFirst; ; ) {

            if ( (iCompare = _wcsicmp(pProg->Command, pProgNext->Command)) < 0 ) {

                pProg->pNext = pProgNext;       // point to next

                if ( pProgNext == (*ppProgramCall)->pFirst )
                    (*ppProgramCall)->pFirst = pProg;  // first item
                else
                    pProgPrev->pNext = pProg;   // link after previous

                break;

            } else if ( iCompare == 0 ) {

                goto CommandInError;    // duplicate command - ignore
            }

            if ( pProgNext->pNext == NULL ) {

                pProgNext->pNext = pProg;   // link at end of list
                break;

            } else {

                pProgPrev = pProgNext;
                pProgNext = pProgNext->pNext;
            }
        }

        continue;

CommandInError:
        /*
         * The command format is in error - ignore it.
         */
        if ( pProg->pRegistryMultiString )
            LocalFree(pProg->pRegistryMultiString);
        memset(pProg, 0, sizeof(PROGRAMCALL));
        pProg--;
    }

error:
    if ( Handle != NULL )
        RegCloseKey(Handle);

    if ( pValueName )
        LocalFree(pValueName);

    if ( pValueData )
        LocalFree(pValueData);

    if ( status != ERROR_SUCCESS ) {

        if ( *ppProgramCall ) {
            RegFreeUtilityCommandList(*ppProgramCall);
            *ppProgramCall = NULL;
        }
    }

    return( status );
}


/*******************************************************************************
 *
 *  RegFreeUtilityCommandList (UNICODE)
 *
 *    Free the specified array of PROGRAMCALL structures.
 *
 * ENTRY:
 *    pProgramCall (input)
 *       Points PROGRAMCALL array to free.
 *
 * EXIT:
 *      ERROR_SUCCESS if all goes well; error code if failure
 *
 ******************************************************************************/

LONG WINAPI
RegFreeUtilityCommandList(
    PPROGRAMCALL pProgramCall
    )
{
    PPROGRAMCALL pProg;
    LONG status = ERROR_SUCCESS;

    if ( pProgramCall ) {

        for ( pProg = pProgramCall->pFirst; pProg != NULL; pProg = pProg->pNext ) {

            if ( LocalFree( pProg->pRegistryMultiString ) != NULL ) {

                status = GetLastError();
#if DBG
                DbgPrint("RegFreeUtilityCommandList: Failed to free command list element for %ws; error = %d\n", pProg->Program, status);
#endif
            }
        }

        if ( LocalFree( pProgramCall ) != NULL ) {

            status = GetLastError();
#if DBG
            DbgPrint("RegFreeUtilityCommandList: Failed to free command list array; error = %d\n", status);
#endif
        }
    }

    return( status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\regapi\regcd.c ===
/*************************************************************************
*
* regcd.c
*
* Register APIs for CDs (connection drivers)
*
* Copyright (c) 1998 Microsoft Corporation
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <windows.h>

/* Added By SalimC */
#include <ksguid.h>
/**/
#include <ntddkbd.h>
#include <ntddmou.h>
#include <winstaw.h>
#include <regapi.h>


/*
 *  External Procedures defined here
 */
LONG WINAPI RegCdEnumerateA( HANDLE, PWDNAMEA, PULONG, PULONG, PCDNAMEA, PULONG );
LONG WINAPI RegCdEnumerateW( HANDLE, PWDNAMEW, PULONG, PULONG, PCDNAMEW, PULONG );
LONG WINAPI RegCdCreateA( HANDLE, PWDNAMEA, PCDNAMEA, BOOLEAN, PCDCONFIGA, ULONG );
LONG WINAPI RegCdCreateW( HANDLE, PWDNAMEW, PCDNAMEW, BOOLEAN, PCDCONFIGW, ULONG );
LONG WINAPI RegCdQueryA( HANDLE, PWDNAMEA, PCDNAMEA, PCDCONFIGA, ULONG, PULONG );
LONG WINAPI RegCdQueryW( HANDLE, PWDNAMEW, PCDNAMEW, PCDCONFIGW, ULONG, PULONG );
LONG WINAPI RegCdDeleteA( HANDLE, PWDNAMEA, PCDNAMEA );
LONG WINAPI RegCdDeleteW( HANDLE, PWDNAMEW, PCDNAMEW );

/*
 *  other internal Procedures used (not defined here)
 */
VOID CreateCd( HKEY, PCDCONFIG );
VOID QueryCd( HKEY, PCDCONFIG );
VOID UnicodeToAnsi( CHAR *, ULONG, WCHAR * );
VOID AnsiToUnicode( WCHAR *, ULONG, CHAR * );
VOID CdConfigU2A( PCDCONFIGA, PCDCONFIGW );
VOID CdConfigA2U( PCDCONFIGW, PCDCONFIGA );


/*******************************************************************************
 *
 *  RegCdEnumerateA (ANSI stub)
 *
 *     Returns a list of configured connection drivers in the registry.
 *
 * ENTRY:
 *
 *    see RegCdEnumerateW
 *
 * EXIT:
 *
 *    see RegCdEnumerateW, plus
 *
 *  ERROR_NOT_ENOUGH_MEMORY - the LocalAlloc failed
 *
 ******************************************************************************/

LONG WINAPI
RegCdEnumerateA( HANDLE hServer,
                 PWDNAMEA pWdName,
                 PULONG  pIndex,
                 PULONG  pEntries,
                 PCDNAMEA  pCdName,
                 PULONG  pByteCount )
{
    PCDNAMEW pBuffer = NULL, pCdNameW;
    WDNAMEW WdNameW;
    LONG Status;
    ULONG Count, ByteCountW = (*pByteCount << 1);

    /*
     * If the caller supplied a buffer and the length is not 0,
     * allocate a corresponding (*2) buffer for UNICODE strings.
     */
    if ( pCdName && ByteCountW ) {

        if ( !(pBuffer = LocalAlloc(0, ByteCountW)) )
            return ( ERROR_NOT_ENOUGH_MEMORY );
    }

    /*
     * Convert ANSI WdName to UNICODE.
     */
    AnsiToUnicode( WdNameW, sizeof(WDNAMEW), pWdName );

    /*
     * Enumerate connection drivers
     */
    pCdNameW = pBuffer;
    Status = RegCdEnumerateW( hServer,
                              WdNameW,
                              pIndex,
                              pEntries,
                              pCdNameW,
                              &ByteCountW );

    /*
     * Always /2 the resultant ByteCount (whether sucessful or not).
     */
    *pByteCount = (ByteCountW >> 1);

    /*
     * If the function completed sucessfully and caller
     * (and stub) defined a buffer to copy into, perform conversion
     * from UNICODE to ANSI.  Note: sucessful return may have copied
     * 0 items from registry (end of enumeration), denoted by *pEntries
     * == 0.
     */
    if ( ((Status == ERROR_SUCCESS) || (Status == ERROR_NO_MORE_ITEMS))
                                         && pCdNameW && pCdName ) {

        for ( Count = *pEntries; Count; Count-- ) {
            UnicodeToAnsi( pCdName, sizeof(CDNAMEA), pCdNameW );
            (char*)pCdName += sizeof(CDNAMEA);
            (char*)pCdNameW += sizeof(CDNAMEW);
        }
    }

    /*
     * If we defined a buffer, free it now, then return the status
     * of the Reg...EnumerateW function call.
     */
    if ( pBuffer )
        LocalFree(pBuffer);

    return ( Status );
}


/*******************************************************************************
 *
 *  RegCdEnumerateW (UNICODE)
 *
 *     Returns a list of configured connection drivers in the registry.
 *
 * ENTRY:
 *
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWdName (input)
 *       Points to the wdname to enumerate Cds for
 *    pIndex (input/output)
 *       Specifies the subkey index for the \Citrix\Wds\<wdname>\Cds subkeys
 *       in the registry.  Should be set to 0 for the initial call, and
 *       supplied again (as modified by this function) for multi-call
 *       enumeration.
 *    pEntries (input/output)
 *       Points to a variable specifying the number of entries requested.
 *       If the number requested is 0xFFFFFFFF, the function returns as
 *       many entries as possible. When the function finishes successfully,
 *       the variable pointed to by the pEntries parameter contains the
 *       number of entries actually read.
 *    pCdName (input)
 *       Points to the buffer to receive the enumeration results, which are
 *       returned as an array of CDNAMEW structures.  If this parameter is
 *       NULL, then no data will be copied, but just an enumeration count will
 *       be made.
 *    pByteCount (input/output)
 *       Points to a variable that specifies the size, in bytes, of the
 *       pCdName parameter. If the buffer is too small to receive even
 *       one entry, the function returns an error code (ERROR_OUTOFMEMORY)
 *       and this variable receives the required size of the buffer for a
 *       single subkey.  When the function finishes sucessfully, the variable
 *       pointed to by the pByteCount parameter contains the number of bytes
 *       actually stored in pCdName.
 *
 * EXIT:
 *
 *  "No Error" codes:
 *    ERROR_SUCCESS       - The enumeration completed as requested and there
 *                          are more CDS subkeys (CDNAMEs) to be
 *                          read.
 *    ERROR_NO_MORE_ITEMS - The enumeration completed as requested and there
 *                          are no more CDS subkeys (CDNAMEs) to
 *                          be read.
 *
 *  "Error" codes:
 *    ERROR_OUTOFMEMORY   - The pCdName buffer is too small for even one
 *                          entry.
 *    ERROR_CANTOPEN      - The Citrix\Cds key can't be opened.
 *
 ******************************************************************************/

LONG WINAPI
RegCdEnumerateW( HANDLE hServer,
                 PWDNAMEW pWdName,
                 PULONG  pIndex,
                 PULONG  pEntries,
                 PCDNAMEW pCdName,
                 PULONG  pByteCount )
{
    LONG Status;
    HKEY Handle;
    ULONG Count;
    ULONG i;
    WCHAR KeyString[256];

    /*
     *  Get the number of names to return
     */
    Count = pCdName ?
            min( *pByteCount / sizeof(CDNAME), *pEntries ) :
            (ULONG) -1;
    *pEntries = *pByteCount = 0;

    /*
     *  Make sure buffer is big enough for at least one name
     */
    if ( Count == 0 ) {
        *pByteCount = sizeof(CDNAME);
        return( ERROR_OUTOFMEMORY );
    }

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\Wds\<wdname>\Cds)
     */
    wcscpy( KeyString, WD_REG_NAME );
    wcscat( KeyString, L"\\" );
    wcscat( KeyString, pWdName );
    wcscat( KeyString, CD_REG_NAME );
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, KeyString, 0,
         KEY_ENUMERATE_SUB_KEYS, &Handle ) != ERROR_SUCCESS ) {
        return( ERROR_CANTOPEN );
    }

    /*
     *  Get list of connection drivers
     */
    for ( i = 0; i < Count; i++ ) {
        CDNAME CdName;

        if ( (Status = RegEnumKey(Handle, *pIndex, CdName,
                                    sizeof(CDNAME)/sizeof(TCHAR) )) != ERROR_SUCCESS )
            break;

        /*
         * If caller supplied a buffer, then copy the CdName
         * and increment the pointer and byte count.  Always increment the
         * entry count and index for the next iteration.
         */
        if ( pCdName ) {
            wcscpy( pCdName, CdName );
            (char*)pCdName += sizeof(CDNAME);
            *pByteCount += sizeof(CDNAME);
        }
        (*pEntries)++;
        (*pIndex)++;
    }

    /*
     *  Close registry
     */
    RegCloseKey( Handle );
    return( Status );
}


/*******************************************************************************
 *
 *  RegCdCreateA (ANSI stub)
 *
 *    Creates a new Cd in the registry or updates an existing entry.
 *      (See RegCdCreateW)
 *
 * ENTRY:
 *    see RegCdCreateW
 * EXIT:
 *    see RegCdCreateW
 *
 ******************************************************************************/

LONG WINAPI
RegCdCreateA( HANDLE hServer,
              PWDNAMEA pWdName,
              PCDNAMEA pCdName,
              BOOLEAN bCreate,
              PCDCONFIGA pCdConfig,
              ULONG CdConfigLength )
{
    WDNAMEW WdNameW;
    CDNAMEW CdNameW;
    CDCONFIGW CdConfigW;

    /*
     * Validate target buffer size.
     */
    if ( CdConfigLength < sizeof(CDCONFIGA) )
        return( ERROR_INSUFFICIENT_BUFFER );

    /*
     * Convert ANSI WdName and CdName to UNICODE.
     */
    AnsiToUnicode( WdNameW, sizeof(WDNAMEW), pWdName );
    AnsiToUnicode( CdNameW, sizeof(CDNAMEW), pCdName );

    /*
     * Copy CDCONFIGA elements to CDCONFIGW elements.
     */
    CdConfigA2U( &CdConfigW, pCdConfig );

    /*
     * Call RegCdCreateW & return it's status.
     */
    return ( RegCdCreateW( hServer,
                           WdNameW,
                           CdNameW,
                           bCreate,
                           &CdConfigW,
                           sizeof(CdConfigW)) );
}


/*******************************************************************************
 *
 *  RegCdCreateW (UNICODE)
 *
 *    Creates a new Cd in the registry or updates an existing entry.  The
 *    state of the bCreate flag determines whether this function will expect
 *    to create a new Cd entry (bCreate == TRUE) or expects to update an
 *    existing entry (bCreate == FALSE).
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWdName (input)
 *       Points to the wdname to create Cd for
 *    pCdName (input)
 *       Name of a new or exisiting connection driver in the registry.
 *    bCreate (input)
 *       TRUE if this is a creation of a new Cd
 *       FALSE if this is an update to an existing Cd
 *    pCdConfig (input)
 *       Pointer to a CDCONFIGW structure containing configuration
 *       information for the specified connection driver name.
 *    CdConfigLength (input)
 *       Specifies the length in bytes of the pCdConfig buffer.
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 *    ERROR_INSUFFICIENT_BUFFER - pCdConfig buffer too small
 *    ERROR_FILE_NOT_FOUND - can't open ...\Citrix\Wds\<wdname>\Cds key
 *    ERROR_CANNOT_MAKE - can't create Cd key (registry problem)
 *    ERROR_ALREADY_EXISTS - create; but Cd key already present
 *    ERROR_CANTOPEN - update; but Cd key could not be opened
 *
 ******************************************************************************/

LONG WINAPI
RegCdCreateW( HANDLE hServer,
              PWDNAMEW pWdName,
              PCDNAMEW pCdName,
              BOOLEAN bCreate,
              PCDCONFIGW pCdConfig,
              ULONG CdConfigLength )
{
    HKEY Handle;
    HKEY Handle1;
    DWORD Disp;
    WCHAR KeyString[256];

    /*
     *  Validate length of buffer
     */
    if ( CdConfigLength < sizeof(CDCONFIG) )
        return( ERROR_INSUFFICIENT_BUFFER );

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\Wds\<wdname>\Cds)
     */
    wcscpy( KeyString, WD_REG_NAME );
    wcscat( KeyString, L"\\" );
    wcscat( KeyString, pWdName );
    wcscat( KeyString, CD_REG_NAME );
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, KeyString, 0,
         KEY_ALL_ACCESS, &Handle1 ) != ERROR_SUCCESS ) {
        return( ERROR_FILE_NOT_FOUND );
    }

    if ( bCreate ) {

        /*
         *  Create requested: create a registry key for the specified
         *  Cd name.
         */
        if ( RegCreateKeyEx( Handle1, pCdName, 0, NULL,
                             REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                             NULL, &Handle, &Disp ) != ERROR_SUCCESS ) {
            RegCloseKey( Handle1 );
            return( ERROR_CANNOT_MAKE );
        }

        /*
         * If an existing key was returned instead of a new one being
         * created, return error (don't update).
         */
        if ( Disp != REG_CREATED_NEW_KEY ) {
            RegCloseKey( Handle1 );
            RegCloseKey( Handle );
            return( ERROR_ALREADY_EXISTS );
        }
    } else {

        /*
         *  Update requested: open the registry key for the specified
         *  Cd name.
         */
        if ( RegOpenKeyEx( Handle1, pCdName, 0, KEY_ALL_ACCESS,
                           &Handle ) != ERROR_SUCCESS ) {
            RegCloseKey( Handle1 );
            return( ERROR_CANTOPEN );
        }
    }

    RegCloseKey( Handle1 );

    /*
     *  Save CDCONFIG Structure
     */
    CreateCd( Handle, pCdConfig );

    /*
     *  Close registry handle
     */
    RegCloseKey( Handle );

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegCdQueryA (ANSI stub)
 *
 *    Query configuration information of a connection driver in the registry.
 *
 * ENTRY:
 *    see RegCdQueryW
 * EXIT:
 *    see RegCdQueryW
 *
 ******************************************************************************/
LONG WINAPI
RegCdQueryA( HANDLE hServer,
             PWDNAMEA pWdName,
             PCDNAMEA pCdName,
             PCDCONFIGA pCdConfig,
             ULONG CdConfigLength,
             PULONG pReturnLength )
{
    WDNAMEW WdNameW;
    CDNAMEW CdNameW;
    CDCONFIGW CdConfigW;
    LONG Status;
    ULONG ReturnLengthW;

    /*
     * Validate length and zero-initialize the destination
     * PDCONFIG3A structure.
     */
    if ( CdConfigLength < sizeof(CDCONFIGA) )
        return( ERROR_INSUFFICIENT_BUFFER );
    memset(pCdConfig, 0, CdConfigLength);

    /*
     * Convert ANSI WdName and CdName to UNICODE.
     */
    AnsiToUnicode(WdNameW, sizeof(WDNAMEW), pWdName);
    AnsiToUnicode(CdNameW, sizeof(CDNAMEW), pCdName);

    /*
     * Query Cd.
     */
    if ( (Status = RegCdQueryW( hServer,
                                WdNameW,
                                CdNameW,
                                &CdConfigW,
                                sizeof(CDCONFIGW),
                                &ReturnLengthW)) != ERROR_SUCCESS )
        return ( Status );

    /*
     * Copy CDCONFIGW elements to CDCONFIGA elements.
     */
    CdConfigU2A( pCdConfig, &CdConfigW );

    *pReturnLength = sizeof(CDCONFIGA);

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegCdQueryW (UNICODE)
 *
 *    Query configuration information of a connection driver in the registry.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWdName (input)
 *       Points to the wdname to query Cd for
 *    pCdName (input)
 *       Name of an exisiting connection driver in the registry.
 *    pCdConfig (input)
 *       Pointer to a CDCONFIGW structure that will receive
 *       information about the specified connection driver name.
 *    CdConfigLength (input)
 *       Specifies the length in bytes of the pCdConfig buffer.
 *    pReturnLength (output)
 *       Receives the number of bytes placed in the pCdConfig buffer.
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 ******************************************************************************/

LONG WINAPI
RegCdQueryW( HANDLE hServer,
             PWDNAMEW pWdName,
             PCDNAMEW pCdName,
             PCDCONFIGW pCdConfig,
             ULONG CdConfigLength,
             PULONG pReturnLength )
{
    HKEY Handle;
    HKEY Handle1;
    WCHAR KeyString[256];

    /*
     * Validate length and zero-initialize the destination
     * PDCONFIG3A structure.
     */
    if ( CdConfigLength < sizeof(CDCONFIG) )
        return( ERROR_INSUFFICIENT_BUFFER );
    memset(pCdConfig, 0, CdConfigLength);

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\Wds\<wdname>\Cds)
     */
    wcscpy( KeyString, WD_REG_NAME );
    wcscat( KeyString, L"\\" );
    wcscat( KeyString, pWdName );
    wcscat( KeyString, CD_REG_NAME );
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, KeyString, 0,
         KEY_READ, &Handle1 ) != ERROR_SUCCESS ) {
        return( ERROR_FILE_NOT_FOUND );
    }

    /*
     *  Now try to open the specified Cd
     */
    if ( RegOpenKeyEx( Handle1, pCdName, 0,
         KEY_READ, &Handle ) != ERROR_SUCCESS ) {
        RegCloseKey( Handle1 );
        return( ERROR_FILE_NOT_FOUND );
    }
    RegCloseKey( Handle1 );

    /*
     *  Query CDCONFIG Structure
     */
    QueryCd( Handle, pCdConfig );

    /*
     *  Close registry
     */
    RegCloseKey( Handle );

    *pReturnLength = sizeof(CDCONFIG);

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegCdDeleteA (ANSI stub)
 *
 *    Deletes a connection driver from the registry.
 *
 * ENTRY:
 *
 *    see RegCdDeleteW
 *
 * EXIT:
 *
 *    see RegCdDeleteW
 *
 ******************************************************************************/
LONG WINAPI
RegCdDeleteA( HANDLE hServer,
              PWDNAMEA pWdName,
              PCDNAMEA pCdName )
{
    WDNAMEW WdNameW;
    CDNAMEW CdNameW;

    AnsiToUnicode( WdNameW, sizeof(WdNameW), pWdName);
    AnsiToUnicode( CdNameW, sizeof(CdNameW), pCdName);

    return ( RegCdDeleteW ( hServer, WdNameW, CdNameW ) );
}


/*******************************************************************************
 *
 *  RegCdDeleteW (UNICODE)
 *
 *    Deletes a connection driver from the registry.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWdName (input)
 *       Points to the wdname to delete Cd from
 *    pCdName (input)
 *       Name of a connection driver to delete from the registry.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 ******************************************************************************/

LONG WINAPI
RegCdDeleteW( HANDLE hServer,
              PWDNAMEW pWdName,
              PCDNAMEW pCdName )
{
    LONG Status;
    HKEY Handle;
    HKEY Handle1;
    WCHAR KeyString[256];

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\Wds\<wdname>\Cds)
     */
    wcscpy( KeyString, WD_REG_NAME );
    wcscat( KeyString, L"\\" );
    wcscat( KeyString, pWdName );
    wcscat( KeyString, CD_REG_NAME );
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, CD_REG_NAME, 0,
         KEY_READ, &Handle ) != ERROR_SUCCESS ) {
        return( ERROR_FILE_NOT_FOUND );
    }

    /*
     *  Now try to open the specified Cd
     */
    if ( RegOpenKeyEx( Handle, pCdName, 0,
         KEY_READ, &Handle1 ) != ERROR_SUCCESS ) {
        RegCloseKey( Handle );
        return( ERROR_FILE_NOT_FOUND );
    }

    /*
     *  Close the Cd key handle, delete the Cd,
     *  and close the parent handle
     */
    RegCloseKey( Handle1 );
    Status = RegDeleteKey( Handle, pCdName );
    RegCloseKey( Handle );

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\regapi\regpd.c ===
/*************************************************************************
*
* regpd.c
*
* Register APIs for Tds and Pds (transport and protocol drivers)
*
* Copyright (c) 1998 Microsoft Corporation
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <windows.h>

#include <ksguid.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <winstaw.h>
#include <regapi.h>


/*
 *  External Procedures defined here
 */


HANDLE WINAPI  RegOpenServerW ( LPWSTR pServerName );
HANDLE WINAPI  RegOpenServerA ( LPSTR pServerName );
LONG WINAPI RegCloseServer ( HANDLE hServer );
LONG WINAPI RegPdEnumerateW( HANDLE, PWDNAMEW, BOOLEAN, PULONG, PULONG, PPDNAMEW, PULONG );
LONG WINAPI RegPdEnumerateA( HANDLE, PWDNAMEA, BOOLEAN, PULONG, PULONG, PPDNAMEA, PULONG );
LONG WINAPI RegPdCreateW( HANDLE, PWDNAMEW, BOOLEAN, PPDNAMEW, BOOLEAN, PPDCONFIG3W, ULONG );
LONG WINAPI RegPdCreateA( HANDLE, PWDNAMEA, BOOLEAN, PPDNAMEA, BOOLEAN, PPDCONFIG3A, ULONG );
LONG WINAPI RegPdQueryW( HANDLE, PWDNAMEW, BOOLEAN, PPDNAMEW, PPDCONFIG3W, ULONG, PULONG );
LONG WINAPI RegPdQueryA( HANDLE, PWDNAMEA, BOOLEAN, PPDNAMEA, PPDCONFIG3A, ULONG, PULONG );
LONG WINAPI RegPdDeleteW( HANDLE, PWDNAMEW, BOOLEAN, PPDNAMEW );
LONG WINAPI RegPdDeleteA( HANDLE, PWDNAMEA, BOOLEAN, PPDNAMEA );

/*
 *  other internal Procedures used (not defined here)
 */
VOID CreatePdConfig3( HKEY, PPDCONFIG3, ULONG );
VOID QueryPdConfig3( HKEY, PPDCONFIG3, ULONG );
VOID UnicodeToAnsi( CHAR *, ULONG, WCHAR * );
VOID AnsiToUnicode( WCHAR *, ULONG, CHAR * );
VOID PdConfigU2A( PPDCONFIGA, PPDCONFIGW );
VOID PdConfigA2U( PPDCONFIGW, PPDCONFIGA );
VOID PdConfig3U2A( PPDCONFIG3A, PPDCONFIG3W );
VOID PdConfig3A2U( PPDCONFIG3W, PPDCONFIG3A );
VOID PdParamsU2A( PPDPARAMSA, PPDPARAMSW );
VOID PdParamsA2U( PPDPARAMSW, PPDPARAMSA );
VOID AsyncConfigU2A ( PASYNCCONFIGA, PASYNCCONFIGW );
VOID AsyncConfigA2U ( PASYNCCONFIGW, PASYNCCONFIGA );


/*****************************************************************************
 *
 *  RegOpenServerA
 *
 *
 * ENTRY:
 *   Machine (input)
 *     Name of WinFrame computer to connect to
 *
 * EXIT:
 *   handle to a server's Registry (or NULL on error)
 *
 ****************************************************************************/

HANDLE WINAPI
RegOpenServerA(
    LPSTR pServerName
    )
{
    HKEY  hServer;
    ULONG NameLength;
    PWCHAR pServerNameW = NULL;

    if( pServerName == NULL ) {
        return( (HANDLE)HKEY_LOCAL_MACHINE );
    }

    NameLength = strlen( pServerName ) + 1;

    pServerNameW = LocalAlloc( 0, NameLength * sizeof(WCHAR) );
    if( pServerNameW == NULL ) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return( NULL );
    }

    AnsiToUnicode( pServerNameW, NameLength*sizeof(WCHAR), pServerName );

    hServer = RegOpenServerW( pServerNameW );

    LocalFree( pServerNameW );

    return( (HANDLE) hServer );
}

/*****************************************************************************
 *
 *  RegOpenServerW
 *
 * NULL for machine name means local system.
 *
 * ENTRY:
 *   Machine (input)
 *     Name of WinFrame computer to connect to
 *
 * EXIT:
 *   handle to server's Registry (or NULL on error)
 *
 ****************************************************************************/

 HANDLE WINAPI
 RegOpenServerW( LPWSTR pServerName ){

    HKEY hKey;

    if( pServerName == NULL )
       return( HKEY_LOCAL_MACHINE );

    else {
       if( RegConnectRegistry( pServerName, HKEY_LOCAL_MACHINE, &hKey ) != ERROR_SUCCESS ){
            return( NULL );
       }
    }

    return( hKey );
 }

/*****************************************************************************
 *
 *  RegCloseServer
 *
 *   Close a connection to a Server Registry.
 *
 * ENTRY:
 *   hServer (input)
 *     Handle to close
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

LONG WINAPI
RegCloseServer( HANDLE hServer )
{
   return( RegCloseKey( (HKEY)hServer ) );
}


/*******************************************************************************
 *
 *  RegPdEnumerateA (ANSI stub)
 *
 *     Returns a list of configured Pds in the registry.
 *
 * ENTRY:
 *
 *    see RegPdEnumerateW
 *
 * EXIT:
 *
 *    see RegPdEnumerateW, plus
 *
 *  ERROR_NOT_ENOUGH_MEMORY - the LocalAlloc failed
 *
 ******************************************************************************/

LONG WINAPI
RegPdEnumerateA( HANDLE hServer,
                 PWDNAMEA pWdName,
                 BOOLEAN bTd,
                 PULONG pIndex,
                 PULONG pEntries,
                 PPDNAMEA pPdName,
                 PULONG pByteCount )
{
    WDNAMEW WdNameW;
    PPDNAMEW pBuffer = NULL, pPdNameW;
    LONG Status;
    ULONG Count, ByteCountW = (*pByteCount << 1);

    /*
     * If the caller supplied a buffer and the length is not 0,
     * allocate a corresponding (*2) buffer for UNICODE strings.
     */
    if ( pPdName && ByteCountW ) {

        if ( !(pBuffer = LocalAlloc(0, ByteCountW)) )
            return ( ERROR_NOT_ENOUGH_MEMORY );
    }

    /*
     * Convert ANSI WdName to UNICODE.
     */
    AnsiToUnicode( WdNameW, sizeof(WDNAMEW), pWdName );

    /*
     * Enumerate Pds
     */
    pPdNameW = pBuffer;
    Status = RegPdEnumerateW( hServer,
                              WdNameW,
                              bTd,
                              pIndex,
                              pEntries,
                              pPdNameW,
                              &ByteCountW );

    /*
     * Always /2 the resultant ByteCount (whether sucessful or not).
     */
    *pByteCount = (ByteCountW >> 1);

    /*
     * If the function completed sucessfully and caller
     * (and stub) defined a buffer to copy into, perform conversion
     * from UNICODE to ANSI.  Note: sucessful return may have copied
     * 0 items from registry (end of enumeration), denoted by *pEntries
     * == 0.
     */
    if ( ((Status == ERROR_SUCCESS) || (Status == ERROR_NO_MORE_ITEMS))
                                         && pPdNameW && pPdName ) {

        for ( Count = *pEntries; Count; Count-- ) {
            UnicodeToAnsi( pPdName, sizeof(PDNAMEA), pPdNameW );
            (char*)pPdName += sizeof(PDNAMEA);
            (char*)pPdNameW += sizeof(PDNAMEW);
        }
    }

    /*
     * If we defined a buffer, free it now, then return the status
     * of the Reg...EnumerateW function call.
     */
    if ( pBuffer )
        LocalFree(pBuffer);

    return ( Status );
}


/*******************************************************************************
 *
 *  RegPdEnumerateW (UNICODE)
 *
 *     Returns a list of configured Pds in the registry.
 *
 * ENTRY:
 *
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWdName (input)
 *       Points to the wdname to enumerate pds for
 *    bTd (input)
 *       TRUE to enumerate Transport Drivers (Tds),
 *       FALSE to enumerate Protocol Drivers (Pds)
 *    pIndex (input/output)
 *       Specifies the subkey index for the \Citrix\Wds\<wdname>\<Pd or Td>
 *       subkeys in the registry.  Should be set to 0 for the initial call,
 *       and supplied again (as modified by this function) for multi-call
 *       enumeration.
 *    pEntries (input/output)
 *       Points to a variable specifying the number of entries requested.
 *       If the number requested is 0xFFFFFFFF, the function returns as
 *       many entries as possible. When the function finishes successfully,
 *       the variable pointed to by the pEntries parameter contains the
 *       number of entries actually read.
 *    pPdName (input)
 *       Points to the buffer to receive the enumeration results, which are
 *       returned as an array of PDNAME structures.  If this parameter is
 *       NULL, then no data will be copied, but just an enumeration count will
 *       be made.
 *    pByteCount (input/output)
 *       Points to a variable that specifies the size, in bytes, of the
 *       pPdName parameter. If the buffer is too small to receive even
 *       one entry, the function returns an error code (ERROR_OUTOFMEMORY)
 *       and this variable receives the required size of the buffer for a
 *       single subkey.  When the function finishes sucessfully, the variable
 *       pointed to by the pByteCount parameter contains the number of bytes
 *       actually stored in pPdName.
 *
 * EXIT:
 *
 *  "No Error" codes:
 *    ERROR_SUCCESS       - The enumeration completed as requested and there
 *                          are more Pds subkeys (PDNAMEs) to be read.
 *    ERROR_NO_MORE_ITEMS - The enumeration completed as requested and there
 *                          are no more Pds subkeys (PDNAMEs) to be read.
 *
 *  "Error" codes:
 *    ERROR_OUTOFMEMORY   - The pPdName buffer is too small for even one entry.
 *    ERROR_CANTOPEN      - The \Citrix\Wds\<wdname>\<Pd or Td> key can't be opened.
 *
 ******************************************************************************/

LONG WINAPI
RegPdEnumerateW( HANDLE hServer,
                 PWDNAMEW pWdName,
                 BOOLEAN bTd,
                 PULONG pIndex,
                 PULONG pEntries,
                 PPDNAMEW pPdName,
                 PULONG pByteCount )
{
    LONG Status;
    HKEY Handle;
    ULONG Count;
    ULONG i;
    HKEY hkey_local_machine;
    WCHAR KeyString[256];

    if( hServer == NULL )
       hkey_local_machine = HKEY_LOCAL_MACHINE;
    else
       hkey_local_machine = hServer;



    /*
     *  Get the number of names to return
     */
    Count = pPdName ?
            min( *pByteCount / sizeof(PDNAME), *pEntries ) :
            (ULONG) -1;
    *pEntries = *pByteCount = 0;

    /*
     *  Make sure buffer is big enough for at least one name
     */
    if ( Count == 0 ) {
        *pByteCount = sizeof(PDNAME);
        return( ERROR_OUTOFMEMORY );
    }

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\Wds\<wdname>\<Pd or Td>)
     */
    wcscpy( KeyString, WD_REG_NAME );
    wcscat( KeyString, L"\\" );
    wcscat( KeyString, pWdName );
    wcscat( KeyString, bTd ? TD_REG_NAME : PD_REG_NAME );
    if ( RegOpenKeyEx( hkey_local_machine, KeyString, 0,
         KEY_ENUMERATE_SUB_KEYS, &Handle ) != ERROR_SUCCESS ) {
        return( ERROR_CANTOPEN );
    }

    /*
     *  Get list of Tds or Pds
     */
    for ( i = 0; i < Count; i++ ) {
        PDNAME PdName;

        if ( (Status = RegEnumKey(Handle, *pIndex, PdName,
                                    sizeof(PDNAME)/sizeof(TCHAR) )) != ERROR_SUCCESS )
            break;

        /*
         * If caller supplied a buffer, then copy the PdName
         * and increment the pointer and byte count.  Always increment the
         * entry count and index for the next iteration.
         */
        if ( pPdName ) {
            wcscpy( pPdName, PdName );
            (char*)pPdName += sizeof(PDNAME);
            *pByteCount += sizeof(PDNAME);
        }
        (*pEntries)++;
        (*pIndex)++;
    }

    /*
     *  Close registry
     */
    RegCloseKey( Handle );
    return( Status );
}


/*******************************************************************************
 *
 *  RegPdCreateA (ANSI stub)
 *
 *    Creates a new Pd in the registry or updates an existing entry.
 *      (See RegPdCreateW)
 *
 * ENTRY:
 *
 *    see RegPdCreateW
 *
 * EXIT:
 *
 *    see RegPdCreateW
 *
 ******************************************************************************/

LONG WINAPI
RegPdCreateA( HANDLE hServer,
              PWDNAMEA pWdName,
              BOOLEAN bTd,
              PPDNAMEA pPdName,
              BOOLEAN bCreate,
              PPDCONFIG3A pPdConfig,
              ULONG PdConfigLength )
{
    PDNAMEW PdNameW;
    WDNAMEW WdNameW;
    PDCONFIG3W PdConfig3W;

    /*
     * Validate target buffer size.
     */
    if ( PdConfigLength < sizeof(PDCONFIG3A) )
        return( ERROR_INSUFFICIENT_BUFFER );

    /*
     * Convert ANSI WdName and PdName to UNICODE.
     */
    AnsiToUnicode( WdNameW, sizeof(WDNAMEW), pWdName );
    AnsiToUnicode( PdNameW, sizeof(PDNAMEW), pPdName );

    /*
     * Copy PDCONFIG3A elements to PDCONFIG3W elements.
     */
    PdConfig3A2U( &PdConfig3W, pPdConfig );

    /*
     * Call RegPdCreateW & return it's status.
     */
    return ( RegPdCreateW( hServer,
                           WdNameW,
                           bTd,
                           PdNameW,
                           bCreate,
                           &PdConfig3W,
                           sizeof(PdConfig3W)) );
}


/*******************************************************************************
 *
 *  RegPdCreateW (UNICODE)
 *
 *    Creates a new Pd in the registry or updates an existing entry.  The
 *    state of the bCreate flag determines whether this function will expect
 *    to create a new Pd entry (bCreate == TRUE) or expects to update an
 *    existing entry (bCreate == FALSE).
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWdName (input)
 *       Points to the wdname to create pd for
 *    bTd (input)
 *       TRUE to create a Transport Driver (Td),
 *       FALSE to create a Protocol Driver (Pd)
 *    pPdName (input)
 *       Name of a new or exisiting Pd in the registry.
 *    bCreate (input)
 *       TRUE if this is a creation of a new Pd
 *       FALSE if this is an update to an existing Pd
 *    pPdConfig (input)
 *       Pointer to a PDCONFIG3 structure containing configuration
 *       information for the specified Pd name.
 *    PdConfigLength (input)
 *       Specifies the length in bytes of the pPdConfig buffer.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 *    ERROR_INSUFFICIENT_BUFFER - pPdConfig buffer too small
 *    ERROR_FILE_NOT_FOUND - can't open ...\Citrix\Wds\<wdname>\<Pd or Td> key
 *    ERROR_CANNOT_MAKE - can't create Pd key (registry problem)
 *    ERROR_ALREADY_EXISTS - create; but Pd key was already present
 *    ERROR_CANTOPEN - update; but Pd key could not be opened
 *
 ******************************************************************************/

LONG WINAPI
RegPdCreateW( HANDLE hServer,
              PWDNAMEW pWdName,
              BOOLEAN bTd,
              PPDNAMEW pPdName,
              BOOLEAN bCreate,
              PPDCONFIG3W pPdConfig,
              ULONG PdConfigLength )
{
    HKEY Handle;
    HKEY Handle1;
    DWORD Disp;
    HKEY hkey_local_machine;
    WCHAR KeyString[256];

    if( hServer == NULL )
       hkey_local_machine = HKEY_LOCAL_MACHINE;
    else
       hkey_local_machine = hServer;


    /*
     *  Validate length of buffer
     */
    if ( PdConfigLength < sizeof(PDCONFIG3) )
        return( ERROR_INSUFFICIENT_BUFFER );

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\Wds\<wdname>\<Pd or Td>)
     */
    wcscpy( KeyString, WD_REG_NAME );
    wcscat( KeyString, L"\\" );
    wcscat( KeyString, pWdName );
    wcscat( KeyString, bTd ? TD_REG_NAME : PD_REG_NAME );
    if ( RegOpenKeyEx( hkey_local_machine, KeyString, 0,
         KEY_ALL_ACCESS, &Handle1 ) != ERROR_SUCCESS ) {
        return( ERROR_FILE_NOT_FOUND );
    }

    if ( bCreate ) {

        /*
         *  Create requested: create a registry key for the specified
         *  Pd name.
         */
        if ( RegCreateKeyEx( Handle1, pPdName, 0, NULL,
                             REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                             NULL, &Handle, &Disp ) != ERROR_SUCCESS ) {
            RegCloseKey( Handle1 );
            return( ERROR_CANNOT_MAKE );
        }

        /*
         * If an existing key was returned instead of a new one being
         * created, return error (don't update).
         */
        if ( Disp != REG_CREATED_NEW_KEY ) {
            RegCloseKey( Handle1 );
            RegCloseKey( Handle );
            return( ERROR_ALREADY_EXISTS );
        }
    } else {

        /*
         *  Update requested: open the registry key for the specified
         *  Pd name.
         */
        if ( RegOpenKeyEx( Handle1, pPdName, 0, KEY_ALL_ACCESS,
                           &Handle ) != ERROR_SUCCESS ) {
            RegCloseKey( Handle1 );
            return( ERROR_CANTOPEN );
        }
    }

    RegCloseKey( Handle1 );

    /*
     *  Save Pd information
     */
    CreatePdConfig3( Handle, pPdConfig, 0 );

    /*
     *  Close registry handle
     */
    RegCloseKey( Handle );

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegPdQueryA (ANSI stub)
 *
 *    Query configuration information of a Pd in the registry.
 *
 * ENTRY:
 *
 *    see RegPdQueryW
 *
 * EXIT:
 *
 *    see RegPdQueryW
 *
 ******************************************************************************/

LONG WINAPI
RegPdQueryA( HANDLE hServer,
             PWDNAMEA pWdName,
             BOOLEAN bTd,
             PPDNAMEA pPdName,
             PPDCONFIG3A pPdConfig,
             ULONG PdConfigLength,
             PULONG pReturnLength )
{
    PDNAMEW PdNameW;
    WDNAMEW WdNameW;
    PDCONFIG3W PdConfig3W;
    LONG Status;
    ULONG ReturnLengthW;

    /*
     * Validate length and zero-initialize the destination
     * PDCONFIG3A structure.
     */
    if ( PdConfigLength < sizeof(PDCONFIG3A) )
        return( ERROR_INSUFFICIENT_BUFFER );
    memset(pPdConfig, 0, PdConfigLength);

    /*
     * Convert ANSI WdName and PdName to UNICODE.
     */
    AnsiToUnicode(WdNameW, sizeof(WDNAMEW), pWdName);
    AnsiToUnicode(PdNameW, sizeof(PDNAMEW), pPdName);

    /*
     * Query Pd.
     */
    if ( (Status = RegPdQueryW( hServer,
                                WdNameW,
                                bTd,
                                PdNameW,
                                &PdConfig3W,
                                sizeof(PDCONFIG3W),
                                &ReturnLengthW)) != ERROR_SUCCESS )
        return ( Status );

    /*
     * Copy PDCONFIG3W elements to PDCONFIG3A elements.
     */
    PdConfig3U2A( pPdConfig, &PdConfig3W );

    *pReturnLength = sizeof(PDCONFIG3A);

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegPdQueryW (UNICODE)
 *
 *    Query configuration information of a Pd in the registry.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWdName (input)
 *       Points to the wdname to query pd for
 *    bTd (input)
 *       TRUE to query a Transport Driver (Td),
 *       FALSE to query a Protocol Driver (Pd)
 *    pPdName (input)
 *       Name of an exisiting Pd in the registry.
 *    pPdConfig (input)
 *       Pointer to a PDCONFIG3 structure that will receive
 *       information about the specified Pd name.
 *    PdConfigLength (input)
 *       Specifies the length in bytes of the pPdConfig buffer.
 *    pReturnLength (output)
 *       Receives the number of bytes placed in the pPdConfig buffer.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 ******************************************************************************/

LONG WINAPI
RegPdQueryW( HANDLE hServer,
             PWDNAMEW pWdName,
             BOOLEAN bTd,
             PPDNAMEW pPdName,
             PPDCONFIG3W pPdConfig,
             ULONG PdConfigLength,
             PULONG pReturnLength )
{
    HKEY Handle;
    HKEY Handle1;
    HKEY hkey_local_machine;
    WCHAR KeyString[256];

    if( hServer == NULL )
       hkey_local_machine = HKEY_LOCAL_MACHINE;
    else
       hkey_local_machine = hServer;


    /*
     * Validate length and zero-initialize the destination
     * PDCONFIG3A structure.
     */
    if ( PdConfigLength < sizeof(PDCONFIG3) )
        return( ERROR_INSUFFICIENT_BUFFER );
    memset(pPdConfig, 0, PdConfigLength);

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\Wds\<wdname>\<Pd or Td>)
     */
    wcscpy( KeyString, WD_REG_NAME );
    wcscat( KeyString, L"\\" );
    wcscat( KeyString, pWdName );
    wcscat( KeyString, bTd ? TD_REG_NAME : PD_REG_NAME );
    if ( RegOpenKeyEx( hkey_local_machine, KeyString, 0,
         KEY_READ, &Handle1 ) != ERROR_SUCCESS ) {
        return( ERROR_FILE_NOT_FOUND );
    }

    /*
     *  Now try to open the specified Pd
     */
    if ( RegOpenKeyEx( Handle1, pPdName, 0,
         KEY_READ, &Handle ) != ERROR_SUCCESS ) {
        RegCloseKey( Handle1 );
        return( ERROR_FILE_NOT_FOUND );
    }
    RegCloseKey( Handle1 );

    /*
     *  Query PDCONFIG3 Structure
     */
    QueryPdConfig3( Handle, pPdConfig, 0 );

    /*
     *  Close registry
     */
    RegCloseKey( Handle );

    *pReturnLength = sizeof(PDCONFIG3);

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegPdDeleteA (ANSI stub)
 *
 *    Deletes a Pd from the registry.
 *
 * ENTRY:
 *
 *    see RegPdDeleteW
 *
 * EXIT:
 *
 *    see RegPdDeleteW
 *
 ******************************************************************************/

LONG WINAPI
RegPdDeleteA( HANDLE hServer,
              PWDNAMEA pWdName,
              BOOLEAN bTd,
              PPDNAMEA pPdName )
{
    WDNAMEW WdNameW;
    PDNAMEW PdNameW;

    AnsiToUnicode( WdNameW, sizeof(WdNameW), pWdName );
    AnsiToUnicode( PdNameW, sizeof(PdNameW), pPdName );

    return ( RegPdDeleteW ( hServer, WdNameW, bTd, PdNameW ) );
}


/*******************************************************************************
 *
 *  RegPdDeleteW (UNICODE)
 *
 *    Deletes a Pd from the registry.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWdName (input)
 *       Points to the wdname to delete pd from
 *    bTd (input)
 *       TRUE to delete a Transport Driver (Td),
 *       FALSE to delete a Protocol Driver (Pd)
 *    pPdName (input)
 *       Name of a Pd to delete from the registry.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 ******************************************************************************/

LONG WINAPI
RegPdDeleteW( HANDLE hServer,
              PWDNAMEW pWdName,
              BOOLEAN bTd,
              PPDNAMEW pPdName )
{
    LONG Status;
    HKEY Handle;
    HKEY Handle1;
    HKEY hkey_local_machine;
    WCHAR KeyString[256];

    if( hServer == NULL )
       hkey_local_machine = HKEY_LOCAL_MACHINE;
    else
       hkey_local_machine = hServer;

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\Wds\<wdname>\<Pd or Td>)
     */
    wcscpy( KeyString, WD_REG_NAME );
    wcscat( KeyString, L"\\" );
    wcscat( KeyString, pWdName );
    wcscat( KeyString, bTd ? TD_REG_NAME : PD_REG_NAME );
    if ( RegOpenKeyEx( hkey_local_machine, KeyString, 0,
         KEY_READ, &Handle ) != ERROR_SUCCESS ) {
        return( ERROR_FILE_NOT_FOUND );
    }

    /*
     *  Now try to open the specified Pd
     */
    if ( RegOpenKeyEx( Handle, pPdName, 0,
         KEY_READ, &Handle1 ) != ERROR_SUCCESS ) {
        RegCloseKey( Handle );
        return( ERROR_FILE_NOT_FOUND );
    }

    /*
     *  Close the Pd key handle, delete the Pd,
     *  and close the parent handle.
     */
    RegCloseKey( Handle1 );
    Status = RegDeleteKey( Handle, pPdName );
    RegCloseKey( Handle );

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\regapi\domname.c ===
/*************************************************************************
*
* domname.c
*
* Get domain name given PDC's server name.
*
* This was a ripoff of NetpGetDomainNameEx.
*
* Copyright (c) 1998 Microsoft Corporation
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <nt.h>                 // NT definitions (temporary)
#include <ntrtl.h>              // NT Rtl structure definitions (temporary)
#include <ntlsa.h>

#include <windef.h>             // Win32 type definitions

#include <lmcons.h>             // LAN Manager common definitions
#include <lmerr.h>              // LAN Manager error code
#include <lmapibuf.h>           // NetApiBufferAllocate()

#include <winerror.h>           // ERROR_ equates, NO_ERROR.

#undef DBGPRINT
#define DBGPRINT(_x_) DbgPrint _x_

NTSTATUS
GetDomainName (
    IN  PWCHAR ServerNamePtr, // name of server to get domain of
    OUT PWCHAR *DomainNamePtr // alloc and set ptr (free with NetApiBufferFree)
    )

/*++

Routine Description:

    Returns the name of the domain or workgroup this machine belongs to.

Arguments:

    DomainNamePtr - The name of the domain or workgroup

    IsWorkgroupName - Returns TRUE if the name is a workgroup name.
        Returns FALSE if the name is a domain name.

Return Value:

   NERR_Success - Success.
   NERR_CfgCompNotFound - There was an error determining the domain name

--*/
{
    NTSTATUS status;
    LSA_HANDLE PolicyHandle;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo;
    OBJECT_ATTRIBUTES ObjAttributes;
    UNICODE_STRING UniServerName;


    //
    // Check for caller's errors.
    //
    if ( DomainNamePtr == NULL ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Open a handle to the local security policy.  Initialize the
    // objects attributes structure first.
    //
    InitializeObjectAttributes(
        &ObjAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );

    RtlInitUnicodeString( &UniServerName, ServerNamePtr );
    status = LsaOpenPolicy(
                   &UniServerName,
                   &ObjAttributes,
                   POLICY_VIEW_LOCAL_INFORMATION,
                   &PolicyHandle
                   );

#ifdef DEBUG
    DbgPrint( "GetDomainName: LsaOpenPolicy returned NTSTATUS = 0x%x\n", status );
#endif // DEBUG
    

    if (! NT_SUCCESS(status)) {
        return( status );
    }

    //
    // Get the name of the primary domain from LSA
    //
    status = LsaQueryInformationPolicy(
                   PolicyHandle,
                   PolicyAccountDomainInformation,
                   (PVOID *)&DomainInfo
                   );

#ifdef DEBUG
    DbgPrint( "GetDomainName: LsaQueryInformationPolicy returned NTSTATUS = 0x%x\n", status );
#endif // DEBUG


    if (! NT_SUCCESS(status)) {
        (void) LsaClose(PolicyHandle);
        return( status );
    }

    (void) LsaClose(PolicyHandle);

    if (NetApiBufferAllocate(
                      DomainInfo->DomainName.Length + sizeof(WCHAR),
                      DomainNamePtr
                      ) != NERR_Success) {
        (void) LsaFreeMemory((PVOID) DomainInfo);
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    RtlZeroMemory(
        *DomainNamePtr,
        DomainInfo->DomainName.Length + sizeof(WCHAR)
        );

    memcpy(
        *DomainNamePtr,
        DomainInfo->DomainName.Buffer,
        DomainInfo->DomainName.Length
        );

    (void) LsaFreeMemory((PVOID) DomainInfo);



    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\regapi\reguc.c ===
/*************************************************************************
*
* reguc.c
*
* Registry APIs for user configuration data and TerminalServer AppServer detection
*
* Copyright (c) 1998 Microsoft Corporation
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>
#include <windows.h>

#include <ntddkbd.h>
#include <ntddmou.h>
#include <winstaw.h>
#include <regapi.h>
#include <regsam.h>


/*
 *  External Procedures defined here
 */
LONG WINAPI RegUserConfigSet( WCHAR *,
                              WCHAR *,
                              PUSERCONFIGW,
                              ULONG );
LONG WINAPI RegUserConfigQuery( WCHAR *,
                                WCHAR *,
                                PUSERCONFIGW,
                                ULONG,
                                PULONG );
LONG WINAPI RegUserConfigDelete( WCHAR *,
                                 WCHAR * );
LONG WINAPI RegUserConfigRename( WCHAR *,
                                 WCHAR *,
                                 WCHAR * );
LONG WINAPI RegDefaultUserConfigQueryW( WCHAR *,
                                        PUSERCONFIGW,
                                        ULONG,
                                        PULONG );
LONG WINAPI RegDefaultUserConfigQueryA( CHAR *,
                                        PUSERCONFIGA,
                                        ULONG,
                                        PULONG );
BOOLEAN WINAPI RegIsTServer( WCHAR * );

/*
 *  other internal Procedures used (not defined here)
 */
VOID CreateUserConfig( HKEY, PUSERCONFIG );
VOID QueryUserConfig( HKEY, PUSERCONFIG );
VOID UserConfigU2A( PUSERCONFIGA, PUSERCONFIGW );
VOID AnsiToUnicode( WCHAR *, ULONG, CHAR * );
VOID CreateNWLogonAdmin( HKEY, PNWLOGONADMIN );
VOID QueryNWLogonAdmin( HKEY, PNWLOGONADMIN );

/*******************************************************************************
 *
 *  RegUserConfigSet (UNICODE)
 *
 *    Creates or updates the specified user's User Configuration structure in
 *    the SAM of the user's Domain controller.
 *
 * ENTRY:
 *    pServerName (input)
 *       Points to string of server to access (NULL for current machine).
 *    pUserName (input)
 *       Points to name of user to set configuration data for.
 *    pUserConfig (input)
 *       Pointer to a USERCONFIG structure containing specified user's
 *       configuration information.
 *    UserConfigLength (input)
 *       Specifies the length in bytes of the pUserConfig buffer.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *    ERROR_INSUFFICIENT_BUFFER - pUserConfig buffer too small
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegUserConfigSet( WCHAR * pServerName,
                  WCHAR * pUserName,
                  PUSERCONFIGW pUserConfig,
                  ULONG UserConfigLength )
{
    LONG Error;

    /*
     *  Validate length of buffer
     */
    if ( UserConfigLength < sizeof(USERCONFIGW) )
        return( ERROR_INSUFFICIENT_BUFFER );

    Error = RegSAMUserConfig( FALSE, pUserName, pServerName, pUserConfig );

    return( Error );
}


/*******************************************************************************
 *
 *  RegUserConfigQuery (UNICODE)
 *
 *    Query the specified user's configuration from the indicated server.
 *
 * ENTRY:
 *    pServerName (input)
 *       Points to string of server to access (NULL for current machine).
 *    pUserName (input)
 *       Points to name of user to query configuration data for.
 *    pUserConfig (input)
 *       Pointer to a USERCONFIGW structure that will receive the user's
 *       configuration data.
 *    UserConfigLength (input)
 *       Specifies the length in bytes of the pUserConfig buffer.
 *    pReturnLength (output)
 *       Receives the number of bytes placed in the pUserConfig buffer.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegUserConfigQuery( WCHAR * pServerName,
                    WCHAR * pUserName,
                    PUSERCONFIGW pUserConfig,
                    ULONG UserConfigLength,
                    PULONG pReturnLength )
{
    LONG Error;
    // WCHAR KeyString[256+USERNAME_LENGTH];
    // HKEY ServerHandle, UserHandle;

    /*
     * Validate length and zero-initialize the destination
     * USERCONFIGW buffer.
     */
    if ( UserConfigLength < sizeof(USERCONFIGW) )
        return( ERROR_INSUFFICIENT_BUFFER );

    if ( ( pUserName == NULL ) ) // || ((wcslen(USERCONFIG_REG_NAME) + wcslen(pUserName)) >= (256+USERNAME_LENGTH))) {
    {
        return ERROR_INVALID_PARAMETER;
    }

    memset(pUserConfig, 0, UserConfigLength);

    Error = RegSAMUserConfig( TRUE , pUserName , pServerName , pUserConfig );

    // all valid sam errors are returned:299987
        
#if 0 // this has to go!!!!
    if( Error == ERROR_FILE_NOT_FOUND )
    {
        /*
         * Connect to registry of specified server.
         */

        if( (Error = RegConnectRegistry( pServerName,
                                          HKEY_LOCAL_MACHINE,
                                          &ServerHandle )) != ERROR_SUCCESS )
		{
			KdPrint( ( "REGAPI - RegUserConfigQuery@RegConnectRegistry returned 0x%x\n", Error ) );

            return( Error );

        /*
         *  Open the key for specified user.
         */
        
        wcscpy( KeyString, USERCONFIG_REG_NAME );
        wcscat( KeyString, pUserName );

        if ( (Error = RegOpenKeyEx( ServerHandle, KeyString, 0,
                                    KEY_READ, &UserHandle )) != ERROR_SUCCESS ) {

            KdPrint( ( "REGAPI - RegUserConfigQuery@RegOpenKeyEx returned 0x%x\n", Error ) );
			RegCloseKey( ServerHandle );
            return( Error );
        }

        /*
         *  Query USERCONFIG Structure
         */
        
        QueryUserConfig( UserHandle, pUserConfig );

        /*
         *  Close registry handles.
         */

        RegCloseKey( UserHandle );
        RegCloseKey( ServerHandle );
        
    }
#endif // legacy crap

    *pReturnLength = sizeof(USERCONFIGW);

    return( Error );
}


/*******************************************************************************
 *
 *  -- FOR COMPATIBILITY ONLY--
 *    Deletion of the user configuration will occur when the user is
 *    removed, since the UserConfiguration is part of the SAM.  The old
 *    Registry-based user configuration is left intact and must be
 *    managed with registry-based 1.6 versions.
 *
 *  RegUserConfigDelete (UNICODE)
 *
 *    Delete the specified user's configuration from the indicated server.
 *
 * ENTRY:
 *    pServerName (input)
 *       Points to string of server to access (NULL for current machine).
 *    pUserName (input)
 *       Points to name of user to delete configuration data for.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegUserConfigDelete( WCHAR * pServerName,
                     WCHAR * pUserName )
{
    return( NO_ERROR );
}


/*******************************************************************************
 *
 *  -- FOR COMPATIBILITY ONLY--
 *    Renaming of the user configuration will occur when the user is
 *    rename, since the UserConfiguration is part of the SAM.  The old
 *    Registry-based user configuration is left intact and must be
 *    managed with registry-based 1.6 versions.
 *
 *  RegUserConfigRename (UNICODE)
 *
 *    Rename the specified user's configuration on the indicated server.
 *
 * ENTRY:
 *    pServerName (input)
 *       Points to string of server to access.
 *    pUserOldName (input)
 *       Points to old name of user.
 *    pUserNewName (input)
 *       Points to new name of user.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegUserConfigRename( WCHAR * pServerName,
                     WCHAR * pUserOldName,
                     WCHAR * pUserNewName )
{
    return( NO_ERROR );
}


/*******************************************************************************
 *
 *  RegDefaultUserConfigQueryA (ANSI stub)
 *
 *    Query the Default User Configuration from the indicated server's registry.
 *
 * ENTRY:
 *    see RegDefaultUserConfigQueryW
 *
 * EXIT:
 *    see RegDefaultUserConfigQueryW
 *
 ******************************************************************************/

LONG WINAPI
RegDefaultUserConfigQueryA( CHAR * pServerName,
                            PUSERCONFIGA pUserConfig,
                            ULONG UserConfigLength,
                            PULONG pReturnLength )
{
    USERCONFIGW UserConfigW;
    WCHAR ServerNameW[ DOMAIN_LENGTH + 1 ];
    ULONG ReturnLengthW;

    /*
     * Validate length and zero-initialize the destination
     * USERCONFIGA structure.
     */
    if ( UserConfigLength < sizeof(USERCONFIGA) )
        return( ERROR_INSUFFICIENT_BUFFER );
    memset(pUserConfig, 0, UserConfigLength);

    /*
     * Convert server name to UINCODE (if present).
     */
    if ( pServerName )
        AnsiToUnicode( ServerNameW, sizeof(ServerNameW), pServerName );

    /*
     * Query Default User Configuration (will always return success).
     */
    RegDefaultUserConfigQueryW( pServerName ?
                                    ServerNameW : (WCHAR *)NULL,
                                &UserConfigW,
                                sizeof(USERCONFIGW),
                                &ReturnLengthW );

    /*
     * Copy USERCONFIGW elements to USERCONFIGA elements.
     */
    UserConfigU2A( pUserConfig, &UserConfigW );

    *pReturnLength = sizeof(USERCONFIGA);

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegDefaultUserConfigQueryW (UNICODE)
 *
 *    Query the Default User Configuration from the indicated server's registry.
 *
 * ENTRY:
 *    pServerName (input)
 *       Points to string of server to access (NULL for current machine).
 *    pUserConfig (input)
 *       Pointer to a USERCONFIGW structure that will receive the default
 *       user configuration information.
 *    UserConfigLength (input)
 *       Specifies the length in bytes of the pUserConfig buffer.
 *    pReturnLength (output)
 *       Receives the number of bytes placed in the pUserConfig buffer.
 *
 * EXIT:
 *    Always will return ERROR_SUCCESS, unless UserConfigLength is incorrect.
 *
 ******************************************************************************/

LONG WINAPI
RegDefaultUserConfigQueryW( WCHAR * pServerName,
                            PUSERCONFIGW pUserConfig,
                            ULONG UserConfigLength,
                            PULONG pReturnLength )
{
    HKEY ServerHandle, ConfigHandle;
    DWORD Disp;

    /*
     * Validate length and zero-initialize the destination
     * USERCONFIGW buffer.
     */
    if ( UserConfigLength < sizeof(USERCONFIGW) )
        return( ERROR_INSUFFICIENT_BUFFER );

    /*
     * Initialize to an initial default in case of failure down the road.
     */
    memset(pUserConfig, 0, UserConfigLength);
//    pUserConfig->fInheritInitialProgram = TRUE;
//    pUserConfig->Shadow = Shadow_EnableInputNotify;
//
//  butchd 10/10/97: Make the default based on the regapi's
//                   built-in preferences (use HKEY_LOCAL_MACHINE for
//                   a valid registry handle that will not have actual
//                   DefaultUserConfig key/values present)
//
    QueryUserConfig( HKEY_LOCAL_MACHINE, pUserConfig );

    *pReturnLength = sizeof(USERCONFIGW);

    /*
     * Connect to registry of specified server.  If a failure is seen at
     * this point, return ERROR_SUCCESS immediately (no point in trying
     * to write the default user configuration key and values).
     */
    if ( RegConnectRegistry( pServerName,
                             HKEY_LOCAL_MACHINE,
                             &ServerHandle ) != ERROR_SUCCESS )
        return( ERROR_SUCCESS );

    /*
     * Open default user configuration registry key.  If this fails, we will
     * attempt to create the key and write the initial default information
     * there, returning ERROR_SUCCESS whether that succeeds or not.
     */
    if ( RegOpenKeyEx( ServerHandle, DEFCONFIG_REG_NAME, 0,
                       KEY_READ, &ConfigHandle ) != ERROR_SUCCESS ) {

        if ( RegCreateKeyEx( ServerHandle, DEFCONFIG_REG_NAME, 0, NULL,
                             REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                             NULL, &ConfigHandle,
                             &Disp ) == ERROR_SUCCESS ) {

            CreateUserConfig( ConfigHandle, pUserConfig );
            RegCloseKey( ConfigHandle );
        }
        RegCloseKey( ServerHandle );
        return( ERROR_SUCCESS );
    }

    /*
     *  Query USERCONFIG Structure
     */
    QueryUserConfig( ConfigHandle, pUserConfig );

    /*
     * Close registry handles.
     */
    RegCloseKey( ConfigHandle );
    RegCloseKey( ServerHandle );

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegIsTServer (UNICODE)
 *
 *    Determine if the specified server is a Terminal Server by checking for
 *    a TServer-specific registry key.
 *
 * ENTRY:
 *    pServerName (input)
 *       Points to string of server to check.
 *
 * EXIT:
 *    TRUE if Terminal Server; FALSE otherwise
 *
 ******************************************************************************/

BOOLEAN WINAPI
RegIsTServer( WCHAR * pServerName )
{
    LONG Error;
    HKEY ServerHandle, UserHandle;

    /*
     * Connect to registry of specified server.
     */
    if ( (Error = RegConnectRegistry( pServerName,
                                      HKEY_LOCAL_MACHINE,
                                      &ServerHandle )) != ERROR_SUCCESS )
        return( FALSE );

    /*
     * Open the Winstations key on the server to see if it is
     * a Terminal Server.
     */
    if ( (Error = RegOpenKeyEx( ServerHandle, WINSTATION_REG_NAME, 0,
                                KEY_READ, &UserHandle )) != ERROR_SUCCESS ) {

        RegCloseKey( ServerHandle );
        return( FALSE );
    }

    /*
     *  Close registry handles.
     */
    RegCloseKey( UserHandle );
    RegCloseKey( ServerHandle );

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\regapi\regwd.c ===
/*************************************************************************
*
* regwd.c
*
* Register APIs for WDs (winstation drivers)
*
* Copyright (c) 1998 Microsoft Corporation
*
*************************************************************************/

/*
 *  Includes
 */
#include <windows.h>

/* Added By SalimC */
#include <ksguid.h>
/**/
#include <ntddkbd.h>
#include <ntddmou.h>
#include <winstaw.h>
#include <regapi.h>


/*
 *  External Procedures defined here
 */
LONG WINAPI RegWdEnumerateA( HANDLE, PULONG, PULONG, PWDNAMEA, PULONG );
LONG WINAPI RegWdEnumerateW( HANDLE, PULONG, PULONG, PWDNAMEW, PULONG );
LONG WINAPI RegWdCreateW( HANDLE, PWDNAMEW, BOOLEAN, PWDCONFIG2W, ULONG );
LONG WINAPI RegWdCreateA( HANDLE, PWDNAMEA, BOOLEAN, PWDCONFIG2A, ULONG );
LONG WINAPI RegWdQueryW( HANDLE, PWDNAMEW, PWDCONFIG2W, ULONG, PULONG );
LONG WINAPI RegWdQueryA( HANDLE, PWDNAMEA, PWDCONFIG2A, ULONG, PULONG );
LONG WINAPI RegWdDeleteW( HANDLE, PWDNAMEW );
LONG WINAPI RegWdDeleteA( HANDLE, PWDNAMEA );

/*
 *  other internal Procedures used (not defined here)
 */
VOID CreateWd( HKEY, PWDCONFIG );
VOID CreateAsync( BOOLEAN, HKEY, PASYNCCONFIG );
VOID CreateUserConfig( HKEY, PUSERCONFIG );
VOID QueryWd( HKEY, PWDCONFIG );
VOID QueryAsync( HKEY, PASYNCCONFIG );
VOID QueryUserConfig( HKEY, PUSERCONFIG );
VOID UnicodeToAnsi( CHAR *, ULONG, WCHAR * );
VOID AnsiToUnicode( WCHAR *, ULONG, CHAR * );
VOID WdConfigU2A( PWDCONFIGA, PWDCONFIGW );
VOID WdConfigA2U( PWDCONFIGW, PWDCONFIGA );
VOID AsyncConfigU2A ( PASYNCCONFIGA, PASYNCCONFIGW );
VOID AsyncConfigA2U ( PASYNCCONFIGW, PASYNCCONFIGA );
VOID UserConfigU2A ( PUSERCONFIGA, PUSERCONFIGW );
VOID UserConfigA2U ( PUSERCONFIGW, PUSERCONFIGA );


/*******************************************************************************
 *
 *  RegWdEnumerateA (ANSI stub)
 *
 *     Returns a list of configured winstation drivers in the registry.
 *
 * ENTRY:
 *
 *    see RegWdEnumerateW
 *
 * EXIT:
 *
 *    see RegWdEnumerateW, plus
 *
 *  ERROR_NOT_ENOUGH_MEMORY - the LocalAlloc failed
 *
 ******************************************************************************/

LONG WINAPI
RegWdEnumerateA( HANDLE hServer,
                 PULONG  pIndex,
                 PULONG  pEntries,
                 PWDNAMEA  pWdName,
                 PULONG  pByteCount )
{
    PWDNAMEW pBuffer = NULL, pWdNameW;
    LONG Status;
    ULONG Count, ByteCountW = (*pByteCount << 1);

    /*
     * If the caller supplied a buffer and the length is not 0,
     * allocate a corresponding (*2) buffer for UNICODE strings.
     */
    if ( pWdName && ByteCountW ) {

        if ( !(pBuffer = LocalAlloc(0, ByteCountW)) )
            return ( ERROR_NOT_ENOUGH_MEMORY );
    }

    /*
     * Enumerate winstation drivers
     */
    pWdNameW = pBuffer;
    Status = RegWdEnumerateW( hServer, pIndex, pEntries, pWdNameW,
                                    &ByteCountW );

    /*
     * Always /2 the resultant ByteCount (whether sucessful or not).
     */
    *pByteCount = (ByteCountW >> 1);

    /*
     * If the function completed sucessfully and caller
     * (and stub) defined a buffer to copy into, perform conversion
     * from UNICODE to ANSI.  Note: sucessful return may have copied
     * 0 items from registry (end of enumeration), denoted by *pEntries
     * == 0.
     */
    if ( ((Status == ERROR_SUCCESS) || (Status == ERROR_NO_MORE_ITEMS))
                                         && pWdNameW && pWdName ) {

        for ( Count = *pEntries; Count; Count-- ) {
            UnicodeToAnsi( pWdName, sizeof(WDNAMEA), pWdNameW );
            (char*)pWdName += sizeof(WDNAMEA);
            (char*)pWdNameW += sizeof(WDNAMEW);
        }
    }

    /*
     * If we defined a buffer, free it now, then return the status
     * of the Reg...EnumerateW function call.
     */
    if ( pBuffer )
        LocalFree(pBuffer);

    return ( Status );
}


/*******************************************************************************
 *
 *  RegWdEnumerateW (UNICODE)
 *
 *     Returns a list of configured winstation drivers in the registry.
 *
 * ENTRY:
 *
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pIndex (input/output)
 *       Specifies the subkey index for the \Citrix\Wds subkeys in the
 *       registry.  Should be set to 0 for the initial call, and supplied
 *       again (as modified by this function) for multi-call enumeration.
 *    pEntries (input/output)
 *       Points to a variable specifying the number of entries requested.
 *       If the number requested is 0xFFFFFFFF, the function returns as
 *       many entries as possible. When the function finishes successfully,
 *       the variable pointed to by the pEntries parameter contains the
 *       number of entries actually read.
 *    pWdName (input)
 *       Points to the buffer to receive the enumeration results, which are
 *       returned as an array of WDNAMEW structures.  If this parameter is
 *       NULL, then no data will be copied, but just an enumeration count will
 *       be made.
 *    pByteCount (input/output)
 *       Points to a variable that specifies the size, in bytes, of the
 *       pWdName parameter. If the buffer is too small to receive even
 *       one entry, the function returns an error code (ERROR_OUTOFMEMORY)
 *       and this variable receives the required size of the buffer for a
 *       single subkey.  When the function finishes sucessfully, the variable
 *       pointed to by the pByteCount parameter contains the number of bytes
 *       actually stored in pWdName.
 *
 * EXIT:
 *
 *  "No Error" codes:
 *    ERROR_SUCCESS       - The enumeration completed as requested and there
 *                          are more WDS subkeys (WDNAMEs) to be
 *                          read.
 *    ERROR_NO_MORE_ITEMS - The enumeration completed as requested and there
 *                          are no more WDS subkeys (WDNAMEs) to
 *                          be read.
 *
 *  "Error" codes:
 *    ERROR_OUTOFMEMORY   - The pWdName buffer is too small for even one
 *                          entry.
 *    ERROR_CANTOPEN      - The Citrix\Wds key can't be opened.
 *
 ******************************************************************************/

LONG WINAPI
RegWdEnumerateW( HANDLE hServer,
                 PULONG  pIndex,
                 PULONG  pEntries,
                 PWDNAMEW pWdName,
                 PULONG  pByteCount )
{
    LONG Status;
    HKEY Handle;
    ULONG Count;
    ULONG i;

    /*
     *  Get the number of names to return
     */
    Count = pWdName ?
            min( *pByteCount / sizeof(WDNAME), *pEntries ) :
            (ULONG) -1;
    *pEntries = *pByteCount = 0;

    /*
     *  Make sure buffer is big enough for at least one name
     */
    if ( Count == 0 ) {
        *pByteCount = sizeof(WDNAME);
        return( ERROR_OUTOFMEMORY );
    }

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\Wds)
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, WD_REG_NAME, 0,
         KEY_ENUMERATE_SUB_KEYS, &Handle ) != ERROR_SUCCESS ) {
        return( ERROR_CANTOPEN );
    }

    /*
     *  Get list of window stations
     */
    for ( i = 0; i < Count; i++ ) {
        WDNAME WdName;

        if ( (Status = RegEnumKey(Handle, *pIndex, WdName,
                                    sizeof(WDNAME)/sizeof(TCHAR) )) != ERROR_SUCCESS )
            break;

        /*
         * If caller supplied a buffer, then copy the WdName
         * and increment the pointer and byte count.  Always increment the
         * entry count and index for the next iteration.
         */
        if ( pWdName ) {
            wcscpy( pWdName, WdName );
            (char*)pWdName += sizeof(WDNAME);
            *pByteCount += sizeof(WDNAME);
        }
        (*pEntries)++;
        (*pIndex)++;
    }

    /*
     *  Close registry
     */
    RegCloseKey( Handle );
    return( Status );
}


/*******************************************************************************
 *
 *  RegWdCreateA (ANSI stub)
 *
 *    Creates a new Wd in the registry or updates an existing entry.
 *      (See RegWdCreateW)
 *
 * ENTRY:
 *    see RegWdCreateW
 * EXIT:
 *    see RegWdCreateW
 *
 ******************************************************************************/

LONG WINAPI
RegWdCreateA( HANDLE hServer,
              PWDNAMEA pWdName,
              BOOLEAN bCreate,
              PWDCONFIG2A pWdConfig,
              ULONG WdConfigLength )
{
    WDNAMEW WdNameW;
    WDCONFIG2W WdConfig2W;

    /*
     * Validate target buffer size.
     */
    if ( WdConfigLength < sizeof(WDCONFIG2A) )
        return( ERROR_INSUFFICIENT_BUFFER );

    /*
     * Convert ANSI WdName to UNICODE.
     */
    AnsiToUnicode( WdNameW, sizeof(WDNAMEW), pWdName );

    /*
     * Copy WDCONFIG2A elements to WDCONFIG2W elements.
     */
    WdConfigA2U( &(WdConfig2W.Wd), &(pWdConfig->Wd) );
    AsyncConfigA2U( &(WdConfig2W.Async), &(pWdConfig->Async) );
    UserConfigA2U( &(WdConfig2W.User), &(pWdConfig->User) );

    /*
     * Call RegWdCreateW & return it's status.
     */
    return ( RegWdCreateW( hServer, WdNameW, bCreate,
                           &WdConfig2W,
                           sizeof(WdConfig2W)) );
}


/*******************************************************************************
 *
 *  RegWdCreateW (UNICODE)
 *
 *    Creates a new Wd in the registry or updates an existing entry.  The
 *    state of the bCreate flag determines whether this function will expect
 *    to create a new Wd entry (bCreate == TRUE) or expects to update an
 *    existing entry (bCreate == FALSE).
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWdName (input)
 *       Name of a new or exisiting winstation driver in the registry.
 *    bCreate (input)
 *       TRUE if this is a creation of a new Wd
 *       FALSE if this is an update to an existing Wd
 *    pWdConfig (input)
 *       Pointer to a WDCONFIG2W structure containing configuration
 *       information for the specified winstation driver name.
 *    WdConfigLength (input)
 *       Specifies the length in bytes of the pWdConfig buffer.
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 *    ERROR_INSUFFICIENT_BUFFER - pWdConfig buffer too small
 *    ERROR_FILE_NOT_FOUND - can't open ...\Citrix\Wds key
 *    ERROR_CANNOT_MAKE - can't create Wd key (registry problem)
 *    ERROR_ALREADY_EXISTS - create; but Wd key already present
 *    ERROR_CANTOPEN - update; but Wd key could not be opened
 *
 ******************************************************************************/

LONG WINAPI
RegWdCreateW( HANDLE hServer,
              PWDNAMEW pWdName,
              BOOLEAN bCreate,
              PWDCONFIG2W pWdConfig,
              ULONG WdConfigLength )
{
    HKEY Handle;
    HKEY Handle1;
    DWORD Disp;

    /*
     *  Validate length of buffer
     */
    if ( WdConfigLength < sizeof(WDCONFIG2) )
        return( ERROR_INSUFFICIENT_BUFFER );

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\Wds)
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, WD_REG_NAME, 0,
         KEY_ALL_ACCESS, &Handle1 ) != ERROR_SUCCESS ) {
        return( ERROR_FILE_NOT_FOUND );
    }

    if ( bCreate ) {

        /*
         *  Create requested: create a registry key for the specified
         *  Wd name.
         */
        if ( RegCreateKeyEx( Handle1, pWdName, 0, NULL,
                             REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                             NULL, &Handle, &Disp ) != ERROR_SUCCESS ) {
            RegCloseKey( Handle1 );
            return( ERROR_CANNOT_MAKE );
        }

        /*
         * If an existing key was returned instead of a new one being
         * created, return error (don't update).
         */
        if ( Disp != REG_CREATED_NEW_KEY ) {
            RegCloseKey( Handle1 );
            RegCloseKey( Handle );
            return( ERROR_ALREADY_EXISTS );
        }
    } else {

        /*
         *  Update requested: open the registry key for the specified
         *  Wd name.
         */
        if ( RegOpenKeyEx( Handle1, pWdName, 0, KEY_ALL_ACCESS,
                           &Handle ) != ERROR_SUCCESS ) {
            RegCloseKey( Handle1 );
            return( ERROR_CANTOPEN );
        }
    }

    RegCloseKey( Handle1 );

    /*
     *  Save WDCONFIG2 Structure
     */
    CreateWd( Handle, &pWdConfig->Wd );
    CreateAsync( TRUE, Handle, &pWdConfig->Async );
    CreateUserConfig( Handle, &pWdConfig->User );

    /*
     *  Close registry handle
     */
    RegCloseKey( Handle );

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegWdQueryA (ANSI stub)
 *
 *    Query configuration information of a winstation driver in the registry.
 *
 * ENTRY:
 *    see RegWdQueryW
 * EXIT:
 *    see RegWdQueryW
 *
 ******************************************************************************/
LONG WINAPI
RegWdQueryA( HANDLE hServer,
             PWDNAMEA pWdName,
             PWDCONFIG2A pWdConfig,
             ULONG WdConfigLength,
             PULONG pReturnLength )
{
    WDNAMEW WdNameW;
    WDCONFIG2W WdConfig2W;
    LONG Status;
    ULONG ReturnLengthW;

    /*
     * Validate length and zero-initialize the destination
     * PDCONFIG3A structure.
     */
    if ( WdConfigLength < sizeof(WDCONFIG2A) )
        return( ERROR_INSUFFICIENT_BUFFER );
    memset(pWdConfig, 0, WdConfigLength);

    /*
     * Convert ANSI WdName to UNICODE.
     */
    AnsiToUnicode(WdNameW, sizeof(WDNAMEW), pWdName);

    /*
     * Query Wd.
     */
    if ( (Status = RegWdQueryW( hServer, WdNameW, &WdConfig2W,
                                      sizeof(WDCONFIG2W),
                                      &ReturnLengthW)) != ERROR_SUCCESS )
        return ( Status );

    /*
     * Copy WDCONFIG2W elements to WDCONFIG2A elements.
     */
    WdConfigU2A( &(pWdConfig->Wd), &(WdConfig2W.Wd) );
    AsyncConfigU2A( &(pWdConfig->Async), &(WdConfig2W.Async) );
    UserConfigU2A( &(pWdConfig->User), &(WdConfig2W.User) );

    *pReturnLength = sizeof(WDCONFIG2A);

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegWdQueryW (UNICODE)
 *
 *    Query configuration information of a winstation driver in the registry.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWdName (input)
 *       Name of an exisiting winstation driver in the registry.
 *    pWdConfig (input)
 *       Pointer to a WDCONFIG2W structure that will receive
 *       information about the specified winstation driver name.
 *    WdConfigLength (input)
 *       Specifies the length in bytes of the pWdConfig buffer.
 *    pReturnLength (output)
 *       Receives the number of bytes placed in the pWdConfig buffer.
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 ******************************************************************************/

LONG WINAPI
RegWdQueryW( HANDLE hServer,
             PWDNAMEW pWdName,
             PWDCONFIG2W pWdConfig,
             ULONG WdConfigLength,
             PULONG pReturnLength )
{
    HKEY Handle;
    HKEY Handle1;

    /*
     * Validate length and zero-initialize the destination
     * PDCONFIG3A structure.
     */
    if ( WdConfigLength < sizeof(WDCONFIG2) )
        return( ERROR_INSUFFICIENT_BUFFER );
    memset(pWdConfig, 0, WdConfigLength);

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\Wds)
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, WD_REG_NAME, 0,
         KEY_READ, &Handle1 ) != ERROR_SUCCESS ) {
        return( ERROR_FILE_NOT_FOUND );
    }

    /*
     *  Now try to open the specified Wd
     */
    if ( RegOpenKeyEx( Handle1, pWdName, 0,
         KEY_READ, &Handle ) != ERROR_SUCCESS ) {
        RegCloseKey( Handle1 );
        return( ERROR_FILE_NOT_FOUND );
    }
    RegCloseKey( Handle1 );

    /*
     *  Query WDCONFIG2 Structure
     */
    QueryWd( Handle, &pWdConfig->Wd );
    QueryAsync( Handle, &pWdConfig->Async );
    QueryUserConfig( Handle, &pWdConfig->User );

    /*
     *  Close registry
     */
    RegCloseKey( Handle );

    *pReturnLength = sizeof(WDCONFIG2);

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegWdDeleteA (ANSI stub)
 *
 *    Deletes a winstation driver from the registry.
 *
 * ENTRY:
 *
 *    see RegWdDeleteW
 *
 * EXIT:
 *
 *    see RegWdDeleteW
 *
 ******************************************************************************/
LONG WINAPI
RegWdDeleteA( HANDLE hServer, PWDNAMEA pWdName )
{
    WDNAMEW WdNameW;

    AnsiToUnicode( WdNameW, sizeof(WdNameW), pWdName);

    return ( RegWdDeleteW ( hServer, WdNameW ) );
}


/*******************************************************************************
 *
 *  RegWdDeleteW (UNICODE)
 *
 *    Deletes a winstation driver from the registry.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWdName (input)
 *       Name of a winstation driver to delete from the registry.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 ******************************************************************************/

LONG WINAPI
RegWdDeleteW( HANDLE hServer, PWDNAMEW pWdName )
{
    LONG Status;
    HKEY Handle;
    HKEY Handle1;

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\Wds)
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, WD_REG_NAME, 0,
         KEY_READ, &Handle ) != ERROR_SUCCESS ) {
        return( ERROR_FILE_NOT_FOUND );
    }

    /*
     *  Now try to open the specified Wd
     */
    if ( RegOpenKeyEx( Handle, pWdName, 0,
         KEY_READ, &Handle1 ) != ERROR_SUCCESS ) {
        RegCloseKey( Handle );
        return( ERROR_FILE_NOT_FOUND );
    }

    /*
     *  Close the Wd key handle, delete the Wd,
     *  and close the handle to the "Citrix\\Wds" directory.
     */
    RegCloseKey( Handle1 );
    Status = RegDeleteKey( Handle, pWdName );
    RegCloseKey( Handle );

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\regapi\regwin.c ===
/*************************************************************************
*
* regwin.c
*
* Register APIs for window stations
*
* Copyright (c) 1998 Microsoft Corporation
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <ntddkbd.h>
#include <ntddmou.h>
#include <winstaw.h>
#include <regapi.h>

//
extern HKEY g_hTSPolicyKey;//handle to TS_POLICY_SUB_TREE key
extern HKEY g_hTSControlKey;//handle to REG_CONTROL_TSERVER key


/*
 *  External Procedures defined here
 */
LONG WINAPI RegWinStationAccessCheck( HANDLE, REGSAM );
LONG WINAPI RegWinStationEnumerateW( HANDLE, PULONG, PULONG, PWINSTATIONNAMEW, PULONG );
LONG WINAPI RegWinStationEnumerateA( HANDLE, PULONG, PULONG, PWINSTATIONNAMEA, PULONG );
LONG WINAPI RegWinStationCreateW( HANDLE, PWINSTATIONNAMEW, BOOLEAN,
                                  PWINSTATIONCONFIG2W, ULONG );
LONG WINAPI RegWinStationCreateA( HANDLE, PWINSTATIONNAMEA, BOOLEAN,
                                  PWINSTATIONCONFIG2A, ULONG );
LONG WINAPI RegWinStationQueryW( HANDLE, PWINSTATIONNAMEW, PWINSTATIONCONFIG2W,
                                 ULONG, PULONG );
LONG WINAPI RegWinStationQueryA( HANDLE, PWINSTATIONNAMEA, PWINSTATIONCONFIG2A,
                                 ULONG, PULONG );
LONG WINAPI RegWinStationDeleteW( HANDLE, PWINSTATIONNAMEW );
LONG WINAPI RegWinStationDeleteA( HANDLE, PWINSTATIONNAMEA );
LONG WINAPI RegWinStationSetSecurityW( HANDLE, PWINSTATIONNAMEW, PSECURITY_DESCRIPTOR,
                                       ULONG );
LONG WINAPI RegWinStationSetSecurityA( HANDLE, PWINSTATIONNAMEA, PSECURITY_DESCRIPTOR,
                                       ULONG );
LONG WINAPI RegWinStationQuerySecurityW( HANDLE, PWINSTATIONNAMEW, PSECURITY_DESCRIPTOR,
                                         ULONG, PULONG );
LONG WINAPI RegWinStationQuerySecurityA( HANDLE, PWINSTATIONNAMEA, PSECURITY_DESCRIPTOR,
                                         ULONG, PULONG );
LONG WINAPI RegWinStationQueryDefaultSecurity( HANDLE, PSECURITY_DESCRIPTOR,
                                               ULONG, PULONG );

LONG WINAPI RegWinStationSetNumValueW( HANDLE, PWINSTATIONNAMEW, LPWSTR, ULONG );
LONG WINAPI RegWinStationQueryNumValueW( HANDLE, PWINSTATIONNAMEW, LPWSTR, PULONG );


LONG WINAPI
RegConsoleShadowQueryA( HANDLE hServer,
                     PWINSTATIONNAMEA pWinStationName,
                     PWDPREFIXA pWdPrefixName,
                     PWINSTATIONCONFIG2A pWinStationConfig,
                     ULONG WinStationConfigLength,
                     PULONG pReturnLength );

LONG WINAPI
RegConsoleShadowQueryW( HANDLE hServer,
                     PWINSTATIONNAMEW pWinStationName,
                     PWDPREFIXW pWdPrefixName,
                     PWINSTATIONCONFIG2W pWinStationConfig,
                     ULONG WinStationConfigLength,
                     PULONG pReturnLength );


/*
 *  Private Procedures defined here
 */
LONG _RegOpenWinStation( PWINSTATIONNAMEW, REGSAM, HKEY * );
LONG _RegGetWinStationSecurity( HKEY, LPWSTR, PSECURITY_DESCRIPTOR, ULONG, PULONG );

/*
 *  other internal Procedures used (not defined here)
 */
VOID CreateWinStaCreate( HKEY, PWINSTATIONCREATE );
VOID CreateConfig( HKEY, PWINSTATIONCONFIG );
VOID CreateWd( HKEY, PWDCONFIG );
VOID CreateCd( HKEY, PCDCONFIG );
VOID CreatePdConfig( BOOLEAN, HKEY, PPDCONFIG, ULONG );
VOID QueryWinStaCreate( HKEY, PWINSTATIONCREATE );
VOID QueryConfig( HKEY, PWINSTATIONCONFIG );
VOID QueryWd( HKEY, PWDCONFIG );
VOID QueryCd( HKEY, PCDCONFIG );
VOID QueryPdConfig( HKEY, PPDCONFIG, PULONG );
VOID UnicodeToAnsi( CHAR *, ULONG, WCHAR * );
VOID AnsiToUnicode( WCHAR *, ULONG, CHAR * );
VOID PdConfigU2A( PPDCONFIGA, PPDCONFIGW );
VOID PdConfigA2U( PPDCONFIGW, PPDCONFIGA );
VOID WdConfigU2A( PWDCONFIGA, PWDCONFIGW );
VOID WdConfigA2U( PWDCONFIGW, PWDCONFIGA );
VOID CdConfigU2A( PCDCONFIGA, PCDCONFIGW );
VOID CdConfigA2U( PCDCONFIGW, PCDCONFIGA );
VOID WinStationCreateU2A( PWINSTATIONCREATEA, PWINSTATIONCREATEW );
VOID WinStationCreateA2U( PWINSTATIONCREATEW, PWINSTATIONCREATEA );
VOID WinStationConfigU2A( PWINSTATIONCONFIGA, PWINSTATIONCONFIGW );
VOID WinStationConfigA2U( PWINSTATIONCONFIGW, PWINSTATIONCONFIGA );
VOID SetWallPaperDisabled( HKEY, BOOLEAN );


/****************************************************************************
 *
 * DllEntryPoint
 *
 *   Function is called when the DLL is loaded and unloaded.
 *
 * ENTRY:
 *   hinstDLL (input)
 *     Handle of DLL module
 *
 *   fdwReason (input)
 *     Why function was called
 *
 *   lpvReserved (input)
 *     Reserved; must be NULL
 *
 * EXIT:
 *   TRUE  - Success
 *   FALSE - Error occurred
 *
 ****************************************************************************/

BOOL WINAPI
DllEntryPoint( HINSTANCE hinstDLL,
               DWORD     fdwReason,
               LPVOID    lpvReserved )
{
    switch ( fdwReason ) {
        case DLL_PROCESS_ATTACH:
            break;

    case DLL_PROCESS_DETACH:
            if( g_hTSPolicyKey )
            {
                RegCloseKey(g_hTSPolicyKey);
            }

            if( g_hTSControlKey )
            {
                RegCloseKey(g_hTSControlKey);
            }
            break;

        default:
            break;
    }

    return( TRUE );
}


/*******************************************************************************
 *
 *  RegWinStationAccessCheck (ANSI or UNICODE)
 *
 *     Determines if the current user has the requested access to the
 *      WinStation registry.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    samDesired (input)
 *      Specifies the security access mask to be used in determining access
 *      to the WinStation registry.
 *
 * EXIT:
 *      ERROR_SUCCESS if the user has the requested access
 *      other error value (most likely ERROR_ACCESS_DENIED) if the user does
 *      not have the requested access.
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationAccessCheck( HANDLE hServer, REGSAM samDesired )
{
    LONG Status;
    HKEY Handle;

    /*
     * Attempt to open the registry (LOCAL_MACHINE\....\Citrix\Pd)
     * at the requested access level.
     */
    if ( (Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, WINSTATION_REG_NAME, 0,
                                 samDesired, &Handle )) == ERROR_SUCCESS  )
        RegCloseKey( Handle );

    return( Status );
}


/*******************************************************************************
 *
 *  RegWinStationEnumerateA (ANSI stub)
 *
 *     Returns a list of configured WinStations in the registry.
 *
 * ENTRY:
 *    see RegWinStationEnumerateW
 *
 * EXIT:
 *    see RegWinStationEnumerateW, plus
 *
 *  ERROR_NOT_ENOUGH_MEMORY - the LocalAlloc failed
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationEnumerateA( HANDLE hServer,
                         PULONG  pIndex,
                         PULONG  pEntries,
                         PWINSTATIONNAMEA  pWinStationName,
                         PULONG  pByteCount )
{
    PWINSTATIONNAMEW pBuffer = NULL, pWinStationNameW;
    LONG Status;
    ULONG Count, ByteCountW = (*pByteCount << 1);

    /*
     * If the caller supplied a buffer and the length is not 0,
     * allocate a corresponding (*2) buffer for UNICODE strings.
     */
    if ( pWinStationName && ByteCountW )
    {
        if ( !(pBuffer = LocalAlloc(0, ByteCountW)) )
            return ( ERROR_NOT_ENOUGH_MEMORY );
    }

    /*
     * Enumerate WinStations
     */
    pWinStationNameW = pBuffer;
    Status = RegWinStationEnumerateW( hServer, pIndex, pEntries, pWinStationNameW,
                                     &ByteCountW );

    /*
     * Always /2 the resultant ByteCount (whether sucessful or not).
     */
    *pByteCount = (ByteCountW >> 1);

    /*
     * If the function completed sucessfully and caller
     * (and stub) defined a buffer to copy into, perform conversion
     * from UNICODE to ANSI.  Note: sucessful return may have copied
     * 0 items from registry (end of enumeration), denoted by *pEntries
     * == 0.
     */
    if ( ((Status == ERROR_SUCCESS) || (Status == ERROR_NO_MORE_ITEMS))
                                   && pWinStationNameW && pWinStationName ) {

        for ( Count = *pEntries; Count; Count-- ) {
            UnicodeToAnsi( pWinStationName, sizeof(WINSTATIONNAMEA),
                           pWinStationNameW );
            (char*)pWinStationName += sizeof(WINSTATIONNAMEA);
            (char*)pWinStationNameW += sizeof(WINSTATIONNAMEW);
        }
    }

    /*
     * If we defined a buffer, free it now, then return the status
     * of the Reg...EnumerateW function call.
     */
    if ( pBuffer )
        LocalFree(pBuffer);

    return ( Status );
}


/*******************************************************************************
 *
 *  RegWinStationEnumerateW (UNICODE)
 *
 *     Returns a list of configured window stations in the registry.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pIndex (input/output)
 *       Specifies the subkey index for the \Citrix\WinStations subkeys in the
 *       registry.  Should be set to 0 for the initial call, and supplied
 *       again (as modified by this function) for multi-call enumeration.
 *    pEntries (input/output)
 *       Points to a variable specifying the number of entries requested.
 *       If the number requested is 0xFFFFFFFF, the function returns as
 *       many entries as possible. When the function finishes successfully,
 *       the variable pointed to by the pEntries parameter contains the
 *       number of entries actually read.
 *    pWinStationName (input)
 *       Points to the buffer to receive the enumeration results, which are
 *       returned as an array of WINSTATIONNAME structures.  If this parameter
 *       is NULL, then no data will be copied, but just an enumeration count
 *       will be made.
 *    pByteCount (input/output)
 *       Points to a variable that specifies the size, in bytes, of the
 *       pWinStationName parameter. If the buffer is too small to receive even
 *       one entry, the function returns an error code (ERROR_OUTOFMEMORY)
 *       and this variable receives the required size of the buffer for a
 *       single subkey.  When the function finishes sucessfully, the variable
 *       pointed to by the pByteCount parameter contains the number of bytes
 *       actually stored in pWinStationName.
 *
 * EXIT:
 *
 *  "No Error" codes:
 *    ERROR_SUCCESS       - The enumeration completed as requested and there
 *                          are more WinStations subkeys (WINSTATIONNAMEs) to
 *                          be read.
 *    ERROR_NO_MORE_ITEMS - The enumeration completed as requested and there
 *                          are no more WinStations subkeys (WINSTATIONNAMEs)
 *                          to be read.
 *
 *  "Error" codes:
 *    ERROR_OUTOFMEMORY   - The pWinStationName buffer is too small for even
 *                          one entry.
 *    ERROR_CANTOPEN      - The Citrix\WinStations key can't be opened.
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationEnumerateW( HANDLE hServer,
                         PULONG  pIndex,
                         PULONG  pEntries,
                         PWINSTATIONNAMEW pWinStationName,
                         PULONG  pByteCount )
{
    LONG Status;
    HKEY Handle;
    ULONG Count;
    ULONG i;

    /*
     *  Get the number of names to return
     */
    Count = pWinStationName ?
            min( *pByteCount / sizeof(WINSTATIONNAME), *pEntries ) :
            (ULONG) -1;
    *pEntries = *pByteCount = 0;

    /*
     *  Make sure buffer is big enough for at least one name
     */
    if ( Count == 0 ) {
        *pByteCount = sizeof(WINSTATIONNAME);
        return( ERROR_OUTOFMEMORY );
    }

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\WinStations)
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, WINSTATION_REG_NAME, 0,
         KEY_ENUMERATE_SUB_KEYS, &Handle ) != ERROR_SUCCESS ) {
        goto DefaultConsole;
    }

    /*
     *  Get list of window stations
     */
    for ( i = 0; i < Count; i++ ) {
        WINSTATIONNAME WinStationName;

        if ( (Status = RegEnumKey(Handle, *pIndex, WinStationName,
                                    sizeof(WINSTATIONNAME)/sizeof(TCHAR) )) != ERROR_SUCCESS )
            break;

        /*
         * If caller supplied a buffer, then copy the WinStationName
         * and increment the pointer and byte count.  Always increment the
         * entry count and index for the next iteration.
         */
        if ( pWinStationName ) {
            wcscpy( pWinStationName, WinStationName );
            (char*)pWinStationName += sizeof(WINSTATIONNAME);
            *pByteCount += sizeof(WINSTATIONNAME);
        }
        (*pEntries)++;
        (*pIndex)++;
    }

    /*
     *  Close registry
     */
    RegCloseKey( Handle );

    if ( Status == ERROR_NO_MORE_ITEMS ) {
        if ( (*pEntries == 0) && (*pIndex == 0) )
            goto DefaultConsole;
    }
    return( Status );

    /*
     *  We come here when there are no WinStations defined.
     *  We return a default "Console" name (if pWinStationName isn't NULL).
     */
DefaultConsole:
    if ( pWinStationName )
        wcscpy( pWinStationName, L"Console" );
    *pEntries = 1;
    *pByteCount = sizeof(WINSTATIONNAME);
    return( ERROR_NO_MORE_ITEMS );
}


/*******************************************************************************
 *
 *  RegWinStationCreateA (ANSI stub)
 *
 *    Creates a new WinStaton in the registry or updates an existing entry.
 *      (See RegWinStationCreateW)
 *
 * ENTRY:
 *    see RegWinStationCreateW
 *
 * EXIT:
 *    see RegWinStationCreateW
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationCreateA( HANDLE hServer,
                      PWINSTATIONNAMEA pWinStationName,
                      BOOLEAN bCreate,
                      PWINSTATIONCONFIG2A pWinStationConfig,
                      ULONG WinStationConfigLength )
{
    WINSTATIONNAMEW WinStationNameW;
    WINSTATIONCONFIG2W WinStationConfig2W;
    int i;

    /*
     * Validate target buffer size.
     */
    if ( WinStationConfigLength < sizeof(WINSTATIONCONFIG2A) )
        return( ERROR_INSUFFICIENT_BUFFER );

    /*
     * Convert ANSI WinStationName to UNICODE.
     */
    AnsiToUnicode( WinStationNameW, sizeof(WINSTATIONNAMEW), pWinStationName );

    /*
     * Copy WINSTATIONCONFIG2A elements to WINSTATIONCONFIG2W elements.
     */
    WinStationCreateA2U( &(WinStationConfig2W.Create),
                         &(pWinStationConfig->Create) );
    for ( i=0; i<MAX_PDCONFIG; i++ ) {
        PdConfigA2U( &(WinStationConfig2W.Pd[i]),
                      &(pWinStationConfig->Pd[i]) );
    }
    WdConfigA2U( &(WinStationConfig2W.Wd),
                       &(pWinStationConfig->Wd) );
    CdConfigA2U( &(WinStationConfig2W.Cd),
                       &(pWinStationConfig->Cd) );
    WinStationConfigA2U( &(WinStationConfig2W.Config),
                         &(pWinStationConfig->Config) );

    /*
     * Call RegWinStationCreateW & return it's status.
     */
    return ( RegWinStationCreateW( hServer, WinStationNameW, bCreate,
                                   &WinStationConfig2W,
                                   sizeof(WinStationConfig2W)) );
}


/*******************************************************************************
 *
 *  RegWinStationCreateW (UNICODE)
 *
 *    Creates a new WinStaton in the registry or updates an existing entry.
 *    The state of the bCreate flag determines whether this function will
 *    expect to create a new WinStation entry (bCreate == TRUE) or expects to
 *    update an existing entry (bCreate == FALSE).
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWinStationName (input)
 *       Name of a new or exisiting window station in the registry.
 *    bCreate (input)
 *       TRUE if this is a creation of a new WinStation
 *       FALSE if this is an update to an existing WinStation
 *    pWinStationConfig (input)
 *       Pointer to a WINSTATIONCONFIG2 structure containing configuration
 *       information for the specified window station name.
 *    WinStationConfigLength (input)
 *       Specifies the length in bytes of the pWinStationConfig buffer.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *
 *    ERROR_INSUFFICIENT_BUFFER - pWinStationConfig buffer too small
 *    ERROR_FILE_NOT_FOUND - can't open ...\Citrix\WinStations key
 *    ERROR_CANNOT_MAKE - can't create WinStation key (registry problem)
 *    ERROR_ALREADY_EXISTS - create; but WinStation key already present
 *    ERROR_CANTOPEN - update; but WinStation key could not be opened
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationCreateW( HANDLE hServer,
                      PWINSTATIONNAMEW pWinStationName,
                      BOOLEAN bCreate,
                      PWINSTATIONCONFIG2W pWinStationConfig,
                      ULONG WinStationConfigLength )
{
    HKEY Handle;
    HKEY Handle1;
    DWORD Disp;

    /*
     *  Validate length of buffer
     */
    if ( WinStationConfigLength < sizeof(WINSTATIONCONFIG2) )
        return( ERROR_INSUFFICIENT_BUFFER );

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\WinStations).
     *  If it doesn't exist, we attemp to create it.
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, WINSTATION_REG_NAME, 0,
                       KEY_ALL_ACCESS, &Handle1 ) != ERROR_SUCCESS &&
         RegCreateKeyEx( HKEY_LOCAL_MACHINE, WINSTATION_REG_NAME, 0, NULL,
                         REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                         &Handle1, &Disp ) != ERROR_SUCCESS ) {
        return( ERROR_FILE_NOT_FOUND );
    }

    if ( bCreate ) {

        /*
         *  Create requested: create a registry key for the specified
         *  WinStation name.
         */
        if ( RegCreateKeyEx( Handle1, pWinStationName, 0, NULL,
                             REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                             NULL, &Handle, &Disp ) != ERROR_SUCCESS ) {
            RegCloseKey( Handle1 );
            return( ERROR_CANNOT_MAKE );
        }

        /*
         * If an existing key was returned instead of a new one being
         * created, return error (don't update).
         */
        if ( Disp != REG_CREATED_NEW_KEY ) {
            RegCloseKey( Handle1 );
            RegCloseKey( Handle );
            return( ERROR_ALREADY_EXISTS );
        }

    } else {

        /*
         *  Update requested: open the registry key for the specified
         *  WinStation name.
         */
        if ( RegOpenKeyEx( Handle1, pWinStationName, 0, KEY_ALL_ACCESS,
                           &Handle ) != ERROR_SUCCESS ) {
            RegCloseKey( Handle1 );
            return( ERROR_CANTOPEN );
        }
    }

    RegCloseKey( Handle1 );

    /*
     *  Save WINSTATIONCONFIG2 Structure
     */
    CreateWinStaCreate( Handle, &pWinStationConfig->Create );
    CreatePdConfig( bCreate, Handle, pWinStationConfig->Pd, MAX_PDCONFIG );
    CreateWd( Handle, &pWinStationConfig->Wd );
    CreateCd( Handle, &pWinStationConfig->Cd );
    CreateConfig( Handle, &pWinStationConfig->Config );

    /*
     *  Close registry handle
     */
    RegCloseKey( Handle );

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegWinStationQueryA (ANSI stub)
 *
 *    Query configuration information of a window station in the registry.
 *
 * ENTRY:
 *    see RegWinStationQueryW
 *
 * EXIT:
 *    see RegWinStationQueryW
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationQueryA( HANDLE hServer,
                     PWINSTATIONNAMEA pWinStationName,
                     PWINSTATIONCONFIG2A pWinStationConfig,
                     ULONG WinStationConfigLength,
                     PULONG pReturnLength )
{
    WINSTATIONNAMEW WinStationNameW;
    WINSTATIONCONFIG2W WinStationConfig2W;
    LONG Status;
    ULONG ReturnLengthW;
    int i;

    /*
     * Validate length and zero-initialize the destination
     * WINSTATIONCONFIG2A structure.
     */
    if ( WinStationConfigLength < sizeof(WINSTATIONCONFIG2A) )
        return( ERROR_INSUFFICIENT_BUFFER );
    memset(pWinStationConfig, 0, WinStationConfigLength);

    /*
     * Convert ANSI WinStationName to UNICODE.
     */
    AnsiToUnicode( WinStationNameW, sizeof(WINSTATIONNAMEW), pWinStationName );

    /*
     * Query WinStation.
     */
    if ( (Status = RegWinStationQueryW( hServer,
                                        WinStationNameW,
                                        &WinStationConfig2W,
                                        sizeof(WINSTATIONCONFIG2W),
                                        &ReturnLengthW)) != ERROR_SUCCESS )
        return ( Status );

    /*
     * Copy WINSTATIONCONFIG2W elements to WINSTATIONCONFIG2A elements.
     */
    WinStationCreateU2A( &(pWinStationConfig->Create),
                         &(WinStationConfig2W.Create) );
    for ( i=0; i<MAX_PDCONFIG; i++ ) {
        PdConfigU2A( &(pWinStationConfig->Pd[i]),
                      &(WinStationConfig2W.Pd[i]) );
    }
    WdConfigU2A( &(pWinStationConfig->Wd),
                       &(WinStationConfig2W.Wd) );
    CdConfigU2A( &(pWinStationConfig->Cd),
                       &(WinStationConfig2W.Cd) );
    WinStationConfigU2A( &(pWinStationConfig->Config),
                         &(WinStationConfig2W.Config) );

    *pReturnLength = sizeof(WINSTATIONCONFIG2A);

    return( ERROR_SUCCESS );
}



/*******************************************************************************
 *
 *
 *
 *  RegWinStationQueryEx (UNICODE)
 *
 *  USE THIS CALL if you are in TermSrv.DLL, since it will update the global policy object
 *
 *  Same as RegWinStationQueryW with the excpetion that a pointer to a global policy object is passed in.
 *
 *    Query configuration information of a window station in the registry.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pMachinePolicy (input)
 *      pointer to a gloabl machine policy struct
 *    pWinStationName (input)
 *       Name of an exisiting window station in the registry.
 *    pWinStationConfig (input)
 *       Pointer to a WINSTATIONCONFIG2 structure that will receive
 *       information about the specified window station name.
 *    WinStationConfigLength (input)
 *       Specifies the length in bytes of the pWinStationConfig buffer.
 *    pReturnLength (output)
 *       Receives the number of bytes placed in the pWinStationConfig buffer.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationQueryEx( HANDLE hServer,
                     PPOLICY_TS_MACHINE     pMachinePolicy,
                     PWINSTATIONNAMEW pWinStationName,
                     PWINSTATIONCONFIG2W pWinStationConfig,
                     ULONG WinStationConfigLength,
                     PULONG pReturnLength,
                     BOOLEAN bPerformMerger)
{
    LONG Status;
    HKEY Handle;
    ULONG Count;

    /*
     * Validate length and zero-initialize the destination
     * WINSTATIONCONFIG2W buffer.
     */
    if ( WinStationConfigLength < sizeof(WINSTATIONCONFIG2) )
        return( ERROR_INSUFFICIENT_BUFFER );
    memset(pWinStationConfig, 0, WinStationConfigLength);

    /*
     *  Open registry
     */
    Status = _RegOpenWinStation( pWinStationName, KEY_READ, &Handle );
    if ( Status )
        Handle = 0;

    /*
     *  Query WINSTATIONCONFIG2 Structure
     */
    QueryWinStaCreate( Handle, &pWinStationConfig->Create );
    Count = MAX_PDCONFIG;
    QueryPdConfig( Handle, pWinStationConfig->Pd, &Count );
    QueryWd( Handle, &pWinStationConfig->Wd );
    QueryCd( Handle, &pWinStationConfig->Cd );

    // This will populate the winstation's userconfig data with machine's version of that data.
    QueryConfig( Handle, &pWinStationConfig->Config );

    // Since we want to co-exist with the legacy path thru TSCC, we continue to call QueryConfig()
    // as we have done above, however, we follow up with a call that get's data from the group policy
    // tree, and then overrides the existing data (aquired above) by the specific data from group policy.
    RegGetMachinePolicy( pMachinePolicy );

    if (bPerformMerger)
        RegMergeMachinePolicy( pMachinePolicy, &pWinStationConfig->Config.User , &pWinStationConfig->Create );

    /*
     *  Close registry
     */
    if ( Status == ERROR_SUCCESS )
        RegCloseKey( Handle );

    *pReturnLength = sizeof(WINSTATIONCONFIG2);

    return( ERROR_SUCCESS );
}



/*******************************************************************************
 *
 *  RegWinStationQueryW (UNICODE)
 *
 *    Query configuration information of a window station in the registry.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWinStationName (input)
 *       Name of an exisiting window station in the registry.
 *    pWinStationConfig (input)
 *       Pointer to a WINSTATIONCONFIG2 structure that will receive
 *       information about the specified window station name.
 *    WinStationConfigLength (input)
 *       Specifies the length in bytes of the pWinStationConfig buffer.
 *    pReturnLength (output)
 *       Receives the number of bytes placed in the pWinStationConfig buffer.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationQueryW( HANDLE hServer,
                     PWINSTATIONNAMEW pWinStationName,
                     PWINSTATIONCONFIG2W pWinStationConfig,
                     ULONG WinStationConfigLength,
                     PULONG pReturnLength )
{
    LONG Status;
    HKEY Handle;
    ULONG Count;
    
    POLICY_TS_MACHINE   MachinePolicy;

    /*
     * Validate length and zero-initialize the destination
     * WINSTATIONCONFIG2W buffer.
     */
    if ( WinStationConfigLength < sizeof(WINSTATIONCONFIG2) )
        return( ERROR_INSUFFICIENT_BUFFER );
    memset(pWinStationConfig, 0, WinStationConfigLength);

    /*
     *  Open registry
     */
    Status = _RegOpenWinStation( pWinStationName, KEY_READ, &Handle );
    if ( Status )
        Handle = 0;

    /*
     *  Query WINSTATIONCONFIG2 Structure
     */
    QueryWinStaCreate( Handle, &pWinStationConfig->Create );
    Count = MAX_PDCONFIG;
    QueryPdConfig( Handle, pWinStationConfig->Pd, &Count );
    QueryWd( Handle, &pWinStationConfig->Wd );
    QueryCd( Handle, &pWinStationConfig->Cd );

    // This will populate the winstation's userconfig data with machine's version of that data.
    QueryConfig( Handle, &pWinStationConfig->Config );

    // Since we want to co-exist with the legacy path thru TSCC, we continue to call QueryConfig()
    // as we have done above, however, we follow up with a call that get's data from the group policy
    // tree, and then overrides the existing data (aquired above) by the specific data from group policy.
    RegGetMachinePolicy( & MachinePolicy );
    RegMergeMachinePolicy(  & MachinePolicy, &pWinStationConfig->Config.User , &pWinStationConfig->Create );

    /*
     *  Close registry
     */
    if ( Status == ERROR_SUCCESS )
        RegCloseKey( Handle );

    *pReturnLength = sizeof(WINSTATIONCONFIG2);

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegConsoleShadowQueryA (ANSI stub)
 *
 *    Query configuration information for the console shadow in the registry.
 *
 * ENTRY:
 *    see RegConsoleShadowQueryW
 *
 * EXIT:
 *    see RegConsoleShadowQueryW
 *
 ******************************************************************************/

LONG WINAPI
RegConsoleShadowQueryA( HANDLE hServer,
                     PWINSTATIONNAMEA pWinStationName,
                     PWDPREFIXA pWdPrefixName,
                     PWINSTATIONCONFIG2A pWinStationConfig,
                     ULONG WinStationConfigLength,
                     PULONG pReturnLength )
{
    WINSTATIONNAMEW WinStationNameW;
    WDPREFIXW WdPrefixNameW;
    WINSTATIONCONFIG2W WinStationConfig2W;
    LONG Status;
    ULONG ReturnLengthW;
    int i;

    /*
     * Validate length and zero-initialize the destination
     * WINSTATIONCONFIG2A structure.
     */
    if ( WinStationConfigLength < sizeof(WINSTATIONCONFIG2A) )
        return( ERROR_INSUFFICIENT_BUFFER );

    /*
     * Convert ANSI WinStationName and prefix name to UNICODE.
     */
    AnsiToUnicode( WinStationNameW, sizeof(WINSTATIONNAMEW), pWinStationName );
    AnsiToUnicode( WdPrefixNameW, sizeof(WDPREFIXW), pWdPrefixName );

    /*
     * Query WinStation.
     */
    if ( (Status = RegConsoleShadowQueryW( hServer,
                                        WinStationNameW,
                                        WdPrefixNameW,
                                        &WinStationConfig2W,
                                        sizeof(WINSTATIONCONFIG2W),
                                        &ReturnLengthW)) != ERROR_SUCCESS )
        return ( Status );

    /*
     * Copy WINSTATIONCONFIG2W elements to WINSTATIONCONFIG2A elements.
     */
    for ( i=0; i<MAX_PDCONFIG; i++ ) {
        PdConfigU2A( &(pWinStationConfig->Pd[i]),
                      &(WinStationConfig2W.Pd[i]) );
    }
    WdConfigU2A( &(pWinStationConfig->Wd),
                       &(WinStationConfig2W.Wd) );
    CdConfigU2A( &(pWinStationConfig->Cd),
                       &(WinStationConfig2W.Cd) );

    *pReturnLength = sizeof(WINSTATIONCONFIG2A);

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegConsoleShadowQueryW (UNICODE)
 *
 *    Query configuration information for the console shadow in the registry.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWinStationName (input)
 *       Name of an exisiting window station in the registry.
 *    pWdPrefixName (input)
 *       Name of the Wd prefix used to point to the sub-winstation key.
 *    pWinStationConfig (input)
 *       Pointer to a WINSTATIONCONFIG2 structure that will receive
 *       information about the specified window station name.
 *    WinStationConfigLength (input)
 *       Specifies the length in bytes of the pWinStationConfig buffer.
 *    pReturnLength (output)
 *       Receives the number of bytes placed in the pWinStationConfig buffer.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegConsoleShadowQueryW( HANDLE hServer,
                     PWINSTATIONNAMEW pWinStationName,
                     PWDPREFIXW pWdPrefixName,
                     PWINSTATIONCONFIG2W pWinStationConfig,
                     ULONG WinStationConfigLength,
                     PULONG pReturnLength )
{
    LONG Status;
    LONG lLength;
    HKEY Handle;
    ULONG Count;
    WCHAR szRegName[ WINSTATIONNAME_LENGTH + WDPREFIX_LENGTH + 2 ];
    
    /*
     * Validate length and zero-initialize the destination
     * WINSTATIONCONFIG2W buffer.
     */
    if ( WinStationConfigLength < sizeof(WINSTATIONCONFIG2) )
        return( ERROR_INSUFFICIENT_BUFFER );

    /*
     *  Open registry
     */
    wcsncpy( szRegName, pWinStationName, sizeof(szRegName)/sizeof(WCHAR) - 1 );
    szRegName[sizeof(szRegName)/sizeof(WCHAR) - 1] = 0; // terminate the string even if pWinStationName is longer than the buffer

    lLength = wcslen( szRegName );

    if ( sizeof(szRegName)/sizeof(WCHAR) > ( lLength + 1 + wcslen( pWdPrefixName ) ) ) {

        wcsncat( szRegName, L"\\", sizeof(szRegName)/sizeof(WCHAR) - lLength - 1 );
        wcsncat( szRegName, pWdPrefixName, sizeof(szRegName)/sizeof(WCHAR) - lLength - 2 );

    } else {
        return ERROR_INVALID_PARAMETER;
    }

    Status = _RegOpenWinStation( szRegName, KEY_READ, &Handle );

    if ( Status )
        Handle = 0;

    /*
     *  Query WINSTATIONCONFIG2 Structure
     */
    Count = MAX_PDCONFIG;
    QueryPdConfig( Handle, pWinStationConfig->Pd, &Count );
    QueryWd( Handle, &pWinStationConfig->Wd );
    QueryCd( Handle, &pWinStationConfig->Cd );

    /*
     *  Close registry
     */
    if ( Status == ERROR_SUCCESS )
        RegCloseKey( Handle );

    *pReturnLength = sizeof(WINSTATIONCONFIG2);

    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  RegWinStationDeleteA (ANSI stub)
 *
 *    Deletes a window station from the registry.
 *
 * ENTRY:
 *    see RegWinStationDeleteW
 *
 * EXIT:
 *    see RegWinStationDeleteW
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationDeleteA( HANDLE hServer, PWINSTATIONNAMEA pWinStationName )
{
    WINSTATIONNAMEW WinStationNameW;

    AnsiToUnicode( WinStationNameW, sizeof(WinStationNameW), pWinStationName );

    return ( RegWinStationDeleteW ( hServer, WinStationNameW ) );
}


/*******************************************************************************
 *
 *  RegWinStationDeleteW (UNICODE)
 *
 *    Deletes a window station from the registry.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWinStationName (input)
 *       Name of a window station to delete from the registry.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationDeleteW( HANDLE hServer, PWINSTATIONNAMEW pWinStationName )
{
    LONG Status;
    HKEY Handle1, Handle2;

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\WinStations).
     */
    if ( (Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                WINSTATION_REG_NAME, 0,
                                KEY_ALL_ACCESS, &Handle1 )
                                                != ERROR_SUCCESS) ) {
        return( Status );
    }

    /*
     *  Open the registry key for the specified WinStation name.
     */
    if ( (Status = RegOpenKeyEx( Handle1, pWinStationName, 0,
                                 KEY_ALL_ACCESS, &Handle2 )
                                                != ERROR_SUCCESS) ) {
        RegCloseKey( Handle1 );
        return( Status );
    }
    SetWallPaperDisabled( Handle2, FALSE );

    /*
     * Close the WinStation key handle just opened (so we can delete key),
     * delete the key, and close the Citrix registry handle.
     */
    RegCloseKey( Handle2 );
    Status = RegDeleteKey( Handle1, pWinStationName );
    RegCloseKey( Handle1 );

    return( Status );
}


/*******************************************************************************
 *
 *  RegWinStationSetSecurityA (ANSI stub)
 *
 *    Sets security info for the specified WinStation.
 *
 * ENTRY:
 *    see RegWinStationSetSecurityW
 *
 * EXIT:
 *    see RegWinStationSetSecurityW
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationSetSecurityA( HANDLE hServer,
                           PWINSTATIONNAMEA pWinStationName,
                           PSECURITY_DESCRIPTOR SecurityDescriptor,
                           ULONG Length )
{
    WINSTATIONNAMEW WinStationNameW;

    AnsiToUnicode( WinStationNameW, sizeof(WinStationNameW), pWinStationName );

    return ( RegWinStationSetSecurityW( hServer, WinStationNameW,
                                        SecurityDescriptor,
                                        Length ) );
}


/*******************************************************************************
 *
 *  RegWinStationSetSecurityW (UNICODE)
 *
 *    Sets security info for the specified WinStation.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWinStationName (input)
 *       Name of a window station to set security for.
 *    pSecurityDescriptor (input)
 *       Pointer to Security Descriptor to save
 *    Length (input)
 *       Length of SecurityDescriptor above
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationSetSecurityW( HANDLE hServer,
                           PWINSTATIONNAMEW pWinStationName,
                           PSECURITY_DESCRIPTOR SecurityDescriptor,
                           ULONG Length )
{
    HKEY Handle;
    ULONG SrLength;
    PSECURITY_DESCRIPTOR SrSecurityDescriptor;
    LONG Error;
    NTSTATUS Status;

    /*
     *  Open registry
     */
    if ( Error = _RegOpenWinStation( pWinStationName, KEY_ALL_ACCESS, &Handle ) )
        return( Error );

    /*
     * Determine buffer length needed to convert SD to self-relative format.
     */
    SrLength = 0;
    Status = RtlMakeSelfRelativeSD( SecurityDescriptor, NULL, &SrLength );
    if ( Status != STATUS_BUFFER_TOO_SMALL ) {
        RegCloseKey( Handle );
        return( RtlNtStatusToDosError( Status ) );
    }

    /*
     * Allocate buffer for self-relative SD.
     */
    SrSecurityDescriptor = LocalAlloc( 0, SrLength );
    if ( SrSecurityDescriptor == NULL ) {
        RegCloseKey( Handle );
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    /*
     * Now convert SD to self-relative format.
     */
    Status = RtlMakeSelfRelativeSD( SecurityDescriptor,
                                    SrSecurityDescriptor, &SrLength );
    if ( !NT_SUCCESS( Status ) ) {
        LocalFree( SrSecurityDescriptor );
        RegCloseKey( Handle );
        return( RtlNtStatusToDosError( Status ) );
    }

    /*
     * Save the security data
     */
    Error = RegSetValueEx( Handle, L"Security", 0, REG_BINARY,
                           (BYTE *)SrSecurityDescriptor, SrLength );

    /*
     * Free memory used for Self-relative Security Descriptor
     */
    LocalFree( SrSecurityDescriptor );

    /*
     *  Close registry
     */
    RegCloseKey( Handle );

    return( Error );
}


/*******************************************************************************
 *
 *  RegWinStationQuerySecurityA (ANSI stub)
 *
 *    Query security info for the specified WinStation.
 *
 * ENTRY:
 *    see RegWinStationQuerySecurityW
 *
 * EXIT:
 *    see RegWinStationQuerySecurityW
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationQuerySecurityA( HANDLE hServer,
                             PWINSTATIONNAMEA pWinStationName,
                             PSECURITY_DESCRIPTOR SecurityDescriptor,
                             ULONG Length,
                             PULONG ReturnLength )
{
    WINSTATIONNAMEW WinStationNameW;

    AnsiToUnicode( WinStationNameW, sizeof(WinStationNameW), pWinStationName );

    return ( RegWinStationQuerySecurityW( hServer, WinStationNameW,
                                        SecurityDescriptor,
                                        Length,
                                        ReturnLength ) );
}


/*******************************************************************************
 *
 *  RegWinStationQuerySecurityW (UNICODE)
 *
 *    Query security info for the specified WinStation.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWinStationName (input)
 *       Name of a window station to query security for.
 *    pSecurityDescriptor (output)
 *       Pointer to location to return SecurityDescriptor.
 *    Length (input)
 *       Length of SecurityDescriptor buffer.
 *    ReturnLength (output)
 *       Pointer to location to return length of SecurityDescriptor returned.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationQuerySecurityW( HANDLE hServer,
                             PWINSTATIONNAMEW pWinStationName,
                             PSECURITY_DESCRIPTOR SecurityDescriptor,
                             ULONG Length,
                             PULONG ReturnLength )
{
    HKEY Handle;
    LONG Error;

    /*
     * Open registry
     */
    if ( Error = _RegOpenWinStation( pWinStationName, KEY_READ, &Handle ) )
        return( Error );

    /*
     * Call RegGetWinStationSecurity() to do all the work
     */
    Error = _RegGetWinStationSecurity( Handle, L"Security",
                                       SecurityDescriptor, Length, ReturnLength );

    RegCloseKey( Handle );
    return( Error );
}


/*******************************************************************************
 *
 *  RegWinStationQueryDefaultSecurity
 *
 *    Query default WinStation security.
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pSecurityDescriptor (output)
 *       Pointer to location to return SecurityDescriptor.
 *    Length (input)
 *       Length of SecurityDescriptor buffer.
 *    ReturnLength (output)
 *       Pointer to location to return length of SecurityDescriptor returned.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationQueryDefaultSecurity( HANDLE hServer,
                                   PSECURITY_DESCRIPTOR SecurityDescriptor,
                                   ULONG Length,
                                   PULONG ReturnLength )
{
    HKEY Handle;
    LONG Error;

    /*
     * Open registry
     */
    if ( Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE, WINSTATION_REG_NAME, 0,
                               KEY_READ, &Handle ) )
        return( Error );

    /*
     * Call RegGetWinStationSecurity() to do all the work
     */
    Error = _RegGetWinStationSecurity( Handle, L"DefaultSecurity",
                                       SecurityDescriptor, Length, ReturnLength );

    RegCloseKey( Handle );
    return( Error );
}


/*******************************************************************************
 *
 *  RegWinStationSetNumValueW (UNICODE)
 *
 *    Set numeric value in WinStation registry configuration
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWinStationName (input)
 *       Name of a window station to modify from the registry.
 *    pValueName (input)
 *       name of registry value to set
 *    ValueData (input)
 *       data (DWORD) for registry value to set
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationSetNumValueW( HANDLE hServer,
                           PWINSTATIONNAMEW pWinStationName,
                           LPWSTR pValueName,
                           ULONG ValueData )
{
    HKEY Handle;
    LONG Error;

    /*
     *  Open registry
     */
    if ( Error = _RegOpenWinStation( pWinStationName, KEY_ALL_ACCESS, &Handle ) )
        return( Error );

    /*
     *  Set the numeric value
     */
    Error = RegSetValueEx( Handle, pValueName, 0, REG_DWORD,
                           (BYTE *)&ValueData, sizeof(DWORD) );

    /*
     *  Close registry
     */
    RegCloseKey( Handle );

    return( Error );
}


/*******************************************************************************
 *
 *  RegWinStationQueryNumValueW (UNICODE)
 *
 *    Query numeric value from WinStation registry configuration
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWinStationName (input)
 *       Name of a window station to modify from the registry.
 *    pValueName (input)
 *       name of registry value to set
 *    pValueData (output)
 *       address to return data (DWORD) value from registry
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationQueryNumValueW( HANDLE hServer,
                             PWINSTATIONNAMEW pWinStationName,
                             LPWSTR pValueName,
                             PULONG pValueData )
{
    DWORD ValueSize = sizeof(DWORD);
    DWORD ValueType;
    HKEY Handle;
    LONG Error;

    /*
     *  Open registry
     */
    if ( Error = _RegOpenWinStation( pWinStationName, KEY_READ, &Handle ) )
        return( Error );

    /*
     *  Query the numeric value
     */
    Error = RegQueryValueEx( Handle, pValueName, NULL, &ValueType,
                             (LPBYTE) pValueData, &ValueSize );

    /*
     *  Close registry
     */
    RegCloseKey( Handle );

    return( Error );
}

/*******************************************************************************
 *
 *  RegWinStationQueryValueW (UNICODE)
 *
 *    Query value from WinStation registry configuration
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWinStationName (input)
 *       Name of a window station to modify from the registry.
 *    pValueName (input)
 *       name of registry value to set
 *    pValueData (output)
 *       address to return data (DWORD) value from registry
 *    ValueSize (input)
 *       size of value buffer
 *    pValueSize (input)
 *       actual value size
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG WINAPI
RegWinStationQueryValueW( HANDLE hServer,
                             PWINSTATIONNAMEW pWinStationName,
                             LPWSTR pValueName,
                             PVOID  pValueData,
                             ULONG  ValueSize,
                             PULONG pValueSize )
{
    DWORD ValueType;
    HKEY Handle;
    LONG Error;

    *pValueSize = ValueSize;

    /*
     *  Open registry
     */
    if ( Error = _RegOpenWinStation( pWinStationName, KEY_READ, &Handle ) )
        return( Error );

    /*
     *  Query the numeric value
     */
    Error = RegQueryValueEx( Handle, pValueName, NULL, &ValueType,
                             (LPBYTE) pValueData, pValueSize );

    /*
     *  Close registry
     */
    RegCloseKey( Handle );

    return( Error );
}

/*******************************************************************************
 *
 *  -- private routine --
 *
 *  _RegOpenWinStation
 *
 *    open registry of specified winstation
 *
 *    NOTE: handle must be closed with "RegCloseKey"
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to WinFrame Server
 *    pWinStationName (input)
 *       Name of a window station to modify from the registry.
 *    samDesired (input)
 *       REGSAM access level for registry open.
 *    pHandle (output)
 *       address to return handle
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG
_RegOpenWinStation( PWINSTATIONNAMEW pWinStationName,
                   REGSAM samDesired,
                   HKEY * pHandle )

{
    HKEY Handle1;
    LONG Error;

    /*
     *  Open registry (LOCAL_MACHINE\....\Citrix\WinStations).
     */
    if ( (Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE, WINSTATION_REG_NAME, 0,
                                samDesired, &Handle1 ) != ERROR_SUCCESS) ) {
        return( Error );
    }

    /*
     *  Open the registry key for the specified WinStation name.
     */
    Error = RegOpenKeyEx( Handle1, pWinStationName, 0, samDesired, pHandle);

    RegCloseKey( Handle1 );

    return( Error );
}


/*******************************************************************************
 *
 *  -- private routine --
 *
 *  _RegGetWinStationSecurity
 *
 *    Query the security descriptor from the specified registry key.
 *
 * ENTRY:
 *    Handle (input)
 *       Open registry key handle.
 *    ValueName (input)
 *       Name of security value.
 *    pSecurityDescriptor (output)
 *       Pointer to location to return SecurityDescriptor.
 *    Length (input)
 *       Length of SecurityDescriptor buffer.
 *    ReturnLength (output)
 *       Pointer to location to return length of SecurityDescriptor returned.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *      otherwise: the error code
 *
 ******************************************************************************/

LONG
_RegGetWinStationSecurity( HKEY Handle,
                           LPWSTR ValueName,
                           PSECURITY_DESCRIPTOR SecurityDescriptor,
                           ULONG Length,
                           PULONG ReturnLength )
{
    DWORD ValueType;
    DWORD SrLength;
    ULONG SdSize, DaclSize, SaclSize, OwnerSize, GroupSize;
    PSECURITY_DESCRIPTOR SrSecurityDescriptor;
    PACL pDacl, pSacl;
    PSID pOwner, pGroup;
    LONG Error;
    NTSTATUS Status;

    /*
     * Query the length of the Security value
     */
    SrLength = 0;
    if ( Error = RegQueryValueEx( Handle, ValueName, NULL, &ValueType,
                                  NULL, &SrLength ) ) {
        return( Error );
    }

    /*
     * Return error if not correct data type
     */
    if ( ValueType != REG_BINARY ) {
        return( ERROR_FILE_NOT_FOUND );
    }

    /*
     * Allocate a buffer to read the Security info and read it
     */
    SrSecurityDescriptor = LocalAlloc( 0, SrLength );
    if ( SrSecurityDescriptor == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }
    if ( Error = RegQueryValueEx( Handle, ValueName, NULL, &ValueType,
                                  SrSecurityDescriptor, &SrLength ) ) {
        LocalFree( SrSecurityDescriptor );
        return( Error );
    }

    /*
     * Determine amount of space required to convert SD from
     * self-relative format to absolute format.
     */
    SdSize = DaclSize = SaclSize = OwnerSize = GroupSize = 0;
    Status = RtlSelfRelativeToAbsoluteSD( SrSecurityDescriptor,
                                          NULL, &SdSize,
                                          NULL, &DaclSize,
                                          NULL, &SaclSize,
                                          NULL, &OwnerSize,
                                          NULL, &GroupSize );
    if ( Status != STATUS_BUFFER_TOO_SMALL ) {
        LocalFree( SrSecurityDescriptor );
        return( RtlNtStatusToDosError( Status ) );
    }
    *ReturnLength = SdSize + DaclSize + SaclSize + OwnerSize + GroupSize;

    /*
     * If required size is greater than callers buffer size, then return
     */
    if ( *ReturnLength > Length ) {
        LocalFree( SrSecurityDescriptor );
        return( ERROR_INSUFFICIENT_BUFFER );
    }

    pDacl = (PACL)((PCHAR)SecurityDescriptor + SdSize);
    pSacl = (PACL)((PCHAR)pDacl + DaclSize);
    pOwner = (PSID)((PCHAR)pSacl + SaclSize);
    pGroup = (PSID)((PCHAR)pOwner + OwnerSize);

    /*
     * Now convert self-relative SD to absolute format.
     */
    Status = RtlSelfRelativeToAbsoluteSD( SrSecurityDescriptor,
                                          SecurityDescriptor, &SdSize,
                                          pDacl, &DaclSize,
                                          pSacl, &SaclSize,
                                          pOwner, &OwnerSize,
                                          pGroup, &GroupSize );
    if ( !NT_SUCCESS( Status ) )
        Error = RtlNtStatusToDosError( Status );

    /*
     * Free memory used for Self-relative Security Descriptor
     */
    LocalFree( SrSecurityDescriptor );

    return( Error );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\regapi\salem.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    salem.cpp

Abstract:

    All Salem related function, this library is shared by termsrv.dll
    and salem sessmgr.exe

Author:


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <lm.h>
#include <winsta.h>
#include "regapi.h"

extern "C" {

BOOLEAN
RegIsMachinePolicyAllowHelp();

BOOLEAN
RegIsMachineInHelpMode();
}


DWORD
GetPolicyAllowGetHelpSetting( 
    HKEY hKey,
    LPCTSTR pszKeyName,
    LPCTSTR pszValueName,
    IN DWORD* value
    )
/*++

Routine Description:

    Routine to query policy registry value.

Parameters:

    hKey : Currently open registry key.
    pszKeyName : Pointer to a null-terminated string containing 
                 the name of the subkey to open. 
    pszValueName : Pointer to a null-terminated string containing 
                   the name of the value to query
    value : Pointer to DWORD to receive GetHelp policy setting.

Returns:

    ERROR_SUCCESS or error code from RegOpenKeyEx().

--*/
{
    DWORD dwStatus;
    HKEY hPolicyKey = NULL;
    DWORD dwType;
    DWORD cbData;

    //
    // Open registry key for system policy
    //
    dwStatus = RegOpenKeyEx(
                        hKey,
                        pszKeyName,
                        0,
                        KEY_READ,
                        &hPolicyKey
                    );

    if( ERROR_SUCCESS == dwStatus )
    {
        // query value
        cbData = 0;
        dwType = 0;
        dwStatus = RegQueryValueEx(
                                hPolicyKey,
                                pszValueName,
                                NULL,
                                &dwType,
                                NULL,
                                &cbData
                            );

        if( ERROR_SUCCESS == dwStatus )
        {
            if( REG_DWORD == dwType )
            {
                cbData = sizeof(DWORD);

                // our registry value is REG_DWORD, if different type,
                // assume not exist.
                dwStatus = RegQueryValueEx(
                                        hPolicyKey,
                                        pszValueName,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)value,
                                        &cbData
                                    );

                ASSERT( ERROR_SUCCESS == dwStatus );
            }
            else
            {
                // bad registry key type, assume
                // key does not exist.
                dwStatus = ERROR_FILE_NOT_FOUND;
            }               
        }

        RegCloseKey( hPolicyKey );
    }

    return dwStatus;
}        


BOOLEAN
RegIsMachinePolicyAllowHelp()
/*++

Routine Description:

    Check if 'GetHelp' is enabled on local machine, routine first query 
    system policy registry key, if policy is not set, then read salem
    specific registry.  Default to 'enable' is registry value does not
    exist.

Parameters:

    None.

Returns:

    TRUE/FALSE

--*/
{
    DWORD dwStatus;
    DWORD dwValue = 0;

    //
    // Open system policy registry key, if registry key/value
    // does not exist, assume it is enable and continue on
    // to local policy key.
    //
    dwStatus = GetPolicyAllowGetHelpSetting(
                                    HKEY_LOCAL_MACHINE,
                                    TS_POLICY_SUB_TREE,
                                    POLICY_TS_REMDSK_ALLOWTOGETHELP,
                                    &dwValue
                                );

    if( ERROR_SUCCESS != dwStatus )
    {
        //
        // For local machine policy, our default value is
        // Not Allow to get help if registry key is not there
        //
        dwStatus = GetPolicyAllowGetHelpSetting(
                                            HKEY_LOCAL_MACHINE,
                                            REG_CONTROL_GETHELP, 
                                            POLICY_TS_REMDSK_ALLOWTOGETHELP,
                                            &dwValue
                                        );

        if( ERROR_SUCCESS != dwStatus )
        {
            //
            // neither group policy nor machine policy has
            // set any value, default to disable.
            //
            dwValue = 0;
        }
    }
    
    return (dwValue == 1);
}

BOOLEAN
RegIsMachineInHelpMode()
/*++

Routine Description:

    Check if 'InHelpMode' is set on local machine.
    Default to FALSE  if registry value does not exist.

Parameters:

    None.

Returns:

    TRUE/FALSE

--*/
{
    DWORD dwStatus;
    DWORD dwValue = 0;

    //
    // The default value is NotInHelp if registry key is not there
    //
    dwStatus = GetPolicyAllowGetHelpSetting(
                                        HKEY_LOCAL_MACHINE,
                                        REG_CONTROL_TSERVER, 
                                        REG_MACHINE_IN_HELP_MODE,
                                        &dwValue
                                    );

    if( ERROR_SUCCESS != dwStatus )
    {
        //
        // The value is not set, default to disable.
        //
        dwValue = 0;
    }
    
    return (dwValue == 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\regapi\regup.c ===
/*************************************************************************
*
* reguc.c
*
* Registry APIs for SAM-based user configuration data
*
* Copyright (c) 1998 Microsoft Corporation
*
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <lm.h>

#include <ntddkbd.h>
#include <ntddmou.h>
#include <winstaw.h>
#include <regapi.h>
#include <regsam.h>

#include <rpc.h>
#include <rpcdce.h>
#include <ntdsapi.h>
// For more info, check out \\index1\src\nt\private\security\tools\delegate\ldap.c

#include "usrprop.h"

/*
 *  !!! WARNING !!! WARNING !!!
 *
 *  A lot of time could be spent on making this calculation accurate and
 *  automatic, but time is of the essence.  So a brute force
 *  approach is used.  The size of the User Configuration section that
 *  Citrix is going to add to the User Parameters is based on NOT
 *  ONLY the size of the USERCONFIG structure, but must account for the
 *  Value names and the buffer management pointers as well, since the
 *  User Parameters section is a linear buffer that holds CITRIX data
 *  and Microsoft Services for Netware data.
 *
 *  It is assumed that the overhead of the value name strings and
 *  the buffer management pointers will NOT be greater than twice the
 *  maximum data size.  If this assumption is false, buffer overruns
 *  will occur.
 *
 *  Bruce Fortune. 1/31/97.
 */
#define CTX_USER_PARAM_MAX_SIZE (3 * sizeof(USERCONFIG))

/*
 *  CTXPREFIX is the prefix for all value names placed in the User
 *  Parameters section of the SAM.  This is a defensive measure since
 *  this section of the SAM is shared with MS Services for Netware.
 */
#define CTXPREFIX L"Ctx"

/*
 *  WIN_FLAGS1 is the name of the Flags value that is used to hold
 *  all of the F1MSK_... flags defined below.  This is done in order to
 *  reduce the amount of space required in the User Parameters section
 *  of the SAM, since the value name of each flag is eliminated.
 */
#define WIN_FLAGS1 L"CfgFlags1"

/*
 *  WIN_CFGPRESENT is used to indicate that the Citrix configuration
 *  information is present in the User Parameters section of the user's
 *  SAM record.
 */
#define WIN_CFGPRESENT L"CfgPresent"
#define CFGPRESENT_VALUE 0xB00B1E55

#define F1MSK_INHERITAUTOLOGON            0x80000000
#define F1MSK_INHERITRESETBROKEN          0x40000000
#define F1MSK_INHERITRECONNECTSAME        0x20000000
#define F1MSK_INHERITINITIALPROGRAM       0x10000000
#define F1MSK_INHERITCALLBACK             0x08000000
#define F1MSK_INHERITCALLBACKNUMBER       0x04000000
#define F1MSK_INHERITSHADOW               0x02000000
#define F1MSK_INHERITMAXSESSIONTIME       0x01000000
#define F1MSK_INHERITMAXDISCONNECTIONTIME 0x00800000
#define F1MSK_INHERITMAXIDLETIME          0x00400000
#define F1MSK_INHERITAUTOCLIENT           0x00200000
#define F1MSK_INHERITSECURITY             0x00100000
#define F1MSK_PROMPTFORPASSWORD           0x00080000
#define F1MSK_RESETBROKEN                 0x00040000
#define F1MSK_RECONNECTSAME               0x00020000
#define F1MSK_LOGONDISABLED               0x00010000
#define F1MSK_AUTOCLIENTDRIVES            0x00008000
#define F1MSK_AUTOCLIENTLPTS              0x00004000
#define F1MSK_FORCECLIENTLPTDEF           0x00002000
#define F1MSK_DISABLEENCRYPTION           0x00001000
#define F1MSK_HOMEDIRECTORYMAPROOT        0x00000800
#define F1MSK_USEDEFAULTGINA              0x00000400
#define F1MSK_DISABLECPM                  0x00000200
#define F1MSK_DISABLECDM                  0x00000100
#define F1MSK_DISABLECCM                  0x00000080
#define F1MSK_DISABLELPT                  0x00000040
#define F1MSK_DISABLECLIP                 0x00000020
#define F1MSK_DISABLEEXE                  0x00000010
#define F1MSK_WALLPAPERDISABLED           0x00000008
#define F1MSK_DISABLECAM                  0x00000004
//#define F1MSK_unused                      0x00000002
//#define F1MSK_unused                      0x00000001

VOID AnsiToUnicode( WCHAR *, ULONG, CHAR * );
NTSTATUS GetDomainName ( PWCHAR, PWCHAR * );
ULONG GetFlagMask( PUSERCONFIG );
VOID QueryUserConfig( HKEY, PUSERCONFIG );


/*******************************************************************************
 *
 *  UsrPropSetValue (UNICODE)
 *
 *    Sets a 1-, 2-, or 4-byte value into the supplied User Parameters buffer
 *
 * ENTRY:
 *    pValueName (input)
 *       Points to the Value Name string
 *    pValue (input)
 *       Points to value
 *    ValueLength (input)
 *       Number of bytes in the Value
 *    pUserParms (input)
 *       Points to the specially formatted User Parameters buffer
 *    UserParmsLength (input)
 *       Length in bytes of the pUserParms buffer
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
UsrPropSetValue(
   WCHAR * pValueName,
   PVOID pValue,
   USHORT ValueLength,
   BOOL fDefaultValue,
   WCHAR * pUserParms,
   ULONG UserParmsLength
   
   )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING uniValue;
    LPWSTR  lpNewUserParms = NULL;
    BOOL fUpdate;
    PWCHAR pNameBuf;
    ULONG NBLen;

    /*
     *  Prefix the name with a unique string so that other users of
     *  the user parameters section of the SAM won't collide with our
     *  value names.
     */
    NBLen = sizeof(CTXPREFIX) + ((wcslen(pValueName) + 1) * sizeof(WCHAR));
    pNameBuf = (PWCHAR) LocalAlloc( LPTR, NBLen );
    if ( !pNameBuf ) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }
    wcscpy( pNameBuf, CTXPREFIX );
    wcscat( pNameBuf, pValueName );

    uniValue.Buffer = (PWCHAR) pValue;
    uniValue.Length = ValueLength;
    uniValue.MaximumLength = uniValue.Length;

    Status = SetUserProperty( pUserParms,
                              pNameBuf,
                              uniValue,
                              USER_PROPERTY_TYPE_ITEM,
                              fDefaultValue,
                              &lpNewUserParms,
                              &fUpdate );

    LocalFree( pNameBuf );
    if ((Status == STATUS_SUCCESS) && (lpNewUserParms != NULL)) {
        if (fUpdate) {
           if ( (wcslen( lpNewUserParms ) * sizeof(WCHAR)) > UserParmsLength ) {
               return( STATUS_BUFFER_TOO_SMALL );
           }
           lstrcpyW( pUserParms, lpNewUserParms);           
        }

        LocalFree( lpNewUserParms );
    }

    return( Status );
}


/*******************************************************************************
 *
 *  UsrPropGetValue (UNICODE)
 *
 *    Gets a value from the supplied User Parameters buffer
 *
 * ENTRY:
 *    pValuegName (input)
 *       Points to the Value Name string
 *    pValue (output)
 *       Points to the buffer to receive the value
 *    ValueLength (input)
 *       Number of bytes in the buffer pointer to by pValue
 *    pUserParms (input)
 *       Points to the specially formatted User Parameters buffer
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
UsrPropGetValue(
   TCHAR * pValueName,
   PVOID pValue,
   ULONG ValueLength,
   WCHAR * pUserParms
   )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING uniValue;
    WCHAR Flag;
    PWCHAR pNameBuf;
    ULONG NBLen;

    /*
     *  Prefix the name with a unique string so that other users of
     *  the user parameters section of the SAM won't collide with our
     *  usage.
     */
    NBLen = sizeof(CTXPREFIX) + ((wcslen(pValueName) + 1) * sizeof(WCHAR));
    pNameBuf = (PWCHAR) LocalAlloc( LPTR, NBLen );
    if ( !pNameBuf ) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }
    wcscpy( pNameBuf, CTXPREFIX );
    wcscat( pNameBuf, pValueName );

    Status =  QueryUserProperty( pUserParms, pNameBuf, &Flag, &uniValue );
    LocalFree( pNameBuf );
    if ( Status != STATUS_SUCCESS ) {
        return( Status );
    }

    if ( !uniValue.Buffer ) {
        memset( pValue, 0, ValueLength );
    } else {
        memcpy( pValue, uniValue.Buffer, ValueLength );
        LocalFree( uniValue.Buffer );
    }

    return( Status );
}


/*******************************************************************************
 *
 *  UsrPropSetString (UNICODE)
 *
 *    Sets a variable length string into the supplied User Parameters buffer
 *
 * ENTRY:
 *    pStringName (input)
 *       Points to the String Name string
 *    pStringValue (input)
 *       Points to the string
 *    pUserParms (input)
 *       Points to the specially formatted User Parameters buffer
 *    UserParmsLength (input)
 *       Length in bytes of the pUserParms buffer
 *    fDefaultValue
 *       Indicates that this value is a default value and should not be saved
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
UsrPropSetString(
   WCHAR * pStringName,
   WCHAR * pStringValue,
   WCHAR * pUserParms,
   ULONG UserParmsLength,
   BOOL fDefaultValue
   )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING uniString;
    CHAR * pchTemp = NULL;
    LPWSTR  lpNewUserParms = NULL;
    BOOL fUpdate;
    PWCHAR pNameBuf;
    ULONG NBLen;
    INT nMBLen;


    if (pStringValue == NULL) {
        uniString.Buffer = NULL;
        uniString.Length =  0;
        uniString.MaximumLength = 0;
    }
    else
    {
        BOOL fDummy;

        INT  nStringLength = lstrlen(pStringValue) + 1;

        // Determine the length of the mulitbyte string
        // allocate it and convert to
        // this fixes bug 264907

        // Next release we'll need to change from ansi code page to 
        // UTF8.
        
        nMBLen = WideCharToMultiByte(CP_ACP,
                                           0,
                                pStringValue,
                               nStringLength,
                                     pchTemp,
                                           0,
                                        NULL,
                                        NULL );
        pchTemp = ( CHAR * )LocalAlloc( LPTR , nMBLen );
        if ( pchTemp == NULL )
        {
#ifdef DBG
            OutputDebugString( L"REGAPI : UsrPropSetString - STATUS_INSUFFICIENT_RESOURCES\n" );
#endif
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else if( !WideCharToMultiByte( CP_ACP,
                                            0 ,
                                 pStringValue ,
                                nStringLength ,
                                      pchTemp ,
                                       nMBLen ,
                                         NULL ,
                                         NULL ) )
        {
#ifdef DBG
            // OutputDebugString( L"REGAPI : UsrPropSetString - STATUS_UNSUCCESSFUL wctomb failed.\n" );
            DbgPrint( "REGAPI : UsrPropSetString - STATUS_UNSUCCESSFUL wctomb failed with 0x%x.\n" , GetLastError( ) );
#endif
            Status = STATUS_UNSUCCESSFUL;
        }

        if( Status == STATUS_SUCCESS )
        {
            uniString.Buffer = (WCHAR *) pchTemp;
            uniString.Length =  (USHORT)nMBLen;
            uniString.MaximumLength = (USHORT)nMBLen;
        }
    }

    /*
     *  Prefix the name with a unique string so that other users of
     *  the user parameters section of the SAM won't collide with our
     *  usage.
     */
    NBLen = sizeof(CTXPREFIX) + ((wcslen(pStringName) + 1) * sizeof(WCHAR));
    pNameBuf = (PWCHAR) LocalAlloc( LPTR, NBLen );
    if ( !pNameBuf ) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    wcscpy( pNameBuf, CTXPREFIX );
    wcscat( pNameBuf, pStringName );

    Status = Status ? Status : SetUserProperty( pUserParms,
                                                pNameBuf,
                                                uniString,
                                                USER_PROPERTY_TYPE_ITEM,
                                                fDefaultValue,
                                                &lpNewUserParms,
                                                &fUpdate );
    LocalFree( pNameBuf );
    if ( (Status == STATUS_SUCCESS) && (lpNewUserParms != NULL))
    {
        if ( fUpdate )
        {
           if ( (wcslen( lpNewUserParms ) * sizeof(WCHAR)) > UserParmsLength )
           {
               return( STATUS_BUFFER_TOO_SMALL );
           }
           lstrcpyW( pUserParms, lpNewUserParms);
        }

        LocalFree( lpNewUserParms );
    }
    if ( pchTemp != NULL )
    {
        LocalFree( pchTemp );
    }
    return( Status );
}


/*******************************************************************************
 *
 *  UsrPropGetString (UNICODE)
 *
 *    Gets a variable length string from the supplied User Parameters buffer
 *
 * ENTRY:
 *    pStringName (input)
 *       Points to the String Name string
 *    pStringValue (output)
 *       Points to the string
 *    StringValueLength (input)
 *       Number of bytes in the buffer pointer to by pStringValue
 *    pUserParms (input)
 *       Points to the specially formatted User Parameters buffer
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
UsrPropGetString(
   TCHAR * pStringName,
   TCHAR * pStringValue,
   ULONG StringValueLength,
   WCHAR * pUserParms
   )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING uniString;
    WCHAR Flag;
    PWCHAR pNameBuf;
    ULONG NBLen;

    /*
     *  Prefix the name with a unique string so that other users of
     *  the user parameters section of the SAM won't collide with our
     *  usage.
     */
    NBLen = sizeof(CTXPREFIX) + ((wcslen(pStringName) + 1) * sizeof(WCHAR));
    pNameBuf = (PWCHAR) LocalAlloc( LPTR, NBLen );
    if ( !pNameBuf ) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }
    wcscpy( pNameBuf, CTXPREFIX );
    wcscat( pNameBuf, pStringName );

    pStringValue[0] = L'\0';
    Status =  QueryUserProperty( pUserParms, pNameBuf, &Flag, &uniString );
    LocalFree( pNameBuf );

    if ( !( Status == STATUS_SUCCESS && uniString.Length && uniString.Buffer) ) {
        pStringValue[0] = L'\0';
    } else {
        if ( !MultiByteToWideChar( CP_ACP,
                                   0,
                                   (CHAR *)uniString.Buffer,
                                   uniString.Length,
                                   pStringValue,
                                   StringValueLength ) ) {
            Status = STATUS_UNSUCCESSFUL;
        }
    }

    if ( uniString.Buffer ) {
        LocalFree( uniString.Buffer );
    }

    return( Status );
}


/*******************************************************************************
 *
 *  ConnectToSAM (UNICODE)
 *
 *    Given a Server name and a Domain name, connect to the SAM
 *
 * ENTRY:
 *    pServerName (input)
 *       Points to the Server name
 *    pDomainValue (input)
 *       Points to the Domain name
 *    pSAMHandle (output)
 *       Pointer to the Handle to the SAM
 *    pDomainHandle (output)
 *       Pointer to the Handle to the Domain
 *    pDomainID (ouptut)
 *       Pointer to the Domain SID
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
ConnectToSam(
   BOOLEAN fReadOnly,
   LPTSTR pServerName,
   LPTSTR pDomainName,
   SAM_HANDLE * pSAMHandle,
   SAM_HANDLE * pDomainHandle,
   PSID * pDomainID
   )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES object_attrib;
    UNICODE_STRING UniDomainName;
    UNICODE_STRING UniServerName;

    *pSAMHandle = NULL;
    *pDomainHandle = NULL;
    *pDomainID = NULL;

    //
    // connect to SAM (Security Account Manager)
    //
#ifdef DEBUG
    DbgPrint( "ConnectToSam: pServerName %ws, pDomainName %ws\n", pServerName, pDomainName );
#endif // DEBUG
    RtlInitUnicodeString(&UniServerName, pServerName);
    RtlInitUnicodeString(&UniDomainName, pDomainName);
    InitializeObjectAttributes(&object_attrib, NULL, 0, NULL, NULL);
    status = SamConnect( &UniServerName,
                         pSAMHandle,
                         fReadOnly
                             ? SAM_SERVER_READ |
                               SAM_SERVER_EXECUTE
                             : STANDARD_RIGHTS_WRITE |
                               SAM_SERVER_EXECUTE,
                         &object_attrib );
#ifdef DEBUG
    DbgPrint( "ConnectToSam: SamConnect returned NTSTATUS = 0x%x\n", status );
#endif // DEBUG
    if ( status != STATUS_SUCCESS ) {
        goto exit;
    }

    status = SamLookupDomainInSamServer( *pSAMHandle,
                                         &UniDomainName,
                                         pDomainID);
#ifdef DEBUG
    DbgPrint( "ConnectToSam: SamLookupDomainInSamServer returned NTSTATUS = 0x%x\n", status );
#endif // DEBUG
    if ( status != STATUS_SUCCESS ) {
        goto cleanupconnect;
    }

    status = SamOpenDomain( *pSAMHandle,
                            fReadOnly
                                ? DOMAIN_READ |
                                  DOMAIN_LOOKUP |
                                  DOMAIN_READ_PASSWORD_PARAMETERS
                                : DOMAIN_READ |
                                  DOMAIN_CREATE_ALIAS |
                                  DOMAIN_LOOKUP |
                                  DOMAIN_CREATE_USER |
                                  DOMAIN_READ_PASSWORD_PARAMETERS,
                            *pDomainID,
                            pDomainHandle );
#ifdef DEBUG
    DbgPrint( "ConnectToSam: SamOpenDomain returned NTSTATUS = 0x%x\n", status );
#endif // DEBUG
    if ( status != STATUS_SUCCESS ) {
        goto cleanuplookup;
    }

    return( STATUS_SUCCESS );

/*
 *  Error returns
 */

cleanuplookup:
   SamFreeMemory( *pDomainID );
   *pDomainID = NULL;

cleanupconnect:
   SamCloseHandle( *pSAMHandle );
   *pSAMHandle = NULL;

exit:
    return( status );
}

/*******************************************************************************
 *
 *  UsrPropQueryUserConfig
 *
 *     Query USERCONFIG info from SAM's User Parameters
 *
 * ENTRY:
 *    pUserParms (input)
 *       pointer to a wide char buffer containing the SAM's User Parameters
 *    UPlength (input )
 *       length of the pUserParms buffer
 *    pUser (output)
 *       pointer to USERCONFIG structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
UsrPropQueryUserConfig(
    WCHAR *pUserParms,
    ULONG UPLength,
    PUSERCONFIG pUser )
{
    ULONG Flags1;
    NTSTATUS Status;
    ULONG CfgPresent;
    USERCONFIG ucDefault;

    QueryUserConfig( HKEY_LOCAL_MACHINE , &ucDefault );

     /*
      *  Check if the configuration exits in the User Parameters
      */

    if( ( ( Status = UsrPropGetValue( WIN_CFGPRESENT,
                                      &CfgPresent,
                                      sizeof(CfgPresent),
                                      pUserParms ) ) != NO_ERROR ) )
    {
        KdPrint( ( "UsrPropQueryUserConfig: UsrPropGetValue returned NTSTATUS = 0x%x\n", Status ) );
        return( Status );
    }
    else
    {
        if( CfgPresent != CFGPRESENT_VALUE )
        {
            KdPrint( ( "UsrPropQueryUserConfig: UsrPropGetValue returned NTSTATUS = 0x%x but TS-signature was not present\n", Status ) );
            return( STATUS_OBJECT_NAME_NOT_FOUND );
        }
    }
    Status = UsrPropGetValue( WIN_FLAGS1,
                              &Flags1,
                              sizeof(Flags1),
                              pUserParms );
    if( NT_SUCCESS( Status ) )
    {
        Status = UsrPropGetValue( WIN_CALLBACK,
                                  &pUser->Callback,
                                  sizeof(pUser->Callback),
                                  pUserParms );
        if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
        {
            pUser->Callback = ucDefault.Callback;
            Status = STATUS_SUCCESS;
        }
    }
    if( NT_SUCCESS( Status ) )
    {
        Status = UsrPropGetValue( WIN_SHADOW,
                                  &pUser->Shadow,
                                  sizeof(pUser->Shadow),
                                  pUserParms );
        if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
        {
            pUser->Shadow = ucDefault.Shadow;
            Status = STATUS_SUCCESS;
        }
    }
    if( NT_SUCCESS( Status ) )
    {
        Status = UsrPropGetValue( WIN_MAXCONNECTIONTIME,
                                  &pUser->MaxConnectionTime,
                                  sizeof(pUser->MaxConnectionTime),
                                  pUserParms );
        if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
        {
            pUser->MaxConnectionTime = ucDefault.MaxConnectionTime;
            Status = STATUS_SUCCESS;
        }
    }
    if( NT_SUCCESS( Status ) )
    {
        Status = UsrPropGetValue( WIN_MAXDISCONNECTIONTIME,
                                  &pUser->MaxDisconnectionTime,
                                  sizeof(pUser->MaxDisconnectionTime),
                                  pUserParms );
        if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
        {
            pUser->MaxDisconnectionTime = ucDefault.MaxDisconnectionTime;
            Status = STATUS_SUCCESS;
        }
    }
    if( NT_SUCCESS( Status ) )
    {
        Status = UsrPropGetValue( WIN_MAXIDLETIME,
                                  &pUser->MaxIdleTime,
                                  sizeof(pUser->MaxIdleTime),
                                  pUserParms );
        if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
        {
            pUser->MaxIdleTime = ucDefault.MaxIdleTime;
            Status = STATUS_SUCCESS;
        }
    }
    if( NT_SUCCESS( Status ) )
    {
        Status = UsrPropGetValue( WIN_KEYBOARDLAYOUT,
                                  &pUser->KeyboardLayout,
                                  sizeof(pUser->KeyboardLayout),
                                  pUserParms );
        if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
        {
            pUser->KeyboardLayout = ucDefault.KeyboardLayout;
            Status = STATUS_SUCCESS;
        }
    }
    if( NT_SUCCESS( Status ) )
    {
        Status = UsrPropGetValue( WIN_MINENCRYPTIONLEVEL,
                                  &pUser->MinEncryptionLevel,
                                  sizeof(pUser->MinEncryptionLevel),
                                  pUserParms );
           if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
        {
            pUser->MinEncryptionLevel = ucDefault.MinEncryptionLevel;
            Status = STATUS_SUCCESS;
        }
    }
    // String properties that do not exist are init to NULL
    // default values are null so need to fix if ret status is a failure.

    if( NT_SUCCESS( Status ) )
    {
         Status = UsrPropGetString( WIN_WORKDIRECTORY,
                                    pUser->WorkDirectory,
                                    sizeof(pUser->WorkDirectory),
                                    pUserParms );
         if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
         {
             Status = STATUS_SUCCESS;
         }
    }
    if( NT_SUCCESS( Status ) )
    {
        Status = UsrPropGetString( WIN_NWLOGONSERVER,
                                   pUser->NWLogonServer,
                                   sizeof(pUser->NWLogonServer),
                                   pUserParms );
         if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
         {
             Status = STATUS_SUCCESS;
         }
    }
    if( NT_SUCCESS( Status ) )
    {
        Status = UsrPropGetString( WIN_WFHOMEDIR,
                                   pUser->WFHomeDir,
                                   sizeof(pUser->WFHomeDir),
                                   pUserParms );
         if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
         {
             Status = STATUS_SUCCESS;
         }
    }
    if( NT_SUCCESS( Status ) )
    {
        Status = UsrPropGetString( WIN_WFHOMEDIRDRIVE,
                                   pUser->WFHomeDirDrive,
                                   sizeof(pUser->WFHomeDir),
                                   pUserParms );
         if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
         {
             Status = STATUS_SUCCESS;
         }
    }
    if( NT_SUCCESS( Status ) )
    {
        Status = UsrPropGetString( WIN_WFPROFILEPATH,
                                   pUser->WFProfilePath,
                                   sizeof(pUser->WFProfilePath),
                                   pUserParms );
         if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
         {
             Status = STATUS_SUCCESS;
         }
    }
    if( NT_SUCCESS( Status ) )
    {
        Status = UsrPropGetString( WIN_INITIALPROGRAM,
                                   pUser->InitialProgram,
                                   sizeof(pUser->InitialProgram),
                                   pUserParms );
         if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
         {
             Status = STATUS_SUCCESS;
         }
    }
    if( NT_SUCCESS( Status ) )
    {
        Status = UsrPropGetString( WIN_CALLBACKNUMBER,
                                   pUser->CallbackNumber,
                                   sizeof(pUser->CallbackNumber),
                                   pUserParms );
         if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
         {
             Status = STATUS_SUCCESS;
         }
    }
    if( !( NT_SUCCESS( Status ) ) )
    {
        return( Status );
    }

    pUser->fInheritAutoLogon =
        Flags1 & F1MSK_INHERITAUTOLOGON ? TRUE : FALSE;
    pUser->fInheritResetBroken =
        Flags1 & F1MSK_INHERITRESETBROKEN ? TRUE : FALSE;
    pUser->fInheritReconnectSame =
        Flags1 & F1MSK_INHERITRECONNECTSAME ? TRUE : FALSE;
    pUser->fInheritInitialProgram =
        Flags1 & F1MSK_INHERITINITIALPROGRAM ? TRUE : FALSE;
    pUser->fInheritCallback =
        Flags1 & F1MSK_INHERITCALLBACK ? TRUE : FALSE;
    pUser->fInheritCallbackNumber =
        Flags1 & F1MSK_INHERITCALLBACKNUMBER ? TRUE : FALSE;
    pUser->fInheritShadow =
        Flags1 & F1MSK_INHERITSHADOW ? TRUE : FALSE;
    pUser->fInheritMaxSessionTime =
        Flags1 & F1MSK_INHERITMAXSESSIONTIME ? TRUE : FALSE;
    pUser->fInheritMaxDisconnectionTime =
        Flags1 & F1MSK_INHERITMAXDISCONNECTIONTIME ? TRUE : FALSE;
    pUser->fInheritMaxIdleTime =
        Flags1 & F1MSK_INHERITMAXIDLETIME ? TRUE : FALSE;
    pUser->fInheritAutoClient =
        Flags1 & F1MSK_INHERITAUTOCLIENT ? TRUE : FALSE;
    pUser->fInheritSecurity =
        Flags1 & F1MSK_INHERITSECURITY ? TRUE : FALSE;
    pUser->fPromptForPassword =
        Flags1 & F1MSK_PROMPTFORPASSWORD ? TRUE : FALSE;
    pUser->fResetBroken =
        Flags1 & F1MSK_RESETBROKEN ? TRUE : FALSE;
    pUser->fReconnectSame =
        Flags1 & F1MSK_RECONNECTSAME ? TRUE : FALSE;
    pUser->fLogonDisabled =
        Flags1 & F1MSK_LOGONDISABLED ? TRUE : FALSE;
    pUser->fAutoClientDrives =
        Flags1 & F1MSK_AUTOCLIENTDRIVES ? TRUE : FALSE;
    pUser->fAutoClientLpts =
        Flags1 & F1MSK_AUTOCLIENTLPTS ? TRUE : FALSE;
    pUser->fForceClientLptDef =
        Flags1 & F1MSK_FORCECLIENTLPTDEF ? TRUE : FALSE;
    pUser->fDisableEncryption =
        Flags1 & F1MSK_DISABLEENCRYPTION ? TRUE : FALSE;
    pUser->fHomeDirectoryMapRoot =
        Flags1 & F1MSK_HOMEDIRECTORYMAPROOT ? TRUE : FALSE;
    pUser->fUseDefaultGina =
        Flags1 & F1MSK_USEDEFAULTGINA ? TRUE : FALSE;
    pUser->fDisableCpm =
        Flags1 & F1MSK_DISABLECPM ? TRUE : FALSE;
    pUser->fDisableCdm =
        Flags1 & F1MSK_DISABLECDM ? TRUE : FALSE;
    pUser->fDisableCcm =
        Flags1 & F1MSK_DISABLECCM ? TRUE : FALSE;
    pUser->fDisableLPT =
        Flags1 & F1MSK_DISABLELPT ? TRUE : FALSE;
    pUser->fDisableClip  =
        Flags1 & F1MSK_DISABLECLIP ? TRUE : FALSE;
    pUser->fDisableExe =
        Flags1 & F1MSK_DISABLEEXE ? TRUE : FALSE;
    pUser->fWallPaperDisabled =
        Flags1 & F1MSK_WALLPAPERDISABLED ? TRUE : FALSE;
    pUser->fDisableCam =
        Flags1 & F1MSK_DISABLECAM ? TRUE : FALSE;

    return( STATUS_SUCCESS );
}

/*******************************************************************************
 *
 *  UsrPropMergeUserConfig
 *
 *     Merge USERCONFIG structure into User Properties section of SAM
 *
 * ENTRY:
 *    pUserParms (input/output)
 *       pointer to a wide char buffer containing the SAM's User Parameters
 *    UPlength (input )
 *       length of the pUserParms buffer
 *    pUser (input)
 *       pointer to USERCONFIG structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 * NOTES:
 *    Certain properties have to be stored regardless if they're default or not
 *    this is done to maintain compatibility for TSE4.0 and W2K servers
 ******************************************************************************/

NTSTATUS
UsrPropMergeUserConfig(
    WCHAR *pUserParms,
    ULONG UPLength,
    PUSERCONFIG pUser )
{
    ULONG Flags1;    
    NTSTATUS Status;
    USERCONFIG ucDefault;
    ULONG CfgPresent = CFGPRESENT_VALUE;
    BOOL fDefaultValue = FALSE;

    // 1st parameter forces default values to be placed in ucDefault
    QueryUserConfig( HKEY_LOCAL_MACHINE , &ucDefault );

    Flags1 = GetFlagMask( pUser );   

    // this value needs to be written out

    Status = UsrPropSetValue( WIN_CFGPRESENT,
                              &CfgPresent,
                              sizeof(CfgPresent),
                              FALSE,
                              pUserParms,
                              UPLength );
    if( NT_SUCCESS( Status ) )
    {
        // these values must be written out for TS4 & TS5.0
        Status = UsrPropSetValue( WIN_FLAGS1,
                                  &Flags1,
                                  sizeof(Flags1),
                                  FALSE,
                                  pUserParms,
                                  UPLength );
        
    }    
    if( NT_SUCCESS( Status ) )
    {
        fDefaultValue = ( pUser->Callback == ucDefault.Callback );
        Status = UsrPropSetValue( WIN_CALLBACK,
                                  &pUser->Callback,
                                  sizeof(pUser->Callback),
                                  fDefaultValue,
                                  pUserParms,
                                  UPLength );
    }
    if( NT_SUCCESS( Status ) )
    {
        // this value must be written out for backcompat servers
        Status = UsrPropSetValue( WIN_SHADOW,
                                  &pUser->Shadow,
                                  sizeof(pUser->Shadow),
                                  FALSE,
                                  pUserParms,
                                  UPLength );
    }
    if( NT_SUCCESS( Status ) )
    {
        fDefaultValue = ( pUser->MaxConnectionTime == ucDefault.MaxConnectionTime );
        Status = UsrPropSetValue( WIN_MAXCONNECTIONTIME,
                                  &pUser->MaxConnectionTime,
                                  sizeof(pUser->MaxConnectionTime),
                                  fDefaultValue,
                                  pUserParms,
                                  UPLength );
    }
    if( NT_SUCCESS( Status ) )
    {
        fDefaultValue = ( pUser->MaxDisconnectionTime == ucDefault.MaxDisconnectionTime );
        Status = UsrPropSetValue( WIN_MAXDISCONNECTIONTIME,
                                  &pUser->MaxDisconnectionTime,
                                  sizeof(pUser->MaxDisconnectionTime),
                                  fDefaultValue,
                                  pUserParms,
                                  UPLength );
    }
    if( NT_SUCCESS( Status ) )
    {
        fDefaultValue = ( pUser->MaxIdleTime == ucDefault.MaxIdleTime );
        Status = UsrPropSetValue( WIN_MAXIDLETIME,
                                  &pUser->MaxIdleTime,
                                  sizeof(pUser->MaxIdleTime),
                                  fDefaultValue,
                                  pUserParms,
                                  UPLength );
    }
    if( NT_SUCCESS( Status ) )
    {
        fDefaultValue = ( pUser->KeyboardLayout == ucDefault.KeyboardLayout );
        Status = UsrPropSetValue( WIN_KEYBOARDLAYOUT,
                                  &pUser->KeyboardLayout,
                                  sizeof(pUser->KeyboardLayout),
                                  fDefaultValue,
                                  pUserParms,
                                  UPLength );
    }
    if( NT_SUCCESS( Status ) )
    {
        // always store minencryption level for backwards compatibilty purposes        
        Status = UsrPropSetValue( WIN_MINENCRYPTIONLEVEL,
                                  &pUser->MinEncryptionLevel,
                                  sizeof(pUser->MinEncryptionLevel),
                                  FALSE,
                                  pUserParms,
                                  UPLength );
    }
    if( NT_SUCCESS( Status ) )
    {
        fDefaultValue = ( pUser->WorkDirectory[0] == 0 );

        Status = UsrPropSetString( WIN_WORKDIRECTORY,
                                   pUser->WorkDirectory,
                                   pUserParms,
                                   UPLength,
                                   fDefaultValue );
    }
    if( NT_SUCCESS( Status ) )
    {
        fDefaultValue = ( pUser->NWLogonServer[0] == 0 );
        Status = UsrPropSetString( WIN_NWLOGONSERVER,
                                   pUser->NWLogonServer,
                                   pUserParms,                                   
                                   UPLength,
                                   fDefaultValue );
    }
    if( NT_SUCCESS( Status ) )
    {
        fDefaultValue = ( pUser->WFHomeDir[0] == 0 );
        Status = UsrPropSetString( WIN_WFHOMEDIR,
                                   pUser->WFHomeDir,
                                   pUserParms,                                   
                                   UPLength,
                                   fDefaultValue );
    }
    if( NT_SUCCESS( Status ) )
    {
        fDefaultValue = ( pUser->WFHomeDirDrive[0] == 0 );
        Status = UsrPropSetString( WIN_WFHOMEDIRDRIVE,
                                   pUser->WFHomeDirDrive,
                                   pUserParms,                                   
                                   UPLength,
                                   fDefaultValue );
    }
    if( NT_SUCCESS( Status ) )
    {
        fDefaultValue = ( pUser->WFProfilePath[0] == 0 );
        Status = UsrPropSetString( WIN_WFPROFILEPATH,
                                   pUser->WFProfilePath,
                                   pUserParms,
                                   UPLength,
                                   fDefaultValue );
    }
    if( NT_SUCCESS( Status ) )
    {
        fDefaultValue = ( pUser->InitialProgram[0] == 0 );
        Status = UsrPropSetString( WIN_INITIALPROGRAM,
                                   pUser->InitialProgram,
                                   pUserParms,
                                   UPLength,
                                   fDefaultValue );
    }
    if( NT_SUCCESS( Status ) )
    {
        fDefaultValue = ( pUser->CallbackNumber[0] == 0 );
        Status = UsrPropSetString( WIN_CALLBACKNUMBER,
                                   pUser->CallbackNumber,
                                   pUserParms,
                                   UPLength,
                                   fDefaultValue );
    }  
    return( Status );
    
}

/*******************************************************************************
 GetFlagMask
    Assembles a bitmask of flags set in pUser

 *******************************************************************************/
ULONG GetFlagMask( PUSERCONFIG pUser )
{
    ULONG Flags1 = 0;

    if ( pUser->fInheritAutoLogon ) {
        Flags1 |= F1MSK_INHERITAUTOLOGON;
    }
    if ( pUser->fInheritResetBroken ) {
        Flags1 |= F1MSK_INHERITRESETBROKEN;
    }
    if ( pUser->fInheritReconnectSame ) {
        Flags1 |= F1MSK_INHERITRECONNECTSAME;
    }
    if ( pUser->fInheritInitialProgram ) {
        Flags1 |= F1MSK_INHERITINITIALPROGRAM;
    }
    if ( pUser->fInheritCallback ) {
        Flags1 |= F1MSK_INHERITCALLBACK;
    }
    if ( pUser->fInheritCallbackNumber ) {
        Flags1 |= F1MSK_INHERITCALLBACKNUMBER;
    }
    if ( pUser->fInheritShadow ) {
        Flags1 |= F1MSK_INHERITSHADOW;
    }
    if ( pUser->fInheritMaxSessionTime ) {
        Flags1 |= F1MSK_INHERITMAXSESSIONTIME;
    }
    if ( pUser->fInheritMaxDisconnectionTime ) {
        Flags1 |= F1MSK_INHERITMAXDISCONNECTIONTIME;
    }
    if ( pUser->fInheritMaxIdleTime ) {
        Flags1 |= F1MSK_INHERITMAXIDLETIME;
    }
    if ( pUser->fInheritAutoClient ) {
        Flags1 |= F1MSK_INHERITAUTOCLIENT;
    }
    if ( pUser->fInheritSecurity ) {
        Flags1 |= F1MSK_INHERITSECURITY;
    }
    if ( pUser->fPromptForPassword ) {
        Flags1 |= F1MSK_PROMPTFORPASSWORD;
    }
    if ( pUser->fResetBroken ) {
        Flags1 |= F1MSK_RESETBROKEN;
    }
    if ( pUser->fReconnectSame ) {
        Flags1 |= F1MSK_RECONNECTSAME;
    }
    if ( pUser->fLogonDisabled ) {
        Flags1 |= F1MSK_LOGONDISABLED;
    }
    if ( pUser->fAutoClientDrives ) {
        Flags1 |= F1MSK_AUTOCLIENTDRIVES;
    }
    if ( pUser->fAutoClientLpts ) {
        Flags1 |= F1MSK_AUTOCLIENTLPTS;
    }
    if ( pUser->fForceClientLptDef ) {
        Flags1 |= F1MSK_FORCECLIENTLPTDEF;
    }
    if ( pUser->fDisableEncryption ) {
        Flags1 |= F1MSK_DISABLEENCRYPTION;
    }
    if ( pUser->fHomeDirectoryMapRoot ) {
        Flags1 |= F1MSK_HOMEDIRECTORYMAPROOT;
    }
    if ( pUser->fUseDefaultGina ) {
        Flags1 |= F1MSK_USEDEFAULTGINA;
    }
    if ( pUser->fDisableCpm ) {
        Flags1 |= F1MSK_DISABLECPM;
    }
    if ( pUser->fDisableCdm ) {
        Flags1 |= F1MSK_DISABLECDM;
    }
    if ( pUser->fDisableCcm ) {
        Flags1 |= F1MSK_DISABLECCM;
    }
    if ( pUser->fDisableLPT ) {
        Flags1 |= F1MSK_DISABLELPT;
    }
    if ( pUser->fDisableClip  ) {
        Flags1 |= F1MSK_DISABLECLIP;
    }
    if ( pUser->fDisableExe ) {
        Flags1 |= F1MSK_DISABLEEXE;
    }
    if ( pUser->fWallPaperDisabled ) {
        Flags1 |= F1MSK_WALLPAPERDISABLED;
    }
    if ( pUser->fDisableCam ) {
        Flags1 |= F1MSK_DISABLECAM;
    }

    return Flags1;
}


/*******************************************************************************
 *
 *  RegMergeUserConfigWithUserParameters
 *
 *     Merge the User Configuration with the supplied SAM's User
 *     Parameters buffer.
 *
 * ENTRY:
 *    pUserParms (input/output)
 *       pointer to a wide char buffer containing the SAM's User Parameters
 *    UPlength (input)
 *       length of the pUserParms buffer
 *    pUser (input)
 *       pointer to USERCONFIG structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
RegMergeUserConfigWithUserParameters(
    PUSER_PARAMETERS_INFORMATION pUserParmInfo,
    PUSERCONFIGW pUser,
    PUSER_PARAMETERS_INFORMATION pNewUserParmInfo
    )
{
    NTSTATUS       status;
    ULONG          ObjectID;
    PWCHAR         lpNewUserParms = NULL;
    ULONG          UPLength;
    WCHAR          *pUserParms;

    /*
     *  Compute the size the user parameter buffer must be
     *  in order to accommodate the CITRIX data plus the existing
     *  User Parameters data.
     */
    
    KdPrint( ("TSUSEREX: User parameter length is %d\n", pUserParmInfo->Parameters.Length ) );

    UPLength = (pUserParmInfo->Parameters.Length +
                CTX_USER_PARAM_MAX_SIZE) *
               sizeof(WCHAR);
    pUserParms = (WCHAR *) LocalAlloc( LPTR, UPLength );

    if ( pUserParms == NULL ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    /*
     *  Copy SAM data to the local buffer.
     *  Let the Set/Get operation terminate the buffer.
     */
    memcpy( pUserParms,
            pUserParmInfo->Parameters.Buffer,
            pUserParmInfo->Parameters.Length );
    
    /*
     *  Zero fill the unused portion of the pUserParms buffer.
     */
    memset( &pUserParms[ pUserParmInfo->Parameters.Length / sizeof(WCHAR) ],
            0,
            UPLength - pUserParmInfo->Parameters.Length );    

    status = UsrPropMergeUserConfig( pUserParms, UPLength, pUser );
    if ( status != NO_ERROR ) {
        goto cleanupoperation;
    }
    RtlInitUnicodeString( &pNewUserParmInfo->Parameters, pUserParms );

    return( STATUS_SUCCESS );

/*
 * Error returns
 */

cleanupoperation:
    LocalFree( pUserParms );

exit:
    return( status );
}


/*******************************************************************************
 *
 *  RegGetUserConfigFromUserParameters
 *
 *     Get the User Configuration from the supplied SAM's
 *     User Parameters buffer.
 *
 * ENTRY:
 *    pUserParmInfo (input)
 *       pointer to a USER_PARAMETERS_INFORMATION structure obtained from
 *       a user's SAM entry
 *    pUser (input)
 *       pointer to USERCONFIG structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
RegGetUserConfigFromUserParameters(
    PUSER_PARAMETERS_INFORMATION pUserParmInfo,
    PUSERCONFIGW pUser
    )
{
    NTSTATUS       status;
    ULONG          ObjectID;
    PWCHAR         lpNewUserParms = NULL;
    ULONG          UPLength;
    WCHAR          *pUserParms;


    /*
     *  Compute the size the user parameter buffer must be
     *  in order to accommodate the existing User Parameters.
     */
    UPLength = pUserParmInfo->Parameters.Length + sizeof(WCHAR);
    pUserParms = (WCHAR *) LocalAlloc( LPTR, UPLength );


    if ( pUserParms == NULL ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    /*
     *  Copy SAM data to the local buffer and terminate the buffer.
     */
    memcpy( pUserParms,
            pUserParmInfo->Parameters.Buffer,
            pUserParmInfo->Parameters.Length );
    pUserParms[ pUserParmInfo->Parameters.Length / sizeof(WCHAR) ] = L'\0';

    /*
     *  Extract the User Configuration from the SAM's User
     *  Parameters.
     */
    status = UsrPropQueryUserConfig( pUserParms, UPLength, pUser );

    LocalFree( pUserParms );
    if ( status != NO_ERROR ) {
        goto exit;
    }

    return( STATUS_SUCCESS );

/*
 *  Error returns
 */

exit:
#ifdef DEBUG
    DbgPrint( "RegGetUserConfigFromUserParameters: status = 0x%x\n", status );
#endif // DEBUG
    return( status );

}


/*******************************************************************************
 *
 *  RegSAMUserConfig
 *
 *     Set or Get the User Configuration for a user from the Domain whose
 *     PDC is server is given.
 *
 * ENTRY:
 *    fGetConfig (input)
 *       TRUE for Get config, FALSE for Set configuration
 *    pUsername (input)
 *       points to the user name
 *    pServerName (input)
 *       points to the name of the server.  UNC names permitted.
 *    pUser (input/output)
 *       pointer to USERCONFIG structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

DWORD
RegSAMUserConfig(
    BOOLEAN fGetConfig,
    PWCHAR pUserName,
    PWCHAR pServerName,
    PUSERCONFIGW pUser
    )
{
    NTSTATUS       status;
    UNICODE_STRING UniUserName;
    PULONG         pRids = NULL;
    PSID_NAME_USE  pSidNameUse = NULL;
    ULONG          ObjectID;
    SID_NAME_USE   SidNameUse;
    SAM_HANDLE     Handle = (SAM_HANDLE) 0;
    PUSER_PARAMETERS_INFORMATION UserParmInfo = NULL;
    ULONG          UPLength;
    SAM_HANDLE     SAMHandle = NULL;
    SAM_HANDLE     DomainHandle = NULL;
    PWCHAR         ServerName = NULL;
    PSID           DomainID = NULL;
    PWCHAR         pUserParms;
    PWCHAR         pDomainName = NULL;
    WCHAR          wCompName[MAX_COMPUTERNAME_LENGTH+1];
    ULONG          openFlag;
    DWORD               dwErr = ERROR_SUCCESS;
    ULONG               cValues;
    HANDLE              hDS = NULL;
    PDS_NAME_RESULTW    pDsResult = NULL;

    typedef DWORD (WINAPI *PFNDSCRACKNAMES) ( HANDLE, DS_NAME_FLAGS, DS_NAME_FORMAT, \
                          DS_NAME_FORMAT, DWORD, LPTSTR *, PDS_NAME_RESULT *);
    typedef void (WINAPI *PFNDSFREENAMERESULT) (DS_NAME_RESULT *);
    typedef DWORD (WINAPI *PFNDSBIND) (TCHAR *, TCHAR *, HANDLE *);
    typedef DWORD (WINAPI *PFNDSUNBIND) (HANDLE *);


    PFNDSCRACKNAMES     pfnDsCrackNamesW;
    PFNDSFREENAMERESULT pfnDsFreeNameResultW;
    PFNDSBIND           pfnDsBindW;
    PFNDSUNBIND         pfnDsUnBindW;


    // vars used for handling UPN anmes
    WCHAR           tmpUserName[MAX_PATH];
    WCHAR           *pUserAlias;
    HINSTANCE       hNtdsApi = NULL;
    // We dont' care about the domain since we get it otherwise.
    // WCHAR           tmpDomainName[ MAX_PATH];
    // tmpDomainName[0]=NULL;

    tmpUserName[0]=0;
    pUserAlias=NULL;

#ifdef DEBUG
    DbgPrint( "RegSAMUserConfig %s, User %ws, Server %ws\n", fGetConfig ? "GET" : "SET", pUserName, pServerName ? pServerName : L"-NULL-" );
#endif // DEBUG

    if (pServerName == NULL) {
       UPLength = MAX_COMPUTERNAME_LENGTH + 1;
       if (!GetComputerName(wCompName, &UPLength)) {
           status = STATUS_INSUFFICIENT_RESOURCES;
           goto exit;
       }
    }

    // init this to the name passed in, if it is not a UPN name, we will continue to use
    // the names passed into this function.
    pUserAlias = pUserName;

    //
    //
    // NEW code to handle UPN if the name passed in contains a '@' in the name.
    // The call to CrackName is to seperate the UPN name into the user alias by
    // contacting the DS and looking in the Gloabl-Catalog.
    //
    //

    if ( wcschr(pUserName,L'@') != NULL )
    {

        hNtdsApi = LoadLibrary(TEXT("ntdsapi.dll"));

        if ( hNtdsApi )
        {
            pfnDsCrackNamesW = (PFNDSCRACKNAMES)GetProcAddress(hNtdsApi, "DsCrackNamesW");
            pfnDsFreeNameResultW = (PFNDSFREENAMERESULT)GetProcAddress(hNtdsApi, "DsFreeNameResultW");
            pfnDsBindW = (PFNDSBIND)GetProcAddress(hNtdsApi, "DsBindW");
            pfnDsUnBindW = (PFNDSUNBIND)GetProcAddress(hNtdsApi, "DsUnBindW");

            
            if (pfnDsBindW && pfnDsCrackNamesW )
            {
                dwErr = pfnDsBindW(NULL, NULL, &hDS);
            }
            else
            {
                dwErr = ERROR_INVALID_FUNCTION;
            }

            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = pfnDsCrackNamesW(hDS,
                                      DS_NAME_NO_FLAGS,
                                      DS_UNKNOWN_NAME,
                                      DS_NT4_ACCOUNT_NAME,
                                      1,
                                      &pUserName,
                                      &pDsResult);

                if(dwErr == ERROR_SUCCESS)
                {
                    if(pDsResult)
                    {
                        if( pDsResult->rItems )
                        {
                            if (pDsResult->rItems[0].pName )
                            {
                                // no error
                                status = STATUS_SUCCESS;

                                wcscpy(tmpUserName, pDsResult->rItems[0].pName);
                                KdPrint(("RegSAMUserConfig: tmpUserName=%ws\n",tmpUserName));

                                // do we have a non-null name?
                                if ( tmpUserName[0] ) {
                                pUserAlias = wcschr(tmpUserName,L'\\');
                                pUserAlias++;   //move pass the wack.

                                // we are not using the domain name, we already have this
                                // wcscpy(tmpDomainName, pDsResult->rItems[0].pDomain);
                                }
                            }
                            else
                            {
                                KdPrint(("RegSAMUserConfig: pDsResult->rItems[0].pName is NULL\n"));
                            }
                        }
                        else
                        {
                            KdPrint(("RegSAMUserConfig: pDsResult->rItems=0x%lx\n",pDsResult->rItems));
                        }
                    }
                    else
                    {
                        KdPrint(("RegSAMUserConfig: pDsResult=0x%lx\n",pDsResult));
                    }
                }
                else
                {
                    switch( dwErr )
                    {
                        case ERROR_INVALID_PARAMETER:
                            status = STATUS_INVALID_PARAMETER;
                        break;

                        case ERROR_NOT_ENOUGH_MEMORY:
                            status = STATUS_NO_MEMORY;
                        break;

                       default:
                            status = STATUS_UNSUCCESSFUL;
                        break;
                    }
                    // have decided to continue using the passed-in pUserName instead of what
                    // would have been returned from CrackName. Hence, no need to exit.
                    // goto exit;
                }
            }
            else
            {
                status = STATUS_UNSUCCESSFUL; // DsBindW doesn't have a clean set of errors.
                // have decided to continue using the passed-in pUserName instead of what
                // would have been returned from DsBind/CrackName. Hence, no need to exit.
                // goto exit;
            }
        }
        else
        {
            status = STATUS_DLL_NOT_FOUND;
            // have decided to continue using the passed-in pUserName instead of what
            // would have been returned from DsBind/CrackName. Hence, no need to exit.
            // goto exit;
        }

    }


#ifdef DEBUG
    DbgPrint( "RegSAMUserConfig: pUserAlias=%ws\n", pUserAlias);
#endif // DEBUG

    status = GetDomainName( pServerName, &pDomainName );

#ifdef DEBUG
    DbgPrint( "RegSAMUserConfig: GetDomainName returned NTSTATUS = 0x%x\n", status );
#endif // DEBUG
    if ( status != STATUS_SUCCESS ) {
        goto exit;
    }

    /*
     *  With the PDC Server name and the Domain Name,
     *  connect to the SAM
     */
    status = ConnectToSam( fGetConfig,
                           pServerName,
                           pDomainName,
                           &SAMHandle,
                           &DomainHandle,
                           &DomainID );
#ifdef DEBUG
    DbgPrint( "RegSAMUserConfig: ConnectToSam returned NTSTATUS = 0x%x\n", status );
#endif // DEBUG
    if ( status != STATUS_SUCCESS ) {
        goto cleanupconnect;
    }

    RtlInitUnicodeString( &UniUserName, pUserAlias );

    status = SamLookupNamesInDomain( DomainHandle,
                                     1,
                                     &UniUserName,
                                     &pRids,
                                     &pSidNameUse );
#ifdef DEBUG
    DbgPrint( "RegSAMUserConfig: SamLookupNamesInDomain returned NTSTATUS = 0x%x\n", status );
#endif // DEBUG

    if ((status != STATUS_SUCCESS) ||
        (pRids == NULL) ||
        (pSidNameUse == NULL)) {
        goto cleanuplookup;
    }

    /*
     *  Found the user name in the SAM, copy and free SAM info
     */
    ObjectID = pRids[ 0 ];
    SidNameUse = pSidNameUse[ 0 ];
    SamFreeMemory( pRids );
    SamFreeMemory( pSidNameUse );

    /*
     *  Open the SAM entry for this user
     */

    openFlag = fGetConfig ? USER_READ
                              : USER_WRITE_ACCOUNT| USER_READ;




#ifdef DEBUG
    DbgPrint("calling SamOpenUSer with flag = 0x%x\n", openFlag);
#endif

    status = SamOpenUser( DomainHandle,
                          openFlag,
                          ObjectID,
                          &Handle );

    // For getting config parametesr...
    // The call will fail if it goes to the DC, for that case, change
    // flag, since DC does allow access to read user-parameters (for
    // legacy compat reasons).
    if (!NT_SUCCESS( status ) && fGetConfig )
    {
        openFlag = 0;
#ifdef DEBUG
        DbgPrint("calling SamOpenUSer with flag = 0x%x\n", openFlag);
#endif
        status = SamOpenUser( DomainHandle,
                          openFlag,
                          ObjectID,
                          &Handle );
    }

#ifdef DEBUG
    DbgPrint( "RegSAMUserConfig: SamOpenUser returned NTSTATUS = 0x%x\n", status );
#endif // DEBUG
    if ( status != STATUS_SUCCESS ) {
        goto cleanupsamopen;
    }

    /*
     *  Get the user parameters from the SAM
     */
    status = SamQueryInformationUser( Handle,
                                      UserParametersInformation,
                                      (PVOID *) &UserParmInfo );


    KdPrint( ( "RegSAMUserConfig: SamQueryInformationUser returned NTSTATUS = 0x%x\n", status ) );


    if ( status != STATUS_SUCCESS || UserParmInfo == NULL ) {
        goto cleanupsamquery;
    }
    if( fGetConfig )
    {
        /*
         *  Extract the User Configuration from the SAM's User
         *  Parameters.
         *
         *  For Whistler builds and higher we assume that not every field
         *  has been stored in the SAM we'll need to retrieve the default
         *  values first
         */        
        KdPrint( ( "RegSAMUserConfig: UserParmInfo %d\n", UserParmInfo->Parameters.Length ) );
        status = RegGetUserConfigFromUserParameters( UserParmInfo, pUser );
        KdPrint( ( "RegSAMUserConfig: RegGetUserConfigFromUserParameters returned NTSTATUS = 0x%x\n", status ) );
        SamFreeMemory( UserParmInfo );
        UserParmInfo = NULL;
        if ( status != NO_ERROR )
        {
            goto cleanupoperation;
        }

    }
    else
    {
        USER_PARAMETERS_INFORMATION NewUserParmInfo;

        /*
         *  Set the SAM based on the supplied User Configuration.
         */

        status = RegMergeUserConfigWithUserParameters( UserParmInfo,
                                                       pUser,
                                                       &NewUserParmInfo );
        KdPrint( ( "RegSAMUserConfig: RegMergeUserConfigWithUserParameters returned NTSTATUS = 0x%x\n", status ) );
        SamFreeMemory( UserParmInfo );
        UserParmInfo = NULL;
        if( status != NO_ERROR )
        {
            goto cleanupoperation;
        }
        status = SamSetInformationUser( Handle,
                                        UserParametersInformation,
                                        (PVOID) &NewUserParmInfo );
        KdPrint( ( "RegSAMUserConfig: NewUserParmInfo.Parameters.Length = %d\n" , NewUserParmInfo.Parameters.Length ) );
        KdPrint( ( "RegSAMUserConfig: SamSetInformationUser returned NTSTATUS = 0x%x\n", status ) );
        LocalFree( NewUserParmInfo.Parameters.Buffer );
        if ( status != STATUS_SUCCESS )
        {
            goto cleanupoperation;
        }
    }
cleanupoperation:
    if ( UserParmInfo ) {
        SamFreeMemory( UserParmInfo );
    }

cleanupsamquery:
    if ( Handle != (SAM_HANDLE) 0 ) {
        SamCloseHandle( Handle );
    }

cleanupsamopen:

cleanuplookup:
    if ( SAMHandle != (SAM_HANDLE) 0 ) {
        SamCloseHandle( SAMHandle );
    }
    if ( DomainHandle != (SAM_HANDLE) 0 ) {
      SamCloseHandle( DomainHandle );
    }
    if ( DomainID != (PSID) 0 ) {
      SamFreeMemory( DomainID );
    }

cleanupconnect:
    if ( pDomainName ) {
        NetApiBufferFree( pDomainName );
    }

exit:

    if (hNtdsApi)
    {
        if (hDS)
        {
            if ( pfnDsUnBindW ) // it should never be otherwise.
                pfnDsUnBindW( & hDS );
        }

        if (pDsResult)
        {
            if (pfnDsFreeNameResultW ) // it should never be otherwise.
                pfnDsFreeNameResultW( pDsResult );
        }

        FreeLibrary(hNtdsApi);
    }

#ifdef DEBUG
    DbgPrint( "RegSAMUserConfig %s NTSTATUS = 0x%x\n", fGetConfig ? "GET" : "SET", status );
#endif // DEBUG
    return( RtlNtStatusToDosError( status ) );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\regapi\usrprop.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    usrprop.c

Abstract:

    This module implements QueryUserProperty() and SetUserProperty()
    which read and write NetWare Properties to the UserParms field.

Author:

    Andy Herron (andyhe)    24-May-1993
    Congpa You  (CongpaY)   28-Oct-1993   Seperated SetUserProperty() and
                                          QueryUserProperty() out from usrprop.c
                                          in ncpsrv\svcdlls\ncpsvc\libbind,
                                          modified the code and  fixed a few
                                          existing problems.

Revision History:

--*/

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "ntioapi.h"
#include "windef.h"
#include "winbase.h"
#include "stdio.h"
#include "stdlib.h"
#include "winuser.h"

#include "usrprop.h"

#define NCP_SET             0x02    /* Series of Object ID numbers, each 4
                                       bytes long */

//
//   All internal (opaque) structures are listed here since no one else
//   needs to reference them.
//

//
// The user's Parameter field is mapped out to a structure that contains
// the backlevel 48 WCHARs for Mac/Ras compatibility plus a new structure
// that is basically an array of chars that make up a property name plus
// a property value.
//

//
//  This is the structure for an individual property.  Note that there are
//  no null terminators in this.
//
typedef struct _USER_PROPERTY {
    WCHAR   PropertyLength;     // length of property name
    WCHAR   ValueLength;        // length of property value
    WCHAR   PropertyFlag;       // type of property (1 = set, 2 = item)
    WCHAR   Property[1];        // start of property name, followed by value
} USER_PROPERTY, *PUSER_PROPERTY;

//
//  This is the structure that maps the beginning of the user's Parameters
//  field.  It is only separate so that we can do a sizeof() without including
//  the first property, which may or may not be there.
//

typedef struct _USER_PROPERTIES_HDR {
    WCHAR   BacklevelParms[48];     // RAS & Mac data stored here.
    WCHAR   PropertySignature;      // signature that we can look for.
    WCHAR   PropertyCount;          // number of properties present.
} USER_PROPERTIES_HDR, *PUSER_PROPERTIES_HDR;

//
//  This structure maps out the whole of the user's Parameters field when
//  the user properties structure is present and at least one property is
//  defined.
//

typedef struct _USER_PROPERTIES {
    USER_PROPERTIES_HDR Header;
    USER_PROPERTY   FirstProperty;
} USER_PROPERTIES, *PUSER_PROPERTIES;

//
// forward references
//

NTSTATUS
UserPropertyAllocBlock (
    IN PUNICODE_STRING Existing,
    IN ULONG DesiredLength,
    IN OUT PUNICODE_STRING New
    );

BOOL
FindUserProperty (
    PUSER_PROPERTIES UserProperties,
    LPWSTR           Property,
    PUSER_PROPERTY  *pUserProperty,
    USHORT          *pCount
    );

VOID
RemoveUserProperty (
    UNICODE_STRING *puniUserParms,
    PUSER_PROPERTY  UserProperty,
    USHORT          Count,
    BOOL           *Update
    );


NTSTATUS
SetUserProperty (
    IN LPWSTR          UserParms,
    IN LPWSTR          Property,
    IN UNICODE_STRING  PropertyValue,
    IN WCHAR           PropertyFlag,
    IN BOOL            fDefaultValue,   // *
    OUT LPWSTR        *pNewUserParms,   // memory has to be freed afer use.
    OUT BOOL          *Update
    )
/*
    This function sets a property field in the user's Parameters field.
*/
{
    NTSTATUS status;
    UNICODE_STRING uniUserParms;
    UNICODE_STRING uniNewUserParms;
    USHORT Count = 0;
    USHORT PropertyLength;
    USHORT ValueLength;
    PUSER_PROPERTIES UserProperties;
    PUSER_PROPERTY   UserProperty;
    LPWSTR PropertyValueString = NULL;
    INT i;
    UCHAR *pchValue = NULL;

    // Check if parameters are correct.
    if (Property == NULL)
    {
        return( STATUS_INVALID_PARAMETER );
    }

    // Initialize output variables.
    *Update = FALSE;
    *pNewUserParms = NULL;

    // Converty UserParms to unicode string.
    uniUserParms.Buffer = UserParms;
    uniUserParms.Length = UserParms? (lstrlenW(UserParms) + 1)* sizeof (WCHAR)
                                   : 0;
    uniUserParms.MaximumLength = uniUserParms.Length;

    /** Get the length of the property name **/

    PropertyLength = (USHORT)(lstrlenW( Property ) * sizeof(WCHAR));

    /** Get the length of the property value **/
    ValueLength = PropertyValue.Length;

    if (ValueLength != 0)
    {
        // Converty property value to asci string so that
        // if property value is 0, it can be stored correctly.

        PropertyValueString = (LPWSTR) LocalAlloc (LPTR, (ValueLength+1)*sizeof (WCHAR));

        if ( !PropertyValueString ) {
            return( STATUS_INSUFFICIENT_RESOURCES );
        }
    
        pchValue = (UCHAR *) PropertyValue.Buffer;

        // Since wsprint converts 0x00 to 20 30 (20 is
        // space and 30 is 0), sscanf converts 20 30 to 0. If the
        // value is uncode string, this convertsion would not
        // convert back to original value. So if we want to store
        // some value in the UserParms, we have to pass in ansi
        // string.
        //
        // The reader does the proper counter to this, so the code is
        // symetrical.
        //
        //
        for (i = 0; i < ValueLength; i++)
        {
            wsprintfA ((PCHAR)(PropertyValueString+i), "%02x", *(pchValue+i));
        }

        *(PropertyValueString+ValueLength) = 0;
        ValueLength = ValueLength * sizeof (WCHAR);
    }

    //
    // check that user has valid property structure , if not, create one
    //

    if (UserParms != NULL)
    {
        Count = (USHORT)((lstrlenW (UserParms) + 1)* sizeof(WCHAR));
    }

    if (Count < sizeof( USER_PROPERTIES))
    {
        Count = sizeof( USER_PROPERTIES_HDR ) + sizeof(WCHAR);
    }

    if (ValueLength > 0)
    {
        Count += sizeof( USER_PROPERTY ) + PropertyLength + ValueLength;
    }

    if (Count > 0x7FFF)
    {
        // can't be bigger than 32K of user parms.
        return (STATUS_BUFFER_OVERFLOW);
    }

    status = UserPropertyAllocBlock( &uniUserParms,
                                     Count,
                                     &uniNewUserParms );

    if ( !NT_SUCCESS(status) )
    {
        return status;
    }

    // Make the output pNewUserParms point to uniNewUserPams's buffer
    // which is the new UserParms string.

    *pNewUserParms = uniNewUserParms.Buffer;

    UserProperties = (PUSER_PROPERTIES) uniNewUserParms.Buffer;

    if (FindUserProperty (UserProperties,
                          Property,
                          &UserProperty,
                          &Count))
    {
        RemoveUserProperty ( &uniNewUserParms,
                             UserProperty,
                             Count,
                             Update);
    }

    // We don't add the new property at all if FindUserProperty failed then
    // the property did not exist, if property did exist then RemoveUserProperty
    // would have removed it from the list.

    if( fDefaultValue )
    {
        *Update = TRUE;
        return STATUS_SUCCESS;
    }
    //
    //  If the new value of the property is not null, add it.
    //

    if (ValueLength > 0)
    {
        // find the end of the parameters list

        UserProperty = &(UserProperties->FirstProperty);

        for (Count = 1; Count <= UserProperties->Header.PropertyCount; Count++)
        {
            UserProperty = (PUSER_PROPERTY)
                               ((LPSTR)((LPSTR) UserProperty +
                                     sizeof(USER_PROPERTY) + // length of entry
                                     UserProperty->PropertyLength +
                                     UserProperty->ValueLength -
                                     sizeof(WCHAR)));  // for Property[0]
        }

        //
        // append it to the end and update length of string
        //

        UserProperty->PropertyFlag   = (PropertyFlag & NCP_SET) ?
                                        USER_PROPERTY_TYPE_SET :
                                        USER_PROPERTY_TYPE_ITEM;

        UserProperty->PropertyLength = PropertyLength;
        UserProperty->ValueLength    = ValueLength;

        RtlCopyMemory(  &(UserProperty->Property[0]),
                        Property,
                        PropertyLength );

        RtlCopyMemory(  &(UserProperty->Property[PropertyLength / sizeof(WCHAR)]),
                        PropertyValueString,
                        ValueLength );

        uniNewUserParms.Length +=
                        sizeof(USER_PROPERTY) + // length of entry
                        PropertyLength +    // length of property name string
                        ValueLength -       // length of value string
                        sizeof(WCHAR);      // account for WCHAR Property[1]

        UserProperties->Header.PropertyCount++;

        *Update = TRUE;
    }

    // UserParms is already null terminated. We don't need to set the
    // end of UserParms to be NULL since we zero init the buffer already.

    return( status );
} // SetUserProperty

#define MAPHEXTODIGIT(x) ( x >= '0' && x <= '9' ? (x-'0') :        \
                           x >= 'A' && x <= 'F' ? (x-'A'+10) :     \
                           x >= 'a' && x <= 'f' ? (x-'a'+10) : 0 )


NTSTATUS
QueryUserProperty (
    IN  LPWSTR          UserParms,
    IN  LPWSTR          PropertyName,
    OUT PWCHAR          PropertyFlag,
    OUT PUNICODE_STRING PropertyValue
    )
/*
    This routine returns a user definable property value as it is stored
    in the user's Parameters field.  Note that the RAS/MAC fields are
    stripped before we start processing user properties.
*/
{
    USHORT          PropertyNameLength;
    USHORT          Count;
    PUSER_PROPERTY  UserProperty;
    WCHAR          *Value;
    UINT            i;
    CHAR           *PropertyValueString;
    CHAR           *pchValue;

    // Set PropertyValue->Length to 0 initially. If the property is not found
    // it will still be 0 on exit.

    PropertyValue->Length = 0;
    PropertyValue->Buffer = NULL;

    PropertyNameLength = (USHORT)(lstrlenW(PropertyName) * sizeof(WCHAR));

    // Check if UserParms have the right structure.

    if (FindUserProperty ((PUSER_PROPERTIES) UserParms,
                          PropertyName,
                          &UserProperty,
                          &Count) )
    {

        Value = (LPWSTR)(LPSTR)((LPSTR) &(UserProperty->Property[0]) +
                                          PropertyNameLength);

        //
        //  Found the requested property
        //

        //
        //  Copy the property flag.
        //

        if (PropertyFlag)
            *PropertyFlag = UserProperty->PropertyFlag;

        // Allocate memory for PropertyValue->Buffer

        PropertyValueString = LocalAlloc ( LPTR, UserProperty->ValueLength+1);
        PropertyValue->Buffer = LocalAlloc ( LPTR, UserProperty->ValueLength/sizeof(WCHAR));

        //
        //  Make sure the property value length is valid.
        //
        if ((PropertyValue->Buffer == NULL) || (PropertyValueString == NULL))
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Copy the property value to the buffer.
        //

        RtlCopyMemory( PropertyValueString,
                       Value,
                       UserProperty->ValueLength );

        pchValue = (CHAR *) PropertyValue->Buffer;

        // Convert from value unicode string to value.
        for (i = 0; i < UserProperty->ValueLength/sizeof(WCHAR) ; i++)
        {
             // sscanf will trash memory.
             // sscanf( PropertyValueString+2*i, "%2x", pchValue+i);

             pchValue[i] = MAPHEXTODIGIT( PropertyValueString[2*i]) * 16 +
                           MAPHEXTODIGIT( PropertyValueString[2*i+1]);
        }

        PropertyValue->Length = UserProperty->ValueLength/sizeof(WCHAR);
        PropertyValue->MaximumLength = UserProperty->ValueLength/sizeof(WCHAR);

        LocalFree( PropertyValueString);
    }
    else
    {
        // if the property name does not exist we then load the default value
        // for this property

        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    return STATUS_SUCCESS;
} // QueryUserProperty


// Common routine used by QueryUserProperty() and SetUserProperty().

BOOL
FindUserProperty (
    PUSER_PROPERTIES UserProperties,
    LPWSTR           Property,
    PUSER_PROPERTY  *pUserProperty,
    USHORT          *pCount
    )
{
    BOOL   fFound = FALSE;
    USHORT PropertyLength;

    //
    // Check if user has valid property structure attached,
    // pointed to by UserProperties.
    //

    if (  ( UserProperties != NULL )
       && ( lstrlenW( (LPWSTR) UserProperties) * sizeof(WCHAR) >
            sizeof(UserProperties->Header.BacklevelParms))
       && ( UserProperties->Header.PropertySignature == USER_PROPERTY_SIGNATURE)
       )
    {
        //
        // user has valid property structure.
        //

        *pUserProperty = &(UserProperties->FirstProperty);

        PropertyLength = (USHORT)(lstrlenW( Property ) * sizeof(WCHAR));

        for ( *pCount = 1; *pCount <= UserProperties->Header.PropertyCount;
              (*pCount)++ )
        {
            if (  ( PropertyLength == (*pUserProperty)->PropertyLength )
               && ( RtlCompareMemory( &((*pUserProperty)->Property[0]),
                                      Property,
                                      PropertyLength ) == PropertyLength )
               )
            {
                fFound = TRUE;
                break;
            }

            *pUserProperty = (PUSER_PROPERTY)
                                     ((LPSTR) (*pUserProperty)
                                     + sizeof( USER_PROPERTY )
                                     + (*pUserProperty)->PropertyLength
                                     + (*pUserProperty)->ValueLength
                                     - sizeof(WCHAR));  // for Property[0]
        }
    }

    return( fFound );
} // FindUserProperty


// Remove a property field from the User Parms.

VOID
RemoveUserProperty (
    UNICODE_STRING *puniUserParms,
    PUSER_PROPERTY  UserProperty,
    USHORT          Count,
    BOOL           *Update
    )
{
    PUSER_PROPERTIES    UserProperties;
    PUSER_PROPERTY      NextProperty;
    USHORT              OldParmLength;

    UserProperties = (PUSER_PROPERTIES) puniUserParms->Buffer;

    OldParmLength = sizeof( USER_PROPERTY ) +
                    UserProperty->PropertyLength +
                    UserProperty->ValueLength -
                    sizeof(WCHAR);  // for Property[0]


    NextProperty = (PUSER_PROPERTY)(LPSTR)((LPSTR) UserProperty + OldParmLength);

    //
    // if we're not on the last one, copy the remaining buffer up
    //

    if (Count < UserProperties->Header.PropertyCount)
    {
        /*
         * Side note, remember it's not moving one property over
         * but it's removing one property by moving the entire set 
         * of the userparamblk but we need to include the nullterminator
         * sizeof( wchar )
         */

        RtlMoveMemory(  UserProperty,
                        NextProperty,
                        sizeof( WCHAR ) + puniUserParms->Length -
                        ((LPSTR) NextProperty -
                         (LPSTR) puniUserParms->Buffer ));
    }

    //
    //  Now reduce the length of the buffer by the amount we pulled out
    //

    puniUserParms->Length -= OldParmLength;

    UserProperties->Header.PropertyCount--;

    *Update = TRUE;
} // RemoveUserProperty


NTSTATUS
UserPropertyAllocBlock (
    IN PUNICODE_STRING     Existing,
    IN ULONG               DesiredLength,
    IN OUT PUNICODE_STRING New
    )
/*
    This allocates a larger block for user's parameters and copies the old
    block in.
*/
{
    PUSER_PROPERTIES    UserProperties;
    CLONG               Count;
    WCHAR               *pNewBuff;


    //
    //  We will allocate a new buffer to store the new parameters
    //  and copy the existing parameters into it.
    //

    New->Buffer = LocalAlloc (LPTR, DesiredLength);

    if ( New->Buffer == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    New->MaximumLength = (USHORT) DesiredLength;

    if (Existing != NULL)
    {

        New->Length = Existing->Length;

        RtlCopyMemory(  New->Buffer,
                        Existing->Buffer,
                        Existing->Length );
    }
    else
    {
        New->Length = 0;
    }

    //
    //  Ensure that we don't have any nulls in our string.
    //

    for ( Count = 0;
          Count < New->Length / sizeof(WCHAR);
          Count++ )
    {
        if (*(New->Buffer + Count) == L'\0')
        {
            New->Length = (USHORT) Count * sizeof(WCHAR);
            break;
        }
    }

    //
    //  now pad it out with spaces until reached Mac+Ras reserved length
    //

    pNewBuff = (WCHAR *) New->Buffer + ( New->Length / sizeof(WCHAR) );

    while ( New->Length < sizeof(UserProperties->Header.BacklevelParms))
    {
        *( pNewBuff++ ) = L' ';
        New->Length += sizeof(WCHAR);
    }

    //
    //  If the signature isn't there, stick it in and set prop count to 0
    //

    UserProperties = (PUSER_PROPERTIES) New->Buffer;

    if (New->Length < sizeof(USER_PROPERTIES_HDR) ||
        UserProperties->Header.PropertySignature != USER_PROPERTY_SIGNATURE)
    {

        UserProperties->Header.PropertySignature = USER_PROPERTY_SIGNATURE;
        UserProperties->Header.PropertyCount = 0;

        New->Length = sizeof(USER_PROPERTIES_HDR);
    }

    return STATUS_SUCCESS;
} // UserPropertyAllocBlock

// usrprop.c eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\regapi\usrprop.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    usrprop.h

Abstract:

    This is the public include file for some of the functions used by
    User Manager and Server Manager.

Author:

    Congpa You 02-Dec-1993  Created.

Revision History:

--*/

#ifndef _USRPROP_H_
#define _USRPROP_H_

#define USER_PROPERTY_SIGNATURE L'P'

#define NO_LIMIT  0xffff


#define USER_PROPERTY_TYPE_ITEM 1
#define USER_PROPERTY_TYPE_SET  2


NTSTATUS
SetUserProperty(
    IN LPWSTR             UserParms,
    IN LPWSTR             Property,
    IN UNICODE_STRING     PropertyValue,
    IN WCHAR              PropertyFlag,
    IN BOOL               fDefaultValue,
    OUT LPWSTR *          pNewUserParms,  // memory has to be freed after use.
    OUT BOOL *            Update
    );

NTSTATUS
QueryUserProperty (
    IN     LPWSTR       UserParms,
    IN     LPWSTR       Property,
    OUT PWCHAR          PropertyFlag,
    OUT PUNICODE_STRING PropertyValue
    );

#endif // _USRPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\client\rdhost\clientdatachannelmgr.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    CClientDataChannelMgr.cpp

Abstract:

    This module implements the CClientDataChannelMgr class, a
	Salem client-side data channel manager ... that abstracts
	access to the underlying protocol, so it can 
	be switched out at run-time.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#include "stdafx.h"

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_cldcmg"

#include "ClientDataChannelMgr.h"
#include <TSRDPRemoteDesktop.h>
//#include <rdchost_i.c>


///////////////////////////////////////////////////////
//
//  ClientChannelEventSink Methods
//

CClientChannelEventSink::~CClientChannelEventSink() 
{
    DC_BEGIN_FN("CClientChannelEventSink::~CClientChannelEventSink");

    ASSERT(m_Obj->IsValid());

    DC_END_FN();
}
void __stdcall 
CClientChannelEventSink::DataReady(
    BSTR data
    ) 
{
	DC_BEGIN_FN("CClientChannelEventSink::DataReady");
	ASSERT(data != NULL);
    m_Obj->OnChannelsReceivedDataChange(data);
	DC_END_FN();
}


///////////////////////////////////////////////////////
//
//	ClientDataChannel Members
//

ClientDataChannel::ClientDataChannel()
/*++

Routine Description:

    Constructor

Arguments:

Return Value:

    None.

 --*/
{
	DC_BEGIN_FN("ClientDataChannel::ClientDataChannel");

	DC_END_FN();
}

ClientDataChannel::~ClientDataChannel()
/*++

Routine Description:

    Destructor

Arguments:

Return Value:

    None.

 --*/
{
	DC_BEGIN_FN("ClientDataChannel::~ClientDataChannel");

	//
	//	Notify the channel manager that we have gone away.
	//
	m_ChannelMgr->RemoveChannel(m_ChannelName);

	//
	//	Give up our reference to the channel manager.
	//
	m_ChannelMgr->Release();

	DC_END_FN();
}

void ClientDataChannel::Initialize(
	CClientDataChannelMgr *mgr,
	BSTR channelName
	) 
/*++

Routine Description:

	Initialize an instance of this class.      

Arguments:

Return Value:

    None.

 --*/
{
	DC_BEGIN_FN("ClientDataChannel::Initialize");

	m_ChannelMgr = mgr;
	m_ChannelMgr->AddRef();
	m_ChannelName = channelName;

	DC_END_FN();
}

STDMETHODIMP 
ClientDataChannel::ReceiveChannelData(
	BSTR *data
	)
/*++

Routine Description:

    Receive the next complete data packet on this channel.

Arguments:

	data	-	The next data packet.  Should be released by the
				caller.

Return Value:

    S_OK on success.  Otherwise, an error result is returned.

 --*/
{
	HRESULT result;

	DC_BEGIN_FN("ClientDataChannel::ReceiveChannelData");

	result = m_ChannelMgr->ReadChannelData(m_ChannelName, data);

	DC_END_FN();

	return result;
}

STDMETHODIMP 
ClientDataChannel::SendChannelData(
	BSTR data
	)
/*++

Routine Description:

    Send data on this channel.

Arguments:

	data	-	Data to send.

Return Value:

    S_OK on success.  Otherwise, an error result is returned.

 --*/
{
	HRESULT hr;

	DC_BEGIN_FN("ClientDataChannel::SendChannelData");
	hr = m_ChannelMgr->SendChannelData(m_ChannelName, data);
	DC_END_FN();

	return hr;
}

STDMETHODIMP 
ClientDataChannel::put_OnChannelDataReady(
	IDispatch * newVal
	)
/*++

Routine Description:

    SAFRemoteDesktopDataChannel Scriptable Event Object Registration 
    Properties

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error status is returned.

 --*/
{
	DC_BEGIN_FN("ClientDataChannel::put_OnChannelDataReady");
	m_OnChannelDataReady = newVal;
	DC_END_FN();
	return S_OK;
}

STDMETHODIMP 
ClientDataChannel::get_ChannelName(
	BSTR *pVal
	)
/*++

Routine Description:

    Return the channel name.

Arguments:

	pVal	-	Returned channel name.

Return Value:

    S_OK on success.  Otherwise, an error status is returned.

 --*/
{
	DC_BEGIN_FN("ClientDataChannel::get_ChannelName");

	CComBSTR str;
	str = m_ChannelName;
	*pVal = str.Detach();

	DC_END_FN();

	return S_OK;
}

/*++

Routine Description:

    Called when data is ready on our channel.

Arguments:

	pVal	-	Returned channel name.

Return Value:

    S_OK on success.  Otherwise, an error status is returned.

 --*/
VOID 
ClientDataChannel::DataReady()
{
	DC_BEGIN_FN("ClientDataChannel::DataReady");

	//
	//	Fire our data ready event.
	//
	Fire_ChannelDataReady(m_ChannelName, m_OnChannelDataReady);

	DC_END_FN();
}


///////////////////////////////////////////////////////
//
//  CClientDataChannelMgr Methods
//

CClientDataChannelMgr::CClientDataChannelMgr()
/*++

Routine Description:

    Constructor

Arguments:

    tsClient    -   Backpointer to TS client ActiveX control.

Return Value:

 --*/
{
    DC_BEGIN_FN("CClientDataChannelMgr::CClientDataChannelMgr");

    //
    //  Not valid until initialized.
    //
    SetValid(FALSE);

    //
    //  Initialize the event sink.
    //
    m_EventSink.m_Obj = this;

    DC_END_FN();
}

CClientDataChannelMgr::~CClientDataChannelMgr()
/*++

Routine Description:

    Destructor

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CClientDataChannelMgr::~CClientDataChannelMgr");

	//
	//	Unregister the previously registered event sink.
	//
	if (m_IOInterface != NULL) {
		m_EventSink.DispEventUnadvise(m_IOInterface);
	}

	//
	//	Release the IO interface.
	//
	m_IOInterface = NULL;


    DC_END_FN();
}

HRESULT
CClientDataChannelMgr::Initialize()
/*++

Routine Description:

    Initialize an instance of this class.

Arguments:

Return Value:

    Returns ERROR_SUCCESS on success.  Otherwise, an error status is returned.

 --*/
{
    DC_BEGIN_FN("CClientDataChannelMgr::Initialize");

    HRESULT hr;

    //
    //  Shouldn't be valid yet.
    //
    ASSERT(!IsValid());

    //
    //  Initialize the parent class.
    //  
    hr = CRemoteDesktopChannelMgr::Initialize();
	if (hr != S_OK) {
		goto CLEANUPANDEXIT;
	}

CLEANUPANDEXIT:

    SetValid(hr == S_OK);

    DC_END_FN();

    return hr;
}

VOID 
CClientDataChannelMgr::SetIOInterface(
	IDataChannelIO *val
	)
/*++

Routine Description:

    Set the Data Channel IO Interface.  This is implemented by the protocol-
	specific layer.

Arguments:

    val	- New IO interface.	

Return Value:

    ERROR_SUCCESS is returned on success.  Otherwise, an error code
    is returned.

 --*/
{
	DC_BEGIN_FN("CClientDataChannelMgr::SetIOInterface");

	HRESULT hr;

	//
	//	Unregister the previously registered event sink and register
	//	the new event sink.
	//
	if (m_IOInterface != NULL) {
		m_EventSink.DispEventUnadvise(m_IOInterface);
	}
	m_IOInterface = val;
	if (val != NULL) {
		hr = m_EventSink.DispEventAdvise(m_IOInterface);
		if (hr != S_OK) {
			TRC_ERR((TB, TEXT("DispEventAdvise:  %08X"), hr));
			goto CLEANUPANDEXIT;
		}
	}

CLEANUPANDEXIT:

	DC_END_FN();
}

HRESULT 
CClientDataChannelMgr::SendData(
    PREMOTEDESKTOP_CHANNELBUFHEADER msg 
    )
/*++

Routine Description:

    Send Function Invoked by Parent Class

Arguments:

    msg -   The underlying data storage for the msg is a BSTR so that 
            it is compatible with COM methods.

Return Value:

    ERROR_SUCCESS is returned on success.  Otherwise, an error code
    is returned.

 --*/
{
	DC_BEGIN_FN("CClientDataChannelMgr::SendData");

	//
	//	Hand off to the data IO manager.
	//
	ASSERT(m_IOInterface != NULL);
	HRESULT hr = m_IOInterface->SendData((BSTR)msg);

	DC_END_FN();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\client\rdhost\clientdatachannelmgr.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    ClientDataChannelMgr.h

Abstract:

    This module implements the CClientDataChannelMgr class, a
	Salem client-side data channel manager ... that abstracts
	access to the underlying protocol, so it can 
	be switched out at run-time.

Author:

    Tad Brockway 06/00

Revision History:

--*/

#ifndef __CLIENTDATACHANNELMGR_H__
#define __CLIENTDATACHANNELMGR_H__

#include <DataChannelMgr.h>
#include "resource.h"       
#include <atlctl.h>
#include <rdchost.h>
#include <rdschan.h>
#include "ClientDataChannelMgrP.h"


#define IDC_EVENT_SOURCE_OBJ 1

//
// Info for all the event functions is entered here
// there is a way to have ATL do this automatically using typelib's
// but it is slower.
//
static _ATL_FUNC_INFO DCEventFuncNoParamsInfo =
{
            CC_STDCALL,     // Calling convention.
            VT_EMPTY,       // Return type.
            0,              // Number of arguments.
            {VT_EMPTY}      // Argument types.
};

static _ATL_FUNC_INFO DCEventFuncLongParamInfo =
{
            CC_STDCALL,     // Calling convention.
            VT_EMPTY,       // Return type.
            1,              // Number of arguments.
            {VT_I4}         // Argument types.
};

static _ATL_FUNC_INFO DCEventFuncOneStringParamInfo =
{
            CC_STDCALL,     // Calling convention.
            VT_EMPTY,       // Return type.
            1,              // Number of arguments.
            {VT_BSTR}       //  Argument types
};


///////////////////////////////////////////////////////
//
//  CClientChannelEventSink
//

class CClientDataChannelMgr;
class CClientChannelEventSink :
        public IDispEventSimpleImpl<IDC_EVENT_SOURCE_OBJ, CClientChannelEventSink,
                   &DIID__IDataChannelIOEvents>,
        public CRemoteDesktopTopLevelObject
{
public:

    CClientDataChannelMgr *m_Obj;            
        
public:

    CClientChannelEventSink()
    {
        m_Obj = NULL;
    }
    ~CClientChannelEventSink();

    BEGIN_SINK_MAP(CClientChannelEventSink)
        SINK_ENTRY_INFO(IDC_EVENT_SOURCE_OBJ, DIID__IDataChannelIOEvents, 
                        DISPID_DATACHANNELEVEVENTS_DATAREADY, 
						DataReady, 
                        &DCEventFuncOneStringParamInfo)
    END_SINK_MAP()

    void __stdcall DataReady(BSTR data);

    //
    //  Return the name of this class.
    //
    virtual const LPTSTR ClassName() {
        return TEXT("CClientChannelEventSink");
    }
};


///////////////////////////////////////////////////////
//
//	ClientDataChannel	
//
//	Client-Specific Subclass of CRemoteDesktopDataChannel.	
//

class ATL_NO_VTABLE ClientDataChannel : 
	public CRemoteDesktopDataChannel,
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<ClientDataChannel, &CLSID_ClientDataChannel>,
	public IConnectionPointContainerImpl<ClientDataChannel>,
	public IDispatchImpl<ISAFRemoteDesktopDataChannel, &IID_ISAFRemoteDesktopDataChannel, &LIBID_RDCCLIENTHOSTLib>,
	public IProvideClassInfo2Impl<&CLSID_ClientDataChannel, NULL, &LIBID_RDCCLIENTHOSTLib>,
	public CProxy_ISAFRemoteDesktopDataChannelEvents< ClientDataChannel >
{
protected:

	//
	//	Scriptable Event Callback Object
	//
	CComPtr<IDispatch>  m_OnChannelDataReady;

	//
	//	Back pointer to the channel manager.
	//	
	CClientDataChannelMgr *m_ChannelMgr;

public:

	//
	//	Constructor/Destructor
	//
	ClientDataChannel();
	virtual ~ClientDataChannel();

    //  
    //  Initialize an instance of this class.      
    //
    virtual void Initialize(
				CClientDataChannelMgr *mgr,
				BSTR channelName
				);

DECLARE_REGISTRY_RESOURCEID(IDR_CLIENTDATACHANNEL)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(ClientDataChannel)
	COM_INTERFACE_ENTRY(ISAFRemoteDesktopDataChannel)
	COM_INTERFACE_ENTRY2(IDispatch, ISAFRemoteDesktopDataChannel)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()
BEGIN_CONNECTION_POINT_MAP(ClientDataChannel)
    CONNECTION_POINT_ENTRY(DIID__ISAFRemoteDesktopDataChannelEvents)
END_CONNECTION_POINT_MAP()

	//
	//	ISAFRemoteDesktopDataChannel Methods
	//
	//	The parent class handles the details of these methods.
	//

	STDMETHOD(ReceiveChannelData)(/*[out, retval]*/BSTR *data);
	STDMETHOD(SendChannelData)(BSTR data);
	STDMETHOD(put_OnChannelDataReady)(/*[in]*/ IDispatch * newVal);
	STDMETHOD(get_ChannelName)(/*[out, retval]*/ BSTR *pVal);

	//
	//	Called to return our ISAFRemoteDesktopDataChannel interface.
	//
	virtual HRESULT GetISAFRemoteDesktopDataChannel(
				ISAFRemoteDesktopDataChannel **channel
				) {
		HRESULT hr;				
		hr = this->QueryInterface(
					IID_ISAFRemoteDesktopDataChannel, (PVOID*)channel
					);
		return hr;					
	}
				
	//
	//	Called by the data channel manager when data is ready on our channel.
	//	
    virtual VOID DataReady();

    //
    //  Return this class name.
    //
    virtual const LPTSTR ClassName()    { return TEXT("ClientDataChannel"); }
};


///////////////////////////////////////////////////////
//
//  CClientDataChannelMgr
//

class CClientDataChannelMgr : 
	public CRemoteDesktopChannelMgr,
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CClientDataChannelMgr, &CLSID_ClientRemoteDesktopChannelMgr>,
	public IDispatchImpl<ISAFRemoteDesktopChannelMgr, &IID_ISAFRemoteDesktopChannelMgr, &LIBID_RDCCLIENTHOSTLib>
{
protected:

	CComPtr<IDataChannelIO> m_IOInterface;		
	CClientChannelEventSink m_EventSink;

    //  
    //  Send Function Invoked by Parent Class
    //
    //  The underlying data storage for the msg is a BSTR so that it is compatible
    //  with COM methods.
    //
    virtual HRESULT SendData(PREMOTEDESKTOP_CHANNELBUFHEADER msg);

	//
	//	Help the parent class out by opening the right channel object
	//	for the platform.
	//
	virtual CRemoteDesktopDataChannel *OpenPlatformSpecificDataChannel(
										BSTR channelName,
										ISAFRemoteDesktopDataChannel **channel
										) 
	{
		CComObject<ClientDataChannel> *obj;
		obj = new CComObject<ClientDataChannel>();
		if (obj != NULL) {
			obj->Initialize(this, channelName);
			obj->QueryInterface(
						__uuidof(ISAFRemoteDesktopDataChannel), 
						(PVOID *)channel
						);
		}
		return obj;
	}

public:

    //
    //  Constructor/Destructor
    //
    CClientDataChannelMgr();
    ~CClientDataChannelMgr();

	DECLARE_REGISTRY_RESOURCEID(IDR_CLIENTREMOTEDESTKOPCHANNELMGR)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CClientDataChannelMgr)
	COM_INTERFACE_ENTRY(ISAFRemoteDesktopChannelMgr)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

	// 
	//	ISAFRemoteDesktopChannelMgr Methods
	//
	STDMETHOD(OpenDataChannel)(BSTR name, ISAFRemoteDesktopDataChannel **channel) 
	{
		//
		//	Let the parent handle it.
		//
		return OpenDataChannel_(name, channel);
	}

	//
	//	Set the Data Channel IO Interface.  This is implemented by the protocol-
	//	specific layer.
	//
	VOID SetIOInterface(IDataChannelIO *val);

    //  
    //  Initialize an instance of this class.      
    //
    virtual HRESULT Initialize();

    //
    //  Called on new channel data.
    //
    HRESULT __stdcall OnChannelsReceivedDataChange(
                                            BSTR data
                                            ) {
		//
		//	Forward to the parent class.
		//
		DataReady(data);
		return S_OK;
	}

    //
    //  Return this class name.
    //
    virtual const LPTSTR ClassName()    
        { return TEXT("CClientDataChannelMgr"); }

};

#endif //__CLIENTDATACHANNELMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\client\rdhost\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__167CA20A_3E71_4F51_897E_0D7458201176__INCLUDED_)
#define AFX_DLLDATAX_H__167CA20A_3E71_4F51_897E_0D7458201176__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__167CA20A_3E71_4F51_897E_0D7458201176__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\client\rdhost\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "RDCHost_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\client\rdhost\clientdatachannelmgrp.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    DataChannelMgrP.h

Abstract:

    Wizard-generated code for invoking data channel event sink functions.

    I added the "scriptDisp" field.  If it is non-NULL, then its default method
    will be called along with any registered interfaces.  This is to accomodate
    script clients that need to bind their event interfaces when the script
    engine initializes.  Our objects are dynamically retrieved by the client
    script or application post-init.

Author:

    Tad Brockway 06/00

Revision History:

--*/

#ifndef _DATACHANNELMGRP_H_
#define _DATACHANNELMGRP_H_

#include <atlcom.h>

template <class T>
class CProxy_ISAFRemoteDesktopDataChannelEvents : public IConnectionPointImpl<T, &DIID__ISAFRemoteDesktopDataChannelEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_ChannelDataReady(BSTR channelName, IDispatch *scriptDisp=NULL)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
        
        if (pvars) {
            int nConnections = m_vec.GetSize();
		
		    for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		    {
			    pT->Lock();
			    CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			    pT->Unlock();
			    IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			    if (pDispatch != NULL)
			    {
				    pvars[0] = channelName;
				    DISPPARAMS disp = { pvars, NULL, 1, 0 };
				    pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			    }
		    }

            //
            //  Invoke the scriptable IDispatch interface, if specified.
            //
            if (scriptDisp != NULL) {
                pvars[0] = channelName;
                DISPPARAMS disp = { pvars, NULL, 1, 0 };
                HRESULT hr = scriptDisp->Invoke(0x0, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }

	        delete[] pvars;
        }
	
	}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\client\rdhost\rdchost.cpp ===
// RDCHost.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for RDCHost.idl by adding the following 
//      files to the Outputs.
//          RDCHost_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f RDCHostps.mk in the project directory.

#include "stdafx.h"

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_rdchst"

#include "resource.h"
#include <initguid.h>
#include "RDCHost.h"
#include "dlldatax.h"

#include "RDCHost_i.c"
#include "RemoteDesktopClientHost.h"
#include "RemoteDesktopClient.h"
#include "TSRDPRemoteDesktopClient.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SAFRemoteDesktopClientHost, CRemoteDesktopClientHost)
OBJECT_ENTRY(CLSID_SAFRemoteDesktopClient, CRemoteDesktopClient)
OBJECT_ENTRY(CLSID_TSRDPRemoteDesktopClient, CTSRDPRemoteDesktopClient)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;

#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_RDCCLIENTHOSTLib);
        DisableThreadLibraryCalls(hInstance);
        AttachDebuggerIfAsked(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}


#include "RemoteDesktopClient.h"
#include "TSRDPRemoteDesktopClient.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\client\rdhost\rdchostcp.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RDCHostCP.h

Abstract:

    Wizard-generated code for invoking client-side event sink functions.

    I added the "scriptDisp" field.  If it is non-NULL, then its default method
    will be called along with any registered interfaces.  This is to accomodate
    script clients that need to bind their event interfaces when the script
    engine initializes.  Our objects are dynamically retrieved by the client
    script or application post-init.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef _RDCHOSTCP_H_
#define _RDCHOSTCP_H_


///////////////////////////////////////////////////////
//
//  CProxy_IRemoteDesktopClientEvents
//
//	Proxy for IRemoteDesktopClientEvents.
//

template <class T>
class CProxy_ISAFRemoteDesktopClientEvents : public IConnectionPointImpl<T, &DIID__ISAFRemoteDesktopClientEvents, CComDynamicUnkArray>
{
public:
	VOID Fire_Connected(IDispatch *scriptDisp=NULL)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				HRESULT hr = pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}

        //
        //  Invoke the scriptable IDispatch interface, if specified.
        //
        if (scriptDisp != NULL) {
			DISPPARAMS disp = { NULL, NULL, 0, 0 };
			HRESULT hr = scriptDisp->Invoke(0x0, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
        }

	}
	VOID Fire_Disconnected(LONG reason, IDispatch *scriptDisp=NULL)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
        
        if (pvars) {
		    int nConnections = m_vec.GetSize();
		
		    for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		    {
			    pT->Lock();
			    CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			    pT->Unlock();
			    IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			    if (pDispatch != NULL)
			    {
    				pvars[0] = reason;
				    DISPPARAMS disp = { pvars, NULL, 1, 0 };
				    HRESULT hr = pDispatch->Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			    }
		    }

            //
            //  Invoke the scriptable IDispatch interface, if specified.
            //
            if (scriptDisp != NULL) {
    			pvars[0] = reason;
	    		DISPPARAMS disp = { pvars, NULL, 1, 0 };
			    HRESULT hr = scriptDisp->Invoke(0x0, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
    
	    	delete[] pvars;
	    }
    }


	VOID Fire_RemoteControlRequestComplete(LONG status, IDispatch *scriptDisp=NULL)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];

        if (pvars) {
		    int nConnections = m_vec.GetSize();
		
		    for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		    {
			    pT->Lock();
			    CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			    pT->Unlock();
			    IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			    if (pDispatch != NULL)
			    {
    				pvars[0] = status;
	    			DISPPARAMS disp = { pvars, NULL, 1, 0 };
				    HRESULT hr = pDispatch->Invoke(0x4, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			    }
		    }

            //
            //Invoke the scriptable IDispatch interface, if specified.
            //
            if (scriptDisp != NULL) {
			    pvars[0] = status;
			    DISPPARAMS disp = { pvars, NULL, 1, 0 };
			    HRESULT hr = scriptDisp->Invoke(0, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }

		    delete[] pvars;
	    }
    }

	
    VOID Fire_ListenConnect(LONG status, IDispatch *scriptDisp=NULL)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];

        if (pvars) {
		    int nConnections = m_vec.GetSize();
		
    		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
	    	{
		    	pT->Lock();
    			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
	    		pT->Unlock();
			    IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			    if (pDispatch != NULL)
			    {
    				pvars[0] = status;
	    			DISPPARAMS disp = { pvars, NULL, 1, 0 };
				    HRESULT hr = pDispatch->Invoke(0x5, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			    }
		    }

            //
            //  Invoke the scriptable IDispatch interface, if specified.
            //
            if (scriptDisp != NULL) {
			    pvars[0] = status;
			    DISPPARAMS disp = { pvars, NULL, 1, 0 };
			    HRESULT hr = scriptDisp->Invoke(0, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }

		    delete[] pvars;
	    }
    }

	VOID Fire_BeginConnect(IDispatch *scriptDisp=NULL)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				HRESULT hr = pDispatch->Invoke(0x6, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}

        //
        //  Invoke the scriptable IDispatch interface, if specified.
        //
        if (scriptDisp != NULL) {
			DISPPARAMS disp = { NULL, NULL, 0, 0 };
			HRESULT hr = scriptDisp->Invoke(0x0, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
        }

	}
};


///////////////////////////////////////////////////////
//
//  CProxy_IDataChannelIOEvents
//
//	Proxy for IDataChannelIOEvents
//

template <class T>
class CProxy_IDataChannelIOEvents : public IConnectionPointImpl<T, &DIID__IDataChannelIOEvents, CComDynamicUnkArray>
{
public:
	VOID Fire_DataReady(BSTR data)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		VARIANT vars[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				vars[0].vt = VT_BSTR;
				vars[0].bstrVal = data;
				DISPPARAMS disp = { (VARIANT*)&vars, NULL, 1, 0 };
				HRESULT hr = pDispatch->Invoke(DISPID_DATACHANNELEVEVENTS_DATAREADY, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\client\rdhost\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\client\rdhost\remotedesktopclient.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RemoteDesktopClient

Abstract:

    The CRemoteDesktopClient class is the parent 
    class for the Remote Desktop class hierarchy on the server-side.  
    It helps the CRemoteDesktopClientHost class to implement 
    the ISAFRemoteDesktopClient interface.  
    
    The Remote Desktop class hierarchy provides a pluggable C++ interface 
    for remote desktop access, by abstracting the implementation 
    specific details of remote desktop access for the server-side.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#include "stdafx.h"

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_rdclnt"

#include "RDCHost.h"
#include "RemoteDesktopClient.h"
#include <RemoteDesktopUtils.h>
#include "ClientDataChannelMgr.h"

#include <algorithm>

using namespace std;


///////////////////////////////////////////////////////
//
//  CRemoteDesktopClientEventSink Methods
//

void __stdcall 
CRemoteDesktopClientEventSink::OnConnected()
{
    m_Obj->OnConnected();
}
void __stdcall 
CRemoteDesktopClientEventSink::OnDisconnected(long reason)
{
    m_Obj->OnDisconnected(reason);
}
void __stdcall 
CRemoteDesktopClientEventSink::OnConnectRemoteDesktopComplete(long status)
{
    m_Obj->OnConnectRemoteDesktopComplete(status);
}
void __stdcall 
CRemoteDesktopClientEventSink::OnListenConnect(long status)
{
    m_Obj->OnListenConnect(status);
}
void __stdcall 
CRemoteDesktopClientEventSink::OnBeginConnect()
{
    m_Obj->OnBeginConnect();
}


///////////////////////////////////////////////////////
//
//  CRemoteDesktopClient Methods
//

HRESULT 
CRemoteDesktopClient::FinalConstruct()
/*++

Routine Description:

    Final Constructor

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopClient::FinalConstruct");

    //
    //  Register with ActiveX
    //
    HRESULT hr = S_OK;

    if (!AtlAxWinInit()) {
        TRC_ERR((TB, L"AtlAxWinInit failed."));
        hr = E_FAIL;
    }

    //
    //  Create the Data Channel Manager 
    //
    m_ChannelMgr = new CComObject<CClientDataChannelMgr>();
    m_ChannelMgr->AddRef();

    //
    //  Initialize the channel mnager
    //
    hr = m_ChannelMgr->Initialize();

    DC_END_FN();
    return hr;
}

CRemoteDesktopClient::~CRemoteDesktopClient()
/*++

Routine Description:

    Destructor

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopClient::~CRemoteDesktopClient");

    DisconnectFromServer();

    //
    //  !!!!NOTE!!!!
    //  Cleaning up the contained m_Client control is being done in the destructor
    //  for Windows XP to make sure it and the MSTSCAX control are not destroyed
    //  in a callback to PC Health via a DisconnectFromServer invokation.  Cleaning
    //  up here removes late-binding of the protocol in that once we connect one time
    //  to a particular protocol type (RDP only for XP), we can't later connect using
    //  some other protocol.  
    //
    //  If we are to support other protocol types in the future, then the clean up
    //  should be done in the DisconnectFromServer so we can rebind to a different protocol
    //  on each ConnectToServer call.  To make this work, we will need to clean up MSTCAX
    //  and the TSRDP Salem control so they can be destroyed in a callback.  I (TadB) actually
    //  had this working for the TSRDP Salem control in an afternoon.  

    //
    //  Zero out the IO interface ptr for the channel manager, since it is 
    //  going away.
    //
    if (m_ChannelMgr != NULL) {
        m_ChannelMgr->SetIOInterface(NULL);
    }

    if (m_Client != NULL) {
        m_Client = NULL;
    }

    if (m_ClientWnd != NULL) {
        m_ClientAxView.DestroyWindow();
        m_ClientWnd = NULL;
    }

    //
    //  Release the data channel manager.
    //
    m_ChannelMgr->Release();

    if ( NULL != m_ExtDllName )
        SysFreeString( m_ExtDllName );

    if ( NULL != m_ExtParams )
        SysFreeString( m_ExtParams );

    DC_END_FN();
}

STDMETHODIMP 
CRemoteDesktopClient::get_IsServerConnected(
    BOOL *pVal
    )
/*++

Routine Description:

    Indicates whether the client-side Remote Desktop Host ActiveX Control is
    connected to the server, independent of whether the remote user's desktop
    is currently remote controlled.

Arguments:

    pVal  - Set to TRUE if the client is currently connected to the server.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopClient::get_IsServerConnected");
    HRESULT hr;

    if (pVal == NULL) {
        ASSERT(FALSE);
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto CLEANUPANDEXIT;
    }

    if (m_Client != NULL) {
        hr = m_Client->get_IsServerConnected(pVal);
    }
    else {
        *pVal = FALSE;
        hr = S_OK;
    }

CLEANUPANDEXIT:

    DC_END_FN();
    return hr;
}

STDMETHODIMP 
CRemoteDesktopClient::get_IsRemoteDesktopConnected(
    BOOL *pVal
    )
/*++

Routine Description:

    Indicates whether the control is currently connected to the server
    machine.

Arguments:

    pVal  - Sets to TRUE if the control is currently connected to the server.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopClient::get_IsRemoteDesktopConnected");
    HRESULT hr;

    if (pVal == NULL) {
        ASSERT(FALSE);
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto CLEANUPANDEXIT;
    }

    if (m_Client != NULL) {
        hr = m_Client->get_IsRemoteDesktopConnected(pVal);
    }
    else {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
    }

CLEANUPANDEXIT:
    DC_END_FN();
    return hr;
}

STDMETHODIMP 
CRemoteDesktopClient::get_ExtendedErrorInfo(
    LONG *error
    )
/*++

Routine Description:

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopClient::get_ExtendedErrorInfo");

    HRESULT hr;

    if (error == NULL) {
        ASSERT(FALSE);
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto CLEANUPANDEXIT;
    }

    if (m_Client != NULL) {
        hr = m_Client->get_ExtendedErrorInfo(error);
    }
    else {
        hr = S_OK;
        *error = SAFERROR_NOERROR;
    }

CLEANUPANDEXIT:

    DC_END_FN();

    return hr;
}

STDMETHODIMP 
CRemoteDesktopClient::DisconnectRemoteDesktop()
/*++

Routine Description:

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopClient::DisconnectRemoteDesktop");
    HRESULT hr;

    //
    //  Hide our window.
    //
    //ShowWindow(SW_HIDE);
    m_RemoteControlEnabled = FALSE;

    if (m_Client != NULL) {
        hr = m_Client->DisconnectRemoteDesktop();
    }
    else {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
    }

    DC_END_FN();
    return hr;
}

STDMETHODIMP 
CRemoteDesktopClient::ConnectRemoteDesktop()
/*++

Routine Description:

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopClient::ConnectRemoteDesktop");
    HRESULT hr;

    if (m_Client != NULL) {
        hr = m_Client->ConnectRemoteDesktop();
    }
    else {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
    }

    DC_END_FN();
    return hr;
}

HRESULT
CRemoteDesktopClient::InitializeRemoteDesktopClientObject()
/*++

Routine Description:

    Routine to initialize window for actvie x control and setups our channel manager

Parameters: 

    None.

Returns:

    S_OK or error code.

Notes:

    put_EnableSmartSizing() is not invoked in here because on listen mode, we
    create/initialize object first then goes into actual connection, two seperate calls, 
    and so it is possible for caller to invoke smartsizeing in-between and we will
    never pick it up, both ConnectToServer() and AcceptListenConnection() 
    need to make the call.

--*/
{
    DC_BEGIN_FN("CRemoteDesktopClient::InitializeRemoteDesktopClientObject");
    HRESULT hr = S_OK;
    IUnknown *pUnk = NULL;
    RECT ourWindowRect; 
    RECT rcClient;
    CComPtr<IDataChannelIO> ioInterface;

    //
    //  Get the dimensions of our window.
    //
    if (!::GetWindowRect(m_hWnd, &ourWindowRect)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        TRC_ERR((TB, L"GetWindowRect:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Create the client Window.
    //
    rcClient.top    = 0;
    rcClient.left   = 0;
    rcClient.right  = ourWindowRect.right - ourWindowRect.left;
    rcClient.bottom = ourWindowRect.bottom - ourWindowRect.top;
    m_ClientWnd = m_ClientAxView.Create(
                            m_hWnd, rcClient, REMOTEDESKTOPRDPCLIENT_TEXTGUID,
                            WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN, 0
                            );

    if (m_ClientWnd == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        TRC_ERR((TB, L"Window Create:  %08X", GetLastError()));
        goto CLEANUPANDEXIT;
    }
    ASSERT(::IsWindow(m_ClientWnd));

    //
    //  Get IUnknown
    //
    hr = AtlAxGetControl(m_ClientWnd, &pUnk);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"AtlAxGetControl:  %08X", hr));
        pUnk = NULL;
        goto CLEANUPANDEXIT;
    }

    //
    //  Get the control.
    //
    hr = pUnk->QueryInterface(__uuidof(ISAFRemoteDesktopClient), (void**)&m_Client);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"QueryInterface:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the event sink.
    //
    m_ClientEventSink.m_Obj = this;

    //
    //  Add the event sink.
    //
    hr = m_ClientEventSink.DispEventAdvise(pUnk);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"DispEventAdvise:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Get the Data IO interface from the control so we can talk
    //  over an OOB data channel.
    //
    hr = pUnk->QueryInterface(__uuidof(IDataChannelIO), (void**)&ioInterface);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"QueryInterface:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Pass the channel manager to the control.
    //
    ioInterface->put_ChannelMgr(m_ChannelMgr);

    //
    //  Indicate the current data io provider to the channel manager
    //  because it just changed.
    //
    m_ChannelMgr->SetIOInterface(ioInterface);

CLEANUPANDEXIT:

    //
    //  m_Client keeps our reference to the client object until
    //  it ref counts to zero.
    //
    if (pUnk != NULL) {
        pUnk->Release();
    }

    return hr;
}    


STDMETHODIMP 
CRemoteDesktopClient::ConnectToServer(BSTR bstrExpertBlob)
/*++

Routine Description:

Arguments:

    bstrExpertBlob : Optional blob to be transmitted over to user side, this
                     is used only in the case of SAF resolver.

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopClient::ConnectToServer");
    HRESULT hr;
    DWORD protocolType;
    CComBSTR tmp;
    CComBSTR helpSessionId;
    DWORD result;
    CComBSTR channelInfo;
    ChannelsType::iterator element;
    DWORD dwConnParmVersion;
    WCHAR buf[MAX_PATH];
 
    //
    //  Check the connection parameters.
    //
    if (m_ConnectParms.Length() == 0) {
        ASSERT(FALSE);
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto CLEANUPANDEXIT;
    }

    //
    //  Parse the connection parms to get the type of server
    //  to which we are connecting.
    //
    result = ParseConnectParmsString(
                            m_ConnectParms, &dwConnParmVersion, &protocolType, tmp, tmp,
                            tmp, helpSessionId, tmp, tmp,
                            tmp
                            );
    if (result != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(result);
        goto CLEANUPANDEXIT;
    }

    //
    //  Right now, we only support the TSRDP client.
    //  TODO:    We should make this pluggable for Whistler timeframe
    //           via registry defined CLSID's.
    //
    if (protocolType != REMOTEDESKTOP_TSRDP_PROTOCOL) {
        TRC_ERR((TB, L"Unsupported protocol:  %ld", protocolType));
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto CLEANUPANDEXIT; 
    }

    if( m_Client == NULL) {
        hr = InitializeRemoteDesktopClientObject();
        if( FAILED(hr) ) {
            TRC_ERR((TB, L"InitializeRemoteDesktopClientObject() failed with :  %x", hr));
            goto CLEANUPANDEXIT;
        }
    }

    //
    //  Enable/disable smart sizing.
    //
    hr = m_Client->put_EnableSmartSizing(m_EnableSmartSizing);
    if (!SUCCEEDED(hr)) {
        goto CLEANUPANDEXIT;
    }

    hr = m_Client->put_ColorDepth(m_ColorDepth);
    if (!SUCCEEDED(hr)) {
        goto CLEANUPANDEXIT;
    }

    //
    //  setup the test extension
    //
    _PutExtParams();

    //
    //  Connect.
    //
    m_Client->put_ConnectParms(m_ConnectParms);
    hr = m_Client->ConnectToServer(bstrExpertBlob);

CLEANUPANDEXIT:

    DC_END_FN();
    return hr;
}

STDMETHODIMP 
CRemoteDesktopClient::DisconnectFromServer()
/*++

Routine Description:

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopClient::DisconnectFromServer");

    //
    //  Hide our window.
    //
    //ShowWindow(SW_HIDE);

    //
    //  Notify the contained client object.
    //
    if (m_Client != NULL) {
        m_Client->DisconnectFromServer();
    }

    DC_END_FN();
    return S_OK;
}


//
//  send parameters to ISAFRemoteDesktopTestExtension
//
HRESULT
CRemoteDesktopClient::_PutExtParams(
    VOID
    )
{
    ISAFRemoteDesktopTestExtension *pExt = NULL;
    HRESULT  hr = E_NOTIMPL;

    DC_BEGIN_FN("CRemoteDesktopClient::_PutExtParams");

    if ( NULL == m_ExtDllName )
    {
        hr = S_OK;
        goto CLEANUPANDEXIT;
    }

    if (m_Client == NULL)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
        goto CLEANUPANDEXIT;
    }

    hr = m_Client->QueryInterface( __uuidof( ISAFRemoteDesktopTestExtension ),
                                   (void **)&pExt );
    if (FAILED( hr ))
    {
        TRC_ERR((TB, L"QueryInterface( ISAFRemoteDesktopTestExtension ), failed %08X", hr));
        goto CLEANUPANDEXIT;
    }


    hr = pExt->put_TestExtDllName( m_ExtDllName );
    if (FAILED( hr ))
    {
        TRC_ERR((TB, L"put_TestExtDllName failed %08X", hr ));
        goto CLEANUPANDEXIT;
    }
    if ( NULL != m_ExtParams )
        hr = pExt->put_TestExtParams( m_ExtParams );

CLEANUPANDEXIT:
    if ( NULL != pExt )
        pExt->Release();

    DC_END_FN();
    return hr;
}


STDMETHODIMP
CRemoteDesktopClient::StartListen( 
    /*[in]*/ LONG timeout
    )
/*++

Description:

    Put client (expert) in listening on socket port listening_port and wait for TS server to connect.

Parameters:

    listening_port : Port to listen on, 0 for dynamic port.
    timeout : Listen timeout.
    pConnectParm : Return Salem specific connection parameter for ISAFRemoteDesktopServerHost object
                   to connect to this client (expert).

returns:

    S_OK or error code.

Notes:

    Function is async, return code, if error, is for listening thread set up, caller is notified of
    successful or error in network connection via ListenConnect event.
    
--*/
{
    HRESULT hr;

    if( m_Client != NULL ) {
        hr = m_Client->StartListen( timeout );
    }
    else {
        hr = E_FAIL;
    }

CLEANUPANDEXIT:

    return hr;
}


STDMETHODIMP
CRemoteDesktopClient::CreateListenEndpoint( 
    /*[in]*/ LONG listening_port, 
    /*[out, retval]*/ BSTR* pConnectParm
    )
/*++

Description:

    Put client (expert) in listening on socket port listening_port and wait for TS server to connect.

Parameters:

    listening_port : Port to listen on, 0 for dynamic port.
    pConnectParm : Return Salem specific connection parameter for ISAFRemoteDesktopServerHost object
                   to connect to this client (expert).

returns:

    S_OK or error code.

Notes:

    Function is async, return code, if error, is for listening thread set up, caller is notified of
    successful or error in network connection via ListenConnect event.
    
--*/
{
    HRESULT hr;

    if( NULL == pConnectParm ) {
        hr = E_INVALIDARG;
    }
    else {
        if( m_Client == NULL ) {
            hr = InitializeRemoteDesktopClientObject();
            if( FAILED(hr) ) {
                goto CLEANUPANDEXIT;
            }
        }

        hr = m_Client->CreateListenEndpoint( listening_port, pConnectParm );
    }

CLEANUPANDEXIT:

    return hr;
}

STDMETHODIMP
CRemoteDesktopClient::StopListen()
/*++

Description:

    Stop listening waiting for TS server (helpee, user) to connect.

Parameters:

    None.

Returns:

    S_OK or error code.

--*/
{
    HRESULT hr;

    if( m_Client != NULL ) {
        hr = m_Client->StopListen();
    } 
    else {
        hr = E_FAIL;
    }

    return hr;
}


STDMETHODIMP
CRemoteDesktopClient::AcceptListenConnection(
    /*[in]*/ BSTR expertBlob
    )
/*++

Description:

    Stop listening waiting for TS server (helpee, user) to connect.

Parameters:

    None.

Returns:

    S_OK or error code.

--*/
{
    HRESULT hr = S_OK;
    DWORD protocolType;
    CComBSTR tmp;
    CComBSTR helpSessionId;
    DWORD result;
    CComBSTR channelInfo;
    ChannelsType::iterator element;
    DWORD dwConnParmVersion;
    WCHAR buf[MAX_PATH];


    DC_BEGIN_FN("CRemoteDesktopClient::AcceptListenConnection");

    //
    //  Check the connection parameters.
    //
    if (m_ConnectParms.Length() == 0 || m_Client == NULL) {
        ASSERT(FALSE);
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto CLEANUPANDEXIT;
    }

    //
    //  Parse the connection parms to get the type of server
    //  to which we are connecting.
    //
    result = ParseConnectParmsString(
                            m_ConnectParms, &dwConnParmVersion, &protocolType, tmp, tmp,
                            tmp, helpSessionId, tmp, tmp,
                            tmp
                            );
    if (result != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(result);
        goto CLEANUPANDEXIT;
    }

    //
    //  Right now, we only support the TSRDP client.
    //  TODO:    We should make this pluggable for Whistler timeframe
    //           via registry defined CLSID's.
    //
    if (protocolType != REMOTEDESKTOP_TSRDP_PROTOCOL) {
        TRC_ERR((TB, L"Unsupported protocol:  %ld", protocolType));
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto CLEANUPANDEXIT; 
    }

    //
    //  Enable/disable smart sizing.
    //
    hr = m_Client->put_EnableSmartSizing(m_EnableSmartSizing);
    if (!SUCCEEDED(hr)) {
        goto CLEANUPANDEXIT;
    }
    
    hr = m_Client->put_ColorDepth(m_ColorDepth);
    if (!SUCCEEDED(hr)) {
        goto CLEANUPANDEXIT;
    }

    //
    //  setup the test extension
    //
    _PutExtParams();

    //
    //  Connect.
    //
    m_Client->put_ConnectParms(m_ConnectParms);
    hr = m_Client->AcceptListenConnection(expertBlob);

CLEANUPANDEXIT:

    DC_END_FN();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\client\rdhost\remotedesktopclienthost.cpp ===
/*+

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RDPRemoteDesktopClientHost

Abstract:

Author:

    Tad Brockway 02/00

Revision History:

--*/

#include "stdafx.h"

#ifdef TRC_FILE
#undef TRC_FILE 
#endif

#define TRC_FILE  "_crdph"

#include "RDCHost.h"
#include "TSRDPRemoteDesktopClient.h"
#include "RemoteDesktopClientHost.h"
#include <RemoteDesktopUtils.h>


///////////////////////////////////////////////////////
//
//  CRemoteDesktopClientHost Methods
//

HRESULT 
CRemoteDesktopClientHost::FinalConstruct()
{
    DC_BEGIN_FN("CRemoteDesktopClientHost::FinalConstruct");

    HRESULT hr = S_OK;
    if (!AtlAxWinInit()) {
        TRC_ERR((TB, L"AtlAxWinInit failed."));
        hr = E_FAIL;
    }

    DC_END_FN();
    return hr;
}

HRESULT 
CRemoteDesktopClientHost::Initialize(
    LPCREATESTRUCT pCreateStruct
    )
/*++

Routine Description:

    Final Initialization

Arguments:

    pCreateStruct   -   WM_CREATE, create struct.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopClientHost::Initialize");

    RECT rcClient = { 0, 0, pCreateStruct->cx, pCreateStruct->cy };
    HRESULT hr;
    IUnknown *pUnk = NULL;

    ASSERT(!m_Initialized);

    //
    //  Create the client Window.
    //
    m_ClientWnd = m_ClientAxView.Create(
                            m_hWnd, rcClient, REMOTEDESKTOPCLIENT_TEXTGUID,
                            WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN, 0
                            );

    if (m_ClientWnd == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        TRC_ERR((TB, L"Window Create:  %08X", GetLastError()));
        goto CLEANUPANDEXIT;
    }
    ASSERT(::IsWindow(m_ClientWnd));

    //
    //  Get IUnknown
    //
    hr = AtlAxGetControl(m_ClientWnd, &pUnk);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"AtlAxGetControl:  %08X", hr));
        pUnk = NULL;
        goto CLEANUPANDEXIT;
    }

    //
    //  Get the client control.
    //
    hr = pUnk->QueryInterface(__uuidof(ISAFRemoteDesktopClient), (void**)&m_Client);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"QueryInterface:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    m_Initialized = TRUE;

CLEANUPANDEXIT:

    //
    //  m_Client keeps our reference to the client object until
    //  the destructor is called.
    //
    if (pUnk != NULL) {
        pUnk->Release();
    }

    DC_END_FN();

    return hr;
}

STDMETHODIMP 
CRemoteDesktopClientHost::GetRemoteDesktopClient(
    ISAFRemoteDesktopClient **client
    )
/*++

Routine Description:

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CRemoteDesktopClientHost::GetRemoteDesktopClient");

    HRESULT hr;

    ASSERT(m_Initialized);

    if (m_Client != NULL) {
        hr = m_Client->QueryInterface(__uuidof(ISAFRemoteDesktopClient), (void **)client);        
    }
    else {
        hr = E_FAIL;
    }

    DC_END_FN();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\client\rdhost\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RDCHost.rc
//
#define IDS_PROJNAME                    100
#define IDB_REMOTEDESKTOPCLIENTHOST 101
#define IDR_REMOTEDESKTOPCLIENTHOST 102
#define IDB_REMOTEDESKTOPCLIENT    103
#define IDR_REMOTEDESKTOPCLIENT    104
#define IDB_TSRDPREMOTEDESKTOPCLIENT 105
#define IDR_TSRDPREMOTEDESKTOPCLIENT 106
#define IDB_CLIENTDATACHANNEL 107
#define IDR_CLIENTDATACHANNEL 108
#define IDB_CLIENTREMOTEDESKTOPCHANNELMGR 109
#define IDR_CLIENTREMOTEDESTKOPCHANNELMGR 110


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\client\rdhost\remotedesktopclient.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RemoteDesktopClient

Abstract:

    The CRemoteDesktopClient class is the parent 
    class for the Remote Desktop class hierarchy on the client-side.  
    It helps the CRemoteDesktopClientHost class to implement 
    the ISAFRemoteDesktopClient interface.  
    
    The Remote Desktop class hierarchy provides a pluggable C++ interface 
    for remote desktop access, by abstracting the implementation 
    specific details of remote desktop access for the client-side of
    .

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __REMOTEDESKTOPCLIENT_H_
#define __REMOTEDESKTOPCLIENT_H_

#include "resource.h"       
#include <atlctl.h>

#include <RemoteDesktopTopLevelObject.h>
#include <ClientDataChannelMgr.h>
#include "RDCHostCP.h"

#pragma warning (disable: 4786)
#include <vector>

#define IDC_EVENT_SOURCE_OBJ 1

//
// Info for all the event functions is entered here
// there is a way to have ATL do this automatically using typelib's
// but it is slower.
//
static _ATL_FUNC_INFO EventFuncNoParamsInfo =
{
            CC_STDCALL,     // Calling convention.
            VT_EMPTY,       // Return type.
            0,              // Number of arguments.
            {VT_EMPTY}      // Argument types.
};

static _ATL_FUNC_INFO EventFuncLongParamInfo =
{
            CC_STDCALL,     // Calling convention.
            VT_EMPTY,       // Return type.
            1,              // Number of arguments.
            {VT_I4}         // Argument types.
};


typedef enum {
    CONNECTION_STATE_NOTCONNECTED,              // not connected
    CONNECTION_STATE_CONNECTPENDINGCONNECT,     // Initiate connection and still waiting for connection to succeed
    CONNECTION_STATE_LISTENPENDINGCONNECT,      // Listening for incoming connection.
    CONNECTION_STATE_CONNECTED                  // we are connected.
} CONNECTION_STATE;



///////////////////////////////////////////////////////
//
//  CRemoteDesktopClientEventSink
//

class CRemoteDesktopClient;
class CRemoteDesktopClientEventSink :
        public IDispEventSimpleImpl<IDC_EVENT_SOURCE_OBJ, CRemoteDesktopClientEventSink,
                   &DIID__ISAFRemoteDesktopClientEvents>,
        public CRemoteDesktopTopLevelObject
{
public:

        CRemoteDesktopClient *m_Obj;
        
public:

    BEGIN_SINK_MAP(CRemoteDesktopClientEventSink)
        SINK_ENTRY_INFO(IDC_EVENT_SOURCE_OBJ, DIID__ISAFRemoteDesktopClientEvents, 
                        DISPID_RDSCLIENTEVENTS_CONNECTED, OnConnected, 
                        &EventFuncNoParamsInfo)
        SINK_ENTRY_INFO(IDC_EVENT_SOURCE_OBJ, DIID__ISAFRemoteDesktopClientEvents, 
                        DISPID_RDSCLIENTEVENTS_DISCONNECTED, OnDisconnected, 
                        &EventFuncLongParamInfo)
        SINK_ENTRY_INFO(IDC_EVENT_SOURCE_OBJ, DIID__ISAFRemoteDesktopClientEvents, 
                        DISPID_RDSCLIENTEVENTS_REMOTECONTROLREQUESTCOMPLETE, 
                        OnConnectRemoteDesktopComplete, 
                        &EventFuncLongParamInfo)
        SINK_ENTRY_INFO(IDC_EVENT_SOURCE_OBJ, DIID__ISAFRemoteDesktopClientEvents, 
                        DISPID_RDSCLIENTEVENTS_LISTENCONNECT, 
                        OnListenConnect, 
                        &EventFuncLongParamInfo)
        SINK_ENTRY_INFO(IDC_EVENT_SOURCE_OBJ, DIID__ISAFRemoteDesktopClientEvents, 
                        DISPID_RDSCLIENTEVENTS_BEGINCONNECT, 
                        OnBeginConnect, 
                        &EventFuncNoParamsInfo)

    END_SINK_MAP()

    CRemoteDesktopClientEventSink()
    {
        m_Obj = NULL;
    }

    //
    //  Event Sinks
    //
    void __stdcall OnConnected();
    void __stdcall OnDisconnected(long reason);
    void __stdcall OnConnectRemoteDesktopComplete(long status);
    void __stdcall OnListenConnect(long status);
    void __stdcall OnBeginConnect();

    //
    //  Return the name of this class.
    //
    virtual const LPTSTR ClassName() {
        return TEXT("CRemoteDesktopClientEventSink");
    }
};


///////////////////////////////////////////////////////
//
//  CRemoteDesktopClient
//

class ATL_NO_VTABLE CRemoteDesktopClient : 
    public CRemoteDesktopTopLevelObject,
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<ISAFRemoteDesktopClient, &IID_ISAFRemoteDesktopClient, &LIBID_RDCCLIENTHOSTLib>,
    public IDispatchImpl<ISAFRemoteDesktopTestExtension, &IID_ISAFRemoteDesktopTestExtension, &LIBID_RDCCLIENTHOSTLib>,
    public CComControl<CRemoteDesktopClient>,
    public IPersistStreamInitImpl<CRemoteDesktopClient>,
    public IOleControlImpl<CRemoteDesktopClient>,
    public IOleObjectImpl<CRemoteDesktopClient>,
    public IOleInPlaceActiveObjectImpl<CRemoteDesktopClient>,
    public IViewObjectExImpl<CRemoteDesktopClient>,
    public IOleInPlaceObjectWindowlessImpl<CRemoteDesktopClient>,
    public IConnectionPointContainerImpl<CRemoteDesktopClient>,
    public IPersistStorageImpl<CRemoteDesktopClient>,
    public ISpecifyPropertyPagesImpl<CRemoteDesktopClient>,
    public IQuickActivateImpl<CRemoteDesktopClient>,
    public IDataObjectImpl<CRemoteDesktopClient>,
    public IProvideClassInfo2Impl<&CLSID_SAFRemoteDesktopClient, &DIID__ISAFRemoteDesktopClientEvents, &LIBID_RDCCLIENTHOSTLib>,
    public IPropertyNotifySinkCP<CRemoteDesktopClient>,
    public CComCoClass<CRemoteDesktopClient, &CLSID_SAFRemoteDesktopClient>,
    public CProxy_ISAFRemoteDesktopClientEvents< CRemoteDesktopClient >
{
private:

    typedef std::vector<LONG, CRemoteDesktopAllocator<LONG> > ChannelsType;
    ChannelsType m_Channels;
    CComPtr<ISAFRemoteDesktopClient> m_Client;
    BSTR        m_ExtDllName;
    BSTR        m_ExtParams;

    HWND        m_ClientWnd;
    CAxWindow   m_ClientAxView;
    BOOL        m_RemoteControlEnabled;
    BOOL        m_EnableSmartSizing;
    LONG        m_ColorDepth;

    CONNECTION_STATE   m_ConnectingState;

    // 
    //  Event sink receives events fired by the client control.. 
    //
    CRemoteDesktopClientEventSink  m_ClientEventSink;

    //
    //  IDispatch Pointers for Scriptable Event Object Registrations
    //
    CComPtr<IDispatch>  m_OnConnected;
    CComPtr<IDispatch>  m_OnDisconnected;
    CComPtr<IDispatch>  m_OnConnectRemoteDesktopComplete;
    CComPtr<IDispatch>  m_OnListenConnect;
    CComPtr<IDispatch>  m_OnBeginConnect;
    //
    //  Data Channel Manager Interface
    //
    CComObject<CClientDataChannelMgr> *m_ChannelMgr;

    //
    //  Connect Parameters
    //
    CComBSTR m_ConnectParms;

    HRESULT _PutExtParams( VOID );

    HRESULT 
    InitializeRemoteDesktopClientObject();


public:

    CRemoteDesktopClient()
    {
        DC_BEGIN_FN("CRemoteDesktopClient::CRemoteDesktopClient");

        m_RemoteControlEnabled = FALSE;

        //
        //  We are window'd, even if our parent supports Windowless 
        //  controls.
        //
        m_bWindowOnly = TRUE;

        m_ClientWnd = NULL;

        m_EnableSmartSizing = FALSE;

        m_ExtDllName = m_ExtParams = NULL;
        
        m_ColorDepth = 8;

        DC_END_FN();
    }
    virtual ~CRemoteDesktopClient();
    HRESULT FinalConstruct();

    //
    //  Event Sinks
    //
    void OnConnected();
    void OnDisconnected(long reason);
    void OnConnectRemoteDesktopComplete(long status);
    void OnListenConnect(long status);
    void OnBeginConnect();

DECLARE_REGISTRY_RESOURCEID(IDR_REMOTEDESKTOPCLIENT)
DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    //  COM Interface Map
    //
BEGIN_COM_MAP(CRemoteDesktopClient)
    COM_INTERFACE_ENTRY(ISAFRemoteDesktopClient)
    COM_INTERFACE_ENTRY(ISAFRemoteDesktopTestExtension)
    COM_INTERFACE_ENTRY2(IDispatch, ISAFRemoteDesktopClient)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY(IQuickActivate)
    COM_INTERFACE_ENTRY(IPersistStorage)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

    //
    //  Property Map
    //  
BEGIN_PROP_MAP(CRemoteDesktopClient)
    PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
    PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    // PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

    //
    //  Connection Point Map
    //  
BEGIN_CONNECTION_POINT_MAP(CRemoteDesktopClient)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    CONNECTION_POINT_ENTRY(DIID__ISAFRemoteDesktopClientEvents)
END_CONNECTION_POINT_MAP()

    //
    //  Message Map
    //  
BEGIN_MSG_MAP(CRemoteDesktopClient)
    CHAIN_MSG_MAP(CComControl<CRemoteDesktopClient>)
    DEFAULT_REFLECTION_HANDLER()
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
END_MSG_MAP()

    // 
    //  Handler prototypes:
    //
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    // 
    //  IViewObjectEx Methods
    //
    DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

public:

    STDMETHOD(CreateListenEndpoint)(
        /*[in]*/ LONG port, 
        /*[out, retval]*/ BSTR* pConnectParm
    );

    STDMETHOD(StartListen)(
        /*[in]*/ LONG timeout 
    );

    STDMETHOD(AcceptListenConnection)(
        /*[in]*/BSTR expertBlob
    );

    STDMETHOD(StopListen)();

    STDMETHOD(get_IsRemoteDesktopConnected)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(get_IsServerConnected)(/*[out, retval]*/BOOL *pVal);
    STDMETHOD(DisconnectRemoteDesktop)();
    STDMETHOD(ConnectRemoteDesktop)();
    STDMETHOD(ConnectToServer)(BSTR bstrServer);
    STDMETHOD(DisconnectFromServer)();
    STDMETHOD(get_ExtendedErrorInfo)(/*[out, retval]*/LONG *error);
    STDMETHOD(get_ChannelManager)(ISAFRemoteDesktopChannelMgr **mgr) {
        m_ChannelMgr->AddRef();
        *mgr = m_ChannelMgr;
        return S_OK;
    }
    STDMETHOD(put_ConnectParms)(/*[in]*/BSTR parms) {
        m_ConnectParms = parms;
        return S_OK;
    }
    STDMETHOD(get_ConnectParms)(/*[out, retval]*/BSTR *parms) {
        CComBSTR tmp;
        tmp = m_ConnectParms;
        *parms = tmp.Detach();
        return S_OK;
    }

    STDMETHOD(put_OnBeginConnect)(/*[in]*/IDispatch *iDisp) { 
        m_OnBeginConnect = iDisp;
        return S_OK; 
    }

    STDMETHOD(put_OnConnected)(/*[in]*/IDispatch *iDisp) { 
        m_OnConnected = iDisp;
        return S_OK; 
    }
    STDMETHOD(put_OnDisconnected)(/*[in]*/IDispatch *iDisp) { 
        m_OnDisconnected = iDisp;
        return S_OK; 
    }
    STDMETHOD(put_OnConnectRemoteDesktopComplete)(/*[in]*/IDispatch *iDisp) { 
        m_OnConnectRemoteDesktopComplete = iDisp;
        return S_OK; 
    }
    STDMETHOD(put_OnListenConnect)(/*[in]*/IDispatch *iDisp) { 
        m_OnListenConnect = iDisp;
        return S_OK; 
    }
    STDMETHOD(put_EnableSmartSizing)(/*[in]*/BOOL val) {
        HRESULT hr;
        if (m_Client != NULL) {
            hr = m_Client->put_EnableSmartSizing(val);
            if (hr == S_OK) {
                m_EnableSmartSizing = val;
            }
        }
        else {
            m_EnableSmartSizing = val;
            hr = S_OK;
        }
        return hr;
    }
    STDMETHOD(get_EnableSmartSizing)(/*[in]*/BOOL *pVal) {
        if (pVal != NULL) {
            *pVal = m_EnableSmartSizing;
            return S_OK;
        }
        else {
            return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        }
    }

    STDMETHOD(get_ConnectedServer)(/*[in]*/BSTR* Val) {
        HRESULT hr;

        if( NULL == Val ) {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        }
        else if( m_Client != NULL ) {
            hr = m_Client->get_ConnectedServer( Val );
        } 
        else {
            hr = E_FAIL;
        }

        return hr;
    }

    STDMETHOD(get_ConnectedPort)(/*[in]*/LONG* Val) {
        HRESULT hr;

        if( NULL == Val ) {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        }
        else if( m_Client != NULL ) {
            hr = m_Client->get_ConnectedPort( Val );
        } 
        else {
            hr = E_FAIL;
        }

        return hr;
    }

    STDMETHOD(put_ColorDepth)(/*[in]*/LONG Val) {
        HRESULT hr;
        if (m_Client != NULL) {
            hr = m_Client->put_ColorDepth(Val);
            if (hr == S_OK) {
                m_ColorDepth = Val;
            }
        }
        else {
            m_ColorDepth = Val;
            hr = S_OK;
        }
        return hr;
    }
    STDMETHOD(get_ColorDepth)(/*[out,retval]*/LONG* pVal) {
        if (pVal != NULL) {
                *pVal = m_ColorDepth;
                return S_OK;
        }
        else {
            return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        }
    }



    //
    //  OnCreate
    //
    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        //
        //  Hide our window, by default.
        //
        //ShowWindow(SW_HIDE);
        return 0;
    }

    //
    //  OnSetFocus
    //
    LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        //
        //  Set focus back to the client window, if it exists.
        //
        if (m_ClientWnd != NULL) {
            ::PostMessage(m_ClientWnd, uMsg, wParam, lParam);
        }
        return 0;
    }

    //
    //  OnSize
    //
    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        DC_BEGIN_FN("CRemoteDesktopClient::OnSize");

        if (m_ClientWnd != NULL) {
            RECT rect;
            GetClientRect(&rect);
            ::MoveWindow(m_ClientWnd, rect.left, rect.top, 
                        rect.right, rect.bottom, TRUE);
        }

        DC_END_FN();
        return 0;
    }

    //
    //  OnDraw
    //
    HRESULT OnDraw(ATL_DRAWINFO& di)
    {
        //
        //  Make sure our window is hidden, if remote control is not
        //  active.
        //
        if (!m_RemoteControlEnabled) {
            //ShowWindow(SW_HIDE);
        }
        return S_OK;
    }

    //
    //  Return the name of this class.
    //
    virtual const LPTSTR ClassName() {
        return TEXT("CRemoteDesktopClient");
    }

    //
    //  ISAFRemoteDesktopTestExtension
    //
    STDMETHOD(put_TestExtDllName)(/*[in]*/BSTR newVal)
    { 
        if ( NULL != m_ExtDllName )
            SysFreeString( m_ExtDllName );
        m_ExtDllName = SysAllocString( newVal );
        return ( NULL != m_ExtDllName )?S_OK:E_OUTOFMEMORY; 
    }

    STDMETHOD(put_TestExtParams)(/*[in]*/BSTR newVal)
    {
        if ( NULL != m_ExtParams )
            SysFreeString( m_ExtDllName );
        m_ExtParams = SysAllocString( newVal );
        return ( NULL != m_ExtDllName )?S_OK:E_OUTOFMEMORY;
    }
};


///////////////////////////////////////////////////////
//
//  CRemoteDesktopClient Inline Methods
//
inline void CRemoteDesktopClient::OnConnected()
{
    Fire_Connected(m_OnConnected);
}
inline void CRemoteDesktopClient::OnDisconnected(long reason)
{
    //
    //  Hide our window.
    //
    m_RemoteControlEnabled = FALSE;
    //ShowWindow(SW_HIDE);

    Fire_Disconnected(reason, m_OnDisconnected);
}
inline void CRemoteDesktopClient::OnConnectRemoteDesktopComplete(long status)
{
    //
    //  Show our window, if the request succeeded.
    //
    if (status == ERROR_SUCCESS) {
        m_RemoteControlEnabled = TRUE;
        ShowWindow(SW_SHOW);
    }
    Fire_RemoteControlRequestComplete(status, m_OnConnectRemoteDesktopComplete);
}

inline void CRemoteDesktopClient::OnListenConnect(long status)
{
    Fire_ListenConnect(status, m_OnListenConnect);
}

inline void CRemoteDesktopClient::OnBeginConnect()
{
    ShowWindow(SW_SHOW);
    Fire_BeginConnect(m_OnBeginConnect);
}

#endif //__REMOTEDESKTOPCLIENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\client\rdhost\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently


//  Enable for ATL tracing.
/*
#define _ATL_DEBUG_INTERFACES
#define ATL_TRACE_CATEGORY 0xFFFFFFFF
#define ATL_TRACE_LEVEL 4
#define DEBUG
*/

#if !defined(AFX_STDAFX_H__D6E6008A_5A57_4C8C_BF1B_7EB12CF522A9__INCLUDED_)
#define AFX_STDAFX_H__D6E6008A_5A57_4C8C_BF1B_7EB12CF522A9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D6E6008A_5A57_4C8C_BF1B_7EB12CF522A9__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\client\rdhost\remotedesktopclienthost.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RemoteDesktopClientHost

Abstract:

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __REMOTEDESKTOPCLIENTHOST_H_
#define __REMOTEDESKTOPCLIENTHOST_H_

#include <RemoteDesktopTopLevelObject.h>
#include "resource.h" 
#include <atlctl.h>
#include "RemoteDesktopClient.h"


///////////////////////////////////////////////////////
//
//  CRemoteDesktopClientHost
//

class ATL_NO_VTABLE CRemoteDesktopClientHost : 
    public CRemoteDesktopTopLevelObject,
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<ISAFRemoteDesktopClientHost, &IID_ISAFRemoteDesktopClientHost, &LIBID_RDCCLIENTHOSTLib>,
	public CComControl<CRemoteDesktopClientHost>,
	public IPersistStreamInitImpl<CRemoteDesktopClientHost>,
	public IOleControlImpl<CRemoteDesktopClientHost>,
	public IOleObjectImpl<CRemoteDesktopClientHost>,
	public IOleInPlaceActiveObjectImpl<CRemoteDesktopClientHost>,
	public IViewObjectExImpl<CRemoteDesktopClientHost>,
	public IOleInPlaceObjectWindowlessImpl<CRemoteDesktopClientHost>,
	public IConnectionPointContainerImpl<CRemoteDesktopClientHost>,
	public IPersistStorageImpl<CRemoteDesktopClientHost>,
	public ISpecifyPropertyPagesImpl<CRemoteDesktopClientHost>,
	public IQuickActivateImpl<CRemoteDesktopClientHost>,
	public IDataObjectImpl<CRemoteDesktopClientHost>,
    public IProvideClassInfo2Impl<&CLSID_SAFRemoteDesktopClientHost, NULL, &LIBID_RDCCLIENTHOSTLib>,
	public IPropertyNotifySinkCP<CRemoteDesktopClientHost>,
	public CComCoClass<CRemoteDesktopClientHost, &CLSID_SAFRemoteDesktopClientHost>
{
private:

    ISAFRemoteDesktopClient  *m_Client;

    HWND        m_ClientWnd;
    CAxWindow   m_ClientAxView;
    BOOL        m_Initialized;

    //
    //  Final Initialization
    //
    HRESULT Initialize(LPCREATESTRUCT pCreateStruct);

public:

    //
    //  Constructor/Destructor
    //
	CRemoteDesktopClientHost()
	{
        //
        //  We are window'd, even if our parent supports Windowless 
        //  controls.
        //
        m_bWindowOnly = TRUE;

        m_Client        = NULL;
        m_ClientWnd     = NULL;
        m_Initialized   = FALSE;
	}
    ~CRemoteDesktopClientHost() 
    {
        DC_BEGIN_FN("CRemoteDesktopClientHost::~CRemoteDesktopClientHost");
        if (m_Client != NULL) {
            m_Client->Release();
        }
        DC_END_FN();
    }
    HRESULT FinalConstruct();

    STDMETHOD(OnFrameWindowActivate)(BOOL fActivate)
    {
        DC_BEGIN_FN("CRemoteDesktopClientHost::OnFrameWindowActivate");
        //
        //  Set focus back to the client window, if it exists.
        //
        if (m_ClientWnd != NULL) {
            ::SetFocus(m_ClientWnd);
        }
        DC_END_FN();
        return S_OK;
    }    

DECLARE_REGISTRY_RESOURCEID(IDR_REMOTEDESKTOPCLIENTHOST)
DECLARE_NOT_AGGREGATABLE(CRemoteDesktopClientHost)

DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    //  COM Interface Map
    //
BEGIN_COM_MAP(CRemoteDesktopClientHost)
	COM_INTERFACE_ENTRY(ISAFRemoteDesktopClientHost)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IQuickActivate)
	COM_INTERFACE_ENTRY(IPersistStorage)
	COM_INTERFACE_ENTRY(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
END_COM_MAP()

BEGIN_PROP_MAP(CRemoteDesktopClientHost)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

    //
    //  Connection Point Map
    //
BEGIN_CONNECTION_POINT_MAP(CRemoteDesktopClientHost)
	CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP()

    //
    //  Message Map
    //
BEGIN_MSG_MAP(CRemoteDesktopClientHost)
	CHAIN_MSG_MAP(CComControl<CRemoteDesktopClientHost>)
	DEFAULT_REFLECTION_HANDLER()
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    // 
    //  IViewObjectEx
    //
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

public:

    //
    //  OnDraw
    //
	HRESULT OnDraw(ATL_DRAWINFO& di)
	{
		RECT& rc = *(RECT*)di.prcBounds;
		Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);
        HRESULT hr;

        if (!m_Initialized) {
            hr = S_OK;
		    SetTextAlign(di.hdcDraw, TA_CENTER|TA_BASELINE);
		    LPCTSTR pszText = _T("Remote Desktop Client Host");
		    TextOut(di.hdcDraw, 
			    (rc.left + rc.right) / 2, 
			    (rc.top + rc.bottom) / 2, 
			    pszText, 
			    lstrlen(pszText));
        }

		return hr;
	}

    //
    //  OnCreate
    //
	LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
        //
        //  We are hidden by default.
        //
        //ShowWindow(SW_HIDE);

        DC_BEGIN_FN("CRemoteDesktopClientHost::OnCreate");
        if (!m_Initialized) {
            //ASSERT(FALSE);
            LPCREATESTRUCT pCreateStruct = (LPCREATESTRUCT)lParam;
            Initialize(pCreateStruct);
        }
		
        DC_END_FN();
		return 0;
	}

    //
    //  OnSetFocus
    //
	LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
        DC_BEGIN_FN("CRemoteDesktopClientHost::OnSetFocus");

        //
        //  Set focus back to the client window, if it exists.
        //
        if (m_ClientWnd != NULL) {
            ::PostMessage(m_ClientWnd, uMsg, wParam, lParam);
        }
        DC_END_FN();
		return 0;
	}

    //
    //  OnSize
    //
	LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
        DC_BEGIN_FN("CRemoteDesktopClientHost::OnSize");

        if (m_ClientWnd != NULL) {
            RECT rect;
            GetClientRect(&rect);

            ASSERT(rect.left == 0);
            ASSERT(rect.top == 0);
            ASSERT(rect.bottom == HIWORD(lParam));
            ASSERT(rect.right == LOWORD(lParam));

            ::MoveWindow(m_ClientWnd, rect.left, rect.top, 
                        rect.right, rect.bottom, TRUE);
        }

        DC_END_FN();
		return 0;
	}

    //
    //  ISAFRemoteDesktopClientHost Methods
    //
	STDMETHOD(GetRemoteDesktopClient)(ISAFRemoteDesktopClient **client);

    //
    //  Return the name of this class.
    //
    virtual const LPTSTR ClassName() {
        return TEXT("CRemoteDesktopClientHost");
    }
};

#endif //__REMOTEDESKTOPCLIENTHOST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\client\rdhost\tsrdpremotedesktopclient.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    TSRDPRemoteDesktopClient

Abstract:

    This is the TS/RDP implementation of the Remote Desktop Client class.
    
    The Remote Desktop Client class hierarchy provides a pluggable C++ 
    interface for remote desktop access, by abstracting the implementation 
    specific details of remote desktop access for the client-side

    The TSRDPRemoteDesktopClass implements remote-desktopping
    with the help of an instance of the MSTSC ActiveX client control.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __TSRDPREMOTEDESKTOPCLIENT_H_
#define __TSRDPREMOTEDESKTOPCLIENT_H_

#include "resource.h"       
#include <atlctl.h>
#include "RDCHostCP.h"
#include <mstsax.h>
#include <rdchost.h>
#include <RemoteDesktopTopLevelObject.h>
#include <RemoteDesktopUtils.h>
#include "parseaddr.h"
#pragma warning (disable: 4786)
#include <list>
#include "icshelpapi.h"

#define IDC_MSTSCEVENT_SOURCE_OBJ	1
#define IDC_CHANNELEVENT_SOURCE_OBJ 2

#define WM_STARTLISTEN              (0xBFFE)
#define WM_TSCONNECT                (0xBFFF)
#define WM_LISTENTIMEOUT_TIMER      1   
#define WM_CONNECTCHECK_TIMER       2

#define MAX_FETCHIPADDRESSRETRY     5



//
//  MSTSC ActiveX GUID
//
#define MSTSCAX_TEXTGUID  _T("{7cacbd7b-0d99-468f-ac33-22e495c0afe5}")
#define RDC_CHECKCONN_TIMEOUT (30 * 1000) //millisec. default value to ping is 30 seconds 
#define RDC_CONNCHECK_ENTRY    L"ConnectionCheck"

//
// Info for all the event functions is entered here
// there is a way to have ATL do this automatically using typelib's
// but it is slower.
//
static _ATL_FUNC_INFO TSRDPClientEventFuncNoParamsInfo =
{
            CC_STDCALL,     // Calling convention.
            VT_EMPTY,       // Return type.
            0,              // Number of arguments.
            {VT_EMPTY}      // Argument types.
};

static _ATL_FUNC_INFO TSRDPClientEventFuncLongParamInfo =
{
            CC_STDCALL,     // Calling convention.
            VT_EMPTY,       // Return type.
            1,              // Number of arguments.
            {VT_I4}         // Argument types.
};

static _ATL_FUNC_INFO TSRDPClientEventFuncTwoStringParamInfo =
{
            CC_STDCALL,     // Calling convention.
            VT_EMPTY,       // Return type.
            2,              // Number of arguments.
            {VT_BSTR,       //  Argument types
             VT_BSTR}
};

static _ATL_FUNC_INFO TSRDPClientEventFuncReceivePublicKeyParamInfo =
{
            CC_STDCALL,     // Calling convention.
            VT_EMPTY,       // Return type.
            2,              // Number of arguments.
            {VT_BSTR,       //  Argument types
             VT_BYREF | VT_BOOL }
};


static _ATL_FUNC_INFO TSRDPClientEventFuncOneStringParamInfo =
{
            CC_STDCALL,     // Calling convention.
            VT_EMPTY,       // Return type.
            1,              // Number of arguments.
            {VT_BSTR}       //  Argument types
};


///////////////////////////////////////////////////////
//
//  CMSTSCClientEventSink
//

class CTSRDPRemoteDesktopClient;
class CMSTSCClientEventSink :
        public IDispEventSimpleImpl<IDC_MSTSCEVENT_SOURCE_OBJ, CMSTSCClientEventSink,
                   &DIID_IMsTscAxEvents>,
        public CRemoteDesktopTopLevelObject
{
public:

        CTSRDPRemoteDesktopClient *m_Obj;
        
public:

    BEGIN_SINK_MAP(CMSTSCClientEventSink)
        SINK_ENTRY_INFO(IDC_MSTSCEVENT_SOURCE_OBJ, DIID_IMsTscAxEvents, 
                        DISPID_CONNECTED, OnRDPConnected,
                        &TSRDPClientEventFuncNoParamsInfo)
        SINK_ENTRY_INFO(IDC_MSTSCEVENT_SOURCE_OBJ, DIID_IMsTscAxEvents, 
                        DISPID_DISCONNECTED, OnDisconnected, 
                        &TSRDPClientEventFuncLongParamInfo)
        SINK_ENTRY_INFO(IDC_MSTSCEVENT_SOURCE_OBJ, DIID_IMsTscAxEvents, 
                        DISPID_LOGINCOMPLETE, OnLoginComplete, 
                        &TSRDPClientEventFuncNoParamsInfo)
        SINK_ENTRY_INFO(IDC_MSTSCEVENT_SOURCE_OBJ, DIID_IMsTscAxEvents,
                        DISPID_RECEVIEDTSPUBLICKEY, OnReceivedTSPublicKey,
                        &TSRDPClientEventFuncReceivePublicKeyParamInfo)
        SINK_ENTRY_INFO(IDC_MSTSCEVENT_SOURCE_OBJ, DIID_IMsTscAxEvents, 
                        DISPID_CHANNELRECEIVEDDATA, OnReceiveData, 
                        &TSRDPClientEventFuncTwoStringParamInfo)
    END_SINK_MAP()

    CMSTSCClientEventSink()
    {
        m_Obj = NULL;
    }
    ~CMSTSCClientEventSink();

    //
    //  Event Sinks
    //
    void __stdcall OnReceivedTSPublicKey(BSTR publicKey, VARIANT_BOOL* pfContinue);
    HRESULT __stdcall OnRDPConnected();
    HRESULT __stdcall OnLoginComplete();
    HRESULT __stdcall OnDisconnected(long disconReason);
    void __stdcall OnReceiveData(BSTR chanName, BSTR data);

    //
    //  Return the name of this class.
    //
    virtual const LPTSTR ClassName() {
        return TEXT("CMSTSCClientEventSink");
    }
};


///////////////////////////////////////////////////////
//
//  CCtlChannelEventSink
//
//  Control Channel Event Sink
//

class CCtlChannelEventSink :
        public IDispEventSimpleImpl<IDC_CHANNELEVENT_SOURCE_OBJ, CCtlChannelEventSink,
                   &DIID__ISAFRemoteDesktopDataChannelEvents>,
        public CRemoteDesktopTopLevelObject
{
public:

        CTSRDPRemoteDesktopClient *m_Obj;
        
public:

    BEGIN_SINK_MAP(CCtlChannelEventSink)
        SINK_ENTRY_INFO(IDC_CHANNELEVENT_SOURCE_OBJ, DIID__ISAFRemoteDesktopDataChannelEvents, 
                        DISPID_RDSCHANNELEVENTS_CHANNELDATAREADY, DataReady, 
                        &TSRDPClientEventFuncOneStringParamInfo)
    END_SINK_MAP()

    CCtlChannelEventSink()
    {
        m_Obj = NULL;
    }
    ~CCtlChannelEventSink();

    //
    //  Event Sinks
    //
    void __stdcall DataReady(BSTR channelName);

    //
    //  Return the name of this class.
    //
    virtual const LPTSTR ClassName() {
        return TEXT("CCtlChannelEventSink");
    }
};


///////////////////////////////////////////////////////
//
//  CTSRDPRemoteDesktopClient
//

class CMSTSCClientEventSink;
class ATL_NO_VTABLE CTSRDPRemoteDesktopClient : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComControl<CTSRDPRemoteDesktopClient>,
    public IPersistStreamInitImpl<CTSRDPRemoteDesktopClient>,
    public IOleControlImpl<CTSRDPRemoteDesktopClient>,
    public IOleObjectImpl<CTSRDPRemoteDesktopClient>,
    public IOleInPlaceActiveObjectImpl<CTSRDPRemoteDesktopClient>,
    public IViewObjectExImpl<CTSRDPRemoteDesktopClient>,
    public IOleInPlaceObjectWindowlessImpl<CTSRDPRemoteDesktopClient>,
    public IPersistStorageImpl<CTSRDPRemoteDesktopClient>,
    public ISpecifyPropertyPagesImpl<CTSRDPRemoteDesktopClient>,
    public IQuickActivateImpl<CTSRDPRemoteDesktopClient>,
    public IDataObjectImpl<CTSRDPRemoteDesktopClient>,
    public IProvideClassInfo2Impl<&CLSID_TSRDPRemoteDesktopClient, &DIID__ISAFRemoteDesktopClientEvents, &LIBID_RDCCLIENTHOSTLib>,
    public CComCoClass<CTSRDPRemoteDesktopClient, &CLSID_TSRDPRemoteDesktopClient>,
    public IDispatchImpl<ISAFRemoteDesktopClient, &IID_ISAFRemoteDesktopClient, &LIBID_RDCCLIENTHOSTLib>,
    public IDispatchImpl<ISAFRemoteDesktopTestExtension, &IID_ISAFRemoteDesktopTestExtension, &LIBID_RDCCLIENTHOSTLib>,
    public IDataChannelIO,
    public CProxy_ISAFRemoteDesktopClientEvents< CTSRDPRemoteDesktopClient>,
    public CProxy_IDataChannelIOEvents< CTSRDPRemoteDesktopClient>,
    public IConnectionPointContainerImpl<CTSRDPRemoteDesktopClient>,
    public CRemoteDesktopTopLevelObject
{
friend CCtlChannelEventSink;
private:

    IMsRdpClient2          *m_TSClient;
    HWND                    m_TSClientWnd;
    CAxWindow               m_TSClientAxView;
    BOOL                    m_ConnectionInProgress;
    BOOL                    m_RemoteControlRequestInProgress;
    BOOL                    m_ConnectedToServer;
    BOOL                    m_Initialized;
    LONG                    m_LastExtendedErrorInfo;

    // 
    //  Event sink receives events fired by the TS client control.. 
    //
    CMSTSCClientEventSink   m_TSClientEventSink;

    //
    //  Control Channel Event Sink
    //
    CCtlChannelEventSink    m_CtlChannelEventSink;

    //
    //  Multiplexes Channel Data
    //
    CComPtr<ISAFRemoteDesktopChannelMgr> m_ChannelMgr;
    CComPtr<ISAFRemoteDesktopDataChannel> m_CtlChannel;

    //
    //  The parsed connection parameters.
    //
    DWORD       m_ConnectParmVersion;
    CComBSTR    m_AssistantAccount;
    CComBSTR    m_AssistantAccountPwd;
    CComBSTR    m_HelpSessionName;
    CComBSTR    m_HelpSessionID;
    CComBSTR    m_HelpSessionPwd;
    CComBSTR    m_TSSecurityBlob;

    ServerAddressList m_ServerAddressList;

    CComBSTR    m_ConnectedServer;
    LONG        m_ConnectedPort;

    //
    //  The complete connection string.
    //
    CComBSTR    m_ConnectParms;

    //
    // Expert side to be transmitted over to user 
    //
    CComBSTR    m_ExpertBlob;

    //
    //  Search for a child window of the specified parent window.
    //
    typedef struct _WinSearch
    {
        HWND    foundWindow;
        LPTSTR  srchCaption;
        LPTSTR  srchClass;
    } WINSEARCH, *PWINSEARCH;
    HWND SearchForWindow(HWND hwndParent, LPTSTR srchCaption, LPTSTR srchClass);
    static BOOL CALLBACK _WindowSrchProc(HWND hwnd, PWINSEARCH srch);

    //timer related members
    DWORD m_PrevTimer;
    UINT m_TimerId;
    DWORD m_RdcConnCheckTimeInterval;

    BOOL        m_ListenConnectInProgress;  // duration of StartListen() until mstscax connected.
    SOCKET      m_ListenSocket;             // listen() socket
    SOCKET      m_TSConnectSocket;          // accept() scoket
    DWORD       m_ICSPort;                  // port that ICS library punch on ICS server
    BOOL        m_InitListeningLibrary;     // Instance of object initialize WinSock/ICS library.
    UINT_PTR    m_ListenTimeoutTimerID;     // Timer ID for listen timeout.

    void
    ListenConnectCleanup()
    {
        m_ListenConnectInProgress = FALSE;

        if( INVALID_SOCKET != m_ListenSocket ) {
            closesocket( m_ListenSocket );
        }

        if( (UINT_PTR)0 != m_ListenTimeoutTimerID ) {
            KillTimer( m_ListenTimeoutTimerID );
        }

        if( INVALID_SOCKET != m_TSConnectSocket ) {
            closesocket( m_TSConnectSocket );
        }

        if( 0 != m_ICSPort ) {
            ClosePort( m_ICSPort );
        }

        m_ListenSocket = INVALID_SOCKET;
        m_TSConnectSocket = INVALID_SOCKET;
        m_ICSPort = 0;
    }        

    //
    // Variable to manage WinSock and ICS library startup/shutdown, WinSock/ICS library
    // is RDP specific so not declare in parent class.
    //
    static LONG gm_ListeningLibraryRefCount; // Number of time we reference WinSock and ICS library

    //
    // accessing only global variable, no need for per-instance.
    //
    static HRESULT
    InitListeningLibrary();

    static HRESULT
    TerminateListeningLibrary();

    //
    // Listen socket already in progress
    //
    inline BOOL
    ListenConnectInProgress() {
        return m_ListenConnectInProgress;
    }

protected:

    //
    //  Final Initialization.
    //
    virtual HRESULT Initialize(LPCREATESTRUCT pCreateStruct);

    //
    //  Generate a remote control request message for the 
    //  server.
    //
    HRESULT GenerateRCRequest(BSTR *rcRequest);

    //
    //  Generate a 'client authenticate' request.
    //
    HRESULT GenerateClientAuthenticateRequest(BSTR *authenticateReq);

    //
    //  Generate a version information packet.  
    //
    HRESULT GenerateVersionInfoPacket(BSTR *versionInfoPacket);

    //
    //  Send the terminate shadowing key sequence to the server.
    //
    HRESULT SendTerminateRCKeysToServer();

    //
    //  Handle Remote Control 'Control' Channel messages.
    //
    VOID HandleControlChannelMsg();

    //
    //  Translate an MSTSC disconnect code into a Salem disconnect
    //  code.
    //        
    LONG TranslateMSTSCDisconnectCode(DisconnectReasonCode disconReason,
                                    ExtendedDisconnectReasonCode extendedReasonCode);

    //
    //  Disconnects the client from the server.
    //
    STDMETHOD(DisconnectFromServerInternal)(
                        LONG disconnectCode
                        );

    HRESULT
    SetupConnectionInfo(BOOL bListen, BSTR expertBlob);


    //
    // Connect to server with port 
    // 
    HRESULT
    ConnectServerPort( 
        BSTR ServerName,
        LONG portNumber
        );

    //
    // Connect to server with established socket
    //
    HRESULT
    ConnectServerWithOpenedSocket();


    //generate a simple message for checking if the connection is alive
    HRESULT GenerateNullData(BSTR *bstrMsg);

    //
    // Retrieve connect parm
    //
    HRESULT
    RetrieveUserConnectParm( BSTR* pConnectParm );

    void
    FireListenConnect( DWORD ErrCode )
    {
        return;
    }

public:

    //
    //  Constructor/Destructor
    //
    CTSRDPRemoteDesktopClient() {

        //
        //  We are window'd, even if our parent supports Windowless 
        //  controls.
        //
        m_bWindowOnly = TRUE;

        m_ConnectedToServer     = FALSE;
        m_Initialized           = FALSE;
        m_TSClient              = NULL;
        m_TSClientWnd           = NULL;
        m_ConnectionInProgress  = FALSE;
        m_RemoteControlRequestInProgress = FALSE;
        m_LastExtendedErrorInfo = 0;
        m_TimerId = 0; //used for pinging
        m_RdcConnCheckTimeInterval = RDC_CHECKCONN_TIMEOUT;

        //
        // No reference to listening library.
        //
        m_InitListeningLibrary = FALSE;
        m_ListenConnectInProgress  = FALSE;
        m_ListenSocket         = INVALID_SOCKET;
        m_TSConnectSocket      = INVALID_SOCKET;
        m_ListenTimeoutTimerID = (UINT_PTR) 0;
        m_ICSPort              = 0;

        //
        //  Not valid until unitialized.
        //
        SetValid(FALSE);
    }
    ~CTSRDPRemoteDesktopClient();
    HRESULT FinalConstruct();

DECLARE_REGISTRY_RESOURCEID(IDR_TSRDPREMOTEDESKTOPCLIENT)
DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    //  Event Sinks
    //
    VOID OnRDPConnected();
    VOID OnLoginComplete();
    VOID OnDisconnected(long disconReason);
    VOID OnMSTSCReceiveData(BSTR data);
    VOID OnReceivedTSPublicKey(BSTR tsPublicKey, VARIANT_BOOL* bContinue);

    //
    //  Interface Map
    //  
BEGIN_COM_MAP(CTSRDPRemoteDesktopClient)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
    COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY(IQuickActivate)
    COM_INTERFACE_ENTRY(IPersistStorage)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY(ISAFRemoteDesktopClient)
    COM_INTERFACE_ENTRY(ISAFRemoteDesktopTestExtension)
    COM_INTERFACE_ENTRY2(IDispatch, ISAFRemoteDesktopClient)
    COM_INTERFACE_ENTRY(IDataChannelIO)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

    //
    //  Property Map
    //  
BEGIN_PROP_MAP(CTSRDPRemoteDesktopClient)
    PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
    PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    // PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

    //
    //  Connection Point Map
    //  
BEGIN_CONNECTION_POINT_MAP(CTSRDPRemoteDesktopClient)
    CONNECTION_POINT_ENTRY(DIID__ISAFRemoteDesktopClientEvents)
    CONNECTION_POINT_ENTRY(DIID__IDataChannelIOEvents)
END_CONNECTION_POINT_MAP()

    //
    //  Message Map
    //  
BEGIN_MSG_MAP(CTSRDPRemoteDesktopClient)
    CHAIN_MSG_MAP(CComControl<CTSRDPRemoteDesktopClient>)
    DEFAULT_REFLECTION_HANDLER()
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_TSCONNECT, OnTSConnect)
    MESSAGE_HANDLER(WM_TIMER, OnTimer)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    // 
    //  IViewObjectEx Methods
    //
    DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

public:

    LRESULT OnTSConnect(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnStartListen(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    //
    //  OnDraw
    //
    HRESULT OnDraw(ATL_DRAWINFO& di)
    {
        RECT& rc = *(RECT*)di.prcBounds;
        Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);
        HRESULT hr;

        if (!m_Initialized) {
            hr = S_OK;
            SetTextAlign(di.hdcDraw, TA_CENTER|TA_BASELINE);
            LPCTSTR pszText = _T("TSRDP Remote Desktop Client");
            TextOut(di.hdcDraw, 
                (rc.left + rc.right) / 2, 
                (rc.top + rc.bottom) / 2, 
                pszText, 
                lstrlen(pszText));
        }

        return hr;
    }

    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        //
        //  Hide our window, by default.
        //
        //ShowWindow(SW_HIDE);

        if (!m_Initialized) {
            LPCREATESTRUCT pCreateStruct = (LPCREATESTRUCT)lParam;
            Initialize(pCreateStruct);
        }
        
        return 0;
    }

    LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        DC_BEGIN_FN("CTSRDPRemoteDesktopClient::OnSetFocus");
        //
        //  Set focus back to the client window, if it exists.
        //
        if (m_TSClientWnd != NULL) {
            ::PostMessage(m_TSClientWnd, uMsg, wParam, lParam);
        }
        DC_END_FN();
        return 0;
    }

    //
    //  OnSize
    //
    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        DC_BEGIN_FN("CTSRDPRemoteDesktopClient::OnSize");

        if (m_TSClientWnd != NULL) {
            RECT rect;
            GetClientRect(&rect);
            ::MoveWindow(m_TSClientWnd, rect.left, rect.top, 
                        rect.right, rect.bottom, TRUE);
        }

        DC_END_FN();
        return 0;
    }

    LRESULT OnKeyDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        bHandled = TRUE;
        return 0;
        //return DefWindowProc(uMsg, wParam, lParam);
    }

    //
    //  ISAFRemoteDesktopClient Methods
    //
    STDMETHOD(ConnectToServer)(BSTR Server);
    STDMETHOD(DisconnectFromServer)();
    STDMETHOD(ConnectRemoteDesktop)();
    STDMETHOD(DisconnectRemoteDesktop)();
    STDMETHOD(get_IsRemoteDesktopConnected)(BOOL * pVal);
    STDMETHOD(get_IsServerConnected)(BOOL * pVal);
    STDMETHOD(put_EnableSmartSizing)(BOOL val);
    STDMETHOD(get_EnableSmartSizing)(BOOL *pVal);
    STDMETHOD(put_ColorDepth)(LONG Val);
    STDMETHOD(get_ColorDepth)(LONG* pVal);

    STDMETHOD(get_ExtendedErrorInfo)(LONG *error) {
        *error = m_LastExtendedErrorInfo;
        return S_OK;
    }
    STDMETHOD(get_ChannelManager)(ISAFRemoteDesktopChannelMgr **mgr) {
        *mgr = m_ChannelMgr;
        return S_OK;
    }
    STDMETHOD(put_ConnectParms)(/*[in]*/BSTR parms) {
        m_ConnectParms = parms;
        return S_OK;
    }
    STDMETHOD(get_ConnectParms)(/*[out, retval]*/BSTR *parms) {
        CComBSTR tmp;
        tmp = m_ConnectParms;
        *parms = tmp.Detach();
        return S_OK;
    }

    //
    //  Scriptable Event Object Registration Properties (not supported)
    //
    STDMETHOD(put_OnConnected)(/*[in]*/IDispatch *iDisp)         { return E_FAIL; }
    STDMETHOD(put_OnDisconnected)(/*[in]*/IDispatch *iDisp)      { return E_FAIL; }
    STDMETHOD(put_OnConnectRemoteDesktopComplete)(/*[in]*/IDispatch *iDisp) { return E_FAIL; }
    STDMETHOD(put_OnListenConnect)(/*[in]*/IDispatch *iDisp)    { return E_FAIL; }
    STDMETHOD(put_OnBeginConnect)(/*[in]*/IDispatch *iDisp)     { return E_FAIL; }

    //
    //  IDataChannelIO Methods
    //
    STDMETHOD(SendData)(/*[in]*/BSTR data);
    STDMETHOD(put_ChannelMgr)(/*[in]*/ISAFRemoteDesktopChannelMgr *newVal);

    //
    //  Return the name of this class.
    //
    virtual const LPTSTR ClassName() {
        return TEXT("CTSRDPRemoteDesktopServer");
    }

    //
    //  ISAFRemoteDesktopTestExtension
    //
    STDMETHOD(put_TestExtDllName)(/*[in]*/BSTR newVal);
    STDMETHOD(put_TestExtParams)(/*[in]*/BSTR newVal);

    STDMETHOD(get_ConnectedServer)(/*[in]*/BSTR* Val) {

        HRESULT hr = S_OK;

        if( m_ConnectedToServer ) {
            *Val = m_ConnectedServer.Copy();
        }
        else {
            hr = E_FAIL;
        }

        return hr;        
    }

    STDMETHOD(get_ConnectedPort)(/*[in]*/LONG* Val) {
        
        HRESULT hr = S_OK;

        if( m_ConnectedToServer ) {
            *Val = m_ConnectedPort;
        }
        else {
            hr = E_FAIL;
        }

        return hr;
    }

    STDMETHOD(CreateListenEndpoint)(
        /*[in]*/ LONG port, 
        /*[out, retval]*/ BSTR* pConnectParm
    );

    STDMETHOD(StartListen)(
        /*[in]*/ LONG timeout 
    );

    STDMETHOD(AcceptListenConnection)(
        /*[in]*/BSTR expertBlob
    );

    STDMETHOD(StopListen)();
};


///////////////////////////////////////////////////////
//
//  CTSRDPRemoteDesktopClient Inline Methods
//

inline STDMETHODIMP 
CTSRDPRemoteDesktopClient::get_IsServerConnected(
    BOOL *pVal
    )
/*++

Routine Description:

    Indicates whether the client is connected to the server, excluding
    control over the remote user's desktop.

Arguments:

    pVal  - Set to TRUE if the client is connected to the server.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::get_IsServerConnected");

    HRESULT hr = S_OK;

    if (IsValid()) {
        *pVal = m_ConnectedToServer;
    }
    else {
        ASSERT(FALSE);
        hr = E_FAIL;
    }

    DC_END_FN();
    return hr;
}

inline STDMETHODIMP 
CTSRDPRemoteDesktopClient::get_IsRemoteDesktopConnected(
    BOOL *pVal
    )
/*++

Routine Description:

    Indicates whether the control is currently controlling the remote user's 
    desktop.

Arguments:

    pVal  - Sets to TRUE if the control is currently connected to the server.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::get_IsRemoteDesktopConnected");

    HRESULT hr = S_OK;

    if (IsValid()) {
        *pVal = m_RemoteControlRequestInProgress;
    }
    else {
        ASSERT(FALSE);
        hr = E_FAIL;
    }

    DC_END_FN();
    return hr;
}


#endif //__TSRDPREMOTEDESKTOPCLIENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\common\datachannelmgr.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    DataChannelMgr.h

Abstract:

	This module contains an implementation of the ISAFRemoteDesktopDataChannel 
	and ISAFRemoteDesktopChannelMgr interfaces.  These interfaces are designed 
	to abstract out-of-band data channel access for the Salem project.

	The classes implemented in this module achieve this objective by 
	multiplexing multiple data channels into a single data channel that is 
	implemented by the remote control-specific Salem layer.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __DATACHANNELMGR_H__
#define __DATACHANNELMGR_H__

#include <RemoteDesktopTopLevelObject.h>
#include <RemoteDesktopChannels.h>
#include "RemoteDesktopUtils.h"
#include <rdschan.h>
#include <atlbase.h>

#pragma warning (disable: 4786)
#include <map>
#include <deque>
#include <vector>


///////////////////////////////////////////////////////
//
//	CRemoteDesktopDataChannel
//

class CRemoteDesktopChannelMgr;
class ATL_NO_VTABLE CRemoteDesktopDataChannel : 
	public CRemoteDesktopTopLevelObject
{
friend CRemoteDesktopChannelMgr;
protected:

	CComBSTR m_ChannelName;

	//
	//	Called to return our ISAFRemoteDesktopDataChannel interface.
	//
	virtual HRESULT GetISAFRemoteDesktopDataChannel(
				ISAFRemoteDesktopDataChannel **channel
				) = 0;

	//
	//	Called by the data channel manager when data is ready on our channel.
	//	
    virtual VOID DataReady() = 0;
};


///////////////////////////////////////////////////////
//
//	CRemoteDesktopChannelMgr
//

class ATL_NO_VTABLE CRemoteDesktopChannelMgr : 
	public CRemoteDesktopTopLevelObject
{
friend CRemoteDesktopDataChannel;
public:
    
protected:

    //
    //  Queue of pending messages for a single channel.
    //
    typedef struct _QueuedChannelBuffer {
        DWORD len;
        BSTR  buf;  
    } QUEUEDCHANNELBUFFER, *PQUEUEDCHANNELBUFFER;

    typedef std::deque<QUEUEDCHANNELBUFFER, CRemoteDesktopAllocator<QUEUEDCHANNELBUFFER> > InputBufferQueue;

    //
    //  Channel Map
    //
	typedef struct ChannelMapEntry
	{
		InputBufferQueue inputBufferQueue;
		CRemoteDesktopDataChannel *channelObject;
	#if DBG
		DWORD   bytesSent; 
		DWORD   bytesRead;
	#endif
	} CHANNELMAPENTRY, *PCHANNELMAPENTRY;
    typedef std::map<CComBSTR, PCHANNELMAPENTRY, CompareBSTR, CRemoteDesktopAllocator<PCHANNELMAPENTRY> > ChannelMap;
    ChannelMap  m_ChannelMap;

    //
    //  ThreadLock
    //
    CRITICAL_SECTION m_cs;

#if DBG
    LONG   m_LockCount;
#endif

    //  
    //  ThreadLock/ThreadUnlock an instance of this class.      
    //
    VOID ThreadLock();
    VOID ThreadUnlock();

protected:

    //
    //  Invoked by the Subclass when the next message is ready.
    //
    virtual VOID DataReady(BSTR msg);

    //
    //  Send Function to be Implemented by Subclass
    //
    //  The underlying data storage for the msg is a BSTR so that it is compatible
    //  with COM methods.
    //
    virtual HRESULT SendData(PREMOTEDESKTOP_CHANNELBUFHEADER msg) = 0;

	// 
	//	ISAFRemoteDesktopChannelMgr Helper Methods
	//
	HRESULT OpenDataChannel_(BSTR name, ISAFRemoteDesktopDataChannel **channel);

	//
	//	The subclass implements this for returning the data channel, specific
	//	to the current platform.
	//
	virtual CRemoteDesktopDataChannel *OpenPlatformSpecificDataChannel(
										BSTR channelName,
										ISAFRemoteDesktopDataChannel **channel
										) = 0;

public:

	//
    //  Constructor/Destructor
    //
    CRemoteDesktopChannelMgr();
    ~CRemoteDesktopChannelMgr();

	//
	//	Remove an existing data channel.
	//
	VOID RemoveChannel(BSTR channel);

	//
	//	Read the next message from a data channel.
	//
	HRESULT ReadChannelData(BSTR channel, BSTR *msg);

	//
	//	Send a buffer on the data channel.  
	//
	HRESULT SendChannelData(BSTR channel, BSTR outputBuf);

    //  
    //  Initialize an instance of this class.      
    //
    virtual HRESULT Initialize() { return S_OK; }

    //
    //  Return this class name.
    //
    virtual const LPTSTR ClassName()    { return TEXT("CRemoteDesktopChannelMgr"); }
};


///////////////////////////////////////////////////////
//
//  Inline Members
//

inline VOID CRemoteDesktopChannelMgr::ThreadLock()
{
    DC_BEGIN_FN("CRemoteDesktopChannelMgr::ThreadLock");
#if DBG
    m_LockCount++;
    //TRC_NRM((TB, TEXT("ThreadLock count is now %ld."), m_LockCount));
#endif
    EnterCriticalSection(&m_cs);
    DC_END_FN();
}

inline VOID CRemoteDesktopChannelMgr::ThreadUnlock()
{
    DC_BEGIN_FN("CRemoteDesktopChannelMgr::ThreadUnlock");
#if DBG
    m_LockCount--;
    //TRC_NRM((TB, TEXT("ThreadLock count is now %ld."), m_LockCount));
    ASSERT(m_LockCount >= 0);
#endif
    LeaveCriticalSection(&m_cs);
    DC_END_FN();
}

#endif //__DATACHANNELMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\common\datachannelmgr.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    DataChannelMgr.cpp

Abstract:

    This module contains an implementation of the ISAFRemoteDesktopDataChannel 
    and ISAFRemoteDesktopChannelMgr interfaces.  These interfaces are designed 
    to abstract out-of-band data channel access for the Salem project.

    The classes implemented in this module achieve this objective by 
    multiplexing multiple data channels into a single data channel that is 
    implemented by the remote control-specific Salem layer.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_dcmpl"

#include "DataChannelMgr.h"
#include <RemoteDesktop.h>
#include <RemoteDesktopDBG.h>


///////////////////////////////////////////////////////
//
//  Local Defines
//

#define OUTBUFRESIZEDELTA       100


///////////////////////////////////////////////////////
//
//  CRemoteDesktopChannelMgr Members
//

CRemoteDesktopChannelMgr::CRemoteDesktopChannelMgr()
/*++

Routine Description:

    Constructor

Arguments:

Return Value:

    None.

 --*/

{
    DC_BEGIN_FN("CRemoteDesktopChannelMgr::CRemoteDesktopChannelMgr");

#if DBG
    m_LockCount = 0;        
#endif

    //
    //  Initialize the critical section.
    //
    InitializeCriticalSection(&m_cs);

    DC_END_FN();
}

CRemoteDesktopChannelMgr::~CRemoteDesktopChannelMgr()
/*++

Routine Description:

    Destructor

Arguments:

Return Value:

    None.

 --*/

{
    DC_BEGIN_FN("CRemoteDesktopChannelMgr::~CRemoteDesktopChannelMgr");

    ThreadLock();

    CComBSTR name;
    CRemoteDesktopDataChannel *chnl;
    HRESULT hr;

    //
    //  Remove each channel.
    //
    while (!m_ChannelMap.empty()) {
        chnl = (*m_ChannelMap.begin()).second->channelObject;       
        RemoveChannel(chnl->m_ChannelName);
    }

    //
    //  Clean up the critical section object.
    //
    ThreadUnlock();
    DeleteCriticalSection(&m_cs);

    DC_END_FN();
}

HRESULT 
CRemoteDesktopChannelMgr::OpenDataChannel_(
                BSTR name, 
                ISAFRemoteDesktopDataChannel **channel
                )
/*++

Routine Description:

    Open a data channel.  Observe that this function doesn't keep
    a reference of its own to the returned interface.  The channel
    notifies us when it goes away so we can remove it from our list.

Arguments:

    name    -   Channel name.  Channel names are restricted to
                16 bytes.
    channel -   Returned channe linterface.

Return Value:

    S_OK is returned on success.  Otherwise, an error code
    is returned.

 --*/

{
    DC_BEGIN_FN("CRemoteDesktopChannelMgr::OpenDataChannel_");

    PCHANNELMAPENTRY newChannel = NULL;
    ChannelMap::iterator iter;
    HRESULT hr = S_OK;
    CComBSTR channelName;

    ASSERT(IsValid());

    ThreadLock();

    //
    //  Check the parms.
    //
    if ((name == NULL) || !wcslen(name)) {
        TRC_ERR((TB, TEXT("Invalid channel name")));
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto CLEANUPANDEXIT;
    }
    if (channel == NULL) {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto CLEANUPANDEXIT;
    }
    channelName = name;

    //
    //  AddRef an existing interface if the channel is already open.
    //
    iter = m_ChannelMap.find(channelName);
    if (iter != m_ChannelMap.end()) {

        TRC_NRM((TB, TEXT("Channel %s exists."), name));

        CRemoteDesktopDataChannel *chnl = (*iter).second->channelObject;
        hr = chnl->GetISAFRemoteDesktopDataChannel(channel);

        if (hr != S_OK) {
            TRC_ERR((TB, TEXT("GetISAFRemoteDesktopDataChannel failed:  %08X"), hr));
        }
        goto CLEANUPANDEXIT;
    }

    //
    //  Create the new channel with some help from the subclass.
    //
    newChannel = new CHANNELMAPENTRY;
    if (newChannel == NULL) {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto CLEANUPANDEXIT;
    }
    newChannel->channelObject = OpenPlatformSpecificDataChannel(
                                                    name,
                                                    channel
                                                    );
    if (newChannel->channelObject == NULL) {
        TRC_ERR((TB, TEXT("Failed to allocate data channel.")));
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto CLEANUPANDEXIT;
    }
#if DBG
    newChannel->bytesSent = 0;
    newChannel->bytesRead = 0;
#endif

    if (hr != S_OK) {
        TRC_ERR((TB, TEXT("QI failed for ISAFRemoteDesktopDataChannel")));
        goto CLEANUPANDEXIT;
    }

    //
    //  Add the channel to the channel map.
    //
    try {
        m_ChannelMap.insert(ChannelMap::value_type(channelName, newChannel));        
    }
    catch(CRemoteDesktopException x) {
        hr = HRESULT_FROM_WIN32(x.m_ErrorCode);
    }

CLEANUPANDEXIT:

    if (hr != S_OK) {
        if (newChannel != NULL) {
            (*channel)->Release();
            delete newChannel;
        }
    }

    ThreadUnlock();

    DC_END_FN();

    return hr;
}

VOID 
CRemoteDesktopChannelMgr::RemoveChannel(
    BSTR channel
    )
/*++

Routine Description:

    Remove an existing data channel.  This function is called from the
    channel object when its ref count goes to 0.

Arguments:

    channel -   Name of channel to remove.

Return Value:

    None.

 --*/

{
    DC_BEGIN_FN("CRemoteDesktopChannelMgr::RemoveChannel");

    ASSERT(IsValid());

    ChannelMap::iterator iter;
    PCHANNELMAPENTRY pChannel;

    ThreadLock();

    //
    //  Find the channel.
    //
    iter = m_ChannelMap.find(channel);
    if (iter == m_ChannelMap.end()) {
        ASSERT(FALSE);
        TRC_ERR((TB, TEXT("Channel %ld does not exist."), channel));
        goto CLEANUPANDEXIT;
    }

    //
    //  Release the input buffer queue and its contents.
    //
    pChannel = (*iter).second;
    while (!pChannel->inputBufferQueue.empty()) {

        QUEUEDCHANNELBUFFER channelBuf = pChannel->inputBufferQueue.front();            
        SysFreeString(channelBuf.buf);
        pChannel->inputBufferQueue.pop_front();
    }

    //
    //  Erase the channel.
    //
    m_ChannelMap.erase(iter);        
    delete pChannel;

CLEANUPANDEXIT:

    ThreadUnlock();

    DC_END_FN();
}

HRESULT 
CRemoteDesktopChannelMgr::SendChannelData(
    BSTR channel, 
    BSTR outputBuf
    )
/*++

Routine Description:

    Send a buffer on the data channel.  

Arguments:

    channel     -   Relevant channel.
    outputBuf   -   Associated output data.

Return Value:

    ERROR_SUCCESS is returned on success.  Otherwise, an error code
    is returned.

 --*/

{
    DC_BEGIN_FN("CRemoteDesktopChannelMgr::SendChannelData");

    ASSERT(IsValid());

    HRESULT result = S_OK;
    PREMOTEDESKTOP_CHANNELBUFHEADER hdr;
    DWORD bytesToSend;
    PBYTE data;
    BSTR fullOutputBuf;
    DWORD bufLen = SysStringByteLen(outputBuf);
    DWORD channelNameLen;
    PBYTE ptr;

    //
    //  Make sure this is a valid channel.
    //
    ChannelMap::iterator iter;

    //
    //  ThreadLock
    //
    ThreadLock();

    //
    //  Make sure the channel exists.
    //
    iter = m_ChannelMap.find(channel);
    if (iter == m_ChannelMap.end()) {
        ASSERT(FALSE);
        goto CLEANUPANDEXIT;
    }

#if DBG
    (*iter).second->bytesSent += SysStringByteLen(outputBuf);           
#endif
    
    //
    //  Allocate the outgoing buffer.
    //
    channelNameLen = SysStringByteLen(channel);
    bytesToSend = sizeof(REMOTEDESKTOP_CHANNELBUFHEADER) + bufLen + channelNameLen;
    fullOutputBuf = (BSTR)SysAllocStringByteLen(
                                NULL, 
                                bytesToSend
                                );
    if (fullOutputBuf == NULL) {
        TRC_ERR((TB, TEXT("Can't allocate %ld bytes."), 
                bytesToSend + OUTBUFRESIZEDELTA));
        result = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the header.
    //
    hdr = (PREMOTEDESKTOP_CHANNELBUFHEADER)fullOutputBuf;
    memset(hdr, 0, sizeof(REMOTEDESKTOP_CHANNELBUFHEADER));

#ifdef USE_MAGICNO
    hdr->magicNo = CHANNELBUF_MAGICNO;
#endif

    hdr->channelNameLen = channelNameLen;
    hdr->dataLen = bufLen;

    //
    //  Copy the channel name.
    //
    ptr = (PBYTE)(hdr + 1);
    memcpy(ptr, channel, hdr->channelNameLen);
    
    //
    //  Copy the data.
    //
    ptr += hdr->channelNameLen;
    memcpy(ptr, outputBuf, bufLen);

    //
    //  Send the data through the concrete subclass.
    //
    result = SendData(hdr);

    //
    //  Release the send buffer that we allocated.
    //
    SysFreeString(fullOutputBuf);

CLEANUPANDEXIT:

    ThreadUnlock();

    DC_END_FN();

    return result;
}

HRESULT 
CRemoteDesktopChannelMgr::ReadChannelData(
    IN BSTR channel, 
    OUT BSTR *msg
    )
/*++

Routine Description:

    Read the next message from a data channel.

Arguments:

    channel         -   Relevant data channel.
    msg             -   The next message.  The caller should release the 
                        data buffer using SysFreeString.

Return Value:

    S_OK on success.  ERROR_NO_MORE_ITEMS is returned if there 
    are no more messages.  An error code otherwise.

 --*/

{
    DC_BEGIN_FN("CRemoteDesktopChannelMgr::ReadChannelData");
    HRESULT result = S_OK;

    ChannelMap::iterator channelIterator;
    PCHANNELMAPENTRY pChannel;

    ASSERT(IsValid());

    ThreadLock();

    //
    //  Initialize the output buf to NULL.
    //
    *msg = NULL;

    //
    //  Find the channel.  
    //
    channelIterator = m_ChannelMap.find(channel);
    if (channelIterator != m_ChannelMap.end()) {
        pChannel = (*channelIterator).second;
    }
    else {
        ASSERT(FALSE);
        result = E_FAIL;
        goto CLEANUPANDEXIT;
    }

    //
    //  Make sure there is data in the queue.
    //
    if (pChannel->inputBufferQueue.empty()) { 
        result = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        goto CLEANUPANDEXIT;
    }

    //
    //  Return the buffer.
    //
    *msg = pChannel->inputBufferQueue.front().buf;
    ASSERT(*msg != NULL);

    //
    //  Delete it.
    //
    pChannel->inputBufferQueue.pop_front();

CLEANUPANDEXIT:

    ThreadUnlock();

    DC_END_FN();

    return result;
}

VOID 
CRemoteDesktopChannelMgr::DataReady(
    BSTR msg
    )
/*++

Routine Description:

    Invoked by the subclass when the next message is ready.  This
    function copies the message buffer and returns.

Arguments:

    msg     -   Next message.

Return Value:

    None.

 --*/

{
    DC_BEGIN_FN("CRemoteDesktopChannelMgr::DataReady");

    ChannelMap::iterator channel;
    QUEUEDCHANNELBUFFER channelBuf;
    PREMOTEDESKTOP_CHANNELBUFHEADER hdr = NULL;
    DWORD result = ERROR_SUCCESS;
    PVOID data;
    PBYTE ptr;
    BSTR tmp;
    CComBSTR channelName;

    ASSERT(IsValid());

    ASSERT(msg != NULL);

    hdr = (PREMOTEDESKTOP_CHANNELBUFHEADER)msg;

#ifdef USE_MAGICNO
    ASSERT(hdr->magicNo == CHANNELBUF_MAGICNO);
#endif


    //
    //  Initialize the channel buf.
    //  
    channelBuf.buf = NULL;

    //
    //  Get the channel name.
    //
    tmp = SysAllocStringByteLen(NULL, hdr->channelNameLen);
    if (tmp == NULL) {
        TRC_ERR((TB, TEXT("Can't allocate channel name.")));
        goto CLEANUPANDEXIT;
    }
    ptr = (PBYTE)(hdr + 1);
    memcpy(tmp, ptr, hdr->channelNameLen);
    channelName.Attach(tmp);

    ThreadLock();

    //
    //  Find the corresponding channel.
    //
#ifdef USE_MAGICNO
    ASSERT(hdr->magicNo == CHANNELBUF_MAGICNO);
#endif

    channel = m_ChannelMap.find(channelName);
    if (channel == m_ChannelMap.end()) {
        TRC_ALT((TB, L"Data received for non-existent channel %s", 
                channelName.m_str));
        result = E_FAIL;
        ThreadUnlock();
        goto CLEANUPANDEXIT;
    }

    //
    //  Copy the incoming data buffer.
    //
    ptr += hdr->channelNameLen;
    channelBuf.len = hdr->dataLen;
    channelBuf.buf = SysAllocStringByteLen(NULL, channelBuf.len);
    if (channelBuf.buf == NULL) {
        TRC_ERR((TB, TEXT("Can't allocate %ld bytes for buf."), channelBuf.len));         
        result = E_FAIL;
        ThreadUnlock();
        goto CLEANUPANDEXIT;
    }
    memcpy(channelBuf.buf, ptr, hdr->dataLen);

    //
    //  Add to the channel's input queue.
    //
    try {
        (*channel).second->inputBufferQueue.push_back(channelBuf);
    }
    catch(CRemoteDesktopException x) {
        result = x.m_ErrorCode;
        ASSERT(result != ERROR_SUCCESS);
    }

    //
    //  Notify the interface that data is ready.
    //
    if (result == ERROR_SUCCESS) {
        (*channel).second->channelObject->DataReady();
    
#if DBG
        (*channel).second->bytesRead += hdr->dataLen;           
#endif
    }

    ThreadUnlock();

CLEANUPANDEXIT:

    if ((result != ERROR_SUCCESS) && (channelBuf.buf != NULL)) {
        SysFreeString(channelBuf.buf);
    }

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\client\rdhost\tsrdpremotedesktopclient.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    TSRDPRemoteDesktopClient

Abstract:

    This is the TS/RDP implementation of the Remote Desktop Client class.
    
    The Remote Desktop Client class hierarchy provides a pluggable C++ 
    interface for remote desktop access, by abstracting the implementation 
    specific details of remote desktop access for the client-side

    The TSRDPRemoteDesktopClass implements remote-desktopping
    with the help of an instance of the MSTSC ActiveX client control.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#include "stdafx.h"

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_tsrdpc"

#include "RDCHost.h"
#include "TSRDPRemoteDesktopClient.h"
#include <RemoteDesktopChannels.h>
#include <mstsax_i.c>
#include <TSRDPRemoteDesktop.h>
#include "pchannel.h"
#include <tsremdsk.h>
#include <sessmgr.h>
#include <sessmgr_i.c>
#include <regapi.h>
#include "parseaddr.h"
#include "icshelpapi.h"
#include <tsperf.h>
#include "base64.h"

#define ISRCSTATUSCODE(code) ((code) > SAFERROR_SHADOWEND_BASE)

//
// Variable to manage WinSock and ICS library startup/shutdown
//
LONG CTSRDPRemoteDesktopClient::gm_ListeningLibraryRefCount = 0;        // Number of time that WinSock is intialized

HRESULT
CTSRDPRemoteDesktopClient::InitListeningLibrary()
/*++

Description:

    Function to initialize WinSock and ICS library for StartListen(), function add
    reference count to library if WinSock/ICS library already initialized.

Parameters:

    None.

Returns:

    S_OK or error code.

--*/
{
    WSADATA  wsaData;
    WORD     versionRequested;
    INT      intRC;
    DWORD    dwStatus;
    HRESULT  hr = S_OK;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::InitListeningLibrary");


    // Our COM object is apartment-threaded model, need a critical section if
    // we switch to multi-threaded
    if( gm_ListeningLibraryRefCount == 0 )
    {
        //
        // Initialize WinSock.
        //
        versionRequested = MAKEWORD(1, 1);
        intRC = WSAStartup(versionRequested, &wsaData);
        if( intRC != 0 )
        {
            intRC = WSAGetLastError();

            TRC_ERR((TB, _T("WSAStartup failed %d"), intRC));
            TRC_ASSERT( (intRC == 0), (TB, _T("WSAStartup failed...\n")) );

            hr = HRESULT_FROM_WIN32( intRC );
            goto CLEANUPANDEXIT;
        }        

        /************************************************************************/
        /* Now confirm that this WinSock supports version 1.1.  Note that if    */
        /* the DLL supports versions greater than 1.1 in addition to 1.1 then   */
        /* it will still return 1.1 in the version information as that is the   */
        /* version requested.                                                   */
        /************************************************************************/
        if ((LOBYTE(wsaData.wVersion) != 1) ||
            (HIBYTE(wsaData.wVersion) != 1))
        {
            /********************************************************************/
            /* Oops - this WinSock doesn't support version 1.1.                 */
            /********************************************************************/
            TRC_ERR((TB, _T("WinSock doesn't support version 1.1")));

            WSACleanup();

            hr = HRESULT_FROM_WIN32( WSAVERNOTSUPPORTED );
            goto CLEANUPANDEXIT;
        }

        //
        // Initialize ICS library.
        //
        dwStatus = StartICSLib();
        if( ERROR_SUCCESS != dwStatus )
        {
            // Shutdown WinSock so that we have a matching WSAStatup() and StartICSLib().
            WSACleanup();

            hr = HRESULT_FROM_WIN32( dwStatus );

            TRC_ERR((TB, _T("StartICSLib() failed with %d"), dwStatus));
            TRC_ASSERT( (ERROR_SUCCESS == dwStatus), (TB, _T("StartICSLib() failed...\n")) );

            goto CLEANUPANDEXIT;
        }
    }

    InterlockedIncrement( &gm_ListeningLibraryRefCount );

CLEANUPANDEXIT:

    DC_END_FN();
    return hr;
}


HRESULT
CTSRDPRemoteDesktopClient::TerminateListeningLibrary()
/*++

Description:

    Function to shutdown ICS libaray and WinSock, decrement reference count
    if more than one object is referencing WinSock/ICS library.

Parameters:

    None.

Returns:

    S_OK or error code

Note:

    Not multi-thread safe, need CRITICAL_SECTION if we switch to multi-threaded
    model.

--*/
{
    HRESULT hr = S_OK;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::TerminateListeningLibrary");


    ASSERT( gm_ListeningLibraryRefCount > 0 );
    if( gm_ListeningLibraryRefCount <= 0 )
    {
        TRC_ERR((TB, _T("TerminateListeningLibrary() called before InitListeningLibrary()")));

        hr = HRESULT_FROM_WIN32(WSANOTINITIALISED);
        goto CLEANUPANDEXIT;
    }
        

    if( 0 == InterlockedDecrement( &gm_ListeningLibraryRefCount ) )
    {
        // Stop ICS libray.
        StopICSLib();

        // Shutdown WinSock
        WSACleanup();
    }

CLEANUPANDEXIT:

    DC_END_FN();
    return hr;
}

///////////////////////////////////////////////////////
//
//  CMSTSCClientEventSink Methods
//

CMSTSCClientEventSink::~CMSTSCClientEventSink() 
{
    DC_BEGIN_FN("CMSTSCClientEventSink::~CMSTSCClientEventSink");

    if (m_Obj) {
        ASSERT(m_Obj->IsValid());
    }

    DC_END_FN();
}

//
//  Event Sinks
//
HRESULT __stdcall 
CMSTSCClientEventSink::OnRDPConnected() 
{
    m_Obj->OnRDPConnected();
    return S_OK;
}
HRESULT __stdcall 
CMSTSCClientEventSink::OnLoginComplete() 
{
    m_Obj->OnLoginComplete();
    return S_OK;
}
HRESULT __stdcall 
CMSTSCClientEventSink::OnDisconnected(
    long disconReason
    ) 
{
    m_Obj->OnDisconnected(disconReason);
    return S_OK;
}
void __stdcall CMSTSCClientEventSink::OnReceiveData(
    BSTR chanName, 
    BSTR data
    )
{
    m_Obj->OnMSTSCReceiveData(data);
}
void __stdcall CMSTSCClientEventSink::OnReceivedTSPublicKey(
    BSTR publicKey, 
    VARIANT_BOOL* pfbContinueLogon 
    )
{
    m_Obj->OnReceivedTSPublicKey(publicKey, pfbContinueLogon);
}

///////////////////////////////////////////////////////
//
//  CCtlChannelEventSink Methods
//

CCtlChannelEventSink::~CCtlChannelEventSink() 
{
    DC_BEGIN_FN("CCtlChannelEventSink::~CCtlChannelEventSink");

    if (m_Obj) {
        ASSERT(m_Obj->IsValid());
    }

    DC_END_FN();
}

//
//  Event Sinks
//
void __stdcall 
CCtlChannelEventSink::DataReady(BSTR channelName)
{
    m_Obj->HandleControlChannelMsg();
}


///////////////////////////////////////////////////////
//
//  CTSRDPRemoteDesktopClient Methods
//

HRESULT 
CTSRDPRemoteDesktopClient::FinalConstruct()
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::FinalConstruct");

    HRESULT hr = S_OK;
    if (!AtlAxWinInit()) {
        TRC_ERR((TB, L"AtlAxWinInit failed."));
        hr = E_FAIL;
    }

    DC_END_FN();
    return hr;
}

CTSRDPRemoteDesktopClient::~CTSRDPRemoteDesktopClient()
/*++

Routine Description:

    The Destructor

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::~CTSRDPRemoteDesktopClient");

    if (m_ChannelMgr) {
        m_CtlChannelEventSink.DispEventUnadvise(m_CtlChannel);
    }

    if (m_TSClient != NULL) {
        m_TSClient->Release();
        m_TSClient = NULL;
    }

    if( m_TimerId > 0 ) {
        KillTimer( m_TimerId );
    }

    ListenConnectCleanup();

    if( m_InitListeningLibrary )
    {
        // Dereference listening library.
        TerminateListeningLibrary();
    }

    DC_END_FN();
}

HRESULT 
CTSRDPRemoteDesktopClient::Initialize(
    LPCREATESTRUCT pCreateStruct
    )
/*++

Routine Description:

    Final Initialization

Arguments:

    pCreateStruct   -   WM_CREATE, create struct.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::Initialize");

    RECT rcClient = { 0, 0, pCreateStruct->cx, pCreateStruct->cy };
    HRESULT hr;
    IUnknown *pUnk = NULL;
    DWORD result;
    IMsRdpClientAdvancedSettings2 *advancedSettings;
    CComBSTR bstr;
    HKEY hKey = NULL;
    HRESULT hrIgnore;

    ASSERT(!m_Initialized);

    //
    //  Create the client Window.
    //
    m_TSClientWnd = m_TSClientAxView.Create(
                            m_hWnd, rcClient, MSTSCAX_TEXTGUID,
                            WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN, 0
                            );

    if (m_TSClientWnd == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        TRC_ERR((TB, L"Window Create:  %08X", GetLastError()));
        goto CLEANUPANDEXIT;
    }

    //
    //  Get IUnknown
    //
    hr = AtlAxGetControl(m_TSClientWnd, &pUnk);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"AtlAxGetControl:  %08X", hr));
        pUnk = NULL;
        goto CLEANUPANDEXIT;
    }

    //
    //  Initialize the event sink.
    //
    m_TSClientEventSink.m_Obj = this;

    //
    //  Add the event sink.
    //
    hr = m_TSClientEventSink.DispEventAdvise(pUnk);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"DispEventAdvise:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Get the control.
    //
    hr = pUnk->QueryInterface(__uuidof(IMsRdpClient2), (void**)&m_TSClient);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"QueryInterface:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Specify that the MSTSC input handler window should accept background
    //  events.
    //
    hr = m_TSClient->get_AdvancedSettings3(&advancedSettings);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"IMsTscAdvancedSettings: %08X", hr));
        goto CLEANUPANDEXIT;
    }
    hr = advancedSettings->put_allowBackgroundInput(1);


    //
    // Disable autoreconnect it doesn't apply to Salem
    //
    hr = advancedSettings->put_EnableAutoReconnect(VARIANT_FALSE);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"put_EnableAutoReconnect:  %08X", hr));
        result = E_FAIL;
        goto CLEANUPANDEXIT;
    }

    //
    //  Disable advanced desktop features for the help session.
    //  An error here is not critical, so we ignore it.
    //
    LONG flags = TS_PERF_DISABLE_WALLPAPER | TS_PERF_DISABLE_THEMING; 
    hrIgnore = advancedSettings->put_PerformanceFlags(flags);
    if (!SUCCEEDED(hrIgnore)) {
        TRC_ERR((TB, L"put_PerformanceFlags:  %08X", hrIgnore));
    }

    //
    //  Disable CTRL_ALT_BREAK, ignore error
    //
    hrIgnore = advancedSettings->put_HotKeyFullScreen(0);
    if (!SUCCEEDED(hrIgnore)) {
        TRC_ERR((TB, L"put_HotKeyFullScreen:  %08X", hrIgnore));
    }

    //
    //  Don't allow mstscax to grab input focus on connect.  Ignore error
    //  on failure.
    //
    hrIgnore = advancedSettings->put_GrabFocusOnConnect(FALSE);
    if (!SUCCEEDED(hrIgnore)) {
        TRC_ERR((TB, L"put_HotKeyFullScreen:  %08X", hrIgnore));
    }

    advancedSettings->Release();
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"put_allowBackgroundInput:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

    //
    //  Create the "remote desktop" virtual channel with the TS Client.
    //
    bstr = TSRDPREMOTEDESKTOP_VC_CHANNEL;
    hr = m_TSClient->CreateVirtualChannels(bstr); 
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"CreateVirtualChannels:  %08X", hr));
        result = E_FAIL;
        goto CLEANUPANDEXIT;
    }
    
    //
    //  Set the Shadow Persistent option
    //
    hr = m_TSClient->SetVirtualChannelOptions(bstr, CHANNEL_OPTION_REMOTE_CONTROL_PERSISTENT); 
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"SetVirtualChannelOptions:  %08X", hr));
        result = E_FAIL;
        goto CLEANUPANDEXIT;
    }

    //initialize timer-related stuff
    m_PrevTimer = GetTickCount();
    //
    //get the time interval for pings from the registry
    //
    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    REG_CONTROL_SALEM,
                    0,
                    KEY_READ,
                    &hKey
                    ) == ERROR_SUCCESS ) {

        DWORD dwSize = sizeof(DWORD);
        DWORD dwType;
        if((RegQueryValueEx(hKey,
                            RDC_CONNCHECK_ENTRY,
                            NULL,
                            &dwType,
                            (PBYTE) &m_RdcConnCheckTimeInterval,
                            &dwSize
                           ) == ERROR_SUCCESS) && dwType == REG_DWORD ) {

            m_RdcConnCheckTimeInterval *= 1000; //we need this in millisecs
        }
        else
        {
            //
            //fall back to default, if reg lookup failed
            //
            m_RdcConnCheckTimeInterval = RDC_CHECKCONN_TIMEOUT;
        }
    }

CLEANUPANDEXIT:

    if(NULL != hKey )
        RegCloseKey(hKey);
    //
    //  m_TSClient keeps our reference to the client object until
    //  the destructor is called.
    //
    if (pUnk != NULL) {
        pUnk->Release();
    }

    SetValid(SUCCEEDED(hr));

    DC_END_FN();

    return hr;
}

STDMETHODIMP 
CTSRDPRemoteDesktopClient::SendData(
    BSTR data
    )
/*++

Routine Description:

    IDataChannelIO Data Channel Send Method

Arguments:

    data    -   Data to send.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::SendData");

    CComBSTR channelName;
    HRESULT hr;

    ASSERT(IsValid());

    channelName = TSRDPREMOTEDESKTOP_VC_CHANNEL;
    hr = m_TSClient->SendOnVirtualChannel(
                                    channelName,
                                    (BSTR)data
                                    );
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"SendOnVirtualChannel:  %08X", hr));
    }

    //
    //update timer
    //
     m_PrevTimer = GetTickCount();

    DC_END_FN();
    return hr;
}

STDMETHODIMP 
CTSRDPRemoteDesktopClient::put_EnableSmartSizing(
    BOOL val
    )
/*++

Routine Description:

    Enable/Disable Smart Sizing

Arguments:

    val     -   TRUE for enable.  FALSE, otherwise.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    HRESULT hr;
    IMsRdpClientAdvancedSettings *pAdvSettings = NULL;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::put_EnableSmartSizing");

    if (!IsValid()) {
        ASSERT(FALSE);
        hr = E_FAIL;
        goto CLEANUPANDEXIT;
    }
    
    hr = m_TSClient->get_AdvancedSettings2(&pAdvSettings);
    if (hr != S_OK) {
        TRC_ERR((TB, L"get_AdvancedSettings2:  %08X", hr));
        goto CLEANUPANDEXIT;
    }
    hr = pAdvSettings->put_SmartSizing(val ? VARIANT_TRUE : VARIANT_FALSE);
    pAdvSettings->Release();

CLEANUPANDEXIT:

    DC_END_FN();
    return hr;
}

STDMETHODIMP 
CTSRDPRemoteDesktopClient::get_EnableSmartSizing(
    BOOL *pVal
    )
/*++

Routine Description:

    Enable/Disable Smart Sizing

Arguments:

    val     -   TRUE for enable.  FALSE, otherwise.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    HRESULT hr;
    VARIANT_BOOL vb;
    IMsRdpClientAdvancedSettings *pAdvSettings = NULL;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::put_EnableSmartSizing");

    if (!IsValid()) {
        ASSERT(FALSE);
        hr = E_FAIL;
        goto CLEANUPANDEXIT;
    }
    
    hr = m_TSClient->get_AdvancedSettings2(&pAdvSettings);
    if (hr != S_OK) {
        TRC_ERR((TB, L"get_AdvancedSettings2:  %08X", hr));
        goto CLEANUPANDEXIT;
    }
    
    hr = pAdvSettings->get_SmartSizing(&vb);
    *pVal = (vb != 0);
    pAdvSettings->Release();

CLEANUPANDEXIT:

    DC_END_FN();

    return hr;
}

STDMETHODIMP 
CTSRDPRemoteDesktopClient::put_ChannelMgr(
    ISAFRemoteDesktopChannelMgr *newVal
    ) 
/*++

Routine Description:

    Assign the data channel manager interface.

Arguments:

    newVal  -   Data Channel Manager

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::put_ChannelMgr");

    HRESULT hr = S_OK;

    //
    //  We should get called one time.
    //
    ASSERT(m_ChannelMgr == NULL);
    m_ChannelMgr = newVal;

    //
    //  Register the Remote Desktop control channel
    //
    hr = m_ChannelMgr->OpenDataChannel(
                    REMOTEDESKTOP_RC_CONTROL_CHANNEL, &m_CtlChannel
                    );
    if (!SUCCEEDED(hr)) {
        goto CLEANUPANDEXIT;
    }

    //
    //  Register an event sink with the channel manager.
    //
    m_CtlChannelEventSink.m_Obj = this;

    //
    //  Add the event sink.
    //
    hr = m_CtlChannelEventSink.DispEventAdvise(m_CtlChannel);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"DispEventAdvise:  %08X", hr));
    }

CLEANUPANDEXIT:

    return hr;
}

HRESULT
CTSRDPRemoteDesktopClient::ConnectServerWithOpenedSocket()
/*++

Routine Description:

    Connects the client component to the server-side Remote Desktop Host COM 
    Object with already opened socket.

Arguments:

    None.

Returns:

    S_OK or error code

--*/
{
    HRESULT hr = S_OK;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::ConnectServerWithSocket");

    IMsRdpClientAdvancedSettings* ptsAdvSettings = NULL;

    TRC_NRM((TB, L"ConnectServerWithOpenedSocket"));

    ASSERT( INVALID_SOCKET != m_TSConnectSocket );

    //
    //  Direct the MSTSCAX control to connect.
    //
    hr = m_TSClient->put_Server( m_ConnectedServer );
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"put_Server:  %ld", hr));
        goto CLEANUPANDEXIT;
    }

    hr = m_TSClient->get_AdvancedSettings2( &ptsAdvSettings );
    if( SUCCEEDED(hr) && ptsAdvSettings ) {
        VARIANT var;

        VariantClear(&var);
        var.vt = VT_BYREF;
        var.byref = (PVOID)m_TSConnectSocket;

        hr = ptsAdvSettings->put_ConnectWithEndpoint( &var );

        if( FAILED(hr) ) {
            TRC_ERR((TB, _T("put_ConnectWithEndpoint failed - GLE:%x"), hr));
        }

        VariantClear(&var);
        ptsAdvSettings->Release();
    }

    if( FAILED(hr) ) {
        goto CLEANUPANDEXIT;
    }

    //
    // mstscax owns this socket and will close it
    //
    m_TSConnectSocket = INVALID_SOCKET;
    
    hr = m_TSClient->Connect();
    if( FAILED(hr) ) {
        TRC_ERR((TB, L"Connect:  0x%08x", hr));
        goto CLEANUPANDEXIT;
    }

CLEANUPANDEXIT:

    DC_END_FN();

    return hr;        
}


HRESULT
CTSRDPRemoteDesktopClient::ConnectServerPort(
    BSTR bstrServer,
    LONG portNumber
    )
/*++

Routine Description:

    Connects the client component to the server-side Remote Desktop Host COM 
    Object with specific port number

Arguments:

    bstrServer : Name or IP address of server.
    portNumber : optional port number.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

--*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::ConnectServerPort");

    HRESULT hr;
    IMsRdpClientAdvancedSettings* ptsAdvSettings = NULL;

    TRC_NRM((TB, L"ConnectServerPort %s %d", bstrServer, portNumber));

    //
    //  Direct the MSTSCAX control to connect.
    //
    hr = m_TSClient->put_Server( bstrServer );
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"put_Server:  %ld", hr));
        goto CLEANUPANDEXIT;
    }

    hr = m_TSClient->get_AdvancedSettings2( &ptsAdvSettings );
    if( SUCCEEDED(hr) && ptsAdvSettings ) {
        //
        // Previous ConnectServerPort() might have set this port number
        // other than 3389
        //
        hr = ptsAdvSettings->put_RDPPort( 
                                    (0 != portNumber) ? portNumber : TERMSRV_TCPPORT
                                );

        if (FAILED(hr) ) {
            TRC_ERR((TB, L"put_RDPPort failed: 0x%08x", hr));
        }

        ptsAdvSettings->Release();
    }
    else {
        TRC_ERR((TB, L"get_AdvancedSettings2 failed: 0x%08x", hr));
    }

    //
    // Failed the connection if we can't set the port number
    //
    if( FAILED(hr) )
    {
        goto CLEANUPANDEXIT;
    }

    m_ConnectedServer = bstrServer;
    m_ConnectedPort = (0 != portNumber) ? portNumber : TERMSRV_TCPPORT;

    hr = m_TSClient->Connect();
    if( FAILED(hr) ) {
        TRC_ERR((TB, L"Connect:  0x%08x", hr));
    }
    

CLEANUPANDEXIT:

    DC_END_FN();

    return hr;        
}

HRESULT
CTSRDPRemoteDesktopClient::SetupConnectionInfo(
    BOOL bListenConnectInfo,
    BSTR bstrExpertBlob
    )
/*++

Routine Description:

    Connects the client component to the server-side Remote Desktop Host COM 
    Object.  

Arguments:

    bstrExpertBlob : Optional parameter to be transmitted to SAF resolver.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

--*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::SetupConnectionInfo");

    HRESULT hr = S_OK;
    DWORD result;
    DWORD protocolType;
    IMsTscNonScriptable* ptsns = NULL;
    IMsRdpClientAdvancedSettings* ptsAdvSettings = NULL;
    IMsRdpClientSecuredSettings* ptsSecuredSettings = NULL;
    CComBSTR bstrAssistantAccount;
    CComBSTR bstrAccountDomainName;
    CComBSTR machineAddressList;
    VARIANT_BOOL bNotifyTSPublicKey;
    
    //
    //  Parse the connection parameters.
    //
    result = ParseConnectParmsString(
                            m_ConnectParms,
                            &m_ConnectParmVersion,
                            &protocolType,
                            machineAddressList,
                            bstrAssistantAccount, 
                            m_AssistantAccountPwd,
                            m_HelpSessionID,
                            m_HelpSessionName,
                            m_HelpSessionPwd,
                            m_TSSecurityBlob
                            );
    if (result != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(result);
        goto CLEANUPANDEXIT;
    }

    //
    //  If the protocol type doesn't match, then fail.
    //
    if (protocolType != REMOTEDESKTOP_TSRDP_PROTOCOL) {
        TRC_ERR((TB, L"Invalid connection protocol %ld", protocolType));
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_USER_BUFFER);
        goto CLEANUPANDEXIT;
    }

    if (bListenConnectInfo) {
        m_ServerAddressList.clear();
    }
    else {
        // 
        // Parse address list in connect parm.
        //
        result = ParseAddressList( machineAddressList, m_ServerAddressList );
        if( ERROR_SUCCESS != result ) {
            TRC_ERR((TB, L"Invalid address list 0x%08x", result));
            hr = HRESULT_FROM_WIN32(result);
            goto CLEANUPANDEXIT;
        }
    
        if( 0 == m_ServerAddressList.size() ) {
            TRC_ERR((TB, L"Invalid connection address list"));
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_USER_BUFFER);
            goto CLEANUPANDEXIT;
        }
    }

    hr = m_TSClient->put_UserName(SALEMHELPASSISTANTACCOUNT_NAME);
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"put_UserName:  %ld", hr));
        goto CLEANUPANDEXIT;
    }

    hr = m_TSClient->get_AdvancedSettings2( &ptsAdvSettings );
    if( SUCCEEDED(hr) && ptsAdvSettings ) {
        hr = ptsAdvSettings->put_DisableRdpdr( TRUE );

        if (FAILED(hr) ) {
            TRC_ERR((TB, L"put_DisableRdpdr failed: 0x%08x", hr));
        }

        // older version does not have security blob so don't notify us about
        // TS public key.
        bNotifyTSPublicKey = (VARIANT_BOOL)(m_ConnectParmVersion >= SALEM_CONNECTPARM_SECURITYBLOB_VERSION);

        // tell activeX control to notify us TS public key
        hr = ptsAdvSettings->put_NotifyTSPublicKey(bNotifyTSPublicKey);
        if (FAILED(hr) ) {
            TRC_ERR((TB, L"put_NotifyTSPublicKey failed: 0x%08x", hr));
            goto CLEANUPANDEXIT;
        }

        ptsAdvSettings->Release();
    }
    else {
        TRC_ERR((TB, L"QueryInterface IID_IMsRdpClientAdvancedSettings: %ld", hr));
    }

    //
    // Setting connection timeout, ICS might take sometime to routine 
    // opened port to actual TS server, neither is critical error.
    //
    hr = ptsAdvSettings->put_singleConnectionTimeout( 60 * 2 ); // try two mins timeout
    if( FAILED(hr) ) {
        TRC_ERR((TB, L"put_singleConnectionTimeout : 0x%x", hr));
    }

    hr = ptsAdvSettings->put_overallConnectionTimeout( 60 * 2 );
    if( FAILED(hr) ) {
        TRC_ERR((TB, L"put_overallConnectionTimeout : 0x%x", hr));
    }


    // Password encryption is based on encyption cycle key + help session ID
    hr = m_TSClient->get_SecuredSettings2( &ptsSecuredSettings );

    if( FAILED(hr) || !ptsSecuredSettings ) {
        TRC_ERR((TB, L"get_IMsTscSecuredSettings :  0x%08x", hr));
        goto CLEANUPANDEXIT;
    }

    //
    // TermSrv invoke sessmgr to check if help session is valid
    // before kicking off rdsaddin.exe, we need to send over
    // help session ID and password, only place available and big
    // enough is on WorkDir and StartProgram property, TermSrv will 
    // ignore these and fill appropriate value for it
    //
    hr = ptsSecuredSettings->put_WorkDir( m_HelpSessionID );
    if( FAILED(hr) ) {
        TRC_ERR((TB, L"put_WorkDir:  0x%08x", hr));
        goto CLEANUPANDEXIT;
    }

    hr = ptsSecuredSettings->put_StartProgram( m_HelpSessionPwd );
    if( FAILED(hr) ) {
        TRC_ERR((TB, L"put_StartProgram:  0x%08x", hr));
        goto CLEANUPANDEXIT;
    }

    ptsSecuredSettings->Release();
    

    // we only use this to disable redirection, not a critical 
    // error, just ugly

    hr = m_TSClient->QueryInterface(IID_IMsTscNonScriptable,
                                    (void**)&ptsns);
    if(!SUCCEEDED(hr) || !ptsns){
        TRC_ERR((TB, L"QueryInterface IID_IMsTscNonScriptable:  %ld", hr));
        goto CLEANUPANDEXIT;
    }

    // password in workdir, stuff something into password field
    hr = ptsns->put_ClearTextPassword( m_AssistantAccountPwd );
    if (!SUCCEEDED(hr)) {
        TRC_ERR((TB, L"put_ClearTextPassword:  0x%08x", hr));
        goto CLEANUPANDEXIT;
    }

    m_ExpertBlob = bstrExpertBlob;

    //
    // Instruct mstscax to connect with certain screen resolution,
    // mstscax will default to 200x20 (???), min. is VGA size.
    //
    {
        RECT rect;
        LONG cx;
        LONG cy;

        GetClientRect(&rect);
        cx = rect.right - rect.left;
        cy = rect.bottom - rect.top;
    
        if( cx < 640 || cy < 480 )
        {
            cx = 640;
            cy = 480;
        }

        m_TSClient->put_DesktopWidth(cx);
        m_TSClient->put_DesktopHeight(cy);
    }

CLEANUPANDEXIT:

    if(ptsns)
    {
        ptsns->Release();
        ptsns = NULL;
    }

    DC_END_FN();
    return hr;
}


STDMETHODIMP
CTSRDPRemoteDesktopClient::AcceptListenConnection(
    BSTR bstrExpertBlob
    )
/*++

Routine Description:

    Establish reverse connection with TS server, TS server must be connected 
    wia reverse connection.

Parameters:

    bstrExpertBlob : Same as ConnectToServer().

Returns:

    S_OK or error code.

--*/
{
    HRESULT hr = S_OK;


    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::AcceptListenConnection");

    //
    //  If we are already connected or not valid, then just 
    //  return.
    //
    if (!IsValid()) {
        ASSERT(FALSE);
        hr = E_FAIL;
        goto CLEANUPANDEXIT;
    }

    if (m_ConnectedToServer || m_ConnectionInProgress) {
        TRC_ERR((TB, L"Connection active"));
        hr = HRESULT_FROM_WIN32(ERROR_CONNECTION_ACTIVE);
        goto CLEANUPANDEXIT;
    }

    if( !ListenConnectInProgress() ) {
        TRC_ERR((TB, L"Connection in-active"));
        hr = HRESULT_FROM_WIN32(ERROR_CONNECTION_INVALID);
        goto CLEANUPANDEXIT;
    }

    if( INVALID_SOCKET == m_TSConnectSocket ) {
        TRC_ERR((TB, L"Socket is not connected"));
        hr = HRESULT_FROM_WIN32(ERROR_CONNECTION_INVALID);
        goto CLEANUPANDEXIT;
    }

    hr = SetupConnectionInfo(TRUE, bstrExpertBlob);

    if( FAILED(hr) ) {
        TRC_ERR((TB, L"SetupConnectionInfo() failed with 0x%08x", hr));
        goto CLEANUPANDEXIT;
    }

    hr = ConnectServerWithOpenedSocket();

CLEANUPANDEXIT:

    m_ConnectionInProgress = SUCCEEDED(hr);

    DC_END_FN();
    return hr;
}


STDMETHODIMP 
CTSRDPRemoteDesktopClient::ConnectToServer(BSTR bstrExpertBlob)
/*++

Routine Description:

    Connects the client component to the server-side Remote Desktop Host COM 
    Object.  

Arguments:

	bstrExpertBlob : Optional parameter to be transmitted to SAF resolver.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 Params--*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::ConnectToServer");

    HRESULT hr = S_OK;
    ServerAddress address;
    
    //
    //  If we are already connected or not valid, then just 
    //  return.
    //
    if (!IsValid()) {
        ASSERT(FALSE);
        hr = E_FAIL;
        goto CLEANUPANDEXIT;
    }

    if (m_ConnectedToServer || m_ConnectionInProgress) {
        TRC_ERR((TB, L"Connection active"));
        hr = HRESULT_FROM_WIN32(ERROR_CONNECTION_ACTIVE);
        goto CLEANUPANDEXIT;
    }

    hr = SetupConnectionInfo(FALSE, bstrExpertBlob);

    address = m_ServerAddressList.front();
    m_ServerAddressList.pop_front();

    hr = ConnectServerPort(address.ServerName, address.portNumber);
    if (FAILED(hr)) {
        TRC_ERR((TB, L"ConnectServerPort:  %08X", hr));
    }

CLEANUPANDEXIT:

    //
    //  If we succeeded, remember that we are in a state of connecting.
    //
    m_ConnectionInProgress = SUCCEEDED(hr);

    DC_END_FN();
    return hr;
}

STDMETHODIMP 
CTSRDPRemoteDesktopClient::DisconnectFromServer()
/*++

Routine Description:

    Disconnects the client from the server to which we are currently
    connected.

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    return DisconnectFromServerInternal(
                    SAFERROR_LOCALNOTERROR
                    );
}

STDMETHODIMP 
CTSRDPRemoteDesktopClient::DisconnectFromServerInternal(
    LONG errorCode
    )
/*++

Routine Description:

    Disconnects the client from the server to which we are currently
    connected.

Arguments:

    reason  -   Reason for disconnect.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::DisconnectFromServerInternal");

    HRESULT hr;

    //
    //  Make sure our window is hidden.
    //
    //ShowWindow(SW_HIDE);

    ListenConnectCleanup();

    if (m_ConnectedToServer || m_ConnectionInProgress) {
        hr = m_TSClient->Disconnect();
        if (SUCCEEDED(hr)) {

            m_ConnectionInProgress = FALSE;
            m_ConnectedToServer = FALSE;

            if (m_RemoteControlRequestInProgress) {
                m_RemoteControlRequestInProgress = FALSE;
                Fire_RemoteControlRequestComplete(SAFERROR_SHADOWEND_UNKNOWN);
            }

            //
            //  Fire the server disconnect event.
            //
            Fire_Disconnected(errorCode);
        }
    }
    else {
        TRC_NRM((TB, L"Not connected."));
        hr = S_OK;
    }

    DC_END_FN();
    return hr;
}

STDMETHODIMP 
CTSRDPRemoteDesktopClient::ConnectRemoteDesktop()
/*++

Routine Description:

    Once "remote desktop mode" has been enabled for the server-side Remote 
    Desktop Host COM Object and we are connected to the server, the 
    ConnectRemoteDesktop method can be invoked to take control of the remote 
    user's desktop.  

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::ConnectRemoteDesktop");

    HRESULT hr = S_OK;
    DWORD result;
    BSTR rcRequest = NULL;

    //
    //  Fail if we are not valid or not connected to the server.
    //
    if (!IsValid()) {
        ASSERT(FALSE);
        hr = E_FAIL;
        goto CLEANUPANDEXIT;
    }
    if (!m_ConnectedToServer) {
        hr = HRESULT_FROM_WIN32(ERROR_DEVICE_NOT_CONNECTED);
        goto CLEANUPANDEXIT;
    }

    //
    //  Succeed if a remote control request is already in progress.
    //
    if (m_RemoteControlRequestInProgress) {
        hr = S_OK;
        goto CLEANUPANDEXIT;
    }

    //
    //  Generate the remote control connect request message.
    //
    hr = GenerateRCRequest(&rcRequest);
    if (!SUCCEEDED(hr)) {
        goto CLEANUPANDEXIT;
    }

    //
    //  Send it.
    //
    hr = m_CtlChannel->SendChannelData(rcRequest);
    if (!SUCCEEDED(hr)) {
        goto CLEANUPANDEXIT;
    }

    //
    //  A request is in progress, if we successfully sent the request.
    //
    m_RemoteControlRequestInProgress = TRUE;

CLEANUPANDEXIT:

    if (rcRequest != NULL) {
        SysFreeString(rcRequest);
    }

    DC_END_FN();
    return hr;
}

STDMETHODIMP 
CTSRDPRemoteDesktopClient::DisconnectRemoteDesktop()
/*++

Routine Description:

    Once "remote desktop mode" has been enabled for the server-side Remote 
    Desktop Host COM Object and we are connected to the server, the 
    ConnectRemoteDesktop method can be invoked to take control of the remote 
    user's desktop.  

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::DisconnectRemoteDesktop");

    HRESULT hr = S_OK;
    CComBSTR rcRequest;

    //
    //  Fail if we are not valid or not connected.
    //
    if (!IsValid()) {
        ASSERT(FALSE);
        hr = E_FAIL;
        goto CLEANUPANDEXIT;
    }
    if (!m_ConnectedToServer) {
        hr = HRESULT_FROM_WIN32(ERROR_DEVICE_NOT_CONNECTED);
        goto CLEANUPANDEXIT;
    }

    //
    //  Generate the terminate remote control key sequence and sent it to the 
    //  server.  
    //
    if (m_RemoteControlRequestInProgress) {
        hr = SendTerminateRCKeysToServer();
    }

CLEANUPANDEXIT:

    DC_END_FN();
    return hr;
}

//
//  ISAFRemoteDesktopTestExtension
//
STDMETHODIMP
CTSRDPRemoteDesktopClient::put_TestExtDllName(/*[in]*/ BSTR newVal)
{
    HRESULT hr = E_NOTIMPL;
    IMsTscAdvancedSettings *pMstscAdvSettings = NULL;
    IMsTscDebug            *pMstscDebug = NULL;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::put_TestExtDllName" );    

    if ( NULL == m_TSClient )
    {
        TRC_ERR((TB, L"m_TSClient is NULL" ));
        hr = E_NOINTERFACE;
        goto CLEANUPANDEXIT;
    }

    hr = m_TSClient->get_AdvancedSettings( &pMstscAdvSettings );
    if (FAILED( hr ))
    {
        TRC_ERR((TB, L"m_TSClient->get_AdvancedSettings failed %08X", hr ));
        goto CLEANUPANDEXIT;
    }

    hr = m_TSClient->get_Debugger( &pMstscDebug );
    if ( FAILED( hr ))
    {
        TRC_ERR((TB, L"m_TSClient->get_Debugger failed %08X", hr ));
        goto CLEANUPANDEXIT;
    }

    hr = pMstscAdvSettings->put_allowBackgroundInput( 1 );
    if (FAILED( hr ))
    {
        TRC_ERR((TB, L"put_allowBackgroundInput failed %08X", hr ));
    }
    pMstscDebug->put_CLXDll( newVal );

CLEANUPANDEXIT:
    if ( NULL != pMstscAdvSettings )
        pMstscAdvSettings->Release();

    if ( NULL != pMstscDebug )
        pMstscDebug->Release();

    DC_END_FN();
    return hr;
}

STDMETHODIMP
CTSRDPRemoteDesktopClient::put_TestExtParams(/*[in]*/ BSTR newVal)
{
    HRESULT hr = E_NOTIMPL;
    IMsTscDebug *pMstscDebug = NULL;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::put_TestExtParams" );

    if ( NULL == m_TSClient )
    {
        TRC_ERR((TB, L"m_TSClient is NULL" ));
        hr = E_NOINTERFACE;
        goto CLEANUPANDEXIT;
    }

    hr = m_TSClient->get_Debugger( &pMstscDebug );
    if (FAILED( hr ))
    {
        TRC_ERR((TB, L"m_TSClient->get_Debugger failed %08X", hr ));
        goto CLEANUPANDEXIT;
    }

    hr = pMstscDebug->put_CLXCmdLine( newVal );

CLEANUPANDEXIT:
    if ( NULL != pMstscDebug )
        pMstscDebug->Release();

    DC_END_FN();
    return hr;
}
VOID 
CTSRDPRemoteDesktopClient::OnMSTSCReceiveData(
    BSTR data
    )
/*++

Routine Description:

    Handle Remote Control Control Channel messages.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::OnMSTSCReceiveData");

    //
    //we got some data, so we must be connected, update timer
    //
     m_PrevTimer = GetTickCount();

    //
    //  Fire the data ready event.
    //
    Fire_DataReady(data);

    DC_END_FN();
}

VOID 
CTSRDPRemoteDesktopClient::HandleControlChannelMsg()
/*++

Routine Description:

    Handle Remote Control Control Channel messages.

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::HandleControlChannelMsg");

    PREMOTEDESKTOP_CTL_BUFHEADER msgHeader;
    BSTR msg = NULL;
    LONG *pResult;
    BSTR authenticateReq = NULL;
    BSTR versionInfoPacket = NULL;
    HRESULT hr;

    DWORD result;

    ASSERT(IsValid());

    //
    //  Read the next message.
    //
    result = m_CtlChannel->ReceiveChannelData(&msg);
    if (result != ERROR_SUCCESS) {
        goto CLEANUPANDEXIT;
    }

    //
    //  Dispatch, based on the message type.
    //
    msgHeader = (PREMOTEDESKTOP_CTL_BUFHEADER)msg;

    //
    //  If the server-side of the VC link is alive.
    //
    //
    if ((msgHeader->msgType == REMOTEDESKTOP_CTL_SERVER_ANNOUNCE) &&
         m_ConnectionInProgress) {

        //
        //  Send version information to the server.
        //
        hr = GenerateVersionInfoPacket(
                                &versionInfoPacket
                                );
        if (!SUCCEEDED(hr)) {
            goto CLEANUPANDEXIT;
        }
        hr = m_CtlChannel->SendChannelData(versionInfoPacket);
        if (!SUCCEEDED(hr)) {
            goto CLEANUPANDEXIT;
        }

        //
        //  Request client authentication.
        //
        hr = GenerateClientAuthenticateRequest(
                                &authenticateReq
                                );
        if (!SUCCEEDED(hr)) {
            goto CLEANUPANDEXIT;
        }
        hr = m_CtlChannel->SendChannelData(authenticateReq);
    }
    //
    //  If the message is from the server, indicating that it is 
    //  disconnecting.  This can happen if the RDSRemoteDesktopServer
    //  is directed to exit listening mode.
    //
    else if (msgHeader->msgType == REMOTEDESKTOP_CTL_DISCONNECT) {
        TRC_NRM((TB, L"Server indicated a disconnect."));
        DisconnectFromServerInternal(SAFERROR_BYSERVER);
    }
    //
    //  If the message is a message result.
    //
    else if (msgHeader->msgType == REMOTEDESKTOP_CTL_RESULT) {

        pResult = (LONG *)(msgHeader+1);

        //
        //  If a remote control request is in progress, then we should check
        //  for a remote control complete status.
        //
        if (m_RemoteControlRequestInProgress && ISRCSTATUSCODE(*pResult)) {

            TRC_ERR((TB, L"Received RC terminate status code."));

            m_RemoteControlRequestInProgress = FALSE;
            Fire_RemoteControlRequestComplete(*pResult);
        }
        //
        //  Otherwise, if a connection is in progress, then the client 
        //  authentication request must have succeeded.
        //
        else if (m_ConnectionInProgress) {

            //
            //  Should not be getting a remote control status here.
            //
            ASSERT(!ISRCSTATUSCODE(*pResult));

            //
            //  Fire connect request succeeded message.
            //
            if (*pResult == SAFERROR_NOERROR ) {
                m_ConnectedToServer = TRUE;
                m_ConnectionInProgress = FALSE;
                   
                //
                //set the timer to check if the user is still connected
                //ignore errors, worst case - the ui is up even after the user disconnects
                //
                if( m_RdcConnCheckTimeInterval )
	                m_TimerId = SetTimer(WM_CONNECTCHECK_TIMER, m_RdcConnCheckTimeInterval);

                //
                // Not in progress once connected
                //
                m_ListenConnectInProgress = FALSE;
                m_TSConnectSocket = INVALID_SOCKET;

                Fire_Connected();
            }
            //
            //  Otherwise, fire a disconnected event.
            //
            else {
                DisconnectFromServerInternal(*pResult);
                m_ConnectionInProgress = FALSE;
            }

        }
    }


    //
    //  We will ignore other packets to support forward compatibility.
    //

CLEANUPANDEXIT:

    //
    //  Release the message.
    //
    if (msg != NULL) {
        SysFreeString(msg);
    }

    if (versionInfoPacket != NULL) {
        SysFreeString(versionInfoPacket);
    }

    if (authenticateReq != NULL) {
        SysFreeString(authenticateReq);
    }

    DC_END_FN();
}

HRESULT
CTSRDPRemoteDesktopClient::GenerateRCRequest(
    BSTR *rcRequest
    )
/*++

Routine Description:

    Generate a remote control request message for the 
    server.

    TODO:   We might need to be able to push this up
            to the parent class, if it makes sense for
            NetMeeting.

Arguments:

    rcRequest   -   Returned request message.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::GenerateRCRequest");

    PREMOTEDESKTOP_CTL_BUFHEADER msgHeader;
    PBYTE ptr;
    HRESULT hr;
    DWORD len;

    len = sizeof(REMOTEDESKTOP_CTL_BUFHEADER) + ((m_ConnectParms.Length()+1) * sizeof(WCHAR));

    msgHeader = (PREMOTEDESKTOP_CTL_BUFHEADER)SysAllocStringByteLen(NULL, len);
    if (msgHeader != NULL) {
        msgHeader->msgType = REMOTEDESKTOP_CTL_REMOTE_CONTROL_DESKTOP;
        ptr = (PBYTE)(msgHeader + 1);
        memcpy(ptr, (BSTR)m_ConnectParms, 
               ((m_ConnectParms.Length()+1) * sizeof(WCHAR)));
        *rcRequest = (BSTR)msgHeader;

        hr = S_OK;
    }
    else {
        TRC_ERR((TB, L"SysAllocStringByteLen failed for %ld bytes", len));
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);        
    }

    DC_END_FN();

    return hr;
}

HRESULT
CTSRDPRemoteDesktopClient::GenerateClientAuthenticateRequest(
    BSTR *authenticateReq
    )
/*++

Routine Description:

    Generate a 'client authenticate' request.

    TODO:   We might need to be able to push this up
            to the parent class, if it makes sense for
            NetMeeting.

Arguments:

    rcRequest   -   Returned request message.

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::GenerateClientAuthenticateRequest");

    PREMOTEDESKTOP_CTL_BUFHEADER msgHeader;
    PBYTE ptr;
    HRESULT hr;
    DWORD len;

    len = sizeof(REMOTEDESKTOP_CTL_BUFHEADER) + ((m_ConnectParms.Length()+1) * sizeof(WCHAR));

    #if FEATURE_USERBLOBS

    if( m_ExpertBlob.Length() > 0 ) {
        len += ((m_ExpertBlob.Length() + 1) * sizeof(WCHAR));
    }

    #endif

    msgHeader = (PREMOTEDESKTOP_CTL_BUFHEADER)SysAllocStringByteLen(NULL, len);
    if (msgHeader != NULL) {
        msgHeader->msgType = REMOTEDESKTOP_CTL_AUTHENTICATE;
        ptr = (PBYTE)(msgHeader + 1);
        memcpy(ptr, (BSTR)m_ConnectParms, 
               ((m_ConnectParms.Length()+1) * sizeof(WCHAR)));

        #if FEATURE_USERBLOBS

        if( m_ExpertBlob.Length() > 0 ) {
            ptr += ((m_ConnectParms.Length()+1) * sizeof(WCHAR));
            memcpy(ptr, (BSTR)m_ExpertBlob, 
                ((m_ExpertBlob.Length()+1) * sizeof(WCHAR)));
        }

        #endif

        *authenticateReq = (BSTR)msgHeader;

        hr = S_OK;
    }
    else {
        TRC_ERR((TB, L"SysAllocStringByteLen failed for %ld bytes", len));
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);        
    }

    DC_END_FN();

    return hr;
}

HRESULT
CTSRDPRemoteDesktopClient::GenerateVersionInfoPacket(
    BSTR *versionInfoPacket
    )
/*++

Routine Description:

    Generate a version information packet.

Arguments:

    versionInfoPacket   -   Version Information Returned Packet

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::GenerateVersionInfoPacket");

    PREMOTEDESKTOP_CTL_BUFHEADER msgHeader;
    PDWORD ptr;
    HRESULT hr;
    DWORD len;

    len = sizeof(REMOTEDESKTOP_CTL_BUFHEADER) + (sizeof(DWORD) * 2);

    msgHeader = (PREMOTEDESKTOP_CTL_BUFHEADER)SysAllocStringByteLen(NULL, len);
    if (msgHeader != NULL) {
        msgHeader->msgType = REMOTEDESKTOP_CTL_VERSIONINFO;
        ptr = (PDWORD)(msgHeader + 1);
        *ptr = REMOTEDESKTOP_VERSION_MAJOR; ptr++;
        *ptr = REMOTEDESKTOP_VERSION_MINOR;
        *versionInfoPacket = (BSTR)msgHeader;
        hr = S_OK;
    }
    else {
        TRC_ERR((TB, L"SysAllocStringByteLen failed for %ld bytes", len));
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);        
    }

    DC_END_FN();

    return hr;
}

VOID
CTSRDPRemoteDesktopClient::OnReceivedTSPublicKey(BSTR bstrPublicKey, VARIANT_BOOL* pfContinue)
{
    DWORD dwStatus;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::OnReceivedPublicKey");
    CComBSTR bstrTSPublicKey;

    if( m_ConnectParmVersion >= SALEM_CONNECTPARM_SECURITYBLOB_VERSION ) {

        //
        // hash TS public key send from client activeX control, reverse
        // hashing from what we got in connect parm might not give us
        // back the original value.
        //
        dwStatus = HashSecurityData( 
                                (PBYTE) bstrPublicKey, 
                                ::SysStringByteLen(bstrPublicKey),
                                bstrTSPublicKey
                            );

        if( ERROR_SUCCESS != dwStatus )
        {
            TRC_ERR((TB, L"Hashed Public Key Send from TS %s", bstrPublicKey));
            TRC_ERR((TB, L"Hashed public Key in parm %s", m_TSSecurityBlob));
            TRC_ERR((TB, L"HashSecurityData() failed with %d", dwStatus));       
            *pfContinue = FALSE;
        }
        else if( !(bstrTSPublicKey == m_TSSecurityBlob) )
        {
            TRC_ERR((TB, L"Hashed Public Key Send from TS %s", bstrPublicKey));
            TRC_ERR((TB, L"Hashed public Key in parm %s", m_TSSecurityBlob));

            *pfContinue = FALSE;
        }
        else
        {
            *pfContinue = TRUE;
        }
    } 
    else {
        *pfContinue = TRUE;
    }

    DC_END_FN();
}

VOID
CTSRDPRemoteDesktopClient::OnRDPConnected()
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::OnRDPConnected");

    Fire_BeginConnect();
    DC_END_FN();
}

VOID 
CTSRDPRemoteDesktopClient::OnLoginComplete()
/*++

Routine Description:

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::OnLoginComplete");

    //
    // Clear server address list
    //
    m_ServerAddressList.clear();

    //
    //  We got some event from the mstsc, so we must be connected, update timer
    //
    m_PrevTimer = GetTickCount();


CLEANUPANDEXIT:

    DC_END_FN();
}

LONG
CTSRDPRemoteDesktopClient::TranslateMSTSCDisconnectCode(
    DisconnectReasonCode disconReason,
    ExtendedDisconnectReasonCode extendedReasonCode
    )
/*++

Routine Description:

    Translate an MSTSC disconnect code into a Salem disconnect
    code.

Arguments:

    disconReason        -   Disconnect Reason
    extendedReasonCode  -   MSTSCAX Extended Reason Code
   
Return Value:

    Salem disconnect code.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::TranslateMSTSCDisconnectCode");

    LONG ret;
    BOOL handled;

    //
    //  First check the extended error information.  
    //  TODO:   Need to keep track of additional values added by NadimA
    //          and company, here, before we ship.
    //
    if (extendedReasonCode != exDiscReasonNoInfo) {
        //
        //  Record the extended error code, if given.  Note that this may be
        //  overridden below if we have better information.
        //
        m_LastExtendedErrorInfo = extendedReasonCode;

        //
        //  Check for a protocol error.
        //
        if ((extendedReasonCode >= exDiscReasonProtocolRangeStart) &&
            (extendedReasonCode <= exDiscReasonProtocolRangeEnd)) {
            ret = SAFERROR_RCPROTOCOLERROR;
            goto CLEANUPANDEXIT;
        }
    }
    
    //
    //  If the extended error information didn't help us.
    //
    switch(disconReason) 
    {
    case disconnectReasonNoInfo                     : ret = SAFERROR_NOINFO;
                                                      break;                      

    case 0xb08: // UI_ERR_NORMAL_DISCONNECT not defined in mstsax.idl
    case disconnectReasonLocalNotError              : ret = SAFERROR_LOCALNOTERROR;              
                                                      break;        

    case disconnectReasonRemoteByUser               : ret = SAFERROR_REMOTEBYUSER;               
                                                      break;                  

    case disconnectReasonByServer                   : ret = SAFERROR_BYSERVER;                   
                                                      break;                  

    case disconnectReasonDNSLookupFailed2            : m_LastExtendedErrorInfo = disconReason;   
    case disconnectReasonDNSLookupFailed             : ret = SAFERROR_DNSLOOKUPFAILED;            
                                                      break;     

    case disconnectReasonOutOfMemory3               : 
    case disconnectReasonOutOfMemory2               : m_LastExtendedErrorInfo = disconReason;
    case disconnectReasonOutOfMemory                : ret = SAFERROR_OUTOFMEMORY;                
                                                      break;                    

    case disconnectReasonConnectionTimedOut         : ret = SAFERROR_CONNECTIONTIMEDOUT;         
                                                      break;          

    case disconnectReasonSocketConnectFailed        : 
    case 0x904                                      : ret = SAFERROR_SOCKETCONNECTFAILED;   // NadimA is adding to 
                                                                                            // MSTSCAX IDL.  This is a
                                                                                            // NL_ERR_TDFDCLOSE error.
                                                      break;             

    case disconnectReasonHostNotFound               : ret = SAFERROR_HOSTNOTFOUND;               
                                                      break;             

    case disconnectReasonWinsockSendFailed          : ret = SAFERROR_WINSOCKSENDFAILED;          
                                                      break;         

    case disconnectReasonInvalidIP                  : m_LastExtendedErrorInfo = disconReason;                                  
    case disconnectReasonInvalidIPAddr              : ret = SAFERROR_INVALIDIPADDR;              
                                                      break;             

    case disconnectReasonSocketRecvFailed           : ret = SAFERROR_SOCKETRECVFAILED;           
                                                      break;           

    case disconnectReasonInvalidEncryption          : ret = SAFERROR_INVALIDENCRYPTION;          
                                                      break;               

    case disconnectReasonGetHostByNameFailed        : ret = SAFERROR_GETHOSTBYNAMEFAILED;        
                                                      break;                 

    case disconnectReasonLicensingFailed            : m_LastExtendedErrorInfo = disconReason;
    case disconnectReasonLicensingTimeout           : ret = SAFERROR_LICENSINGFAILED;            
                                                      break;          

    case disconnectReasonDecryptionError            : ret = SAFERROR_DECRYPTIONERROR;            
                                                      break;       

    case disconnectReasonServerCertificateUnpackErr : ret = SAFERROR_MISMATCHPARMS;
                                                      break;

    default:                                          ret = SAFERROR_RCUNKNOWNERROR;        
                                                      m_LastExtendedErrorInfo = disconReason;
                                                      ASSERT(FALSE);
    }

CLEANUPANDEXIT:
    DC_END_FN();
    return ret;
}

VOID 
CTSRDPRemoteDesktopClient::OnDisconnected(
    long disconReason
    )
/*++

Routine Description:

Arguments:

Return Value:

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::OnDisconnected");
    HRESULT hr = E_HANDLE;      // initialize an error code.

    long clientReturnCode;
    ExtendedDisconnectReasonCode extendedClientCode;

    TRC_ERR((TB, L"Disconnected because %ld", disconReason));

    m_TSClient->get_ExtendedDisconnectReason(&extendedClientCode);
    clientReturnCode = TranslateMSTSCDisconnectCode(
                                            (DisconnectReasonCode)disconReason, 
                                            extendedClientCode
                                            );

    // Go thru all remaining server:port, mstscax might return some
    // error code that we don't understand.
    if( m_ServerAddressList.size() > 0 ) {

        ServerAddress address;

        address = m_ServerAddressList.front();
        m_ServerAddressList.pop_front();

        hr = ConnectServerPort( address.ServerName, address.portNumber );
        if (FAILED(hr)) {
            TRC_ERR((TB, L"ConnectServerPort:  %08X", hr));
        }
    }

    //
    // Return the error code from connecting to 'last' server to client
    //
    if( FAILED(hr) ) {
    
        m_ServerAddressList.clear();

        //
        //  Fire the server disconnect event, if we are really connected or
        //  we have a connection in progress.
        //
        if (m_ConnectedToServer || m_ConnectionInProgress) {
            Fire_Disconnected(clientReturnCode);
        }

        m_ConnectedToServer = FALSE;
        m_ConnectionInProgress = FALSE;

        ListenConnectCleanup();

        //
        //  Fire the remote control request failure event, if appropriate.
        //
        if (m_RemoteControlRequestInProgress) {
            ASSERT(clientReturnCode != SAFERROR_NOERROR);
            Fire_RemoteControlRequestComplete(SAFERROR_SHADOWEND_UNKNOWN);
            m_RemoteControlRequestInProgress = FALSE;
        }
    }

    DC_END_FN();
}

HRESULT
CTSRDPRemoteDesktopClient::SendTerminateRCKeysToServer()
/*++

Routine Description:

    Send the terminate shadowing key sequence to the server.

Arguments:

Return Value:

    S_OK on success.  Otherwise, an error status is returned.

 --*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::SendTerminateRCKeysToServer");

    HRESULT hr = S_OK;
    IMsRdpClientNonScriptable* pTscNonScript = NULL;

    VARIANT_BOOL keyUp[]    = { 
        VARIANT_FALSE, VARIANT_FALSE, VARIANT_TRUE, VARIANT_TRUE
        };
    LONG keyData[]  = { 
        MapVirtualKey(VK_CONTROL, 0),   // these are SCANCODES.
        MapVirtualKey(VK_MULTIPLY, 0), 
        MapVirtualKey(VK_MULTIPLY, 0),
        MapVirtualKey(VK_CONTROL, 0),
        };

    //
    //  Send the terminate keys to the server.
    //
    hr = m_TSClient->QueryInterface(
                            IID_IMsRdpClientNonScriptable,
                            (void**)&pTscNonScript
                            );
    if (hr != S_OK) {
        TRC_ERR((TB, L"QI:  %08X", hr));
        goto CLEANUPANDEXIT;
    }
    pTscNonScript->NotifyRedirectDeviceChange(0, 0);
    pTscNonScript->SendKeys(4, keyUp, keyData);
    if (hr != S_OK) {
        TRC_ERR((TB, L"SendKeys, QI:  %08X", hr));
    }

    pTscNonScript->Release();

CLEANUPANDEXIT:

    DC_END_FN();

    return hr;
}

HWND CTSRDPRemoteDesktopClient::SearchForWindow(
    HWND hwndParent, 
    LPTSTR srchCaption, 
    LPTSTR srchClass
    )
/*++

Routine Description:

    Search for a child window of the specified parent window.

Arguments:

    srchCaption -   Window caption for which to search.  NULL is
                    considered a wildcard.
    srchClass   -   Window class for which to search.  NULL is
                    considred a wildcard.

Return Value:

    S_OK on success.  Otherwise, an error status is returned.

 --*/
{
    WINSEARCH srch;

    srch.foundWindow = NULL;   
    srch.srchCaption = srchCaption;
    srch.srchClass   = srchClass;

    BOOL result = EnumChildWindows(
                            hwndParent,
                            (WNDENUMPROC)_WindowSrchProc,  
                            (LPARAM)&srch
                            );

    return srch.foundWindow;
}
BOOL CALLBACK 
CTSRDPRemoteDesktopClient::_WindowSrchProc(HWND hwnd, PWINSEARCH srch)
{
    TCHAR classname[128];
    TCHAR caption[128];

    if (srch->srchClass && !GetClassName(hwnd, classname, sizeof(classname) / sizeof(TCHAR)))
    {
        return TRUE;
    }
    if (srch->srchCaption && !::GetWindowText(hwnd, caption, sizeof(caption)/sizeof(TCHAR)))
    {
        return TRUE;
    }

    if ((!srch->srchClass || !_tcscmp(classname, srch->srchClass)
        &&
        (!srch->srchCaption || !_tcscmp(caption, srch->srchCaption)))
        )
    {
        srch->foundWindow = hwnd;
        return FALSE;
    }    

    return TRUE;
}

HRESULT
CTSRDPRemoteDesktopClient::GenerateNullData( BSTR* pbstrData )
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::GenerateNullData");
    HRESULT hr;
    DWORD len;

    PREMOTEDESKTOP_CTL_BUFHEADER msgHeader = NULL;
    len = sizeof( REMOTEDESKTOP_CTL_BUFHEADER );
    
    msgHeader = (PREMOTEDESKTOP_CTL_BUFHEADER)SysAllocStringByteLen(NULL, len);
    if (msgHeader != NULL) {
        msgHeader->msgType = REMOTEDESKTOP_CTL_ISCONNECTED;
        //nothing else other than the message
        *pbstrData = (BSTR)msgHeader;
        hr = S_OK;
    }
    else {
        TRC_ERR((TB, L"SysAllocStringByteLen failed for %ld bytes", len));
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);        
    }


    DC_END_FN();
    return hr;
}


LRESULT CTSRDPRemoteDesktopClient::OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::OnCheckConnectTimer");
    BSTR bstrMsg = NULL;

    if( WM_LISTENTIMEOUT_TIMER == wParam ) {

        bHandled = TRUE;
        if( TRUE == ListenConnectInProgress() ) {
            StopListen();
            Fire_ListenConnect( SAFERROR_CONNECTIONTIMEDOUT );
        }
    } 
    else if ( WM_CONNECTCHECK_TIMER == wParam ) {
        DWORD dwCurTimer = GetTickCount();

        bHandled = TRUE;

        if(m_ConnectedToServer) {
            //
            //see if the timer wrapped around to zero (does so if the system was up 49.7 days or something)
            //if so reset it
            //
            if( dwCurTimer > m_PrevTimer && ( dwCurTimer - m_PrevTimer >= m_RdcConnCheckTimeInterval )) {
                //
                //time to send a null data
                //
                if(SUCCEEDED(GenerateNullData(&bstrMsg))) { 
                    if(!SUCCEEDED(m_CtlChannel->SendChannelData(bstrMsg))) {
                        //
                        //could not send data, assume disconnected
                        //
                        DisconnectFromServer();
                        //
                        //don't need the timer anymore, kill it
                        //
                        KillTimer( m_TimerId );
                        m_TimerId =  0;
                    }
                }
            }
        } //m_ConnectedToServer
    
        //
        //update the timer
        //
        m_PrevTimer = dwCurTimer;
    
        if( NULL != bstrMsg ) {
            SysFreeString(bstrMsg);
        }
    }
    
    DC_END_FN();
    return 0;
}

STDMETHODIMP 
CTSRDPRemoteDesktopClient::CreateListenEndpoint(
    IN LONG port,
    OUT BSTR* pConnectParm
    )
/*++

Description:

    Routine to create a listening socket and return connection parameter to this 'listen' socket.

Parameters:

    port : Port that socket should listen on.
    pConnectParm : Return connection parameter to this listening socket.

returns:

    S_OK or error code.

Notes:

    Function is async, return code, if error, is for listening thread set up, caller is notified of
    successful or error in network connection via ListenConnect event.

--*/
{
    HRESULT hr = S_OK;

    SOCKET hListenSocket = INVALID_SOCKET;
    IMsRdpClientAdvancedSettings* pAdvSettings;
    LONG rdpPort = 0;
    int intRC;
    int lastError;
    SOCKADDR_IN sockAddr;
    int sockAddrSize;
    int optvalue;


    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::CreateListenEndpoint");

    if( NULL == pConnectParm )
    {
        hr = E_POINTER;
        return hr;
    }

    if (!IsValid()) {
        ASSERT(FALSE);
        hr = E_FAIL;
        return hr;
    }

    //
    // Return error if we are in progress of connect or connected.
    //
    if( TRUE == ListenConnectInProgress() ||        // Listen already started.
        TRUE == m_ConnectionInProgress ||           // Connection already in progress
        TRUE == m_ConnectedToServer ) {             // Already connected to server
        hr = HRESULT_FROM_WIN32( ERROR_SHARING_VIOLATION );
        TRC_ERR((TB, L"StartListen() already in listen"));
        goto CLEANUPANDEXIT;
    }

    //
    // Initialize Winsock and ICS library if not yet initialized.
    // InitListeningLibrary() will only add ref. count
    // if library already initialized by other instance.
    //
    if( FALSE == m_InitListeningLibrary ) {

        hr = InitListeningLibrary();
        if( FAILED(hr) ) {
            TRC_ERR((TB, L"InitListeningLibrary() failed :  %08X", hr));
            goto CLEANUPANDEXIT;
        }

        m_InitListeningLibrary = TRUE;
    }

    //
    // mstscax will close the socket once connection is ended.
    //
    m_TSConnectSocket = INVALID_SOCKET;

    //
    // Create a listening socket
    //
    m_ListenSocket = socket(AF_INET, SOCK_STREAM, 0);
    if( INVALID_SOCKET == m_ListenSocket ) {
        intRC = WSAGetLastError();
        TRC_ERR((TB, _T("socket failed %d"), intRC));   
        hr = HRESULT_FROM_WIN32(intRC);
        goto CLEANUPANDEXIT;
    }

    //
    // Disable NAGLE algorithm and enable don't linger option.
    //
    optvalue = 1;
    setsockopt( m_ListenSocket, IPPROTO_TCP, TCP_NODELAY, (char *)&optvalue, sizeof(optvalue) );

    optvalue = 1;
    setsockopt( m_ListenSocket, SOL_SOCKET, SO_DONTLINGER, (char *)&optvalue, sizeof(optvalue) );


    //
    // Request async notifications to send to our window
    //
    intRC = WSAAsyncSelect(
                        m_ListenSocket,
                        m_hWnd,
                        WM_TSCONNECT,
                        FD_ACCEPT
                    );

    if(SOCKET_ERROR == intRC) {
        intRC = WSAGetLastError();
        
        TRC_ERR((TB, _T("WSAAsyncSelect failed %d"), intRC));   
        hr = HRESULT_FROM_WIN32(intRC);
        goto CLEANUPANDEXIT;
    }

    sockAddr.sin_family      = AF_INET;
    sockAddr.sin_port        = htons(port);
    sockAddr.sin_addr.s_addr = htonl(INADDR_ANY);;    

    intRC = bind( m_ListenSocket, (struct sockaddr *) &sockAddr, sizeof(sockAddr) );
    if( SOCKET_ERROR == intRC ) {
        lastError = WSAGetLastError();
        TRC_ERR((TB, _T("bind failed - %d"), lastError));
        hr = HRESULT_FROM_WIN32( lastError );
        goto CLEANUPANDEXIT;
    }

    if( 0 == port ) {
        //
        // Retrieve which port we are listening
        //
        sockAddrSize = sizeof( sockAddr );
        intRC = getsockname( 
                            m_ListenSocket,
                            (struct sockaddr *)&sockAddr,
                            &sockAddrSize 
                        );
        if( SOCKET_ERROR == intRC )
        {
            lastError = WSAGetLastError();
            TRC_ERR((TB, _T("getsockname failed - GLE:%d"),lastError));
            hr = HRESULT_FROM_WIN32( lastError );
            goto CLEANUPANDEXIT;
        }

        m_ConnectedPort = ntohs(sockAddr.sin_port);
    }
    else {
        m_ConnectedPort = port;
    }

    TRC_ERR((TB, _T("Listenin on port %d"),m_ConnectedPort));

    //
    // Tell ICS library to punch a hole thru ICS, no-op 
    // if not ICS configuration.
    //
    m_ICSPort = OpenPort( m_ConnectedPort );

    //
    // Retrieve connection parameters for this client (expert).
    //
    hr = RetrieveUserConnectParm( pConnectParm );
    if( FAILED(hr) ) {
        TRC_ERR((TB, _T("RetrieveUserConnectParm failed - 0x%08x"),hr));
    }
   

CLEANUPANDEXIT:    

    if( FAILED(hr) ) {
        StopListen();
    }

    DC_END_FN();
    return hr;   
}




STDMETHODIMP 
CTSRDPRemoteDesktopClient::StopListen()
/*++

Description:

    Stop listening waiting for TS server (helpee, user) to connect.

Parameters:

    None.

Returns:

    S_OK or error code.

--*/
{
    HRESULT hr = S_OK;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::StopListen");    


    if (!IsValid()) {
        ASSERT(FALSE);
        hr = E_FAIL;
        return hr;
    }
    
    // End listening, either we are actually issued a listen() to socket
    // or we just created the listen socket but not yet start listening
    if( TRUE == ListenConnectInProgress() || INVALID_SOCKET != m_ListenSocket ) {
        ListenConnectCleanup();
        Fire_ListenConnect( SAFERROR_STOPLISTENBYUSER );
    }
    else {
        TRC_ERR((TB, _T("StopListen called while not in listen mode")));
        hr = HRESULT_FROM_WIN32( WSANOTINITIALISED );
    }

    DC_END_FN();
    return hr;
}


LRESULT
CTSRDPRemoteDesktopClient::OnTSConnect(
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam, 
    BOOL& bHandled
    )
/*++

Routine Description:

    Window Message Handler FD_ACCEPT from async. winsock.

Parameters:

    Refer to async. winsock FD_ACCEPT.

Returns:

   

--*/
{
    WORD eventWSA;
    WORD errorWSA;
    HRESULT hr = S_OK;
    SOCKADDR_IN inSockAddr;
    int inSockAddrSize;
    SOCKET s;
    DWORD dwStatus;

    DWORD SafErrorCode = SAFERROR_NOERROR;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::OnTSConnect");    

    eventWSA = WSAGETSELECTEVENT(lParam);
    errorWSA = WSAGETSELECTERROR(lParam);

    // 
    // MSDN : Message might already in our queue before we stop listen.
    //
    if( INVALID_SOCKET == m_ListenSocket || FALSE == ListenConnectInProgress() ) {
        bHandled = TRUE;
        return 0;
    }

    //
    // we are not expecting event other than FD_CONNECT
    //
    if( eventWSA != FD_ACCEPT ) {
        TRC_ERR((TB, _T("Expecting event %d got got %d"), FD_CONNECT, eventWSA)); 
        return 0;
    }

    //
    // Make sure we don't do anything other than our own socket
    //
    if( (SOCKET)wParam != m_ListenSocket ) {
        TRC_ERR((TB, _T("Expecting listening socket %d got %d"), m_ListenSocket, wParam)); 
        return 0;
    }

    //
    // We handle the message
    //
    bHandled = TRUE;

    //
    // Error occurred, fire a error event.
    //
    if( 0 != errorWSA ) {
        TRC_ERR((TB, _T("WSA socket listen failed : %d"), errorWSA));
        hr = HRESULT_FROM_WIN32( errorWSA );
        SafErrorCode = SAFERROR_SOCKETCONNECTFAILED;
        goto CLEANUPANDEXIT;
    }

    inSockAddrSize = sizeof(inSockAddr);
    m_TSConnectSocket = accept( m_ListenSocket,
                (struct sockaddr DCPTR)&inSockAddr,
                &inSockAddrSize 
            );

    if( INVALID_SOCKET == m_TSConnectSocket ) {
        dwStatus = WSAGetLastError();
        hr = HRESULT_FROM_WIN32(dwStatus);
        TRC_ERR((TB, _T("accept failed : %d"), dwStatus));
        SafErrorCode = SAFERROR_SOCKETCONNECTFAILED;
        goto CLEANUPANDEXIT;
    }

    //
    // Cached connecting TS server IP address.
    // m_ConnectPort is set at the time we bind socket
    //
    m_ConnectedServer = inet_ntoa(inSockAddr.sin_addr);


    //
    // Stop async. event notification now, accepted socket
    // has same properties as original listening socket.
    //
    dwStatus = WSAAsyncSelect(
                        m_TSConnectSocket,
                        m_hWnd,
                        0,
                        0
                    );

    //
    // Not critical, 
    // listening socket.
    //
    if((DWORD)SOCKET_ERROR == dwStatus) {
        TRC_ERR((TB, _T("WSAAsyncSelect resetting notification failed : %d"), dwStatus));
    }

CLEANUPANDEXIT:

    //
    // Close listening socket and kill timer.
    //
    if( (UINT_PTR)0 != m_ListenTimeoutTimerID  )
    {
        KillTimer( m_ListenTimeoutTimerID );
        m_ListenTimeoutTimerID = (UINT_PTR)0;
    }

    if( INVALID_SOCKET != m_ListenSocket )
    {
        closesocket( m_ListenSocket );
        m_ListenSocket = INVALID_SOCKET;
    }

    //
    // Successfully established connection, terminate listening socket
    //
    Fire_ListenConnect( SafErrorCode );

    DC_END_FN();
    return 0;
}


STDMETHODIMP
CTSRDPRemoteDesktopClient::StartListen(
    /*[in]*/ LONG timeout
    )
/*++

Routine Description:

    Put client into listen mode with optionally timeout.

Parameters:

    timeout : Listen wait timeout, 0 for infinite.

Returns:

    S_OK or error code.

--*/
{
    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::OnTSConnect");    
    HRESULT hr = S_OK;
    int intRC;
    int lastError;

    if( FALSE == IsValid() ) {
        ASSERT(FALSE);
        hr = E_FAIL;
        goto CLEANUPANDEXIT;
    }        

    if( INVALID_SOCKET == m_ListenSocket ) {
        ASSERT(FALSE);
        hr = E_FAIL;
        goto CLEANUPANDEXIT;
    }

    // 
    // Start listening on the port
    //
    intRC = listen( m_ListenSocket, SOMAXCONN );
    if( SOCKET_ERROR == intRC )
    {
        lastError = WSAGetLastError();
        TRC_ERR((TB, _T("listen failed - GLE:%d"), lastError));
        hr = HRESULT_FROM_WIN32( lastError );
        goto CLEANUPANDEXIT;
    }

    //
    // we are in listening now.
    //
    m_ListenConnectInProgress = TRUE;

    //
    // Start listening timer
    //
    if( 0 != timeout )
    {
        m_ListenTimeoutTimerID = SetTimer( (UINT_PTR)WM_LISTENTIMEOUT_TIMER, (UINT)(timeout * 1000) );
        if( (UINT_PTR)0 == m_ListenTimeoutTimerID )
        {
            DWORD dwStatus;

            // Failed to create a timer
            dwStatus = GetLastError();

            TRC_ERR((TB, _T("SetTimer failed - %d"),dwStatus));    
            hr = HRESULT_FROM_WIN32( dwStatus );
        }
    }
    else
    {
        m_ListenTimeoutTimerID = (UINT_PTR)0;
    }

CLEANUPANDEXIT:

    if( FAILED(hr) ) {
        StopListen();
    }

    DC_END_FN();
    return hr;
}


HRESULT
CTSRDPRemoteDesktopClient::RetrieveUserConnectParm( 
    BSTR* pConnectParm 
    )
/*++

Routine Description:

    Retrieve Salem connection parameter to this expert.

Parameters:

    pConnectParm : Pointer to BSTR to receive connect parm.

Returns:

    S_OK or error code.

--*/
{
    LPTSTR pszAddress = NULL;
    int BufSize = 0;
    CComBSTR bstrConnParm;
    DWORD dwRetry;
    HRESULT hRes;
    DWORD dwBufferRequire;
    DWORD dwNumChars;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::RetrieveUserConnectParm");    

    if( NULL == pConnectParm )
    {
        hRes = E_POINTER;
        goto CLEANUPANDEXIT;
    }

    //
    // Address might have change which might require bigger buffer, retry 
    //
    //
    for(dwRetry=0; dwRetry < MAX_FETCHIPADDRESSRETRY; dwRetry++) {

        if( NULL != pszAddress ) {
            LocalFree( pszAddress );
        }

        //
        // Fetch all address on local machine.
        //
        dwBufferRequire = FetchAllAddresses( NULL, 0 );
        if( 0 == dwBufferRequire ) {
            hRes = E_UNEXPECTED;
            ASSERT(FALSE);
            goto CLEANUPANDEXIT;
        }

        pszAddress = (LPTSTR) LocalAlloc( LPTR, sizeof(TCHAR)*(dwBufferRequire+1) );
        if( NULL == pszAddress ) {
            hRes = E_OUTOFMEMORY;
            goto CLEANUPANDEXIT;
        }

        dwNumChars = FetchAllAddresses( pszAddress, dwBufferRequire );
        ASSERT( dwNumChars <= dwBufferRequire );
        if( dwNumChars <= dwBufferRequire ) {
            break;
        }
    }

    if( NULL == pszAddress ) {
        hRes = E_UNEXPECTED;
        goto CLEANUPANDEXIT;
    }

    bstrConnParm = pszAddress;
    *pConnectParm = bstrConnParm.Copy();

    if( NULL == *pConnectParm ) {
        hRes = E_OUTOFMEMORY;
    }

CLEANUPANDEXIT:

    if( NULL != pszAddress ) {
        LocalFree(pszAddress);
    }

    DC_END_FN();
    return hRes;
}


STDMETHODIMP 
CTSRDPRemoteDesktopClient::put_ColorDepth(
    LONG val
    )
/*++

Routine Description:

    Set Color depth

Arguments:

    val     -   Value in bits perpel to set

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    HRESULT hr;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::put_ColorDepth");

    if (!IsValid()) {
        ASSERT(FALSE);
        hr = E_FAIL;
        goto CLEANUPANDEXIT;
    }
    
    hr = m_TSClient->put_ColorDepth(val);

    if (hr != S_OK) {
        TRC_ERR((TB, L"put_ColorDepth:  %08X", hr));
        goto CLEANUPANDEXIT;
    }

CLEANUPANDEXIT:

    DC_END_FN();

    return hr;
}

STDMETHODIMP 
CTSRDPRemoteDesktopClient::get_ColorDepth(
    LONG *pVal
    )
/*++

Routine Description:

    Get Color depth

Arguments:

    pVal     -   address to place the colordepth value in

Return Value:

    S_OK on success.  Otherwise, an error code is returned.

 --*/
{
    HRESULT hr;
    IMsRdpClientAdvancedSettings *pAdvSettings = NULL;

    DC_BEGIN_FN("CTSRDPRemoteDesktopClient::get_ColorDepth");

    if (!IsValid()) {
        ASSERT(FALSE);
        hr = E_FAIL;
        goto CLEANUPANDEXIT;
    }
    
    hr = m_TSClient->get_ColorDepth(pVal);
    if (hr != S_OK) {
        TRC_ERR((TB, L"get_ColorDepth:  %08X", hr));
        goto CLEANUPANDEXIT;
    }


CLEANUPANDEXIT:

    DC_END_FN();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\common\parseaddr.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    parseaddr

Abstract:

    Misc. RD Utils

Author:

    HueiWang

Revision History:

--*/

#ifndef __REMOTEDESKTOPPARSEADDR_H__
#define __REMOTEDESKTOPPARSEADDR_H__

#include <atlbase.h>
#pragma warning (disable: 4786)
#include <list>

#include "RemoteDesktopTopLevelObject.h"

typedef struct __ServerAddress {
    CComBSTR ServerName;
    LONG portNumber;
} ServerAddress;

typedef std::list<ServerAddress, CRemoteDesktopAllocator<ServerAddress> > ServerAddressList;


//
// Parse Address list
//
HRESULT
ParseAddressList(
    BSTR addressListString,
    OUT ServerAddressList& addressList
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\common\remotedesktop.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RemoteDesktop

Abstract:
    
    Remote Desktop Top-Level Include for Global Types and Defines

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __REMOTEDESKTOP_H__
#define __REMOTEDESKTOP_H__

//
//  Disable tracing for free builds.
//
#if DBG
#define TRC_CL TRC_LEVEL_DBG
#define TRC_ENABLE_PRF
#else
#define TRC_CL TRC_LEVEL_DIS
#undef TRC_ENABLE_PRF
#endif

//
//  Required for DCL Tracing
//
#define OS_WIN32
#define TRC_GROUP TRC_GROUP_NETWORK
#define DEBUG_MODULE DBG_MOD_ANY
#include <adcgbase.h>
#include <at120ex.h>
#include <atrcapi.h>
#include <adcgbase.h>
#include <at120ex.h>

//
//  Protocol Types
//
#define REMOTEDESKTOP_RESERVED_PROTOCOL_BASE        0x0
#define REMOTEDESKTOP_TSRDP_PROTOCOL                REMOTEDESKTOP_RESERVED_PROTOCOL_BASE+1
#define REMOTEDESKTOP_NETMEETING_PROTOCOL           REMOTEDESKTOP_RESERVED_PROTOCOL_BASE+2
#define REMOTEDESKTOP_USERDEFINED_PROTOCOL_BASE     0x10

//
//  Protocol Version Information
//
#define REMOTEDESKTOP_VERSION_MAJOR                 1

#if FEATURE_USERBLOBS

#define REMOTEDESKTOP_VERSION_MINOR                 2

#else

#define REMOTEDESKTOP_VERSION_MINOR                 1

#endif


//  GUID for TSRDP Client ActiveX Control
//
#define REMOTEDESKTOPRDPCLIENT_TEXTGUID  _T("{F137E241-0092-4575-976A-D3E33980BB26}")
#define REMOTEDESKTOPCLIENT_TEXTGUID     _T("{B90D0115-3AEA-45D3-801E-93913008D49E}")

#endif //__REMOTEDESKTOP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\common\imsconf2.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Mon Jan 10 10:49:51 2000
 */
/* Compiler settings for D:\salem\sclientapp\imsconf2.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __imsconf2_h__
#define __imsconf2_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __INmManager_FWD_DEFINED__
#define __INmManager_FWD_DEFINED__
typedef interface INmManager INmManager;
#endif 	/* __INmManager_FWD_DEFINED__ */


#ifndef __INmManagerNotify_FWD_DEFINED__
#define __INmManagerNotify_FWD_DEFINED__
typedef interface INmManagerNotify INmManagerNotify;
#endif 	/* __INmManagerNotify_FWD_DEFINED__ */


#ifndef __INmSysInfo_FWD_DEFINED__
#define __INmSysInfo_FWD_DEFINED__
typedef interface INmSysInfo INmSysInfo;
#endif 	/* __INmSysInfo_FWD_DEFINED__ */


#ifndef __INmCall_FWD_DEFINED__
#define __INmCall_FWD_DEFINED__
typedef interface INmCall INmCall;
#endif 	/* __INmCall_FWD_DEFINED__ */


#ifndef __INmCallNotify_FWD_DEFINED__
#define __INmCallNotify_FWD_DEFINED__
typedef interface INmCallNotify INmCallNotify;
#endif 	/* __INmCallNotify_FWD_DEFINED__ */


#ifndef __INmConference_FWD_DEFINED__
#define __INmConference_FWD_DEFINED__
typedef interface INmConference INmConference;
#endif 	/* __INmConference_FWD_DEFINED__ */


#ifndef __INmConferenceNotify_FWD_DEFINED__
#define __INmConferenceNotify_FWD_DEFINED__
typedef interface INmConferenceNotify INmConferenceNotify;
#endif 	/* __INmConferenceNotify_FWD_DEFINED__ */


#ifndef __INmMember_FWD_DEFINED__
#define __INmMember_FWD_DEFINED__
typedef interface INmMember INmMember;
#endif 	/* __INmMember_FWD_DEFINED__ */


#ifndef __INmChannel_FWD_DEFINED__
#define __INmChannel_FWD_DEFINED__
typedef interface INmChannel INmChannel;
#endif 	/* __INmChannel_FWD_DEFINED__ */


#ifndef __INmChannelNotify_FWD_DEFINED__
#define __INmChannelNotify_FWD_DEFINED__
typedef interface INmChannelNotify INmChannelNotify;
#endif 	/* __INmChannelNotify_FWD_DEFINED__ */


#ifndef __INmChannelData_FWD_DEFINED__
#define __INmChannelData_FWD_DEFINED__
typedef interface INmChannelData INmChannelData;
#endif 	/* __INmChannelData_FWD_DEFINED__ */


#ifndef __INmChannelDataNotify_FWD_DEFINED__
#define __INmChannelDataNotify_FWD_DEFINED__
typedef interface INmChannelDataNotify INmChannelDataNotify;
#endif 	/* __INmChannelDataNotify_FWD_DEFINED__ */


#ifndef __INmChannelAudio_FWD_DEFINED__
#define __INmChannelAudio_FWD_DEFINED__
typedef interface INmChannelAudio INmChannelAudio;
#endif 	/* __INmChannelAudio_FWD_DEFINED__ */


#ifndef __INmChannelAudioNotify_FWD_DEFINED__
#define __INmChannelAudioNotify_FWD_DEFINED__
typedef interface INmChannelAudioNotify INmChannelAudioNotify;
#endif 	/* __INmChannelAudioNotify_FWD_DEFINED__ */


#ifndef __INmChannelVideo_FWD_DEFINED__
#define __INmChannelVideo_FWD_DEFINED__
typedef interface INmChannelVideo INmChannelVideo;
#endif 	/* __INmChannelVideo_FWD_DEFINED__ */


#ifndef __INmChannelVideoNotify_FWD_DEFINED__
#define __INmChannelVideoNotify_FWD_DEFINED__
typedef interface INmChannelVideoNotify INmChannelVideoNotify;
#endif 	/* __INmChannelVideoNotify_FWD_DEFINED__ */


#ifndef __INmChannelFt_FWD_DEFINED__
#define __INmChannelFt_FWD_DEFINED__
typedef interface INmChannelFt INmChannelFt;
#endif 	/* __INmChannelFt_FWD_DEFINED__ */


#ifndef __INmChannelFtNotify_FWD_DEFINED__
#define __INmChannelFtNotify_FWD_DEFINED__
typedef interface INmChannelFtNotify INmChannelFtNotify;
#endif 	/* __INmChannelFtNotify_FWD_DEFINED__ */


#ifndef __INmFt_FWD_DEFINED__
#define __INmFt_FWD_DEFINED__
typedef interface INmFt INmFt;
#endif 	/* __INmFt_FWD_DEFINED__ */


#ifndef __INmChannelAppShare_FWD_DEFINED__
#define __INmChannelAppShare_FWD_DEFINED__
typedef interface INmChannelAppShare INmChannelAppShare;
#endif 	/* __INmChannelAppShare_FWD_DEFINED__ */


#ifndef __INmChannelAppShareNotify_FWD_DEFINED__
#define __INmChannelAppShareNotify_FWD_DEFINED__
typedef interface INmChannelAppShareNotify INmChannelAppShareNotify;
#endif 	/* __INmChannelAppShareNotify_FWD_DEFINED__ */


#ifndef __INmSharableApp_FWD_DEFINED__
#define __INmSharableApp_FWD_DEFINED__
typedef interface INmSharableApp INmSharableApp;
#endif 	/* __INmSharableApp_FWD_DEFINED__ */


#ifndef __IEnumNmConference_FWD_DEFINED__
#define __IEnumNmConference_FWD_DEFINED__
typedef interface IEnumNmConference IEnumNmConference;
#endif 	/* __IEnumNmConference_FWD_DEFINED__ */


#ifndef __IEnumNmMember_FWD_DEFINED__
#define __IEnumNmMember_FWD_DEFINED__
typedef interface IEnumNmMember IEnumNmMember;
#endif 	/* __IEnumNmMember_FWD_DEFINED__ */


#ifndef __IEnumNmChannel_FWD_DEFINED__
#define __IEnumNmChannel_FWD_DEFINED__
typedef interface IEnumNmChannel IEnumNmChannel;
#endif 	/* __IEnumNmChannel_FWD_DEFINED__ */


#ifndef __IEnumNmCall_FWD_DEFINED__
#define __IEnumNmCall_FWD_DEFINED__
typedef interface IEnumNmCall IEnumNmCall;
#endif 	/* __IEnumNmCall_FWD_DEFINED__ */


#ifndef __IEnumNmSharableApp_FWD_DEFINED__
#define __IEnumNmSharableApp_FWD_DEFINED__
typedef interface IEnumNmSharableApp IEnumNmSharableApp;
#endif 	/* __IEnumNmSharableApp_FWD_DEFINED__ */


#ifndef __INmObject_FWD_DEFINED__
#define __INmObject_FWD_DEFINED__
typedef interface INmObject INmObject;
#endif 	/* __INmObject_FWD_DEFINED__ */


#ifndef __NmManager_FWD_DEFINED__
#define __NmManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class NmManager NmManager;
#else
typedef struct NmManager NmManager;
#endif /* __cplusplus */

#endif 	/* __NmManager_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_imsconf2_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995-1999 Microsoft Corporation. All Rights Reserved.
//
//  File: imsconf2.h
//
//--------------------------------------------------------------------------




























////////////////////////////////////////////////////////////////////////////
//
// Constants

// NetMeeting Channel Types
#define NMCH_NONE                     0x00000000
#define NMCH_DATA                     0x00000001
#define NMCH_AUDIO                    0x00000002
#define NMCH_VIDEO                    0x00000004
#define NMCH_SHARE                    0x00000010
#define NMCH_FT                       0x00000020
#define NMCH_ALL                      0x0000FFFF
#define NMCH_SECURE                   0x00010000

// Initialization options
#define NM_INIT_NORMAL                0x00000000
#define NM_INIT_CONTROL               0x00000001
#define NM_INIT_NO_LAUNCH             0x00000002
#define NM_INIT_BACKGROUND            0x00000005

// INmChannelDataNotify.DataReceived dwFlags
#define NM_DF_BROADCAST               0x00000010
#define NM_DF_PRIVATE                 0x00000020
#define NM_DF_SEGMENT_END             0x00000040
#define NM_DF_SEGMENT_BEGIN           0x00000080

// Audio
#define NM_MAX_AUDIO_LEVEL            0x0000FFFF

// Video
#define NM_VIDEO_NO_AUTOSIZE          0x00000000
#define NM_VIDEO_SMALL                0x00000001
#define NM_VIDEO_MEDIUM               0x00000002
#define NM_VIDEO_LARGE                0x00000004
#define NM_VIDEO_MIN_QUALITY          0x00000000
#define NM_VIDEO_MAX_QUALITY          0x0000001F
#define NM_VIDEO_SOURCE_DIALOG        0x00000001
#define NM_VIDEO_FORMAT_DIALOG        0x00000002

// Version Numbers
#define NM_VER_UNKNOWN                0x00000000
#define NM_VER_1                      0x00000001
#define NM_VER_2                      0x00000002
#define NM_VER_NetMeeting2_11         0x00000003
#define NM_VER_NetMeeting3            0x00000004
#define NM_VER_FUTURE                 0x0000000F


// User Categories
#define NM_CATEGORY_PERSONAL          0x00000001
#define NM_CATEGORY_BUSINESS          0x00000002
#define NM_CATEGORY_ADULT             0x00000004


////////////////////////////////////////////////////////////////////////////
//  Error Codes

#define NM_E(e) (0x81000000UL | (ULONG) (e))

enum {

// NetMeeting specific error codes
//
  NM_S_NEXT_CONFERENCE          = ((ULONG) 0x0201),
  NM_S_ON_RESTART               = ((ULONG) 0x0202),


// Call specific error codes
//
  NM_CALLERR_NOT_INITIALIZED    = NM_E(0x0100),
  NM_CALLERR_MEDIA              = NM_E(0x0101),
  NM_CALLERR_NAME_RESOLUTION    = NM_E(0x0102),
  NM_CALLERR_PASSWORD           = NM_E(0x0103),
  NM_CALLERR_CONFERENCE_NAME    = NM_E(0x0104),
  NM_CALLERR_IN_CONFERENCE      = NM_E(0x0105),
  NM_CALLERR_NOT_FOUND          = NM_E(0x0106),
  NM_CALLERR_MCU                = NM_E(0x0107),
  NM_CALLERR_REJECTED           = NM_E(0x0108),
  NM_CALLERR_AUDIO              = NM_E(0x0109),
  NM_CALLERR_AUDIO_LOCAL        = NM_E(0x010A),
  NM_CALLERR_AUDIO_REMOTE       = NM_E(0x010B),
  NM_CALLERR_ALREADY_CALLING    = NM_E(0x01FD),
  NM_CALLERR_LOOPBACK           = NM_E(0x01FE),
  NM_CALLERR_UNKNOWN            = NM_E(0x01FF),

// other error codes
//
  NM_E_NOT_INITIALIZED          = NM_E(0x0200),
  NM_E_CHANNEL_ALREADY_EXISTS   = NM_E(0x0201),
  NM_E_NO_T120_CONFERENCE       = NM_E(0x0202),
  NM_E_NOT_ACTIVE               = NM_E(0x0203),
  NM_E_FILE_TOO_BIG             = NM_E(0x0204),
  NM_E_USER_CANCELED_SETUP	   = NM_E(0x0205),
  NM_E_ALREADY_RUNNING		   = NM_E(0x0206),
  NM_E_SHARING_NOT_AVAILABLE	   = NM_E(0x0207),
};

typedef 
enum tagNmConferenceState
    {	NM_CONFERENCE_IDLE	= 0,
	NM_CONFERENCE_WAITING	= 1,
	NM_CONFERENCE_INITIALIZING	= 2,
	NM_CONFERENCE_ACTIVE	= 3
    }	NM_CONFERENCE_STATE;

typedef 
enum tagNmCallType
    {	NM_CALL_DEFAULT	= 0,
	NM_CALL_T120	= 1,
	NM_CALL_H323	= 2
    }	NM_CALL_TYPE;

typedef 
enum tagNmAddrType
    {	NM_ADDR_UNKNOWN	= 0,
	NM_ADDR_IP	= 1,
	NM_ADDR_MACHINENAME	= 2,
	NM_ADDR_PSTN	= 3,
	NM_ADDR_ULS	= 4,
	NM_ADDR_H323_GATEWAY	= 5,
	NM_ADDR_CALLTO	= 6,
	NM_ADDR_T120_TRANSPORT	= 7
    }	NM_ADDR_TYPE;

typedef 
enum tagNmCallState
    {	NM_CALL_INVALID	= 0,
	NM_CALL_INIT	= 1,
	NM_CALL_RING	= 2,
	NM_CALL_SEARCH	= 3,
	NM_CALL_WAIT	= 4,
	NM_CALL_ACCEPTED	= 5,
	NM_CALL_REJECTED	= 6,
	NM_CALL_CANCELED	= 7
    }	NM_CALL_STATE;

typedef 
enum tagNmMemberNotify
    {	NM_MEMBER_ADDED	= 0,
	NM_MEMBER_REMOVED	= 1,
	NM_MEMBER_UPDATED	= 2
    }	NM_MEMBER_NOTIFY;

typedef 
enum tagNmChannelNotify
    {	NM_CHANNEL_ADDED	= 0,
	NM_CHANNEL_REMOVED	= 1,
	NM_CHANNEL_UPDATED	= 2
    }	NM_CHANNEL_NOTIFY;

typedef 
enum tagNmFtState
    {	NM_FT_INVALID	= 0,
	NM_FT_SENDING	= 1,
	NM_FT_RECEIVING	= 2,
	NM_FT_COMPLETE	= 3
    }	NM_FT_STATE;

typedef 
enum tagNmAudioState
    {	NM_AUDIO_IDLE	= 0,
	NM_AUDIO_LOCAL_PAUSED	= 1,
	NM_AUDIO_TRANSFERRING	= 3
    }	NM_AUDIO_STATE;

typedef 
enum tagNmAudProp
    {	NM_AUDPROP_LEVEL	= 1,
	NM_AUDPROP_PAUSE	= 2
    }	NM_AUDPROP;

typedef 
enum tagNmVideoState
    {	NM_VIDEO_IDLE	= 0,
	NM_VIDEO_LOCAL_PAUSED	= 1,
	NM_VIDEO_PREVIEWING	= 2,
	NM_VIDEO_TRANSFERRING	= 3,
	NM_VIDEO_BOTH_PAUSED	= 5,
	NM_VIDEO_REMOTE_PAUSED	= 7
    }	NM_VIDEO_STATE;

typedef 
enum tagNmVidProp
    {	NM_VIDPROP_PAUSE	= 1,
	NM_VIDPROP_WINDOW_AUTO_SIZE	= 2,
	NM_VIDPROP_WINDOW_SIZE	= 3,
	NM_VIDPROP_WINDOW_POSITION	= 4,
	NM_VIDPROP_WINDOW_TOP_MOST	= 5,
	NM_VIDPROP_WINDOW_VISIBLE	= 6,
	NM_VIDPROP_IMAGE_PREFERRED_SIZE	= 7,
	NM_VIDPROP_IMAGE_QUALITY	= 8,
	NM_VIDPROP_CAMERA_DIALOG	= 9
    }	NM_VIDPROP;

typedef 
enum tagNmShareState
    {	NM_SHARE_UNKNOWN	= 0,
	NM_SHARE_WORKING_ALONE	= 1,
	NM_SHARE_COLLABORATING	= 2,
	NM_SHARE_IN_CONTROL	= 3
    }	NM_SHARE_STATE;

typedef 
enum tagNmShAppState
    {	NM_SHAPP_NOT_SHARED	= 0,
	NM_SHAPP_SHARED	= 1
    }	NM_SHAPP_STATE;

typedef 
enum tagNmSysProp
    {	NM_SYSPROP_EMAIL_NAME	= 1,
	NM_SYSPROP_SERVER_NAME	= 2,
	NM_SYSPROP_RESOLVE_NAME	= 3,
	NM_SYSPROP_FIRST_NAME	= 4,
	NM_SYSPROP_LAST_NAME	= 5,
	NM_SYSPROP_USER_NAME	= 6,
	NM_SYSPROP_USER_CITY	= 7,
	NM_SYSPROP_USER_COUNTRY	= 8,
	NM_SYSPROP_USER_COMMENTS	= 9,
	NM_SYSPROP_USER_CATEGORY	= 10,
	NM_SYSPROP_USER_PHONENUM	= 11,
	NM_SYSPROP_USER_LOCATION	= 12,
	NM_SYSPROP_H323_GATEWAY	= 20,
	NM_SYSPROP_H323_GATEWAY_ENABLE	= 21,
	NM_SYSPROP_INSTALL_DIRECTORY	= 50,
	NM_SYSPROP_APP_NAME	= 51,
	NM_SYSPROP_LOGGED_ON	= 69,
	NM_SYSPROP_IS_RUNNING	= 100,
	NM_SYSPROP_IN_CONFERENCE	= 101,
	NM_SYSPROP_BUILD_VER	= 200,
	NM_SYSPROP_DISABLE_H323	= 201,
	NM_SYSPROP_DISABLE_INITIAL_ILS_LOGON	= 202
    }	NM_SYSPROP;

typedef 
enum tagConfn
    {	CONFN_FT_UI	= 0x211,
	CONFN_FT_OFFERED	= 0x212,
	CONFN_FT_STARTED	= 0x213,
	CONFN_FT_PROGRESS	= 0x214,
	CONFN_FT_COMPLETE	= 0x215,
	CONFN_FT_CANCELED	= 0x216,
	CONFN_CLICK_CONTROL	= 0x220,
	CONFN_CLICK_OBSCURE	= 0x221,
	CONFN_CLICK_REMOTE_NOT_COLLABORATING	= 0x222,
	CONFN_CLICK_LOCAL_NOT_COLLABORATING	= 0x223,
	CONFN_CALL_INCOMPATIBLE	= 0x400,
	CONFN_CALL_OLDER	= 0x401,
	CONFN_CALL_NEWER	= 0x402,
	CONFN_CALL_IGNORED	= 0x403,
	CONFN_CALL_FAILED	= 0x404,
	CONFN_CALL_IN_CONFERENCE	= 0x405,
	CONFN_NM_STARTED	= 0x600,
	CONFN_NM_STOPPED	= 0x601
    }	CONFN;

typedef 
enum NM_APPID
    {	NM_APPID_CHAT	= 1,
	NM_APPID_WHITEBOARD	= 2,
	NM_APPID_T126_WHITEBOARD	= 3,
	NM_APPID_FILE_TRANSFER	= 4,
	NM_APPID_APPSHARING	= 5
    }	NM_APPID;

typedef 
enum NM_VUI
    {	NM_VUI_CHECK	= 0,
	NM_VUI_SHOW	= 1
    }	NM_VUI;



extern RPC_IF_HANDLE __MIDL_itf_imsconf2_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imsconf2_0000_v0_0_s_ifspec;

#ifndef __INmManager_INTERFACE_DEFINED__
#define __INmManager_INTERFACE_DEFINED__

/* interface INmManager */
/* [unique][uuid][object] */ 

typedef /* [unique] */ INmManager __RPC_FAR *LPNMMANAGER;


EXTERN_C const IID IID_INmManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B0701-718C-11d0-8B1A-00A0C91BC90E")
    INmManager : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [out][in] */ ULONG __RPC_FAR *puOptions,
            /* [out][in] */ ULONG __RPC_FAR *puchCaps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSysInfo( 
            /* [out] */ INmSysInfo __RPC_FAR *__RPC_FAR *ppSysInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumConference( 
            /* [out] */ IEnumNmConference __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateConference( 
            /* [out] */ INmConference __RPC_FAR *__RPC_FAR *ppConference,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrPassword,
            /* [in] */ ULONG uchCaps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCall( 
            /* [out] */ IEnumNmCall __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateCall( 
            /* [out] */ INmCall __RPC_FAR *__RPC_FAR *ppCall,
            /* [in] */ NM_CALL_TYPE callType,
            /* [in] */ NM_ADDR_TYPE addrType,
            /* [in] */ BSTR bstrAddr,
            /* [in] */ INmConference __RPC_FAR *pConference) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CallConference( 
            /* [out] */ INmCall __RPC_FAR *__RPC_FAR *ppCall,
            /* [in] */ NM_CALL_TYPE callType,
            /* [in] */ NM_ADDR_TYPE addrType,
            /* [in] */ BSTR bstrAddr,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrPassword) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INmManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INmManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INmManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INmManager __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            INmManager __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *puOptions,
            /* [out][in] */ ULONG __RPC_FAR *puchCaps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSysInfo )( 
            INmManager __RPC_FAR * This,
            /* [out] */ INmSysInfo __RPC_FAR *__RPC_FAR *ppSysInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumConference )( 
            INmManager __RPC_FAR * This,
            /* [out] */ IEnumNmConference __RPC_FAR *__RPC_FAR *ppEnum);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateConference )( 
            INmManager __RPC_FAR * This,
            /* [out] */ INmConference __RPC_FAR *__RPC_FAR *ppConference,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrPassword,
            /* [in] */ ULONG uchCaps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumCall )( 
            INmManager __RPC_FAR * This,
            /* [out] */ IEnumNmCall __RPC_FAR *__RPC_FAR *ppEnum);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateCall )( 
            INmManager __RPC_FAR * This,
            /* [out] */ INmCall __RPC_FAR *__RPC_FAR *ppCall,
            /* [in] */ NM_CALL_TYPE callType,
            /* [in] */ NM_ADDR_TYPE addrType,
            /* [in] */ BSTR bstrAddr,
            /* [in] */ INmConference __RPC_FAR *pConference);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CallConference )( 
            INmManager __RPC_FAR * This,
            /* [out] */ INmCall __RPC_FAR *__RPC_FAR *ppCall,
            /* [in] */ NM_CALL_TYPE callType,
            /* [in] */ NM_ADDR_TYPE addrType,
            /* [in] */ BSTR bstrAddr,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrPassword);
        
        END_INTERFACE
    } INmManagerVtbl;

    interface INmManager
    {
        CONST_VTBL struct INmManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INmManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INmManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INmManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INmManager_Initialize(This,puOptions,puchCaps)	\
    (This)->lpVtbl -> Initialize(This,puOptions,puchCaps)

#define INmManager_GetSysInfo(This,ppSysInfo)	\
    (This)->lpVtbl -> GetSysInfo(This,ppSysInfo)

#define INmManager_EnumConference(This,ppEnum)	\
    (This)->lpVtbl -> EnumConference(This,ppEnum)

#define INmManager_CreateConference(This,ppConference,bstrName,bstrPassword,uchCaps)	\
    (This)->lpVtbl -> CreateConference(This,ppConference,bstrName,bstrPassword,uchCaps)

#define INmManager_EnumCall(This,ppEnum)	\
    (This)->lpVtbl -> EnumCall(This,ppEnum)

#define INmManager_CreateCall(This,ppCall,callType,addrType,bstrAddr,pConference)	\
    (This)->lpVtbl -> CreateCall(This,ppCall,callType,addrType,bstrAddr,pConference)

#define INmManager_CallConference(This,ppCall,callType,addrType,bstrAddr,bstrName,bstrPassword)	\
    (This)->lpVtbl -> CallConference(This,ppCall,callType,addrType,bstrAddr,bstrName,bstrPassword)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE INmManager_RemoteInitialize_Proxy( 
    INmManager __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *puOptions,
    /* [out][in] */ ULONG __RPC_FAR *puchCaps);


void __RPC_STUB INmManager_RemoteInitialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmManager_GetSysInfo_Proxy( 
    INmManager __RPC_FAR * This,
    /* [out] */ INmSysInfo __RPC_FAR *__RPC_FAR *ppSysInfo);


void __RPC_STUB INmManager_GetSysInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmManager_EnumConference_Proxy( 
    INmManager __RPC_FAR * This,
    /* [out] */ IEnumNmConference __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB INmManager_EnumConference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmManager_RemoteCreateConference_Proxy( 
    INmManager __RPC_FAR * This,
    /* [out] */ INmConference __RPC_FAR *__RPC_FAR *ppConference,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrPassword,
    /* [in] */ ULONG uchCaps);


void __RPC_STUB INmManager_RemoteCreateConference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmManager_EnumCall_Proxy( 
    INmManager __RPC_FAR * This,
    /* [out] */ IEnumNmCall __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB INmManager_EnumCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmManager_RemoteCreateCall_Proxy( 
    INmManager __RPC_FAR * This,
    /* [out] */ INmCall __RPC_FAR *__RPC_FAR *ppCall,
    /* [in] */ NM_CALL_TYPE callType,
    /* [in] */ NM_ADDR_TYPE addrType,
    /* [in] */ BSTR bstrAddr,
    /* [in] */ INmConference __RPC_FAR *pConference);


void __RPC_STUB INmManager_RemoteCreateCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmManager_RemoteCallConference_Proxy( 
    INmManager __RPC_FAR * This,
    /* [out] */ INmCall __RPC_FAR *__RPC_FAR *ppCall,
    /* [in] */ NM_CALL_TYPE callType,
    /* [in] */ NM_ADDR_TYPE addrType,
    /* [in] */ BSTR bstrAddr,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrPassword);


void __RPC_STUB INmManager_RemoteCallConference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INmManager_INTERFACE_DEFINED__ */


#ifndef __INmManagerNotify_INTERFACE_DEFINED__
#define __INmManagerNotify_INTERFACE_DEFINED__

/* interface INmManagerNotify */
/* [unique][uuid][object] */ 

typedef /* [unique] */ INmManagerNotify __RPC_FAR *LPNMMANAGERNOTIFY;


EXTERN_C const IID IID_INmManagerNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B0702-718C-11d0-8B1A-00A0C91BC90E")
    INmManagerNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NmUI( 
            /* [in] */ CONFN uNotify) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConferenceCreated( 
            /* [in] */ INmConference __RPC_FAR *pConference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CallCreated( 
            /* [in] */ INmCall __RPC_FAR *pCall) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INmManagerNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INmManagerNotify __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INmManagerNotify __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INmManagerNotify __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NmUI )( 
            INmManagerNotify __RPC_FAR * This,
            /* [in] */ CONFN uNotify);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConferenceCreated )( 
            INmManagerNotify __RPC_FAR * This,
            /* [in] */ INmConference __RPC_FAR *pConference);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CallCreated )( 
            INmManagerNotify __RPC_FAR * This,
            /* [in] */ INmCall __RPC_FAR *pCall);
        
        END_INTERFACE
    } INmManagerNotifyVtbl;

    interface INmManagerNotify
    {
        CONST_VTBL struct INmManagerNotifyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INmManagerNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INmManagerNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INmManagerNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INmManagerNotify_NmUI(This,uNotify)	\
    (This)->lpVtbl -> NmUI(This,uNotify)

#define INmManagerNotify_ConferenceCreated(This,pConference)	\
    (This)->lpVtbl -> ConferenceCreated(This,pConference)

#define INmManagerNotify_CallCreated(This,pCall)	\
    (This)->lpVtbl -> CallCreated(This,pCall)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INmManagerNotify_NmUI_Proxy( 
    INmManagerNotify __RPC_FAR * This,
    /* [in] */ CONFN uNotify);


void __RPC_STUB INmManagerNotify_NmUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmManagerNotify_ConferenceCreated_Proxy( 
    INmManagerNotify __RPC_FAR * This,
    /* [in] */ INmConference __RPC_FAR *pConference);


void __RPC_STUB INmManagerNotify_ConferenceCreated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmManagerNotify_CallCreated_Proxy( 
    INmManagerNotify __RPC_FAR * This,
    /* [in] */ INmCall __RPC_FAR *pCall);


void __RPC_STUB INmManagerNotify_CallCreated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INmManagerNotify_INTERFACE_DEFINED__ */


#ifndef __INmSysInfo_INTERFACE_DEFINED__
#define __INmSysInfo_INTERFACE_DEFINED__

/* interface INmSysInfo */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ INmSysInfo __RPC_FAR *LPNMSYSINFO;


EXTERN_C const IID IID_INmSysInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B0703-718C-11d0-8B1A-00A0C91BC90E")
    INmSysInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsInstalled( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ NM_SYSPROP uProp,
            /* [out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ NM_SYSPROP uProp,
            /* [in] */ BSTR bstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserData( 
            /* [in] */ REFGUID rguid,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppb,
            /* [out] */ ULONG __RPC_FAR *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUserData( 
            /* [in] */ REFGUID rguid,
            /* [in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNmApp( 
            /* [in] */ REFGUID rguid,
            /* [out] */ BSTR __RPC_FAR *pbstrApplication,
            /* [out] */ BSTR __RPC_FAR *pbstrCommandLine,
            /* [out] */ BSTR __RPC_FAR *pbstrDirectory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNmApp( 
            /* [in] */ REFGUID rguid,
            /* [in] */ BSTR bstrApplication,
            /* [in] */ BSTR bstrCommandLine,
            /* [in] */ BSTR bstrDirectory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNmchCaps( 
            /* [out] */ ULONG __RPC_FAR *pchCaps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLaunchInfo( 
            /* [out] */ INmConference __RPC_FAR *__RPC_FAR *ppConference,
            /* [out] */ INmMember __RPC_FAR *__RPC_FAR *ppMember) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INmSysInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INmSysInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INmSysInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INmSysInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsInstalled )( 
            INmSysInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            INmSysInfo __RPC_FAR * This,
            /* [in] */ NM_SYSPROP uProp,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProperty )( 
            INmSysInfo __RPC_FAR * This,
            /* [in] */ NM_SYSPROP uProp,
            /* [in] */ BSTR bstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUserData )( 
            INmSysInfo __RPC_FAR * This,
            /* [in] */ REFGUID rguid,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppb,
            /* [out] */ ULONG __RPC_FAR *pcb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUserData )( 
            INmSysInfo __RPC_FAR * This,
            /* [in] */ REFGUID rguid,
            /* [in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNmApp )( 
            INmSysInfo __RPC_FAR * This,
            /* [in] */ REFGUID rguid,
            /* [out] */ BSTR __RPC_FAR *pbstrApplication,
            /* [out] */ BSTR __RPC_FAR *pbstrCommandLine,
            /* [out] */ BSTR __RPC_FAR *pbstrDirectory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNmApp )( 
            INmSysInfo __RPC_FAR * This,
            /* [in] */ REFGUID rguid,
            /* [in] */ BSTR bstrApplication,
            /* [in] */ BSTR bstrCommandLine,
            /* [in] */ BSTR bstrDirectory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNmchCaps )( 
            INmSysInfo __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pchCaps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLaunchInfo )( 
            INmSysInfo __RPC_FAR * This,
            /* [out] */ INmConference __RPC_FAR *__RPC_FAR *ppConference,
            /* [out] */ INmMember __RPC_FAR *__RPC_FAR *ppMember);
        
        END_INTERFACE
    } INmSysInfoVtbl;

    interface INmSysInfo
    {
        CONST_VTBL struct INmSysInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INmSysInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INmSysInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INmSysInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INmSysInfo_IsInstalled(This)	\
    (This)->lpVtbl -> IsInstalled(This)

#define INmSysInfo_GetProperty(This,uProp,pbstrName)	\
    (This)->lpVtbl -> GetProperty(This,uProp,pbstrName)

#define INmSysInfo_SetProperty(This,uProp,bstrName)	\
    (This)->lpVtbl -> SetProperty(This,uProp,bstrName)

#define INmSysInfo_GetUserData(This,rguid,ppb,pcb)	\
    (This)->lpVtbl -> GetUserData(This,rguid,ppb,pcb)

#define INmSysInfo_SetUserData(This,rguid,pb,cb)	\
    (This)->lpVtbl -> SetUserData(This,rguid,pb,cb)

#define INmSysInfo_GetNmApp(This,rguid,pbstrApplication,pbstrCommandLine,pbstrDirectory)	\
    (This)->lpVtbl -> GetNmApp(This,rguid,pbstrApplication,pbstrCommandLine,pbstrDirectory)

#define INmSysInfo_SetNmApp(This,rguid,bstrApplication,bstrCommandLine,bstrDirectory)	\
    (This)->lpVtbl -> SetNmApp(This,rguid,bstrApplication,bstrCommandLine,bstrDirectory)

#define INmSysInfo_GetNmchCaps(This,pchCaps)	\
    (This)->lpVtbl -> GetNmchCaps(This,pchCaps)

#define INmSysInfo_GetLaunchInfo(This,ppConference,ppMember)	\
    (This)->lpVtbl -> GetLaunchInfo(This,ppConference,ppMember)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INmSysInfo_IsInstalled_Proxy( 
    INmSysInfo __RPC_FAR * This);


void __RPC_STUB INmSysInfo_IsInstalled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmSysInfo_GetProperty_Proxy( 
    INmSysInfo __RPC_FAR * This,
    /* [in] */ NM_SYSPROP uProp,
    /* [out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB INmSysInfo_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmSysInfo_SetProperty_Proxy( 
    INmSysInfo __RPC_FAR * This,
    /* [in] */ NM_SYSPROP uProp,
    /* [in] */ BSTR bstrName);


void __RPC_STUB INmSysInfo_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmSysInfo_GetUserData_Proxy( 
    INmSysInfo __RPC_FAR * This,
    /* [in] */ REFGUID rguid,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppb,
    /* [out] */ ULONG __RPC_FAR *pcb);


void __RPC_STUB INmSysInfo_GetUserData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmSysInfo_SetUserData_Proxy( 
    INmSysInfo __RPC_FAR * This,
    /* [in] */ REFGUID rguid,
    /* [in] */ BYTE __RPC_FAR *pb,
    /* [in] */ ULONG cb);


void __RPC_STUB INmSysInfo_SetUserData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmSysInfo_GetNmApp_Proxy( 
    INmSysInfo __RPC_FAR * This,
    /* [in] */ REFGUID rguid,
    /* [out] */ BSTR __RPC_FAR *pbstrApplication,
    /* [out] */ BSTR __RPC_FAR *pbstrCommandLine,
    /* [out] */ BSTR __RPC_FAR *pbstrDirectory);


void __RPC_STUB INmSysInfo_GetNmApp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmSysInfo_SetNmApp_Proxy( 
    INmSysInfo __RPC_FAR * This,
    /* [in] */ REFGUID rguid,
    /* [in] */ BSTR bstrApplication,
    /* [in] */ BSTR bstrCommandLine,
    /* [in] */ BSTR bstrDirectory);


void __RPC_STUB INmSysInfo_SetNmApp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmSysInfo_GetNmchCaps_Proxy( 
    INmSysInfo __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pchCaps);


void __RPC_STUB INmSysInfo_GetNmchCaps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmSysInfo_GetLaunchInfo_Proxy( 
    INmSysInfo __RPC_FAR * This,
    /* [out] */ INmConference __RPC_FAR *__RPC_FAR *ppConference,
    /* [out] */ INmMember __RPC_FAR *__RPC_FAR *ppMember);


void __RPC_STUB INmSysInfo_GetLaunchInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INmSysInfo_INTERFACE_DEFINED__ */


#ifndef __INmCall_INTERFACE_DEFINED__
#define __INmCall_INTERFACE_DEFINED__

/* interface INmCall */
/* [unique][uuid][object] */ 

typedef /* [unique] */ INmCall __RPC_FAR *LPNMCALL;


EXTERN_C const IID IID_INmCall;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B0704-718C-11d0-8B1A-00A0C91BC90E")
    INmCall : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsIncoming( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [out] */ NM_CALL_STATE __RPC_FAR *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAddr( 
            /* [out] */ BSTR __RPC_FAR *pbstrAddr,
            /* [out] */ NM_ADDR_TYPE __RPC_FAR *puType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserData( 
            /* [in] */ REFGUID rguid,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppb,
            /* [out] */ ULONG __RPC_FAR *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConference( 
            /* [out] */ INmConference __RPC_FAR *__RPC_FAR *ppConference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Accept( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reject( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INmCallVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INmCall __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INmCall __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INmCall __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsIncoming )( 
            INmCall __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetState )( 
            INmCall __RPC_FAR * This,
            /* [out] */ NM_CALL_STATE __RPC_FAR *pState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            INmCall __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAddr )( 
            INmCall __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrAddr,
            /* [out] */ NM_ADDR_TYPE __RPC_FAR *puType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUserData )( 
            INmCall __RPC_FAR * This,
            /* [in] */ REFGUID rguid,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppb,
            /* [out] */ ULONG __RPC_FAR *pcb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConference )( 
            INmCall __RPC_FAR * This,
            /* [out] */ INmConference __RPC_FAR *__RPC_FAR *ppConference);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Accept )( 
            INmCall __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reject )( 
            INmCall __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Cancel )( 
            INmCall __RPC_FAR * This);
        
        END_INTERFACE
    } INmCallVtbl;

    interface INmCall
    {
        CONST_VTBL struct INmCallVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INmCall_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INmCall_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INmCall_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INmCall_IsIncoming(This)	\
    (This)->lpVtbl -> IsIncoming(This)

#define INmCall_GetState(This,pState)	\
    (This)->lpVtbl -> GetState(This,pState)

#define INmCall_GetName(This,pbstrName)	\
    (This)->lpVtbl -> GetName(This,pbstrName)

#define INmCall_GetAddr(This,pbstrAddr,puType)	\
    (This)->lpVtbl -> GetAddr(This,pbstrAddr,puType)

#define INmCall_GetUserData(This,rguid,ppb,pcb)	\
    (This)->lpVtbl -> GetUserData(This,rguid,ppb,pcb)

#define INmCall_GetConference(This,ppConference)	\
    (This)->lpVtbl -> GetConference(This,ppConference)

#define INmCall_Accept(This)	\
    (This)->lpVtbl -> Accept(This)

#define INmCall_Reject(This)	\
    (This)->lpVtbl -> Reject(This)

#define INmCall_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INmCall_IsIncoming_Proxy( 
    INmCall __RPC_FAR * This);


void __RPC_STUB INmCall_IsIncoming_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmCall_GetState_Proxy( 
    INmCall __RPC_FAR * This,
    /* [out] */ NM_CALL_STATE __RPC_FAR *pState);


void __RPC_STUB INmCall_GetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmCall_GetName_Proxy( 
    INmCall __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB INmCall_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmCall_GetAddr_Proxy( 
    INmCall __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrAddr,
    /* [out] */ NM_ADDR_TYPE __RPC_FAR *puType);


void __RPC_STUB INmCall_GetAddr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmCall_GetUserData_Proxy( 
    INmCall __RPC_FAR * This,
    /* [in] */ REFGUID rguid,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppb,
    /* [out] */ ULONG __RPC_FAR *pcb);


void __RPC_STUB INmCall_GetUserData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmCall_GetConference_Proxy( 
    INmCall __RPC_FAR * This,
    /* [out] */ INmConference __RPC_FAR *__RPC_FAR *ppConference);


void __RPC_STUB INmCall_GetConference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmCall_Accept_Proxy( 
    INmCall __RPC_FAR * This);


void __RPC_STUB INmCall_Accept_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmCall_Reject_Proxy( 
    INmCall __RPC_FAR * This);


void __RPC_STUB INmCall_Reject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmCall_Cancel_Proxy( 
    INmCall __RPC_FAR * This);


void __RPC_STUB INmCall_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INmCall_INTERFACE_DEFINED__ */


#ifndef __INmCallNotify_INTERFACE_DEFINED__
#define __INmCallNotify_INTERFACE_DEFINED__

/* interface INmCallNotify */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INmCallNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B0705-718C-11d0-8B1A-00A0C91BC90E")
    INmCallNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NmUI( 
            /* [in] */ CONFN uNotify) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StateChanged( 
            /* [in] */ NM_CALL_STATE uState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Failed( 
            /* [in] */ ULONG uError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Accepted( 
            /* [in] */ INmConference __RPC_FAR *pConference) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INmCallNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INmCallNotify __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INmCallNotify __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INmCallNotify __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NmUI )( 
            INmCallNotify __RPC_FAR * This,
            /* [in] */ CONFN uNotify);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StateChanged )( 
            INmCallNotify __RPC_FAR * This,
            /* [in] */ NM_CALL_STATE uState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Failed )( 
            INmCallNotify __RPC_FAR * This,
            /* [in] */ ULONG uError);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Accepted )( 
            INmCallNotify __RPC_FAR * This,
            /* [in] */ INmConference __RPC_FAR *pConference);
        
        END_INTERFACE
    } INmCallNotifyVtbl;

    interface INmCallNotify
    {
        CONST_VTBL struct INmCallNotifyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INmCallNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INmCallNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INmCallNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INmCallNotify_NmUI(This,uNotify)	\
    (This)->lpVtbl -> NmUI(This,uNotify)

#define INmCallNotify_StateChanged(This,uState)	\
    (This)->lpVtbl -> StateChanged(This,uState)

#define INmCallNotify_Failed(This,uError)	\
    (This)->lpVtbl -> Failed(This,uError)

#define INmCallNotify_Accepted(This,pConference)	\
    (This)->lpVtbl -> Accepted(This,pConference)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INmCallNotify_NmUI_Proxy( 
    INmCallNotify __RPC_FAR * This,
    /* [in] */ CONFN uNotify);


void __RPC_STUB INmCallNotify_NmUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmCallNotify_StateChanged_Proxy( 
    INmCallNotify __RPC_FAR * This,
    /* [in] */ NM_CALL_STATE uState);


void __RPC_STUB INmCallNotify_StateChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmCallNotify_Failed_Proxy( 
    INmCallNotify __RPC_FAR * This,
    /* [in] */ ULONG uError);


void __RPC_STUB INmCallNotify_Failed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmCallNotify_Accepted_Proxy( 
    INmCallNotify __RPC_FAR * This,
    /* [in] */ INmConference __RPC_FAR *pConference);


void __RPC_STUB INmCallNotify_Accepted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INmCallNotify_INTERFACE_DEFINED__ */


#ifndef __INmConference_INTERFACE_DEFINED__
#define __INmConference_INTERFACE_DEFINED__

/* interface INmConference */
/* [unique][uuid][object] */ 

typedef /* [unique] */ INmConference __RPC_FAR *LPNMCONFERENCE;


EXTERN_C const IID IID_INmConference;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B0710-718C-11d0-8B1A-00A0C91BC90E")
    INmConference : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetID( 
            /* [out] */ ULONG __RPC_FAR *puID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [out] */ NM_CONFERENCE_STATE __RPC_FAR *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNmchCaps( 
            /* [out] */ ULONG __RPC_FAR *puchCaps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTopProvider( 
            /* [out] */ INmMember __RPC_FAR *__RPC_FAR *ppMember) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumMember( 
            /* [out] */ IEnumNmMember __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMemberCount( 
            /* [out] */ ULONG __RPC_FAR *puCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumChannel( 
            /* [out] */ IEnumNmChannel __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChannelCount( 
            /* [out] */ ULONG __RPC_FAR *puCount) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateDataChannel( 
            /* [out] */ INmChannelData __RPC_FAR *__RPC_FAR *ppChannel,
            /* [in] */ REFGUID rguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsHosting( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Host( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Leave( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LaunchRemote( 
            /* [in] */ REFGUID rguid,
            /* [in] */ INmMember __RPC_FAR *pMember) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INmConferenceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INmConference __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INmConference __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INmConference __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            INmConference __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetID )( 
            INmConference __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetState )( 
            INmConference __RPC_FAR * This,
            /* [out] */ NM_CONFERENCE_STATE __RPC_FAR *pState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNmchCaps )( 
            INmConference __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puchCaps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTopProvider )( 
            INmConference __RPC_FAR * This,
            /* [out] */ INmMember __RPC_FAR *__RPC_FAR *ppMember);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumMember )( 
            INmConference __RPC_FAR * This,
            /* [out] */ IEnumNmMember __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMemberCount )( 
            INmConference __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumChannel )( 
            INmConference __RPC_FAR * This,
            /* [out] */ IEnumNmChannel __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChannelCount )( 
            INmConference __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puCount);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateDataChannel )( 
            INmConference __RPC_FAR * This,
            /* [out] */ INmChannelData __RPC_FAR *__RPC_FAR *ppChannel,
            /* [in] */ REFGUID rguid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsHosting )( 
            INmConference __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Host )( 
            INmConference __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Leave )( 
            INmConference __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LaunchRemote )( 
            INmConference __RPC_FAR * This,
            /* [in] */ REFGUID rguid,
            /* [in] */ INmMember __RPC_FAR *pMember);
        
        END_INTERFACE
    } INmConferenceVtbl;

    interface INmConference
    {
        CONST_VTBL struct INmConferenceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INmConference_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INmConference_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INmConference_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INmConference_GetName(This,pbstrName)	\
    (This)->lpVtbl -> GetName(This,pbstrName)

#define INmConference_GetID(This,puID)	\
    (This)->lpVtbl -> GetID(This,puID)

#define INmConference_GetState(This,pState)	\
    (This)->lpVtbl -> GetState(This,pState)

#define INmConference_GetNmchCaps(This,puchCaps)	\
    (This)->lpVtbl -> GetNmchCaps(This,puchCaps)

#define INmConference_GetTopProvider(This,ppMember)	\
    (This)->lpVtbl -> GetTopProvider(This,ppMember)

#define INmConference_EnumMember(This,ppEnum)	\
    (This)->lpVtbl -> EnumMember(This,ppEnum)

#define INmConference_GetMemberCount(This,puCount)	\
    (This)->lpVtbl -> GetMemberCount(This,puCount)

#define INmConference_EnumChannel(This,ppEnum)	\
    (This)->lpVtbl -> EnumChannel(This,ppEnum)

#define INmConference_GetChannelCount(This,puCount)	\
    (This)->lpVtbl -> GetChannelCount(This,puCount)

#define INmConference_CreateDataChannel(This,ppChannel,rguid)	\
    (This)->lpVtbl -> CreateDataChannel(This,ppChannel,rguid)

#define INmConference_IsHosting(This)	\
    (This)->lpVtbl -> IsHosting(This)

#define INmConference_Host(This)	\
    (This)->lpVtbl -> Host(This)

#define INmConference_Leave(This)	\
    (This)->lpVtbl -> Leave(This)

#define INmConference_LaunchRemote(This,rguid,pMember)	\
    (This)->lpVtbl -> LaunchRemote(This,rguid,pMember)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INmConference_GetName_Proxy( 
    INmConference __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB INmConference_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmConference_GetID_Proxy( 
    INmConference __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puID);


void __RPC_STUB INmConference_GetID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmConference_GetState_Proxy( 
    INmConference __RPC_FAR * This,
    /* [out] */ NM_CONFERENCE_STATE __RPC_FAR *pState);


void __RPC_STUB INmConference_GetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmConference_GetNmchCaps_Proxy( 
    INmConference __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puchCaps);


void __RPC_STUB INmConference_GetNmchCaps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmConference_GetTopProvider_Proxy( 
    INmConference __RPC_FAR * This,
    /* [out] */ INmMember __RPC_FAR *__RPC_FAR *ppMember);


void __RPC_STUB INmConference_GetTopProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmConference_EnumMember_Proxy( 
    INmConference __RPC_FAR * This,
    /* [out] */ IEnumNmMember __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB INmConference_EnumMember_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmConference_GetMemberCount_Proxy( 
    INmConference __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puCount);


void __RPC_STUB INmConference_GetMemberCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmConference_EnumChannel_Proxy( 
    INmConference __RPC_FAR * This,
    /* [out] */ IEnumNmChannel __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB INmConference_EnumChannel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmConference_GetChannelCount_Proxy( 
    INmConference __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puCount);


void __RPC_STUB INmConference_GetChannelCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmConference_RemoteCreateDataChannel_Proxy( 
    INmConference __RPC_FAR * This,
    /* [out] */ INmChannelData __RPC_FAR *__RPC_FAR *ppChannel,
    /* [in] */ REFGUID rguid);


void __RPC_STUB INmConference_RemoteCreateDataChannel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmConference_IsHosting_Proxy( 
    INmConference __RPC_FAR * This);


void __RPC_STUB INmConference_IsHosting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmConference_Host_Proxy( 
    INmConference __RPC_FAR * This);


void __RPC_STUB INmConference_Host_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmConference_Leave_Proxy( 
    INmConference __RPC_FAR * This);


void __RPC_STUB INmConference_Leave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmConference_LaunchRemote_Proxy( 
    INmConference __RPC_FAR * This,
    /* [in] */ REFGUID rguid,
    /* [in] */ INmMember __RPC_FAR *pMember);


void __RPC_STUB INmConference_LaunchRemote_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INmConference_INTERFACE_DEFINED__ */


#ifndef __INmConferenceNotify_INTERFACE_DEFINED__
#define __INmConferenceNotify_INTERFACE_DEFINED__

/* interface INmConferenceNotify */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INmConferenceNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B0711-718C-11d0-8B1A-00A0C91BC90E")
    INmConferenceNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NmUI( 
            /* [in] */ CONFN uNotify) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StateChanged( 
            /* [in] */ NM_CONFERENCE_STATE uState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MemberChanged( 
            /* [in] */ NM_MEMBER_NOTIFY uNotify,
            /* [in] */ INmMember __RPC_FAR *pMember) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChannelChanged( 
            /* [in] */ NM_CHANNEL_NOTIFY uNotify,
            /* [in] */ INmChannel __RPC_FAR *pChannel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INmConferenceNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INmConferenceNotify __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INmConferenceNotify __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INmConferenceNotify __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NmUI )( 
            INmConferenceNotify __RPC_FAR * This,
            /* [in] */ CONFN uNotify);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StateChanged )( 
            INmConferenceNotify __RPC_FAR * This,
            /* [in] */ NM_CONFERENCE_STATE uState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MemberChanged )( 
            INmConferenceNotify __RPC_FAR * This,
            /* [in] */ NM_MEMBER_NOTIFY uNotify,
            /* [in] */ INmMember __RPC_FAR *pMember);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ChannelChanged )( 
            INmConferenceNotify __RPC_FAR * This,
            /* [in] */ NM_CHANNEL_NOTIFY uNotify,
            /* [in] */ INmChannel __RPC_FAR *pChannel);
        
        END_INTERFACE
    } INmConferenceNotifyVtbl;

    interface INmConferenceNotify
    {
        CONST_VTBL struct INmConferenceNotifyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INmConferenceNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INmConferenceNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INmConferenceNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INmConferenceNotify_NmUI(This,uNotify)	\
    (This)->lpVtbl -> NmUI(This,uNotify)

#define INmConferenceNotify_StateChanged(This,uState)	\
    (This)->lpVtbl -> StateChanged(This,uState)

#define INmConferenceNotify_MemberChanged(This,uNotify,pMember)	\
    (This)->lpVtbl -> MemberChanged(This,uNotify,pMember)

#define INmConferenceNotify_ChannelChanged(This,uNotify,pChannel)	\
    (This)->lpVtbl -> ChannelChanged(This,uNotify,pChannel)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INmConferenceNotify_NmUI_Proxy( 
    INmConferenceNotify __RPC_FAR * This,
    /* [in] */ CONFN uNotify);


void __RPC_STUB INmConferenceNotify_NmUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmConferenceNotify_StateChanged_Proxy( 
    INmConferenceNotify __RPC_FAR * This,
    /* [in] */ NM_CONFERENCE_STATE uState);


void __RPC_STUB INmConferenceNotify_StateChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmConferenceNotify_MemberChanged_Proxy( 
    INmConferenceNotify __RPC_FAR * This,
    /* [in] */ NM_MEMBER_NOTIFY uNotify,
    /* [in] */ INmMember __RPC_FAR *pMember);


void __RPC_STUB INmConferenceNotify_MemberChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmConferenceNotify_ChannelChanged_Proxy( 
    INmConferenceNotify __RPC_FAR * This,
    /* [in] */ NM_CHANNEL_NOTIFY uNotify,
    /* [in] */ INmChannel __RPC_FAR *pChannel);


void __RPC_STUB INmConferenceNotify_ChannelChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INmConferenceNotify_INTERFACE_DEFINED__ */


#ifndef __INmMember_INTERFACE_DEFINED__
#define __INmMember_INTERFACE_DEFINED__

/* interface INmMember */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INmMember;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B0712-718C-11d0-8B1A-00A0C91BC90E")
    INmMember : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetID( 
            /* [out] */ ULONG __RPC_FAR *puID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNmVersion( 
            /* [out] */ ULONG __RPC_FAR *puVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAddr( 
            /* [out] */ BSTR __RPC_FAR *pbstrAddr,
            /* [out] */ NM_ADDR_TYPE __RPC_FAR *puType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserData( 
            /* [in] */ REFGUID rguid,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppb,
            /* [out] */ ULONG __RPC_FAR *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConference( 
            /* [out] */ INmConference __RPC_FAR *__RPC_FAR *ppConference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNmchCaps( 
            /* [out] */ ULONG __RPC_FAR *puchCaps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetShareState( 
            /* [out] */ NM_SHARE_STATE __RPC_FAR *puState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSelf( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsMCU( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Eject( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INmMemberVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INmMember __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INmMember __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INmMember __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            INmMember __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetID )( 
            INmMember __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNmVersion )( 
            INmMember __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAddr )( 
            INmMember __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrAddr,
            /* [out] */ NM_ADDR_TYPE __RPC_FAR *puType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUserData )( 
            INmMember __RPC_FAR * This,
            /* [in] */ REFGUID rguid,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppb,
            /* [out] */ ULONG __RPC_FAR *pcb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConference )( 
            INmMember __RPC_FAR * This,
            /* [out] */ INmConference __RPC_FAR *__RPC_FAR *ppConference);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNmchCaps )( 
            INmMember __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puchCaps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetShareState )( 
            INmMember __RPC_FAR * This,
            /* [out] */ NM_SHARE_STATE __RPC_FAR *puState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsSelf )( 
            INmMember __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsMCU )( 
            INmMember __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Eject )( 
            INmMember __RPC_FAR * This);
        
        END_INTERFACE
    } INmMemberVtbl;

    interface INmMember
    {
        CONST_VTBL struct INmMemberVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INmMember_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INmMember_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INmMember_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INmMember_GetName(This,pbstrName)	\
    (This)->lpVtbl -> GetName(This,pbstrName)

#define INmMember_GetID(This,puID)	\
    (This)->lpVtbl -> GetID(This,puID)

#define INmMember_GetNmVersion(This,puVersion)	\
    (This)->lpVtbl -> GetNmVersion(This,puVersion)

#define INmMember_GetAddr(This,pbstrAddr,puType)	\
    (This)->lpVtbl -> GetAddr(This,pbstrAddr,puType)

#define INmMember_GetUserData(This,rguid,ppb,pcb)	\
    (This)->lpVtbl -> GetUserData(This,rguid,ppb,pcb)

#define INmMember_GetConference(This,ppConference)	\
    (This)->lpVtbl -> GetConference(This,ppConference)

#define INmMember_GetNmchCaps(This,puchCaps)	\
    (This)->lpVtbl -> GetNmchCaps(This,puchCaps)

#define INmMember_GetShareState(This,puState)	\
    (This)->lpVtbl -> GetShareState(This,puState)

#define INmMember_IsSelf(This)	\
    (This)->lpVtbl -> IsSelf(This)

#define INmMember_IsMCU(This)	\
    (This)->lpVtbl -> IsMCU(This)

#define INmMember_Eject(This)	\
    (This)->lpVtbl -> Eject(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INmMember_GetName_Proxy( 
    INmMember __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB INmMember_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmMember_GetID_Proxy( 
    INmMember __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puID);


void __RPC_STUB INmMember_GetID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmMember_GetNmVersion_Proxy( 
    INmMember __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puVersion);


void __RPC_STUB INmMember_GetNmVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmMember_GetAddr_Proxy( 
    INmMember __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrAddr,
    /* [out] */ NM_ADDR_TYPE __RPC_FAR *puType);


void __RPC_STUB INmMember_GetAddr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmMember_GetUserData_Proxy( 
    INmMember __RPC_FAR * This,
    /* [in] */ REFGUID rguid,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppb,
    /* [out] */ ULONG __RPC_FAR *pcb);


void __RPC_STUB INmMember_GetUserData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmMember_GetConference_Proxy( 
    INmMember __RPC_FAR * This,
    /* [out] */ INmConference __RPC_FAR *__RPC_FAR *ppConference);


void __RPC_STUB INmMember_GetConference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmMember_GetNmchCaps_Proxy( 
    INmMember __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puchCaps);


void __RPC_STUB INmMember_GetNmchCaps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmMember_GetShareState_Proxy( 
    INmMember __RPC_FAR * This,
    /* [out] */ NM_SHARE_STATE __RPC_FAR *puState);


void __RPC_STUB INmMember_GetShareState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmMember_IsSelf_Proxy( 
    INmMember __RPC_FAR * This);


void __RPC_STUB INmMember_IsSelf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmMember_IsMCU_Proxy( 
    INmMember __RPC_FAR * This);


void __RPC_STUB INmMember_IsMCU_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmMember_Eject_Proxy( 
    INmMember __RPC_FAR * This);


void __RPC_STUB INmMember_Eject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INmMember_INTERFACE_DEFINED__ */


#ifndef __INmChannel_INTERFACE_DEFINED__
#define __INmChannel_INTERFACE_DEFINED__

/* interface INmChannel */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INmChannel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B0720-718C-11d0-8B1A-00A0C91BC90E")
    INmChannel : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsSameAs( 
            /* [in] */ INmChannel __RPC_FAR *pChannel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsActive( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActive( 
            /* [in] */ BOOL fActive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConference( 
            /* [out] */ INmConference __RPC_FAR *__RPC_FAR *ppConference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInterface( 
            /* [out] */ IID __RPC_FAR *piid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNmch( 
            /* [out] */ ULONG __RPC_FAR *puCh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumMember( 
            /* [out] */ IEnumNmMember __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMemberCount( 
            /* [out] */ ULONG __RPC_FAR *puCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INmChannelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INmChannel __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INmChannel __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INmChannel __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsSameAs )( 
            INmChannel __RPC_FAR * This,
            /* [in] */ INmChannel __RPC_FAR *pChannel);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsActive )( 
            INmChannel __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetActive )( 
            INmChannel __RPC_FAR * This,
            /* [in] */ BOOL fActive);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConference )( 
            INmChannel __RPC_FAR * This,
            /* [out] */ INmConference __RPC_FAR *__RPC_FAR *ppConference);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterface )( 
            INmChannel __RPC_FAR * This,
            /* [out] */ IID __RPC_FAR *piid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNmch )( 
            INmChannel __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puCh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumMember )( 
            INmChannel __RPC_FAR * This,
            /* [out] */ IEnumNmMember __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMemberCount )( 
            INmChannel __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puCount);
        
        END_INTERFACE
    } INmChannelVtbl;

    interface INmChannel
    {
        CONST_VTBL struct INmChannelVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INmChannel_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INmChannel_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INmChannel_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INmChannel_IsSameAs(This,pChannel)	\
    (This)->lpVtbl -> IsSameAs(This,pChannel)

#define INmChannel_IsActive(This)	\
    (This)->lpVtbl -> IsActive(This)

#define INmChannel_SetActive(This,fActive)	\
    (This)->lpVtbl -> SetActive(This,fActive)

#define INmChannel_GetConference(This,ppConference)	\
    (This)->lpVtbl -> GetConference(This,ppConference)

#define INmChannel_GetInterface(This,piid)	\
    (This)->lpVtbl -> GetInterface(This,piid)

#define INmChannel_GetNmch(This,puCh)	\
    (This)->lpVtbl -> GetNmch(This,puCh)

#define INmChannel_EnumMember(This,ppEnum)	\
    (This)->lpVtbl -> EnumMember(This,ppEnum)

#define INmChannel_GetMemberCount(This,puCount)	\
    (This)->lpVtbl -> GetMemberCount(This,puCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INmChannel_IsSameAs_Proxy( 
    INmChannel __RPC_FAR * This,
    /* [in] */ INmChannel __RPC_FAR *pChannel);


void __RPC_STUB INmChannel_IsSameAs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmChannel_IsActive_Proxy( 
    INmChannel __RPC_FAR * This);


void __RPC_STUB INmChannel_IsActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmChannel_SetActive_Proxy( 
    INmChannel __RPC_FAR * This,
    /* [in] */ BOOL fActive);


void __RPC_STUB INmChannel_SetActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmChannel_GetConference_Proxy( 
    INmChannel __RPC_FAR * This,
    /* [out] */ INmConference __RPC_FAR *__RPC_FAR *ppConference);


void __RPC_STUB INmChannel_GetConference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmChannel_GetInterface_Proxy( 
    INmChannel __RPC_FAR * This,
    /* [out] */ IID __RPC_FAR *piid);


void __RPC_STUB INmChannel_GetInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmChannel_GetNmch_Proxy( 
    INmChannel __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puCh);


void __RPC_STUB INmChannel_GetNmch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmChannel_EnumMember_Proxy( 
    INmChannel __RPC_FAR * This,
    /* [out] */ IEnumNmMember __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB INmChannel_EnumMember_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmChannel_GetMemberCount_Proxy( 
    INmChannel __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puCount);


void __RPC_STUB INmChannel_GetMemberCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INmChannel_INTERFACE_DEFINED__ */


#ifndef __INmChannelNotify_INTERFACE_DEFINED__
#define __INmChannelNotify_INTERFACE_DEFINED__

/* interface INmChannelNotify */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INmChannelNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B0721-718C-11d0-8B1A-00A0C91BC90E")
    INmChannelNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NmUI( 
            /* [in] */ CONFN uNotify) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MemberChanged( 
            /* [in] */ NM_MEMBER_NOTIFY uNotify,
            /* [in] */ INmMember __RPC_FAR *pMember) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INmChannelNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INmChannelNotify __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INmChannelNotify __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INmChannelNotify __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NmUI )( 
            INmChannelNotify __RPC_FAR * This,
            /* [in] */ CONFN uNotify);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MemberChanged )( 
            INmChannelNotify __RPC_FAR * This,
            /* [in] */ NM_MEMBER_NOTIFY uNotify,
            /* [in] */ INmMember __RPC_FAR *pMember);
        
        END_INTERFACE
    } INmChannelNotifyVtbl;

    interface INmChannelNotify
    {
        CONST_VTBL struct INmChannelNotifyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INmChannelNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INmChannelNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INmChannelNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INmChannelNotify_NmUI(This,uNotify)	\
    (This)->lpVtbl -> NmUI(This,uNotify)

#define INmChannelNotify_MemberChanged(This,uNotify,pMember)	\
    (This)->lpVtbl -> MemberChanged(This,uNotify,pMember)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INmChannelNotify_NmUI_Proxy( 
    INmChannelNotify __RPC_FAR * This,
    /* [in] */ CONFN uNotify);


void __RPC_STUB INmChannelNotify_NmUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmChannelNotify_MemberChanged_Proxy( 
    INmChannelNotify __RPC_FAR * This,
    /* [in] */ NM_MEMBER_NOTIFY uNotify,
    /* [in] */ INmMember __RPC_FAR *pMember);


void __RPC_STUB INmChannelNotify_MemberChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INmChannelNotify_INTERFACE_DEFINED__ */


#ifndef __INmChannelData_INTERFACE_DEFINED__
#define __INmChannelData_INTERFACE_DEFINED__

/* interface INmChannelData */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INmChannelData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B0722-718C-11d0-8B1A-00A0C91BC90E")
    INmChannelData : public INmChannel
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetGuid( 
            /* [out] */ GUID __RPC_FAR *pguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendData( 
            /* [in] */ INmMember __RPC_FAR *pMember,
            /* [in] */ ULONG uSize,
            /* [size_is][in] */ byte __RPC_FAR *pvBuffer,
            /* [in] */ ULONG uOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INmChannelDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INmChannelData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INmChannelData __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INmChannelData __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsSameAs )( 
            INmChannelData __RPC_FAR * This,
            /* [in] */ INmChannel __RPC_FAR *pChannel);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsActive )( 
            INmChannelData __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetActive )( 
            INmChannelData __RPC_FAR * This,
            /* [in] */ BOOL fActive);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConference )( 
            INmChannelData __RPC_FAR * This,
            /* [out] */ INmConference __RPC_FAR *__RPC_FAR *ppConference);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterface )( 
            INmChannelData __RPC_FAR * This,
            /* [out] */ IID __RPC_FAR *piid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNmch )( 
            INmChannelData __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puCh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumMember )( 
            INmChannelData __RPC_FAR * This,
            /* [out] */ IEnumNmMember __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMemberCount )( 
            INmChannelData __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGuid )( 
            INmChannelData __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendData )( 
            INmChannelData __RPC_FAR * This,
            /* [in] */ INmMember __RPC_FAR *pMember,
            /* [in] */ ULONG uSize,
            /* [size_is][in] */ byte __RPC_FAR *pvBuffer,
            /* [in] */ ULONG uOptions);
        
        END_INTERFACE
    } INmChannelDataVtbl;

    interface INmChannelData
    {
        CONST_VTBL struct INmChannelDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INmChannelData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INmChannelData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INmChannelData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INmChannelData_IsSameAs(This,pChannel)	\
    (This)->lpVtbl -> IsSameAs(This,pChannel)

#define INmChannelData_IsActive(This)	\
    (This)->lpVtbl -> IsActive(This)

#define INmChannelData_SetActive(This,fActive)	\
    (This)->lpVtbl -> SetActive(This,fActive)

#define INmChannelData_GetConference(This,ppConference)	\
    (This)->lpVtbl -> GetConference(This,ppConference)

#define INmChannelData_GetInterface(This,piid)	\
    (This)->lpVtbl -> GetInterface(This,piid)

#define INmChannelData_GetNmch(This,puCh)	\
    (This)->lpVtbl -> GetNmch(This,puCh)

#define INmChannelData_EnumMember(This,ppEnum)	\
    (This)->lpVtbl -> EnumMember(This,ppEnum)

#define INmChannelData_GetMemberCount(This,puCount)	\
    (This)->lpVtbl -> GetMemberCount(This,puCount)


#define INmChannelData_GetGuid(This,pguid)	\
    (This)->lpVtbl -> GetGuid(This,pguid)

#define INmChannelData_SendData(This,pMember,uSize,pvBuffer,uOptions)	\
    (This)->lpVtbl -> SendData(This,pMember,uSize,pvBuffer,uOptions)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INmChannelData_GetGuid_Proxy( 
    INmChannelData __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pguid);


void __RPC_STUB INmChannelData_GetGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmChannelData_SendData_Proxy( 
    INmChannelData __RPC_FAR * This,
    /* [in] */ INmMember __RPC_FAR *pMember,
    /* [in] */ ULONG uSize,
    /* [size_is][in] */ byte __RPC_FAR *pvBuffer,
    /* [in] */ ULONG uOptions);


void __RPC_STUB INmChannelData_SendData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INmChannelData_INTERFACE_DEFINED__ */


#ifndef __INmChannelDataNotify_INTERFACE_DEFINED__
#define __INmChannelDataNotify_INTERFACE_DEFINED__

/* interface INmChannelDataNotify */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INmChannelDataNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B0723-718C-11d0-8B1A-00A0C91BC90E")
    INmChannelDataNotify : public INmChannelNotify
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DataSent( 
            /* [in] */ INmMember __RPC_FAR *pMember,
            /* [in] */ ULONG uSize,
            /* [size_is][in] */ byte __RPC_FAR *pvBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DataReceived( 
            /* [in] */ INmMember __RPC_FAR *pMember,
            /* [in] */ ULONG uSize,
            /* [size_is][in] */ byte __RPC_FAR *pvBuffer,
            /* [in] */ ULONG dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INmChannelDataNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INmChannelDataNotify __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INmChannelDataNotify __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INmChannelDataNotify __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NmUI )( 
            INmChannelDataNotify __RPC_FAR * This,
            /* [in] */ CONFN uNotify);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MemberChanged )( 
            INmChannelDataNotify __RPC_FAR * This,
            /* [in] */ NM_MEMBER_NOTIFY uNotify,
            /* [in] */ INmMember __RPC_FAR *pMember);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DataSent )( 
            INmChannelDataNotify __RPC_FAR * This,
            /* [in] */ INmMember __RPC_FAR *pMember,
            /* [in] */ ULONG uSize,
            /* [size_is][in] */ byte __RPC_FAR *pvBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DataReceived )( 
            INmChannelDataNotify __RPC_FAR * This,
            /* [in] */ INmMember __RPC_FAR *pMember,
            /* [in] */ ULONG uSize,
            /* [size_is][in] */ byte __RPC_FAR *pvBuffer,
            /* [in] */ ULONG dwFlags);
        
        END_INTERFACE
    } INmChannelDataNotifyVtbl;

    interface INmChannelDataNotify
    {
        CONST_VTBL struct INmChannelDataNotifyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INmChannelDataNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INmChannelDataNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INmChannelDataNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INmChannelDataNotify_NmUI(This,uNotify)	\
    (This)->lpVtbl -> NmUI(This,uNotify)

#define INmChannelDataNotify_MemberChanged(This,uNotify,pMember)	\
    (This)->lpVtbl -> MemberChanged(This,uNotify,pMember)


#define INmChannelDataNotify_DataSent(This,pMember,uSize,pvBuffer)	\
    (This)->lpVtbl -> DataSent(This,pMember,uSize,pvBuffer)

#define INmChannelDataNotify_DataReceived(This,pMember,uSize,pvBuffer,dwFlags)	\
    (This)->lpVtbl -> DataReceived(This,pMember,uSize,pvBuffer,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INmChannelDataNotify_DataSent_Proxy( 
    INmChannelDataNotify __RPC_FAR * This,
    /* [in] */ INmMember __RPC_FAR *pMember,
    /* [in] */ ULONG uSize,
    /* [size_is][in] */ byte __RPC_FAR *pvBuffer);


void __RPC_STUB INmChannelDataNotify_DataSent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmChannelDataNotify_DataReceived_Proxy( 
    INmChannelDataNotify __RPC_FAR * This,
    /* [in] */ INmMember __RPC_FAR *pMember,
    /* [in] */ ULONG uSize,
    /* [size_is][in] */ byte __RPC_FAR *pvBuffer,
    /* [in] */ ULONG dwFlags);


void __RPC_STUB INmChannelDataNotify_DataReceived_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INmChannelDataNotify_INTERFACE_DEFINED__ */


#ifndef __INmChannelAudio_INTERFACE_DEFINED__
#define __INmChannelAudio_INTERFACE_DEFINED__

/* interface INmChannelAudio */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INmChannelAudio;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B0724-718C-11d0-8B1A-00A0C91BC90E")
    INmChannelAudio : public INmChannel
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsIncoming( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [out] */ NM_AUDIO_STATE __RPC_FAR *puState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ NM_AUDPROP uID,
            /* [out] */ ULONG __RPC_FAR *puValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ NM_AUDPROP uID,
            /* [in] */ ULONG uValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INmChannelAudioVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INmChannelAudio __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INmChannelAudio __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INmChannelAudio __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsSameAs )( 
            INmChannelAudio __RPC_FAR * This,
            /* [in] */ INmChannel __RPC_FAR *pChannel);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsActive )( 
            INmChannelAudio __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetActive )( 
            INmChannelAudio __RPC_FAR * This,
            /* [in] */ BOOL fActive);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConference )( 
            INmChannelAudio __RPC_FAR * This,
            /* [out] */ INmConference __RPC_FAR *__RPC_FAR *ppConference);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterface )( 
            INmChannelAudio __RPC_FAR * This,
            /* [out] */ IID __RPC_FAR *piid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNmch )( 
            INmChannelAudio __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puCh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumMember )( 
            INmChannelAudio __RPC_FAR * This,
            /* [out] */ IEnumNmMember __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMemberCount )( 
            INmChannelAudio __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsIncoming )( 
            INmChannelAudio __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetState )( 
            INmChannelAudio __RPC_FAR * This,
            /* [out] */ NM_AUDIO_STATE __RPC_FAR *puState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            INmChannelAudio __RPC_FAR * This,
            /* [in] */ NM_AUDPROP uID,
            /* [out] */ ULONG __RPC_FAR *puValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProperty )( 
            INmChannelAudio __RPC_FAR * This,
            /* [in] */ NM_AUDPROP uID,
            /* [in] */ ULONG uValue);
        
        END_INTERFACE
    } INmChannelAudioVtbl;

    interface INmChannelAudio
    {
        CONST_VTBL struct INmChannelAudioVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INmChannelAudio_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INmChannelAudio_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INmChannelAudio_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INmChannelAudio_IsSameAs(This,pChannel)	\
    (This)->lpVtbl -> IsSameAs(This,pChannel)

#define INmChannelAudio_IsActive(This)	\
    (This)->lpVtbl -> IsActive(This)

#define INmChannelAudio_SetActive(This,fActive)	\
    (This)->lpVtbl -> SetActive(This,fActive)

#define INmChannelAudio_GetConference(This,ppConference)	\
    (This)->lpVtbl -> GetConference(This,ppConference)

#define INmChannelAudio_GetInterface(This,piid)	\
    (This)->lpVtbl -> GetInterface(This,piid)

#define INmChannelAudio_GetNmch(This,puCh)	\
    (This)->lpVtbl -> GetNmch(This,puCh)

#define INmChannelAudio_EnumMember(This,ppEnum)	\
    (This)->lpVtbl -> EnumMember(This,ppEnum)

#define INmChannelAudio_GetMemberCount(This,puCount)	\
    (This)->lpVtbl -> GetMemberCount(This,puCount)


#define INmChannelAudio_IsIncoming(This)	\
    (This)->lpVtbl -> IsIncoming(This)

#define INmChannelAudio_GetState(This,puState)	\
    (This)->lpVtbl -> GetState(This,puState)

#define INmChannelAudio_GetProperty(This,uID,puValue)	\
    (This)->lpVtbl -> GetProperty(This,uID,puValue)

#define INmChannelAudio_SetProperty(This,uID,uValue)	\
    (This)->lpVtbl -> SetProperty(This,uID,uValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INmChannelAudio_IsIncoming_Proxy( 
    INmChannelAudio __RPC_FAR * This);


void __RPC_STUB INmChannelAudio_IsIncoming_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmChannelAudio_GetState_Proxy( 
    INmChannelAudio __RPC_FAR * This,
    /* [out] */ NM_AUDIO_STATE __RPC_FAR *puState);


void __RPC_STUB INmChannelAudio_GetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmChannelAudio_GetProperty_Proxy( 
    INmChannelAudio __RPC_FAR * This,
    /* [in] */ NM_AUDPROP uID,
    /* [out] */ ULONG __RPC_FAR *puValue);


void __RPC_STUB INmChannelAudio_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmChannelAudio_SetProperty_Proxy( 
    INmChannelAudio __RPC_FAR * This,
    /* [in] */ NM_AUDPROP uID,
    /* [in] */ ULONG uValue);


void __RPC_STUB INmChannelAudio_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INmChannelAudio_INTERFACE_DEFINED__ */


#ifndef __INmChannelAudioNotify_INTERFACE_DEFINED__
#define __INmChannelAudioNotify_INTERFACE_DEFINED__

/* interface INmChannelAudioNotify */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INmChannelAudioNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B0725-718C-11d0-8B1A-00A0C91BC90E")
    INmChannelAudioNotify : public INmChannelNotify
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StateChanged( 
            /* [in] */ NM_AUDIO_STATE uState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PropertyChanged( 
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INmChannelAudioNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INmChannelAudioNotify __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INmChannelAudioNotify __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INmChannelAudioNotify __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NmUI )( 
            INmChannelAudioNotify __RPC_FAR * This,
            /* [in] */ CONFN uNotify);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MemberChanged )( 
            INmChannelAudioNotify __RPC_FAR * This,
            /* [in] */ NM_MEMBER_NOTIFY uNotify,
            /* [in] */ INmMember __RPC_FAR *pMember);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StateChanged )( 
            INmChannelAudioNotify __RPC_FAR * This,
            /* [in] */ NM_AUDIO_STATE uState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PropertyChanged )( 
            INmChannelAudioNotify __RPC_FAR * This,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } INmChannelAudioNotifyVtbl;

    interface INmChannelAudioNotify
    {
        CONST_VTBL struct INmChannelAudioNotifyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INmChannelAudioNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INmChannelAudioNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INmChannelAudioNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INmChannelAudioNotify_NmUI(This,uNotify)	\
    (This)->lpVtbl -> NmUI(This,uNotify)

#define INmChannelAudioNotify_MemberChanged(This,uNotify,pMember)	\
    (This)->lpVtbl -> MemberChanged(This,uNotify,pMember)


#define INmChannelAudioNotify_StateChanged(This,uState)	\
    (This)->lpVtbl -> StateChanged(This,uState)

#define INmChannelAudioNotify_PropertyChanged(This,dwReserved)	\
    (This)->lpVtbl -> PropertyChanged(This,dwReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INmChannelAudioNotify_StateChanged_Proxy( 
    INmChannelAudioNotify __RPC_FAR * This,
    /* [in] */ NM_AUDIO_STATE uState);


void __RPC_STUB INmChannelAudioNotify_StateChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmChannelAudioNotify_PropertyChanged_Proxy( 
    INmChannelAudioNotify __RPC_FAR * This,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB INmChannelAudioNotify_PropertyChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INmChannelAudioNotify_INTERFACE_DEFINED__ */


#ifndef __INmChannelVideo_INTERFACE_DEFINED__
#define __INmChannelVideo_INTERFACE_DEFINED__

/* interface INmChannelVideo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INmChannelVideo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B0726-718C-11d0-8B1A-00A0C91BC90E")
    INmChannelVideo : public INmChannel
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsIncoming( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [out] */ NM_VIDEO_STATE __RPC_FAR *puState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ NM_VIDPROP uID,
            /* [out] */ ULONG __RPC_FAR *puValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ NM_VIDPROP uID,
            /* [in] */ ULONG uValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INmChannelVideoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INmChannelVideo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INmChannelVideo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INmChannelVideo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsSameAs )( 
            INmChannelVideo __RPC_FAR * This,
            /* [in] */ INmChannel __RPC_FAR *pChannel);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsActive )( 
            INmChannelVideo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetActive )( 
            INmChannelVideo __RPC_FAR * This,
            /* [in] */ BOOL fActive);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConference )( 
            INmChannelVideo __RPC_FAR * This,
            /* [out] */ INmConference __RPC_FAR *__RPC_FAR *ppConference);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterface )( 
            INmChannelVideo __RPC_FAR * This,
            /* [out] */ IID __RPC_FAR *piid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNmch )( 
            INmChannelVideo __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puCh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumMember )( 
            INmChannelVideo __RPC_FAR * This,
            /* [out] */ IEnumNmMember __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMemberCount )( 
            INmChannelVideo __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsIncoming )( 
            INmChannelVideo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetState )( 
            INmChannelVideo __RPC_FAR * This,
            /* [out] */ NM_VIDEO_STATE __RPC_FAR *puState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            INmChannelVideo __RPC_FAR * This,
            /* [in] */ NM_VIDPROP uID,
            /* [out] */ ULONG __RPC_FAR *puValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProperty )( 
            INmChannelVideo __RPC_FAR * This,
            /* [in] */ NM_VIDPROP uID,
            /* [in] */ ULONG uValue);
        
        END_INTERFACE
    } INmChannelVideoVtbl;

    interface INmChannelVideo
    {
        CONST_VTBL struct INmChannelVideoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INmChannelVideo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INmChannelVideo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INmChannelVideo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INmChannelVideo_IsSameAs(This,pChannel)	\
    (This)->lpVtbl -> IsSameAs(This,pChannel)

#define INmChannelVideo_IsActive(This)	\
    (This)->lpVtbl -> IsActive(This)

#define INmChannelVideo_SetActive(This,fActive)	\
    (This)->lpVtbl -> SetActive(This,fActive)

#define INmChannelVideo_GetConference(This,ppConference)	\
    (This)->lpVtbl -> GetConference(This,ppConference)

#define INmChannelVideo_GetInterface(This,piid)	\
    (This)->lpVtbl -> GetInterface(This,piid)

#define INmChannelVideo_GetNmch(This,puCh)	\
    (This)->lpVtbl -> GetNmch(This,puCh)

#define INmChannelVideo_EnumMember(This,ppEnum)	\
    (This)->lpVtbl -> EnumMember(This,ppEnum)

#define INmChannelVideo_GetMemberCount(This,puCount)	\
    (This)->lpVtbl -> GetMemberCount(This,puCount)


#define INmChannelVideo_IsIncoming(This)	\
    (This)->lpVtbl -> IsIncoming(This)

#define INmChannelVideo_GetState(This,puState)	\
    (This)->lpVtbl -> GetState(This,puState)

#define INmChannelVideo_GetProperty(This,uID,puValue)	\
    (This)->lpVtbl -> GetProperty(This,uID,puValue)

#define INmChannelVideo_SetProperty(This,uID,uValue)	\
    (This)->lpVtbl -> SetProperty(This,uID,uValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INmChannelVideo_IsIncoming_Proxy( 
    INmChannelVideo __RPC_FAR * This);


void __RPC_STUB INmChannelVideo_IsIncoming_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmChannelVideo_GetState_Proxy( 
    INmChannelVideo __RPC_FAR * This,
    /* [out] */ NM_VIDEO_STATE __RPC_FAR *puState);


void __RPC_STUB INmChannelVideo_GetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmChannelVideo_GetProperty_Proxy( 
    INmChannelVideo __RPC_FAR * This,
    /* [in] */ NM_VIDPROP uID,
    /* [out] */ ULONG __RPC_FAR *puValue);


void __RPC_STUB INmChannelVideo_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmChannelVideo_SetProperty_Proxy( 
    INmChannelVideo __RPC_FAR * This,
    /* [in] */ NM_VIDPROP uID,
    /* [in] */ ULONG uValue);


void __RPC_STUB INmChannelVideo_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INmChannelVideo_INTERFACE_DEFINED__ */


#ifndef __INmChannelVideoNotify_INTERFACE_DEFINED__
#define __INmChannelVideoNotify_INTERFACE_DEFINED__

/* interface INmChannelVideoNotify */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INmChannelVideoNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B0727-718C-11d0-8B1A-00A0C91BC90E")
    INmChannelVideoNotify : public INmChannelNotify
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StateChanged( 
            /* [in] */ NM_VIDEO_STATE uState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PropertyChanged( 
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INmChannelVideoNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INmChannelVideoNotify __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INmChannelVideoNotify __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INmChannelVideoNotify __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NmUI )( 
            INmChannelVideoNotify __RPC_FAR * This,
            /* [in] */ CONFN uNotify);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MemberChanged )( 
            INmChannelVideoNotify __RPC_FAR * This,
            /* [in] */ NM_MEMBER_NOTIFY uNotify,
            /* [in] */ INmMember __RPC_FAR *pMember);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StateChanged )( 
            INmChannelVideoNotify __RPC_FAR * This,
            /* [in] */ NM_VIDEO_STATE uState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PropertyChanged )( 
            INmChannelVideoNotify __RPC_FAR * This,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } INmChannelVideoNotifyVtbl;

    interface INmChannelVideoNotify
    {
        CONST_VTBL struct INmChannelVideoNotifyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INmChannelVideoNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INmChannelVideoNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INmChannelVideoNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INmChannelVideoNotify_NmUI(This,uNotify)	\
    (This)->lpVtbl -> NmUI(This,uNotify)

#define INmChannelVideoNotify_MemberChanged(This,uNotify,pMember)	\
    (This)->lpVtbl -> MemberChanged(This,uNotify,pMember)


#define INmChannelVideoNotify_StateChanged(This,uState)	\
    (This)->lpVtbl -> StateChanged(This,uState)

#define INmChannelVideoNotify_PropertyChanged(This,dwReserved)	\
    (This)->lpVtbl -> PropertyChanged(This,dwReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INmChannelVideoNotify_StateChanged_Proxy( 
    INmChannelVideoNotify __RPC_FAR * This,
    /* [in] */ NM_VIDEO_STATE uState);


void __RPC_STUB INmChannelVideoNotify_StateChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmChannelVideoNotify_PropertyChanged_Proxy( 
    INmChannelVideoNotify __RPC_FAR * This,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB INmChannelVideoNotify_PropertyChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INmChannelVideoNotify_INTERFACE_DEFINED__ */


#ifndef __INmChannelFt_INTERFACE_DEFINED__
#define __INmChannelFt_INTERFACE_DEFINED__

/* interface INmChannelFt */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INmChannelFt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B0728-718C-11d0-8B1A-00A0C91BC90E")
    INmChannelFt : public INmChannel
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SendFile( 
            /* [out] */ INmFt __RPC_FAR *__RPC_FAR *ppFt,
            /* [in] */ INmMember __RPC_FAR *pMember,
            /* [in] */ BSTR bstrFile,
            /* [in] */ ULONG uOptions) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetReceiveFileDir( 
            /* [in] */ BSTR bstrDir) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReceiveFileDir( 
            /* [out] */ BSTR __RPC_FAR *pbstrDir) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INmChannelFtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INmChannelFt __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INmChannelFt __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INmChannelFt __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsSameAs )( 
            INmChannelFt __RPC_FAR * This,
            /* [in] */ INmChannel __RPC_FAR *pChannel);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsActive )( 
            INmChannelFt __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetActive )( 
            INmChannelFt __RPC_FAR * This,
            /* [in] */ BOOL fActive);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConference )( 
            INmChannelFt __RPC_FAR * This,
            /* [out] */ INmConference __RPC_FAR *__RPC_FAR *ppConference);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterface )( 
            INmChannelFt __RPC_FAR * This,
            /* [out] */ IID __RPC_FAR *piid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNmch )( 
            INmChannelFt __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puCh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumMember )( 
            INmChannelFt __RPC_FAR * This,
            /* [out] */ IEnumNmMember __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMemberCount )( 
            INmChannelFt __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puCount);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendFile )( 
            INmChannelFt __RPC_FAR * This,
            /* [out] */ INmFt __RPC_FAR *__RPC_FAR *ppFt,
            /* [in] */ INmMember __RPC_FAR *pMember,
            /* [in] */ BSTR bstrFile,
            /* [in] */ ULONG uOptions);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetReceiveFileDir )( 
            INmChannelFt __RPC_FAR * This,
            /* [in] */ BSTR bstrDir);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReceiveFileDir )( 
            INmChannelFt __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrDir);
        
        END_INTERFACE
    } INmChannelFtVtbl;

    interface INmChannelFt
    {
        CONST_VTBL struct INmChannelFtVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INmChannelFt_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INmChannelFt_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INmChannelFt_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INmChannelFt_IsSameAs(This,pChannel)	\
    (This)->lpVtbl -> IsSameAs(This,pChannel)

#define INmChannelFt_IsActive(This)	\
    (This)->lpVtbl -> IsActive(This)

#define INmChannelFt_SetActive(This,fActive)	\
    (This)->lpVtbl -> SetActive(This,fActive)

#define INmChannelFt_GetConference(This,ppConference)	\
    (This)->lpVtbl -> GetConference(This,ppConference)

#define INmChannelFt_GetInterface(This,piid)	\
    (This)->lpVtbl -> GetInterface(This,piid)

#define INmChannelFt_GetNmch(This,puCh)	\
    (This)->lpVtbl -> GetNmch(This,puCh)

#define INmChannelFt_EnumMember(This,ppEnum)	\
    (This)->lpVtbl -> EnumMember(This,ppEnum)

#define INmChannelFt_GetMemberCount(This,puCount)	\
    (This)->lpVtbl -> GetMemberCount(This,puCount)


#define INmChannelFt_SendFile(This,ppFt,pMember,bstrFile,uOptions)	\
    (This)->lpVtbl -> SendFile(This,ppFt,pMember,bstrFile,uOptions)

#define INmChannelFt_SetReceiveFileDir(This,bstrDir)	\
    (This)->lpVtbl -> SetReceiveFileDir(This,bstrDir)

#define INmChannelFt_GetReceiveFileDir(This,pbstrDir)	\
    (This)->lpVtbl -> GetReceiveFileDir(This,pbstrDir)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE INmChannelFt_RemoteSendFile_Proxy( 
    INmChannelFt __RPC_FAR * This,
    /* [out] */ INmFt __RPC_FAR *__RPC_FAR *ppFt,
    /* [in] */ INmMember __RPC_FAR *pMember,
    /* [in] */ BSTR bstrFile,
    /* [in] */ ULONG uOptions);


void __RPC_STUB INmChannelFt_RemoteSendFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmChannelFt_RemoteSetReceiveFileDir_Proxy( 
    INmChannelFt __RPC_FAR * This,
    /* [in] */ BSTR bstrDir);


void __RPC_STUB INmChannelFt_RemoteSetReceiveFileDir_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmChannelFt_GetReceiveFileDir_Proxy( 
    INmChannelFt __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrDir);


void __RPC_STUB INmChannelFt_GetReceiveFileDir_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INmChannelFt_INTERFACE_DEFINED__ */


#ifndef __INmChannelFtNotify_INTERFACE_DEFINED__
#define __INmChannelFtNotify_INTERFACE_DEFINED__

/* interface INmChannelFtNotify */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INmChannelFtNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B0729-718C-11d0-8B1A-00A0C91BC90E")
    INmChannelFtNotify : public INmChannelNotify
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FtUpdate( 
            /* [in] */ CONFN uNotify,
            /* [in] */ INmFt __RPC_FAR *pFt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INmChannelFtNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INmChannelFtNotify __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INmChannelFtNotify __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INmChannelFtNotify __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NmUI )( 
            INmChannelFtNotify __RPC_FAR * This,
            /* [in] */ CONFN uNotify);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MemberChanged )( 
            INmChannelFtNotify __RPC_FAR * This,
            /* [in] */ NM_MEMBER_NOTIFY uNotify,
            /* [in] */ INmMember __RPC_FAR *pMember);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FtUpdate )( 
            INmChannelFtNotify __RPC_FAR * This,
            /* [in] */ CONFN uNotify,
            /* [in] */ INmFt __RPC_FAR *pFt);
        
        END_INTERFACE
    } INmChannelFtNotifyVtbl;

    interface INmChannelFtNotify
    {
        CONST_VTBL struct INmChannelFtNotifyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INmChannelFtNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INmChannelFtNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INmChannelFtNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INmChannelFtNotify_NmUI(This,uNotify)	\
    (This)->lpVtbl -> NmUI(This,uNotify)

#define INmChannelFtNotify_MemberChanged(This,uNotify,pMember)	\
    (This)->lpVtbl -> MemberChanged(This,uNotify,pMember)


#define INmChannelFtNotify_FtUpdate(This,uNotify,pFt)	\
    (This)->lpVtbl -> FtUpdate(This,uNotify,pFt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INmChannelFtNotify_FtUpdate_Proxy( 
    INmChannelFtNotify __RPC_FAR * This,
    /* [in] */ CONFN uNotify,
    /* [in] */ INmFt __RPC_FAR *pFt);


void __RPC_STUB INmChannelFtNotify_FtUpdate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INmChannelFtNotify_INTERFACE_DEFINED__ */


#ifndef __INmFt_INTERFACE_DEFINED__
#define __INmFt_INTERFACE_DEFINED__

/* interface INmFt */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INmFt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B0732-718C-11d0-8B1A-00A0C91BC90E")
    INmFt : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsIncoming( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [out] */ NM_FT_STATE __RPC_FAR *puState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ ULONG __RPC_FAR *puBytes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBytesTransferred( 
            /* [out] */ ULONG __RPC_FAR *puBytes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMember( 
            /* [out] */ INmMember __RPC_FAR *__RPC_FAR *ppMember) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INmFtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INmFt __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INmFt __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INmFt __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsIncoming )( 
            INmFt __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetState )( 
            INmFt __RPC_FAR * This,
            /* [out] */ NM_FT_STATE __RPC_FAR *puState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            INmFt __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSize )( 
            INmFt __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puBytes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBytesTransferred )( 
            INmFt __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puBytes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMember )( 
            INmFt __RPC_FAR * This,
            /* [out] */ INmMember __RPC_FAR *__RPC_FAR *ppMember);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Cancel )( 
            INmFt __RPC_FAR * This);
        
        END_INTERFACE
    } INmFtVtbl;

    interface INmFt
    {
        CONST_VTBL struct INmFtVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INmFt_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INmFt_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INmFt_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INmFt_IsIncoming(This)	\
    (This)->lpVtbl -> IsIncoming(This)

#define INmFt_GetState(This,puState)	\
    (This)->lpVtbl -> GetState(This,puState)

#define INmFt_GetName(This,pbstrName)	\
    (This)->lpVtbl -> GetName(This,pbstrName)

#define INmFt_GetSize(This,puBytes)	\
    (This)->lpVtbl -> GetSize(This,puBytes)

#define INmFt_GetBytesTransferred(This,puBytes)	\
    (This)->lpVtbl -> GetBytesTransferred(This,puBytes)

#define INmFt_GetMember(This,ppMember)	\
    (This)->lpVtbl -> GetMember(This,ppMember)

#define INmFt_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INmFt_IsIncoming_Proxy( 
    INmFt __RPC_FAR * This);


void __RPC_STUB INmFt_IsIncoming_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmFt_GetState_Proxy( 
    INmFt __RPC_FAR * This,
    /* [out] */ NM_FT_STATE __RPC_FAR *puState);


void __RPC_STUB INmFt_GetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmFt_GetName_Proxy( 
    INmFt __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB INmFt_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmFt_GetSize_Proxy( 
    INmFt __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puBytes);


void __RPC_STUB INmFt_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmFt_GetBytesTransferred_Proxy( 
    INmFt __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puBytes);


void __RPC_STUB INmFt_GetBytesTransferred_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmFt_GetMember_Proxy( 
    INmFt __RPC_FAR * This,
    /* [out] */ INmMember __RPC_FAR *__RPC_FAR *ppMember);


void __RPC_STUB INmFt_GetMember_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmFt_Cancel_Proxy( 
    INmFt __RPC_FAR * This);


void __RPC_STUB INmFt_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INmFt_INTERFACE_DEFINED__ */


#ifndef __INmChannelAppShare_INTERFACE_DEFINED__
#define __INmChannelAppShare_INTERFACE_DEFINED__

/* interface INmChannelAppShare */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INmChannelAppShare;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B072A-718C-11d0-8B1A-00A0C91BC90E")
    INmChannelAppShare : public INmChannel
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [out] */ NM_SHARE_STATE __RPC_FAR *puState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetState( 
            /* [in] */ NM_SHARE_STATE uState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumSharableApp( 
            /* [out] */ IEnumNmSharableApp __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INmChannelAppShareVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INmChannelAppShare __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INmChannelAppShare __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INmChannelAppShare __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsSameAs )( 
            INmChannelAppShare __RPC_FAR * This,
            /* [in] */ INmChannel __RPC_FAR *pChannel);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsActive )( 
            INmChannelAppShare __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetActive )( 
            INmChannelAppShare __RPC_FAR * This,
            /* [in] */ BOOL fActive);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConference )( 
            INmChannelAppShare __RPC_FAR * This,
            /* [out] */ INmConference __RPC_FAR *__RPC_FAR *ppConference);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterface )( 
            INmChannelAppShare __RPC_FAR * This,
            /* [out] */ IID __RPC_FAR *piid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNmch )( 
            INmChannelAppShare __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puCh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumMember )( 
            INmChannelAppShare __RPC_FAR * This,
            /* [out] */ IEnumNmMember __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMemberCount )( 
            INmChannelAppShare __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetState )( 
            INmChannelAppShare __RPC_FAR * This,
            /* [out] */ NM_SHARE_STATE __RPC_FAR *puState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetState )( 
            INmChannelAppShare __RPC_FAR * This,
            /* [in] */ NM_SHARE_STATE uState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumSharableApp )( 
            INmChannelAppShare __RPC_FAR * This,
            /* [out] */ IEnumNmSharableApp __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } INmChannelAppShareVtbl;

    interface INmChannelAppShare
    {
        CONST_VTBL struct INmChannelAppShareVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INmChannelAppShare_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INmChannelAppShare_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INmChannelAppShare_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INmChannelAppShare_IsSameAs(This,pChannel)	\
    (This)->lpVtbl -> IsSameAs(This,pChannel)

#define INmChannelAppShare_IsActive(This)	\
    (This)->lpVtbl -> IsActive(This)

#define INmChannelAppShare_SetActive(This,fActive)	\
    (This)->lpVtbl -> SetActive(This,fActive)

#define INmChannelAppShare_GetConference(This,ppConference)	\
    (This)->lpVtbl -> GetConference(This,ppConference)

#define INmChannelAppShare_GetInterface(This,piid)	\
    (This)->lpVtbl -> GetInterface(This,piid)

#define INmChannelAppShare_GetNmch(This,puCh)	\
    (This)->lpVtbl -> GetNmch(This,puCh)

#define INmChannelAppShare_EnumMember(This,ppEnum)	\
    (This)->lpVtbl -> EnumMember(This,ppEnum)

#define INmChannelAppShare_GetMemberCount(This,puCount)	\
    (This)->lpVtbl -> GetMemberCount(This,puCount)


#define INmChannelAppShare_GetState(This,puState)	\
    (This)->lpVtbl -> GetState(This,puState)

#define INmChannelAppShare_SetState(This,uState)	\
    (This)->lpVtbl -> SetState(This,uState)

#define INmChannelAppShare_EnumSharableApp(This,ppEnum)	\
    (This)->lpVtbl -> EnumSharableApp(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INmChannelAppShare_GetState_Proxy( 
    INmChannelAppShare __RPC_FAR * This,
    /* [out] */ NM_SHARE_STATE __RPC_FAR *puState);


void __RPC_STUB INmChannelAppShare_GetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmChannelAppShare_SetState_Proxy( 
    INmChannelAppShare __RPC_FAR * This,
    /* [in] */ NM_SHARE_STATE uState);


void __RPC_STUB INmChannelAppShare_SetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmChannelAppShare_EnumSharableApp_Proxy( 
    INmChannelAppShare __RPC_FAR * This,
    /* [out] */ IEnumNmSharableApp __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB INmChannelAppShare_EnumSharableApp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INmChannelAppShare_INTERFACE_DEFINED__ */


#ifndef __INmChannelAppShareNotify_INTERFACE_DEFINED__
#define __INmChannelAppShareNotify_INTERFACE_DEFINED__

/* interface INmChannelAppShareNotify */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INmChannelAppShareNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B072B-718C-11d0-8B1A-00A0C91BC90E")
    INmChannelAppShareNotify : public INmChannelNotify
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StateChanged( 
            /* [in] */ NM_SHAPP_STATE uState,
            /* [in] */ INmSharableApp __RPC_FAR *pApp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INmChannelAppShareNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INmChannelAppShareNotify __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INmChannelAppShareNotify __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INmChannelAppShareNotify __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NmUI )( 
            INmChannelAppShareNotify __RPC_FAR * This,
            /* [in] */ CONFN uNotify);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MemberChanged )( 
            INmChannelAppShareNotify __RPC_FAR * This,
            /* [in] */ NM_MEMBER_NOTIFY uNotify,
            /* [in] */ INmMember __RPC_FAR *pMember);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StateChanged )( 
            INmChannelAppShareNotify __RPC_FAR * This,
            /* [in] */ NM_SHAPP_STATE uState,
            /* [in] */ INmSharableApp __RPC_FAR *pApp);
        
        END_INTERFACE
    } INmChannelAppShareNotifyVtbl;

    interface INmChannelAppShareNotify
    {
        CONST_VTBL struct INmChannelAppShareNotifyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INmChannelAppShareNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INmChannelAppShareNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INmChannelAppShareNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INmChannelAppShareNotify_NmUI(This,uNotify)	\
    (This)->lpVtbl -> NmUI(This,uNotify)

#define INmChannelAppShareNotify_MemberChanged(This,uNotify,pMember)	\
    (This)->lpVtbl -> MemberChanged(This,uNotify,pMember)


#define INmChannelAppShareNotify_StateChanged(This,uState,pApp)	\
    (This)->lpVtbl -> StateChanged(This,uState,pApp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INmChannelAppShareNotify_StateChanged_Proxy( 
    INmChannelAppShareNotify __RPC_FAR * This,
    /* [in] */ NM_SHAPP_STATE uState,
    /* [in] */ INmSharableApp __RPC_FAR *pApp);


void __RPC_STUB INmChannelAppShareNotify_StateChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INmChannelAppShareNotify_INTERFACE_DEFINED__ */


#ifndef __INmSharableApp_INTERFACE_DEFINED__
#define __INmSharableApp_INTERFACE_DEFINED__

/* interface INmSharableApp */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INmSharableApp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B0734-718C-11d0-8B1A-00A0C91BC90E")
    INmSharableApp : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHwnd( 
            /* [out] */ HWND __RPC_FAR *phwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [out] */ NM_SHAPP_STATE __RPC_FAR *puState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetState( 
            /* [in] */ NM_SHAPP_STATE uState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INmSharableAppVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INmSharableApp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INmSharableApp __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INmSharableApp __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            INmSharableApp __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHwnd )( 
            INmSharableApp __RPC_FAR * This,
            /* [out] */ HWND __RPC_FAR *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetState )( 
            INmSharableApp __RPC_FAR * This,
            /* [out] */ NM_SHAPP_STATE __RPC_FAR *puState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetState )( 
            INmSharableApp __RPC_FAR * This,
            /* [in] */ NM_SHAPP_STATE uState);
        
        END_INTERFACE
    } INmSharableAppVtbl;

    interface INmSharableApp
    {
        CONST_VTBL struct INmSharableAppVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INmSharableApp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INmSharableApp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INmSharableApp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INmSharableApp_GetName(This,pbstrName)	\
    (This)->lpVtbl -> GetName(This,pbstrName)

#define INmSharableApp_GetHwnd(This,phwnd)	\
    (This)->lpVtbl -> GetHwnd(This,phwnd)

#define INmSharableApp_GetState(This,puState)	\
    (This)->lpVtbl -> GetState(This,puState)

#define INmSharableApp_SetState(This,uState)	\
    (This)->lpVtbl -> SetState(This,uState)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INmSharableApp_GetName_Proxy( 
    INmSharableApp __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB INmSharableApp_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmSharableApp_GetHwnd_Proxy( 
    INmSharableApp __RPC_FAR * This,
    /* [out] */ HWND __RPC_FAR *phwnd);


void __RPC_STUB INmSharableApp_GetHwnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmSharableApp_GetState_Proxy( 
    INmSharableApp __RPC_FAR * This,
    /* [out] */ NM_SHAPP_STATE __RPC_FAR *puState);


void __RPC_STUB INmSharableApp_GetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmSharableApp_SetState_Proxy( 
    INmSharableApp __RPC_FAR * This,
    /* [in] */ NM_SHAPP_STATE uState);


void __RPC_STUB INmSharableApp_SetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INmSharableApp_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imsconf2_0141 */
/* [local] */ 


////////////////////////////////////////////////////////////////////////////
//  Enumerator Definitions


extern RPC_IF_HANDLE __MIDL_itf_imsconf2_0141_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imsconf2_0141_v0_0_s_ifspec;

#ifndef __IEnumNmConference_INTERFACE_DEFINED__
#define __IEnumNmConference_INTERFACE_DEFINED__

/* interface IEnumNmConference */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumNmConference;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B0741-718C-11d0-8B1A-00A0C91BC90E")
    IEnumNmConference : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cConference,
            /* [out] */ INmConference __RPC_FAR *__RPC_FAR *rgpConference,
            /* [out] */ ULONG __RPC_FAR *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cConference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumNmConference __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumNmConferenceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumNmConference __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumNmConference __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumNmConference __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumNmConference __RPC_FAR * This,
            /* [in] */ ULONG cConference,
            /* [out] */ INmConference __RPC_FAR *__RPC_FAR *rgpConference,
            /* [out] */ ULONG __RPC_FAR *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumNmConference __RPC_FAR * This,
            /* [in] */ ULONG cConference);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumNmConference __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumNmConference __RPC_FAR * This,
            /* [out] */ IEnumNmConference __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumNmConferenceVtbl;

    interface IEnumNmConference
    {
        CONST_VTBL struct IEnumNmConferenceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumNmConference_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumNmConference_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumNmConference_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumNmConference_Next(This,cConference,rgpConference,pcFetched)	\
    (This)->lpVtbl -> Next(This,cConference,rgpConference,pcFetched)

#define IEnumNmConference_Skip(This,cConference)	\
    (This)->lpVtbl -> Skip(This,cConference)

#define IEnumNmConference_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumNmConference_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumNmConference_RemoteNext_Proxy( 
    IEnumNmConference __RPC_FAR * This,
    /* [in] */ ULONG cConference,
    /* [length_is][size_is][out] */ INmConference __RPC_FAR *__RPC_FAR *rgpConference,
    /* [out] */ ULONG __RPC_FAR *pcFetched,
    /* [out] */ ULONG __RPC_FAR *pcItems,
    /* [in] */ BOOL bGetNumberRemaining);


void __RPC_STUB IEnumNmConference_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNmConference_Skip_Proxy( 
    IEnumNmConference __RPC_FAR * This,
    /* [in] */ ULONG cConference);


void __RPC_STUB IEnumNmConference_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNmConference_Reset_Proxy( 
    IEnumNmConference __RPC_FAR * This);


void __RPC_STUB IEnumNmConference_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNmConference_Clone_Proxy( 
    IEnumNmConference __RPC_FAR * This,
    /* [out] */ IEnumNmConference __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumNmConference_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumNmConference_INTERFACE_DEFINED__ */


#ifndef __IEnumNmMember_INTERFACE_DEFINED__
#define __IEnumNmMember_INTERFACE_DEFINED__

/* interface IEnumNmMember */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumNmMember;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B0742-718C-11d0-8B1A-00A0C91BC90E")
    IEnumNmMember : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cMember,
            /* [out] */ INmMember __RPC_FAR *__RPC_FAR *rgpMember,
            /* [out] */ ULONG __RPC_FAR *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cMember) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumNmMember __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumNmMemberVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumNmMember __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumNmMember __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumNmMember __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumNmMember __RPC_FAR * This,
            /* [in] */ ULONG cMember,
            /* [out] */ INmMember __RPC_FAR *__RPC_FAR *rgpMember,
            /* [out] */ ULONG __RPC_FAR *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumNmMember __RPC_FAR * This,
            /* [in] */ ULONG cMember);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumNmMember __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumNmMember __RPC_FAR * This,
            /* [out] */ IEnumNmMember __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumNmMemberVtbl;

    interface IEnumNmMember
    {
        CONST_VTBL struct IEnumNmMemberVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumNmMember_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumNmMember_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumNmMember_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumNmMember_Next(This,cMember,rgpMember,pcFetched)	\
    (This)->lpVtbl -> Next(This,cMember,rgpMember,pcFetched)

#define IEnumNmMember_Skip(This,cMember)	\
    (This)->lpVtbl -> Skip(This,cMember)

#define IEnumNmMember_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumNmMember_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumNmMember_RemoteNext_Proxy( 
    IEnumNmMember __RPC_FAR * This,
    /* [in] */ ULONG cMember,
    /* [length_is][size_is][out] */ INmMember __RPC_FAR *__RPC_FAR *rgpMember,
    /* [out] */ ULONG __RPC_FAR *pcFetched,
    /* [out] */ ULONG __RPC_FAR *pcItems,
    /* [in] */ BOOL bGetNumberRemaining);


void __RPC_STUB IEnumNmMember_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNmMember_Skip_Proxy( 
    IEnumNmMember __RPC_FAR * This,
    /* [in] */ ULONG cMember);


void __RPC_STUB IEnumNmMember_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNmMember_Reset_Proxy( 
    IEnumNmMember __RPC_FAR * This);


void __RPC_STUB IEnumNmMember_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNmMember_Clone_Proxy( 
    IEnumNmMember __RPC_FAR * This,
    /* [out] */ IEnumNmMember __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumNmMember_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumNmMember_INTERFACE_DEFINED__ */


#ifndef __IEnumNmChannel_INTERFACE_DEFINED__
#define __IEnumNmChannel_INTERFACE_DEFINED__

/* interface IEnumNmChannel */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumNmChannel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B0743-718C-11d0-8B1A-00A0C91BC90E")
    IEnumNmChannel : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cChannel,
            /* [length_is][size_is][out] */ INmChannel __RPC_FAR *__RPC_FAR *rgpChannel,
            /* [out] */ ULONG __RPC_FAR *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cChannel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumNmChannel __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumNmChannelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumNmChannel __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumNmChannel __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumNmChannel __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumNmChannel __RPC_FAR * This,
            /* [in] */ ULONG cChannel,
            /* [length_is][size_is][out] */ INmChannel __RPC_FAR *__RPC_FAR *rgpChannel,
            /* [out] */ ULONG __RPC_FAR *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumNmChannel __RPC_FAR * This,
            /* [in] */ ULONG cChannel);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumNmChannel __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumNmChannel __RPC_FAR * This,
            /* [out] */ IEnumNmChannel __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumNmChannelVtbl;

    interface IEnumNmChannel
    {
        CONST_VTBL struct IEnumNmChannelVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumNmChannel_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumNmChannel_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumNmChannel_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumNmChannel_Next(This,cChannel,rgpChannel,pcFetched)	\
    (This)->lpVtbl -> Next(This,cChannel,rgpChannel,pcFetched)

#define IEnumNmChannel_Skip(This,cChannel)	\
    (This)->lpVtbl -> Skip(This,cChannel)

#define IEnumNmChannel_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumNmChannel_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumNmChannel_RemoteNext_Proxy( 
    IEnumNmChannel __RPC_FAR * This,
    /* [in] */ ULONG cChannel,
    /* [length_is][size_is][out] */ INmChannel __RPC_FAR *__RPC_FAR *rgpChannel,
    /* [out] */ ULONG __RPC_FAR *pcFetched,
    /* [out] */ ULONG __RPC_FAR *pcItems,
    /* [in] */ BOOL bGetNumberRemaining);


void __RPC_STUB IEnumNmChannel_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNmChannel_Skip_Proxy( 
    IEnumNmChannel __RPC_FAR * This,
    /* [in] */ ULONG cChannel);


void __RPC_STUB IEnumNmChannel_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNmChannel_Reset_Proxy( 
    IEnumNmChannel __RPC_FAR * This);


void __RPC_STUB IEnumNmChannel_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNmChannel_Clone_Proxy( 
    IEnumNmChannel __RPC_FAR * This,
    /* [out] */ IEnumNmChannel __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumNmChannel_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumNmChannel_INTERFACE_DEFINED__ */


#ifndef __IEnumNmCall_INTERFACE_DEFINED__
#define __IEnumNmCall_INTERFACE_DEFINED__

/* interface IEnumNmCall */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumNmCall;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B0744-718C-11d0-8B1A-00A0C91BC90E")
    IEnumNmCall : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cCall,
            /* [out] */ INmCall __RPC_FAR *__RPC_FAR *rgpCall,
            /* [out] */ ULONG __RPC_FAR *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cCall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumNmCall __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumNmCallVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumNmCall __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumNmCall __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumNmCall __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumNmCall __RPC_FAR * This,
            /* [in] */ ULONG cCall,
            /* [out] */ INmCall __RPC_FAR *__RPC_FAR *rgpCall,
            /* [out] */ ULONG __RPC_FAR *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumNmCall __RPC_FAR * This,
            /* [in] */ ULONG cCall);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumNmCall __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumNmCall __RPC_FAR * This,
            /* [out] */ IEnumNmCall __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumNmCallVtbl;

    interface IEnumNmCall
    {
        CONST_VTBL struct IEnumNmCallVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumNmCall_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumNmCall_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumNmCall_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumNmCall_Next(This,cCall,rgpCall,pcFetched)	\
    (This)->lpVtbl -> Next(This,cCall,rgpCall,pcFetched)

#define IEnumNmCall_Skip(This,cCall)	\
    (This)->lpVtbl -> Skip(This,cCall)

#define IEnumNmCall_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumNmCall_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumNmCall_RemoteNext_Proxy( 
    IEnumNmCall __RPC_FAR * This,
    /* [in] */ ULONG cCall,
    /* [length_is][size_is][out] */ INmCall __RPC_FAR *__RPC_FAR *rgpCall,
    /* [out] */ ULONG __RPC_FAR *pcFetched,
    /* [out] */ ULONG __RPC_FAR *pcItems,
    /* [in] */ BOOL bGetNumberRemaining);


void __RPC_STUB IEnumNmCall_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNmCall_Skip_Proxy( 
    IEnumNmCall __RPC_FAR * This,
    /* [in] */ ULONG cCall);


void __RPC_STUB IEnumNmCall_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNmCall_Reset_Proxy( 
    IEnumNmCall __RPC_FAR * This);


void __RPC_STUB IEnumNmCall_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNmCall_Clone_Proxy( 
    IEnumNmCall __RPC_FAR * This,
    /* [out] */ IEnumNmCall __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumNmCall_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumNmCall_INTERFACE_DEFINED__ */


#ifndef __IEnumNmSharableApp_INTERFACE_DEFINED__
#define __IEnumNmSharableApp_INTERFACE_DEFINED__

/* interface IEnumNmSharableApp */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumNmSharableApp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B0745-718C-11d0-8B1A-00A0C91BC90E")
    IEnumNmSharableApp : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cApp,
            /* [out] */ INmSharableApp __RPC_FAR *__RPC_FAR *rgpApp,
            /* [out] */ ULONG __RPC_FAR *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cApp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumNmSharableApp __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumNmSharableAppVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumNmSharableApp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumNmSharableApp __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumNmSharableApp __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumNmSharableApp __RPC_FAR * This,
            /* [in] */ ULONG cApp,
            /* [out] */ INmSharableApp __RPC_FAR *__RPC_FAR *rgpApp,
            /* [out] */ ULONG __RPC_FAR *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumNmSharableApp __RPC_FAR * This,
            /* [in] */ ULONG cApp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumNmSharableApp __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumNmSharableApp __RPC_FAR * This,
            /* [out] */ IEnumNmSharableApp __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumNmSharableAppVtbl;

    interface IEnumNmSharableApp
    {
        CONST_VTBL struct IEnumNmSharableAppVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumNmSharableApp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumNmSharableApp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumNmSharableApp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumNmSharableApp_Next(This,cApp,rgpApp,pcFetched)	\
    (This)->lpVtbl -> Next(This,cApp,rgpApp,pcFetched)

#define IEnumNmSharableApp_Skip(This,cApp)	\
    (This)->lpVtbl -> Skip(This,cApp)

#define IEnumNmSharableApp_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumNmSharableApp_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumNmSharableApp_RemoteNext_Proxy( 
    IEnumNmSharableApp __RPC_FAR * This,
    /* [in] */ ULONG cApp,
    /* [length_is][size_is][out] */ INmSharableApp __RPC_FAR *__RPC_FAR *rgpApp,
    /* [out] */ ULONG __RPC_FAR *pcFetched,
    /* [out] */ ULONG __RPC_FAR *pcItems,
    /* [in] */ BOOL bGetNumberRemaining);


void __RPC_STUB IEnumNmSharableApp_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNmSharableApp_Skip_Proxy( 
    IEnumNmSharableApp __RPC_FAR * This,
    /* [in] */ ULONG cApp);


void __RPC_STUB IEnumNmSharableApp_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNmSharableApp_Reset_Proxy( 
    IEnumNmSharableApp __RPC_FAR * This);


void __RPC_STUB IEnumNmSharableApp_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNmSharableApp_Clone_Proxy( 
    IEnumNmSharableApp __RPC_FAR * This,
    /* [out] */ IEnumNmSharableApp __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumNmSharableApp_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumNmSharableApp_INTERFACE_DEFINED__ */


#ifndef __INmObject_INTERFACE_DEFINED__
#define __INmObject_INTERFACE_DEFINED__

/* interface INmObject */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INmObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("068B0780-718C-11d0-8B1A-00A0C91BC90E")
    INmObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CallDialog( 
            /* [in] */ long hwnd,
            /* [in] */ int options) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowLocal( 
            /* [in] */ NM_APPID appId) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE VerifyUserInfo( 
            /* [in] */ long hwnd,
            /* [in] */ NM_VUI options) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INmObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INmObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INmObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INmObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CallDialog )( 
            INmObject __RPC_FAR * This,
            /* [in] */ long hwnd,
            /* [in] */ int options);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowLocal )( 
            INmObject __RPC_FAR * This,
            /* [in] */ NM_APPID appId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *VerifyUserInfo )( 
            INmObject __RPC_FAR * This,
            /* [in] */ long hwnd,
            /* [in] */ NM_VUI options);
        
        END_INTERFACE
    } INmObjectVtbl;

    interface INmObject
    {
        CONST_VTBL struct INmObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INmObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INmObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INmObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INmObject_CallDialog(This,hwnd,options)	\
    (This)->lpVtbl -> CallDialog(This,hwnd,options)

#define INmObject_ShowLocal(This,appId)	\
    (This)->lpVtbl -> ShowLocal(This,appId)

#define INmObject_VerifyUserInfo(This,hwnd,options)	\
    (This)->lpVtbl -> VerifyUserInfo(This,hwnd,options)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INmObject_CallDialog_Proxy( 
    INmObject __RPC_FAR * This,
    /* [in] */ long hwnd,
    /* [in] */ int options);


void __RPC_STUB INmObject_CallDialog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INmObject_ShowLocal_Proxy( 
    INmObject __RPC_FAR * This,
    /* [in] */ NM_APPID appId);


void __RPC_STUB INmObject_ShowLocal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmObject_RemoteVerifyUserInfo_Proxy( 
    INmObject __RPC_FAR * This,
    /* [in] */ long hwnd,
    /* [in] */ NM_VUI options);


void __RPC_STUB INmObject_RemoteVerifyUserInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INmObject_INTERFACE_DEFINED__ */



#ifndef __NmManager_LIBRARY_DEFINED__
#define __NmManager_LIBRARY_DEFINED__

/* library NmManager */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_NmManager;

EXTERN_C const CLSID CLSID_NmManager;

#ifdef __cplusplus

class DECLSPEC_UUID("068B0700-718C-11d0-8B1A-00A0C91BC90E")
NmManager;
#endif
#endif /* __NmManager_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE INmManager_Initialize_Proxy( 
    INmManager __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *puOptions,
    /* [out][in] */ ULONG __RPC_FAR *puchCaps);


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmManager_Initialize_Stub( 
    INmManager __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *puOptions,
    /* [out][in] */ ULONG __RPC_FAR *puchCaps);

/* [local] */ HRESULT STDMETHODCALLTYPE INmManager_CreateConference_Proxy( 
    INmManager __RPC_FAR * This,
    /* [out] */ INmConference __RPC_FAR *__RPC_FAR *ppConference,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrPassword,
    /* [in] */ ULONG uchCaps);


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmManager_CreateConference_Stub( 
    INmManager __RPC_FAR * This,
    /* [out] */ INmConference __RPC_FAR *__RPC_FAR *ppConference,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrPassword,
    /* [in] */ ULONG uchCaps);

/* [local] */ HRESULT STDMETHODCALLTYPE INmManager_CreateCall_Proxy( 
    INmManager __RPC_FAR * This,
    /* [out] */ INmCall __RPC_FAR *__RPC_FAR *ppCall,
    /* [in] */ NM_CALL_TYPE callType,
    /* [in] */ NM_ADDR_TYPE addrType,
    /* [in] */ BSTR bstrAddr,
    /* [in] */ INmConference __RPC_FAR *pConference);


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmManager_CreateCall_Stub( 
    INmManager __RPC_FAR * This,
    /* [out] */ INmCall __RPC_FAR *__RPC_FAR *ppCall,
    /* [in] */ NM_CALL_TYPE callType,
    /* [in] */ NM_ADDR_TYPE addrType,
    /* [in] */ BSTR bstrAddr,
    /* [in] */ INmConference __RPC_FAR *pConference);

/* [local] */ HRESULT STDMETHODCALLTYPE INmManager_CallConference_Proxy( 
    INmManager __RPC_FAR * This,
    /* [out] */ INmCall __RPC_FAR *__RPC_FAR *ppCall,
    /* [in] */ NM_CALL_TYPE callType,
    /* [in] */ NM_ADDR_TYPE addrType,
    /* [in] */ BSTR bstrAddr,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrPassword);


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmManager_CallConference_Stub( 
    INmManager __RPC_FAR * This,
    /* [out] */ INmCall __RPC_FAR *__RPC_FAR *ppCall,
    /* [in] */ NM_CALL_TYPE callType,
    /* [in] */ NM_ADDR_TYPE addrType,
    /* [in] */ BSTR bstrAddr,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrPassword);

/* [local] */ HRESULT STDMETHODCALLTYPE INmConference_CreateDataChannel_Proxy( 
    INmConference __RPC_FAR * This,
    /* [out] */ INmChannelData __RPC_FAR *__RPC_FAR *ppChannel,
    /* [in] */ REFGUID rguid);


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmConference_CreateDataChannel_Stub( 
    INmConference __RPC_FAR * This,
    /* [out] */ INmChannelData __RPC_FAR *__RPC_FAR *ppChannel,
    /* [in] */ REFGUID rguid);

/* [local] */ HRESULT STDMETHODCALLTYPE INmChannelFt_SendFile_Proxy( 
    INmChannelFt __RPC_FAR * This,
    /* [out] */ INmFt __RPC_FAR *__RPC_FAR *ppFt,
    /* [in] */ INmMember __RPC_FAR *pMember,
    /* [in] */ BSTR bstrFile,
    /* [in] */ ULONG uOptions);


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmChannelFt_SendFile_Stub( 
    INmChannelFt __RPC_FAR * This,
    /* [out] */ INmFt __RPC_FAR *__RPC_FAR *ppFt,
    /* [in] */ INmMember __RPC_FAR *pMember,
    /* [in] */ BSTR bstrFile,
    /* [in] */ ULONG uOptions);

/* [local] */ HRESULT STDMETHODCALLTYPE INmChannelFt_SetReceiveFileDir_Proxy( 
    INmChannelFt __RPC_FAR * This,
    /* [in] */ BSTR bstrDir);


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmChannelFt_SetReceiveFileDir_Stub( 
    INmChannelFt __RPC_FAR * This,
    /* [in] */ BSTR bstrDir);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumNmConference_Next_Proxy( 
    IEnumNmConference __RPC_FAR * This,
    /* [in] */ ULONG cConference,
    /* [out] */ INmConference __RPC_FAR *__RPC_FAR *rgpConference,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumNmConference_Next_Stub( 
    IEnumNmConference __RPC_FAR * This,
    /* [in] */ ULONG cConference,
    /* [length_is][size_is][out] */ INmConference __RPC_FAR *__RPC_FAR *rgpConference,
    /* [out] */ ULONG __RPC_FAR *pcFetched,
    /* [out] */ ULONG __RPC_FAR *pcItems,
    /* [in] */ BOOL bGetNumberRemaining);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumNmMember_Next_Proxy( 
    IEnumNmMember __RPC_FAR * This,
    /* [in] */ ULONG cMember,
    /* [out] */ INmMember __RPC_FAR *__RPC_FAR *rgpMember,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumNmMember_Next_Stub( 
    IEnumNmMember __RPC_FAR * This,
    /* [in] */ ULONG cMember,
    /* [length_is][size_is][out] */ INmMember __RPC_FAR *__RPC_FAR *rgpMember,
    /* [out] */ ULONG __RPC_FAR *pcFetched,
    /* [out] */ ULONG __RPC_FAR *pcItems,
    /* [in] */ BOOL bGetNumberRemaining);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumNmChannel_Next_Proxy( 
    IEnumNmChannel __RPC_FAR * This,
    /* [in] */ ULONG cChannel,
    /* [length_is][size_is][out] */ INmChannel __RPC_FAR *__RPC_FAR *rgpChannel,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumNmChannel_Next_Stub( 
    IEnumNmChannel __RPC_FAR * This,
    /* [in] */ ULONG cChannel,
    /* [length_is][size_is][out] */ INmChannel __RPC_FAR *__RPC_FAR *rgpChannel,
    /* [out] */ ULONG __RPC_FAR *pcFetched,
    /* [out] */ ULONG __RPC_FAR *pcItems,
    /* [in] */ BOOL bGetNumberRemaining);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumNmCall_Next_Proxy( 
    IEnumNmCall __RPC_FAR * This,
    /* [in] */ ULONG cCall,
    /* [out] */ INmCall __RPC_FAR *__RPC_FAR *rgpCall,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumNmCall_Next_Stub( 
    IEnumNmCall __RPC_FAR * This,
    /* [in] */ ULONG cCall,
    /* [length_is][size_is][out] */ INmCall __RPC_FAR *__RPC_FAR *rgpCall,
    /* [out] */ ULONG __RPC_FAR *pcFetched,
    /* [out] */ ULONG __RPC_FAR *pcItems,
    /* [in] */ BOOL bGetNumberRemaining);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumNmSharableApp_Next_Proxy( 
    IEnumNmSharableApp __RPC_FAR * This,
    /* [in] */ ULONG cApp,
    /* [out] */ INmSharableApp __RPC_FAR *__RPC_FAR *rgpApp,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumNmSharableApp_Next_Stub( 
    IEnumNmSharableApp __RPC_FAR * This,
    /* [in] */ ULONG cApp,
    /* [length_is][size_is][out] */ INmSharableApp __RPC_FAR *__RPC_FAR *rgpApp,
    /* [out] */ ULONG __RPC_FAR *pcFetched,
    /* [out] */ ULONG __RPC_FAR *pcItems,
    /* [in] */ BOOL bGetNumberRemaining);

/* [local] */ HRESULT STDMETHODCALLTYPE INmObject_VerifyUserInfo_Proxy( 
    INmObject __RPC_FAR * This,
    /* [in] */ long hwnd,
    /* [in] */ NM_VUI options);


/* [call_as] */ HRESULT STDMETHODCALLTYPE INmObject_VerifyUserInfo_Stub( 
    INmObject __RPC_FAR * This,
    /* [in] */ long hwnd,
    /* [in] */ NM_VUI options);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\common\parseaddr.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    parseaddr

Abstract:

    Misc. RD Utils that require reremotedesktopchannelsObject.h 

Author:

    HueiWang

Revision History:

--*/

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_parse"

#include "parseaddr.h"


HRESULT
ParseAddressList( 
    IN BSTR addressListString,
    OUT ServerAddressList& addressList 
    )
/*++

Description:

    Parse address list string in the form of "172.31.254.130:3389;hueiwangsalem4"
    to ServerList structure.

Parameters:

    addressString : Pointer to address list string.
    addressList : Return list of parsed address structure.

Return:

    S_OK or error code.

--*/
{
    BSTR tmp;
    WCHAR *nextTok;
    WCHAR *port;
    DWORD result = ERROR_SUCCESS;
    ServerAddress address;
    
    // clear entire list
    addressList.clear();

    tmp = SysAllocString( addressListString );
    if( NULL == tmp ) {
        result = ERROR_OUTOFMEMORY;
        goto CLEANUPANDEXIT;
    }
   
    while (tmp && *tmp) {
        nextTok = wcschr( tmp, L';' );

        if( NULL != nextTok ) {
            *nextTok = NULL;
            nextTok++;
        }

        //
        // ICS library might return us ;;
        //
        if( 0 != lstrlen(tmp) ) {

            port = wcschr( tmp, L':' );
            if( NULL != port ) {
                *port = NULL;
                port++;

                address.portNumber = _wtoi(port);
            }
            else {
                address.portNumber = 0;
            }

            //
            // Make sure we have server name/ipaddress
            //
            if( 0 != lstrlen(tmp) ) {

                // ICS might return ;;
                address.ServerName = tmp;

                try {
                    addressList.push_back( address );
                }
                catch(CRemoteDesktopException x) {
                    result = ERROR_OUTOFMEMORY;
                }

                if( ERROR_SUCCESS != result ) {
                    goto CLEANUPANDEXIT;
                }
            }
        }

        tmp = nextTok;
    }

CLEANUPANDEXIT:

    if( NULL != tmp ) {
        SysFreeString(tmp);
    }

    if( ERROR_SUCCESS != result ) {
        addressList.clear();
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\common\remotedesktopchannels.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RemoteDesktopUtils

Abstract:

    Misc. RD Utils

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_rdutl"

#include <RemoteDesktop.h>
#include <atlbase.h>
#include "RemoteDesktopUtils.h"

BSTR 
CreateConnectParmsString(
    IN DWORD protocolType,
    IN CComBSTR &machineName,
    IN CComBSTR &assistantAccount,
    IN CComBSTR &assistantAccountPwd,
    IN LONG helpSessionID,
    IN CComBSTR &helpSessionName,
    IN CComBSTR &helpSessionPwd,
    IN CComBSTR &protocolSpecificParms
    )
/*++

Routine Description:

    Create a connect parms string.  Format is:

    "protocolType,machineName,assistantAccount,assistantAccountPwd,helpSessionName,helpSessionPwd,protocolSpecificParms"

Arguments:

    protocolType            -   Identifies the protocol type.  
                                See RemoteDesktopChannels.h
    machineName             -   Identifies network address of server machine.
    assistantAccountName    -   Account name for initial log in to server 
                                machine.
    assistantAccountNamePwd -   Password for assistantAccountName
    helpSessionID           -   Help session identifier.
    helpSessionName         -   Help session name.
    helpSessionPwd          -   Password to help session once logged in to server 
                                machine.
    protocolSpecificParms   -   Parameters specific to a particular protocol.

Return Value:

 --*/
{
    DC_BEGIN_FN("CreateConnectParmsString");

    CComBSTR result;
    WCHAR buf[256];

    wsprintf(buf, TEXT("%ld"), protocolType);
    result = buf;
    result += TEXT(",");
    result += machineName;
    result += TEXT(",");
    result += assistantAccount;
    result += TEXT(",");
    result += assistantAccountPwd;
    result += TEXT(",");
    wsprintf(buf, TEXT("%ld"), helpSessionID);
    result += buf;
    result += TEXT(",");
    result += helpSessionName;
    result += TEXT(",");
    result += helpSessionPwd;
    
    if (protocolSpecificParms.Length() > 0) {
        result += TEXT(",");
        result += protocolSpecificParms;
    }

	DC_END_FN();

    return result.Detach();
}

DWORD
ParseConnectParmsString(
    IN BSTR parmsString,
    OUT DWORD *protocolType,
    OUT CComBSTR &machineName,
    OUT CComBSTR &assistantAccount,
    OUT CComBSTR &assistantAccountPwd,
    OUT LONG *helpSessionID,
    OUT CComBSTR &helpSessionName,
    OUT CComBSTR &helpSessionPwd,
    OUT CComBSTR &protocolSpecificParms
    )
/*++

Routine Description:

    Parse a connect string created by a call to CreateConnectParmsString.

Arguments:

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("ParseConnectParmsString");
    BSTR tmp;
    WCHAR *tok;
    DWORD result = ERROR_SUCCESS;
    DWORD len;

    //
    //  Make a copy of the input string so we can parse it.
    //
    tmp = SysAllocString(parmsString);
    if (tmp == NULL) {
        TRC_ERR((TB, TEXT("Can't allocate parms string.")));
        result = ERROR_OUTOFMEMORY;
        goto CLEANUPANDEXIT;
    }

    //
    //  Protocol.
    //
    tok = wcstok(tmp, L",");
    if (tok != NULL) {
        *protocolType = _wtoi(tok);
    }

    //
    //  Machine Name
    //
    tok = wcstok(NULL, L",");
    if (tok != NULL) {
        machineName = tok;
    }
    else {
        result = ERROR_INVALID_USER_BUFFER;
        goto CLEANUPANDEXIT;
    }

    //
    //  Assistant Account
    //
    tok = wcstok(NULL, L",");
    if (tok != NULL) {
        assistantAccount = tok;
    }
    else {
        result = ERROR_INVALID_USER_BUFFER;
        goto CLEANUPANDEXIT;
    }

    //
    //  Assistant Account Password
    //
    tok = wcstok(NULL, L",");
    if (tok != NULL) {
        assistantAccountPwd = tok;
    }
    else {
        result = ERROR_INVALID_USER_BUFFER;
        goto CLEANUPANDEXIT;
    }

    //
    //  Help Session ID
    //
    tok = wcstok(NULL, L",");
    if (tok != NULL) {
        *helpSessionID = _wtoi(tok);
    }
    else {
        result = ERROR_INVALID_USER_BUFFER;
        goto CLEANUPANDEXIT;
    }

    //
    //  Help Session Name
    //
    tok = wcstok(NULL, L",");
    if (tok != NULL) {
        helpSessionName = tok;
    }
    else {
        result = ERROR_INVALID_USER_BUFFER;
        goto CLEANUPANDEXIT;
    }

    //
    //  Help Session Password
    //
    tok = wcstok(NULL, L",");
    if (tok != NULL) {
        helpSessionPwd = tok;
    }
    else {
        result = ERROR_INVALID_USER_BUFFER;
        goto CLEANUPANDEXIT;
    }

    //
    //  Protocol-Specific Parms
    //
    len = wcslen(parmsString);
    if (tok < (tmp + len)) {
        tok += wcslen(tok);
        tok += 1;
        if (*tok != L'\0') {
            protocolSpecificParms = tok;
        }
        else {
            protocolSpecificParms = L"";
        }
    }
    else {
        protocolSpecificParms = L"";
    }

CLEANUPANDEXIT:

    if (result != ERROR_SUCCESS) {
        TRC_ERR((TB, TEXT("Error parsing %s"), parmsString));
    }

    if (tmp != NULL) {
        SysFreeString(tmp);
    }

	DC_END_FN();

    return result;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\common\remotedesktopchannels.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name :
    
    wtblobj.c

Abstract:

    Manage a list of waitable objects and associated callbacks.

Author:

    TadB

Revision History:
--*/

#include <RemoteDesktop.h>
#include <RemoteDesktopDBG.h>
#include "wtblobj.h"


////////////////////////////////////////////////////////
//      
//      Define 
//

#define WTBLOBJMGR_MAGICNO  0x57575757


////////////////////////////////////////////////////////
//      
//      Local Typedefs
//

typedef struct tagWAITABLEOBJECTMGR
{
#if DBG
    DWORD                magicNo;
#endif
    WTBLOBJ_ClientFunc   funcs[MAXIMUM_WAIT_OBJECTS];
    HANDLE               objects[MAXIMUM_WAIT_OBJECTS];
    PVOID                clientData[MAXIMUM_WAIT_OBJECTS];
    ULONG                objectCount;
} WAITABLEOBJECTMGR, *PWAITABLEOBJECTMGR;


WTBLOBJMGR 
WTBLOBJ_CreateWaitableObjectMgr()
/*++

Routine Description:

    Create a new instance of the Waitable Object Manager.

Arguments:

Return Value:

    NULL on error.  Otherwise, a new Waitable Object Manager is 
    returned.

--*/
{
    PWAITABLEOBJECTMGR objMgr;

    objMgr = ALLOCMEM(sizeof(WAITABLEOBJECTMGR));
    if (objMgr != NULL) {
#if DBG    
        objMgr->magicNo = WTBLOBJMGR_MAGICNO;
#endif        
        objMgr->objectCount = 0;
        memset(&objMgr->objects[0], 0, sizeof(objMgr->objects));
        memset(&objMgr->funcs[0], 0, sizeof(objMgr->funcs));
        memset(&objMgr->clientData[0], 0, sizeof(objMgr->clientData));
    }

    return objMgr;
}

VOID 
WTBLOBJ_DeleteWaitableObjectMgr(
     IN WTBLOBJMGR mgr
     )
/*++

Routine Description:

    Release an instance of the Waitable Object Manager that was
    created via a call to WTBLOBJ_CreateWaitableObjectMgr.

Arguments:

    mgr     -   Waitable object manager.

Return Value:

    NULL on error.  Otherwise, a new Waitable Object Manager is 
    returned.

--*/
{
    PWAITABLEOBJECTMGR objMgr = (PWAITABLEOBJECTMGR)mgr;

#if DBG
    objMgr->magicNo = 0xcccccccc;
#endif

    FREEMEM(objMgr);
}

DWORD 
WTBLOBJ_AddWaitableObject(
    IN WTBLOBJMGR mgr,
    IN PVOID clientData, 
    IN HANDLE waitableObject,
    IN WTBLOBJ_ClientFunc func
    )
/*++

Routine Description:

    Add a new waitable object to an existing Waitable Object Manager.

Arguments:

    mgr             -   Waitable object manager.
    clientData      -   Associated client data.
    waitableObject  -   Associated waitable object.
    func            -   Completion callback function.

Return Value:

    ERROR_SUCCESS on success.  Otherwise, a Windows error code is
    returned.

--*/
{
    ULONG objectCount;
    DWORD retCode = ERROR_SUCCESS;
    PWAITABLEOBJECTMGR objMgr = (PWAITABLEOBJECTMGR)mgr;

    objectCount = objMgr->objectCount;

    //
    //  Make sure we don't run out of waitable objects.  This version
    //  only supports MAXIMUM_WAIT_OBJECTS waitable objects.
    //
    if (objectCount < MAXIMUM_WAIT_OBJECTS) {
        objMgr->funcs[objectCount]      = func;
        objMgr->objects[objectCount]    = waitableObject;
        objMgr->clientData[objectCount] = clientData;
        objMgr->objectCount++;
    }
    else {
        retCode = ERROR_INSUFFICIENT_BUFFER;
    }
    return retCode;
}

VOID 
WTBLOBJ_RemoveWaitableObject(
    IN WTBLOBJMGR mgr,
    IN HANDLE waitableObject
    )
/*++

Routine Description:

    Remove a waitable object via a call to WTBLOBJ_AddWaitableObject.

Arguments:

    mgr             -   Waitable object manager.
    waitableObject  -   Associated waitable object.

Return Value:

    NA

--*/
{
    ULONG offset;

    PWAITABLEOBJECTMGR objMgr = (PWAITABLEOBJECTMGR)mgr;

    //
    //  Find the waitable object in the list, using a linear search.
    //
    for (offset=0; offset<objMgr->objectCount; offset++) {
        if (objMgr->objects[offset] == waitableObject) {
            break;
        }
    }

    if (offset < objMgr->objectCount) {
        //
        //  Move the last items to the now vacant spot and decrement the count.
        //
        objMgr->objects[offset]    = objMgr->objects[objMgr->objectCount - 1];
        objMgr->funcs[offset]      = objMgr->funcs[objMgr->objectCount - 1];
        objMgr->clientData[offset] = objMgr->clientData[objMgr->objectCount - 1];

        //
        //  Clear the unused spot.
        //
        objMgr->objects[objMgr->objectCount - 1]      = NULL;
        objMgr->funcs[objMgr->objectCount - 1]        = NULL;
        objMgr->clientData[objMgr->objectCount - 1]   = NULL;
        objMgr->objectCount--;
    }
}

DWORD
WTBLOBJ_PollWaitableObjects(
    WTBLOBJMGR mgr
    )
/*++

Routine Description:

    Poll the list of waitable objects associated with a 
    Waitable Object manager, until the next waitable object
    is signaled.

Arguments:

    waitableObject  -   Associated waitable object.

Return Value:

    ERROR_SUCCESS on success.  Otherwise, a Windows error status
    is returned.

--*/
{
    DWORD waitResult, objectOffset;
    DWORD ret = ERROR_SUCCESS;
    HANDLE obj;
    WTBLOBJ_ClientFunc func;
    PVOID clientData;

    PWAITABLEOBJECTMGR objMgr = (PWAITABLEOBJECTMGR)mgr;

    //
    //  Wait for all the waitable objects.
    //
    waitResult = WaitForMultipleObjectsEx(
                                objMgr->objectCount,
                                objMgr->objects,
                                FALSE,
                                INFINITE,
                                FALSE
                                );
    if (waitResult != WAIT_FAILED) {
        objectOffset = waitResult - WAIT_OBJECT_0;

        //
        //  Call the associated callback.
        //
        clientData = objMgr->clientData[objectOffset];
        func       = objMgr->funcs[objectOffset];
        obj        = objMgr->objects[objectOffset];
        func(obj, clientData);
    }
    else {
        ret = GetLastError();
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\common\remotedesktopchannels.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RemoteDesktopChannels.h

Abstract:
    
    Remote Desktop Data Channel Messages and Defines

Author:

    Tad Brockway 02/00

Revision History:
4
--*/

#ifndef __REMOTEDESKTOPCHANNELS_H__
#define __REMOTEDESKTOPCHANNELS_H__

//
//  Turn off compiler padding of structures
//  and save previous packing style.
//
#pragma pack (push, t128pack, 1)

//
//  Reserved Channel Names (Limit is REMOTEDESKTOP_RC_CHANNELNAMEMAX bytes)
//
#define REMOTEDESKTOP_RC_CONTROL_CHANNEL            TEXT("RC_CTL")

//
//	64-bytes so aligned on IA64
//
#define	REMOTEDESKTOP_RC_CHANNELNAME_LENGTH			64

//
//  Channel Buffer Header
//
//	This data structure is at the top of all channel packets.  Channel name
//	and message data immediately follow.
//

//TODO: Get rid of the magic number
#define CHANNELBUF_MAGICNO      0x08854107
typedef struct _RemoteDesktop_ChannelBufHeader {

#ifdef USE_MAGICNO
    DWORD   magicNo;        //  Buffer contents sanity checking
                            //  TODO:  This can be removed, once debugged.
#endif

    DWORD   channelNameLen; //  Length of channel name (in bytes) that immediately 
                            //   follows the header.
    DWORD   dataLen;        //  Length of data (in bytes) that follows the channel 
                            //   name.
#ifdef USE_MAGICNO
    DWORD   padForIA64;
#endif

} REMOTEDESKTOP_CHANNELBUFHEADER, *PREMOTEDESKTOP_CHANNELBUFHEADER;

//
//	Control Message Packet Header
//
typedef struct _REMOTEDESKTOP_CTL_PACKETHEADER
{
	REMOTEDESKTOP_CHANNELBUFHEADER channelBufHeader;
	BYTE	channelName[REMOTEDESKTOP_RC_CHANNELNAME_LENGTH];    
} REMOTEDESKTOP_CTL_PACKETHEADER, *PREMOTEDESKTOP_CTL_PACKETHEADER;


//////////////////////////////////////////////////////////////////
//
//  REMOTEDESKTOP_RC_CONTROL_CHANNEL Control Channel Messages
//

//
//  Control Channel Message Header
//
typedef struct _RemoteDesktopCtlBufHeader {
    DWORD   msgType;
} REMOTEDESKTOP_CTL_BUFHEADER, *PREMOTEDESKTOP_CTL_BUFHEADER;

//
//  Message Type:   REMOTEDESKTOP_CTL_REMOTE_CONTROL_DESKTOP
//  Direction:      Client->Server
//  Summary:        Desktop Remote Control Request
//  Message Data:   BSTR Connection Parms
//  Returns:        REMOTEDESKTOP_CTL_RESULT
//
#define REMOTEDESKTOP_CTL_REMOTE_CONTROL_DESKTOP    1   
typedef struct _RemoteDesktopRCCtlRequestPacket {
	REMOTEDESKTOP_CTL_PACKETHEADER	packetHeader;
    REMOTEDESKTOP_CTL_BUFHEADER     msgHeader;
} REMOTEDESKTOP_RCCTL_REQUEST_PACKET, *PREMOTEDESKTOP_RCCTL_REQUEST_PACKET;

//
//  Message Type:   REMOTEDESKTOP_CTL_RESULT
//  Direction:      Client->Server or Server->Client
//  Summary:        Request Result in HRESULT Format.
//  Message Data:   REMOTEDESKTOP_CTL_RESULT_PACKET
//  Returns:        NA
//
//  The result field is ERROR_SUCCESS is on success.  Otherwise,
//  a Windows error code is returned.
//
#define REMOTEDESKTOP_CTL_RESULT                    2
typedef struct _RemoteDesktopCtlResultPacket {
	REMOTEDESKTOP_CTL_PACKETHEADER	packetHeader;
    REMOTEDESKTOP_CTL_BUFHEADER		msgHeader;
    LONG result; // SAFRemoteDesktopErrorCode
} REMOTEDESKTOP_CTL_RESULT_PACKET, *PREMOTEDESKTOP_CTL_RESULT_PACKET;

//
//  Message Type:   REMOTEDESKTOP_CTL_AUTHENTICATE
//  Direction:      Client->Server
//  Summary:        Client Authentication Request
//  Message Data:   BSTR Connection Parms
//  Returns:        REMOTEDESKTOP_CTL_RESULT
//
#define REMOTEDESKTOP_CTL_AUTHENTICATE              3   
typedef struct _RemoteDesktopAuthenticatePacket {
	REMOTEDESKTOP_CTL_PACKETHEADER	packetHeader;
    REMOTEDESKTOP_CTL_BUFHEADER		msgHeader;
} REMOTEDESKTOP_CTL_AUTHENTICATE_PACKET, *PREMOTEDESKTOP_CTL_AUTHENTICATE_PACKET;

//
//  Message Type:   REMOTEDESKTOP_CTL_SERVER_ANNOUNCE
//  Direction:      Server->Client
//  Summary:        Server Announce to Initiate Connect Sequence
//  Message Data:   NONE
//  Returns:        NONE
//
#define REMOTEDESKTOP_CTL_SERVER_ANNOUNCE           4
typedef struct _RemoteDesktopCtlServerAnnouncePacket {
	REMOTEDESKTOP_CTL_PACKETHEADER	packetHeader;
    REMOTEDESKTOP_CTL_BUFHEADER		msgHeader;
} REMOTEDESKTOP_CTL_SERVERANNOUNCE_PACKET, *PREMOTEDESKTOP_CTL_SERVERANNOUNCE_PACKET;

//
//  Message Type:   REMOTEDESKTOP_CTL_DISCONNECT
//  Direction:      Server->Client
//  Summary:        Disconnect Notification
//  Message Data:   NONE
//  Returns:        NONE
//
#define REMOTEDESKTOP_CTL_DISCONNECT               5
typedef struct _RemoteDesktopCtlDisconnectPacket {
	REMOTEDESKTOP_CTL_PACKETHEADER	packetHeader;
    REMOTEDESKTOP_CTL_BUFHEADER		msgHeader;
} REMOTEDESKTOP_CTL_DISCONNECT_PACKET, *PREMOTEDESKTOP_CTL_DISCONNECT_PACKET;

//
//  Message Type:   REMOTEDESKTOP_CTL_VERSIONINFO
//  Direction:      Server->Client and Client->Server
//  Summary:        Protocol Version Information
//  Message Data:   NONE
//  Returns:        NONE
//
#define REMOTEDESKTOP_CTL_VERSIONINFO               6
typedef struct _RemoteDesktopVersionInfoPacket {
    REMOTEDESKTOP_CTL_PACKETHEADER  packetHeader;
    REMOTEDESKTOP_CTL_BUFHEADER     msgHeader;
    DWORD                           versionMajor;
    DWORD                           versionMinor;
} REMOTEDESKTOP_CTL_VERSIONINFO_PACKET, *PREMOTEDESKTOP_CTL_VERSIONINFO_PACKET;


//
//  Message Type:   REMOTEDESKTOP_CTL_ISCONNECTED
//  Direction:      Server->Client and Client->Server
//  Summary:        Client/Server connection status
//  Message Data:   NONE
//  Returns:        NONE
//
#define REMOTEDESKTOP_CTL_ISCONNECTED                    	7
typedef struct _RemoteDesktopIsConnected {
	REMOTEDESKTOP_CTL_PACKETHEADER	packetHeader;
    REMOTEDESKTOP_CTL_BUFHEADER		msgHeader;
} REMOTEDESKTOP_CTL_ISCONNECTED_PACKET, *PREMOTEDESKTOP_CTL_ISCONNECTED_PACKET;
//
//  Restore previous packing 
//
#pragma pack (pop, t128pack)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\common\remotedesktopchannelsobject.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

   RemoteDesktopChannelsObject.h
 
Abstract:

    This module defines the common parent for all client-side
	RDP device redirection classes, CRemoteDesktopTopLevelObject.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __REMOTEDESKTOPCHANNELSOBJECT_H__
#define __REMOTEDESKTOPCHANNELSOBJECT_H__ 

#ifndef TRC_FILE
#define TRC_FILE  "_rdchnl"
#endif


#include <RemoteDesktop.h>
#include <RemoteDesktopDBG.h>


///////////////////////////////////////////////////////////////
//
//  CRemoteDesktopException
//
class CRemoteDesktopException 
{
public:

    DWORD   m_ErrorCode;

    CRemoteDesktopException(DWORD errorCode = 0) : m_ErrorCode(errorCode) {}
};


///////////////////////////////////////////////////////////////
//
//	CRemoteDesktopTopLevelObject
//

class CRemoteDesktopTopLevelObject 
{
private:

    BOOL    _isValid;

protected:

    //
    //  Remember if this instance is valid.
    //
    VOID SetValid(BOOL set)     { _isValid = set;   }  

public:

    //
    //  Mark an instance as allocated or bogus.
    //
#if DBG
    ULONG   _magicNo;
#endif

    //  
    //  Constructor/Destructor
    //
    CRemoteDesktopTopLevelObject() : _isValid(TRUE) 
    {
#if DBG
        _magicNo = GOODMEMMAGICNUMBER;
#endif
    }
    virtual ~CRemoteDesktopTopLevelObject() 
    {
        DC_BEGIN_FN("CRemoteDesktopTopLevelObject::~CRemoteDesktopTopLevelObject");
#if DBG
        ASSERT(_magicNo == GOODMEMMAGICNUMBER);
        memset(&_magicNo, REMOTEDESKTOPBADMEM, sizeof(_magicNo));
#endif        
        SetValid(FALSE);
        DC_END_FN();
    }

    // 
    //  Return whether this class instance is valid.
    //
    virtual BOOL IsValid()           
    {
        DC_BEGIN_FN("CRemoteDesktopTopLevelObject::IsValid");
        ASSERT(_magicNo == GOODMEMMAGICNUMBER);
        DC_END_FN();
        return _isValid; 
    }

    //
    //  Memory Management Operators
    //
#if DBG
    inline void *__cdecl operator new(size_t sz, DWORD tag=REMOTEDESKTOPOBJECT_TAG)
    {
        void *ptr = RemoteDesktopAllocateMem(sz, tag);
        return ptr;
    }

    inline void __cdecl operator delete(void *ptr)
    {
        RemoteDesktopFreeMem(ptr);
    }
#endif

    //
    //  Return the class name.
    //
    virtual const LPTSTR ClassName() = 0;
};


///////////////////////////////////////////////////////////////
//
//  An STL Memory Allocator that Throws C++ Exception on Failure
//

template<class T> inline
	T  *_RemoteDesktopAllocate(int sz, T *)
	{
        DC_BEGIN_FN("_RemoteDesktopAllocate");        
        if (sz < 0)
		    sz = 0;

        T* ret = (T *)operator new((size_t)sz * sizeof(T));  
        if (ret == NULL) {
            TRC_ERR((TB, TEXT("Can't allocate %ld bytes."),
                    (size_t)sz * sizeof(T)));
            DC_END_FN();    
            throw CRemoteDesktopException(ERROR_NOT_ENOUGH_MEMORY);
        }
        DC_END_FN();        
	    return ret;
    }

template<class T1, class T2> inline
	void _RemoteDesktopConstruct(T1 *ptr, const T2& args)
	{
        DC_BEGIN_FN("_RemoteDesktopConstruct");        
        void *val = new ((void  *)ptr)T1(args); 
        if (val == NULL) {
            throw CRemoteDesktopException(ERROR_NOT_ENOUGH_MEMORY);
        }
        DC_END_FN();
    }

template<class T> inline
	void _RemoteDesktopDestroy(T  *ptr)
	{
        (ptr)->~T();
    }

inline void _RemoteDesktopDestroy(char  *ptr)
	{
    }

inline void _RemoteDesktopDestroy(wchar_t  *ptr)
	{
    }

template<class T>
	class CRemoteDesktopAllocator {

public:

	typedef size_t size_type;
	typedef int difference_type;
	typedef T  *pointer;
	typedef const T  *const_pointer;
	typedef T & reference;
	typedef const T & const_reference;
	typedef T value_type;

	pointer address(reference obj) const
		{return (&obj); }

	const_pointer address(const_reference obj) const
		{return (&obj); }

	pointer allocate(size_type sz, const void *) // throws REMOTDESKTOPEXCEPTION
		{return (_RemoteDesktopAllocate((difference_type)sz, (pointer)0)); }

	char  *_Charalloc(size_type sz) // throws REMOTEDESKTOPEXCEPTION
		{return (_RemoteDesktopAllocate((difference_type)sz,
			(char  *)0)); }

	void deallocate(void  *ptr, size_type)
		{operator delete(ptr); }

	void construct(pointer ptr, const T& args)
		{_RemoteDesktopConstruct(ptr, args); }

	void destroy(pointer ptr)
		{_RemoteDesktopDestroy(ptr); }

	size_t max_size() const
		{size_t sz = (size_t)(-1) / sizeof(T);
		return (0 < sz ? sz : 1); }
};


#endif //__REMOTEDESKTOPTOPLEVELOBJECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\common\wtblobj.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name :
    
    wtblobj.c

Abstract:

    Manage a list of waitable objects and associated callbacks.

Author:

    TadB

Revision History:
--*/

#include <RemoteDesktop.h>
#include <RemoteDesktopDBG.h>
#include "wtblobj.h"


////////////////////////////////////////////////////////
//      
//      Define 
//

#define WTBLOBJMGR_MAGICNO  0x57575757


////////////////////////////////////////////////////////
//      
//      Local Typedefs
//

typedef struct tagWAITABLEOBJECTMGR
{
#if DBG
    DWORD                magicNo;
#endif
    WTBLOBJ_ClientFunc   funcs[MAXIMUM_WAIT_OBJECTS];
    HANDLE               objects[MAXIMUM_WAIT_OBJECTS];
    PVOID                clientData[MAXIMUM_WAIT_OBJECTS];
    ULONG                objectCount;
} WAITABLEOBJECTMGR, *PWAITABLEOBJECTMGR;


WTBLOBJMGR 
WTBLOBJ_CreateWaitableObjectMgr()
/*++

Routine Description:

    Create a new instance of the Waitable Object Manager.

Arguments:

Return Value:

    NULL on error.  Otherwise, a new Waitable Object Manager is 
    returned.

--*/
{
    PWAITABLEOBJECTMGR objMgr;

    objMgr = ALLOCMEM(sizeof(WAITABLEOBJECTMGR));
    if (objMgr != NULL) {
#if DBG    
        objMgr->magicNo = WTBLOBJMGR_MAGICNO;
#endif        
        objMgr->objectCount = 0;
        memset(&objMgr->objects[0], 0, sizeof(objMgr->objects));
        memset(&objMgr->funcs[0], 0, sizeof(objMgr->funcs));
        memset(&objMgr->clientData[0], 0, sizeof(objMgr->clientData));
    }

    return objMgr;
}

VOID 
WTBLOBJ_DeleteWaitableObjectMgr(
     IN WTBLOBJMGR mgr
     )
/*++

Routine Description:

    Release an instance of the Waitable Object Manager that was
    created via a call to WTBLOBJ_CreateWaitableObjectMgr.

Arguments:

    mgr     -   Waitable object manager.

Return Value:

    NULL on error.  Otherwise, a new Waitable Object Manager is 
    returned.

--*/
{
    PWAITABLEOBJECTMGR objMgr = (PWAITABLEOBJECTMGR)mgr;

#if DBG
    objMgr->magicNo = 0xcccccccc;
#endif

    FREEMEM(objMgr);
}

DWORD 
WTBLOBJ_AddWaitableObject(
    IN WTBLOBJMGR mgr,
    IN PVOID clientData, 
    IN HANDLE waitableObject,
    IN WTBLOBJ_ClientFunc func
    )
/*++

Routine Description:

    Add a new waitable object to an existing Waitable Object Manager.

Arguments:

    mgr             -   Waitable object manager.
    clientData      -   Associated client data.
    waitableObject  -   Associated waitable object.
    func            -   Completion callback function.

Return Value:

    ERROR_SUCCESS on success.  Otherwise, a Windows error code is
    returned.

--*/
{
    ULONG objectCount;
    DWORD retCode = ERROR_SUCCESS;
    PWAITABLEOBJECTMGR objMgr = (PWAITABLEOBJECTMGR)mgr;

    objectCount = objMgr->objectCount;

    //
    //  Make sure we don't run out of waitable objects.  This version
    //  only supports MAXIMUM_WAIT_OBJECTS waitable objects.
    //
    if (objectCount < MAXIMUM_WAIT_OBJECTS) {
        objMgr->funcs[objectCount]      = func;
        objMgr->objects[objectCount]    = waitableObject;
        objMgr->clientData[objectCount] = clientData;
        objMgr->objectCount++;
    }
    else {
        retCode = ERROR_INSUFFICIENT_BUFFER;
    }
    return retCode;
}

VOID 
WTBLOBJ_RemoveWaitableObject(
    IN WTBLOBJMGR mgr,
    IN HANDLE waitableObject
    )
/*++

Routine Description:

    Remove a waitable object via a call to WTBLOBJ_AddWaitableObject.

Arguments:

    mgr             -   Waitable object manager.
    waitableObject  -   Associated waitable object.

Return Value:

    NA

--*/
{
    ULONG offset;

    PWAITABLEOBJECTMGR objMgr = (PWAITABLEOBJECTMGR)mgr;

    //
    //  Find the waitable object in the list, using a linear search.
    //
    for (offset=0; offset<objMgr->objectCount; offset++) {
        if (objMgr->objects[offset] == waitableObject) {
            break;
        }
    }

    if (offset < objMgr->objectCount) {
        //
        //  Move the last items to the now vacant spot and decrement the count.
        //
        objMgr->objects[offset]    = objMgr->objects[objMgr->objectCount - 1];
        objMgr->funcs[offset]      = objMgr->funcs[objMgr->objectCount - 1];
        objMgr->clientData[offset] = objMgr->clientData[objMgr->objectCount - 1];

        //
        //  Clear the unused spot.
        //
        objMgr->objects[objMgr->objectCount - 1]      = NULL;
        objMgr->funcs[objMgr->objectCount - 1]        = NULL;
        objMgr->clientData[objMgr->objectCount - 1]   = NULL;
        objMgr->objectCount--;
    }
}

DWORD
WTBLOBJ_PollWaitableObjects(
    WTBLOBJMGR mgr
    )
/*++

Routine Description:

    Poll the list of waitable objects associated with a 
    Waitable Object manager, until the next waitable object
    is signaled.

Arguments:

    waitableObject  -   Associated waitable object.

Return Value:

    ERROR_SUCCESS on success.  Otherwise, a Windows error status
    is returned.

--*/
{
    DWORD waitResult, objectOffset;
    DWORD ret = ERROR_SUCCESS;
    HANDLE obj;
    WTBLOBJ_ClientFunc func;
    PVOID clientData;

    PWAITABLEOBJECTMGR objMgr = (PWAITABLEOBJECTMGR)mgr;

    //
    //  Wait for all the waitable objects.
    //
    waitResult = WaitForMultipleObjectsEx(
                                objMgr->objectCount,
                                objMgr->objects,
                                FALSE,
                                INFINITE,
                                FALSE
                                );
    if (waitResult != WAIT_FAILED) {
        objectOffset = waitResult - WAIT_OBJECT_0;

        //
        //  Call the associated callback.
        //
        clientData = objMgr->clientData[objectOffset];
        func       = objMgr->funcs[objectOffset];
        obj        = objMgr->objects[objectOffset];
        func(obj, clientData);
    }
    else {
        ret = GetLastError();
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\common\remotedesktopdbg.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RemoteDesktopDBG

Abstract:
    
    Contains Debug Routines for RD

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __REMOTEDESKTOPDBG_H__
#define __REMOTEDESKTOPDBG_H__

//
//  Route ASSERT to TRC_ASSERT.
//
#undef ASSERT
#if DBG
#define ASSERT(expr) if (!(expr)) \
    { TRC_ERR((TB, L"Failure at Line %d in %s\n",__LINE__, TEXT##(__FILE__)));  \
    DebugBreak(); }
#else
#define ASSERT(expr)
#endif

//
//  Object and Memory Tracking Defines
//
#define GOODMEMMAGICNUMBER      0x07052530
#define REMOTEDESKTOPBADMEM     0xCF
#define UNITIALIZEDMEM          0xCC
#define FREEDMEMMAGICNUMBER     0x09362229

//
//  Memory Allocation Tags
//
#define REMOTEDESKTOPOBJECT_TAG        ('BOHS')
#define REMOTEDESKTOPGLOBAL_TAG        ('BGHS')

////////////////////////////////////////////////////////////
//
//  Memory Allocation Routines
//

#if DBG
//  
//  The Functions
//
#ifdef __cplusplus 
extern "C" {
#endif
void *RemoteDesktopAllocateMem(size_t size, DWORD tag);
void RemoteDesktopFreeMem(void *ptr);
void *RemoteDesktopReallocMem(void *ptr, size_t sz);
#ifdef __cplusplus
}
#endif

//
//  The C++ Operators
//
#if defined(__cplusplus) && defined(DEBUGMEM)
inline void *__cdecl operator new(size_t sz)
{
    void *ptr = RemoteDesktopAllocateMem(sz, REMOTEDESKTOPGLOBAL_TAG);
    return ptr;
}
inline void *__cdecl operator new(size_t sz, DWORD tag)
{
    void *ptr = RemoteDesktopAllocateMem(sz, tag);
    return ptr;
}
inline void __cdecl operator delete(void *ptr)
{
    RemoteDesktopFreeMem(ptr);
}
#endif

#define ALLOCMEM(size)      RemoteDesktopAllocateMem(size, REMOTEDESKTOPGLOBAL_TAG)
#define FREEMEM(ptr)        RemoteDesktopFreeMem(ptr)
#define REALLOCMEM(ptr, sz) RemoteDesktopReallocMem(ptr, sz)
#else
#define ALLOCMEM(size)      malloc(size)
#define FREEMEM(ptr)        free(ptr)
#define REALLOCMEM(ptr, sz) realloc(ptr, sz)
#endif

#endif //__REMOTEDESKTOPDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\common\remotedesktopdbg.cpp ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    drdbg

Abstract:
    
    Contains Debug Routines for Remote Desktopping

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_slmdbg"

#include <RemoteDesktop.h>
#include <RemoteDesktopDBG.h>

#if DBG

typedef struct tagREMOTEDESKTOP_MEMHDR
{
    DWORD       magicNo;
    DWORD       tag;
    DWORD       size;
    DWORD       pad;
} REMOTEDESKTOP_MEMHDR, *PREMOTEDESKTOP_MEMHDR;

void *
RemoteDesktopAllocateMem(
    IN size_t size, 
    IN DWORD tag   
    )
/*++

Routine Description:

    Allocate memory.  Similiar to malloc.

Arguments:

    size        -   Number of bytes to allocate.
    tag         -   Tag identifying the allocated block for tracking
                    memory allocations.

Return Value:

    Pointer to allocated memory on success.  Otherwise, NULL is returned.

--*/
{
    PREMOTEDESKTOP_MEMHDR hdr;
    PBYTE p;

    DC_BEGIN_FN("RemoteDesktopAllocateMem");

    hdr = (PREMOTEDESKTOP_MEMHDR)malloc(size + sizeof(REMOTEDESKTOP_MEMHDR));
    if (hdr != NULL) {
        hdr->magicNo = GOODMEMMAGICNUMBER;
        hdr->tag  = tag;
        hdr->size = size;

        p = (PBYTE)(hdr + 1);
        memset(p, UNITIALIZEDMEM, size);
        DC_END_FN();
        return (void *)p;
    }
    else {
        TRC_ERR((TB, TEXT("Can't allocate %ld bytes."), size));
        DC_END_FN();
        return NULL;
    }
}

void 
RemoteDesktopFreeMem(
    IN void *ptr
    )
/*++

Routine Description:

    Release memory allocated by a call to RemoteDesktopAllocateMem.

Arguments:

    ptr -   Block of memory allocated by a call to RemoteDesktopAllocateMem.

Return Value:

    NA

--*/
{
    PREMOTEDESKTOP_MEMHDR hdr;

    DC_BEGIN_FN("RemoteDesktopFreeMem");

    //
    //  NULL is okay with 'free' so it has to be okay with us.
    //  (STL passes NULL to 'delete')
    //
    if (ptr == NULL) {
        DC_END_FN();
        return;
    }

    //
    //  Get a pointer to the header to the memory block.
    //
    hdr = (PREMOTEDESKTOP_MEMHDR)ptr;
    hdr--;

    //
    //  Make sure the block is valid.
    //
    ASSERT(hdr->magicNo == GOODMEMMAGICNUMBER);

    //
    //  Mark it as freed.
    //
    hdr->magicNo = FREEDMEMMAGICNUMBER;

    //
    //  Scramble and free the memory.
    //
    memset(ptr, REMOTEDESKTOPBADMEM, (size_t)hdr->size);

    free(hdr);

    DC_END_FN();
}

void *
RemoteDesktopReallocMem(
    IN void *ptr,
    IN size_t size
    )
/*++

Routine Description:

    Realloc a block.

Arguments:

    ptr -   Block of memory allocated by a call to RemoteDesktopAllocateMem.
    sz  -   Size of new block.

Return Value:

    NA

--*/
{
    PREMOTEDESKTOP_MEMHDR hdr;

    DC_BEGIN_FN("RemoteDesktopReallocMem");

    ASSERT(ptr != NULL);

    //
    //  Get a pointer to the header to the memory block.
    //
    hdr = (PREMOTEDESKTOP_MEMHDR)ptr;
    hdr--;

    //
    //  Make sure the block is valid.
    //
    ASSERT(hdr->magicNo == GOODMEMMAGICNUMBER);

    //
    //  Whack the old block magic number in case we move.
    //
    hdr->magicNo = FREEDMEMMAGICNUMBER;

    //
    //  Resize.
    //
    hdr = (PREMOTEDESKTOP_MEMHDR)realloc(hdr, size + sizeof(REMOTEDESKTOP_MEMHDR));

    //
    //  Update the size and update the magic number.
    //
    if (hdr != NULL) {
        hdr->magicNo = GOODMEMMAGICNUMBER;
        hdr->size = size;
        ptr = (PBYTE)(hdr + 1);
    }
    else {
        TRC_ERR((TB, TEXT("Can't allocate %ld bytes."), size));
        ptr = NULL;
    }

    DC_END_FN();
    return (void *)ptr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\common\remotedesktoptoplevelobject.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RemoteDesktopTopLevelObject

Abstract:

    This module defines the common parent for all client-side
	RDP device redirection classes, CRemoteDesktopTopLevelObject.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __REMOTEDESKTOPTOPLEVELOBJECT_H__
#define __REMOTEDESKTOPTOPLEVELOBJECT_H__


#include <RemoteDesktop.h>
#include <RemoteDesktopDBG.h>


///////////////////////////////////////////////////////////////
//
//  CRemoteDesktopException
//
class CRemoteDesktopException 
{
public:

    DWORD   m_ErrorCode;

    CRemoteDesktopException(DWORD errorCode = 0) : m_ErrorCode(errorCode) {}
};


///////////////////////////////////////////////////////////////
//
//	CRemoteDesktopTopLevelObject
//

class CRemoteDesktopTopLevelObject 
{
private:

    BOOL    _isValid;

protected:

    //
    //  Remember if this instance is valid.
    //
    VOID SetValid(BOOL set)     { _isValid = set;   }  

public:

    //
    //  Mark an instance as allocated or bogus.
    //
#if DBG
    ULONG   _magicNo;
#endif

    //  
    //  Constructor/Destructor
    //
    CRemoteDesktopTopLevelObject() : _isValid(TRUE) 
    {
#if DBG
        _magicNo = GOODMEMMAGICNUMBER;
#endif
    }
    virtual ~CRemoteDesktopTopLevelObject() 
    {
        DC_BEGIN_FN("CRemoteDesktopTopLevelObject::~CRemoteDesktopTopLevelObject");
#if DBG
        ASSERT(_magicNo == GOODMEMMAGICNUMBER);
        memset(&_magicNo, REMOTEDESKTOPBADMEM, sizeof(_magicNo));
#endif        
        SetValid(FALSE);
        DC_END_FN();
    }

    // 
    //  Return whether this class instance is valid.
    //
    virtual BOOL IsValid()           
    {
        DC_BEGIN_FN("CRemoteDesktopTopLevelObject::IsValid");
        ASSERT(_magicNo == GOODMEMMAGICNUMBER);
        DC_END_FN();
        return _isValid; 
    }

    //
    //  Memory Management Operators
    //
#if DBG
#ifdef DEBUGMEM
    inline void *__cdecl operator new(size_t sz, DWORD tag=REMOTEDESKTOPOBJECT_TAG)
    {
        void *ptr = RemoteDesktopAllocateMem(sz, tag);
        return ptr;
    }

    inline void __cdecl operator delete(void *ptr)
    {
        RemoteDesktopFreeMem(ptr);
    }
#endif
#endif

    //
    //  Return the class name.
    //
    virtual const LPTSTR ClassName() = 0;
};


///////////////////////////////////////////////////////////////
//
//  An STL Memory Allocator that Throws C++ Exception on Failure
//

template<class T> inline
	T  *_RemoteDesktopAllocate(int sz, T *)
	{
        DC_BEGIN_FN("_RemoteDesktopAllocate");        
        if (sz < 0)
		    sz = 0;

        T* ret = (T *)operator new((size_t)sz * sizeof(T));  
        if (ret == NULL) {
            TRC_ERR((TB, TEXT("Can't allocate %ld bytes."),
                    (size_t)sz * sizeof(T)));
            DC_END_FN();    
            throw CRemoteDesktopException(ERROR_NOT_ENOUGH_MEMORY);
        }
        DC_END_FN();        
	    return ret;
    }

template<class T1, class T2> inline
	void _RemoteDesktopConstruct(T1 *ptr, const T2& args)
	{
        DC_BEGIN_FN("_RemoteDesktopConstruct");        
        void *val = new ((void  *)ptr)T1(args); 
        if (val == NULL) {
            throw CRemoteDesktopException(ERROR_NOT_ENOUGH_MEMORY);
        }
        DC_END_FN();
    }

template<class T> inline
	void _RemoteDesktopDestroy(T  *ptr)
	{
        (ptr)->~T();
    }

inline void _RemoteDesktopDestroy(char  *ptr)
	{
    }

inline void _RemoteDesktopDestroy(wchar_t  *ptr)
	{
    }

template<class T>
	class CRemoteDesktopAllocator {

public:

	typedef size_t size_type;
	typedef int difference_type;
	typedef T  *pointer;
	typedef const T  *const_pointer;
	typedef T & reference;
	typedef const T & const_reference;
	typedef T value_type;

	pointer address(reference obj) const
		{return (&obj); }

	const_pointer address(const_reference obj) const
		{return (&obj); }

	pointer allocate(size_type sz, const void *) // throws REMOTDESKTOPEXCEPTION
		{return (_RemoteDesktopAllocate((difference_type)sz, (pointer)0)); }

	char  *_Charalloc(size_type sz) // throws REMOTEDESKTOPEXCEPTION
		{return (_RemoteDesktopAllocate((difference_type)sz,
			(char  *)0)); }

	void deallocate(void  *ptr, size_type)
		{operator delete(ptr); }

	void construct(pointer ptr, const T& args)
		{_RemoteDesktopConstruct(ptr, args); }

	void destroy(pointer ptr)
		{_RemoteDesktopDestroy(ptr); }

	size_t max_size() const
		{size_t sz = (size_t)(-1) / sizeof(T);
		return (0 < sz ? sz : 1); }
};


#endif //__REMOTEDESKTOPTOPLEVELOBJECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\common\tsrdpremotedesktop.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    TSRDPRemoteDesktop.h

Abstract:
    
    TSRDP-Specific Defines

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __TSRDPREMOTEDESKTOP__H__
#define __TSRDPREMOTEDESKTOP__H__

//
//  RD Virtual Channel Name
//  (must be exactly 7 characters)
//
#define TSRDPREMOTEDESKTOP_VC_CHANNEL     TEXT("remdesk")
#define TSRDPREMOTEDESKTOP_VC_CHANNEL_A   "remdesk"

//
//  Add-In Named Pipe Information
//
#define TSRDPREMOTEDESKTOP_PIPENAME     TEXT("TSRDPRemoteDesktopPipe")
#define TSRDPREMOTEDESKTOP_PIPEBUFSIZE  2048
#define TSRDPREMOTEDESKTOP_PIPETIMEOUT  (30 * 1000) /* 30 seconds */

//
//  Virtual key and modifier to press to stop shadow (ctrl-*)
//  TODO:   This should be passed to the client in the connection
//          parms for later compatibility issues.
//
#define TSRDPREMOTEDESKTOP_SHADOWVKEYMODIFIER 0x02    
#define TSRDPREMOTEDESKTOP_SHADOWVKEY         VK_MULTIPLY

#endif  // __TSRDPREMOTEDESKTOP__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\common\remotedesktoputils.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RemoteDesktopUtils

Abstract:

    Misc. RD Utils

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __REMOTEDESKTOPUTILS_H__
#define __REMOTEDESKTOPUTILS_H__

#include <atlbase.h>


//
// Version stamp for first supported connect parm, Whistler
// beta 1 does not have this version stamp.
//
#define SALEM_FIRST_VALID_CONNECTPARM_VERSION 0x00010001


//
// Changes to Salem connect parm.
//
// Changes                                      Start                       Compatible with previous build
// ----------------------------------           --------------------        ------------------------------
// Add version stamp as first field             Whister Beta 2              No
// Remove helpassistant from connect parm       Build 2406                  No
// Add security blob as protocol specfic        Build 2476+                 Yes
//   parameter
//
//

//
// Version that does not have security blob as protocol specific
// parameters (last field in our connect parm).
//
#define SALEM_CONNECTPARM_NOSECURITYBLOB_VERSION    0x00010001

//
// Starting version having security blob as protocol specific
// parameters (last field in our connect parm).
//
#define SALEM_CONNECTPARM_SECURITYBLOB_VERSION      0x00010002

//
//
// Current version stamp for Salem connect parm.
//
#define SALEM_CURRENT_CONNECTPARM_VERSION  SALEM_CONNECTPARM_SECURITYBLOB_VERSION

#define SALEM_CONNECTPARM_UNUSEFILED_SUBSTITUTE _TEXT("*")


//
//	Compare two BSTR's.
//
struct CompareBSTR 
{
	bool operator()(BSTR str1, BSTR str2) const {
	
		if ((str1 == NULL) || (str2 == NULL)) {
			return false;
		}
        return (wcscmp(str1, str2) < 0);
	}
};
struct BSTREqual
{
	bool operator()(BSTR str1, BSTR str2) const {

		if ((str1 == NULL) || (str2 == NULL)) {
			return false;
		}
		int minLen = SysStringByteLen(str1) < SysStringByteLen(str2) ? 
					 SysStringByteLen(str1) : SysStringByteLen(str2);
		return (memcmp(str1, str2, minLen) == 0);
	}
};

//
//  Create a connect parms string.
//
BSTR 
CreateConnectParmsString(
    IN DWORD  protocolType,
    IN CComBSTR &machineAddressList,
    IN CComBSTR &assistantAccount,
    IN CComBSTR &assistantAccountPwd,
    IN CComBSTR &helpSessionId,
    IN CComBSTR &helpSessionName,
    IN CComBSTR &helpSessionPwd,
    IN CComBSTR &protocolSpecificParms
    );

//
//  Parse a connect string created by a call to CreateConnectParmsString.
//
DWORD
ParseConnectParmsString(
    IN BSTR parmsString,
    OUT DWORD* pdwVersion,
    OUT DWORD *protocolType,
    OUT CComBSTR &machineAddressList,
    OUT CComBSTR &assistantAccount,
    OUT CComBSTR &assistantAccountPwd,
    OUT CComBSTR &helpSessionId,
    OUT CComBSTR &helpSessionName,
    OUT CComBSTR &helpSessionPwd,
    OUT CComBSTR &protocolSpecificParms
    );

//
//	Realloc a BSTR
//
BSTR 
ReallocBSTR(
	IN BSTR origStr, 
	IN DWORD requiredByteLen
	);

int
GetClientmachineAddressList(
    OUT CComBSTR& clientmachineAddressList
    );

DWORD
ParseHelpAccountName(
    IN BSTR helpAccount,
    OUT CComBSTR& machineAddressList,
    OUT CComBSTR& AccountName
    );

//
//  Create a SYSTEM SID.
//
DWORD CreateSystemSid(
    PSID *ppSystemSid
    );

//
//  Returns whether the current thread is running under SYSTEM security.
//
BOOL IsCallerSystem(PSID pSystemSid);

//
// Routine to attach debugger is asked.
//
void
AttachDebuggerIfAsked(HINSTANCE hInst);

DWORD
HashSecurityData(
    IN PBYTE const pbData,
    IN DWORD cbData,
    OUT CComBSTR& bstrHashedKey
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\msngr\approvaldialog.cpp ===
// ApprovalDialog.cpp: implementation of the CApprovalDialog class.
//
//////////////////////////////////////////////////////////////////////

// This class is temporary until the remote control completed stuff
// is fixed for Salem

#include "stdafx.h"
#include "ApprovalDialog.h"

#include "RemoteDesktopClientSession.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CApprovalDialog::CApprovalDialog()
{

}

CApprovalDialog::~CApprovalDialog()
{

}

VOID CApprovalDialog::OnOk()
{
    m_rObj->ShowRemdeskControl();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\msngr\approvaldialog.h ===
// ApprovalDialog.h: interface for the CApprovalDialog class.
//
//////////////////////////////////////////////////////////////////////


// This class is temporary until the remote control completed stuff
// is fixed for Salem

#if !defined(AFX_APPROVALDIALOG_H__263811F5_3495_45BC_B6A9_2648831887B0__INCLUDED_)
#define AFX_APPROVALDIALOG_H__263811F5_3495_45BC_B6A9_2648831887B0__INCLUDED_

#include "StaticOkDialog.h"

class CRemoteDesktopClientSession;

class CApprovalDialog : public CStaticOkDialog  
{
public:
	CRemoteDesktopClientSession * m_rObj;
	CApprovalDialog();
	virtual ~CApprovalDialog();

private:

    virtual VOID OnOk();

};

#endif // !defined(AFX_APPROVALDIALOG_H__263811F5_3495_45BC_B6A9_2648831887B0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\common\wtblobj.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name :
    
    wtblobj.h

Abstract:

    Manage a list of waitable objects and associated callbacks.

Author:

    TadB

Revision History:
--*/

#ifndef _WTBLOBJ_
#define _WTBLOBJ_

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

typedef VOID (*WTBLOBJ_ClientFunc)(HANDLE waitableObject, PVOID clientData);
typedef VOID *WTBLOBJMGR;

WTBLOBJMGR WTBLOBJ_CreateWaitableObjectMgr();

VOID WTBLOBJ_DeleteWaitableObjectMgr(WTBLOBJMGR mgr);

DWORD WTBLOBJ_AddWaitableObject(WTBLOBJMGR mgr, PVOID clientData, 
                               HANDLE waitableObject,
                               IN WTBLOBJ_ClientFunc func);

VOID WTBLOBJ_RemoveWaitableObject(WTBLOBJMGR mgr, 
                                HANDLE waitableObject);

DWORD WTBLOBJ_PollWaitableObjects(WTBLOBJMGR mgr);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif //#ifndef _WTBLOBJ_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\common\remotedesktoputils.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RemoteDesktopUtils

Abstract:

    Misc. RD Utils

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE  "_rdsutl"


#include <winsock2.h>
#include <RemoteDesktop.h>
#include "RemoteDesktopUtils.h"
#include "base64.h"
//#include "RemoteDesktopDBG.h"

int
GetClientmachineAddressList(
    OUT CComBSTR& clientmachineAddressList
    )
/*++


--*/
{
    char hostname[MAX_PATH+1];
    int errCode = 0;

    struct hostent* pHostEnt;
    
    if( gethostname(hostname, sizeof(hostname)) != 0 ) {
        errCode = WSAGetLastError();
    }
    else {

        pHostEnt = gethostbyname( hostname );
        if( NULL != pHostEnt ) {
            clientmachineAddressList = pHostEnt->h_name;
        } 
        else {
             errCode = WSAGetLastError();
        }
    }

    return errCode;
}


BSTR 
CreateConnectParmsString(
    IN DWORD protocolType,
    IN CComBSTR &machineAddressList,
    IN CComBSTR &assistantAccount,
    IN CComBSTR &assistantAccountPwd,
    IN CComBSTR &helpSessionID,
    IN CComBSTR &helpSessionName,
    IN CComBSTR &helpSessionPwd,
    IN CComBSTR &protocolSpecificParms
    )
/*++

Routine Description:

    Create a connect parms string.  Format is:

    "protocolType,machineAddressList,assistantAccount,assistantAccountPwd,helpSessionName,helpSessionPwd,protocolSpecificParms"

Arguments:

    protocolType            -   Identifies the protocol type.  
                                See RemoteDesktopChannels.h
    machineAddressList      -   Identifies network address of server machine.
    assistantAccountName    -   Account name for initial log in to server 
                                machine, ignore for Whistler
    assistantAccountNamePwd -   Password for assistantAccountName
    helpSessionID           -   Help session identifier.
    helpSessionName         -   Help session name.
    helpSessionPwd          -   Password to help session once logged in to server 
                                machine.
    protocolSpecificParms   -   Parameters specific to a particular protocol.

Return Value:

 --*/
{
    CComBSTR result;
    WCHAR buf[256];

    UNREFERENCED_PARAMETER(assistantAccount);

    //
    // Add a version stamp for our connect parm.
    wsprintf(buf, TEXT("%ld"), SALEM_CURRENT_CONNECTPARM_VERSION);
    result = buf;
    result += TEXT(",");

    wsprintf(buf, TEXT("%ld"), protocolType);
    result += buf;
    result += TEXT(",");
    result += machineAddressList;
    result += TEXT(",");
    result += assistantAccountPwd;
    result += TEXT(",");
    result += helpSessionID;
    result += TEXT(",");
    result += helpSessionName;
    result += TEXT(",");
    result += helpSessionPwd;
    
    if (protocolSpecificParms.Length() > 0) {
        result += TEXT(",");
        result += protocolSpecificParms;
    }

    return result.Detach();
}

DWORD
ParseHelpAccountName(
    IN BSTR helpAccount,
    OUT CComBSTR& machineAddressList,
    OUT CComBSTR& AccountName
    )
/*++

HelpAccount in connection parameter is <machineAddressList>\HelpAssistant.

--*/
{
    DC_BEGIN_FN("ParseHelpAccountName");
    BSTR tmp;
    WCHAR *tok;
    DWORD result = ERROR_SUCCESS;
    DWORD len;

    //
    //  Make a copy of the input string so we can parse it.
    //
    tmp = SysAllocString(helpAccount);
    if (tmp == NULL) {
        TRC_ERR((TB, TEXT("Can't allocate parms string.")));
        result = ERROR_OUTOFMEMORY;
        goto CLEANUPANDEXIT;
    }

    machineAddressList = L"";
    AccountName = L"";

    //
    // Machine Name
    //
    tok = wcstok(tmp, L"\\");
    if (tok != NULL) {
        machineAddressList = tok;
    }
    else {
        // 
        // for backward compatible.
        //
        machineAddressList = L"";
        AccountName = helpAccount;
        goto CLEANUPANDEXIT;
    }

    //
    //  Actual help assistant account name.
    //
    len = wcslen(helpAccount);
    if (tok < (tmp + len)) {
        tok += wcslen(tok);
        tok += 1;
        if (*tok != L'\0') {
            AccountName = tok;
        }
    }

    //
    // Help Assistant accout name must be in the string or
    // this is critical error.
    //
    if( AccountName.Length() == 0 ) {
        result = ERROR_INVALID_PARAMETER;
    }

CLEANUPANDEXIT:

    if (tmp != NULL) {
        SysFreeString(tmp);
    }

	DC_END_FN();
    return result;
}

DWORD
ParseConnectParmsString(
    IN BSTR parmsString,
    OUT DWORD* pdwConnParmVersion,
    OUT DWORD *protocolType,
    OUT CComBSTR &machineAddressList,
    OUT CComBSTR &assistantAccount,
    OUT CComBSTR &assistantAccountPwd,
    OUT CComBSTR &helpSessionID,
    OUT CComBSTR &helpSessionName,
    OUT CComBSTR &helpSessionPwd,
    OUT CComBSTR &protocolSpecificParms
    )
/*++

Routine Description:

    Parse a connect string created by a call to CreateConnectParmsString.

Arguments:

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("ParseConnectParmsString");
    BSTR tmp;
    WCHAR *tok;
    DWORD result = ERROR_SUCCESS;
    DWORD len;
    DWORD dwVersion = 0;

    UNREFERENCED_PARAMETER(assistantAccount);

    //
    //  Make a copy of the input string so we can parse it.
    //
    tmp = SysAllocString(parmsString);
    if (tmp == NULL) {
        TRC_ERR((TB, TEXT("Can't allocate parms string.")));
        result = ERROR_OUTOFMEMORY;
        goto CLEANUPANDEXIT;
    }

    //
    // Retrieve connect parm version stamp, Whistler beta 1 
    // connect parm does not have version stamp, bail out, 
    // sessmgr/termsrv will wipe out pending help.
    //
    tok = wcstok(tmp, L",");
    if (tok != NULL) {
        dwVersion = _wtol(tok);
    }
    else {
        result = ERROR_INVALID_USER_BUFFER;
        goto CLEANUPANDEXIT;
    }

    if( dwVersion < SALEM_FIRST_VALID_CONNECTPARM_VERSION ) {
        //
        // connect parm is whistler beta 1
        //
        result = ERROR_NOT_SUPPORTED;
        goto CLEANUPANDEXIT;
    }

    *pdwConnParmVersion = dwVersion;

    // 
    // We have no use for version at this time,
    // future update on connect parm should
    // take make the necessary change
    //

    //
    //  Protocol.
    //
    tok = wcstok(NULL, L",");
    if (tok != NULL) {
        *protocolType = _wtoi(tok);
    }

    //
    //  Machine Name
    //
    tok = wcstok(NULL, L",");
    if (tok != NULL) {
        machineAddressList = tok;
    }
    else {
        result = ERROR_INVALID_USER_BUFFER;
        goto CLEANUPANDEXIT;
    }

    //
    //  Assistant Account Password
    //
    tok = wcstok(NULL, L",");
    if (tok != NULL) {
        assistantAccountPwd = tok;
    }
    else {
        result = ERROR_INVALID_USER_BUFFER;
        goto CLEANUPANDEXIT;
    }

    //
    //  Help Session ID
    //
    tok = wcstok(NULL, L",");
    if (tok != NULL) {
        helpSessionID = tok;
    }
    else {
        result = ERROR_INVALID_USER_BUFFER;
        goto CLEANUPANDEXIT;
    }

    //
    //  Help Session Name
    //
    tok = wcstok(NULL, L",");
    if (tok != NULL) {
        helpSessionName = tok;
    }
    else {
        result = ERROR_INVALID_USER_BUFFER;
        goto CLEANUPANDEXIT;
    }

    //
    //  Help Session Password
    //
    tok = wcstok(NULL, L",");
    if (tok != NULL) {
        helpSessionPwd = tok;
    }
    else {
        result = ERROR_INVALID_USER_BUFFER;
        goto CLEANUPANDEXIT;
    }

    //
    //  Protocol-Specific Parms
    //
    len = wcslen(parmsString);
    if (tok < (tmp + len)) {
        tok += wcslen(tok);
        tok += 1;
        if (*tok != L'\0') {
            protocolSpecificParms = tok;
        }
        else {
            protocolSpecificParms = L"";
        }
    }
    else {
        protocolSpecificParms = L"";
    }

CLEANUPANDEXIT:

    if (result != ERROR_SUCCESS) {
        TRC_ERR((TB, TEXT("Error parsing %s"), parmsString));
    }

    if (tmp != NULL) {
        SysFreeString(tmp);
    }

	DC_END_FN();

    return result;

}

BSTR 
ReallocBSTR(
	IN BSTR origStr, 
	IN DWORD requiredByteLen
	)
/*++

Routine Description:

    Realloc a BSTR

Arguments:

Return Value:

    The realloc'd string on success.  Otherwise, NULL is returned.

 --*/
{
	DC_BEGIN_FN("ReallocBSTR");

	BSTR tmp;
	DWORD len;
	DWORD origLen;

	//
	//	Allocate the new string.
	//
	tmp = SysAllocStringByteLen(NULL, requiredByteLen);
	if (tmp == NULL) {
		TRC_ERR((TB, TEXT("Failed to allocate %ld bytes."), requiredByteLen));
		goto  CLEANUPANDEXIT;
	}

	//
	//	Copy data from the original string.
	//
	origLen = SysStringByteLen(origStr);
	len = origLen <= requiredByteLen ? origLen : requiredByteLen;
	memcpy(tmp, origStr, len);

	//
	//	Release the old string.
	//
	SysFreeString(origStr);

CLEANUPANDEXIT:

	DC_END_FN();

	return tmp;
}

DWORD
CreateSystemSid(
    PSID *ppSystemSid
    )
/*++

Routine Description:

    Create a SYSTEM SID.

Arguments:

Return Value:

    ERROR_SUCCESS on success.  Otherwise, an error code is returned.

 --*/
{
    DC_BEGIN_FN("CreateSystemSid");

    DWORD dwStatus = ERROR_SUCCESS;
    PSID pSid;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;

    TRC_ASSERT(ppSystemSid != NULL, (TB, L"ppSystemSid != NULL"));

    if( TRUE == AllocateAndInitializeSid(
                            &SidAuthority,
                            1,
                            SECURITY_LOCAL_SYSTEM_RID,
                            0, 0, 0, 0, 0, 0, 0,
                            &pSid
                        ) )
    {
        *ppSystemSid = pSid;
    }
    else
    {
        dwStatus = GetLastError();
    }

    DC_END_FN();
    return dwStatus;
}

BOOL
IsSystemToken(
    HANDLE TokenHandle,
    PSID pSystemSid
    )
/*++

Routine Description:

    Returns whether the current token is running under SYSTEM security.

Arguments:

    TokenHandle -   Param1 Thread or process token
    pSystemSid  -   System SID.

Return Value:

    TRUE if System token. FALSE otherwise.

 --*/
{
    DC_BEGIN_FN("IsSystemToken");

    BOOL   Result = FALSE;
    ULONG  ReturnLength, BufferLength;
    DWORD dwStatus;
    PTOKEN_USER pTokenUser = NULL;

    TRC_ASSERT(NULL != pSystemSid, (TB, L"NULL != pSystemSid"));

    // Get user SID.
    ReturnLength = 0;
    Result = GetTokenInformation(
                         TokenHandle,
                         TokenUser,
                         NULL,
                         0,
                         &ReturnLength
                     );

    if( ReturnLength == 0 ) 
    {
        TRC_ERR((TB, L"GetTokenInformation:  %08X", GetLastError()));            
        Result = FALSE;
        CloseHandle( TokenHandle );
        goto CLEANUPANDEXIT;
    }

    BufferLength = ReturnLength;

    pTokenUser = (PTOKEN_USER)LocalAlloc( LPTR, BufferLength );
    if( pTokenUser == NULL ) 
    {
        TRC_ERR((TB, L"LocalAlloc:  %08X", GetLastError()));
        Result = FALSE;
        CloseHandle( TokenHandle );
        goto CLEANUPANDEXIT;
    }

    Result = GetTokenInformation(
                     TokenHandle,
                     TokenUser,
                     pTokenUser,
                     BufferLength,
                     &ReturnLength
                 );

    CloseHandle( TokenHandle );

    if( TRUE == Result ) {
        Result = EqualSid( pTokenUser->User.Sid, pSystemSid);
    }
    else {
        TRC_ERR((TB, L"GetTokenInformation:  %08X", GetLastError()));
    }

CLEANUPANDEXIT:

    if( pTokenUser )
    {
        LocalFree( pTokenUser );
    }

    DC_END_FN();
    return Result;
}

BOOL
IsCallerSystem(
    PSID pSystemSid
    )
/*++

Routine Description:

    Returns whether the current thread is running under SYSTEM security.

    NOTE:   Caller should be impersonated prior to invoking this function.

Arguments:

    pSystemSid  -   System SID.

Return Value:

    TRUE if System. FALSE otherwise.

 --*/
{
    DC_BEGIN_FN("IsCallerSystem");
    BOOL   Result;
    HANDLE TokenHandle;

    //
    // Open the thread token and check if System token. 
    //
    Result = OpenThreadToken(
                     GetCurrentThread(),
                     TOKEN_QUERY,
                     FALSE,              // Use impersonation
                     &TokenHandle
                    );

    if( TRUE == Result ) {
        //
        //  This token should not be released.  This function does not leak
        //  handles.
        //
        Result = IsSystemToken(TokenHandle, pSystemSid);
    }
    else {
        TRC_ERR((TB, L"OpenThreadToken:  %08X", GetLastError()));
    }
    DC_END_FN();
    return Result;
}


void
AttachDebugger( 
    LPCTSTR pszDebugger 
    )
/*++

Routine Description:

    Attach debugger to our process or process hosting our DLL.

Parameters:

    pszDebugger : Debugger command, e.g. ntsd -d -g -G -p %d

Returns:

    None.

Note:

    Must have "-p %d" since we don't know debugger's parameter for process.

--*/
{
    //
    // Attach debugger
    //
    if( !IsDebuggerPresent() ) {

        TCHAR szCommand[256];
        PROCESS_INFORMATION ProcessInfo;
        STARTUPINFO StartupInfo;

        //
        // ntsd -d -g -G -p %d
        //
        wsprintf( szCommand, pszDebugger, GetCurrentProcessId() );
        ZeroMemory(&StartupInfo, sizeof(StartupInfo));
        StartupInfo.cb = sizeof(StartupInfo);

        if (!CreateProcess(NULL, szCommand, NULL, NULL, FALSE, 0, NULL, NULL, &StartupInfo, &ProcessInfo)) {
            return;
        }
        else {

            CloseHandle(ProcessInfo.hProcess);
            CloseHandle(ProcessInfo.hThread);

            while (!IsDebuggerPresent())
            {
                Sleep(500);
            }
        }
    } else {
        DebugBreak();
    }

    return;
}

void
AttachDebuggerIfAsked(HINSTANCE hInst)
/*++

Routine Description:

    Check if debug enable flag in our registry HKLM\Software\Microsoft\Remote Desktop\<module name>,
    if enable, attach debugger to running process.

Parameter :

    hInst : instance handle.

Returns:

    None.

--*/
{
    CRegKey regKey;
    DWORD dwStatus;
    TCHAR szModuleName[MAX_PATH+1];
    TCHAR szFileName[MAX_PATH+1];
    CComBSTR bstrRegKey(_TEXT("Software\\Microsoft\\Remote Desktop\\"));
    TCHAR szDebugCmd[256];
    DWORD cbDebugCmd = sizeof(szDebugCmd)/sizeof(szDebugCmd[0]);

    dwStatus = GetModuleFileName( hInst, szModuleName, MAX_PATH+1 );
    if( 0 == dwStatus ) {
        //
        // Can't attach debugger with name.
        //
        return;
    }

    _tsplitpath( szModuleName, NULL, NULL, szFileName, NULL );
    bstrRegKey += szFileName;

    //
    // Check if we are asked to attach/break into debugger
    //
    dwStatus = regKey.Open( HKEY_LOCAL_MACHINE, bstrRegKey );
    if( 0 != dwStatus ) {
        return;
    }

    dwStatus = regKey.QueryValue( szDebugCmd, _TEXT("Debugger"), &cbDebugCmd );
    if( 0 != dwStatus || cbDebugCmd > 200 ) {
        // 200 chars is way too much for debugger command.
        return;
    }
    
    AttachDebugger( szDebugCmd );
    return;
}

DWORD
HashSecurityData(
    IN PBYTE const pbData,
    IN DWORD cbData,
    OUT CComBSTR& bstrHashedData
    )
/*++

Routine Description:

    Hash a blob of data and return hased data in BSTR

Parameters:

    pbData : Pointer to data to be hashed.
    cbData : Size of data to be hashed.
    bstrHashedData : Return hashed data in BSTR form.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DC_BEGIN_FN("HashSecurityData");

    DWORD dwStatus;
    LPSTR pbEncodedData = NULL;
    DWORD cbEncodedData = 0;

    PBYTE pbHashedData = NULL;
    DWORD cbHashedData = 0;
    DWORD dwSize;

    HCRYPTPROV hCryptProv = NULL;
    HCRYPTHASH hHash = NULL;

    BOOL bSuccess;

    bSuccess = CryptAcquireContext(
                                &hCryptProv,
                                NULL,
                                NULL,
                                PROV_RSA_FULL, 
                                CRYPT_VERIFYCONTEXT
                            );

    if( FALSE == bSuccess ) {
        dwStatus = GetLastError();
        TRC_ERR((TB, L"CryptAcquireContext:  %08X", dwStatus));
        goto CLEANUPANDEXIT;
    }

    bSuccess = CryptCreateHash(
                       hCryptProv, 
                       CALG_SHA1,
                       0, 
                       0, 
                       &hHash
                    );

    if( FALSE == bSuccess ) {
        dwStatus = GetLastError();
        TRC_ERR((TB, L"CryptCreateHash:  %08X", dwStatus));
        goto CLEANUPANDEXIT;
    }

    
    bSuccess = CryptHashData(
                        hHash,
                        pbData,
                        cbData,
                        0
                    );

    if( FALSE == bSuccess ) {
        dwStatus = GetLastError();
        TRC_ERR((TB, L"CryptHashData:  %08X", dwStatus));
        goto CLEANUPANDEXIT;
    }


    dwSize = sizeof( cbHashedData );
    bSuccess = CryptGetHashParam(
                            hHash,
                            HP_HASHSIZE,
                            (PBYTE)&cbHashedData,
                            &dwSize,
                            0
                        );
 
    if( FALSE == bSuccess ) {
        dwStatus = GetLastError();
        TRC_ERR((TB, L"CryptGetHashParam with HP_HASHSIZE :  %08X", dwStatus));
        goto CLEANUPANDEXIT;
    }

    pbHashedData = (PBYTE)LocalAlloc(LPTR, cbHashedData);
    if( NULL == pbHashedData ) {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    bSuccess = CryptGetHashParam(
                            hHash,
                            HP_HASHVAL,
                            pbHashedData,
                            &cbHashedData,
                            0
                        );
 
    if( FALSE == bSuccess ) {
        dwStatus = GetLastError();
        TRC_ERR((TB, L"CryptGetHashParam with HP_HASHVAL :  %08X", dwStatus));
        goto CLEANUPANDEXIT;
    }


    //
    // Hash data and convert to string form.
    //
    dwStatus = LSBase64EncodeA(
                            pbHashedData,
                            cbHashedData,
                            NULL,
                            &cbEncodedData
                        );

    if( ERROR_SUCCESS != dwStatus ) {
        TRC_ERR((TB, L"LSBase64EncodeA  :  %08X", dwStatus));
        goto CLEANUPANDEXIT;
    }

    pbEncodedData = (LPSTR) LocalAlloc( LPTR, cbEncodedData+1 );
    if( NULL == pbEncodedData ) {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    dwStatus = LSBase64EncodeA(
                            pbHashedData,
                            cbHashedData,
                            pbEncodedData,
                            &cbEncodedData
                        );

    if( ERROR_SUCCESS == dwStatus ) {

        //
        // Base64 encoding always add '\r', '\n' at the end,
        // remove it
        //
        if( pbEncodedData[cbEncodedData - 1] == '\n' &&
            pbEncodedData[cbEncodedData - 2] == '\r' )
        {
            pbEncodedData[cbEncodedData - 2] = 0;
            cbEncodedData -= 2;
        }

        bstrHashedData = pbEncodedData;
    }
    else {
        TRC_ERR((TB, L"LSBase64EncodeA  :  %08X", dwStatus));
    }

CLEANUPANDEXIT:

    if( NULL != pbEncodedData ) {
        LocalFree( pbEncodedData );
    }

    if( NULL != pbHashedData ) {
        LocalFree( pbHashedData );
    }

    if( NULL != hHash ) {
        CryptDestroyHash( hHash );
    }

    if( NULL != hCryptProv ) {
        CryptReleaseContext( hCryptProv, 0 );
    }

    DC_END_FN();
    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\msngr\directplayconnection.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    DirectPlayConnection

Abstract:

    DirectPlayConnection is a wrapper around the direct play interfaces
    to just do what is needed for this application.  It takes care of 
    connecting to the remote machine and sending/recieving the connction
    paramters.

Author:

    Marc Reyhner 7/5/2000

--*/

#ifndef __DIRECTPLAYCONNECTION_H__
#define __DIRECTPLAYCONNECTION_H__

#include "dplobby.h"

//  We want to wait 15 seconds for the remote instance to start
#define GETREMOTEPLAYERTIMEOUT (60*1000)

//  We want to wait 15 seconds for the message to show up
#define GETPARMSTIMEOUT (60*1000)

////////////////////////////////////////////////
//
//    CDirectPlayConnection
//
//    Class for dealing with all the direct play APIs.
//

class CDirectPlayConnection  
{
private:
    
    DPID m_PlayerID;
    BOOL m_bConnected;
    LPDIRECTPLAY2 m_rDirectPlay;
    LPDPLCONNECTION m_rSettings;
    LPDIRECTPLAYLOBBY m_rLobby;
    HANDLE m_hEventHandle;

    DPID xGetOtherPlayerID();
    LPDPMSG_GENERIC xReceiveMessage(DPID from, DPID to, DWORD dwFlags);

public:

    //  Constructor/Destructor
    CDirectPlayConnection();
    virtual ~CDirectPlayConnection();
    
    //  This returns whether or not this is the server session.
    BOOL IsServer();

    //  This fetches the connection parms from the server session.
    BSTR ReceiveConnectionParameters();

    //  This sends the connection parms to the client session,
    VOID SendConnectionParameters(BSTR parms);
    
    //  This connections you to the remote session.
    VOID ConnectToRemoteApplication();

    // This disconnects you from the remote session
    VOID DisconnectRemoteApplication();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\msngr\exception.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Exception

Abstract:

    This is a simple class to do exceptions.  The only thing it does
    is return an error string.

Author:

    Marc Reyhner 7/17/2000

--*/

#include "stdafx.h"

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE "rce"

#include "rcontrol.h"
#include "Exception.h"


CException::CException(
    IN UINT uID
    )

/*++

Routine Description:

    Creates a new exception and loads the error string.

Arguments:

    uID - Resource id of the string to load.

Return Value:

    None

--*/
{
    DC_BEGIN_FN("CException::CException");
    
    LoadStringSimple(uID,m_errstr);
    
    DC_END_FN();
}

CException::CException(
    IN CException &rException
    )

/*++

Routine Description:

    Copy constructor for CException.

Arguments:

    rException - Exception to copy the error from.

Return Value:

    None

--*/
{
    DC_BEGIN_FN("CException::CException");
    
    _tcscpy(m_errstr,rException.m_errstr);
    
    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\msngr\directplayconnection.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    DirectPlayConnection

Abstract:

    DirectPlayConnection is a wrapper around the direct play interfaces
    to just do what is needed for this application.  It takes care of 
    connecting to the remote machine and sending/recieving the connction
    paramters.

Author:

    Marc Reyhner 7/5/2000

--*/

#include "stdafx.h"

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE "rcdpc"

#include "DirectPlayConnection.h"
#include "exception.h"
#include "resource.h"


static BOOL SendLaunchSuccessful(LPDIRECTPLAYLOBBY2 pLobby);

//  A structure for passing data to our callback
//  function for enumerating the player list.
typedef struct _CALLBACKDATA {
	DPID playerID;
	BOOL bSet;
} CALLBACKDATA, FAR *LPCALLBACKDATA;


#define DPSYS_CONNECTPARMSMSG          0x0111

typedef struct _DPMSG_CONNECTPARMS
{
    DWORD       dwType;         // Message type
    DWORD       dwDataSize;
} DPMSG_CONNECTPARMS, FAR *LPDPMSG_CONNECTPARMS;



//  Callback function for enumerating the player list.
static BOOL FAR PASCAL
PlayerCallback(
    DPID dpId,
    DWORD dwPlayerType,
    LPCDPNAME lpName,
    DWORD dwFlags,
    LPVOID lpContext
    );

CDirectPlayConnection::CDirectPlayConnection(
    )
/*++

Routine Description:

    This is the constructor for CDirectPlayConnection.  All that
    it does is create the direct play lobby.

Arguments:

    None

Return Value:

    None

--*/
{
	HRESULT hr;

    DC_BEGIN_FN("CDirectPlayConnection::CDirectPlayConnection");

    m_rLobby = NULL;
    m_rSettings = NULL;
    m_rDirectPlay = NULL;
    m_bConnected = FALSE;
    m_PlayerID = 0;

    hr = CoCreateInstance(CLSID_DirectPlayLobby,NULL,CLSCTX_ALL,
        IID_IDirectPlayLobby,(LPVOID*)&m_rLobby);
	if (hr != S_OK) {
		TRC_ERR((TB,TEXT("Error creating IDirectPlayLobby")));
        goto FAILURE;
        
	}

    m_hEventHandle = CreateEvent(NULL,FALSE,FALSE,NULL);
    if (!m_hEventHandle) {
        TRC_ERR((TB,TEXT("Error creating event handle")));
        goto FAILURE;
    }

    DC_END_FN();

    return;

FAILURE:
    
    if (m_rLobby) {
        m_rLobby->Release();
        m_rLobby = NULL;
    }
    if (m_hEventHandle) {
        CloseHandle(m_hEventHandle);
        m_hEventHandle = NULL;
    }

    throw CException(IDS_DPERRORCREATE);
}

CDirectPlayConnection::~CDirectPlayConnection(
    )
/*++

Routine Description:

    This destroys all the direct play objects that were created.

Arguments:

    None

Return Value:

    None

--*/
{
    DC_BEGIN_FN("CDirectPlayConnection::~CDirectPlayConnection");

    if (m_bConnected) {
        DisconnectRemoteApplication();
    }
    if (m_rLobby) {
		m_rLobby->Release();
	}
	if (m_rDirectPlay) {
		m_rDirectPlay->Release();
	}
	if (m_rSettings) {
		delete m_rSettings;
	}

    DC_END_FN();
}

VOID
CDirectPlayConnection::ConnectToRemoteApplication(
    )
/*++

Routine Description:

    This connects to the remote application.  If we were not started
    by a lobby application an exception will be thrown at this point.

Arguments:

    None

Return Value:

    None

--*/
{
	DWORD dwSize = 0;
	HRESULT hr;

    DC_BEGIN_FN("CDirectPlayConnection::ConnectToRemoteApplication");

    hr = m_rLobby->GetConnectionSettings(0,NULL,&dwSize);
	if (hr != DPERR_BUFFERTOOSMALL) {
		TRC_ERR((TB,TEXT("Error getting connection settings size")));
        goto FAILURE;
	}

	m_rSettings = (DPLCONNECTION *)new BYTE [dwSize];
	if (!m_rSettings) {
        TRC_ERR((TB,TEXT("Out of memory")));
        
		goto FAILURE;
	}
	
	hr = m_rLobby->GetConnectionSettings(0,m_rSettings,&dwSize);
	if (hr != DP_OK) {
        TRC_ERR((TB,TEXT("Error getting connection settings")));
		goto FAILURE;
	}

/*	m_rSettings->lpSessionDesc->dwFlags |= DPSESSION_SECURESERVER;
	hr = m_rLobby->SetConnectionSettings(0,0,m_rSettings);
	if (hr != DP_OK) {
        TRC_ERR((TB,TEXT("Error setting connection settings")));
		goto FAILURE;
	}*/

    hr = m_rLobby->Connect(0,&m_rDirectPlay,NULL);
	if (hr != DP_OK) {
        TRC_ERR((TB,TEXT("Error connecting to remote application: 0x%8lx"),hr));
		goto FAILURE;
    }

	hr = m_rDirectPlay->CreatePlayer(&m_PlayerID,NULL,m_hEventHandle,NULL,0,0);
	if (hr != DP_OK) {
        TRC_ERR((TB,TEXT("Error creating player")));
		goto FAILURE;
	}

	m_bConnected = TRUE;
    
    DC_END_FN();
	return;

FAILURE:
	if (m_rSettings) {
		delete m_rSettings;
		m_rSettings = NULL;
	}
	if (m_rDirectPlay) {
		m_rDirectPlay->Release();
		m_rDirectPlay = NULL;
	}
    //
    // We did a TRC_ERR up where the error was thrown so we won't
    // do another here.
    //
    if (hr == DPERR_NOTLOBBIED) {
        throw CException(IDS_DPNOTLOBBIED);
    } else {
        throw CException(IDS_DPERRORCONNECT);
    }
}


VOID
CDirectPlayConnection::DisconnectRemoteApplication(
    )

{
    DC_BEGIN_FN("CDirectPlayConnection::DisconnectRemoteApplication");
    
    if (!m_bConnected) {
        TRC_ERR((TB,TEXT("Not connected to remote application")));
        throw CException(IDS_DPNOTCONNECTED);
	}
    m_rDirectPlay->Close();
    m_rDirectPlay->Release();
    m_rDirectPlay = NULL;
    
    delete m_rSettings;
    m_rSettings = NULL;

    m_bConnected = FALSE;

    DC_END_FN();
}


VOID 
CDirectPlayConnection::SendConnectionParameters(
    IN BSTR parms
    )
/*++

Routine Description:

    This sends the connection parms to the client application

Arguments:

    parms - The connection parms for Salem.

Return Value:

    None

--*/
{
    LPVOID      sendBuffer;
    DWORD       cbSendBuffer;
    LPDPMSG_CONNECTPARMS unsecMsg;
    DPID otherPlayerID;
	HRESULT hr;

    DC_BEGIN_FN("CDirectPlayConnection::SendConnectionParameters");
	
    sendBuffer = NULL;

    if (!m_bConnected) {
        TRC_ERR((TB,TEXT("Not connected to remote application")));
        throw CException(IDS_DPNOTCONNECTED);
	}
	otherPlayerID = xGetOtherPlayerID();
    if (m_rSettings->lpSessionDesc->dwFlags & DPSESSION_SECURESERVER) {
	    hr = m_rDirectPlay->Send(m_PlayerID,otherPlayerID,
		    DPSEND_ENCRYPTED|DPSEND_GUARANTEED|DPSEND_SIGNED,parms,
		    (wcslen(parms)+1)*sizeof(OLECHAR));
        if (hr != DP_OK) {
            TRC_ERR((TB,TEXT("Error sending dp message.")));
		    throw CException(IDS_DPERRORSEND);
	    }
    } else {
        cbSendBuffer = sizeof(DPMSG_CONNECTPARMS) + (wcslen(parms)+1)*sizeof(OLECHAR);
        sendBuffer = new BYTE [ cbSendBuffer ];
        if (!sendBuffer) {
            TRC_ERR((TB,TEXT("Out of memory.")));
		    throw CException(IDS_DPERRORSEND);
        }
        unsecMsg = (LPDPMSG_CONNECTPARMS)sendBuffer;
        unsecMsg->dwType = DPSYS_CONNECTPARMSMSG;
        unsecMsg->dwDataSize = cbSendBuffer -  sizeof(DPMSG_CONNECTPARMS);
        CopyMemory((LPBYTE)sendBuffer +  sizeof(DPMSG_CONNECTPARMS),parms,
            unsecMsg->dwDataSize);
        hr = m_rDirectPlay->Send(m_PlayerID,otherPlayerID,DPSEND_GUARANTEED,
            sendBuffer,cbSendBuffer);
        delete sendBuffer;
        sendBuffer = NULL;
        if (hr != DP_OK) {
            TRC_ERR((TB,TEXT("Error sending dp message.")));
		    throw CException(IDS_DPERRORSEND);
	    }

    }
	
    DC_END_FN();
}

BSTR
CDirectPlayConnection::ReceiveConnectionParameters(
    )
/*++

Routine Description:

    This reads the connection parms sent by the server.  This will
    block waiting for the server to send.

Arguments:

    None

Return Value:

    BSTR - The connection parameters.

--*/
{
	BSTR parms = NULL;
	DPID otherPlayerID;
    LPDPMSG_GENERIC lpMsg;
	LPDPMSG_SECUREMESSAGE lpMsgSec = NULL;
    LPDPMSG_CONNECTPARMS lpMsgUnsec = NULL;
	DWORD dwSize = 0;
	DWORD endWaitTime, dwWaitTime;
    BOOL bFirstTimeInLoop;
    DWORD dwResult;

    DC_BEGIN_FN("CDirectPlayConnection::ReceiveConnectionParameters");

    if (!m_bConnected) {
        TRC_ERR((TB,TEXT("Not connected to remote application")));
		throw CException(IDS_DPNOTCONNECTED);
	}
	otherPlayerID = xGetOtherPlayerID();
	

	endWaitTime = GetTickCount() + GETPARMSTIMEOUT;
	
    bFirstTimeInLoop = TRUE;
    while (endWaitTime > GetTickCount()) {
        dwWaitTime = endWaitTime - GetTickCount();
        if (dwWaitTime <= 0) {
            //  We hit time between the beginning of the loop
            //  and now.
            break;
        }
        if (bFirstTimeInLoop) {
            bFirstTimeInLoop = FALSE;
        } else {
            dwResult = WaitForSingleObject(m_hEventHandle,dwWaitTime);
            if (dwResult != WAIT_OBJECT_0) {
                TRC_ERR((TB,TEXT("Timed waiting for event.")));
		        goto FAILURE;
            }
        }
        while (lpMsg = xReceiveMessage(0,m_PlayerID,DPRECEIVE_TOPLAYER)) {
            if (lpMsg->dwType == DPSYS_SECUREMESSAGE) {
                lpMsgSec = (LPDPMSG_SECUREMESSAGE)lpMsg;
                if (!(lpMsgSec->dwFlags & (DPSEND_SIGNED|DPSEND_ENCRYPTED))) {
		            TRC_ERR((TB,TEXT("Message not signed or encrypted.")));
		            goto FAILURE;
	            }

	            parms = (BSTR)new BYTE [lpMsgSec->dwDataSize];
	            if (!parms) {
                    TRC_ERR((TB,TEXT("Out of memory")));
		            goto FAILURE;
	            }
	
	            CopyMemory(parms,lpMsgSec->lpData,lpMsgSec->dwDataSize);
                break;
            } else if (lpMsg->dwType == DPSYS_CONNECTPARMSMSG) {
                lpMsgUnsec = (LPDPMSG_CONNECTPARMS)lpMsg;
                parms = (BSTR)new BYTE [lpMsgUnsec->dwDataSize];
	            if (!parms) {
                    TRC_ERR((TB,TEXT("Out of memory")));
		            goto FAILURE;
	            }
	
	            CopyMemory(parms,((PCHAR)lpMsgUnsec) + sizeof(DPMSG_CONNECTPARMS),
                    lpMsgUnsec->dwDataSize);
                break;
            } else {
                delete lpMsg;
                lpMsg = NULL;
            }
        }
        if (lpMsg) {
            break;
        }
    }
    if (!lpMsg) {
        TRC_ERR((TB,TEXT("No messages ever showed up.")));
		goto FAILURE;
    }

    
	
	delete lpMsg;
	
    DC_END_FN();

    return parms;

FAILURE:
	if (lpMsg) {
		delete lpMsg;
	}
	if (parms) {
		delete parms;
	}
	throw CException(IDS_DPERRORRECEIVE);
}

BOOL
CDirectPlayConnection::IsServer(
    )
/*++

Routine Description:

    This returns whether or not this is the server.

Arguments:

    None

Return Value:

    BOOL - Is this the server

--*/
{
	DC_BEGIN_FN("CDirectPlayConnection::IsServer");
    if (!m_bConnected) {
		TRC_ERR((TB,TEXT("Not connected to remote application")));
		throw CException(IDS_DPNOTCONNECTED);
	}

    DC_END_FN();
	return (m_rSettings->dwFlags & DPLCONNECTION_CREATESESSION);
}


DPID
CDirectPlayConnection::xGetOtherPlayerID(
    )
/*++

Routine Description:

    This finds out what the playerID for the remote session is.  If the player
    has not yet been created we loop waiting for it to be created.

Arguments:

    None

Return Value:

    None

--*/
{
    LPDPMSG_GENERIC lpMsg = NULL;
    LPDPMSG_CREATEPLAYERORGROUP lpCreateMsg; 
    DWORD dwResult;
    DWORD dwWaitTime;
    DWORD timeOutTime;
    DPID otherPlayer = 0;
    CALLBACKDATA playerData;
    HRESULT hr;

    DC_BEGIN_FN("CDirectPlayConnection::xGetOtherPlayerID");

    playerData.bSet = FALSE;
    hr = m_rDirectPlay->EnumPlayers(NULL,PlayerCallback,&playerData,DPENUMPLAYERS_REMOTE);
	if (hr == DP_OK && playerData.bSet) {
		DC_END_FN();
        return playerData.playerID;
	}

    timeOutTime = GetTickCount() + GETREMOTEPLAYERTIMEOUT;
	while (timeOutTime > GetTickCount()) {
        dwWaitTime = timeOutTime - GetTickCount();
        if (dwWaitTime <= 0) {
            //  We hit time between the beginning of the loop
            //  and now.
            break;
        }
        dwResult = WaitForSingleObject(m_hEventHandle,dwWaitTime);
        if (dwResult != WAIT_OBJECT_0) {
            TRC_ERR((TB,TEXT("Timed out waiting for event.")));
	        throw CException(IDS_DPERRORTIMEOUT);
        }
        while (lpMsg = xReceiveMessage(DPID_SYSMSG,m_PlayerID,
            DPRECEIVE_TOPLAYER|DPRECEIVE_FROMPLAYER)) {
            if (lpMsg->dwType == DPSYS_CREATEPLAYERORGROUP) {
                lpCreateMsg = (LPDPMSG_CREATEPLAYERORGROUP)lpMsg;
                if (lpCreateMsg->dwPlayerType == DPPLAYERTYPE_PLAYER) {
                    if (lpCreateMsg->dpId != m_PlayerID) {
                        otherPlayer = lpCreateMsg->dpId;
                        break;
                    }
                }
            }
            delete lpMsg;
        }
        if (otherPlayer) {
            break;
        }
    }
    if (lpMsg) {
        delete lpMsg;
    }

    if (otherPlayer) {
        DC_END_FN();
        return otherPlayer;
    }

    TRC_ERR((TB,TEXT("Timed out waiting to find remote player.")));
	throw CException(IDS_DPERRORTIMEOUT);
}

static BOOL FAR PASCAL
PlayerCallback(
    IN DPID dpId,
    IN DWORD dwPlayerType,
    IN LPCDPNAME lpName,
    IN DWORD dwFlags,
    IN OUT LPVOID lpContext
    )
/*++

Routine Description:

    This is the callback for the direct play player enumeration functin.
    We just set what the other playerID is and then return.

Arguments:

    None

Return Value:

    BOOL - Should we continue the enumeration.

--*/
{
    DC_BEGIN_FN("PlayerCallback");
	LPCALLBACKDATA data = (LPCALLBACKDATA)lpContext;
	data->playerID = dpId;
	data->bSet = TRUE;
	DC_END_FN();
    return FALSE;
}


LPDPMSG_GENERIC
CDirectPlayConnection::xReceiveMessage(
    IN DPID from,
    IN DPID to,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    This reads the next message for the given from and to addresses.

Arguments:

    from - Who the message is from.

    to - Who the message is to.

    dwFlags - flags for the incoming message. 

Return Value:

    LPDPMSG_GENERIC - If there was a message.

    NULL - There was not a message available.

--*/
{
    HRESULT hr;
    LPVOID lpMsg;
    DWORD dwSize = 0;

    DC_BEGIN_FN("CDirectPlayConnection::xReceiveMessage");

    hr = m_rDirectPlay->Receive(&from,&to,dwFlags,NULL,&dwSize);
    if (hr != DPERR_BUFFERTOOSMALL) {
        if (hr == DPERR_NOMESSAGES) {
            DC_END_FN();
            return NULL;
        } else {
            TRC_ERR((TB,TEXT("Error receiving message size.")));
            goto FAILURE;
        }
    }
    lpMsg = (LPVOID)new BYTE [dwSize];
    if (!lpMsg) {
        TRC_ERR((TB,TEXT("Out of memory.")));
        goto FAILURE;
    }
    hr = m_rDirectPlay->Receive(&from,&to,dwFlags,lpMsg,&dwSize);
    if (hr != DP_OK) {
        TRC_ERR((TB,TEXT("Error receiving message.")));
        goto FAILURE;
    }

    DC_END_FN();
    return (LPDPMSG_GENERIC)lpMsg;

FAILURE:

    if (lpMsg) {
        delete lpMsg;
    }
    throw CException(IDS_DPERRORMSGRECIEVE);
}











static BOOL
SendLaunchSuccessful(
    IN OUT LPDIRECTPLAYLOBBY2 pLobby
    )
{
	HRESULT hr;
	DPLMSG_GENERIC msg;
	
	msg.dwType = DPLSYS_DPLAYCONNECTSUCCEEDED;
	hr = pLobby->SendLobbyMessage( DPLMSG_STANDARD, 0, &msg, sizeof(msg) );
	if ( FAILED(hr) )
	{
		MessageBox( NULL, TEXT("Send system message failed."), TEXT("Error"), MB_OK |
               	MB_APPLMODAL );
		return false;
	}

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\msngr\exception.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Exception

Abstract:

    This is a simple class to do exceptions.  The only thing it does
    is return an error string.

Author:

    Marc Reyhner 7/17/2000

--*/

#ifndef __EXCEPTION_H__
#define __EXCEPTION_H__

#include "rcontrol.h"


////////////////////////////////////////////////
//
//    CException
//
//    Class for doing exceptions.
//
class CException  
{
public:
	CException(UINT uID);
    CException(CException &rException);

    inline LPCTSTR GetErrorStr() const
    {
        DC_BEGIN_FN("CException::GetErrorStr");
        DC_END_FN();
        return m_errstr;   
    };

private:

    TCHAR m_errstr[MAX_STR_LEN];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\msngr\remotedesktopclienteventsink.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RemoteDesktopClientEventSink

Abstract:

    This listens to the events from the IRemoteDesktopClient so
    we can find out when the server connects.

Author:

    Marc Reyhner 7/11/2000

--*/

#include "stdafx.h"

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE "rcrdces"

#include "rcontrol.h"
#include "RemoteDesktopClientSession.h"
#include "RemoteDesktopClientEventSink.h"
#include "Resource.h"



CRemoteDesktopClientEventSink::CRemoteDesktopClientEventSink(
    IN OUT CRemoteDesktopClientSession *obj
    )

/*++

Routine Description:

    Create a new event sink and save the pointer back to the
    CRemoteDesktopClientSession we are monitoring.

Arguments:

    obj - The CRemoteDesktopClientSession we are monitoring events for

Return Value:

    None

--*/
{
    DC_BEGIN_FN("CRemoteDesktopClientEventSink::CRemoteDesktopClientEventSink");
    m_Obj = obj;
    DC_END_FN();
}


VOID __stdcall
CRemoteDesktopClientEventSink::OnConnected(
    )

/*++

Routine Description:

    We are connected to the server so we want to remote control the desktop.

Arguments:

    None

Return Value:

    None

--*/
{
	DC_BEGIN_FN("CRemoteDesktopClientEventSink::OnConnected");
    
    m_Obj->ConnectRemoteDesktop();
    
    DC_END_FN();
}


VOID __stdcall
CRemoteDesktopClientEventSink::OnDisconnected(
    IN LONG reason
    )

/*++

Routine Description:

    We've been disconnected.  We currently don't do
    anything here.

Arguments:

    reason - Why we were disconnected.

Return Value:

    None

--*/
{
    TCHAR dlgTitle[MAX_STR_LEN];
    TCHAR dlgText[MAX_STR_LEN];
    
    DC_BEGIN_FN("CRemoteDesktopClientEventSink::OnDisconnected");
    
    if (reason != S_OK) {
        TRC_ERR((TB,TEXT("We were disconnected with code 0x%0X"),reason));
    }
    LoadStringSimple(IDS_CLIENTREMOTEDISCONNECT,dlgText);
    LoadStringSimple(IDS_CLIENTWNDTITLE,dlgTitle);
    MessageBox(m_Obj->m_hWnd,dlgText,dlgTitle,MB_OK);
    DestroyWindow(m_Obj->m_hWnd);

    DC_END_FN();
}

VOID __stdcall
CRemoteDesktopClientEventSink::OnRemoteControlRequestComplete(
    IN LONG status
    )

/*++

Routine Description:

    This never gets called so we can't do anything here.

Arguments:

    status - The status of our request.

Return Value:

    None

--*/
{
    TCHAR dlgTitle[MAX_STR_LEN];
    TCHAR dlgText[MAX_STR_LEN];

    DC_BEGIN_FN("CRemoteDesktopClientEventSink::OnRemoteControlRequestComplete");
    
    if (status != S_OK) {
        TRC_ERR((TB,TEXT("Remote control failed with code 0x%0X"),status));

        LoadStringSimple(IDS_CLIENTWNDTITLE,dlgTitle);
        LoadStringSimple(IDS_CLIENTREMOTEFAIL,dlgText);
        MessageBox(m_Obj->m_hWnd,dlgText,dlgTitle,MB_OK|MB_ICONWARNING);
        DestroyWindow(m_Obj->m_hWnd);
    } else {
        // this isn't getting called but it should be.
        m_Obj->m_ApprovalDlg.DestroyDialog();
    }
    
    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\msngr\rcontrol.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Rcontrol Main

Abstract:

    This includes WinMain and the WndProc for the system tray icon.

Author:

    Marc Reyhner 7/5/2000


--*/

#ifndef __RCONTROL_H__
#define __RCONTROL_H__

#include <guiddef.h>
//
// Debug tracing headers
//


//
//  Disable tracing for free builds.
//
#if DBG
#define TRC_CL TRC_LEVEL_DBG
#define TRC_ENABLE_PRF
#else
#define TRC_CL TRC_LEVEL_DIS
#undef TRC_ENABLE_PRF
#endif

//
//  Required for DCL Tracing
//
#define OS_WIN32
#define TRC_GROUP TRC_GROUP_NETWORK
#define DEBUG_MODULE DBG_MOD_ANY
#include <adcgbase.h>
#include <at120ex.h>
#include <atrcapi.h>
#include <adcgbase.h>
#include <at120ex.h>

class CDirectPlayConnection;

//  This is a pointer to our instance so that we can pass it off to some
//  of the menu functions.
extern HINSTANCE g_hInstance;

//  This is the structure for setting parameters for the taskbar icon.  We keep one copy
//  of it around that we can pass in to Shell_NotifyIcon
extern NOTIFYICONDATA g_iconData;

//  This is a global pointer to the direct play connection so that
//  the server can close the DP connection on connect.
extern CDirectPlayConnection *g_DpConnection;

//  This is the max length of a string to be loaded from the appliction
//  string table
#define MAX_STR_LEN 1024

//  This is the string loaded when the requested resource can't be found
#define STR_RES_MISSING (TEXT("Error: string resource missing"))

//
//  This will load the given string from the applications string table.  If
//  it is longer than MAX_STR_LEN it is truncated.  lpBuffer should be at least
//  MAX_STR_LEN characters long.  If the string does not exist we return 0
//  and set the buffer to STR_RES_MISSING.
//
INT LoadStringSimple(UINT uID, LPTSTR lpBuffer);

DEFINE_GUID(DIID__ISAFRemoteDesktopClientEvents,0x327A98F6,0xB337,0x43B0,0xA3,0xDE,0x40,0x8B,0x46,0xE6,0xC4,0xCE);

DEFINE_GUID(IID_ISAFRemoteDesktopSession,0x9D8C82C9,0xA89F,0x42C5,0x8A,0x52,0xFE,0x2A,0x77,0xB0,0x0E,0x82);

DEFINE_GUID(IID_ISAFRemoteDesktopServerHost,0xC9CCDEB3,0xA3DD,0x4673,0xB4,0x95,0xC1,0xC8,0x94,0x94,0xD9,0x0E);

DEFINE_GUID(CLSID_SAFRemoteDesktopServerHost,0x5EA6F67B,0x7713,0x45F3,0xB5,0x35,0x0E,0x03,0xDD,0x63,0x73,0x45);

DEFINE_GUID(DIID__ISAFRemoteDesktopSessionEvents,0x434AD1CF,0x4054,0x44A8,0x93,0x3F,0xC6,0x98,0x89,0xCA,0x22,0xD7);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\msngr\remotedesktopclientsession.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RemoteDesktopClientSession

Abstract:

    RemoteDesktopClientSession manages the client side GUI for the application
    hostiving the Salem ActiveX control.

Author:

    Marc Reyhner 7/11/2000

--*/

#ifndef __REMOTEDESKTOPCLIENTSESSION_H__
#define __REMOTEDESKTOPCLIENTSESSION_H__

#include "stdafx.h"
#include "rdchost.h"
#include <atlwin.h>
#include "ApprovalDialog.h"
#include "StaticOkDialog.h"	//  Added by ClassView

//  A forward declaration of the event sink.
class CRemoteDesktopClientEventSink;


////////////////////////////////////////////////
//
//    CRemoteDesktopClientSession
//
//    This manages all of the client side GUI.
//

class CRemoteDesktopClientSession  
{
private:
    VOID DoMessageLoop();
    static LRESULT CALLBACK _WindowProc(HWND hWnd, UINT uMsg,
        WPARAM wParam, LPARAM lParam);
	// All the message handler functions.
    VOID OnAbout();
    LRESULT OnCommand(WPARAM wParam, LPARAM lParam);
    LRESULT OnCreate(HWND hWnd);
	VOID OnDestroy();
    VOID OnSetFocus();
	VOID OnSize(WORD width, WORD height);
    
    HINSTANCE m_hInstance;
	HWND m_hWnd;
    HWND m_hRdcHostWnd;
    ISAFRemoteDesktopClient *m_RemDeskClient;
    CRemoteDesktopClientEventSink * m_Sink;
    CApprovalDialog m_ApprovalDlg;
    CStaticOkDialog m_AboutDlg;

public:

	CRemoteDesktopClientSession(HINSTANCE hInstance);
    virtual ~CRemoteDesktopClientSession();
    VOID DoClientSession(BSTR parms);
	
    //  These two methods are meant to be used by either the event
    //  sink or the dialogs not the user of the class.
    VOID ShowRemdeskControl();
	VOID ConnectRemoteDesktop();

    // Let the event sink have access to the member variables
    friend class CRemoteDesktopClientEventSink;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\msngr\remotedesktopclientsession.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RemoteDesktopClientSession

Abstract:

    RemoteDesktopClientSession manages the client side GUI for the application
    hostiving the Salem ActiveX control.

Author:

    Marc Reyhner 7/11/2000

--*/

#include "stdafx.h"

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE "rcrdcs"

#include "RemoteDesktopClientSession.h"
#include "RemoteDesktopClientEventSink.h"
#include "resource.h"
#include "exception.h"

//
//  The guid for the ActiveX control we are creating the child window for.
//

#define REMOTEDESKTOPHOST_TEXTGUID TEXT("{299BE050-E83E-4DB7-A7DA-D86FDEBFE6D0}")

CRemoteDesktopClientSession::CRemoteDesktopClientSession(
    IN OUT HINSTANCE hInstance
    )

/*++

Routine Description:

    The only thing the constructor does is to save hInstance and to
    set gm_Session to be this class.

Arguments:

    hInstance - The instance for this module.

Return value:

    None.

--*/
{
    DC_BEGIN_FN("CRemoteDesktopClientSession::CRemoteDesktopClientSession");

    m_hWnd = NULL;
    m_hRdcHostWnd = NULL;
    m_RemDeskClient = NULL;
    m_Sink = NULL;

    m_hInstance = hInstance;

    DC_END_FN();
}

CRemoteDesktopClientSession::~CRemoteDesktopClientSession(
    )

/*++

Routine Description:

    We just NULL the gm_Session pointer here since everything else
    was already cleaned up.

Arguments:

    None.

Return value:

    None.

--*/
{
    DC_BEGIN_FN("CRemoteDesktopClientSession::~CRemoteDesktopClientSession");

    DC_END_FN();
}

VOID
CRemoteDesktopClientSession::DoClientSession(
    IN BSTR parms
    )

/*++

Routine Description:

    Here we start and manage the entire client GUI.

Arguments:

    parms - The string needed for Salem to connect to the remote server.

Return value:

    None.

--*/
{
	DC_BEGIN_FN("CRemoteDesktopClientSession::DoClientSession");
    
    HRESULT hr;

    ATOM atom;
    TCHAR wndTitle[MAX_STR_LEN];
    HICON wndIcon = (HICON)LoadImage(m_hInstance,MAKEINTRESOURCE(IDI_TRAYICON),
        IMAGE_ICON,0,0,0);
    WNDCLASS wndClass = { CS_PARENTDC, _WindowProc, 0, 0, m_hInstance, wndIcon, NULL,
        (HBRUSH)COLOR_WINDOWFRAME,MAKEINTRESOURCE(IDR_CLIENTMENU),TEXT("RdcWndClass") };
    
    AtlAxWinInit();
    atom = RegisterClass(&wndClass);
    if (!atom) {
        TRC_ERR((TB,TEXT("Error registering window class for main frame.")));
        goto FAILURE;
    }
    LoadStringSimple(IDS_CLIENTWNDTITLE,wndTitle);
    m_hWnd = CreateWindowEx(WS_EX_CLIENTEDGE,(LPCTSTR)atom,wndTitle,
        WS_VISIBLE|WS_OVERLAPPEDWINDOW|WS_CLIPCHILDREN,
        50,50,690,530,NULL,NULL,m_hInstance,this);
    if (!m_hWnd) {
        TRC_ERR((TB,TEXT("Error creating main frame.")));
        goto FAILURE;
    }

    
    
    SetForegroundWindow(m_hWnd);
    
    m_Sink = new CRemoteDesktopClientEventSink(this);
    if (!m_Sink) {
        TRC_ERR((TB,TEXT("Error creating client event sink.")));
        goto FAILURE;
    }
	
    hr = m_Sink->DispEventAdvise(m_RemDeskClient);
    if (hr != S_OK) {
        goto FAILURE;
    }

    hr = m_RemDeskClient->put_ConnectParms(parms);
    if (hr != S_OK) {
        goto FAILURE;
    }
    
    hr = m_RemDeskClient->ConnectToServer(NULL);
    if (hr != S_OK) {
        goto FAILURE;
    }

    DoMessageLoop();
    
    delete m_Sink;
    m_Sink = NULL;

    DestroyIcon(wndIcon);
    
    DC_END_FN();
    
    return;

FAILURE:
    throw CException(IDS_CLIENTERRORCREATE);
}



LRESULT CALLBACK 
CRemoteDesktopClientSession::_WindowProc(
    IN OUT HWND hWnd,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam 
    )

/*++

Routine Description:

    The window proc calls the appropriate message handler for the messages
    that we care about.

Arguments:

    hWnd - The window the message is for.

    uMsg - The message.

    wParam - WPARAM for the message.

    lParam - LPARAM for the message.

Return value:

    LRESULT - The message specific return code. See MSDN for details.

--*/
{
    LRESULT retValue = 0;
    CRemoteDesktopClientSession *session;

    DC_BEGIN_FN("CRemoteDesktopClientSession::_WindowProc");

    if (uMsg != WM_CREATE) {
        session = (CRemoteDesktopClientSession*)GetWindowLongPtr(hWnd,GWLP_USERDATA);
    }

    switch (uMsg) {
    case WM_CREATE:
        session = (CRemoteDesktopClientSession*)
            ((LPCREATESTRUCT)lParam)->lpCreateParams;
        SetWindowLongPtr(hWnd,GWLP_USERDATA,(long)session);
        retValue = session->OnCreate(hWnd);
        break;        
    
    case WM_COMMAND:
        if (session) {
            retValue = session->OnCommand(wParam,lParam);
        }
        break;
    case WM_DESTROY:
        if (session) {
            session->OnDestroy();
        }
        break;
    case WM_SETFOCUS:
        if (session) {
            session->OnSetFocus();
        }
        break;
    case WM_SIZE:
        if (session) {
            session->OnSize(LOWORD(lParam),HIWORD(lParam));
        }
        break;
    default:
        retValue = DefWindowProc(hWnd,uMsg,wParam,lParam);
    }

    DC_END_FN();
    return retValue;
}

VOID
CRemoteDesktopClientSession::DoMessageLoop(
    )

/*++

Routine Description:

    This runs through your normal event loop until we get a WM_QUIT.
    Any dialogs that messages should be caught for need to be inserted
    into this function.

Arguments:

    None.

Return value:

    None.

--*/
{
    MSG msg;

    DC_BEGIN_FN("CRemoteDesktopClientSession::DoMessageLoop");

    while (GetMessage(&msg,NULL,0,0)>0) {
        if (!m_AboutDlg.DialogMessage(&msg) && !m_ApprovalDlg.DialogMessage(&msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    DC_END_FN();
}

LRESULT
CRemoteDesktopClientSession::OnCreate(
    IN OUT HWND hWnd
    )

/*++

Routine Description:

    When the window is being created we create the child window and get a pointer
    to the IRemoteDesktopClient for the control.  If there is a problem we return
    -1 and the window is not created.

Arguments:

    hWnd - The window being created.

Return value:
    
    0  - The window was created correctly.

    -1 - There was an error creating the window.

--*/
{
    HRESULT hr;
    IUnknown *pUnk = NULL;
    ISAFRemoteDesktopClientHost *remClientHost = NULL;

    DC_BEGIN_FN("CRemoteDesktopClientSession::OnCreate");

    m_hRdcHostWnd = CreateWindow(TEXT("AtlAxWin"),REMOTEDESKTOPHOST_TEXTGUID,
        WS_CHILD|WS_CLIPCHILDREN|WS_VISIBLE,0,0,0,0,hWnd,NULL,m_hInstance,NULL);
    if (!m_hRdcHostWnd) {
        TRC_ERR((TB,TEXT("Error creating Salem window.")));
        goto FAILURE;
    }
    hr = AtlAxGetControl(m_hRdcHostWnd,&pUnk);
    if (hr != S_OK) {
        TRC_ERR((TB,TEXT("Error getting IUnknown from salem window.")));
        goto FAILURE;
    }
    hr = pUnk->QueryInterface(__uuidof(ISAFRemoteDesktopClientHost),(LPVOID*)&remClientHost);
    if (hr != S_OK) {
        TRC_ERR((TB,TEXT("Error getting IRemoteDesktopClientHost from Salem control.")));
        goto FAILURE;
    }
    pUnk->Release();
    pUnk = NULL;
    
    hr = remClientHost->GetRemoteDesktopClient(&m_RemDeskClient);
    if (hr != S_OK) {
        TRC_ERR((TB,TEXT("Error gettin IRemoteDesktopClient from host.")));
        goto FAILURE;
    }
    remClientHost->Release();
    remClientHost = NULL;
    
    DC_END_FN();

    return 0;

FAILURE:
    if (m_hRdcHostWnd) {
        DestroyWindow(m_hRdcHostWnd);
        m_hRdcHostWnd = NULL;
    }
    if (pUnk) {
        pUnk->Release();
        pUnk = NULL;
    }
    if (remClientHost) {
        remClientHost->Release();
        remClientHost = NULL;
    }
    return -1;
}

VOID
CRemoteDesktopClientSession::OnSize(
    IN WORD width,
    IN WORD height
    )

/*++

Routine Description:

    We keep the child window the same as our new size.

Arguments:

    None.

Return value:
    
    None.

--*/
{
    DC_BEGIN_FN("CRemoteDesktopClientSession::OnSize");
    
    SetWindowPos(m_hRdcHostWnd,NULL,0,0,width,height,SWP_NOZORDER);

    DC_END_FN();
}

VOID 
CRemoteDesktopClientSession::ConnectRemoteDesktop(
    )

/*++

Routine Description:

    We initiate a request to control the remote desktop and pop up the
    approval warning dialog.

Arguments:

    None.

Return value:
    
    None.

--*/
{
    DC_BEGIN_FN("CRemoteDesktopClientSession::ConnectRemoteDesktop");
    
    m_RemDeskClient->ConnectRemoteDesktop();
    m_ApprovalDlg.m_rObj = this;
    m_ApprovalDlg.Create(m_hInstance,IDD_APPROVALWAIT,m_hWnd);

    DC_END_FN();
}

VOID
CRemoteDesktopClientSession::OnAbout(
    )

/*++

Routine Description:

    We either create or bring to the foreground the about box.

Arguments:

    None.

Return value:
    
    None.

--*/
{
    DC_BEGIN_FN("CRemoteDesktopClientSession::OnAbout");

    if (m_AboutDlg.IsCreated()) {
        m_AboutDlg.Activate();
    } else {
        m_AboutDlg.Create(m_hInstance,IDD_ABOUT,m_hWnd);
    }

    DC_END_FN();
}

LRESULT
CRemoteDesktopClientSession::OnCommand(
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    When the window is destroyed we disconnect from the remote host and then
    send a quit message to exit the event loop.

Arguments:

    wParam - The command which was triggered.

    lParam - The control the command came from.

Return value:
    
    0 - We handled the command.

    1 - We did not handle the command.

--*/
{
    LRESULT retValue = 0;

    DC_BEGIN_FN("CRemoteDesktopClientSession::OnCommand");

    switch (wParam) {
    case ID_EXIT:
        DestroyWindow(m_hWnd);
        break;
    case ID_ABOUT:
        OnAbout();
        break;
    default:
        retValue = 1;
    }

    DC_END_FN();

    return retValue;
}

VOID
CRemoteDesktopClientSession::OnDestroy(
    )

/*++

Routine Description:

    When the window is destroyed we disconnect from the remote host and then
    send a quit message to exit the event loop.

Arguments:

    None.

Return value:
    
    None.

--*/
{
    BOOL isConnected;
    HRESULT hr;
    
    DC_BEGIN_FN("CRemoteDesktopClientSession::OnDestroy");

    if(m_RemDeskClient) {
        hr = m_RemDeskClient->get_IsRemoteDesktopConnected(&isConnected);
        if (hr == S_OK && isConnected) {
            m_RemDeskClient->DisconnectRemoteDesktop();
        }
        m_RemDeskClient->DisconnectFromServer();
    }
    PostQuitMessage(0);

    DC_END_FN();
}

VOID
CRemoteDesktopClientSession::ShowRemdeskControl(
    )

/*++

Routine Description:

    This makes our child window visible.

Arguments:

    None.

Return value:
    
    None.

--*/
{
    DC_BEGIN_FN("CRemoteDesktopClientSession::ShowRemdeskControl");

    ShowWindow(m_hRdcHostWnd,SW_SHOW);

    DC_END_FN();
}

VOID
CRemoteDesktopClientSession::OnSetFocus(
    )

/*++

Routine Description:

    When we get focus we pass it off to our child window.

Arguments:

    None.

Return value:
    
    None.

--*/
{
    DC_BEGIN_FN("CRemoteDesktopClientSession::OnSetFocus");
    
    SetFocus(m_hRdcHostWnd);

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\msngr\rcontrol.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Rcontrol Main

Abstract:

    This includes WinMain and the WndProc for the system tray icon.

Author:

    Marc Reyhner 7/5/2000


--*/

#include "stdafx.h"
#include <initguid.h>

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE    "rcm"

#include "rcontrol.h"
#include "resource.h"
#include "exception.h"
#include "DirectPlayConnection.h"
#include "RemoteDesktopClientSession.h"
#include "RemoteDesktopServer.h"
#include "RemoteDesktopServerEventSink.h"

//  This is the message that will will get when someone does something to the
//  taskbar icon.
#define WM_SYSICONMESSAGE (WM_USER + 1)


//
//
//
#define MUTEX_NAME (TEXT("Local\\MICROSOFT_SALEM_IM_MUTEX"))

//  This is a pointer to our instance so that we can pass it off to some
//  of the menu functions.
HINSTANCE g_hInstance;

//  This is the structure for setting parameters for the taskbar icon.  We keep one copy
//  of it around that we can pass in to Shell_NotifyIcon
NOTIFYICONDATA g_iconData;

//  This is a global pointer to the direct play connection so that
//  the server can close the DP connection on connect.
CDirectPlayConnection *g_DpConnection;

//  This helper function lauches the executable for the gui passing it the
//  connection parameters on the command line.
static VOID 
LaunchClient(
    HINSTANCE hInstance,
    BSTR parms
    );

//  This helper function runs the system tray icon if this is a server.
static VOID
DoSystemTray(   
    );

//  This is the WndProc for the taskbar icon
static LRESULT CALLBACK
SysTrayWndProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT WINAPI
WinMain(
    IN HINSTANCE hInstance, 
    IN HINSTANCE hPrevInstance,
    IN LPSTR lpCmdLine,
    IN INT nShowCmd)
/*++

Routine Description:

    The entry point for the application.  This figures out
    if we are a server or client and then behaves accordingly.

Arguments:

    hInstance - The instance for this application.

    hPrevInstance - Previous instance, should be NULL

    lpCmdLine - Command line for the application.

    nShowCmd - Flags for how to show the application.

Return value:

    INT - The return code for the application.

--*/
{
    HANDLE lpMutex = NULL;
    DWORD error;
    BSTR serverParms, clientParms;
    
    DC_BEGIN_FN("WinMain");

    serverParms = NULL;
    clientParms = NULL;
    g_hInstance = hInstance;
    
    CoInitialize(NULL);
    try {
        CDirectPlayConnection connection;
        
        g_DpConnection = &connection;
        connection.ConnectToRemoteApplication();
        if (connection.IsServer()) {
            // we are a server
            
            CRemoteDesktopServer server;
            CRemoteDesktopServerEventSink sink;
            HRESULT hr;

            lpMutex = CreateMutex(NULL,TRUE,MUTEX_NAME);
            if (!lpMutex) {
                throw CException(IDS_INITERRORMUTEX);
            }
            error = GetLastError();
            if (error == ERROR_ALREADY_EXISTS) {
                throw CException(IDS_INITALREADYEXISTS);
            }
            serverParms = server.StartListening();
            hr = server.EventSinkAdvise(&sink);
            if (hr != S_OK) {
                throw CException(IDS_ADVISEERROR);
            }
            connection.SendConnectionParameters(serverParms);
            DoSystemTray();
            try {
                server.StopListening();
            } catch (CException e) {
                TRC_ERR((TB,TEXT("Caught Exception: %s"),e.GetErrorStr()));
                // We are shutting down so just suppress the error.
            }
            CloseHandle(lpMutex);
        } else {
            // we are the client
            
            clientParms = connection.ReceiveConnectionParameters();
            connection.DisconnectRemoteApplication();
            LaunchClient(hInstance,clientParms);
        }
    } catch (CException e) {
        TCHAR dlgTitle[MAX_STR_LEN];
        
        TRC_ERR((TB,TEXT("Caught Exception: %s"),e.GetErrorStr()));
        LoadStringSimple(IDS_ERRORDDLGTITLE,dlgTitle);
        MessageBox(NULL,e.GetErrorStr(),dlgTitle,MB_OK|MB_ICONERROR);
    }
    if (clientParms) {
        delete clientParms;
    }

    CoUninitialize();

    DC_END_FN();
    
    return 0;
}

static VOID
LaunchClient(
    IN OUT HINSTANCE hInstance,
    IN BSTR parms
    )

/*++

Routine Description:

    This starts (and does) the client GUI side of the application.
    DoClientSession will not returne until the client GUI is totally
    done.

Arguments:

    hInstance - The instance for this application

    parms - The connection parameters for connecting to the server.

Return value:
    
    None

--*/
{
    DC_BEGIN_FN("LaunchClient");

    CRemoteDesktopClientSession clientSession(hInstance);
    
    clientSession.DoClientSession(parms);

    DC_END_FN();
}


static VOID
DoSystemTray(
    )
/*++

Routine Description:

    This creates the system tray and enters the event loop
    until the a WM_QUIT message is generated.

Arguments:

    None

Return value:

    None

--*/
{
    MSG msg;
    WNDCLASS wndClass;
    ATOM className;
    HWND hWnd;
    TCHAR tipText[MAX_STR_LEN];

    DC_BEGIN_FN("DoSystemTray");

    wndClass.style = 0; 
    wndClass.lpfnWndProc = SysTrayWndProc;
    wndClass.cbClsExtra = 0; 
    wndClass.cbWndExtra = 0; 
    wndClass.hInstance = g_hInstance; 
    wndClass.hIcon = NULL; 
    wndClass.hCursor = NULL; 
    wndClass.hbrBackground = NULL; 
    wndClass.lpszMenuName = NULL;
    //  This is an internal name so we don't need to localize this.
    wndClass.lpszClassName = TEXT("SysTrayWindowClass");
    className = RegisterClass(&wndClass);
    
    hWnd = CreateWindow((LPCTSTR)className,TEXT(""),0,0,0,0,0,/*HWND_MESSAGE*/0,NULL,NULL,NULL);
    if (hWnd == NULL) {
        throw "Failed to create system tray icon.";
    }

    g_iconData.cbSize = sizeof(g_iconData);
    g_iconData.hIcon = ::LoadIcon(g_hInstance,MAKEINTRESOURCE(IDI_TRAYICON));
    g_iconData.hWnd = hWnd;
    LoadStringSimple(IDS_TRAYTOOLTIPDISCONNECTED,tipText);
    // The buffer is only 128 chars.
    _tcsncpy(g_iconData.szTip,tipText,128 - 1);
    g_iconData.uCallbackMessage = WM_SYSICONMESSAGE;
    g_iconData.uFlags = NIF_ICON|NIF_MESSAGE |NIF_TIP;
    g_iconData.uID = 0;
    g_iconData.uVersion = NOTIFYICON_VERSION;

    Shell_NotifyIcon(NIM_ADD,&g_iconData);
    g_iconData.uFlags = 0;
    Shell_NotifyIcon(NIM_SETVERSION,&g_iconData);
    
    // Do our message loop.
    while (GetMessage(&msg, (HWND) NULL, 0, 0)>0) 
    { 
        TranslateMessage(&msg); 
        DispatchMessage(&msg); 
    }
    Shell_NotifyIcon(NIM_DELETE,&g_iconData);
    
    DC_END_FN();
}


static LRESULT CALLBACK
SysTrayWndProc(
    IN HWND hWnd,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Callback for our taskbar icon.  This handles all the window messages
    related to the icon.

Arguments:

    hWnd - Window the message is for

    uMsg - The message code

    wParam - First message flag

    lParam - Second message flag

Return value:
    
    LRESULT - The result of processing the message

--*/
{
    //  This is the window message for when the taskbar
    //  is recreated.  We will just initialize it once on
    //  WM_CREATE
    static UINT g_wmTaskbarCreated = 0;
    // This is the code we will return.  We will initialize it to 1.
    LRESULT result = 1;

    DC_BEGIN_FN("SysTrayWndProc");
    
    //  If the taskbar is recreates (i.e. explorer crashed) it will
    //  give us this message.  When that happens we want to re-create
    //  the taskbar icon.

    if (uMsg == g_wmTaskbarCreated) {
        g_iconData.uFlags = NIF_ICON|NIF_MESSAGE |NIF_TIP;
        Shell_NotifyIcon(NIM_ADD,&g_iconData);
        g_iconData.uFlags = 0;
        Shell_NotifyIcon(NIM_SETVERSION,&g_iconData);
        DC_END_FN();
        return 0;
    }
    switch (uMsg) {
    case WM_CREATE:
        g_wmTaskbarCreated = RegisterWindowMessage(TEXT("TaskbarCreated"));
        if (!g_wmTaskbarCreated) {
            result = -1;
        } else {
            result = 0;
        }
    case WM_SYSICONMESSAGE:
        switch (lParam) {
        case WM_CONTEXTMENU:
            POINT pos;
            HMENU hMenu, hSubmenu;
            GetCursorPos(&pos);
            hMenu = LoadMenu(g_hInstance,MAKEINTRESOURCE(IDR_TRAYMENU));
            hSubmenu = GetSubMenu(hMenu,0);
            SetForegroundWindow(hWnd);
            TrackPopupMenu(hSubmenu,TPM_VERNEGANIMATION,pos.x,pos.y,0,hWnd,NULL);
            // this also destroys the submenu
            DestroyMenu(hMenu);
            g_iconData.uFlags = 0;
            Shell_NotifyIcon(NIM_SETFOCUS,&g_iconData);
            result = 0;
            break;
        case WM_LBUTTONDOWN:
            PostMessage(hWnd,WM_COMMAND,ID_QUIT,NULL);
            result = 0;
            break;
        default:
            // Any other messages we will ignore
            result = 0;
        }
        break;
    case WM_COMMAND:
        switch (wParam) {
        case ID_QUIT:
            TCHAR dlgText[MAX_STR_LEN], dlgTitle[MAX_STR_LEN];
            LoadStringSimple(IDS_TRAYEXITDLGTEXT,dlgText);
            LoadStringSimple(IDS_TRAYEXITDLGTITLE,dlgTitle);
            if (IDYES == MessageBox(hWnd,dlgText,dlgTitle,MB_YESNO)) {
                PostQuitMessage(0);
            }
            result = 0;
            break;
        }
        break;
    default:
        //  We don't understand this message so do the default.
        result = DefWindowProc(hWnd,uMsg,wParam,lParam);
    }
    DC_END_FN();
    return result;
}

INT
LoadStringSimple(
    IN UINT uID,
    OUT LPTSTR lpBuffer
    )

/*++

Routine Description:

    This will load the given string from the applications string table.  If
    it is longer than MAX_STR_LEN it is truncated.  lpBuffer should be at least
    MAX_STR_LEN characters long.  If the string does not exist we return 0
    and set the buffer to IDS_STRINGMISSING, if that failes then we set it to the
    hard coded STR_RES_MISSING.

Arguments:

    uID - Id of the resource to load.

    lpBuffer - Buffer of MAX_STR_LEN to hold the string

Return value:
    
    0 - String resource could not be loaded.

    postive integer - length of the string loaded.

--*/
{
    INT length;
    
    DC_BEGIN_FN("LoadStringSimple");

    length = LoadString(g_hInstance,uID,lpBuffer,MAX_STR_LEN);
    if (length == 0) {
        length = LoadString(g_hInstance,IDS_STRINGMISSING,lpBuffer,MAX_STR_LEN);
        if (length == 0) {
            _tcscpy(lpBuffer,STR_RES_MISSING);
        }
        length = 0;
    }

    DC_END_FN();
    return length;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\msngr\remotedesktopserver.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RemoteDesktopServer

Abstract:

    The RemoteDesktopServer is the interface for dealing
    with the salem server classes.  It just presents
    the methods necessary for this application to use.

Author:

    Marc Reyhner 7/5/2000

--*/

#include "stdafx.h"

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE "rcrds"

#include "RemoteDesktopServer.h"
#include "RemoteDesktopServerEventSink.h"
#include "exception.h"
#include "resource.h"

CRemoteDesktopServer::CRemoteDesktopServer(
    )

/*++

Routine Description:

    This is the constructor for CRemoteDesktopServer.  It creates
    a server host object and then gets an IRemoteDesktopServer
    from the server host.  The server host is then destroyed.

Arguments:

    None

Return Value:

    None

--*/
{
	HRESULT hr;
	
    DC_BEGIN_FN("CRemoteDesktopServer::CRemoteDesktopServer");

    m_rServerHost = NULL;
    m_rServerSession = NULL;

	hr = CoCreateInstance(CLSID_SAFRemoteDesktopServerHost,NULL,CLSCTX_ALL ,
		IID_ISAFRemoteDesktopServerHost,(LPVOID*)&m_rServerHost);
	if (hr != S_OK) {
		TRC_ERR((TB,TEXT("Error creating ISAFRemoteDesktopServerHost: 0x%0X"),hr));
        goto FAILURE;
	}
	
    DC_END_FN();

    return;

FAILURE:
	if (m_rServerHost) {
		m_rServerHost->Release();
	}
	throw CException(IDS_SERVERRRORCREATE);
}

CRemoteDesktopServer::~CRemoteDesktopServer(
    )
/*++

Routine Description:

    The destructor just makes sure to destroy the RemoteDesktopServer.

Arguments:

    None

Return Value:

    None

--*/
{
    DC_BEGIN_FN("CRemoteDesktopServer::~CRemoteDesktopServer");
    
    if (m_rServerSession) {
        m_rServerSession->CloseRemoteDesktopSession();
        m_rServerSession->Release();
    }
    if (m_rServerHost) {
		m_rServerHost->Release();
	}

    DC_END_FN();
}

BSTR
CRemoteDesktopServer::StartListening(
    )
/*++

Routine Description:

    This starts the server listening and gets the connection parameters
    from ISAFRemoteDesktopSession.

Arguments:

    None

Return Value:

    BSTR - The connection paremters a client can use to connect
           to the server.

--*/
{
	HRESULT hr;
	BSTR parms;

	DC_BEGIN_FN("CRemoteDesktopServer::StartListening");
    
    hr = m_rServerHost->CreateRemoteDesktopSession(CONTROLDESKTOP_PERMISSION_REQUIRE,
        NULL,0,&m_rServerSession);
	if (hr != S_OK) {
		TRC_ERR((TB,TEXT("Error getting ISAFRemoteDesktopSession from host: 0x%0X"),hr));
        goto FAILURE;
	}
	

    hr = m_rServerSession->get_ConnectParms(&parms);
	if (hr != S_OK) {
        TRC_ERR((TB,TEXT("Error getting connection parameters 0x%0X"),hr));
		goto FAILURE;
	}

    DC_END_FN();
	return parms;

FAILURE:
	throw CException(IDS_SERVERERRORLISTEN);
}

VOID
CRemoteDesktopServer::StopListening(
    )

/*++

Routine Description:

    This stops the server listening on the remote session.

Arguments:

    None

Return Value:

    None

--*/
{
    HRESULT hr;

    DC_BEGIN_FN("CRemoteDesktopServer::StopListening");

    if (m_rServerSession) {
        hr = m_rServerSession->CloseRemoteDesktopSession();
        if (hr != S_OK) {
            TRC_ERR((TB,TEXT("Error in CloseRemoteDesktopSession 0x%0X"),hr));
            goto FAILURE;
        }
        m_rServerSession->Release();
    }
    m_rServerSession = NULL;

    DC_END_FN();
    
    return;

FAILURE:
    throw CException(IDS_RDSERRORSTOPLISTENING);
}


HRESULT
CRemoteDesktopServer::EventSinkAdvise(
    IN CRemoteDesktopServerEventSink *rSink
    )
/*++

Routine Description:

    This starts the passed in event sink listening
    for events from the IRemoteDesktopServer

Arguments:

    rSink - The event sink that wants to be advised of events.

Return Value:

    None

--*/
{
    DC_BEGIN_FN("CRemoteDesktopServer::EventSinkAdvise");

    return rSink->DispEventAdvise(m_rServerSession);

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\msngr\remotedesktopserver.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RemoteDesktopServer

Abstract:

    The RemoteDesktopServer is the interface for dealing
    with the salem server classes.  It just presents
    the methods necessary for this application to use.

Author:

    Marc Reyhner 7/5/2000

--*/

#ifndef __REMOTEDESKTOPSERVER_H__
#define __REMOTEDESKTOPSERVER_H__

#include "rdshost.h"


class CRemoteDesktopServerEventSink;

////////////////////////////////////////////////
//
//    CRemoteDesktopServer
//
//    Class for managing the Salem RemoteDesktopServer session.
//

class CRemoteDesktopServer  
{
private:

    ISAFRemoteDesktopServerHost *m_rServerHost;
    ISAFRemoteDesktopSession *m_rServerSession;

public:

    // Constructor/destructor
    CRemoteDesktopServer();
	virtual ~CRemoteDesktopServer();

    BSTR StartListening();
	VOID StopListening();

    // Pass in an event sink that wants to be advised of events.
    HRESULT EventSinkAdvise(CRemoteDesktopServerEventSink *rSink);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\msngr\remotedesktopclienteventsink.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RemoteDesktopClientEventSink

Abstract:

    This listens to the events from the IRemoteDesktopClient so
    we can find out when the server connects.

Author:

    Marc Reyhner 7/11/2000

--*/

#ifndef __REMOTEDESKTOPCLIENTEVENTSINK_H__
#define __REMOTEDESKTOPCLIENTEVENTSINK_H__

#define IDC_EVENT_SOURCE_OBJ 1

//
// Info for all the event functions is entered here
// there is a way to have ATL do this automatically using typelib's
// but it is slower.
//
static _ATL_FUNC_INFO EventFuncNoParamsInfo =
{
            CC_STDCALL,     // Calling convention.
            VT_EMPTY,       // Return type.
            0,              // Number of arguments.
            {VT_EMPTY}      // Argument types.
};

static _ATL_FUNC_INFO EventFuncLongParamInfo =
{
            CC_STDCALL,     // Calling convention.
            VT_EMPTY,       // Return type.
            1,              // Number of arguments.
            {VT_I4}         // Argument types.
};

// Forward declaration of CRemoteDesktopClientSession
class CRemoteDesktopClientSession;

////////////////////////////////////////////////
//
//    CRemoteDesktopClientEventSink
//
//    Event sink for client events.
//

class CRemoteDesktopClientEventSink :
		public IDispEventSimpleImpl<IDC_EVENT_SOURCE_OBJ, CRemoteDesktopClientEventSink,
                   &DIID__ISAFRemoteDesktopClientEvents>
{
        
public:

    BEGIN_SINK_MAP(CRemoteDesktopClientEventSink)
        SINK_ENTRY_INFO(IDC_EVENT_SOURCE_OBJ, DIID__ISAFRemoteDesktopClientEvents, 
                        2, OnConnected, 
                        &EventFuncNoParamsInfo)
        SINK_ENTRY_INFO(IDC_EVENT_SOURCE_OBJ, DIID__ISAFRemoteDesktopClientEvents, 
                        3, OnDisconnected, 
                        &EventFuncLongParamInfo)
        SINK_ENTRY_INFO(IDC_EVENT_SOURCE_OBJ, DIID__ISAFRemoteDesktopClientEvents, 
                        4, OnRemoteControlRequestComplete, 
                        &EventFuncLongParamInfo)
    END_SINK_MAP()

    CRemoteDesktopClientEventSink(CRemoteDesktopClientSession *obj);

    //
    //  Event Sinks
    //
    VOID __stdcall OnConnected();
    VOID __stdcall OnDisconnected(LONG reason);
    VOID __stdcall OnRemoteControlRequestComplete(LONG status);

    //
    //  Return the name of this class.
    //
    virtual const LPTSTR ClassName() {
        return TEXT("CRemoteDesktopClientEventSink");
    }

private:

    CRemoteDesktopClientSession *m_Obj;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\msngr\remotedesktopservereventsink.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RemoteDesktopServerEventSink

Abstract:

    This listens to the events from the IRemoteDesktopServer so
    we can find out when the client connects/disconnects

Author:

    Marc Reyhner 7/5/2000

--*/

#include "stdafx.h"

#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE "rcrdses"

#include "RemoteDesktopServerEventSink.h"
#include "DirectPlayConnection.h"
#include "rcontrol.h"
#include "resource.h"


VOID __stdcall
CRemoteDesktopServerEventSink::OnConnected(
    )
/*++

Routine Description:

    This is called when the client has connected.  We update the taskbar icon
    to reflect the fact that someone has connected

Arguments:

    None

Return Value:

    None

--*/
{
    TCHAR tipText[MAX_STR_LEN];
    TCHAR infoText[MAX_STR_LEN];
    TCHAR infoTitle[MAX_STR_LEN];

    DC_BEGIN_FN("CRemoteDesktopServerEventSink::OnConnected");

    LoadStringSimple(IDS_TRAYTOOLTIPCONNECTED,tipText);
    _tcsncpy(g_iconData.szTip,tipText, 128 - 1);
    LoadStringSimple(IDS_TRAYINFOTEXT,infoText);
	_tcsncpy(g_iconData.szInfo,infoText, 256 - 1);
    LoadStringSimple(IDS_TRAYINFOTITLE,infoTitle);
	_tcsncpy(g_iconData.szInfoTitle,infoTitle, 64 - 1);
	g_iconData.uTimeout = (1000 * 15);
	g_iconData.dwInfoFlags = NIIF_INFO;
	g_iconData.uFlags = NIF_INFO|NIF_TIP;
	Shell_NotifyIcon(NIM_MODIFY,&g_iconData);

    //
    //  We want to kill the direct play connection now since we
    //  are sure the client has the info they need.
    //
    g_DpConnection->DisconnectRemoteApplication();

    DC_END_FN();
}


VOID __stdcall
CRemoteDesktopServerEventSink::OnDisconnected(
    )

/*++

Routine Description:

    This is called when the client has disconnected.  We send a quit
    message to indicate that we should exit the application.

Arguments:

    None

Return Value:

    None

--*/
{
	DC_BEGIN_FN("CRemoteDesktopServerEventSink::OnDisconnected");

    PostQuitMessage(0);

    DC_END_FN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\msngr\stdafx.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Precompiled Headers

Abstract:

    Just the precompiled headers.

Author:

    Marc Reyhner 7/5/2000

--*/

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\msngr\remotedesktopservereventsink.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RemoteDesktopServerEventSink

Abstract:

    This listens to the events from the IRemoteDesktopServer so
    we can find out when the client connects/disconnects

Author:

    Marc Reyhner 7/5/2000

--*/

#ifndef __REMOTEDESKTOPSERVEREVENTSINK_H__
#define __REMOTEDESKTOPSERVEREVENTSINK_H__

#include "rdshost.h"

#define IDC_EVENT_SOURCE_OBJ 1

//
// Info for all the event functions is entered here
// there is a way to have ATL do this automatically using typelib's
// but it is slower.
//
static _ATL_FUNC_INFO EventFuncNoParamsInfo =
{
            CC_STDCALL,     // Calling convention.
            VT_EMPTY,       // Return type.
            0,              // Number of arguments.
            {VT_EMPTY}      // Argument types.
};

static _ATL_FUNC_INFO EventFuncLongParamInfo =
{
            CC_STDCALL,     // Calling convention.
            VT_EMPTY,       // Return type.
            1,              // Number of arguments.
            {VT_I4}         // Argument types.
};

////////////////////////////////////////////////
//
//    CRemoteDesktopServerEventSink
//
//    Event sink for server events.
//

class CRemoteDesktopServerEventSink :
        public IDispEventSimpleImpl<IDC_EVENT_SOURCE_OBJ, CRemoteDesktopServerEventSink,
                   &DIID__ISAFRemoteDesktopSessionEvents>
{
        
public:
    //  The sink map for ATL
    BEGIN_SINK_MAP(CRemoteDesktopServerEventSink)
        SINK_ENTRY_INFO(IDC_EVENT_SOURCE_OBJ, DIID__ISAFRemoteDesktopSessionEvents, 
                        1, OnConnected, 
                        &EventFuncNoParamsInfo)
        SINK_ENTRY_INFO(IDC_EVENT_SOURCE_OBJ, DIID__ISAFRemoteDesktopSessionEvents, 
                        2, OnDisconnected, 
                        &EventFuncNoParamsInfo)
    END_SINK_MAP()

    

    //
    //  Event Sinks
    //

    //  The client connected
    VOID __stdcall OnConnected();
    
    //  The client disconnected
    VOID __stdcall OnDisconnected();
    
    //  Return the name of this class.
    virtual const LPTSTR ClassName() {
        return TEXT("CRemoteDesktopServerEventSink");
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\msngr\staticokdialog.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    StaticOkDialog

Abstract:

    This is an abstraction around a simple non-modal dialog
    box to make them easier to use.

Author:

    Marc Reyhner 7/11/2000

--*/

#ifndef __STATICOKDIALOG_H__
#define __STATICOKDIALOG_H__

//  Forward declaration for the DlgListT struct.
class CStaticOkDialog;

////////////////////////////////////////////////
//
//    CStaticOkDialog
//
//    Class for making static dialog boxes simpler.
//

class CStaticOkDialog  
{
public:

	CStaticOkDialog();
	virtual ~CStaticOkDialog();
	VOID Activate();
	BOOL DialogMessage(LPMSG msg);
	VOID DestroyDialog();
	BOOL IsCreated();
	BOOL Create(HINSTANCE hInstance, WORD resId, HWND parentWnd);

private:
    
    HWND m_hWnd;

    virtual VOID OnOk();
    static INT_PTR CALLBACK _DlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam,
        LPARAM lParam);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\ascom.inc ===
##############################################################################
#                                                                            #
#   Microsoft Confidential                                                   #
#   Copyright (C) Microsoft Corporation 1991-97                              #
#   All Rights Reserved.                                                     #
#                                                                            #
##############################################################################
# Changes:                                                                   #
#                                                                            #
#   15Oct96 NFC SFR0563     Set MSC_WARNING_LEVEL to level 3.                #
#   05Feb97 TH  SFR1441     Turn off DCL network layer for App Serving       #
#   07Feb97 OBK SFR1434     Merge SFR1338/1380: Allow for unaligned accesses #
#                                                                            #
##############################################################################


!include $(DEVROOT)\common.inc

INCLUDES=..\h;$(INCLUDES)

########################################################################################
# We cannot compile for WINVER=0x500 due to driver compat issues
########################################################################################

WIN32_DEFINE=-DWIN32=200 -D_CHICAGO_=200 -D_WIN32_WINDOWS=0x040a -D_WIN32_WINNT=0x0400 -D_WIN32_IE=0x0401
C_DEFINES       = $(C_DEFINES) -DSTRICT -DWIN32 -D_WIN32 -DOS_WINDOWS -DWIN_95_32_BIT


!IF "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"
C_DEFINES = $(C_DEFINES) -DDC_NO_UNALIGNED
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\msngr\staticokdialog.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    StaticOkDialog

Abstract:

    This is an abstraction around a simple non-modal dialog
    box to make them easier to use.

Author:

    Marc Reyhner 7/11/2000

--*/

#include "stdafx.h"


#ifdef TRC_FILE
#undef TRC_FILE
#endif

#define TRC_FILE "rcsokd"

#include "rcontrol.h"
#include "StaticOkDialog.h"


CStaticOkDialog::CStaticOkDialog(
    )

/*++

Routine Description:

    This is the constructor for CStaticOkDialog.  This just initializes
    the member variables.  Create must be called to create the dialog.

Arguments:

    None

Return Value:

    None

--*/
{
    DC_BEGIN_FN("CStaticOkDialog::CStaticOkDialog");

    m_hWnd= NULL;

    DC_END_FN();
}

CStaticOkDialog::~CStaticOkDialog(
    )

/*++

Routine Description:

    This is the destructor for CStaticOkDialog.  This will call DestroyWindow
    on the dialog if that has not been already done.

Arguments:

    None

Return Value:

    None

--*/
{
    DC_BEGIN_FN("CStaticOkDialog::~CStaticOkDialog");
    
    if (IsCreated()) {
        DestroyWindow(m_hWnd);
    }

    DC_END_FN();
}

BOOL
CStaticOkDialog::Create(
    IN HINSTANCE hInstance,
    IN WORD resId,
    IN OUT HWND parentWnd
    )

/*++

Routine Description:

    This creates the dialog and displays it.

Arguments:

    hInstance - The instance for this module.

    resId - The resource id of the dialog template.

    parentWnd - Handle to the parent window for the dialog

Return Value:

    TRUE - The dialog was created.

    FALSE - There was an error creating the dialog.

--*/
{
    DC_BEGIN_FN("CStaticOkDialog::Create");

    if (IsCreated()) {
        DC_END_FN();   
        return FALSE;
    }
    m_hWnd = CreateDialog(hInstance,MAKEINTRESOURCE(resId),parentWnd,_DlgProc);
    if (m_hWnd) {
        SetWindowLongPtr(m_hWnd,GWLP_USERDATA,(LONG)this);
        ShowWindow(m_hWnd,SW_SHOW);
        SetFocus(m_hWnd);
        DC_END_FN();
        return TRUE;
    } else {

        DC_END_FN();
        return FALSE;
    }
}

INT_PTR CALLBACK
CStaticOkDialog::_DlgProc(
    IN OUT HWND hwndDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    This is the DialogProc for the dialog.  If the user hit
    the "ok" button we close the dialog.  Otherwise we ignore the
    message.

Arguments:

    hwndDlg - Handle to the dialog.

    uMsg - Message that occurred.

    wParam - WPARAM for the message.

    lParam - LPARAM for the message.

Return Value:

    TRUE - We handled the message

    FALSE - We didn't handle the message

--*/
{
    BOOL retValue = TRUE;
    CStaticOkDialog *theClass;

    DC_BEGIN_FN("CStaticOkDialog::_DlgProc");

    theClass = (CStaticOkDialog*)GetWindowLongPtr(hwndDlg,GWLP_USERDATA);
    switch (uMsg) {
    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            if (theClass) {
                theClass->OnOk();
            }
            DestroyWindow(hwndDlg);
            break;
        }
    default:
        retValue = FALSE;
    }

    DC_END_FN();

    return retValue;
}


BOOL
CStaticOkDialog::IsCreated(
    )

/*++

Routine Description:

    This returns whether or not the dialog is a current valid window.

Arguments:

    None

Return Value:

    TRUE - The dialog has been created.

    FALSE - The dialog has not been created or was destroyed.

--*/
{
    BOOL result;
    
    DC_BEGIN_FN("CStaticOkDialog::IsCreated");

    result = IsWindow(m_hWnd);

    DC_END_FN();

    return result;
}

VOID
CStaticOkDialog::DestroyDialog(
    )

/*++

Routine Description:

    This destroys the dialog.  You can create it again after this
    if you want.

Arguments:

    None

Return Value:

    None

--*/
{
    DC_BEGIN_FN("CStaticOkDialog::DestroyDialog");

    DestroyWindow(m_hWnd);
    m_hWnd = NULL;

    DC_END_FN();
}

BOOL
CStaticOkDialog::DialogMessage(
    IN LPMSG lpMsg
    )

/*++

Routine Description:

    This needs to be called by the event loop while this dialog is created
    to send it windows messages.

Arguments:

    lpMsg - The message which was sent.

Return Value:

    TRUE - The message was for this dialog.

    FALSE - The message was not for this dialog.

--*/
{
    BOOL result;

    DC_BEGIN_FN("CStaticOkDialog::DialogMessage");

    if (IsCreated()) {
        result = IsDialogMessage(m_hWnd,lpMsg);
    } else {
        result = FALSE;
    }

    DC_END_FN();

    return result;
}

VOID
CStaticOkDialog::Activate(
    )

/*++

Routine Description:

    This brings the dialog to the foreground.

Arguments:

    None

Return Value:

    None

--*/
{
    DC_BEGIN_FN("CStaticOkDialog::Activate");

    if (IsCreated()) {
        SetForegroundWindow(m_hWnd);
        SetFocus(m_hWnd);
    }

    DC_END_FN();

    
}

VOID
CStaticOkDialog::OnOk(
    )


{
    // this is a temporary function to be removed when
    // salem gets remote control notifications correct.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\msngr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rcontrol.rc
//
#define IDS_FOO                         1
#define IDS_ADVISEERROR                 1
#define IDS_ERRORDDLGTITLE              2
#define IDS_TRAYTOOLTIPDISCONNECTED     3
#define IDS_TRAYEXITDLGTEXT             4
#define IDS_TRAYEXITDLGTITLE            5
#define IDS_STRINGMISSING               6
#define IDS_DPERRORCREATE               7
#define IDS_DPNOTLOBBIED                8
#define IDS_DPERRORCONNECT              9
#define IDS_DPNOTCONNECTED              10
#define IDS_DPERRORSEND                 11
#define IDS_DPERRORRECEIVE              12
#define IDS_DPERRORTIMEOUT              13
#define IDS_CLIENTWNDTITLE              14
#define IDS_CLIENTERRORCREATE           15
#define IDS_SERVERRRORCREATE            16
#define IDS_SERVERERRORLISTEN           17
#define IDS_TRAYTOOLTIPCONNECTED        18
#define IDS_TRAYINFOTEXT                19
#define IDS_TRAYINFOTITLE               20
#define IDS_INITERRORMUTEX              21
#define IDS_INITALREADYEXISTS           22
#define IDS_DPERRORMSGRECIEVE           23
#define IDS_CLIENTREMOTEFAIL            24
#define IDS_CLIENTREMOTEDISCONNECT      25
#define IDS_RDSERRORSTOPLISTENING       26
#define IDS_PROJNAME                    100
#define IDR_Rcontrol                    100
#define IDR_ONCONNECTED                 101
#define IDI_TRAYICON                    201
#define IDR_TRAYMENU                    204
#define IDR_CLIENTMENU                  206
#define IDI_CLIENTICON                  207
#define IDD_ABOUT                       208
#define IDD_APPROVALWAIT                209
#define ID_QUIT                         32773
#define ID_EXIT                         32774
#define ID_ABOUT                        32775

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        211
#define _APS_NEXT_COMMAND_VALUE         32776
#define _APS_NEXT_CONTROL_VALUE         202
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\msngr\stdafx.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Precompiled Headers

Abstract:

    Just the precompiled headers.

Author:

    Marc Reyhner 7/5/2000

--*/

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <atlbase.h>

//
//  This makes ATL happy.  We don't actually instantiate this anywhere
//  but ATL gets unhappy if _Module isn't even defined
//
extern CComModule _Module;

#include <atlcom.h>
#include <atlwin.h>



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\as16\globals.c ===
//
// GLOBALS.C
// Global Variable Storage/Init
//
// Copyright(c) Microsoft 1997-
//


#include <as16.h>

#include <datainit.h>
#include <globals.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\as16\ba.c ===
//
// BA.C
// Bounds Accumulator
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>


//
// BA_DDProcessRequest()
// Handles BA escapes
//


BOOL BA_DDProcessRequest
(
    UINT        fnEscape,
    LPOSI_ESCAPE_HEADER pResult,
    DWORD       cbResult
)
{
    BOOL                    rc = TRUE;
    LPBA_BOUNDS_INFO        pBoundsInfo;
    UINT                    i;
    RECT                    rect;

    DebugEntry(BA_DDProcessRequest);

    switch (fnEscape)
    {
        case BA_ESC_GET_BOUNDS:
        {
            //
            // The share core is calling us to get the current bounds
            // (presumably to try to send them).  While the share core is
            // processing the bounds, we reset the bounds, but take a copy
            // first to use for spoiling orders by SDA.  When the share
            // core has completed processing the bounds, it will call us
            // again with a BA_ESC_RETURN_BOUNDS escape (even if it has
            // sent all the bounds).
            //
            // So, we have to:
            //  - return the bounds to the share core
            //  - set up the spoiling rects to be these bounds
            //  - clear our main bounds.
            //

            //
            // This will copy the current bounds to the caller's buffer and
            // clear our current bounds.
            // NOTE:  We keep these in globals because the caller will shortly
            // call us to return any unsent bounds rects.
            //
            BA_CopyBounds(g_baSpoilingRects, &g_baNumSpoilingRects, TRUE);

            //
            // Return the bounds info to the share core
            //
            if (g_baNumSpoilingRects)
            {
                TRACE_OUT(( "Returning %d rects to share core", g_baNumSpoilingRects));
            }

            pBoundsInfo = (LPBA_BOUNDS_INFO)pResult;
            pBoundsInfo->numRects = g_baNumSpoilingRects;

            for (i = 0; i < g_baNumSpoilingRects; i++)
            {
                RECT_TO_RECTL(&g_baSpoilingRects[i], &pBoundsInfo->rects[i]);
            }
        }
        break;

        case BA_ESC_RETURN_BOUNDS:
        {
            //
            // The share core has completed its processing of the bounds
            // which we passed on the BA_ESC_GET_BOUNDS escape.  We have to
            // reset the spoiling rectangles and add any bounds which the
            // share core failed to process into our current bounds.
            //

            //
            // To reset the spoiling bounds we just have to reset the
            // number of bounds.
            //
            g_baNumSpoilingRects = 0;

            //
            // Now add the share core's bounds into our current bounds
            //
            pBoundsInfo = (LPBA_BOUNDS_INFO)pResult;

            if (pBoundsInfo->numRects)
            {
                TRACE_OUT(( "Received %d rects from share core",
                             pBoundsInfo->numRects));
            }

            for (i = 0 ; i < pBoundsInfo->numRects ; i++)
            {
                RECTL_TO_RECT(&pBoundsInfo->rects[i], &rect);

                TRACE_OUT(( "Rect %d, {%d, %d, %d, %d}",
                     i, rect.left, rect.top, rect.right, rect.bottom));

                BA_AddScreenData(&rect);
            }
        }
        break;

        default:
        {
            ERROR_OUT(( "Unrecognised BA escape"));
            rc = FALSE;
        }
        break;
    }

    DebugExitBOOL(BA_DDProcessRequest, rc);
    return(rc);
}



//
// BA_DDInit - see ba.h for description.
//
void BA_DDInit(void)
{
    DebugEntry(BA_Init);

    BA_ResetBounds();

    DebugExitVOID(BA_Init);
}




//
// This gets a current version of our bound rect list, and clears it 
// afterwards if requested.
//
void BA_CopyBounds
(
    LPRECT  pRects,
    LPUINT  pNumRects,
    BOOL    fReset
)
{
    UINT    i;
#ifdef DEBUG
    UINT    cRects = 0;
#endif

    DebugEntry(BA_CopyBounds);

    *pNumRects = g_baRectsUsed;

    //
    // A return with *pNumRects as zero is an OK return - it just says
    // no bounds have been accumulated since the last call.
    //
    if ( *pNumRects != 0)
    {
        //
        // We can return the bounds in any order - we don't care how we
        // order the SDA rectangles.
        //
        // Also note that we must compare BA_NUM_RECTS + 1 sets of
        // rectangles because that's the number actually used by the add
        // rectangle code and while it guarantees that it will only use
        // BA_NUM_RECTS rectangles, it does not guarantee that the last
        // element in the array is the merge rectangle.
        //
        for (i = 0; i <= BA_NUM_RECTS; i++)
        {
            if (g_baBounds[i].InUse)
            {
                TRACE_OUT(("Found rect: {%04d,%04d,%04d,%04d}",
                    g_baBounds[i].Coord.left, g_baBounds[i].Coord.top,
                    g_baBounds[i].Coord.right, g_baBounds[i].Coord.bottom));

                *pRects = g_baBounds[i].Coord;
                pRects++;
#ifdef DEBUG
                cRects++;
#endif
            }
        }

        //
        // Check for self-consistency
        //
        ASSERT(cRects == *pNumRects);

        if (fReset)
            BA_ResetBounds();
    }

    DebugExitVOID(BACopyBounds);
}

//
//
// BA_AddScreenData(..)
//
// Adds the specified rectangle to the current Screen Data Area.
//
// Called by the GDI interception code for orders that it cannot send as
// orders.
//
// NOTE that the rectangle is inclusive coords
//
//
void BA_AddScreenData(LPRECT pRect)
{
    RECT  preRects[BA_NUM_RECTS];
    RECT  postRects[BA_NUM_RECTS];
    UINT  numPreRects;
    UINT  numPostRects;
    UINT  i;

    DebugEntry(BA_AddScreenData);

    //
    // Check that the caller has passed a valid rectangle.  If not, do a
    // trace alert, and then return immediately (as an invalid rectangle
    // shouldn't contribute to the accumulated bounds) - but report an OK
    // return code, so we keep running.
    //
    if ((pRect->right < pRect->left) ||
        (pRect->bottom < pRect->top) )
    {
        //
        // NOTE:  This will happen when the visrgn of a DC clips out the
        // output, so the drawing bounds are empty, but the output 
        // 'succeeded'.  BUT WE SHOULD NEVER GET A RECT THAT IS LESS THAN
        // EMPTY--if so, it means the right/left or bottom/top coords got
        // mistakenly flipped.
        //
        ASSERT(pRect->right >= pRect->left-1);
        ASSERT(pRect->bottom >= pRect->top-1);
        DC_QUIT;
    }

    if ((g_oaFlow == OAFLOW_SLOW) && g_baSpoilByNewSDAEnabled)
    {
        //
        // We are spoiling existing orders by new SDA, so query the current
        // bounds.
        //
        BA_CopyBounds(preRects, &numPreRects, FALSE);
    }

    //
    // Add the rect to the bounds.
    //
    if (BAAddRect(pRect, 0))
    {
        if ((pRect->right > pRect->left) && (pRect->bottom > pRect->top))
        {
            LPBA_FAST_DATA  lpbaFast;

            lpbaFast = BA_FST_START_WRITING;

            SHM_CheckPointer(lpbaFast);
            lpbaFast->totalSDA += COM_SizeOfRectInclusive(pRect);

            TRACE_OUT(("Added rect to bounds, giving %ld of SD", lpbaFast->totalSDA));

            //
            // This is where the Win95 product would make a call to
            // DCS_TriggerEarlyTimer
            //

            BA_FST_STOP_WRITING;
        }

        if ((g_oaFlow == OAFLOW_SLOW) && g_baSpoilByNewSDAEnabled)
        {
            //
            // Adding the new rectangle changed the existing bounds so
            // query the new bounds
            //
            BA_CopyBounds(postRects, &numPostRects, FALSE);

            //
            // Try to spoil existing orders using each of the rectangles
            // which have changed.
            //
            for (i = 0; i < numPostRects; i++)
            {
                if ( (i > numPreRects)                          ||
                     (postRects[i].left   != preRects[i].left)  ||
                     (postRects[i].right  != preRects[i].right) ||
                     (postRects[i].top    != preRects[i].top)   ||
                     (postRects[i].bottom != preRects[i].bottom) )
                {
                    OA_DDSpoilOrdersByRect(&postRects[i]);
                }
            }
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(BA_AddScreenData);
}



//
//
// BA_QuerySpoilingBounds() - see ba.h
//
//
void BA_QuerySpoilingBounds(LPRECT pRects, LPUINT pNumRects)
{
    DebugEntry(BA_QuerySpoilingBounds);

    //
    // Just have to return the number of spoiling rectangles, and the
    // rectangles themselves.  No rectangles is perfectly valid.
    //
    TRACE_OUT(( "Num rects %d", g_baNumSpoilingRects));

    *pNumRects = g_baNumSpoilingRects;
    hmemcpy(pRects, g_baSpoilingRects, g_baNumSpoilingRects*sizeof(RECT));

    DebugExitVOID(BA_QuerySpoilingBounds);
}



void BA_ResetBounds(void)
{
    UINT i;

    DebugEntry(BA_ResetBounds);

    //
    // Clear the bounds - reset the number we are using, mark all slots as
    // free, and clean the list.
    //
    for ( i = 0; i <= BA_NUM_RECTS; i++ )
    {
        g_baBounds[i].InUse = FALSE;
        g_baBounds[i].iNext = BA_INVALID_RECT_INDEX;
    }

    g_baFirstRect = BA_INVALID_RECT_INDEX;
    g_baLastRect  = BA_INVALID_RECT_INDEX;
    g_baRectsUsed = 0;

    DebugExitVOID(BA_ResetBounds);
}





//
// Name:        BAOverlap
//
// Description: Detects overlap between two rectangles.
//
//              - check for no overlap using loose test that lets through
//                adjacent/overlapping merges
//              - check for adjacent/overlapping merges
//              - check for no overlap (using strict test)
//              - use outcodes to check internal edge cases
//              - use outcodes to check external edge cases
//
//              If at each stage the check detects that the two rectangles
//              meet the criteria, the function returns the appropriate
//              return or outcode combination.
//
//              Note that all rectangle coordinates are inclusive, ie
//              a rectangle of 0,0,0,0 has an area of 1 pel.
//
//              This function does not alter either of the rectangles.
//
// Params (IN): pRect1 - first rectangle
//              pRect2 - second rectangle
//
// Returns:     One of the overlap return codes or outcode combinations
//              defined above.
//
//
int BAOverlap(LPRECT pRect1, LPRECT pRect2 )
{
    int ExternalEdges;
    int ExternalCount;
    int InternalEdges;
    int InternalCount;

    //
    // Check for no overlap.
    //
    // Note that this test is looser than strict no overlap, and will let
    // through rectangles that do not overlap, but just abutt by one pel -
    // so that we get a chance to detect adjacent merges.
    //
    // So (for example) for the following:
    //
    // - it detects no overlap when there is at least 1 pel between rects
    //
    //                  10,10        52,10
    //                   +----------++----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------++----------+
    //                          50,50         100,50
    //
    // - it allows rectangles through when they abutt and are mergable
    //
    //                  10,10        51,10
    //                   +----------++----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------++----------+
    //                          50,50         100,50
    //
    // - it allows rectangles through when they abutt, even where they are
    //   not mergable
    //
    //                  10,10
    //                   +----------+51,15
    //                   |          |+----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||          |
    //                   |          ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------+|          |
    //                          50,50+----------+
    //                                        100,55
    //
    // - it allows rectangles through when they overlap in some way
    //
    //                          40,0
    //                           +------------+
    //                  10,10    |            |
    //                   +-------+--+         |
    //                   |       |  |         |
    //                   |       |  | Rect 2  |
    //                   |       |  |         |
    //                   |Rect 1 |  |         |
    //                   |       |  |         |
    //                   |       +--+---------+
    //                   |          |        90,40
    //                   +----------+
    //                          50,50
    //
    //
    if (!((pRect1->left <= pRect2->right + 1) &&
          (pRect1->top <= pRect2->bottom + 1) &&
          (pRect1->right >= pRect2->left - 1) &&
          (pRect1->bottom >= pRect2->top - 1)   ))
    {
        return(OL_NONE);
    }

    //
    // Check for adjoining/overlapping rectangles which can be merged.
    //
    // These tests detect (for example for the XMAX variant), where:
    //
    // - the rectangles abutt and can be merged
    //
    //                  10,10        51,10
    //                   +----------++----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------++----------+
    //                          50,50         100,50
    //
    // - the rectangles overlap and can be merged
    //
    //                  10,10   40,10
    //                   +-------+--+------+
    //                   |       |  |      |
    //                   |       |  |      |
    //                   |       |  |      |
    //                   |Rect 1 |  |Rect 2|
    //                   |       |  |      |
    //                   |       |  |      |
    //                   |       |  |      |
    //                   +-------+--+------+
    //                              50,50  90,50
    //
    // - the rectangles abutt and cannot be merged - this case is detected
    //   by the strict overlap case below
    //
    //                  10,10
    //                   +----------+51,15
    //                   |          |+----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||          |
    //                   |          ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------+|          |
    //                          50,50+----------+
    //                                        100,55
    //
    // - the rectangles overlap and cannot be merged - this case is
    //   detected by the outcode tests below
    //
    //                          40,0
    //                           +------------+
    //                  10,10    |            |
    //                   +-------+--+         |
    //                   |       |  |         |
    //                   |       |  | Rect 2  |
    //                   |       |  |         |
    //                   |Rect 1 |  |         |
    //                   |       |  |         |
    //                   |       +--+---------+
    //                   |          |        90,40
    //                   +----------+
    //                          50,50
    //
    // - rectangle 2 is enclosed in rectangle 1 and should not be merged -
    //   this case is detected by the outcode tests below.
    //
    //                  10,10   40,10
    //                   +-------+------+-----+
    //                   |       |      |     |
    //                   |       |      |     |
    //                   |       |      |     |
    //                   |Rect 1 |Rect 2|     |
    //                   |       |      |     |
    //                   |       |      |     |
    //                   |       |      |     |
    //                   +-------+------+-----+
    //                               60,50   90,50
    //                               Rect2   Rect1
    //
    //
    if ( (pRect1->left <= pRect2->right + 1) &&
         (pRect1->left >  pRect2->left    ) &&
         (pRect1->right >  pRect2->right    ) &&
         (pRect1->top == pRect2->top    ) &&
         (pRect1->bottom == pRect2->bottom    )   )
    {
        return(OL_MERGE_XMIN);
    }

    if ( (pRect1->top <= pRect2->bottom + 1) &&
         (pRect1->top >  pRect2->top    ) &&
         (pRect1->bottom >  pRect2->bottom    ) &&
         (pRect1->left == pRect2->left    ) &&
         (pRect1->right == pRect2->right    )   )
    {
        return(OL_MERGE_YMIN);
    }

    if ( (pRect1->right >= pRect2->left - 1) &&
         (pRect1->right <  pRect2->right    ) &&
         (pRect1->left <  pRect2->left    ) &&
         (pRect1->top == pRect2->top    ) &&
         (pRect1->bottom == pRect2->bottom    )   )
    {
        return(OL_MERGE_XMAX);
    }

    if ( (pRect1->bottom >= pRect2->top - 1) &&
         (pRect1->bottom <  pRect2->bottom    ) &&
         (pRect1->top <  pRect2->top    ) &&
         (pRect1->left == pRect2->left    ) &&
         (pRect1->right == pRect2->right    )   )
    {
        return(OL_MERGE_YMAX);
    }

    //
    // Check for no overlap.
    // Note that this test is a stricter version than the earlier one, so
    // that we now only continue testing rectangles that do genuinely
    // overlap.
    //
    if (!((pRect1->left <= pRect2->right) &&
          (pRect1->top <= pRect2->bottom) &&
          (pRect1->right >= pRect2->left) &&
          (pRect1->bottom >= pRect2->top)   ))
    {
        return(OL_NONE);
    }

    //
    // Use outcodes for Internal edge cases, as follows:
    //
    // EE_XMIN - rect1 xmin is enclosed within rect2
    // EE_YMIN - rect1 ymin is enclosed within rect2
    // EE_XMAX - rect1 xmax is enclosed within rect2
    // EE_YMAX - rect1 ymax is enclosed within rect2
    //
    // If 3 or more bits are set then rect1 is enclosed either partially or
    // completely within rect2 as follows (see individual switch cases for
    // diagrams).
    //
    // OL_ENCLOSED           = EE_XMIN | EE_YMIN | EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSED_XMIN = EE_XMIN | EE_YMIN |           EE_YMAX
    // OL_PART_ENCLOSED_YMIN = EE_XMIN | EE_YMIN | EE_XMAX
    // OL_PART_ENCLOSED_XMAX =           EE_YMIN | EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSED_YMAX = EE_XMIN |           EE_XMAX | EE_YMAX
    //
    // In practice, if 3 or more bits are set, the negative of the outcode
    // value is retruned to ensure that it is distinct from the external
    // edge outcode returns (see below).
    //
    //
    InternalCount = 0;
    InternalEdges = 0;
    if ( pRect1->left >= pRect2->left && pRect1->left <= pRect2->right)
    {
        InternalEdges |= EE_XMIN;
        InternalCount ++;
    }
    if ( pRect1->top >= pRect2->top && pRect1->top <= pRect2->bottom)
    {
        InternalEdges |= EE_YMIN;
        InternalCount ++;
    }
    if ( pRect1->right >= pRect2->left && pRect1->right <= pRect2->right)
    {
        InternalEdges |= EE_XMAX;
        InternalCount ++;
    }
    if ( pRect1->bottom >= pRect2->top && pRect1->bottom <= pRect2->bottom)
    {
        InternalEdges |= EE_YMAX;
        InternalCount ++;
    }

    if ( InternalCount >= 3)
    {
        return(-InternalEdges);
    }

    //
    // Use outcodes for External edge cases as follows.
    //
    // EE_XMIN - rect1 xmin is left of rect2 xmin
    // EE_YMIN - rect1 ymin is above rect2 ymin
    // EE_XMAX - rect1 xmax is right of rect2 xmax
    // EE_YMAX - rect1 ymax is below rect2 ymax
    //
    // These are the classic "line" outcodes.
    //
    // If 2 or more bits are set then rect1 overlaps rect2 as follows (see
    // individual switch cases for diagrams).
    //
    // OL_ENCLOSES           = EE_XMIN | EE_YMIN | EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSES_XMIN =           EE_YMIN | EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSES_XMAX = EE_XMIN | EE_YMIN |           EE_YMAX
    // OL_PART_ENCLOSES_YMIN = EE_XMIN |           EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSES_YMAX = EE_XMIN | EE_YMIN | EE_XMAX
    // OL_SPLIT_X            =           EE_YMIN |           EE_YMAX
    // OL_SPLIT_Y            = EE_XMIN |           EE_XMAX
    // OL_SPLIT_XMIN_YMIN    =                     EE_XMAX | EE_YMAX
    // OL_SPLIT_XMAX_YMIN    = EE_XMIN |                     EE_YMAX
    // OL_SPLIT_XMIN_YMAX    =           EE_YMIN | EE_XMAX
    // OL_SPLIT_XMAX_YMAX    = EE_XMIN | EE_YMIN
    //
    // The accumulated outcode value is returned.
    //
    //
    ExternalEdges = 0;
    ExternalCount = 0;
    if ( pRect1->left <= pRect2->left )
    {
        ExternalEdges |= EE_XMIN;
        ExternalCount ++;
    }
    if ( pRect1->top <= pRect2->top )
    {
        ExternalEdges |= EE_YMIN;
        ExternalCount ++;
    }
    if ( pRect1->right >= pRect2->right )
    {
        ExternalEdges |= EE_XMAX;
        ExternalCount ++;
    }
    if ( pRect1->bottom >= pRect2->bottom )
    {
        ExternalEdges |= EE_YMAX;
        ExternalCount ++;
    }
    if (ExternalCount >= 2)
    {
        return(ExternalEdges);
    }

    //
    // If get here then we failed to detect a valid case.
    //
    WARNING_OUT(( "Unrecognised Overlap: (%d,%d,%d,%d),(%d,%d,%d,%d)",
            pRect1->left, pRect1->top, pRect1->right, pRect1->bottom,
            pRect2->left, pRect2->top, pRect2->right, pRect2->bottom ));
    return(OL_NONE);
}



//
// Name:        BAAddRectList
//
// Description: Adds a rectangle to the list of accumulated rectangles.
//
//              - find a free slot in the array
//              - add slot record to list
//              - fill slot record with rect and mark as in use.
//
// Params (IN): pRect - rectangle to add
//
// Returns:
//
//
void BAAddRectList(LPRECT pRect)
{
    UINT     i;
    BOOL     fFoundFreeSlot;

    DebugEntry(BAAddRectList);

    //
    // Find a free slot in the array.  Note that the loop searches to
    // BA_NUM_RECTS+1, because:
    //
    // - the array is defined as having one more slot than BA_NUM_RECTS
    //
    // - we may need to add a rect in that slot when BA_NUM_RECTS are
    //   in use prior to a forced merge.
    //
    fFoundFreeSlot = FALSE;
    for ( i = 0; i <= BA_NUM_RECTS; i++ )
    {
        if (!g_baBounds[i].InUse)
        {
            fFoundFreeSlot = TRUE;
            break;
        }
    }

    if (!fFoundFreeSlot)
    {
        WARNING_OUT(( "No space in array for rect (%d,%d,%d,%d)",
                   pRect->left,
                   pRect->top,
                   pRect->right,
                   pRect->bottom));

        for ( i = 0; i <= BA_NUM_RECTS; i++ )
        {
            WARNING_OUT((
                     "Entry %i:Next(%lx),(%d,%d,%d,%d),Index(%d),InUse(%d)",
                       g_baBounds[i].iNext,
                       g_baBounds[i].Coord.left,
                       g_baBounds[i].Coord.top,
                       g_baBounds[i].Coord.right,
                       g_baBounds[i].Coord.bottom,
                       i,
                       g_baBounds[i].InUse));
        }

        DC_QUIT;
    }

    //
    // If first rect, then set up list.
    // If not, add to tail of list.
    //
    if (g_baRectsUsed == 0)
    {
        g_baFirstRect = i;
        g_baLastRect = i;
    }
    else
    {
        g_baBounds[g_baLastRect].iNext = i;
        g_baLastRect = i;
    }
    g_baBounds[i].iNext = BA_INVALID_RECT_INDEX;

    //
    // Fill in slot and mark as in use.
    //
    g_baBounds[i].InUse = TRUE;
    g_baBounds[i].Coord = *pRect;

    //
    // Increment number of rectangles.
    //
    TRACE_OUT(( "Add Rect  : ix - %d, (%d,%d,%d,%d)", i,
                    pRect->left,pRect->top,pRect->right,pRect->bottom));
    g_baRectsUsed++;

DC_EXIT_POINT:
    DebugExitVOID(BAAddRectList);
}


//
// Name:        BA_RemoveRectList
//
// Description: Removes a rectangle from the list of accumulated
//              rectangles.
//
//              - find the rectangle in the list
//              - unlink it from the list and mark the slot as free
//
// Params (IN): pRect - rectangle to remove
//
// Returns:
//
//
void BA_RemoveRectList(LPRECT pRect)
{
    UINT      i;
    UINT      j;

    DebugEntry(BA_RemoveRectList);

    //
    // If rectangle to remove is first...
    // Remove it by adjusting first pointer and mark as free.
    // Note that the check for tail adjustment has to be done before we
    // change first.
    //
    if ( g_baBounds[g_baFirstRect].Coord.left == pRect->left &&
         g_baBounds[g_baFirstRect].Coord.top == pRect->top &&
         g_baBounds[g_baFirstRect].Coord.right == pRect->right &&
         g_baBounds[g_baFirstRect].Coord.bottom == pRect->bottom   )
    {
        TRACE_OUT(( "Remove first"));
        if (g_baFirstRect == g_baLastRect)
        {
            g_baLastRect = BA_INVALID_RECT_INDEX;
        }
        g_baBounds[g_baFirstRect].InUse = FALSE;
        g_baFirstRect = g_baBounds[g_baFirstRect].iNext;
    }

    //
    // If rectangle to remove is not first...
    // Find it in list, remove it by adjusting previous pointer and mark it
    // as free.
    // Note that the check for tail adjustment has to be done before we
    // change the previous pointer.
    //
    else
    {
        TRACE_OUT(( "Remove not first"));
        for ( j = g_baFirstRect;
              g_baBounds[j].iNext != BA_INVALID_RECT_INDEX;
              j = g_baBounds[j].iNext )
        {
            if ( (g_baBounds[g_baBounds[j].iNext].Coord.left == pRect->left) &&
                 (g_baBounds[g_baBounds[j].iNext].Coord.top == pRect->top) &&
                 (g_baBounds[g_baBounds[j].iNext].Coord.right == pRect->right) &&
                 (g_baBounds[g_baBounds[j].iNext].Coord.bottom == pRect->bottom) )
            {
                break;
            }
        }

        if (j == BA_INVALID_RECT_INDEX)
        {
            WARNING_OUT(( "Couldn't remove rect (%d,%d,%d,%d)",
                       pRect->left,
                       pRect->top,
                       pRect->right,
                       pRect->bottom ));

            for ( i = 0; i <= BA_NUM_RECTS; i++ )
            {
                WARNING_OUT((
                       "Entry %i:Next(%lx),(%d,%d,%d,%d),Index(%d),InUse(%d)",
                           g_baBounds[i].iNext,
                           g_baBounds[i].Coord.left,
                           g_baBounds[i].Coord.top,
                           g_baBounds[i].Coord.right,
                           g_baBounds[i].Coord.bottom,
                           i,
                           g_baBounds[i].InUse));
            }
            return;
        }

        if (g_baBounds[j].iNext == g_baLastRect )
        {
             g_baLastRect = j;
        }
        g_baBounds[g_baBounds[j].iNext].InUse = FALSE;
        g_baBounds[j].iNext = g_baBounds[g_baBounds[j].iNext].iNext;
    }

    //
    // One less rect...
    //
    g_baRectsUsed--;
    DebugExitVOID(BA_RemoveRectList);
}


//
// Name:        BAAddRect
//
// Description: Accumulates rectangles.
//
//              This is a complex routine, with the essential algorithm
//              as follows.
//
//              - Start with the supplied rectangle as the candidate
//                rectangle.
//
//              - Compare the candidate against each of the existing
//                accumulated rectangles.
//
//              - If some form of overlap is detected between the
//                candidate and an existing rectangle, this may result in
//                one of the following (see the cases of the switch for
//                details):
//
//                - adjust the candidate or the existing rectangle or both
//                - merge the candidate into the existing rectangle
//                - discard the candidate as it is enclosed by an existing
//                  rectangle.
//
//              - If the merge or adjustment results in a changed
//                candidate, restart the comparisons from the beginning of
//                the list with the changed candidate.
//
//              - If the adjustment results in a split (giving two
//                candidate rectangles), invoke this routine recursively
//                with one of the two candidates as its candidate.
//
//              - If no overlap is detected against the existing rectangles,
//                add the candidate to the list of accumulated rectangles.
//
//              - If the add results in more than BA_NUM_RECTS
//                accumulated rectangles, do a forced merge of two of the
//                accumulate rectangles (which include the newly added
//                candidate) - choosing the two rectangles where the merged
//                rectangle results in the smallest increase in area over
//                the two non-merged rectangles.
//
//              - After a forced merge, restart the comparisons from the
//                beginning of the list with the newly merged rectangle as
//                the candidate.
//
//              For a particular call, this process will continue until
//              the candidate (whether the supplied rectangle, an adjusted
//              version of that rectangle, or a merged rectangle):
//
//              - does not find an overlap among the rectangles in the list
//                and does not cause a forced merge
//              - is discarded becuase it is enclosed within one of the
//                rectangles in the list.
//
//              Note that all rectangle coordinates are inclusive, ie
//              a rectangle of 0,0,0,0 has an area of 1 pel.
//
// Params (IN): pCand - new candidate rectangle
//              level - recursion level
//
// Returns:  TRUE if rectandle was spoilt due to a complete overlap.
//
//
BOOL BAAddRect
(
    LPRECT  pCand,
    int     level
)
{
    LONG    bestMergeIncrease;
    LONG    mergeIncrease;
    UINT    iBestMerge1;
    UINT    iBestMerge2;
    UINT    iExist;
    UINT    iTmp;
    BOOL    fRectToAdd;
    BOOL    fRectMerged;
    BOOL    fResetRects;
    RECT    rectNew;
    UINT    iLastMerge;
    int     OverlapType;
    BOOL    rc = TRUE;

    DebugEntry(BAAddRect);

    //
    // Increase the level count in case we recurse.
    //
    level++;

    //
    // Start off by assuming the candidate rectangle will be added to the
    // accumulated list of rectangles, and that no merges will occur.
    //
    fRectToAdd  = TRUE;
    fRectMerged = FALSE;

    //
    // Loop until no merges occur.
    //
    do
    {
        TRACE_OUT(( "Candidate rect: (%d,%d,%d,%d)",
                    pCand->left,pCand->top,pCand->right,pCand->bottom));

        //
        // Compare the current candidate rectangle against the rectangles
        // in the current accumulated list.
        //
        iExist = g_baFirstRect;

        while (iExist != BA_INVALID_RECT_INDEX)
        {
            //
            // Assume that the comparisons will run through the whole list.
            //
            fResetRects = FALSE;

            //
            // If the candidate and the existing rectangle are the same
            // then ignore.  This occurs when an existing rectangle is
            // replaced by a candidate and the comparisons are restarted
            // from the front of the list - whereupon at some point the
            // candidate will be compared with itself.
            //
            if ( &g_baBounds[iExist].Coord == pCand )
            {
                iExist = g_baBounds[iExist].iNext;
                continue;
            }

            //
            // Switch on the overlap type (see Overlap routine).
            //
            OverlapType = BAOverlap(&(g_baBounds[iExist].Coord), pCand);
            switch (OverlapType)
            {

                case OL_NONE:
                    //
                    // No overlap.
                    //
                    break;

                case OL_MERGE_XMIN:
                    //
                    // - either the candidate abutts the existing rectangle
                    //   on the left
                    //
                    //              10,10        51,10
                    //               +----------++----------+
                    //               |          ||          |
                    //               |          ||          |
                    //               |          ||          |
                    //               |  Cand    ||  Exist   |
                    //               |          ||          |
                    //               |          ||          |
                    //               |          ||          |
                    //               +----------++----------+
                    //                      50,50         100,50
                    //
                    // - or the candidate overlaps the existing on the left
                    //   and can be merged
                    //
                    //              10,10   40,10
                    //               +-------+--+------+
                    //               |       |  |      |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               | Cand  |  |Exist |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               +-------+--+------+
                    //                          50,50  90,50
                    //
                    // If the candidate is the original, merge the
                    // candidate into the existing, and make the existing
                    // the new candidate.
                    //
                    // If this is a merge of two existing rectangles (ie
                    // the candidate is the result of a merge), merge the
                    // overlapping existing into the candidate (the last
                    // merged) and remove the existing.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord.left = pCand->left;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        pCand->right = g_baBounds[iExist].Coord.right;
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;


                case OL_MERGE_XMAX:
                    //
                    // - either the candidate abutts the existing rectangle
                    //   on the right
                    //
                    //              10,10        51,10
                    //               +----------++----------+
                    //               |          ||          |
                    //               |          ||          |
                    //               |          ||          |
                    //               |  Exist   ||  Cand    |
                    //               |          ||          |
                    //               |          ||          |
                    //               |          ||          |
                    //               +----------++----------+
                    //                      50,50         100,50
                    //
                    // - or the candidate overlaps the existing on the right
                    //   and can be merged
                    //
                    //              10,10   40,10
                    //               +-------+--+------+
                    //               |       |  |      |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               | Exist |  | Cand |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               +-------+--+------+
                    //                          50,50  90,50
                    //
                    // If the candidate is the original, merge the
                    // candidate into the existing, and make the existing
                    // the new candidate.
                    //
                    // If this is a merge of two existing rectangles (ie
                    // the candidate is the result of a merge), merge the
                    // overlapping existing into the candidate (the last
                    // merged) and remove the existing.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord.right = pCand->right;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        pCand->left = g_baBounds[iExist].Coord.left;
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;

                case OL_MERGE_YMIN:
                    //
                    // - either the candidate abutts the existing rectangle
                    //   on the top
                    //
                    //              10,10
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,50
                    //            10,51+---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,100
                    //
                    // - or the candidate overlaps the existing on the top
                    //   and can be merged
                    //
                    //              10,10
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 |         |
                    //      Exist 10,40+---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,60 Cand
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,100
                    //
                    // If the candidate is the original, merge the
                    // candidate into the existing, and make the existing
                    // the new candidate.
                    //
                    // If this is a merge of two existing rectangles (ie
                    // the candidate is the result of a merge), merge the
                    // overlapping existing into the candidate (the last
                    // merged) and remove the existing.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord.top = pCand->top;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        pCand->bottom = g_baBounds[iExist].Coord.bottom;
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;

                case OL_MERGE_YMAX:
                    //
                    // - either the candidate abutts the existing rectangle
                    //   from below
                    //
                    //              10,10
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,50
                    //            10,51+---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,100
                    //
                    // - or the candidate overlaps the existing from below
                    //   and can be merged
                    //
                    //              10,10
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 |         |
                    //       Cand 10,40+---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,60 Exist
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,100
                    //
                    // If the candidate is the original, merge the
                    // candidate into the existing, and make the existing
                    // the new candidate.
                    //
                    // If this is a merge of two existing rectangles (ie
                    // the candidate is the result of a merge), merge the
                    // overlapping existing into the candidate (the last
                    // merged) and remove the existing.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord.bottom = pCand->bottom;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        pCand->top = g_baBounds[iExist].Coord.top;
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;

                case OL_ENCLOSED:
                    //
                    // The existing is enclosed by the candidate.
                    //
                    //              100,100
                    //              +----------------------+
                    //              |        Cand          |
                    //              |                      |
                    //              |    130,130           |
                    //              |    +------------+    |
                    //              |    |            |    |
                    //              |    |            |    |
                    //              |    |   Exist    |    |
                    //              |    |            |    |
                    //              |    +------------+    |
                    //              |             170,170  |
                    //              |                      |
                    //              +----------------------+
                    //                                   200,200
                    //
                    // If the candidate is the original, replace the
                    // existing by the candidate, and make the new existing
                    // the new candidate.
                    //
                    // If the candidate is an existing rectangle, remove
                    // the other existing rectangle.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord   = *pCand;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;

                case OL_PART_ENCLOSED_XMIN:
                    //
                    // The existing is partially enclosed by the candidate
                    // - but not on the right.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |        Cand          |
                    //           |                      |
                    //           |    130,130           |
                    //           |    +-----------------+---+
                    //           |    |                 |   |
                    //           |    |                 |   |
                    //           |    |   Exist         |   |
                    //           |    |                 |   |
                    //           |    +-----------------+---+
                    //           |                      |  220,170
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the existing rectangle to be the non-
                    // overlapped portion.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |                      |
                    //           |                      |201,130
                    //           |                      |+--+
                    //           |                      ||E |
                    //           |                      ||x |
                    //           |        Cand          ||i |
                    //           |                      ||s |
                    //           |                      ||t |
                    //           |                      ||  |
                    //           |                      |+--+
                    //           |                      |  220,170
                    //           +----------------------+
                    //                                200,200
                    //
                    // Note that this does not restart the comparisons.
                    //
                    g_baBounds[iExist].Coord.left = pCand->right + 1;
                    break;

                case OL_PART_ENCLOSED_XMAX:
                    //
                    // The existing is partially enclosed by the candidate
                    // - but not on the left.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |        Cand          |
                    //   70,130  |                      |
                    //     +-----+---------------+      |
                    //     |     |               |      |
                    //     |     |               |      |
                    //     |     |        Exist  |      |
                    //     |     |               |      |
                    //     +-----+---------------+      |
                    //           |           170,170    |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the existing rectangle to be the non-
                    // overlapped portion.
                    //
                    //           100,100
                    //           +----------------------+
                    //    70,130 |                      |
                    //     +----+|                      |
                    //     | E  ||                      |
                    //     | x  ||                      |
                    //     | i  ||        Cand          |
                    //     | s  ||                      |
                    //     | t  ||                      |
                    //     |    ||                      |
                    //     +----+|                      |
                    //     99,170|                      |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Note that this does not restart the comparisons.
                    //
                    g_baBounds[iExist].Coord.right = pCand->left - 1;
                    break;

                case OL_PART_ENCLOSED_YMIN:
                    //
                    // The existing is partially enclosed by the candidate
                    // - but not on the bottom.
                    //
                    //     100,100
                    //           +----------------------+
                    //           |        Cand          |
                    //           | 130,130              |
                    //           |     +--------+       |
                    //           |     |        |       |
                    //           |     |  Exist |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           +-----+--------+-------+
                    //                 |        |     200,200
                    //                 |        |
                    //                 |        |
                    //                 +--------+170,230
                    //
                    // Adjust the existing rectangle to be the non-
                    // overlapped portion.
                    //
                    //
                    //     100,100
                    //           +----------------------+
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |        Cand          |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           +----------------------+
                    //          130,201+---------+   200,200
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 +---------+170,230
                    //
                    // Note that this does not restart the comparisons.
                    //
                    g_baBounds[iExist].Coord.top = pCand->bottom + 1;
                    break;

                case OL_PART_ENCLOSED_YMAX:
                    //
                    // The existing is partially enclosed by the candidate
                    // - but not on the top.
                    //
                    //               70,130
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //     100,100     |         |
                    //           +-----+---------+------+
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     |  Exist  |      |
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     +---------+      |
                    //           |           170,170    |
                    //           |                      |
                    //           |        Cand          |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the existing rectangle to be the non-
                    // overlapped portion.
                    //
                    //               70,130
                    //                 +---------+
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //     100,100     +---------+170,99
                    //           +----------------------+
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |        Cand          |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Note that this does not restart the comparisons.
                    //
                    g_baBounds[iExist].Coord.bottom = pCand->top - 1;
                    break;

                case OL_ENCLOSES:
                    //
                    // The existing encloses the candidate.
                    //
                    //              100,100
                    //              +----------------------+
                    //              |        Exist         |
                    //              |                      |
                    //              |    130,130           |
                    //              |    +------------+    |
                    //              |    |            |    |
                    //              |    |            |    |
                    //              |    |   Cand     |    |
                    //              |    |            |    |
                    //              |    |            |    |
                    //              |    +------------+    |
                    //              |             170,170  |
                    //              |                      |
                    //              +----------------------+
                    //                                   200,200
                    //
                    // Just discard the candidate by exiting.
                    //
                    //
                    //
                    // Return FALSE indicating that the rectangle is
                    // already catered for by the existing bounds
                    //
                    rc= FALSE;
                    DC_QUIT;
                    break;

                case OL_PART_ENCLOSES_XMIN:
                    //
                    // The existing partially encloses the candidate - but
                    // not on the left.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |        Exist         |
                    //   70,130  |                      |
                    //     +-----+---------------+      |
                    //     |     |               |      |
                    //     |     |        Cand   |      |
                    //     |     |               |      |
                    //     +-----+---------------+      |
                    //           |           170,170    |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the candidate rectangle to be the non-
                    // overlapped portion.
                    //
                    //           100,100
                    //           +----------------------+
                    //    70,130 |                      |
                    //     +----+|                      |
                    //     |    ||                      |
                    //     | C  ||                      |
                    //     | a  ||                      |
                    //     | n  ||        Exist         |
                    //     | d  ||                      |
                    //     |    ||                      |
                    //     +----+|                      |
                    //     99,170|                      |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Because this affects the candidate, restart the
                    // comparisons to check for overlaps between the
                    // adjusted candidate and other existing rectangles.
                    //
                    //
                    pCand->right = g_baBounds[iExist].Coord.left - 1;

                    fResetRects = TRUE;
                    break;

                case OL_PART_ENCLOSES_XMAX:
                    //
                    // The existing partially encloses the candidate - but
                    // not on the right.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |        Exist         |
                    //           |                      |
                    //           |    130,130           |
                    //           |    +-----------------+---+
                    //           |    |                 |   |
                    //           |    |                 |   |
                    //           |    |   Cand          |   |
                    //           |    |                 |   |
                    //           |    +-----------------+---+
                    //           |                      |  220,170
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the candidate rectangle to be the non-
                    // overlapped portion.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |                      |201,130
                    //           |                      |+--+
                    //           |                      ||  |
                    //           |                      ||C |
                    //           |        Exist         ||a |
                    //           |                      ||n |
                    //           |                      ||d |
                    //           |                      ||  |
                    //           |                      |+--+
                    //           |                      |  220,170
                    //           +----------------------+
                    //                                200,200
                    //
                    // Because this affects the candidate, restart the
                    // comparisons to check for overlaps between the
                    // adjusted candidate and other existing rectangles.
                    //
                    //
                    pCand->left = g_baBounds[iExist].Coord.right + 1;

                    fResetRects = TRUE;
                    break;

                case OL_PART_ENCLOSES_YMIN:
                    //
                    // The existing partially encloses the candidate - but
                    // not on the top.
                    //
                    //               70,130
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //     100,100     |         |
                    //           +-----+---------+------+
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     |  Cand   |      |
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     +---------+      |
                    //           |           170,170    |
                    //           |                      |
                    //           |        Exist         |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the candidate rectangle to be the non-
                    // overlapped portion.
                    //
                    //
                    //               70,130
                    //                 +---------+
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //     100,100     +---------+170,99
                    //           +----------------------+
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |        Exist         |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Because this affects the candidate, restart the
                    // comparisons to check for overlaps between the
                    // adjusted candidate and other existing rectangles.
                    //
                    //
                    pCand->bottom = g_baBounds[iExist].Coord.top - 1;

                    fResetRects = TRUE;
                    break;

                case OL_PART_ENCLOSES_YMAX:
                    //
                    // The existing partially encloses the candidate - but
                    // not on the bottom.
                    //
                    //     100,100
                    //           +----------------------+
                    //           |        Exist         |
                    //           |                      |
                    //           | 130,130              |
                    //           |     +--------+       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |  Cand  |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           +-----+--------+-------+
                    //                 |        |     200,200
                    //                 |        |
                    //                 |        |
                    //                 +--------+170,230
                    //
                    // Adjust the candidate rectangle to be the non-
                    // overlapped portion.
                    //
                    //
                    //     100,100
                    //           +----------------------+
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |        Exist         |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           +----------------------+
                    //          130,201+---------+   200,200
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 +---------+170,230
                    //
                    // Because this affects the candidate, restart the
                    // comparisons to check for overlaps between the
                    // adjusted candidate and other existing rectangles.
                    //
                    //
                    pCand->top = g_baBounds[iExist].Coord.bottom + 1;

                    fResetRects = TRUE;
                    break;

                case OL_SPLIT_X:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //               100,100
                    //                 +--------+
                    //                 |        |
                    //        70,130   |  Exist |
                    //           +-----+--------+------+
                    //           |     |        |      |
                    //           |     |        |      |
                    //           | Cand|        |      |
                    //           |     |        |      |
                    //           |     |        |      |
                    //           +-----+--------+------+180,160
                    //                 |        |
                    //                 |        |
                    //                 +--------+150,200
                    //
                    // Need to split candidate into left and right halves.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the left and a new rectangle on
                    // the right. Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //               100,100
                    //                 +--------+
                    //                 |        |
                    //        70,130   |        |151,130
                    //           +----+|        |+-----+
                    //           |    ||        ||     |
                    //           |    ||        ||     |
                    //           |Cand|| Exist  || New |
                    //           |    ||        ||     |
                    //           |    ||        ||     |
                    //           +----+|        |+-----+
                    //           99,160|        |     180,160
                    //                 |        |
                    //                 +--------+150,200
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //
                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = g_baBounds[iExist].Coord.right + 1;
                        rectNew.right  = pCand->right;
                        rectNew.top    = pCand->top;
                        rectNew.bottom = pCand->bottom;
                        pCand->right   = g_baBounds[iExist].Coord.left - 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_Y:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //               100,100
                    //                 +--------+
                    //                 |        |
                    //        70,130   |  Cand  |
                    //           +-----+--------+------+
                    //           |     |        |      |
                    //           |     |        |      |
                    //           |Exist|        |      |
                    //           |     |        |      |
                    //           |     |        |      |
                    //           +-----+--------+------+180,160
                    //                 |        |
                    //                 |        |
                    //                 +--------+150,200
                    //
                    // Need to split candidate into top and bottom halves.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the top and a new rectangle on
                    // the bottom.  Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //               100,100
                    //                 +--------+
                    //                 |  Cand  |
                    //        70,130   +--------+150,129
                    //           +---------------------+
                    //           |                     |
                    //           |                     |
                    //           |                     |
                    //           |                     |
                    //           |                     |
                    //           +---------------------+180,160
                    //          100,161+--------+
                    //                 |  New   |
                    //                 +--------+150,200
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //

                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = pCand->left;
                        rectNew.right  = pCand->right;
                        rectNew.top    = g_baBounds[iExist].Coord.bottom + 1;
                        rectNew.bottom = pCand->bottom;
                        pCand->bottom  = g_baBounds[iExist].Coord.top - 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_XMIN_YMIN:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //          100,100
                    //              +---------------+
                    //              |   Cand        |
                    //              |               |
                    //              |               |
                    //              |      150,150  |
                    //              |       +-------+-----+
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              +-------+-------+     |
                    //                      |    200,200  |
                    //                      |             |
                    //                      |    Exist    |
                    //                      |             |
                    //                      +-------------+
                    //                                 250,250
                    //
                    // Need to split candidate into top and left pieces.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the left and a new rectangle on
                    // the top.  Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //          100,100     151,100
                    //              +-------+-------+
                    //              |       |       |
                    //              |       |  New  |
                    //              |       |       |
                    //              |       |       |200,149
                    //              |       +-------+-----+
                    //              | Cand  |150,150      |
                    //              |       |             |
                    //              |       |             |
                    //              |       |             |
                    //              |       |    Exist    |
                    //              +-------+             |
                    //               150,200|             |
                    //                      |             |
                    //                      |             |
                    //                      |             |
                    //                      +-------------+
                    //                                 250,250
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //

                    if ( g_baRectsUsed < BA_NUM_RECTS )
                    {
                        rectNew.left   = g_baBounds[iExist].Coord.left;
                        rectNew.right  = pCand->right;
                        rectNew.top    = pCand->top;
                        rectNew.bottom = g_baBounds[iExist].Coord.top - 1;
                        pCand->right   = g_baBounds[iExist].Coord.left - 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_XMAX_YMIN:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //                  150,100
                    //                     +---------------+
                    //                     |               |
                    //                     |       Cand    |
                    //          100,150    |               |
                    //              +------+--------+      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      +--------+------+
                    //              |               |   250,200
                    //              |  Exist        |
                    //              |               |
                    //              +---------------+
                    //                           200,250
                    //
                    // Need to split candidate into top and right pieces.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the right and a new rectangle
                    // on the top.  Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //                  150,100     201,100
                    //                     +--------+------+
                    //                     |  New   |      |
                    //                     |        |      |
                    //          100,150    | 200,149|      |
                    //              +------+--------+      |
                    //              |               | Cand |
                    //              |               |      |
                    //              |               |      |
                    //              |               |      |
                    //              |     Exist     |      |
                    //              |               |      |
                    //              |               +------+
                    //              |               |   250,200
                    //              |               |
                    //              |               |
                    //              +---------------+
                    //                           200,250
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //

                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = pCand->left;
                        rectNew.right  = g_baBounds[iExist].Coord.right;
                        rectNew.top    = pCand->top;
                        rectNew.bottom = g_baBounds[iExist].Coord.top - 1;
                        pCand->left    = g_baBounds[iExist].Coord.right + 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_XMIN_YMAX:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //                  150,100
                    //                     +---------------+
                    //                     |               |
                    //                     |      Exist    |
                    //          100,150    |               |
                    //              +------+--------+      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      +--------+------+
                    //              |               |   250,200
                    //              |  Cand         |
                    //              |               |
                    //              +---------------+
                    //                           200,250
                    //
                    // Need to split candidate into left and bottom pieces.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the left and a new rectangle on
                    // the bottom.  Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //                  150,100
                    //                     +---------------+
                    //                     |               |
                    //                     |               |
                    //          100,150    |               |
                    //              +------+               |
                    //              |      |               |
                    //              |      |               |
                    //              |      |               |
                    //              |      |               |
                    //              | Cand |               |
                    //              |      |               |
                    //              |      +--------+------+
                    //              |      |151,200 |   250,200
                    //              |      |        |
                    //              |      |  New   |
                    //              +------+--------+
                    //                  149,250   200,250
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //

                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = g_baBounds[iExist].Coord.left;
                        rectNew.right  = pCand->right;
                        rectNew.top    = g_baBounds[iExist].Coord.bottom + 1;
                        rectNew.bottom = pCand->bottom;
                        pCand->right   = g_baBounds[iExist].Coord.left - 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_XMAX_YMAX:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //          100,100
                    //              +---------------+
                    //              |   Exist       |
                    //              |               |
                    //              |               |
                    //              |      150,150  |
                    //              |       +-------+-----+
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              +-------+-------+     |
                    //                      |    200,200  |
                    //                      |             |
                    //                      |    Cand     |
                    //                      |             |
                    //                      +-------------+
                    //                                 250,250
                    //
                    // Need to split candidate into bottom and right pieces.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the right and a new rectangle
                    // on the bottom.  Call this routine recursively to
                    // handle the new rectangle.
                    //
                    //          100,100
                    //              +---------------+
                    //              |               |
                    //              |               |
                    //              |               |
                    //              |               |201,150
                    //              |    Exist      +-----+
                    //              |               |     |
                    //              |               |     |
                    //              |               |     |
                    //              |               |Cand |
                    //              |        200,200|     |
                    //              +-------+-------+     |
                    //               150,201|       |     |
                    //                      |       |     |
                    //                      |  New  |     |
                    //                      |       |     |
                    //                      +-------+-----+
                    //                         200,250  250,250
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //

                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = pCand->left;
                        rectNew.right  = g_baBounds[iExist].Coord.right;
                        rectNew.top    = g_baBounds[iExist].Coord.bottom + 1;
                        rectNew.bottom = pCand->bottom;
                        pCand->left    = g_baBounds[iExist].Coord.right + 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                default:
                    //
                    // This should not happen.
                    //
                    ERROR_OUT(( "Unrecognised overlap case-%d",OverlapType));
                    break;
            }

            iExist = (fResetRects) ? g_baFirstRect :
                                     g_baBounds[iExist].iNext;
        }


        //
        // Arriving here means that no overlap was found between the
        // candidate and the existing rectangles.
        //
        // - If the candidate is the original rectangle, add it to the
        //   list.
        // - If the candidate is an existing rectangle, it is already in
        //   the list.
        //
        if ( fRectToAdd )
        {
            BAAddRectList(pCand);
        }


        //
        // The compare and add processing above is allowed to add a
        // rectangle to the list when there are already BA_NUM_RECTS
        // (eg. when doing a split or when there is no overlap at all with
        // the existing rectangles) - and there is an extra slot for that
        // purpose.
        //
        // If we now have more than BA_NUM_RECTS rectangles, do a
        // forced merge, so that the next call to this routine has a spare
        // slot.
        //
        //
        fRectMerged = ( g_baRectsUsed > BA_NUM_RECTS );
        if ( fRectMerged )
        {
            //
            // Start looking for merged rectangles.
            //
            // For each rectangle in the list, compare it with the others,
            // and Determine cost of merging.
            //
            // We want to merge the two rectangles with the minimum
            // area difference, ie that will produce a merged
            // rectangle that covers the least superfluous screen
            // area.
            //
            // Note that we calculate the areas of the rectangles here
            // (rather than on the fly as they are created/ manipulated in
            // the loop), as the statistics show that forced merges occur
            // very much less frequently than non-forced manipulations (ie
            // splits, adds etc.
            //
            //
            bestMergeIncrease = 0x7FFFFFFF;

            for ( iExist = g_baFirstRect;
                  iExist != BA_INVALID_RECT_INDEX;
                  iExist = g_baBounds[iExist].iNext )
            {
                g_baBounds[iExist].Area =
                    COM_SizeOfRectInclusive(&g_baBounds[iExist].Coord);
            }

#ifdef _DEBUG
            iBestMerge1 = BA_INVALID_RECT_INDEX;
            iBestMerge2 = BA_INVALID_RECT_INDEX;
#endif
            for ( iExist = g_baFirstRect;
                  iExist != BA_INVALID_RECT_INDEX;
                  iExist = g_baBounds[iExist].iNext )
            {
                for ( iTmp = g_baBounds[iExist].iNext;
                      iTmp != BA_INVALID_RECT_INDEX;
                      iTmp = g_baBounds[iTmp].iNext )
                {
                    rectNew.left = min( g_baBounds[iExist].Coord.left,
                                           g_baBounds[iTmp].Coord.left );
                    rectNew.top = min( g_baBounds[iExist].Coord.top,
                                          g_baBounds[iTmp].Coord.top );
                    rectNew.right = max( g_baBounds[iExist].Coord.right,
                                            g_baBounds[iTmp].Coord.right );
                    rectNew.bottom = max( g_baBounds[iExist].Coord.bottom,
                                             g_baBounds[iTmp].Coord.bottom );

                    mergeIncrease = COM_SizeOfRectInclusive(&rectNew) -
                        g_baBounds[iExist].Area - g_baBounds[iTmp].Area;

                    if (bestMergeIncrease > mergeIncrease)
                    {
                        iBestMerge1 = iExist;
                        iBestMerge2 = iTmp;
                        bestMergeIncrease = mergeIncrease;
                    }
                }
            }

            ASSERT(iBestMerge1 != BA_INVALID_RECT_INDEX);
            ASSERT(iBestMerge2 != BA_INVALID_RECT_INDEX);

            //
            // Now do the merge.
            //
            // We recalculate the size of the merged rectangle here -
            // alternatively we could remember the size of the best so far
            // in the loop above.  The trade off is between calculating
            // twice or copying at least once but probably more than once
            // as we find successively better merges.
            //
            TRACE_OUT(("BestMerge1 %d, {%d,%d,%d,%d}", iBestMerge1,
                       g_baBounds[iBestMerge1].Coord.left,
                       g_baBounds[iBestMerge1].Coord.top,
                       g_baBounds[iBestMerge1].Coord.right,
                       g_baBounds[iBestMerge1].Coord.bottom ));

            TRACE_OUT(("BestMerge2 %d, {%d,%d,%d,%d}", iBestMerge2,
                       g_baBounds[iBestMerge2].Coord.left,
                       g_baBounds[iBestMerge2].Coord.top,
                       g_baBounds[iBestMerge2].Coord.right,
                       g_baBounds[iBestMerge2].Coord.bottom ));

            g_baBounds[iBestMerge1].Coord.left =
                            min( g_baBounds[iBestMerge1].Coord.left,
                                    g_baBounds[iBestMerge2].Coord.left );
            g_baBounds[iBestMerge1].Coord.top =
                            min( g_baBounds[iBestMerge1].Coord.top,
                                    g_baBounds[iBestMerge2].Coord.top );
            g_baBounds[iBestMerge1].Coord.right =
                            max( g_baBounds[iBestMerge1].Coord.right,
                                    g_baBounds[iBestMerge2].Coord.right );
            g_baBounds[iBestMerge1].Coord.bottom =
                            max( g_baBounds[iBestMerge1].Coord.bottom,
                                    g_baBounds[iBestMerge2].Coord.bottom );

            //
            // Remove the second best merge.
            //
            BA_RemoveRectList(&(g_baBounds[iBestMerge2].Coord));

            //
            // The best merged rectangle becomes the candidate, and we fall
            // back to the head of the comparison loop to start again.
            //
            pCand      = &(g_baBounds[iBestMerge1].Coord);
            iLastMerge = iBestMerge1;
            fRectToAdd = FALSE;
        }

    } while ( fRectMerged );

DC_EXIT_POINT:
    DebugExitBOOL(BAAddRect, rc);
    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\as16\com.c ===
//
// COM.C
// Utility functions
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>


//
// PostMessageNoFail()
// This makes sure posted messages don't get lost on Win95 due to the fixed
// interrupt queue.  Conveniently, USER exports PostPostedMessages for
// KERNEL to flush the queue, so we call that before calling PostMessage().
//
void PostMessageNoFail(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PostPostedMessages();
    PostMessage(hwnd, uMsg, wParam, lParam);
}


//
// AnsiToUni()
//
// UniToAnsi() is conveniently exported by krnl386.  However, we need 
// AnsiToUni() conversions also so we can make sure we end up where we
// started.  This one we have to roll our own thunk for
//
int AnsiToUni
(
    LPSTR   lpAnsi,
    int     cchAnsi,
    LPWSTR  lpUni,
    int     cchUni
)
{
    DWORD   dwMask;
    LONG    lReturn;

    DebugEntry(AnsiToUni);

    ASSERT(g_lpfnAnsiToUni);
    ASSERT(SELECTOROF(lpAnsi));
    ASSERT(SELECTOROF(lpUni));

    //
    // Set up the mask.  These are the params:
    //      0   --  CodePage (CP_ACP, which is 0L)
    //      1   --  Flags (0L)
    //      2   --  lpAnsi              POINTER
    //      3   --  cchAnsi
    //      4   --  lpUni               POINTER
    //      5   --  cchUni
    //
    //
    dwMask = (1L << 2) | (1L << 4);

    //
    // Take the win16lock an extra time; this API will release it, and we
    // can't yield in the middle of a GDI call.
    //
    _EnterWin16Lock();
    lReturn = CallProcEx32W(6, dwMask, (DWORD)g_lpfnAnsiToUni, 0L, 0L, lpAnsi,
        (DWORD)(UINT)cchAnsi, lpUni, (DWORD)(UINT)cchUni);
    _LeaveWin16Lock();

    DebugExitDWORD(AnsiToUni, (DWORD)lReturn);
    return((int)lReturn);
}


//
// PATCHING CODE
//


//
// Get32BitOnlyExport16()
//
// This function gets hold of a 16:16 function address that isn't exported
// but is called via a flat thunk from the exported 32-bit version.  We use
// this for GDI and USER functions that are handy.
//
// This code assumes that the 32-bit routine looks like the following:
//      <DEBUG>
//          68 dwStr32          Push string
//          E8 dwOffsetOut      Call trace out
//      <DEBUG AND RETAIL>
//          B1 bIndex           Put offset in thunk table into cl
//        OR
//          66 B9 wIndex        Put offset in thunk table into cx
//          
//          EB bOffset          Jmp to common flat thunk routine
//        OR
//          66 ED wOffset       Jmp word to common flat thunk routine
//        OR
//          prolog of common flat thunk routine
//          
BOOL GetGdi32OnlyExport
(
    LPSTR   lpszExport32,
    UINT    cbJmpOffset,
    FARPROC FAR* lplpfn16
)
{
    BOOL    rc;

    DebugEntry(GetGdi32OnlyExport);

    rc = Get32BitOnlyExport(GetProcAddress32(g_hInstGdi32, lpszExport32),
        cbJmpOffset, FT_GdiFThkThkConnectionData, lplpfn16);

    DebugExitBOOL(GetGdi32OnlyExport, rc);
    return(rc);
}


BOOL GetUser32OnlyExport
(
    LPSTR   lpszExport32,
    FARPROC FAR* lplpfn16
)
{
    BOOL    rc;

    DebugEntry(GetUser32OnlyExport);

    rc = Get32BitOnlyExport(GetProcAddress32(g_hInstUser32, lpszExport32),
        0, FT_UsrFThkThkConnectionData, lplpfn16);

    DebugExitBOOL(GetUser32OnlyExport, rc);
    return(rc);
}



BOOL Get32BitOnlyExport
(
    DWORD   dwfn32,
    UINT    cbJmpOffset,
    LPDWORD lpThunkTable,
    FARPROC FAR* lplpfn16
)
{
    LPBYTE  lpfn32;
    UINT    offsetThunk;

    DebugEntry(Get32BitOnlyExport);

    ASSERT(lplpfn16);
    *lplpfn16 = NULL;

    //
    // The thunk table pointer points to two DWORDs.  The first is a
    // checksum signature.  The second is the pointer to the target
    // function array.
    //
    ASSERT(!IsBadReadPtr(lpThunkTable, 2*sizeof(DWORD)));
    lpThunkTable = (LPDWORD)lpThunkTable[1];
    ASSERT(!IsBadReadPtr(lpThunkTable, sizeof(DWORD)));

    //
    // Get 16:16 pointer to export
    //
    lpfn32 = NULL;

    if (!dwfn32)
    {
        ERROR_OUT(("Missing 32-bit export"));
        DC_QUIT;
    }

    lpfn32 = MapLS((LPVOID)dwfn32);
    if (!SELECTOROF(lpfn32))
    {
        ERROR_OUT(("Out of selectors"));
        DC_QUIT;
    }

    //
    // Was a jmp offset passed in?  If so, decode the instruction there.
    // It should be a jmp <dword offset>.  Figure out what EIP would be
    // if we jumped there. That's the place the flat thunk occurs.  
    // Currently, only PolyPolyline needs this.
    //
    if (cbJmpOffset)
    {
        if (IsBadReadPtr(lpfn32, cbJmpOffset+5) ||
            (lpfn32[cbJmpOffset] != OPCODE32_JUMP4))
        {
            ERROR_OUT(("Can't read 32-bit export"));
            DC_QUIT;
        }

        //
        // Add dword at cbJmpOffset+1, add this number to (lpfn32+cbJmpOffset+
        // 5), which is the EIP of the next instruction after the jump.  This
        // produces the EIP of the real thunk stub.
        //
        dwfn32 += cbJmpOffset + 5 + *(LPDWORD)(lpfn32+cbJmpOffset+1);

        UnMapLS(lpfn32);
        lpfn32 = MapLS((LPVOID)dwfn32);
        if (!SELECTOROF(lpfn32))
        {
            ERROR_OUT(("Out of selectors"));
            DC_QUIT;
        }
    }

    //
    // Verify that we can read 13 bytes.  The reason this will won't go 
    // past the end in a legitimate case is that this thunklet is either
    // followed by the large # of bytes in the common flat thunk routine,
    // or by another thunklet
    //
    if (IsBadReadPtr(lpfn32, 13))
    {
        ERROR_OUT(("Can't read code in 32-bit export"));
        DC_QUIT;
    }

    //
    // Does this have the 10-byte DEBUG prolog?
    //
    if (*lpfn32 == OPCODE32_PUSH)
    {
        // Yes, skip it
        lpfn32 += 5;

        // Make sure that next thing is a call
        if (*lpfn32 != OPCODE32_CALL)
        {
            ERROR_OUT(("Can't read code in 32-bit export"));
            DC_QUIT;
        }

        lpfn32 += 5;
    }

    //
    // This should either be mov cl, byte or mov cx, word
    //
    if (*lpfn32 == OPCODE32_MOVCL)
    {
        offsetThunk = *(lpfn32+1);
    }
    else if (*((LPWORD)lpfn32) == OPCODE32_MOVCX)
    {
        //
        // NOTE:  Even though this is a CX offset, the thunk code only
        // looks at the low BYTE
        //
        offsetThunk = *(lpfn32+2);
    }
    else
    {
        ERROR_OUT(("Can't read code in 32-bit export"));
        DC_QUIT;
    }

    //
    // Now, can we read this value?
    //
    if (IsBadReadPtr(lpThunkTable+offsetThunk, sizeof(DWORD)) ||
        IsBadCodePtr((FARPROC)lpThunkTable[offsetThunk]))
    {
        ERROR_OUT(("Can't read thunk table entry"));
        DC_QUIT;
    }

    *lplpfn16 = (FARPROC)lpThunkTable[offsetThunk];

DC_EXIT_POINT:
    if (SELECTOROF(lpfn32))
    {
        UnMapLS(lpfn32);
    }
    DebugExitBOOL(Get32BitOnlyExport16, (*lplpfn16 != NULL));
    return(*lplpfn16 != NULL);
}




//
// CreateFnPatch()
// This sets things up to be able to quickly patch/unpatch a system routine.
// The patch is not originally enabled.
//
UINT CreateFnPatch
(
    LPVOID      lpfnToPatch,
    LPVOID      lpfnJumpTo,
    LPFN_PATCH  lpbPatch,
    UINT        uCodeAlias
)
{
    SEGINFO     segInfo;
    UINT        ib;

    DebugEntry(CreateFnPatch);

    ASSERT(lpbPatch->lpCodeAlias == NULL);
    ASSERT(lpbPatch->wSegOrg == 0);

    //
    // Do NOT call IsBadReadPtr() here, that will cause the segment, if
    // not present, to get pulled in, and will masks problems in the debug
    // build that will show up in retail.
    //
    // Fortunately, PrestoChangoSelector() will set the linear address and
    // limit and attributes of our read/write selector properly.
    //

    //
    // Call GetCodeInfo() to check out bit-ness of code segment.  If 32-bit
    // we need to use the 16-bit override opcode for a far 16:16 jump.
    //
    segInfo.flags = 0;
    GetCodeInfo(lpfnToPatch, &segInfo);
    if (segInfo.flags & NSUSE32)
    {
        WARNING_OUT(("Patching 32-bit code segment 0x%04x:0x%04x", SELECTOROF(lpfnToPatch), OFFSETOF(lpfnToPatch)));
        lpbPatch->f32Bit = TRUE;
    }

    //
    // We must fix the codeseg in linear memory, or our shadow will end up
    // pointing somewhere if the original moves.  PolyBezier and SetPixel
    // are in moveable code segments for example.
    //
    // So save this away.  We will fix it when the patch is enabled.
    //
    lpbPatch->wSegOrg = SELECTOROF(lpfnToPatch);

    if (uCodeAlias)
    {
        //
        // We are going to share an already allocated selector.  Note that
        // this only works if the code segments of the two patched functions
        // are identical.  We verify this by the base address in an assert
        // down below.
        //
        lpbPatch->fSharedAlias = TRUE;
    }
    else
    {
        //
        // Create a selector with read-write attributes to alias the read-only
        // code function.  Using the original will set the limit of our
        // selector to the same as that of the codeseg, with the same
        // attributes but read-write.
        //
        uCodeAlias = AllocSelector(SELECTOROF(lpfnToPatch));
        if (!uCodeAlias)
        {
            ERROR_OUT(("CreateFnPatch: Unable to create alias selector"));
            DC_QUIT;
        }
        uCodeAlias = PrestoChangoSelector(SELECTOROF(lpfnToPatch), uCodeAlias);
    }

    lpbPatch->lpCodeAlias = MAKELP(uCodeAlias, OFFSETOF(lpfnToPatch));

    //
    // Create the N patch bytes (jmp far16 Seg:Function) of the patch
    //
    ib = 0;
    if (lpbPatch->f32Bit)
    {
        lpbPatch->rgbPatch[ib++] = OPCODE32_16OVERRIDE;
    }
    lpbPatch->rgbPatch[ib++] = OPCODE_FARJUMP16;
    lpbPatch->rgbPatch[ib++] = LOBYTE(OFFSETOF(lpfnJumpTo));
    lpbPatch->rgbPatch[ib++] = HIBYTE(OFFSETOF(lpfnJumpTo));
    lpbPatch->rgbPatch[ib++] = LOBYTE(SELECTOROF(lpfnJumpTo));
    lpbPatch->rgbPatch[ib++] = HIBYTE(SELECTOROF(lpfnJumpTo));

    lpbPatch->fActive  = FALSE;
    lpbPatch->fEnabled = FALSE;
     
DC_EXIT_POINT:
    DebugExitBOOL(CreateFnPatch, uCodeAlias);
    return(uCodeAlias);
}



//
// DestroyFnPatch()
// This frees any resources used when creating a function patch.  The
// alias data selector to the codeseg for writing purposes is it.
//
void DestroyFnPatch(LPFN_PATCH lpbPatch)
{
    DebugEntry(DestroyFnPatch);

    //
    // First, disable the patch if in use
    //
    if (lpbPatch->fActive)
    {
        TRACE_OUT(("Destroying active patch"));
        EnableFnPatch(lpbPatch, PATCH_DEACTIVATE);
    }

    //
    // Second, free the alias selector if we allocated one
    //
    if (lpbPatch->lpCodeAlias)
    {
        if (!lpbPatch->fSharedAlias)
        {
            FreeSelector(SELECTOROF(lpbPatch->lpCodeAlias));
        }
        lpbPatch->lpCodeAlias = NULL;
    }

    //
    // Third, clear this to fine cleanup problems
    //
    lpbPatch->wSegOrg = 0;
    lpbPatch->f32Bit  = FALSE;

    DebugExitVOID(DestroyFnPatch);
}




//
// EnableFnPatch()
// This actually patches the function to jump to our routine using the
// info saved when created.
//
// THIS ROUTINE MAY GET CALLED AT INTERRUPT TIME.  YOU CAN NOT USE ANY
// EXTERNAL FUNCTION, INCLUDING DEBUG TRACING/ASSERTS.
//
#define SAFE_ASSERT(x)       if (!lpbPatch->fInterruptable) { ASSERT(x); }

void EnableFnPatch(LPFN_PATCH lpbPatch, UINT flags)
{
    UINT    ib;
    UINT    cbPatch;

    SAFE_ASSERT(lpbPatch->lpCodeAlias);
    SAFE_ASSERT(lpbPatch->wSegOrg);

    //
    // Make sure the original and the alias are pointing to the same
    // linear memory.  We don't do this when not enabling/disabling for calls,
    // only when starting/stopping the patches
    //

    //
    // If enabling for the first time, fix BEFORE bytes are copied
    //
    if ((flags & ENABLE_MASK) == ENABLE_ON)
    {
        //
        // We need to fix the original code segment so it won't move in
        // linear memory.  Note that we set the selector base of our alias
        // even though several patches (not too many) may share one.  The 
        // extra times are harmless, and this prevents us from having to order
        // patches in our array in such a way that the original precedes the
        // shared ones, and walking our array in opposite orders to enable or
        // disable.
        //
        // And GlobalFix() just bumps up a lock count, so again, it's OK to do
        // this multiple times.
        //

        //
        // WE KNOW THIS CODE DOESN'T EXECUTE AT INTERRUPT TIME.
        //
        ASSERT(!lpbPatch->fEnabled);
        ASSERT(!lpbPatch->fActive);

        if (!lpbPatch->fActive)
        {
            lpbPatch->fActive = TRUE;

            //
            // Make sure this segment gets pulled in if discarded.  GlobalFix()
            // fails if not, and worse we'll fault the second we try to write 
            // to or read from the alias.  We do this by grabbing the 1st word
            // from the original.
            //
            // GlobalFix will prevent the segment from being discarded until
            // GlobalUnfix() happens.
            //
            ib = *(LPUINT)MAKELP(lpbPatch->wSegOrg, OFFSETOF(lpbPatch->lpCodeAlias));
            GlobalFix((HGLOBAL)lpbPatch->wSegOrg);
            SetSelectorBase(SELECTOROF(lpbPatch->lpCodeAlias), GetSelectorBase(lpbPatch->wSegOrg));
        }
    }

    if (lpbPatch->fInterruptable)
    {
        //
        // If this is for starting/stopping the patch, we have to disable
        // interrupts around the byte copying.  Or we could die if the
        // interrupt handler happens in the middle.
        //
        // We don't need to do this when disabling/enabling to call through
        // to the original, since we know that reflected interrupts aren't
        // nested, and the interrupt will complete before we come back to 
        // the interrupted normal app code.
        //
        if (!(flags & ENABLE_FORCALL))
        {
            _asm cli
        }
    }

    SAFE_ASSERT(GetSelectorBase(SELECTOROF(lpbPatch->lpCodeAlias)) == GetSelectorBase(lpbPatch->wSegOrg));

    if (lpbPatch->f32Bit)
    {
        cbPatch = CB_PATCHBYTES32;
    }
    else
    {
        cbPatch = CB_PATCHBYTES16;
    }

    if (flags & ENABLE_ON)
    {
        SAFE_ASSERT(lpbPatch->fActive);
        SAFE_ASSERT(!lpbPatch->fEnabled);

        if (!lpbPatch->fEnabled)
        {
            //
            // Save the function's original first N bytes, and copy the jump far16
            // patch in.
            //
            for (ib = 0; ib < cbPatch; ib++)
            {
                lpbPatch->rgbOrg[ib]        = lpbPatch->lpCodeAlias[ib];
                lpbPatch->lpCodeAlias[ib]   = lpbPatch->rgbPatch[ib];
            }

            lpbPatch->fEnabled = TRUE;
        }
    }
    else
    {
        SAFE_ASSERT(lpbPatch->fActive);
        SAFE_ASSERT(lpbPatch->fEnabled);

        if (lpbPatch->fEnabled)
        {
            //
            // Put back the function's original first N bytes
            //
            for (ib = 0; ib < cbPatch; ib++)
            {
                lpbPatch->lpCodeAlias[ib] = lpbPatch->rgbOrg[ib];
            }

            lpbPatch->fEnabled = FALSE;
        }
    }

    SAFE_ASSERT(GetSelectorBase(SELECTOROF(lpbPatch->lpCodeAlias)) == GetSelectorBase(lpbPatch->wSegOrg));

    if (lpbPatch->fInterruptable)
    {
        //
        // Reenable interrupts
        //
        if (!(flags & ENABLE_FORCALL))
        {
            _asm sti
        }

    }

    //
    // If really stopping, unfix AFTER the bytes have been copied.  This will
    // bump down a lock count, so when all patches are disabled, the original
    // code segment will be able to move.
    //
    if ((flags & ENABLE_MASK) == ENABLE_OFF)
    {
        //
        // WE KNOW THIS CODE DOESN'T EXECUTE AT INTERRUPT TIME.
        //

        ASSERT(!lpbPatch->fEnabled);
        ASSERT(lpbPatch->fActive);

        if (lpbPatch->fActive)
        {
            lpbPatch->fActive = FALSE;
            GlobalUnfix((HGLOBAL)lpbPatch->wSegOrg);
        }
    }
}


//
// LIST MANIPULATION ROUTINES
//

//
// COM_BasedListInsertBefore(...)
//
// See com.h for description.
//
void COM_BasedListInsertBefore(PBASEDLIST pExisting, PBASEDLIST pNew)
{
    PBASEDLIST  pTemp;

    DebugEntry(COM_BasedListInsertBefore);

    //
    // Check for bad parameters.
    //
    ASSERT((pNew != NULL));
    ASSERT((pExisting != NULL));

    //
    // Find the item before pExisting:
    //
    pTemp = COM_BasedPrevListField(pExisting);
    ASSERT((pTemp != NULL));

    TRACE_OUT(("Inserting item at %#lx into list between %#lx and %#lx",
                 pNew, pTemp, pExisting));

    //
    // Set its <next> field to point to the new item
    //
    pTemp->next = PTRBASE_TO_OFFSET(pNew, pTemp);
    pNew->prev  = PTRBASE_TO_OFFSET(pTemp, pNew);

    //
    // Set <prev> field of pExisting to point to new item:
    //
    pExisting->prev = PTRBASE_TO_OFFSET(pNew, pExisting);
    pNew->next      = PTRBASE_TO_OFFSET(pExisting, pNew);

    DebugExitVOID(COM_BasedListInsertBefore);
} // COM_BasedListInsertBefore


//
// COM_BasedListInsertAfter(...)
//
// See com.h for description.
//
void COM_BasedListInsertAfter(PBASEDLIST pExisting, PBASEDLIST pNew)
{
    PBASEDLIST  pTemp;

    DebugEntry(COM_BasedListInsertAfter);

    //
    // Check for bad parameters.
    //
    ASSERT((pNew != NULL));
    ASSERT((pExisting != NULL));

    //
    // Find the item after pExisting:
    //
    pTemp = COM_BasedNextListField(pExisting);
    ASSERT((pTemp != NULL));

    TRACE_OUT(("Inserting item at %#lx into list between %#lx and %#lx",
                 pNew, pExisting, pTemp));

    //
    // Set its <prev> field to point to the new item
    //
    pTemp->prev = PTRBASE_TO_OFFSET(pNew, pTemp);
    pNew->next  = PTRBASE_TO_OFFSET(pTemp, pNew);

    //
    // Set <next> field of pExisting to point to new item:
    //
    pExisting->next = PTRBASE_TO_OFFSET(pNew, pExisting);
    pNew->prev      = PTRBASE_TO_OFFSET(pExisting, pNew);

    DebugExitVOID(COM_BasedListInsertAfter);
} // COM_BasedListInsertAfter


//
// COM_BasedListRemove(...)
//
// See com.h for description.
//
void COM_BasedListRemove(PBASEDLIST pListItem)
{
    PBASEDLIST pNext     = NULL;
    PBASEDLIST pPrev     = NULL;

    DebugEntry(COM_BasedListRemove);

    //
    // Check for bad parameters.
    //
    ASSERT((pListItem != NULL));

    pPrev = COM_BasedPrevListField(pListItem);
    pNext = COM_BasedNextListField(pListItem);

    ASSERT((pPrev != NULL));
    ASSERT((pNext != NULL));

    TRACE_OUT(("Removing item at %#lx from list", pListItem));

    pPrev->next = PTRBASE_TO_OFFSET(pNext, pPrev);
    pNext->prev = PTRBASE_TO_OFFSET(pPrev, pNext);

    DebugExitVOID(COM_BasedListRemove);
} // COM_BasedListRemove


//
// NOTE:
// Because this is small model 16-bit code, NULL (which is 0) gets turned
// into ds:0 when casting to void FAR*.  Therefore we use our own FAR_NULL
// define, which is 0:0.
//
void FAR * COM_BasedListNext( PBASEDLIST pHead, void FAR * pEntry, UINT nOffset )
{
     PBASEDLIST p;

     ASSERT(pHead != NULL);
     ASSERT(pEntry != NULL);

     p = COM_BasedNextListField(COM_BasedStructToField(pEntry, nOffset));
     return ((p == pHead) ? FAR_NULL : COM_BasedFieldToStruct(p, nOffset));
}

void FAR * COM_BasedListPrev ( PBASEDLIST pHead, void FAR * pEntry, UINT nOffset )
{
     PBASEDLIST p;

     ASSERT(pHead != NULL);
     ASSERT(pEntry != NULL);

     p = COM_BasedPrevListField(COM_BasedStructToField(pEntry, nOffset));
     return ((p == pHead) ? FAR_NULL : COM_BasedFieldToStruct(p, nOffset));
}


void FAR * COM_BasedListFirst ( PBASEDLIST pHead, UINT nOffset )
{
    return (COM_BasedListIsEmpty(pHead) ?
            FAR_NULL :
            COM_BasedFieldToStruct(COM_BasedNextListField(pHead), nOffset));
}

void FAR * COM_BasedListLast ( PBASEDLIST pHead, UINT nOffset )
{
    return (COM_BasedListIsEmpty(pHead) ?
            FAR_NULL :
            COM_BasedFieldToStruct(COM_BasedPrevListField(pHead), nOffset));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\common.inc ===
#
# COMMON.INC
# Common build rules for NT/Win95 app sharing dll
#
# Copyright(c) Microsoft 1998-
#

$(O)\nmas.rc: ..\cpi32\nmas.rc
                del $(O)\nmas.rc
                copy ..\cpi32\nmas.rc $(O)

$(O)\cpi32dll.cpp: ..\cpi32\cpi32dll.cpp
                del $(O)\cpi32dll.cpp
                copy ..\cpi32\cpi32dll.cpp $(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\as16\globals.h ===
//
// GLOBALS.H
// Global Variable Decls
//
// Copyright(c) Microsoft 1997-
//


//
// Debug stuff
//
#ifdef DEBUG
DC_DATA_VAL ( char,         g_szAssertionFailure[], "Assertion failure!" );
DC_DATA_VAL ( char,         g_szNewline[], "\n" );
DC_DATA_ARRAY ( char,       g_szDbgBuf, CCH_DEBUG_MAX );
DC_DATA     ( UINT,         g_dbgRet );
DC_DATA     ( UINT,         g_trcConfig );
#endif // DEBUG


//
// DLL/Driver stuff
//
DC_DATA     ( HINSTANCE,    g_hInstAs16 );
DC_DATA     ( UINT,         g_cProcesses );
DC_DATA     ( HTASK,        g_hCoreTask );

DC_DATA     ( HINSTANCE,    g_hInstKrnl16 );
DC_DATA     ( HMODULE,      g_hModKrnl16 );
DC_DATA     ( DWORD,        g_hInstKrnl32 );
DC_DATA     ( HINSTANCE,    g_hInstKrnl32MappedTo16 );
DC_DATA     ( ANSITOUNIPROC,    g_lpfnAnsiToUni );

DC_DATA     ( HINSTANCE,    g_hInstGdi16 );
DC_DATA     ( HMODULE,      g_hModGdi16 );
DC_DATA     ( DWORD,        g_hInstGdi32 );
DC_DATA     ( REALPATBLTPROC,   g_lpfnRealPatBlt );
DC_DATA     ( EXTTEXTOUTWPROC,  g_lpfnExtTextOutW );
DC_DATA     ( TEXTOUTWPROC,     g_lpfnTextOutW );
DC_DATA     ( POLYLINETOPROC,   g_lpfnPolylineTo );
DC_DATA     ( POLYPOLYLINEPROC, g_lpfnPolyPolyline );

DC_DATA     ( HINSTANCE,    g_hInstUser16 );
DC_DATA     ( HMODULE,      g_hModUser16 );
DC_DATA     ( DWORD,        g_hInstUser32 );
DC_DATA     ( GETWINDOWTHREADPROCESSIDPROC,  g_lpfnGetWindowThreadProcessId );

DC_DATA     ( HDC,          g_osiScreenDC );
DC_DATA     ( HDC,          g_osiMemoryDC );
DC_DATA     ( HBITMAP,      g_osiMemoryBMP );
DC_DATA     ( HBITMAP,      g_osiMemoryOld );
DC_DATA     ( RECT,         g_osiScreenRect );
DC_DATA     ( UINT,         g_osiScreenBitsPlane );
DC_DATA     ( UINT,         g_osiScreenPlanes );
DC_DATA     ( UINT,         g_osiScreenBPP );
DC_DATA     ( DWORD,        g_osiScreenRedMask );
DC_DATA     ( DWORD,        g_osiScreenGreenMask );
DC_DATA     ( DWORD,        g_osiScreenBlueMask );

DC_DATA     ( BITMAPINFO_ours,  g_osiScreenBMI );
DC_DATA     ( HWND,         g_osiDesktopWindow );


//
// Shared Memory
//
DC_DATA     ( LPSHM_SHARED_MEMORY,  g_asSharedMemory );
DC_DATA_ARRAY ( LPOA_SHARED_DATA,   g_poaData,  2 );


//
// Window/Task tracking
//
DC_DATA ( HWND,             g_asMainWindow );
DC_DATA ( BOOL,             g_hetDDDesktopIsShared );


//
// Cursor Manager
//
DC_DATA ( LPCURSORSHAPE,    g_cmMungedCursor );     // Holds <= color cursor bits
DC_DATA ( LPBYTE,           g_cmXformMono );        // 2x height, mono
DC_DATA ( LPBYTE,           g_cmXformColor );       // 2x height, color
DC_DATA ( BOOL,             g_cmXformOn );
DC_DATA ( BOOL,             g_cmCursorHidden );
DC_DATA ( DWORD,            g_cmNextCursorStamp );
DC_DATA ( UINT,             g_cxCursor );
DC_DATA ( UINT,             g_cyCursor );
DC_DATA ( UINT,             g_cmMonoByteSize );
DC_DATA ( UINT,             g_cmColorByteSize );
DC_DATA ( SETCURSORPROC,    g_lpfnSetCursor );
DC_DATA ( FN_PATCH,         g_cmSetCursorPatch );

extern PALETTEENTRY CODESEG g_osiVgaPalette[16];



//
// Order Accumulator
//

DC_DATA ( UINT,         g_oaFlow );
DC_DATA_VAL ( BOOL,     g_oaPurgeAllowed,            TRUE);



//
// Order Encoder
//
DC_DATA ( BOOL,             g_oeViewers );

DC_DATA ( UINT,             g_oeEnterCount );

DC_DATA ( BOOL,             g_oeSendOrders );

DC_DATA ( BOOL,             g_oeTextEnabled );
DC_DATA_ARRAY ( BYTE,       g_oeOrderSupported,   ORD_NUM_INTERNAL_ORDERS );

DC_DATA ( HPALETTE,         g_oeStockPalette );

DC_DATA ( TSHR_RECT32,      g_oeLastETORect );

//
// Only valid within a single DDI call, saves stack space to use globals
// NOTE:
// We need at most 2 pointers to DCs, the source and dest.  So we have
// two allocated selectors.
//
DC_DATA ( OESTATE,          g_oeState );
DC_DATA ( UINT,             g_oeSelDst );
DC_DATA ( UINT,             g_oeSelSrc );


DC_DATA ( BOOL,             g_oeBaselineTextEnabled );
DC_DATA ( UINT,             g_oeFontCaps );


//
// Local font matching data - this is passed from the share core
// NOTE:  it's so large that we allocate it in 16-bit code
//
DC_DATA ( LPLOCALFONT,      g_poeLocalFonts );
DC_DATA_ARRAY( WORD,        g_oeLocalFontIndex, FH_LOCAL_INDEX_SIZE );
DC_DATA ( UINT,             g_oeNumFonts );

DC_DATA ( FH_CACHE,         g_oeFhLast );
DC_DATA_ARRAY ( char,       g_oeAnsiString, ORD_MAX_STRING_LEN_WITHOUT_DELTAS+1 );
DC_DATA_ARRAY ( WCHAR,      g_oeTempString, ORD_MAX_STRING_LEN_WITHOUT_DELTAS+1 );


DC_DATA_ARRAY ( FN_PATCH,   g_oeDDPatches, DDI_MAX );

DC_DATA ( FN_PATCH,         g_oeDisplaySettingsPatch );
DC_DATA ( FN_PATCH,         g_oeDisplaySettingsExPatch );
DC_DATA ( CDSEXPROC,        g_lpfnCDSEx );


//
// Bounds Accumulation
//

DC_DATA ( UINT,             g_baFirstRect );
DC_DATA ( UINT,             g_baLastRect );
DC_DATA ( UINT,             g_baRectsUsed );

DC_DATA_ARRAY ( DD_BOUNDS,  g_baBounds,   BA_NUM_RECTS+1);

//
// A local copy of the bounding rectangles which the share core is
// currently processing.  These are used when accumulating orders which
// rely on the contents of the destination.
//
DC_DATA         ( UINT,    g_baNumSpoilingRects);
DC_DATA_ARRAY   ( RECT,    g_baSpoilingRects,    BA_NUM_RECTS);

//
// Is the spoiling of existing orders when adding screen data allowed at
// the moment, or temporarily disabled ?  To do the spoiling, both
// baSpoilByNewSDA and baSpoilByNewSDAEnabled must be TRUE.
//
DC_DATA_VAL ( BOOL,         g_baSpoilByNewSDAEnabled,     TRUE);



//
// Save Screenbits Interceptor
//

//
// Remote status for SSB
//
DC_DATA ( REMOTE_SSB_STATE,  g_ssiRemoteSSBState );

//
// Local status for SSB
//
DC_DATA ( LOCAL_SSB_STATE,  g_ssiLocalSSBState );

//
// Current max for save screen bitmap size
//
DC_DATA ( DWORD,            g_ssiSaveBitmapSize );

DC_DATA ( SAVEBITSPROC,     g_lpfnSaveBits );

DC_DATA ( FN_PATCH,         g_ssiSaveBitsPatch );

DC_DATA ( HBITMAP,          g_ssiLastSpbBitmap );



//
// IM stuff
//

//
// NOTE:
// Since we smart pagelock our data segment anyway, we don't need to
// put g_imSharedData into a separate block of memory.
//
DC_DATA ( IM_SHARED_DATA,   g_imSharedData );
DC_DATA ( IM_WIN95_DATA,    g_imWin95Data );
DC_DATA_ARRAY ( FN_PATCH,   g_imPatches, IM_MAX );
DC_DATA ( int,              g_imMouseDowns );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\as16\het.c ===
//
// HET.C
// Hosted Entity Tracker
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>



/////
//
// DISPLAY DRIVER functionality
//
/////

//
// HET_DDInit()
//
BOOL HET_DDInit(void)
{
    return(TRUE);
}


//
// HET_DDTerm()
//
void HET_DDTerm(void)
{
    DebugEntry(HET_DDTerm);

    //
    // Make sure we stop hosting
    //
    g_hetDDDesktopIsShared = FALSE;

    DebugExitVOID(HET_DDTerm);
}



//
// HET_DDProcessRequest()
// Handles HET escapes
//

BOOL  HET_DDProcessRequest
(
    UINT    fnEscape,
    LPOSI_ESCAPE_HEADER pResult,
    DWORD   cbResult
)
{
    BOOL    rc = TRUE;

    DebugEntry(HET_DDProcessRequest);

    switch (fnEscape)
    {
        //
        // NOTE:
        // Unlike NT, we have no need of keeping a duplicated list of
        // shared windows.  We can make window calls directly, and can use
        // GetProp to find out.
        //
        case HET_ESC_UNSHARE_ALL:
        {
            // Nothing to do
        }
        break;

        case HET_ESC_SHARE_DESKTOP:
        {
            ASSERT(!g_hetDDDesktopIsShared);
            g_hetDDDesktopIsShared = TRUE;
        }
        break;

        case HET_ESC_UNSHARE_DESKTOP:
        {
            ASSERT(g_hetDDDesktopIsShared);
            g_hetDDDesktopIsShared = FALSE;
            HETDDViewing(FALSE);
        }
        break;

        case HET_ESC_VIEWER:
        {
            HETDDViewing(((LPHET_VIEWER)pResult)->viewersPresent != 0);
            break;
        }

        default:
        {
            ERROR_OUT(("Unrecognized HET escape"));
            rc = FALSE;
        }
        break;
    }

    DebugExitBOOL(HET_DDProcessRequest, rc);
    return(rc);
}




//
// HETDDViewing()
//
// Called when viewing of our shared apps starts/stops.  Naturally, no longer
// sharing anything stops viewing also.
//
void HETDDViewing(BOOL fViewers)
{
    DebugEntry(HETDDViewing);

    if (g_oeViewers != fViewers)
    {
        g_oeViewers = fViewers;
        OE_DDViewing(fViewers);
    }

    DebugExitVOID(HETDDViewing);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\as16\cm.c ===
//
// CM.C
// Cursor Manager
//
// Copyright(c) 1997-
//

#include <as16.h>


//
// CM_DDProcessRequest()
// Handles CM escapes
//

BOOL CM_DDProcessRequest
(
    UINT    fnEscape,
    LPOSI_ESCAPE_HEADER     pResult,
    DWORD   cbResult
)
{
    BOOL        rc;

    DebugEntry(CM_DDProcessRequest);

    switch (fnEscape)
    {
        case CM_ESC_XFORM:
        {
            ASSERT(cbResult == sizeof(CM_DRV_XFORM_INFO));
            ((LPCM_DRV_XFORM_INFO)pResult)->result =
                    CMDDSetTransform((LPCM_DRV_XFORM_INFO)pResult);
            rc = TRUE;
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognized CM_ escape"));
            rc = FALSE;
        }
        break;
    }

    DebugExitBOOL(CM_DDProcessRequest, rc);
    return(rc);
}



//
// CM_DDInit()
// 
BOOL CM_DDInit(HDC hdcScreen)
{
    BOOL    rc = FALSE;
    HGLOBAL hg;
    LPBYTE  lpfnPatch;

    DebugEntry(CM_DDInit);

    //
    // Get the size of the cursor
    //
    g_cxCursor = GetSystemMetrics(SM_CXCURSOR);
    g_cyCursor = GetSystemMetrics(SM_CYCURSOR);

    //
    // Create our work bit buffers
    //

    g_cmMonoByteSize = BitmapSize(g_cxCursor, g_cyCursor, 1, 1);
    g_cmColorByteSize = BitmapSize(g_cxCursor, g_cyCursor,
            g_osiScreenPlanes, g_osiScreenBitsPlane);

    // This will hold a color cursor, mono is always <= to this
    hg = GlobalAlloc(GMEM_FIXED | GMEM_SHARE, sizeof(CURSORSHAPE) +
        g_cmMonoByteSize + g_cmColorByteSize);
    g_cmMungedCursor = MAKELP(hg, 0);

    // Always alloc mono Xform
    hg = GlobalAlloc(GMEM_FIXED | GMEM_SHARE, 2 * g_cmMonoByteSize);
    g_cmXformMono = MAKELP(hg, 0);

    if (!SELECTOROF(g_cmMungedCursor) || !SELECTOROF(g_cmXformMono))
    {
        ERROR_OUT(("Couldn't allocate cursor xform buffers"));
        DC_QUIT;
    }

    lpfnPatch = (LPBYTE)g_lpfnSetCursor;

    // If color cursors supported, alloc color image bits, again 2x the size
    if (GetDeviceCaps(hdcScreen, CAPS1) & C1_COLORCURSOR)
    {
        hg = GlobalAlloc(GMEM_FIXED | GMEM_SHARE, 2 * g_cmColorByteSize);
        if (!hg)
        {
            ERROR_OUT(("Couldn't allocate color cursor xform buffer"));
            DC_QUIT;
        }

        g_cmXformColor = MAKELP(hg, 0);
    }
    else
    {
        //
        // Older drivers (VGA and SUPERVGA e.g.) hook int2f and read their
        // DS from the SetCursor ddi prolog code, in many places.  Therefore,
        // if we patch over this instruction, they will blow up.  For these
        // drivers, we patch 3 bytes after the start, which leaves
        //      mov  ax, DGROUP
        // intact and is harmless.  When we call the original routine, we call
        // back to the beginning, which will set up ax again before the body
        // of the ddi code.
        //
        // NOTE:
        // We use the color cursor caps for this detection.  DRIVERVERSION
        // doesn't work, VGA et al. got restamped in Win95.  This is the 
        // most reliable way to decide if this is an older driver or not.
        //
        // NOTE 2:
        // We still want to decode this routine to see if it is of the form
        // mov ax, xxxx.  If not, patch at the front anyway, or we'll write
        // possibly into the middle of an instruction.
        //
        if (*lpfnPatch == OPCODE_MOVAX)
            lpfnPatch = lpfnPatch + 3;
    }

    if (!CreateFnPatch(lpfnPatch, DrvSetPointerShape, &g_cmSetCursorPatch, 0))
    {
        ERROR_OUT(("Couldn't get cursor routines"));
        DC_QUIT;
    }

    g_cmSetCursorPatch.fInterruptable = TRUE;

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(CM_DDInit, rc);
    return(rc);
}



//
// CM_DDTerm()
//
void CM_DDTerm(void)
{
    DebugEntry(CM_DDTerm);

    //
    // Clean up our patches
    //
    DestroyFnPatch(&g_cmSetCursorPatch);

    g_cmXformOn = FALSE;
    g_cmCursorHidden = FALSE;
        
    //
    // Free our memory blocks.
    //
    if (SELECTOROF(g_cmXformColor))
    {
        GlobalFree((HGLOBAL)SELECTOROF(g_cmXformColor));
        g_cmXformColor = NULL;
    }

    if (SELECTOROF(g_cmXformMono))
    {
        GlobalFree((HGLOBAL)SELECTOROF(g_cmXformMono));
        g_cmXformMono = NULL;
    }

    if (SELECTOROF(g_cmMungedCursor))
    {
        GlobalFree((HGLOBAL)SELECTOROF(g_cmMungedCursor));
        g_cmMungedCursor = NULL;
    }

    DebugExitVOID(CM_DDTerm);
}



//
// CMDDSetTransform()
//
BOOL CMDDSetTransform(LPCM_DRV_XFORM_INFO pResult)
{
    BOOL    rc = FALSE;
    LPBYTE  lpAND;

    DebugEntry(CMDDSetTransform);

    //
    // Turn off transform
    //
    // Do this first--that way if an interrupt comes in, we won't apply
    // some half-copied xform to the cursor.  This can only happen for
    // an anicur.  We jiggle the cursor below, which will reset the
    // xform if necessary.
    //
    g_cmXformOn = FALSE;

    //
    // If AND bitmap is NULL, we are turning the transform off.  We also
    // do this if we can't get a 16:16 pointer to this memory
    //
    if (pResult->pANDMask == 0)
    {
        TRACE_OUT(("Clear transform"));
        rc = TRUE;
    }
    else
    {
        ASSERT(pResult->width == g_cxCursor);
        ASSERT(pResult->height == g_cyCursor);
        
        lpAND = MapLS(pResult->pANDMask);
        if (!SELECTOROF(lpAND))
        {
            ERROR_OUT(("Couldn't get AND mask pointer"));
            DC_QUIT;
        }

        hmemcpy(g_cmXformMono, lpAND, 2 * g_cmMonoByteSize);
        UnMapLS(lpAND);

        if (SELECTOROF(g_cmXformColor))
        {
            HBITMAP hbmMono = NULL;
            HBITMAP hbmMonoOld;
            HBITMAP hbmColorOld;
            HBITMAP hbmColor = NULL;
            HDC     hdcMono = NULL;
            HDC     hdcColor = NULL;

            //
            // Get color expanded version of the mask & image.
            // We do this blting the mono bitmap into a color one, then
            // getting the color bits.
            //
            hdcColor = CreateCompatibleDC(g_osiScreenDC);
            hbmColor = CreateCompatibleBitmap(g_osiScreenDC, g_cxCursor,
                2*g_cyCursor);

            if (!hdcColor || !hbmColor)
                goto ColorError;

            hbmColorOld = SelectBitmap(hdcColor, hbmColor);

            hdcMono = CreateCompatibleDC(hdcColor);
            hbmMono = CreateBitmap(g_cxCursor, 2*g_cyCursor, 1, 1,
                g_cmXformMono);
            hbmMonoOld = SelectBitmap(hdcMono, hbmMono);

            if (!hdcMono || !hbmMono)
                goto ColorError;

            //
            // The defaults should be black & white for the text/back
            // colors, since we just created these DCs
            //
            ASSERT(GetBkColor(hdcColor) == RGB(255, 255, 255));
            ASSERT(GetTextColor(hdcColor) == RGB(0, 0, 0));

            ASSERT(GetBkColor(hdcMono) == RGB(255, 255, 255));
            ASSERT(GetTextColor(hdcMono) == RGB(0, 0, 0));

            BitBlt(hdcColor, 0, 0, g_cxCursor, 2*g_cyCursor, hdcMono,
                0, 0, SRCCOPY);

            GetBitmapBits(hbmColor, 2*g_cmColorByteSize, g_cmXformColor);

            g_cmXformOn = TRUE;

ColorError:
            if (hbmColor)
            {
                SelectBitmap(hdcColor, hbmColorOld);
                DeleteBitmap(hbmColor);
            }
            if (hdcColor)
            {
                DeleteDC(hdcColor);
            }

            if (hbmMono)
            {
                SelectBitmap(hdcMono, hbmMonoOld);
                DeleteBitmap(hbmMono);
            }
            if (hdcMono)
            {
                DeleteDC(hdcMono);
            }
        }
        else
            g_cmXformOn = TRUE;

        rc = (g_cmXformOn != 0);
    }


DC_EXIT_POINT:
    //
    // Jiggle the cursor to get it to redraw with the new transform
    //
    CMDDJiggleCursor();

    DebugExitBOOL(CMDDSetTransform, rc);
    return(rc);
}



//
// CM_DDViewing()
//
// We install our hooks & jiggle the cursor, if starting.
// We remove our hooks, if stopping.
//
void CM_DDViewing(BOOL fViewers)
{
    DebugEntry(CM_DDViewing);

    //
    // SetCursor() can be called at interrupt time for animated cursors.
    // Fortunately, we don't have to really pagelock the data segments
    // we touch.  Animated cursors aren't allowed when you page through DOS.
    // When paging in protected mode, the guts of Windows can handle
    // page-ins during 16-bit ring3 reflected interrupts.  Therfore
    // GlobalFix() works just fine.
    //
    if (fViewers)
    {
        // Do this BEFORE enabling patch
        GlobalFix(g_hInstAs16);
        GlobalFix((HGLOBAL)SELECTOROF((LPBYTE)DrvSetPointerShape));

        GlobalFix((HGLOBAL)SELECTOROF(g_cmMungedCursor));
        GlobalFix((HGLOBAL)SELECTOROF(g_cmXformMono));

        if (SELECTOROF(g_cmXformColor))
            GlobalFix((HGLOBAL)SELECTOROF(g_cmXformColor));

    }

    //
    // This enable will disable interrupts while copying bytes back and
    // forth.  Animated cursors draw at interrupt time, and one could
    // come in while we're in the middle of copying the patch.  The code
    // would blow up on half-copied instructions.
    //
    EnableFnPatch(&g_cmSetCursorPatch, (fViewers ? PATCH_ACTIVATE : PATCH_DEACTIVATE));

    if (!fViewers)
    {
        // Do this AFTER disabling patch
        if (SELECTOROF(g_cmXformColor))
            GlobalUnfix((HGLOBAL)SELECTOROF(g_cmXformColor));
        
        GlobalUnfix((HGLOBAL)SELECTOROF(g_cmXformMono));
        GlobalUnfix((HGLOBAL)SELECTOROF(g_cmMungedCursor));

        GlobalUnfix((HGLOBAL)SELECTOROF((LPBYTE)DrvSetPointerShape));
        GlobalUnfix(g_hInstAs16);
    }
    else
    {
        //
        // Jiggle the cursor to get the current image
        //
        CMDDJiggleCursor();
    }

    DebugExitVOID(CM_DDViewing);
}


//
// CMDDJiggleCursor()
// This causes the cursor to redraw with/without our tag.
//
void CMDDJiggleCursor(void)
{
    DebugEntry(CMDDJiggleCursor);

    if (g_asSharedMemory)
    {
        //
        // Toggle full screen via WinOldAppHackOMatic().  This is the most
        // innocuous way I can come up with to force USER to refresh the
        // cursor with all the right parameters.
        //
        // If a full screen dos box is currently up, we don't need to do
        // anything--the user doesn't have a cursor, and the cursor will
        // refesh when we go back to windows mode anyway.
        //
        // Sometimes 16-bit code is beautiful!   We own the win16lock,
        // so the two function calls below are atomic, and we know USER
        // won't do any calculation that would check the fullscreen state
        // while we're in the middle.
        //
        if (!g_asSharedMemory->fullScreen)
        {
            WinOldAppHackoMatic(WOAHACK_LOSINGDISPLAYFOCUS);
            WinOldAppHackoMatic(WOAHACK_GAININGDISPLAYFOCUS);
        }
    }

    DebugExitVOID(CMDDJiggleCursor);
}



//
// DrvSetPointerShape()
// This is the intercept for the display driver's SetCursor routine.
// 
// NOTE THAT THIS CAN BE CALLED AT INTERRUPT TIME FOR ANIMATED CURSORS.
//
// While we can access our data (interrupt calls only happen when NOT
// paging thru DOS, and protected mode paging can take pagefaults in ring3
// reflected interrupt code), we can not call kernel routines that might
// access non-fixed things.
// 
// THIS MEANS NO DEBUG TRACING AT ALL IN THIS FUNCTION.  AND NO CALLS TO
// HMEMCPY.
//
// We must preserve EDX.  Memphis display drivers get passed an instance
// value from USER in this register.  We only trash DX, so that's all we
// need to save.
//
#pragma optimize("gle", off)
BOOL WINAPI DrvSetPointerShape(LPCURSORSHAPE lpcur)
{
    UINT    dxSave;
    BOOL    rc;
    UINT    i;
    LPDWORD lpDst;
    LPDWORD lpSrc;
    LPCURSORSHAPE   lpcurNew;
    LPCM_FAST_DATA  lpcmShared;

    _asm    mov dxSave, dx

    //
    // Call the original entry point in the driver with the xformed bits
    // NOTE:  
    // For VGA/SUPERVGA et al, we patch at SetCursor+3 to leave the
    //      move ax, dgroup instruction intact.  We call through the org
    //      routine to get ax reset up.
    //

    EnableFnPatch(&g_cmSetCursorPatch, PATCH_DISABLE);

    lpcurNew = XformCursorBits(lpcur);

    _asm    mov dx, dxSave
    rc  = g_lpfnSetCursor(lpcurNew);

    EnableFnPatch(&g_cmSetCursorPatch, PATCH_ENABLE);

    //
    // Did it succeed?
    //
    if (!rc)
        DC_QUIT;


    //
    // Hiding the cursor is done on Win95 by calling with NULL
    //
    if (!SELECTOROF(lpcur))
    {
        if (!g_cmCursorHidden)
        {
            CM_SHM_START_WRITING;
            g_asSharedMemory->cmCursorHidden = TRUE;
            CM_SHM_STOP_WRITING;

            g_cmCursorHidden = TRUE;
        }
    }
    else
    {
        // Set the bits first, THEN show the cursor to avoid flicker
        lpcmShared = CM_SHM_START_WRITING;

        //
        // NOTE:  if this isn't the right size or a recognizable color
        // format, set a NULL cursor.  This should never happen, but Win95's
        // own display driver has checks for it, and if it does we'll blue
        // screen if we do nothing.
        //
        if ((lpcur->cx != g_cxCursor)   ||
            (lpcur->cy != g_cyCursor)   ||
            ((lpcur->BitsPixel != 1) && (lpcur->BitsPixel != g_osiScreenBitsPlane)) ||
            ((lpcur->Planes != 1) && (lpcur->Planes != g_osiScreenPlanes)))
        {
            // Set 'null' cursor
            lpcmShared->cmCursorShapeData.hdr.cPlanes = 0xFF;
            lpcmShared->cmCursorShapeData.hdr.cBitsPerPel = 0xFF;
            goto CursorDone;
        }

        lpcmShared->cmCursorShapeData.hdr.ptHotSpot.x = lpcur->xHotSpot;
        lpcmShared->cmCursorShapeData.hdr.ptHotSpot.y = lpcur->yHotSpot;
        lpcmShared->cmCursorShapeData.hdr.cx          = lpcur->cx;
        lpcmShared->cmCursorShapeData.hdr.cy          = lpcur->cy;
        lpcmShared->cmCursorShapeData.hdr.cPlanes     = lpcur->Planes;
        lpcmShared->cmCursorShapeData.hdr.cBitsPerPel = lpcur->BitsPixel;
        lpcmShared->cmCursorShapeData.hdr.cbRowWidth  = lpcur->cbWidth;

        //
        // Can't call hmemcpy at interrupt time.  So we copy a DWORD
        // at a time.
        //
        // LAURABU:  NM 2.0 did this too.  But maybe we should right this
        // in ASM for speed...
        //
        i = BitmapSize(lpcur->cx, lpcur->cy, 1, 1) +
            BitmapSize(lpcur->cx, lpcur->cy, lpcur->Planes, lpcur->BitsPixel);
        i >>= 2;

        lpDst = (LPDWORD)lpcmShared->cmCursorShapeData.data;
        lpSrc = (LPDWORD)(lpcur+1);

        while (i-- > 0)
        {
            *(lpDst++) = *(lpSrc++);
        }

        if ((lpcur->Planes == 1) && (lpcur->BitsPixel == 1))
        {
            //
            // Mono color table
            //
            lpcmShared->colorTable[0].peRed         = 0;
            lpcmShared->colorTable[0].peGreen       = 0;
            lpcmShared->colorTable[0].peBlue        = 0;
            lpcmShared->colorTable[0].peFlags       = 0;

            lpcmShared->colorTable[1].peRed         = 255;
            lpcmShared->colorTable[1].peGreen       = 255;
            lpcmShared->colorTable[1].peBlue        = 255;
            lpcmShared->colorTable[1].peFlags       = 0;
        }
        else if (g_osiScreenBPP <= 8)
        {
            UINT    iBase;

            //
            // Color cursors for this depth only use VGA colors.  So fill
            // in LOW 8 and HIGH 8, skip rest.  There will be garbage in
            // the middle 256-16 colors for 256 color cursors, but none
            // of those RGBs are referenced in the bitmap data.
            //
            for (i = 0; i < 8; i++)
            {
                lpcmShared->colorTable[i]  =   g_osiVgaPalette[i];
            }

            if (g_osiScreenBPP == 4)
                iBase = 8;
            else
                iBase = 0xF8;

            for (i = 0; i < 8; i++)
            {
                lpcmShared->colorTable[i + iBase] = g_osiVgaPalette[i + 8];
            }
        }
        else
        {
            lpcmShared->bitmasks[0] = g_osiScreenRedMask;
            lpcmShared->bitmasks[1] = g_osiScreenGreenMask;
            lpcmShared->bitmasks[2] = g_osiScreenBlueMask;
        }

CursorDone:
        lpcmShared->cmCursorStamp   = g_cmNextCursorStamp++;

        if (g_cmCursorHidden)
        {
            g_asSharedMemory->cmCursorHidden = FALSE;
            g_cmCursorHidden = FALSE;
        }

        CM_SHM_STOP_WRITING;
    }

DC_EXIT_POINT:
    return(rc);
}
#pragma optimize("", on)



//
// XformCursorBits()
// This routine copies and transforms the cursor bits at the same time.
// We return either the same thing passed in (if we can't xform it) or
// our temp buffer g_cmXformMono.
//
LPCURSORSHAPE XformCursorBits
(
    LPCURSORSHAPE  lpOrg
)
{
    LPCURSORSHAPE   lpResult;
    LPDWORD lpDst;
    LPDWORD lpSrc;
    LPDWORD lpXform;
    UINT    cDwords;
    BOOL    fColor;

    lpResult = lpOrg;

    //
    // If no xform is on, bail out
    //
    if (!g_cmXformOn || !SELECTOROF(lpOrg))
        DC_QUIT;

    //
    // If the cursor isn't the right size, forget it.
    //
    if ((lpOrg->cx != g_cxCursor) || (lpOrg->cy != g_cyCursor))
        DC_QUIT;

    //
    // If the cursor isn't monochrome or the color depth of the display,
    // forget it.
    //
    if ((lpOrg->Planes == 1) && (lpOrg->BitsPixel == 1))
    {
        // We handle this
        fColor = FALSE;
    }
    else if ((lpOrg->Planes == g_osiScreenPlanes) && (lpOrg->BitsPixel == g_osiScreenBitsPlane))
    {
        // We handle this
        fColor = TRUE;
    }
    else
    {
        // Unrecognized
        DC_QUIT;
    }

    //
    // OK, we can handle this
    //
    lpResult = g_cmMungedCursor;

    //
    // COPY THE HEADER
    //
    *lpResult = *lpOrg;

    //
    // FIRST:
    // AND the two masks together (both are mono)
    //

    lpDst   = (LPDWORD)(lpResult+1);
    lpSrc   = (LPDWORD)(lpOrg+1);
    lpXform = (LPDWORD)g_cmXformMono;

    cDwords = g_cmMonoByteSize >> 2;
    while (cDwords-- > 0)
    {
        *lpDst = (*lpSrc) & (*lpXform);

        lpDst++;
        lpSrc++;
        lpXform++;
    }

    //
    // SECOND:
    // AND the mask of the xform with the image of the cursor.  If the
    // cursor is color, use the color-expanded mask of the xform
    //
    if (fColor)
    {
        lpXform = (LPDWORD)g_cmXformColor;
        cDwords = g_cmColorByteSize;
    }
    else
    {
        lpXform = (LPDWORD)g_cmXformMono;
        cDwords = g_cmMonoByteSize;
    }
    cDwords >>= 2;

    while (cDwords-- > 0)
    {
        *lpDst = (*lpSrc) & (*lpXform);

        lpDst++;
        lpSrc++;
        lpXform++;
    }

    //
    // LAST:
    // XOR the image of the xform with the image of the cursor
    //
    if (fColor)
    {
        lpXform = (LPDWORD)(g_cmXformColor + g_cmColorByteSize);
        cDwords = g_cmColorByteSize;
    }
    else
    {
        lpXform = (LPDWORD)(g_cmXformMono + g_cmMonoByteSize);
        cDwords = g_cmMonoByteSize;
    }
    cDwords >>= 2;

    lpDst = (LPDWORD)((LPBYTE)(lpResult+1) + g_cmMonoByteSize);

    while (cDwords-- > 0)
    {
        *lpDst ^= (*lpXform);

        lpDst++;
        lpXform++;
    }

DC_EXIT_POINT:
    return(lpResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\as16\as16.h ===
// --------------------------------------------------------------------------
//
//  AS16.H
//  
//  Defines for 16-bit patching dll, the vestigial pieces of the dclwin95
//  code we still need in the 32-bit port.
//
//  NOTE ON VARIABLE NAMING CONVENTION:
//      c_ is codeseg   (constant)
//      s_ is local     (writeable, static to file)
//      g_ is global    (writeable, accessed by any file)
//
// --------------------------------------------------------------------------
#ifndef _H_AS16
#define _H_AS16


#define DLL_PROCESS_DETACH      0
#define DLL_PROCESS_ATTACH      1

#define FAR_NULL                ((void FAR*)0L)

#define CODESEG                 _based(_segname("_CODE"))

#define DWORD_PTR               DWORD
#define LONG_PTR                LONG
#define UINT_PTR                DWORD
#define PVOID                   LPVOID


//
// SYSTEM & APP SHARING HEADERS
//
#include <dcg.h>
#include <ut.h>
#include <dcs.h>
#include <osi.h>
#include <shm.h>
#include <sbc.h>
#include <oe.h>
#include <ssi.h>
#include <host.h>
#include <im.h>
#include <usr.h>
#include <asthk.h>


//
// WINDOWS FUNCTIONS
//

int MyStrcmp(LPCSTR lp1, LPCSTR lp2);


/////////////////////////////////////////////////////////////////////////////
// KERNEL
/////////////////////////////////////////////////////////////////////////////


// Pointer mapping 16<->32
LPVOID  WINAPI MapSL(LPVOID lp16BitPtr);
LPVOID  WINAPI MapLS(LPVOID lp32BitPtr);
void    WINAPI UnMapLS(LPVOID lp16BitMappedPtr);
DWORD   WINAPI GetModuleHandle32(LPSTR);
DWORD   WINAPI GetProcAddress32(DWORD, LPSTR);
HANDLE  WINAPI GetExePtr(HANDLE);

HINSTANCE  WINAPI MapInstance32(DWORD);      // Our wrapper around MaphInstLS

// GetCodeInfo() flags
#define NSTYPE      0x0007
#define NSCODE      0x0000
#define NSDATA      0x0001
#define NSITER      0x0008
#define NSMOVE      0x0010
#define NSSHARE     0x0020
#define HSPRELOAD   0x0040
#define NSERONLY    0x0080
#define NSRELOC     0x0100
#define NSDPL       0x0C00
#define NSDISCARD   0x1000
#define NS286DOS    0xCE06
#define NSALLOCED   0x0002
#define NSLOADED    0x0004
#define NSCOMPR     0x0200
#define NSUSESDATA  0x0400
#define NSKCACHED   0x0800
#define NSUSE32     0x2000
#define NSWINCODE   0x4000
#define NSINROM     0x8000

// Process info
#define GPD_PPI                 0
#define GPD_FLAGS               -4
#define GPD_PARENT              -8
#define GPD_STARTF_FLAGS        -12
#define GPD_STARTF_POS          -16
#define GPD_STARTF_SIZE         -20
#define GPD_STARTF_SHOWCMD      -24
#define GPD_STARTF_HOTKEY       -28
#define GPD_STARTF_SHELLDATA    -32
#define GPD_CURR_PROCESS_ID     -36
#define GPD_CURR_THREAD_ID      -40
#define GPD_EXP_WINVER          -44
#define	GPD_EXP_WINVER          -44
#define GPD_HINST               -48
#define GPD_HUTSTATE		    -52
#define GPD_COMPATFLAGS         -56


// 
// GPD_FLAGS
//
#define GPF_DEBUG_PROCESS       0x00000001
#define GPF_WIN16_PROCESS       0x00000008
#define GPF_DOS_PROCESS         0x00000010
#define GPF_CONSOLE_PROCESS     0x00000020
#define GPF_SERVICE_PROCESS     0x00000100

//
// GPD_STARTF_FLAGS
//
#define STARTF_USESHOWWINDOW    0x00000001
#define STARTF_USESIZE          0x00000002
#define STARTF_USEPOSITION      0x00000004
#define STARTF_FORCEONFEEDBACK  0x00000040
#define STARTF_FORCEOFFFEEDBACK 0x00000080
#define STARTF_USEHOTKEY        0x00000200  
#define STARTF_HASSHELLDATA     0x00000400  

DWORD WINAPI GetProcessDword(DWORD idProcess, int iIndex);
BOOL  WINAPI SetProcessDword(DWORD idProcess, int iIndex, DWORD dwValue);


void WINAPI _EnterWin16Lock(void);
void WINAPI _LeaveWin16Lock(void);


//
// Special krnl386 routine to map unicode to ansi.  We only need thunk for
// converting back.
//
int   WINAPI UniToAnsi(LPWSTR lpwszSrc, LPSTR lpszDst, int cch);

//
// kernel32.dll routine to map back to unicode from ansi.
//
typedef LONG (WINAPI * ANSITOUNIPROC)(DWORD codePage, DWORD dwFlags,
    LPCSTR lpMb, LONG cchMb, LPWSTR lpUni, LONG cchUni);

int AnsiToUni(LPSTR lpMb, int cchMb, LPWSTR lpUni, int cchUni);



//
// dwMask is bitfields, where 1 means that parameter should be thunked as 
// a pointer.  0x00000001 means the 1st param, 0x00000002 means the 2nd, 
// and so on.
//
// The caller is responsible for making sure that the 32-bit address is
// valid to call.
//
DWORD FAR _cdecl CallProcEx32W(DWORD numParams, DWORD dwMask, DWORD lpfn32, ...);


/////////////////////////////////////////////////////////////////////////////
// GDI
/////////////////////////////////////////////////////////////////////////////

//
// Useful DIB def
//
typedef struct tagDIB4
{
    BITMAPINFOHEADER    bi;
    DWORD               ct[16];
} DIB4;


BOOL    WINAPI MakeObjectPrivate(HANDLE, BOOL);

UINT    WINAPI CreateSpb(HDC, int, int);
BOOL    WINAPI SysDeleteObject(HANDLE);
HRGN    WINAPI GetClipRgn(HDC);

UINT    WINAPI Death(HDC);
UINT    WINAPI Resurrection(HDC, DWORD, DWORD, DWORD);
void    WINAPI RealizeDefaultPalette(HDC);
DWORD   WINAPI GDIRealizePalette(HDC);


extern DWORD FAR FT_GdiFThkThkConnectionData[];

typedef BOOL (WINAPI* REALPATBLTPROC)(HDC, int, int, int, int, DWORD);
typedef BOOL (WINAPI* TEXTOUTWPROC)(HDC, int, int, LPCWSTR, int);
typedef BOOL (WINAPI* EXTTEXTOUTWPROC)(HDC, int, int, UINT, LPCRECT, LPCWSTR, UINT, LPINT);
typedef BOOL (WINAPI* POLYLINETOPROC)(HDC, LPCPOINT, int);
typedef BOOL (WINAPI* POLYPOLYLINEPROC)(DWORD, HDC, LPCPOINT, LPINT, int);


typedef BOOL (WINAPI* SETCURSORPROC)(LPCURSORSHAPE lpcurs);
typedef BOOL (WINAPI* SAVEBITSPROC)(LPRECT lprcSave, UINT uCmd);


/////////////////////////////////////////////////////////////////////////////
// USER
/////////////////////////////////////////////////////////////////////////////


#define WOAHACK_CHECKALTKEYSTATE        1
#define WOAHACK_IGNOREALTKEYDOWN        2
#define WOAHACK_DISABLEREPAINTSCREEN    3
#define WOAHACK_LOSINGDISPLAYFOCUS      4
#define WOAHACK_GAININGDISPLAYFOCUS     5
#define WOAHACK_IAMAWINOLDAPPSORTOFGUY  6
#define WOAHACK_SCREENSAVER             7


BOOL  WINAPI RealGetCursorPos(LPPOINT);
void  WINAPI PostPostedMessages(void);
void  WINAPI DispatchInput(void);
LONG  WINAPI WinOldAppHackoMatic(LONG flags);

typedef DWORD (WINAPI* GETWINDOWTHREADPROCESSIDPROC)(HWND, LPDWORD);
typedef LONG  (WINAPI* CDSEXPROC)(LPCSTR, LPDEVMODE, HWND, DWORD, LPVOID);

typedef struct tagCWPSTRUCT
{
    LPARAM  lParam;
    WPARAM  wParam;
    UINT    message;
    HWND    hwnd;
} CWPSTRUCT, FAR* LPCWPSTRUCT;

//
// Cursor stuff
//
#define BitmapWidth(cx, bits)\
    ((((cx)*(bits) + 0x0F) & ~0x0F) >> 3)

#define BitmapSize(cx, cy, planes, bits)\
    (BitmapWidth(cx, bits) * (cy) * (planes))



extern DWORD FAR FT_UsrFThkThkConnectionData[];

void    PostMessageNoFail(HWND, UINT, WPARAM, LPARAM);


//
// Mouse_ and Keybd_ Event stuf
//

//
// For keyboard events, the app API and USER intterrupt flags are different.
// For mouse events, they are the same.
//
#define KEYEVENTF_EXTENDEDKEY   0x0001 
#define KEYEVENTF_KEYUP         0x0002

#define USERKEYEVENTF_EXTENDEDKEY   0x0100
#define USERKEYEVENTF_KEYUP         0x8000

#define MOUSEEVENTF_MOVE        0x0001
#define MOUSEEVENTF_LEFTDOWN    0x0002
#define MOUSEEVENTF_LEFTUP      0x0004
#define MOUSEEVENTF_RIGHTDOWN   0x0008
#define MOUSEEVENTF_RIGHTUP     0x0010
#define MOUSEEVENTF_MIDDLEDOWN  0x0020
#define MOUSEEVENTF_MIDDLEUP    0x0040
#define MOUSEEVENTF_WHEEL       0x0800
#define MOUSEEVENTF_ABSOLUTE    0x8000

void FAR    mouse_event(void);
void FAR    ASMMouseEvent(void);
void        CallMouseEvent(UINT regAX, UINT regBX, UINT regCX, UINT regDX,
                UINT regSI, UINT regDI);

void FAR    keybd_event(void);
void FAR    ASMKeyboardEvent(void);
void        CallKeyboardEvent(UINT regAX, UINT regBX, UINT regSI, UINT regDI);


//
// Signals
//

#define SIG_PRE_FORCE_LOCK      0x0003
#define SIG_POST_FORCE_LOCK     0x0004

BOOL WINAPI SignalProc32(DWORD dwSignal, DWORD dwID, DWORD dwFlags, WORD hTask16);

//
// PATCHING
//


#define OPCODE32_PUSH           0x68
#define OPCODE32_CALL           0xE8
#define OPCODE32_MOVCL          0xB1
#define OPCODE32_MOVCX          0xB966
#define OPCODE32_JUMP4          0xE9

#define OPCODE_MOVAX            0xB8
#define OPCODE_FARJUMP16        0xEA
#define OPCODE32_16OVERRIDE     0x66

#define CB_PATCHBYTES16         5
#define CB_PATCHBYTES32         6
#define CB_PATCHBYTESMAX        max(CB_PATCHBYTES16, CB_PATCHBYTES32)

typedef struct tagFN_PATCH
{
    BYTE    rgbOrg[CB_PATCHBYTESMAX];   // Original function bytes
    BYTE    rgbPatch[CB_PATCHBYTESMAX]; // Patch bytes

    UINT    wSegOrg;                // Original code segment (we fix it)
    UINT    fActive:1;              // Patch has been activated
    UINT    fEnabled:1;             // Patch is currently enabled
    UINT    fSharedAlias:1;         // Don't free selector on destroy
    UINT    fInterruptable:1;       // Interrupt handler
    UINT    f32Bit:1;               // 32-bit code segment
    LPBYTE  lpCodeAlias;            // We keep an alias around to quickly enable/disable
} FN_PATCH, FAR* LPFN_PATCH;


#define ENABLE_OFF      0x0000      // disable end
#define ENABLE_ON       0x0001      // enable start
#define ENABLE_FORCALL  0x8000      // disable/enable for org call
#define ENABLE_MASK     0x8001

#define PATCH_ACTIVATE      (ENABLE_ON)
#define PATCH_DEACTIVATE    (ENABLE_OFF)
#define PATCH_ENABLE        (ENABLE_ON | ENABLE_FORCALL)
#define PATCH_DISABLE       (ENABLE_OFF | ENABLE_FORCALL)


//
// NOTE:  If the function being patched can be called at interrupt time,
// the caller must make sure the jump to function can handle it.
//
// When your patch is called you:
//      * disable your patch with ENABLE_CALLOFF
//      * call the original function
//      * enable your patch with ENABLE_CALLON
//
UINT    CreateFnPatch(LPVOID lpfnToPatch, LPVOID lpfnJumpTo, LPFN_PATCH lpbPatch, UINT selCodeAlias);
void    DestroyFnPatch(LPFN_PATCH lpbPatch);
void    EnableFnPatch(LPFN_PATCH lpbPatch, UINT flags);

BOOL    GetGdi32OnlyExport(LPSTR lpszExport, UINT cbJmpOffset, FARPROC FAR* lplpfn16);
BOOL    GetUser32OnlyExport(LPSTR lpszExport, FARPROC FAR* lplpfn16);
BOOL    Get32BitOnlyExport(DWORD lpfn32, UINT cbJmpOffset, LPDWORD lpThunkTable, FARPROC FAR * lplpfn16);

LPCURSORSHAPE  XformCursorBits(LPCURSORSHAPE lpOrg);


// #define OTRACE      WARNING_OUT
#define OTRACE   TRACE_OUT

#include <globals.h>

#endif // !_H_AS16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\as16\im.c ===
//
// IM.C
// Input Manager
//
// Copyright(c) 1997-
//

#include <as16.h>



//
// IM_DDInit()
// This creates the resources we need for controlling
//
BOOL IM_DDInit(void)
{
    UINT    uSel;
    BOOL    rc = FALSE;

    DebugEntry(IM_DDInit);

    //
    // Create interrupt patches for mouse_event and keybd_event
    //
    uSel = CreateFnPatch(mouse_event, ASMMouseEvent, &g_imPatches[IM_MOUSEEVENT], 0);
    if (!uSel)
    {
        ERROR_OUT(("Couldn't find mouse_event"));
        DC_QUIT;
    }
    g_imPatches[IM_MOUSEEVENT].fInterruptable = TRUE;


    if (!CreateFnPatch(keybd_event, ASMKeyboardEvent, &g_imPatches[IM_KEYBOARDEVENT], uSel))
    {
        ERROR_OUT(("Couldn't find keybd_event"));
        DC_QUIT;
    }
    g_imPatches[IM_KEYBOARDEVENT].fInterruptable = TRUE;

    //
    // Create patch for SignalProc32 so we can find out when fault/hung
    // dialogs from KERNEL32 come up.
    //
    if (!CreateFnPatch(SignalProc32, DrvSignalProc32, &g_imPatches[IM_SIGNALPROC32], 0))
    {
        ERROR_OUT(("Couldn't patch SignalProc32"));
        DC_QUIT;
    }

    //
    // Create patches for win16lock pulsing in 16-bit app modal loops
    //
    uSel = CreateFnPatch(RealGetCursorPos, DrvGetCursorPos, &g_imPatches[IM_GETCURSORPOS], 0);
    if (!uSel)
    {
        ERROR_OUT(("Couldn't find GetCursorPos"));
        DC_QUIT;
    }

    if (!CreateFnPatch(GetAsyncKeyState, DrvGetAsyncKeyState, &g_imPatches[IM_GETASYNCKEYSTATE], 0))
    {
        ERROR_OUT(("Couldn't find GetAsyncKeyState"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(IM_DDInit, rc);
    return(rc);
}


//
// IM_DDTerm()
// This cleans up any resources we needed for controlling
//
void IM_DDTerm(void)
{
    IM_PATCH    imPatch;

    DebugEntry(IM_DDTerm);

    //
    // Force undo of hooks
    //
    OSIInstallControlledHooks16(FALSE);

    //
    // Destroy patches
    //
    for (imPatch = IM_FIRST; imPatch < IM_MAX; imPatch++)
    {
        DestroyFnPatch(&g_imPatches[imPatch]);
    }

    DebugExitVOID(IM_DDTerm);
}



//
// OSIInstallControlledHooks16()
//
// This installs/removes the input hooks we need to allow this machine to
// be controlled.  
//
BOOL WINAPI OSIInstallControlledHooks16(BOOL fEnable)
{               
    BOOL        rc = TRUE;
    IM_PATCH    imPatch;

    DebugEntry(OSIInstallControlledHooks16);

    if (fEnable)
    {
        if (!g_imWin95Data.imLowLevelHooks)
        {
            g_imWin95Data.imLowLevelHooks = TRUE;

            g_imMouseDowns = 0;

            //
            // GlobalSmartPageLock() stuff we need:
            //      * Our code segment
            //      * Our data segment
            //
            GlobalSmartPageLock((HGLOBAL)SELECTOROF((LPVOID)DrvMouseEvent));
            GlobalSmartPageLock((HGLOBAL)SELECTOROF((LPVOID)&g_imSharedData));

            //
            // Install hooks
            //
            for (imPatch = IM_FIRST; imPatch < IM_MAX; imPatch++)
            {
                EnableFnPatch(&g_imPatches[imPatch], PATCH_ACTIVATE);
            }
        }
    }
    else
    {
        if (g_imWin95Data.imLowLevelHooks)
        {
            //
            // Uninstall hooks
            //
            for (imPatch = IM_MAX; imPatch > 0; imPatch--)
            {
                EnableFnPatch(&g_imPatches[imPatch-1], PATCH_DEACTIVATE);
            }

            //
            // GlobalSmartUnPageLock() stuff we needed
            //
            GlobalSmartPageUnlock((HGLOBAL)SELECTOROF((LPVOID)&g_imSharedData));
            GlobalSmartPageUnlock((HGLOBAL)SELECTOROF((LPVOID)DrvMouseEvent));

            g_imWin95Data.imLowLevelHooks = FALSE;
        }
    }

    DebugExitBOOL(OSIInstallControlledHooks16, rc);
    return(rc);
}


#pragma optimize("gle", off)
void IMInject(BOOL fOn)
{
    if (fOn)
    {
#ifdef DEBUG
        DWORD   tmp;

        //
        // Disable interrupts then turn injection global on
        // But before we do this, we must make sure that we aren't going
        // to have to fault in a new stack page.  Since this is on a 32-bit
        // thread, we will be in trouble.
        //
        tmp = GetSelectorBase(SELECTOROF(((LPVOID)&fOn))) +
            OFFSETOF((LPVOID)&fOn);
        if ((tmp & 0xFFFFF000) != ((tmp - 0x100) & 0xFFFFF000))
        {
            ERROR_OUT(("Close to page boundary on 32-bit stack %08lx", tmp));
        }
#endif // DEBUG

        _asm    cli
        g_imWin95Data.imInjecting = TRUE;
    }
    else
    {
        //
        // Turn injection global off then enable interrupts
        //
        g_imWin95Data.imInjecting = FALSE;
        _asm    sti
    }
}
#pragma optimize("", on)


//
// OSIInjectMouseEvent16()
//
void WINAPI OSIInjectMouseEvent16
(
    UINT    flags,
    int     x,
    int     y,
    UINT    mouseData,
    DWORD   dwExtraInfo
)
{
    DebugEntry(OSIInjectMouseEvent16);

    if (flags & IM_MOUSEEVENTF_BUTTONDOWN_FLAGS)
    {
        ++g_imMouseDowns;
    }

    //
    // We disable interrupts, call the real mouse_event, reenable
    // interrupts.  That way our mouse_event patch is serialized.
    // And we can check imInjecting.
    //
    IMInject(TRUE);
    CallMouseEvent(flags, x, y, mouseData, LOWORD(dwExtraInfo), HIWORD(dwExtraInfo));
    IMInject(FALSE);

    if (flags & IM_MOUSEEVENTF_BUTTONUP_FLAGS)
    {
        --g_imMouseDowns;
        ASSERT(g_imMouseDowns >= 0);
    }

    