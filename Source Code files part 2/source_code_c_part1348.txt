t, HRESULT hReason);
	static BOOL m_fGKProhibit;
	static RASNOTIFYPROC m_pRasNotifyProc;

// IH323CallControl stuff
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR * ppvObj);
	STDMETHOD_(ULONG, AddRef());
	STDMETHOD_(ULONG, Release());
	STDMETHOD( Initialize(PORT *lpPort));
	STDMETHOD( SetMaxPPBandwidth(UINT Bandwidth));
	STDMETHOD( RegisterConnectionNotify(CNOTIFYPROC pConnectRequestHandler));
	STDMETHOD( DeregisterConnectionNotify(CNOTIFYPROC pConnectRequestHandler));
	STDMETHOD( GetNumConnections(ULONG *lp));
	STDMETHOD( GetConnectionArray(IH323Endpoint * *lplpArray, UINT uSize));
	STDMETHOD( CreateConnection(IH323Endpoint * *lplpLine, GUID PIDofProtocolType));
	STDMETHOD( SetUserDisplayName(LPWSTR lpwName));
	STDMETHODIMP CreateLocalCommChannel(ICommChannel** ppCommChan, LPGUID lpMID,
		IMediaChannel* pMediaStream);
	STDMETHODIMP SetUserAliasNames(P_H323ALIASLIST pAliases);
	STDMETHODIMP EnableGatekeeper(BOOL bEnable, PSOCKADDR_IN pGKAddr, 
	    P_H323ALIASLIST pAliases, RASNOTIFYPROC pRasNotifyProc);
};

#else	// not __cplusplus


#endif	//  __cplusplus


#endif	//#ifndef _H323CC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\h323\ictlchan.h ===
/*
 *  	File: ictlchan.h
 *
 *      Network AV conference control channel interface header file.
 *
 *		Revision History:
 *
 *		04/15/96	mikev	created
 */


#ifndef _ICTLCHAN_H
#define _ICTLCHAN_H

// Call progress states
typedef enum {
	CCS_Idle,
	CCS_Connecting,
	CCS_Accepting,
	CCS_Ringing,
	CCS_Opening,
	CCS_Closing,
	CCS_Ready,	// the diff between Ready and InUse is that going to the CCS_Ready
	// state notifies the parent object (The one that implements IConfAdvise) and
	// then the state goes immediately to CCS_InUse

	CCS_InUse,
	CCS_Listening,
	CCS_Disconnecting,
	CCS_Filtering
}CtlChanStateType;


//
// 	event status codes passed to IConfAdvise::OnControlEvent
//


#define CCEV_RINGING			0x00000001	// waiting for user to accept
#define CCEV_CONNECTED			0x00000002	// accepted.  Remote user info is available.
// undefined whether or not capabilities have been exchanged.
// undefined whether or not default channels are open at this time   Should there be a
// CCEV_MEMBER_ADD indication even on a point to point connection then?

#define CCEV_CAPABILITIES_READY		0x00000003	// capabilities are available. it's
// best to cache them now, default channels will be opened next (may already be open)
// attempts at opening ad-hoc channels can now be made
#define CCEV_CHANNEL_READY_RX		0x00000004// (or call channel->OnChannelOpen ???)
#define CCEV_CHANNEL_READY_TX		0x00000005//
#define CCEV_CHANNEL_READY_BIDI		0x00000006//

// parent obj supplies expected channels in EnumChannels().  Requests are fulfilled
// using the supplied channels if possible, and if not, the request is passed upward
#define CCEV_CHANNEL_REQUEST		0x00000007		// another channel is being requested
// what about invalid requests, like unsupported formats? reject and report the error
// upward or just pass upward and require the parent to reject?

// what's the H.323 behavior of mute?
//#define CCEV_MUTE_INDICATION 		0x00000008
//#define CCEV_UNMUTE_INDICATION	0x00000009

//#define CCEV_MEMBER_ADD    	   	0x0000000a
//#define CCEV_MEMBER_DROP			0x0000000b


#define CCEV_DISCONNECTING			0x0000000e	// opportunity to cleanup channels
#define CCEV_REMOTE_DISCONNECTING	0x0000000f	// opportunity to cleanup channels
#define CCEV_DISCONNECTED			0x00000010	//
#define CCEV_ALL_CHANNELS_READY 	0x00000011	// all *mandatory* channels are open
												// but not necessarily all channels
#define CCEV_CALL_INCOMPLETE	 	0x00000012	// busy, no answer, rejected, etc.
#define CCEV_ACCEPT_INCOMPLETE	 	0x00000013	//
#define CCEV_CALLER_ID				0x00000014


//
//  Extended information for CCEV_CALL_INCOMPLETE event.  Not all are applicable to all
//	call control implementations
//

#define CCCI_UNKNOWN		    MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x00000000)
#define CCCI_BUSY				MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x00000001)
#define CCCI_REJECTED			MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x00000002)
#define CCCI_REMOTE_ERROR		MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x00000003)
#define CCCI_LOCAL_ERROR		MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x00000004)
#define CCCI_CHANNEL_OPEN_ERROR		MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x00000005)	// all mandatory channels could not be opened.
#define CCCI_INCOMPATIBLE		MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x00000006)
#define CCCI_REMOTE_MEDIA_ERROR	MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x00000007)
#define CCCI_LOCAL_MEDIA_ERROR	MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x00000008)
#define CCCI_PROTOCOL_ERROR		MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x00000009)
#define CCCI_USE_ALTERNATE_PROTOCOL		MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x0000000a)
#define CCCI_NO_ANSWER_TIMEOUT  MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x0000000b)
#define CCCI_GK_NO_RESOURCES    MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x0000000c)
#define CCCI_SECURITY_DENIED	MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_CALLINCOMPLETE, 0x0000000d)


//
//	User information structure.  This needs to be replaced by a real property interface.
//  The only viable content at this time is a user name string. There is still some
//  volatility in the H.323 draft regarding how the user name gets propagated
typedef struct _user_info {
	DWORD dwCallerIDSize;		// total size of this structure
	LPVOID lpvCallerIDData;	// pointer to caller ID
	LPVOID lpvRemoteProtocolInfo;	// protocol specific extra info
	LPVOID lpvLocalProtocolInfo;	//	
}CTRL_USER_INFO, *LPCTRL_USER_INFO;


#ifdef __cplusplus

class IConfAdvise
{
	public:
	STDMETHOD_(ULONG,  AddRef()) =0;
	STDMETHOD_(ULONG, Release())=0;

    STDMETHOD(OnControlEvent(DWORD dwEvent, LPVOID lpvData, LPIControlChannel lpControlObject))=0;
	STDMETHOD(GetCapResolver(LPVOID *lplpCapObject, GUID CapType))=0;
	STDMETHOD_(LPWSTR, GetUserDisplayName()) =0;
    STDMETHOD_(PCC_ALIASNAMES, GetUserAliases()) =0;
    STDMETHOD_(PCC_ALIASITEM, GetUserDisplayAlias()) =0;
	STDMETHOD_( CREQ_RESPONSETYPE, FilterConnectionRequest(
	    LPIControlChannel lpControlChannel,  P_APP_CALL_SETUP_DATA pAppData))=0;

	// GetAcceptingObject may create a new conf object, but always creates a new control
	// channel and initializes it with a back pointer to the new or existing conf object.
	// the accepting object is the new control channel object.  Whatever the accepting
	// objects back pointer points to will get the CCEV_CONNECTED notification and then
	// will be able to get the caller ID etc., and then decide if it wants to accept the
	// call.
	STDMETHOD(GetAcceptingObject(LPIControlChannel *lplpAcceptingObject,
		LPGUID pPID))=0;

	STDMETHOD(FindAcceptingObject(LPIControlChannel *lplpAcceptingObject,
		LPVOID lpvConfID))=0;
	STDMETHOD_(IH323Endpoint *, GetIConnIF()) =0;
	STDMETHOD(AddCommChannel) (THIS_ ICtrlCommChan *pChan) PURE;
};

class IControlChannel
{
	public:
	STDMETHOD_(ULONG,  AddRef()) =0;
	STDMETHOD_(ULONG, Release())=0;

	STDMETHOD( Init(IConfAdvise *pConfAdvise))=0;
	STDMETHOD( DeInit(IConfAdvise *pConfAdvise))=0;
	// so we know what address we accepted on
	STDMETHOD( GetLocalAddress(PSOCKADDR_IN *lplpAddr))=0;	
	// so we know the address of the caller
	STDMETHOD( GetRemoteAddress(PSOCKADDR_IN *lplpAddr))=0;
	STDMETHOD( GetRemotePort(PORT * lpPort))=0;
	STDMETHOD( GetLocalPort(PORT * lpPort))=0;
    STDMETHOD(PlaceCall (BOOL bUseGKResolution, PSOCKADDR_IN pCallAddr,		
        P_H323ALIASLIST pDestinationAliases, P_H323ALIASLIST pExtraAliases,  	
	    LPCWSTR pCalledPartyNumber, P_APP_CALL_SETUP_DATA pAppData))=0;
	    
	STDMETHOD_(VOID,  Disconnect(DWORD dwReason))=0;
	STDMETHOD( ListenOn(PORT Port))=0;
	STDMETHOD( StopListen(VOID))=0;
   	STDMETHOD( AsyncAcceptRejectCall(CREQ_RESPONSETYPE Response))=0;	
   	
	// accept from the listening connection.  The ideal is that the accepting
	// object would QueryInterface for a private interface, then grab all the
	// pertinent connection info through that interface.  Temporarily expose this
	// using the IControlChannel interface.  The call control state will vary greatly
	// between implementations. For some implementations, this may perform
	// a socket accept before user information has been exchanged. User information will
	// be read into the accepting object directly.  For other implementations, the
	// socket accept is decoupled and has already been performed, and user information
	// has already been read into the listening object. In that case, this method
	// copies the user info and advises the parent "Conference" object of the
	// incoming call
	
	STDMETHOD( AcceptConnection(IControlChannel *pListenObject, LPVOID lpvAcceptData))=0;
	// true if this channel is resonsible for accepting connections into the conference
	// indicated by lpvConfID. In the future this may be split into two methods:
	// GetConfID() and IsAccepting()
	STDMETHOD_(BOOL, IsAcceptingConference(LPVOID lpvConfID))=0;
	STDMETHOD( GetProtocolID(LPGUID lpPID))=0;
	STDMETHOD_(IH323Endpoint *, GetIConnIF()) =0;	
	STDMETHOD( MiscChannelCommand(ICtrlCommChan *pChannel,VOID * pCmd)) =0;
	STDMETHOD( MiscChannelIndication(ICtrlCommChan *pChannel,VOID * pCmd)) =0;
	STDMETHOD( OpenChannel(ICtrlCommChan* pCommChannel, IH323PubCap *pCapResolver, 
		MEDIA_FORMAT_ID dwIDLocalSend, MEDIA_FORMAT_ID dwIDRemoteRecv))=0;
	STDMETHOD (CloseChannel(ICtrlCommChan* pCommChannel))=0;
    STDMETHOD (AddChannel(ICtrlCommChan * pCommChannel, LPIH323PubCap pCapabilityResolver))=0;
    STDMETHOD(GetVersionInfo)(THIS_
        PCC_VENDORINFO *ppLocalVendorInfo, PCC_VENDORINFO *ppRemoteVendorInfo) PURE;    
};

#endif	// __cplusplus

#endif	//#ifndef _ICTLCHAN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\h323\intif.h ===
/*
 *  	File: intif.h
 *
 *      
 *
 *		Revision History:
 *
 *		05/06/96	mikev	created
 */
 

#ifndef _INTIF_H
#define _INTIF_H

//
//	Internal interface classes
//
class IConfAdvise;
class IControlChannel;
class IH323PubCap;

typedef IControlChannel *LPIControlChannel;
typedef IConfAdvise* LPIConfAdvise;
typedef IH323PubCap *LPIH323PubCap;

#endif //_INTIF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\h323\icomchan.cpp ===
#include "precomp.h"

#ifndef OLDSTUFF
extern IRTP *g_pIRTP;
#endif
STDMETHODIMP  ImpICommChan::StandbyInit(LPGUID lpMID, LPIH323PubCap pCapObject, 
	    IMediaChannel* pMediaStreamSend)
{
	if((!lpMID) || (!pCapObject))
		return CHAN_E_INVALID_PARAM;
		
	m_MediaID = *lpMID;
	bIsSendDirection = TRUE;
	m_pMediaStream = pMediaStreamSend;
	m_pMediaStream->AddRef();
	
	// keeps a cap object ref
	pCapObject->AddRef();
	m_pCapObject = pCapObject;
	return hrSuccess;
}

STDMETHODIMP ImpICommChan::QueryInterface( REFIID iid,	void ** ppvObject)
{
	// this breaks the rules for the official COM QueryInterface because
	// the interfaces that are queried for are not necessarily real COM 
	// interfaces.  The reflexive property of QueryInterface would be broken in 
	// that case.
	
	HRESULT hr = E_NOINTERFACE;
	if(!ppvObject)
		return hr;
		
	*ppvObject = 0;
	if(iid == IID_IUnknown) 
	{
		*ppvObject = this;
		hr = hrSuccess;
		AddRef();
	}
	else if((iid == IID_ICommChannel))
	{
		*ppvObject = (ICommChannel *)this;
		hr = hrSuccess;
		AddRef();
	}
	else if((iid == IID_ICtrlCommChannel))
	{
		*ppvObject = (ICtrlCommChan *)this;
		hr = hrSuccess;
		AddRef();
	}
	else if((iid == IID_IStreamSignal))
	{
		*ppvObject = (IStreamSignal *)this;
		hr = hrSuccess;
		AddRef();
	} 
	else if((iid == IID_IAppAudioCap ) && m_pCapObject)
	{
		hr = m_pCapObject->QueryInterface(iid, ppvObject);
	}
	else if((iid == IID_IAppVidCap ) && m_pCapObject)
	{
		hr = m_pCapObject->QueryInterface(iid, ppvObject);
	}
	else if((iid == IID_IDualPubCap) && m_pCapObject)
	{
		hr = m_pCapObject->QueryInterface(iid, ppvObject);
	}
	else if(iid == IID_IVideoRender)
	{
		hr=hrSuccess;	
		if(!m_pMediaStream && m_pH323ConfAdvise)
		{
			hr = m_pH323ConfAdvise->GetMediaChannel(&m_MediaID, 
				bIsSendDirection, &m_pMediaStream);
		}
		if(HR_SUCCEEDED(hr))
		{
			hr = m_pMediaStream->QueryInterface(iid, ppvObject);
		}
	}
	else if(iid == IID_IVideoChannel)
	{
		hr=hrSuccess;	
		if(!m_pMediaStream && m_pH323ConfAdvise)
		{
			hr = m_pH323ConfAdvise->GetMediaChannel(&m_MediaID, 
				bIsSendDirection, &m_pMediaStream);
		}
		if(HR_SUCCEEDED(hr))
		{
			hr = m_pMediaStream->QueryInterface(iid, ppvObject);
		}
	}
	return (hr);
}


ULONG ImpICommChan::AddRef()
{
	m_uRef++;
	DEBUGMSG(ZONE_REFCOUNT,("ImpICommChan::AddRef:(0x%08lX)->AddRef() m_uRef = 0x%08lX\r\n",this, m_uRef ));
	return m_uRef;
}

ULONG ImpICommChan::Release()
{
	m_uRef--;
	if(m_uRef == 0)
	{
		DEBUGMSG(ZONE_REFCOUNT,("ImpICommChan::Release:(0x%08lX)->Releasing\r\n", this));
		delete this;
		return 0;
	}
	else
	{
		DEBUGMSG(ZONE_REFCOUNT,("ImpICommChan::Release:(0x%08lX)->Release() m_uRef = 0x%08lX\r\n",this, m_uRef ));
		return m_uRef;
	}
}

HRESULT ImpICommChan::GetMediaType(LPGUID pGuid)
{
	if(!pGuid)
		return CHAN_E_INVALID_PARAM;
		
	*pGuid = m_MediaID;
	return hrSuccess;
}



HRESULT ImpICommChan::IsChannelOpen(BOOL *pbOpen)
{
	if(!pbOpen)
		return CHAN_E_INVALID_PARAM;
	*pbOpen = (IsComchOpen()) ? TRUE:FALSE;
	return hrSuccess;	
}


STDMETHODIMP ImpICommChan::GetProperty(DWORD prop, PVOID pBuf, LPUINT pcbBuf)
{
	#define CHECKSIZE(type) if(*pcbBuf != sizeof(type))	return CHAN_E_INVALID_PARAM;
	#define OUTPROP(type) *(type *)pBuf
	if(!pBuf || !pcbBuf)
		return CHAN_E_INVALID_PARAM;
	switch (prop) 
	{

		case PROP_TS_TRADEOFF:
			CHECKSIZE(DWORD);
		  	OUTPROP(DWORD) = m_TemporalSpatialTradeoff;
		break;
		case PROP_REMOTE_TS_CAPABLE:
			CHECKSIZE(BOOL);
			OUTPROP(BOOL) = m_bPublicizeTSTradeoff;
		break;
		case PROP_CHANNEL_ENABLED:
			CHECKSIZE(BOOL);
		  	OUTPROP(BOOL) = (m_dwFlags && COMCH_ENABLED )? TRUE:FALSE;
		break;
		case PROP_LOCAL_FORMAT_ID:
			CHECKSIZE(MEDIA_FORMAT_ID);
		  	OUTPROP(MEDIA_FORMAT_ID) = m_LocalFmt;
		break;
		case PROP_REMOTE_FORMAT_ID:
			CHECKSIZE(MEDIA_FORMAT_ID);
		  	OUTPROP(MEDIA_FORMAT_ID) = m_RemoteFmt;
		break;
		case PROP_REMOTE_PAUSED:
		    CHECKSIZE(BOOL);
		  	OUTPROP(BOOL) = (IsStreamingRemote())? FALSE:TRUE;
		break;
        case PROP_LOCAL_PAUSE_RECV:
		case PROP_LOCAL_PAUSE_SEND:
            CHECKSIZE(BOOL);
            OUTPROP(BOOL) = IsPausedLocal();
        break;
		case PROP_VIDEO_PREVIEW_ON:
			CHECKSIZE(BOOL);
			OUTPROP(BOOL) = IsStreamingStandby();
		break;
		case PROP_VIDEO_PREVIEW_STANDBY:
			CHECKSIZE(BOOL);
			OUTPROP(BOOL) = IsConfigStandby();
		break;
		default:
			if(m_pMediaStream)
			{
				// we don't recognize this property, pass to media control 
				return m_pMediaStream->GetProperty(prop, pBuf, (LPUINT)pcbBuf);
			}
			else
				return CHAN_E_INVALID_PARAM;
		break;
	}
	return hrSuccess;
}

// Some properties are not writeable by client code. CtrlChanSetProperty allows setting of 
// those properties.  This method is *not* exposed in ICommChannel
STDMETHODIMP ImpICommChan::CtrlChanSetProperty(DWORD prop, PVOID pBuf, DWORD cbBuf)
{
	FX_ENTRY("ImpICommChan::CtrlChanSetProperty");
	BOOL bTemp;
	HRESULT hr = hrSuccess;
	if(!pBuf || !pBuf || !cbBuf)
		return CHAN_E_INVALID_PARAM;

	#define CHECKSIZEIN(type) if(cbBuf != sizeof(type))	return CHAN_E_INVALID_PARAM;
	#define INPROP(type) *(type *)pBuf
	switch (prop) 
	{
		case PROP_TS_TRADEOFF_IND:	// remote sender changed T/S tradeoff of what it is
			if(bIsSendDirection)	// sending  (valid for receive channels only)
				return CHAN_E_INVALID_PARAM;
				
			m_TemporalSpatialTradeoff = INPROP(DWORD);
			if(m_pH323ConfAdvise && m_pCtlChan)
			{
				DEBUGMSG(ZONE_COMMCHAN,("%s:issuing notification 0x%08lX\r\n",_fx_, CHANNEL_VIDEO_TS_TRADEOFF));
				m_pH323ConfAdvise->ChannelEvent(this, m_pCtlChan->GetIConnIF(), CHANNEL_VIDEO_TS_TRADEOFF);
			}
		break;

		case PROP_REMOTE_FORMAT_ID:
			CHECKSIZEIN(DWORD);
			m_RemoteFmt = INPROP(DWORD);
		break;
		case PROP_REMOTE_TS_CAPABLE:	// only valid for receive channels
			if(bIsSendDirection)
				return CHAN_E_INVALID_PARAM;
			else
			{
				CHECKSIZEIN(BOOL);
				m_bPublicizeTSTradeoff = INPROP(BOOL);
				DEBUGMSG (ZONE_COMMCHAN,("%s:remote TS tradeoff cap %d\r\n", _fx_, m_bPublicizeTSTradeoff));
	
			}
			break;
		default:
			return SetProperty(prop, pBuf, cbBuf);
		break;
	}
	return hr;
	
}

STDMETHODIMP ImpICommChan::Preview(MEDIA_FORMAT_ID idLocalFormat, IMediaChannel * pMediaStream)
{
	HRESULT hr = hrSuccess;
	FX_ENTRY("ImpICommChan::Preview");
	SHOW_OBJ_ETIME("ImpICommChan::Preview");
	LPVOID lpvFormatDetails;
	UINT uFormatSize;
	
	if(!bIsSendDirection)
	{
		hr = CHAN_E_INVALID_PARAM;
		goto EXIT;
	}
	if(NULL == pMediaStream)
	{
		// preview off

		if(IsStreamingStandby())
		{
			DEBUGMSG(ZONE_COMMCHAN,("%s:(%s)transition to preview OFF\r\n",_fx_,
				(bIsSendDirection)?"send":"recv"));

			//turn preview off. 
		
			// if network side is paused or closed, stop all streaming
			if(!IsComchOpen() || !IsStreamingNet())
			{	
				DEBUGMSG(ZONE_COMMCHAN,("%s:(%s)stopping local stream\r\n",_fx_,
						(bIsSendDirection)?"send":"recv"));
				//	Stop the stream, but DO NOT UNCONFIGURE becase we want to 
				//  be able to start later
				hr = m_pMediaStream->Stop();
				if(!HR_SUCCEEDED(hr)) 
				{
					DEBUGMSG(ZONE_COMMCHAN,("%s:(%s)Stop() returned 0x%08lx\r\n",_fx_,
						(bIsSendDirection)?"send":"recv", hr));
				}
				SHOW_OBJ_ETIME("ImpICommChan::Preview - stopped");
				LocalStreamFlagOff();
			}
			
			// else just need to turn off flag
			StandbyFlagOff();
		}
		else
			DEBUGMSG(ZONE_COMMCHAN,("%s:(%s) no change (%s)\r\n",_fx_, 
				(bIsSendDirection)?"send":"recv", "OFF"));
	}
	else
	{
		// preview on
		ASSERT(m_pCapObject);
		if(idLocalFormat == INVALID_MEDIA_FORMAT)
		{
			hr = CHAN_E_INVALID_PARAM;
			goto EXIT;
		}

		ASSERT(!(m_pMediaStream && (m_pMediaStream != pMediaStream)));

		if (m_pMediaStream == NULL)
		{
			m_pMediaStream = pMediaStream;
			m_pMediaStream->AddRef();
		}
		
		if(!IsStreamingStandby())
		{
			DEBUGMSG(ZONE_COMMCHAN,("%s:(%s)transition to preview ON\r\n",_fx_,
				(bIsSendDirection)?"send":"recv"));
			// turn preview on.
			if(!IsStreamingLocal())
			{
				ASSERT(!IsStreamingNet());
				if(IsComchOpen())
				{
					// if the channel is open, local streaming should only be off
					// if the network side of the channel is paused.
					//ASSERT(!IsStreamingNet());
				}
				else
				{

					// ensure that the stream does not come up with network send enabled
					// (!!!!! override default stream behavior !!!!!)
			
					BOOL bPause = TRUE;
					hr = m_pMediaStream->SetProperty( 
						(bIsSendDirection)? PROP_PAUSE_SEND:PROP_PAUSE_RECV, 
						&bPause, sizeof(bPause));
				
					// get format info for the specified format
					m_pCapObject->GetEncodeFormatDetails(idLocalFormat, &lpvFormatDetails, &uFormatSize);

					// fire up the local stream
					// this is now a two step process
					hr = m_pMediaStream->Configure((BYTE*)lpvFormatDetails, uFormatSize, 
						NULL, 0, (IUnknown*)(ImpICommChan *)this);
						
					if(!HR_SUCCEEDED(hr))
					{	
						ERRORMESSAGE(("%s: m_pMediaStream->Configure returned 0x%08lX\r\n", _fx_, hr));
						goto EXIT;
					}

					m_pMediaStream->SetNetworkInterface(NULL);
					if(!HR_SUCCEEDED(hr))
					{	
						ERRORMESSAGE(("%s: m_pMediaStream->SetNetworkInterface returned 0x%08lX\r\n", _fx_, hr));
						goto EXIT;
					}


					SHOW_OBJ_ETIME("ImpICommChan::Preview - config'd for preview");
				}
				//	Start the stream
				hr = m_pMediaStream->Start();
				if(!HR_SUCCEEDED(hr))
				{	
					ERRORMESSAGE(("%s: m_pMediaStream->Start returned 0x%08lX\r\n", _fx_, hr));
					goto EXIT;
				}	
				SHOW_OBJ_ETIME("ImpICommChan::Preview - started preview");

				LocalStreamFlagOn();
			}
			// else	// just need to set flag to make preview sticky
			StandbyFlagOn();
		}
		else
			DEBUGMSG(ZONE_COMMCHAN,("%s:(%s) no change (%s)\r\n",_fx_, 
				(bIsSendDirection)?"send":"recv", "ON"));
	}

EXIT:
	return hr;
}
STDMETHODIMP ImpICommChan::PauseNetworkStream(BOOL fPause)
{
	if(fPause)
    	LocalPauseFlagOn();
	else
		LocalPauseFlagOff();
		
	return PauseNet(fPause, FALSE);    

}

BOOL ImpICommChan::IsNetworkStreamPaused(VOID)
{
	return IsPausedLocal();
}

BOOL ImpICommChan::IsRemotePaused(VOID)
{
	return (IsStreamingRemote())? FALSE:TRUE;
}

STDMETHODIMP ImpICommChan::PauseNet(BOOL bPause, BOOL bRemoteInitiated)
{
	HRESULT hr = hrSuccess;

	FX_ENTRY("ImpICommChan::PauseNet");

    // issue notification
	if(bRemoteInitiated)
	{
	    // keep track of remote state
        if(bPause)
            RemoteStreamFlagOff();
        else
            RemoteStreamFlagOn();
            
	    if(!IsNotificationSupressed())
	    {
			if(m_pH323ConfAdvise && m_pCtlChan)
			{
        		DEBUGMSG(ZONE_COMMCHAN,("%s:issuing %s notification \r\n",_fx_,
        		    (bPause)?"pause":"un-pause"));
				m_pH323ConfAdvise->ChannelEvent(this, m_pCtlChan->GetIConnIF(), 
        		    (bPause)? CHANNEL_REMOTE_PAUSE_ON: CHANNEL_REMOTE_PAUSE_OFF);		
        	}
        	else
        		DEBUGMSG(ZONE_COMMCHAN,("%s:not issuing %s notification: m_pH323ConfAdvise: 0x%08lX, m_pCtlChan:0x%08lX \r\n"
        			,_fx_, (bPause)?"pause":"un-pause", m_pH323ConfAdvise,m_pCtlChan));
        }
    }
	if(bPause && IsStreamingNet())
	{
		ASSERT(IsComchOpen());
		// deactivate the channel  
		DEBUGMSG(ZONE_COMMCHAN,("%s:(%s)transition to pause\r\n",_fx_,
			(bIsSendDirection)?"send":"recv" ));

		if(!bRemoteInitiated)
		{
		    // locally initiated, so signal remote
		
			if(bIsSendDirection)
			{
				DEBUGMSG (ZONE_COMMCHAN,("%s:signaling pause of %s channel\r\n", 
	    			_fx_, (bIsSendDirection)?"send":"recv" ));
    			// signal remote
       			MiscellaneousIndication mi;
       			mi.type.choice  = logicalChannelInactive_chosen;
           		hr = m_pCtlChan->MiscChannelIndication(this, &mi); 
        		if(!HR_SUCCEEDED(hr))
        		{
                    DEBUGMSG (ZONE_COMMCHAN,("%s:(%s) CC_Mute returned 0x%08lx\r\n", 
    				    _fx_, (bIsSendDirection)?"send":"recv", hr));
    				hr = hrSuccess;  // don't care about signaling error, act normal
        		}
    
        	}
		}
		
		//
		hr = m_pMediaStream->SetProperty( 
			(bIsSendDirection)? PROP_PAUSE_SEND:PROP_PAUSE_RECV, 
			&bPause, sizeof(bPause));
				
		NetworkStreamFlagOff();
// LOOKLOOK - can't stop receive streams because they can't be restarted
// check this with GeorgeJ

//		if(!IsStreamingStandby())	// need local stream for anything?
		if(!IsStreamingStandby() && bIsSendDirection)	// need local stream for anything?

		{
			DEBUGMSG(ZONE_COMMCHAN,("%s:(%s)stopping local stream\r\n",_fx_,
				(bIsSendDirection)?"send":"recv"));
			// can shut off local streaming now
			hr = m_pMediaStream->Stop();
			LocalStreamFlagOff();
		}
		
	}
	else if(!bPause && !IsStreamingNet())
	{
		DEBUGMSG(ZONE_COMMCHAN,("%s:(%s)transition to unpause\r\n",_fx_,
			(bIsSendDirection)?"send":"recv"));

		if(IsComchOpen())
		{
			// activate the channel
	   		if(!bRemoteInitiated)
			{	
    		    // locally initiated, so signal remote
	    		if(bIsSendDirection)
    			{
   		    		DEBUGMSG (ZONE_COMMCHAN,("%s:signaling UNpause of %s channel\r\n", 
	    	    		_fx_, (bIsSendDirection)?"send":"recv" ));
       				// signal remote
       				MiscellaneousIndication mi;
           			mi.type.choice  = logicalChannelActive_chosen;
               		hr = m_pCtlChan->MiscChannelIndication(this, &mi); 
            		if(!HR_SUCCEEDED(hr))
            		{
                        DEBUGMSG (ZONE_COMMCHAN,("%s:(%s) CC_UnMute returned 0x%08lx\r\n", 
        				    _fx_, (bIsSendDirection)?"send":"recv", hr));
        				hr = hrSuccess;  // don't care about signaling error, act normal
            		}
            	}
			}
       		else
    		{
    		    // remotely initiated OR special case first time channel is unpaused
    		    // after opening
                AllowNotifications();   // stop supressing notifications
        	}
        	if(!IsPausedLocal())
			{					
				// MUST ensure unpaused state before starting stream ????
				hr = m_pMediaStream->SetProperty( 
					(bIsSendDirection)? PROP_PAUSE_SEND:PROP_PAUSE_RECV, 
					&bPause, sizeof(bPause));
					
				// check local streaming state, start it if needed
				if(!IsStreamingLocal())
				{
					DEBUGMSG(ZONE_COMMCHAN,("%s:(%s)starting local stream\r\n",_fx_,
						(bIsSendDirection)?"send":"recv"));
					// need to startup stream 
					hr = m_pMediaStream->Start();
					LocalStreamFlagOn();
				}
				else
				{	
					if(bIsSendDirection)
					{
						DEBUGMSG(ZONE_COMMCHAN,("%s:(%s)already streaming locally\r\n",_fx_,
		                    (bIsSendDirection)?"send":"recv" ));
						DEBUGMSG(ZONE_COMMCHAN,("%s:(%s)RESTARTING local stream\r\n",_fx_,
					        (bIsSendDirection)?"send":"recv"));
						// This is temporary until it is possible to start the 
						// network side of a running stream 
			        	hr = m_pMediaStream->Stop();
						hr = m_pMediaStream->Start();
					}
				}
				NetworkStreamFlagOn();

				//
				//	if this is a receive video channel, make the sender send an I-frame now
				//
				if(!bIsSendDirection && (GetTickCount() > (m_dwLastUpdateTick + MIN_IFRAME_REQ_TICKS)))
				{
					if((MEDIA_TYPE_H323VIDEO == m_MediaID)) 
					{
						MiscellaneousCommand mc;
						// mc.logicalChannelNumber = ?;  ** call control fills this in **
						mc.type.choice  = videoFastUpdatePicture_chosen;
						// do the control channel signaling for THIS channel
						hr = m_pCtlChan->MiscChannelCommand(this, &mc); 
					}
					m_dwLastUpdateTick = GetTickCount();
				}
			}
		}
		else
			ERRORMESSAGE(("%s:(%s) Not open: bPause=%d, streaming=%d\r\n", _fx_,
				(bIsSendDirection)?"send":"recv", bPause, 	IsStreamingNet()));

	}
	else
	{
		ERRORMESSAGE(("%s:(%s) bPause=%d, streaming=%d\r\n", _fx_, 
			(bIsSendDirection)?"send":"recv", bPause, IsStreamingNet()));
	}
	return hr;
}

STDMETHODIMP ImpICommChan::SetProperty(DWORD prop, PVOID pBuf, UINT cbBuf)
{
	FX_ENTRY("ImpICommChan::SetProperty");
	BOOL bTemp;
	HRESULT hr = hrSuccess;
	if(!pBuf || !pBuf || !cbBuf)
		return CHAN_E_INVALID_PARAM;

	#define CHECKSIZEIN(type) if(cbBuf != sizeof(type))	return CHAN_E_INVALID_PARAM;
	#define INPROP(type) *(type *)pBuf
	#define SetMediaProperty() 	\
			if(m_pMediaStream) \
				{return m_pMediaStream->SetProperty(prop, pBuf, cbBuf);	} \
			else  hr = CHAN_E_INVALID_PARAM;
			
	switch (prop) 
	{
		// (read only) case PROP_REMOTE_FORMAT_ID:
		// (read only) case PROP_LOCAL_FORMAT_ID:
		// (read only) case PROP_REMOTE_TS_CAPABLE:
		
		case PROP_TS_TRADEOFF:
			CHECKSIZEIN(DWORD);
			if(bIsSendDirection)	// set local T/S tradeoff, then signal remote
			{
				// scale value - input is 0-31, (lower number = higher quality and lower frame rate)
				m_TemporalSpatialTradeoff = INPROP(DWORD);
				DEBUGMSG (ZONE_COMMCHAN,("%s:TS tradeoff (tx) %d\r\n", _fx_, m_TemporalSpatialTradeoff));

				// change our compression
				if (m_pMediaStream)
				{
					HRESULT hr;
					
					hr = m_pMediaStream->SetProperty(PROP_VIDEO_IMAGE_QUALITY, 
						&m_TemporalSpatialTradeoff, sizeof (m_TemporalSpatialTradeoff));
				}
				if(m_bPublicizeTSTradeoff && m_pCtlChan)	// check our own capability and if in a call
				{
					// we said we supported TS tradeoff, so we have to signal our
					// new value
					MiscellaneousIndication mi;
					// mi.logicalChannelNumber = ?;  ** call control fills this in **
					mi.type.choice  = MIn_tp_vdTmprlSptlTrdOff_chosen;
					mi.type.u.MIn_tp_vdTmprlSptlTrdOff = LOWORD(m_TemporalSpatialTradeoff);
					// do the control channel signaling for THIS channel
					hr = m_pCtlChan->MiscChannelIndication(this, &mi); 
				}
			}	
			else	// signal remote to change its T/S tradoff of its send channel
			{
				m_TemporalSpatialTradeoff = INPROP(DWORD);
				DEBUGMSG (ZONE_COMMCHAN,("%s:TS tradeoff (rx) %d\r\n", _fx_, m_TemporalSpatialTradeoff));

				if(m_bPublicizeTSTradeoff && m_pCtlChan)// check remote's TS capability
				{
					MiscellaneousCommand mc;
					// mc.logicalChannelNumber = ?;  ** call control fills this in **
					mc.type.choice  = MCd_tp_vdTmprlSptlTrdOff_chosen;
					mc.type.u.MCd_tp_vdTmprlSptlTrdOff = LOWORD(m_TemporalSpatialTradeoff);
					
					hr = m_pCtlChan->MiscChannelCommand(this, &mc); 
				}
				else	// remote said it does not support TS tradeoff
					return CHAN_E_INVALID_PARAM;
			}
		break;
		case PROP_CHANNEL_ENABLED:
			CHECKSIZEIN(BOOL);
			if(INPROP(BOOL))
			{
				m_dwFlags |= COMCH_ENABLED;
			}
			else
			{
				m_dwFlags &= ~COMCH_ENABLED;
			}
		break;
		//
		//	Media streaming properties
		//
		case PROP_LOCAL_PAUSE_RECV:
		case PROP_LOCAL_PAUSE_SEND:
            CHECKSIZEIN(BOOL);
            bTemp = INPROP(BOOL);
            if(bTemp)
                LocalPauseFlagOn();
            else
                LocalPauseFlagOff();
                
            hr = PauseNet(bTemp, FALSE);    
        break;

		case PROP_PAUSE_RECV:
		case PROP_PAUSE_SEND:
			CHECKSIZEIN(BOOL);
			hr = PauseNet(INPROP(BOOL), FALSE);
		break;
	//	case PROP_PAUSE_RECV:
	//		SetMediaProperty();
	//	break;
	
		case PROP_VIDEO_PREVIEW_ON:
			ASSERT(0);
		break;
		case PROP_VIDEO_PREVIEW_STANDBY:
			CHECKSIZEIN(BOOL);
			bTemp = INPROP(BOOL);
			if(bTemp)
				StandbyConfigFlagOn();
			else
				StandbyConfigFlagOff();
		break;
		default:
			// we don't recognize this property, pass to media control 
			if(m_pMediaStream)
			{
				return m_pMediaStream->SetProperty(prop, pBuf, cbBuf);
			}
			else
				hr = CHAN_E_INVALID_PARAM;
		break;
	}
	return hr;
}

HRESULT ImpICommChan::EnableOpen(BOOL bEnable)
{
	if(bEnable)
	{
		m_dwFlags |= COMCH_ENABLED;
	}
	else
	{
		m_dwFlags &= ~COMCH_ENABLED;
	}	
	return hrSuccess;
}

HRESULT ImpICommChan::GetLocalParams(LPVOID lpvChannelParams, UINT uBufSize)
{
	if(!lpvChannelParams || !pLocalParams || !uBufSize)
		return CHAN_E_INVALID_PARAM;
	if(uBufSize < uLocalParamSize)
		return CHAN_E_INVALID_PARAM;
	
	memcpy(lpvChannelParams, pLocalParams, uLocalParamSize);			
	return hrSuccess;
}

HRESULT ImpICommChan::ConfigureStream(MEDIA_FORMAT_ID idLocalFormat)
{
	FX_ENTRY("ImpICommChan::ConfigureStream");
	HRESULT hr;
	ASSERT(m_pRTPChan && m_pCapObject);

	LPVOID lpvFormatGoo;
	UINT uFormatGooSize;
	IUnknown *pUnknown=NULL;
	
	// get format info for Configure()
	
	if(bIsSendDirection)
	{
		m_pCapObject->GetEncodeFormatDetails(idLocalFormat, &lpvFormatGoo, &uFormatGooSize);
	}
	else
	{
		m_pCapObject->GetDecodeFormatDetails(idLocalFormat, &lpvFormatGoo, &uFormatGooSize);
	}
	
	hr = m_pMediaStream->Configure((BYTE*)lpvFormatGoo, uFormatGooSize,
	                               (BYTE*)pLocalParams, uLocalParamSize,
	                               (IUnknown*)(ImpICommChan *)this);
	if(!HR_SUCCEEDED(hr))
	{
		ERRORMESSAGE(("%s: Configure returned 0x%08lX\r\n", _fx_, hr));
	}



	// SetNetworkInterface expects an IUnknown pointer
	// the IUnknown wil be QI'd for either an IRTPSend or an IRTPRecv
	// interface.  The IUnknown should be free'd by the caller.

	if (m_pRTPChan)
	{
		m_pRTPChan->QueryInterface(IID_IUnknown, (void**)&pUnknown);
		ASSERT(pUnknown);
	}

	hr = m_pMediaStream->SetNetworkInterface(pUnknown);
	if(!HR_SUCCEEDED(hr))
	{
		ERRORMESSAGE(("%s: SetNetworkInterface returned 0x%08lX\r\n", _fx_, hr));
	}
	if (pUnknown)
	{
		pUnknown->Release();
	}

	return hr;
}
HRESULT ImpICommChan::ConfigureCapability(LPVOID lpvRemoteChannelParams, UINT uRemoteParamSize,
	LPVOID lpvLocalParams, UINT uGivenLocalParamSize)
{
	HRESULT hr= hrSuccess;
	
	if(!lpvRemoteChannelParams)
		return CHAN_E_INVALID_PARAM;
	if(pRemoteParams)
	{
		MemFree(pRemoteParams);
		pRemoteParams = NULL;
	}

	// if uParamSize ==0, it means that the memory that lpvRemoteChannelParams points to
	// is being supplied
	if(uRemoteParamSize)
	{
		pRemoteParams = MemAlloc(uRemoteParamSize);
		if(pRemoteParams)
		{
			memcpy(pRemoteParams, lpvRemoteChannelParams, uRemoteParamSize);
		}
	}
	else
		pRemoteParams = lpvRemoteChannelParams;
		
	if(lpvLocalParams)
	{
		// memory for local parameters is always supplied by the caller
		if (!uGivenLocalParamSize)
		{
			 hr = CHAN_E_INVALID_PARAM;
			 goto EXIT;
		}
		if(pLocalParams)
		{	
			MemFree(pLocalParams);
			// not needed pLocalParams= NULL;
		}
	
		uLocalParamSize = uGivenLocalParamSize;
		pLocalParams = lpvLocalParams;

	}
EXIT:
	return hr;
}	

HRESULT ImpICommChan::OnChannelClose(DWORD dwStatus)
{
	HRESULT hr = hrSuccess;
	FX_ENTRY("ImpICommChan::OnChannelClose");
	BOOL fCloseAction = FALSE;

	SHOW_OBJ_ETIME("ImpICommChan::OnChannelClose");

	m_dwFlags &= ~COMCH_OPEN_PENDING;
	
	switch(dwStatus)
	{
		case CHANNEL_CLOSED:
		DEBUGMSG(ZONE_COMMCHAN,("%s:closing (%s)\r\n"
				,_fx_, (bIsSendDirection)?"send":"recv"));
			if(IsComchOpen())
			{
				fCloseAction = TRUE;
				m_dwFlags &= ~COMCH_OPEN;
			}
			else
			{
				ERRORMESSAGE(("%s: %d notification when not open (%s)\r\n", _fx_, 
					dwStatus,(bIsSendDirection)?"send":"recv"));
			}
		break;
		//case CHANNEL_REJECTED:
		//case CHANNEL_NO_CAPABILITY:
		default:
		break;
	}
	// clear general purpose channel handle 
	dwhChannel = 0;
	
// LOOKLOOK  **** RIGHT HERE ***
// ** need to notify the UI of the channel event ON_CLOSING so that the last
// frame can be grabbed for rendering (a still picture is better than a black window)
// LOOKLOOK  **** RIGHT HERE ***

	// Now check preview state
	if(IsStreamingStandby() && bIsSendDirection )
	{
		if (m_pMediaStream != NULL) 
		{
			DEBUGMSG(ZONE_COMMCHAN,("%s:transition back to preview\r\n"	,_fx_));
			// need to stop sending and reconfigure for preview
			// make sure send is paused
			DWORD dwProp = TRUE;
			hr = m_pMediaStream->SetProperty (PROP_PAUSE_SEND,&dwProp, sizeof(dwProp));
			if(!HR_SUCCEEDED(hr))
			{	
				ERRORMESSAGE(("%s: m_pMediaStream->SetProperty returned 0x%08lX\r\n", _fx_, hr));
				// do what now? 
			}

			NetworkStreamFlagOff();
			hr = m_pMediaStream->Stop();	
			LocalStreamFlagOff();
			StandbyFlagOff();
			ASSERT(hr == S_OK);
		}
		else
		{
			NetworkStreamFlagOff();
			LocalStreamFlagOff();
		}
		
		if(fCloseAction)
		{
			// Cleanup RTP session. This is a NOP if the opposite direction is still open.
			if (m_pRTPChan) 
			{
				m_pRTPChan->Release();
				m_pRTPChan = NULL;
			}
		}
	}
	else // not previewing
	{
		//
		//	Stop the media stream
		//
		if (m_pMediaStream) 
		{
			hr = m_pMediaStream->Stop();	// probably not necessary
			ASSERT(hr == S_OK);
			// implement "capture device standby": don't unconfigure if
			// the standby flag is set and it is a send stream.  
			if(!IsConfigStandby() || !bIsSendDirection)
			{
				if(!bIsSendDirection)       // keep send stream reference until *this* object is released
				{
					m_pMediaStream->Release();    
					m_pMediaStream = NULL;
				}
			}
		}
		SHOW_OBJ_ETIME("ImpICommChan::OnChannelClose - stream stopped");

		if(fCloseAction)
		{
			// Cleanup RTP session. This is a NOP if the opposite direction is still open.
			if (m_pRTPChan) 
			{
				m_pRTPChan->Release();
				m_pRTPChan = NULL;
			}
		}
		StreamFlagsOff();
	}// end if not previewing

	if(m_pH323ConfAdvise && m_pCtlChan)
	{
		DEBUGMSG(ZONE_COMMCHAN,("%s:issuing notification 0x%08lX\r\n",_fx_, dwStatus));
		m_pH323ConfAdvise->ChannelEvent(this, m_pCtlChan->GetIConnIF(), dwStatus);
	}

	return hr;
}
HRESULT ImpICommChan::OnChannelOpening()
{
	ASSERT((m_dwFlags & COMCH_OPEN_PENDING) ==0);
	m_dwFlags |= COMCH_OPEN_PENDING;
	return hrSuccess;
}

HRESULT ImpICommChan::OnChannelOpen(DWORD dwStatus)
{
	HRESULT hr;
	BOOL bConfigured = FALSE, bNewStream = FALSE;	// these bools make error cleanup cleaner
	FX_ENTRY("ImpICommChan::OnChannelOpen");

	SHOW_OBJ_ETIME("ImpICommChan::OnChannelOpen");
	// the open is no longer pending, regardless of success or failure
	m_dwFlags &= ~COMCH_OPEN_PENDING;
	m_dwLastUpdateTick = 0;		// reset tick count of last I-frame request so that one 
								// will be requested
	if(IsComchOpen())
	{
		ERRORMESSAGE(("%s: %d notification when open (%s)\r\n", _fx_, 
			dwStatus, (bIsSendDirection)?"send":"recv"));
	}		
	switch(dwStatus)
	{
		case CHANNEL_OPEN:
			m_dwFlags |= (COMCH_OPEN | COMCH_SUPPRESS_NOTIFICATION);
		break;
			
		default:
			dwStatus = CHANNEL_OPEN_ERROR;
			// fall through to notification
		case CHANNEL_REJECTED:
		case CHANNEL_NO_CAPABILITY:
			goto NOTIFICATION;			
		break;
	}
	
	// The channel is open as far as call control is concerned. 	

	// if previewing, the stream already exists.  We don't want another, nor do we 
	// want to tear it down at channel close time or in error cases
	if(!m_pMediaStream)
	{
		ASSERT(!IsStreamingLocal() &&m_pH323ConfAdvise); // can't be streaming without a stream
		bNewStream = TRUE;
		// Associate the media streaming endpoint with this channel 
		// see above		
		hr = m_pH323ConfAdvise->GetMediaChannel(&m_MediaID, 
				bIsSendDirection, &m_pMediaStream);
		if(!HR_SUCCEEDED(hr))
		{	
			ERRORMESSAGE(("%s: m_pH323ConfAdvise->GetMediaChannel returned 0x%08lX\r\n", _fx_, hr));
			goto ERROR_NOTIFICATION;
		}				
				
	}
	
    if(IsStreamingLocal())
    {
		DEBUGMSG(ZONE_COMMCHAN,("%s:(%s)transition:preview -> send\r\n",_fx_,
			(bIsSendDirection)?"send":"recv"));
		// need to stop stream while configuring  ( ***** check w/ RichP ******)
		hr = m_pMediaStream->Stop();
		LocalStreamFlagOff();
    }

	// notify upper layers of channel open now
	if(m_pH323ConfAdvise && m_pCtlChan)
	{
		DEBUGMSG(ZONE_COMMCHAN,("%s:issuing CHANNEL_OPEN notification\r\n",_fx_));
		m_pH323ConfAdvise->ChannelEvent(this, m_pCtlChan->GetIConnIF(), dwStatus);
	}

   	dwStatus = CHANNEL_ACTIVE;	// new status! notification is posted below
	ASSERT(m_pRTPChan);

	// get format info for Configure()
	
	hr = ConfigureStream(m_LocalFmt);
	if(!HR_SUCCEEDED(hr))
	{
		ERRORMESSAGE(("%s: Configure returned 0x%08lX\r\n", _fx_, hr));
		goto ERROR_NOTIFICATION;
	}
	SHOW_OBJ_ETIME("ImpICommChan::OnChannelOpen - configured stream");
		bConfigured = TRUE;
	// turn on flow to the network
	// SupressNotification()  // pre-initialized above in both CHANNEL_OPEN_xxx cases
	PauseNet(FALSE, TRUE);  // unpause, 
	//dwStatus = CHANNEL_ACTIVE;
	SHOW_OBJ_ETIME("ImpICommChan::OnChannelOpen - unpaused");
	
NOTIFICATION:
	if(m_pH323ConfAdvise && m_pCtlChan)
	{
		DEBUGMSG(ZONE_COMMCHAN,("%s:issuing notification 0x%08lX\r\n",_fx_, dwStatus));
		m_pH323ConfAdvise->ChannelEvent(this, m_pCtlChan->GetIConnIF(), dwStatus);	
	}
	else
		DEBUGMSG(ZONE_COMMCHAN,("%s: *** not issuing notification 0x%08lX m_pH323ConfAdvise: 0x%08lX, m_pCtlChan:0x%08lX \r\n"
			,_fx_, dwStatus,m_pH323ConfAdvise,m_pCtlChan));
			
	SHOW_OBJ_ETIME("ImpICommChan::OnChannelOpen - done ");

	return hr;	
	
ERROR_NOTIFICATION:
	dwStatus = CHANNEL_OPEN_ERROR;
	if(m_pMediaStream)
	{
		if(bNewStream)	// was the media stream just created?
		{		
			m_pMediaStream->Release();
			m_pMediaStream = NULL;
		}
	}
	if(m_pH323ConfAdvise && m_pCtlChan)
	{
		DEBUGMSG(ZONE_COMMCHAN,("%s:issuing notification 0x%08lX\r\n",_fx_, dwStatus));
		m_pH323ConfAdvise->ChannelEvent(this, m_pCtlChan->GetIConnIF(), dwStatus);
	}
	else
		DEBUGMSG(ZONE_COMMCHAN,("%s: *** not issuing notification 0x%08lX m_pH323ConfAdvise: 0x%08lX, m_pCtlChan:0x%08lX \r\n"
			,_fx_, dwStatus,m_pH323ConfAdvise,m_pCtlChan));
			
	// close the channel. 
	if(m_pCtlChan)
	{
		// close channel, but hr already contains the relevant return code
		m_pCtlChan->CloseChannel(this);
	}
	
	return hr;	
}


HRESULT ImpICommChan::Open(MEDIA_FORMAT_ID idLocalFormat, IH323Endpoint *pConnection)
{
    HRESULT hr; 
    MEDIA_FORMAT_ID idRemoteFormat;
    IConfAdvise * pConfAdvise = NULL;
    if((m_dwFlags & COMCH_OPEN_PENDING) || IsComchOpen() || (idLocalFormat == INVALID_MEDIA_FORMAT) || !pConnection)
        return CHAN_E_INVALID_PARAM;

    if(!m_pCtlChan) // this channel is not part of a call 
    {
        hr = pConnection->QueryInterface(IID_IConfAdvise, (void **)&pConfAdvise);
        if(!HR_SUCCEEDED(hr))
            goto EXIT;       
        hr = pConfAdvise->AddCommChannel(this);
        if(!HR_SUCCEEDED(hr))
            goto EXIT;  
            
        ASSERT(m_pCtlChan && m_pCapObject);
	}
	hr = m_pCapObject->ResolveToLocalFormat(idLocalFormat, &idRemoteFormat);
	if(!HR_SUCCEEDED(hr))
            goto EXIT;  
            
	// start the control channel stuff needed to open the channel
	hr = m_pCtlChan->OpenChannel((ICtrlCommChan*)this, m_pCapObject,
		idLocalFormat, idRemoteFormat);
    
EXIT:    
    if(pConfAdvise)
        pConfAdvise->Release();
        
	return hr;
}
HRESULT ImpICommChan::Close()
{
	HRESULT hr = CHAN_E_INVALID_PARAM;
    if(!IsComchOpen() || !m_pCtlChan)
		goto EXIT;
	if(!bIsSendDirection)
		goto EXIT;
	hr = m_pCtlChan->CloseChannel(this);

EXIT:
	return hr;
}

HRESULT ImpICommChan::BeginControlSession(IControlChannel *pCtlChan, LPIH323PubCap pCapObject)
{
	// this channel is now "in a call".
// LOOKLOOK - it might help to notify (ICommChannel notifications to client) 
// that the channel is part of a call now.
	ASSERT((m_pCtlChan == NULL) && pCtlChan && pCapObject);
	if(m_pCapObject)
	{
		m_pCapObject->Release();
	}
	m_pCtlChan = pCtlChan;
	m_pCapObject = pCapObject;
	m_pCapObject->AddRef();
	return hrSuccess;
}
HRESULT ImpICommChan::EndControlSession()
{
	// this channel is no longer "in a call".
	m_pCtlChan = NULL;
	return hrSuccess;
}


BOOL ImpICommChan::SelectPorts(LPIControlChannel pCtlChannel)
{
	// create the RTP channel
	HRESULT hr;
 	PSOCKADDR_IN psin=NULL;
	pCtlChannel->GetLocalAddress(&psin);

	PORT savedPort = psin->sin_port;
	if (!m_pRTPChan) {
		UINT sessFlags = bIsSendDirection ? SESSIONF_SEND : SESSIONF_RECV;
		UINT sessId;
	    GUID mediaGuid;
	    GetMediaType(&mediaGuid);
		if (mediaGuid == MEDIA_TYPE_H323VIDEO)
		{
			sessFlags |= SESSIONF_VIDEO;
			sessId = 2;
		}
		else
		{
			sessId = 1;
			sessFlags |= SESSIONF_AUDIO;
		}
		psin->sin_port = 0;		// zero port forces RTP to choose a port
		hr = g_pIRTP->OpenSession(sessId, sessFlags,
				(BYTE *)psin, sizeof(PSOCKADDR_IN),
				&m_pRTPChan);
	}
	else
		hr = m_pRTPChan->SetLocalAddress((BYTE *)psin,sizeof(SOCKADDR_IN));
	psin->sin_port = savedPort;


	return hr==S_OK;
}

// get the address and port of the base port that was selected by SelectPorts().
// in this typical implementation, that is the address/port of the RTCP channel
PSOCKADDR_IN ImpICommChan::GetLocalAddress()
{
#ifdef OLDSTUFF
	return m_pRTPChan ? m_pRTPChan->GetChannelDescription()->pLocalAddr : NULL;
#else
	const BYTE *pAddr;
	UINT cbAddr;
	HRESULT hr;
	hr = m_pRTPChan->GetLocalAddress(&pAddr, &cbAddr);
	return (SUCCEEDED(hr)) ? (PSOCKADDR_IN) pAddr : NULL;
#endif
}

STDMETHODIMP ImpICommChan::GetRemoteAddress(PSOCKADDR_IN pAddrOutput)
{
	HRESULT hr;
	if (!pAddrOutput)
	{
		return CHAN_E_INVALID_PARAM;
	}
	const BYTE *pAddr;
	UINT cbAddr;
	hr = m_pRTPChan->GetRemoteRTPAddress(&pAddr, &cbAddr);
	if(SUCCEEDED(hr))
	{
		ASSERT(cbAddr == sizeof(SOCKADDR_IN));
		*pAddrOutput = *((PSOCKADDR_IN) pAddr);
	}
	return hrSuccess;
}

UINT ImpICommChan::Reset()
{
	UINT uret;
	ASSERT(!IsComchOpen());
	if (m_pRTPChan) {
		uret = m_pRTPChan->Release();
		m_pRTPChan = NULL;
	} else
		uret = 0;
	return uret;
}
	
PORT ImpICommChan::GetLocalRTPPort()
{
#ifdef OLDSTUFF

	return (m_pRTPChan ? ntohs(m_pRTPChan->GetChannelDescription()->pLocalAddr->sin_port) : 0);
#else
	const BYTE *pAddr;
	UINT cbAddr;
	HRESULT hr;
	hr = m_pRTPChan->GetLocalAddress(&pAddr, &cbAddr);
	return (SUCCEEDED(hr)) ? ntohs(((PSOCKADDR_IN) pAddr)->sin_port) : 0;
#endif
}

PORT ImpICommChan::GetLocalRTCPPort()
{
#ifdef OLDSTUFF
	return (m_pRTPChan ? ntohs(m_pRTPChan->GetChannelDescription()->pLocalRTCPAddr->sin_port) : 0);
#else
	const BYTE *pAddr;
	UINT cbAddr;
	HRESULT hr;
	hr = m_pRTPChan->GetLocalAddress(&pAddr, &cbAddr);
	return (SUCCEEDED(hr)) ? ntohs(((PSOCKADDR_IN) pAddr)->sin_port)+1 : 0;
#endif
}

HRESULT ImpICommChan::AcceptRemoteRTCPAddress(PSOCKADDR_IN pSinC)
{
	HRESULT hr;
#ifdef OLDSTUFF
    if (!m_pRTPChan) {
    	RTPCHANNELDESC chanDesc = {0};
    	GetMediaType(&chanDesc.mediaId);
    	chanDesc.pRemoteRTCPAddr = pSinC;
    	hr = CreateRTPChannel(&chanDesc, &m_pRTPChan);
	} else
		hr = m_pRTPChan->SetRemoteAddresses(NULL,pSinC);
#else
	hr = m_pRTPChan->SetRemoteRTCPAddress((BYTE *)pSinC, sizeof(SOCKADDR_IN));
#endif
	return hr;
}

HRESULT ImpICommChan::AcceptRemoteAddress(PSOCKADDR_IN pSinD)
{
    HRESULT hr;
	hr = m_pRTPChan->SetRemoteRTPAddress((BYTE *)pSinD, sizeof(SOCKADDR_IN));
	return hr;
}

HRESULT ImpICommChan::SetAdviseInterface(IH323ConfAdvise *pH323ConfAdvise)
{
	if (!pH323ConfAdvise)
	{
		return CHAN_E_INVALID_PARAM;
	}
	m_pH323ConfAdvise = pH323ConfAdvise;	
	return hrSuccess;
}
STDMETHODIMP ImpICommChan::PictureUpdateRequest()
{
	FX_ENTRY ("ImpICommChan::PictureUpdateRequest");
	HRESULT hr;
	if (!m_pCtlChan)
	{
		return CHAN_E_NOT_OPEN;
	}
	if(bIsSendDirection || (MEDIA_TYPE_H323VIDEO != m_MediaID))
	{
		return CHAN_E_INVALID_PARAM;
	}
	// issue miscellaneous command for picture update
	MiscellaneousCommand mc;
	// mc.logicalChannelNumber = ?;  ** call control fills this in **
	mc.type.choice  = videoFastUpdatePicture_chosen;
	// do the control channel signaling for THIS channel
	hr = m_pCtlChan->MiscChannelCommand(this, &mc); 
	
	// record the tick count of this command
	m_dwLastUpdateTick = GetTickCount();
	return hr;
}

STDMETHODIMP ImpICommChan::GetVersionInfo( 
        PCC_VENDORINFO *ppLocalVendorInfo, 
        PCC_VENDORINFO *ppRemoteVendorInfo)
{
	FX_ENTRY ("ImpICommChan::GetVersionInfo");
	if (!m_pCtlChan)
	{
		return CHAN_E_INVALID_PARAM;
	}
	return m_pCtlChan->GetVersionInfo(ppLocalVendorInfo, ppRemoteVendorInfo);
}

ImpICommChan::ImpICommChan ()
:pRemoteParams(NULL),
m_pMediaStream(NULL),
pLocalParams(NULL),
uLocalParamSize(0),
m_pCtlChan(NULL),
m_pH323ConfAdvise(NULL),
m_pCapObject(NULL),
m_dwFlags(0),
dwhChannel(0),
m_LocalFmt(INVALID_MEDIA_FORMAT),
m_RemoteFmt(INVALID_MEDIA_FORMAT),
m_TemporalSpatialTradeoff(0),	// default to highest resolution
m_bPublicizeTSTradeoff(FALSE),
m_uRef(1)
{
	ZeroMemory(&m_MediaID, sizeof(m_MediaID));
}


ImpICommChan::~ImpICommChan ()
{
	if(pRemoteParams)
		MemFree(pRemoteParams);
	if(pLocalParams)
		MemFree(pLocalParams);
    if(m_pMediaStream)
	{
	    m_pMediaStream->Stop();	// probably not necessary
		m_pMediaStream->Release();
		m_pMediaStream = NULL;
	}
	if(m_pCapObject)
		m_pCapObject->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\intelcc\include\ccerror.h ===
/****************************************************************************
 *
 *      $Archive:   S:/STURGEON/SRC/INCLUDE/VCS/ccerror.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *      Copyright (c) 1993-1994 Intel Corporation.
 *
 *      $Revision:   1.0  $
 *      $Date:   16 Dec 1996 18:59:34  $
 *      $Author:   EHOWARDX  $
 *
 *      Deliverable:
 *
 *      Abstract:
 *              
 *
 *      Notes:
 *
 ***************************************************************************/


#ifndef CCERROR_H
#define CCERROR_H

#include "apierror.h"

#ifdef __cplusplus
extern "C" {
#endif

// Status codes
#define CC_OK							NOERROR
#define CC_NO_MEMORY					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_OUTOFMEMORY)
#define CC_PEER_REJECT					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 1)
#define CC_BAD_PARAM					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 2)
#define CC_BAD_SIZE						MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 3)
#define CC_ACTIVE_CONNECTIONS			MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 4)
#define CC_INTERNAL_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 5)
#define CC_NOT_IMPLEMENTED				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 6)
#define CC_DUPLICATE_CONFERENCE_ID		MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 7)
#define CC_ILLEGAL_IN_MULTIPOINT		MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 8)
#define CC_NOT_MULTIPOINT_CAPABLE		MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 9)
#define CC_PEER_CANCEL					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 10)
#define CC_GKI_STATE                    MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 21)
#define CC_GKI_CALL_STATE               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 22)
#define CC_GKI_LISTEN_NOT_FOUND         MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 23)
#define CC_GATEKEEPER_REFUSED           MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 24)
#define CC_INVALID_WITHOUT_GATEKEEPER   MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 25)
#define CC_GKI_IP_ADDRESS               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 26)
#define CC_GKI_LOAD                     MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 27)


#ifdef __cplusplus
}
#endif

#endif CCERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\h323\precomp.h ===
/* precomp.h for H323CC.DLL */


#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <winsock2.h>

// NetMeeting standard includes
#include <oprahcom.h>
#include <confdbg.h>
#include <avutil.h>
#include <oblist.h>
#include <regentry.h>

#include <limits.h>
#include "debug.h"
#include "nacguids.h"
#include "mperror.h"
#include "common.h"
#include "vidinout.h"
#include "irtp.h"
#include "iacapapi.h"
#include "capflags.h"
#include "ih323cc.h"
#include "iconnect.h"
#include "icomchan.h"
#include "incommon.h"
#include "callcont.h"
#include "h245api.h"
#include "intif.h"
#include "imstream.h"
#include "commchan.h"
#include "t120chan.h"
#include "codecs.h"
#include "mediacap.h"
#include "capif.h"
#include "ictlchan.h"
#include "cmember.h"
#include "nmqos.h"
#include "h323cc.h"
#include "connobj.h"
#include "auformats.h"
#include "intelcc.h"
#include "iprop.h"
#include "ividrdr.h"
#include "avcommon.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\h323\plog.cpp ===
#include "precomp.h"

#ifdef PLS_DEBUG
#include "plog.h"



CCallLog::CCallLog(int size)
{
	m_bValid = false;

    DBG_SAVE_FILE_LINE
	m_pLogEntry = new CPacketLogEntry[size];
	if (m_pLogEntry == NULL)
	{
		WARNING_OUT(("CCallLog:Out of memory"));
		return;
	}

	m_currentIndex = 0;
	m_size = size;
	m_bValid = true;
}

CCallLog::~CCallLog()
{
	if (m_bValid)
	{
		delete [] m_pLogEntry;
	}
}



bool CCallLog::AddEntry(DWORD dwTimeStamp, DWORD dwSeqNum, LARGE_INTEGER LL_ArrivalTime, DWORD dwSize, bool fMark)
{
	CPacketLogEntry Entry;

	if (m_bValid == false) return false;

	Entry.dwTimeStamp = dwTimeStamp;
	Entry.dwSequenceNumber = dwSeqNum;
	Entry.LL_ArrivalTime = LL_ArrivalTime;
	Entry.dwSize = dwSize;
	Entry.dwLosses = 0;
	Entry.bLate = false;
	Entry.bMark = fMark;

	if (SizeCheck() == false)
		return false;

	m_pLogEntry[m_currentIndex++] = Entry;
	return true;

}

bool CCallLog::SizeCheck()
{
	if (m_bValid == false)
		return false;

	if (m_currentIndex < m_size)
		return true;
	return false;
}


bool CCallLog::Flush(HANDLE hFile)
{
	int index;
	CPacketLogEntry *pEntry;
	char szOutputLine[80];
	DWORD dwNumWritten;
   __int64 ArrivalTime64;
	__int64 PerfFreq64;
	LARGE_INTEGER LL_PerfFreq;
	
	if (m_bValid == false)
		return false;

	if (hFile == INVALID_HANDLE_VALUE)
		return false;

	PerformStats();

	// what's the performance frequency of this machine
	QueryPerformanceFrequency(&LL_PerfFreq);
	PerfFreq64 = LL_PerfFreq.QuadPart;

	for (index = 0; index < m_currentIndex; index++)
	{
		pEntry = &m_pLogEntry[index];

		ArrivalTime64 = pEntry->LL_ArrivalTime.QuadPart * 1000;
		ArrivalTime64 = ArrivalTime64 / PerfFreq64;

		sprintf(szOutputLine, "%d\t%d\t%d\t%d\t%d",
		        pEntry->dwTimeStamp,
		        pEntry->dwSequenceNumber,
		        (int)ArrivalTime64,
		        pEntry->dwSize,
		        pEntry->dwLosses);
		
		if (pEntry->bMark)
			strcat(szOutputLine, "\tMARK");
		else strcat(szOutputLine, "\t");

		if (pEntry->bLate)
			strcat(szOutputLine, "\tLATE");
		
		strcat(szOutputLine, "\n");

		WriteFile(hFile, szOutputLine, strlen(szOutputLine), &dwNumWritten, NULL);

	}
	return true;
}


CCallLog& CCallLog::operator=(const CCallLog& log)
{
	WARNING_OUT(("CCallLog:Assignment not supported"));
	return *this;
}

CCallLog::CCallLog(const CCallLog& log)
{
	WARNING_OUT(("CCallLog:Copy constructor not supported"));
	return;
}

bool CCallLog::PerformStats()
{
	int index, probeIndex;
	DWORD nextExpected;
	bool bFound;

	if (m_bValid == false)
		return false;

	if (m_currentIndex == 0)
		return false;

	// Set the current "loss" value for each entry to 0
	for (index = 0; index < m_currentIndex; index++)
	{
		m_pLogEntry[index].dwLosses = 0;
		m_pLogEntry[index].bLate = false;
	}

	// the first packet will always be a match with nextExpected
	nextExpected = m_pLogEntry[0].dwSequenceNumber;

	for (index = 0; index < m_currentIndex; index++)
	{
		if (nextExpected > 65535)
			nextExpected = 0;
		// if the packet has the next expected seq num, then everything is ok
		if (m_pLogEntry[index].dwSequenceNumber == nextExpected)
		{
			nextExpected++;
			continue;
		}

		// we've detected a missing packet... time to go hunting
		else if (m_pLogEntry[index].dwSequenceNumber > nextExpected)
		{
			bFound = false;
			probeIndex = index+1;
			while ((probeIndex < m_currentIndex) &&
			       (probeIndex < (index+PLOG_MAX_NOT_LATE)) )
			{
				if (m_pLogEntry[index].dwSequenceNumber == nextExpected)
					bFound = true;
				probeIndex++;
			}

			// the packet was merely out of sequence
			if (bFound == true)
			{
				nextExpected++;
				continue;
			}

			// the packet is probably lost
			// notice that we are simply incrementing dwLoss measure,
			// rolling the index back one
			m_pLogEntry[index].dwLosses++;
			nextExpected++;
			index--; // this is so we can continue to count additional
			         // loss packets for the same index
			continue; // back to the top of the for-loop
		}

		// a packet that was either previously thought of as lost or late
		else
		{
			m_pLogEntry[index].bLate = true;	
		}


	}


	return true;
}


// --------------------------------------------------------------

CPacketLog::CPacketLog(LPTSTR szDiskFile):
	m_hFile(INVALID_HANDLE_VALUE),
	m_nExtension(0)
{
	m_pCallLog = NULL;
	strcpy(m_szDiskFile, szDiskFile);
}


// initializes an output file.  Closes the current file if still open
bool CPacketLog::InitFile()
{
	char szFileName[120];

	if (m_hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
	}

	sprintf(szFileName, "%s%d%s", m_szDiskFile, m_nExtension, PLOG_FILE_EXT);
	m_hFile = CreateFile(szFileName, 
									GENERIC_READ|GENERIC_WRITE, 
									0, NULL, OPEN_EXISTING,
									FILE_ATTRIBUTE_NORMAL, NULL);

	while ((m_hFile != INVALID_HANDLE_VALUE) && (m_nExtension < 100))
	{
		CloseHandle(m_hFile);
		sprintf(szFileName, "%s%d%s", m_szDiskFile, m_nExtension, PLOG_FILE_EXT);
		m_hFile = CreateFile(szFileName, 
									GENERIC_READ|GENERIC_WRITE, 
									0, NULL, OPEN_EXISTING,
									FILE_ATTRIBUTE_NORMAL, NULL);
		m_nExtension++;
	}
			

	m_hFile = CreateFile(szFileName,
	                     GENERIC_READ|GENERIC_WRITE, 
	                     FILE_SHARE_READ,
	                     NULL,
	                     CREATE_ALWAYS,
	                     FILE_ATTRIBUTE_NORMAL,
	                     NULL);
	                     
	                     
	if (m_hFile == INVALID_HANDLE_VALUE)
	{
		WARNING_OUT(("CPacketLog:Unable to initialize output file"));
		return false;
	}

	return true;

}


CPacketLog::CPacketLog(const CPacketLog& packet_log)
{
	// it wouldn't be an error if duphandle was used correctly
	ERROR_OUT(("CPacketLog:Invalid to create a new packetLog via a copy constructor"));
	return;
}



CPacketLog& CPacketLog::operator=(const CPacketLog& packet_log)
{
	// it wouldn't be an error if duphandle was used correctly
	ERROR_OUT(("CPacketLog:Invalid to create a new packetLog via the assignment operator"));
	return *this;	
}


CPacketLog::~CPacketLog()
{
	if (m_pCallLog != NULL)
	{
		Flush();
		delete (m_pCallLog);
	}

	if (m_hFile != INVALID_HANDLE_VALUE)
		CloseHandle(m_hFile);

}


bool CPacketLog::Flush()
{
	char *szCallHeader = "CALLSTART\n";
	DWORD dwNumWritten;

	if (m_pCallLog == NULL)
		return false;

	WriteFile(m_hFile, szCallHeader, strlen(szCallHeader), &dwNumWritten, NULL);
	m_pCallLog->Flush(m_hFile);		

	return true;
}



bool CPacketLog::MarkCallStart()
{
	// write the previous call to file
	if (m_pCallLog != NULL)
	{
		Flush();
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
		delete m_pCallLog;
	}

	if (false == InitFile())
	{
		return false;
	}

    DBG_SAVE_FILE_LINE
	m_pCallLog = new CCallLog(PLOG_MAX_PACKETS_CALL);
	if (m_pCallLog == NULL)
		return false;

	return true;
}


bool CPacketLog::AddEntry(DWORD dwTimeStamp, DWORD dwSeqNum, LARGE_INTEGER LL_ArrivalTime, DWORD dwSize, bool fMark)
{
	if (m_pCallLog == NULL)
	{
		if (false == MarkCallStart())
			return false;
	}

	return (m_pCallLog->AddEntry(dwTimeStamp, dwSeqNum, LL_ArrivalTime, dwSize, fMark));

}


// if-def pls_debug
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\h323\plog.h ===
#ifndef PLOG_H
#define PLOG_H

#define PLOG_MAX_CALLS	20
#define PLOG_MAX_PACKETS_CALL 20000
#define PLOG_FILE_AUDIO "C:\\AuPacketLog"
#define PLOG_FILE_VIDEO "C:\\VidPacketLog"
#define PLOG_FILE_EXT    ".txt"

// number of packets until the missing packet
// is declared "lost" instead of late
#define PLOG_MAX_NOT_LATE	20

struct CPacketLogEntry
{
	DWORD dwSequenceNumber;
	DWORD dwTimeStamp;
	LARGE_INTEGER LL_ArrivalTime;
	DWORD dwSize;
	DWORD dwLosses;
	bool bLate;  // is the packet late ?
	bool bMark;  // is the M bit set in the RTP packet
};


class CCallLog
{
private:
	CPacketLogEntry *m_pLogEntry;
	int m_size;  // max num of entries this list can hold
	int m_currentIndex;
	bool m_bValid;
public:
	CCallLog(int size=PLOG_MAX_PACKETS_CALL);
	~CCallLog();
	bool AddEntry(DWORD dwTimeStamp, DWORD dwSeqNum, LARGE_INTEGER LL_ArrivalTime, DWORD dwSize, bool fMark); 
	bool Flush(HANDLE hFile);
	bool SizeCheck();

	CCallLog& operator=(const CCallLog&);
	CCallLog(const CCallLog&);

	bool PerformStats();
};



// PacketLog maintains a list of CPacketLogEntry's
class CPacketLog
{
private:
	HANDLE m_hFile;         // handle to disk file where logs are kept
	CCallLog *m_pCallLog;   // pointer to CCallLog instance
	char m_szDiskFile[80];  // base name of the disk file
	int m_nExtension;	// current file extension index number

	bool InitFile();

public :
	CPacketLog(LPTSTR szDiskFile);
	CPacketLog(const CPacketLog&);

	CPacketLog& operator=(const CPacketLog&);

	~CPacketLog();
	bool Flush();

	bool MarkCallStart();
	bool AddEntry(DWORD dwTimeStamp, DWORD dwSeqNum, LARGE_INTEGER LL_ArrivalTime, DWORD dwSize, bool fMark); 

};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\intelcc\include\cclock.h ===
/****************************************************************************
 *
 *      $Archive:   S:/STURGEON/SRC/INCLUDE/VCS/cclock.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *      Copyright (c) 1993-1994 Intel Corporation.
 *
 *      $Revision:   1.0  $
 *      $Date:   31 Jan 1997 12:36:14  $
 *      $Author:   MANDREWS  $
 *
 *      Deliverable:
 *
 *      Abstract:
 *              
 *
 *      Notes:
 *
 ***************************************************************************/


#ifndef CCLOCK_H
#define CCLOCK_H

// Status codes
#define CCLOCK_OK						NOERROR
#define CCLOCK_NO_MEMORY				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CCLOCK,ERROR_OUTOFMEMORY)
#define CCLOCK_INTERNAL_ERROR			MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CCLOCK,ERROR_LOCAL_BASE_ID + 1)

#ifdef __cplusplus
extern "C" {
#endif

#if defined(CCLOCK_EXPORT)
#define CCLOCK_API __declspec (dllexport)
#else // CCLOCK_IMPORT
#define CCLOCK_API __declspec (dllimport)
#endif

#pragma pack(push,8)


CCLOCK_API
HRESULT CCLOCK_AcquireLock();

CCLOCK_API
HRESULT CCLOCK_RelinquishLock();

#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif CCLOCK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\h323\t120chan.h ===
/*
 *  	File: t120chan.h
 *
 *      T.120 implementation of media channel.
 *      Interfaces:  ICommChannel, ICtrlCommChan
 *
 *		Revision History:
 *
 *		06/11/97	mikev	created
 */


#ifndef _T120CHAN_H
#define _T120CHAN_H

class ImpT120Chan : public ICommChannel, public ICtrlCommChan
{
	
protected:
	SOCKADDR_IN local_sin;
	SOCKADDR_IN remote_sin;	
	
	UINT uRef;
	GUID m_MediaID;
	IControlChannel *m_pCtlChan;
	LPIH323PubCap   m_pCapObject;
    IH323ConfAdvise *m_pH323ConfAdvise;
	DWORD   m_dwFlags;
	DWORD_PTR dwhChannel; //General purpose handle.  Whatever
	// creates an instance of this class can use this for whatever it wants
	
public:
	ImpT120Chan ();
	~ImpT120Chan ();
	
// ICtrlCommChannel methods
  	STDMETHODIMP_(IControlChannel *) GetControlChannel(VOID) {return m_pCtlChan;};
    STDMETHODIMP StandbyInit(LPGUID lpMID, LPIH323PubCap pCapObject,
	    IMediaChannel* pMediaStreamSend)
	    {
	        return hrSuccess;
	    };
	STDMETHODIMP_(BOOL) Init(LPGUID lpMID, IH323ConfAdvise *pH323ConfAdvise,
	    BOOL fSendDirection)
	    {
        	m_MediaID = *lpMID;
    		m_pH323ConfAdvise = pH323ConfAdvise;
	        return TRUE;
	    };
	
    STDMETHODIMP GetMediaType(LPGUID pGuid);
    STDMETHODIMP CtrlChanSetProperty(DWORD prop, PVOID pBuf, DWORD cbBuf){return CHAN_E_INVALID_PARAM;};
	STDMETHODIMP PauseNet(BOOL bPause, BOOL bRemote)  {return CHAN_E_INVALID_PARAM;};
	STDMETHODIMP BeginControlSession(IControlChannel *pCtlChan, LPIH323PubCap pCapObject);
	STDMETHODIMP EndControlSession();
	STDMETHODIMP OnChannelOpening();
	STDMETHODIMP OnChannelOpen(DWORD dwStatus);
	STDMETHODIMP OnChannelClose(DWORD dwStatus);
  	STDMETHODIMP_(UINT) Reset(VOID) {return 0;};
   	
	STDMETHODIMP_(BOOL) SelectPorts(LPIControlChannel pCtlChannel);
	STDMETHODIMP_(PSOCKADDR_IN) GetLocalAddress(){return &local_sin;};
	
	STDMETHODIMP_(PORT) GetLocalRTPPort() {return 0;};
	STDMETHODIMP_(PORT) GetLocalRTCPPort() {return 0;};
	STDMETHODIMP AcceptRemoteAddress (PSOCKADDR_IN pSinD);
	STDMETHODIMP AcceptRemoteRTCPAddress(PSOCKADDR_IN pSinC) {return CHAN_E_INVALID_PARAM;};

    STDMETHODIMP_(BOOL) IsSendChannel () {return TRUE;};
	STDMETHODIMP_(BOOL) IsChannelOpen(){return ((m_dwFlags & COMCH_OPEN) !=0);};
	STDMETHODIMP_(BOOL) IsOpenPending(){return ((m_dwFlags & COMCH_OPEN_PENDING ) !=0);};
	STDMETHODIMP_(BOOL) IsChannelEnabled(){return ((m_dwFlags & COMCH_ENABLED ) !=0);};

	
	STDMETHODIMP ConfigureCapability(LPVOID lpvRemoteChannelParams, UINT uRemoteParamSize,
		LPVOID lpvLocalParams, UINT uLocalParamSize){return CHAN_E_INVALID_PARAM;};
	STDMETHODIMP GetLocalParams(LPVOID lpvChannelParams, UINT uBufSize){return CHAN_E_INVALID_PARAM;};
	STDMETHODIMP_(PVOID) GetRemoteParams(VOID) {return NULL;}
 	STDMETHODIMP_(VOID) SetNegotiatedLocalFormat(DWORD dwF) {return;};
	STDMETHODIMP_(VOID) SetNegotiatedRemoteFormat(DWORD dwF) {return;};
   	STDMETHODIMP_(DWORD_PTR) GetHChannel(VOID) {return dwhChannel;};
    STDMETHODIMP_(VOID) SetHChannel (DWORD_PTR dwSetChannel) {dwhChannel = dwSetChannel;};	

// ICommChannel Methods
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR * ppvObj);
	STDMETHOD_(ULONG,AddRef());
	STDMETHOD_(ULONG,Release());
	
	STDMETHOD(GetProperty(DWORD prop, PVOID pBuf, LPUINT pcbBuf)) {return CHAN_E_INVALID_PARAM;};
	STDMETHOD(SetProperty(DWORD prop, PVOID pBuf, UINT cbBuf))  {return CHAN_E_INVALID_PARAM;};
	STDMETHOD(IsChannelOpen(BOOL *pbOpen));
	STDMETHOD(Open(MEDIA_FORMAT_ID idLocalFormat,IH323Endpoint *pConnection));
	STDMETHOD(Close());
	STDMETHOD(SetAdviseInterface(IH323ConfAdvise *pH323ConfAdvise));

	STDMETHOD(EnableOpen(BOOL bEnable));
    STDMETHOD_(IMediaChannel *, GetMediaChannel(VOID)) {return NULL;};
   	STDMETHOD(Preview(MEDIA_FORMAT_ID idLocalFormat, IMediaChannel * pMediaChannel)){return CHAN_E_INVALID_PARAM;};
   	STDMETHOD(PauseNetworkStream(BOOL fPause)){return CHAN_E_INVALID_PARAM;};
    STDMETHOD_(BOOL, IsNetworkStreamPaused(VOID)){return CHAN_E_INVALID_PARAM;};
    STDMETHOD_(BOOL, IsRemotePaused(VOID)){return CHAN_E_INVALID_PARAM;};
    STDMETHODIMP_(MEDIA_FORMAT_ID) GetConfiguredFormatID() {return INVALID_MEDIA_FORMAT;};
   	STDMETHODIMP GetRemoteAddress(PSOCKADDR_IN pAddrOutput);

};

#endif  // _T120CHAN_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\intelcc\include\gkierror.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1997 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *																	   *
 *	$Archive:   S:\sturgeon\src\include\vcs\gkierror.h_v  $
 *
 *	$Revision:   1.2  $
 *	$Date:   08 Feb 1997 12:20:14  $
 *
 *	$Author:   CHULME  $
 *
 *  $Log:   S:\sturgeon\src\include\vcs\gkierror.h_v  $
 * 
 *    Rev 1.2   08 Feb 1997 12:20:14   CHULME
 * Added error code for semaphore creation error
 * 
 *    Rev 1.1   16 Jan 1997 15:25:08   BPOLING
 * changed copyrights to 1997
 * 
 *    Rev 1.0   27 Dec 1996 14:37:02   EHOWARDX
 * Initial revision.
 *                                                                     * 
 ***********************************************************************/

// gkicom.h : common includes between gkitest and gki
/////////////////////////////////////////////////////////////////////////////

#ifndef GKIERROR_H
#define GKIERROR_H

// Status codes
#define GKI_EXIT_THREAD_CODE			ERROR_LOCAL_BASE_ID + 1	// not actually error code
#define GKI_REDISCOVER_CODE				ERROR_LOCAL_BASE_ID + 2	// not actually error code
#define GKI_DELETE_CALL_CODE			ERROR_LOCAL_BASE_ID + 3	// not actually error code
#define GKI_GCF_RCV_CODE				ERROR_LOCAL_BASE_ID + 4	// not actually error code

#define GKI_ALREADY_REG_CODE			ERROR_LOCAL_BASE_ID + 0x10
#define GKI_VERSION_ERROR_CODE			ERROR_LOCAL_BASE_ID + 0x11
#define GKI_ENCODER_ERROR_CODE			ERROR_LOCAL_BASE_ID + 0x12
#define GKI_NOT_REG_CODE				ERROR_LOCAL_BASE_ID + 0x13
#define GKI_BUSY_CODE					ERROR_LOCAL_BASE_ID + 0x14
#define GKI_NO_TA_ERROR_CODE			ERROR_LOCAL_BASE_ID + 0x15
#define GKI_NO_RESPONSE_CODE			ERROR_LOCAL_BASE_ID + 0x16
#define GKI_DECODER_ERROR_CODE			ERROR_LOCAL_BASE_ID + 0x17
#define GKI_SEMAPHORE_ERROR_CODE		ERROR_LOCAL_BASE_ID + 0x18
#define GKI_NOT_INITIALIZED_ERROR_CODE	ERROR_LOCAL_BASE_ID + 0x19

#define GKI_OK							NOERROR

#define GKI_EXIT_THREAD					MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS,1,FACILITY_GKI,GKI_EXIT_THREAD_CODE)
#define GKI_REDISCOVER					MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS,1,FACILITY_GKI,GKI_REDISCOVER_CODE)
#define GKI_DELETE_CALL					MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS,1,FACILITY_GKI,GKI_DELETE_CALL_CODE)
#define GKI_GCF_RCV						MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS,1,FACILITY_GKI,GKI_GCF_RCV_CODE)

#define GKI_NO_MEMORY					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,ERROR_OUTOFMEMORY)
#define GKI_NO_THREAD					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,ERROR_TOO_MANY_TCBS)
#define GKI_HANDLE_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,ERROR_INVALID_HANDLE)

#define GKI_ALREADY_REG					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_ALREADY_REG_CODE)
#define GKI_VERSION_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_VERSION_ERROR_CODE)
#define GKI_ENCODER_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_ENCODER_ERROR_CODE)
#define GKI_NOT_REG						MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_NOT_REG_CODE)
#define GKI_BUSY						MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_BUSY_CODE)
#define GKI_NO_TA_ERROR					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_NO_TA_ERROR_CODE)
#define GKI_NO_RESPONSE					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_NO_RESPONSE_CODE)
#define GKI_DECODER_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_DECODER_ERROR_CODE)
#define GKI_SEMAPHORE_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_SEMAPHORE_ERROR_CODE)

#define GKI_WINSOCK2_ERROR(w)			(MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_WINSOCK2,w))
#define GKI_NOT_INITIALIZED				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_NOT_INITIALIZED_ERROR_CODE)

#endif // GKIERROR_H

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\intelcc\include\gkerror.h ===
/***********************************************************************
 *																		*
 *	INTEL CORPORATION PROPRIETARY INFORMATION							*
 *																		*
 *	This software is supplied under the terms of a license			   	*
 *	agreement or non-disclosure agreement with Intel Corporation		*
 *	and may not be copied or disclosed except in accordance	   			*
 *	with the terms of that agreement.									*
 *																		*
 *	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
 *																		*
 *	$Archive:   S:\sturgeon\src\include\vcs\gkerror.h_v  $
 *
 *	$Revision:   1.18  $
 *	$Date:   16 Jan 1997 15:25:06  $
 *
 *	$Author:   BPOLING  $
 *
 *  $Log:   S:\sturgeon\src\include\vcs\gkerror.h_v  $
 * 
 *    Rev 1.18   16 Jan 1997 15:25:06   BPOLING
 * changed copyrights to 1997
 * 
 *    Rev 1.17   19 Dec 1996 18:46:44   BPOLING
 * added error code for no call signal address left in a user.
 * 
 *    Rev 1.16   18 Dec 1996 21:48:16   AKLEMENT
 * Fixed an error code for GWInfo.cpp
 * 
 *    Rev 1.14   18 Dec 1996 17:02:58   AKLEMENT
 * Added more GKInfo error codes.
 * 
 *    Rev 1.13   17 Dec 1996 19:20:02   AKLEMENT
 * Added GWInfo error codes.
 * 
 *    Rev 1.12   11 Dec 1996 13:32:44   AKLEMENT
 * Fixed the Prop Info header.
 * 
 *    Rev 1.11   10 Dec 1996 15:55:02   AKLEMENT
 * Added Resource Reading error define.
 * 
 *    Rev 1.10   10 Dec 1996 01:23:58   BPOLING
 * added a new error code for sending RRJ Undefined Reason.
 * 
 *    Rev 1.9   09 Dec 1996 14:13:34   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.8   04 Dec 1996 10:43:18   BPOLING
 * added a new message id to post to h/i.
 * 
 *    Rev 1.7   04 Dec 1996 10:14:46   BPOLING
 * added error code for invalid ip address
 * 
 *    Rev 1.6   21 Nov 1996 13:06:18   BPOLING
 * added error code for HI PostMessage decoding.
 * 
 *    Rev 1.5   15 Nov 1996 14:38:18   BPOLING
 * vcs log fix.
 *                                                                     * 
 ***********************************************************************/

#ifndef GK_ERROR_H
#define GK_ERROR_H

#define GK_NOERROR					0

// WIN32 system error 000

#define GK_MEMORY_ERROR				1
#define GK_REGCREATEKEY_FAILED 		2
#define GK_GUID_ERROR				3
#define GK_EXCEPTION				4
#define GK_RESOURCE_ERROR			5

// Service related 100

#define GK_INVALID_ARG 				101
#define GK_NOARGS					102
#define GK_STARTSERVICE_FAILED		103
#define GK_EXIT						104

// User Class Errors 200

#define GK_USER_NOTINITIALIZED		201
#define GK_NOUSERFOUND				202
#define GK_EMPTYSEQUENCE			203
#define GK_TRANSPORTNOTFOUND		204
#define GK_ALIASNOTFOUND			205
#define GK_NO_CALLSIG				206

// Engine related Errors 300

#define GK_XRSRESPONSE				301
#define GK_NORESPONSE				303
#define GK_INVALIDMESSAGE			304
#define GK_SENDRRJ_NEEDGRQ			305
#define GK_XRSMESSAGERECEIVED		306
#define GK_NSMMESSAGERECEIVED		307
#define GK_BADENDPOINTID			308
#define GK_SENDGRJ_TERMEX			309
#define GK_SENDRRJ_UNDEFINED		310

// Ras Map related errors 400

#define GK_NORASFOUND		  	401
#define GK_RASFOUND				402
#define GK_DUPLICATERAS			403
#define GK_RAS_NOTINITIALIZED	404
#define GK_RAS_NOT_UNIQUE		405

// Sockets related errors 500

#define GK_NOPORT					501
#define GK_NOHOSTNAME				502
#define GK_UNSUPPORTEDPROTOCOL		503
#define GK_PROTOCOLNOTFOUND			504
#define GK_INVALIDPDUTYPE			505
#define GK_SOCKETSERROR				506
#define GK_RESPONSE					507
#define GK_INVALID_IPADDRESS		508

// Bound Map related errors 600

#define GK_NOBOUNDFOUND				601
#define GK_BOUNDFOUND				602
#define GK_DUPLICATEBOUND			603
#define GK_BOUND_NOTINITIALIZED		604
#define GK_BOUNDLOCKED				607
#define GK_BOUNDNOTLOCKED			608

// CONF Map related errors 700

#define GK_NOCONFFOUND				701
#define GK_CONFFOUND				702
#define GK_DUPLICATECONF			703
#define GK_CONF_NOTINITIALIZED		704
#define GK_NOT_IN_CONF				706
#define GK_INVALID_REQUEST			707
#define GK_CONFDELETE				708
#define GK_CONFCREATEFAILED			709


// PDU Error return codes 800

#define GK_ARJ_REQUEST_DENIED		800
#define GK_ARJ_UNDEFINED_REASON		801

// Alias CMap Errors 900

#define GK_ALIAS_NOTINITIALIZED		900
#define GK_ALIAS_NOT_UNIQUE			901
#define GK_ALIASFOUND				902
#define GK_NOALIASFOUND				903

// Guid Map related errors 1000

#define GK_NOGUIDFOUND				1001
#define GK_GUIDFOUND				1002
#define GK_DUPLICATEGUID			1003
#define GK_GUIDINUSE				1004
#define GK_GUID_NOTINITIALIZED		1005

// Call Sig CMap Errors 1100

#define GK_CALLSIG_NOTINITIALIZED		1100
#define GK_CALLSIG_NOT_UNIQUE			1101
#define GK_CALLSIGFOUND					1102
#define GK_NOCALLSIGFOUND				1103

// Call Errors 1200

#define GK_NOCALLFOUND					1200
#define GK_DIDNOTPURGE					1201
#define GK_CALL_NOTINITIALIZED			1202
#define GK_CALL_CREATE					1203
#define GK_CALL_DELETE					1204
#define GK_CALL_CHANGE					1205
#define GK_CALL_TIMER					1206

// Bandwidth Manager Errors 1300

#define GK_INVALID_BANDWIDTH			1300
#define GK_EXTERNAL_EXCEEDS_INTERNAL	1301
#define GK_NO_AVAILABLE_BANDWIDTH		1302
#define GK_USEDBW_WENT_NEGATIVE			1303
#define GK_LESS_AVAILABLE_BANDWIDTH		1304

// Logger Errors 1400

#define GK_LOGGING_IS_OFF				1400
#define GK_FILE_NOT_OPEN				1401
#define GK_COULD_NOT_OPEN_FILE			1402
#define GK_FILE_ALREADY_OPEN			1403
#define GK_NAME_USED_FOR_LOG			1404
#define GK_COULD_NOT_MAKE_DIR			1405

// GWInfo Errors 1500
#define GK_WRONG_PDU					1500
#define GK_NOT_GATEWAY					1501
#define GK_PROTOCOL_NOT_PRESENT			1502
#define GK_GW_NOT_FOUND					1503
#define GK_GW_NOT_REQUIRED				1504
#define GK_PREFIX_RESERVED				1505
#define GK_NO_DEST_INFO_SPECIFIED		1506

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\intelcc\include\av_asn1.h ===
#ifndef _MS_AV_ASN1_H_
#define _MS_AV_ASN1_H_

#include "nmasn1.h"

#ifdef __cplusplus
extern "C" {
#endif

// lonchanc: copied from ossdll.h
#define DLL_ENTRY       WINAPI
#define DLL_ENTRY_FDEF  WINAPI
#define DLL_ENTRY_FPTR  WINAPI


extern ASN1module_t     Q931ASN_Module;

#define q931asn         Q931ASN_Module
#define ObjectID_       ASN1objectidentifier_s

typedef ASN1bool_t      ASN1_BOOL;


typedef struct
{
    ASN1encoding_t  pEncInfo;
    ASN1decoding_t  pDecInfo;
}
    ASN1_CODER_INFO;

typedef struct
{
    ULONG           length;
    PBYTE           value;
}
    ASN1_BUF;

int Q931_InitModule(void);
int Q931_TermModule(void);
int Q931_InitWorld(ASN1_CODER_INFO *pWorld);
int Q931_TermWorld(ASN1_CODER_INFO *pWorld);
int Q931_Encode(ASN1_CODER_INFO *pWorld, void *pStruct, int nPDU, BYTE **ppEncoded, DWORD *pcbEncodedSize);
int Q931_Decode(ASN1_CODER_INFO *pWorld, void **ppStruct, int nPDU, BYTE *pEncoded, DWORD cbEncodedSize);

int H245_InitModule(void);
int H245_TermModule(void);
int H245_InitWorld(ASN1_CODER_INFO *pWorld);
int H245_TermWorld(ASN1_CODER_INFO *pWorld);
int H245_Encode(ASN1_CODER_INFO *pWorld, void *pStruct, int nPDU, ASN1_BUF *pBuf);
int H245_Decode(ASN1_CODER_INFO *pWorld, void **ppStruct, int nPDU, ASN1_BUF *pBuf);




__inline int freePDU(ASN1_CODER_INFO *pWorld, int nPDU, void *pDecoded, ASN1module_t pModule)
{
    return pModule->decfree(pWorld->pDecInfo, pDecoded, nPDU);
}


#ifdef __cplusplus
}
#endif

#endif // _MS_AV_ASN1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\h323\t120chan.cpp ===
/*
 *  	File: t120chan.cpp
 *
 *		T.120 implementation of ICommChannel, ICtrlCommChannel 
 *
 *		Revision History:
 *
 *		06/11/97	mikev	created
 *					
 */


#include "precomp.h"

ImpT120Chan::ImpT120Chan()
:m_MediaID(MEDIA_TYPE_H323_T120),
m_pCtlChan(NULL),
m_pCapObject(NULL),
m_pH323ConfAdvise(NULL),
m_dwFlags(COMCH_ENABLED),
dwhChannel(0), 
uRef(1)
{
	ZeroMemory(&local_sin, sizeof(local_sin));
	ZeroMemory(&remote_sin, sizeof(remote_sin));
}

ImpT120Chan::~ImpT120Chan ()
{
}

STDMETHODIMP ImpT120Chan::GetMediaType(LPGUID pGuid)
{
	if(!pGuid)
		return CHAN_E_INVALID_PARAM;
	*pGuid = m_MediaID;
	return hrSuccess;
}

STDMETHODIMP ImpT120Chan::QueryInterface( REFIID iid,	void ** ppvObject)
{
	// this breaks the rules for the official COM QueryInterface because
	// the interfaces that are queried for are not necessarily real COM 
	// interfaces.  The reflexive property of QueryInterface would be broken in 
	// that case.
	
	HRESULT hr = E_NOINTERFACE;
	if(!ppvObject)
		return hr;
		
	*ppvObject = 0;
	if(iid == IID_IUnknown) 
	{
		*ppvObject = this;
		hr = hrSuccess;
		AddRef();
	}
	else if((iid == IID_ICommChannel))
	{
		*ppvObject = (ICommChannel *)this;
		hr = hrSuccess;
		AddRef();
	}
	else if((iid == IID_ICtrlCommChannel))
	{
		*ppvObject = (ICtrlCommChan *)this;
		hr = hrSuccess;
		AddRef();
	}
	return (hr);
}

ULONG ImpT120Chan::AddRef()
{
	uRef++;
	return uRef;
}

ULONG ImpT120Chan::Release()
{
	uRef--;
	if(uRef == 0)
	{
		delete this;
		return 0;
	}
	else
	{
		return uRef;
	}
}

HRESULT ImpT120Chan::BeginControlSession(IControlChannel *pCtlChan, LPIH323PubCap pCapObject)
{
	// this channel is now "in a call".
	m_pCtlChan = pCtlChan;
	m_pCapObject = pCapObject;
	return hrSuccess;
}
HRESULT ImpT120Chan::EndControlSession()
{
	// this channel is no longer "in a call".
	m_pCtlChan = NULL;
	m_pCapObject = NULL;
	return hrSuccess;
}

HRESULT ImpT120Chan::OnChannelClose(DWORD dwStatus)
{
	HRESULT hr = hrSuccess;
	FX_ENTRY("ImpT120Chan::OnChannelClose");
	BOOL fCloseAction = FALSE;

	SHOW_OBJ_ETIME("ImpT120Chan::OnChannelClose");

	m_dwFlags &= ~COMCH_OPEN_PENDING;
	
	switch(dwStatus)
	{
		default:
			ERRORMESSAGE(("%s: unexpected unidirectional notification\r\n", _fx_)); 
		case CHANNEL_CLOSED:
			DEBUGMSG(ZONE_COMMCHAN,("%s:closing\r\n",_fx_));
			if(IsComchOpen())
			{
				fCloseAction = TRUE;
				m_dwFlags &= ~COMCH_OPEN;
			}
			else
			{
				ERRORMESSAGE(("%s: notification when not open\r\n", _fx_)); 
			}
		break;
	}
	// clear general purpose channel handle 
	dwhChannel = 0;
	if(m_pH323ConfAdvise && m_pCtlChan)
	{
		DEBUGMSG(ZONE_COMMCHAN,("%s:issuing notification 0x%08lX\r\n",_fx_, dwStatus));
		m_pH323ConfAdvise->ChannelEvent(this, m_pCtlChan->GetIConnIF(), dwStatus);
	}

	return hr;
}
HRESULT ImpT120Chan::OnChannelOpening()
{
	m_dwFlags |= COMCH_OPEN_PENDING;
	return hrSuccess;
}

HRESULT ImpT120Chan::OnChannelOpen(DWORD dwStatus)
{
	FX_ENTRY("ImpT120Chan::OnChannelOpen");

	SHOW_OBJ_ETIME("ImpICommChan::OnChannelOpen");
	// the open is no longer pending, regardless of success or failure
	m_dwFlags &= ~COMCH_OPEN_PENDING;

	if(IsComchOpen())
	{
		ERRORMESSAGE(("%s: %d notification when open\r\n", _fx_, 
					dwStatus));
	}		
	switch(dwStatus)
	{
		case CHANNEL_OPEN:
			m_dwFlags |= (COMCH_OPEN | COMCH_SUPPRESS_NOTIFICATION);
		break;
			
		default:
			dwStatus = CHANNEL_OPEN_ERROR;
			// fall through to notification
		case CHANNEL_REJECTED:
		case CHANNEL_NO_CAPABILITY:
			goto NOTIFICATION;			
		break;
	}
	
NOTIFICATION:
	if(m_pH323ConfAdvise && m_pCtlChan)
	{
		DEBUGMSG(ZONE_COMMCHAN,("%s:issuing notification 0x%08lX\r\n",_fx_, dwStatus));
		m_pH323ConfAdvise->ChannelEvent(this, m_pCtlChan->GetIConnIF(), dwStatus);
	}
	else
		DEBUGMSG(ZONE_COMMCHAN,("%s: *** not issuing notification 0x%08lX m_pH323ConfAdvise: 0x%08lX, m_pCtlChan:0x%08lX \r\n"
			,_fx_, dwStatus,m_pH323ConfAdvise,m_pCtlChan));
			
	SHOW_OBJ_ETIME("ImpT120Chan::OnChannelOpen - done ");
	return hrSuccess;	

}

BOOL ImpT120Chan::SelectPorts(LPIControlChannel pCtlChannel)
{
	PSOCKADDR_IN psin;
	HRESULT hr;
	hr = pCtlChannel->GetLocalAddress(&psin);
	{
		if(!HR_SUCCEEDED(hr))
			return FALSE;
	}
	local_sin = *psin;
// HACK uses well known port
	local_sin.sin_port = htons(1503);
	return TRUE;
}

HRESULT ImpT120Chan::AcceptRemoteAddress (PSOCKADDR_IN pSin)
{
	if(!pSin)
		return CHAN_E_INVALID_PARAM;
	remote_sin = *pSin;	
	return hrSuccess;
}


STDMETHODIMP ImpT120Chan::GetRemoteAddress(PSOCKADDR_IN pAddrOutput)
{
	if (!pAddrOutput)
	{
		return CHAN_E_INVALID_PARAM;
	}
	*pAddrOutput = remote_sin;
	return hrSuccess;
}

HRESULT ImpT120Chan::EnableOpen(BOOL bEnable)
{
	if(bEnable)
	{
		m_dwFlags |= COMCH_ENABLED;
	}
	else
	{
		m_dwFlags &= ~COMCH_ENABLED;
	}	
	return hrSuccess;
}

HRESULT ImpT120Chan::IsChannelOpen(BOOL *pbOpen)
{
	if(!pbOpen)
		return CHAN_E_INVALID_PARAM;
	*pbOpen = (IsComchOpen()) ? TRUE:FALSE;
	return hrSuccess;	
}

HRESULT ImpT120Chan::Open(MEDIA_FORMAT_ID idLocalFormat, IH323Endpoint *pConnection)
{
    HRESULT hr; 
    IConfAdvise * pConfAdvise = NULL;
    if((m_dwFlags & COMCH_OPEN_PENDING) || IsComchOpen() || !pConnection)
        return CHAN_E_INVALID_PARAM;

    if(!m_pCtlChan) // this channel is not part of a call 
    {
        hr = pConnection->QueryInterface(IID_IConfAdvise, (void **)&pConfAdvise);
        if(!HR_SUCCEEDED(hr))
            goto EXIT;       
        hr = pConfAdvise->AddCommChannel(this);
        if(!HR_SUCCEEDED(hr))
            goto EXIT;  
            
        ASSERT(m_pCtlChan && m_pCapObject);
	}
            
	// Start the control channel stuff needed to open the channel.
	// The media format ID arguments are irrelevant for T.120 channels
	hr = m_pCtlChan->OpenChannel((ICtrlCommChan*)this, m_pCapObject,
		idLocalFormat, INVALID_MEDIA_FORMAT);
    
EXIT:    
    if(pConfAdvise)
        pConfAdvise->Release();
        
	return hr;
}

HRESULT ImpT120Chan::Close()
{
	HRESULT hr = CHAN_E_INVALID_PARAM;
    if(!IsComchOpen() || !m_pCtlChan)
		goto EXIT;

	hr = m_pCtlChan->CloseChannel((ICtrlCommChan*)this);

EXIT:
	return hr;
}

HRESULT ImpT120Chan::SetAdviseInterface(IH323ConfAdvise *pH323ConfAdvise)
{
	if (!pH323ConfAdvise)
	{
		return CHAN_E_INVALID_PARAM;
	}
	m_pH323ConfAdvise = pH323ConfAdvise;	
	return hrSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\intelcc\include\callcont.h ===
/****************************************************************************
 *
 *      $Archive:   S:/STURGEON/SRC/INCLUDE/VCS/callcont.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *      Copyright (c) 1993-1994 Intel Corporation.
 *
 *      $Revision:   1.102  $
 *      $Date:   13 Feb 1997 21:28:38  $
 *      $Author:   MANDREWS  $
 *
 *      Deliverable:
 *
 *      Abstract:
 *              
 *
 *      Notes:
 *
 ***************************************************************************/


#ifndef CALLCONT_H
#define CALLCONT_H

#if defined(CALL_CONTROL_EXPORT)
#define CC_API __declspec (dllexport)
#else // CALL_CONTROL_IMPORT
#define CC_API __declspec (dllimport)
#endif

#pragma pack(push,8)

#ifndef H245API_H
#include "h245api.h"
#endif H245API_H

#ifndef CCERROR_H
#include "ccerror.h"
#endif  CCERROR_H

#ifdef __cplusplus
extern "C" {
#endif

// Indication codes
#define CC_RINGING_INDICATION						1
#define CC_CONNECT_INDICATION						2
#define CC_TX_CHANNEL_OPEN_INDICATION				3
#define CC_RX_CHANNEL_REQUEST_INDICATION			4
#define CC_RX_CHANNEL_CLOSE_INDICATION				5
#define CC_MUTE_INDICATION							6
#define CC_UNMUTE_INDICATION						7
#define CC_PEER_ADD_INDICATION						8
#define CC_PEER_DROP_INDICATION						9
#define CC_PEER_CHANGE_CAP_INDICATION				10
#define CC_CONFERENCE_TERMINATION_INDICATION		11
#define CC_HANGUP_INDICATION						12
#define CC_RX_NONSTANDARD_MESSAGE_INDICATION		13
#define CC_MULTIPOINT_INDICATION					14
#define CC_PEER_UPDATE_INDICATION					15
#define CC_H245_MISCELLANEOUS_COMMAND_INDICATION	16
#define CC_H245_MISCELLANEOUS_INDICATION_INDICATION	17
#define CC_H245_CONFERENCE_REQUEST_INDICATION		18
#define CC_H245_CONFERENCE_RESPONSE_INDICATION		19
#define CC_H245_CONFERENCE_COMMAND_INDICATION		20
#define CC_H245_CONFERENCE_INDICATION_INDICATION	21
#define CC_FLOW_CONTROL_INDICATION					22
#define CC_TX_CHANNEL_CLOSE_REQUEST_INDICATION		23
#define CC_REQUEST_MODE_INDICATION					24
#define CC_REQUEST_MODE_RESPONSE_INDICATION			25
#define CC_VENDOR_ID_INDICATION						26
#define CC_MAXIMUM_AUDIO_VIDEO_SKEW_INDICATION		27
#define CC_T120_CHANNEL_REQUEST_INDICATION			28
#define CC_T120_CHANNEL_OPEN_INDICATION				29
#define CC_BANDWIDTH_CHANGED_INDICATION             30
#define CC_ACCEPT_CHANNEL_INDICATION                31
#define CC_TERMINAL_ID_REQUEST_INDICATION           32
#define CC_PING_RESPONSE_INDICATION					33
#define CC_TERMINAL_NUMBER_INDICATION               34

// Conference configuration values; these are bit mask values
#define CC_CONFIGURE_MULTIPOINT_CAPABLE				0x0001
#define CC_CONFIGURE_FORCE_MC						0x0002

// Timeout type codes
#define CC_Q931_ALERTING_TIMEOUT					1
#define CC_H245_RETRY_COUNT							2
#define CC_H245_TIMEOUT								3

// Conference termination reasons
#define CC_PEER_HANGUP								0
#define CC_GATEKEEPER_HANGUP						1

typedef enum {
	CC_WILL_TRANSMIT_PREFERRED_MODE,
	CC_WILL_TRANSMIT_LESS_PREFERRED_MODE,
	CC_MODE_UNAVAILABLE,
	CC_MULTIPOINT_CONSTRAINT,
	CC_REQUEST_DENIED
} CC_REQUEST_MODE_RESPONSE;

typedef H245_TOTCAP_T   CC_TERMCAP, *PCC_TERMCAP, **PPCC_TERMCAP;

typedef struct {
	WORD					wLength;
	PPCC_TERMCAP			pTermCapArray;
} CC_TERMCAPLIST, *PCC_TERMCAPLIST;

typedef struct {
	WORD					wLength;
	H245_TOTCAPDESC_T		**pTermCapDescriptorArray;
} CC_TERMCAPDESCRIPTORS, *PCC_TERMCAPDESCRIPTORS;

typedef struct {
	BYTE					bMCUNumber;
	BYTE					bTerminalNumber;
} CC_TERMINAL_LABEL, *PCC_TERMINAL_LABEL;

typedef struct {
	CC_TERMINAL_LABEL		TerminalLabel;
	CC_OCTETSTRING			TerminalID;
} CC_PARTICIPANTINFO, *PCC_PARTICIPANTINFO;

typedef struct {
	WORD					wLength;
	PCC_PARTICIPANTINFO		ParticipantInfoArray;
} CC_PARTICIPANTLIST, *PCC_PARTICIPANTLIST;

typedef struct 
{
	BOOL					bMaster;
	BOOL					bMultipointController;
	BOOL					bMultipointConference;
	CC_CONFERENCEID			ConferenceID;
	CC_TERMINAL_LABEL		LocalTerminalLabel;
	WORD					wNumCalls;
	PCC_PARTICIPANTLIST		pParticipantList;
	DWORD					dwConferenceToken;
    DWORD                   dwBandwidthAllocated;
    DWORD                   dwBandwidthUsed;
} CC_CONFERENCEATTRIBUTES, *PCC_CONFERENCEATTRIBUTES;

typedef struct {
	BYTE					bSessionID;
	BYTE					bAssociatedSessionID;
	CC_OCTETSTRING			SessionDescription;
	PCC_TERMCAP				pTermCap;
	PCC_ADDR				pRTPAddr;
	PCC_ADDR				pRTCPAddr;
} CC_SESSIONINFO, *PCC_SESSIONINFO;

typedef struct {
	WORD					wLength;
	PCC_SESSIONINFO			SessionInfoArray;
} CC_SESSIONTABLE, *PCC_SESSIONTABLE;

typedef struct 
{
	CC_HCALL				hCall;
	PCC_ALIASNAMES			pCallerAliasNames;
	PCC_ALIASNAMES			pCalleeAliasNames;
	PCC_NONSTANDARDDATA		pNonStandardData;
	PWSTR					pszDisplay;
	PCC_VENDORINFO			pVendorInfo;
	WORD					wGoal;
	CC_CONFERENCEID			ConferenceID;
	PCC_ADDR				pCallerAddr;
	PCC_ADDR				pCalleeAddr;
	DWORD					dwListenToken;
} CC_LISTEN_CALLBACK_PARAMS, *PCC_LISTEN_CALLBACK_PARAMS;

typedef void *  PCC_CONFERENCE_CALLBACK_PARAMS;


// CC_RINGING_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	PCC_NONSTANDARDDATA		pNonStandardData;
	DWORD					dwUserToken;
} CC_RINGING_CALLBACK_PARAMS, *PCC_RINGING_CALLBACK_PARAMS;

// CC_CONNECT_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	PCC_NONSTANDARDDATA		pNonStandardData;
	PWSTR					pszPeerDisplay;
	BYTE					bRejectReason;
	PCC_TERMCAPLIST			pTermCapList;
	PCC_TERMCAP				pH2250MuxCapability;
	PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors;
	PCC_ADDR				pLocalAddr;
	PCC_ADDR				pPeerAddr;
	PCC_VENDORINFO			pVendorInfo;
	BOOL					bMultipointConference;
	PCC_CONFERENCEID		pConferenceID;
	PCC_ADDR				pMCAddress;
	PCC_ADDR				pAlternateAddress;
	DWORD					dwUserToken;
} CC_CONNECT_CALLBACK_PARAMS, *PCC_CONNECT_CALLBACK_PARAMS;

// CC_TX_CHANNEL_OPEN_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCHANNEL             hChannel;
	PCC_ADDR				pPeerRTPAddr;
	PCC_ADDR				pPeerRTCPAddr;
	DWORD					dwRejectReason;
	DWORD					dwUserToken;
} CC_TX_CHANNEL_OPEN_CALLBACK_PARAMS, *PCC_TX_CHANNEL_OPEN_CALLBACK_PARAMS;

// CC_RX_CHANNEL_REQUEST_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCHANNEL             hChannel;
	PCC_TERMCAP				pChannelCapability;
	BYTE					bSessionID;
	BYTE					bAssociatedSessionID;
	PCC_ADDR	            pPeerRTPAddr;
	PCC_ADDR				pPeerRTCPAddr;
	BYTE					bRTPPayloadType;
	BOOL					bSilenceSuppression;
	CC_TERMINAL_LABEL		TerminalLabel;
} CC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS, *PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS;

// CC_RX_CHANNEL_CLOSE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCHANNEL             hChannel;
} CC_RX_CHANNEL_CLOSE_CALLBACK_PARAMS, *PCC_RX_CHANNEL_CLOSE_CALLBACK_PARAMS;

// CC_MUTE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCHANNEL             hChannel;
} CC_MUTE_CALLBACK_PARAMS, *PCC_MUTE_CALLBACK_PARAMS;

// CC_UNMUTE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCHANNEL             hChannel;
} CC_UNMUTE_CALLBACK_PARAMS, *PCC_UNMUTE_CALLBACK_PARAMS;

// CC_PEER_ADD_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		TerminalLabel;
	PCC_OCTETSTRING			pPeerTerminalID;
} CC_PEER_ADD_CALLBACK_PARAMS, *PCC_PEER_ADD_CALLBACK_PARAMS;

// CC_PEER_DROP_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		TerminalLabel;
	PCC_OCTETSTRING			pPeerTerminalID;
} CC_PEER_DROP_CALLBACK_PARAMS, *PCC_PEER_DROP_CALLBACK_PARAMS;

// CC_PEER_CHANGE_CAP_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	PCC_TERMCAPLIST			pTermCapList;
	PCC_TERMCAP				pH2250MuxCapability;
	PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors;
} CC_PEER_CHANGE_CAP_CALLBACK_PARAMS, *PCC_PEER_CHANGE_CAP_CALLBACK_PARAMS;

// CC_CONFERENCE_TERMINATION_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	DWORD					dwReason;
} CC_CONFERENCE_TERMINATION_CALLBACK_PARAMS, *PCC_CONFERENCE_TERMINATION_CALLBACK_PARAMS;

// CC_HANGUP_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	DWORD					dwUserToken;
} CC_HANGUP_CALLBACK_PARAMS, *PCC_HANGUP_CALLBACK_PARAMS;

// CC_RX_NONSTANDARD_MESSAGE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	BYTE					bH245MessageType;
	CC_NONSTANDARDDATA		NonStandardData;
} CC_RX_NONSTANDARD_MESSAGE_CALLBACK_PARAMS, *PCC_RX_NONSTANDARD_MESSAGE_CALLBACK_PARAMS;

// CC_MULTIPOINT_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	PCC_PARTICIPANTINFO		pTerminalInfo;
	PCC_SESSIONTABLE		pSessionTable;
} CC_MULTIPOINT_CALLBACK_PARAMS, *PCC_MULTIPOINT_CALLBACK_PARAMS;

// CC_PEER_UPDATE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		TerminalLabel;
	PCC_OCTETSTRING			pPeerTerminalID;
} CC_PEER_UPDATE_CALLBACK_PARAMS, *PCC_PEER_UPDATE_CALLBACK_PARAMS;

// CC_H245_MISCELLANEOUS_COMMAND_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	CC_HCHANNEL				hChannel;
	BOOL					bH323ActionRequired;
	MiscellaneousCommand	*pMiscellaneousCommand;
} CC_H245_MISCELLANEOUS_COMMAND_CALLBACK_PARAMS, *PCC_H245_MISCELLANEOUS_COMMAND_CALLBACK_PARAMS;

// CC_H245_MISCELLANEOUS_INDICATION_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	CC_HCHANNEL				hChannel;
	MiscellaneousIndication	*pMiscellaneousIndication;
} CC_H245_MISCELLANEOUS_INDICATION_CALLBACK_PARAMS, *PCC_H245_MISCELLANEOUS_INDICATION_CALLBACK_PARAMS;

// CC_H245_CONFERENCE_REQUEST_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	H245_CONFER_REQ_ENUM_T	RequestType;
	CC_TERMINAL_LABEL		TerminalLabel;
} CC_H245_CONFERENCE_REQUEST_CALLBACK_PARAMS, *PCC_H245_CONFERENCE_REQUEST_CALLBACK_PARAMS;

// CC_H245_CONFERENCE_RESPONSE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	H245_CONFER_RSP_ENUM_T	ResponseType;
	CC_TERMINAL_LABEL		TerminalLabel;
	PCC_OCTETSTRING			pOctetString;
	CC_TERMINAL_LABEL		*pTerminalList;
	WORD					wTerminalListCount;
} CC_H245_CONFERENCE_RESPONSE_CALLBACK_PARAMS, *PCC_H245_CONFERENCE_RESPONSE_CALLBACK_PARAMS;

// CC_H245_CONFERENCE_COMMAND_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	CC_HCHANNEL				hChannel;
	H245_CONFER_CMD_ENUM_T	CommandType;
	CC_TERMINAL_LABEL		TerminalLabel;
} CC_H245_CONFERENCE_COMMAND_CALLBACK_PARAMS, *PCC_H245_CONFERENCE_COMMAND_CALLBACK_PARAMS;

// CC_H245_CONFERENCE_INDICATION_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	H245_CONFER_IND_ENUM_T	IndicationType;
	BYTE					bSBENumber;
	CC_TERMINAL_LABEL		TerminalLabel;
} CC_H245_CONFERENCE_INDICATION_CALLBACK_PARAMS, *PCC_H245_CONFERENCE_INDICATION_CALLBACK_PARAMS;

// CC_FLOW_CONTROL_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCHANNEL				hChannel;
	DWORD					dwRate;
} CC_FLOW_CONTROL_CALLBACK_PARAMS, *PCC_FLOW_CONTROL_CALLBACK_PARAMS;

// CC_TX_CHANNEL_CLOSE_REQUEST_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCHANNEL				hChannel;
} CC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS, *PCC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS;

// CC_REQUEST_MODE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	RequestedModesLink		pRequestedModes;
} CC_REQUEST_MODE_CALLBACK_PARAMS, *PCC_REQUEST_MODE_CALLBACK_PARAMS;

// CC_REQUEST_MODE_RESPONSE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		TerminalLabel;
	CC_REQUEST_MODE_RESPONSE RequestModeResponse;
} CC_REQUEST_MODE_RESPONSE_CALLBACK_PARAMS, *PCC_REQUEST_MODE_RESPONSE_CALLBACK_PARAMS;

// CC_VENDOR_ID_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	PCC_NONSTANDARDDATA		pNonStandardData;
	PCC_OCTETSTRING			pProductNumber;
	PCC_OCTETSTRING			pVersionNumber;
} CC_VENDOR_ID_CALLBACK_PARAMS, *PCC_VENDOR_ID_CALLBACK_PARAMS;

// CC_MAXIMUM_AUDIO_VIDEO_SKEW_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCHANNEL				hChannel1;
	CC_HCHANNEL				hChannel2;
	WORD					wMaximumSkew;
} CC_MAXIMUM_AUDIO_VIDEO_SKEW_CALLBACK_PARAMS, *PCC_MAXIMUM_AUDIO_VIDEO_SKEW_CALLBACK_PARAMS;

// CC_T120_CHANNEL_OPEN_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCHANNEL				hChannel;
	CC_HCALL				hCall;
	BOOL					bAssociateConference;
	PCC_OCTETSTRING			pExternalReference;
	PCC_ADDR				pAddr;
	DWORD					dwRejectReason;
	DWORD					dwUserToken;
} CC_T120_CHANNEL_OPEN_CALLBACK_PARAMS, *PCC_T120_CHANNEL_OPEN_CALLBACK_PARAMS;

// CC_T120_CHANNEL_REQUEST_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCHANNEL				hChannel;
	BOOL					bAssociateConference;
	PCC_OCTETSTRING			pExternalReference;
	PCC_ADDR				pAddr;
	BOOL					bMultipointController;
	CC_TERMINAL_LABEL		TerminalLabel;
} CC_T120_CHANNEL_REQUEST_CALLBACK_PARAMS, *PCC_T120_CHANNEL_REQUEST_CALLBACK_PARAMS;

typedef struct {
	CC_HCALL	            hCall;
	DWORD		            dwBandwidthTotal;
    long                    lBandwidthChange;
} CC_BANDWIDTH_CALLBACK_PARAMS, *PCC_BANDWIDTH_CALLBACK_PARAMS;

// CC_ACCEPT_CHANNEL_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCHANNEL             hChannel;
} CC_ACCEPT_CHANNEL_CALLBACK_PARAMS, *PCC_ACCEPT_CHANNEL_CALLBACK_PARAMS;

// CC_PING_RESPONSE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		TerminalLabel;
	BOOL					bResponse;
} CC_PING_RESPONSE_CALLBACK_PARAMS, *PCC_PING_RESPONSE_CALLBACK_PARAMS;

#ifndef NO_APIS

typedef void (*CC_LISTEN_CALLBACK)(		HRESULT							hStatus,
										PCC_LISTEN_CALLBACK_PARAMS		ListenCallbackParams);

typedef HRESULT (*CC_CONFERENCE_CALLBACK)(
										BYTE							bIndication,
										HRESULT							hStatus,
										CC_HCONFERENCE					hConference,
										DWORD							dwConferenceToken,
										PCC_CONFERENCE_CALLBACK_PARAMS	pConferenceCallbackParams);

typedef HRESULT (*CC_SESSIONTABLE_CONSTRUCTOR)(
										CC_HCONFERENCE					hConference,
										DWORD							dwConferenceToken,
										BOOL							bCreate,
										BOOL							*pbSessionTableChanged,
										WORD							wListCount,
										PCC_TERMCAPLIST					pTermCapList[],
										PCC_TERMCAPDESCRIPTORS			pTermCapDescriptors[],
										PCC_SESSIONTABLE				*ppSessionTable);

typedef HRESULT (*CC_TERMCAP_CONSTRUCTOR)(
										CC_HCONFERENCE					hConference,
										DWORD							dwConferenceToken,
										BOOL							bCreate,
										BOOL							*pbTermCapsChanged,
										WORD							wListCount,
										PCC_TERMCAPLIST					pInTermCapList[],
										PCC_TERMCAPDESCRIPTORS			pInTermCapDescriptors[],
										PCC_TERMCAPLIST					*ppOutTermCapList,
										PCC_TERMCAPDESCRIPTORS			*ppOutTermCapDescriptors);

CC_API
HRESULT CC_AcceptCall(					CC_HCONFERENCE					hConference,
										PCC_NONSTANDARDDATA				pNonStandardData,
										PWSTR							pszDisplay,
										CC_HCALL						hCall,
										DWORD                           dwBandwidth,
										DWORD							dwUserToken);

typedef HRESULT (*CC_ACCEPTCALL)(		CC_HCONFERENCE					hConference,
										PCC_NONSTANDARDDATA				pNonStandardData,
										PWSTR							pszDisplay,
										CC_HCALL						hCall,
                                        DWORD                           dwBandwidth,
										DWORD							dwUserToken);

CC_API
HRESULT CC_AcceptChannel(				CC_HCHANNEL						hChannel,
										PCC_ADDR						pRTPAddr,
										PCC_ADDR						pRTCPAddr,
										DWORD							dwChannelBitRate);
									
typedef HRESULT (*CC_ACCEPTCHANNEL) (	CC_HCHANNEL						hChannel,
										PCC_ADDR						pRTPAddr,
										PCC_ADDR						pRTCPAddr,
										DWORD							dwChannelBitRate);

CC_API
HRESULT CC_AcceptT120Channel(			CC_HCHANNEL						hChannel,
										BOOL							bAssociateConference,
										PCC_OCTETSTRING					pExternalReference,
										PCC_ADDR						pAddr);
									
typedef HRESULT (*CC_ACCEPTT120CHANNEL)(CC_HCHANNEL						hChannel,
										BOOL							bAssociateConference,
										PCC_OCTETSTRING					pExternalReference,
										PCC_ADDR						pAddr);
									
CC_API
HRESULT CC_CallListen(					PCC_HLISTEN						phListen,
										PCC_ADDR						pListenAddr,
										PCC_ALIASNAMES					pLocalAliasNames,
										DWORD							dwListenToken,
										CC_LISTEN_CALLBACK				ListenCallback);

typedef HRESULT (*CC_CALLLISTEN)(		PCC_HLISTEN						phListen,
										PCC_ADDR						pListenAddr,
										PCC_ALIASNAMES					pLocalAliasNames,
										DWORD							dwListenToken,
										CC_LISTEN_CALLBACK				ListenCallback);


CC_API
HRESULT CC_CancelCall(					CC_HCALL						hCall);

typedef HRESULT (*CC_CANCELCALL)(		CC_HCALL						hCall);


CC_API
HRESULT CC_CancelListen(				CC_HLISTEN						hListen);

typedef HRESULT (*CC_CANCELLISTEN)(		CC_HLISTEN						hListen);

CC_API
HRESULT CC_ChangeConferenceCapabilities(
										CC_HCONFERENCE					hConference,
										PCC_TERMCAPLIST					pTermCapList,
										PCC_TERMCAPDESCRIPTORS			pTermCapDescriptors);

typedef HRESULT (*CC_CHANGECONFERENCECAPABILITIES)(
										CC_HCONFERENCE					hConference,
										PCC_TERMCAPLIST					pTermCapList,
										PCC_TERMCAPDESCRIPTORS			pTermCapDescriptors);

CC_API
HRESULT CC_CloseChannel(				CC_HCHANNEL						hChannel);

typedef HRESULT (*CC_CLOSECHANNEL)(		CC_HCHANNEL						hChannel);


CC_API
HRESULT CC_CloseChannelResponse(		CC_HCHANNEL						hChannel,
										BOOL							bWillCloseChannel);

typedef HRESULT (*CC_CLOSECHANNELRESPONSE)(
										CC_HCHANNEL						hChannel,
										BOOL							bWillCloseChannel);

CC_API
HRESULT CC_CreateConference(			PCC_HCONFERENCE					phConference,
										PCC_CONFERENCEID				pConferenceID,
										DWORD							dwConferenceConfiguration,
										PCC_TERMCAPLIST					pTermCapList,
										PCC_TERMCAPDESCRIPTORS			pTermCapDescriptors,
										PCC_VENDORINFO					pVendorInfo,
										PCC_OCTETSTRING					pTerminalID,
										DWORD							dwConferenceToken,
										CC_TERMCAP_CONSTRUCTOR			TermCapConstructor,
										CC_SESSIONTABLE_CONSTRUCTOR		SessionTableConstructor,
										CC_CONFERENCE_CALLBACK			ConferenceCallback);

typedef HRESULT	(*CC_CREATECONFERENCE) (PCC_HCONFERENCE					phConference,
										PCC_CONFERENCEID				pConferenceID,
										DWORD							dwConferenceConfiguration,
										PCC_TERMCAPLIST					pTermCapList,
										PCC_TERMCAPDESCRIPTORS			pTermCapDescriptors,
										PCC_VENDORINFO					pVendorInfo,
										PCC_OCTETSTRING					pTerminalID,
										DWORD							dwConferenceToken,
										CC_TERMCAP_CONSTRUCTOR			TermCapConstructor,
										CC_SESSIONTABLE_CONSTRUCTOR		SessionTableConstructor,
										CC_CONFERENCE_CALLBACK			ConferenceCallback);

CC_API
HRESULT CC_DestroyConference(			CC_HCONFERENCE					hConference,
										BOOL							bAutoAccept);

typedef HRESULT (*CC_DESTROYCONFERENCE)(CC_HCONFERENCE					hConference,
										BOOL							bAutoAccept);

CC_API
HRESULT CC_EnumerateConferences(		PWORD							pwNumConferences,
										CC_HCONFERENCE					ConferenceList[]);

typedef HRESULT (*CC_ENUMERATECONFERENCES)(
										PWORD							pwNumConferences,
										CC_HCONFERENCE					ConferenceList[]);

CC_API
HRESULT CC_FlowControl(					CC_HCHANNEL						hChannel,
										DWORD							dwRate);

typedef HRESULT (*CC_FLOWCONTROL)(		CC_HCHANNEL						hChannel,
										DWORD							dwRate);

CC_API
HRESULT CC_GetCallControlVersion(		WORD							wArraySize,
										PWSTR							pszVersion);

typedef HRESULT (*CC_GETCALLCONTROLVERSION)
									   (WORD							wArraySize,
										PWSTR							pszVersion);

CC_API
HRESULT CC_GetConferenceAttributes(		CC_HCONFERENCE					hConference,
										PCC_CONFERENCEATTRIBUTES		pConferenceAttributes);

typedef HRESULT (*CC_GETCONFERENCEATTRIBUTES) 
									   (CC_HCONFERENCE                  hConference,
									    PCC_CONFERENCEATTRIBUTES        pConferenceAttributes);

CC_API
HRESULT CC_H245ConferenceRequest(		CC_HCALL						hCall,
										H245_CONFER_REQ_ENUM_T			RequestType,
										CC_TERMINAL_LABEL				TerminalLabel);

typedef HRESULT (*CC_H245CONFERENCEREQUEST)(
										CC_HCALL						hCall,
										H245_CONFER_REQ_ENUM_T			RequestType,
										CC_TERMINAL_LABEL				TerminalLabel);

CC_API
HRESULT CC_H245ConferenceResponse(		CC_HCALL						hCall,
										H245_CONFER_RSP_ENUM_T			ResponseType,
										CC_TERMINAL_LABEL				TerminalLabel,
										PCC_OCTETSTRING					pOctetString,
										CC_TERMINAL_LABEL				*pTerminalList,
										WORD							wTerminalListCount);

typedef HRESULT (*CC_H245CONFERENCERESPONSE)(
										CC_HCALL						hCall,
										H245_CONFER_RSP_ENUM_T			ResponseType,
										CC_TERMINAL_LABEL				TerminalLabel,
										PCC_OCTETSTRING					pOctetString,
										CC_TERMINAL_LABEL				*pTerminalList,
										WORD							wTerminalListCount);

CC_API
HRESULT CC_H245ConferenceCommand(		CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										H245_CONFER_CMD_ENUM_T			CommandType,
										CC_TERMINAL_LABEL				TerminalLabel);

typedef HRESULT (*CC_H245CONFERENCECOMMAND)(
										CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										H245_CONFER_CMD_ENUM_T			CommandType,
										CC_TERMINAL_LABEL				TerminalLabel);

CC_API
HRESULT CC_H245ConferenceIndication(	CC_HCALL						hCall,
										H245_CONFER_IND_ENUM_T			IndicationType,
										BYTE							bSBENumber,
										CC_TERMINAL_LABEL				TerminalLabel);

typedef HRESULT (*CC_H245CONFERENCEINDICATION)(
										CC_HCALL						hCall,
										H245_CONFER_IND_ENUM_T			IndicationType,
										BYTE							bSBENumber,
										CC_TERMINAL_LABEL				TerminalLabel);

CC_API
HRESULT CC_H245MiscellaneousCommand(	CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										MiscellaneousCommand			*pMiscellaneousCommand);

typedef HRESULT (*CC_H245MISCELLANEOUSCOMMAND)(
										CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										MiscellaneousCommand			*pMiscellaneousCommand);

CC_API
HRESULT CC_H245MiscellaneousIndication(
										CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										MiscellaneousIndication			*pMiscellaneousIndication);

typedef HRESULT (*CC_H245MISCELLANEOUSINDICATION)(
										CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										MiscellaneousIndication			*pMiscellaneousIndication);

CC_API
HRESULT CC_Hangup(						CC_HCONFERENCE					hConference,
										BOOL							bTerminateConference,
										DWORD							dwUserToken);

typedef HRESULT (*CC_HANGUP)(			CC_HCONFERENCE					hConference,
										BOOL							bTerminateConference,
										DWORD							dwUserToken);

CC_API
HRESULT CC_MaximumAudioVideoSkew(		CC_HCHANNEL						hChannelAudio,
										CC_HCHANNEL						hChannelVideo,
										WORD							wMaximumSkew);

typedef HRESULT (*CC_MAXIMUMAUDIOVIDEOSKEW)(
										CC_HCHANNEL						hChannelAudio,
										CC_HCHANNEL						hChannelVideo,
										WORD							wMaximumSkew);

CC_API
HRESULT CC_Mute(						CC_HCHANNEL						hChannel);

typedef HRESULT (*CC_MUTE)(				CC_HCHANNEL						hChannel);

CC_API
HRESULT CC_OpenChannel(					CC_HCONFERENCE					hConference,
										PCC_HCHANNEL					phChannel,
										BYTE							bSessionID,
										BYTE							bAssociatedSessionID,
										BOOL							bSilenceSuppression,
										PCC_TERMCAP						pTermCap,
										PCC_ADDR						pLocalRTCPAddr,
										BYTE							bDynamicRTPPayloadType,
										DWORD							dwChannelBitRate,
										DWORD							dwUserToken);

typedef HRESULT (*CC_OPENCHANNEL)(		CC_HCONFERENCE					hConference,
										PCC_HCHANNEL					phChannel,
										BYTE							bSessionID,
										BYTE							bAssociatedSessionID,
										BOOL							bSilenceSuppression,
										PCC_TERMCAP						pTermCap,
										PCC_ADDR						pLocalRTCPAddr,
										BYTE							bDynamicRTPPayloadType,
										DWORD							dwChannelBitRate,
										DWORD							dwUserToken);

CC_API
HRESULT CC_OpenT120Channel(				CC_HCONFERENCE					hConference,
                                        PCC_HCHANNEL                    phChannel,
										BOOL							bAssociateConference,
										PCC_OCTETSTRING					pExternalReference,
										PCC_ADDR						pAddr,
										DWORD							dwChannelBitRate,
										DWORD							dwUserToken);

typedef HRESULT (*CC_OPENT120CHANNEL)(	CC_HCONFERENCE					hConference,
                                        PCC_HCHANNEL                    phChannel,
										BOOL							bAssociateConference,
										PCC_OCTETSTRING					pExternalReference,
										PCC_ADDR						pAddr,
										DWORD							dwChannelBitRate,
										DWORD							dwUserToken);

CC_API
HRESULT CC_Ping(						CC_HCALL						hCall,
										DWORD							dwTimeout);

typedef HRESULT (*CC_PING)(				CC_HCALL						hCall,
										DWORD							dwTimeout);

CC_API
HRESULT CC_PlaceCall(					CC_HCONFERENCE					hConference,
										PCC_HCALL						phCall,
										PCC_ALIASNAMES					pLocalAliasNames,
										PCC_ALIASNAMES					pCalleeAliasNames,
										PCC_ALIASNAMES					pCalleeExtraAliasNames,
										PCC_ALIASITEM					pCalleeExtension,
										PCC_NONSTANDARDDATA				pNonStandardData,
										PWSTR							pszDisplay,
										PCC_ADDR						pDestinationAddr,
										PCC_ADDR						pConnectAddr,
										DWORD                           dwBandwidth,
										DWORD							dwUserToken);

typedef HRESULT (*CC_PLACECALL)(		CC_HCONFERENCE					hConference,
										PCC_HCALL						phCall,
										PCC_ALIASNAMES					pLocalAliasNames,
										PCC_ALIASNAMES					pCalleeAliasNames,
										PCC_ALIASNAMES					pCalleeExtraAliasNames,
										PCC_ALIASITEM					pCalleeExtension,
										PCC_NONSTANDARDDATA				pNonStandardData,
										PWSTR							pszDisplay,
										PCC_ADDR						pDestinationAddr,
										PCC_ADDR						pConnectAddr,
										DWORD                           dwBandwidth,
										DWORD							dwUserToken);

CC_API
HRESULT CC_RejectCall(					BYTE							bRejectReason,
										PCC_NONSTANDARDDATA				pNonStandardData,
										CC_HCALL						hCall);

typedef HRESULT (*CC_REJECTCALL)(		BYTE							bRejectReason,
										PCC_NONSTANDARDDATA				pNonStandardData,
										CC_HCALL						hCall);

CC_API
HRESULT CC_RejectChannel(				CC_HCHANNEL						hChannel,
										DWORD							dwRejectReason);

typedef HRESULT (*CC_REJECTCHANNEL)(	CC_HCHANNEL						hChannel,
										DWORD							dwRejectReason);

CC_API
HRESULT CC_RequestMode(					CC_HCALL						hCall,
										WORD							wNumModeDescriptions,
										ModeDescription					ModeDescriptions[]);

typedef HRESULT (*CC_REQUESTMODE)(		CC_HCALL						hCall,
										WORD							wNumModeDescriptions,
										ModeDescription					ModeDescriptions[]);

CC_API
HRESULT CC_RequestModeResponse(			CC_HCALL						hCall,
										CC_REQUEST_MODE_RESPONSE		RequestModeResponse);

typedef HRESULT (*CC_REQUESTMODERESPONSE)(
										CC_HCALL						hCall,
										CC_REQUEST_MODE_RESPONSE		RequestModeResponse);

CC_API
HRESULT CC_SendNonStandardMessage(		CC_HCALL						hCall,
										BYTE							bMessageType,
										CC_NONSTANDARDDATA				NonStandardData);

typedef HRESULT (*CC_SENDNONSTANDARDMESSAGE)(
										CC_HCALL						hCall,
										BYTE							bMessageType,
										CC_NONSTANDARDDATA				NonStandardData);

CC_API
HRESULT CC_SendVendorID(				CC_HCALL						hCall,
										CC_NONSTANDARDDATA				NonStandardData,
										PCC_OCTETSTRING					pProductNumber,
										PCC_OCTETSTRING					pVersionNumber);

typedef HRESULT (*CC_SENDVENDORID)(		CC_HCALL						hCall,
										CC_NONSTANDARDDATA				NonStandardData,
										PCC_OCTETSTRING					pProductNumber,
										PCC_OCTETSTRING					pVersionNumber);
CC_API
HRESULT CC_SetCallControlTimeout(		WORD							wType,
										DWORD							dwDuration);

typedef HRESULT (*CC_SETCALLCONTROLTIMEOUT)
									   (WORD							wType,
										DWORD							dwDuration);

CC_API
HRESULT CC_SetTerminalID(				CC_HCONFERENCE					hConference,
										PCC_OCTETSTRING					pTerminalID);

typedef HRESULT (*CC_SETTERMINALID)(	CC_HCONFERENCE					hConference,
										PCC_OCTETSTRING					pTerminalID);

CC_API
HRESULT CC_Shutdown();
CC_API
HRESULT CC_Initialize();

typedef HRESULT (*CC_SHUTDOWN)();
typedef HRESULT (*CC_INITIALIZE)();

CC_API
HRESULT CC_UnMute(						CC_HCHANNEL						hChannel);

typedef HRESULT (*CC_UNMUTE)(			CC_HCHANNEL						hChannel);

CC_API
HRESULT CC_UpdatePeerList(				CC_HCONFERENCE					hConference);

typedef HRESULT (*CC_UPDATEPEERLIST)(	CC_HCONFERENCE					hConference);

CC_API
HRESULT CC_UserInput(					CC_HCALL						hCall,
										PWSTR							pszUserInput);

typedef HRESULT (*CC_USERINPUT)(		CC_HCALL						hCall,
										PWSTR							pszUserInput);


// structure used for holding the entry points to the CallControl module
typedef struct _CALLCONTROLAPI
{
	CC_ACCEPTCALL							CC_AcceptCall;
	CC_ACCEPTCHANNEL						CC_AcceptChannel;
	CC_ACCEPTT120CHANNEL					CC_AcceptT120Channel;
	CC_CALLLISTEN                           CC_CallListen;
	CC_CANCELCALL                           CC_CancelCall;
	CC_CANCELLISTEN                         CC_CancelListen;
	CC_CLOSECHANNEL                         CC_CloseChannel;
	CC_CLOSECHANNELRESPONSE					CC_CloseChannelResponse;
	CC_CHANGECONFERENCECAPABILITIES			CC_ChangeConferenceCapabilities;
	CC_CREATECONFERENCE                     CC_CreateConference;
	CC_DESTROYCONFERENCE					CC_DestroyConference;
	CC_ENUMERATECONFERENCES					CC_EnumerateConferences;
	CC_FLOWCONTROL							CC_FlowControl;
	CC_GETCALLCONTROLVERSION				CC_GetCallControlVersion;
	CC_GETCONFERENCEATTRIBUTES				CC_GetConferenceAttributes;
	CC_H245CONFERENCEREQUEST				CC_H245ConferenceRequest;
	CC_H245CONFERENCERESPONSE				CC_H245ConferenceResponse;
	CC_H245CONFERENCECOMMAND				CC_H245ConferenceCommand;
	CC_H245CONFERENCEINDICATION				CC_H245ConferenceIndication;
	CC_H245MISCELLANEOUSCOMMAND				CC_H245MiscellaneousCommand;
	CC_H245MISCELLANEOUSINDICATION			CC_H245MiscellaneousIndication;
	CC_HANGUP                               CC_Hangup;
	CC_MAXIMUMAUDIOVIDEOSKEW				CC_MaximumAudioVideoSkew;
	CC_MUTE                                 CC_Mute;
	CC_OPENCHANNEL                          CC_OpenChannel;
	CC_OPENT120CHANNEL						CC_OpenT120Channel;
	CC_PING									CC_Ping;
	CC_PLACECALL                            CC_PlaceCall;
	CC_REJECTCALL							CC_RejectCall;
	CC_REJECTCHANNEL						CC_RejectChannel;
	CC_REQUESTMODE							CC_RequestMode;
	CC_REQUESTMODERESPONSE					CC_RequestModeResponse;
	CC_SENDNONSTANDARDMESSAGE				CC_SendNonStandardMessage;
	CC_SENDVENDORID							CC_SendVendorID;
	CC_SETCALLCONTROLTIMEOUT				CC_SetCallControlTimeout;
	CC_SETTERMINALID						CC_SetTerminalID;
	CC_SHUTDOWN								CC_Shutdown;
	CC_INITIALIZE                           CC_Initialize;
	CC_UNMUTE                               CC_UnMute;
	CC_UPDATEPEERLIST						CC_UpdatePeerList;
	CC_USERINPUT							CC_UserInput;
} CALLCONTROLAPI, *LPCALLCONTROLAPI; 

#endif


#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif CALLCONT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\intelcc\include\gkicom.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1997 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *																	   *
 *	$Archive:   S:\sturgeon\src\include\vcs\gkicom.h_v  $
 *
 *	$Revision:   1.3  $
 *	$Date:   10 Jan 1997 17:41:10  $
 *
 *	$Author:   CHULME  $
 *
 *  $Log:   S:\sturgeon\src\include\vcs\gkicom.h_v  $
 * 
 *    Rev 1.3   10 Jan 1997 17:41:10   CHULME
 * Changed CallReturnInfo structure to contain CRV and conferenceID
 * 
 *    Rev 1.2   10 Jan 1997 16:06:54   CHULME
 * Removed stdafx.h check for non MFC GKI implementation
 * 
 *    Rev 1.1   27 Dec 1996 14:37:22   EHOWARDX
 * Split out error codes into GKIERROR.H.
 * 
 *    Rev 1.0   11 Dec 1996 14:49:48   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.9   09 Dec 1996 14:13:38   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.8   22 Nov 1996 15:25:44   CHULME
 * Added VCS log to the header
 *                                                                     * 
 ***********************************************************************/

// gkicom.h : common includes between gkitest and gki
/////////////////////////////////////////////////////////////////////////////

#ifndef GKICOM_H
#define GKICOM_H

#include "apierror.h"
#include "gkierror.h"
#include "gkpdu.h"
#include "gk_asn1.h"

// The following GKVER_xxx constants define the expiration date of GKI.DLL
#define GKVER_EXPIRE_YEAR          1997
#define GKVER_EXPIRE_MONTH         10
#define GKVER_EXPIRE_DAY           31

typedef struct SeqTransportAddr {
	struct SeqTransportAddr	*next;
	TransportAddress		value;
} SeqTransportAddr;

typedef struct SeqAliasAddr {
	struct SeqAliasAddr		*next;
	AliasAddress			value;
} SeqAliasAddr;

typedef struct CallReturnInfo {
	HANDLE					hCall;
	CallModel				callModel;
	TransportAddress		destCallSignalAddress;
	BandWidth				bandWidth;
	CallReferenceValue		callReferenceValue;
	ConferenceIdentifier	conferenceID;
	WORD					wError;
} CallReturnInfo;

// Version Information for GKI Interface
#define GKI_VERSION				21	// TBD - reset to 1 after testing

// wMsg literals - these are added to the wBaseMessage supplied by the user
#define GKI_REG_CONFIRM			1
#define GKI_REG_DISCOVERY		2
#define GKI_REG_REJECT			3
#define GKI_REG_BYPASS			4

#define GKI_UNREG_CONFIRM		5
#define GKI_UNREG_REJECT		6

#define GKI_ADM_CONFIRM			7
#define GKI_ADM_REJECT			8

#define GKI_BW_CONFIRM			9
#define GKI_BW_REJECT			0xa

#define GKI_DISENG_CONFIRM		0xb
#define GKI_DISENG_REJECT		0xc

#define GKI_LOCATION_CONFIRM	0xd
#define GKI_LOCATION_REJECT		0xe

#define GKI_ERROR				0xf
#define MAX_ASYNC_MSGS			0xf

#define HR_SEVERITY_MASK				0x80000000
#define HR_R_MASK						0x40000000
#define HR_C_MASK						0x20000000
#define HR_N_MASK						0x10000000
#define HR_R2_MASK						0x08000000
#define HR_FACILITY_MASK				0x07ff0000
#define HR_CODE_MASK					0x0000ffff

#endif // GKICOM_H

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\intelcc\include\gk_asn1.h ===
#ifndef _GK_ASN1_H_
#define _GK_ASN1_H_

#include "av_asn1.h"
#include "gkpdu.h"

#ifdef __cplusplus
extern "C" {
#endif


// GatekeeperInfo, H310Caps, H320Caps, H321Caps, H322Caps, H323Caps, H324Caps, VoiceCaps, T120OnlyCaps, McuInfo, TerminalInfo
#define GtkprInf_nnStndrdDt_present     GatekeeperInfo_nonStandardData_present
#define GtkprInf_nnStndrdDt             nonStandardData

// GatewayInfo
#define GtwyInf_nonStandardData_present GatewayInfo_nonStandardData_present
#define GtwyInf_nonStandardData         nonStandardData
#define _seqof2                         GatewayInfo_protocol

// EndpointType
#define EndpntTyp_nnStndrdDt_present    EndpointType_nonStandardData_present
#define EndpntTyp_nnStndrdDt            nonStandardData

// GatekeeperRequest
#define GtkprRqst_nnStndrdDt_present    GatekeeperRequest_nonStandardData_present
#define GtkprRqst_gtkprIdntfr_present   GatekeeperRequest_gatekeeperIdentifier_present
#define GtkprRqst_callServices_present  GatekeeperRequest_callServices_present
#define GtkprRqst_endpointAlias_present GatekeeperRequest_endpointAlias_present
#define GtkprRqst_nnStndrdDt            nonStandardData
#define GtkprRqst_gtkprIdntfr           gatekeeperIdentifier
#define GtkprRqst_callServices          callServices
#define GtkprRqst_endpointAlias         endpointAlias
#define _seqof3                         GatekeeperRequest_endpointAlias

// GatekeeperConfirm
#define GtkprCnfrm_nnStndrdDt_present   GatekeeperConfirm_nonStandardData_present
#define GtkprCnfrm_gtkprIdntfr_present  GatekeeperConfirm_gatekeeperIdentifier_present
#define GtkprCnfrm_nnStndrdDt           nonStandardData
#define GtkprCnfrm_gtkprIdntfr          gatekeeperIdentifier

// GatekeeperRejectReason
#define GtkprRjctRsn_rsrcUnvlbl_chosen  GatekeeperRejectReason_resourceUnavailable_chosen
#define GtkprRjctRsn_invldRvsn_chosen   GatekeeperRejectReason_invalidRevision_chosen
#define GtkprRjctRsn_undfndRsn_chosen   GatekeeperRejectReason_undefinedReason_chosen

// GatekeeperReject
#define GtkprRjct_nnStndrdDt_present    GatekeeperReject_nonStandardData_present
#define GtkprRjct_gtkprIdntfr_present   GatekeeperReject_gatekeeperIdentifier_present
#define GtkprRjct_nnStndrdDt            nonStandardData
#define GtkprRjct_gtkprIdntfr           gatekeeperIdentifier

// RegistrationRequest
#define RgstrtnRqst_nnStndrdDt_present  RegistrationRequest_nonStandardData_present
#define RgstrtnRqst_trmnlAls_present    RegistrationRequest_terminalAlias_present
#define RgstrtnRqst_gtkprIdntfr_present RegistrationRequest_gatekeeperIdentifier_present
#define RgstrtnRqst_nnStndrdDt          nonStandardData
#define _seqof4                         RegistrationRequest_callSignalAddress
#define _seqof5                         RegistrationRequest_rasAddress
#define _seqof6                         RegistrationRequest_terminalAlias
#define RgstrtnRqst_trmnlAls            terminalAlias
#define RgstrtnRqst_gtkprIdntfr         gatekeeperIdentifier

// RegistrationConfirm
#define RgstrtnCnfrm_nnStndrdDt_present RegistrationConfirm_nonStandardData_present
#define RgstrtnCnfrm_trmnlAls_present   RegistrationConfirm_terminalAlias_present
#define RCm_gtkprIdntfr_present         RegistrationConfirm_gatekeeperIdentifier_present
#define RgstrtnCnfrm_nnStndrdDt         nonStandardData
#define _seqof7                         RegistrationConfirm_callSignalAddress
#define _seqof8                         RegistrationConfirm_terminalAlias
#define RgstrtnCnfrm_trmnlAls           terminalAlias
#define RCm_gtkprIdntfr                 gatekeeperIdentifier

// RegistrationRejectReason
#define RgstrtnRjctRsn_invldRvsn_chosen RegistrationRejectReason_invalidRevision_chosen
#define RgstrtnRjctRsn_undfndRsn_chosen RegistrationRejectReason_undefinedReason_chosen
#define _seqof9                         RegistrationRejectReason_duplicateAlias

// RegistrationReject
#define RgstrtnRjct_nnStndrdDt_present  RegistrationReject_nonStandardData_present
#define RgstrtnRjct_gtkprIdntfr_present RegistrationReject_gatekeeperIdentifier_present
#define RgstrtnRjct_nnStndrdDt          nonStandardData
#define RgstrtnRjct_gtkprIdntfr         gatekeeperIdentifier

// UnregistrationRequest
#define UnrgstrtnRqst_endpntAls_present UnregistrationRequest_endpointAlias_present
#define URt_nnStndrdDt_1_present        UnregistrationRequest_nonStandardData_present
#define URt_endpntIdntfr_present        UnregistrationRequest_endpointIdentifier_present
#define _seqof10                        UnregistrationRequest_callSignalAddress
#define _seqof11                        UnregistrationRequest_endpointAlias
#define UnrgstrtnRqst_endpntAls         endpointAlias
#define URt_nnStndrdDt_1                nonStandardData
#define URt_endpntIdntfr                endpointIdentifier

// UnregistrationConfirm
#define UCm_nnStndrdDt_present          UnregistrationConfirm_nonStandardData_present
#define UCm_nnStndrdDt                  nonStandardData

// UnregRejectReason
#define UnrgRjctRsn_undfndRsn_chosen    UnregRejectReason_undefinedReason_chosen

// UnregistrationReject
#define URt_nnStndrdDt_2_present        UnregistrationReject_nonStandardData_present
#define URt_nnStndrdDt_2                nonStandardData

// AdmissionRequest
#define AdmssnRqst_nnStndrdDt_present   AdmissionRequest_nonStandardData_present
#define AdmssnRqst_callServices_present AdmissionRequest_callServices_present
#define _seqof12                        AdmissionRequest_destinationInfo
#define _seqof13                        AdmissionRequest_destExtraCallInfo
#define _seqof14                        AdmissionRequest_srcInfo
#define AdmssnRqst_nnStndrdDt           nonStandardData
#define AdmssnRqst_callServices         callServices

// AdmissionConfirm
#define AdmssnCnfrm_nnStndrdDt_present  AdmissionConfirm_nonStandardData_present
#define AdmssnCnfrm_nnStndrdDt          nonStandardData

// AdmissionRejectReason
#define ARRn_invldPrmssn_chosen         AdmissionRejectReason_invalidPermission_chosen
#define AdmssnRjctRsn_rqstDnd_chosen    AdmissionRejectReason_requestDenied_chosen
#define AdmssnRjctRsn_undfndRsn_chosen  AdmissionRejectReason_undefinedReason_chosen
#define invldEndpntIdntfr_chosen        invalidEndpointIdentifier_chosen
#define AdmssnRjctRsn_rsrcUnvlbl_chosen AdmissionRejectReason_resourceUnavailable_chosen

// AdmissionReject
#define AdmssnRjct_nnStndrdDt_present   AdmissionReject_nonStandardData_present
#define AdmssnRjct_nnStndrdDt           nonStandardData

// BandwidthRequest
#define BndwdthRqst_nnStndrdDt_present  BandwidthRequest_nonStandardData_present
#define BndwdthRqst_nnStndrdDt          nonStandardData

// BandwidthConfirm
#define BndwdthCnfrm_nnStndrdDt_present BandwidthConfirm_nonStandardData_present
#define BndwdthCnfrm_nnStndrdDt         nonStandardData

// BandRejectReason
#define BndRjctRsn_invldPrmssn_chosen   BandRejectReason_invalidPermission_chosen
#define BndRjctRsn_invldRvsn_chosen     BandRejectReason_invalidRevision_chosen
#define BndRjctRsn_undfndRsn_chosen     BandRejectReason_undefinedReason_chosen

// BandwidthReject
#define BndwdthRjct_nnStndrdDt_present  BandwidthReject_nonStandardData_present
#define BndwdthRjct_nnStndrdDt          nonStandardData

// DisengageReason
#define DsnggRsn_undefinedReason_chosen DisengageReason_undefinedReason_chosen

// DisengageRequest
#define DsnggRqst_nnStndrdDt_present    DisengageRequest_nonStandardData_present
#define DsnggRqst_nnStndrdDt            nonStandardData

// DisengageConfirm
// #define UCm_nnStndrdDt_present          DisengageConfirm_nonStandardData_present
#define UCm_nnStndrdDt                  nonStandardData

// DisengageRejectReason
#define DsnggRjctRsn_ntRgstrd_chosen    DisengageRejectReason_notRegistered_chosen

// DisengageReject
#define DsnggRjct_nnStndrdDt_present    DisengageReject_nonStandardData_present
#define DsnggRjct_nnStndrdDt            nonStandardData

// LocationRequest
#define LctnRqst_endpntIdntfr_present   LocationRequest_endpointIdentifier_present
#define LctnRqst_nnStndrdDt_present     LocationRequest_nonStandardData_present
#define LctnRqst_endpntIdntfr           endpointIdentifier
#define _seqof15                        LocationRequest_destinationInfo
#define LctnRqst_nnStndrdDt             nonStandardData

// LocationConfirm
#define LctnCnfrm_nnStndrdDt_present    LocationConfirm_nonStandardData_present
#define LctnCnfrm_nnStndrdDt            nonStandardData

// LocationRejectReason
#define LctnRjctRsn_ntRgstrd_chosen     LocationRejectReason_notRegistered_chosen
#define LctnRjctRsn_invldPrmssn_chosen  LocationRejectReason_invalidPermission_chosen
#define LctnRjctRsn_rqstDnd_chosen      LocationRejectReason_requestDenied_chosen
#define LctnRjctRsn_undfndRsn_chosen    LocationRejectReason_undefinedReason_chosen

// LocationReject
#define LctnRjct_nnStndrdDt_present     LocationReject_nonStandardData_present
#define LctnRjct_nnStndrdDt             nonStandardData

// InfoRequest
#define InfRqst_nonStandardData_present InfoRequest_nonStandardData_present
#define InfRqst_nonStandardData         nonStandardData

// InfoRequestResponse
#define InfRqstRspns_nnStndrdDt_present InfoRequestResponse_nonStandardData_present
#define InfRqstRspns_endpntAls_present  InfoRequestResponse_endpointAlias_present
#define InfRqstRspns_nnStndrdDt         nonStandardData
#define _seqof20                        InfoRequestResponse_callSignalAddress
#define _seqof21                        InfoRequestResponse_endpointAlias
#define InfRqstRspns_endpntAls          endpointAlias
#define _seqof22                        InfoRequestResponse_perCallInfo

// _seqof22 vs InfoRequestResponse_perCallInfo_Seq
#define prCllInf_nnStndrdDt_present     InfoRequestResponse_perCallInfo_Seq_nonStandardData_present
#define prCllInf_nnStndrdDt             nonStandardData


#ifdef __cplusplus
}
#endif


#endif // _GK_ASN1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\intelcc\include\coder.hpp ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1997 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *																	   *
 *	$Archive:   S:\sturgeon\src\include\vcs\coder.hpv  $
 *
 *	$Revision:   1.4  $
 *	$Date:   16 Jan 1997 15:25:06  $
 *
 *	$Author:   BPOLING  $
 *
 *	$Log:   S:\sturgeon\src\include\vcs\coder.hpv  $
// 
//    Rev 1.4   16 Jan 1997 15:25:06   BPOLING
// changed copyrights to 1997
// 
//    Rev 1.3   18 Dec 1996 21:49:58   BPOLING
// builds with msdev and for windows only
// 
//    Rev 1.2   09 Dec 1996 14:13:54   EHOWARDX
// Updated copyright notice.
 * 
 *    Rev 1.1   15 Nov 1996 16:16:14   BPOLING
 * vcs header added.
 *                                                                     *
 ***********************************************************************
 *																	   *
 *	coder.hpp														   *
 *																	   * 
 *	PURPOSE:	Encode/Decode ANS.1 Gatekeeper PDU using the OSS ANS.1 *
 *				compiler functions.									   *
 *																	   *
 *	FUNCTIONS:														   *
 *																	   *
 *	COMMENTS: 														   *
 *																	   *
 ***********************************************************************/

/************************************************************************
 * 						Include Files		           				   	*
 ***********************************************************************/

/************************************************************************
 * 						Manifest Constants								*
 ***********************************************************************/
																			
/************************************************************************
*						GLOBAL VARIABLES								*
************************************************************************/

/************************************************************************
 * 						Class Definitions								*
 ***********************************************************************/

#ifndef _CODER_HPP
#define _CODER_HPP

#include "av_asn1.h"
#include "gk_asn1.h"

extern "C" {
int GK_InitModule(void);
int GK_TermModule(void);
int GK_InitWorld(ASN1_CODER_INFO *pWorld);
int GK_TermWorld(ASN1_CODER_INFO *pWorld);
int GK_Encode(ASN1_CODER_INFO *pWorld, void *pStruct, int nPDU, ASN1_BUF *pBuf);
int GK_Decode(ASN1_CODER_INFO *pWorld, void **ppStruct, int nPDU, ASN1_BUF *pBuf);
}

//  DEBUG OPTIONS
#define CODER_DEBUG		  0x00000001
#define CODER_SUPER_DEBUG 0x00000002

// Coder Error Messages

#define CODER_NOERROR 0
#define CODER_ERROR   1

// Protocol version information
#define ITU_T			0
#define RECOMMENDATION	0
#define SERIES			8     // H225.0
#define RECOMM_NUMBER   2250
#define VERSION         0
#define ADDITIONAL      1


typedef struct InfoRequestResponse_perCallInfo      SEQPERCALLINFO, *PSEQPERCALLINFO;

typedef struct _seqtransadds{
    struct _seqtransadds  	*next;
    TransportAddress 		value;
} SEQTRANSADDS, *PSEQTRANSADDS;

typedef struct _seqaliasadds {
    struct _seqaliasadds  	*next;
    AliasAddress    		value;
} SEQALIASADDS, *PSEQALIASADDS;

class Coder{

private:
	ASN1_CODER_INFO		m_World;
	CRITICAL_SECTION	m_critSec;

public:
	struct ObjectID_ m_protocolIdentifier1,m_protocolIdentifier2,m_protocolIdentifier3,
		             m_protocolIdentifier4,m_protocolIdentifier5,m_protocolIdentifier6;

public:
	Coder();
	~Coder();

	int InitCoder();
	// Creates an OssBuf
	int Encode(RasMessage *pInputData, ASN1_BUF *pOutputOssBuf);
	// Create memory to hold decoded OssBuf
	// For H323 this is a rasStruct
	int Decode(ASN1_BUF *pInputOssBuf, RasMessage **pOutputData);
	// Used to free buffer created by decode
	int Free(RasMessage *pData);
	// Used to free buffer created by encode
	void Free(ASN1_BUF Asn1Buf);
	// Returns the sequence number out of any RasMessage
	// Returns zero on error
	RequestSeqNum GetSequenceNumber(RasMessage *prasStruct);
	RequestSeqNum SetSequenceNumber(RasMessage &rasStruct,RequestSeqNum reqNum);
	// Returns a pointer EndpointIdentifier for any RasMessage
	// NULL for RasMessage that have no EndpointIdentifier
	EndpointIdentifier *GetEndpointID(RasMessage *prasStruct);
	// Returns a pointer to a valid H323 protocolIdentifier linked list 
	// when a valid Rasmessage is passed in and sets the protocol Identifier
	// item in RasMessages that have an protocol Identifier
	// If in an RasMessage that doesn't have a protocol identifer is passed in,
	// NULL is returned.
	ProtocolIdentifier SetProtocolIdentifier(RasMessage &rasStruct);
	// Returns TRUE if protocols match, FALSE - otherwise
	BOOL VerifyProtocolIdentifier(RasMessage &rasStruct);
	// finds the requested protocol rasAddress and copies it
	DWORD CopyRasAddress(TransportAddress *pDestAddress, RasMessage *prasStruct, unsigned short choice);
	DWORD CopyRasAddress(TransportAddress *pDestAddress, PSEQTRANSADDS pSrcSeqRasAddress, unsigned short choice);
	// finds the requested protocol callSignalAddress and copies it
	DWORD CopyCallSignal(TransportAddress *pCallSignalAddress, RasMessage *prasStruct, unsigned short choice);
	DWORD CopyCallSignal(TransportAddress *pDestCallSignalAddress, PSEQTRANSADDS pSrcSeqCSAAddress, unsigned short choice);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\intelcc\include\gkpdu.h ===
#ifndef _GKPDU_Module_H_
#define _GKPDU_Module_H_

#include "nmasn1.h"
#ifdef __cplusplus
extern "C" {
#endif

typedef struct TransportAddress_ipSourceRoute_route * PTransportAddress_ipSourceRoute_route;

typedef struct RTPSession_associatedSessionIds * PRTPSession_associatedSessionIds;

typedef struct InfoRequestResponse_endpointAlias * PInfoRequestResponse_endpointAlias;

typedef struct LocationRequest_destinationInfo * PLocationRequest_destinationInfo;

typedef struct AdmissionRequest_srcInfo * PAdmissionRequest_srcInfo;

typedef struct AdmissionRequest_destExtraCallInfo * PAdmissionRequest_destExtraCallInfo;

typedef struct AdmissionRequest_destinationInfo * PAdmissionRequest_destinationInfo;

typedef struct UnregistrationRequest_endpointAlias * PUnregistrationRequest_endpointAlias;

typedef struct RegistrationRejectReason_duplicateAlias * PRegistrationRejectReason_duplicateAlias;

typedef struct RegistrationConfirm_terminalAlias * PRegistrationConfirm_terminalAlias;

typedef struct RegistrationRequest_terminalAlias * PRegistrationRequest_terminalAlias;

typedef struct GatekeeperRequest_endpointAlias * PGatekeeperRequest_endpointAlias;

typedef struct InfoRequestResponse_perCallInfo_Seq_data * PInfoRequestResponse_perCallInfo_Seq_data;

typedef struct InfoRequestResponse_perCallInfo_Seq_video * PInfoRequestResponse_perCallInfo_Seq_video;

typedef struct InfoRequestResponse_perCallInfo_Seq_audio * PInfoRequestResponse_perCallInfo_Seq_audio;

typedef struct InfoRequestResponse_perCallInfo * PInfoRequestResponse_perCallInfo;

typedef struct InfoRequestResponse_callSignalAddress * PInfoRequestResponse_callSignalAddress;

typedef struct UnregistrationRequest_callSignalAddress * PUnregistrationRequest_callSignalAddress;

typedef struct RegistrationConfirm_callSignalAddress * PRegistrationConfirm_callSignalAddress;

typedef struct RegistrationRequest_rasAddress * PRegistrationRequest_rasAddress;

typedef struct RegistrationRequest_callSignalAddress * PRegistrationRequest_callSignalAddress;

typedef struct GatewayInfo_protocol * PGatewayInfo_protocol;

typedef struct TransportAddress_ipSourceRoute_route_Seq {
    ASN1uint32_t length;
    ASN1octet_t value[4];
} TransportAddress_ipSourceRoute_route_Seq;

typedef ASN1uint16_t RTPSession_associatedSessionIds_Seq;

typedef struct ConferenceIdentifier {
    ASN1uint32_t length;
    ASN1octet_t value[16];
} ConferenceIdentifier;

typedef ASN1uint16_t RequestSeqNum;

typedef ASN1char16string_t GatekeeperIdentifier;

typedef ASN1uint32_t BandWidth;

typedef ASN1uint16_t CallReferenceValue;

typedef ASN1char16string_t EndpointIdentifier;

typedef ASN1objectidentifier_t ProtocolIdentifier;

typedef struct TransportAddress_ipSourceRoute_routing {
    ASN1choice_t choice;
#   define strict_chosen 1
#   define loose_chosen 2
} TransportAddress_ipSourceRoute_routing;

typedef struct TransportAddress_ipSourceRoute_route {
    PTransportAddress_ipSourceRoute_route next;
    TransportAddress_ipSourceRoute_route_Seq value;
} TransportAddress_ipSourceRoute_route_Element;

typedef struct RTPSession_associatedSessionIds {
    PRTPSession_associatedSessionIds next;
    RTPSession_associatedSessionIds_Seq value;
} RTPSession_associatedSessionIds_Element;

typedef struct TransportAddress_ip6Address {
    struct TransportAddress_ip6Address_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } ip;
    ASN1uint16_t port;
} TransportAddress_ip6Address;

typedef struct TransportAddress_ipxAddress {
    struct TransportAddress_ipxAddress_node_node {
	ASN1uint32_t length;
	ASN1octet_t value[6];
    } node;
    struct TransportAddress_ipxAddress_netnum_netnum {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } netnum;
    struct TransportAddress_ipxAddress_port_port {
	ASN1uint32_t length;
	ASN1octet_t value[2];
    } port;
} TransportAddress_ipxAddress;

typedef struct TransportAddress_ipSourceRoute {
    struct TransportAddress_ipSourceRoute_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } ip;
    ASN1uint16_t port;
    PTransportAddress_ipSourceRoute_route route;
    TransportAddress_ipSourceRoute_routing routing;
} TransportAddress_ipSourceRoute;

typedef struct TransportAddress_ipAddress {
    struct TransportAddress_ipAddress_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } ip;
    ASN1uint16_t port;
} TransportAddress_ipAddress;

typedef struct AliasAddress {
    ASN1choice_t choice;
    union {
#	define e164_chosen 1
	ASN1char_t e164[129];
#	define h323_ID_chosen 2
	ASN1char16string_t h323_ID;
    } u;
} AliasAddress;

typedef struct Q954Details {
    ASN1bool_t conferenceCalling;
    ASN1bool_t threePartyService;
} Q954Details;

typedef struct H221NonStandard {
    ASN1uint16_t t35CountryCode;
    ASN1uint16_t t35Extension;
    ASN1uint16_t manufacturerCode;
} H221NonStandard;

typedef struct NonStandardIdentifier {
    ASN1choice_t choice;
    union {
#	define object_chosen 1
	ASN1objectidentifier_t object;
#	define h221NonStandard_chosen 2
	H221NonStandard h221NonStandard;
    } u;
} NonStandardIdentifier;

typedef struct GatekeeperRejectReason {
    ASN1choice_t choice;
#   define GatekeeperRejectReason_resourceUnavailable_chosen 1
#   define terminalExcluded_chosen 2
#   define GatekeeperRejectReason_invalidRevision_chosen 3
#   define GatekeeperRejectReason_undefinedReason_chosen 4
} GatekeeperRejectReason;

typedef struct RegistrationRejectReason {
    ASN1choice_t choice;
    union {
#	define discoveryRequired_chosen 1
#	define RegistrationRejectReason_invalidRevision_chosen 2
#	define invalidCallSignalAddress_chosen 3
#	define invalidRASAddress_chosen 4
#	define duplicateAlias_chosen 5
	PRegistrationRejectReason_duplicateAlias duplicateAlias;
#	define invalidTerminalType_chosen 6
#	define RegistrationRejectReason_undefinedReason_chosen 7
#	define transportNotSupported_chosen 8
    } u;
} RegistrationRejectReason;

typedef struct UnregRejectReason {
    ASN1choice_t choice;
#   define notCurrentlyRegistered_chosen 1
#   define callInProgress_chosen 2
#   define UnregRejectReason_undefinedReason_chosen 3
} UnregRejectReason;

typedef struct CallType {
    ASN1choice_t choice;
#   define pointToPoint_chosen 1
#   define oneToN_chosen 2
#   define nToOne_chosen 3
#   define nToN_chosen 4
} CallType;

typedef struct CallModel {
    ASN1choice_t choice;
#   define direct_chosen 1
#   define gatekeeperRouted_chosen 2
} CallModel;

typedef struct AdmissionRejectReason {
    ASN1choice_t choice;
#   define calledPartyNotRegistered_chosen 1
#   define AdmissionRejectReason_invalidPermission_chosen 2
#   define AdmissionRejectReason_requestDenied_chosen 3
#   define AdmissionRejectReason_undefinedReason_chosen 4
#   define callerNotRegistered_chosen 5
#   define routeCallToGatekeeper_chosen 6
#   define invalidEndpointIdentifier_chosen 7
#   define AdmissionRejectReason_resourceUnavailable_chosen 8
} AdmissionRejectReason;

typedef struct BandRejectReason {
    ASN1choice_t choice;
#   define notBound_chosen 1
#   define invalidConferenceID_chosen 2
#   define BandRejectReason_invalidPermission_chosen 3
#   define insufficientResources_chosen 4
#   define BandRejectReason_invalidRevision_chosen 5
#   define BandRejectReason_undefinedReason_chosen 6
} BandRejectReason;

typedef struct LocationRejectReason {
    ASN1choice_t choice;
#   define LocationRejectReason_notRegistered_chosen 1
#   define LocationRejectReason_invalidPermission_chosen 2
#   define LocationRejectReason_requestDenied_chosen 3
#   define LocationRejectReason_undefinedReason_chosen 4
} LocationRejectReason;

typedef struct DisengageReason {
    ASN1choice_t choice;
#   define forcedDrop_chosen 1
#   define normalDrop_chosen 2
#   define DisengageReason_undefinedReason_chosen 3
} DisengageReason;

typedef struct DisengageRejectReason {
    ASN1choice_t choice;
#   define DisengageRejectReason_notRegistered_chosen 1
#   define requestToDropOther_chosen 2
} DisengageRejectReason;

typedef struct UnknownMessageResponse {
    RequestSeqNum requestSeqNum;
} UnknownMessageResponse;

typedef struct InfoRequestResponse_endpointAlias {
    PInfoRequestResponse_endpointAlias next;
    AliasAddress value;
} InfoRequestResponse_endpointAlias_Element;

typedef struct LocationRequest_destinationInfo {
    PLocationRequest_destinationInfo next;
    AliasAddress value;
} LocationRequest_destinationInfo_Element;

typedef struct AdmissionRequest_srcInfo {
    PAdmissionRequest_srcInfo next;
    AliasAddress value;
} AdmissionRequest_srcInfo_Element;

typedef struct AdmissionRequest_destExtraCallInfo {
    PAdmissionRequest_destExtraCallInfo next;
    AliasAddress value;
} AdmissionRequest_destExtraCallInfo_Element;

typedef struct AdmissionRequest_destinationInfo {
    PAdmissionRequest_destinationInfo next;
    AliasAddress value;
} AdmissionRequest_destinationInfo_Element;

typedef struct UnregistrationRequest_endpointAlias {
    PUnregistrationRequest_endpointAlias next;
    AliasAddress value;
} UnregistrationRequest_endpointAlias_Element;

typedef struct RegistrationRejectReason_duplicateAlias {
    PRegistrationRejectReason_duplicateAlias next;
    AliasAddress value;
} RegistrationRejectReason_duplicateAlias_Element;

typedef struct RegistrationConfirm_terminalAlias {
    PRegistrationConfirm_terminalAlias next;
    AliasAddress value;
} RegistrationConfirm_terminalAlias_Element;

typedef struct RegistrationRequest_terminalAlias {
    PRegistrationRequest_terminalAlias next;
    AliasAddress value;
} RegistrationRequest_terminalAlias_Element;

typedef struct GatekeeperRequest_endpointAlias {
    PGatekeeperRequest_endpointAlias next;
    AliasAddress value;
} GatekeeperRequest_endpointAlias_Element;

typedef struct VendorIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H221NonStandard vendor;
#   define productId_present 0x80
    struct VendorIdentifier_productId_productId {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } productId;
#   define versionId_present 0x40
    struct VendorIdentifier_versionId_versionId {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } versionId;
} VendorIdentifier;

typedef struct QseriesOptions {
    ASN1bool_t q932Full;
    ASN1bool_t q951Full;
    ASN1bool_t q952Full;
    ASN1bool_t q953Full;
    ASN1bool_t q955Full;
    ASN1bool_t q956Full;
    ASN1bool_t q957Full;
    Q954Details q954Info;
} QseriesOptions;

typedef struct NonStandardParameter {
    NonStandardIdentifier nonStandardIdentifier;
    ASN1octetstring_t data;
} NonStandardParameter;

typedef struct GatekeeperReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define GatekeeperReject_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
#   define GatekeeperReject_gatekeeperIdentifier_present 0x40
    GatekeeperIdentifier gatekeeperIdentifier;
    GatekeeperRejectReason rejectReason;
} GatekeeperReject;

typedef struct RegistrationConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define RegistrationConfirm_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
    PRegistrationConfirm_callSignalAddress callSignalAddress;
#   define RegistrationConfirm_terminalAlias_present 0x40
    PRegistrationConfirm_terminalAlias terminalAlias;
#   define RegistrationConfirm_gatekeeperIdentifier_present 0x20
    GatekeeperIdentifier gatekeeperIdentifier;
    EndpointIdentifier endpointIdentifier;
} RegistrationConfirm;

typedef struct RegistrationReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define RegistrationReject_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
    RegistrationRejectReason rejectReason;
#   define RegistrationReject_gatekeeperIdentifier_present 0x40
    GatekeeperIdentifier gatekeeperIdentifier;
} RegistrationReject;

typedef struct UnregistrationRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    PUnregistrationRequest_callSignalAddress callSignalAddress;
#   define UnregistrationRequest_endpointAlias_present 0x80
    PUnregistrationRequest_endpointAlias endpointAlias;
#   define UnregistrationRequest_nonStandardData_present 0x40
    NonStandardParameter nonStandardData;
#   define UnregistrationRequest_endpointIdentifier_present 0x20
    EndpointIdentifier endpointIdentifier;
} UnregistrationRequest;

typedef struct UnregistrationConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
#   define UnregistrationConfirm_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} UnregistrationConfirm;

typedef struct UnregistrationReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    UnregRejectReason rejectReason;
#   define UnregistrationReject_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} UnregistrationReject;

typedef struct AdmissionReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    AdmissionRejectReason rejectReason;
#   define AdmissionReject_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} AdmissionReject;

typedef struct BandwidthRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    EndpointIdentifier endpointIdentifier;
    ConferenceIdentifier conferenceID;
    CallReferenceValue callReferenceValue;
#   define callType_present 0x80
    CallType callType;
    BandWidth bandWidth;
#   define BandwidthRequest_nonStandardData_present 0x40
    NonStandardParameter nonStandardData;
} BandwidthRequest;

typedef struct BandwidthConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    BandWidth bandWidth;
#   define BandwidthConfirm_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} BandwidthConfirm;

typedef struct BandwidthReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    BandRejectReason rejectReason;
    BandWidth allowedBandWidth;
#   define BandwidthReject_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} BandwidthReject;

typedef struct LocationReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    LocationRejectReason rejectReason;
#   define LocationReject_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} LocationReject;

typedef struct DisengageRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    EndpointIdentifier endpointIdentifier;
    ConferenceIdentifier conferenceID;
    CallReferenceValue callReferenceValue;
    DisengageReason disengageReason;
#   define DisengageRequest_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} DisengageRequest;

typedef struct DisengageConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
#   define DisengageConfirm_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} DisengageConfirm;

typedef struct DisengageReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    DisengageRejectReason rejectReason;
#   define DisengageReject_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} DisengageReject;

typedef struct NonStandardMessage {
    RequestSeqNum requestSeqNum;
    NonStandardParameter nonStandardData;
} NonStandardMessage;

typedef struct TransportAddress {
    ASN1choice_t choice;
    union {
#	define ipAddress_chosen 1
	TransportAddress_ipAddress ipAddress;
#	define ipSourceRoute_chosen 2
	TransportAddress_ipSourceRoute ipSourceRoute;
#	define ipxAddress_chosen 3
	TransportAddress_ipxAddress ipxAddress;
#	define ip6Address_chosen 4
	TransportAddress_ip6Address ip6Address;
#	define netBios_chosen 5
	struct TransportAddress_netBios_netBios {
	    ASN1uint32_t length;
	    ASN1octet_t value[16];
	} netBios;
#	define nsap_chosen 6
	struct TransportAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define nonStandardAddress_chosen 7
	NonStandardParameter nonStandardAddress;
    } u;
} TransportAddress;

typedef struct GatewayInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define protocol_present 0x80
    PGatewayInfo_protocol protocol;
#   define GatewayInfo_nonStandardData_present 0x40
    NonStandardParameter nonStandardData;
} GatewayInfo;

typedef struct H310Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H310Caps_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} H310Caps;

typedef struct H320Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H320Caps_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} H320Caps;

typedef struct H321Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H321Caps_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} H321Caps;

typedef struct H322Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H322Caps_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} H322Caps;

typedef struct H323Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H323Caps_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} H323Caps;

typedef struct H324Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H324Caps_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} H324Caps;

typedef struct VoiceCaps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define VoiceCaps_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} VoiceCaps;

typedef struct T120OnlyCaps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define T120OnlyCaps_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} T120OnlyCaps;

typedef struct McuInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define McuInfo_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} McuInfo;

typedef struct TerminalInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define TerminalInfo_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} TerminalInfo;

typedef struct GatekeeperInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define GatekeeperInfo_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} GatekeeperInfo;

typedef struct GatekeeperConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define GatekeeperConfirm_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
#   define GatekeeperConfirm_gatekeeperIdentifier_present 0x40
    GatekeeperIdentifier gatekeeperIdentifier;
    TransportAddress rasAddress;
} GatekeeperConfirm;

typedef struct AdmissionRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    CallType callType;
#   define callModel_present 0x80
    CallModel callModel;
    EndpointIdentifier endpointIdentifier;
#   define destinationInfo_present 0x40
    PAdmissionRequest_destinationInfo destinationInfo;
#   define destCallSignalAddress_present 0x20
    TransportAddress destCallSignalAddress;
#   define destExtraCallInfo_present 0x10
    PAdmissionRequest_destExtraCallInfo destExtraCallInfo;
    PAdmissionRequest_srcInfo srcInfo;
#   define srcCallSignalAddress_present 0x8
    TransportAddress srcCallSignalAddress;
    BandWidth bandWidth;
    CallReferenceValue callReferenceValue;
#   define AdmissionRequest_nonStandardData_present 0x4
    NonStandardParameter nonStandardData;
#   define AdmissionRequest_callServices_present 0x2
    QseriesOptions callServices;
    ConferenceIdentifier conferenceID;
    ASN1bool_t activeMC;
    ASN1bool_t answerCall;
} AdmissionRequest;

typedef struct AdmissionConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    BandWidth bandWidth;
    CallModel callModel;
    TransportAddress destCallSignalAddress;
#   define irrFrequency_present 0x80
    ASN1uint16_t irrFrequency;
#   define AdmissionConfirm_nonStandardData_present 0x40
    NonStandardParameter nonStandardData;
} AdmissionConfirm;

typedef struct LocationRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
#   define LocationRequest_endpointIdentifier_present 0x80
    EndpointIdentifier endpointIdentifier;
    PLocationRequest_destinationInfo destinationInfo;
#   define LocationRequest_nonStandardData_present 0x40
    NonStandardParameter nonStandardData;
    TransportAddress replyAddress;
} LocationRequest;

typedef struct LocationConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    TransportAddress callSignalAddress;
    TransportAddress rasAddress;
#   define LocationConfirm_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
} LocationConfirm;

typedef struct InfoRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    CallReferenceValue callReferenceValue;
#   define InfoRequest_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
#   define replyAddress_present 0x40
    TransportAddress replyAddress;
} InfoRequest;

typedef struct TransportChannelInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define sendAddress_present 0x80
    TransportAddress sendAddress;
#   define recvAddress_present 0x40
    TransportAddress recvAddress;
} TransportChannelInfo;

typedef struct RTPSession {
    TransportChannelInfo rtpAddress;
    TransportChannelInfo rtcpAddress;
    ASN1ztcharstring_t cname;
    ASN1uint32_t ssrc;
    ASN1uint16_t sessionId;
    PRTPSession_associatedSessionIds associatedSessionIds;
} RTPSession;

typedef struct InfoRequestResponse_perCallInfo_Seq_data {
    PInfoRequestResponse_perCallInfo_Seq_data next;
    TransportChannelInfo value;
} InfoRequestResponse_perCallInfo_Seq_data_Element;

typedef struct InfoRequestResponse_perCallInfo_Seq_video {
    PInfoRequestResponse_perCallInfo_Seq_video next;
    RTPSession value;
} InfoRequestResponse_perCallInfo_Seq_video_Element;

typedef struct InfoRequestResponse_perCallInfo_Seq_audio {
    PInfoRequestResponse_perCallInfo_Seq_audio next;
    RTPSession value;
} InfoRequestResponse_perCallInfo_Seq_audio_Element;

typedef struct InfoRequestResponse_perCallInfo_Seq {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define InfoRequestResponse_perCallInfo_Seq_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
    CallReferenceValue callReferenceValue;
    ConferenceIdentifier conferenceID;
#   define originator_present 0x40
    ASN1bool_t originator;
#   define audio_present 0x20
    PInfoRequestResponse_perCallInfo_Seq_audio audio;
#   define video_present 0x10
    PInfoRequestResponse_perCallInfo_Seq_video video;
#   define data_present 0x8
    PInfoRequestResponse_perCallInfo_Seq_data data;
    TransportChannelInfo h245;
    TransportChannelInfo callSignaling;
    CallType callType;
    BandWidth bandWidth;
    CallModel callModel;
} InfoRequestResponse_perCallInfo_Seq;

typedef struct InfoRequestResponse_perCallInfo {
    PInfoRequestResponse_perCallInfo next;
    InfoRequestResponse_perCallInfo_Seq value;
} InfoRequestResponse_perCallInfo_Element;

typedef struct InfoRequestResponse_callSignalAddress {
    PInfoRequestResponse_callSignalAddress next;
    TransportAddress value;
} InfoRequestResponse_callSignalAddress_Element;

typedef struct UnregistrationRequest_callSignalAddress {
    PUnregistrationRequest_callSignalAddress next;
    TransportAddress value;
} UnregistrationRequest_callSignalAddress_Element;

typedef struct RegistrationConfirm_callSignalAddress {
    PRegistrationConfirm_callSignalAddress next;
    TransportAddress value;
} RegistrationConfirm_callSignalAddress_Element;

typedef struct RegistrationRequest_rasAddress {
    PRegistrationRequest_rasAddress next;
    TransportAddress value;
} RegistrationRequest_rasAddress_Element;

typedef struct RegistrationRequest_callSignalAddress {
    PRegistrationRequest_callSignalAddress next;
    TransportAddress value;
} RegistrationRequest_callSignalAddress_Element;

typedef struct EndpointType {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define EndpointType_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
#   define vendor_present 0x40
    VendorIdentifier vendor;
#   define gatekeeper_present 0x20
    GatekeeperInfo gatekeeper;
#   define gateway_present 0x10
    GatewayInfo gateway;
#   define mcu_present 0x8
    McuInfo mcu;
#   define terminal_present 0x4
    TerminalInfo terminal;
    ASN1bool_t mc;
    ASN1bool_t undefinedNode;
} EndpointType;

typedef struct SupportedProtocols {
    ASN1choice_t choice;
    union {
#	define nonStandardData_chosen 1
	NonStandardParameter nonStandardData;
#	define h310_chosen 2
	H310Caps h310;
#	define h320_chosen 3
	H320Caps h320;
#	define h321_chosen 4
	H321Caps h321;
#	define h322_chosen 5
	H322Caps h322;
#	define h323_chosen 6
	H323Caps h323;
#	define h324_chosen 7
	H324Caps h324;
#	define voice_chosen 8
	VoiceCaps voice;
#	define t120_only_chosen 9
	T120OnlyCaps t120_only;
    } u;
} SupportedProtocols;

typedef struct GatekeeperRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define GatekeeperRequest_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
    TransportAddress rasAddress;
    EndpointType endpointType;
#   define GatekeeperRequest_gatekeeperIdentifier_present 0x40
    GatekeeperIdentifier gatekeeperIdentifier;
#   define GatekeeperRequest_callServices_present 0x20
    QseriesOptions callServices;
#   define GatekeeperRequest_endpointAlias_present 0x10
    PGatekeeperRequest_endpointAlias endpointAlias;
} GatekeeperRequest;

typedef struct RegistrationRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define RegistrationRequest_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
    ASN1bool_t discoveryComplete;
    PRegistrationRequest_callSignalAddress callSignalAddress;
    PRegistrationRequest_rasAddress rasAddress;
    EndpointType terminalType;
#   define RegistrationRequest_terminalAlias_present 0x40
    PRegistrationRequest_terminalAlias terminalAlias;
#   define RegistrationRequest_gatekeeperIdentifier_present 0x20
    GatekeeperIdentifier gatekeeperIdentifier;
    VendorIdentifier endpointVendor;
} RegistrationRequest;

typedef struct InfoRequestResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define InfoRequestResponse_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
    RequestSeqNum requestSeqNum;
    EndpointType endpointType;
    EndpointIdentifier endpointIdentifier;
    TransportAddress rasAddress;
    PInfoRequestResponse_callSignalAddress callSignalAddress;
#   define InfoRequestResponse_endpointAlias_present 0x40
    PInfoRequestResponse_endpointAlias endpointAlias;
#   define perCallInfo_present 0x20
    PInfoRequestResponse_perCallInfo perCallInfo;
} InfoRequestResponse;

typedef struct GatewayInfo_protocol {
    PGatewayInfo_protocol next;
    SupportedProtocols value;
} GatewayInfo_protocol_Element;

typedef struct RasMessage {
    ASN1choice_t choice;
    union {
#	define gatekeeperRequest_chosen 1
	GatekeeperRequest gatekeeperRequest;
#	define gatekeeperConfirm_chosen 2
	GatekeeperConfirm gatekeeperConfirm;
#	define gatekeeperReject_chosen 3
	GatekeeperReject gatekeeperReject;
#	define registrationRequest_chosen 4
	RegistrationRequest registrationRequest;
#	define registrationConfirm_chosen 5
	RegistrationConfirm registrationConfirm;
#	define registrationReject_chosen 6
	RegistrationReject registrationReject;
#	define unregistrationRequest_chosen 7
	UnregistrationRequest unregistrationRequest;
#	define unregistrationConfirm_chosen 8
	UnregistrationConfirm unregistrationConfirm;
#	define unregistrationReject_chosen 9
	UnregistrationReject unregistrationReject;
#	define admissionRequest_chosen 10
	AdmissionRequest admissionRequest;
#	define admissionConfirm_chosen 11
	AdmissionConfirm admissionConfirm;
#	define admissionReject_chosen 12
	AdmissionReject admissionReject;
#	define bandwidthRequest_chosen 13
	BandwidthRequest bandwidthRequest;
#	define bandwidthConfirm_chosen 14
	BandwidthConfirm bandwidthConfirm;
#	define bandwidthReject_chosen 15
	BandwidthReject bandwidthReject;
#	define disengageRequest_chosen 16
	DisengageRequest disengageRequest;
#	define disengageConfirm_chosen 17
	DisengageConfirm disengageConfirm;
#	define disengageReject_chosen 18
	DisengageReject disengageReject;
#	define locationRequest_chosen 19
	LocationRequest locationRequest;
#	define locationConfirm_chosen 20
	LocationConfirm locationConfirm;
#	define locationReject_chosen 21
	LocationReject locationReject;
#	define infoRequest_chosen 22
	InfoRequest infoRequest;
#	define infoRequestResponse_chosen 23
	InfoRequestResponse infoRequestResponse;
#	define nonStandardMessage_chosen 24
	NonStandardMessage nonStandardMessage;
#	define unknownMessageResponse_chosen 25
	UnknownMessageResponse unknownMessageResponse;
    } u;
} RasMessage;
#define RasMessage_PDU 0
#define SIZE_GKPDU_Module_PDU_0 sizeof(RasMessage)

extern ASN1module_t GKPDU_Module;
extern void ASN1CALL GKPDU_Module_init();
extern void ASN1CALL GKPDU_Module_finit();

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route_ElmFn(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route val);
    extern int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route_ElmFn(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route val);
    extern void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route_ElmFn(PTransportAddress_ipSourceRoute_route val);
    extern int ASN1CALL ASN1Enc_RTPSession_associatedSessionIds_ElmFn(ASN1encoding_t enc, PRTPSession_associatedSessionIds val);
    extern int ASN1CALL ASN1Dec_RTPSession_associatedSessionIds_ElmFn(ASN1decoding_t dec, PRTPSession_associatedSessionIds val);
    extern void ASN1CALL ASN1Free_RTPSession_associatedSessionIds_ElmFn(PRTPSession_associatedSessionIds val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_endpointAlias_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_endpointAlias val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_endpointAlias_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_endpointAlias val);
    extern void ASN1CALL ASN1Free_InfoRequestResponse_endpointAlias_ElmFn(PInfoRequestResponse_endpointAlias val);
    extern int ASN1CALL ASN1Enc_LocationRequest_destinationInfo_ElmFn(ASN1encoding_t enc, PLocationRequest_destinationInfo val);
    extern int ASN1CALL ASN1Dec_LocationRequest_destinationInfo_ElmFn(ASN1decoding_t dec, PLocationRequest_destinationInfo val);
    extern void ASN1CALL ASN1Free_LocationRequest_destinationInfo_ElmFn(PLocationRequest_destinationInfo val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_srcInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_srcInfo val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_srcInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_srcInfo val);
    extern void ASN1CALL ASN1Free_AdmissionRequest_srcInfo_ElmFn(PAdmissionRequest_srcInfo val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destExtraCallInfo val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destExtraCallInfo val);
    extern void ASN1CALL ASN1Free_AdmissionRequest_destExtraCallInfo_ElmFn(PAdmissionRequest_destExtraCallInfo val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_destinationInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destinationInfo val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_destinationInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destinationInfo val);
    extern void ASN1CALL ASN1Free_AdmissionRequest_destinationInfo_ElmFn(PAdmissionRequest_destinationInfo val);
    extern int ASN1CALL ASN1Enc_UnregistrationRequest_endpointAlias_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_endpointAlias val);
    extern int ASN1CALL ASN1Dec_UnregistrationRequest_endpointAlias_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_endpointAlias val);
    extern void ASN1CALL ASN1Free_UnregistrationRequest_endpointAlias_ElmFn(PUnregistrationRequest_endpointAlias val);
    extern int ASN1CALL ASN1Enc_RegistrationRejectReason_duplicateAlias_ElmFn(ASN1encoding_t enc, PRegistrationRejectReason_duplicateAlias val);
    extern int ASN1CALL ASN1Dec_RegistrationRejectReason_duplicateAlias_ElmFn(ASN1decoding_t dec, PRegistrationRejectReason_duplicateAlias val);
    extern void ASN1CALL ASN1Free_RegistrationRejectReason_duplicateAlias_ElmFn(PRegistrationRejectReason_duplicateAlias val);
    extern int ASN1CALL ASN1Enc_RegistrationConfirm_terminalAlias_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_terminalAlias val);
    extern int ASN1CALL ASN1Dec_RegistrationConfirm_terminalAlias_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_terminalAlias val);
    extern void ASN1CALL ASN1Free_RegistrationConfirm_terminalAlias_ElmFn(PRegistrationConfirm_terminalAlias val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_terminalAlias_ElmFn(ASN1encoding_t enc, PRegistrationRequest_terminalAlias val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_terminalAlias_ElmFn(ASN1decoding_t dec, PRegistrationRequest_terminalAlias val);
    extern void ASN1CALL ASN1Free_RegistrationRequest_terminalAlias_ElmFn(PRegistrationRequest_terminalAlias val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_endpointAlias_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_endpointAlias val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_endpointAlias_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_endpointAlias val);
    extern void ASN1CALL ASN1Free_GatekeeperRequest_endpointAlias_ElmFn(PGatekeeperRequest_endpointAlias val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_data val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_data val);
    extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(PInfoRequestResponse_perCallInfo_Seq_data val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_video val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_video val);
    extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(PInfoRequestResponse_perCallInfo_Seq_video val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_audio val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_audio val);
    extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(PInfoRequestResponse_perCallInfo_Seq_audio val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo val);
    extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_ElmFn(PInfoRequestResponse_perCallInfo val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_callSignalAddress_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_callSignalAddress_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_callSignalAddress val);
    extern void ASN1CALL ASN1Free_InfoRequestResponse_callSignalAddress_ElmFn(PInfoRequestResponse_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_UnregistrationRequest_callSignalAddress_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_UnregistrationRequest_callSignalAddress_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_callSignalAddress val);
    extern void ASN1CALL ASN1Free_UnregistrationRequest_callSignalAddress_ElmFn(PUnregistrationRequest_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_RegistrationConfirm_callSignalAddress_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_RegistrationConfirm_callSignalAddress_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_callSignalAddress val);
    extern void ASN1CALL ASN1Free_RegistrationConfirm_callSignalAddress_ElmFn(PRegistrationConfirm_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_rasAddress_ElmFn(ASN1encoding_t enc, PRegistrationRequest_rasAddress val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_rasAddress_ElmFn(ASN1decoding_t dec, PRegistrationRequest_rasAddress val);
    extern void ASN1CALL ASN1Free_RegistrationRequest_rasAddress_ElmFn(PRegistrationRequest_rasAddress val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_callSignalAddress_ElmFn(ASN1encoding_t enc, PRegistrationRequest_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_callSignalAddress_ElmFn(ASN1decoding_t dec, PRegistrationRequest_callSignalAddress val);
    extern void ASN1CALL ASN1Free_RegistrationRequest_callSignalAddress_ElmFn(PRegistrationRequest_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_GatewayInfo_protocol_ElmFn(ASN1encoding_t enc, PGatewayInfo_protocol val);
    extern int ASN1CALL ASN1Dec_GatewayInfo_protocol_ElmFn(ASN1decoding_t dec, PGatewayInfo_protocol val);
    extern void ASN1CALL ASN1Free_GatewayInfo_protocol_ElmFn(PGatewayInfo_protocol val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _GKPDU_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\intelcc\include\h245api.h ===
#ifndef H245API_H
#define H245API_H

/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   h245api.h  $
 *  $Revision:   1.64  $
 *  $Modtime:   04 Mar 1997 16:51:38  $
 *  $Log:   S:/sturgeon/src/include/vcs/h245api.h_v  $
 * 
 *    Rev 1.64   04 Mar 1997 17:32:36   MANDREWS
 * H245CopyCap() and H245CopyCapDescriptor() now return HRESULTs.
 * 
 *    Rev 1.63   26 Feb 1997 10:56:20   MANDREWS
 * Added H245_MAX_CAPID.
 * 
 *    Rev 1.62   Feb 24 1997 18:28:26   tomitowx
 * multiple modedescriptor support
 * 
 *    Rev 1.61   19 Dec 1996 17:16:10   EHOWARDX
 * Now using ASN.1 compiler C++ flag.
 * 
 *    Rev 1.60   17 Dec 1996 17:14:12   EHOWARDX
 * Added pSeparateStack to IND_OPEN_T.
 * 
 *    Rev 1.59   12 Dec 1996 11:24:38   EHOWARDX
 * Backed out H245_CONF_H323_OLD change.
 * 
 *    Rev 1.57   11 Dec 1996 13:46:46   SBELL1
 * Changed H245Init to return linkLayer Physical ID
 * 
 *    Rev 1.56   24 Oct 1996 15:57:54   MANDREWS
 * Fixed typo in last update.
 * 
 *    Rev 1.55   Oct 21 1996 17:11:00   mandrews
 * Fixed type in last check-in.
 * 
 *    Rev 1.54   Oct 21 1996 16:41:20   mandrews
 * Added H245_MASTER_SLAVE_CONFLICT as an additional openChannelReject
 * reason code.
 * 
 *    Rev 1.53   17 Oct 1996 18:17:54   EHOWARDX
 * Changed general string to always be Unicode.
 * 
 *    Rev 1.52   14 Oct 1996 14:00:28   EHOWARDX
 * 
 * Unicode changes.
 * 
 *    Rev 1.51   03 Sep 1996 18:09:54   EHOWARDX
 * 
 * Changed some parameters to const.
 * Changed H245_REQ_ENTRY_H243_CONFERENCE_ID to H245_REQ_ENTER_H243_CONFERENCE
 * 
 *    Rev 1.50   15 Aug 1996 14:33:48   EHOWARDX
 * Changed definition of H245_COMM_MODE_ENTRY_T as per Mike Andrews' request.
 * 
 *    Rev 1.49   24 Jul 1996 15:18:16   EHOWARDX
 * Backed out change of IndNonstandardRequest to IndNonstandardReq,
 * IndNonstandardResponse to IndNonStandardRsp, and IndNonstandardCommand to
 * IndNonstandardCmd to make less work for upper layers (CCTEST).
 * 
 *    Rev 1.48   19 Jul 1996 14:12:20   EHOWARDX
 * 
 * Added indication callback structure for CommunicationModeResponse and
 * CommunicationModeCommand.
 * 
 *    Rev 1.47   19 Jul 1996 12:50:30   EHOWARDX
 * 
 * Multipoint clean-up.
 * 
 *    Rev 1.46   16 Jul 1996 17:53:48   unknown
 * Added FNS indication.
 * 
 *    Rev 1.45   16 Jul 1996 11:51:58   EHOWARDX
 * 
 * Changed ERROR_LOCAL_BASE_ID to ERROR_BASE_ID.
 * 
 *    Rev 1.44   16 Jul 1996 11:46:10   EHOWARDX
 * 
 * Eliminated H245_ERROR_MUX_CAPS_ALREADY_SET (changing the existing
 * mux cap should not be an error).
 * 
 *    Rev 1.43   11 Jul 1996 18:42:14   rodellx
 * 
 * Fixed bug where HRESULT ids were in violation of Facility and/or Code
 * value rules.
 * 
 *    Rev 1.42   10 Jul 1996 11:33:42   unknown
 * Changed error base.
 * 
 *    Rev 1.41   01 Jul 1996 22:07:24   EHOWARDX
 * Added Conference and CommunicationMode structures and API functions.
 * 
 *    Rev 1.40   18 Jun 1996 14:48:54   EHOWARDX
 * 
 * Bumped version number to 2 and modified H245MaintenanceLoopRelease()
 * and associated Confirms.
 * 
 *    Rev 1.39   14 Jun 1996 18:59:38   EHOWARDX
 * Geneva update.
 * 
 *    Rev 1.38   31 May 1996 18:19:46   EHOWARDX
 * Brought error codes in line with STURERR.DOC guidelines.
 * 
 *    Rev 1.37   30 May 1996 23:37:26   EHOWARDX
 * Clean up.
 * 
 *    Rev 1.36   30 May 1996 13:55:02   EHOWARDX
 * Changed H245EndConnection to H245EndSession.
 * Removed H245_CONF_ENDCONNECTION.
 * 
 *    Rev 1.35   29 May 1996 14:23:58   EHOWARDX
 * Changed definition of H245_ERROR_OK back to 0 (NOERROR == S_OK == 0).
 * 
 *    Rev 1.34   29 May 1996 13:19:50   EHOWARDX
 * RESULT to HRESULT conversion.
 * 
 *    Rev 1.33   24 May 1996 23:12:56   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.32   21 May 1996 18:23:58   EHOWARDX
 * 
 * Added dwTransId parameter to H245RequestMultiplexEntry,
 * H245RequestMode, and H245MaintenanceLoopRequest.
 * 
 *    Rev 1.31   20 May 1996 14:14:42   EHOWARDX
 * Fixed typo.
 * 
 *    Rev 1.30   20 May 1996 14:05:20   EHOWARDX
 * Removed dwTransId formal parameter from H245EndConnection().
 * 
 *    Rev 1.29   16 May 1996 15:51:56   EHOWARDX
 * Fixed typo in H245_INVALID_CAPDESCID.
 * 
 *    Rev 1.28   16 May 1996 10:57:46   unknown
 * Added H245_INVALID_CAPDESCID.
 * 
 *    Rev 1.27   14 May 1996 20:20:14   EHOWARDX
 * Removed H245_IND_SYS.
 * 
 *    Rev 1.26   14 May 1996 19:00:58   EHOWARDX
 * Deleted unused H245_SYSCON_xxx values.
 * 
 *    Rev 1.25   14 May 1996 16:58:48   EHOWARDX
 * Changed H245_IND_CAPDESC_T To H245_TOTCAPDESC_T.
 * H245EnumCaps() cap desc callback now takes single pointer to
 * H245_TOTCAPDESC_T instead of separate H245_CAPDESCID_T and
 * H245_CAPDESC_T pointer.
 * 
 *    Rev 1.24   13 May 1996 23:13:46   EHOWARDX
 * Everything ready for Micrsoft drop on the 17th.
 * 
 *    Rev 1.23   13 May 1996 15:43:16   EHOWARDX
 * Changed return type of H245CopyCapDescriptor from H245_CAPDESC_T pointer
 * to H245_TOTCAPDESC_T pointer.
 * 
 *    Rev 1.22   13 May 1996 14:05:16   EHOWARDX
 * Added H245CopyCapDescriptor() and H245FreeCapDescriptor().
 * 
 *    Rev 1.21   11 May 1996 20:00:34   EHOWARDX
 * Changed IS1381 to IS13818 (correct name for capability).
 * Changed H245SystemControl() - eliminated dwTransId and added
 * H245_SYSCON_GET_XXX requests.
 * 
 *    Rev 1.20   10 May 1996 17:38:28   unknown
 * Changed H245GetCaps and H245EnumCaps to also return Cap Descriptors.
 * 
 *    Rev 1.19   09 May 1996 20:22:58   EHOWARDX
 * Latest and greatest...
 * 
 *    Rev 1.35   09 May 1996 19:38:14   EHOWARDX
 * Redesigned locking logic and added new functionality.
 * 
 *    Rev 1.34   06 May 1996 13:19:44   EHOWARDX
 * Moved enums out of structures.
 * Added H245NonStandardH221() and H245NonStandardObject().
 * 
 *    Rev 1.33   01 May 1996 19:29:16   EHOWARDX
 * Added H245CopyCap(), H245FreeCap(), H245CopyMux(), H245FreeMux().
 * Changed H2250_xxx definitions for H.225.0 address to H245_xxx.
 * 
 *    Rev 1.32   27 Apr 1996 21:04:26   EHOWARDX
 * Changed channel numbers to words, added new open/open ack fields.
 * 
 *    Rev 1.31   26 Apr 1996 15:57:14   EHOWARDX
 * Added new Terminal Capabilities.
 * 
 *    Rev 1.27.1.6   25 Apr 1996 17:53:06   EHOWARDX
 * Added H245_INVALID_ID, currently set to zero, should be 0xFFFFFFFF later.
 * 
 *    Rev 1.27.1.5   25 Apr 1996 16:50:04   EHOWARDX
 * Added new functions as per API Changes spec.
 * 
 *    Rev 1.27.1.4   24 Apr 1996 20:57:30   EHOWARDX
 * Added new OpenLogicalChannelAck/OpenLogicalChannelReject support.
 * 
 *    Rev 1.27.1.3   18 Apr 1996 15:56:42   EHOWARDX
 * Updated to 1.30.
 * 
 *    Rev 1.27.1.2   16 Apr 1996 20:09:52   EHOWARDX
 * Added new H2250LogicalChannelParameter fields.
 * 
 *    Rev 1.27.1.1   16 Apr 1996 18:45:24   EHOWARDX
 * Added silenceSupression to H.225.0 Logical Channel Parameters.
 * 
 *    Rev 1.27.1.0   03 Apr 1996 15:56:14   cjutzi
 * Branched for H.323.
 *
 *    Rev 1.27   02 Apr 1996 08:29:44   cjutzi
 * - Changed CapDescriptor API
 * 
 *    Rev 1.26   01 Apr 1996 16:46:50   cjutzi
 * 
 * - Completed ENdConnection, and made asynch.. rather
 * than sync.. as before
 * Changed H245ShutDown to be sync rather than async..
 * 
 *    Rev 1.25   29 Mar 1996 14:55:52   cjutzi
 * 
 * - added USERINPUT stuff
 * - Added hooks for stats in SYSCON H245SystemControl
 * 
 *    Rev 1.24   27 Mar 1996 10:55:40   cjutzi
 * - added c++ wrapper for API calls..
 *
 *    Rev 1.23   20 Mar 1996 14:42:46   cjutzi
 * - added ERROR NO_CAPDESC
 *
 *    Rev 1.22   18 Mar 1996 15:14:56   cjutzi
 *
 * - added RxPort and TEST_TIMER
 *
 *    Rev 1.21   12 Mar 1996 15:49:24   cjutzi
 *
 * - implemented locking
 * - added EndSession
 * - added Shutdown
 *
 *
 *    Rev 1.20   08 Mar 1996 14:06:04   cjutzi
 *
 * - Removed Simultanious capability api
 * - added CapabilityDescriptor api.. (very similar.. made more sence)
 * - compeleted Mux Table upcall information..
 *
 *    Rev 1.19   06 Mar 1996 08:45:58   cjutzi
 *
 * - added ERROR ASN1
 *
 *    Rev 1.18   05 Mar 1996 17:32:24   cjutzi
 *
 * - master slave indication message from Hani.. implemented..
 *   added H245_IND_MSTSLV ..
 *
 *    Rev 1.17   05 Mar 1996 16:36:46   cjutzi
 *
 * - removed MUX_ENTRY_DESC_T .. cleaned it up.. don't need it..
 *
 *    Rev 1.16   05 Mar 1996 10:06:30   cjutzi
 *
 * - added mux table entry stuff
 * - changed errors to map to 10000
 *
 *    Rev 1.15   01 Mar 1996 13:46:20   cjutzi
 * - added more error messages
 *
 *    Rev 1.14   29 Feb 1996 17:27:38   cjutzi
 *
 * - bi-directional channel working
 *
 *    Rev 1.13   29 Feb 1996 11:33:50   cjutzi
 * - fixed bug w/ H245_CONF_IND_T .. as global union.. fixed to be
 *   struct
 *
 *    Rev 1.12   29 Feb 1996 08:26:48   cjutzi
 *
 * - added 2 error messages (SIMCAPID and DATA_FORMAT)
 *
 *    Rev 1.11   27 Feb 1996 13:28:50   cjutzi
 * - added global protocol id H245_PROTOID
 *
 *    Rev 1.10   26 Feb 1996 17:24:10   cjutzi
 *
 * -  added MiscCommand.. had to add channel to H245_IND_MISC_T..
 *
 *    Rev 1.9   26 Feb 1996 11:07:24   cjutzi
 *
 * - added simultanoius caps..
 *
 *    Rev 1.8   16 Feb 1996 12:59:26   cjutzi
 * - added tracing and debug..
 * - got close to work.. Added structure to H245_IND_T.. new CLOSE indication
 *
 *    Rev 1.7   15 Feb 1996 14:13:08   cjutzi
 *
 * - re-arranged the AL_T entries for more clairity..
 *
 *    Rev 1.6   15 Feb 1996 10:48:30   cjutzi
 *
 * - major changes..
 * - added MUX_T
 * - changed H245_IND_T
 * - changed IND_OPEN/IND_OPEN_NEEDSRSP etc..
 *
 *    Rev 1.5   09 Feb 1996 16:14:04   cjutzi
 *
 * - removed init_success
 * - removed shutdown success
 * - added masterslave type for callback/confirm
 * - added SYSCON TraceLvl
 *
 *****************************************************************************/

//
// H.245 return codes
//
#if defined(OIL)

#include "common.x"
#define HRESULT RESULT
#define ERROR_BASE_ID             0x8000
#define MAKE_H245_ERROR(error)          (error)
#define H245_ERROR_OK                   0
#define H245_ERROR_INVALID_DATA_FORMAT  MAKE_H245_ERROR(ERROR_BASE_ID+0x01) /* Data Structure passed down is somehow invalid    */
#define H245_ERROR_NOMEM                MAKE_H245_ERROR(ERROR_BASE_ID+0x02) /* memory allocation failure                        */
#define H245_ERROR_NOSUP                MAKE_H245_ERROR(ERROR_BASE_ID+0x03) /* H245 feature not valid, or not in this H245 spec */
#define H245_ERROR_PARAM                MAKE_H245_ERROR(ERROR_BASE_ID+0x04) /* invalid parameter or data structure passed to API*/
#define H245_ERROR_ALREADY_INIT         MAKE_H245_ERROR(ERROR_BASE_ID+0x05) /* system has already been initialized              */
#define H245_ERROR_NOT_CONNECTED        MAKE_H245_ERROR(ERROR_BASE_ID+0x06) /* system is not in the connected state             */

#else

#pragma warning( disable : 4115 4201 4214 4514 )
#include "apierror.h"
#define H245_ERROR_OK                   NOERROR
#define H245_ERROR_INVALID_DATA_FORMAT  MAKE_H245_ERROR(ERROR_INVALID_DATA)       /* Data Structure passed down is somehow invalid    */
#define H245_ERROR_NOMEM                MAKE_H245_ERROR(ERROR_OUTOFMEMORY)        /* memory allocation failure                        */
#define H245_ERROR_NOSUP                MAKE_H245_ERROR(ERROR_NOT_SUPPORTED)      /* H245 feature not valid, or not in this H245 spec */
#define H245_ERROR_PARAM                MAKE_H245_ERROR(ERROR_INVALID_PARAMETER)  /* invalid parameter or data structure passed to API*/
#define H245_ERROR_ALREADY_INIT         MAKE_H245_ERROR(ERROR_ALREADY_INITIALIZED)/* system has already been initialized              */
#define H245_ERROR_NOT_CONNECTED        MAKE_H245_ERROR(ERROR_NOT_CONNECTED)      /* system is not in the connected state             */

#endif

#define H245_ERROR_NORESOURCE           MAKE_H245_ERROR(ERROR_BASE_ID+0x10) /* No resources left for this call                  */
#define H245_ERROR_NOTIMP               MAKE_H245_ERROR(ERROR_BASE_ID+0x11) /* H245 feature should be implemented.. but is not  */
#define H245_ERROR_SUBSYS               MAKE_H245_ERROR(ERROR_BASE_ID+0x12) /* subsystem failure.. error unknown                */
#define H245_ERROR_FATAL                MAKE_H245_ERROR(ERROR_BASE_ID+0x13) /* fatal error.. system will be coming down..       */
#define H245_ERROR_MAXTBL               MAKE_H245_ERROR(ERROR_BASE_ID+0x14) /* you have reached the maxium number of tbl entries*/
#define H245_ERROR_CHANNEL_INUSE        MAKE_H245_ERROR(ERROR_BASE_ID+0x15) /* channel is currently in use                      */
#define H245_ERROR_INVALID_CAPID        MAKE_H245_ERROR(ERROR_BASE_ID+0x16) /* Invalid Cap ID.. can not be found                */
#define H245_ERROR_INVALID_OP           MAKE_H245_ERROR(ERROR_BASE_ID+0x17) /* Invalid operation at this time..                 */
#define H245_ERROR_UNKNOWN              MAKE_H245_ERROR(ERROR_BASE_ID+0x18) /* unknown error                                    */
#define H245_ERROR_NOBANDWIDTH          MAKE_H245_ERROR(ERROR_BASE_ID+0x19) /* Bandwidth will not allow this                    */
#define H245_ERROR_LOSTCON              MAKE_H245_ERROR(ERROR_BASE_ID+0x1A) /* System connection .. channel 0 was lost          */
#define H245_ERROR_INVALID_MUXTBLENTRY  MAKE_H245_ERROR(ERROR_BASE_ID+0x1B) /* Invalid Multiplex Table Entry                    */
#define H245_ERROR_INVALID_INST         MAKE_H245_ERROR(ERROR_BASE_ID+0x1C) /* instance is either no longer valid or is invalid */
#define H245_ERROR_INPROCESS            MAKE_H245_ERROR(ERROR_BASE_ID+0x1D) /* request is denied.. action already in process    */
#define H245_ERROR_INVALID_STATE        MAKE_H245_ERROR(ERROR_BASE_ID+0x1E) /* Not proper state to process request              */
#define H245_ERROR_TIMEOUT              MAKE_H245_ERROR(ERROR_BASE_ID+0x1F) /* Timeout occured                                  */
#define H245_ERROR_INVALID_CHANNEL      MAKE_H245_ERROR(ERROR_BASE_ID+0x20) /* Invalid channel                                  */
#define H245_ERROR_INVALID_CAPDESCID    MAKE_H245_ERROR(ERROR_BASE_ID+0x21) /* Invalid Capbility Descriptor ID                  */
#define H245_ERROR_CANCELED             MAKE_H245_ERROR(ERROR_BASE_ID+0x22) /* operation you are responding to has been canceled*/
#define H245_ERROR_MUXELEMENT_DEPTH     MAKE_H245_ERROR(ERROR_BASE_ID+0x23) /* Mux Table Entry is too complex.. MAX recursion   */
#define H245_ERROR_MUXELEMENT_WIDTH     MAKE_H245_ERROR(ERROR_BASE_ID+0x24) /* Mux Table Entry has reached max subelement width */
#define H245_ERROR_ASN1                 MAKE_H245_ERROR(ERROR_BASE_ID+0x25) /* ASN1 PDU compiler error - see PDU log            */
#define H245_ERROR_NO_MUX_CAPS          MAKE_H245_ERROR(ERROR_BASE_ID+0x26) /* Mux Capabilities have not been loaded            */
#define H245_ERROR_NO_CAPDESC           MAKE_H245_ERROR(ERROR_BASE_ID+0x27) /* No Capability Descriptors set                    */



// declare exported functions
#if defined(H245DLL_EXPORT)
#define H245DLL __declspec (dllexport)
#else   // (H245DLL_EXPORT)
#define H245DLL __declspec (dllimport)
#endif  // (H245DLL_EXPORT)



/************************************/
/* ASN.1 DATASTRUCTURES ABSTRACTION */
/************************************/

#include "h245asn1.h"

typedef struct NonStandardIdentifier    H245_NONSTANDID_T;

typedef struct NonStandardParameter     H245_NONSTANDARD_PARAMETER_T;

typedef H245_NONSTANDARD_PARAMETER_T    H245_CAP_NONSTANDARD_T;

typedef struct H261VideoCapability      H245_CAP_H261_T;

typedef struct H262VideoCapability      H245_CAP_H262_T;

typedef struct H263VideoCapability      H245_CAP_H263_T;

typedef struct IS11172VideoCapability   H245_CAP_VIS11172_T;

typedef struct IS11172AudioCapability   H245_CAP_AIS11172_T;

typedef struct IS13818AudioCapability   H245_CAP_IS13818_T;

typedef struct DataApplicationCapability H245_CAP_DATAAPPLICATION_T;

typedef struct H222Capability           H245_CAP_H222_T;

typedef struct H223Capability           H245_CAP_H223_T;

typedef struct V76Capability            H245_CAP_VGMUX_T;

typedef struct H2250Capability          H245_CAP_H2250_T;

typedef struct ConferenceCapability     H245_CAP_CONFERENCE_T;

typedef struct TerminalLabel            H245_TERMINAL_LABEL_T;

#define PDU_T           MltmdSystmCntrlMssg
#define H245_ACCESS_T   NetworkAccessParameters
typedef unsigned long  H245_INST_T;
typedef unsigned short H245_CHANNEL_T;
typedef unsigned long  H245_PORT_T;
#define H245_INVALID_ID          ((H245_INST_T)0)
#define H245_INVALID_CHANNEL     ((H245_CHANNEL_T)0)
#define H245_INVALID_PORT_NUMBER ((H245_PORT_T)-1)

typedef struct
{
  unsigned int    length;
  unsigned char  *value;
} H245_OCTET_STRING_T;



/************************/
/* H245 ABSTRACTION     */
/************************/

/* H245_CAPDIR_T */
typedef enum
{
  H245_CAPDIR_DONTCARE = 0,
  H245_CAPDIR_RMTRX,
  H245_CAPDIR_RMTTX,
  H245_CAPDIR_RMTRXTX,
  H245_CAPDIR_LCLRX,
  H245_CAPDIR_LCLTX,
  H245_CAPDIR_LCLRXTX
} H245_CAPDIR_T;

/* H245_DATA_T */
typedef enum
{
  H245_DATA_DONTCARE = 0,
  H245_DATA_NONSTD,
  H245_DATA_NULL,
  H245_DATA_VIDEO,
  H245_DATA_AUDIO,
  H245_DATA_DATA,
  H245_DATA_ENCRYPT_D,
  H245_DATA_CONFERENCE,
  H245_DATA_MUX         /* mux parameters */
} H245_DATA_T;

/* H245_CLIENT_T */
typedef enum
{
  H245_CLIENT_DONTCARE = 0,     // For H245EnumCap/H245GetCap
  H245_CLIENT_NONSTD,

  H245_CLIENT_VID_NONSTD,
  H245_CLIENT_VID_H261,
  H245_CLIENT_VID_H262,
  H245_CLIENT_VID_H263,
  H245_CLIENT_VID_IS11172,

  H245_CLIENT_AUD_NONSTD,
  H245_CLIENT_AUD_G711_ALAW64,
  H245_CLIENT_AUD_G711_ALAW56,
  H245_CLIENT_AUD_G711_ULAW64,
  H245_CLIENT_AUD_G711_ULAW56,
  H245_CLIENT_AUD_G722_64,
  H245_CLIENT_AUD_G722_56,
  H245_CLIENT_AUD_G722_48,
  H245_CLIENT_AUD_G723,
  H245_CLIENT_AUD_G728,
  H245_CLIENT_AUD_G729,
  H245_CLIENT_AUD_GDSVD,
  H245_CLIENT_AUD_IS11172,
  H245_CLIENT_AUD_IS13818,

  H245_CLIENT_DAT_NONSTD,
  H245_CLIENT_DAT_T120,
  H245_CLIENT_DAT_DSMCC,
  H245_CLIENT_DAT_USERDATA,
  H245_CLIENT_DAT_T84,
  H245_CLIENT_DAT_T434,
  H245_CLIENT_DAT_H224,
  H245_CLIENT_DAT_NLPID,
  H245_CLIENT_DAT_DSVD,
  H245_CLIENT_DAT_H222,

  H245_CLIENT_ENCRYPTION_TX,
  H245_CLIENT_ENCRYPTION_RX,
  H245_CLIENT_CONFERENCE,

  // Multiplex capabilities
  H245_CLIENT_MUX_NONSTD,
  H245_CLIENT_MUX_H222,
  H245_CLIENT_MUX_H223,
  H245_CLIENT_MUX_VGMUX,
  H245_CLIENT_MUX_H2250,
  H245_CLIENT_MUX_H223_ANNEX_A

} H245_CLIENT_T;


/* H245_CAP_T */
typedef union
{
  H245_CAP_NONSTANDARD_T        H245_NonStd;            /* not implemented */

  H245_CAP_NONSTANDARD_T        H245Vid_NONSTD;
  H245_CAP_H261_T               H245Vid_H261;
  H245_CAP_H262_T               H245Vid_H262;
  H245_CAP_H263_T               H245Vid_H263;
  H245_CAP_VIS11172_T           H245Vid_IS11172;

  H245_CAP_NONSTANDARD_T        H245Aud_NONSTD;
  unsigned short                H245Aud_G711_ALAW64;
  unsigned short                H245Aud_G711_ALAW56;
  unsigned short                H245Aud_G711_ULAW64;
  unsigned short                H245Aud_G711_ULAW56;
  unsigned short                H245Aud_G722_64;
  unsigned short                H245Aud_G722_56;
  unsigned short                H245Aud_G722_48;
  H245_CAP_G723_T               H245Aud_G723;
  unsigned short                H245Aud_G728;
  unsigned short                H245Aud_G729;
  unsigned short                H245Aud_GDSVD;
  H245_CAP_AIS11172_T           H245Aud_IS11172;
  H245_CAP_IS13818_T            H245Aud_IS13818;

  H245_CAP_DATAAPPLICATION_T    H245Dat_NONSTD;
  H245_CAP_DATAAPPLICATION_T    H245Dat_T120;
  H245_CAP_DATAAPPLICATION_T    H245Dat_DSMCC;
  H245_CAP_DATAAPPLICATION_T    H245Dat_USERDATA;
  H245_CAP_DATAAPPLICATION_T    H245Dat_T84;
  H245_CAP_DATAAPPLICATION_T    H245Dat_T434;
  H245_CAP_DATAAPPLICATION_T    H245Dat_H224;
  H245_CAP_DATAAPPLICATION_T    H245Dat_NLPID;
  H245_CAP_DATAAPPLICATION_T    H245Dat_DSVD;
  H245_CAP_DATAAPPLICATION_T    H245Dat_H222;

  ASN1_BOOL                     H245Encryption_TX;
  unsigned char                 H245Encryption_RX;
  H245_CAP_CONFERENCE_T         H245Conference;

  // Multiplex capabilities
  H245_CAP_NONSTANDARD_T        H245Mux_NONSTD;
  H245_CAP_H222_T               H245Mux_H222;
  H245_CAP_H223_T               H245Mux_H223;
  H245_CAP_VGMUX_T              H245Mux_VGMUX;
  H245_CAP_H2250_T              H245Mux_H2250;

} H245_CAP_T;

/* H245_CAPID_T */
typedef unsigned short H245_CAPID_T;
#define H245_INVALID_CAPID      ((H245_CAPID_T)-1)
#define H245_MAX_CAPID			(((H245_CAPID_T)-1) / 2)

/* H245_CAPDESCID_T */
typedef unsigned short H245_CAPDESCID_T;
#define H245_INVALID_CAPDESCID  ((H245_CAPDESCID_T)-1)

/* H245_SIMCAP_T */
#define H245_MAX_ALTCAPS        16
typedef struct
{
  unsigned short Length;                     /* number of CapId's in Array   */
  H245_CAPID_T AltCaps[H245_MAX_ALTCAPS];   /* list of alternatives CapId's */

} H245_SIMCAP_T;

#define H245_MAX_SIMCAPS        16
/* H245_CAPDESC_T */
typedef struct
{
  unsigned short Length;
  H245_SIMCAP_T SimCapArray[H245_MAX_SIMCAPS];

} H245_CAPDESC_T;

/* H245_TOTCAPDESC_T */
typedef struct
{
  H245_CAPDESCID_T      CapDescId;
  H245_CAPDESC_T        CapDesc;

} H245_TOTCAPDESC_T;

/* H245_TOTCAP_T */
typedef struct
{
  H245_CAPDIR_T   Dir;
  H245_DATA_T     DataType;
  H245_CLIENT_T   ClientType;
  H245_CAPID_T    CapId;
  H245_CAP_T      Cap;

} H245_TOTCAP_T;



/* H245_CONFIG_T */
typedef enum
{
  H245_CONF_H324 = 1,
  H245_CONF_H323,
  H245_CONF_H310,
  H245_CONF_GVD

} H245_CONFIG_T;




/* H245_ACC_REJ_T */

typedef unsigned long H245_ACC_REJ_T;

#define H245_ACC                        0
#define H245_REJ                        1 // unspecified

// Master Slave Determination reject causes
#define H245_REJ_MSD_IDENTICAL          identicalNumbers_chosen

// Terminal Capability Set reject causes
#define H245_REJ_UNDEF_TBL_ENTRY        undefinedTableEntryUsed_chosen
#define H245_REJ_DIS_CAP_EXCEED         dscrptrCpctyExcdd_chosen
#define H245_REJ_TBLENTRY_CAP_EXCEED    tblEntryCpctyExcdd_chosen

// Open Logical Channel reject causes
#define H245_REJ_REV_PARAM              unstblRvrsPrmtrs_chosen
#define H245_REJ_TYPE_NOTSUPPORT        dataTypeNotSupported_chosen
#define H245_REJ_TYPE_NOTAVAIL          dataTypeNotAvailable_chosen
#define H245_REJ_TYPE_UNKNOWN           unknownDataType_chosen
#define H245_REJ_AL_COMB                dtTypALCmbntnNtSpprtd_chosen
#define H245_REJ_MULTICAST              mltcstChnnlNtAllwd_chosen
#define H245_REJ_BANDWIDTH              insufficientBandwidth_chosen
#define H245_REJ_STACK                  sprtStckEstblshmntFld_chosen
#define H245_REJ_SESSION_ID             invalidSessionID_chosen
#define H245_REJ_MASTER_SLAVE_CONFLICT  masterSlaveConflict_chosen

// Request Channel Close reject causes - use H245_REJ

// Multiplex Table Entry Send reject causes
#define H245_REJ_MUX_COMPLICATED        descriptorTooComplex_chosen

// Request Mode reject causes
#define H245_REJ_UNAVAILABLE            modeUnavailable_chosen
#define H245_REJ_MULTIPOINT             multipointConstraint_chosen
#define H245_REJ_DENIED                 requestDenied_chosen




/* H245_ACC_REJ_MUX_T */
typedef struct
{
  H245_ACC_REJ_T        AccRej;
  unsigned long         MuxEntryId;

} H245_ACC_REJ_MUX_T[15];

/* H245_H222_LOGICAL_PARAM_T */
typedef struct
{
  unsigned short        resourceID;
  unsigned short        subChannelID;
  ASN1_BOOL             pcr_pidPresent;
  unsigned short        pcr_pid;                // optional
  H245_OCTET_STRING_T   programDescriptors;     // optional
  H245_OCTET_STRING_T   streamDescriptors;      // optional
} H245_H222_LOGICAL_PARAM_T;

/* H245_H223_LOGICAL_PARAM_T */
typedef enum
{
  H245_H223_AL_NONSTD        = H223LCPs_aLTp_nnStndrd_chosen,
  H245_H223_AL_AL1FRAMED     = H223LCPs_aLTp_al1Frmd_chosen,
  H245_H223_AL_AL1NOTFRAMED  = H223LCPs_aLTp_al1NtFrmd_chosen,
  H245_H223_AL_AL2NOSEQ      = H223LCPs_aLTp_a2WSNs_1_chosen,
  H245_H223_AL_AL2SEQ        = H223LCPs_aLTp_a2WSNs_2_chosen,
  H245_H223_AL_AL3           = H223LCPs_aLTp_al3_chosen

} H245_H223_AL_T;

typedef struct
{
  H245_H223_AL_T                AlType;
  unsigned int                  SndBufSize;   // 0..16777215
  unsigned char                 CtlFldOctet;  // 0..2
  ASN1_BOOL                     SegmentFlag;
  H245_NONSTANDARD_PARAMETER_T  H223_NONSTD;

} H245_H223_LOGICAL_PARAM_T;

/* H245_VGMUX_LOGICAL_PARAM_T */
typedef enum
{
  H245_V76_CRC8BIT  = crc8bit_chosen,
  H245_V76_CRC16BIT = crc16bit_chosen,
  H245_V76_CRC32BIT = crc32bit_chosen
} H245_V76_CRC_LENGTH_T;

typedef enum
{
  H245_V76_WITH_ADDRESS    = wAddress_chosen,
  H245_V76_WITHOUT_ADDRESS = woAddress_chosen
} H245_V76_SUSPEND_RESUME_T;

typedef enum
{
  H245_V76_ERM   = eRM_chosen,
  H245_V76_UNERM = uNERM_chosen
} H245_V76_MODE_T;

typedef enum
{
  H245_V76_REJ   = rej_chosen,
  H245_V76_SREJ  = sREJ_chosen,
  H245_V76_MSREJ = mSREJ_chosen
} H245_V76_RECOVERY_T;

typedef struct
{
  H245_V76_CRC_LENGTH_T       crcLength;
  unsigned short              n401;
  ASN1_BOOL                   loopbackTestProcedure;
  H245_V76_SUSPEND_RESUME_T   suspendResume;
  ASN1_BOOL                   uIH;
  H245_V76_MODE_T             mode;
  unsigned short              windowSize;       // Only valid if mode = ERM
  H245_V76_RECOVERY_T         recovery;         // Only valid if mode = ERM
  ASN1_BOOL                   audioHeaderPresent;
} H245_VGMUX_LOGICAL_PARAM_T;


typedef struct
{
  unsigned char               type;
  /* Note: All unicast types should be odd */
#define H245_IP_UNICAST       1
#define H245_IP_MULTICAST     2
#define H245_IP6_UNICAST      3
#define H245_IP6_MULTICAST    4
#define H245_IPSSR_UNICAST    5  // IP Strict Source Route
#define H245_IPLSR_UNICAST    6  // IP Loose  Source Route
#define H245_IPX_UNICAST      9
#define H245_NETBIOS_UNICAST 11
  union
  {
    // type == H245_IP_UNICAST or H245_IP_MULTICAST
    struct
    {
       unsigned short         tsapIdentifier;
       unsigned char          network[4];
    } ip;

    // type == H245_IP6_UNICAST or H245_IP6_MULTICAST
    struct
    {
       unsigned short         tsapIdentifier;
       unsigned char          network[16];
    } ip6;

    // type == H245_IPSSR_UNICAST or H245_IPLSR_UNICAST
    struct
    {
       unsigned short         tsapIdentifier;
       unsigned char          network[4];
       unsigned char *        route;            // Routing info
       unsigned long          dwCount;          // Number of addresses in above
    } ipSourceRoute;

    // type == H245_IPX_UNICAST
    struct
    {
       unsigned char          node[6];
       unsigned char          netnum[4];
       unsigned char          tsapIdentifier[2];
    } ipx;

    // type == H245_NETBIOS_UNICAST
    unsigned char             netBios[16];
  } u;
} H245_TRANSPORT_ADDRESS_T;

/* H245_H2250_LOGICAL_PARAM_T */
typedef struct
{
  // Note: first 8 fields MUST be same as H245_H2250ACK_LOGICAL_PARAM_T
  H2250LCPs_nnStndrdLink      nonStandardList;              // Optional
  H245_TRANSPORT_ADDRESS_T    mediaChannel;                 // Media Channel Address
  ASN1_BOOL                   mediaChannelPresent;          // TRUE if previous field used
  H245_TRANSPORT_ADDRESS_T    mediaControlChannel;          // Reverse RTCP channel
  ASN1_BOOL                   mediaControlChannelPresent;   // TRUE if previous field used
  unsigned char               dynamicRTPPayloadType;        // 96..127
  ASN1_BOOL                   dynamicRTPPayloadTypePresent; // TRUE if previous field used
  unsigned char               sessionID;                    // 0..255
  unsigned char               associatedSessionID;          // 1..255
  ASN1_BOOL                   associatedSessionIDPresent;   // TRUE if previous field used
  ASN1_BOOL                   mediaGuaranteed;              // TRUE if guaranteed delivery
  ASN1_BOOL                   mediaGuaranteedPresent;       // TRUE if previous field used
  ASN1_BOOL                   mediaControlGuaranteed;       // TRUE if previous field used
  ASN1_BOOL                   mediaControlGuaranteedPresent;// TRUE if previous field used
  ASN1_BOOL                   silenceSuppression;           // TRUE if using silence suppression
  ASN1_BOOL                   silenceSuppressionPresent;    // TRUE if previous field used
  H245_TERMINAL_LABEL_T       destination;                  // Terminal label for destination
  ASN1_BOOL                   destinationPresent;           // TRUE if previous field used
  ASN1_BOOL                   h261aVideoPacketization;
} H245_H2250_LOGICAL_PARAM_T;

/* H245_H2250ACK_LOGICAL_PARAM_T */
typedef struct
{
  H2250LCAPs_nnStndrdLink     nonStandardList;             // Optional
  H245_TRANSPORT_ADDRESS_T    mediaChannel;                // Transport address
  ASN1_BOOL                   mediaChannelPresent;         // TRUE if previous field used
  H245_TRANSPORT_ADDRESS_T    mediaControlChannel;         // Forward RTCP channel
  ASN1_BOOL                   mediaControlChannelPresent;  // TRUE if previous field used
  unsigned char               dynamicRTPPayloadType;       // 96..127
  ASN1_BOOL                   dynamicRTPPayloadTypePresent;// TRUE if previous field used
  unsigned char               sessionID;                   // 1..255
  ASN1_BOOL                   sessionIDPresent;            // TRUE if previous field used
} H245_H2250ACK_LOGICAL_PARAM_T;


/* H245_MUX_T */
typedef enum
{
  H245_H222     = fLCPs_mPs_h222LCPs_chosen,
  H245_H223     = fLCPs_mPs_h223LCPs_chosen,
  H245_VGMUX    = fLCPs_mPs_v76LCPs_chosen,
  H245_H2250    = fLCPs_mPs_h2250LCPs_chosen,
  H245_H2250ACK = fLCPs_mPs_h223AALCPs_chosen
} H245_MUX_KIND_T;

typedef struct
{
  H245_MUX_KIND_T Kind;
  union
  {
    H245_H222_LOGICAL_PARAM_T     H222;
    H245_H223_LOGICAL_PARAM_T     H223;
    H245_VGMUX_LOGICAL_PARAM_T    VGMUX;
    H245_H2250_LOGICAL_PARAM_T    H2250;
    H245_H2250ACK_LOGICAL_PARAM_T H2250ACK;
  } u;
} H245_MUX_T;


/*
   H245_MUX_ENTRY_ELEMENT_T

   This structure defines the multiplex pattern
   which will be used to decode bit patterns in
   a given mux table entry.  the Kind defines
   whether this is a recursive structure (i.e.
   pointing to yet another Mux Entry Element) or
   whether it is a terminating leaf in the recursive
   mux tree.

   RepeatCount indicates how many bits should be
   used for this channel.  If bit count == 0 this
   indicates repeat sequence until close flag
*/

typedef enum
{
  H245_MUX_LOGICAL_CHANNEL = 1,     /* logical channel number (Terminate list) */
  H245_MUX_ENTRY_ELEMENT            /* recursive.. yet another one             */
} H245_MUX_ENTRY_KIND_T;

typedef struct H245_MUX_ENTRY_ELEMENT_T
{
  struct H245_MUX_ENTRY_ELEMENT_T      *pNext;
  H245_MUX_ENTRY_KIND_T                 Kind;
  union
  {
      H245_CHANNEL_T                    Channel;
      struct H245_MUX_ENTRY_ELEMENT_T  *pMuxTblEntryElem;
  } u;

  /* RepeatCount                                */
  /* RepeatCount == 0 -> repeat until close     */
  /* RepeatCount != 0 -> repeate count          */
  unsigned long                         RepeatCount;

} H245_MUX_ENTRY_ELEMENT_T;


/*
   H245_MUX_TABLE_T

   an H245 Mux Table is defined as a linked list of
   Mux Entry Descriptors.  Each descriptor has an
   associated entry number.  These entry numbers
   range from 1-15 and must be unique within the table.
   The end of the list is designated by a pNext == NULL
*/

typedef  struct H245_MUX_TABLE_T
{
  struct H245_MUX_TABLE_T       *pNext;
  unsigned long                  MuxEntryId;
  H245_MUX_ENTRY_ELEMENT_T      *pMuxTblEntryElem;      /* NULL indicates delete entry */

} H245_MUX_TABLE_T;

/********************/
/********************/
/*  Indicator Code  */
/********************/
/********************/

#define H245_IND_MSTSLV                 0x01
#define H245_IND_CAP                    0x02
#define H245_IND_CESE_RELEASE           0x30
#define H245_IND_OPEN                   0x03
#define H245_IND_OPEN_CONF              0x04
#define H245_IND_CLOSE                  0x05
#define H245_IND_REQ_CLOSE              0x06
#define H245_IND_CLCSE_RELEASE          0x31
#define H245_IND_MUX_TBL                0x07
#define H245_IND_MTSE_RELEASE           0x08
#define H245_IND_RMESE                  0x09
#define H245_IND_RMESE_RELEASE          0x0A
#define H245_IND_MRSE                   0x0B
#define H245_IND_MRSE_RELEASE           0x0C
#define H245_IND_MLSE                   0x0D
#define H245_IND_MLSE_RELEASE           0x0E
#define H245_IND_NONSTANDARD_REQUEST    0x0F
#define H245_IND_NONSTANDARD_RESPONSE   0x10
#define H245_IND_NONSTANDARD_COMMAND    0x11
#define H245_IND_NONSTANDARD            0x12
#define H245_IND_MISC_COMMAND           0x13
#define H245_IND_MISC                   0x14
#define H245_IND_COMM_MODE_REQUEST      0x15
#define H245_IND_COMM_MODE_RESPONSE     0x16
#define H245_IND_COMM_MODE_COMMAND      0x17
#define H245_IND_CONFERENCE_REQUEST     0x18
#define H245_IND_CONFERENCE_RESPONSE    0x19
#define H245_IND_CONFERENCE_COMMAND     0x1A
#define H245_IND_CONFERENCE             0x1B
#define H245_IND_SEND_TERMCAP           0x1C
#define H245_IND_ENCRYPTION             0x1D
#define H245_IND_FLOW_CONTROL           0x1E
#define H245_IND_ENDSESSION             0x1F
#define H245_IND_FUNCTION_NOT_UNDERSTOOD 0x20
#define H245_IND_JITTER                 0x21
#define H245_IND_H223_SKEW              0x22
#define H245_IND_NEW_ATM_VC             0x23
#define H245_IND_USERINPUT              0x24
#define H245_IND_H2250_MAX_SKEW         0x25
#define H245_IND_MC_LOCATION            0x26
#define H245_IND_VENDOR_ID              0x27
#define H245_IND_FUNCTION_NOT_SUPPORTED 0x28
#define H245_IND_H223_RECONFIG          0x29
#define H245_IND_H223_RECONFIG_ACK      0x2A
#define H245_IND_H223_RECONFIG_REJECT   0x2B

/* H245_MSTSLV_T */
typedef enum
{
  H245_INDETERMINATE = 0,       // Master/Slave Determination failed
  H245_MASTER = master_chosen,  // Local terminal is Master
  H245_SLAVE  = slave_chosen    // Local terminal is Slave

} H245_MSTSLV_T;

/* H245_IND_OPEN_T */
typedef struct
{
  /* for receive */
  H245_CHANNEL_T RxChannel;
  H245_PORT_T    RxPort;        // optional
  H245_DATA_T    RxDataType;
  H245_CLIENT_T  RxClientType;
  H245_CAP_T    *pRxCap;
  H245_MUX_T    *pRxMux;

  /* for bi-directional channel */
  /* requested transmit stuff   */

  H245_DATA_T    TxDataType;
  H245_CLIENT_T  TxClientType;
  H245_CAP_T    *pTxCap;
  H245_MUX_T    *pTxMux;

  H245_ACCESS_T *pSeparateStack; // optional

} H245_IND_OPEN_T;

/* H245_IND_OPEN_CONF_T */
typedef struct
{
  /* receive channel              */
  /* remote requested channel #   */
  H245_CHANNEL_T          RxChannel;

  /* transmit channel                     */
  /* locally opened transmit channel #    */
  H245_CHANNEL_T          TxChannel;

} H245_IND_OPEN_CONF_T;

/* H245_IND_CLOSE_T */
typedef enum
{
  H245_USER = user_chosen,
  H245_LCSE = lcse_chosen

} H245_IND_CLOSE_REASON_T;

typedef struct
{
  H245_CHANNEL_T          Channel;
  H245_IND_CLOSE_REASON_T Reason;

} H245_IND_CLOSE_T;

/* H245_IND_MUX_TBL */
typedef struct
{
  H245_MUX_TABLE_T      *pMuxTbl;
  unsigned long          Count;

} H245_IND_MUXTBL_T;

/* H245_RMESE_T */
typedef struct
{
  unsigned short        awMultiplexTableEntryNumbers[15];
  unsigned long         dwCount;

} H245_RMESE_T;

/* H245_IND_MRSE_T */
typedef struct
{
  RequestedModesLink pRequestedModes;

} H245_IND_MRSE_T;

/* H245_MLSE_T */
typedef enum
{
  H245_SYSTEM_LOOP  = systemLoop_chosen,
  H245_MEDIA_LOOP   = mediaLoop_chosen,
  H245_CHANNEL_LOOP = logicalChannelLoop_chosen

} H245_LOOP_TYPE_T;

typedef struct
{
  H245_LOOP_TYPE_T      LoopType;
  H245_CHANNEL_T        Channel;

} H245_MLSE_T;

/* H245_IND_ENDSESSION_T */
typedef enum
{
  H245_ENDSESSION_NONSTD     = EndSssnCmmnd_nonStandard_chosen,
  H245_ENDSESSION_DISCONNECT = disconnect_chosen,
  H245_ENDSESSION_TELEPHONY,
  H245_ENDSESSION_V8BIS,
  H245_ENDSESSION_V34DSVD,
  H245_ENDSESSION_V34DUPFAX,
  H245_ENDSESSION_V34H324

} H245_ENDSESSION_T;

typedef struct
{
  H245_ENDSESSION_T             SessionMode;
  /* if non standard chosen */
  H245_NONSTANDARD_PARAMETER_T  SessionNonStd;

} H245_IND_ENDSESSION_T;

/* H245_IND_NONSTANDARD_T */
typedef struct
{
  unsigned char *        pData;
  unsigned long          dwDataLength;
  unsigned short *       pwObjectId;
  unsigned long          dwObjectIdLength;
  unsigned char          byCountryCode;
  unsigned char          byExtension;
  unsigned short         wManufacturerCode;
} H245_IND_NONSTANDARD_T;

typedef struct
{
  CMTEy_nnStndrdLink          pNonStandard;                 // NULL if not present
  unsigned char               sessionID;                    // 0..255
  unsigned char               associatedSessionID;          // 1..255
  ASN1_BOOL                   associatedSessionIDPresent;   // TRUE if previous field used
  H245_TERMINAL_LABEL_T       terminalLabel;
  ASN1_BOOL                   terminalLabelPresent;
  unsigned short *            pSessionDescription;
  unsigned short              wSessionDescriptionLength;
  H245_TOTCAP_T               dataType;
  H245_TRANSPORT_ADDRESS_T    mediaChannel;                 // Media Channel Address
  ASN1_BOOL                   mediaChannelPresent;          // TRUE if previous field used
  H245_TRANSPORT_ADDRESS_T    mediaControlChannel;          // Reverse RTCP channel
  ASN1_BOOL                   mediaControlChannelPresent;   // TRUE if previous field used
  ASN1_BOOL                   mediaGuaranteed;              // TRUE if guaranteed delivery
  ASN1_BOOL                   mediaGuaranteedPresent;       // TRUE if previous field used
  ASN1_BOOL                   mediaControlGuaranteed;       // TRUE if previous field used
  ASN1_BOOL                   mediaControlGuaranteedPresent;// TRUE if previous field used
} H245_COMM_MODE_ENTRY_T;

typedef struct
{
  H245_COMM_MODE_ENTRY_T *pTable;
  unsigned char          byTableCount;
} H245_IND_COMM_MODE_T;

typedef enum
{
  H245_REQ_TERMINAL_LIST            = terminalListRequest_chosen,
  H245_REQ_MAKE_ME_CHAIR            = makeMeChair_chosen,
  H245_REQ_CANCEL_MAKE_ME_CHAIR     = cancelMakeMeChair_chosen,
  H245_REQ_DROP_TERMINAL            = dropTerminal_chosen,
  H245_REQ_TERMINAL_ID              = requestTerminalID_chosen,
  H245_REQ_ENTER_H243_PASSWORD      = enterH243Password_chosen,
  H245_REQ_ENTER_H243_TERMINAL_ID   = enterH243TerminalID_chosen,
  H245_REQ_ENTER_H243_CONFERENCE_ID = enterH243ConferenceID_chosen
} H245_CONFER_REQ_ENUM_T;

typedef struct
{
  H245_CONFER_REQ_ENUM_T  RequestType;
  unsigned char           byMcuNumber;
  unsigned char           byTerminalNumber;
} H245_CONFER_REQ_T;

typedef enum
{
  H245_RSP_MC_TERMINAL_ID           = mCTerminalIDResponse_chosen,
  H245_RSP_TERMINAL_ID              = terminalIDResponse_chosen,
  H245_RSP_CONFERENCE_ID            = conferenceIDResponse_chosen,
  H245_RSP_PASSWORD                 = passwordResponse_chosen,
  H245_RSP_TERMINAL_LIST            = terminalListResponse_chosen,
  H245_RSP_VIDEO_COMMAND_REJECT     = videoCommandReject_chosen,
  H245_RSP_TERMINAL_DROP_REJECT     = terminalDropReject_chosen,
  H245_RSP_DENIED_CHAIR_TOKEN,
  H245_RSP_GRANTED_CHAIR_TOKEN
} H245_CONFER_RSP_ENUM_T;

typedef struct
{
  H245_CONFER_RSP_ENUM_T  ResponseType;
  unsigned char           byMcuNumber;
  unsigned char           byTerminalNumber;
  unsigned char          *pOctetString;
  unsigned char           byOctetStringLength;
  TerminalLabel          *pTerminalList;
  unsigned short          wTerminalListCount;
} H245_CONFER_RSP_T;

typedef enum
{
  H245_CMD_BROADCAST_CHANNEL        = brdcstMyLgclChnnl_chosen,
  H245_CMD_CANCEL_BROADCAST_CHANNEL = cnclBrdcstMyLgclChnnl_chosen,
  H245_CMD_BROADCASTER              = makeTerminalBroadcaster_chosen,
  H245_CMD_CANCEL_BROADCASTER       = cnclMkTrmnlBrdcstr_chosen,
  H245_CMD_SEND_THIS_SOURCE         = sendThisSource_chosen,
  H245_CMD_CANCEL_SEND_THIS_SOURCE  = cancelSendThisSource_chosen,
  H245_CMD_DROP_CONFERENCE          = dropConference_chosen
} H245_CONFER_CMD_ENUM_T;

typedef struct
{
  H245_CONFER_CMD_ENUM_T  CommandType;
  H245_CHANNEL_T          Channel;
  unsigned char           byMcuNumber;
  unsigned char           byTerminalNumber;
} H245_CONFER_CMD_T;

typedef enum
{
  H245_IND_SBE_NUMBER               = sbeNumber_chosen,
  H245_IND_TERMINAL_NUMBER_ASSIGN   = terminalNumberAssign_chosen,
  H245_IND_TERMINAL_JOINED          = terminalJoinedConference_chosen,
  H245_IND_TERMINAL_LEFT            = terminalLeftConference_chosen,
  H245_IND_SEEN_BY_ONE_OTHER        = seenByAtLeastOneOther_chosen,
  H245_IND_CANCEL_SEEN_BY_ONE_OTHER = cnclSnByAtLstOnOthr_chosen,
  H245_IND_SEEN_BY_ALL              = seenByAll_chosen,
  H245_IND_CANCEL_SEEN_BY_ALL       = cancelSeenByAll_chosen,
  H245_IND_TERMINAL_YOU_ARE_SEEING  = terminalYouAreSeeing_chosen,
  H245_IND_REQUEST_FOR_FLOOR        = requestForFloor_chosen
} H245_CONFER_IND_ENUM_T;

typedef struct
{
  H245_CONFER_IND_ENUM_T  IndicationType;
  unsigned char           bySbeNumber;
  unsigned char           byMcuNumber;
  unsigned char           byTerminalNumber;
} H245_CONFER_IND_T;

typedef enum
{
  H245_SCOPE_CHANNEL_NUMBER   = FCCd_scp_lgclChnnlNmbr_chosen,
  H245_SCOPE_RESOURCE_ID      = FlwCntrlCmmnd_scp_rsrcID_chosen,
  H245_SCOPE_WHOLE_MULTIPLEX  = FCCd_scp_whlMltplx_chosen
} H245_SCOPE_T;

#define H245_NO_RESTRICTION 0xFFFFFFFFL

typedef struct
{
  H245_SCOPE_T           Scope;
  H245_CHANNEL_T         Channel;       // only used if Scope is H245_SCOPE_CHANNEL_NUMBER
  unsigned short         wResourceID;   // only used if Scope is H245_SCOPE_RESOURCE_ID
  unsigned long          dwRestriction; // H245_NO_RESTRICTION if no restriction
} H245_IND_FLOW_CONTROL_T;

/* H245_USERINPUT_T */
typedef enum
{
  H245_USERINPUT_NONSTD = UsrInptIndctn_nnStndrd_chosen,
  H245_USERINPUT_STRING = alphanumeric_chosen
} H245_USERINPUT_KIND_T;

typedef struct
{
  H245_USERINPUT_KIND_T     Kind;
  union
  {
    WCHAR *                           pGenString;
    H245_NONSTANDARD_PARAMETER_T      NonStd;
  } u;
} H245_IND_USERINPUT_T;

typedef struct
{
  H245_CHANNEL_T        LogicalChannelNumber1;
  H245_CHANNEL_T        LogicalChannelNumber2;
  unsigned short        wSkew;
} H245_IND_SKEW_T;

typedef struct
{
  H245_NONSTANDID_T      Identifier;
  unsigned char         *pProductNumber;
  unsigned char          byProductNumberLength;
  unsigned char         *pVersionNumber;
  unsigned char          byVersionNumberLength;
} H245_IND_VENDOR_ID_T;

typedef enum
{
  UNKNOWN,
  REQ_NONSTANDARD,
  REQ_MASTER_SLAVE,
  REQ_TERMCAP_SET,
  REQ_OPEN_LOGICAL_CHANNEL,
  REQ_CLOSE_LOGICAL_CHANNEL,
  REQ_REQUEST_CHANNEL_CLOSE,
  REQ_MULTIPLEX_ENTRY_SEND,
  REQ_REQUEST_MULTIPLEX_ENTRY,
  REQ_REQUEST_MODE,
  REQ_ROUND_TRIP_DELAY,
  REQ_MAINTENANCE_LOOP,
  REQ_COMMUNICATION_MODE,
  REQ_CONFERENCE,
  REQ_H223_ANNEX_A_RECONFIG,
  RSP_NONSTANDARD,
  RSP_MASTER_SLAVE_ACK,
  RSP_MASTER_SLAVE_REJECT,
  RSP_TERMCAP_SET_ACK,
  RSP_TERMCAP_SET_REJECT,
  RSP_OPEN_LOGICAL_CHANNEL_ACK,
  RSP_OPEN_LOGICAL_CHANNEL_REJECT,
  RSP_CLOSE_LOGICAL_CHANNEL_ACK,
  RSP_REQUEST_CHANNEL_CLOSE_ACK,
  RSP_REQUEST_CHANNEL_CLOSE_REJECT,
  RSP_MULTIPLEX_ENTRY_SEND_ACK,
  RSP_MULTIPLEX_ENTRY_SEND_REJECT,
  RSP_REQUEST_MULTIPLEX_ENTRY_ACK,
  RSP_REQUEST_MULTIPLEX_ENTRY_REJECT,
  RSP_REQUEST_MODE_ACK,
  RSP_REQUEST_MODE_REJECT,
  RSP_ROUND_TRIP_DELAY,
  RSP_MAINTENANCE_LOOP_ACK,
  RSP_MAINTENANCE_LOOP_REJECT,
  RSP_COMMUNICATION_MODE,
  RSP_CONFERENCE,
  RSP_H223_ANNEX_A_RECONFIG_ACK,
  RSP_H223_ANNEX_A_RECONFIG_REJECT,
  CMD_NONSTANDARD,
  CMD_MAINTENANCE_LOOP_OFF,
  CMD_SEND_TERMCAP,
  CMD_ENCRYPTION,
  CMD_FLOW_CONTROL,
  CMD_END_SESSION,
  CMD_MISCELLANEOUS,
  CMD_COMMUNICATION_MODE,
  CMD_CONFERENCE,
  IND_NONSTANDARD,
  IND_FUNCTION_NOT_UNDERSTOOD,
  IND_MASTER_SLAVE_RELEASE,
  IND_TERMCAP_SET_RELEASE,
  IND_OPEN_LOGICAL_CHANNEL_CONFIRM,
  IND_REQUEST_CHANNEL_CLOSE_RELEASE,
  IND_MULTIPLEX_ENTRY_SEND_RELEASE,
  IND_REQUEST_MULTIPLEX_ENTRY_RELEASE,
  IND_REQUEST_MODE_RELEASE,
  IND_MISCELLANEOUS,
  IND_JITTER,
  IND_H223_SKEW,
  IND_NEW_ATM_VC,
  IND_USER_INPUT,
  IND_H2250_MAX_SKEW,
  IND_MC_LOCATION,
  IND_CONFERENCE_INDICATION,
  IND_VENDOR_IDENTIFICATION,
  IND_FUNCTION_NOT_SUPPORTED,
} H245_SUBMESSAGE_T;

typedef enum
{
  H245_SYNTAX_ERROR     = syntaxError_chosen,
  H245_SEMANTIC_ERROR   = semanticError_chosen,
  H245_UNKNOWN_FUNCTION = unknownFunction_chosen
} H245_FNS_CAUSE_T;

typedef struct
{
  H245_FNS_CAUSE_T      Cause;
  H245_SUBMESSAGE_T     Type;
} H245_IND_FNS_T;

/**************/
/* H245_IND_T */
/**************/

typedef struct
{
  unsigned long         Indicator;              // Type
  unsigned long         dwPreserved;            // User supplied dwPreserved from H245Init()
  union
  {
    H245_MSTSLV_T            IndMstSlv;         // H245_IND_MSTSLV
                                                // H245_IND_CAP
                                                // H245_IND_CESE_RELEASE
    H245_IND_OPEN_T          IndOpen;           // H245_IND_OPEN
    H245_IND_OPEN_CONF_T     IndOpenConf;       // H245_IND_OPEN_CONF
    H245_IND_CLOSE_T         IndClose;          // H245_IND_CLOSE
    H245_CHANNEL_T           IndReqClose;       // H245_IND_REQ_CLOSE
                                                // H245_IND_CLCSE_RELEASE
    H245_IND_MUXTBL_T        IndMuxTbl;         // H245_IND_MUX_TBL
                                                // H245_IND_MTSE_RELEASE
    H245_RMESE_T             IndRmese;          // H245_IND_RMESE
                                                // H245_IND_RMESE_RELEASE
    H245_IND_MRSE_T          IndMrse;           // H245_IND_MRSE
                                                // H245_IND_MRSE_RELEASE
    H245_MLSE_T              IndMlse;           // H245_IND_MLSE
                                                // H245_IND_MLSE_RELEASE
    H245_IND_NONSTANDARD_T   IndNonstandardRequest; // H245_IND_NONSTANDARD_REQUEST
    H245_IND_NONSTANDARD_T   IndNonstandardResponse; // H245_IND_NONSTANDARD_RESPONSE
    H245_IND_NONSTANDARD_T   IndNonstandardCommand; // H245_IND_NONSTANDARD_COMMAND
    H245_IND_NONSTANDARD_T   IndNonstandard;    // H245_IND_NONSTANDARD
                                                // H245_IND_MISC_COMMAND
                                                // H245_IND_MISC
                                                // H245_IND_COMM_MODE_REQUEST
    H245_IND_COMM_MODE_T     IndCommRsp;        // H245_IND_COMM_MODE_RESPONSE
    H245_IND_COMM_MODE_T     IndCommCmd;        // H245_IND_COMM_MODE_COMMAND
    H245_CONFER_REQ_T        IndConferReq;      // H245_IND_CONFERENCE_REQUEST
    H245_CONFER_RSP_T        IndConferRsp;      // H245_IND_CONFERENCE_RESPONSE
    H245_CONFER_CMD_T        IndConferCmd;      // H245_IND_CONFERENCE_COMMAND
    H245_CONFER_IND_T        IndConfer;         // H245_IND_CONFERENCE
                                                // H245_IND_SEND_TERMCAP
                                                // H245_IND_ENCRYPTION
    H245_IND_FLOW_CONTROL_T  IndFlowControl;    // H245_IND_FLOW_CONTROL
    H245_IND_ENDSESSION_T    IndEndSession;     // H245_IND_ENDSESSION
                                                // H245_IND_FUNCTION_NOT_UNDERSTOOD
                                                // H245_IND_JITTER
    H245_IND_SKEW_T          IndH223Skew;       // H245_IND_H223_SKEW
                                                // H245_IND_NEW_ATM_VC
    H245_IND_USERINPUT_T     IndUserInput;      // H245_IND_USERINPUT
    H245_IND_SKEW_T          IndH2250MaxSkew;   // H245_IND_H2250_MAX_SKEW
    H245_TRANSPORT_ADDRESS_T IndMcLocation;     // H245_IND_MC_LOCATION
    H245_IND_VENDOR_ID_T     IndVendorId;       // H245_IND_VENDOR_ID
    H245_IND_FNS_T           IndFns;            // H245_IND_FUNCTION_NOT_SUPPORTED
                                                // H245_IND_H223_RECONFIG
                                                // H245_IND_H223_RECONFIG_ACK
                                                // H245_IND_H223_RECONFIG_REJECT
  } u;
} H245_IND_T;


/********************/
/********************/
/*  Confirm   Code  */
/********************/
/********************/

#define H245_CONF_INIT_MSTSLV    0x101
#define H245_CONF_SEND_TERMCAP   0x102
#define H245_CONF_OPEN           0x103
#define H245_CONF_NEEDRSP_OPEN   0x104
#define H245_CONF_CLOSE          0x105
#define H245_CONF_REQ_CLOSE      0x106
#define H245_CONF_MUXTBL_SND     0x107

#define H245_CONF_RMESE          0x109
#define H245_CONF_RMESE_REJECT   0x10A
#define H245_CONF_RMESE_EXPIRED  0x10B
#define H245_CONF_MRSE           0x10C
#define H245_CONF_MRSE_REJECT    0x10D
#define H245_CONF_MRSE_EXPIRED   0x10E
#define H245_CONF_MLSE           0x10F
#define H245_CONF_MLSE_REJECT    0x110
#define H245_CONF_MLSE_EXPIRED   0x111
#define H245_CONF_RTDSE          0x112
#define H245_CONF_RTDSE_EXPIRED  0x113

/* H245_CONF_SEND_TERMCAP_T */
typedef struct
{
  H245_ACC_REJ_T        AccRej;

} H245_CONF_SEND_TERMCAP_T;

/* H245_CONF_OPEN_T */
typedef struct
{
  H245_ACC_REJ_T        AccRej;
  H245_CHANNEL_T        TxChannel;
  H245_MUX_T *          pTxMux;         // optional
  H245_CHANNEL_T        RxChannel;      // bi-dir only
  H245_MUX_T *          pRxMux;         // bi-dir only
  H245_PORT_T           RxPort;         // bi-dir only
  H245_ACCESS_T *       pSeparateStack; // optional

} H245_CONF_OPEN_T;

typedef H245_CONF_OPEN_T H245_CONF_NEEDRSP_OPEN_T;

/* H245_CONF_CLOSE_T */
typedef struct
{
  H245_ACC_REJ_T        AccRej;
  H245_CHANNEL_T        Channel;

} H245_CONF_CLOSE_T;

/* H245_CONF_REQ_CLOSE_T */
typedef H245_CONF_CLOSE_T H245_CONF_REQ_CLOSE_T;

/* H245_CONF_MUXTBL_T */
typedef struct
{
  H245_ACC_REJ_T        AccRej;
  unsigned long         MuxEntryId;

} H245_CONF_MUXTBL_T;



/***************/
/* H245_CONF_T */
/***************/

typedef struct
{
  unsigned long         Confirm;                // Type
  unsigned long         dwPreserved;            // User supplied dwPreserved from H245Init()
  unsigned long         dwTransId;              // User supplied dwTransId from originating call
  HRESULT               Error;                  // Error code
  union                                         // Data for specific indications:
  {
    H245_MSTSLV_T             ConfMstSlv;       // H245_CONF_INIT_MSTSLV
    H245_CONF_SEND_TERMCAP_T  ConfSndTcap;      // H245_CONF_SEND_TERMCAP
    H245_CONF_OPEN_T          ConfOpen;         // H245_CONF_OPEN
    H245_CONF_NEEDRSP_OPEN_T  ConfOpenNeedRsp;  // H245_CONF_NEEDRSP_OPEN
    H245_CONF_CLOSE_T         ConfClose;        // H245_CONF_CLOSE
    H245_CONF_REQ_CLOSE_T     ConfReqClose;     // H245_CONF_REQ_CLOSE
    H245_CONF_MUXTBL_T        ConfMuxSnd;       // H245_CONF_MUXTBL_SND
    H245_RMESE_T              ConfRmese;        // H245_CONF_RMESE
    H245_RMESE_T              ConfRmeseReject;  // H245_CONF_RMESE_REJECT
                                                // H245_CONF_RMESE_EXPIRED
    unsigned short            ConfMrse;         // H245_CONF_MRSE
    unsigned short            ConfMrseReject;   // H245_CONF_MRSE_REJECT
                                                // H245_CONF_MRSE_EXPIRED
    H245_MLSE_T               ConfMlse;         // H245_CONF_MLSE
    H245_MLSE_T               ConfMlseReject;   // H245_CONF_MLSE_REJECT
                                                // H245_CONF_MLSE_EXPIRED
                                                // H245_CONF_RTDSE
                                                // H245_CONF_RTDSE_EXPIRED
  } u;
} H245_CONF_T;



typedef enum
{
  H245_MESSAGE_REQUEST     = MltmdSystmCntrlMssg_rqst_chosen,
  H245_MESSAGE_RESPONSE    = MSCMg_rspns_chosen,
  H245_MESSAGE_COMMAND     = MSCMg_cmmnd_chosen,
  H245_MESSAGE_INDICATION  = indication_chosen
} H245_MESSAGE_TYPE_T;



/*******************/
/* H245_CONF_IND_T */
/*******************/
typedef enum
{
  H245_CONF = 1,
  H245_IND
} H245_CONF_IND_KIND_T;

typedef struct
{
  H245_CONF_IND_KIND_T  Kind;
  union
  {
    H245_CONF_T         Confirm;
    H245_IND_T          Indication;
  } u;

} H245_CONF_IND_T;



/***************************/
/* SYSTEM CONTROL MESSAGES */
/***************************/

typedef struct
{
  unsigned long NumPduTx;       /* number of tranmitted pdu's    */
  unsigned long NumPduRx;       /* number of received pdu's      */
  unsigned long NumCRCErrors;   /* number of crc errors          */
  unsigned long NumPduReTx;     /* number of pdu's retransmitted */

} H245_SYSCON_STATS_T;

#define H245_SYSCON_TRACE_LVL           0x0100  /* pData = &dwTraceLevel   */
#define H245_SYSCON_DUMP_TRACKER        0x0200  /* pData = NULL (debug)    */
#define H245_SYSCON_GET_STATS           0x0300  /* pData = &H245_SYSCON_STATS_T */
#define H245_SYSCON_RESET_STATS         0x0400  /* pData = NULL            */

#define H245_SYSCON_SET_FSM_N100        0x1000  /* pData = &dwRetryCount   */
#define H245_SYSCON_SET_FSM_T101        0x1100  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T102        0x1200  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T103        0x1300  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T104        0x1400  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T105        0x1500  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T106        0x1600  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T107        0x1700  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T108        0x1800  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T109        0x1900  /* pData = &dwMilliseconds */

#define H245_SYSCON_GET_FSM_N100        0x2000  /* pData = &dwRetryCount   */
#define H245_SYSCON_GET_FSM_T101        0x2100  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T102        0x2200  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T103        0x2300  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T104        0x2400  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T105        0x2500  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T106        0x2600  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T107        0x2700  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T108        0x2800  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T109        0x2900  /* pData = &dwMilliseconds */



/************************/
/* PROTOCOL ID FOR H245 */
/************************/

#define H245_PROTOID                    "0.0.8.245.0.2"



/**************************************************/
/* API Procedure Call Typedefs and API Prototypes */
/**************************************************/

typedef unsigned long H245_INST_T;
typedef HRESULT (*H245_CONF_IND_CALLBACK_T)(H245_CONF_IND_T *, void *);
typedef int (*H245_CAP_CALLBACK_T)(unsigned long, H245_TOTCAP_T *);
typedef int (*H245_CAPDESC_CALLBACK_T)(unsigned long, H245_TOTCAPDESC_T *);

#ifdef __cplusplus
extern "C" {
#endif

H245DLL H245_INST_T
H245Init                (
                         H245_CONFIG_T            Configuration,
                         unsigned long            dwPhysId,
                         unsigned long            *pdwLinkLayerPhysId,
                         unsigned long            dwPreserved,
                         H245_CONF_IND_CALLBACK_T CallBack,
                         unsigned char            byTerminalType
                        );

H245DLL H245_INST_T
H245GetInstanceId       (unsigned long          dwPhysicalId);

H245DLL HRESULT
H245EndSession          (
                         H245_INST_T                    dwInst,
                         H245_ENDSESSION_T              Mode,
                         const H245_NONSTANDARD_PARAMETER_T * pNonStd
                        );

H245DLL HRESULT
H245ShutDown            (H245_INST_T            dwInst);

H245DLL HRESULT
H245InitMasterSlave     (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId
                        );

H245DLL HRESULT
H245SetLocalCap         (
                         H245_INST_T            dwInst,
                         H245_TOTCAP_T *        pTotCap,
                         H245_CAPID_T  *        pCapId
                        );

H245DLL HRESULT
H245DelLocalCap         (
                         H245_INST_T            dwInst,
                         H245_CAPID_T           CapId
                        );

H245DLL HRESULT
H245SetCapDescriptor    (
                         H245_INST_T            dwInst,
                         H245_CAPDESC_T        *pCapDesc,
                         H245_CAPDESCID_T      *pCapDescId
                        );

H245DLL HRESULT
H245DelCapDescriptor    (
                         H245_INST_T            dwInst,
                         H245_CAPDESCID_T       CapDescId
                        );

H245DLL HRESULT
H245SendTermCaps        (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId
                        );

H245DLL HRESULT
H245EnumCaps            (
                         H245_INST_T              dwInst,
                         unsigned long            dwTransId,
                         H245_CAPDIR_T            Direction,
                         H245_DATA_T              DataType,
                         H245_CLIENT_T            ClientType,
                         H245_CAP_CALLBACK_T      pfCapCallback,
                         H245_CAPDESC_CALLBACK_T  pfCapDescCallback
                        );

H245DLL HRESULT
H245GetCaps             (
                         H245_INST_T            dwInst,
                         H245_CAPDIR_T          Direction,
                         H245_DATA_T            DataType,
                         H245_CLIENT_T          ClientType,
                         H245_TOTCAP_T      * * ppTotCap,
                         unsigned long *        pdwTotCapLen,
                         H245_TOTCAPDESC_T  * * ppCapDesc,
                         unsigned long *        pdwCapDescLen
                        );

H245DLL HRESULT
H245CopyCap             (H245_TOTCAP_T		   **ppDestTotCap,
						 const H245_TOTCAP_T   *pTotCap);

H245DLL HRESULT
H245FreeCap             (H245_TOTCAP_T          *pTotCap);

H245DLL HRESULT
H245CopyCapDescriptor   (H245_TOTCAPDESC_T		 **ppDestCapDesc,
						 const H245_TOTCAPDESC_T *pCapDesc);

H245DLL HRESULT
H245FreeCapDescriptor   (H245_TOTCAPDESC_T     *pCapDesc);

H245DLL H245_MUX_T *
H245CopyMux             (const H245_MUX_T *     pMux);

H245DLL HRESULT
H245FreeMux             (H245_MUX_T *           pMux);

H245DLL HRESULT
H245OpenChannel         (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_CHANNEL_T         wTxChannel,
                         const H245_TOTCAP_T *  pTxMode,
                         const H245_MUX_T    *  pTxMux,
                         H245_PORT_T            dwTxPort,       // optional
                         const H245_TOTCAP_T *  pRxMode,        // bi-dir only
                         const H245_MUX_T    *  pRxMux,         // bi-dir only
                         const H245_ACCESS_T *  pSeparateStack  // optional
                        );

H245DLL HRESULT
H245OpenChannelAccept   (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_CHANNEL_T         wRxChannel,     // RxChannel from IND_OPEN
                         const H245_MUX_T *     pRxMux,         // optional H2250LogicalChannelAckParameters
                         H245_CHANNEL_T         wTxChannel,     // bi-dir only
                         const H245_MUX_T *     pTxMux,         // bi-dir only optional H2250LogicalChannelParameters
                         H245_PORT_T            dwTxPort,       // bi-dir only optional
                         const H245_ACCESS_T *  pSeparateStack  // optional
                        );

H245DLL HRESULT
H245OpenChannelReject   (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wRxChannel, // RxChannel from IND_OPEN
                         unsigned short         wCause
                        );

H245DLL HRESULT
H245CloseChannel        (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_CHANNEL_T         wTxChannel
                        );

H245DLL HRESULT
H245CloseChannelReq     (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_CHANNEL_T         wRxChannel
                        );

H245DLL HRESULT
H245CloseChannelReqResp (
                         H245_INST_T            dwInst,
                         H245_ACC_REJ_T         AccRej,
                         H245_CHANNEL_T         wChannel
                        );

H245DLL HRESULT
H245SendLocalMuxTable   (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_MUX_TABLE_T      *pMuxTable
                        );

H245DLL HRESULT
H245MuxTableIndResp     (
                         H245_INST_T            dwInst,
                         H245_ACC_REJ_MUX_T     AccRejMux,
                         unsigned long          dwCount
                        );

H245DLL HRESULT
H245RequestMultiplexEntry (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         const unsigned short * pwMultiplexTableEntryNumbers,
                         unsigned long          dwCount
                        );

H245DLL HRESULT
H245RequestMultiplexEntryAck (
                         H245_INST_T            dwInst,
                         const unsigned short * pwMultiplexTableEntryNumbers,
                         unsigned long          dwCount
                        );

H245DLL HRESULT
H245RequestMultiplexEntryReject (
                         H245_INST_T            dwInst,
                         const unsigned short * pwMultiplexTableEntryNumbers,
                         unsigned long          dwCount
                        );

/*
H245DLL HRESULT
H245RequestMode         (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         const ModeElement *    pModeElements,
                         unsigned long          dwCount
                        );
*/
H245DLL HRESULT
H245RequestMode         (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
//                         const ModeElement *    pModeElements,
//tomitowoju@intel.com
						 ModeDescription 		ModeDescriptions[],
//tomitowoju@intel.com
                         unsigned long          dwCount
                        ) ;



H245DLL HRESULT
H245RequestModeAck      (
                         H245_INST_T            dwInst,
                         unsigned short         wResponse
                        );

H245DLL HRESULT
H245RequestModeReject   (
                         H245_INST_T            dwInst,
                         unsigned short         wCause
                        );

H245DLL HRESULT
H245RoundTripDelayRequest (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId
                        );

H245DLL HRESULT
H245MaintenanceLoop     (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_LOOP_TYPE_T       dwLoopType,
                         H245_CHANNEL_T         wChannel
                        );

H245DLL HRESULT
H245MaintenanceLoopRelease (H245_INST_T         dwInst);

H245DLL HRESULT
H245MaintenanceLoopAccept (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wChannel
                        );

H245DLL HRESULT
H245MaintenanceLoopReject (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wChannel,
                         unsigned short         wCause
                        );

H245DLL HRESULT
H245NonStandardObject   (
                         H245_INST_T            dwInst,
                         H245_MESSAGE_TYPE_T    MessageType,
                         const unsigned char *  pData,
                         unsigned long          dwDataLength,
                         const unsigned short * pwObjectId,
                         unsigned long          dwObjectIdLength
                        );

H245DLL HRESULT
H245NonStandardH221     (
                         H245_INST_T            dwInst,
                         H245_MESSAGE_TYPE_T    MessageType,
                         const unsigned char *  pData,
                         unsigned long          dwDataLength,
                         unsigned char          byCountryCode,
                         unsigned char          byExtension,
                         unsigned short         wManufacturerCode
                        );

H245DLL HRESULT
H245CommunicationModeRequest(H245_INST_T            dwInst);

H245DLL HRESULT
H245CommunicationModeResponse(
                         H245_INST_T            dwInst,
                         const H245_COMM_MODE_ENTRY_T *pTable,
                         unsigned char          byTableCount
                        );

H245DLL HRESULT
H245CommunicationModeCommand(
                         H245_INST_T            dwInst,
                         const H245_COMM_MODE_ENTRY_T *pTable,
                         unsigned char          byTableCount
                        );

H245DLL HRESULT
H245ConferenceRequest   (
                         H245_INST_T            dwInst,
                         H245_CONFER_REQ_ENUM_T RequestType,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber
                        );

H245DLL HRESULT
H245ConferenceResponse  (
                         H245_INST_T            dwInst,
                         H245_CONFER_RSP_ENUM_T ResponseType,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber,
                         const unsigned char   *pOctetString,
                         unsigned char          byOctetStringLength,
                         const TerminalLabel   *pTerminalList,
                         unsigned short         wTerminalListCount
                        );

H245DLL HRESULT
H245ConferenceCommand   (
                         H245_INST_T            dwInst,
                         H245_CONFER_CMD_ENUM_T CommandType,
                         H245_CHANNEL_T         Channel,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber
                        );

H245DLL HRESULT
H245ConferenceIndication(
                         H245_INST_T            dwInst,
                         H245_CONFER_IND_ENUM_T IndicationType,
                         unsigned char          bySbeNumber,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber
                        );

H245DLL HRESULT
H245UserInput           (
                         H245_INST_T                    dwInst,
                         const WCHAR *                  pGenString,
                         const H245_NONSTANDARD_PARAMETER_T * pNonStd
                        );

H245DLL HRESULT
H245FlowControl         (
                         H245_INST_T            dwInst,
                         H245_SCOPE_T           Scope,
                         H245_CHANNEL_T         Channel,       // only used if Scope is H245_SCOPE_CHANNEL_NUMBER
                         unsigned short         wResourceID,   // only used if Scope is H245_SCOPE_RESOURCE_ID
                         unsigned long          dwRestriction  // H245_NO_RESTRICTION if no restriction
                        );

H245DLL HRESULT
H245H223SkewIndication  (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wLogicalChannelNumber1,
                         H245_CHANNEL_T         wLogicalChannelNumber2,
                         unsigned short         wSkew
                        );

H245DLL HRESULT
H245H2250MaximumSkewIndication(
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wLogicalChannelNumber1,
                         H245_CHANNEL_T         wLogicalChannelNumber2,
                         unsigned short         wMaximumSkew
                        );

H245DLL HRESULT
H245MCLocationIndication(
                         H245_INST_T                dwInst,
                         const H245_TRANSPORT_ADDRESS_T * pSignalAddress
                        );

H245DLL HRESULT
H245VendorIdentification(
                         H245_INST_T            dwInst,
                         const H245_NONSTANDID_T *pIdentifier,
                         const unsigned char   *pProductNumber,       // optional
                         unsigned char          byProductNumberLength,// optional
                         const unsigned char   *pVersionNumber,       // optional
                         unsigned char          byVersionNumberLength // optional
                        );

H245DLL HRESULT
H245SendPDU             (
                         H245_INST_T            dwInst,
                         PDU_T *                pPdu
                        );

H245DLL HRESULT
H245SystemControl       (
                         H245_INST_T            dwInst,
                         unsigned long          dwRequest,
                         void   *               pData
                        );

#ifdef __cplusplus
        }
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\intelcc\include\cpls.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/

#ifndef __CPLS_H
#define __CPLS_H

#include <limits.h>

#ifdef WIN32
	#include <windows.h>
	#include <windowsx.h> 
	#include "port32.h"
#endif

#ifdef _WINDOWS
	#ifndef _MSWINDOWS_
		#define _MSWINDOWS_
	#endif
#endif

typedef int HLOG;                          

#ifndef FALSE
	#define FALSE   0
#endif

#ifndef TRUE
	#define TRUE    1
#endif
#ifdef WIN32
	#ifdef BUILDING_CPLS_DLL
		#define CPLS_FAREXPORT __declspec(dllexport)
		#define CPLS_EXPORT __declspec(dllexport)
	#else
		#define CPLS_FAREXPORT __declspec(dllimport)
		#define CPLS_EXPORT __declspec(dllimport)
	#endif
	#ifndef EXPORT
		#define EXPORT
	#endif	// EXPORT
#elif _MSWINDOWS_
	#ifndef CALLBACK
		#define CALLBACK _far _pascal
	#endif
	#ifdef BUILDING_CPLS_DLL
		#define CPLS_FAREXPORT _far _export _pascal
		#define CPLS_EXPORT _export
	#else
		#define CPLS_FAREXPORT _far _pascal
		#define CPLS_EXPORT
	#endif
	#ifndef EXPORT
		#define EXPORT _export
	#endif	// EXPORT
	#ifndef FAR
		#define FAR _far
	#endif
#else    
	#ifndef CALLBACK
		#define CALLBACK      
	#endif
	#define CPLS_FAREXPORT
	#ifndef EXPORT
		#define EXPORT  
	#endif
	#ifndef FAR
		#define FAR
	#endif
#endif  // _MSWINDOWS_  


typedef int BOOL;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef const char FAR* CPLProtocol;
typedef int CPLProtocolID;

#define CONFIG_FILENAME "CPLS.INI"    // internal use only

// Pre-defined event and event category constants.
//
#define String_Event USHRT_MAX
#define Binary_Event USHRT_MAX-1

#define String_Category USHRT_MAX
#define Binary_Category USHRT_MAX-1

#ifdef __cplusplus      
	class CProtocolLog;
	class CProtocolEvent;
	typedef CProtocolEvent FAR* (CALLBACK *CPLEventGenesisProc)( 
															BYTE FAR* pObject,              // in
															CProtocolLog FAR* pSourceLog,   // in
															BOOL bCopyObject );             // in
extern "C"{

// This first one is only for C++ clients...
void CPLS_FAREXPORT CPLRegisterEventGenesisProc( CPLProtocolID ProtocolID, CPLEventGenesisProc pfnGenesisProc );

#endif  // __cplusplus

// Possible file mode values for CPLOpen().
//
#define CPLS_CREATE 0		// Will overwrite an existing file.
#define CPLS_APPEND 1		// Will append to an existing file, or create a new one.

/////////////////////////////////////////////////////////////////////////////
// 					PROTOCOL LOGGING FUNCTIONS
//
// Here is the sequence of functions to call for use of a protocol logger:
//		1) CPLInitialize() or CPLINTInitialize()
//		2) CPLOpen()
//		3) CPLOutput*() or CPLINTOutput*() -- repeat as necessary
//		4) CPLClose()
//		5) CPLUninitialize()
//
// CPLInitialize() - Creates a protocol logger.
// CPLINTInitialize() - The version of CPLInitialize() which must be called
//		by clients which will be calling the CPLINTOuptut*() functions within
//		interrupt context.  CPLINTInitialize may not be called within
//		interrupt context.
// CPLUninitialize() - Releases a protocol logger.  This must be called for
//		every initialized logger before shutdown in order to free associated
//		memory.
// CPLOpen() - Associates a protocol logger with a file (output stream).
// CPLClose() - Releases a logger's usage of a stream.  This function does
//		not block.  A "close" event is placed on the event queue of the
//		stream.  Release of the stream occurs when this "close" event is
//		serviced.
// CPLOutputDebug() - 
// CPLINTOutputDebug() - The version of CPLOutputDebug() safely callable
//		within interrupt context.
// CPLOutputAscii() - 
// CPLINTOutputAscii() - The version of CPLOutputAscii() safely callable
//		within interrupt context.
// CPLOutput() - 
// CPLINTOutput() - The version of CPLOutput() safely callable
//		within interrupt context.
// CPLFlush() - Flushes all events to the stream of the specified logger.
//		Blocks until the flush is complete.
// CPLINTFlush() -  The version of CPLFlush() safely callable within
//		interrupt context.  This version does not block.  A "flush" message
//		is sent to CPLS.  The flush occurs when this flush message is
//		serviced.
// CPLFlushAndClose() -
// CPLEnable() - Enables or disables protocol logging at runtime.
// CPLEnableAsync() - Sets synchronous or asynchronous logging output mode.
//		CURRENTLY NOT SUPPORTED.
// CPLLogAscii() - 
// CPLINTLogAscii() - The version of CPLLogAscii() safely callable
//		within interrupt context.
//
// Only these functions may be called from within interrupt context:
//		CPLINTOutputDebug()
//		CPLINTOutputAscii()
//		CPLINTOutput()
//		CPLINTFlush()
//		CPLEnable()
//		CPLINTLogAscii()
/////////////////////////////////////////////////////////////////////////////
CPLProtocolID CPLS_FAREXPORT WINAPI CPLInitialize( CPLProtocol Protocol );

CPLProtocolID CPLS_FAREXPORT CPLINTInitialize( CPLProtocol Protocol );

int  CPLS_FAREXPORT WINAPI CPLUninitialize( HLOG hlog );

HLOG CPLS_FAREXPORT WINAPI CPLOpen( CPLProtocolID ProtocolID, 
							const char FAR* szName, 
							int FileMode );
HLOG CPLS_FAREXPORT CPLINTOpen( CPLProtocolID ProtocolID, 
							const char FAR* szName, 
							int FileMode );
int  CPLS_FAREXPORT WINAPI CPLClose( HLOG hLog );

int  CPLS_FAREXPORT CPLOutputDebug( HLOG hLog, 
							const char FAR* szString );
int  CPLS_FAREXPORT CPLINTOutputDebug( HLOG hLog, 
							const char FAR* szString );

int  CPLS_FAREXPORT CPLOutputAscii( HLOG hLog, 
							WORD EventID, 
							const char FAR* szEvent, 
							BYTE FAR* pData, 
							int nDataBytes, 
							WORD EventCategory, 
							unsigned long UserData );
int  CPLS_FAREXPORT CPLINTOutputAscii( HLOG hLog, 
							WORD EventID, 
							const char FAR* szEvent, 
							BYTE FAR* pData, 
							int nDataBytes, 
							WORD EventCategory, 
							unsigned long UserData );

int  CPLS_FAREXPORT WINAPI CPLOutput( HLOG hLog, 
							BYTE FAR* pData, 
							int nDataBytes,
							unsigned long UserData );
int  CPLS_FAREXPORT CPLINTOutput( HLOG hLog, 
							BYTE FAR* pData, 
							int nDataBytes,
							unsigned long UserData );

int  CPLS_FAREXPORT CPLFlush( HLOG hLog );
int  CPLS_FAREXPORT CPLINTFlush( HLOG hLog );
int  CPLS_FAREXPORT CPLFlushAndClose( HLOG hLog );

void CPLS_FAREXPORT CPLEnable( BOOL bEnable );
//void CPLS_FAREXPORT CPLEnableAsync( BOOL bEnable );

#ifdef __cplusplus
};      // extern "C"
#endif  // __cplusplus

#define CPLLogAscii( hLog, \
				EventID, \
				pData, \
				nDataBytes, \
				EventCategory, \
				UserData ) \
		CPLOutputAscii( hLog, EventID, #EventID, pData, nDataBytes, EventCategory, UserData )

#define CPLINTLogAscii( hLog, \
				EventID, \
				pData, \
				nDataBytes, \
				EventCategory, \
				UserData ) \
		CPLINTOutputAscii( hLog, EventID, #EventID, pData, nDataBytes, EventCategory, UserData )
		
#endif  // __CPLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\intelcc\include\gkiexp.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1997 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *																	   *
 *	$Archive:   S:\sturgeon\src\include\vcs\gkiexp.h_v  $
 *
 *	$Revision:   1.7  $
 *	$Date:   11 Feb 1997 15:37:30  $
 *
 *	$Author:   CHULME  $															*
 *
 *	$Log:   S:\sturgeon\src\include\vcs\gkiexp.h_v  $
 * 
 *    Rev 1.7   11 Feb 1997 15:37:30   CHULME
 * Added GKI_CleanupRequest function
 * 
 *    Rev 1.6   16 Jan 1997 15:25:00   BPOLING
 * changed copyrights to 1997
 * 
 *    Rev 1.5   17 Dec 1996 18:23:36   CHULME
 * Change interface to use Remote rather than destination for AdmissionRequest
 * 
 *    Rev 1.4   09 Dec 1996 14:13:40   EHOWARDX
 * Updated copyright notice.
 *                                                                     * 
 ***********************************************************************/

// gkiexp.h : header file
//

#ifndef GKIEXP_H
#define GKIEXP_H

#ifdef __cplusplus
extern "C" {
#endif

#include "GKICOM.H"

#ifndef DLL_EXPORT
#define DLL_EXPORT __declspec(dllexport)
#endif
#ifndef DLL_IMPORT
#define DLL_IMPORT __declspec(dllimport)
#endif

// ------------------------ Variable Imports --------------------------
extern DLL_IMPORT DWORD dwGKIDLLFlags;
extern DLL_IMPORT BOOL  fGKIEcho;
extern DLL_IMPORT BOOL  fGKIDontSend;
#if 0 //NSMWrap
extern DLL_IMPORT BOOL  fNSMWrapper;
#endif

// ------------------------ Function Imports --------------------------
HRESULT DLL_IMPORT GKI_RegistrationRequest(long             lVersion,
                                    SeqTransportAddr     *pCallSignalAddr, 
                                    EndpointType         *pTerminalType,
                                    SeqAliasAddr         *pAliasAddr, 
                                    HWND                 hWnd,
                                    WORD                 wBaseMessage,
                                    unsigned short       usRegistrationTransport /* = ipAddress_chosen */);

HRESULT DLL_IMPORT GKI_UnregistrationRequest(void);

HRESULT DLL_IMPORT GKI_LocationRequest(SeqAliasAddr         *pLocationInfo);

HRESULT DLL_IMPORT GKI_AdmissionRequest(unsigned short      usCallTypeChoice,
                                    SeqAliasAddr         *pRemoteInfo,
                                    TransportAddress     *pRemoteCallSignalAddress,
                                    SeqAliasAddr         *pDestExtraCallInfo,
                                    BandWidth            bandWidth,
                                    ConferenceIdentifier *pConferenceID,
                                    BOOL                 activeMC,
                                    BOOL                 answerCall,
                                    unsigned short       usCallTransport /* = ipAddress_chosen */);

HRESULT DLL_IMPORT GKI_BandwidthRequest(HANDLE              hModCall, 
                                    unsigned short       usCallTypeChoice,
                                    BandWidth            bandWidth);

HRESULT DLL_IMPORT GKI_DisengageRequest(HANDLE hCall);
HRESULT DLL_IMPORT GKI_Initialize(void);
HRESULT DLL_IMPORT GKI_CleanupRequest(void);

#ifdef _DEBUG
WORD DLL_IMPORT Dump_GKI_RegistrationRequest(long        lVersion, 
                                    SeqTransportAddr     *pCallSignalAddr, 
                                    EndpointType         *pTerminalType,
                                    SeqAliasAddr         *pAliasAddr, 
                                    HWND                 hWnd,
                                    WORD                 wBaseMessage,
                                    unsigned short       usRegistrationTransport /* = ipAddress_chosen */);

WORD DLL_IMPORT Dump_GKI_LocationRequest(SeqAliasAddr    *pLocationInfo);

WORD DLL_IMPORT Dump_GKI_AdmissionRequest(unsigned short usCallTypeChoice,
                                    SeqAliasAddr         *pDestinationInfo,
                                    TransportAddress     *pDestCallSignalAddress,
                                    SeqAliasAddr         *pDextExtraCallInfo,
                                    BandWidth            bandWidth,
                                    ConferenceIdentifier *pConferenceID,
                                    BOOL                 activeMC,
                                    BOOL                 answerCall,
                                    unsigned short       usCallTransport /* = ipAddress_chosen */);

WORD DLL_IMPORT Dump_GKI_LocationRequest(SeqAliasAddr    *pLocationInfo);
#endif // _DEBUG

#ifdef __cplusplus
}
#endif // __cplusplus

#endif //GKIEXP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\intelcc\include\h245asn.h ===
#ifndef _H245ASN_Module_H_
#define _H245ASN_Module_H_

#include "nmasn1.h"
#ifdef __cplusplus
extern "C" {
#endif

typedef struct UnicastAddress_iPSourceRouteAddress_route * PUnicastAddress_iPSourceRouteAddress_route;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers * PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers;

typedef struct MultiplexElement_type_subElementList * PMultiplexElement_type_subElementList;

typedef struct MultipointCapability_mediaDistributionCapability * PMultipointCapability_mediaDistributionCapability;

typedef struct H222Capability_vcCapability * PH222Capability_vcCapability;

typedef struct CapabilityDescriptor_simultaneousCapabilities * PCapabilityDescriptor_simultaneousCapabilities;

typedef struct CommunicationModeTableEntry_nonStandard * PCommunicationModeTableEntry_nonStandard;

typedef struct MultiplexEntrySend_multiplexEntryDescriptors * PMultiplexEntrySend_multiplexEntryDescriptors;

typedef struct H2250LogicalChannelAckParameters_nonStandard * PH2250LogicalChannelAckParameters_nonStandard;

typedef struct H2250LogicalChannelParameters_nonStandard * PH2250LogicalChannelParameters_nonStandard;

typedef struct ConferenceCapability_nonStandardData * PConferenceCapability_nonStandardData;

typedef struct MediaDistributionCapability_distributedData * PMediaDistributionCapability_distributedData;

typedef struct MediaDistributionCapability_centralizedData * PMediaDistributionCapability_centralizedData;

typedef struct CommunicationModeResponse_communicationModeTable * PCommunicationModeResponse_communicationModeTable;

typedef struct CommunicationModeCommand_communicationModeTable * PCommunicationModeCommand_communicationModeTable;

typedef struct RequestMode_requestedModes * PRequestMode_requestedModes;

typedef struct TerminalCapabilitySet_capabilityTable * PTerminalCapabilitySet_capabilityTable;

typedef struct UnicastAddress_iPSourceRouteAddress_route_Seq {
    ASN1uint32_t length;
    ASN1octet_t value[4];
} UnicastAddress_iPSourceRouteAddress_route_Seq;

typedef ASN1uint16_t SequenceNumber;

typedef ASN1uint16_t CapabilityTableEntryNumber;

typedef ASN1uint16_t CapabilityDescriptorNumber;

typedef ASN1uint16_t LogicalChannelNumber;

typedef ASN1uint16_t MultiplexTableEntryNumber;

typedef ASN1uint16_t McuNumber;

typedef ASN1uint16_t TerminalNumber;

typedef struct TerminalID {
    ASN1uint32_t length;
    ASN1octet_t value[128];
} TerminalID;

typedef struct ConferenceID {
    ASN1uint32_t length;
    ASN1octet_t value[32];
} ConferenceID;

typedef struct Password {
    ASN1uint32_t length;
    ASN1octet_t value[32];
} Password;

typedef struct NewATMVCIndication_aal_aal1_errorCorrection {
    ASN1choice_t choice;
#   define nullErrorCorrection_chosen 1
#   define longInterleaver_chosen 2
#   define shortInterleaver_chosen 3
#   define errorCorrectionOnly_chosen 4
} NewATMVCIndication_aal_aal1_errorCorrection;

typedef struct NewATMVCIndication_aal_aal1_clockRecovery {
    ASN1choice_t choice;
#   define nullClockRecovery_chosen 1
#   define srtsClockRecovery_chosen 2
#   define adaptiveClockRecovery_chosen 3
} NewATMVCIndication_aal_aal1_clockRecovery;

typedef struct V76LogicalChannelParameters_mode_eRM_recovery {
    ASN1choice_t choice;
#   define rej_chosen 1
#   define sREJ_chosen 2
#   define mSREJ_chosen 3
} V76LogicalChannelParameters_mode_eRM_recovery;

typedef struct VCCapability_availableBitRates_type_rangeOfBitRates {
    ASN1uint16_t lowerBitRate;
    ASN1uint16_t higherBitRate;
} VCCapability_availableBitRates_type_rangeOfBitRates;

typedef struct TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded {
    ASN1choice_t choice;
    union {
#	define highestEntryNumberProcessed_chosen 1
	CapabilityTableEntryNumber highestEntryNumberProcessed;
#	define noneProcessed_chosen 2
    } u;
} TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded;

typedef struct VCCapability_availableBitRates_type {
    ASN1choice_t choice;
    union {
#	define singleBitRate_chosen 1
	ASN1uint16_t singleBitRate;
#	define rangeOfBitRates_chosen 2
	VCCapability_availableBitRates_type_rangeOfBitRates rangeOfBitRates;
    } u;
} VCCapability_availableBitRates_type;

typedef struct H223Capability_h223MultiplexTableCapability_enhanced {
    ASN1uint16_t maximumNestingDepth;
    ASN1uint16_t maximumElementListSize;
    ASN1uint16_t maximumSubElementListSize;
} H223Capability_h223MultiplexTableCapability_enhanced;

typedef struct H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced {
    ASN1uint16_t maximumNestingDepth;
    ASN1uint16_t maximumElementListSize;
    ASN1uint16_t maximumSubElementListSize;
} H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced;

typedef struct H223LogicalChannelParameters_adaptationLayerType_al3 {
    ASN1uint16_t controlFieldOctets;
    ASN1uint32_t sendBufferSize;
} H223LogicalChannelParameters_adaptationLayerType_al3;

typedef struct V76LogicalChannelParameters_mode_eRM {
    ASN1uint16_t windowSize;
    V76LogicalChannelParameters_mode_eRM_recovery recovery;
} V76LogicalChannelParameters_mode_eRM;

typedef struct UnicastAddress_iPSourceRouteAddress_route {
    PUnicastAddress_iPSourceRouteAddress_route next;
    UnicastAddress_iPSourceRouteAddress_route_Seq value;
} UnicastAddress_iPSourceRouteAddress_route_Element;

typedef struct UnicastAddress_iPSourceRouteAddress_routing {
    ASN1choice_t choice;
#   define strict_chosen 1
#   define loose_chosen 2
} UnicastAddress_iPSourceRouteAddress_routing;

typedef struct H223ModeParameters_adaptationLayerType_al3 {
    ASN1uint16_t controlFieldOctets;
    ASN1uint32_t sendBufferSize;
} H223ModeParameters_adaptationLayerType_al3;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers {
    ASN1uint32_t count;
    CapabilityDescriptorNumber value[256];
} SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers {
    PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers next;
    CapabilityTableEntryNumber value;
} SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_Element;

typedef struct MiscellaneousCommand_type_videoFastUpdateMB {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define firstGOB_present 0x80
    ASN1uint16_t firstGOB;
#   define firstMB_present 0x40
    ASN1uint16_t firstMB;
    ASN1uint16_t numberOfMBs;
} MiscellaneousCommand_type_videoFastUpdateMB;

typedef struct MiscellaneousCommand_type_videoFastUpdateGOB {
    ASN1uint16_t firstGOB;
    ASN1uint16_t numberOfGOBs;
} MiscellaneousCommand_type_videoFastUpdateGOB;

typedef struct MiscellaneousIndication_type_videoNotDecodedMBs {
    ASN1uint16_t firstMB;
    ASN1uint16_t numberOfMBs;
    ASN1uint16_t temporalReference;
} MiscellaneousIndication_type_videoNotDecodedMBs;

typedef struct NewATMVCIndication_aal_aal5 {
    ASN1uint16_t forwardMaximumSDUSize;
    ASN1uint16_t backwardMaximumSDUSize;
} NewATMVCIndication_aal_aal5;

typedef struct NewATMVCIndication_aal_aal1 {
    NewATMVCIndication_aal_aal1_clockRecovery clockRecovery;
    NewATMVCIndication_aal_aal1_errorCorrection errorCorrection;
    ASN1bool_t structuredDataTransfer;
    ASN1bool_t partiallyFilledCells;
} NewATMVCIndication_aal_aal1;

typedef struct NewATMVCIndication_multiplex {
    ASN1choice_t choice;
#   define noMultiplex_chosen 1
#   define transportStream_chosen 2
#   define programStream_chosen 3
} NewATMVCIndication_multiplex;

typedef struct NewATMVCIndication_aal {
    ASN1choice_t choice;
    union {
#	define aal1_chosen 1
	NewATMVCIndication_aal_aal1 aal1;
#	define aal5_chosen 2
	NewATMVCIndication_aal_aal5 aal5;
    } u;
} NewATMVCIndication_aal;

typedef struct JitterIndication_scope {
    ASN1choice_t choice;
    union {
#	define JitterIndication_scope_logicalChannelNumber_chosen 1
	LogicalChannelNumber logicalChannelNumber;
#	define JitterIndication_scope_resourceID_chosen 2
	ASN1uint16_t resourceID;
#	define JitterIndication_scope_wholeMultiplex_chosen 3
    } u;
} JitterIndication_scope;

typedef struct MiscellaneousIndication_type {
    ASN1choice_t choice;
    union {
#	define logicalChannelActive_chosen 1
#	define logicalChannelInactive_chosen 2
#	define multipointConference_chosen 3
#	define cancelMultipointConference_chosen 4
#	define multipointZeroComm_chosen 5
#	define cancelMultipointZeroComm_chosen 6
#	define multipointSecondaryStatus_chosen 7
#	define cancelMultipointSecondaryStatus_chosen 8
#	define videoIndicateReadyToActivate_chosen 9
#	define MiscellaneousIndication_type_videoTemporalSpatialTradeOff_chosen 10
	ASN1uint16_t videoTemporalSpatialTradeOff;
#	define videoNotDecodedMBs_chosen 11
	MiscellaneousIndication_type_videoNotDecodedMBs videoNotDecodedMBs;
    } u;
} MiscellaneousIndication_type;

typedef struct FunctionNotSupported_cause {
    ASN1choice_t choice;
#   define syntaxError_chosen 1
#   define semanticError_chosen 2
#   define unknownFunction_chosen 3
} FunctionNotSupported_cause;

typedef struct MiscellaneousCommand_type {
    ASN1choice_t choice;
    union {
#	define equaliseDelay_chosen 1
#	define zeroDelay_chosen 2
#	define multipointModeCommand_chosen 3
#	define cancelMultipointModeCommand_chosen 4
#	define videoFreezePicture_chosen 5
#	define videoFastUpdatePicture_chosen 6
#	define videoFastUpdateGOB_chosen 7
	MiscellaneousCommand_type_videoFastUpdateGOB videoFastUpdateGOB;
#	define MiscellaneousCommand_type_videoTemporalSpatialTradeOff_chosen 8
	ASN1uint16_t videoTemporalSpatialTradeOff;
#	define videoSendSyncEveryGOB_chosen 9
#	define videoSendSyncEveryGOBCancel_chosen 10
#	define videoFastUpdateMB_chosen 11
	MiscellaneousCommand_type_videoFastUpdateMB videoFastUpdateMB;
    } u;
} MiscellaneousCommand_type;

typedef struct EndSessionCommand_gstnOptions {
    ASN1choice_t choice;
#   define telephonyMode_chosen 1
#   define v8bis_chosen 2
#   define v34DSVD_chosen 3
#   define v34DuplexFAX_chosen 4
#   define v34H324_chosen 5
} EndSessionCommand_gstnOptions;

typedef struct FlowControlCommand_restriction {
    ASN1choice_t choice;
    union {
#	define maximumBitRate_chosen 1
	ASN1uint32_t maximumBitRate;
#	define noRestriction_chosen 2
    } u;
} FlowControlCommand_restriction;

typedef struct FlowControlCommand_scope {
    ASN1choice_t choice;
    union {
#	define FlowControlCommand_scope_logicalChannelNumber_chosen 1
	LogicalChannelNumber logicalChannelNumber;
#	define FlowControlCommand_scope_resourceID_chosen 2
	ASN1uint16_t resourceID;
#	define FlowControlCommand_scope_wholeMultiplex_chosen 3
    } u;
} FlowControlCommand_scope;

typedef struct SendTerminalCapabilitySet_specificRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t multiplexCapability;
#   define capabilityTableEntryNumbers_present 0x80
    PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers capabilityTableEntryNumbers;
#   define capabilityDescriptorNumbers_present 0x40
    SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers capabilityDescriptorNumbers;
} SendTerminalCapabilitySet_specificRequest;

typedef struct H223AnnexAReconfiguration_headerCRC {
    ASN1choice_t choice;
#   define H223AnnexAReconfiguration_headerCRC_nil_chosen 1
#   define threebits_chosen 2
#   define H223AnnexAReconfiguration_headerCRC_eightbits_chosen 3
} H223AnnexAReconfiguration_headerCRC;

typedef struct H223AnnexAReconfiguration_headerFEC {
    ASN1choice_t choice;
#   define rate5by15_chosen 1
#   define rate6by31_chosen 2
#   define rate7by63_chosen 3
#   define rate7by15_chosen 4
#   define rate10by63_chosen 5
#   define rate11by31_chosen 6
#   define rate11by15_chosen 7
#   define rate16by63_chosen 8
#   define rate16by31_chosen 9
#   define rate18by63_chosen 10
} H223AnnexAReconfiguration_headerFEC;

typedef struct H223AnnexAReconfiguration_headerInterleaving {
    ASN1choice_t choice;
#   define bitInterleaving_chosen 1
#   define byteInterleaving_chosen 2
#   define noInterleaving_chosen 3
} H223AnnexAReconfiguration_headerInterleaving;

typedef struct H223AnnexAReconfiguration_synchFlagLength {
    ASN1choice_t choice;
#   define length15_chosen 1
#   define length31_chosen 2
} H223AnnexAReconfiguration_synchFlagLength;

typedef struct ConferenceResponse_makeMeChairResponse {
    ASN1choice_t choice;
#   define grantedChairToken_chosen 1
#   define deniedChairToken_chosen 2
} ConferenceResponse_makeMeChairResponse;

typedef struct MaintenanceLoopReject_cause {
    ASN1choice_t choice;
#   define canNotPerformLoop_chosen 1
} MaintenanceLoopReject_cause;

typedef struct MaintenanceLoopReject_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopReject_type_systemLoop_chosen 1
#	define MaintenanceLoopReject_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopReject_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopReject_type;

typedef struct MaintenanceLoopAck_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopAck_type_systemLoop_chosen 1
#	define MaintenanceLoopAck_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopAck_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopAck_type;

typedef struct MaintenanceLoopRequest_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopRequest_type_systemLoop_chosen 1
#	define MaintenanceLoopRequest_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopRequest_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopRequest_type;

typedef struct IS13818AudioMode_multichannelType {
    ASN1choice_t choice;
#   define IS13818AudioMode_multichannelType_singleChannel_chosen 1
#   define IS13818AudioMode_multichannelType_twoChannelStereo_chosen 2
#   define IS13818AudioMode_multichannelType_twoChannelDual_chosen 3
#   define threeChannels2_1_chosen 4
#   define threeChannels3_0_chosen 5
#   define fourChannels2_0_2_0_chosen 6
#   define fourChannels2_2_chosen 7
#   define fourChannels3_1_chosen 8
#   define fiveChannels3_0_2_0_chosen 9
#   define fiveChannels3_2_chosen 10
} IS13818AudioMode_multichannelType;

typedef struct IS13818AudioMode_audioSampling {
    ASN1choice_t choice;
#   define audioSampling16k_chosen 1
#   define audioSampling22k05_chosen 2
#   define audioSampling24k_chosen 3
#   define IS13818AudioMode_audioSampling_audioSampling32k_chosen 4
#   define IS13818AudioMode_audioSampling_audioSampling44k1_chosen 5
#   define IS13818AudioMode_audioSampling_audioSampling48k_chosen 6
} IS13818AudioMode_audioSampling;

typedef struct IS13818AudioMode_audioLayer {
    ASN1choice_t choice;
#   define IS13818AudioMode_audioLayer_audioLayer1_chosen 1
#   define IS13818AudioMode_audioLayer_audioLayer2_chosen 2
#   define IS13818AudioMode_audioLayer_audioLayer3_chosen 3
} IS13818AudioMode_audioLayer;

typedef struct IS11172AudioMode_multichannelType {
    ASN1choice_t choice;
#   define IS11172AudioMode_multichannelType_singleChannel_chosen 1
#   define IS11172AudioMode_multichannelType_twoChannelStereo_chosen 2
#   define IS11172AudioMode_multichannelType_twoChannelDual_chosen 3
} IS11172AudioMode_multichannelType;

typedef struct IS11172AudioMode_audioSampling {
    ASN1choice_t choice;
#   define IS11172AudioMode_audioSampling_audioSampling32k_chosen 1
#   define IS11172AudioMode_audioSampling_audioSampling44k1_chosen 2
#   define IS11172AudioMode_audioSampling_audioSampling48k_chosen 3
} IS11172AudioMode_audioSampling;

typedef struct IS11172AudioMode_audioLayer {
    ASN1choice_t choice;
#   define IS11172AudioMode_audioLayer_audioLayer1_chosen 1
#   define IS11172AudioMode_audioLayer_audioLayer2_chosen 2
#   define IS11172AudioMode_audioLayer_audioLayer3_chosen 3
} IS11172AudioMode_audioLayer;

typedef struct AudioMode_g7231 {
    ASN1choice_t choice;
#   define noSilenceSuppressionLowRate_chosen 1
#   define noSilenceSuppressionHighRate_chosen 2
#   define silenceSuppressionLowRate_chosen 3
#   define silenceSuppressionHighRate_chosen 4
} AudioMode_g7231;

typedef struct H263VideoMode_resolution {
    ASN1choice_t choice;
#   define sqcif_chosen 1
#   define H263VideoMode_resolution_qcif_chosen 2
#   define H263VideoMode_resolution_cif_chosen 3
#   define cif4_chosen 4
#   define cif16_chosen 5
} H263VideoMode_resolution;

typedef struct H262VideoMode_profileAndLevel {
    ASN1choice_t choice;
#   define profileAndLevel_SPatML_chosen 1
#   define profileAndLevel_MPatLL_chosen 2
#   define profileAndLevel_MPatML_chosen 3
#   define profileAndLevel_MPatH_14_chosen 4
#   define profileAndLevel_MPatHL_chosen 5
#   define profileAndLevel_SNRatLL_chosen 6
#   define profileAndLevel_SNRatML_chosen 7
#   define profileAndLevel_SpatialatH_14_chosen 8
#   define profileAndLevel_HPatML_chosen 9
#   define profileAndLevel_HPatH_14_chosen 10
#   define profileAndLevel_HPatHL_chosen 11
} H262VideoMode_profileAndLevel;

typedef struct H261VideoMode_resolution {
    ASN1choice_t choice;
#   define H261VideoMode_resolution_qcif_chosen 1
#   define H261VideoMode_resolution_cif_chosen 2
} H261VideoMode_resolution;

typedef struct AL3MParameters_arqType {
    ASN1choice_t choice;
#   define AL3MParameters_arqType_noArq_chosen 1
#   define AL3MParameters_arqType_typeIArq_chosen 2
#   define AL3MParameters_arqType_typeIIArq_chosen 3
} AL3MParameters_arqType;

typedef struct AL3MParameters_crcLength {
    ASN1choice_t choice;
#   define AL3MParameters_crcLength_nil_chosen 1
#   define AL3MParameters_crcLength_eightbits_chosen 2
#   define AL3MParameters_crcLength_sixteenbits_chosen 3
#   define AL3MParameters_crcLength_thirtytwobits_chosen 4
} AL3MParameters_crcLength;

typedef struct AL1MParameters_numberOfRetransmissions {
    ASN1choice_t choice;
    union {
#	define AL1MParameters_numberOfRetransmissions_finite_chosen 1
	ASN1uint16_t finite;
#	define infinite_chosen 2
    } u;
} AL1MParameters_numberOfRetransmissions;

typedef struct AL1MParameters_arqType {
    ASN1choice_t choice;
#   define AL1MParameters_arqType_noArq_chosen 1
#   define AL1MParameters_arqType_typeIArq_chosen 2
#   define AL1MParameters_arqType_typeIIArq_chosen 3
} AL1MParameters_arqType;

typedef struct AL1MParameters_crcLength {
    ASN1choice_t choice;
#   define AL1MParameters_crcLength_nil_chosen 1
#   define AL1MParameters_crcLength_eightbits_chosen 2
#   define AL1MParameters_crcLength_sixteenbits_chosen 3
#   define AL1MParameters_crcLength_thirtytwobits_chosen 4
} AL1MParameters_crcLength;

typedef struct RequestModeReject_cause {
    ASN1choice_t choice;
#   define modeUnavailable_chosen 1
#   define multipointConstraint_chosen 2
#   define requestDenied_chosen 3
} RequestModeReject_cause;

typedef struct RequestModeAck_response {
    ASN1choice_t choice;
#   define willTransmitMostPreferredMode_chosen 1
#   define willTransmitLessPreferredMode_chosen 2
} RequestModeAck_response;

typedef struct RequestMultiplexEntryRelease_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryRelease_entryNumbers;

typedef struct RequestMultiplexEntryRejectionDescriptions_cause {
    ASN1choice_t choice;
#   define RequestMultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen 1
} RequestMultiplexEntryRejectionDescriptions_cause;

typedef struct RequestMultiplexEntryReject_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryReject_entryNumbers;

typedef struct RequestMultiplexEntryAck_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryAck_entryNumbers;

typedef struct RequestMultiplexEntry_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntry_entryNumbers;

typedef struct MultiplexEntrySendRelease_multiplexTableEntryNumber {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} MultiplexEntrySendRelease_multiplexTableEntryNumber;

typedef struct MultiplexEntryRejectionDescriptions_cause {
    ASN1choice_t choice;
#   define MultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen 1
#   define descriptorTooComplex_chosen 2
} MultiplexEntryRejectionDescriptions_cause;

typedef struct MultiplexEntrySendAck_multiplexTableEntryNumber {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} MultiplexEntrySendAck_multiplexTableEntryNumber;

typedef struct MultiplexElement_repeatCount {
    ASN1choice_t choice;
    union {
#	define MultiplexElement_repeatCount_finite_chosen 1
	ASN1uint16_t finite;
#	define untilClosingFlag_chosen 2
    } u;
} MultiplexElement_repeatCount;

typedef struct MultiplexElement_type {
    ASN1choice_t choice;
    union {
#	define MultiplexElement_type_logicalChannelNumber_chosen 1
	ASN1uint16_t logicalChannelNumber;
#	define subElementList_chosen 2
	PMultiplexElement_type_subElementList subElementList;
    } u;
} MultiplexElement_type;

typedef struct RequestChannelCloseReject_cause {
    ASN1choice_t choice;
#   define RequestChannelCloseReject_cause_unspecified_chosen 1
} RequestChannelCloseReject_cause;

typedef struct CloseLogicalChannel_source {
    ASN1choice_t choice;
#   define user_chosen 1
#   define lcse_chosen 2
} CloseLogicalChannel_source;

typedef struct OpenLogicalChannelReject_cause {
    ASN1choice_t choice;
#   define OpenLogicalChannelReject_cause_unspecified_chosen 1
#   define unsuitableReverseParameters_chosen 2
#   define dataTypeNotSupported_chosen 3
#   define dataTypeNotAvailable_chosen 4
#   define unknownDataType_chosen 5
#   define dataTypeALCombinationNotSupported_chosen 6
#   define multicastChannelNotAllowed_chosen 7
#   define insufficientBandwidth_chosen 8
#   define separateStackEstablishmentFailed_chosen 9
#   define invalidSessionID_chosen 10
#   define masterSlaveConflict_chosen 11
} OpenLogicalChannelReject_cause;

typedef struct MulticastAddress_iP6Address {
    struct MulticastAddress_iP6Address_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } network;
    ASN1uint16_t tsapIdentifier;
} MulticastAddress_iP6Address;

typedef struct MulticastAddress_iPAddress {
    struct MulticastAddress_iPAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
} MulticastAddress_iPAddress;

typedef struct UnicastAddress_iPSourceRouteAddress {
    UnicastAddress_iPSourceRouteAddress_routing routing;
    struct UnicastAddress_iPSourceRouteAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
    PUnicastAddress_iPSourceRouteAddress_route route;
} UnicastAddress_iPSourceRouteAddress;

typedef struct UnicastAddress_iP6Address {
    struct UnicastAddress_iP6Address_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } network;
    ASN1uint16_t tsapIdentifier;
} UnicastAddress_iP6Address;

typedef struct UnicastAddress_iPXAddress {
    struct UnicastAddress_iPXAddress_node_node {
	ASN1uint32_t length;
	ASN1octet_t value[6];
    } node;
    struct UnicastAddress_iPXAddress_netnum_netnum {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } netnum;
    struct UnicastAddress_iPXAddress_tsapIdentifier_tsapIdentifier {
	ASN1uint32_t length;
	ASN1octet_t value[2];
    } tsapIdentifier;
} UnicastAddress_iPXAddress;

typedef struct UnicastAddress_iPAddress {
    struct UnicastAddress_iPAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
} UnicastAddress_iPAddress;

typedef struct H2250LogicalChannelParameters_mediaPacketization {
    ASN1choice_t choice;
#   define h261aVideoPacketization_chosen 1
} H2250LogicalChannelParameters_mediaPacketization;

typedef struct V76LogicalChannelParameters_mode {
    ASN1choice_t choice;
    union {
#	define eRM_chosen 1
	V76LogicalChannelParameters_mode_eRM eRM;
#	define uNERM_chosen 2
    } u;
} V76LogicalChannelParameters_mode;

typedef struct V76LogicalChannelParameters_suspendResume {
    ASN1choice_t choice;
#   define wAddress_chosen 1
#   define woAddress_chosen 2
} V76LogicalChannelParameters_suspendResume;

typedef struct Q2931Address_address {
    ASN1choice_t choice;
    union {
#	define internationalNumber_chosen 1
	ASN1char_t internationalNumber[17];
#	define nsapAddress_chosen 2
	struct Q2931Address_address_nsapAddress_nsapAddress {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsapAddress;
    } u;
} Q2931Address_address;

typedef struct NetworkAccessParameters_distribution {
    ASN1choice_t choice;
#   define unicast_chosen 1
#   define multicast_chosen 2
} NetworkAccessParameters_distribution;

typedef struct T84Profile_t84Restricted {
    ASN1bool_t qcif;
    ASN1bool_t cif;
    ASN1bool_t ccir601Seq;
    ASN1bool_t ccir601Prog;
    ASN1bool_t hdtvSeq;
    ASN1bool_t hdtvProg;
    ASN1bool_t g3FacsMH200x100;
    ASN1bool_t g3FacsMH200x200;
    ASN1bool_t g4FacsMMR200x100;
    ASN1bool_t g4FacsMMR200x200;
    ASN1bool_t jbig200x200Seq;
    ASN1bool_t jbig200x200Prog;
    ASN1bool_t jbig300x300Seq;
    ASN1bool_t jbig300x300Prog;
    ASN1bool_t digPhotoLow;
    ASN1bool_t digPhotoMedSeq;
    ASN1bool_t digPhotoMedProg;
    ASN1bool_t digPhotoHighSeq;
    ASN1bool_t digPhotoHighProg;
} T84Profile_t84Restricted;

typedef struct AudioCapability_g7231 {
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
} AudioCapability_g7231;

typedef struct H223AnnexACapability_h223AnnexAMultiplexTableCapability {
    ASN1choice_t choice;
    union {
#	define H223AnnexACapability_h223AnnexAMultiplexTableCapability_basic_chosen 1
#	define H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced_chosen 2
	H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced enhanced;
    } u;
} H223AnnexACapability_h223AnnexAMultiplexTableCapability;

typedef struct H2250Capability_mcCapability {
    ASN1bool_t centralizedConferenceMC;
    ASN1bool_t decentralizedConferenceMC;
} H2250Capability_mcCapability;

typedef struct H223Capability_h223MultiplexTableCapability {
    ASN1choice_t choice;
    union {
#	define H223Capability_h223MultiplexTableCapability_basic_chosen 1
#	define H223Capability_h223MultiplexTableCapability_enhanced_chosen 2
	H223Capability_h223MultiplexTableCapability_enhanced enhanced;
    } u;
} H223Capability_h223MultiplexTableCapability;

typedef struct VCCapability_availableBitRates {
    VCCapability_availableBitRates_type type;
} VCCapability_availableBitRates;

typedef struct VCCapability_aal5 {
    ASN1uint16_t forwardMaximumSDUSize;
    ASN1uint16_t backwardMaximumSDUSize;
} VCCapability_aal5;

typedef struct VCCapability_aal1 {
    ASN1bool_t nullClockRecovery;
    ASN1bool_t srtsClockRecovery;
    ASN1bool_t adaptiveClockRecovery;
    ASN1bool_t nullErrorCorrection;
    ASN1bool_t longInterleaver;
    ASN1bool_t shortInterleaver;
    ASN1bool_t errorCorrectionOnly;
    ASN1bool_t structuredDataTransfer;
    ASN1bool_t partiallyFilledCells;
} VCCapability_aal1;

typedef struct Capability_h233EncryptionReceiveCapability {
    ASN1uint16_t h233IVResponseTime;
} Capability_h233EncryptionReceiveCapability;

typedef struct TerminalCapabilitySetReject_cause {
    ASN1choice_t choice;
    union {
#	define TerminalCapabilitySetReject_cause_unspecified_chosen 1
#	define undefinedTableEntryUsed_chosen 2
#	define descriptorCapacityExceeded_chosen 3
#	define tableEntryCapacityExceeded_chosen 4
	TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded tableEntryCapacityExceeded;
    } u;
} TerminalCapabilitySetReject_cause;

typedef struct MasterSlaveDeterminationReject_cause {
    ASN1choice_t choice;
#   define identicalNumbers_chosen 1
} MasterSlaveDeterminationReject_cause;

typedef struct MasterSlaveDeterminationAck_decision {
    ASN1choice_t choice;
#   define master_chosen 1
#   define slave_chosen 2
} MasterSlaveDeterminationAck_decision;

typedef struct NonStandardIdentifier_h221NonStandard {
    ASN1uint16_t t35CountryCode;
    ASN1uint16_t t35Extension;
    ASN1uint16_t manufacturerCode;
} NonStandardIdentifier_h221NonStandard;

typedef struct NonStandardIdentifier {
    ASN1choice_t choice;
    union {
#	define object_chosen 1
	ASN1objectidentifier_t object;
#	define h221NonStandard_chosen 2
	NonStandardIdentifier_h221NonStandard h221NonStandard;
    } u;
} NonStandardIdentifier;

typedef struct MasterSlaveDetermination {
    ASN1uint16_t terminalType;
    ASN1uint32_t statusDeterminationNumber;
} MasterSlaveDetermination;

typedef struct MasterSlaveDeterminationAck {
    MasterSlaveDeterminationAck_decision decision;
} MasterSlaveDeterminationAck;

typedef struct MasterSlaveDeterminationReject {
    MasterSlaveDeterminationReject_cause cause;
} MasterSlaveDeterminationReject;

typedef struct MasterSlaveDeterminationRelease {
    char placeholder;
} MasterSlaveDeterminationRelease;

typedef struct V75Capability {
    ASN1bool_t audioHeader;
} V75Capability;

typedef struct CapabilityDescriptor {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CapabilityDescriptorNumber capabilityDescriptorNumber;
#   define simultaneousCapabilities_present 0x80
    PCapabilityDescriptor_simultaneousCapabilities simultaneousCapabilities;
} CapabilityDescriptor;

typedef struct AlternativeCapabilitySet {
    ASN1uint32_t count;
    CapabilityTableEntryNumber value[256];
} AlternativeCapabilitySet;

typedef struct TerminalCapabilitySetAck {
    SequenceNumber sequenceNumber;
} TerminalCapabilitySetAck;

typedef struct TerminalCapabilitySetReject {
    SequenceNumber sequenceNumber;
    TerminalCapabilitySetReject_cause cause;
} TerminalCapabilitySetReject;

typedef struct TerminalCapabilitySetRelease {
    char placeholder;
} TerminalCapabilitySetRelease;

typedef struct H222Capability {
    ASN1uint16_t numberOfVCs;
    PH222Capability_vcCapability vcCapability;
} H222Capability;

typedef struct VCCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define aal1_present 0x80
    VCCapability_aal1 aal1;
#   define aal5_present 0x40
    VCCapability_aal5 aal5;
    ASN1bool_t transportStream;
    ASN1bool_t programStream;
    VCCapability_availableBitRates availableBitRates;
} VCCapability;

typedef struct H223Capability {
    ASN1bool_t transportWithI_frames;
    ASN1bool_t videoWithAL1;
    ASN1bool_t videoWithAL2;
    ASN1bool_t videoWithAL3;
    ASN1bool_t audioWithAL1;
    ASN1bool_t audioWithAL2;
    ASN1bool_t audioWithAL3;
    ASN1bool_t dataWithAL1;
    ASN1bool_t dataWithAL2;
    ASN1bool_t dataWithAL3;
    ASN1uint16_t maximumAl2SDUSize;
    ASN1uint16_t maximumAl3SDUSize;
    ASN1uint16_t maximumDelayJitter;
    H223Capability_h223MultiplexTableCapability h223MultiplexTableCapability;
} H223Capability;

typedef struct V76Capability {
    ASN1bool_t suspendResumeCapabilitywAddress;
    ASN1bool_t suspendResumeCapabilitywoAddress;
    ASN1bool_t rejCapability;
    ASN1bool_t sREJCapability;
    ASN1bool_t mREJCapability;
    ASN1bool_t crc8bitCapability;
    ASN1bool_t crc16bitCapability;
    ASN1bool_t crc32bitCapability;
    ASN1bool_t uihCapability;
    ASN1uint16_t numOfDLCS;
    ASN1bool_t twoOctetAddressFieldCapability;
    ASN1bool_t loopBackTestCapability;
    ASN1uint16_t n401Capability;
    ASN1uint16_t maxWindowSizeCapability;
    V75Capability v75Capability;
} V76Capability;

typedef struct MediaPacketizationCapability {
    ASN1bool_t h261aVideoPacketization;
} MediaPacketizationCapability;

typedef struct MultipointCapability {
    ASN1bool_t multicastCapability;
    ASN1bool_t multiUniCastConference;
    PMultipointCapability_mediaDistributionCapability mediaDistributionCapability;
} MultipointCapability;

typedef struct MediaDistributionCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t centralizedControl;
    ASN1bool_t distributedControl;
    ASN1bool_t centralizedAudio;
    ASN1bool_t distributedAudio;
    ASN1bool_t centralizedVideo;
    ASN1bool_t distributedVideo;
#   define centralizedData_present 0x80
    PMediaDistributionCapability_centralizedData centralizedData;
#   define distributedData_present 0x40
    PMediaDistributionCapability_distributedData distributedData;
} MediaDistributionCapability;

typedef struct H223AnnexACapability {
    ASN1bool_t transferWithI_frames;
    ASN1bool_t videoWithAL1M;
    ASN1bool_t videoWithAL2M;
    ASN1bool_t videoWithAL3M;
    ASN1bool_t audioWithAL1M;
    ASN1bool_t audioWithAL2M;
    ASN1bool_t audioWithAL3M;
    ASN1bool_t dataWithAL1M;
    ASN1bool_t dataWithAL2M;
    ASN1bool_t dataWithAL3M;
    ASN1uint16_t maximumAL2MSDUSize;
    ASN1uint16_t maximumAL3MSDUSize;
    ASN1uint16_t maximumDelayJitter;
    ASN1bool_t reconfigurationCapability;
    H223AnnexACapability_h223AnnexAMultiplexTableCapability h223AnnexAMultiplexTableCapability;
} H223AnnexACapability;

typedef struct H261VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H261VideoCapability_qcifMPI_present 0x80
    ASN1uint16_t qcifMPI;
#   define H261VideoCapability_cifMPI_present 0x40
    ASN1uint16_t cifMPI;
    ASN1bool_t temporalSpatialTradeOffCapability;
    ASN1uint16_t maxBitRate;
    ASN1bool_t stillImageTransmission;
} H261VideoCapability;

typedef struct H262VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t profileAndLevel_SPatML;
    ASN1bool_t profileAndLevel_MPatLL;
    ASN1bool_t profileAndLevel_MPatML;
    ASN1bool_t profileAndLevel_MPatH_14;
    ASN1bool_t profileAndLevel_MPatHL;
    ASN1bool_t profileAndLevel_SNRatLL;
    ASN1bool_t profileAndLevel_SNRatML;
    ASN1bool_t profileAndLevel_SpatialatH_14;
    ASN1bool_t profileAndLevel_HPatML;
    ASN1bool_t profileAndLevel_HPatH_14;
    ASN1bool_t profileAndLevel_HPatHL;
#   define H262VideoCapability_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define H262VideoCapability_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define H262VideoCapability_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define H262VideoCapability_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define H262VideoCapability_framesPerSecond_present 0x8
    ASN1uint16_t framesPerSecond;
#   define H262VideoCapability_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} H262VideoCapability;

typedef struct H263VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define H263VideoCapability_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define H263VideoCapability_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
    ASN1uint32_t maxBitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
    ASN1bool_t temporalSpatialTradeOffCapability;
#   define hrd_B_present 0x4
    ASN1uint32_t hrd_B;
#   define bppMaxKb_present 0x2
    ASN1uint16_t bppMaxKb;
#   define slowSqcifMPI_present 0x8000
    ASN1uint16_t slowSqcifMPI;
#   define slowQcifMPI_present 0x4000
    ASN1uint16_t slowQcifMPI;
#   define slowCifMPI_present 0x2000
    ASN1uint16_t slowCifMPI;
#   define slowCif4MPI_present 0x1000
    ASN1uint16_t slowCif4MPI;
#   define slowCif16MPI_present 0x800
    ASN1uint16_t slowCif16MPI;
#   define H263VideoCapability_errorCompensation_present 0x400
    ASN1bool_t errorCompensation;
} H263VideoCapability;

typedef struct IS11172VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t constrainedBitstream;
#   define IS11172VideoCapability_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define IS11172VideoCapability_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define IS11172VideoCapability_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define IS11172VideoCapability_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define IS11172VideoCapability_pictureRate_present 0x8
    ASN1uint16_t pictureRate;
#   define IS11172VideoCapability_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} IS11172VideoCapability;

typedef struct IS11172AudioCapability {
    ASN1bool_t audioLayer1;
    ASN1bool_t audioLayer2;
    ASN1bool_t audioLayer3;
    ASN1bool_t audioSampling32k;
    ASN1bool_t audioSampling44k1;
    ASN1bool_t audioSampling48k;
    ASN1bool_t singleChannel;
    ASN1bool_t twoChannels;
    ASN1uint16_t bitRate;
} IS11172AudioCapability;

typedef struct IS13818AudioCapability {
    ASN1bool_t audioLayer1;
    ASN1bool_t audioLayer2;
    ASN1bool_t audioLayer3;
    ASN1bool_t audioSampling16k;
    ASN1bool_t audioSampling22k05;
    ASN1bool_t audioSampling24k;
    ASN1bool_t audioSampling32k;
    ASN1bool_t audioSampling44k1;
    ASN1bool_t audioSampling48k;
    ASN1bool_t singleChannel;
    ASN1bool_t twoChannels;
    ASN1bool_t threeChannels2_1;
    ASN1bool_t threeChannels3_0;
    ASN1bool_t fourChannels2_0_2_0;
    ASN1bool_t fourChannels2_2;
    ASN1bool_t fourChannels3_1;
    ASN1bool_t fiveChannels3_0_2_0;
    ASN1bool_t fiveChannels3_2;
    ASN1bool_t lowFrequencyEnhancement;
    ASN1bool_t multilingual;
    ASN1uint16_t bitRate;
} IS13818AudioCapability;

typedef struct T84Profile {
    ASN1choice_t choice;
    union {
#	define t84Unrestricted_chosen 1
#	define t84Restricted_chosen 2
	T84Profile_t84Restricted t84Restricted;
    } u;
} T84Profile;

typedef struct ConferenceCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define nonStandardData_present 0x80
    PConferenceCapability_nonStandardData nonStandardData;
    ASN1bool_t chairControlCapability;
} ConferenceCapability;

typedef struct Q2931Address {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Q2931Address_address address;
#   define subaddress_present 0x80
    struct Q2931Address_subaddress_subaddress {
	ASN1uint32_t length;
	ASN1octet_t value[20];
    } subaddress;
} Q2931Address;

typedef struct V75Parameters {
    ASN1bool_t audioHeaderPresent;
} V75Parameters;

typedef struct H222LogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t resourceID;
    ASN1uint16_t subChannelID;
#   define pcr_pid_present 0x80
    ASN1uint16_t pcr_pid;
#   define programDescriptors_present 0x40
    ASN1octetstring_t programDescriptors;
#   define streamDescriptors_present 0x20
    ASN1octetstring_t streamDescriptors;
} H222LogicalChannelParameters;

typedef struct CRCLength {
    ASN1choice_t choice;
#   define crc8bit_chosen 1
#   define crc16bit_chosen 2
#   define crc32bit_chosen 3
} CRCLength;

typedef struct OpenLogicalChannelReject {
    LogicalChannelNumber forwardLogicalChannelNumber;
    OpenLogicalChannelReject_cause cause;
} OpenLogicalChannelReject;

typedef struct OpenLogicalChannelConfirm {
    LogicalChannelNumber forwardLogicalChannelNumber;
} OpenLogicalChannelConfirm;

typedef struct CloseLogicalChannel {
    LogicalChannelNumber forwardLogicalChannelNumber;
    CloseLogicalChannel_source source;
} CloseLogicalChannel;

typedef struct CloseLogicalChannelAck {
    LogicalChannelNumber forwardLogicalChannelNumber;
} CloseLogicalChannelAck;

typedef struct RequestChannelClose {
    LogicalChannelNumber forwardLogicalChannelNumber;
} RequestChannelClose;

typedef struct RequestChannelCloseAck {
    LogicalChannelNumber forwardLogicalChannelNumber;
} RequestChannelCloseAck;

typedef struct RequestChannelCloseReject {
    LogicalChannelNumber forwardLogicalChannelNumber;
    RequestChannelCloseReject_cause cause;
} RequestChannelCloseReject;

typedef struct RequestChannelCloseRelease {
    LogicalChannelNumber forwardLogicalChannelNumber;
} RequestChannelCloseRelease;

typedef struct MultiplexEntrySend {
    SequenceNumber sequenceNumber;
    PMultiplexEntrySend_multiplexEntryDescriptors multiplexEntryDescriptors;
} MultiplexEntrySend;

typedef struct MultiplexElement {
    MultiplexElement_type type;
    MultiplexElement_repeatCount repeatCount;
} MultiplexElement;

typedef struct MultiplexEntrySendAck {
    SequenceNumber sequenceNumber;
    MultiplexEntrySendAck_multiplexTableEntryNumber multiplexTableEntryNumber;
} MultiplexEntrySendAck;

typedef struct MultiplexEntryRejectionDescriptions {
    MultiplexTableEntryNumber multiplexTableEntryNumber;
    MultiplexEntryRejectionDescriptions_cause cause;
} MultiplexEntryRejectionDescriptions;

typedef struct MultiplexEntrySendRelease {
    MultiplexEntrySendRelease_multiplexTableEntryNumber multiplexTableEntryNumber;
} MultiplexEntrySendRelease;

typedef struct RequestMultiplexEntry {
    RequestMultiplexEntry_entryNumbers entryNumbers;
} RequestMultiplexEntry;

typedef struct RequestMultiplexEntryAck {
    RequestMultiplexEntryAck_entryNumbers entryNumbers;
} RequestMultiplexEntryAck;

typedef struct RequestMultiplexEntryRejectionDescriptions {
    MultiplexTableEntryNumber multiplexTableEntryNumber;
    RequestMultiplexEntryRejectionDescriptions_cause cause;
} RequestMultiplexEntryRejectionDescriptions;

typedef struct RequestMultiplexEntryRelease {
    RequestMultiplexEntryRelease_entryNumbers entryNumbers;
} RequestMultiplexEntryRelease;

typedef struct RequestMode {
    SequenceNumber sequenceNumber;
    PRequestMode_requestedModes requestedModes;
} RequestMode;

typedef struct RequestModeAck {
    SequenceNumber sequenceNumber;
    RequestModeAck_response response;
} RequestModeAck;

typedef struct RequestModeReject {
    SequenceNumber sequenceNumber;
    RequestModeReject_cause cause;
} RequestModeReject;

typedef struct RequestModeRelease {
    char placeholder;
} RequestModeRelease;

typedef struct AL1MParameters {
    AL1MParameters_crcLength crcLength;
    ASN1uint16_t targetCodeRate;
    AL1MParameters_arqType arqType;
    AL1MParameters_numberOfRetransmissions numberOfRetransmissions;
    ASN1uint32_t sendBufferSize;
} AL1MParameters;

typedef struct AL3MParameters {
    AL3MParameters_crcLength crcLength;
    ASN1uint16_t targetCodeRate;
    AL3MParameters_arqType arqType;
    ASN1uint16_t numberOfRetransmissions;
    ASN1uint32_t sendBufferSize;
} AL3MParameters;

typedef struct V76ModeParameters {
    ASN1choice_t choice;
#   define suspendResumewAddress_chosen 1
#   define suspendResumewoAddress_chosen 2
} V76ModeParameters;

typedef struct H261VideoMode {
    H261VideoMode_resolution resolution;
    ASN1uint16_t bitRate;
    ASN1bool_t stillImageTransmission;
} H261VideoMode;

typedef struct H262VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H262VideoMode_profileAndLevel profileAndLevel;
#   define H262VideoMode_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define H262VideoMode_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define H262VideoMode_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define H262VideoMode_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define H262VideoMode_framesPerSecond_present 0x8
    ASN1uint16_t framesPerSecond;
#   define H262VideoMode_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} H262VideoMode;

typedef struct H263VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H263VideoMode_resolution resolution;
    ASN1uint16_t bitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
#   define H263VideoMode_errorCompensation_present 0x80
    ASN1bool_t errorCompensation;
} H263VideoMode;

typedef struct IS11172VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t constrainedBitstream;
#   define IS11172VideoMode_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define IS11172VideoMode_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define IS11172VideoMode_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define IS11172VideoMode_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define IS11172VideoMode_pictureRate_present 0x8
    ASN1uint16_t pictureRate;
#   define IS11172VideoMode_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} IS11172VideoMode;

typedef struct IS11172AudioMode {
    IS11172AudioMode_audioLayer audioLayer;
    IS11172AudioMode_audioSampling audioSampling;
    IS11172AudioMode_multichannelType multichannelType;
    ASN1uint16_t bitRate;
} IS11172AudioMode;

typedef struct IS13818AudioMode {
    IS13818AudioMode_audioLayer audioLayer;
    IS13818AudioMode_audioSampling audioSampling;
    IS13818AudioMode_multichannelType multichannelType;
    ASN1bool_t lowFrequencyEnhancement;
    ASN1bool_t multilingual;
    ASN1uint16_t bitRate;
} IS13818AudioMode;

typedef struct RoundTripDelayRequest {
    SequenceNumber sequenceNumber;
} RoundTripDelayRequest;

typedef struct RoundTripDelayResponse {
    SequenceNumber sequenceNumber;
} RoundTripDelayResponse;

typedef struct MaintenanceLoopRequest {
    MaintenanceLoopRequest_type type;
} MaintenanceLoopRequest;

typedef struct MaintenanceLoopAck {
    MaintenanceLoopAck_type type;
} MaintenanceLoopAck;

typedef struct MaintenanceLoopReject {
    MaintenanceLoopReject_type type;
    MaintenanceLoopReject_cause cause;
} MaintenanceLoopReject;

typedef struct MaintenanceLoopOffCommand {
    char placeholder;
} MaintenanceLoopOffCommand;

typedef struct CommunicationModeCommand {
    PCommunicationModeCommand_communicationModeTable communicationModeTable;
} CommunicationModeCommand;

typedef struct CommunicationModeRequest {
    char placeholder;
} CommunicationModeRequest;

typedef struct CommunicationModeResponse {
    ASN1choice_t choice;
    union {
#	define communicationModeTable_chosen 1
	PCommunicationModeResponse_communicationModeTable communicationModeTable;
    } u;
} CommunicationModeResponse;

typedef struct TerminalLabel {
    McuNumber mcuNumber;
    TerminalNumber terminalNumber;
} TerminalLabel;

typedef struct H223AnnexAReconfiguration {
    H223AnnexAReconfiguration_synchFlagLength synchFlagLength;
    ASN1uint16_t informationFieldSize;
    H223AnnexAReconfiguration_headerInterleaving headerInterleaving;
    H223AnnexAReconfiguration_headerFEC headerFEC;
    H223AnnexAReconfiguration_headerCRC headerCRC;
    ASN1uint16_t headerCounterForward;
} H223AnnexAReconfiguration;

typedef struct H223AnnexAReconfigurationAck {
    char placeholder;
} H223AnnexAReconfigurationAck;

typedef struct H223AnnexAReconfigurationReject {
    char placeholder;
} H223AnnexAReconfigurationReject;

typedef struct SendTerminalCapabilitySet {
    ASN1choice_t choice;
    union {
#	define specificRequest_chosen 1
	SendTerminalCapabilitySet_specificRequest specificRequest;
#	define genericRequest_chosen 2
    } u;
} SendTerminalCapabilitySet;

typedef struct FlowControlCommand {
    FlowControlCommand_scope scope;
    FlowControlCommand_restriction restriction;
} FlowControlCommand;

typedef struct ConferenceCommand {
    ASN1choice_t choice;
    union {
#	define broadcastMyLogicalChannel_chosen 1
	LogicalChannelNumber broadcastMyLogicalChannel;
#	define cancelBroadcastMyLogicalChannel_chosen 2
	LogicalChannelNumber cancelBroadcastMyLogicalChannel;
#	define makeTerminalBroadcaster_chosen 3
	TerminalLabel makeTerminalBroadcaster;
#	define cancelMakeTerminalBroadcaster_chosen 4
#	define sendThisSource_chosen 5
	TerminalLabel sendThisSource;
#	define cancelSendThisSource_chosen 6
#	define dropConference_chosen 7
    } u;
} ConferenceCommand;

typedef struct MiscellaneousCommand {
    LogicalChannelNumber logicalChannelNumber;
    MiscellaneousCommand_type type;
} MiscellaneousCommand;

typedef struct FunctionNotSupported {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    FunctionNotSupported_cause cause;
#   define returnedFunction_present 0x80
    ASN1octetstring_t returnedFunction;
} FunctionNotSupported;

typedef struct ConferenceIndication {
    ASN1choice_t choice;
    union {
#	define sbeNumber_chosen 1
	ASN1uint16_t sbeNumber;
#	define terminalNumberAssign_chosen 2
	TerminalLabel terminalNumberAssign;
#	define terminalJoinedConference_chosen 3
	TerminalLabel terminalJoinedConference;
#	define terminalLeftConference_chosen 4
	TerminalLabel terminalLeftConference;
#	define seenByAtLeastOneOther_chosen 5
#	define cancelSeenByAtLeastOneOther_chosen 6
#	define seenByAll_chosen 7
#	define cancelSeenByAll_chosen 8
#	define terminalYouAreSeeing_chosen 9
	TerminalLabel terminalYouAreSeeing;
#	define requestForFloor_chosen 10
    } u;
} ConferenceIndication;

typedef struct MiscellaneousIndication {
    LogicalChannelNumber logicalChannelNumber;
    MiscellaneousIndication_type type;
} MiscellaneousIndication;

typedef struct JitterIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    JitterIndication_scope scope;
    ASN1uint16_t estimatedReceivedJitterMantissa;
    ASN1uint16_t estimatedReceivedJitterExponent;
#   define skippedFrameCount_present 0x80
    ASN1uint16_t skippedFrameCount;
#   define additionalDecoderBuffer_present 0x40
    ASN1uint32_t additionalDecoderBuffer;
} JitterIndication;

typedef struct H223SkewIndication {
    LogicalChannelNumber logicalChannelNumber1;
    LogicalChannelNumber logicalChannelNumber2;
    ASN1uint16_t skew;
} H223SkewIndication;

typedef struct H2250MaximumSkewIndication {
    LogicalChannelNumber logicalChannelNumber1;
    LogicalChannelNumber logicalChannelNumber2;
    ASN1uint16_t maximumSkew;
} H2250MaximumSkewIndication;

typedef struct VendorIdentification {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    NonStandardIdentifier vendor;
#   define productNumber_present 0x80
    struct VendorIdentification_productNumber_productNumber {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } productNumber;
#   define versionNumber_present 0x40
    struct VendorIdentification_versionNumber_versionNumber {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } versionNumber;
} VendorIdentification;

typedef struct NewATMVCIndication {
    ASN1uint16_t resourceID;
    ASN1uint16_t bitRate;
    ASN1bool_t bitRateLockedToPCRClock;
    ASN1bool_t bitRateLockedToNetworkClock;
    NewATMVCIndication_aal aal;
    NewATMVCIndication_multiplex multiplex;
} NewATMVCIndication;

typedef struct MultiplexElement_type_subElementList {
    ASN1uint32_t count;
    MultiplexElement value[255];
} MultiplexElement_type_subElementList;

typedef struct ConferenceResponse_terminalListResponse {
    ASN1uint32_t count;
    TerminalLabel value[256];
} ConferenceResponse_terminalListResponse;

typedef struct ConferenceResponse_passwordResponse {
    TerminalLabel terminalLabel;
    Password password;
} ConferenceResponse_passwordResponse;

typedef struct ConferenceResponse_conferenceIDResponse {
    TerminalLabel terminalLabel;
    ConferenceID conferenceID;
} ConferenceResponse_conferenceIDResponse;

typedef struct ConferenceResponse_terminalIDResponse {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} ConferenceResponse_terminalIDResponse;

typedef struct ConferenceResponse_mCTerminalIDResponse {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} ConferenceResponse_mCTerminalIDResponse;

typedef struct RequestMultiplexEntryReject_rejectionDescriptions {
    ASN1uint32_t count;
    RequestMultiplexEntryRejectionDescriptions value[15];
} RequestMultiplexEntryReject_rejectionDescriptions;

typedef struct MultiplexEntrySendReject_rejectionDescriptions {
    ASN1uint32_t count;
    MultiplexEntryRejectionDescriptions value[15];
} MultiplexEntrySendReject_rejectionDescriptions;

typedef struct MultiplexEntryDescriptor_elementList {
    ASN1uint32_t count;
    MultiplexElement value[256];
} MultiplexEntryDescriptor_elementList;

typedef struct MultipointCapability_mediaDistributionCapability {
    PMultipointCapability_mediaDistributionCapability next;
    MediaDistributionCapability value;
} MultipointCapability_mediaDistributionCapability_Element;

typedef struct H222Capability_vcCapability {
    PH222Capability_vcCapability next;
    VCCapability value;
} H222Capability_vcCapability_Element;

typedef struct CapabilityDescriptor_simultaneousCapabilities {
    PCapabilityDescriptor_simultaneousCapabilities next;
    AlternativeCapabilitySet value;
} CapabilityDescriptor_simultaneousCapabilities_Element;

typedef struct TerminalCapabilitySet_capabilityDescriptors {
    ASN1uint32_t count;
    CapabilityDescriptor value[256];
} TerminalCapabilitySet_capabilityDescriptors;

typedef struct NonStandardParameter {
    NonStandardIdentifier nonStandardIdentifier;
    ASN1octetstring_t data;
} NonStandardParameter;

typedef struct H2250Capability {
    ASN1uint16_t maximumAudioDelayJitter;
    MultipointCapability receiveMultipointCapability;
    MultipointCapability transmitMultipointCapability;
    MultipointCapability receiveAndTransmitMultipointCapability;
    H2250Capability_mcCapability mcCapability;
    ASN1bool_t rtcpVideoControlCapability;
    MediaPacketizationCapability mediaPacketizationCapability;
} H2250Capability;

typedef struct VideoCapability {
    ASN1choice_t choice;
    union {
#	define VideoCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h261VideoCapability_chosen 2
	H261VideoCapability h261VideoCapability;
#	define h262VideoCapability_chosen 3
	H262VideoCapability h262VideoCapability;
#	define h263VideoCapability_chosen 4
	H263VideoCapability h263VideoCapability;
#	define is11172VideoCapability_chosen 5
	IS11172VideoCapability is11172VideoCapability;
    } u;
} VideoCapability;

typedef struct AudioCapability {
    ASN1choice_t choice;
    union {
#	define AudioCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define AudioCapability_g711Alaw64k_chosen 2
	ASN1uint16_t g711Alaw64k;
#	define AudioCapability_g711Alaw56k_chosen 3
	ASN1uint16_t g711Alaw56k;
#	define AudioCapability_g711Ulaw64k_chosen 4
	ASN1uint16_t g711Ulaw64k;
#	define AudioCapability_g711Ulaw56k_chosen 5
	ASN1uint16_t g711Ulaw56k;
#	define g722_64k_chosen 6
	ASN1uint16_t g722_64k;
#	define g722_56k_chosen 7
	ASN1uint16_t g722_56k;
#	define g722_48k_chosen 8
	ASN1uint16_t g722_48k;
#	define AudioCapability_g7231_chosen 9
	AudioCapability_g7231 g7231;
#	define AudioCapability_g728_chosen 10
	ASN1uint16_t g728;
#	define AudioCapability_g729_chosen 11
	ASN1uint16_t g729;
#	define AudioCapability_g729AnnexA_chosen 12
	ASN1uint16_t g729AnnexA;
#	define is11172AudioCapability_chosen 13
	IS11172AudioCapability is11172AudioCapability;
#	define is13818AudioCapability_chosen 14
	IS13818AudioCapability is13818AudioCapability;
#	define AudioCapability_g729AnnexAwSilenceSuppression_chosen 15
	ASN1uint16_t g729AnnexAwSilenceSuppression;
    } u;
} AudioCapability;

typedef struct DataProtocolCapability {
    ASN1choice_t choice;
    union {
#	define DataProtocolCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define v14buffered_chosen 2
#	define v42lapm_chosen 3
#	define hdlcFrameTunnelling_chosen 4
#	define h310SeparateVCStack_chosen 5
#	define h310SingleVCStack_chosen 6
#	define transparent_chosen 7
#	define segmentationAndReassembly_chosen 8
#	define hdlcFrameTunnelingwSAR_chosen 9
#	define v120_chosen 10
#	define separateLANStack_chosen 11
    } u;
} DataProtocolCapability;

typedef struct V76HDLCParameters {
    CRCLength crcLength;
    ASN1uint16_t n401;
    ASN1bool_t loopbackTestProcedure;
} V76HDLCParameters;

typedef struct UnicastAddress {
    ASN1choice_t choice;
    union {
#	define UnicastAddress_iPAddress_chosen 1
	UnicastAddress_iPAddress iPAddress;
#	define iPXAddress_chosen 2
	UnicastAddress_iPXAddress iPXAddress;
#	define UnicastAddress_iP6Address_chosen 3
	UnicastAddress_iP6Address iP6Address;
#	define netBios_chosen 4
	struct UnicastAddress_netBios_netBios {
	    ASN1uint32_t length;
	    ASN1octet_t value[16];
	} netBios;
#	define iPSourceRouteAddress_chosen 5
	UnicastAddress_iPSourceRouteAddress iPSourceRouteAddress;
#	define UnicastAddress_nsap_chosen 6
	struct UnicastAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define UnicastAddress_nonStandardAddress_chosen 7
	NonStandardParameter nonStandardAddress;
    } u;
} UnicastAddress;

typedef struct MulticastAddress {
    ASN1choice_t choice;
    union {
#	define MulticastAddress_iPAddress_chosen 1
	MulticastAddress_iPAddress iPAddress;
#	define MulticastAddress_iP6Address_chosen 2
	MulticastAddress_iP6Address iP6Address;
#	define MulticastAddress_nsap_chosen 3
	struct MulticastAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define MulticastAddress_nonStandardAddress_chosen 4
	NonStandardParameter nonStandardAddress;
    } u;
} MulticastAddress;

typedef struct MultiplexEntryDescriptor {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    MultiplexTableEntryNumber multiplexTableEntryNumber;
#   define elementList_present 0x80
    MultiplexEntryDescriptor_elementList elementList;
} MultiplexEntryDescriptor;

typedef struct MultiplexEntrySendReject {
    SequenceNumber sequenceNumber;
    MultiplexEntrySendReject_rejectionDescriptions rejectionDescriptions;
} MultiplexEntrySendReject;

typedef struct RequestMultiplexEntryReject {
    RequestMultiplexEntryReject_entryNumbers entryNumbers;
    RequestMultiplexEntryReject_rejectionDescriptions rejectionDescriptions;
} RequestMultiplexEntryReject;

typedef struct VideoMode {
    ASN1choice_t choice;
    union {
#	define VideoMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h261VideoMode_chosen 2
	H261VideoMode h261VideoMode;
#	define h262VideoMode_chosen 3
	H262VideoMode h262VideoMode;
#	define h263VideoMode_chosen 4
	H263VideoMode h263VideoMode;
#	define is11172VideoMode_chosen 5
	IS11172VideoMode is11172VideoMode;
    } u;
} VideoMode;

typedef struct AudioMode {
    ASN1choice_t choice;
    union {
#	define AudioMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define AudioMode_g711Alaw64k_chosen 2
#	define AudioMode_g711Alaw56k_chosen 3
#	define AudioMode_g711Ulaw64k_chosen 4
#	define AudioMode_g711Ulaw56k_chosen 5
#	define g722_64k_chosen 6
#	define g722_56k_chosen 7
#	define g722_48k_chosen 8
#	define AudioMode_g728_chosen 9
#	define AudioMode_g729_chosen 10
#	define AudioMode_g729AnnexA_chosen 11
#	define AudioMode_g7231_chosen 12
	AudioMode_g7231 g7231;
#	define is11172AudioMode_chosen 13
	IS11172AudioMode is11172AudioMode;
#	define is13818AudioMode_chosen 14
	IS13818AudioMode is13818AudioMode;
#	define AudioMode_g729AnnexAwSilenceSuppression_chosen 15
    } u;
} AudioMode;

typedef struct EncryptionMode {
    ASN1choice_t choice;
    union {
#	define EncryptionMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h233Encryption_chosen 2
    } u;
} EncryptionMode;

typedef struct ConferenceRequest {
    ASN1choice_t choice;
    union {
#	define terminalListRequest_chosen 1
#	define makeMeChair_chosen 2
#	define cancelMakeMeChair_chosen 3
#	define dropTerminal_chosen 4
	TerminalLabel dropTerminal;
#	define requestTerminalID_chosen 5
	TerminalLabel requestTerminalID;
#	define enterH243Password_chosen 6
#	define enterH243TerminalID_chosen 7
#	define enterH243ConferenceID_chosen 8
    } u;
} ConferenceRequest;

typedef struct ConferenceResponse {
    ASN1choice_t choice;
    union {
#	define mCTerminalIDResponse_chosen 1
	ConferenceResponse_mCTerminalIDResponse mCTerminalIDResponse;
#	define terminalIDResponse_chosen 2
	ConferenceResponse_terminalIDResponse terminalIDResponse;
#	define conferenceIDResponse_chosen 3
	ConferenceResponse_conferenceIDResponse conferenceIDResponse;
#	define passwordResponse_chosen 4
	ConferenceResponse_passwordResponse passwordResponse;
#	define terminalListResponse_chosen 5
	ConferenceResponse_terminalListResponse terminalListResponse;
#	define videoCommandReject_chosen 6
#	define terminalDropReject_chosen 7
#	define makeMeChairResponse_chosen 8
	ConferenceResponse_makeMeChairResponse makeMeChairResponse;
    } u;
} ConferenceResponse;

typedef struct EndSessionCommand {
    ASN1choice_t choice;
    union {
#	define EndSessionCommand_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define disconnect_chosen 2
#	define gstnOptions_chosen 3
	EndSessionCommand_gstnOptions gstnOptions;
    } u;
} EndSessionCommand;

typedef struct UserInputIndication {
    ASN1choice_t choice;
    union {
#	define UserInputIndication_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define alphanumeric_chosen 2
	ASN1ztcharstring_t alphanumeric;
    } u;
} UserInputIndication;

typedef struct DataApplicationCapability_application_nlpid {
    DataProtocolCapability nlpidProtocol;
    ASN1octetstring_t nlpidData;
} DataApplicationCapability_application_nlpid;

typedef struct DataApplicationCapability_application_t84 {
    DataProtocolCapability t84Protocol;
    T84Profile t84Profile;
} DataApplicationCapability_application_t84;

typedef struct DataMode_application_nlpid {
    DataProtocolCapability nlpidProtocol;
    ASN1octetstring_t nlpidData;
} DataMode_application_nlpid;

typedef struct EncryptionCommand_encryptionAlgorithmID {
    SequenceNumber h233AlgorithmIdentifier;
    NonStandardParameter associatedAlgorithm;
} EncryptionCommand_encryptionAlgorithmID;

typedef struct CommunicationModeTableEntry_nonStandard {
    PCommunicationModeTableEntry_nonStandard next;
    NonStandardParameter value;
} CommunicationModeTableEntry_nonStandard_Element;

typedef struct DataMode_application {
    ASN1choice_t choice;
    union {
#	define DataMode_application_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define DataMode_application_t120_chosen 2
	DataProtocolCapability t120;
#	define dsm_cc_chosen 3
	DataProtocolCapability dsm_cc;
#	define DataMode_application_userData_chosen 4
	DataProtocolCapability userData;
#	define DataMode_application_t84_chosen 5
	DataProtocolCapability t84;
#	define DataMode_application_t434_chosen 6
	DataProtocolCapability t434;
#	define DataMode_application_h224_chosen 7
	DataProtocolCapability h224;
#	define DataMode_application_nlpid_chosen 8
	DataMode_application_nlpid nlpid;
#	define DataMode_application_dsvdControl_chosen 9
#	define DataMode_application_h222DataPartitioning_chosen 10
	DataProtocolCapability h222DataPartitioning;
    } u;
} DataMode_application;

typedef struct H223AnnexAModeParameters_adaptationLayertype {
    ASN1choice_t choice;
    union {
#	define H223AnnexAModeParameters_adaptationLayertype_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223AnnexAModeParameters_adaptationLayertype_al1M_chosen 2
	AL1MParameters al1M;
#	define H223AnnexAModeParameters_adaptationLayertype_al2M_chosen 3
#	define H223AnnexAModeParameters_adaptationLayertype_al3M_chosen 4
	AL3MParameters al3M;
    } u;
} H223AnnexAModeParameters_adaptationLayertype;

typedef struct H223ModeParameters_adaptationLayerType {
    ASN1choice_t choice;
    union {
#	define H223ModeParameters_adaptationLayerType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223ModeParameters_adaptationLayerType_al1Framed_chosen 2
#	define H223ModeParameters_adaptationLayerType_al1NotFramed_chosen 3
#	define H223ModeParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen 4
#	define H223ModeParameters_adaptationLayerType_al2WithSequenceNumbers_chosen 5
#	define H223ModeParameters_adaptationLayerType_al3_chosen 6
	H223ModeParameters_adaptationLayerType_al3 al3;
    } u;
} H223ModeParameters_adaptationLayerType;

typedef struct MultiplexEntrySend_multiplexEntryDescriptors {
    PMultiplexEntrySend_multiplexEntryDescriptors next;
    MultiplexEntryDescriptor value;
} MultiplexEntrySend_multiplexEntryDescriptors_Element;

typedef struct H2250LogicalChannelAckParameters_nonStandard {
    PH2250LogicalChannelAckParameters_nonStandard next;
    NonStandardParameter value;
} H2250LogicalChannelAckParameters_nonStandard_Element;

typedef struct H223AnnexALogicalChannelParameters_adaptationLayertype {
    ASN1choice_t choice;
    union {
#	define H223AnnexALogicalChannelParameters_adaptationLayertype_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223AnnexALogicalChannelParameters_adaptationLayertype_al1M_chosen 2
	AL1MParameters al1M;
#	define H223AnnexALogicalChannelParameters_adaptationLayertype_al2M_chosen 3
#	define H223AnnexALogicalChannelParameters_adaptationLayertype_al3M_chosen 4
	AL3MParameters al3M;
    } u;
} H223AnnexALogicalChannelParameters_adaptationLayertype;

typedef struct H2250LogicalChannelParameters_nonStandard {
    PH2250LogicalChannelParameters_nonStandard next;
    NonStandardParameter value;
} H2250LogicalChannelParameters_nonStandard_Element;

typedef struct H223LogicalChannelParameters_adaptationLayerType {
    ASN1choice_t choice;
    union {
#	define H223LogicalChannelParameters_adaptationLayerType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223LogicalChannelParameters_adaptationLayerType_al1Framed_chosen 2
#	define H223LogicalChannelParameters_adaptationLayerType_al1NotFramed_chosen 3
#	define H223LogicalChannelParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen 4
#	define H223LogicalChannelParameters_adaptationLayerType_al2WithSequenceNumbers_chosen 5
#	define H223LogicalChannelParameters_adaptationLayerType_al3_chosen 6
	H223LogicalChannelParameters_adaptationLayerType_al3 al3;
    } u;
} H223LogicalChannelParameters_adaptationLayerType;

typedef struct ConferenceCapability_nonStandardData {
    PConferenceCapability_nonStandardData next;
    NonStandardParameter value;
} ConferenceCapability_nonStandardData_Element;

typedef struct DataApplicationCapability_application {
    ASN1choice_t choice;
    union {
#	define DataApplicationCapability_application_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define DataApplicationCapability_application_t120_chosen 2
	DataProtocolCapability t120;
#	define dsm_cc_chosen 3
	DataProtocolCapability dsm_cc;
#	define DataApplicationCapability_application_userData_chosen 4
	DataProtocolCapability userData;
#	define DataApplicationCapability_application_t84_chosen 5
	DataApplicationCapability_application_t84 t84;
#	define DataApplicationCapability_application_t434_chosen 6
	DataProtocolCapability t434;
#	define DataApplicationCapability_application_h224_chosen 7
	DataProtocolCapability h224;
#	define DataApplicationCapability_application_nlpid_chosen 8
	DataApplicationCapability_application_nlpid nlpid;
#	define DataApplicationCapability_application_dsvdControl_chosen 9
#	define DataApplicationCapability_application_h222DataPartitioning_chosen 10
	DataProtocolCapability h222DataPartitioning;
    } u;
} DataApplicationCapability_application;

typedef struct NonStandardMessage {
    NonStandardParameter nonStandardData;
} NonStandardMessage;

typedef struct MultiplexCapability {
    ASN1choice_t choice;
    union {
#	define MultiplexCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h222Capability_chosen 2
	H222Capability h222Capability;
#	define h223Capability_chosen 3
	H223Capability h223Capability;
#	define v76Capability_chosen 4
	V76Capability v76Capability;
#	define h2250Capability_chosen 5
	H2250Capability h2250Capability;
#	define h223AnnexACapability_chosen 6
	H223AnnexACapability h223AnnexACapability;
    } u;
} MultiplexCapability;

typedef struct DataApplicationCapability {
    DataApplicationCapability_application application;
    ASN1uint32_t maxBitRate;
} DataApplicationCapability;

typedef struct DataType {
    ASN1choice_t choice;
    union {
#	define DataType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define nullData_chosen 2
#	define DataType_videoData_chosen 3
	VideoCapability videoData;
#	define DataType_audioData_chosen 4
	AudioCapability audioData;
#	define DataType_data_chosen 5
	DataApplicationCapability data;
#	define encryptionData_chosen 6
	EncryptionMode encryptionData;
    } u;
} DataType;

typedef struct H223LogicalChannelParameters {
    H223LogicalChannelParameters_adaptationLayerType adaptationLayerType;
    ASN1bool_t segmentableFlag;
} H223LogicalChannelParameters;

typedef struct V76LogicalChannelParameters {
    V76HDLCParameters hdlcParameters;
    V76LogicalChannelParameters_suspendResume suspendResume;
    ASN1bool_t uIH;
    V76LogicalChannelParameters_mode mode;
    V75Parameters v75Parameters;
} V76LogicalChannelParameters;

typedef struct TransportAddress {
    ASN1choice_t choice;
    union {
#	define unicastAddress_chosen 1
	UnicastAddress unicastAddress;
#	define multicastAddress_chosen 2
	MulticastAddress multicastAddress;
    } u;
} TransportAddress;

typedef struct H223AnnexALogicalChannelParameters {
    H223AnnexALogicalChannelParameters_adaptationLayertype adaptationLayertype;
    ASN1bool_t segmentableFlag;
} H223AnnexALogicalChannelParameters;

typedef struct H2250LogicalChannelAckParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H2250LogicalChannelAckParameters_nonStandard_present 0x80
    PH2250LogicalChannelAckParameters_nonStandard nonStandard;
#   define sessionID_present 0x40
    ASN1uint16_t sessionID;
#   define H2250LogicalChannelAckParameters_mediaChannel_present 0x20
    TransportAddress mediaChannel;
#   define H2250LogicalChannelAckParameters_mediaControlChannel_present 0x10
    TransportAddress mediaControlChannel;
#   define H2250LogicalChannelAckParameters_dynamicRTPPayloadType_present 0x8
    ASN1uint16_t dynamicRTPPayloadType;
} H2250LogicalChannelAckParameters;

typedef struct H223ModeParameters {
    H223ModeParameters_adaptationLayerType adaptationLayerType;
    ASN1bool_t segmentableFlag;
} H223ModeParameters;

typedef struct H223AnnexAModeParameters {
    H223AnnexAModeParameters_adaptationLayertype adaptationLayertype;
    ASN1bool_t segmentableFlag;
} H223AnnexAModeParameters;

typedef struct DataMode {
    DataMode_application application;
    ASN1uint32_t bitRate;
} DataMode;

typedef struct EncryptionCommand {
    ASN1choice_t choice;
    union {
#	define encryptionSE_chosen 1
	ASN1octetstring_t encryptionSE;
#	define encryptionIVRequest_chosen 2
#	define encryptionAlgorithmID_chosen 3
	EncryptionCommand_encryptionAlgorithmID encryptionAlgorithmID;
    } u;
} EncryptionCommand;

typedef struct MCLocationIndication {
    TransportAddress signalAddress;
} MCLocationIndication;

typedef struct CommunicationModeTableEntry_dataType {
    ASN1choice_t choice;
    union {
#	define CommunicationModeTableEntry_dataType_videoData_chosen 1
	VideoCapability videoData;
#	define CommunicationModeTableEntry_dataType_audioData_chosen 2
	AudioCapability audioData;
#	define CommunicationModeTableEntry_dataType_data_chosen 3
	DataApplicationCapability data;
    } u;
} CommunicationModeTableEntry_dataType;

typedef struct ModeElement_type {
    ASN1choice_t choice;
    union {
#	define ModeElement_type_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define videoMode_chosen 2
	VideoMode videoMode;
#	define audioMode_chosen 3
	AudioMode audioMode;
#	define dataMode_chosen 4
	DataMode dataMode;
#	define encryptionMode_chosen 5
	EncryptionMode encryptionMode;
    } u;
} ModeElement_type;

typedef struct OpenLogicalChannelAck_forwardMultiplexAckParameters {
    ASN1choice_t choice;
    union {
#	define h2250LogicalChannelAckParameters_chosen 1
	H2250LogicalChannelAckParameters h2250LogicalChannelAckParameters;
    } u;
} OpenLogicalChannelAck_forwardMultiplexAckParameters;

typedef struct NetworkAccessParameters_networkAddress {
    ASN1choice_t choice;
    union {
#	define q2931Address_chosen 1
	Q2931Address q2931Address;
#	define e164Address_chosen 2
	ASN1char_t e164Address[129];
#	define localAreaAddress_chosen 3
	TransportAddress localAreaAddress;
    } u;
} NetworkAccessParameters_networkAddress;

typedef struct MediaDistributionCapability_distributedData {
    PMediaDistributionCapability_distributedData next;
    DataApplicationCapability value;
} MediaDistributionCapability_distributedData_Element;

typedef struct MediaDistributionCapability_centralizedData {
    PMediaDistributionCapability_centralizedData next;
    DataApplicationCapability value;
} MediaDistributionCapability_centralizedData_Element;

typedef struct CommandMessage {
    ASN1choice_t choice;
    union {
#	define CommandMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define maintenanceLoopOffCommand_chosen 2
	MaintenanceLoopOffCommand maintenanceLoopOffCommand;
#	define sendTerminalCapabilitySet_chosen 3
	SendTerminalCapabilitySet sendTerminalCapabilitySet;
#	define encryptionCommand_chosen 4
	EncryptionCommand encryptionCommand;
#	define flowControlCommand_chosen 5
	FlowControlCommand flowControlCommand;
#	define endSessionCommand_chosen 6
	EndSessionCommand endSessionCommand;
#	define miscellaneousCommand_chosen 7
	MiscellaneousCommand miscellaneousCommand;
#	define communicationModeCommand_chosen 8
	CommunicationModeCommand communicationModeCommand;
#	define conferenceCommand_chosen 9
	ConferenceCommand conferenceCommand;
    } u;
} CommandMessage;

typedef struct TerminalCapabilitySet {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SequenceNumber sequenceNumber;
    ASN1objectidentifier_t protocolIdentifier;
#   define multiplexCapability_present 0x80
    MultiplexCapability multiplexCapability;
#   define capabilityTable_present 0x40
    PTerminalCapabilitySet_capabilityTable capabilityTable;
#   define capabilityDescriptors_present 0x20
    TerminalCapabilitySet_capabilityDescriptors capabilityDescriptors;
} TerminalCapabilitySet;

typedef struct Capability {
    ASN1choice_t choice;
    union {
#	define Capability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define receiveVideoCapability_chosen 2
	VideoCapability receiveVideoCapability;
#	define transmitVideoCapability_chosen 3
	VideoCapability transmitVideoCapability;
#	define receiveAndTransmitVideoCapability_chosen 4
	VideoCapability receiveAndTransmitVideoCapability;
#	define receiveAudioCapability_chosen 5
	AudioCapability receiveAudioCapability;
#	define transmitAudioCapability_chosen 6
	AudioCapability transmitAudioCapability;
#	define receiveAndTransmitAudioCapability_chosen 7
	AudioCapability receiveAndTransmitAudioCapability;
#	define receiveDataApplicationCapability_chosen 8
	DataApplicationCapability receiveDataApplicationCapability;
#	define transmitDataApplicationCapability_chosen 9
	DataApplicationCapability transmitDataApplicationCapability;
#	define receiveAndTransmitDataApplicationCapability_chosen 10
	DataApplicationCapability receiveAndTransmitDataApplicationCapability;
#	define h233EncryptionTransmitCapability_chosen 11
	ASN1bool_t h233EncryptionTransmitCapability;
#	define h233EncryptionReceiveCapability_chosen 12
	Capability_h233EncryptionReceiveCapability h233EncryptionReceiveCapability;
#	define conferenceCapability_chosen 13
	ConferenceCapability conferenceCapability;
    } u;
} Capability;

typedef struct NetworkAccessParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define distribution_present 0x80
    NetworkAccessParameters_distribution distribution;
    NetworkAccessParameters_networkAddress networkAddress;
    ASN1bool_t associateConference;
#   define externalReference_present 0x40
    struct NetworkAccessParameters_externalReference_externalReference {
	ASN1uint32_t length;
	ASN1octet_t value[255];
    } externalReference;
} NetworkAccessParameters;

typedef struct H2250LogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H2250LogicalChannelParameters_nonStandard_present 0x80
    PH2250LogicalChannelParameters_nonStandard nonStandard;
    ASN1uint16_t sessionID;
#   define H2250LogicalChannelParameters_associatedSessionID_present 0x40
    ASN1uint16_t associatedSessionID;
#   define H2250LogicalChannelParameters_mediaChannel_present 0x20
    TransportAddress mediaChannel;
#   define H2250LogicalChannelParameters_mediaGuaranteedDelivery_present 0x10
    ASN1bool_t mediaGuaranteedDelivery;
#   define H2250LogicalChannelParameters_mediaControlChannel_present 0x8
    TransportAddress mediaControlChannel;
#   define H2250LogicalChannelParameters_mediaControlGuaranteedDelivery_present 0x4
    ASN1bool_t mediaControlGuaranteedDelivery;
#   define silenceSuppression_present 0x2
    ASN1bool_t silenceSuppression;
#   define destination_present 0x1
    TerminalLabel destination;
#   define H2250LogicalChannelParameters_dynamicRTPPayloadType_present 0x8000
    ASN1uint16_t dynamicRTPPayloadType;
#   define mediaPacketization_present 0x4000
    H2250LogicalChannelParameters_mediaPacketization mediaPacketization;
} H2250LogicalChannelParameters;

typedef struct ModeElement {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ModeElement_type type;
#   define h223ModeParameters_present 0x80
    H223ModeParameters h223ModeParameters;
#   define v76ModeParameters_present 0x8000
    V76ModeParameters v76ModeParameters;
#   define h223AnnexAModeParameters_present 0x4000
    H223AnnexAModeParameters h223AnnexAModeParameters;
} ModeElement;

typedef struct CommunicationModeTableEntry {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define CommunicationModeTableEntry_nonStandard_present 0x80
    PCommunicationModeTableEntry_nonStandard nonStandard;
    ASN1uint16_t sessionID;
#   define CommunicationModeTableEntry_associatedSessionID_present 0x40
    ASN1uint16_t associatedSessionID;
#   define terminalLabel_present 0x20
    TerminalLabel terminalLabel;
    ASN1char16string_t sessionDescription;
    CommunicationModeTableEntry_dataType dataType;
#   define CommunicationModeTableEntry_mediaChannel_present 0x10
    TransportAddress mediaChannel;
#   define CommunicationModeTableEntry_mediaGuaranteedDelivery_present 0x8
    ASN1bool_t mediaGuaranteedDelivery;
#   define CommunicationModeTableEntry_mediaControlChannel_present 0x4
    TransportAddress mediaControlChannel;
#   define CommunicationModeTableEntry_mediaControlGuaranteedDelivery_present 0x2
    ASN1bool_t mediaControlGuaranteedDelivery;
} CommunicationModeTableEntry;

typedef struct OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen 1
	H222LogicalChannelParameters h222LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen 2
	H223LogicalChannelParameters h223LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen 3
	V76LogicalChannelParameters v76LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 4
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h223AnnexALogicalChannelParameters_chosen 5
	H223AnnexALogicalChannelParameters h223AnnexALogicalChannelParameters;
    } u;
} OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters;

typedef struct OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen 1
	H223LogicalChannelParameters h223LogicalChannelParameters;
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen 2
	V76LogicalChannelParameters v76LogicalChannelParameters;
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 3
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h223AnnexALogicalChannelParameters_chosen 4
	H223AnnexALogicalChannelParameters h223AnnexALogicalChannelParameters;
    } u;
} OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters;

typedef struct OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen 1
	H222LogicalChannelParameters h222LogicalChannelParameters;
#	define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 2
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
    } u;
} OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters;

typedef struct CommunicationModeResponse_communicationModeTable {
    PCommunicationModeResponse_communicationModeTable next;
    CommunicationModeTableEntry value;
} CommunicationModeResponse_communicationModeTable_Element;

typedef struct CommunicationModeCommand_communicationModeTable {
    PCommunicationModeCommand_communicationModeTable next;
    CommunicationModeTableEntry value;
} CommunicationModeCommand_communicationModeTable_Element;

typedef struct OpenLogicalChannelAck_reverseLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    LogicalChannelNumber reverseLogicalChannelNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber_present 0x80
    ASN1uint16_t portNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_present 0x40
    OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters multiplexParameters;
} OpenLogicalChannelAck_reverseLogicalChannelParameters;

typedef struct OpenLogicalChannel_reverseLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    DataType dataType;
#   define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_present 0x80
    OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters multiplexParameters;
} OpenLogicalChannel_reverseLogicalChannelParameters;

typedef struct OpenLogicalChannel_forwardLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define OpenLogicalChannel_forwardLogicalChannelParameters_portNumber_present 0x80
    ASN1uint16_t portNumber;
    DataType dataType;
    OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters multiplexParameters;
} OpenLogicalChannel_forwardLogicalChannelParameters;

typedef struct CapabilityTableEntry {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CapabilityTableEntryNumber capabilityTableEntryNumber;
#   define capability_present 0x80
    Capability capability;
} CapabilityTableEntry;

typedef struct OpenLogicalChannel {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
    OpenLogicalChannel_forwardLogicalChannelParameters forwardLogicalChannelParameters;
#   define OpenLogicalChannel_reverseLogicalChannelParameters_present 0x80
    OpenLogicalChannel_reverseLogicalChannelParameters reverseLogicalChannelParameters;
#   define OpenLogicalChannel_separateStack_present 0x8000
    NetworkAccessParameters separateStack;
} OpenLogicalChannel;

typedef struct OpenLogicalChannelAck {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_present 0x80
    OpenLogicalChannelAck_reverseLogicalChannelParameters reverseLogicalChannelParameters;
#   define OpenLogicalChannelAck_separateStack_present 0x8000
    NetworkAccessParameters separateStack;
#   define forwardMultiplexAckParameters_present 0x4000
    OpenLogicalChannelAck_forwardMultiplexAckParameters forwardMultiplexAckParameters;
} OpenLogicalChannelAck;

typedef struct ModeDescription {
    ASN1uint32_t count;
    ModeElement value[256];
} ModeDescription;

typedef struct RequestMode_requestedModes {
    PRequestMode_requestedModes next;
    ModeDescription value;
} RequestMode_requestedModes_Element;

typedef struct TerminalCapabilitySet_capabilityTable {
    PTerminalCapabilitySet_capabilityTable next;
    CapabilityTableEntry value;
} TerminalCapabilitySet_capabilityTable_Element;

typedef struct RequestMessage {
    ASN1choice_t choice;
    union {
#	define RequestMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define masterSlaveDetermination_chosen 2
	MasterSlaveDetermination masterSlaveDetermination;
#	define terminalCapabilitySet_chosen 3
	TerminalCapabilitySet terminalCapabilitySet;
#	define openLogicalChannel_chosen 4
	OpenLogicalChannel openLogicalChannel;
#	define closeLogicalChannel_chosen 5
	CloseLogicalChannel closeLogicalChannel;
#	define requestChannelClose_chosen 6
	RequestChannelClose requestChannelClose;
#	define multiplexEntrySend_chosen 7
	MultiplexEntrySend multiplexEntrySend;
#	define requestMultiplexEntry_chosen 8
	RequestMultiplexEntry requestMultiplexEntry;
#	define requestMode_chosen 9
	RequestMode requestMode;
#	define roundTripDelayRequest_chosen 10
	RoundTripDelayRequest roundTripDelayRequest;
#	define maintenanceLoopRequest_chosen 11
	MaintenanceLoopRequest maintenanceLoopRequest;
#	define communicationModeRequest_chosen 12
	CommunicationModeRequest communicationModeRequest;
#	define conferenceRequest_chosen 13
	ConferenceRequest conferenceRequest;
#	define h223AnnexAReconfiguration_chosen 14
	H223AnnexAReconfiguration h223AnnexAReconfiguration;
    } u;
} RequestMessage;

typedef struct ResponseMessage {
    ASN1choice_t choice;
    union {
#	define ResponseMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define masterSlaveDeterminationAck_chosen 2
	MasterSlaveDeterminationAck masterSlaveDeterminationAck;
#	define masterSlaveDeterminationReject_chosen 3
	MasterSlaveDeterminationReject masterSlaveDeterminationReject;
#	define terminalCapabilitySetAck_chosen 4
	TerminalCapabilitySetAck terminalCapabilitySetAck;
#	define terminalCapabilitySetReject_chosen 5
	TerminalCapabilitySetReject terminalCapabilitySetReject;
#	define openLogicalChannelAck_chosen 6
	OpenLogicalChannelAck openLogicalChannelAck;
#	define openLogicalChannelReject_chosen 7
	OpenLogicalChannelReject openLogicalChannelReject;
#	define closeLogicalChannelAck_chosen 8
	CloseLogicalChannelAck closeLogicalChannelAck;
#	define requestChannelCloseAck_chosen 9
	RequestChannelCloseAck requestChannelCloseAck;
#	define requestChannelCloseReject_chosen 10
	RequestChannelCloseReject requestChannelCloseReject;
#	define multiplexEntrySendAck_chosen 11
	MultiplexEntrySendAck multiplexEntrySendAck;
#	define multiplexEntrySendReject_chosen 12
	MultiplexEntrySendReject multiplexEntrySendReject;
#	define requestMultiplexEntryAck_chosen 13
	RequestMultiplexEntryAck requestMultiplexEntryAck;
#	define requestMultiplexEntryReject_chosen 14
	RequestMultiplexEntryReject requestMultiplexEntryReject;
#	define requestModeAck_chosen 15
	RequestModeAck requestModeAck;
#	define requestModeReject_chosen 16
	RequestModeReject requestModeReject;
#	define roundTripDelayResponse_chosen 17
	RoundTripDelayResponse roundTripDelayResponse;
#	define maintenanceLoopAck_chosen 18
	MaintenanceLoopAck maintenanceLoopAck;
#	define maintenanceLoopReject_chosen 19
	MaintenanceLoopReject maintenanceLoopReject;
#	define communicationModeResponse_chosen 20
	CommunicationModeResponse communicationModeResponse;
#	define conferenceResponse_chosen 21
	ConferenceResponse conferenceResponse;
#	define h223AnnexAReconfigurationAck_chosen 22
	H223AnnexAReconfigurationAck h223AnnexAReconfigurationAck;
#	define h223AnnexAReconfigurationReject_chosen 23
	H223AnnexAReconfigurationReject h223AnnexAReconfigurationReject;
    } u;
} ResponseMessage;

typedef struct FunctionNotUnderstood {
    ASN1choice_t choice;
    union {
#	define FunctionNotUnderstood_request_chosen 1
	RequestMessage request;
#	define FunctionNotUnderstood_response_chosen 2
	ResponseMessage response;
#	define FunctionNotUnderstood_command_chosen 3
	CommandMessage command;
    } u;
} FunctionNotUnderstood;

typedef struct IndicationMessage {
    ASN1choice_t choice;
    union {
#	define IndicationMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define functionNotUnderstood_chosen 2
	FunctionNotUnderstood functionNotUnderstood;
#	define masterSlaveDeterminationRelease_chosen 3
	MasterSlaveDeterminationRelease masterSlaveDeterminationRelease;
#	define terminalCapabilitySetRelease_chosen 4
	TerminalCapabilitySetRelease terminalCapabilitySetRelease;
#	define openLogicalChannelConfirm_chosen 5
	OpenLogicalChannelConfirm openLogicalChannelConfirm;
#	define requestChannelCloseRelease_chosen 6
	RequestChannelCloseRelease requestChannelCloseRelease;
#	define multiplexEntrySendRelease_chosen 7
	MultiplexEntrySendRelease multiplexEntrySendRelease;
#	define requestMultiplexEntryRelease_chosen 8
	RequestMultiplexEntryRelease requestMultiplexEntryRelease;
#	define requestModeRelease_chosen 9
	RequestModeRelease requestModeRelease;
#	define miscellaneousIndication_chosen 10
	MiscellaneousIndication miscellaneousIndication;
#	define jitterIndication_chosen 11
	JitterIndication jitterIndication;
#	define h223SkewIndication_chosen 12
	H223SkewIndication h223SkewIndication;
#	define newATMVCIndication_chosen 13
	NewATMVCIndication newATMVCIndication;
#	define userInput_chosen 14
	UserInputIndication userInput;
#	define h2250MaximumSkewIndication_chosen 15
	H2250MaximumSkewIndication h2250MaximumSkewIndication;
#	define mcLocationIndication_chosen 16
	MCLocationIndication mcLocationIndication;
#	define conferenceIndication_chosen 17
	ConferenceIndication conferenceIndication;
#	define vendorIdentification_chosen 18
	VendorIdentification vendorIdentification;
#	define functionNotSupported_chosen 19
	FunctionNotSupported functionNotSupported;
    } u;
} IndicationMessage;

typedef struct MultimediaSystemControlMessage {
    ASN1choice_t choice;
    union {
#	define MultimediaSystemControlMessage_request_chosen 1
	RequestMessage request;
#	define MultimediaSystemControlMessage_response_chosen 2
	ResponseMessage response;
#	define MultimediaSystemControlMessage_command_chosen 3
	CommandMessage command;
#	define indication_chosen 4
	IndicationMessage indication;
    } u;
} MultimediaSystemControlMessage;
#define MultimediaSystemControlMessage_PDU 0
#define SIZE_H245ASN_Module_PDU_0 sizeof(MultimediaSystemControlMessage)

extern ASN1module_t H245ASN_Module;
extern void ASN1CALL H245ASN_Module_init();
extern void ASN1CALL H245ASN_Module_finit();

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1encoding_t enc, PUnicastAddress_iPSourceRouteAddress_route val);
    extern int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1decoding_t dec, PUnicastAddress_iPSourceRouteAddress_route val);
    extern void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress_route_ElmFn(PUnicastAddress_iPSourceRouteAddress_route val);
    extern int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1encoding_t enc, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
    extern int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1decoding_t dec, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
    extern void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
    extern int ASN1CALL ASN1Enc_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1encoding_t enc, PMultipointCapability_mediaDistributionCapability val);
    extern int ASN1CALL ASN1Dec_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1decoding_t dec, PMultipointCapability_mediaDistributionCapability val);
    extern void ASN1CALL ASN1Free_MultipointCapability_mediaDistributionCapability_ElmFn(PMultipointCapability_mediaDistributionCapability val);
    extern int ASN1CALL ASN1Enc_H222Capability_vcCapability_ElmFn(ASN1encoding_t enc, PH222Capability_vcCapability val);
    extern int ASN1CALL ASN1Dec_H222Capability_vcCapability_ElmFn(ASN1decoding_t dec, PH222Capability_vcCapability val);
    extern void ASN1CALL ASN1Free_H222Capability_vcCapability_ElmFn(PH222Capability_vcCapability val);
    extern int ASN1CALL ASN1Enc_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1encoding_t enc, PCapabilityDescriptor_simultaneousCapabilities val);
    extern int ASN1CALL ASN1Dec_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1decoding_t dec, PCapabilityDescriptor_simultaneousCapabilities val);
    extern void ASN1CALL ASN1Free_CapabilityDescriptor_simultaneousCapabilities_ElmFn(PCapabilityDescriptor_simultaneousCapabilities val);
    extern int ASN1CALL ASN1Enc_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1encoding_t enc, PCommunicationModeTableEntry_nonStandard val);
    extern int ASN1CALL ASN1Dec_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1decoding_t dec, PCommunicationModeTableEntry_nonStandard val);
    extern void ASN1CALL ASN1Free_CommunicationModeTableEntry_nonStandard_ElmFn(PCommunicationModeTableEntry_nonStandard val);
    extern int ASN1CALL ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1encoding_t enc, PMultiplexEntrySend_multiplexEntryDescriptors val);
    extern int ASN1CALL ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1decoding_t dec, PMultiplexEntrySend_multiplexEntryDescriptors val);
    extern void ASN1CALL ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(PMultiplexEntrySend_multiplexEntryDescriptors val);
    extern int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelAckParameters_nonStandard val);
    extern int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelAckParameters_nonStandard val);
    extern void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters_nonStandard_ElmFn(PH2250LogicalChannelAckParameters_nonStandard val);
    extern int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelParameters_nonStandard val);
    extern int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelParameters_nonStandard val);
    extern void ASN1CALL ASN1Free_H2250LogicalChannelParameters_nonStandard_ElmFn(PH2250LogicalChannelParameters_nonStandard val);
    extern int ASN1CALL ASN1Enc_ConferenceCapability_nonStandardData_ElmFn(ASN1encoding_t enc, PConferenceCapability_nonStandardData val);
    extern int ASN1CALL ASN1Dec_ConferenceCapability_nonStandardData_ElmFn(ASN1decoding_t dec, PConferenceCapability_nonStandardData val);
    extern void ASN1CALL ASN1Free_ConferenceCapability_nonStandardData_ElmFn(PConferenceCapability_nonStandardData val);
    extern int ASN1CALL ASN1Enc_MediaDistributionCapability_distributedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_distributedData val);
    extern int ASN1CALL ASN1Dec_MediaDistributionCapability_distributedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_distributedData val);
    extern void ASN1CALL ASN1Free_MediaDistributionCapability_distributedData_ElmFn(PMediaDistributionCapability_distributedData val);
    extern int ASN1CALL ASN1Enc_MediaDistributionCapability_centralizedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_centralizedData val);
    extern int ASN1CALL ASN1Dec_MediaDistributionCapability_centralizedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_centralizedData val);
    extern void ASN1CALL ASN1Free_MediaDistributionCapability_centralizedData_ElmFn(PMediaDistributionCapability_centralizedData val);
    extern int ASN1CALL ASN1Enc_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeResponse_communicationModeTable val);
    extern int ASN1CALL ASN1Dec_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeResponse_communicationModeTable val);
    extern void ASN1CALL ASN1Free_CommunicationModeResponse_communicationModeTable_ElmFn(PCommunicationModeResponse_communicationModeTable val);
    extern int ASN1CALL ASN1Enc_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeCommand_communicationModeTable val);
    extern int ASN1CALL ASN1Dec_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeCommand_communicationModeTable val);
    extern void ASN1CALL ASN1Free_CommunicationModeCommand_communicationModeTable_ElmFn(PCommunicationModeCommand_communicationModeTable val);
    extern int ASN1CALL ASN1Enc_RequestMode_requestedModes_ElmFn(ASN1encoding_t enc, PRequestMode_requestedModes val);
    extern int ASN1CALL ASN1Dec_RequestMode_requestedModes_ElmFn(ASN1decoding_t dec, PRequestMode_requestedModes val);
    extern void ASN1CALL ASN1Free_RequestMode_requestedModes_ElmFn(PRequestMode_requestedModes val);
    extern int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1encoding_t enc, PTerminalCapabilitySet_capabilityTable val);
    extern int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1decoding_t dec, PTerminalCapabilitySet_capabilityTable val);
    extern void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityTable_ElmFn(PTerminalCapabilitySet_capabilityTable val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _H245ASN_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\intelcc\include\port32.h ===
//////////////////////////////////////////////////////////////////////////////
//
//              INTEL CORPORATION PROPRIETARY INFORMATION
//  
//   This source is supplied under the terms of a licence agreement or
//   non-disclosure statement with Intel Corporation and may not be copied
//   nor disclosed except in accordance with the terms of that agreement.
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// PORT32.H
// Stuff to make porting from Win3.1 to Win32 a little less hellish.
//////////////////////////////////////////////////////////////////////////////
#ifndef PORT32_H
#define PORT32_H


//////////////////////////////////////////////////////////////////////////////
// some convenient, explicit types
//////////////////////////////////////////////////////////////////////////////
typedef short INTEGER_16;
typedef int INTEGER_32;
typedef unsigned short UINTEGER_16;
typedef unsigned int UINTEGER_32;
typedef short BOOLEAN_16;

#ifndef _BASETSD_H_
typedef short INT16;
typedef int INT32;
typedef unsigned short UINT16;
typedef unsigned int UINT32;
#endif

typedef short BOOL16;
	
//////////////////////////////////////////////////////////////////////////////
// macros to make old keywords go away
//////////////////////////////////////////////////////////////////////////////
#define __pascal
#define _pascal
#define _far
#define __far
#define _export
#define __export
#define _huge
#define huge
#define __huge
#define  __segment
#define _HFAR_
#define _loadds
#define __loadds

//////////////////////////////////////////////////////////////////////////////
// other macros that may or may not be handy
//////////////////////////////////////////////////////////////////////////////
#define WRITE OF_WRITE

#define OFFSETOF(lp)        (int) (lp)
#define SELECTOROF

#define GLOBALHANDLE(lp)      GlobalHandle(lp)
#define GLOBALHANDLEFUNC(lp)  GlobalHandle(lp)
#define LOCALHANDLE(lp)       LocalHandle(lp)
#define LOCALHANDLEFUNC(lp)   LocalHandle(lp)


#define _AfxGetPtrFromFarPtr(p)   ((void*)(p))
#define GETWINDOWHINSTANCE(hWnd)  GetWindowLong(hWnd ,GWL_HINSTANCE)
#define GETWINDOWHPARENT(hWnd)    GetWindowLong(hWnd, GWL_HWNDPARENT)
#define GETWINDOWID(hWnd)         GetWindowLong(hWnd, GWL_ID)

#define SETCLASSCURSOR(hWnd,NewVal)  SetClassLong(hWnd ,GCL_HCURSOR,NewVal)

//////////////////////////////////////////////////////////////////////////////
// Name of shared mutex for serializing access to 16-bit data stack
//////////////////////////////////////////////////////////////////////////////
#define STR_DATASTACKMUX "_mux_DataStack"

#endif // PORT32_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\intelcc\include\rasplog.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1994:  Intel Corporation
// Confidential -- All proprietary rights reserved.
//
// AUTHOR	Steve Nesland, Sam Sakthivel
//
// DESCRIPTION
//		This file contains protocol logging definitions needed by MBFT and
//		the MBFT PDU logging class.
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

// This define identifies the MBFT protocol as the one to be logged.  In the 
// MBFT code, it is used only in the CPLInitialize() call.  
// For example:  MBFTProtocolLogger = CPLInitialize( MBFT_PROTOCOL );
//
#define RASLOG_PROTOCOL "RAS_PDU"

// PDU encoding type flags and PDU type flags.  These flags are passed from
// MBFT to the logging via user data.  Bit zero of the user data represents
// the ASN encoding type.  Bit 1 represents pdu type (Connect or Domain).
// Bit 2 represents whether the PDU was sent or received.
//

#define RASLOG_SENT_PDU                1UL
#define RASLOG_RECEIVED_PDU            0UL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\intelcc\include\q931pdu.h ===
/****************************************************************************
 *
 *  $Archive:   S:/STURGEON/SRC/INCLUDE/VCS/q931pdu.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *  Copyright (c) 1996 Intel Corporation.
 *
 *  $Revision:   1.11  $
 *  $Date:   22 Jan 1997 17:21:04  $
 *  $Author:   MANDREWS  $
 *
 *  Abstract: Parser routines for Q931 PDUs
 *
 ***************************************************************************/
#ifndef Q931PAR_H
#define Q931PAR_H

#include <winerror.h>
#include "av_asn1.h"

#ifdef __cplusplus
extern "C" {
#endif

struct S_BUFFERDESCR
{
    DWORD Length;
    BYTE *BufferPtr;
};

typedef struct S_BUFFERDESCR BUFFERDESCR;
typedef struct S_BUFFERDESCR *PBUFFERDESCR;

// Mask to extract a message type from a byte
#define MESSAGETYPEMASK 0x7f

typedef BYTE MESSAGEIDTYPE;

// Q931 defined message types
#define ALERTINGMESSAGETYPE      0x01
#define PROCEEDINGMESSAGETYPE    0x02
#define CONNECTMESSAGETYPE       0x07
#define CONNECTACKMESSAGETYPE    0x0F
#define PROGRESSMESSAGETYPE      0x03
#define SETUPMESSAGETYPE         0x05
#define SETUPACKMESSAGETYPE      0x0D

#define RESUMEMESSAGETYPE        0x26
#define RESUMEACKMESSAGETYPE     0x2E
#define RESUMEREJMESSAGETYPE     0x22
#define SUSPENDMESSAGETYPE       0x25
#define SUSPENDACKMESSAGETYPE    0x2D
#define SUSPENDREJMESSAGETYPE    0x21
#define USERINFOMESSAGETYPE      0x20

#define DISCONNECTMESSAGETYPE    0x45
#define RELEASEMESSAGETYPE       0x4D
#define RELEASECOMPLMESSAGETYPE  0x5A
#define RESTARTMESSAGETYPE       0x46
#define RESTARTACKMESSAGETYPE    0x4E

#define SEGMENTMESSAGETYPE       0x60
#define CONGCTRLMESSAGETYPE      0x79
#define INFORMATIONMESSAGETYPE   0x7B
#define NOTIFYMESSAGETYPE        0x6E
#define STATUSMESSAGETYPE        0x7D
#define STATUSENQUIRYMESSAGETYPE 0x75


// Mask to remove only the field identifier from a type 1 single octet field
#define TYPE1IDENTMASK 0xf0

// Mask to remove only the value from a type 1 single octet field
#define TYPE1VALUEMASK 0x0f

// Type of the field identitifiers
typedef BYTE FIELDIDENTTYPE;

// Field identifiers
// Single octet values
#define IDENT_RESERVED        0x80
#define IDENT_SHIFT           0x90
#define IDENT_MORE            0xA0
#define IDENT_SENDINGCOMPLETE 0xA1
#define IDENT_CONGESTION      0xB0
#define IDENT_REPEAT          0xD0

// Variable length octet values
#define IDENT_SEGMENTED       0x00
#define IDENT_BEARERCAP       0x04
#define IDENT_CAUSE           0x08
#define IDENT_CALLIDENT       0x10
#define IDENT_CALLSTATE       0x14
#define IDENT_CHANNELIDENT    0x18
#define IDENT_PROGRESS        0x1E
#define IDENT_NETWORKSPEC     0x20
#define IDENT_NOTIFICATION    0x27
#define IDENT_DISPLAY         0x28
#define IDENT_DATE            0x29
#define IDENT_KEYPAD          0x2C
#define IDENT_SIGNAL          0x34
#define IDENT_INFORMATIONRATE 0x40
#define IDENT_ENDTOENDDELAY   0x42
#define IDENT_TRANSITDELAY    0x43
#define IDENT_PLBINARYPARAMS  0x44
#define IDENT_PLWINDOWSIZE    0x45
#define IDENT_PACKETSIZE      0x46
#define IDENT_CLOSEDUG        0x47
#define IDENT_REVCHARGE       0x4A
#define IDENT_CALLINGNUMBER   0x6C
#define IDENT_CALLINGSUBADDR  0x6D
#define IDENT_CALLEDNUMBER    0x70
#define IDENT_CALLEDSUBADDR   0x71
#define IDENT_REDIRECTING     0x74
#define IDENT_TRANSITNET      0x78
#define IDENT_RESTART         0x79
#define IDENT_LLCOMPATIBILITY 0x7C
#define IDENT_HLCOMPATIBILITY 0x7D
#define IDENT_USERUSER        0x7E
   
//-------------------------------------------------------------------
// Structures for messages and information elements
//-------------------------------------------------------------------

typedef BYTE PDTYPE;
#define Q931PDVALUE ((PDTYPE)0x08)

typedef WORD CRTYPE;

// Since right now we don't need to separate out the individual
// parts of the fields of the structures these are the base 
// types from which the fields are made.
// Single octet element type 1 (contains a value)
struct S_SINGLESTRUCT1
{
    BOOLEAN Present;
    BYTE Value;
};

// Single octet element type 2 (does not contain a value)
struct S_SINGLESTRUCT2
{
    BOOLEAN Present;
};

// Variable length element
// Maximum element size
#define MAXVARFIELDLEN 131

struct S_VARSTRUCT
{
    BOOLEAN Present;
    BYTE Length;
    BYTE Contents[MAXVARFIELDLEN];
};

// Right now all of the fields are bound to the simplest
// structures above.  No parsing other than just 
// single octet/variable octet is done.  When the values
// in some of the subfields are important, change the 
// structures here and change the appropriate parsing
// routine to generate the right structure

// The shift element is a single type 1
typedef struct S_SINGLESTRUCT1 SHIFTIE;
typedef struct S_SINGLESTRUCT1 *PSHIFTIE;

// The more data element is a single type 2
typedef struct S_SINGLESTRUCT2 MOREDATAIE;
typedef struct S_SINGLESTRUCT2 *PMOREDATAIE;

// The sending complete element is a single type 2
typedef struct S_SINGLESTRUCT2 SENDCOMPLIE;
typedef struct S_SINGLESTRUCT2 *PSENDCOMPLIE;

// The congestion level element is a single type 1
typedef struct S_SINGLESTRUCT1 CONGESTIONIE;
typedef struct S_SINGLESTRUCT1 *PCONGESTIONIE;

// The repeat indicator element is a single type 1
typedef struct S_SINGLESTRUCT1 REPEATIE;
typedef struct S_SINGLESTRUCT1 *PREPEATIE;

// The segmented element is a variable 
typedef struct S_VARSTRUCT SEGMENTEDIE;
typedef struct S_VARSTRUCT *PSEGMENTEDIE;

// The bearer capability element is a variable 
typedef struct S_VARSTRUCT BEARERCAPIE;
typedef struct S_VARSTRUCT *PBEARERCAPIE;

// The cause element is a variable 
typedef struct S_VARSTRUCT CAUSEIE;
typedef struct S_VARSTRUCT *PCAUSEIE;

// The call identity element is a variable 
typedef struct S_VARSTRUCT CALLIDENTIE;
typedef struct S_VARSTRUCT *PCALLIDENTIE;

// The call state element is a variable 
typedef struct S_VARSTRUCT CALLSTATEIE;
typedef struct S_VARSTRUCT *PCALLSTATEIE;

// The channel identifier element is a variable 
typedef struct S_VARSTRUCT CHANIDENTIE;
typedef struct S_VARSTRUCT *PCHANIDENTIE;

// The progress indicator element is a variable 
typedef struct S_VARSTRUCT PROGRESSIE;
typedef struct S_VARSTRUCT *PPROGRESSIE;

// The network specific element is a variable 
typedef struct S_VARSTRUCT NETWORKIE;
typedef struct S_VARSTRUCT *PNETWORKIE;

// The notification indicator element is a variable 
typedef struct S_VARSTRUCT NOTIFICATIONINDIE;
typedef struct S_VARSTRUCT *PNOTIFICATIONINDIE;

// The display element is a variable 
typedef struct S_VARSTRUCT DISPLAYIE;
typedef struct S_VARSTRUCT *PDISPLAYIE;

// The date element is a variable 
typedef struct S_VARSTRUCT DATEIE;
typedef struct S_VARSTRUCT *PDATEIE;

// The keypad element is a variable 
typedef struct S_VARSTRUCT KEYPADIE;
typedef struct S_VARSTRUCT *PKEYPADIE;

// The signal element is a variable 
typedef struct S_VARSTRUCT SIGNALIE;
typedef struct S_VARSTRUCT *PSIGNALIE;

// The information rate element is a variable 
typedef struct S_VARSTRUCT INFORATEIE;
typedef struct S_VARSTRUCT *PINFORATEIE;

// The end to end transit delay element is a variable 
typedef struct S_VARSTRUCT ENDTOENDDELAYIE;
typedef struct S_VARSTRUCT *PENDTOENDDELAYIE;

// The transit delay element is a variable 
typedef struct S_VARSTRUCT TRANSITDELAYIE;
typedef struct S_VARSTRUCT *PTRANSITDELAYIE;

// The packet layer binary parameters element is a variable 
typedef struct S_VARSTRUCT PLBINARYPARAMSIE;
typedef struct S_VARSTRUCT *PPLBINARYPARAMSIE;

// The packet layer window size element is a variable 
typedef struct S_VARSTRUCT PLWINDOWSIZEIE;
typedef struct S_VARSTRUCT *PPLWINDOWSIZEIE;

// The packet size element is a variable 
typedef struct S_VARSTRUCT PACKETSIZEIE;
typedef struct S_VARSTRUCT *PPACKETSIZEIE;

// The closed user group element is a variable 
typedef struct S_VARSTRUCT CLOSEDUGIE;
typedef struct S_VARSTRUCT *PCLOSEDUGIE;

// The reverse charge indication element is a variable 
typedef struct S_VARSTRUCT REVERSECHARGEIE;
typedef struct S_VARSTRUCT *PREVERSECHARGEIE;

// The calling party number element is a variable 
typedef struct S_VARSTRUCT CALLINGNUMBERIE;
typedef struct S_VARSTRUCT *PCALLINGNUMBERIE;

// The calling party subaddress element is a variable 
typedef struct S_VARSTRUCT CALLINGSUBADDRIE;
typedef struct S_VARSTRUCT *PCALLINGSUBADDRIE;

// The called party subaddress element is a variable 
typedef struct S_VARSTRUCT CALLEDSUBADDRIE;
typedef struct S_VARSTRUCT *PCALLEDSUBADDRIE;

// The redirecting number element is a variable 
typedef struct S_VARSTRUCT REDIRECTINGIE;
typedef struct S_VARSTRUCT *PREDIRECTINGIE;

// The transit network selection element is a variable 
typedef struct S_VARSTRUCT TRANSITNETIE;
typedef struct S_VARSTRUCT *PTRANSITNETIE;

// The restart indicator element is a variable 
typedef struct S_VARSTRUCT RESTARTIE;
typedef struct S_VARSTRUCT *PRESTARTIE;

// The low layer compatibility element is a variable 
typedef struct S_VARSTRUCT LLCOMPATIBILITYIE;
typedef struct S_VARSTRUCT *PLLCOMPATIBILITYIE;

// The higher layer compatibility element is a variable 
typedef struct S_VARSTRUCT HLCOMPATIBILITYIE;
typedef struct S_VARSTRUCT *PHLCOMPATIBILITYIE;

#define Q931_PROTOCOL_X209 ((PDTYPE)0x05)

struct S_VARSTRUCT_UU
{
    BOOLEAN Present;
    BYTE ProtocolDiscriminator;
    WORD UserInformationLength;
    BYTE UserInformation[0x1000];   // 4k bytes should be good for now...
};

// The user to user element is a variable 
typedef struct S_VARSTRUCT_UU USERUSERIE;
typedef struct S_VARSTRUCT_UU *PUSERUSERIE;

struct S_PARTY_NUMBER
{
    BOOLEAN Present;
    BYTE NumberType;
    BYTE NumberingPlan;
    BYTE PartyNumberLength;
    BYTE PartyNumbers[MAXVARFIELDLEN];
};

// The called party number element is a variable 
typedef struct S_PARTY_NUMBER CALLEDNUMBERIE;
typedef struct S_PARTY_NUMBER *PCALLEDNUMBERIE;

// Q932 defined message types
#define FACILITYMESSAGETYPE   0x62
#define IDENT_FACILITY        0x1C
typedef struct S_VARSTRUCT FACILITYIE;
typedef struct S_VARSTRUCT *PFACILITYIE;


// Generic structure for a Q.931 message
struct S_MESSAGE
{
    PDTYPE ProtocolDiscriminator;
    CRTYPE CallReference;
    MESSAGEIDTYPE MessageType;
    SHIFTIE Shift;
    MOREDATAIE MoreData;
    SENDCOMPLIE SendingComplete;
    CONGESTIONIE CongestionLevel;
    REPEATIE RepeatIndicator;
    SEGMENTEDIE SegmentedMessage;
    BEARERCAPIE BearerCapability;
    CAUSEIE Cause;
    CALLIDENTIE CallIdentity;
    CALLSTATEIE CallState;
    CHANIDENTIE ChannelIdentification;
    PROGRESSIE ProgressIndicator;
    NETWORKIE NetworkFacilities;
    NOTIFICATIONINDIE NotificationIndicator;
    DISPLAYIE Display;
    DATEIE Date;
    KEYPADIE Keypad;
    SIGNALIE Signal;
    INFORATEIE InformationRate;
    ENDTOENDDELAYIE EndToEndTransitDelay;
    TRANSITDELAYIE TransitDelay;
    PLBINARYPARAMSIE PacketLayerBinaryParams;
    PLWINDOWSIZEIE PacketLayerWindowSize;
    PACKETSIZEIE PacketSize;
    CLOSEDUGIE ClosedUserGroup;
    REVERSECHARGEIE ReverseChargeIndication;
    CALLINGNUMBERIE CallingPartyNumber;
    CALLINGSUBADDRIE CallingPartySubaddress;
    CALLEDNUMBERIE CalledPartyNumber;
    CALLEDSUBADDRIE CalledPartySubaddress;
    REDIRECTINGIE RedirectingNumber;
    TRANSITNETIE TransitNetworkSelection;
    RESTARTIE RestartIndicator;
    LLCOMPATIBILITYIE LowLayerCompatibility;
    HLCOMPATIBILITYIE HighLayerCompatibility;
    FACILITYIE Facility;
    USERUSERIE UserToUser;
};

typedef struct S_MESSAGE Q931MESSAGE;
typedef struct S_MESSAGE *PQ931MESSAGE;

//-------------------------------------------------------------------
// Single routine for parsing Q931 messages
//-------------------------------------------------------------------
HRESULT
Q931ParseMessage(
    BYTE *CodedBufferPtr,
    DWORD CodedBufferLength,
    PQ931MESSAGE Message);

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

//==========================================================
// CAUSE FIELD DEFINITIONS
//==========================================================
#define CAUSE_EXT_BIT                0x80
#define CAUSE_CODING_CCITT           0x00
#define CAUSE_LOCATION_USER          0x00
#define CAUSE_RECOMMENDATION_Q931    0x00

#define CAUSE_VALUE_NORMAL_CLEAR     0x10
#define CAUSE_VALUE_USER_BUSY        0x11
#define CAUSE_VALUE_NO_ANSWER        0x13   // Callee does not answer
#define CAUSE_VALUE_REJECTED         0x15
#define CAUSE_VALUE_ENQUIRY_RESPONSE 0x1E
#define CAUSE_VALUE_NOT_IMPLEMENTED  0x4F
#define CAUSE_VALUE_INVALID_CRV      0x51
#define CAUSE_VALUE_INVALID_MSG      0x5F
#define CAUSE_VALUE_IE_MISSING       0x60
#define CAUSE_VALUE_IE_CONTENTS      0x64
#define CAUSE_VALUE_TIMER_EXPIRED    0x66

typedef struct _ERROR_MAP
{
    int nErrorCode;
#ifdef UNICODE_TRACE
    LPWSTR pszErrorText;
#else
    LPSTR pszErrorText;
#endif
} ERROR_MAP;

typedef struct _BINARY_STRING
{
    WORD length;
    BYTE *ptr;
} BINARY_STRING;

typedef struct _Q931_SETUP_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    PCC_ALIASNAMES pCallerAliasList;
    PCC_ALIASNAMES pCalleeAliasList;
    PCC_ALIASNAMES pExtraAliasList;
    PCC_ALIASITEM pExtensionAliasItem;
    BOOL SourceAddrPresent;
    BOOL CallerAddrPresent;
    BOOL CalleeAddrPresent;
    BOOL CalleeDestAddrPresent;
    CC_ADDR SourceAddr;                // originating addr
    CC_ADDR CallerAddr;                // gk addr
    CC_ADDR CalleeAddr;                // local addr
    CC_ADDR CalleeDestAddr;            // target destination addr
    WORD wGoal;
    WORD wCallType;
    BOOL bCallerIsMC;
    CC_CONFERENCEID ConferenceID;

    CC_ENDPOINTTYPE EndpointType;
    CC_VENDORINFO VendorInfo;
    BYTE bufProductValue[CC_MAX_PRODUCT_LENGTH];
    BYTE bufVersionValue[CC_MAX_VERSION_LENGTH];

} Q931_SETUP_ASN;

typedef struct _Q931_RELEASE_COMPLETE_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    BYTE bReason;
} Q931_RELEASE_COMPLETE_ASN;

typedef struct _Q931_CONNECT_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    BOOL h245AddrPresent;
    CC_ADDR h245Addr;
    CC_CONFERENCEID ConferenceID;

    CC_ENDPOINTTYPE EndpointType;
    CC_VENDORINFO VendorInfo;
    BYTE bufProductValue[CC_MAX_PRODUCT_LENGTH];
    BYTE bufVersionValue[CC_MAX_VERSION_LENGTH];

} Q931_CONNECT_ASN;

typedef struct _Q931_ALERTING_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    CC_ADDR h245Addr;
} Q931_ALERTING_ASN;

typedef struct _Q931_CALL_PROCEEDING_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    CC_ADDR h245Addr;
} Q931_CALL_PROCEEDING_ASN;

typedef struct _Q931_FACILITY_ASN
{
    BOOL NonStandardDataPresent;
    CC_NONSTANDARDDATA NonStandardData;
    CC_ADDR AlternativeAddr;
    PCC_ALIASNAMES pAlternativeAliasList;
    CC_CONFERENCEID ConferenceID;
    BOOL ConferenceIDPresent;
    BYTE bReason;
} Q931_FACILITY_ASN;

//-------------------------------------------------------------------
// Initialization Routines
//-------------------------------------------------------------------
HRESULT Q931InitPER();
HRESULT Q931DeInitPER();

//-------------------------------------------------------------------
// Parsing Routines
//-------------------------------------------------------------------

HRESULT
Q931MakeEncodedMessage(
    PQ931MESSAGE Message,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931SetupParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_SETUP_ASN *pParsedData);

HRESULT
Q931ReleaseCompleteParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_RELEASE_COMPLETE_ASN *pParsedData);

HRESULT
Q931ConnectParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_CONNECT_ASN *pParsedData);

HRESULT
Q931AlertingParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_ALERTING_ASN *pParsedData);

HRESULT
Q931ProceedingParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_CALL_PROCEEDING_ASN *pParsedData);

HRESULT
Q931FacilityParseASN(
    ASN1_CODER_INFO *pWorld,
    BYTE *pEncodedBuf,
    DWORD dwEncodedLength,
    Q931_FACILITY_ASN *pParsedData);

//-------------------------------------------------------------------
// Encoding Routines
//-------------------------------------------------------------------

// routines for the Setup Message:
HRESULT
Q931SetupEncodePDU(
    WORD wCallReference,
    char *pszDisplay,
    char *pszCalledPartyNumber,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931SetupEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *pCallerAddr,
    CC_ADDR *pCalleeAddr,
    WORD wGoal,
    WORD wCallType,
    BOOL bCallerIsMC,
    CC_CONFERENCEID *pConferenceID,
    PCC_ALIASNAMES pCallerAliasList,
    PCC_ALIASNAMES pCalleeAliasList,
    PCC_ALIASNAMES pExtraAliasList,
    PCC_ALIASITEM pExtensionAliasItem,
    PCC_VENDORINFO pVendorInfo,
    BOOL bIsTerminal,
    BOOL bIsGateway,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength);

// routines for the Release Complete Message:
HRESULT
Q931ReleaseCompleteEncodePDU(
    WORD wCallReference,
    BYTE *pbCause,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931ReleaseCompleteEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_CONFERENCEID *pConferenceID, // must be able to support 16 byte conf id's!
    BYTE *pbReason,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength);

// routines for the Connect Message:
HRESULT
Q931ConnectEncodePDU(
    WORD wCallReference,
    char *pszDisplay,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931ConnectEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_CONFERENCEID *pConferenceID, // must be able to support 16 byte conf id's!
    CC_ADDR *h245Addr,
    PCC_ENDPOINTTYPE pEndpointType,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength);

// routines for the Alerting Message:
HRESULT
Q931AlertingEncodePDU(
    WORD wCallReference,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931AlertingEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *h245Addr,
    PCC_ENDPOINTTYPE pEndpointType,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength);

// routines for the Proceeding Message:
HRESULT
Q931ProceedingEncodePDU(
    WORD wCallReference,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931ProceedingEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *h245Addr,
    PCC_ENDPOINTTYPE pEndpointType,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength);

HRESULT
Q931FacilityEncodePDU(
    WORD wCallReference,
    BINARY_STRING *pUserUserData,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

HRESULT
Q931FacilityEncodeASN(
    PCC_NONSTANDARDDATA pNonStandardData,
    CC_ADDR *AlternativeAddr,
    BYTE bReason,
    CC_CONFERENCEID *pConferenceID,
    PCC_ALIASNAMES pAlternativeAliasList,
    ASN1_CODER_INFO *pWorld,
    BYTE **ppEncodedBuf,
    DWORD *pdwEncodedLength);

HRESULT
Q931StatusEncodePDU(
    WORD wCallReference,
    char *pszDisplay,
    BYTE bCause,
    BYTE bCallState,
    BYTE **CodedBufferPtr,
    DWORD *CodedBufferLength);

void
Q931FreeEncodedBuffer(ASN1_CODER_INFO *pWorld, BYTE *pEncodedBuf);

#ifdef __cplusplus
}
#endif

#endif Q931PAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\intelcc\include\linkapi.h ===
/***************************************************************************
 *
 * File: linkapi.h
 *
 * INTEL Corporation Proprietary Information
 * Copyright (c) 1996 Intel Corporation.
 *
 * This listing is supplied under the terms of a license agreement
 * with INTEL Corporation and may not be used, copied, nor disclosed
 * except in accordance with the terms of that agreement.
 *
 ***************************************************************************
 *
 * $Workfile:   linkapi.h  $
 * $Revision:   1.17  $
 * $Modtime:   11 Dec 1996 13:57:14  $
 * $Log:   S:\sturgeon\src\include\vcs\linkapi.h_v  $
 * 
 *    Rev 1.17   11 Dec 1996 14:10:48   SBELL1
 * changed parameters to linkLayerInit/Listen
 * 
 *    Rev 1.16.1.0   11 Dec 1996 13:57:14   SBELL1
 * CHanged parameters to linkLayerInit and Listen.
 * 
 *    Rev 1.16   14 Oct 1996 14:00:20   EHOWARDX
 * 
 * Unicode changes.
 * 
 *    Rev 1.15   15 Aug 1996 14:00:08   rodellx
 * 
 * Added additional address validation error case for DOMAIN_NAME addresses
 * which cannot be resolved, but are used with SocketBind().
 * 
 *    Rev 1.14   11 Jul 1996 18:42:10   rodellx
 * 
 * Fixed bug where HRESULT ids were in violation of Facility and/or Code
 * value rules.
 * 
 *    Rev 1.13   10 Jul 1996 21:36:26   rodellx
 * 
 * Changed error code base to required value defined by apierror.h.
 * 
 *    Rev 1.12   May 28 1996 18:09:08   plantz
 * Change all error and message codes to use HRESULT. Deleted unused codes.
 * 
 *    Rev 1.11   09 May 1996 18:28:36   EHOWARDX
 * Eliminated unnessary formal parameters.
 * 
 *    Rev 1.4   25 Apr 1996 21:43:50   helgebax
 * Copied Philip's changes from sturgeon\src\include.
 * 
 *    Rev 1.10   Apr 25 1996 21:07:16   plantz
 * Add messages for connect callback.
 * Add connect callback parameter to link layer accept.
 * 
 *    Rev 1.9   Apr 25 1996 15:36:50   plantz
 * Remove #include incommon.h and dependencies on types defined in incommon
 * (use pointers to incomplete structure types instead).
 * 
 *    Rev 1.8   Apr 24 1996 20:54:08   plantz
 * Change name of H245LISTENCALLBACK to H245CONNECTCALLBACK and add additional
 * parameters. Add it as an parameter to linkLayerConnect as well as
 * linkLayerListen.
 * 
 *    Rev 1.7   Apr 24 1996 17:00:04   plantz
 * Merge 1.3.1.0 with 1.6 (changes to support Q931).
 * 
 *    Rev 1.6   19 Apr 1996 10:35:36   EHOWARDX
 * Encorporate Dan's latest SRPAPI.H changes.
 * 
 *    Rev 1.3.1.0   Apr 23 1996 13:45:26   plantz
 * Changes to support Q.931.
 * 
 *****************************************************************************/

#ifndef LINKAPI_H
#define LINKAPI_H

#include "apierror.h"

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)

// declare exported functions
#if defined(LINKDLL_EXPORT)
#define LINKDLL __declspec (dllexport)
#else   // (LINKDLL_EXPORT)
#define LINKDLL __declspec (dllimport)
#endif  // (LINKDLL_EXPORT)
#define SRPDLL LINKDLL

////////////////////////////////////////////////////////////////////////////
//
// Link Layer defaults
//
////////////////////////////////////////////////////////////////////////////

#define INVALID_PHYS_ID			(DWORD) 0xffffffff


////////////////////////////////////////////////////////////////////////////
//
// Link Layer Error defines
//
////////////////////////////////////////////////////////////////////////////

#define LINK_ERROR_BASE        ERROR_LOCAL_BASE_ID
#define LINK_SEND_ERROR_BASE   LINK_ERROR_BASE + 0x100
#define LINK_SEND_COMP_BASE    LINK_ERROR_BASE + 0x200
#define LINK_RCV_ERROR_BASE    LINK_ERROR_BASE + 0x300
#define LINK_RCV_COMP_BASE     LINK_ERROR_BASE + 0x400
#define LINK_UTIL_ERROR_BASE   LINK_ERROR_BASE + 0x500
#define LINK_UTIL_COMP_BASE    LINK_ERROR_BASE + 0x600
#define LINK_FATAL_ERROR       LINK_ERROR_BASE + 0x700
#define LINK_CONN_ERROR_BASE   LINK_ERROR_BASE + 0x800
#define LINK_CONN_COMP_BASE    LINK_ERROR_BASE + 0x900

////////////////////////////////////////////////////////////////////////////
//
// CallBack Prototype for Channel CallBack
//
////////////////////////////////////////////////////////////////////////////

typedef void (*H245SRCALLBACK)
(
    DWORD       dwH245Instance,
    HRESULT     dwMessage,
    PBYTE       pbyDataBuf,
    DWORD       dwLength
);

// Link Send Callback error codes
#define LINK_SEND_COMPLETE     MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_SEND_COMP_BASE+ 0)
#define LINK_SEND_ABORT        MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_SEND_COMP_BASE+ 5) // Tx aborted the SDU (not implemented)
#define LINK_SEND_WOULD_BLOCK  MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_SEND_COMP_BASE+20)
#define LINK_SEND_CLOSED       MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_SEND_COMP_BASE+22)
#define LINK_SEND_ERROR        MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_SEND_COMP_BASE+23)

// Link Receive Callback error codes
#define LINK_RECV_DATA         MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_RCV_COMP_BASE+ 6) // DATA.INDICATION from H.223 (Should not be zero)
#define LINK_RECV_ABORT        MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_RCV_COMP_BASE+ 7) // Tx aborted the SDU (not implemented)
#define LINK_RECV_ERROR        MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_RCV_COMP_BASE+10) // from AL2 - _CRC error
#define LINK_RECV_WOULD_BLOCK  MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_RCV_COMP_BASE+20)
#define LINK_RECV_CLOSED       MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_RCV_COMP_BASE+22)

typedef void (*H245CONNECTCALLBACK)
(
   DWORD       dwH245Instance,
   HRESULT     dwMessage,
   struct _ADDR *LocalAddr,
   struct _ADDR *PeerAddr
);

#define LINK_CONNECT_REQUEST   MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_CONN_COMP_BASE+1)
#define LINK_CONNECT_COMPLETE  MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_CONN_COMP_BASE+2)

////////////////////////////////////////////////////////////////////////////
//
// Link Layer Function Prototypes
//
////////////////////////////////////////////////////////////////////////////
LINKDLL VOID H245WSShutdown();

/**************************************************************************
**	Function 	: linkLayerInit
**	Description : This function will initialize the datalink subsystem. 
**				  This in turn will make appropriate calls to initialize 
**				  the software and hardware subsystems below this layer. 
**				  linkLayernit() has to be called before any other service or
**				  System control functions are used.
****************************************************************************/
LINKDLL HRESULT
linkLayerInit
(
    DWORD*           pdwPhysicalId,
    DWORD           dwH245Instance,
    H245SRCALLBACK  cbReceiveComplete,
    H245SRCALLBACK  cbTransmitComplete
);

typedef
HRESULT 
(*PFxnlinkLayerInit)
(
    DWORD*           pdwPhysicalId,
    DWORD           dwH245Instance,
    H245SRCALLBACK  cbReceiveComplete,
    H245SRCALLBACK  cbTransmitComplete
);

///////////////////////////////////////////////////////////////
///
///	SRP Initialization defines
///
///////////////////////////////////////////////////////////////

#define LINK_INVALID_INSTANCE    MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_ERROR_BASE+1)
#define LINK_DUPLICATE_INSTANCE  MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_ERROR_BASE+2)
#define LINK_MEM_FAILURE         MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, ERROR_OUTOFMEMORY)
#define LINK_INVALID_STATE       MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_ERROR_BASE+6)



/**************************************************************************
**	Function 	: linkLayerShutdown
**	Description : This releases all the memory the link layer used for a particular 
**				  instance. For using any of the linklayer services in that 
**				  instance again, a linkLayerInit has to be called. 
**				  This function will shutdown the linklayer session pointed 
**				  by the dwPhysicalID.
***************************************************************************/
LINKDLL HRESULT
linkLayerShutdown
(DWORD dwPhysicalId);



typedef
 HRESULT 
(*PFxnlinkLayerShutdown)
(DWORD dwPhysicalId);



///////////////////////////////////////////////////////////////
///
///	SRP Termination defines
///
///////////////////////////////////////////////////////////////

/**************************************************************************
**	Function 	: linkLayerGetInstance
**	Description : Returns the link layer instance corresponding to a physical ID
***************************************************************************/
LINKDLL DWORD
linkLayerGetInstance
(DWORD dwPhysicalId);



typedef
DWORD  
(*PFxnlinkLayerGetInstance)
(DWORD dwPhysicalId);



/**************************************************************************
**	Function 	: datalinkReceiveRequest
**	Description : Posts one receive message buffer to the link layer subsystem. 
**				  This buffer will be filled in by the incoming message for
** 				  the specified channel. H223_DATA_INDICATION will be sendto 
**				  the client on receiving a complete PDU. Error messages may also be 
**				  reported.
***************************************************************************/
LINKDLL HRESULT
datalinkReceiveRequest
(
    DWORD   dwPhysicalId,
    PBYTE   pbyDataBuf,
    DWORD   dwLength
);

typedef
HRESULT  
(*PFxndatalinkReceiveRequest)
(
    DWORD   dwPhysicalId,
    PBYTE   pbyDataBuf,
    DWORD   dwLength
);

// Link Receive Request return codes

#define LINK_RECV_NOBUFF       MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_RCV_ERROR_BASE+ 2) // No room for buffering


/**************************************************************************
**	Function 	: datalinkSendRequest
**	Description : Hands over the message to be sent to the link layer subsystem.
***************************************************************************/
LINKDLL HRESULT
datalinkSendRequest
(
    DWORD   dwPhysicalId,
    PBYTE   pbyDataBuf,
    DWORD   dwLength
);

typedef
HRESULT  
(*PFxndatalinkSendRequest)
(
    DWORD   dwPhysicalId,
    PBYTE   pbyDataBuf,
    DWORD   dwLength
);

// Link Send Request return codes

#define LINK_SEND_NOBUFF       MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,   TRUE, FACILITY_H245WS, LINK_SEND_ERROR_BASE+2)


/**************************************************************************
**	Function 	: linkLayerFlushChannel
**	Description : All the posted transmit and/or receive buffers are released.
**					The bitmasks DATALINK_RECEIVE and DATALINK_RECEIVE can
**					be OR'd together to perform both functions in the same call
**************************************************************************/
LINKDLL HRESULT
linkLayerFlushChannel
(DWORD dwPhysicalId, DWORD dwDirectionMask);




typedef
HRESULT 
(*PFxnlinkLayerFlushChannel)
(DWORD dwPhysicalId, DWORD dwDirectionMask);




// Bits for dwDirectionMask
#define DATALINK_RECEIVE      0x01  // Flush buffer in receive direction
#define DATALINK_TRANSMIT     0x02  // Flush buffer in Transmit direction
#define DATALINK_TX_ACTIVES   0x04  // Flush buffers actively being transmitted
#define SHUTDOWN_PENDING      0x08  // Shutdown is in progress
#define FLUSH_SYNCH           0x10  // 0: Asynch call, 1: Synchronous call
#define DATALINK_TRANSMIT_ALL (DATALINK_TRANSMIT | DATALINK_TX_ACTIVES)
#define SHUTDOWN_MASK         (DATALINK_RECEIVE | DATALINK_TRANSMIT | SHUTDOWN_PENDING)


// linkLayerFlushChannel Callback

#define LINK_FLUSH_COMPLETE   MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS, TRUE, FACILITY_H245WS, LINK_UTIL_COMP_BASE+1)


/**************************************************************************
**	Function 	: linkLayerFlushAll
**	Description : All the posted transmit and/or receive buffers are released.
**					Same as LinkLayerFlushChannel except:
**					1) Synchronous Call
**					2) Transmit Buffers in progress are flushed
**************************************************************************/
LINKDLL HRESULT
linkLayerFlushAll
(DWORD	dwPhysicalId);



typedef
HRESULT 
(*PFxnlinkLayerFlushAll)
(DWORD	dwPhysicalId);



// linkLayerFlushChannel RETURN CODES same as for linkLayerFlushChannel

#define LINK_UNKNOWN_ADDR      MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_H245WS, LINK_UTIL_ERROR_BASE + 1)

LINKDLL HRESULT
linkLayerConnect(DWORD dwPhysicalId, struct _ADDR *pAddr, H245CONNECTCALLBACK callback);

LINKDLL HRESULT
linkLayerListen(DWORD* dwPhysicalId, DWORD dwH245Instance, struct _ADDR *pAddr, H245CONNECTCALLBACK callback);

LINKDLL HRESULT
linkLayerAccept(DWORD dwPhysicalIdListen, DWORD dwPhysicalIdAccept, H245CONNECTCALLBACK callback);


#define LL_PDU_SIZE             2048



/**************************************************************************
**
**  Dynamic DLL Function Calls
**
**************************************************************************/
#ifdef UNICODE
#define SRPDLLFILE          L"h245srp.dll"
#define H245WSDLLFILE       L"h245ws.dll"
#else
#define SRPDLLFILE          "h245srp.dll"
#define H245WSDLLFILE       "h245ws.dll"
#endif
#define LINKINITIALIZE      __TEXT("linkLayerInit")
#define LINKSHUTDOWN        __TEXT("linkLayerShutdown")
#define LINKGETINSTANCE     __TEXT("linkLayerGetInstance")
#define LINKRECEIVEREQUEST  __TEXT("datalinkReceiveRequest")
#define LINKSENDREQUEST     __TEXT("datalinkSendRequest")
#define LINKFLUSHCHANNEL    __TEXT("linkLayerFlushChannel")
#define LINKFLUSHALL        __TEXT("linkLayerFlushAll")

#if defined(__cplusplus)
}
#endif  // (__cplusplus)

#endif  // LINKAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\intelcc\include\q931.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/INCLUDE/VCS/q931.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1996 Intel Corporation.
 *
 *	$Revision:   1.49  $
 *	$Date:   08 Jan 1997 18:02:54  $
 *	$Author:   EHOWARDX  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/


#ifndef Q931_H
#define Q931_H


#include "incommon.h"
#include "q931pdu.h"
#include "apierror.h"

#ifdef __cplusplus
extern "C" {
#endif

//====================================================================================
// Q931-specific codes
//====================================================================================

// Status codes
#define CS_OK                               NOERROR
#define CS_BAD_PARAM                        MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x1)
#define CS_DUPLICATE_LISTEN                 MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x2)
#define CS_INTERNAL_ERROR                   MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x3)
#define CS_BAD_SIZE                         MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x4)
#define CS_NO_MEMORY                        MAKE_Q931_ERROR(ERROR_OUTOFMEMORY)
#define CS_NOT_IMPLEMENTED                  MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x6)
#define CS_NOT_INITIALIZED                  MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x7)
#define CS_DUPLICATE_INITIALIZE             MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x8)
#define CS_SUBSYSTEM_FAILURE                MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x9)
#define CS_OUT_OF_SEQUENCE                  MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xA)
#define CS_PEER_UNREACHABLE                 MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xB)
#define CS_SETUP_TIMER_EXPIRED              MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xC)
#define CS_RINGING_TIMER_EXPIRED            MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xD)
#define CS_INCOMPATIBLE_VERSION             MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xE)

// parsing error cases
#define CS_OPTION_NOT_IMPLEMENTED           MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0xF)
#define CS_ENDOFINPUT                       MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x10)
#define CS_INVALID_FIELD                    MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x11)
#define CS_NO_FIELD_DATA                    MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x12)
#define CS_INVALID_PROTOCOL                 MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x13)
#define CS_INVALID_MESSAGE_TYPE             MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x14)
#define CS_MANDATORY_IE_MISSING             MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x15)
#define CS_BAD_IE_CONTENT                   MAKE_Q931_ERROR(ERROR_LOCAL_BASE_ID + 0x16)

// Event codes
#define Q931_CALL_INCOMING                  1
#define Q931_CALL_REMOTE_HANGUP             2
#define Q931_CALL_REJECTED                  3
#define Q931_CALL_ACCEPTED                  4
#define Q931_CALL_RINGING                   5
#define Q931_CALL_FAILED                    6
#define Q931_CALL_CONNECTION_CLOSED         7

// Goal codes
#define CSG_NONE                            0
#define CSG_JOIN                            1
#define CSG_CREATE                          2
#define CSG_INVITE                          3

#define CC_MAX_PARTY_NUMBER_LEN             254

//====================================================================================
// Q931-specific types
//====================================================================================

typedef HRESULT CS_STATUS;
typedef DWORD HQ931LISTEN, *PHQ931LISTEN;
typedef DWORD HQ931CALL, *PHQ931CALL;


//====================================================================================
// Callback definitions.
//====================================================================================

typedef DWORD (*Q931_CALLBACK) (BYTE bEvent, HQ931CALL hQ931Call,
    HQ931LISTEN hListenToken, DWORD dwUserToken, void *pEventData);

typedef BOOL (*Q931_RECEIVE_PDU_CALLBACK) (Q931MESSAGE *pMessage,
    HQ931CALL hQ931Call, DWORD dwListenToken, DWORD dwUserToken);

//====================================================================================
// definitions of structures passed to callbacks as parameters.
//====================================================================================

// CSS_CALL_INCOMING callback parameter type
typedef struct 
{
    WORD wCallReference;
    WORD wGoal;
    WORD wCallType;
    BOOL bCallerIsMC;
    CC_CONFERENCEID ConferenceID;
    LPWSTR pszCalledPartyNumber;
    PCC_ADDR pSourceAddr;
    PCC_ADDR pCallerAddr;
    PCC_ADDR pCalleeDestAddr;
    PCC_ADDR pLocalAddr;
    PCC_ALIASNAMES pCallerAliasList;
    PCC_ALIASNAMES pCalleeAliasList;
    PCC_ALIASNAMES pExtraAliasList;
    PCC_ALIASITEM pExtensionAliasItem;
    LPWSTR pszDisplay;
    PCC_ENDPOINTTYPE pSourceEndpointType;
    PCC_NONSTANDARDDATA pNonStandardData;
} CSS_CALL_INCOMING, *PCSS_CALL_INCOMING;

// CSS_CALL_REMOTE_HANGUP callback parameter type
typedef struct
{
    BYTE bReason;
} CSS_CALL_REMOTE_HANGUP, *PCSS_CALL_REMOTE_HANGUP;


// CSS_CALL_REJECTED callback parameter type
typedef struct 
{
    BYTE bRejectReason;
    CC_CONFERENCEID ConferenceID;
    PCC_ADDR pAlternateAddr;
    PCC_NONSTANDARDDATA pNonStandardData;
} CSS_CALL_REJECTED, *PCSS_CALL_REJECTED;

// CSS_CALL_ACCEPTED callback parameter type
typedef struct 
{
    WORD wCallReference;
    CC_CONFERENCEID ConferenceID;
    PCC_ADDR pCalleeAddr;
    PCC_ADDR pLocalAddr;
    PCC_ADDR pH245Addr;
    LPWSTR pszDisplay;
    PCC_ENDPOINTTYPE pDestinationEndpointType;
    PCC_NONSTANDARDDATA pNonStandardData;
} CSS_CALL_ACCEPTED, *PCSS_CALL_ACCEPTED;

// Q931_CALL_RINGING callback event will have pEventData set to NULL

// CSS_CALL_FAILED callback paremeter type
typedef struct
{
    HRESULT error;
} CSS_CALL_FAILED, *PCSS_CALL_FAILED;

//====================================================================================
// function declarations.
//====================================================================================

CS_STATUS Q931Init();

CS_STATUS Q931DeInit();

CS_STATUS Q931Listen(
    PHQ931LISTEN phQ931Listen,
    PCC_ADDR pListenAddr,
    DWORD dwListenToken,
    Q931_CALLBACK ListenCallback);

CS_STATUS Q931CancelListen(
    HQ931LISTEN hQ931Listen);

CS_STATUS Q931PlaceCall(
    PHQ931CALL phQ931Call,
    LPWSTR pszDisplay,
    PCC_ALIASNAMES pCallerAliasList,
    PCC_ALIASNAMES pCalleeAliasList,
    PCC_ALIASNAMES pExtraAliasList,
    PCC_ALIASITEM pExtensionAliasItem,
    PCC_NONSTANDARDDATA pNonStandardData,
    PCC_ENDPOINTTYPE pSourceEndpointType,
    LPWSTR pszCalledPartyNumber,
    PCC_ADDR pControlAddr,
    PCC_ADDR pDestinationAddr,
    PCC_ADDR pSourceAddr,
    BOOL bCallerIsMC,
    CC_CONFERENCEID *pConferenceID,
    WORD wGoal,
    WORD wCallType,
    DWORD dwUserToken,
    Q931_CALLBACK ConnectCallback,
    WORD wCRV);

CS_STATUS Q931Hangup(
    HQ931CALL hQ931Call,
    BYTE bReason);

CS_STATUS Q931Ringing(
    HQ931CALL hQ931Call,
    WORD *pwCRV);

CS_STATUS Q931AcceptCall(
    HQ931CALL hQ931Call,
    LPWSTR pszDisplay,
    PCC_NONSTANDARDDATA pNonStandardData,
    PCC_ENDPOINTTYPE pDestinationEndpointType,
    PCC_ADDR pH245Addr,
    DWORD dwUserToken);

CS_STATUS Q931RejectCall(
    HQ931CALL hQ931Call,
    BYTE bRejectReason,
    PCC_CONFERENCEID pConferenceID,
    PCC_ADDR pAlternateAddr,
    PCC_NONSTANDARDDATA pNonStandardData);

CS_STATUS Q931ReOpenConnection(
    HQ931CALL hQ931Call);

CS_STATUS Q931GetVersion(
    WORD wLength,          // character count, not byte count.
    LPWSTR pszVersion);

CS_STATUS Q931SetAlertingTimeout(
    DWORD dwDuration);

void Q931SetReceivePDUHook(
    Q931_RECEIVE_PDU_CALLBACK Q931ReceivePDUCallback);

CS_STATUS Q931SendProceedingMessage(
    HQ931CALL hQ931Call,
    WORD wCallReference,
    PCC_ENDPOINTTYPE pDestinationEndpointType,
    PCC_NONSTANDARDDATA pNonStandardData);

CS_STATUS Q931SendPDU(
    HQ931CALL hQ931Call,
    BYTE* CodedPtrPDU,
    DWORD CodedLengthPDU);

CS_STATUS Q931FlushSendQueue(
    HQ931CALL hQ931Call);

// utility routines
CS_STATUS Q931ValidateAddr(PCC_ADDR pAddr);
CS_STATUS Q931ValidatePartyNumber(LPWSTR pszPartyNumber);

CS_STATUS Q931ValidateAliasItem(PCC_ALIASITEM pSource);
CS_STATUS Q931CopyAliasItem(PCC_ALIASITEM *ppTarget, PCC_ALIASITEM pSource);
CS_STATUS Q931FreeAliasItem(PCC_ALIASITEM pSource);

CS_STATUS Q931ValidateAliasNames(PCC_ALIASNAMES pSource);
CS_STATUS Q931CopyAliasNames(PCC_ALIASNAMES *ppTarget, PCC_ALIASNAMES pSource);
CS_STATUS Q931FreeAliasNames(PCC_ALIASNAMES pSource);

CS_STATUS Q931ValidateDisplay(LPWSTR pszDisplay);
CS_STATUS Q931CopyDisplay(LPWSTR *ppDest, LPWSTR pSource);
CS_STATUS Q931FreeDisplay(LPWSTR pszDisplay);

CS_STATUS Q931ValidateVendorInfo(PCC_VENDORINFO pVendorInfo);
CS_STATUS Q931CopyVendorInfo(PCC_VENDORINFO *ppDest, PCC_VENDORINFO pSource);
CS_STATUS Q931FreeVendorInfo(PCC_VENDORINFO pVendorInfo);

CS_STATUS Q931ValidateNonStandardData(PCC_NONSTANDARDDATA pNonStandardData);
CS_STATUS Q931CopyNonStandardData(PCC_NONSTANDARDDATA *ppDest, PCC_NONSTANDARDDATA pSource);
CS_STATUS Q931FreeNonStandardData(PCC_NONSTANDARDDATA pNonStandardData);

#ifdef __cplusplus
}
#endif

#endif Q931_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\intelcc\include\h245asn1.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/

#ifndef H245ASN1_H
#define H245ASN1_H

#include "h245asn.h"
#include "av_asn1.h"
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif


// LONCHANC: ORIGINAL MAPPING WITH NEW STRUCTURE NAMES

#define VCCapabilityLink                PH222Capability_vcCapability
#define SmltnsCpbltsLink                PCapabilityDescriptor_simultaneousCapabilities
#define CapabilityTableLink             PTerminalCapabilitySet_capabilityTable
#define MultiplexEntryDescriptorLink    PMultiplexEntrySend_multiplexEntryDescriptors
#define CommunicationModeTableLink      PCommunicationModeResponse_communicationModeTable
#define TerminalListResponseLink        PConferenceResponse_terminalListResponse
#define CpbltyTblEntryNmbrsLink         PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers
#define CommunicationModeCommandLink    PCommunicationModeCommand_communicationModeTable
#define CentralizedDataLink             PMediaDistributionCapability_centralizedData
#define DistributedDataLink             PMediaDistributionCapability_distributedData
#define MediaDistributionCapabilityLink PMultipointCapability_mediaDistributionCapability
#define NonStandardDataLink             PConferenceCapability_nonStandardData
#define RouteLink                       PUnicastAddress_iPSourceRouteAddress_route
#define H2250LCPs_nnStndrdLink          PH2250LogicalChannelParameters_nonStandard
#define MultiplexElementLink            PMultiplexElement_type_subElementList
#define RequestedModesLink              PRequestMode_requestedModes
#define H2250LCAPs_nnStndrdLink         PH2250LogicalChannelAckParameters_nonStandard
#define CMTEy_nnStndrdLink              PCommunicationModeTableEntry_nonStandard
#define OBJECTID                        struct ObjectID_
#define POBJECTID                       struct ObjectID_ *
typedef DataApplicationCapability_application_t84       H245_CAP_T84_T;
typedef DataApplicationCapability_application_nlpid     H245_CAP_NLPID_T;
typedef AudioCapability_g7231                           H245_CAP_G723_T;


// LONCHANC: NEW MAPPING FOR FIELDS AND DEFINITIONS

// _choice2 vs H223Capability_h223MultiplexTableCapability
#define h223MltplxTblCpblty_bsc_chosen  H223Capability_h223MultiplexTableCapability_basic_chosen
#define h223MTCy_enhncd_chosen          H223Capability_h223MultiplexTableCapability_enhanced_chosen
#define h223MTCy_enhncd                 enhanced

// V76Capability
#define sspndRsmCpbltywAddrss           suspendResumeCapabilitywoAddress

// DataProtocolCapability
#define DtPrtclCpblty_nnStndrd_chosen   DataProtocolCapability_nonStandard_chosen
#define sgmnttnAndRssmbly_chosen        segmentationAndReassembly_chosen          
#define DtPrtclCpblty_nnStndrd          nonStandard

// _choice3 vs DataApplicationCapability_application
#define DACy_applctn_nnStndrd_chosen    DataApplicationCapability_application_nonStandard_chosen
#define DACy_applctn_t120_chosen        DataApplicationCapability_application_t120_chosen
#define DACy_applctn_dsm_cc_chosen      dsm_cc_chosen
#define DACy_applctn_usrDt_chosen       DataApplicationCapability_application_userData_chosen
#define DACy_applctn_t84_chosen         DataApplicationCapability_application_t84_chosen
#define DACy_applctn_t434_chosen        DataApplicationCapability_application_t434_chosen
#define DACy_applctn_h224_chosen        DataApplicationCapability_application_h224_chosen
#define DACy_applctn_nlpd_chosen        DataApplicationCapability_application_nlpid_chosen
#define DACy_applctn_dsvdCntrl_chosen   DataApplicationCapability_application_dsvdControl_chosen
#define DACy_an_h222DtPrttnng_chosen    DataApplicationCapability_application_h222DataPartitioning_chosen
#define DACy_applctn_nnStndrd           nonStandard
#define DACy_applctn_t120               t120
#define DACy_applctn_dsm_cc             dsm_cc
#define DACy_applctn_usrDt              userData
#define DACy_applctn_t84                t84
#define DACy_applctn_t434               t434
#define DACy_applctn_h224               h224
#define DACy_applctn_nlpd               nlpid
#define DACy_an_h222DtPrttnng           h222DataPartitioning

// H2250Capability
#define rcvAndTrnsmtMltpntCpblty        receiveAndTransmitMultipointCapability

// _choice4 vs H223AnnexACapability_h223AnnexAMultiplexTableCapability
#define h223AAMTCy_bsc_chosen           H223AnnexACapability_h223AnnexAMultiplexTableCapability_basic_chosen
#define h223AAMTCy_enhncd_chosen        H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced_chosen
#define h223AAMTCy_enhncd               enhanced

// MultiplexCapability
#define MltplxCpblty_nonStandard_chosen MultiplexCapability_nonStandard_chosen
#define MltplxCpblty_nonStandard        nonStandard

// H261VideoCapability
#define H261VdCpblty_qcifMPI_present    H261VideoCapability_qcifMPI_present
#define H261VdCpblty_cifMPI_present     H261VideoCapability_cifMPI_present
#define H261VdCpblty_qcifMPI            qcifMPI
#define H261VdCpblty_cifMPI             cifMPI
#define tmprlSptlTrdOffCpblty           temporalSpatialTradeOffCapability

// H262VideoCapability
#define H262VdCpblty_vdBtRt_present     H262VideoCapability_videoBitRate_present
#define H262VdCpblty_vbvBffrSz_present  H262VideoCapability_vbvBufferSize_present
#define H262VdCpblty_smplsPrLn_present  H262VideoCapability_samplesPerLine_present
#define H262VdCpblty_lnsPrFrm_present   H262VideoCapability_linesPerFrame_present
#define H262VdCpblty_frmsPrScnd_present H262VideoCapability_framesPerSecond_present
#define H262VCy_lmnncSmplRt_present     H262VideoCapability_luminanceSampleRate_present
#define H262VdCpblty_vdBtRt             videoBitRate
#define H262VdCpblty_vbvBffrSz          vbvBufferSize
#define H262VdCpblty_smplsPrLn          samplesPerLine
#define H262VdCpblty_lnsPrFrm           linesPerFrame
#define H262VdCpblty_frmsPrScnd         framesPerSecond
#define H262VCy_lmnncSmplRt             luminanceSampleRate

// H263VideoCapability
#define H263VdCpblty_qcifMPI_present    H263VideoCapability_qcifMPI_present
#define H263VdCpblty_cifMPI_present     H263VideoCapability_cifMPI_present
#define H263VCy_errrCmpnstn_present     H263VideoCapability_errorCompensation_present
#define H263VdCpblty_qcifMPI            qcifMPI
#define H263VdCpblty_cifMPI             cifMPI
#define tmprlSptlTrdOffCpblty           temporalSpatialTradeOffCapability
#define H263VCy_errrCmpnstn             errorCompensation

// IS11172VideoCapability
#define IS11172VdCpblty_vdBtRt_present  IS11172VideoCapability_videoBitRate_present
#define IS11172VCy_vbvBffrSz_present    IS11172VideoCapability_vbvBufferSize_present
#define IS11172VCy_smplsPrLn_present    IS11172VideoCapability_samplesPerLine_present
#define IS11172VCy_lnsPrFrm_present     IS11172VideoCapability_linesPerFrame_present
#define IS11172VdCpblty_pctrRt_present  IS11172VideoCapability_pictureRate_present
#define IS11172VCy_lmnncSmplRt_present  IS11172VideoCapability_luminanceSampleRate_present
#define IS11172VdCpblty_vdBtRt          videoBitRate
#define IS11172VCy_vbvBffrSz            vbvBufferSize
#define IS11172VCy_smplsPrLn            samplesPerLine
#define IS11172VCy_lnsPrFrm             linesPerFrame
#define IS11172VdCpblty_pctrRt          pictureRate
#define IS11172VCy_lmnncSmplRt          luminanceSampleRate

// VideoCapability
#define VdCpblty_nonStandard_chosen     VideoCapability_nonStandard_chosen
#define VdCpblty_nonStandard            nonStandard

// AudioCapability
#define AdCpblty_nonStandard_chosen     AudioCapability_nonStandard_chosen
#define AdCpblty_g711Alaw64k_chosen     AudioCapability_g711Alaw64k_chosen
#define AdCpblty_g711Alaw56k_chosen     AudioCapability_g711Alaw56k_chosen
#define AdCpblty_g711Ulaw64k_chosen     AudioCapability_g711Ulaw64k_chosen
#define AdCpblty_g711Ulaw56k_chosen     AudioCapability_g711Ulaw56k_chosen
#define AudioCapability_g722_64k_chosen g722_64k_chosen
#define AudioCapability_g722_56k_chosen g722_56k_chosen
#define AudioCapability_g722_48k_chosen g722_48k_chosen
#define AdCpblty_g729AnnexA_chosen      AudioCapability_g729AnnexA_chosen
#define ACy_g729AASSn_chosen            AudioCapability_g729AnnexAwSilenceSuppression_chosen
#define AdCpblty_nonStandard            nonStandard
#define AdCpblty_g711Alaw64k            g711Alaw64k
#define AdCpblty_g711Alaw56k            g711Alaw56k
#define AdCpblty_g711Ulaw64k            g711Ulaw64k
#define AdCpblty_g711Ulaw56k            g711Ulaw56k
#define AudioCapability_g722_64k        g722_64k
#define AudioCapability_g722_56k        g722_56k
#define AudioCapability_g722_48k        g722_48k
#define AudioCapability_g7231           g7231
#define AudioCapability_g728            g728
#define AudioCapability_g729            g729
#define AdCpblty_g729AnnexA             g729AnnexA
#define ACy_g729AASSn                   g729AnnexAwSilenceSuppression

// Capability
#define rcvAndTrnsmtVdCpblty_chosen     receiveAndTransmitVideoCapability_chosen
#define rcvAndTrnsmtAdCpblty_chosen     receiveAndTransmitAudioCapability_chosen
#define rcvDtApplctnCpblty_chosen       receiveDataApplicationCapability_chosen
#define trnsmtDtApplctnCpblty_chosen    transmitDataApplicationCapability_chosen
#define rATDACy_chosen                  receiveAndTransmitDataApplicationCapability_chosen
#define h233EncryptnTrnsmtCpblty_chosen h233EncryptionTransmitCapability_chosen
#define h233EncryptnRcvCpblty_chosen    h233EncryptionReceiveCapability_chosen
#define Capability_nonStandard          nonStandard
#define rcvAndTrnsmtVdCpblty            receiveAndTransmitVideoCapability
#define rcvAndTrnsmtAdCpblty            receiveAndTransmitAudioCapability
#define rcvDtApplctnCpblty              receiveDataApplicationCapability
#define trnsmtDtApplctnCpblty           transmitDataApplicationCapability
#define rATDACy                         receiveAndTransmitDataApplicationCapability
#define h233EncryptnTrnsmtCpblty        h233EncryptionTransmitCapability
#define h233EncryptnRcvCpblty           h233EncryptionReceiveCapability

// CapabilityDescriptor
#define smltnsCpblts_present            simultaneousCapabilities_present
#define smltnsCpblts                    simultaneousCapabilities

// EncryptionMode
#define EncryptnMd_nonStandard_chosen   EncryptionMode_nonStandard_chosen
#define EncryptnMd_nonStandard          nonStandard

// DataType
#define DataType_nonStandard            nonStandard
#define DataType_videoData              videoData
#define DataType_audioData              audioData
#define DataType_data                   data

// _choice5 vs H223LogicalChannelParameters_adaptationLayerType
#define H223LCPs_aLTp_nnStndrd_chosen   H223LogicalChannelParameters_adaptationLayerType_nonStandard_chosen
#define H223LCPs_aLTp_al1Frmd_chosen    H223LogicalChannelParameters_adaptationLayerType_al1Framed_chosen
#define H223LCPs_aLTp_al1NtFrmd_chosen  H223LogicalChannelParameters_adaptationLayerType_al1NotFramed_chosen
#define H223LCPs_aLTp_a2WSNs_1_chosen   H223LogicalChannelParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen
#define H223LCPs_aLTp_a2WSNs_2_chosen   H223LogicalChannelParameters_adaptationLayerType_al2WithSequenceNumbers_chosen
#define H223LCPs_aLTp_al3_chosen        H223LogicalChannelParameters_adaptationLayerType_al3_chosen
#define H223LCPs_aLTp_nnStndrd          nonStandard
#define H223LCPs_aLTp_al3               al3

// UnicastAddress
#define UncstAddrss_iP6Address_chosen   UnicastAddress_iP6Address_chosen
#define UAs_nnStndrdAddrss_chosen       UnicastAddress_nonStandardAddress_chosen
#define UnicastAddress_iPAddress        iPAddress
#define UncstAddrss_iP6Address          iP6Address
#define UnicastAddress_nsap             nsap
#define UAs_nnStndrdAddrss              nonStandardAddress

// MulticastAddress
#define MltcstAddrss_iPAddress_chosen   MulticastAddress_iPAddress_chosen
#define MltcstAddrss_iP6Address_chosen  MulticastAddress_iP6Address_chosen
#define MAs_nnStndrdAddrss_chosen       MulticastAddress_nonStandardAddress_chosen
#define MltcstAddrss_iPAddress          iPAddress
#define MltcstAddrss_iP6Address         iP6Address
#define MulticastAddress_nsap           nsap
#define MAs_nnStndrdAddrss              nonStandardAddress

// H2250LogicalChannelParameters
#define H2250LCPs_nnStndrd_present      H2250LogicalChannelParameters_nonStandard_present
#define H2250LCPs_assctdSssnID_present  H2250LogicalChannelParameters_associatedSessionID_present
#define H2250LCPs_mdChnnl_present       H2250LogicalChannelParameters_mediaChannel_present
#define H2250LCPs_mdGrntdDlvry_present  H2250LogicalChannelParameters_mediaGuaranteedDelivery_present
#define H2250LCPs_mdCntrlChnnl_present  H2250LogicalChannelParameters_mediaControlChannel_present
#define H2250LCPs_mCGDy_present         H2250LogicalChannelParameters_mediaControlGuaranteedDelivery_present
#define H2250LCPs_dRTPPTp_present       H2250LogicalChannelParameters_dynamicRTPPayloadType_present
#define H2250LCPs_nnStndrd              nonStandard
#define H2250LCPs_assctdSssnID          associatedSessionID
#define H2250LCPs_mdChnnl               mediaChannel
#define H2250LCPs_mdGrntdDlvry          mediaGuaranteedDelivery
#define H2250LCPs_mdCntrlChnnl          mediaControlChannel
#define H2250LCPs_mCGDy                 mediaControlGuaranteedDelivery
#define H2250LCPs_dRTPPTp               dynamicRTPPayloadType

// _choice20 vs OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters
#define fLCPs_mPs_h222LCPs_chosen       OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen
#define fLCPs_mPs_h223LCPs_chosen       OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen
#define fLCPs_mPs_v76LCPs_chosen        OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen
#define fLCPs_mPs_h2250LCPs_chosen      OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen
#define fLCPs_mPs_h223AALCPs_chosen     OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h223AnnexALogicalChannelParameters_chosen
#define fLCPs_mPs_h222LCPs              h222LogicalChannelParameters
#define fLCPs_mPs_h223LCPs              h223LogicalChannelParameters
#define fLCPs_mPs_v76LCPs               v76LogicalChannelParameters
#define fLCPs_mPs_h2250LCPs             h2250LogicalChannelParameters
#define fLCPs_mPs_h223AALCPs            h223AnnexALogicalChannelParameters

// _choice21 vs OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters
#define rLCPs_mPs_h223LCPs_chosen       OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen
#define rLCPs_mPs_v76LCPs_chosen        OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen
#define rLCPs_mPs_h2250LCPs_chosen      OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen
#define rLCPs_mPs_h223AALCPs_chosen     OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h223AnnexALogicalChannelParameters_chosen
#define rLCPs_mPs_h223LCPs              h223LogicalChannelParameters
#define rLCPs_mPs_v76LCPs               v76LogicalChannelParameters
#define rLCPs_mPs_h2250LCPs             h2250LogicalChannelParameters
#define rLCPs_mPs_h223AALCPs            h223AnnexALogicalChannelParameters

// OpenLogicalChannel
#define OLCl_rLCPs_present              OpenLogicalChannel_reverseLogicalChannelParameters_present
#define OpnLgclChnnl_sprtStck_present   OpenLogicalChannel_separateStack_present
#define fLCPs_prtNmbr_present           OpenLogicalChannel_forwardLogicalChannelParameters_portNumber_present
#define fLCPs_prtNmbr                   portNumber
#define OLCl_rLCPs_mltplxPrmtrs_present OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_present
#define OLCl_rLCPs_mltplxPrmtrs         multiplexParameters
#define OLCl_rLCPs                      reverseLogicalChannelParameters
#define OpnLgclChnnl_sprtStck           separateStack

// _choice23 vs MultiplexElement_type
#define typ_logicalChannelNumber_chosen MultiplexElement_type_logicalChannelNumber_chosen
#define typ_logicalChannelNumber        logicalChannelNumber

// _choice24 vs MultiplexElement_repeatCount
#define repeatCount_finite_chosen       MultiplexElement_repeatCount_finite_chosen
#define repeatCount_finite              finite

// _choice25 vs H261VideoMode_resolution
#define H261VdMd_resolution_qcif_chosen H261VideoMode_resolution_qcif_chosen
#define H261VdMd_resolution_cif_chosen  H261VideoMode_resolution_cif_chosen

// _choice26 vs H262VideoMode_profileAndLevel
#define prflAndLvl_SpatialatH_14_chosen profileAndLevel_SpatialatH_14_chosen

// H262VideoMode
#define H262VdMd_videoBitRate_present   H262VideoMode_videoBitRate_present
#define H262VdMd_vbvBufferSize_present  H262VideoMode_vbvBufferSize_present
#define H262VdMd_samplesPerLine_present H262VideoMode_samplesPerLine_present
#define H262VdMd_linesPerFrame_present  H262VideoMode_linesPerFrame_present
#define H262VdMd_frmsPrScnd_present     H262VideoMode_framesPerSecond_present
#define H262VdMd_lmnncSmplRt_present    H262VideoMode_luminanceSampleRate_present
#define H262VdMd_videoBitRate           videoBitRate
#define H262VdMd_vbvBufferSize          vbvBufferSize
#define H262VdMd_samplesPerLine         samplesPerLine
#define H262VdMd_linesPerFrame          linesPerFrame
#define H262VdMd_frmsPrScnd             framesPerSecond
#define H262VdMd_lmnncSmplRt            luminanceSampleRate

// _choice27 vs H263VideoMode_resolution
#define H263VdMd_resolution_qcif_chosen H263VideoMode_resolution_qcif_chosen
#define H263VdMd_resolution_cif_chosen  H263VideoMode_resolution_cif_chosen

// H263VideoMode
#define H263VdMd_errrCmpnstn_present    H263VideoMode_errorCompensation_present
#define H263VdMd_errrCmpnstn            errorCompensation

// IS11172VideoMode
#define IS11172VdMd_vdBtRt_present      IS11172VideoMode_videoBitRate_present
#define IS11172VdMd_vbvBffrSz_present   IS11172VideoMode_vbvBufferSize_present
#define IS11172VdMd_smplsPrLn_present   IS11172VideoMode_samplesPerLine_present
#define IS11172VdMd_lnsPrFrm_present    IS11172VideoMode_linesPerFrame_present
#define IS11172VdMd_pictureRate_present IS11172VideoMode_pictureRate_present
#define IS11172VdMd_lmnncSmplRt_present IS11172VideoMode_luminanceSampleRate_present
#define IS11172VdMd_vdBtRt              videoBitRate
#define IS11172VdMd_vbvBffrSz           vbvBufferSize
#define IS11172VdMd_smplsPrLn           samplesPerLine
#define IS11172VdMd_lnsPrFrm            linesPerFrame
#define IS11172VdMd_pictureRate         pictureRate
#define IS11172VdMd_lmnncSmplRt         luminanceSampleRate

// VideoMode
#define VideoMode_nonStandard           nonStandard

// _choice28 vs IS11172AudioMode_audioLayer
#define audioLayer1_chosen      IS11172AudioMode_audioLayer_audioLayer1_chosen
#define audioLayer2_chosen      IS11172AudioMode_audioLayer_audioLayer2_chosen
#define audioLayer3_chosen      IS11172AudioMode_audioLayer_audioLayer3_chosen

// _choice29 vs IS11172AudioMode_audioSampling
#define IS11172AMd_aSg_aS32k_chosen     IS11172AudioMode_audioSampling_audioSampling32k_chosen
#define IS11172AMd_aSg_aS441_chosen     IS11172AudioMode_audioSampling_audioSampling44k1_chosen
#define IS11172AMd_aSg_aS48k_chosen     IS11172AudioMode_audioSampling_audioSampling48k_chosen

// _choice30 vs IS11172AudioMode_multichannelType
#define IS11172AMd_mTp_snglChnnl_chosen IS11172AudioMode_multichannelType_singleChannel_chosen
#define IS11172AMd_mTp_tCSr_chosen      IS11172AudioMode_multichannelType_twoChannelStereo_chosen
#define IS11172AMd_mTp_twChnnlDl_chosen IS11172AudioMode_multichannelType_twoChannelDual_chosen

// _choice32 vs IS13818AudioMode_audioSampling
#define IS13818AMd_aSg_aS32k_chosen     IS13818AudioMode_audioSampling_audioSampling32k_chosen
#define IS13818AMd_aSg_aS441_chosen     IS13818AudioMode_audioSampling_audioSampling44k1_chosen
#define IS13818AMd_aSg_aS48k_chosen     IS13818AudioMode_audioSampling_audioSampling48k_chosen

// _choice33 vs IS13818AudioMode_multichannelType
#define IS13818AMd_mTp_snglChnnl_chosen IS13818AudioMode_multichannelType_singleChannel_chosen
#define IS13818AMd_mTp_tCSr_chosen      IS13818AudioMode_multichannelType_twoChannelStereo_chosen
#define IS13818AMd_mTp_twChnnlDl_chosen IS13818AudioMode_multichannelType_twoChannelDual_chosen

// _choice34 vs AudioMode_g7231
#define nSlncSpprssnLwRt_chosen         noSilenceSuppressionLowRate_chosen
#define nSlncSpprssnHghRt_chosen        noSilenceSuppressionHighRate_chosen
#define slncSpprssnLwRt_chosen          silenceSuppressionLowRate_chosen
#define slncSpprssnHghRt_chosen         silenceSuppressionHighRate_chosen

// AudioMode
#define AMd_g729AASSn_chosen            AudioMode_g729AnnexAwSilenceSuppression_chosen
#define AudioMode_nonStandard           nonStandard
#define AudioMode_g7231                 g7231

// _choice35 vs DataMode_application
#define DtMd_applctn_nonStandard_chosen DataMode_application_nonStandard_chosen
#define DtMd_application_t120_chosen    DataMode_application_t120_chosen
#define DtMd_application_dsm_cc_chosen  dsm_cc_chosen
#define DtMd_applctn_userData_chosen    DataMode_application_userData_chosen
#define DtMd_application_t434_chosen    DataMode_application_t434_chosen
#define DtMd_application_h224_chosen    DataMode_application_h224_chosen
#define DtMd_application_nlpid_chosen   DataMode_application_nlpid_chosen
#define DtMd_applctn_dsvdControl_chosen DataMode_application_dsvdControl_chosen
#define DMd_an_h222DtPrttnng_chosen     DataMode_application_h222DataPartitioning_chosen
#define DtMd_applctn_nonStandard        nonStandard
#define DtMd_application_t120           t120
#define DtMd_application_dsm_cc         dsm_cc
#define DtMd_applctn_userData           userData
#define DataMode_application_t84        t84
#define DtMd_application_t434           t434
#define DtMd_application_h224           h224
#define DtMd_application_nlpid          nlpid
#define DMd_an_h222DtPrttnng            h222DataPartitioning

// _choice36 vs H223ModeParameters_adaptationLayerType
#define H223MPs_aLTp_nnStndrd_chosen    H223ModeParameters_adaptationLayerType_nonStandard_chosen
#define H223MPs_aLTp_al1Frmd_chosen     H223ModeParameters_adaptationLayerType_al1Framed_chosen
#define H223MPs_aLTp_al1NtFrmd_chosen   H223ModeParameters_adaptationLayerType_al1NotFramed_chosen
#define H223MPs_aLTp_a2WSNs_1_chosen    H223ModeParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen
#define H223MPs_aLTp_a2WSNs_2_chosen    H223ModeParameters_adaptationLayerType_al2WithSequenceNumbers_chosen
#define H223MPs_adpttnLyrTyp_al3_chosen H223ModeParameters_adaptationLayerType_al3_chosen
#define H223MPs_aLTp_nnStndrd           nonStandard
#define H223MPs_adpttnLyrTyp_al3        al3

// ModeElement
#define h223AnnxAMdPrmtrs_present       h223AnnexAModeParameters_present
#define h223AnnxAMdPrmtrs               h223AnnexAModeParameters

// _choice38 vs MaintenanceLoopRequest_type
#define systemLoop_chosen               MaintenanceLoopRequest_type_systemLoop_chosen // MaintenanceLoopReject_type_systemLoop_chosen
#define mediaLoop_chosen                MaintenanceLoopRequest_type_mediaLoop_chosen // MaintenanceLoopReject_type_mediaLoop_chosen
#define logicalChannelLoop_chosen       MaintenanceLoopRequest_type_logicalChannelLoop_chosen // MaintenanceLoopReject_type_logicalChannelLoop_chosen

// RequestMessage
#define RqstMssg_nonStandard_chosen     RequestMessage_nonStandard_chosen
#define h223AnnxARcnfgrtn_chosen        h223AnnexAReconfiguration_chosen
#define RqstMssg_nonStandard            nonStandard
#define h223AnnxARcnfgrtn               h223AnnexAReconfiguration

// _choice45 vs TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded
#define hghstEntryNmbrPrcssd_chosen     highestEntryNumberProcessed_chosen
#define hghstEntryNmbrPrcssd            highestEntryNumberProcessed

// _choice46 vs TerminalCapabilitySetReject_cause
#define TCSRt_cs_unspcfd_chosen         TerminalCapabilitySetReject_cause_unspecified_chosen
#define dscrptrCpctyExcdd_chosen        descriptorCapacityExceeded_chosen
#define tblEntryCpctyExcdd_chosen       tableEntryCapacityExceeded_chosen
#define tblEntryCpctyExcdd              tableEntryCapacityExceeded

// H2250LgclChnnlAckPrmtrs vs H2250LogicalChannelAckParameters
#define H2250LgclChnnlAckPrmtrs         H2250LogicalChannelAckParameters
#define H2250LCAPs_nnStndrd_present     H2250LogicalChannelAckParameters_nonStandard_present
#define H2250LCAPs_mdChnnl_present      H2250LogicalChannelAckParameters_mediaChannel_present
#define H2250LCAPs_mdCntrlChnnl_present H2250LogicalChannelAckParameters_mediaControlChannel_present
#define H2250LCAPs_dRTPPTp_present      H2250LogicalChannelAckParameters_dynamicRTPPayloadType_present
#define H2250LCAPs_nnStndrd             nonStandard
#define H2250LCAPs_mdChnnl              mediaChannel
#define H2250LCAPs_mdCntrlChnnl         mediaControlChannel
#define H2250LCAPs_dRTPPTp              dynamicRTPPayloadType

// _choice47 vs OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters
#define rLCPs_mPs_h222LCPs_chosen       OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen
#define mPs_h2250LgclChnnlPrmtrs_chosen OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen
#define rLCPs_mPs_h222LCPs              h222LogicalChannelParameters
#define mPs_h2250LgclChnnlPrmtrs        h2250LogicalChannelParameters

// _choice48 vs OpenLogicalChannelAck_forwardMultiplexAckParameters
#define h2250LgclChnnlAckPrmtrs_chosen  h2250LogicalChannelAckParameters_chosen
#define h2250LgclChnnlAckPrmtrs         h2250LogicalChannelAckParameters

// OpenLogicalChannelAck
#define OLCAk_rLCPs_present             OpenLogicalChannelAck_reverseLogicalChannelParameters_present
#define OLCAk_sprtStck_present          OpenLogicalChannelAck_separateStack_present
#define frwrdMltplxAckPrmtrs_present    forwardMultiplexAckParameters_present
#define rLCPs_prtNmbr_present           OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber_present
#define OLCAk_rLCPs_mPs_present         OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_present
#define rLCPs_prtNmbr                   portNumber
#define OLCAk_rLCPs_mPs                 multiplexParameters
#define OLCAk_rLCPs                     reverseLogicalChannelParameters
#define OLCAk_sprtStck                  separateStack
#define frwrdMltplxAckPrmtrs            forwardMultiplexAckParameters

// _choice49 vs OpenLogicalChannelReject_cause
#define OLCRt_cs_unspcfd_chosen         OpenLogicalChannelReject_cause_unspecified_chosen
#define unstblRvrsPrmtrs_chosen         unsuitableReverseParameters_chosen
#define dtTypALCmbntnNtSpprtd_chosen    dataTypeALCombinationNotSupported_chosen
#define mltcstChnnlNtAllwd_chosen       multicastChannelNotAllowed_chosen
#define sprtStckEstblshmntFld_chosen    separateStackEstablishmentFailed_chosen

// _choice51 vs MultiplexEntryRejectionDescriptions_cause
#define MERDs_cs_unspcfdCs_chosen       MultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen

// MltplxEntryRjctnDscrptns vs MultiplexEntryRejectionDescriptions
#define MltplxEntryRjctnDscrptns        MultiplexEntryRejectionDescriptions

// _choice52 vs RequestMultiplexEntryRejectionDescriptions_cause
#define RMERDs_cs_unspcfdCs_chosen      RequestMultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen

// RqstMltplxEntryRjctnDscrptns vs RequestMultiplexEntryRejectionDescriptions
#define RqstMltplxEntryRjctnDscrptns    RequestMultiplexEntryRejectionDescriptions

// _choice53 vs RequestModeAck_response
#define wllTrnsmtMstPrfrrdMd_chosen     willTransmitMostPreferredMode_chosen
#define wllTrnsmtLssPrfrrdMd_chosen     willTransmitLessPreferredMode_chosen

// _choice57 vs CommunicationModeTableEntry_dataType
#define dataType_videoData_chosen       CommunicationModeTableEntry_dataType_videoData_chosen
#define dataType_audioData_chosen       CommunicationModeTableEntry_dataType_audioData_chosen
#define dataType_data_chosen            CommunicationModeTableEntry_dataType_data_chosen
#define dataType_videoData              videoData
#define dataType_audioData              audioData
#define dataType_data                   data

// CommunicationModeTableEntry
#define CMTEy_nnStndrd_present          CommunicationModeTableEntry_nonStandard_present
#define CMTEy_assctdSssnID_present      CommunicationModeTableEntry_associatedSessionID_present
#define CMTEy_mdChnnl_present           CommunicationModeTableEntry_mediaChannel_present
#define CMTEy_mdGrntdDlvry_present      CommunicationModeTableEntry_mediaGuaranteedDelivery_present
#define CMTEy_mdCntrlChnnl_present      CommunicationModeTableEntry_mediaControlChannel_present
#define CMTEy_mdCntrlGrntdDlvry_present CommunicationModeTableEntry_mediaControlGuaranteedDelivery_present
#define CMTEy_nnStndrd                  nonStandard
#define CMTEy_assctdSssnID              associatedSessionID
#define CMTEy_mdChnnl                   mediaChannel
#define CMTEy_mdGrntdDlvry              mediaGuaranteedDelivery
#define CMTEy_mdCntrlChnnl              mediaControlChannel
#define CMTEy_mdCntrlGrntdDlvry         mediaControlGuaranteedDelivery

// ResponseMessage
#define RspnsMssg_nonStandard_chosen    ResponseMessage_nonStandard_chosen
#define mstrSlvDtrmntnAck_chosen        masterSlaveDeterminationAck_chosen
#define mstrSlvDtrmntnRjct_chosen       masterSlaveDeterminationReject_chosen
#define trmnlCpbltyStRjct_chosen        terminalCapabilitySetReject_chosen
#define rqstChnnlClsRjct_chosen         requestChannelCloseReject_chosen
#define rqstMltplxEntryRjct_chosen      requestMultiplexEntryReject_chosen
#define cmmnctnMdRspns_chosen           communicationModeResponse_chosen
#define h223AnnxARcnfgrtnAck_chosen     h223AnnexAReconfigurationAck_chosen
#define h223AnnxARcnfgrtnRjct_chosen    h223AnnexAReconfigurationReject_chosen
#define RspnsMssg_nonStandard           nonStandard
#define mstrSlvDtrmntnAck               masterSlaveDeterminationAck
#define mstrSlvDtrmntnRjct              masterSlaveDeterminationReject
#define trmnlCpbltyStRjct               terminalCapabilitySetReject
#define rqstChnnlClsRjct                requestChannelCloseReject
#define rqstMltplxEntryRjct             requestMultiplexEntryReject
#define cmmnctnMdRspns                  communicationModeResponse
#define h223AnnxARcnfgrtnAck            h223AnnexAReconfigurationAck
#define h223AnnxARcnfgrtnRjct           h223AnnexAReconfigurationReject

// SendTerminalCapabilitySet
#define cpbltyTblEntryNmbrs_present     capabilityTableEntryNumbers_present
#define cpbltyDscrptrNmbrs_present      capabilityDescriptorNumbers_present
#define cpbltyTblEntryNmbrs             capabilityTableEntryNumbers
#define cpbltyDscrptrNmbrs              capabilityDescriptorNumbers

// _choice59 vs FlowControlCommand_scope
#define FCCd_scp_lgclChnnlNmbr_chosen   FlowControlCommand_scope_logicalChannelNumber_chosen
#define FlwCntrlCmmnd_scp_rsrcID_chosen FlowControlCommand_scope_resourceID_chosen
#define FCCd_scp_whlMltplx_chosen       FlowControlCommand_scope_wholeMultiplex_chosen
#define FCCd_scp_lgclChnnlNmbr          logicalChannelNumber
#define FlwCntrlCmmnd_scp_rsrcID        resourceID

// EndSessionCommand
#define EndSssnCmmnd_nonStandard_chosen EndSessionCommand_nonStandard_chosen
#define EndSssnCmmnd_nonStandard        nonStandard

// _choice62 vs MiscellaneousCommand_type
#define cnclMltpntMdCmmnd_chosen        cancelMultipointModeCommand_chosen
#define MCd_tp_vdTmprlSptlTrdOff_chosen MiscellaneousCommand_type_videoTemporalSpatialTradeOff_chosen
#define vdSndSyncEvryGOBCncl_chosen     videoSendSyncEveryGOBCancel_chosen
#define MCd_tp_vdTmprlSptlTrdOff        videoTemporalSpatialTradeOff

// ConferenceCommand
#define brdcstMyLgclChnnl_chosen        broadcastMyLogicalChannel_chosen
#define cnclBrdcstMyLgclChnnl_chosen    cancelBroadcastMyLogicalChannel_chosen
#define cnclMkTrmnlBrdcstr_chosen       cancelMakeTerminalBroadcaster_chosen
#define brdcstMyLgclChnnl               broadcastMyLogicalChannel
#define cnclBrdcstMyLgclChnnl           cancelBroadcastMyLogicalChannel
             
// CommandMessage
#define CmmndMssg_nonStandard_chosen    CommandMessage_nonStandard_chosen
#define mntnncLpOffCmmnd_chosen         maintenanceLoopOffCommand_chosen
#define sndTrmnlCpbltySt_chosen         sendTerminalCapabilitySet_chosen
#define CmmndMssg_nonStandard           nonStandard
#define mntnncLpOffCmmnd                maintenanceLoopOffCommand
#define sndTrmnlCpbltySt                sendTerminalCapabilitySet

// FunctionNotUnderstood
#define FnctnNtUndrstd_request_chosen   FunctionNotUnderstood_request_chosen
#define FnctnNtUndrstd_response_chosen  FunctionNotUnderstood_response_chosen
#define FnctnNtUndrstd_command_chosen   FunctionNotUnderstood_command_chosen
#define FnctnNtUndrstd_request          request
#define FnctnNtUndrstd_response         response
#define FnctnNtUndrstd_command          command

// _choice63 vs MiscellaneousIndication_type
#define cnclMltpntCnfrnc_chosen         cancelMultipointConference_chosen
#define mltpntScndryStts_chosen         multipointSecondaryStatus_chosen
#define cnclMltpntScndryStts_chosen     cancelMultipointSecondaryStatus_chosen
#define vdIndctRdyTActvt_chosen         videoIndicateReadyToActivate_chosen
#define MIn_tp_vdTmprlSptlTrdOff_chosen MiscellaneousIndication_type_videoTemporalSpatialTradeOff_chosen
#define MIn_tp_vdTmprlSptlTrdOff        videoTemporalSpatialTradeOff

// _choice64 vs JitterIndication_scope
#define JIn_scp_lgclChnnlNmbr_chosen    JitterIndication_scope_logicalChannelNumber_chosen
#define JttrIndctn_scp_rsrcID_chosen    JitterIndication_scope_resourceID_chosen
#define JttrIndctn_scp_whlMltplx_chosen JitterIndication_scope_wholeMultiplex_chosen
#define JIn_scp_lgclChnnlNmbr           logicalChannelNumber
#define JttrIndctn_scp_rsrcID           resourceID

// UserInputIndication
#define UsrInptIndctn_nnStndrd_chosen   UserInputIndication_nonStandard_chosen
#define UsrInptIndctn_nnStndrd          nonStandard

// ConferenceIndication
#define cnclSnByAtLstOnOthr_chosen      cancelSeenByAtLeastOneOther_chosen

// IndicationMessage
#define IndctnMssg_nonStandard_chosen   IndicationMessage_nonStandard_chosen
#define mstrSlvDtrmntnRls_chosen        masterSlaveDeterminationRelease_chosen
#define trmnlCpbltyStRls_chosen         terminalCapabilitySetRelease_chosen
#define opnLgclChnnlCnfrm_chosen        openLogicalChannelConfirm_chosen
#define rqstChnnlClsRls_chosen          requestChannelCloseRelease_chosen
#define mltplxEntrySndRls_chosen        multiplexEntrySendRelease_chosen
#define rqstMltplxEntryRls_chosen       requestMultiplexEntryRelease_chosen
#define h2250MxmmSkwIndctn_chosen       h2250MaximumSkewIndication_chosen
#define IndctnMssg_nonStandard          nonStandard
#define mstrSlvDtrmntnRls               masterSlaveDeterminationRelease
#define trmnlCpbltyStRls                terminalCapabilitySetRelease
#define opnLgclChnnlCnfrm               openLogicalChannelConfirm
#define rqstChnnlClsRls                 requestChannelCloseRelease
#define mltplxEntrySndRls               multiplexEntrySendRelease
#define rqstMltplxEntryRls              requestMultiplexEntryRelease
#define h2250MxmmSkwIndctn              h2250MaximumSkewIndication

// MltmdSystmCntrlMssg vs MultimediaSystemControlMessage
#define MltmdSystmCntrlMssg             MultimediaSystemControlMessage
#define MltmdSystmCntrlMssg_PDU         MultimediaSystemControlMessage_PDU
#define MltmdSystmCntrlMssg_rqst_chosen MultimediaSystemControlMessage_request_chosen
#define MSCMg_rspns_chosen              MultimediaSystemControlMessage_response_chosen
#define MSCMg_cmmnd_chosen              MultimediaSystemControlMessage_command_chosen
#define MltmdSystmCntrlMssg_rqst        request
#define MSCMg_rspns                     response
#define MSCMg_cmmnd                     command


#ifdef __cplusplus
}
#endif

#endif // H245ASN1_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\intelcc\include\interop.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/

#ifndef __INTEROP_H
#define __INTEROP_H

#include <windows.h>

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))

#define INTEROP_EXPORT  __declspec(dllexport)

#define DLLName "CPLS.DLL"


typedef int    (WINAPI *CPLInitialize_t)(const char*);
typedef int    (WINAPI *CPLUninitialize_t)(int) ;
typedef int    (WINAPI *CPLOpen_t)(int, 
							const char*, 
							int);
typedef int    (WINAPI *CPLClose_t)( int );
typedef int    (WINAPI *CPLOutput_t)(int, 
							BYTE*, 
							int,
							unsigned long);



typedef struct {
    CPLInitialize_t       CPLInitialize;
	CPLUninitialize_t     CPLUninitialize;
    CPLOpen_t			  CPLOpen;
    CPLClose_t			  CPLClose;
    CPLOutput_t			  CPLOutput;
	int					  g_ComplianceProtocolLogger;
	int					  g_ProtocolLogID;
	HINSTANCE hInst;
} *LPInteropLogger, InteropLogger;

#ifdef __cplusplus
extern "C" {
#endif

LPInteropLogger INTEROP_EXPORT InteropLoad(const char*  Protocol);
void INTEROP_EXPORT InteropUnload(LPInteropLogger Logger);
void INTEROP_EXPORT InteropOutput(LPInteropLogger Logger, BYTE* buf, int length, unsigned long userData);

#ifdef __cplusplus
}
#endif

#else   // ! (defined(_DEBUG) || defined(PCS_COMPLIANCE))
#define InteropLoad()
#define InteropUnload()
#define InteropOutput()

#endif  // (defined(_DEBUG) || defined(PCS_COMPLIANCE))

#endif  // __CPLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\intelcc\include\incommon.h ===
/****************************************************************************
 *
 *      $Archive:   S:/STURGEON/SRC/INCLUDE/VCS/incommon.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *      Copyright (c) 1996 Intel Corporation.
 *
 *      $Revision:   1.41  $
 *      $Date:   12 Feb 1997 09:34:42  $
 *      $Author:   MANDREWS  $
 *
 *      Deliverable:    INCOMMON.H
 *
 *      Abstract:        commonly used structures
 *              
 *
 *      Notes:
 *
 ***************************************************************************/
#ifndef INCOMMON_H
#define INCOMMON_H

#pragma pack(push,8)

#define CC_INVALID_HANDLE                    0

// CCRC_CALL_REJECTED reason codes (includes cause values)
#define CC_REJECT_NO_BANDWIDTH              1
#define CC_REJECT_GATEKEEPER_RESOURCES      2
#define CC_REJECT_UNREACHABLE_DESTINATION   3
#define CC_REJECT_DESTINATION_REJECTION     4
#define CC_REJECT_INVALID_REVISION          5
#define CC_REJECT_NO_PERMISSION             6
#define CC_REJECT_UNREACHABLE_GATEKEEPER    7
#define CC_REJECT_GATEWAY_RESOURCES         8
#define CC_REJECT_BAD_FORMAT_ADDRESS        9
#define CC_REJECT_ADAPTIVE_BUSY             10
#define CC_REJECT_IN_CONF                   11
#define CC_REJECT_ROUTE_TO_GATEKEEPER       12
#define CC_REJECT_CALL_FORWARDED            13
#define CC_REJECT_ROUTE_TO_MC               14
#define CC_REJECT_UNDEFINED_REASON          15
#define CC_REJECT_INTERNAL_ERROR            16    // Internal error occured in peer CS stack.
#define CC_REJECT_NORMAL_CALL_CLEARING      17    // Normal call hangup
#define CC_REJECT_USER_BUSY                 18    // User is busy with another call
#define CC_REJECT_NO_ANSWER                 19    // Callee does not answer
#define CC_REJECT_NOT_IMPLEMENTED           20    // Service has not been implemented
#define CC_REJECT_MANDATORY_IE_MISSING      21    // Pdu missing mandatory ie
#define CC_REJECT_INVALID_IE_CONTENTS       22    // Pdu ie was incorrect
#define CC_REJECT_TIMER_EXPIRED             23    // Own timer expired
#define CC_REJECT_CALL_DEFLECTION           24    // You deflected the call, so lets quit.
#define CC_REJECT_GATEKEEPER_TERMINATED     25    // Gatekeeper terminated call

// Q931 call types
#define CC_CALLTYPE_UNKNOWN                 0
#define CC_CALLTYPE_PT_PT                   1
#define CC_CALLTYPE_1_N                     2
#define CC_CALLTYPE_N_1                     3
#define CC_CALLTYPE_N_N                     4

// alias contants
#define CC_ALIAS_MAX_H323_ID                256
#define CC_ALIAS_MAX_H323_PHONE             128

// unicode character mask contants
#define CC_ALIAS_H323_PHONE_CHARS           L"0123456789#*,"
#define CC_ODOTTO_CHARS                     L".0123456789"


// alias type codes
#define CC_ALIAS_H323_ID                    1    // Return call information.
#define CC_ALIAS_H323_PHONE                 2    // H323 Phone Number.

// default port id's
#define CC_H323_GATE_DISC    1718 // Gatekeeper IP Discovery Port
#define CC_H323_GATE_STAT    1719 // Gatekeeper UDP Reg. and Status Port
#define CC_H323_HOST_CALL    1720 // Endpoint TCP Call Signalling Por

// Call creation goals
#define CC_GOAL_UNKNOWN                     0
#define CC_GOAL_CREATE                      1
#define CC_GOAL_JOIN                        2
#define CC_GOAL_INVITE                      3
    
// H245 non-standard message types
#define CC_H245_MESSAGE_REQUEST             0
#define CC_H245_MESSAGE_RESPONSE            1
#define CC_H245_MESSAGE_COMMAND             2
#define CC_H245_MESSAGE_INDICATION          3

// Call Control handle typedefs
typedef DWORD        CC_HLISTEN, *PCC_HLISTEN;
typedef DWORD        CC_HCONFERENCE, *PCC_HCONFERENCE;
typedef DWORD        CC_HCALL, *PCC_HCALL;
typedef DWORD        CC_HCHANNEL, *PCC_HCHANNEL;

// IP address in domain name format
typedef struct 
{
    WORD         wPort;          // UDP or TCP port (host byte order)
    WCHAR        cAddr[255];     // UNICODE zstring
} CC_IP_DomainName_t;

// IP address in conventional dot notation
typedef struct 
{
    WORD         wPort;          // UDP or TCP port (host byte order)
    WCHAR        cAddr[16];      // UNICODE zstring
} CC_IP_Dot_t;

// IP address in binary format
typedef struct 
{
    WORD         wPort;          // UDP or TCP port (host byte order)
    DWORD        dwAddr;         // binary address (host byte order)
} CC_IP_Binary_t;

typedef enum
{
    CC_IP_DOMAIN_NAME,
    CC_IP_DOT,
    CC_IP_BINARY
} CC_ADDRTYPE;

typedef struct _ADDR
{
    CC_ADDRTYPE nAddrType;
    BOOL        bMulticast;
    union 
    {
        CC_IP_DomainName_t   IP_DomainName;
        CC_IP_Dot_t          IP_Dot;
        CC_IP_Binary_t       IP_Binary;
    } Addr;
} CC_ADDR, *PCC_ADDR;

typedef struct
{
    BYTE *pOctetString;
    WORD wOctetStringLength;
} CC_OCTETSTRING, *PCC_OCTETSTRING;

typedef struct
{
    CC_OCTETSTRING          sData;            // pointer to Octet data.
    BYTE                    bCountryCode;
    BYTE                    bExtension;
    WORD                    wManufacturerCode;
} CC_NONSTANDARDDATA, *PCC_NONSTANDARDDATA;

#define CC_MAX_PRODUCT_LENGTH 256
#define CC_MAX_VERSION_LENGTH 256
#define CC_MAX_DISPLAY_LENGTH 82

typedef struct
{
    BYTE                    bCountryCode;
    BYTE                    bExtension;
    WORD                    wManufacturerCode;
    PCC_OCTETSTRING         pProductNumber;
    PCC_OCTETSTRING         pVersionNumber;
} CC_VENDORINFO, *PCC_VENDORINFO;

typedef struct
{
    PCC_VENDORINFO          pVendorInfo;
    BOOL                    bIsTerminal;
    BOOL                    bIsGateway;    // for now, the H323 capability will be hard-coded.
} CC_ENDPOINTTYPE, *PCC_ENDPOINTTYPE;

typedef struct
{
    WORD                    wType;
    WORD                    wPrefixLength;
    LPWSTR                  pPrefix;
    WORD                    wDataLength;   // UNICODE character count
    LPWSTR                  pData;         // UNICODE data.
} CC_ALIASITEM, *PCC_ALIASITEM;

typedef struct
{
    WORD                    wCount;
    PCC_ALIASITEM           pItems;
} CC_ALIASNAMES, *PCC_ALIASNAMES;

typedef struct _CONFERENCE_ID
{
    BYTE                    buffer[16];  // This is OCTET data, not ASCII.
} CC_CONFERENCEID, *PCC_CONFERENCEID;

#pragma pack(pop)

#endif    INCOMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\intelcc\interop\interop.cpp ===
#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))

#include "interop.h"
#include <stdio.h>
#include "cpls.h"

static int g_nRefCount = 0;

LPInteropLogger INTEROP_EXPORT InteropLoad(CPLProtocol Protocol)
{
	OutputDebugString("Loading CPLS\n");
	LPInteropLogger Logger = (LPInteropLogger) GlobalAlloc (GMEM_FIXED | GMEM_ZEROINIT, sizeof(InteropLogger));
	if (!(Logger))
		return NULL;
    UINT oldMode = SetErrorMode(SEM_NOOPENFILEERRORBOX);

	(Logger)->hInst = LoadLibrary(DLLName);

    SetErrorMode(oldMode);

    if ((INT_PTR)(Logger)->hInst > HINSTANCE_ERROR)
    {
	  g_nRefCount++;

	#ifdef _DEBUG
	  char buf[80];
	  wsprintf (buf, "Loading Generic Protocol Logger: %s\n",DLLName);
      OutputDebugString(buf);
	#endif

      (Logger)->CPLInitialize = (CPLInitialize_t)GetProcAddress((Logger)->hInst, "CPLInitialize");
      (Logger)->CPLUninitialize = (CPLUninitialize_t)GetProcAddress((Logger)->hInst, "CPLUninitialize");
      (Logger)->CPLOpen = (CPLOpen_t)GetProcAddress((Logger)->hInst, "CPLOpen");
      (Logger)->CPLClose = (CPLClose_t)GetProcAddress((Logger)->hInst, "CPLClose");
      (Logger)->CPLOutput = (CPLOutput_t)GetProcAddress((Logger)->hInst, "CPLOutput");
	  Logger->g_ProtocolLogID = Logger->CPLInitialize(Protocol);
	  Logger->g_ComplianceProtocolLogger = Logger->CPLOpen(Logger->g_ProtocolLogID,
													NULL,
													CPLS_CREATE | CPLS_APPEND);
	}
    else
    {
		GlobalFree((Logger));
		(Logger) = NULL;
	#ifdef _DEBUG
		char buf[80];
		wsprintf (buf, "Loading Generic Protocol Logger %s Failed\n",DLLName);
		OutputDebugString(buf);
	#endif
    }

    return Logger;
}

void INTEROP_EXPORT InteropUnload(LPInteropLogger Logger)
{
	#ifdef _DEBUG
	char buf[80];
	wsprintf (buf, "Unloading Generic Protocol Logger: %s\n",DLLName);
	OutputDebugString(buf);
	#endif

	if ((Logger))
	{
		if ((INT_PTR)(Logger)->hInst > HINSTANCE_ERROR)
		{
			Logger->CPLClose(Logger->g_ComplianceProtocolLogger);
			Logger->CPLUninitialize(Logger->g_ProtocolLogID);
			if (--g_nRefCount <= 0)
				FreeLibrary((Logger)->hInst);
		}
		GlobalFree((Logger));
		(Logger) = NULL;
	}

}

void INTEROP_EXPORT InteropOutput(LPInteropLogger Logger, BYTE* buf,
							int length, unsigned long userData)
{
	if (!Logger)
		return;
	Logger->CPLOutput(Logger->g_ComplianceProtocolLogger, buf, length,userData);

}

#endif // #if (defined(_DEBUG) || defined(PCS_COMPLIANCE))

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\intelcc\include\tstable.h ===
/****************************************************************************
 *
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1996 Intel Corporation.
 *
 *
 *	Abstract:   
 *
 *	Notes:
 *
 ***************************************************************************/

#ifndef __TSTABLE_H
#define __TSTABLE_H

#include <windows.h>

typedef struct _LOCK_ENTRY
{
	HANDLE        hLock;
	int           iLockCount;
	BOOL          bCleanup,
								bDeleted;
	WORD          wNextFree,
								wUniqueID;

} LOCK_ENTRY, *PLOCK_ENTRY;


// definition of an invalid ID
#define TSTABLE_INVALID_ID				(DWORD) 0xFFFFFFFF

// return codes that the callback function used in conjunction with EnumerateEntries can return
const DWORD CALLBACK_CONTINUE                = 1;
const DWORD CALLBACK_ABORT                   = 2;
const DWORD CALLBACK_DELETE_ENTRY            = 3;
const DWORD CALLBACK_DELETE_ENTRY_AND_OBJECT = 4;



// used in call to Lock
#define TSTABLE_INVALID_UNIQUE_ID            (WORD) 0xFFFF
#define TSTABLE_INVALID_INDEX                (WORD) 0xFFFF

// This is a compare function that we aren't using right now.  It
// will be useful in the future if there is a reason to search
// the table 

typedef INT (*ENTRY_COMPARE) (LPVOID ptr1, LPVOID ptr2);


template <class EntryData> class TSTable
{
typedef DWORD (*TABLE_CALLBACK) (EntryData* ptr, LPVOID context);

public:
	           TSTable         (WORD            _size);
	          ~TSTable         ();
	BOOL       Resize          (WORD            wNewSize);
	BOOL       CreateAndLock   (EntryData*      pEntryData,
															LPDWORD         lpdwID);
	BOOL       Validate        (DWORD           dwID);
	EntryData *Lock            (DWORD           dwID,
															DWORD           timeout = INFINITE);
	BOOL       Unlock          (DWORD           dwID);
	BOOL       Delete          (DWORD           dwID,
															BOOL            bCleanup = FALSE);
	EntryData *EnumerateEntries(TABLE_CALLBACK  callBackFunc,
															void*           context,
															BOOL            bUnlockTable = FALSE);
	
	BOOL       IsInitialized   () {return bInitialized;}
	WORD       GetSize         () {return wNumUsed;}

private:
	// data

	EntryData**       pDataTable;
	PLOCK_ENTRY       pLockTable;
	CRITICAL_SECTION  csTableLock;
	WORD              wSize,
					  wNumUsed,
					  wFirstFree,
				      wLastFree,
					  wUniqueID;
	BOOL              bInitialized;

	// private methods

	BOOL LockEntry   (WORD wIndex,
									 DWORD timeout = INFINITE);
	BOOL UnLockEntry(WORD wIndex);
	void LockTable  () { EnterCriticalSection(&csTableLock); };
	void UnLockTable() { LeaveCriticalSection(&csTableLock); };
	WORD GenerateUniqueID();
	DWORD MakeID(WORD wIndex, WORD wUniqueID)
		{
			DWORD theID = wUniqueID;
			theID = (theID << 16) & 0xFFFF0000;
			theID |= wIndex;
			return(theID);
		};
	void BreakID(DWORD theID, WORD* pwIndex, WORD* pwUID)
		{
			*pwIndex = (WORD) (theID & 0x0000FFFF);
			*pwUID   = (WORD) ((theID >> 16) & 0x0000FFFF);
		};

};

/*
 ** TSTable::TSTable
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\tstable.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
TSTable<EntryData>::TSTable(WORD _size) :
														wSize(_size),
														wNumUsed((WORD) 0),
														wFirstFree((WORD) 0),
														wLastFree((WORD) (_size - 1)),
														wUniqueID((WORD) 0),
														bInitialized(TRUE),
														pDataTable(NULL),
														pLockTable(NULL)
{
	WORD wIndex;

	// Create the table lock

	InitializeCriticalSection(&csTableLock);

	// Lock the table

	LockTable();

	// Create the data table

	pDataTable = new EntryData*[wSize];
	
	if(pDataTable == NULL) 
	{
		bInitialized = FALSE;
		return;
	}   

	// Init the pointers

	for (wIndex = 0; wIndex < wSize; wIndex++)
	{
		pDataTable[wIndex] = NULL;
	}

	// Create the lock table

	pLockTable = new LOCK_ENTRY[wSize];

	if (pLockTable == NULL)
	{
		bInitialized = FALSE;
		return;
	}   

	// Initialize the lock table entries...each entry begins with
	// a NULL mutex handle, a zero lock count and it's next free is
	// the next successive entry.

	for (wIndex = 0; wIndex < wSize; wIndex++ )
	{
		pLockTable[wIndex].hLock      = NULL;
		pLockTable[wIndex].iLockCount = 0;
		pLockTable[wIndex].wNextFree = (WORD) (wIndex + 1);
	}   

	// note: the wNextFree in the last table entry points to an invalid index, however,
	// this is OK since if the table ever fills, it is automatically resized making what 
	// was an invalid index, the index into the first entry of newly added part of the 
	// enlargened table.  Trust me...

	// Unlock the table

	UnLockTable();
}

/*
 ** TSTable::~TSTable
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
TSTable<EntryData>::~TSTable()
{
	DWORD wIndex;

	// Lock the table

	LockTable();

	// Delete the data table

	if (pDataTable != NULL)
	{
		delete pDataTable;
	}

	// Delete the lock table

	if (pLockTable != NULL)
	{
		// Destroy the mutexes

		for (wIndex = 0; wIndex < wSize; wIndex++)
		{
			if (pLockTable[wIndex].hLock != NULL)
			{
				CloseHandle(pLockTable[wIndex].hLock);
			}
		}

		delete pLockTable;
	}

	// Unlock the table

	UnLockTable();

	// Destroy the table lock

	DeleteCriticalSection(&csTableLock);

	bInitialized = FALSE; 
}

/*
 ** TSTable::Resize
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::Resize(WORD wNewSize) 
{
	BOOL        bRetCode = TRUE;
	EntryData** pNewDataTable;
	PLOCK_ENTRY pNewLockTable;
	WORD        wIndex;

	// Lock the table

	LockTable();

	// If the table is shrinking, pretend we did it

	if (wNewSize <= wSize)
	{
		goto EXIT;
	}
	
	// Allocate new data and lock tables and make sure that succeeds.

	pNewDataTable = new EntryData*[wNewSize];

	if(pNewDataTable == NULL) 
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	pNewLockTable = new LOCK_ENTRY[wNewSize];

	if(pNewLockTable == NULL) 
	{
		bRetCode = FALSE;
		goto CLEANUP1;
	}

	// Initialize the new section of the lock and data tables

	for (wIndex = wSize; wIndex < wNewSize; wIndex++)
	{
		pNewDataTable[wIndex]            = NULL;

		pNewLockTable[wIndex].hLock      = NULL;
		pNewLockTable[wIndex].iLockCount = 0;
		pNewLockTable[wIndex].wNextFree = (WORD) (wIndex + 1);
	}

	// Copy the old data table pointers to the new data table

	memcpy((PCHAR) pNewDataTable,
				 (PCHAR) pDataTable,
				 sizeof(EntryData*) * wSize);

	// Delete the old data table and fix the pointer 

	delete pDataTable;
	pDataTable = pNewDataTable;

	// Copy the old lock table to the new lock table

	memcpy((PCHAR) pNewLockTable,
				 (PCHAR) pLockTable,
				 sizeof(LOCK_ENTRY) * wSize);

	// Delete the old lock table and fix the pointer 

	delete pLockTable;
	pLockTable = pNewLockTable;

	// Fix the size variable

	wSize = wNewSize;

	goto EXIT;

CLEANUP1:

	// Delete the new data table

	delete pNewDataTable;

EXIT:

	// Unlock the table

	UnLockTable();

	return bRetCode;
}

/*
 ** TSTable::CreateAndLock
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::CreateAndLock(EntryData* pEntryData,
																			 LPDWORD    lpdwID)
{
	BOOL  bRetCode = FALSE;
	WORD wIndex;

	// If the pointer passed in is bad, then don't even try to do anything for them

	if (pEntryData == NULL || lpdwID == NULL)
	{
		goto EXIT;
	}

	// Lock the table

	LockTable();

	// If the table is full, then resize it.

	if (wNumUsed == wSize)
	{
		if (Resize((WORD) (wSize + 20)) == FALSE)
		{
			goto EXIT;
		}
	}

	// Get the first free entry

	wIndex = wFirstFree;

	// Create the mutex for the object

	if ((pLockTable[wIndex].hLock = CreateMutexA(NULL, FALSE, NULL)) == NULL)
	{
		goto EXIT;
	}

	// Lock the entry (no need checking the return code as the entire
	// table is locked) - since this is a new entry, that means that nobody
	// could have locked the entry already.

	LockEntry(wIndex, 0);

	// Copy pointer to the data table

	pDataTable[wIndex] = pEntryData;

	// Init the corresponding lock table entry

	pLockTable[wIndex].bDeleted   = FALSE;
	pLockTable[wIndex].iLockCount = 1;
	pLockTable[wIndex].wUniqueID = GenerateUniqueID();

	// Set the id for the caller

	*lpdwID = MakeID(wIndex, pLockTable[wIndex].wUniqueID);

	// Bump up the count of number used

	wNumUsed++;

	// Fix the next free index

	wFirstFree = pLockTable[wIndex].wNextFree;

	// Signal success

	bRetCode = TRUE;

EXIT:

	// Unlock the table

	UnLockTable();
	return bRetCode;
}

/*
 ** TSTable::Lock
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
EntryData* TSTable<EntryData>::Lock(DWORD dwID,
																		DWORD timeout) 
{
	EntryData* pEntryData = NULL;

	WORD wIndex,
       wUID;

	BreakID(dwID, &wIndex, &wUID); 

	// Lock the table

	LockTable();

	// Verify the index is within bounds

	if (wIndex >= wSize)
	{
		goto EXIT;
	}

	// Verify that the entry is actually valid (ie the lock in non-NULL,
	// the object status is valid, and the unique ID matches).

	if (pLockTable[wIndex].hLock    == NULL ||
			pLockTable[wIndex].bDeleted == TRUE ||
			pLockTable[wIndex].wUniqueID != wUID)
	{
		goto EXIT;
	}

	// If the timeout is INFINITE, then try to lock the entry using a more
	// "thread friendly" method.	 If a timeout is specified, then don't do
	// the spin lock since it could be implemented at a higher level.

	if(timeout == INFINITE)
	{
		// simulate infinity with a pseudo "spin lock"
		// This is more "thread friendly" in that it unlocks the table allowing some
		// other thread that is trying to unlock the same entry to be able to lock the
		// table.

		while(LockEntry(wIndex, 0) == FALSE)
		{
			UnLockTable();

			// give up the rest of this thread quantum, allowing others to run and potentially
			// unlock the entry

			Sleep(0); 
			LockTable();

			// If the entry has been replaced, deleted or marked for deletion then
			// bag it (give up)

			if((pLockTable[wIndex].wUniqueID != wUID)  ||
				 (pLockTable[wIndex].hLock      == NULL)  || 
				 (pLockTable[wIndex].bDeleted   == TRUE))
			{
				goto EXIT;
			}
		}

		// we got the lock

		pEntryData = pDataTable[wIndex];
	}
	
	// Otherwise, do a normal lock

	else
	{	
		if (LockEntry(wIndex, timeout) == TRUE) 
		{
			pEntryData = pDataTable[wIndex];
		}
	}

EXIT:

	// Unlock the table

	UnLockTable();

	return pEntryData;
}

/*
 ** TSTable::Unlock
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::Unlock(DWORD dwID)
{
	BOOL bRetCode = TRUE;

	WORD wIndex,
       wUID;

	BreakID(dwID, &wIndex, &wUID); 
	
	// Lock the table

	LockTable();

	// Verify the id is within bounds

	if (wIndex >= wSize) 
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// verify that the UID matches
	if (pLockTable[wIndex].wUniqueID != wUID)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// Verify that the lock is actually valid and that the entry has not been
	// deleted

	if (pLockTable[wIndex].hLock == NULL)
	{
		goto EXIT;
	}

	// Make sure that that thread has the lock on the entry

	if ((bRetCode = LockEntry(wIndex, 0)) == TRUE) 
	{
		// if this table entry is marked for delete and the lock count is less than 2
		// (since the thread could have called delete after unlocking the entry...although
		// this is a no-no) then clean up the table entry

		if (pLockTable[wIndex].bDeleted   == TRUE &&
				pLockTable[wIndex].iLockCount <= 2)
		{
			// If the caller specifed cleanup on delete, then get rid of memory

			if (pLockTable[wIndex].bCleanup == TRUE)
			{
				delete pDataTable[wIndex];
			}

			// Set the pointer to NULL

			pDataTable[wIndex] = NULL;

			// Decrement the count of used entries

			wNumUsed--;

			// Fix the entry so that it's next free index is what is currently
			// the next free pointed to by the current last free entry.  
			// Then update the last free entry's next pointer, and finally, 
			// update the last free index to this entry
			pLockTable[wIndex].wNextFree    = pLockTable[wLastFree].wNextFree;
			pLockTable[wLastFree].wNextFree = wIndex;
			wLastFree                       = wIndex;
		}

		// Do two unlocks on the entry ... one for the original lock and another for
		// the lock we obtained during the test

		UnLockEntry(wIndex);
		UnLockEntry(wIndex);

		// Since the entire table is locked, then we can get away with this.  If
		// the code is ever changed so that the entire table is not locked during
		// these operations, then this will cause a race condition.

		// If we got rid of the data, then close the handle to the mutex and
		// set the handle to NULL

		if (pDataTable[wIndex] == NULL)
		{
			CloseHandle(pLockTable[wIndex].hLock);
			pLockTable[wIndex].hLock = NULL;
		}
	}

EXIT:

	// Unlock the table

	UnLockTable();

	return bRetCode;
}

/*
 ** TSTable::Delete
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::Delete(DWORD dwID,
																BOOL  bCleanup) 
{
	BOOL bRetCode = TRUE;

	WORD wIndex,
       wUID;

	BreakID(dwID, &wIndex, &wUID); 

	// Lock the table

	LockTable();

	// Verify that the ID is within bounds

	if (wIndex >= wSize) 
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// verify that the UID matches
	if (pLockTable[wIndex].wUniqueID != wUID)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// Verify that the entry is valid

	if (pDataTable[wIndex] == NULL)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// Try to lock the entry (ie check to see if we had the entry locked)

	if (LockEntry(wIndex, 0) == TRUE)
	{
		// mark it for deletion, set the cleanp flag and then unlock it

		pLockTable[wIndex].bDeleted = TRUE;
		pLockTable[wIndex].bCleanup = bCleanup;

		UnLockEntry(wIndex);

		// Note: this function does not call ::Unlock() on behalf of the user.
		// Thus, the entry is only marked as deleted at this point and can no
		// longer be locked by any threads (including the one that marked it for delete).
		// The thread that marked the entry as deleted must call ::Unlock() to actually
		// free up the entry.
	}

EXIT:

	// Unlock the table

	UnLockTable();

	return bRetCode;
}

/*
 ** TSTable::Lock
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:  Validates that an object still exists.  Can be called
 *								regardless if caller has entry locked or not.
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::Validate(DWORD dwID)
{
	BOOL bRetCode = TRUE;
	WORD wIndex,
       wUID;

	BreakID(dwID, &wIndex, &wUID); 

	// Lock the table

	LockTable();

	// Verify the index is within bounds

	if (wIndex >= wSize)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

	// Verify that the entry is actually valid (ie the lock in non-NULL,
	// the object status is valid, the unique ID matches, and the data ptr is not null).

	if (pLockTable[wIndex].hLock    == NULL  ||
			pLockTable[wIndex].bDeleted == TRUE  ||
			pLockTable[wIndex].wUniqueID != wUID ||
			pDataTable[wIndex] == NULL)
	{
		bRetCode = FALSE;
		goto EXIT;
	}

EXIT:

	// Unlock the table

	UnLockTable();

	return bRetCode;
}

/*
 ** TSTable::EnumerateEntries
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
EntryData* TSTable<EntryData>::EnumerateEntries(TABLE_CALLBACK callbackFunc,
																								LPVOID         context,
																								BOOL           bUnlockTable) 
{
	DWORD      dwAction;
	WORD       wIndex = wSize;
	EntryData* pEntryData = NULL;
	DWORD      dwEntryID;

	// Make sure they passed a good function

	if (callbackFunc == NULL)
	{
		goto EXIT;
	}

	// Lock the table

	LockTable();

	// Run through the data table and pass the data to the callback function

	for (wIndex = 0; wIndex < wSize; wIndex++)
	{
		// Verify that there is actually data in the entry and that the entry has not
		// been marked for deletion.

		if (pDataTable[wIndex]          == NULL ||
				pLockTable[wIndex].bDeleted == TRUE)
		{
			continue;
		}


		// Try to lock the entry...if we cannot, then we don't have the lock and
		// we will only report entries that we have locked (or are unlocked)

		if (LockEntry(wIndex, 0) == FALSE)
		{
			continue;
		}
		
		// build and remember the "full" entry ID so we can use it to unlock the entry
		dwEntryID = MakeID(wIndex, pLockTable[wIndex].wUniqueID);

		// Save the pointer to the object.

		pEntryData = pDataTable[wIndex];

		// note: only unlock the table during the callback if we are explicitly asked to (the 
		// default is not to unlock the table). 
		if(bUnlockTable == TRUE)
			UnLockTable();

		// Call their function
		dwAction = callbackFunc(pDataTable[wIndex], context);

		if(bUnlockTable == TRUE)
			LockTable();

		// If the action says to delete the entry, then do so...if we are also to delete
		// the object, pass in a TRUE.

		if (dwAction == CALLBACK_DELETE_ENTRY ||
				dwAction == CALLBACK_DELETE_ENTRY_AND_OBJECT)
		{
			Delete(dwEntryID, (dwAction == CALLBACK_DELETE_ENTRY ? FALSE : TRUE));
		}

		// If the action says abort, then break the loop...notice that means that
		// the entry is still locked

		else if (dwAction == CALLBACK_ABORT)
		{
			goto EXIT;
		}

		// Unlock the entry...notice we don't use UnLockEntry.  The reason is that
		// if the entry has been marked as deleted, then we need to have
		// it destroyed and UnLockEntry doesn't do that.

		Unlock(dwEntryID);
	}

EXIT:

	// Unlock the table

	UnLockTable();

	// Return NULL if we processed the entire table...if we were told to abort,
	// return a pointer to the entry we stopped on.

	return (wIndex == wSize ? NULL : pEntryData);
}

// helper functions - these assume table is locked and index is good

/*
 ** TSTable::LockEntry
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::LockEntry(WORD wIndex,
																	 DWORD timeout) 
{
	BOOL  bRetCode = TRUE;
	DWORD dwRetCode;


	// Try to lock the entry.  If it succeeds, we'll bump up the lock count.  If
	// the wait ended because another thread abandoned the mutex, then set the count
	// to one.

	dwRetCode = WaitForSingleObject(pLockTable[wIndex].hLock, timeout);
	
	if (dwRetCode == WAIT_OBJECT_0)
	{
		pLockTable[wIndex].iLockCount++;
	}
	else if (dwRetCode == WAIT_ABANDONED)
	{
		pLockTable[wIndex].iLockCount = 1;
	}
	else
	{
		bRetCode = FALSE;
	}

	return bRetCode;
}

/*
 ** TSTable::UnLockEntry
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

template <class EntryData>
BOOL TSTable<EntryData>::UnLockEntry(WORD wIndex)
{
	BOOL bRetCode;

	// Release the mutex...if that succeeds, reduce the count

	if((bRetCode = ReleaseMutex(pLockTable[wIndex].hLock)) == TRUE) 
	{
		pLockTable[wIndex].iLockCount--;
	}

	return bRetCode;
}


/*
 ** TSTable::GenerateUniqueID
 *
 *  FILENAME: c:\msdev\projects\firewalls\inc\table.h
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION: table should be locked before calling this function.
 *
 *  RETURNS:
 *
 */

template <class EntryData>
WORD TSTable<EntryData>::GenerateUniqueID()
{
	// table must be locked
	if(++wUniqueID == TSTABLE_INVALID_UNIQUE_ID)
		wUniqueID++;
	return(wUniqueID);
}






#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\intelcc\interop\interop.h ===
#ifndef __INTEROP_H
#define __INTEROP_H

#include <windows.h>

#define INTEROP_EXPORT  __declspec(dllexport)

#define DLLName "CPLS.DLL"


typedef int    (WINAPI *CPLInitialize_t)(const char*);
typedef int    (WINAPI *CPLUninitialize_t)(int) ;
typedef int    (WINAPI *CPLOpen_t)(int, 
							const char*, 
							int);
typedef int    (WINAPI *CPLClose_t)( int );
typedef int    (WINAPI *CPLOutput_t)(int, 
							BYTE*, 
							int,
							unsigned long);



typedef struct {
    CPLInitialize_t       CPLInitialize;
	CPLUninitialize_t     CPLUninitialize;
    CPLOpen_t			  CPLOpen;
    CPLClose_t			  CPLClose;
    CPLOutput_t			  CPLOutput;
	int					  g_ComplianceProtocolLogger;
	int					  g_ProtocolLogID;
	HINSTANCE hInst;
} *LPInteropLogger, InteropLogger;

#ifdef __cplusplus
extern "C" {
#endif

LPInteropLogger INTEROP_EXPORT InteropLoad(const char*  Protocol);
void INTEROP_EXPORT InteropUnload(LPInteropLogger Logger);
void INTEROP_EXPORT InteropOutput(LPInteropLogger Logger, BYTE* buf, int length, unsigned long userData);

#ifdef __cplusplus
}
#endif


#endif  // __CPLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\acmcaps.h ===
/*
 *  	File: acmcaps.h
 *
 *
 *		ACM implementation of Microsoft Network Audio capability object.
 *
 *		Additional methods supported by this implementation:
 *			BOOL OpenACMDriver(HACMDRIVERID hadid); // (internal)
 *			VOID CloseACMDriver();					// (internal)
 *			HACMDRIVER GetDriverHandle();			// (internal)
 *	
 *		AUDIO_FORMAT_ID AddEncodeFormat(AUDCAP_DETAILS *pFmtBuf,LPVOID lpvMappingData, UINT uSize);
 *		AUDIO_FORMAT_ID AddDecodeFormat(AUDCAP_DETAILS *pFmtBuf,LPVOID lpvMappingData, UINT uSize);
 *

 *		Revision History:
 *
 *		12/27/95	mikev	created
 */


#ifndef _ACMCAPS_H
#define _ACMCAPS_H


// ACM enumeration support functions
BOOL GetFormatBuffer(VOID);
BOOL __stdcall ACMFormatTagEnumCallback(HACMDRIVERID hadid, LPACMFORMATTAGDETAILS paftd,
    DWORD_PTR dwInstance,  DWORD fdwSupport);
BOOL __stdcall ACMFormatEnumCallback(HACMDRIVERID hadid,
    LPACMFORMATDETAILS pafd, DWORD_PTR dwInstance, DWORD fdwSupport);
BOOL __stdcall ACMDriverEnumCallback(HACMDRIVERID hadid,
    DWORD_PTR dwInstance, DWORD fdwSupport);


#ifdef __cplusplus

class CAcmCapability
{
protected:

	HACMDRIVER hAcmDriver;	
public:
	CAcmCapability();
	~CAcmCapability();
	BOOL DriverEnum(DWORD_PTR pAppParam);
	HACMDRIVER GetDriverHandle() {return hAcmDriver;};
	virtual BOOL FormatEnumHandler(HACMDRIVERID hadid,
	    LPACMFORMATDETAILS pafd, DWORD_PTR dwInstance, DWORD fdwSupport);
	virtual BOOL OpenACMDriver(HACMDRIVERID hadid);
	virtual VOID CloseACMDriver();
};

#define PREF_ORDER_UNASSIGNED 0xffff
typedef enum {
	SortByAppPref=0
}SortMode;

typedef struct AudioParameters
{
	BYTE    RTPPayload;		// RTP payload type
	DWORD 	dwFormatDescriptor;		// the unique ID of this format
	UINT	uSamplesPerSec;	
	UINT	uBitsPerSample;
}AUDIO_PARAMS;


typedef struct H245AudCaps
{
	H245_CAPDIR_T   Dir;
	H245_DATA_T     DataType;
	H245_CLIENT_T   ClientType;
	H245_CAPID_T    CapId;

	H245_CAP_NONSTANDARD_T        H245_NonStd;
	H245_CAP_NONSTANDARD_T        H245Aud_NONSTD;
	unsigned short                H245Aud_G711_ALAW64;
	unsigned short                H245Aud_G711_ULAW64;
	H245_CAP_G723_T               H245Aud_G723;

} H245_TERMCAP;


// default initializer for NSC_CHANNEL_PARAMETERS
#define STD_CHAN_PARAMS {0, 0,0,0,0,0,0,0,0}	
// initializers for CC_TERMCAP
#define NONSTD_TERMCAP {H245_CAPDIR_LCLRX, H245_DATA_AUDIO,H245_CLIENT_AUD_NONSTD, 0, {0}}
#define STD_TERMCAP(tc) {H245_CAPDIR_LCLRX, H245_DATA_AUDIO,(tc), 0, {0}}
// Capability cache structure.  This contains local capabilities, public versions of
// those capabilities, parameters for capabilities, plus other information
// that is used to affect how the local machine proritizes or selects a format
//
typedef struct AudCapDetails
{
	WORD	wFormatTag;
	H245_TERMCAP H245TermCap;
	
	NSC_CHANNEL_PARAMETERS nonstd_params;
	AUDIO_PARAMS audio_params;	
	DWORD dwPublicRefIndex;	// index of the local capability entry that will be
							// advertized.  Zero if this entry is the one to advertize
	BOOL bSendEnabled;
	BOOL bRecvEnabled;	
	DWORD dwDefaultSamples;		// default number of samples per packet
	UINT uMaxBitrate;			// max bandwidth used by this format (calculated: bits per sample * sample rate)
	UINT uAvgBitrate;			// average bandwidth used by this format (we get this from the codec)
	WORD wCPUUtilizationEncode;
	WORD wCPUUtilizationDecode;	
	WORD wApplicationPrefOrder;	// overriding preference - lower number means more preferred
	UINT uLocalDetailsSize;		// size in bytes of what lpLocalFormatDetails points to
	LPVOID lpLocalFormatDetails;
	UINT uRemoteDetailsSize;	// size in bytes of what lpRemoteFormatDetails points to
	LPVOID lpRemoteFormatDetails;
	char szFormat[ACMFORMATDETAILS_FORMAT_CHARS];
}AUDCAP_DETAILS, *PAUDCAP_DETAILS;

//Registry Format Cache Structure
//Use In the ACM routines. They build a list of format names, and a list of format data blocks.
//rrf_nFormats is the number of formats we read from the registry.
typedef struct rrfCache {

    char **pNames;
    BYTE **pData;
    UINT nFormats;

} RRF_INFO, *PRRF_INFO;

/*
 *	ACM interface
 *	Definitions for interfacing with ACM
 */

#define ACMAPP_FORMATENUMHANDLER_MASK	0x3
#define ACMAPP_FORMATENUMHANDLER_ENUM	0x0
#define ACMAPP_FORMATENUMHANDLER_ADD	0x1

typedef struct
{
	CAcmCapability *pCapObject;		// the "calling" capability object
	PAUDCAP_DETAILS pAudcapDetails;	// a pointer to an AUDCAP_DETAILS structure
	DWORD dwFlags;					// misc flags...
	LPWAVEFORMATEX lpwfx;			// pointer to wave format structure. used when adding formats
	LPACMFORMATTAGDETAILS paftd;	// pointer to an ACM format tag details.
									// is filled in during DriverEnum
	HRESULT hr;
    PRRF_INFO pRegCache;
} ACM_APP_PARAM, *PACM_APP_PARAM;

//
//  implementation class of the audio interface
//

class CImpAppAudioCap : public IAppAudioCap
{
	public:
	STDMETHOD_(ULONG,  AddRef());
	STDMETHOD_(ULONG, Release());
	
	STDMETHOD(GetNumFormats(UINT *puNumFmtOut));
    STDMETHOD(ApplyAppFormatPrefs(PBASIC_AUDCAP_INFO pFormatPrefsBuf,
		UINT uNumFormatPrefs));
    STDMETHOD(EnumFormats(PBASIC_AUDCAP_INFO pFmtBuf, UINT uBufsize,
		UINT *uNumFmtOut));
	STDMETHOD(EnumCommonFormats(PBASIC_AUDCAP_INFO pFmtBuf, UINT uBufsize,
		UINT *uNumFmtOut, BOOL bTXCaps));
	STDMETHOD( GetBasicAudcapInfo (AUDIO_FORMAT_ID Id,
		PBASIC_AUDCAP_INFO pFormatPrefsBuf));
	STDMETHOD( AddACMFormat (LPWAVEFORMATEX lpwfx, PBASIC_AUDCAP_INFO pAudCapInfo));
	STDMETHOD( RemoveACMFormat (LPWAVEFORMATEX lpwfx));

	STDMETHOD_ (LPVOID, GetFormatDetails) (AUDIO_FORMAT_ID Id) ;
 	void Init(class CMsiaCapability * pCapObject) {m_pCapObject = pCapObject;};

protected:
	class CMsiaCapability * m_pCapObject;
};


class CMsiaCapability : public IH323MediaCap, public CAcmCapability
{
protected:
	UINT uRef;
	BOOL bPublicizeTXCaps;
	BOOL bPublicizeTSTradeoff;
	PRRF_INFO pRegFmts;     //Registry cache info structure
	// LOOKLOOK this supports a hack to disable CPU intensive codecs if not running on a pentium
	WORD wMaxCPU;
	UINT m_uPacketDuration;	// packet duration in millisecs

	static MEDIA_FORMAT_ID IDsByRank[MAX_CAPS_PRESORT];
	
	static UINT uNumLocalFormats;			// # of active entries in pLocalFormats
	static UINT uCapIDBase;					// rebase capability ID to index into IDsByRank
	static AUDCAP_DETAILS *pLocalFormats;	// cached list of formats that we can receive
	static UINT uLocalFormatCapacity;		// size of pLocalFormats (in multiples of AUDCAP_DETAILS)
	static UINT uStaticRef;					// global ref count for all instances of CMsiaCapability

	AUDCAP_DETAILS *pRemoteDecodeFormats;	// cached list of formats that the
	UINT uNumRemoteDecodeFormats;	// # of entries for remote decode capabilities
	UINT uRemoteDecodeFormatCapacity;	// size of pRemoteDecodeFormats (in multiples of VIDCAP_DETAILS)
											// other end can receive/decode

	// embedded interface classes											
	CImpAppAudioCap m_IAppCap;											

public:
protected:
	// Internal functions
	UINT IDToIndex(MEDIA_FORMAT_ID id) {return id - uCapIDBase;};
	MEDIA_FORMAT_ID IndexToId(UINT uIndex){return uIndex + uCapIDBase;};
	LPTSTR AllocRegistryKeyName(LPTSTR lpDriverName,
		UINT uSampleRate, UINT uBitsPerSample, UINT uBytesPerSec);
	VOID FreeRegistryKeyName(LPTSTR lpszKeyName);
	virtual VOID CalculateFormatProperties(AUDCAP_DETAILS *pFmtBuf,LPWAVEFORMATEX lpwfx);
	virtual BOOL IsFormatSpecified(LPWAVEFORMATEX lpFormat, LPACMFORMATDETAILS pafd,
		LPACMFORMATTAGDETAILS paftd, AUDCAP_DETAILS *pAudcapDetails);
	virtual VOID SortEncodeCaps(SortMode sortmode);
	BOOL UpdateFormatInRegistry(AUDCAP_DETAILS *pFmt);
	BOOL BuildFormatName(	AUDCAP_DETAILS *pAudcapDetails,
							char *pszFormatTagName,
							char *pszFormatName);
	virtual AUDIO_FORMAT_ID AddFormat(AUDCAP_DETAILS *pFmtBuf,LPVOID lpvMappingData, UINT uSize);
	DWORD MaxFramesPerPacket(WAVEFORMATEX *pwf);
	DWORD MinFramesPerPacket(WAVEFORMATEX *pwf);
	UINT MinSampleSize(WAVEFORMATEX *pwf);


public:
	STDMETHOD_(BOOL, Init());
	STDMETHOD_(BOOL, ReInit());
	CMsiaCapability();
	~CMsiaCapability();

	// handler for codec enumeration callback	
	virtual BOOL FormatEnumHandler(HACMDRIVERID hadid,
		LPACMFORMATDETAILS pafd, DWORD_PTR dwInstance, DWORD fdwSupport);
	virtual BOOL AddFormatEnumHandler(HACMDRIVERID hadid,
		LPACMFORMATDETAILS pafd, DWORD_PTR dwInstance, DWORD fdwSupport);

//
// Common interface methods
//
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR * ppvObj);
	STDMETHOD_(ULONG,  AddRef());
	STDMETHOD_(ULONG, Release());

//		
// IACapApi methods		
//
    STDMETHOD(GetNumFormats(UINT *puNumFmtOut));
	STDMETHOD(ApplyAppFormatPrefs(PBASIC_AUDCAP_INFO pFormatPrefsBuf,
		UINT uNumFormatPrefs));
    STDMETHOD(EnumFormats(PBASIC_AUDCAP_INFO pFmtBuf, UINT uBufsize,
		UINT *uNumFmtOut));
	STDMETHOD(EnumCommonFormats(PBASIC_AUDCAP_INFO pFmtBuf, UINT uBufsize,
		UINT *uNumFmtOut, BOOL bTXCaps));
	STDMETHOD( GetBasicAudcapInfo (AUDIO_FORMAT_ID Id,
		PBASIC_AUDCAP_INFO pFormatPrefsBuf));
	STDMETHOD( AddACMFormat (LPWAVEFORMATEX lpwfx, PAUDCAP_INFO pAudCapInfo));
	STDMETHOD( RemoveACMFormat (LPWAVEFORMATEX lpwfx));

// support of  IACapApi
	virtual HRESULT CopyAudcapInfo (PAUDCAP_DETAILS pDetails, PAUDCAP_INFO pInfo,
									BOOL bDirection);

//
//	H.323 method implementations
//
	STDMETHOD_(VOID, FlushRemoteCaps());
	STDMETHOD( AddRemoteDecodeCaps(PCC_TERMCAPLIST pTermCapList));
	STDMETHOD_(MEDIA_FORMAT_ID, AddRemoteDecodeFormat(PCC_TERMCAP pCCThisCap));

	STDMETHOD( CreateCapList(LPVOID *ppCapBuf));
	STDMETHOD( DeleteCapList(LPVOID pCapBuf));

	STDMETHOD( ResolveEncodeFormat(AUDIO_FORMAT_ID *pIDEncodeOut,
			AUDIO_FORMAT_ID *pIDRemoteDecode));
			
	STDMETHOD_(UINT, GetLocalSendParamSize(MEDIA_FORMAT_ID dwID));
	STDMETHOD_(UINT, GetLocalRecvParamSize(PCC_TERMCAP pCapability));
	STDMETHOD( GetEncodeParams(LPVOID pBufOut, UINT uBufSize,LPVOID pLocalParams, UINT uSizeLocal,
		AUDIO_FORMAT_ID idRemote, AUDIO_FORMAT_ID idLocal));
	STDMETHOD( GetLocalDecodeParams(LPVOID lpvBuf, UINT uBufSize, AUDIO_FORMAT_ID id));
	STDMETHOD( GetPublicDecodeParams(LPVOID pBufOut, UINT uBufSize, AUDIO_FORMAT_ID id));
	STDMETHOD( GetDecodeParams(PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS  pChannelParams,
		AUDIO_FORMAT_ID * pFormatID, LPVOID lpvBuf, UINT uBufSize));
	STDMETHOD_(BOOL, IsCapabilityRecognized(PCC_TERMCAP pCCThisCap));
	STDMETHOD_(BOOL, IsFormatPublic(MEDIA_FORMAT_ID FormatID));	
	STDMETHOD_(MEDIA_FORMAT_ID, GetPublicID(MEDIA_FORMAT_ID FormatID));

	STDMETHOD_ (VOID, EnableTXCaps(BOOL bSetting)) {bPublicizeTXCaps = bSetting;};
	STDMETHOD_ (VOID, EnableRemoteTSTradeoff(BOOL bSetting)) {bPublicizeTSTradeoff= bSetting;};
	STDMETHOD (SetAudioPacketDuration( UINT durationInMs));
	STDMETHOD (ResolveToLocalFormat(MEDIA_FORMAT_ID FormatIDLocal,
		MEDIA_FORMAT_ID * pFormatIDRemote));	
// Methods common to H.323 and MSICCP
	STDMETHOD_(UINT, GetNumCaps()){return uNumLocalFormats;};
	STDMETHOD_(UINT, GetNumCaps(BOOL bRXCaps));
	STDMETHOD_(BOOL, IsHostForCapID(MEDIA_FORMAT_ID CapID));
	STDMETHOD(SetCapIDBase(UINT uNewBase));
	STDMETHOD_(UINT, GetCapIDBase()) {return uCapIDBase;};
	STDMETHOD (IsFormatEnabled (MEDIA_FORMAT_ID FormatID, PBOOL bRecv, PBOOL bSend));

// methods provided to the Data pump, common to H.323 and MSICCP
	STDMETHOD(GetEncodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize));
	STDMETHOD(GetDecodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize));


};

#endif	// __cplusplus

#endif	//#ifndef _ACMCAPS_H




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\intelcc\isrdbg32\isrdbg32.c ===
/****************************************************************************

	INTEL CORPORATION PROPRIETARY INFORMATION
	Copyright (c) 1992 Intel Corporation
	All Rights Reserved

	This software is supplied under the terms of a license
	agreement or non-disclosure agreement with Intel Corporation
	and may not be copied or disclosed except in accordance
	with the terms of that agreement

    $Source: q:/prism/network/isrdbg/rcs/isrdbg.c $
 $Revision:   1.3  $
      $Date:   30 Dec 1996 16:44:32  $
    $Author:   EHOWARDX  $
    $Locker:  $

	Description
	-----------
	VCITest - test harness for VCI and underlaying subsystems.

****************************************************************************/

// Turn off Windows stuff will never use.
#define NOSOUND
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NOCOMM
#define NOKANJI

#ifndef STRICT
#define STRICT
#endif // not defined STRICT

#include <windows.h>

#include <string.h>

#define ISRDBG32_C
#include <isrg.h>					// exports to functions.

#include "isrdbg32.h"				// private header file for this app



HINSTANCE		ghAppInstance = 0;		// global instance handle

// Global lock to protect:
//		gStrTabOfs, guNumItems
HANDLE			gSemaphore = 0;			// global semaphore for accessing dbg info.



// Most data needs to be globally mapped because info is shared with viewer and apps
// placing debug info into the buffers.
typedef struct _tDS
{
	UINT			uBindCount;		// How many copies of this DLL have run.
	UINT			guNumModules;
	UINT			guNumItems;
	UINT			gStrTabOfs;
	WORD			ghDefaultModule;
} tDS,*ptDS;

HANDLE			ghDS = 0;
ptDS			gpDS = NULL;

HANDLE			ghModuleTable = 0;
ptISRModule		gpModuleTable = NULL;

HANDLE			ghDbgTable = 0;
ptISRItem		gpDbgTable = NULL;

HANDLE			ghzStrTab = 0;
LPSTR			gpzStrTab = NULL;


//------------------------------------------------------------------------------
ptISRItem WINAPI
ISR_GetItemInternal (UINT uItem);



//------------------------------------------------------------------------------
BOOL MapGlobalWin32Memory(void** pMem,HANDLE* hMem,UINT MemSize,char* MemName)
{
	BOOL		fInit;


	if (!pMem || !hMem)
		return FALSE;

	*hMem = CreateFileMapping(
		INVALID_HANDLE_VALUE,	// use paging file
		NULL,					// no security attr.
		PAGE_READWRITE,			// read/write access
		0,						// size: high 32-bits
		MemSize,				// size: low 32-bits
		MemName);		// name of map object
	if (!*hMem)
		return FALSE;

	// The first process to attach initializes memory.
	fInit = (GetLastError() != ERROR_ALREADY_EXISTS);

	// Get a pointer to the file-mapped shared memory.
	*pMem = MapViewOfFile(
		*hMem,			// object to map view of
		FILE_MAP_WRITE,	// read/write access
		0,				// high offset:   map from
		0,				// low offset:    beginning
		0);				// default: map entire file
	if (!*pMem)
	{
		CloseHandle(*hMem);
		*hMem = 0;
		return FALSE;
	}

	// Initialize memory if this is the first process.
	if (fInit)
	{
		memset(*pMem,0,MemSize);
	}

	return TRUE;
}


void FreeGlobalWin32Memory(void* pMem,HANDLE hMem)
{
	// Unmap shared memory from the process's address space.
	if (pMem)
		UnmapViewOfFile(pMem);

	// Close the process's handle to the file-mapping object.
	if (hMem)
		CloseHandle(hMem);
}


//------------------------------------------------------------------------------
//	InitModules
//		Init the Module filters on startup.
//		Do not init the filters when the module is registered.
//		The display app may have some global filters in effect by the time
//		the individual register module calls come in.
//------------------------------------------------------------------------------
static void
InitModules (void)
{
	UINT			hMod;
	ptISRModule		pMod;


	for (hMod = 0; hMod < kMaxModules; hMod++)
	{
		pMod = ISR_GetModule(hMod);
		if (!pMod)
			break;

		pMod->DisplayFilter = 0xFF;
		pMod->CaptureFilter = 0xFF;
	}
}


//------------------------------------------------------------------------------
//	ValidCaptureMsg
//		Validate the capture filters to determine if this message should be
//		dropped.
//
//	Returns:
//		TRUE	- if msg is valid and should be kept
//		FALSE	- if msg is filtered out and should be dropped.
//------------------------------------------------------------------------------
static UINT
ValidCaptureMsg (WORD hISRInst, BYTE DbgLevel)
{
	ptISRModule		pMod;


	pMod = ISR_GetModule(hISRInst);
	if (!pMod)
		return FALSE;

	if (DbgLevel & pMod->CaptureFilter)
		return TRUE;
	else
		return FALSE;
}


//------------------------------------------------------------------------------
//	OutputRec ()
//		Store a string resource Id to be displayed at task time.
//		In addition store a number to be displayed in printf format of the
//		string.
//------------------------------------------------------------------------------
ISR_DLL void WINAPI
OutputRec
	(
	WORD	hISRInst,		// Our handle to registered modules
	BYTE	DbgLevel,		// Caller determined debug level
	BYTE	Flags,
	UINT	IP,				// Callers Instruction Ptr address
	DWORD	Param1,
	DWORD	Param2
	)
{
	ptISRItem	pItem;
	UINT		uItem;


	// Capture Filter
	if ( !ValidCaptureMsg(hISRInst, DbgLevel) )
		return;

	// Protect against reentrancy.  Just drop the msg if reentered.
	if (WAIT_OBJECT_0 != WaitForSingleObject(gSemaphore,100))
		return;

	uItem = gpDS->guNumItems++;
	if (kMaxISRItems <= gpDS->guNumItems)
	{
		gpDS->guNumItems = 0;
	}
	ReleaseSemaphore(gSemaphore,1,NULL);

	pItem = ISR_GetItemInternal(uItem);
	if (!pItem)
	{
		// This is a serious bug.  Our debugger is even hosed.
		// Need to think of a way to indicate this to the user.
		return;
	}

	pItem->hISRInst = hISRInst;
	pItem->DbgLevel = DbgLevel;
	pItem->Flags = Flags;
	pItem->IP = IP;
	pItem->Param1 = Param1;
	pItem->Param2 = Param2;
}


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
ISR_DLL void WINAPI
OutputRecStr
	(
	WORD	hISRInst,		// Our handle to registered modules
	BYTE	DbgLevel,		// Caller determined debug level
	BYTE	Flags,
	UINT	IP,				// Callers Instruction Ptr address
	LPSTR	pzStr1,
	LPSTR	pzStr2,
	DWORD	Param1
	)
{
	LPSTR		pzStrTab;
	UINT		uStrOfs;
	UINT		uStrLen;
	UINT		StrLen1;
	UINT		StrLen2;


	// Capture Filter
	if ( !ValidCaptureMsg(hISRInst, DbgLevel) )
		return;

	if (pzStr1)
		StrLen1 = lstrlen(pzStr1);
	else
		StrLen1 = 0;
	if (pzStr2)
		StrLen2 = lstrlen(pzStr2);
	else
		StrLen2 = 0;
	uStrLen = StrLen1 + StrLen2 + 1;	// 1 for null terminator.
	if (kMaxStrTab <= uStrLen)
	{
		return;	// It is so big.
	}
	
	// Protect against reentrancy.  Just drop the msg if reentered.
	if (WAIT_OBJECT_0 != WaitForSingleObject(gSemaphore,100))
		return;

	uStrOfs = gpDS->gStrTabOfs;
	gpDS->gStrTabOfs += uStrLen;
	if (kMaxStrTab <= gpDS->gStrTabOfs)
	{
		uStrOfs = 0;
		gpDS->gStrTabOfs = uStrLen;

		// Also reset items which would otherwise point in trashed strings.
		gpDS->guNumItems = 0;
	}
	pzStrTab = gpzStrTab + uStrOfs;
	ReleaseSemaphore(gSemaphore,1,NULL);

	if (pzStr1)
		lstrcpy(pzStrTab, pzStr1);
	if (pzStr2)
		lstrcpy(pzStrTab+StrLen1, pzStr2);

	OutputRec(hISRInst, DbgLevel, kParam1IsStr, IP, uStrOfs, Param1);
}


//------------------------------------------------------------------------------
//	ISR_HookDbgStrStr
//		Allow two strings to be concatenated together.
//------------------------------------------------------------------------------
ISR_DLL void WINAPI DLL_EXPORT
ISR_HookDbgStrStr (UINT IP, WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, LPSTR pzStr2)
{
	OutputRecStr(hISRInst, DbgLevel, kParam1IsStr, IP, pzStr1, pzStr2, 0);
}


//------------------------------------------------------------------------------
//	ISR_HookDbgRes
//		Use a resource to format a number.
//------------------------------------------------------------------------------
ISR_DLL void WINAPI DLL_EXPORT
ISR_HookDbgRes (UINT IP, WORD hISRInst, BYTE DbgLevel, UINT uResId, DWORD Param1)
{
	OutputRec(hISRInst, DbgLevel, kParam1IsRes, IP, uResId, Param1);
}


//------------------------------------------------------------------------------
//	ISR_HookDbgStr
//		Use a str to format a number.
//------------------------------------------------------------------------------
ISR_DLL void WINAPI DLL_EXPORT
ISR_HookDbgStr (UINT IP, WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, DWORD Param1)
{
	OutputRecStr(hISRInst, DbgLevel, kParam1IsStr, IP, pzStr1, 0, Param1);
}


//------------------------------------------------------------------------------
//	ISR_DbgStrStr
//		Allow two strings to be concatenated together.
//------------------------------------------------------------------------------
ISR_DLL void WINAPI DLL_EXPORT
ISR_DbgStrStr (WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, LPSTR pzStr2)
{
	UINT		IP = 0;


//	_asm
//	{
//		push	ax
//		mov		ax,[bp+2]
//		mov		IP,ax
//		pop		ax
//	}
	ISR_HookDbgStrStr(IP, hISRInst, DbgLevel, pzStr1, pzStr2);
}


//------------------------------------------------------------------------------
//	ISR_DbgRes
//		Use a resource to format a number.
//------------------------------------------------------------------------------
ISR_DLL void WINAPI DLL_EXPORT
ISR_DbgRes (WORD hISRInst, BYTE DbgLevel, UINT uResId, DWORD Param1)
{
	UINT		IP = 0;


//	_asm
//	{
//		push	ax
//		mov		ax,[bp+2]
//		mov		IP,ax
//		pop		ax
//	}
	ISR_HookDbgRes(IP, hISRInst, DbgLevel, uResId, Param1);
}


//------------------------------------------------------------------------------
//	ISR_DbgStr
//		Use a str to format a number.
//------------------------------------------------------------------------------
ISR_DLL void WINAPI DLL_EXPORT
ISR_DbgStr (WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, DWORD Param1)
{
	UINT		IP = 0;


//	_asm
//	{
//		push	ax
//		mov		ax,[bp+2]
//		mov		IP,ax
//		pop		ax
//	}
	ISR_HookDbgStr(IP, hISRInst, DbgLevel, pzStr1, Param1);
}


//------------------------------------------------------------------------------
//	TT_DbgMsg
//		This function builds a formatted string, based upon numeric or
//		string input parameters, and sends the string to isrdbg.dll to
//		be displayed in the isrdsp.exe window.	THIS FUNCTION CAN NOT
//		BE CALLED AT INTERRUPT-TIME.  This function uses the same
//		mechanism as isrdbg.dll to enable/disable debug output.
//
// In:
//		hISRInst,		- Module's ISRDBG handle.
//		DbgLevel,		- Appropriate ISRDBG level.
//		zMsgFmt,		- Output format string (like printf).
//		...				- Optional parameter list.
//
// Out:
//		none
//
// Return:
//		none
//------------------------------------------------------------------------------
ISR_DLL void FAR cdecl DLL_EXPORT
TTDbgMsg
(
	WORD		hISRInst,
	BYTE		DbgLevel,
	LPCSTR		zMsgFmt,
	...
)
{
	WORD		TempIP = 0;
	char		MsgBuf[256];

//	_asm
//	{
//		push	ax
//		mov		ax,[bp+2]
//		mov 	TempIP,ax
//		pop		ax
//	}

#ifdef _M_ALPHA
	va_list valDummy;
	ZeroMemory(&valDummy, sizeof(valDummy));

	va_start (valDummy,zMsgFmt);
	wvsprintf (MsgBuf, zMsgFmt, valDummy);
	va_end  (valDummy);
#else  // _M_ALPHA
	wvsprintf (MsgBuf, zMsgFmt, (va_list) (&zMsgFmt + 1));
#endif // _M_ALPHA

	ISR_HookDbgStrStr(TempIP, hISRInst, DbgLevel, MsgBuf, 0);
}


//------------------------------------------------------------------------------
//	ISR_OutputDbgStr ()
//		Store a string to be displayed at task time.
//		The passed in string will be copied to a local storage.
//		Therefore the caller can reuse on return.
//------------------------------------------------------------------------------
ISR_DLL void WINAPI DLL_EXPORT
ISR_OutputDbgStr (LPSTR pzStr)
{
	WORD		TempIP = 0;


//	_asm
//	{
//		push	ax
//		mov		ax,[bp+2]
//		mov		TempIP,ax
//		pop		ax
//	}
	
	ISR_HookDbgStrStr(TempIP, gpDS->ghDefaultModule, kISRDefault, pzStr, 0);
}


//------------------------------------------------------------------------------
//	ISR_OutputStr ()
//		Store a string resource Id to be displayed at task time.
//------------------------------------------------------------------------------
ISR_DLL void WINAPI DLL_EXPORT
ISR_OutputStr (UINT uResId)
{
	UINT		TempIP = 0;


//	_asm
//	{
//		push	ax
//		mov		ax,[bp+2]
//		mov		TempIP,ax
//		pop		ax
//	}
	ISR_HookDbgRes(TempIP, gpDS->ghDefaultModule, kISRDefault, uResId, 0);
}


//------------------------------------------------------------------------------
//	ISR_OutputNum ()
//		Store a string resource Id to be displayed at task time.
//		In addition store a number to be displayed in printf format of the
//		string.
//------------------------------------------------------------------------------
ISR_DLL void WINAPI DLL_EXPORT
ISR_OutputNum (UINT uResId, DWORD Num)
{
	WORD		TempIP = 0;


//	_asm
//	{
//		push	ax
//		mov		ax,[bp+2]
//		mov		TempIP,ax
//		pop		ax
//	}
	ISR_HookDbgRes(TempIP, gpDS->ghDefaultModule, kISRDefault, uResId, Num);
}


//------------------------------------------------------------------------------
//	DbgMsg ()
//		Canned Debug format that may be useful.  This function has nothen
//		to do with Interrupt time display.  However it keeps all the
//		display info in one place.  Basically it is convenient.
//
//		WARNING: Do not call this at interrupt time.  wsprintf is not reentrant.
//------------------------------------------------------------------------------
ISR_DLL void FAR cdecl DLL_EXPORT
DbgMsg
	(
	LPCSTR		module,
	int			state,
	LPCSTR		format_str,
	...
	)
{
	WORD		TempIP = 0;
	char		MsgBuf[256];
	va_list valDummy;


//	_asm
//	{
//		push	ax
//		mov		ax,[bp+2]
//		mov		TempIP,ax
//		pop		ax
//	}

	wsprintf (MsgBuf, ">--<%s> %s", module,
			(LPSTR) ((state == ISR_DBG) ? "debug : " : "ERROR : "));


#ifdef _M_ALPHA
	ZeroMemory(&valDummy, sizeof(valDummy));

	va_start (valDummy,format_str);
	wvsprintf ((LPSTR) (MsgBuf + lstrlen (MsgBuf)), format_str,valDummy);
	va_end  (valDummy);
#else  // _M_ALPHA
	wvsprintf ((LPSTR) (MsgBuf + lstrlen (MsgBuf)), format_str,
			(va_list) (&format_str + 1));

#endif // _M_ALPHA


	ISR_HookDbgStrStr(TempIP, gpDS->ghDefaultModule, kISRDefault, MsgBuf, 0);

//	lstrcat (MsgBuf, "\n");

//	OutputDebugString (MsgBuf);
}


//------------------------------------------------------------------------------
//	ISR_ClearItems ()
//		Clear the list of debug msgs.
//------------------------------------------------------------------------------
ISR_DLL void WINAPI DLL_EXPORT
ISR_ClearItems (void)
{
	// Protect against reentrancy.  Just drop the msg if reentered.
	if (WAIT_OBJECT_0 != WaitForSingleObject(gSemaphore,100))
		return;

	// This is not a serious race condition.  Must likely failure
	// is what messages get dropped.
	gpDS->guNumItems = 0;
	gpDS->gStrTabOfs = 0;

	ReleaseSemaphore(gSemaphore,1,NULL);
}


//------------------------------------------------------------------------------
//	ISR_GetNumItems ()
//		Return the number of items that have be entered.
//------------------------------------------------------------------------------
ISR_DLL UINT WINAPI DLL_EXPORT
ISR_GetNumItems (void)
{
	return gpDS->guNumItems;
}
//------------------------------------------------------------------------------
//	ISR_GetNumModules ()
//		Return the number of modules that have be entered.
//------------------------------------------------------------------------------
ISR_DLL UINT WINAPI DLL_EXPORT
ISR_GetNumModules (void)
{
	return gpDS->guNumModules;
}


//------------------------------------------------------------------------------
//	ISR_GetItemInternal
//		Return a pointer to the record num uItem.  Only reason to
//		do it this way is to hide the buf struct.  This way I can use a
//		heap manager such as BigMem or SmartHeap or NT HeapAlloc.
//		The items are numbered 0..n-1.
//		Alternatively a Ptr to the array of records could be passed back.
//------------------------------------------------------------------------------
ptISRItem WINAPI
ISR_GetItemInternal (UINT uItem)
{
	if (kMaxISRItems <= uItem)
	{
		return NULL;
	}

	return &gpDbgTable[uItem];
}


//------------------------------------------------------------------------------
//	ISR_GetItem
//		Return a pointer to the record num uItem.  Only reason to
//		do it this way is to hide the buf struct.  This way I can use a
//		heap manager such as BigMem or SmartHeap or NT HeapAlloc.
//		The items are numbered 0..n-1.
//		Alternatively a Ptr to the array of records could be passed back.
//------------------------------------------------------------------------------
ISR_DLL ptISRItem WINAPI DLL_EXPORT
ISR_GetItem (UINT uItem,ptISRItem pItem)
{
	ptISRItem		pISRItem;

	if (!pItem)
	{
		return NULL;
	}

	pISRItem = ISR_GetItemInternal(uItem);
	if (!pISRItem)
	{
		return NULL;
	}

	memcpy(pItem,pISRItem,sizeof(tISRItem));
	if (pISRItem->Flags & kParam1IsStr)
	{
		// This memory is shared so therefore need to make a copy for upper layers
		// Ptr within the struct are offsets so now need to be ptrs again.
		// Each instance of DLL in Win32 has its own memory map
		pItem->Param1 += (DWORD_PTR)gpzStrTab;
	}

	return pItem;
}


//------------------------------------------------------------------------------
//	ISR_RegisterModule
//		Register a name to be associated with related debug strings.
//		The debug display code can then present this information to the user
//		to determine how to filter the data.
//
//	Params:
//		zShortName	- name to display when space is critical.
//		zLongName	- name to display when a complete description is needed.
//
//	Returns:
//		on error zero for the compatible handle.
//		a handle to be used when making all other debug output calls.
//------------------------------------------------------------------------------
ISR_DLL void WINAPI DLL_EXPORT
ISR_RegisterModule (LPWORD phISRInst, LPSTR pzShortName, LPSTR pzLongName)
{
	ptISRModule		pMod;
	UINT			hMod;

	if (!phISRInst)
		return;

	*phISRInst = 0;

	if (kMaxModules <= gpDS->guNumModules)
	{
		// We are out of handles.
		// Return the default handle and drop the name info.
		return;
	}

	// Check if this module label was used before.  If it has then just reuse it.
	// This case will most likely happen when the module is loaded, unloaded,
	// and then reloaded.  Another case is when the same name is used in two
	// different instances.  This would be a confusing programmer oversight
	// and that his problem.
	for (hMod = 0; hMod < kMaxModules; hMod++)
	{
		// if no name then we cannot group very well.
		// In this case waste another handle.
		if (!pzShortName || (0 == *pzShortName))
			break;
		
		pMod = ISR_GetModule(hMod);
		if (!pMod)
			break;

		if ( !_strnicmp(pzShortName,pMod->zSName,sizeof(pMod->zSName)-1) )
		{
			// It matched so just reuse it.
			*phISRInst = (WORD)hMod;
			return;
		}
	}


	*phISRInst = gpDS->guNumModules++;

	pMod = ISR_GetModule(*phISRInst);
	if (!pMod)
		return;

	if (pzShortName)
		strncpy(pMod->zSName,pzShortName,sizeof(pMod->zSName));
	pMod->zSName[sizeof(pMod->zSName)-1] = 0;
	if (pzLongName)
		strncpy(pMod->zLName,pzLongName,sizeof(pMod->zLName));
	pMod->zLName[sizeof(pMod->zLName)-1] = 0;

	return;
}


//------------------------------------------------------------------------------
//	ISR_GetModule
//		Return a pointer to the module record.  Only reason to
//		do it this way is to hide the buf struct.  This way I can use a
//		heap manager such as BigMem or SmartHeap or NT HeapAlloc.
//		Alternatively a Ptr to the array of records could be passed back.
//------------------------------------------------------------------------------
ISR_DLL ptISRModule WINAPI DLL_EXPORT
ISR_GetModule (UINT hISRInst)
{
	if (kMaxModules <= hISRInst)
	{
		return NULL;
	}

	return(&gpModuleTable[hISRInst]);
}


//------------------------------------------------------------------------------
//	ISR_SetCaptureFilter
//		Debug Messages for a given module can be dropped based on a low/high
//		filter.  If the entire module is not wanted then call with
//		LoFilter = 255, and HiFilter = 0.
//
//------------------------------------------------------------------------------
ISR_DLL int WINAPI DLL_EXPORT
ISR_SetCaptureFilter (WORD hISRInst, BYTE CaptureFilter,  BYTE DisplayFilter)
{
	ptISRModule		pMod;


	pMod = ISR_GetModule(hISRInst);
	if (!pMod)
		return -1;

	pMod->CaptureFilter = CaptureFilter;
	pMod->DisplayFilter = DisplayFilter;

	return 0;
}


/***************************************************************************
	LibMain()
		DLL entry point

	Parameters
		hDllInstance	= instance handle of the DLL (NOT our caller!)
		wDataSegment	= our DS
		wHeapSize		= size of our heap in DS (see .def)
		lpzCmdLine		= argv passed to application (our caller)

	Returns
		TRUE iff we were able to register our window class


	Side Effects
		- Unlocks our data segment (which is really a NOP for protect mode)
	
****************************************************************************/
extern BOOL WINAPI
DllMain
	(
    HINSTANCE	hDllInstance,
	DWORD		dwReason,
	PVOID		pReserved
	)
{
	switch (dwReason)
	{
		case DLL_PROCESS_ATTACH:
		{
			// Called for each exe binding.  Each time a exe binds a different hDllInstance will
			// be passed in.  Also our global data will be unique for each Process binding.
			ghAppInstance = hDllInstance;

			// Create a named file mapping object for the base table.
			MapGlobalWin32Memory(&gpDS,&ghDS,sizeof(tDS),"ISRDBG_DS");
			MapGlobalWin32Memory(&gpModuleTable,&ghModuleTable,sizeof(tISRModule) * kMaxModules,"ISRDBG_ModuleTable");
			MapGlobalWin32Memory(&gpDbgTable,&ghDbgTable,sizeof(tISRItem) * kMaxISRItems,"ISRDBG_DbgTable");
			MapGlobalWin32Memory(&gpzStrTab,&ghzStrTab,kMaxStrTab,"ISRDBG_StrTab");
			if (!gpDS || !gpModuleTable || !gpDbgTable || !gpzStrTab)
			{
				return FALSE;
			}

			gSemaphore = CreateSemaphore(NULL,1,1,NULL);

			if (!gpDS->uBindCount++)
			{
				// Set the filters before any output.
				InitModules();

				// Reserve the default module.
				ISR_RegisterModule(&gpDS->ghDefaultModule, "Default", "<ISRDBG><Default Module>");
				ISR_DbgStrStr(gpDS->ghDefaultModule, kISRDefault, "<ISRDBG><DllMain>", "Win32 x1.00");
				ISR_DbgStrStr(gpDS->ghDefaultModule, kISRDefault, "<ISRDBG><DllMain>", "Line 2 test");
			}
			break;
		}
		case DLL_THREAD_ATTACH:
		{
			break;
		}

		case DLL_THREAD_DETACH:
		{
			break;
		}

		case DLL_PROCESS_DETACH:
		{
		    if (gSemaphore)
            {
                CloseHandle(gSemaphore);
                gSemaphore = 0;
            }

			// The DLL is detaching from a process due to
			// process termination or a call to FreeLibrary.
			FreeGlobalWin32Memory(gpDS,ghDS);
			FreeGlobalWin32Memory(gpModuleTable,ghModuleTable);
			FreeGlobalWin32Memory(gpDbgTable,ghDbgTable);
			FreeGlobalWin32Memory(gpzStrTab,ghzStrTab);

			break;
		}
 	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\acmfilter.cpp ===
#include "precomp.h"
#include "AcmFilter.h"

AcmFilter::AcmFilter() :
m_bOpened(FALSE),
m_hStream(NULL),
m_dwConvertFlags(0),
m_pWfSrc(NULL),
m_pWfDst(NULL)
{
	return;
};

AcmFilter::~AcmFilter()
{
	Close();
}


MMRESULT AcmFilter::Open(WAVEFORMATEX *pWaveFormatSrc, WAVEFORMATEX *pWaveFormatDst)
{
	const int nMaxExtra = WF_EXTRASIZE;
	int nExtra;
	DWORD dwOpenFlags=0;
	MMRESULT mmr;
	int nAllocAmount = sizeof(WAVEFORMATEX)+nMaxExtra;

	// just in case we are already opened in some other context
	Close();


	m_pWfSrc = (WAVEFORMATEX *)MEMALLOC(nAllocAmount);
	m_pWfDst = (WAVEFORMATEX *)MEMALLOC(nAllocAmount);

	CopyMemory(m_pWfSrc, pWaveFormatSrc, sizeof(WAVEFORMATEX));
	CopyMemory(m_pWfDst, pWaveFormatDst, sizeof(WAVEFORMATEX));

	nExtra = m_pWfSrc->cbSize;
	if (nExtra > nMaxExtra)
		nExtra = nMaxExtra;
	CopyMemory((BYTE*)m_pWfSrc+sizeof(WAVEFORMATEX), (BYTE*)pWaveFormatSrc + sizeof(WAVEFORMATEX), nExtra);

	nExtra = m_pWfDst->cbSize;
	if (nExtra > nMaxExtra)
		nExtra = nMaxExtra;
	CopyMemory((BYTE*)m_pWfDst+sizeof(WAVEFORMATEX), (BYTE*)pWaveFormatDst + sizeof(WAVEFORMATEX), nExtra);

	// now handle all the special conditions for licensed codecs
	// and their individual properties
	FixHeader(m_pWfSrc);
	FixHeader(m_pWfDst);

	GetFlags(m_pWfSrc, m_pWfDst, &dwOpenFlags, &m_dwConvertFlags);

	mmr = acmStreamOpen(&m_hStream, NULL, m_pWfSrc, m_pWfDst, NULL,
	                    0, // no callback
	                    0, // no instance data
	                    dwOpenFlags);

	m_bOpened = (mmr == 0);

#ifdef _DEBUG
	if (m_pWfSrc->wFormatTag == WAVE_FORMAT_PCM)
	{
		DEBUGMSG (1, ("acmStreamOpen: Opened %.6s compression stream\r\n", (m_pWfDst->wFormatTag == 66) ? "G723.1" : (m_pWfDst->wFormatTag == 112) ? "LHCELP" : (m_pWfDst->wFormatTag == 113) ? "LHSB08" : (m_pWfDst->wFormatTag == 114) ? "LHSB12" : (m_pWfDst->wFormatTag == 115) ? "LHSB16" : (m_pWfDst->wFormatTag == 6) ? "MSALAW" : (m_pWfDst->wFormatTag == 7) ? "MSULAW" : (m_pWfDst->wFormatTag == 130) ? "MSRT24" : "??????"));
	}
	else
	{
		DEBUGMSG (1, ("acmStreamOpen: Opened %.6s decompression stream\r\n", (m_pWfSrc->wFormatTag == 66) ? "G723.1" : (m_pWfSrc->wFormatTag == 112) ? "LHCELP" : (m_pWfSrc->wFormatTag == 113) ? "LHSB08" : (m_pWfSrc->wFormatTag == 114) ? "LHSB12" : (m_pWfSrc->wFormatTag == 115) ? "LHSB16" : (m_pWfSrc->wFormatTag == 6) ? "MSALAW" : (m_pWfSrc->wFormatTag == 7) ? "MSULAW" : (m_pWfSrc->wFormatTag == 130) ? "MSRT24" : "??????"));
	}
#endif

	// post opening messages for L&H codecs
	NotifyCodec();

#ifdef DEBUG
	if (mmr != 0)
	{
		DEBUGMSG(ZONE_ACM, ("acmStreamOpen failure: mmr = %d\r\n", mmr));
	}
#endif


	return mmr;
}


MMRESULT AcmFilter::Close()
{
	if (m_bOpened)
	{
		acmStreamClose(m_hStream, 0);
		m_hStream = NULL;
	}

	m_bOpened = FALSE;
	if (m_pWfSrc)
	{
		MEMFREE(m_pWfSrc);
		m_pWfSrc = NULL;
	}

	if (m_pWfDst)
	{
		MEMFREE(m_pWfDst);
		m_pWfDst = NULL;
	}


	return 0;

}


MMRESULT AcmFilter::PrepareHeader(ACMSTREAMHEADER *pHdr)
{
	MMRESULT mmr;

	if (m_bOpened == FALSE)
	{
		return MMSYSERR_INVALHANDLE;
	}

	mmr = acmStreamPrepareHeader(m_hStream, pHdr, 0);

	return mmr;

}


MMRESULT AcmFilter::UnPrepareHeader(ACMSTREAMHEADER *pHdr)
{
	MMRESULT mmr;
	if (m_bOpened == FALSE)
	{
		return MMSYSERR_INVALHANDLE;
	}

	mmr = acmStreamUnprepareHeader(m_hStream, pHdr, 0);

	return mmr;
}



MMRESULT AcmFilter::PrepareAudioPackets(AudioPacket **ppAudPacket, UINT uPackets, UINT uDirection)
{
	MMRESULT mmr;
	ACMSTREAMHEADER *pAcmHeader;
	UINT uIndex;
	UINT uSizeRaw, uSizeNet;
    DWORD_PTR dwPropVal;
	DWORD dwSizeNetMax;
	BYTE *pRaw, *pNet;

	if (m_bOpened == FALSE)
	{
		return MMSYSERR_INVALHANDLE;
	}

	for (uIndex = 0; uIndex < uPackets; uIndex++)
	{
		pAcmHeader = (ACMSTREAMHEADER*)(ppAudPacket[uIndex]->GetConversionHeader());

		ASSERT(pAcmHeader);
		
		ppAudPacket[uIndex]->GetDevData((PVOID*)&pRaw, &uSizeRaw);
		ppAudPacket[uIndex]->GetNetData((PVOID*)&pNet, &uSizeNet);
		ppAudPacket[uIndex]->GetProp(MP_PROP_MAX_NET_LENGTH, &dwPropVal);
        dwSizeNetMax = (DWORD)dwPropVal;

		ZeroMemory(pAcmHeader, sizeof(ACMSTREAMHEADER));
		pAcmHeader->cbStruct = sizeof(ACMSTREAMHEADER);

		if (uDirection == AP_ENCODE)
		{
			pAcmHeader->pbSrc = pRaw;
			pAcmHeader->cbSrcLength = uSizeRaw;

			pAcmHeader->pbDst = pNet;
			pAcmHeader->cbDstLength = uSizeNet;
		}
		else
		{
			pAcmHeader->pbSrc = pNet;
			pAcmHeader->cbSrcLength = dwSizeNetMax;

			pAcmHeader->pbDst = pRaw;
			pAcmHeader->cbDstLength = uSizeRaw;
		}
		
		mmr = PrepareHeader(pAcmHeader);
		if (mmr != MMSYSERR_NOERROR)
		{
			return mmr;
		}

	}

	return mmr;
}

MMRESULT AcmFilter::UnPrepareAudioPackets(AudioPacket **ppAudPacket, UINT uPackets, UINT uDirection)
{
	MMRESULT mmr;
	ACMSTREAMHEADER *pAcmHeader;
	UINT uIndex;
    DWORD_PTR dwPropVal;
	DWORD dwSizeNetMax;
	BYTE *pRaw, *pNet;

	if (m_bOpened == FALSE)
	{
		return MMSYSERR_INVALHANDLE;
	}

	for (uIndex = 0; uIndex < uPackets; uIndex++)
	{
		pAcmHeader = (ACMSTREAMHEADER*)(ppAudPacket[uIndex]->GetConversionHeader());

		ASSERT(pAcmHeader);
		
		ppAudPacket[uIndex]->GetProp(MP_PROP_MAX_NET_LENGTH, &dwPropVal);
        dwSizeNetMax = (DWORD)dwPropVal;

		if (uDirection == AP_DECODE)
		{
			pAcmHeader->cbSrcLength = dwSizeNetMax;
		}
		
		mmr = UnPrepareHeader(pAcmHeader);  // ignore errors
		ZeroMemory(pAcmHeader, sizeof(ACMSTREAMHEADER));
	}

	return mmr;
}



MMRESULT AcmFilter::Convert(BYTE *srcBuffer, UINT *pcbSizeSrc, UINT cbSizeSrcMax, BYTE *destBuffer, UINT *pcbSizeDest)
{
	ACMSTREAMHEADER acmHeader;
	MMRESULT mmr;

	if (m_bOpened == FALSE)
	{
		return MMSYSERR_INVALHANDLE;
	}

	ASSERT((*pcbSizeSrc) <= cbSizeSrcMax);

	ZeroMemory(&acmHeader, sizeof(ACMSTREAMHEADER));

	acmHeader.cbStruct = sizeof(ACMSTREAMHEADER);

	acmHeader.pbSrc = srcBuffer;
	acmHeader.cbSrcLength = cbSizeSrcMax;

	acmHeader.pbDst = destBuffer;
	acmHeader.cbDstLength = *pcbSizeDest;

	mmr = PrepareHeader(&acmHeader);
	if (mmr != 0)
	{
		return mmr;
	}

	acmHeader.cbSrcLength = *pcbSizeSrc;

	mmr = Convert(&acmHeader);

	*pcbSizeSrc = acmHeader.cbSrcLengthUsed;
	*pcbSizeDest = acmHeader.cbDstLengthUsed;

	acmHeader.cbSrcLength = cbSizeSrcMax;  // makes ACM happy
	UnPrepareHeader(&acmHeader);

	return mmr;

}


MMRESULT AcmFilter::Convert(ACMSTREAMHEADER *pAcmHdr)
{
	MMRESULT mmr;

	if (m_bOpened == FALSE)
	{
		return MMSYSERR_INVALHANDLE;
	}

	mmr = acmStreamConvert(m_hStream, pAcmHdr, m_dwConvertFlags);


#ifdef DEBUG
	if (mmr != 0)
	{
		DEBUGMSG(ZONE_ACM, ("acmStreamConvert failed (mmr = %d)\r\n", mmr));
	}
#endif


	return mmr;

}


MMRESULT AcmFilter::Convert(AudioPacket *pAP, UINT uDirection)
{
	MMRESULT mmr=MMSYSERR_INVALPARAM;

	BYTE *pRaw, *pNet;
	UINT uSizeRaw, uSizeNet;
	DWORD dwSizeNetMax;
	ACMSTREAMHEADER *pAcmHeader;


	if (m_bOpened == FALSE)
	{
		return MMSYSERR_INVALHANDLE;
	}

	pAcmHeader = (ACMSTREAMHEADER*)(pAP->GetConversionHeader());

	ASSERT(pAcmHeader);

	if (uDirection == AP_ENCODE)
	{
		mmr = Convert(pAcmHeader);
		pAP->SetNetLength(pAcmHeader->cbDstLengthUsed);
	}

	else if (uDirection == AP_DECODE)
	{
		pAP->GetNetData((PVOID*)&pNet, &uSizeNet);
		pAcmHeader->cbSrcLength = uSizeNet;
		mmr = Convert(pAcmHeader);
		pAP->SetRawActual(pAcmHeader->cbDstLengthUsed);
	}

	return mmr;
}



// primarily for putting code licensing codes into header
int AcmFilter::FixHeader(WAVEFORMATEX *pWF)
{
	switch (pWF->wFormatTag)
	{
		case WAVE_FORMAT_PCM:
			break;

		case WAVE_FORMAT_MSG723:
		{
			ASSERT(pWF->cbSize == 10);
			((MSG723WAVEFORMAT *) pWF)->dwCodeword1 = G723MAGICWORD1;
			((MSG723WAVEFORMAT *) pWF)->dwCodeword2 = G723MAGICWORD2;
			break;
		}

		case WAVE_FORMAT_MSRT24:
		{
			// assume call control will take care of the other
			// params ?
			ASSERT(pWF->cbSize == 80);
			lstrcpy(((VOXACM_WAVEFORMATEX *) pWF)->szKey, VOXWARE_KEY);
			break;
		}
	}

	return 0;

}


int AcmFilter::GetFlags(WAVEFORMATEX *pWfSrc, WAVEFORMATEX *pWfDst, DWORD *pDwOpen, DWORD *pDwConvert)
{
	*pDwOpen = 0;
	*pDwConvert = ACM_STREAMCONVERTF_START | ACM_STREAMCONVERTF_END;

	if (  (pWfSrc->wFormatTag == WAVE_FORMAT_GSM610) ||
	      (pWfDst->wFormatTag == WAVE_FORMAT_GSM610))
	{
		*pDwOpen |= ACM_STREAMOPENF_NONREALTIME;
	}

	return 0;
}

int AcmFilter::NotifyCodec()
{

	if (m_bOpened == FALSE)
		return -1;

	switch	(m_pWfSrc->wFormatTag)
	{
		case WAVE_FORMAT_LH_SB8:
		case WAVE_FORMAT_LH_SB12:
		case WAVE_FORMAT_LH_SB16:
			acmStreamMessage ((HACMSTREAM) m_hStream, ACMDM_LH_DATA_PACKAGING,
		                       LH_PACKET_DATA_FRAMED, 0);
		break;
	}

	return 0;

}


// pWfSrc is a compressed format
// pWfDst is an uncompressed PCM format
MMRESULT AcmFilter::SuggestDecodeFormat(WAVEFORMATEX *pWfSrc, WAVEFORMATEX *pWfDst)
{
	MMRESULT mmr;

	ZeroMemory(pWfDst, sizeof(WAVEFORMATEX));
	pWfDst->nSamplesPerSec = pWfSrc->nSamplesPerSec;
	pWfDst->wFormatTag = WAVE_FORMAT_PCM;
	pWfDst->nChannels = pWfSrc->nChannels;

	mmr = acmFormatSuggest(NULL, pWfSrc, pWfDst, sizeof(WAVEFORMATEX),
			ACM_FORMATSUGGESTF_NCHANNELS | ACM_FORMATSUGGESTF_NSAMPLESPERSEC
			| ACM_FORMATSUGGESTF_WFORMATTAG);


#ifdef DEBUG
	if (mmr != 0)
	{
		DEBUGMSG(ZONE_ACM, ("acmFormatSuggest failed (mmr == %d)\r\n", mmr));
	}
	else
	{
		DEBUGMSG(ZONE_ACM,
		         ("acmFormatSuggest: wFormat = %d  nChannels = %d  nSamplesPerSec = %d  wBitsPerSample = %d\r\n",
				   pWfDst->wFormatTag, pWfDst->nChannels, pWfDst->nSamplesPerSec, pWfDst->wBitsPerSample));
	}
#endif


	return mmr;
}

MMRESULT AcmFilter::SuggestSrcSize(DWORD dwDestSize, DWORD *p_dwSuggestedSourceSize)
{
	MMRESULT mmr;

	if (m_bOpened == FALSE)
	{
		return MMSYSERR_INVALHANDLE;
	}

	// 4th param specifies type of 2nd parameter
	mmr = acmStreamSize(m_hStream, dwDestSize, p_dwSuggestedSourceSize, ACM_STREAMSIZEF_DESTINATION);

	return mmr;
}



MMRESULT AcmFilter::SuggestDstSize(DWORD dwSourceSize, DWORD *p_dwSuggestedDstSize)
{
	MMRESULT mmr;

	if (m_bOpened == FALSE)
	{
		return MMSYSERR_INVALHANDLE;
	}

	// 4th param specifies type of 2nd parameter
	mmr = acmStreamSize(m_hStream, dwSourceSize, p_dwSuggestedDstSize, ACM_STREAMSIZEF_SOURCE);

	return mmr;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\intelcc\isrdbg32\isrdbg32.h ===
/****************************************************************************

	INTEL CORPORATION PROPRIETARY INFORMATION
	Copyright (c) 1992 Intel Corporation
	All Rights Reserved

	This software is supplied under the terms of a license
	agreement or non-disclosure agreement with Intel Corporation
	and may not be copied or disclosed except in accordance
	with the terms of that agreement

    $Source: q:/prism/network/isrdbg/rcs/isrdbgp.h $
  $Revision:   1.0  $
      $Date:   Feb 05 1996 16:27:28  $
    $Author:   DMGORLIC  $
    $Locker:  $

	Description
	-----------
	Interrupt Service Routine debug header file
	This module allows for a way of doing OutputDebugString()
	at interrupt time.


****************************************************************************/


//--------------------------------------------------------------------------
// Function prototypes
//--------------------------------------------------------------------------
// Exported protos are in isrg.h

//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\acmfilter.h ===
#ifndef ACM_FILTER_H
#define ACM_FILTER_H

#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>

// this is where are the WAVE_FORMAT_XXX defs live
#include <auformats.h>



// max number of bytes that may appear at the end of 
// a WAVEFORMATEX structure (e.g. VoxWare key)
#define WF_EXTRASIZE	80

#ifndef G723MAGICWORD1
#define G723MAGICWORD1 0xf7329ace
#endif

#ifndef G723MAGICWORD2
#define G723MAGICWORD2 0xacdeaea2
#endif



#ifndef VOXWARE_KEY
#define VOXWARE_KEY "35243410-F7340C0668-CD78867B74DAD857-AC71429AD8CAFCB5-E4E1A99E7FFD-371"
#endif


#define AP_ENCODE	1
#define AP_DECODE	2


class AcmFilter
{
public:
	AcmFilter();
	~AcmFilter();


	MMRESULT Open(WAVEFORMATEX *pWaveFormatSource, WAVEFORMATEX *pWaveFormatDest);


	// normally, you shouldn't have to worry about calling these
	// methods unless you pass an ACMSTREAMHEADER directly into Convert
	MMRESULT PrepareHeader(ACMSTREAMHEADER *pHdr);
	MMRESULT UnPrepareHeader(ACMSTREAMHEADER *pHdr);

	MMRESULT PrepareAudioPackets(AudioPacket **ppAudPacket, UINT uPackets, UINT uDirection);
	MMRESULT UnPrepareAudioPackets(AudioPacket **ppAudPacket, UINT uPackets, UINT uDirection);


	// pcbSizeSrc and pcbSizeDst are in/out params
	// specify size of buffers before compression and return
	// the amount of data used after compressioin
	// for most codecs: cbSizeSrcMax == cbSizeSrc unless the decode
	// operation support variable bit rates such as G723.1.  In this
	// case cbSizeSrcMax >= cbSizeSrc
	MMRESULT Convert(BYTE *srcBuffer, UINT *pcbSizeSrc, UINT cbSizeSrcMax,
	                 BYTE *destBuffer, UINT *pcbSizeDest);

	// make sure you sequence this particular call between PrepareHeader
	// and UnPrepareHeader
	MMRESULT Convert(ACMSTREAMHEADER *pHdr);

	MMRESULT Convert(AudioPacket *pAP, UINT uDirection);
	MMRESULT Close();

	MMRESULT SuggestSrcSize(DWORD dwDestSize, DWORD *p_dwSuggestedSourceSize);
	MMRESULT SuggestDstSize(DWORD dwSourceSize, DWORD *p_dwSuggestedDstSize);

	static MMRESULT SuggestDecodeFormat(WAVEFORMATEX *pWfSrc, WAVEFORMATEX *pWfDst);
	


private:
	BOOL m_bOpened;
	HACMSTREAM m_hStream;
	DWORD m_dwConvertFlags;

	WAVEFORMATEX *m_pWfSrc;
	WAVEFORMATEX *m_pWfDst;

	static int FixHeader(WAVEFORMATEX *pWF);
	static int GetFlags(WAVEFORMATEX *pWfSrc, WAVEFORMATEX *pWfDst, DWORD *pDwOpen, DWORD *pDwConvert);


	int NotifyCodec();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\acmcaps.cpp ===
/*
 *  	File: acmcaps.cpp
 *
 *		Base ACM implementation of Microsoft Network Audio capability object.
 *
 *		Revision History:
 *
 *		12/20/95	mikev	created
 *		06/11/96	mikev	separated protocol implementation specifics into
 *							msiacaps.cpp (the original proprietary version) and
 *							acmh323.cpp (H.323/H.245 implementation)
 */

#include "precomp.h"


LPACMFORMATTAGDETAILS paftd_g;
ACMDRIVERDETAILS *padd;
ACMDRIVERDETAILS add;
static UINT uMaxFormatSize =0;
	
LPWAVEFORMATEX lpScratchFormat;

//Variables imported from msiacaps.cpp.
//uDefTableEntries is the count of default entries
//and default_id_table is the table itself
extern UINT uDefTableEntries;
extern AUDCAP_DETAILS default_id_table[];

BOOL __stdcall DriverEnumCallback(HACMDRIVERID hadid,
    DWORD_PTR dwInstance, DWORD fdwSupport);
BOOL __stdcall ACMFormatTagEnumCallback(HACMDRIVERID hadid,
    LPACMFORMATTAGDETAILS paftd, DWORD_PTR dwInstance, DWORD fdwSupport);
BOOL __stdcall FormatEnumCallback(HACMDRIVERID hadid,
    LPACMFORMATDETAILS pafd, DWORD_PTR dwInstance, DWORD fdwSupport);

CAcmCapability::CAcmCapability()
{
	hAcmDriver = NULL;
}

CAcmCapability::~CAcmCapability()
{
	CloseACMDriver();
}


BOOL CAcmCapability::OpenACMDriver(HACMDRIVERID hadid)
{
	MMRESULT mResult;
	// clear any previous open
	CloseACMDriver();
	// do it
	mResult = acmDriverOpen(&hAcmDriver, hadid, 0);
	if(mResult != MMSYSERR_NOERROR)
   	{
		return FALSE;
   	}
   	return TRUE;
}

VOID CAcmCapability:: CloseACMDriver()
{
	if(hAcmDriver)
	{
		acmDriverClose(hAcmDriver, 0);
		hAcmDriver = NULL;
	}
}


//
//	DriverEnum() is the root level enumeration of ACM formats. Each permutation of
//  format tag, bits per sample, and sample rate is considered a unique format
//  and will have a unique registry entry if it is "enabled" for internet audio
//

//
// acmDriverEnum() calls DriverEnumCallback() which calls acmFormatTagEnum()
// which calls FormatTagEnumCallback() which calls acmFormatEnum() which
// calls FormatEnumCallback().
//

BOOL CAcmCapability::DriverEnum(DWORD_PTR pAppParam)
{
	MMRESULT mResult;

	if(!GetFormatBuffer())
	{
		return FALSE;
	}

    mResult = acmDriverEnum(DriverEnumCallback, pAppParam, NULL);

	if(lpScratchFormat) {
	   MEMFREE(lpScratchFormat);
	   lpScratchFormat=NULL;
	}

	if(mResult != MMSYSERR_NOERROR)
   	{
		return FALSE;
   	}
	return TRUE;
}

// default implementation of FormatEnumHandler does nothing
BOOL  CAcmCapability::FormatEnumHandler(HACMDRIVERID hadid,
	    LPACMFORMATDETAILS pafd, DWORD_PTR dwInstance, DWORD fdwSupport)
{
	return FALSE;
}

BOOL __stdcall DriverEnumCallback(HACMDRIVERID hadid,
    DWORD_PTR dwInstance, DWORD fdwSupport)
{
	MMRESULT mResult;
	PACM_APP_PARAM pAppParam = (PACM_APP_PARAM) dwInstance;
	CAcmCapability *pCapObject = pAppParam->pCapObject;

	ACMFORMATTAGDETAILS aftd;
	
	// not interested unless it's a codec driver
	if(!(fdwSupport & ACMDRIVERDETAILS_SUPPORTF_CODEC))
		return TRUE;	// continue enumeration

	add.cbStruct = sizeof(add);
	aftd.cbStruct = sizeof(ACMFORMATTAGDETAILS);
    aftd.dwFormatTagIndex=0;
    aftd.cbFormatSize=0;
    // I do NOT know why, but fdwSupport MUST be initialized to zero before
    // calling acmFormatTagEnum().  (returns MMSYSERR_INVALPARAM otherwise)
   	aftd.fdwSupport = 0;
    aftd.dwFormatTag = WAVE_FORMAT_UNKNOWN;
    aftd.szFormatTag[0]=0;

	// now see what formats this driver supports
	mResult =  acmDriverDetails(hadid, &add, 0);
	if(mResult != MMSYSERR_NOERROR)
   	{
		return TRUE;  //error, but continue enumerating
   	}

   	// set global driver details pointer
   	padd = &add;
   	
	// # of formats are in add.cFormatTags;
	DEBUGMSG(ZONE_ACM,("DriverEnumCallback: driver %s has %d formats\r\n",
		add.szShortName, add.cFormatTags));
		
	aftd.cStandardFormats = add.cFormatTags;

	// open the driver so we can query it for stuff
	//mResult = acmDriverOpen(&had, hadid, 0);
	//if(mResult != MMSYSERR_NOERROR)
	if(!pCapObject->OpenACMDriver(hadid))
   	{
		ERRORMESSAGE(("DriverEnumCallback: driver open failed:0x%08lX\r\n",mResult));
		padd = NULL;
		return TRUE;  //error, but continue enumerating
   	}
   	
	mResult = acmFormatTagEnum(pCapObject->GetDriverHandle(), &aftd,	ACMFormatTagEnumCallback, dwInstance, 0);
	if(mResult != MMSYSERR_NOERROR)
   	{
		ERRORMESSAGE(("DriverEnumCallback: acmFormatTagEnum failed:0x%08lX\r\n",mResult));
	}
	// cleanup
	pCapObject->CloseACMDriver();
	padd = NULL;
	return TRUE;
	
}


BOOL GetFormatBuffer()
{
	// get size of largest WAVEFORMATEX structure in the system
	MMRESULT mResult = acmMetrics(NULL, ACM_METRIC_MAX_SIZE_FORMAT,
		(LPVOID) &uMaxFormatSize);
	if(mResult != MMSYSERR_NOERROR)
	{
		ERRORMESSAGE(("GetFormatBuffer: acmMetrics failed:0x%08lX\r\n",mResult));
		return FALSE;
	}

	// workaround bug in some third party codecs: it has been observed that the
	// Voxware RT-24 codec distributed by Netscape CoolTalk corrupts the heap when
	// the codec is enumerated.  It writes more data to the WAVEFORMATEX that it
	// indicates when metrics are evaluated.  Workaround by allocating twice as much as
	// we think we need.

	lpScratchFormat = (LPWAVEFORMATEX) MEMALLOC(2* uMaxFormatSize);
	if(!lpScratchFormat)
	{
		ERRORMESSAGE(("GetFormatBuffer: allocation failed\r\n"));
		return FALSE;
	}
	ZeroMemory(lpScratchFormat, uMaxFormatSize);
	//Set the size of the extra buffer to maximum possible size...
	lpScratchFormat->cbSize=(WORD)(uMaxFormatSize - sizeof (WAVEFORMATEX));
	return TRUE;
}


//
//	Gets format details (all permutations of formats) for a given format tag that
//	the driver supports
//	

BOOL __stdcall ACMFormatTagEnumCallback(
	HACMDRIVERID hadid,
    LPACMFORMATTAGDETAILS paftd,
    DWORD_PTR dwInstance,
    DWORD fdwSupport)
{
	PACM_APP_PARAM pAppParam = (PACM_APP_PARAM) dwInstance;
	CAcmCapability *pCapObject = pAppParam->pCapObject;
	MMRESULT mResult;
	ACMFORMATDETAILS afd;
	UINT i;

    //Set this first, so that if we are using a default format, we can help the enumerator
    //narrow the field.
	afd.pwfx = lpScratchFormat;

	// if caller wanted to enum ALL formats go right to it (for adding a format)
	if (((pAppParam->dwFlags && ACMAPP_FORMATENUMHANDLER_MASK) != ACMAPP_FORMATENUMHANDLER_ADD) &&
		(pAppParam->pRegCache)) {
        //Do we care about this particular format?
        //rrf_nFormats is the number of formats we read in the
        //registry.
        if (pAppParam->pRegCache->nFormats) {
            for (i=0;i<pAppParam->pRegCache->nFormats;i++) {
                if (((AUDCAP_DETAILS *)pAppParam->pRegCache->pData[i])->wFormatTag == paftd->dwFormatTag){
                    //Add some guesses based on the default information
                    break;
                }
            }

            // i is the index of either the found tag (so we care.) or
            // equal to the # of formats in the cache, which means not
            // found, so check the default list.

            if (i==pAppParam->pRegCache->nFormats) {
                //Check the case that some (but not all) of the default formats are missing.
                for (i=0;i<uDefTableEntries;i++) {
                    if (paftd->dwFormatTag == default_id_table[i].wFormatTag) {
                        break;
                    }
                }
                if (i==uDefTableEntries) {
                    //We don't care about this format, it's not in the cache, or default list
                    return TRUE;
                }
            }
        }
    }
    //We support mono formats
    afd.pwfx->nChannels=1;
	afd.cbStruct = sizeof(afd);
	afd.dwFormatIndex = 0;
	afd.dwFormatTag = paftd->dwFormatTag;
	afd.fdwSupport = 0;
	afd.cbwfx = uMaxFormatSize;
	afd.szFormat[0]=0;
	
	//afd.dwFormatTag = WAVE_FORMAT_UNKNOWN;
	//lpScratchFormat->wFormatTag = WAVE_FORMAT_UNKNOWN;
	lpScratchFormat->wFormatTag = LOWORD(paftd->dwFormatTag);
	
	DEBUGMSG(ZONE_ACM,("ACMFormatTagEnumCallback:dwFormatTag 0x%08lX, cbFormatSize 0x%08lX,\r\n",
		paftd->dwFormatTag, paftd->cbFormatSize));
	DEBUGMSG(ZONE_ACM,("ACMFormatTagEnumCallback:cStandardFormats 0x%08lX, szTag %s,\r\n",
		paftd->cStandardFormats, paftd->szFormatTag));

    paftd_g = paftd;
	// just setting the global paftd_g should be fine, but I'd like to rid of it later
	pAppParam->paftd = paftd;   	

	DEBUGMSG(ZONE_ACM,(""));
	DEBUGMSG(ZONE_ACM,("All %s formats known to ACM", paftd->szFormatTag));
	DEBUGMSG(ZONE_ACM,("====================================="));
	DEBUGMSG(ZONE_ACM,("Tag    Channels SampPerSec AvgBytPerSec Block  BitsPerSample cbSize szFormat"));

	mResult = acmFormatEnum(pCapObject->GetDriverHandle(), &afd,
    	FormatEnumCallback, dwInstance, ACM_FORMATENUMF_WFORMATTAG|ACM_FORMATENUMF_NCHANNELS);
    	
	return TRUE;
}


BOOL __stdcall FormatEnumCallback(HACMDRIVERID hadid,
    LPACMFORMATDETAILS pafd, DWORD_PTR dwInstance, DWORD fdwSupport)
{
	PACM_APP_PARAM pAppParam = (PACM_APP_PARAM) dwInstance;
	CAcmCapability *pCapObject = pAppParam->pCapObject;

	DEBUGMSG(ZONE_ACM,("0x%04x %8d 0x%08lx 0x%010lx 0x%04x 0x%011x 0x%04x %s",
						pafd->pwfx->wFormatTag, pafd->pwfx->nChannels,
						pafd->pwfx->nSamplesPerSec, pafd->pwfx->nAvgBytesPerSec,
						pafd->pwfx->nBlockAlign, pafd->pwfx->wBitsPerSample,
						pafd->pwfx->cbSize,	pafd->szFormat));
	
	return pCapObject->FormatEnumHandler(hadid, pafd, dwInstance, fdwSupport);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\agc.h ===
#ifndef _AGC_H
#define _AGC_H

#include "mixer.h"

#define PEAKARRAYSIZE	5
#define AGC_INCREMENT	10000  // approx 1/6 of the mixer range
#define AGC_MAXVOL	65535   // highest mixer volume setting

#define AGC_HIGHVOL	24576   // minimum for loud volume see Update() method
#define AGC_PEAKVOL 32767   // peak sample value (could also be 32768)

#define AGC_DEFAULT_THRESH	16384


#define AGC_NOUPDATE	0
#define AGC_UPDATE_LOWERVOL	1
#define AGC_UPDATE_RAISEVOL	2

class AGC
{
private:
	CMixerDevice *m_pMixer;

	WORD m_aPeaks[PEAKARRAYSIZE];
	int m_cPeaks;  // how many have been inserted into above array

	WORD m_wCurrentPeak;  // max value of last second
	DWORD m_dwCollectionTime; // amount of sampling collected so far

	WORD m_wThreshStrength;  // the minimum we are trying to target

	DWORD m_dwLastVolumeSetting; // last known volume setting
	int m_nLastUpdateResult;

	inline BOOL RaiseVolume();
	inline BOOL LowerVolume();
	inline BOOL HasVolumeChanged();

public:
	AGC(CMixerDevice *pMixer);
	void SetMixer(CMixerDevice *pMixer);
	inline void SetThresholdStrength(WORD wStrength) {m_wThreshStrength=wStrength;}
	int Update(WORD wPeakStrength, DWORD dwLengthMS);
	void Reset();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\agc.cpp ===
#include "precomp.h"
#include "mixer.h"
#include "agc.h"



// this should be moved to the mixer class - but right
// now we already have two instances of that class (one in NAC, the other in CONF)
static BOOL GetVolume(CMixerDevice *pMixer, DWORD *pdwVol)
{
	DWORD dwSub=0, dwMain=0;
	BOOL fSubAvail, fMainAvail;

	if (pMixer == NULL)
	{
		return FALSE;
	}

	fSubAvail = pMixer->GetSubVolume(&dwSub);
	fMainAvail = pMixer->GetMainVolume(&dwMain);

	if ((!fSubAvail) && (!fMainAvail))
	{
		*pdwVol = 0;
		return FALSE;
	}

	if ((fSubAvail) && (fMainAvail))
	{
		*pdwVol = ((dwSub + dwMain)/2);
	}

	else if (fSubAvail)
	{
		*pdwVol = dwSub;
	}

	else
	{
		*pdwVol = dwMain;
	}

	return TRUE;
}


// check to see if volume has changed since the last update of the mixer
// if so, we update m_dsLastVolumeSetting and return TRUE
BOOL AGC::HasVolumeChanged()
{
	DWORD dwVol;

	if (m_pMixer)
	{
		if (GetVolume(m_pMixer, &dwVol))
		{
			if (dwVol != m_dwLastVolumeSetting)
			{	
				m_dwLastVolumeSetting = dwVol;
				return TRUE;
			}
		}
	}
	return FALSE;
}


// raise the volume my the increment amount
inline BOOL AGC::RaiseVolume()
{
	DWORD dwVol;

	if (m_pMixer)
	{
		if (GetVolume(m_pMixer, &dwVol))
		{
			if (dwVol < (AGC_MAXVOL-AGC_INCREMENT))
			{
				dwVol += AGC_INCREMENT;
			}
			else
			{
				dwVol = AGC_MAXVOL;
			}
			m_pMixer->SetVolume(dwVol);
			GetVolume(m_pMixer, &m_dwLastVolumeSetting);
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}
	return FALSE;
}

// lower the volume by the increment amount
inline BOOL AGC::LowerVolume()
{
	DWORD dwRet;

	if (m_pMixer)
	{
		if (GetVolume(m_pMixer, &dwRet))
		{
			if (dwRet > (AGC_INCREMENT+AGC_INCREMENT/2))
				m_dwLastVolumeSetting = dwRet - AGC_INCREMENT;
			else
				m_dwLastVolumeSetting = AGC_INCREMENT / 2;

			m_pMixer->SetVolume(m_dwLastVolumeSetting);
			GetVolume(m_pMixer, &m_dwLastVolumeSetting);
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}
	return FALSE;
}



AGC::AGC(CMixerDevice *pMixer) :
m_cPeaks(0), m_wCurrentPeak(0),
m_dwCollectionTime(0),
m_pMixer(pMixer),
m_wThreshStrength(AGC_DEFAULT_THRESH),
m_dwLastVolumeSetting(0),
m_nLastUpdateResult(AGC_NOUPDATE)
{;}


// resets all stats inside the AGC control except the mixer object
void AGC::Reset()
{
	m_cPeaks = 0;
	m_wCurrentPeak = 0;
	m_dwCollectionTime = 0;
	m_wThreshStrength = AGC_DEFAULT_THRESH;
	m_dwLastVolumeSetting = 0;
	m_nLastUpdateResult = AGC_NOUPDATE;
}


// initialize the AGC control with an instance of a mixer object
// (you can also set the mixer in the constructor)
void AGC::SetMixer(CMixerDevice *pMixer)
{
	m_pMixer = pMixer;

	if (pMixer)
	{
		GetVolume(pMixer, &m_dwLastVolumeSetting);
		pMixer->SetVolume(m_dwLastVolumeSetting);
	}
}



// call this method for all recorded packets that
// are begin sent. mixer will get raised/lowered as
// appropriate. wPeakStrength can be any WORD that
// represents a volume amount, but is designed to be
// the highest sample value in a packet.
int AGC::Update(WORD wPeakStrength, DWORD dwLengthMS)
{
	int nIndex;
	DWORD dwTotal=0, dwMin=AGC_PEAKVOL, dwMax=0;
	DWORD dwAvg=0;
	BOOL nMaxPeaks=0;

	ASSERT (PEAKARRAYSIZE >= 2);


	if (wPeakStrength > m_wCurrentPeak)
	{
		m_wCurrentPeak = wPeakStrength;
	}

	m_dwCollectionTime += dwLengthMS;

	// have we exceeded one second worth of collections
	if (m_dwCollectionTime > 1000)
	{
		m_aPeaks[m_cPeaks++] = m_wCurrentPeak;
		m_dwCollectionTime = 0;
		m_wCurrentPeak = 0;
	}


	if (m_cPeaks >= 2)
	{
		// compute the average volume and number of clips that occurred
		for (nIndex = 0; nIndex < m_cPeaks; nIndex++)
		{
			dwTotal += m_aPeaks[nIndex];
			if (m_aPeaks[nIndex] < dwMin)
			{
				dwMin = m_aPeaks[nIndex];
			}
			else if (m_aPeaks[nIndex] > dwMax)
			{
				dwMax = m_aPeaks[nIndex];
			}
			if (m_aPeaks[nIndex] >= AGC_PEAKVOL)
			{
				nMaxPeaks++;
			}
		}

		dwAvg = (dwTotal-dwMin) / (PEAKARRAYSIZE-1);


		// check for clipping every 2 seconds
		if (((nMaxPeaks >= 1) && (dwAvg > AGC_HIGHVOL)) || (nMaxPeaks >=2))
		{
			// if the volume changed during (user manually adjusted sliders)
			// then allow those settings to stay in effect for this update
			if (HasVolumeChanged())
			{
				m_nLastUpdateResult = AGC_NOUPDATE;
			}
			else
			{
				m_cPeaks = 0;
				LowerVolume();
				m_nLastUpdateResult = AGC_UPDATE_LOWERVOL;
			}
			return m_nLastUpdateResult;
		}


		if (m_cPeaks >= PEAKARRAYSIZE)
		{
			m_cPeaks = 0;

			// if the volume changed during (user manually adjusted sliders)
			// then allow those settings to stay in effect for this update
			if (HasVolumeChanged())
			{
				m_nLastUpdateResult = AGC_NOUPDATE;
			}


			// should we actually raise the volume ?
			// if we just lowered the volume, don't raise it again
			// prevents the system from appearing "jerky"

			// if we just raised the volume, then don't raise immediately
			// again... let silence detection catch up.
			else if ((dwAvg < m_wThreshStrength) && (m_nLastUpdateResult == AGC_NOUPDATE))
			{
				RaiseVolume();
				m_nLastUpdateResult = AGC_UPDATE_RAISEVOL;
			}

			else
			{
				m_nLastUpdateResult = AGC_NOUPDATE;
			}

			return m_nLastUpdateResult;
		}

		return AGC_NOUPDATE;

	}

	// return NOUPDATE, but don't set m_nLastUpdateResult since
	// there was no decision made.
	return AGC_NOUPDATE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\audpackt.cpp ===
#include "precomp.h"

#define ZONE_AP			ZONE_DP


#define _GetState()		(m_dwState & DP_MASK_STATE)
#define _SetState(s)	(m_dwState = (m_dwState & ~DP_MASK_STATE) | (s & DP_MASK_STATE))

#define _GetPlatform()	(m_dwState & DP_MASK_PLATFORM)
#define _SetPlatform(s)	(m_dwState = (m_dwState & ~DP_MASK_PLATFORM) | (s & DP_MASK_PLATFORM))


int g_wavein_prepare = 0;
int g_waveout_prepare = 0;


///////////////////////////////////////////////////////
//
//  Public methods
//




HRESULT AudioPacket::Initialize ( MEDIAPACKETINIT * p )
{
	HRESULT hr = DPR_SUCCESS;

	FX_ENTRY ("AdPckt::Init")

	if (p == NULL)
	{
		DEBUGMSG (ZONE_AP, ("%s: invalid parameter (null ptr)\r\n", _fx_));
		return DPR_INVALID_PARAMETER;
	}

	hr = MediaPacket::Initialize( p);
	
	if (hr != DPR_SUCCESS)
		goto MyExit;
		
	// allocate conversion header only if m_pWaveData != m_pNetData
	if (m_pRawData != m_pNetData)
	{
		if (m_dwState & DP_FLAG_ACM)
		{
			m_pStrmConvHdr = MemAlloc (sizeof (ACMSTREAMHEADER));
			if (m_pStrmConvHdr == NULL)
			{
				DEBUGMSG (ZONE_AP, ("%s: MemAlloc4 (%ld) failed\r\n",
				_fx_, (ULONG) sizeof (ACMSTREAMHEADER)));
				hr = DPR_OUT_OF_MEMORY;
				goto MyExit;
			}
		}
		else
		{
			DEBUGMSG (ZONE_AP, ("%s: invalid platform (acm)\r\n", _fx_));
			hr = DPR_INVALID_PLATFORM;
			goto MyExit;
		}

	}
	else
	{
		m_pStrmConvHdr = NULL;
	}

	// allocate device header
	if (m_dwState & DP_FLAG_MMSYSTEM)
	{
		m_pDevHdr = MemAlloc (sizeof (WAVEHDR));
		if (m_pDevHdr == NULL)
		{
			DEBUGMSG (ZONE_AP, ("%s: MemAlloc5 (%ld) failed\r\n",
			_fx_, (ULONG) sizeof (WAVEHDR)));
			hr = DPR_OUT_OF_MEMORY;
			goto MyExit;
		}
	}
	else
	{
		DEBUGMSG (ZONE_AP, ("%s: invalid platform (mm)\r\n", _fx_));
		hr = DPR_INVALID_PLATFORM;
		goto MyExit;
	}

	MakeSilence ();

MyExit:

	if (hr != DPR_SUCCESS)
	{
		m_fInitialized = FALSE;
		Release();
	}

	return hr;
}


HRESULT AudioPacket::Play ( MMIODEST *pmmioDest, UINT uDataType )
{
	HRESULT hr = DPR_SUCCESS;
	DWORD dwState = _GetState ();
	MMRESULT mmr;

	FX_ENTRY ("AdPckt::Play")

	if (dwState != MP_STATE_DECODED && dwState != MP_STATE_RESET)
	{
		DEBUGMSG (ZONE_AP, ("%s: out of seq, state=0x%lX\r\n", _fx_, m_dwState));
		return DPR_OUT_OF_SEQUENCE;
	}

	if (uDataType == MP_DATATYPE_SILENCE)
	{
		LOG((LOGMSG_PLAY_SILENT,m_index,GetTickCount()));
		MakeSilence ();
	}
	else
	{
		if (uDataType == MP_DATATYPE_INTERPOLATED)
		{
			if (dwState == MP_STATE_DECODED)
			{
				LOG((LOGMSG_PLAY_INTERPOLATED,m_index,GetTickCount()));
			}
			else
			{
				LOG((LOGMSG_PLAY_SILENT,m_index,GetTickCount()));
				MakeSilence ();
			}
		}
		else
		{
			LOG((LOGMSG_PLAY,m_index, GetTickCount()));
		}
	}


	if (m_hDev)
	{
		if (m_dwState & DP_FLAG_MMSYSTEM)
		{
			((WAVEHDR *) m_pDevHdr)->lpData = (char *) m_pDevData->data;
//			((WAVEHDR *) m_pDevHdr)->dwBufferLength = (dwState == MP_STATE_DECODED ?
//									((ACMSTREAMHEADER *) m_pStrmConvHdr)->cbDstLengthUsed :
//									m_pDevData->length);

			((WAVEHDR *) m_pDevHdr)->dwBufferLength = (dwState == MP_STATE_DECODED ?
			                        m_cbValidRawData : m_pDevData->length);
			


			((WAVEHDR *) m_pDevHdr)->dwUser = (DWORD_PTR) this;
			((WAVEHDR *) m_pDevHdr)->dwFlags &= ~(WHDR_DONE|WHDR_INQUEUE);
			((WAVEHDR *) m_pDevHdr)->dwLoops = 0L;

			// feed this buffer to play
			mmr = waveOutWrite ((HWAVEOUT) m_hDev, (WAVEHDR *) m_pDevHdr, sizeof (WAVEHDR));
			if (mmr != MMSYSERR_NOERROR)
			{
				DEBUGMSG (ZONE_AP, ("%s: waveOutWrite failed, mmr=%ld\r\n", _fx_, (ULONG) mmr));
				hr = DPR_CANT_WRITE_WAVE_DEV;

				// this is an extremely rare error, but we've seen it
				// occur on some sound cards

				// in this case, just set the "done" bit, mark the
				// state to the "playing", but still return an error.

				((WAVEHDR *) m_pDevHdr)->dwFlags |= WHDR_DONE;


				goto MyExit;
			}
		}
		else
		{
			DEBUGMSG (ZONE_AP, ("%s: invalid platform (mm)\r\n", _fx_));
			hr = DPR_INVALID_PLATFORM;
			goto MyExit;
		}
		if (pmmioDest && pmmioDest->fRecordToFile && pmmioDest->hmmioDst)
		{
			// write this buffer to disk
			WriteToFile(pmmioDest);
		}
	}
	else
	{
		DEBUGMSG (ZONE_AP, ("%s: invalid handle\r\n", _fx_));
		hr = DPR_INVALID_HANDLE;
		goto MyExit;
	}

MyExit:

	if ((hr == DPR_SUCCESS) || (hr == DPR_CANT_WRITE_WAVE_DEV))
	{
		_SetState (((uDataType == MP_DATATYPE_SILENCE) || (uDataType == MP_DATATYPE_INTERPOLATED))? MP_STATE_PLAYING_SILENCE : MP_STATE_PLAYING_BACK);
	}
	return hr;
}



HRESULT AudioPacket::Record ( void )
{
	HRESULT hr = DPR_SUCCESS;
	MMRESULT mmr;

	FX_ENTRY ("AdPckt::Record")

	LOG((LOGMSG_RECORD,m_index));

	if (_GetState () != MP_STATE_RESET)
	{
		DEBUGMSG (ZONE_AP, ("%s: out of seq, state=0x%lX\r\n", _fx_, m_dwState));
		return DPR_OUT_OF_SEQUENCE;
	}

	if (m_hDev)
	{
		if (m_dwState & DP_FLAG_MMSYSTEM)
		{
			((WAVEHDR *) m_pDevHdr)->lpData = (char *) m_pDevData->data;
			((WAVEHDR *) m_pDevHdr)->dwBufferLength = m_pDevData->length;
			((WAVEHDR *) m_pDevHdr)->dwUser = (DWORD_PTR) this;
			((WAVEHDR *) m_pDevHdr)->dwFlags |= WHDR_PREPARED;
			((WAVEHDR *) m_pDevHdr)->dwLoops = 0L;

			// feed this buffer to record
			mmr = waveInAddBuffer ((HWAVEIN)m_hDev, (WAVEHDR *) m_pDevHdr, sizeof (WAVEHDR));
			if (mmr != MMSYSERR_NOERROR)
			{
				DEBUGMSG (ZONE_AP, ("%s: waveInAddBuffer failed, mmr=%ld\r\n", _fx_, (ULONG) mmr));
				hr = DPR_CANT_ADD_BUFFER;
				goto MyExit;
			}
		}
		else
		{
			DEBUGMSG (ZONE_AP, ("%s: invalid platform (mm)\r\n", _fx_));
			hr = DPR_INVALID_PLATFORM;
			goto MyExit;
		}
	}
	else
	{
		DEBUGMSG (ZONE_AP, ("%s: invalid handle\r\n", _fx_));
		hr = DPR_INVALID_HANDLE;
		goto MyExit;
	}

MyExit:

	if (hr == DPR_SUCCESS) _SetState (MP_STATE_RECORDING);
	return hr;
}


BOOL AudioPacket::IsBufferDone ( void )
{
	FX_ENTRY ("AdPckt::IsBufferDone")

	if (m_hDev)
	{
		if (m_dwState & DP_FLAG_MMSYSTEM)
		{
			return (((WAVEHDR *) m_pDevHdr)->dwFlags & WHDR_DONE);
		}
	}

	return FALSE;
}


HRESULT AudioPacket::MakeSilence ( void )
{
	// create white noise!!!

	FX_ENTRY ("AdPckt::MakeSilence")

	if (m_pDevFmt)
	{
		if (m_pDevData)
		{
			FillSilenceBuf ((WAVEFORMATEX *) m_pDevFmt, (PBYTE) m_pDevData->data,
											(ULONG) m_pDevData->length);
		}

	#if 0
		if (m_pRawData != m_pDevData)
		{
			if (m_pRawData)
				ZeroMemory (m_pRawData->data, m_pRawData->length);
		}

		if (m_pNetData != m_pRawData)
		{
			if (m_pNetData)
				ZeroMemory (m_pNetData->data, m_pNetData->length);
		}
	#endif
	}

	_SetState(MP_STATE_RESET);
	return DPR_SUCCESS;
}

/*
	Returns the max. peak-to-peak signal value scaled to
	the range [0,0xffff]
	Optional argument returns the peak value as well
*/
HRESULT AudioPacket::GetSignalStrength (  PDWORD pdwMaxStrength)
{
	return ComputePower(pdwMaxStrength, NULL);
}


HRESULT AudioPacket::ComputePower(PDWORD pdwMaxStrength, PWORD pwPeakStrength)
{
	BYTE bMax, bMin, *pb;
	short sMax, sMin, *ps;
	UINT cbSize;

	FX_ENTRY ("AdPckt::GetSignalStrength")

	if (((WAVEFORMATEX *) m_pDevFmt)->wFormatTag != WAVE_FORMAT_PCM) return FALSE;

	switch (((WAVEFORMATEX *) m_pDevFmt)->wBitsPerSample)
	{
	case 8: // unsigned char

		pb = (PBYTE) (m_pDevData->data);
		cbSize = m_pDevData->length;

		bMax = 0;
		bMin = 255;

		for ( ; cbSize; cbSize--, pb++)
		{
			if (*pb > bMax) bMax = *pb;
			if (*pb < bMin) bMin = *pb;
		}
	
		if (pdwMaxStrength)
		{
			// 2^9 <-- 2^16 / 2^7
			*pdwMaxStrength = ((DWORD) (bMax - bMin)) << 8;
		}
		if (pwPeakStrength)
		{
				*pwPeakStrength = (bMax > bMin) ? bMax : (WORD)(-bMin);
				*pwPeakStrength = (*pwPeakStrength) << 8;
		}
		break;

	case 16: // (signed) short

		ps = (short *) (m_pDevData->data);
		cbSize = m_pDevData->length;

		sMax = sMin = 0;

		for (cbSize >>= 1; cbSize; cbSize--, ps++)
		{
			if (*ps > sMax) sMax = *ps;
			if (*ps < sMin) sMin = *ps;
		}
	
		if (pdwMaxStrength)
		{
			*pdwMaxStrength = (DWORD) (sMax - sMin); // drop sign bit
		}
		if (pwPeakStrength)
		{
			*pwPeakStrength = ((WORD)(sMax) > (WORD)(-sMin)) ? sMax : (WORD)(-sMin);
		}
		break;

	default:
		if (pdwMaxStrength)
			*pdwMaxStrength = 0;
		if (pwPeakStrength)
			*pwPeakStrength = 0;	
		break;
	}
	//LOG((LOGMSG_SILENT,m_index,fResult));

	return DPR_SUCCESS;
}


HRESULT AudioPacket::Interpolate ( MediaPacket * pPrev, MediaPacket * pNext)
{
	HRESULT			hr = DPR_SUCCESS;
	DPHANDLE		hPrevDevAudio;
	NETBUF			*pPrevDevData;
	PVOID			pPrevDevHdr;
	WAVEFORMATEX	*pPrevpwfDevAudio;
	WAVEFORMATEX	*pNextpwfDevAudio;
	NETBUF			*pNextDevData;
	PVOID			pNextDevHdr;
	PCMSUB			PCMSub;

	FX_ENTRY ("AdPckt::Interpolate")

	// Make sure this really is an empty packet, that the previous packet is not an
	// empty packet and is being played back. It is not that important that we get
	// a handle to the next packet. If the next packet is decoded, then it's cool,
	// we can do a good job at interpolating between previous and next packet. If it's
	// not, well, too bad, we'll just work with the previous packet.
	if ((_GetState() != MP_STATE_RESET) || (pPrev->GetState() != MP_STATE_PLAYING_BACK))
	{
		// DEBUGMSG (ZONE_AP, ("%s: out of seq, state=0x%lX\r\n", _fx_, m_dwState));
		hr = DPR_OUT_OF_SEQUENCE;
		goto MyExit;
	}

	// Get pointers to the member variables of interest in the previous and next
	// packet. Test the next packet to find out if we can use it in the interpolation
	// algorithm.
	pPrev->GetProp (MP_PROP_DEV_HANDLE, (PDWORD_PTR)&hPrevDevAudio);
	pPrev->GetProp (MP_PROP_DEV_DATA, (PDWORD_PTR)&pPrevDevData);
	pPrev->GetProp (MP_PROP_DEV_MEDIA_HDR, (PDWORD_PTR)&pPrevDevHdr);
	pPrev->GetProp (MP_PROP_DEV_MEDIA_FORMAT, (PDWORD_PTR)&pPrevpwfDevAudio);
	if (hPrevDevAudio && pPrevDevData && pPrevDevHdr && pPrevpwfDevAudio && (pPrevpwfDevAudio->wFormatTag == 1) && (pPrevpwfDevAudio->nSamplesPerSec == 8000) && (pPrevpwfDevAudio->wBitsPerSample == 16))
	{
		PCMSub.pwWaSuBf = (short *)m_pDevData->data;
		PCMSub.dwBfSize = ((WAVEHDR *) pPrevDevHdr)->dwBufferLength >> 1;
		PCMSub.dwSaPeSe = (DWORD)pPrevpwfDevAudio->nSamplesPerSec;
		PCMSub.dwBiPeSa = (DWORD)pPrevpwfDevAudio->wBitsPerSample;
		PCMSub.pwPrBf = (short *)pPrevDevData->data;

		pNext->GetProp (MP_PROP_DEV_DATA, (PDWORD_PTR)&pNextDevData);
		pNext->GetProp (MP_PROP_DEV_MEDIA_HDR, (PDWORD_PTR)&pNextDevHdr);
		pNext->GetProp (MP_PROP_DEV_MEDIA_FORMAT, (PDWORD_PTR)&pNextpwfDevAudio);

		// Do a bit of checking
		if ((pNext->GetState() == MP_STATE_DECODED) && pNextDevData && pNextDevHdr
			&& (PCMSub.dwBfSize == (((WAVEHDR *) pNextDevHdr)->dwBufferLength >> 1))
			&& pNextpwfDevAudio && (pNextpwfDevAudio->wFormatTag == 1) && (pNextpwfDevAudio->nSamplesPerSec == 8000)
			&& (pNextpwfDevAudio->wBitsPerSample == 16))
		{
			PCMSub.eTech = techPATT_MATCH_BOTH_SIGN_CC;
			//PCMSub.eTech = techDUPLICATE_PREV;
			PCMSub.pwNeBf = (short *)pNextDevData->data;
			PCMSub.fScal = TRUE;
		}
		else
		{
			PCMSub.eTech = techPATT_MATCH_PREV_SIGN_CC;
			//PCMSub.eTech = techDUPLICATE_PREV;
			PCMSub.pwNeBf = (short *)NULL;
			PCMSub.fScal = FALSE;
		}
		// Do the actual interpolation
		hr = PCMSubstitute(&PCMSub);
		((ACMSTREAMHEADER *) m_pStrmConvHdr)->cbDstLengthUsed = ((WAVEHDR *) pPrevDevHdr)->dwBufferLength;
	}
	else
	{
		DEBUGMSG (ZONE_AP, ("%s: can't interpolate\r\n", _fx_));
		hr = DPR_INVALID_HANDLE;
		goto MyExit;
	}

	LOG((LOGMSG_INTERPOLATED,m_index));

MyExit:

	if (hr == DPR_SUCCESS)
		_SetState (MP_STATE_DECODED);
	else
		_SetState (MP_STATE_RESET);

	return hr;

}


HRESULT AudioPacket::Open ( UINT uType, DPHANDLE hdl )
// called by RxStream or TxStream
{
	HRESULT hr = DPR_SUCCESS;
	MMRESULT mmr;

	FX_ENTRY ("AdPckt::Open")

	switch (uType)
	{
#ifdef PREP_HDR_PER_CONV
	case MP_TYPE_RECVSTRMCONV:
		m_hStrmConv = hdl;
		break;
#endif

	case MP_TYPE_STREAMCONV:
		if ((m_hStrmConv = hdl) != NULL)
		{
			if (m_dwState & DP_FLAG_ACM)
			{
				// initialize the header
				ZeroMemory (m_pStrmConvHdr, sizeof (ACMSTREAMHEADER));
				((ACMSTREAMHEADER *) m_pStrmConvHdr)->cbStruct = sizeof (ACMSTREAMHEADER);
				((ACMSTREAMHEADER *) m_pStrmConvHdr)->fdwStatus = 0;
				((ACMSTREAMHEADER *) m_pStrmConvHdr)->dwUser = 0;
				((ACMSTREAMHEADER *) m_pStrmConvHdr)->dwSrcUser = 0;
				((ACMSTREAMHEADER *) m_pStrmConvHdr)->cbSrcLengthUsed = 0;
				((ACMSTREAMHEADER *) m_pStrmConvHdr)->dwDstUser = 0;
				((ACMSTREAMHEADER *) m_pStrmConvHdr)->cbDstLengthUsed = 0;
				if (m_dwState & DP_FLAG_SEND)
				{
					((ACMSTREAMHEADER *) m_pStrmConvHdr)->pbSrc = m_pRawData->data;
					((ACMSTREAMHEADER *) m_pStrmConvHdr)->cbSrcLength = m_pRawData->length;
					((ACMSTREAMHEADER *) m_pStrmConvHdr)->pbDst = m_pNetData->data;
					((ACMSTREAMHEADER *) m_pStrmConvHdr)->cbDstLength = m_pNetData->length;
				}
				else
				if (m_dwState & DP_FLAG_RECV)
				{
					((ACMSTREAMHEADER *) m_pStrmConvHdr)->pbSrc = m_pNetData->data;
					((ACMSTREAMHEADER *) m_pStrmConvHdr)->cbSrcLength = m_pNetData->length;
					((ACMSTREAMHEADER *) m_pStrmConvHdr)->pbDst = m_pRawData->data;
					((ACMSTREAMHEADER *) m_pStrmConvHdr)->cbDstLength = m_pRawData->length;
				}

				// prepare the header
				mmr = acmStreamPrepareHeader ((HACMSTREAM) m_hStrmConv,
											  (ACMSTREAMHEADER *) m_pStrmConvHdr, 0);
				if (mmr != MMSYSERR_NOERROR)
				{
					DEBUGMSG (ZONE_AP, ("%s: acmStreamPrepareHeader failed, mmr=%ld\r\n", _fx_, (ULONG) mmr));
					hr = DPR_CANT_PREPARE_HEADER;
					goto MyExit;
				}

				m_fStrmPrepared = TRUE;
			}
			else
			{
				hr = DPR_INVALID_PLATFORM;
				goto MyExit;
			}
		}
		break;

	case MP_TYPE_DEV:
		if ((m_hDev = hdl) != NULL)
		{
			if (m_dwState & DP_FLAG_MMSYSTEM)
			{
				// initialize the header
				ZeroMemory (m_pDevHdr, sizeof (WAVEHDR));
				((WAVEHDR *) m_pDevHdr)->lpData = (char *) m_pDevData->data;
				((WAVEHDR *) m_pDevHdr)->dwBufferLength = m_pDevData->length;
				((WAVEHDR *) m_pDevHdr)->dwUser = (DWORD_PTR) this;
				((WAVEHDR *) m_pDevHdr)->dwFlags = 0L;
				((WAVEHDR *) m_pDevHdr)->dwLoops = 0L;

				if (m_dwState & DP_FLAG_SEND)
				{
					g_wavein_prepare++;

					// prepare the header
					mmr = waveInPrepareHeader ((HWAVEIN) m_hDev, (WAVEHDR *) m_pDevHdr, sizeof (WAVEHDR));
					if (mmr != MMSYSERR_NOERROR)
					{
						DEBUGMSG (ZONE_AP, ("%s: waveInPrepareHeader failed, mmr=%ld\r\n", _fx_, (ULONG) mmr));
						hr = DPR_CANT_PREPARE_HEADER;
						goto MyExit;
					}
				}
				else
				if (m_dwState & DP_FLAG_RECV)
				{
					g_waveout_prepare++;

					// prepare header
					mmr = waveOutPrepareHeader ((HWAVEOUT) m_hDev, (WAVEHDR *) m_pDevHdr, sizeof (WAVEHDR));
					if (mmr != MMSYSERR_NOERROR)
					{
						DEBUGMSG (ZONE_AP, ("%s: waveOutPrepareHeader failed, mmr=%ld\r\n", _fx_, (ULONG) mmr));
						hr = DPR_CANT_PREPARE_HEADER;
						goto MyExit;
					}
				}
				else
				{
					hr = DPR_INVALID_PARAMETER;
					goto MyExit;
				}

				m_fDevPrepared = TRUE;
			}
			else
			{
				hr = DPR_INVALID_PLATFORM;
				goto MyExit;
			}
		}
		else
		{
			hr = DPR_INVALID_HANDLE;
			goto MyExit;
		}
		break;

	default:
		hr = DPR_INVALID_PARAMETER;
		goto MyExit;
	}

MyExit:

	return hr;
}


HRESULT AudioPacket::Close ( UINT uType )
// called by RxStream or TxStream
{
	HRESULT hr = DPR_SUCCESS;
	MMRESULT mmr;

	FX_ENTRY ("AdPckt::Close")

	switch (uType)
	{
#ifdef PREP_HDR_PER_CONV
	case MP_TYPE_RECVSTRMCONV:
#endif

	case MP_TYPE_STREAMCONV:
		if (m_hStrmConv)
		{
			if (m_dwState & DP_FLAG_ACM)
			{
				if (m_fStrmPrepared)
				{
					// unprepare the header
					if (m_dwState & DP_FLAG_RECV)
					{
						// Within acmStreamUnprepareHeader, there is a test that compares ((ACMSTREAMHEADER *)m_pStrmConvHdr)->cbSrcLength
						// to ((ACMSTREAMHEADER *)m_pStrmConvHdr)->cbPreparedSrcLength. If there isn't an exact match, MSACM32 will fail
						// this call. That test is Ok when the size of the input buffer is constant, but with the variable bit rate codecs,
						// we can receive packets with a size smaller than the max size we advertize when we prepare the buffers. In
						// order to make this call succeed, we fix up ((ACMSTREAMHEADER *)m_pStrmConvHdr)->cbSrcLength before the call.
						((ACMSTREAMHEADER *)m_pStrmConvHdr)->cbSrcLength = ((ACMSTREAMHEADER *)m_pStrmConvHdr)->dwReservedDriver[7];
					}
					mmr = acmStreamUnprepareHeader ((HACMSTREAM) m_hStrmConv,
													(ACMSTREAMHEADER *) m_pStrmConvHdr, 0);
					m_fStrmPrepared = FALSE; // don't care about any error

					if (mmr != MMSYSERR_NOERROR)
					{
						DEBUGMSG (ZONE_AP, ("%s: acmStreamUnprepareHeader failed, mmr=%ld\r\n", _fx_, (ULONG) mmr));
						hr = DPR_CANT_UNPREPARE_HEADER;
						goto MyExit;
					}
				}
			}

			if (uType == MP_TYPE_STREAMCONV) m_hStrmConv = NULL;
		}
		break;

	case MP_TYPE_DEV:
		if (m_hDev)
		{
			if (m_fDevPrepared)
			{
				if (m_dwState & DP_FLAG_SEND)
				{
					g_wavein_prepare--;
					mmr = waveInUnprepareHeader ((HWAVEIN) m_hDev,
												 (WAVEHDR *) m_pDevHdr,
												 sizeof (WAVEHDR));
				}
				else
				if (m_dwState & DP_FLAG_RECV)
				{
					g_waveout_prepare--;
					mmr = waveOutUnprepareHeader ((HWAVEOUT) m_hDev,
												  (WAVEHDR *) m_pDevHdr,
												  sizeof (WAVEHDR));
				}
				else
				{
					hr = DPR_INVALID_PARAMETER;
					goto MyExit;
				}

				m_fDevPrepared = FALSE; // don't care about any error

				if (mmr != MMSYSERR_NOERROR)
				{
					DEBUGMSG (ZONE_AP, ("%s: Unprep hdr failed, mmr=0x%lX\r\n", _fx_, mmr));
					hr = DPR_CANT_UNPREPARE_HEADER;
					goto MyExit;
				}
			}

			m_hDev = NULL;
		}
		else
		{
			hr = DPR_INVALID_HANDLE;
			goto MyExit;
		}
		break;

	default:
		hr = DPR_INVALID_PARAMETER;
		goto MyExit;
	}

MyExit:

	return hr;
}

void AudioPacket::WriteToFile (MMIODEST *pmmioDest)
{
	MMRESULT mmr;
	long dwDataLength;

	FX_ENTRY ("AdPckt::WriteToFile")

	AudioFile::WriteDestFile(pmmioDest,	m_pDevData->data, m_pDevData->length);
}

void AudioPacket::ReadFromFile (MMIOSRC *pmmioSrc)
{
	AudioFile::ReadSourceFile(pmmioSrc, (BYTE*)(((WAVEHDR*)m_pDevHdr)->lpData), ((WAVEHDR*)m_pDevHdr)->dwBytesRecorded);
}



BOOL AudioPacket::IsSameMediaFormat(PVOID fmt1,PVOID fmt2)
{
	return IsSameWaveFormat(fmt1,fmt2);
}

/*************************************************************************

  Function: PCMSubstitute(PCMSUB *)

  Purpose : Fills up missing buffer with wave data.

  Returns : HRESULT. DPR_SUCCESS if everything is cool, some error code
			otherwise.

  Params  : pPCMSub == Pointer to wave substitution structure

  Techniques:	* Straight replication of the previous packet
				* Straight replication of the next packet	
				* Replication of some part of the previous packet based on pattern matching
				* Replication of some part of the next packet based on pattern matching
				* Search window size need to be at least twice the size of the pattern!!!

  Comments: * The algorithm searches previous packets to find pPCMSub->dwBfSize
			samples that resemble the missing packet. To do so it uses as a
			template the M speech samples that came just before
			the missing packet. The algorithm scans a search window of
			duration N samples to find the M samples that best match the
			template. It then uses as a replacement packet the L samples
			that follow the best match.
			* Current code assumes all the packets (current, previous, and
			next) have the same size.
			* Current code only takes 8kHz data.
			* Current code only takes 16bit data.
			* Current code requires that the matching pattern be smaller than packet.

  History : Date      Reason
            04/16/95  Created - PhilF

*************************************************************************/
HRESULT AudioPacket::PCMSubstitute(PCMSUB *pPCMSub)
{
	DWORD	dwPaSize;						// Pattern size in samples
	DWORD	dwSeWiSize;						// Search window size in samples
	short	*pwPa = (short *)NULL;			// Pointer to the pattern
	short	*pwPaSav = (short *)NULL;		// Pointer to the pattern (copy)
	short	*pwPrSeWi = (short *)NULL;		// Pointer to the previous buffer (search window)
	short	*pwPrSeWiSav = (short *)NULL;	// Pointer to the previous buffer (search window) (copy)
	short	*pwNeSeWi = (short *)NULL;		// Pointer to the next buffer (search window)
	short	*pwNeSeWiSav = (short *)NULL;	// Pointer to the next buffer (search window) (copy)
	DWORD	i, j;							// Counters
	DWORD	dwPrCCPosMax;					// Sample position of the maximum cross-correlation between pattern and previous buffer
	DWORD	dwNeCCPosMax;					// Sample position of the maximum cross-correlation between pattern and previous buffer
	long	lPrCCMax;						// Max cross-correlation with previous buffer
	long	lNeCCMax;						// Max cross-correlation with next buffer
	long	lCCNum;							// Cross-correlation numerator
	DWORD	dwNuSaToCopy;					// Number of samples to copy in the missing buffer
	DWORD	dwNuSaCopied;					// Number of samples copied in the missing buffer
	long	alSign[2] = {1,-1};				// Sign array
	DWORD	dwPaAmp;						// Amplitude of the pattern
	DWORD	dwPaAmpExp;						// Expected amplitude of the pattern
	DWORD	dwNeSeWiAmp;					// Amplitude of a segment of the window following the current window
	DWORD	dwNumPaInSeWin;					// Number of patterns in search window
	DWORD	dwPrSeWiAmp;					// Amplitude of a segment of the current window
	BOOL	fPaInPr;						// Pattern is at the end of previous buffer of at the beginning of next buffer


	// Test input parameters
	if ((!pPCMSub) || (!pPCMSub->pwWaSuBf) || (pPCMSub->dwBiPeSa != 16) || (pPCMSub->dwSaPeSe != 8000))
		return DPR_INVALID_PARAMETER;

	// Check number of buffer available before and after missing packet
	// In case there are no packet before or after the missing packet,
	// just return; the packet will be filled with silence data later.
	if (!pPCMSub->pwPrBf && !pPCMSub->pwNeBf)
		return DPR_CANT_INTERPOLATE;

	// Just replicate previous packet
	if ((pPCMSub->eTech == techDUPLICATE_PREV) && pPCMSub->pwPrBf)
		CopyMemory(pPCMSub->pwWaSuBf, pPCMSub->pwPrBf, pPCMSub->dwBfSize << 1);
	else	// Just replicate next packet
		if ((pPCMSub->eTech == techDUPLICATE_NEXT) && pPCMSub->pwNeBf)
			CopyMemory(pPCMSub->pwWaSuBf, pPCMSub->pwNeBf, pPCMSub->dwBfSize << 1);
		else
			if ((pPCMSub->eTech == techPATT_MATCH_PREV_SIGN_CC) || (pPCMSub->eTech == techPATT_MATCH_NEXT_SIGN_CC) || (pPCMSub->eTech == techPATT_MATCH_BOTH_SIGN_CC))
			{

				// We use a search window with a size double the size of the matching pattern
				// Experimentation will tell if this is a reasonable size or not
				// Experimentation will also tell if 4ms size of the matching pattern is Ok
				dwPaSize = pPCMSub->dwSaPeSe / 1000 * PATTERN_SIZE;
				if (dwPaSize > (pPCMSub->dwBfSize/2))
					dwPaSize = pPCMSub->dwBfSize/2;
				if (!dwPaSize)
					return DPR_CANT_INTERPOLATE;
#if 1
				// For now look up the whole previous frame
				dwSeWiSize = pPCMSub->dwBfSize;
#else
				dwSeWiSize = min(pPCMSub->dwBfSize, pPCMSub->dwSaPeSe / 1000 * SEARCH_SIZE);
#endif

				// In order to use pattern matching based techniques we need to have the
				// previous buffer when doing a backward search, the next buffer
				// when doing a forward search, the previous buffer and the next buffer
				// when doing a full search
				if (pPCMSub->pwPrBf && (pPCMSub->eTech == techPATT_MATCH_PREV_SIGN_CC))
				{
					pwPa     = pwPaSav = pPCMSub->pwPrBf + pPCMSub->dwBfSize - dwPaSize;
					pwPrSeWi = pwPrSeWiSav = pPCMSub->pwPrBf + pPCMSub->dwBfSize - dwSeWiSize;
				}
				else
					if (pPCMSub->pwNeBf && (pPCMSub->eTech == techPATT_MATCH_NEXT_SIGN_CC))
					{
						pwPa   = pwPaSav = pPCMSub->pwNeBf;
						pwNeSeWi = pwNeSeWiSav = pPCMSub->pwNeBf;
					}
					else
						if (pPCMSub->pwPrBf && pPCMSub->pwNeBf && (pPCMSub->eTech == techPATT_MATCH_BOTH_SIGN_CC))
						{
							// Use the pattern with the highest amplitude
							pwPa = pwPaSav = pPCMSub->pwPrBf + pPCMSub->dwBfSize - dwPaSize;
							pwNeSeWi = pPCMSub->pwNeBf;
							pwPrSeWi = pwPrSeWiSav = pPCMSub->pwPrBf + pPCMSub->dwBfSize - dwSeWiSize;
							fPaInPr = TRUE;
							for (i=0, dwPaAmp = 0, dwNeSeWiAmp = 0; i<dwPaSize; i++, pwPa++, pwNeSeWi++)
							{
								dwPaAmp		+= abs(*pwPa);
								dwNeSeWiAmp	+= abs(*pwNeSeWi);
							}
							if (dwNeSeWiAmp > dwPaAmp)
							{
								pwPaSav = pPCMSub->pwNeBf;
								fPaInPr = FALSE;
							}
							pwPa = pwPaSav;
							pwNeSeWi = pwNeSeWiSav = pPCMSub->pwNeBf + dwPaSize/2;
						}

				if (pwPa && (pwPrSeWi || pwNeSeWi))
				{
					// Look for best match in previous packet
					dwPrCCPosMax = 0; lPrCCMax = -((long)dwPaSize+1);
					if (pwPrSeWi && ((pPCMSub->eTech == techPATT_MATCH_PREV_SIGN_CC) || ((fPaInPr) && (pPCMSub->eTech == techPATT_MATCH_BOTH_SIGN_CC))))
					{
						// Look for the highest sign correlation between pattern and search window
						for (i=0; i<(dwSeWiSize-dwPaSize-dwPaSize/2+1); i++, pwPa = pwPaSav, pwPrSeWi = pwPrSeWiSav + i)
						{
							// Compute the sign correlation between pattern, and search window
							for (j=0, lCCNum = 0; j<dwPaSize; j++, pwPa++, pwPrSeWi++)
								lCCNum += alSign[(*pwPa ^ *pwPrSeWi)>> 15 & 1];

							// Save position and value of highest sign correlation
							if (lCCNum>lPrCCMax)
							{
								dwPrCCPosMax = i;
								lPrCCMax = lCCNum;
							}
						}
					}

					// Look for best match in next packet
					dwNeCCPosMax = dwPaSize/2; lNeCCMax = -((long)dwPaSize+1);
					if (pwNeSeWi && ((pPCMSub->eTech == techPATT_MATCH_NEXT_SIGN_CC) || ((!fPaInPr) && (pPCMSub->eTech == techPATT_MATCH_BOTH_SIGN_CC))))
					{
						// Look for the highest sign correlation between pattern and search window
						for (i=dwPaSize/2; i<(dwSeWiSize-dwPaSize-dwPaSize/2+1); i++, pwPa = pwPaSav, pwNeSeWi = pwNeSeWiSav + i)
						{
							// Compute the sign correlation between pattern, and search window
							for (j=0, lCCNum = 0; j<dwPaSize; j++, pwPa++, pwNeSeWi++)
								lCCNum += alSign[(*pwPa ^ *pwNeSeWi)>> 15 & 1];

							// Save position and value of highest sign correlation
							if (lCCNum>lNeCCMax)
							{
								dwNeCCPosMax = i;
								lNeCCMax = lCCNum;
							}
						}
					}				

					if ((pPCMSub->eTech == techPATT_MATCH_PREV_SIGN_CC) || (pwPrSeWiSav && fPaInPr && (pPCMSub->eTech == techPATT_MATCH_BOTH_SIGN_CC)))
					{
						// Copy matching samples from the previous frame in missing frame
						dwNuSaToCopy = pPCMSub->dwBfSize-dwPaSize-dwPrCCPosMax;
						CopyMemory(pPCMSub->pwWaSuBf, pwPrSeWiSav+dwPaSize+dwPrCCPosMax, dwNuSaToCopy << 1);

						// Do it until missing packet is full
						for (dwNuSaCopied = dwNuSaToCopy; dwNuSaCopied<pPCMSub->dwBfSize;dwNuSaCopied += dwNuSaToCopy)
						{
							dwNuSaToCopy = min(pPCMSub->dwBfSize-dwNuSaCopied, dwNuSaToCopy);
							CopyMemory(pPCMSub->pwWaSuBf + dwNuSaCopied, pwPrSeWiSav+dwPaSize+dwPrCCPosMax, dwNuSaToCopy << 1);
						}
					}
					else
					{
						// Copy matching samples from the next frame in missing frame
						dwNuSaToCopy = dwNeCCPosMax;
						CopyMemory(pPCMSub->pwWaSuBf + pPCMSub->dwBfSize - dwNuSaToCopy, pPCMSub->pwNeBf, dwNuSaToCopy << 1);

						// Do it until missing packet is full
						for (dwNuSaCopied = dwNuSaToCopy; dwNuSaCopied<pPCMSub->dwBfSize;dwNuSaCopied += dwNuSaToCopy)
						{
							dwNuSaToCopy = min(pPCMSub->dwBfSize-dwNuSaCopied, dwNuSaToCopy);
							CopyMemory(pPCMSub->pwWaSuBf + pPCMSub->dwBfSize - dwNuSaCopied - dwNuSaToCopy, pPCMSub->pwNeBf+dwNeCCPosMax-dwNuSaToCopy, dwNuSaToCopy << 1);
						}
					}

					if ((pPCMSub->eTech == techPATT_MATCH_BOTH_SIGN_CC) && pwNeSeWiSav && pwPrSeWiSav)
					{
						if (pPCMSub->fScal)
						{
							// Compute the amplitude of the pattern
							for (i=0, dwPrSeWiAmp = 0, dwNeSeWiAmp = 0, pwPrSeWi = pPCMSub->pwPrBf + pPCMSub->dwBfSize - dwPaSize, pwNeSeWi = pPCMSub->pwNeBf; i<dwPaSize; i++, pwPrSeWi++, pwNeSeWi++)
							{
								dwPrSeWiAmp	+= abs(*pwPrSeWi);
								dwNeSeWiAmp	+= abs(*pwNeSeWi);
							}
							// Scale data
							dwNumPaInSeWin = pPCMSub->dwBfSize/dwPaSize;
							for (i=0, pwPaSav = pPCMSub->pwWaSuBf; i<dwNumPaInSeWin; i++, pwPaSav += dwPaSize)
							{
								for (j=0, pwPa = pwPaSav, dwPaAmp = 0; j<dwPaSize; j++, pwPa++)
									dwPaAmp	+= abs(*pwPa);
								dwPaAmpExp = (dwPrSeWiAmp * (dwNumPaInSeWin - i) + dwNeSeWiAmp * (i + 1)) / (dwNumPaInSeWin + 1);
								for (;dwPaAmpExp > 65536; dwPaAmpExp >>= 1, dwPaAmp >>= 1)
									;
								if (dwPaAmp && (dwPaAmp != dwPaAmpExp))
									for (j=0, pwPa = pwPaSav; j<dwPaSize; j++, pwPa++)
										*pwPa = (short)((long)*pwPa * (long)dwPaAmpExp / (long)dwPaAmp);
							}
						}
					}
				}
			}
		else
			return DPR_CANT_INTERPOLATE;

	return DPR_SUCCESS;

}

// returns length of uncompressed PCM data in buffer
DWORD
AudioPacket::GetDevDataSamples()
{
	DWORD dwState = _GetState();
	DWORD cbData;
	
	if (dwState == MP_STATE_DECODED)
		// return actual length
		cbData = ((ACMSTREAMHEADER *) m_pStrmConvHdr)->cbDstLengthUsed ;
	else if (m_pDevData)
		// return size of buffer
		cbData = m_pDevData->length;
	else
		cbData = 0;

	return cbData * 8/ ((WAVEFORMATEX *) m_pDevFmt)->wBitsPerSample;
	
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\bufpool.cpp ===
#include "precomp.h"

///////////////////////////////////////////////////////
//
//  Public methods
//


BufferPool::BufferPool ( void )
{
	InitializeCriticalSection (&m_CritSect);

	_Construct ();
}


BufferPool::~BufferPool ( void )
{
	_Destruct ();

	DeleteCriticalSection (&m_CritSect);
}


HRESULT BufferPool::Initialize ( UINT uBuf, ULONG cbSizeBuf )
{
	HRESULT hr = DPR_SUCCESS;
	PBYTE *ppb;

	DEBUGMSG (ZONE_VERBOSE, ("BufPool::Initialize: enter.\r\n"));

	EnterCriticalSection (&m_CritSect);

	if (m_fInitialized)
	{
		hr = DPR_CANT_INITIALIZE_AGAIN;
		goto MyExit;
	}

	m_cBufFree = uBuf;
	m_cbSizeBuf = (cbSizeBuf + 3) & (~3);	// round up to 4

	m_pAlloc = m_pBufFree = LocalAlloc (LMEM_FIXED, m_cBufFree * m_cbSizeBuf);
	if (m_pAlloc == NULL)
	{
		hr = DPR_OUT_OF_MEMORY;
		goto MyExit;
	}

	ppb = (PBYTE *) m_pBufFree;
	while (-- uBuf)
	{
		ppb = (PBYTE *) (*ppb = (PBYTE) ppb + m_cbSizeBuf);
	}
	*ppb = NULL;

MyExit:

	if (hr == DPR_SUCCESS) m_fInitialized = TRUE;

	LeaveCriticalSection (&m_CritSect);

	DEBUGMSG (ZONE_VERBOSE, ("BufPool::Initialize: exit, hr=0x%lX\r\n",  hr));

	return hr;
}


PVOID BufferPool::GetBuffer ( void )
{
	PVOID p = NULL;

	EnterCriticalSection (&m_CritSect);

	if (m_fInitialized)
	{
		p = m_pBufFree;

		if (m_pBufFree)
		{
			m_pBufFree = (PVOID) *((PBYTE *) m_pBufFree);
		}
	}

	LeaveCriticalSection (&m_CritSect);

	return p;
}


void BufferPool::ReturnBuffer ( PVOID p )
{
	EnterCriticalSection (&m_CritSect);

	if (m_fInitialized)
	{
		*((PVOID *) p) = m_pBufFree;
		m_pBufFree = p;
	}

	LeaveCriticalSection (&m_CritSect);
}


ULONG BufferPool::GetMaxBufferSize ( void )
{
	return m_fInitialized ? m_cbSizeBuf : 0;
}


void BufferPool::Release ( void )
{
	_Destruct ();
}


///////////////////////////////////////////////////////
//
//  Private methods
//


void BufferPool::_Construct ( void )
{
	m_fInitialized = FALSE;

	m_cbSizeBuf = 0;
	m_cBufAlloc = 0;
	m_cBufFree = 0;

	m_pAlloc = NULL;

	m_pBufFree = NULL;
}


void BufferPool::_Destruct ( void )
{
	if (m_fInitialized)
	{
		if (m_pAlloc)
		{
			LocalFree (m_pAlloc);
			m_pAlloc = NULL;
		}

		m_fInitialized = FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\bufpool.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    bufpool.h

Abstract:
	The class defined here manages a pool of fixed-size buffers that are typically used
	for network packets or sound buffers.

--*/
#ifndef _BUFPOOL_H_
#define _BUFPOOL_H_


#include <pshpack8.h> /* Assume 8 byte packing throughout */

class BufferPool
{
private:

	BOOL	m_fInitialized;

	ULONG	m_cbSizeBuf;
	UINT	m_cBufAlloc;
	UINT	m_cBufFree;

	PVOID	m_pAlloc;

	PVOID	m_pBufFree;

	// intra-process/inter-thread synchronization
	CRITICAL_SECTION m_CritSect;

private:

	void _Construct ( void );
	void _Destruct ( void );

public:

	BufferPool ( void );
	~BufferPool ( void );

	HRESULT Initialize ( UINT uBuf, ULONG cbSizeBuf );
	PVOID GetBuffer ( void );
	void ReturnBuffer ( PVOID pBuf );
	ULONG GetMaxBufferSize ( void );
	void Release ( void );
};


#include <poppack.h> /* End byte packing */

#endif // _BUFPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\audiofile.cpp ===
#include "precomp.h"



/*************************************************************************

  Function: AudioFile::OpenSourceFile(MMIOSRC *pSrcFile, WAVEFORMATEX *pwf)

  Purpose : Opens wav file to read audio data from.

  Returns : HRESULT.

  Params  : None

  Comments: * Registry keys:
            \\HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Audio\PlayFromFile\fPlayFromFile
              If set to zero, data will not be read from wav file.
              If set to a non null value <= INT_MAX, data will be read from wav file.
            \\HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Audio\PlayFromFile\szInputFileName
              Name of the wav file to read audio data from.
            \\HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Audio\PlayFromFile\fLoop
              If set to zero, the file will only be read once.
              If set to a non null value <= INT_MAX, the file will be read circularly.
            \\HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Audio\PlayFromFile\cchIOBuffer
              If set to zero, size of the MM IO buffer is set to its default value (8Kbytes).
              If set to one, size of the MM IO buffer is set to match maximum size of the wav file.
              If set a non null value between 2 and INT_MAX, size of the MM IO buffer is set to cchIOBuffer bytes.

  History : Date      Reason
            06/02/96  Created - PhilF

*************************************************************************/
HRESULT AudioFile::OpenSourceFile (MMIOSRC *pSrcFile, WAVEFORMATEX *pwf)
{
	HRESULT			hr = DPR_SUCCESS;
	MMIOINFO		mmioInfo;
	long			cchBuffer;
	WAVEFORMATEX	*pwfFile;
	DWORD			dw;

	FX_ENTRY ("SendAudioStream::OpenSrcFile")

	RegEntry reIPhoneInFile(szRegInternetPhone TEXT("\\") szRegInternetPhoneInputFile,
							HKEY_LOCAL_MACHINE,
							FALSE,
							KEY_READ);

	// For now, get the file name from the registry
	if (pSrcFile->fPlayFromFile = reIPhoneInFile.GetNumberIniStyle(TEXT("fPlayFromFile"), FALSE))
	{
		lstrcpyn(pSrcFile->szInputFileName,
					reIPhoneInFile.GetString(TEXT("szInputFileName")),
					CCHMAX(pSrcFile->szInputFileName));
		cchBuffer = reIPhoneInFile.GetNumberIniStyle(TEXT("cchIOBuffer"), 0L);
		pSrcFile->fLoop = reIPhoneInFile.GetNumberIniStyle(TEXT("fLoop"), TRUE);
		pSrcFile->fDisconnectAfterPlayback 
			= reIPhoneInFile.GetNumberIniStyle(TEXT("fDisconnectAfterPlayback"), FALSE);
		
		cchBuffer = MMIO_DEFAULTBUFFER;

		ZeroMemory(&mmioInfo, sizeof(MMIOINFO));
		do
		{
			mmioInfo.cchBuffer = cchBuffer;
			pSrcFile->hmmioSrc = mmioOpen((LPSTR)&(pSrcFile->szInputFileName[0]), (LPMMIOINFO)&mmioInfo, MMIO_READ | MMIO_DENYWRITE | MMIO_EXCLUSIVE | MMIO_ALLOCBUF);
			cchBuffer /= 2;
		} while ((mmioInfo.wErrorRet == MMIOERR_OUTOFMEMORY) && (mmioInfo.cchBuffer > MMIO_DEFAULTBUFFER));

		if (pSrcFile->hmmioSrc)
		{
			// Locate a 'WAVE' form type in a 'RIFF' thing...
			pSrcFile->ckSrcRIFF.fccType = mmioFOURCC('W', 'A', 'V', 'E');
			if (mmioDescend(pSrcFile->hmmioSrc, (LPMMCKINFO)&(pSrcFile->ckSrcRIFF), NULL, MMIO_FINDRIFF))
				goto MyMMIOErrorExit3;

			// We found a WAVE chunk--now go through and get all subchunks that we know how to deal with
			while (mmioDescend(pSrcFile->hmmioSrc, &(pSrcFile->ckSrc), &(pSrcFile->ckSrcRIFF), 0) == 0)
			{
				// Quickly check for corrupt RIFF file--don't ascend past end!
				if ((pSrcFile->ckSrc.dwDataOffset + pSrcFile->ckSrc.cksize) > (pSrcFile->ckSrcRIFF.dwDataOffset + pSrcFile->ckSrcRIFF.cksize))
					goto MyMMIOErrorExit1;
				// Make sure the wave format structure of this file is compatible with the microphone
				if (pSrcFile->ckSrc.ckid == mmioFOURCC('f', 'm', 't', ' '))
				{
					if ((dw = pSrcFile->ckSrc.cksize) < sizeof(WAVEFORMATEX))
						dw = sizeof(WAVEFORMATEX);

					if (!(pwfFile = (WAVEFORMATEX *)GlobalAllocPtr(GHND, dw)))
						goto MyMMIOErrorExit1;

					dw = pSrcFile->ckSrc.cksize;
					if (mmioRead(pSrcFile->hmmioSrc, (HPSTR)pwfFile, dw) != (LONG)dw)
						goto MyMMIOErrorExit0;
					if (dw == sizeof(WAVEFORMATEX))
						pwfFile->cbSize = 0;
					if ((pwfFile->wFormatTag != pwf->wFormatTag) || (pwfFile->nChannels != pwf->nChannels)
						|| (pwfFile->nSamplesPerSec != pwf->nSamplesPerSec) || (pwfFile->nAvgBytesPerSec != pwf->nAvgBytesPerSec)
						|| (pwfFile->nBlockAlign != pwf->nBlockAlign)  || (pwfFile->wBitsPerSample != pwf->wBitsPerSample) || (pwfFile->cbSize != pwf->cbSize))
						goto MyMMIOErrorExit0;
					pwfFile = (WAVEFORMATEX *)(UINT_PTR)GlobalFreePtr(pwfFile);
				}
				// Step up to prepare for next chunk..
				mmioAscend(pSrcFile->hmmioSrc, &(pSrcFile->ckSrc), 0);
			}

			// Go back to beginning of data portion of WAVE chunk
			if (-1L == mmioSeek(pSrcFile->hmmioSrc, pSrcFile->ckSrcRIFF.dwDataOffset + sizeof(FOURCC), SEEK_SET))
				goto MyMMIOErrorExit2;
			pSrcFile->ckSrc.ckid = mmioFOURCC('d', 'a', 't', 'a');
			if (mmioDescend(pSrcFile->hmmioSrc, &(pSrcFile->ckSrc), &(pSrcFile->ckSrcRIFF), MMIO_FINDCHUNK))
				goto MyMMIOErrorExit2;
			pSrcFile->dwMaxDataLength = pSrcFile->ckSrc.cksize;
			pSrcFile->dwDataLength = 0;
			pSrcFile->wfx = *pwf;

			// At this point, the src file is sitting at the very
			// beginning of its data chunks--so we can read from the src file...

			goto MyLastExit;

MyMMIOErrorExit0:
			GlobalFreePtr(pwfFile);
MyMMIOErrorExit1:
			mmioAscend(pSrcFile->hmmioSrc, &(pSrcFile->ckSrc), 0);
MyMMIOErrorExit2:
			mmioAscend(pSrcFile->hmmioSrc, &(pSrcFile->ckSrcRIFF), 0);
MyMMIOErrorExit3:
			mmioClose(pSrcFile->hmmioSrc, 0);
			pSrcFile->hmmioSrc = NULL;
		}
	}

MyLastExit:

	return hr;

}


/*************************************************************************

  Function: AudioFile::CloseSourceFile(void)

  Purpose : Close wav file used to read audio data from.

  Returns : HRESULT.

  Params  : None

  Comments:

  History : Date      Reason
            06/02/96  Created - PhilF

*************************************************************************/
HRESULT AudioFile::CloseSourceFile (MMIOSRC *pSrcFile)
{
	HRESULT	hr = DPR_SUCCESS;

	FX_ENTRY ("SendAudioStream::CloseSrcFile")

	if (pSrcFile->fPlayFromFile && pSrcFile->hmmioSrc)
	{
		mmioAscend(pSrcFile->hmmioSrc, &(pSrcFile->ckSrc), 0);
		mmioAscend(pSrcFile->hmmioSrc, &(pSrcFile->ckSrcRIFF), 0);
		mmioClose(pSrcFile->hmmioSrc, 0);
		pSrcFile->hmmioSrc = NULL;
	}

	return hr;
}

HRESULT AudioFile::ReadSourceFile(MMIOSRC *pmmioSrc, BYTE *pData, DWORD dwBytesToRead)
{

	long lNumBytesRead;
	bool bCloseFile = false;

	FX_ENTRY ("AdPckt::ReadFromFile")

	if (pmmioSrc->hmmioSrc == NULL)
		return S_FALSE;


	if (dwBytesToRead)
	{
MyRead:
		if ((pmmioSrc->dwDataLength + dwBytesToRead) <= pmmioSrc->dwMaxDataLength)
		{
			lNumBytesRead = mmioRead(pmmioSrc->hmmioSrc, (char*)pData, dwBytesToRead);
			pmmioSrc->dwDataLength += lNumBytesRead;
		}
		else
		{
			lNumBytesRead = mmioRead(pmmioSrc->hmmioSrc, (char*)pData, pmmioSrc->dwMaxDataLength - pmmioSrc->dwDataLength);
			pmmioSrc->dwDataLength += lNumBytesRead;

			// silence out the remainder of the block
			if (pmmioSrc->wfx.wBitsPerSample != 8)
			{
				ZeroMemory(pData, dwBytesToRead - lNumBytesRead);
			}
			else
			{
				FillMemory(pData, dwBytesToRead - lNumBytesRead, 0x80);
			}

			pmmioSrc->dwDataLength = 0;
			lNumBytesRead = 0;
		}
		
		if (!lNumBytesRead)
		{
			if (pmmioSrc->fLoop && !pmmioSrc->fDisconnectAfterPlayback)
			{
				// Reset file pointer to beginning of data
				mmioAscend(pmmioSrc->hmmioSrc, &(pmmioSrc->ckSrc), 0);
				if (-1L == mmioSeek(pmmioSrc->hmmioSrc, pmmioSrc->ckSrcRIFF.dwDataOffset + sizeof(FOURCC), SEEK_SET))
				{
					DEBUGMSG (1, ("MediaControl::OpenSrcFile: Couldn't seek in file, mmr=%ld\r\n", (ULONG) 0L));
					bCloseFile = true;
				}
				else
				{
					pmmioSrc->ckSrc.ckid = mmioFOURCC('d', 'a', 't', 'a');
					if (mmioDescend(pmmioSrc->hmmioSrc, &(pmmioSrc->ckSrc), &(pmmioSrc->ckSrcRIFF), MMIO_FINDCHUNK))
					{
						DEBUGMSG (1, ("MediaControl::OpenSrcFile: Couldn't locate 'data' chunk, mmr=%ld\r\n", (ULONG) 0L));
						bCloseFile = true;
					}
					else
					{
						// At this point, the src file is sitting at the very
						// beginning of its data chunks--so we can read from the src file...
						goto MyRead;
					}
				}
			}
			else
			{
				bCloseFile = true;
			}

			if (bCloseFile)
			{
				mmioAscend(pmmioSrc->hmmioSrc, &(pmmioSrc->ckSrcRIFF), 0);
				mmioClose(pmmioSrc->hmmioSrc, 0);
				pmmioSrc->hmmioSrc = NULL;
				return S_FALSE;
			}
		}

		return S_OK;

	}
	return S_FALSE;
}






/*************************************************************************

  Function: RecvAudioStream::OpenDestFile(void)

  Purpose : Opens wav file to record audio data into.

  Returns : HRESULT.

  Params  : None

  Comments: * Registry keys:
            \\HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Audio\RecordToFile\fRecordToFile
              If set to zero, data will not be recorded into wav file.
              If set to a non null value <= INT_MAX, data will be recorded into wav file.
            \\HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Audio\RecordToFile\fRecordToFile
              If set to zero, data will overwrite existing data if wav file already exists.
              If set to a non null value <= INT_MAX, data will be recorded into wav file after existing data.
            \\HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Audio\RecordToFile\szOutputFileName
              Name of the wav file to record audio data into.
            \\HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Audio\RecordToFile\lMaxTimeLength
              If set to zero, there is no limit to the size of the wav file.
              If set to a non null value <= INT_MAX, size of the file will be clamped to lMaxTimeLength.
            \\HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Audio\RecordToFile\cchIOBuffer
              If set to zero, size of the MM IO buffer is set to its default value (8Kbytes).
              If set to one, size of the MM IO buffer is set to match maximum size of the wav file.
              If set a non null value between 2 and INT_MAX, size of the MM IO buffer is set to cchIOBuffer bytes.

  History : Date      Reason
            06/02/96  Created - PhilF

*************************************************************************/
HRESULT AudioFile::OpenDestFile (MMIODEST *pDestFile, WAVEFORMATEX *pwf)
{
	HRESULT			hr = DPR_SUCCESS;
	MMIOINFO		mmioInfo;
	DWORD			dw;
	long			cchBuffer;
	long			lMaxTimeLength;
	BOOL			fAppend;
	MMRESULT		mmr;

	FX_ENTRY ("RecvAudioStream::OpenDestFile")

	RegEntry reIPhoneOutFile(szRegInternetPhone TEXT("\\") szRegInternetPhoneOutputFile,
							HKEY_LOCAL_MACHINE,
							FALSE,
							KEY_READ);

	// For now, get the file name from the registry
	if (pDestFile->fRecordToFile = reIPhoneOutFile.GetNumberIniStyle(TEXT("fRecordToFile"), FALSE))
	{
		lstrcpyn(pDestFile->szOutputFileName,
					reIPhoneOutFile.GetString(TEXT("szOutputFileName")),
					CCHMAX(pDestFile->szOutputFileName));
		cchBuffer = reIPhoneOutFile.GetNumberIniStyle(TEXT("cchIOBuffer"), 0L);
		lMaxTimeLength = reIPhoneOutFile.GetNumberIniStyle(TEXT("lMaxTimeLength"), 0L);
#if 0
		fAppend = reIPhoneOutFile.GetNumberIniStyle(TEXT("fAppend"), FALSE);
#else
		fAppend = FALSE;
#endif
		// Try to open the file for writing using buffered I/O
		// If the size of the buffer is too large, try again
		// with a buffer half that size.
		// m_RecvFilter->GetProp(FM_PROP_DST_MEDIA_FORMAT, (PDWORD)&pwf);

		if (!pwf)
			goto MyLastExit;
		pDestFile->dwMaxDataLength = lMaxTimeLength == 0L ? (DWORD)INT_MAX : (DWORD)(lMaxTimeLength * pwf->nSamplesPerSec * pwf->nBlockAlign / 1000L);
		if ((cchBuffer == 0L) || (lMaxTimeLength == 0L))
			cchBuffer = MMIO_DEFAULTBUFFER;
		else
			if (cchBuffer == 1L)
				cchBuffer = (long)pDestFile->dwMaxDataLength;
		ZeroMemory(&mmioInfo, sizeof(MMIOINFO));
		if (!mmioOpen((LPSTR)&(pDestFile->szOutputFileName[0]), NULL, MMIO_EXIST))
			fAppend = FALSE;
		do
		{
			mmioInfo.cchBuffer = cchBuffer;
			// pDestFile->hmmioDst = mmioOpen((LPSTR)&(pDestFile->szOutputFileName[0]), (LPMMIOINFO)&mmioInfo, MMIO_EXCLUSIVE | MMIO_ALLOCBUF | (fAppend ? MMIO_READWRITE : MMIO_WRITE | MMIO_CREATE));
			pDestFile->hmmioDst = mmioOpen((LPSTR)&(pDestFile->szOutputFileName[0]), (LPMMIOINFO)&mmioInfo, MMIO_EXCLUSIVE | MMIO_ALLOCBUF | (fAppend ? MMIO_WRITE : MMIO_WRITE | MMIO_CREATE));
			cchBuffer /= 2;
		} while ((mmioInfo.wErrorRet == MMIOERR_OUTOFMEMORY) && (mmioInfo.cchBuffer > MMIO_DEFAULTBUFFER));
		if (pDestFile->hmmioDst)
		{
			if (!fAppend)
			{
				// Create the RIFF chunk of form type 'WAVE'
				pDestFile->ckDstRIFF.fccType = mmioFOURCC('W', 'A', 'V', 'E');
				pDestFile->ckDstRIFF.cksize  = 0L;
				if (mmioCreateChunk(pDestFile->hmmioDst, &(pDestFile->ckDstRIFF), MMIO_CREATERIFF))
					goto MyMMIOErrorExit3;

				// Now create the destination fmt, fact, and data chunks _in that order_
				pDestFile->ckDst.ckid   = mmioFOURCC('f', 'm', 't', ' ');
				pDestFile->ckDst.cksize = dw = SIZEOF_WAVEFORMATEX(pwf);
				if (mmioCreateChunk(pDestFile->hmmioDst, &(pDestFile->ckDst), 0))
					goto MyMMIOErrorExit2;
				if (mmioWrite(pDestFile->hmmioDst, (HPSTR)pwf, dw) != (LONG)dw)
					goto MyMMIOErrorExit1;
				if (mmioAscend(pDestFile->hmmioDst, &(pDestFile->ckDst), 0))
					goto MyMMIOErrorExit1;

				// Create the 'fact' chunk.
				// Since we are not writing any data to this file (yet), we set the
				// samples contained in the file to 0.
				pDestFile->ckDst.ckid   = mmioFOURCC('f', 'a', 'c', 't');
				pDestFile->ckDst.cksize = 0L;
				if (mmioCreateChunk(pDestFile->hmmioDst, &(pDestFile->ckDst), 0))
					goto MyMMIOErrorExit2;
				pDestFile->dwDataLength = 0; // This will be updated when closing the file.
				if (mmioWrite(pDestFile->hmmioDst, (HPSTR)&(pDestFile->dwDataLength), sizeof(long)) != sizeof(long))
					goto MyMMIOErrorExit1;
				if (mmioAscend(pDestFile->hmmioDst, &(pDestFile->ckDst), 0))
					goto MyMMIOErrorExit1;

				// Create the data chunk and stay descended
				pDestFile->ckDst.ckid   = mmioFOURCC('d', 'a', 't', 'a');
				pDestFile->ckDst.cksize = 0L;
				if (mmioCreateChunk(pDestFile->hmmioDst, &(pDestFile->ckDst), 0))
					goto MyMMIOErrorExit2;

				// At this point, the dst file is sitting at the very
				// beginning of its data chunks--so we can write to the dst file...
				goto MyLastExit;

MyMMIOErrorExit1:
				mmioAscend(pDestFile->hmmioDst, &(pDestFile->ckDst), 0);
MyMMIOErrorExit2:
				mmioAscend(pDestFile->hmmioDst, &(pDestFile->ckDstRIFF), 0);
MyMMIOErrorExit3:
				mmioClose(pDestFile->hmmioDst, 0);
				mmioOpen((LPSTR)&(pDestFile->szOutputFileName[0]), (LPMMIOINFO)&mmioInfo, MMIO_DELETE);
				pDestFile->hmmioDst = NULL;
			}
			else
			{
				// File already exists, only need to position pointer at the end of existing data.
				// Locate a 'WAVE' form type in a 'RIFF' thing...
				pDestFile->ckDstRIFF.fccType = mmioFOURCC('W', 'A', 'V', 'E');
				if (mmr = mmioDescend(pDestFile->hmmioDst, (LPMMCKINFO)&(pDestFile->ckDstRIFF), NULL, MMIO_FINDRIFF))
					goto MyOtherMMIOErrorExit3;

				// We found a WAVE chunk--now go through and get all subchunks that we know how to deal with
				while (mmr = mmioDescend(pDestFile->hmmioDst, &(pDestFile->ckDst), &(pDestFile->ckDstRIFF), 0) == 0)
				{
					// Quickly check for corrupt RIFF file--don't ascend past end!
					if ((pDestFile->ckDst.dwDataOffset + pDestFile->ckDst.cksize) > (pDestFile->ckDstRIFF.dwDataOffset + pDestFile->ckDstRIFF.cksize))
						goto MyOtherMMIOErrorExit1;
					// Step up to prepare for next chunk..
					mmr = mmioAscend(pDestFile->hmmioDst, &(pDestFile->ckDst), 0);
				}

				// Go back to beginning of data portion of WAVE chunk
				if (-1L == mmioSeek(pDestFile->hmmioDst, pDestFile->ckDstRIFF.dwDataOffset + sizeof(FOURCC), SEEK_SET))
					goto MyOtherMMIOErrorExit2;
				pDestFile->ckDst.ckid = mmioFOURCC('d', 'a', 't', 'a');
				if (mmr = mmioDescend(pDestFile->hmmioDst, &(pDestFile->ckDst), &(pDestFile->ckDstRIFF), MMIO_FINDCHUNK))
					goto MyOtherMMIOErrorExit2;
				pDestFile->dwDataLength = pDestFile->ckDst.cksize;
				if (-1L == (mmr = mmioSeek(pDestFile->hmmioDst, 0, SEEK_END)))
					goto MyOtherMMIOErrorExit2;

				// At this point, the dst file is sitting at the very
				// end of its data chunks--so we can write to the dst file...

				goto MyLastExit;

MyOtherMMIOErrorExit1:
				mmioAscend(pDestFile->hmmioDst, &(pDestFile->ckDst), 0);
MyOtherMMIOErrorExit2:
				mmioAscend(pDestFile->hmmioDst, &(pDestFile->ckDstRIFF), 0);
MyOtherMMIOErrorExit3:
				mmioClose(pDestFile->hmmioDst, 0);
				pDestFile->hmmioDst = NULL;
			}
		}
	}

MyLastExit:
	return hr;

}


/*************************************************************************

  Function: RecvAudioStream::CloseDestFile(void)

  Purpose : Close wav file used to record audio data into.

  Returns : HRESULT.

  Params  : None

  Comments:

  History : Date      Reason
            06/02/96  Created - PhilF

*************************************************************************/
HRESULT AudioFile::CloseDestFile (MMIODEST *pDestFile)
{
	HRESULT	hr = DPR_SUCCESS;
	FX_ENTRY ("RecvAudioStream::CloseDestFile")

	if (pDestFile->fRecordToFile && pDestFile->hmmioDst)
	{
		mmioAscend(pDestFile->hmmioDst, &(pDestFile->ckDst), 0);
		mmioAscend(pDestFile->hmmioDst, &(pDestFile->ckDstRIFF), 0);
		mmioClose(pDestFile->hmmioDst, 0);
		pDestFile->hmmioDst = NULL;
	}

	return hr;
}




HRESULT AudioFile::WriteDestFile(MMIODEST *pmmioDest, BYTE *pData, DWORD dwBytesToWrite)
{
	MMRESULT mmr=MMSYSERR_NOERROR;

	FX_ENTRY ("AudioFile::WriteToFile")

	if ((pmmioDest->hmmioDst == NULL) || (dwBytesToWrite == 0))
	{
		return S_FALSE;
	}

	if (mmioWrite(pmmioDest->hmmioDst, (char *) pData, dwBytesToWrite) != (long)dwBytesToWrite)
	{
		mmr = MMSYSERR_ERROR;
	}
	else
	{
		pmmioDest->dwDataLength += dwBytesToWrite;
	}

	if ((pmmioDest->dwDataLength >= pmmioDest->dwMaxDataLength) ||
	    (mmr != MMSYSERR_NOERROR))
	{
		mmr = mmioAscend(pmmioDest->hmmioDst, &(pmmioDest->ckDst), 0);
		mmr = mmioAscend(pmmioDest->hmmioDst, &(pmmioDest->ckDstRIFF), 0);
		mmr = mmioClose(pmmioDest->hmmioDst, 0);
		pmmioDest->hmmioDst = NULL;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\audpackt.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    audpackt.h

Abstract:

    Contains  prototypes for the AudioPacket class, which encapsulates a sound buffer in
    its various states: recorded/encoded/network/decoded/playing etc.

--*/
#ifndef _AUDPACKT_H_
#define _AUDPACKT_H_

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#define AP_NUM_PREAMBLE_PACKETS		6

//
// Start of Interpolation defines
//

// Recovering techniques
typedef enum tagTECHNIQUE
{
	techPATT_MATCH_PREV_SIGN_CC,	// Replicate from the previous frame using pattern matching and signed cross-correlation
	techPATT_MATCH_NEXT_SIGN_CC,	// Replicate from the previous frame using pattern matching and signed cross-correlation
	techPATT_MATCH_BOTH_SIGN_CC,	// Interpolate between the previous and the next frame using pattern matching and signed cross-correlation
	techDUPLICATE_PREV,				// Replicate last frame
	techDUPLICATE_NEXT				// Replicate next frame
}TECHNIQUE;

// Wave Substitution structure
typedef struct tagPCMSUB
{
	short		*pwWaSuBf;	// Pointer to missing buffer
	short		*pwPrBf;	// Pointer to previous audio buffer
	short		*pwNeBf;	// Pointer to next audio buffer
	DWORD		dwBfSize;	// Number of samples in audio buffer
	DWORD		dwSaPeSe;	// Frequency sampling for ALL buffers (in samples per second)
	DWORD		dwBiPeSa;	// Number of bits per sample for ALL buffers (in bits per sample)
	TECHNIQUE	eTech;		// Technique to be used
	BOOL		fScal;      // Scale reconstructed frame
}PCMSUB;

#define PATTERN_SIZE 4		// Pattern size in milliseconds. Experiment with values between 2 and 8 ms.
#define SEARCH_SIZE 8		// Window search size in milliseconds. Experiment with values between 8 and 16 ms.

//
// End of Interpolation defines
//

class AudioPacket : public MediaPacket
{
 public:
	virtual HRESULT Initialize ( MEDIAPACKETINIT * p );
	virtual HRESULT Play ( MMIODEST *pmmioDest, UINT uDataType );
	virtual HRESULT Record ( void );
	virtual HRESULT Interpolate ( MediaPacket * pPrev, MediaPacket * pNext);
	virtual HRESULT GetSignalStrength ( PDWORD pdwMaxStrength );
	HRESULT ComputePower ( PDWORD pdwVoiceStrength, PWORD pwPeakStrength);
	virtual HRESULT MakeSilence ( void );
	virtual HRESULT Open ( UINT uType, DPHANDLE hdl );	// called by RxStream or TxStream
	virtual HRESULT Close ( UINT uType );				// called by RxStream or TxStream
	virtual BOOL IsBufferDone ( void );
	virtual BOOL IsSameMediaFormat(PVOID fmt1,PVOID fmt2);
	virtual DWORD GetDevDataSamples();

	void WriteToFile (MMIODEST *pmmioDest);
	void ReadFromFile (MMIOSRC *pmmioSrc);
	HRESULT PCMSubstitute( PCMSUB *pPCMSub);
};


#include <poppack.h> /* End byte packing */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\com.h ===
/*
 -  COM.H
 -
 *	Microsoft NetMeeting
 *	Network Audio Controller (NAC) DLL
 *	Internal header file for general COM "things"
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		2.3.97		Yoram Yaacovi		Created
 *
 */

#include <pshpack8.h> /* Assume 8 byte packing throughout */

/* 
 *	Class factory
 */
typedef HRESULT (STDAPICALLTYPE *PFNCREATE)(IUnknown *, REFIID, void **);
class CClassFactory : public IClassFactory
{
    public:
        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, void **);
        STDMETHODIMP         LockServer(BOOL);

        CClassFactory(PFNCREATE);
        ~CClassFactory(void);

    protected:
        ULONG	m_cRef;
		PFNCREATE m_pfnCreate;
};

#include <poppack.h> /* End byte packing */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\clsfact.cpp ===
/*
 -  CLSFACT.CPP
 -
 *	Microsoft NetMeeting
 *	Network Audio Control DLL
 *	Generic class factory
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		2.6.97		Yoram Yaacovi		Copied from qosfact.cpp
 *										Added handling of CInstallCodecs
 *		2.27.97		Yoram Yaacovi		Added DllRegisterServer and DllUnregisterServer
 *
 *	Functions:
 *		DllGetClassObject
 *		DllCanUnloadNow
 *		DllRegisterServer
 *		DllUnregisterServer
 *		CClassFactory::QueryInterface
 *		CClassFactory::AddRef
 *		CClassFactory::Release
 *		CClassFactory::CreateInstance
 *		CClassFactory::LockServer
 *		CreateClassFactory
 *		
 *
 *	Object types supported:
 *		CQoS
 *		CInstallCodecs
 *
 *	Notes:
 *		To add support for manufacturing objects of other types, change:
 *			DllGetClassObject
 *			DllCanUnloadNow
 *			Add the CLSID and description to aObjectInfo
 *
 */

#include <precomp.h>

int g_cObjects = 0;				// A general object count. Used for LockServer.
EXTERN_C int g_cQoSObjects;		// QoS object count. Public in qos\qos.cpp
EXTERN_C int g_cICObjects;		// CInstallCodecs object count. Public in inscodec.cpp

EXTERN_C HINSTANCE g_hInst;		// global module instance

// Untested code for registering COM objects in the NAC
// when enabled, DllRegisterServer and DllUnregisterServer should be exported
// in nac.def

#define GUID_STR_LEN    40

typedef struct
{
    const CLSID *pclsid;
	char szDescription[MAX_PATH];
} OBJECT_INFO;

static OBJECT_INFO aObjectInfo[]=
	{&CLSID_QoS, TEXT("Microsoft NetMeeting Quality of Service"),
	 &CLSID_InstallCodecs, TEXT("Microsoft NetMeeting Installable Codecs"),
	 NULL, TEXT("")};

// Internal helper functions
BOOL DeleteKeyAndSubKeys(HKEY hkIn, LPTSTR pszSubKey);
BOOL UnregisterUnknownObject(const CLSID *prclsid);
BOOL RegisterUnknownObject(LPCTSTR  pszObjectName, const CLSID *prclsid);

/***************************************************************************

    Name      : DllGetClassObject

    Purpose   : Standard COM entry point to create a COM object

    Parameters:

    Returns   : HRESULT

    Comment   : 

***************************************************************************/
STDAPI DllGetClassObject (REFCLSID rclsid, REFIID riid, void **ppv)
{
    HRESULT hr;
    CClassFactory *pObj;

	*ppv = 0;

	// find out object of what class we need to create and instantiate
	// the class factory with the correct create function
    if (CLSID_QoS == rclsid)
	{
    	DBG_SAVE_FILE_LINE
		pObj = new CClassFactory(CreateQoS);
	}
	else if (CLSID_InstallCodecs == rclsid)
	{
		DBG_SAVE_FILE_LINE
		pObj = new CClassFactory(CreateInstallCodecs);
	}
	else
	{
		hr = CLASS_E_CLASSNOTAVAILABLE;
		goto out;
	}

    if (!pObj)
	{
		hr = E_OUTOFMEMORY;
		goto out;
	}

    hr = pObj->QueryInterface(riid, ppv);
    if (FAILED(hr))
        delete pObj;

out:
    return hr;
}

/***************************************************************************

    Name      : DllCanUnloadNow

    Purpose   : Standard COM entry point tell a DLL it can unload

    Parameters:

    Returns   : HRESULT

    Comment   : 

***************************************************************************/
STDAPI DllCanUnloadNow ()
{
	HRESULT hr=S_OK;
	int vcObjects = g_cObjects + g_cQoSObjects + g_cICObjects;

	return (vcObjects == 0 ? S_OK : S_FALSE);
}

/***************************************************************************

    Name      : DllRegisterServer

    Purpose   : Standard COM entry point to register a COM server

    Parameters:

    Returns   : HRESULT

    Comment   : 

***************************************************************************/
STDAPI DllRegisterServer(void)
{
	ULONG i=0;
	HRESULT hr=NOERROR;

	while ((aObjectInfo[i].pclsid != NULL) &&
			(lstrlen(aObjectInfo[i].szDescription) != 0))
    {
		if (!RegisterUnknownObject(aObjectInfo[i].szDescription,
								   aObjectInfo[i].pclsid))
		{
			hr = E_FAIL;
			goto out;
		}

		// next server to register
		i++;
	}

out:
	return hr;
}

/***************************************************************************

    Name      : DllUnregisterServer

    Purpose   : Standard COM entry point to unregister a COM server

    Parameters:

    Returns   : HRESULT

    Comment   : 

***************************************************************************/
STDAPI DllUnregisterServer(void)
{
 	ULONG i=0;
	HRESULT hr=NOERROR;

	while ((aObjectInfo[i].pclsid != NULL) &&
			(lstrlen(aObjectInfo[i].szDescription) != 0))
    {
		if (!UnregisterUnknownObject(aObjectInfo[i].pclsid))
		{
			hr = E_FAIL;
			goto out;
		}

		// next server to register
		i++;
	}

out:
	return hr;
}

/***************************************************************************

    ClassFactory: Generic implementation

***************************************************************************/
CClassFactory::CClassFactory(PFNCREATE pfnCreate)
{
	m_cRef=0;
	m_pfnCreate = pfnCreate;

	return;
}

CClassFactory::~CClassFactory(void)
{
	return;
}

/***************************************************************************

    IUnknown Methods for  CClassFactory

***************************************************************************/
HRESULT CClassFactory::QueryInterface (REFIID riid, void **ppv)
{
	HRESULT hr=NOERROR;

#ifdef DEBUG
	// parameter validation
    if (IsBadReadPtr(&riid, (UINT) sizeof(IID)))
    {
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (IsBadWritePtr(ppv, sizeof(LPVOID)))
    {
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }
#endif // DEBUG
	
	*ppv = 0;

    if (IID_IUnknown == riid ||
		IID_IClassFactory == riid)
	{
		*ppv = this;
	}
	else    
	{
        hr = ResultFromScode(E_NOINTERFACE);
        goto out;
    }

	((IUnknown *)*ppv)->AddRef();

out:
	return hr;
}

ULONG CClassFactory::AddRef (void)
{
    return ++m_cRef;
}

ULONG CClassFactory::Release (void)
{
	// if the cRef is already 0 (shouldn't happen), assert, but let it through
	ASSERT(m_cRef);
	if (--m_cRef == 0)
	{
		delete this;
		return 0;
	}

	return m_cRef;
}

/***************************************************************************

    Name      : CreateInstance

    Purpose   : Standard COM class factory entry point which creates the
				object that this class factory knows to create

    Parameters:

    Returns   : HRESULT

    Comment   : 

***************************************************************************/
HRESULT CClassFactory::CreateInstance (	IUnknown *punkOuter,
										REFIID riid,
										void **ppv)
{
	DEBUGMSG(ZONE_VERBOSE,("CClassFactory::CreateInstance\n"));

	return (m_pfnCreate)(punkOuter, riid, ppv);
}

/***************************************************************************

    Name      : LockServer

    Purpose   : Standard COM class factory entry point which will prevent
				the server from shutting down. Necessary when the caller
				keeps the class factory (through CoGetClassObject) instead
				of calling CoCreateInstance.

    Parameters:

    Returns   : HRESULT

    Comment   : 

***************************************************************************/
HRESULT CClassFactory::LockServer (BOOL flock)
{
	if (flock)
		++g_cObjects;
	else
		--g_cObjects;

	return NOERROR;
}

/***************************************************************************

	Helper functions

***************************************************************************/
/***************************************************************************

    Name      : StringFromGuid

    Purpose   : Creates a string out of a GUID

    Parameters: riid - [in]  clsid to make string out of.
				pszBuf - [in]  buffer in which to place resultant GUID

    Returns   : int - number of chars written out

    Comment   : 

***************************************************************************/
int StringFromGuid(const CLSID *priid, LPTSTR pszBuf)
{
    return wsprintf(pszBuf, TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
            priid->Data1, 
            priid->Data2, priid->Data3, priid->Data4[0], priid->Data4[1], priid->Data4[2], 
            priid->Data4[3], priid->Data4[4], priid->Data4[5], priid->Data4[6], priid->Data4[7]);
}

/***************************************************************************

    Name      : RegisterUnknownObject

    Purpose   : Registers a simple CoCreatable object
				We add the following information to the registry:

				HKEY_CLASSES_ROOT\CLSID\<CLSID> = <ObjectName> Object
				HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32 = <path to local server>
				HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32  @ThreadingModel = Apartment

    Parameters: pszObjectName - [in] Object Name
				prclsid - [in] pointer to the CLSID of the object

    Returns   : BOOL - FALSE means couldn't register it all

    Comment   : 

***************************************************************************/
BOOL RegisterUnknownObject(LPCTSTR  pszObjectName, const CLSID *prclsid)
{
    HKEY  hk = NULL, hkSub = NULL;
    TCHAR szGuidStr[GUID_STR_LEN];
    DWORD dwPathLen, dwDummy;
    TCHAR szScratch[MAX_PATH];
	BOOL bRet = FALSE;
    long  l;

    // clean out any garbage
    UnregisterUnknownObject(prclsid);

    if (!StringFromGuid(prclsid, szGuidStr))
		goto out;

	// CLSID/<class-id>
    wsprintf(szScratch, TEXT("CLSID\\%s"), szGuidStr);
    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, TEXT(""), REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hk, &dwDummy);
	if (l != ERROR_SUCCESS)
		goto out;

	// CLSID/<class-id>: class name 
    wsprintf(szScratch, TEXT("%s Object"), pszObjectName);
    l = RegSetValueEx(hk, NULL, 0, REG_SZ, (BYTE *)szScratch,
                      (lstrlen(szScratch) + 1)*sizeof(TCHAR));
	if (l != ERROR_SUCCESS)
		goto out;

	// CLSID/<class-id>/InprocServer32
    l = RegCreateKeyEx(hk, TEXT("InprocServer32"), 0, TEXT(""), REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
	if (l != ERROR_SUCCESS)
		goto out;

	// CLSID/<class-id>/InprocServer32:<file name>
    dwPathLen = GetModuleFileName(g_hInst, szScratch, sizeof(szScratch)/sizeof(TCHAR));
    if (!dwPathLen)
		goto out;
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, (dwPathLen + 1)*sizeof(TCHAR));
	if (l != ERROR_SUCCESS)
		goto out;

	// CLSID/<class-id>/InprocServer32: ThreadingModel = Apartment
    l = RegSetValueEx(hkSub, TEXT("ThreadingModel"), 0, REG_SZ, (BYTE *)TEXT("Apartment"),
                      sizeof(TEXT("Apartment")));
	if (l != ERROR_SUCCESS)
		goto out;

    bRet = TRUE;

out:
	// clean the keys if we failed somewhere
	if (!bRet)
		UnregisterUnknownObject(prclsid);
    if (hk)
		RegCloseKey(hk);
    if (hkSub)
		RegCloseKey(hkSub);
    return bRet;
}

/***************************************************************************

    Name      : UnregisterUnknownObject

    Purpose   : cleans up all the stuff that RegisterUnknownObject puts in the
				registry.

    Parameters: prclsid - [in] pointer to the CLSID of the object

    Returns   : BOOL - FALSE means couldn't register it all

    Comment   : 

***************************************************************************/
BOOL UnregisterUnknownObject(const CLSID *prclsid)
{
	TCHAR szScratch[MAX_PATH];
	HKEY hk=NULL;
	BOOL f;
	long l;
	BOOL bRet = FALSE;

	// delete everybody of the form
	//   HKEY_CLASSES_ROOT\CLSID\<CLSID> [\] *
	//
	if (!StringFromGuid(prclsid, szScratch))
		goto out;

	l = RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("CLSID"), 0, KEY_ALL_ACCESS, &hk);
	if (l != ERROR_SUCCESS)
		goto out;

	// Delete the object key and subkeys
	bRet = DeleteKeyAndSubKeys(hk, szScratch);

out:
    if (hk)
		RegCloseKey(hk);
	return bRet;
}

/***************************************************************************

    Name      : DeleteKeyAndSubKeys

    Purpose   : delete's a key and all of it's subkeys.

    Parameters: hkIn - [in] delete the descendant specified
				pszSubKey - [in] i'm the descendant specified

    Returns   : BOOL - TRUE = OK

    Comment   : Despite the win32 docs claiming it does, RegDeleteKey doesn't seem to
				work with sub-keys under windows 95.
				This function is recursive.

***************************************************************************/
BOOL DeleteKeyAndSubKeys(HKEY hkIn, LPTSTR pszSubKey)
{
    HKEY  hk;
    TCHAR szTmp[MAX_PATH];
    DWORD dwTmpSize;
    long  l;
    BOOL  f;
    int   x;

    l = RegOpenKeyEx(hkIn, pszSubKey, 0, KEY_ALL_ACCESS, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    // loop through all subkeys, blowing them away.
    //
    f = TRUE;
    x = 0;
    while (f) {
        dwTmpSize = MAX_PATH;
        l = RegEnumKeyEx(hk, x, szTmp, &dwTmpSize, 0, NULL, NULL, NULL);
        if (l != ERROR_SUCCESS) break;
        f = DeleteKeyAndSubKeys(hk, szTmp);
        x++;
    }

    // there are no subkeys left, [or we'll just generate an error and return FALSE].
    // let's go blow this dude away.
    //
    RegCloseKey(hk);
    l = RegDeleteKey(hkIn, pszSubKey);

    return (l == ERROR_SUCCESS) ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\devaudq.cpp ===
#include "precomp.h"

DevMediaQueue::DevMediaQueue ( void )
{
    m_uBegin = 0;
    m_uEnd = 0;
    m_uMaxNum = 0;
}


DevMediaQueue::~DevMediaQueue ( void )
{
    if (m_paPackets)
    {
        MemFree ((PVOID) m_paPackets);
        m_paPackets = NULL;
    }
}


void DevMediaQueue::SetSize ( UINT uMaxNum )
{
    m_uMaxNum = uMaxNum + 8;

	// Allocate zero-filled media packets
    m_paPackets = (MediaPacket **) MemAlloc (m_uMaxNum * sizeof (MediaPacket *));
}


void DevMediaQueue::Put ( MediaPacket * p )
{
    m_paPackets[m_uEnd++] = p;
    m_uEnd %= m_uMaxNum;
}


MediaPacket * DevMediaQueue::Get ( void )
{
    MediaPacket * p = NULL;

    if (m_uBegin != m_uEnd)
    {
        p = m_paPackets[m_uBegin];
		m_paPackets[m_uBegin++] = NULL;
        m_uBegin %= m_uMaxNum;
    }

    return p;
}


MediaPacket * DevMediaQueue::Peek ( void )
{
    return ((m_uBegin != m_uEnd) ? m_paPackets[m_uBegin] : NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\counters.cpp ===
//  COUNTERS.CPP
//
//      Global performance counters for the nac
//
//  Created 13-Nov-96 [JonT]

#include "precomp.h"

// Global ICounterMgr. We just use as an CLSID_Counter class factory
ICounterMgr* g_pCtrMgr;

// Define all counters here
ICounter* g_pctrVideoSend;   
ICounter* g_pctrVideoReceive;
ICounter* g_pctrVideoSendBytes;
ICounter* g_pctrVideoReceiveBytes;
ICounter* g_pctrVideoSendLost;
ICounter* g_pctrVideoCPUuse;
ICounter* g_pctrVideoBWuse;

ICounter* g_pctrAudioSendBytes;
ICounter* g_pctrAudioReceiveBytes;
ICounter* g_pctrAudioSendLost;
ICounter* g_pctrAudioJBDelay;

// Define all reports here
IReport* g_prptCallParameters;   
IReport* g_prptSystemSettings;

// Put these in a .LIB file someday
const IID IID_ICounterMgr = {0x9CB7FE5B,0x3444,0x11D0,{0xB1,0x43,0x00,0xC0,0x4F,0xC2,0xA1,0x18}};
const CLSID CLSID_CounterMgr = {0x65DDC229,0x38FE,0x11d0,{0xB1,0x43,0x00,0xC0,0x4F,0xC2,0xA1,0x18}};

//  InitCountersAndReports
//      Initializes all counters and reports that we want to use

extern "C" BOOL WINAPI InitCountersAndReports(void)
{
    // Get a pointer to the statistics counter interface if it's around
    if (CoCreateInstance(CLSID_CounterMgr, NULL, CLSCTX_INPROC_SERVER, IID_ICounterMgr, (void**)&g_pCtrMgr) != S_OK)
        return FALSE;

    // Create counters here
    DEFINE_COUNTER(&g_pctrVideoSend, "Video Send Frames Per Second", COUNTER_FLAG_ACCUMULATE);
    DEFINE_COUNTER(&g_pctrVideoReceive, "Video Receive Frames Per Second", COUNTER_FLAG_ACCUMULATE);
    DEFINE_COUNTER(&g_pctrVideoSendBytes, "Video Send Bits Per Second", COUNTER_FLAG_ACCUMULATE);
    DEFINE_COUNTER(&g_pctrVideoReceiveBytes, "Video Receive Bits Per Second", COUNTER_FLAG_ACCUMULATE);
    DEFINE_COUNTER(&g_pctrAudioSendBytes, "Audio Send Bits Per Second", COUNTER_FLAG_ACCUMULATE);
    DEFINE_COUNTER(&g_pctrAudioReceiveBytes, "Audio Receive Bits Per Second", COUNTER_FLAG_ACCUMULATE);
    DEFINE_COUNTER(&g_pctrAudioSendLost, "Audio Send Packets Lost", 0);
    DEFINE_COUNTER(&g_pctrVideoSendLost, "Video Send Packets Lost", 0);
    DEFINE_COUNTER(&g_pctrAudioJBDelay, "Audio Jitter Buffer Delay", 0);

    DEFINE_COUNTER(&g_pctrVideoCPUuse, "Video CPU use calculation", COUNTER_CLEAR);
    DEFINE_COUNTER(&g_pctrVideoBWuse, "Video Bit rate calculation", COUNTER_CLEAR);

    // Create reports here
    DEFINE_REPORT(&g_prptCallParameters, "Call Parameters", 0);
    DEFINE_REPORT(&g_prptSystemSettings, "System Settings", 0);

	// Create call parameters report entries here
	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Audio Send Format", REP_SEND_AUDIO_FORMAT);
	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Audio Send Sampling Rate (Hz)", REP_SEND_AUDIO_SAMPLING);
	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Audio Send Bitrate (w/o network overhead - bps)", REP_SEND_AUDIO_BITRATE);
	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Audio Send Packetization (ms / packet)", REP_SEND_AUDIO_PACKET);

	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Audio Recv Format", REP_RECV_AUDIO_FORMAT);
	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Audio Recv Sampling Rate (Hz)", REP_RECV_AUDIO_SAMPLING);
	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Audio Recv Bitrate (w/o network overhead - bps)", REP_RECV_AUDIO_BITRATE);
	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Audio Recv Packetization (ms / packet)", REP_RECV_AUDIO_PACKET);

	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Video Send Format", REP_SEND_VIDEO_FORMAT);
	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Video Send Max Frame Rate (negotiated - fps)", REP_SEND_VIDEO_MAXFPS);
	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Video Send Max Bitrate (negotiated - bps)", REP_SEND_VIDEO_BITRATE);

	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Video Recv Format", REP_RECV_VIDEO_FORMAT);
	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Video Recv Max Frame Rate (negotiated - fps)", REP_RECV_VIDEO_MAXFPS);
	DEFINE_REPORT_ENTRY(g_prptCallParameters, "Video Recv Max Bitrate (negotiated - bps)", REP_RECV_VIDEO_BITRATE);

	// Create system settings report entries here
	DEFINE_REPORT_ENTRY(g_prptSystemSettings, "Bandwidth (user setting)", REP_SYS_BANDWIDTH);
	DEFINE_REPORT_ENTRY(g_prptSystemSettings, "Audio Subsystem", REP_SYS_AUDIO_DSOUND);
	DEFINE_REPORT_ENTRY(g_prptSystemSettings, "Audio Record", REP_SYS_AUDIO_RECORD);
	DEFINE_REPORT_ENTRY(g_prptSystemSettings, "Audio Playback", REP_SYS_AUDIO_PLAYBACK);
	DEFINE_REPORT_ENTRY(g_prptSystemSettings, "Audio Duplex Type", REP_SYS_AUDIO_DUPLEX);
	DEFINE_REPORT_ENTRY(g_prptSystemSettings, "Capture", REP_SYS_VIDEO_DEVICE);
	DEFINE_REPORT_ENTRY(g_prptSystemSettings, "Device Image Size", REP_DEVICE_IMAGE_SIZE);

	// Provide defaults for some entries
	UPDATE_REPORT_ENTRY(g_prptSystemSettings, 4, REP_SYS_BANDWIDTH);
	UPDATE_REPORT_ENTRY(g_prptSystemSettings, 0, REP_SYS_AUDIO_DSOUND);
	UPDATE_REPORT_ENTRY(g_prptSystemSettings, 0, REP_SYS_AUDIO_RECORD);
	UPDATE_REPORT_ENTRY(g_prptSystemSettings, 0, REP_SYS_AUDIO_PLAYBACK);
	UPDATE_REPORT_ENTRY(g_prptSystemSettings, 0, REP_SYS_VIDEO_DEVICE);
	UPDATE_REPORT_ENTRY(g_prptSystemSettings, 0, REP_DEVICE_IMAGE_SIZE);

	UPDATE_COUNTER(g_pctrAudioJBDelay, 0);
	UPDATE_COUNTER(g_pctrAudioSendLost,0);
	UPDATE_COUNTER(g_pctrVideoSendLost,0);
	INIT_COUNTER_MAX(g_pctrAudioJBDelay, 500); // jitter delay above 500ms is bad


    return TRUE;
}


//  DoneCountersAndReports
//      Cleans up after all counters and reports we wanted to use

extern "C" void WINAPI DoneCountersAndReports(void)
{
    ICounterMgr* pctrmgr;

    // Release the statistics stuff if it's around
    if (!g_pCtrMgr)
        return;

    // Zero out the interface pointer so we don't accidentally use it elsewhere
    pctrmgr = g_pCtrMgr;
    g_pCtrMgr = NULL;

    // Remove counters here
    DELETE_COUNTER(&g_pctrVideoSend);
    DELETE_COUNTER(&g_pctrVideoReceive);
    DELETE_COUNTER(&g_pctrVideoSendBytes);
    DELETE_COUNTER(&g_pctrVideoReceiveBytes);
    DELETE_COUNTER(&g_pctrVideoSendLost);

    DELETE_COUNTER(&g_pctrAudioSendBytes);
    DELETE_COUNTER(&g_pctrAudioReceiveBytes);
    DELETE_COUNTER(&g_pctrAudioSendLost);

    DELETE_COUNTER(&g_pctrVideoCPUuse);
    DELETE_COUNTER(&g_pctrVideoBWuse);

    DELETE_COUNTER(&g_pctrAudioJBDelay);
	
    // Remove reports here
    DELETE_REPORT(&g_prptCallParameters);
    DELETE_REPORT(&g_prptSystemSettings);

    // Done with ICounterMgr
    pctrmgr->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\counters.h ===
//  COUNTERS.H
//
//      Global performance counters for the nac
//
//  Created 13-Nov-96 [JonT]


#ifndef _COUNTERS_H
#define _COUNTER_H

#include <objbase.h>
#include "icounter.h"

// Interface pointer to counter manager object.
// If this pointer is NULL, stats are not around (or not initialized)
extern ICounterMgr* g_pCtrMgr;

// Counter pointers. All available counters should be listed here
extern ICounter* g_pctrVideoSend;
extern ICounter* g_pctrVideoReceive;
extern ICounter* g_pctrVideoSendBytes;
extern ICounter* g_pctrVideoReceiveBytes;
extern ICounter* g_pctrVideoSendLost;

extern ICounter* g_pctrAudioSendBytes;
extern ICounter* g_pctrAudioReceiveBytes;
extern ICounter* g_pctrAudioSendLost;

extern ICounter* g_pctrVideoCPUuse;
extern ICounter* g_pctrVideoBWuse;
extern ICounter* g_pctrAudioJBDelay;


extern IReport* g_prptCallParameters;
extern IReport* g_prptSystemSettings;

// Helper function prototypes (COUNTER.CPP)
extern "C" BOOL WINAPI InitCountersAndReports(void);
extern "C" void WINAPI DoneCountersAndReports(void);

// Function helpers (better than using macros)
void __inline DEFINE_COUNTER(ICounter** ppctr, char* szName, DWORD dwFlags)
{
    if (g_pCtrMgr->CreateCounter(ppctr) == S_OK)
        (*ppctr)->Initialize(szName, dwFlags);
}

void __inline DELETE_COUNTER(ICounter** ppctr)
{
    ICounter* pctrT;

    if (*ppctr)
    {
        pctrT = *ppctr;
        *ppctr = NULL;
        pctrT->Release();
    }
}

void __inline UPDATE_COUNTER(ICounter* pctr, int nValue)
{
    if (pctr)
        pctr->Update(nValue);
}

void __inline INIT_COUNTER_MAX(ICounter* pctr, int nMaxValue)
{
    if (pctr)
        pctr->InitMax(nMaxValue);
}

void __inline DEFINE_REPORT(IReport** pprpt, char* szName, DWORD dwFlags)
{
    if (g_pCtrMgr->CreateReport(pprpt) == S_OK)
        (*pprpt)->Initialize(szName, dwFlags);
}

void __inline DELETE_REPORT(IReport** pprpt)
{
    IReport* prptT;

    if (*pprpt)
    {
        prptT = *pprpt;
        *pprpt = NULL;
        prptT->Release();
    }
}

void __inline DEFINE_REPORT_ENTRY(IReport* prpt, char* szName, DWORD dwIndex)
{
    if (prpt)
        prpt->CreateEntry(szName, dwIndex);
}

void __inline UPDATE_REPORT_ENTRY(IReport* prpt, int nValue, DWORD dwIndex)
{
    if (prpt)
        prpt->Update(nValue, dwIndex);
}

#endif // #ifndef _COUNTERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\datapump.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    datapump.h

Abstract:
	Contains constants and class declarations for the DataPump object. The DataPump controls
	the streaming of audio/video information between the network and the local record/playback
	source. It contains  or references several subclasses that deal with the multimedia devices,
	compression apis, buffer streaming and the network transport.
	
--*/
#ifndef _DATAPUMP_H_
#define _DATAPUMP_H_

#include "PacketSender.h"
#include "imstream.h"
#include "ThreadEvent.h"

#include <pshpack8.h> /* Assume 8 byte packing throughout */

typedef HANDLE DPHANDLE;

//move this to nac..
#define 	MEDIA_ID_AUDIO		1
#define		MEDIA_ID_VIDEO		2

#define DEF_SILENCE_LIMIT		10
#define DEF_MISSING_LIMIT		10

#define DP_PROP_DUPLEX_TYPE		100		// internal version of PROP_DUPLEX_TYPE
										// needs to be above the PROP_xxx range in iprop.h

#define DP_MASK_PLATFORM		0xFF000000UL
#define DP_FLAG_ACM				0x01000000UL
#define DP_FLAG_QUARTZ			0x02000000UL
#define DP_FLAG_MMSYSTEM		0x04000000UL
#define DP_FLAG_AUDIO			DP_FLAG_MMSYSTEM
#define DP_FLAG_DIRECTSOUND		0x08000000UL
#define DP_FLAG_VCM				0x10000000UL
#define DP_FLAG_VIDEO			0x20000000UL

#define DP_MASK_TRANSPORT		0x00F00000UL
#define DP_FLAG_SEND			0x00100000UL
#define DP_FLAG_RECV			0x00200000UL

#define DP_MASK_DUPLEX			0x00030000UL
#define DP_FLAG_HALF_DUPLEX		0x00010000UL
#define DP_FLAG_FULL_DUPLEX		0x00020000UL

#define DP_MASK_WAVE_DEVICE		0x00000300UL
#define DP_FLAG_PLAY_CAP		0x00000100UL
#define DP_FLAG_RECORD_CAP		0x00000200UL

#define DP_MASK_VOICESWITCH		0x00007000UL    // used to r/w mode of voice switching
#define DP_FLAG_AUTO_SWITCH		0x00001000UL	// MODE:normal operation
#define DP_FLAG_MIC_ON			0x00002000UL	// MODE:manual "talk" control
#define DP_FLAG_MIC_OFF			0x00004000UL	// MODE:"mute"
#define DP_FLAG_AUTO_SILENCE_DETECT	0x00008000	// use auto thresholding (when auto-switching)

// m_DPFlags  is made up of the following plus some of the DP_XXX flags above
#define DPFLAG_INITIALIZED		0x00000001
#define DPFLAG_STARTED_SEND		0x00000002
#define DPFLAG_STARTED_RECV		0x00000004
#define DPFLAG_CONFIGURED_SEND	0x00000008
#define DPFLAG_CONFIGURED_RECV	0x00000010
#define DPFLAG_ENABLE_PREVIEW	0x00000020	// preview mode (video)
#define DPFLAG_AV_SYNC			0x00000040	// enable synchronization
#define DPFLAG_REAL_THING		0x00000080	// Allows distinction between preview and real call in Configure/Unconfigure

#define DPFLAG_ENABLE_SEND		0x00400000	// packets are recorded and sent
#define DPFLAG_ENABLE_RECV		0x00800000	// packets are recved and played


// ThreadFlags
#define DPTFLAG_STOP_MASK   0xFF
#define DPTFLAG_STOP_SEND	0x1
#define DPTFLAG_STOP_RECV	0x2
#define DPTFLAG_STOP_RECORD	0x4
#define DPTFLAG_STOP_PLAY	0x8
#define DPTFLAG_PAUSE_RECV	0x10
#define DPTFLAG_PAUSE_SEND	0x20
#define DPTFLAG_PAUSE_CAPTURE	0x40
#define DPTFLAG_SEND_PREAMBLE	0x100	// send I frames

	
#define MAX_MMIO_PATH 128


// the number of times the device must "fail" before a
// stream event notification gets sent
#define MAX_FAILCOUNT	3

typedef struct tagMMIOSRC
{
	BOOL		fPlayFromFile;
	HMMIO		hmmioSrc;
	MMCKINFO	ckSrc;
	MMCKINFO	ckSrcRIFF;
	DWORD		dwDataLength;
	DWORD		dwMaxDataLength;
	TCHAR		szInputFileName[MAX_MMIO_PATH];
	BOOL		fLoop;
	BOOL		fStart;
	BOOL		fStop;
	BOOL		fDisconnectAfterPlayback;
	WAVEFORMATEX wfx;
} MMIOSRC;

typedef struct tagMMIODEST
{
	BOOL		fRecordToFile;
	HMMIO		hmmioDst;
	MMCKINFO	ckDst;
	MMCKINFO	ckDstRIFF;
	DWORD		dwDataLength;
	DWORD		dwMaxDataLength;
	TCHAR		szOutputFileName[MAX_MMIO_PATH];
} MMIODEST;

namespace AudioFile
{
	HRESULT OpenSourceFile(MMIOSRC *pSrcFile, WAVEFORMATEX *pwf);
	HRESULT ReadSourceFile(MMIOSRC *pSrcFile, BYTE *pData, DWORD dwBytesToRead);
	HRESULT CloseSourceFile(MMIOSRC *pSrcFile);

	HRESULT OpenDestFile(MMIODEST *pDestFile, WAVEFORMATEX *pwf);
	HRESULT WriteDestFile(MMIODEST *pDestFile, BYTE *pData, DWORD dwBytesToWrite);
	HRESULT CloseDestFile(MMIODEST *pDestFile);
};



extern HANDLE g_hEventHalfDuplex;


#define MAX_TIMESTAMP 0xffffffffUL

/*
	TTimeout is used to schedule a thread timeout notification and is used along with
	the ThreadTimer class.
	Derive from the TTimeOut abstract class by defining the TimeoutIndication virtual function and
	pass an instance of the derived class to ThreadTimer::SetTimeout() after setting the time interval.
*/
class TTimeout
{
public:
	TTimeout() {pNext = pPrev = this;}
	void SetDueTime(DWORD msWhen) {m_DueTime = msWhen;}
	DWORD GetDueTime(void) {return m_DueTime;}
	
	friend class ThreadTimer;
private:
	class TTimeout *pNext;	// ptrs for doubly-linked-list
	class TTimeout *pPrev;	//
	DWORD m_DueTime;		// absolute time when this will fire 
	void InsertAfter(class TTimeout *pFirst) {
		pNext = pFirst->pNext;
		pPrev = pFirst;
		pFirst->pNext = this;
		pNext->pPrev = this;
	};
	void Remove(void) {
		pNext->pPrev = pPrev;
		pPrev->pNext = pNext;
		pNext = this;	// make next and prev self-referential so that Remove() is idempotent
		pPrev = this;
	}
	
protected:
	virtual void TimeoutIndication() {};

};

/*
	Implements a mechanism for a worker thread to schedule timeouts.
	The client calls SetTimeout(TTimeout *) to schedule an interval callback and CancelTimeout()
	to cancel a scheduled timeout. The main loop of the worker thread must call UpdateTime(curTime) periodically, at
	which point any elapsed timeouts will be triggered. UpdateTime() returns the time when it next needs to be called,
	which is usually the time of the earliest scheduled timeout.
	NOTE: All methods are expected to be called from the same thread so there is no need for critical sections..
*/
class ThreadTimer {
public:
	void SetTimeout(TTimeout *pTObj);
	void CancelTimeout(TTimeout  *pTObj);
	DWORD UpdateTime (DWORD curTime);

private:
	TTimeout m_TimeoutList;
	DWORD m_CurTime;

	BOOL IsEmpty() {return (&m_TimeoutList == m_TimeoutList.pNext);}
	
	
};


//flags for Start()/Stop()

#define DP_STREAM_SEND		1
#define DP_STREAM_RECV		2

// Number of video frames used to compute QoS stats
// We need at least 30 entries since the max frames
// per sec capture rate is 30. 32 allows us to figure
// out the integer stats per frame using a simple shift.
#define NUM_QOS_VID_ENTRIES 32
// The sizes of the IP and UDP header added to each packet
// need to be added to the size of the compressed packet
#define IP_HEADER_SIZE 20
#define UDP_HEADER_SIZE 8
class MediaStream;
class SendMediaStream;
class RecvMediaStream;

class DataPump : public IMediaChannelBuilder, public IVideoDevice, public IAudioDevice
{
	friend class SendAudioStream;
	friend class RecvAudioStream;
	friend class RecvDSAudioStream;

public:
	DataPump();
	~DataPump();

	// IMediaChannelBuilder
	STDMETHODIMP Initialize(HWND hWnd, HINSTANCE hInst);
	STDMETHODIMP CreateMediaChannel(UINT flags, IMediaChannel  **ppObj);
	STDMETHODIMP SetStreamEventObj(IStreamEventNotify *pNotify);

	// Internal

	void AddMediaChannel(UINT flags, IMediaChannel *pMediaChannel);
	void RemoveMediaChannel(UINT flags, IMediaChannel *pMediaChannel);
	HRESULT GetMediaChannelInterface(UINT flags, IMediaChannel **ppI);
	HRESULT StartReceiving(RecvMediaStream *pMS);
	HRESULT StopReceiving(RecvMediaStream *pMS);
	void ReleaseResources();

	STDMETHODIMP StreamEvent(UINT uDirection, UINT uMediaType, 
	                         UINT uEventType, UINT uSubCode);


    // IUnknown methods
   	STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IQOS interface pointer and two resources requests: one for BW and one for CPU
	LPIQOS		m_pIQoS;

	// Recv thread timeout scheduler
	ThreadTimer m_RecvTimer;

	CRITICAL_SECTION m_crs;	// serializes access to multithread-safe methods
	
	// the app handles are global 
	static HWND		m_hAppWnd;
	static HINSTANCE	m_hAppInst;

	PacketSender m_PacketSender;
	ThreadEventProxy *m_pTEP;

	BOOL m_bDisableRSVP;

	// IVideoDevice Methods
	// Capture Device related methods
	HRESULT __stdcall GetNumCapDev();
	HRESULT __stdcall GetMaxCapDevNameLen();
	HRESULT __stdcall EnumCapDev(DWORD *pdwCapDevIDs, TCHAR *pszCapDevNames, DWORD dwNumCapDev);
	HRESULT __stdcall GetCurrCapDevID();
	HRESULT __stdcall SetCurrCapDevID(int nCapDevID);


	// IAudioDevice Methods
	HRESULT __stdcall GetRecordID(UINT *puWaveDevID);
	HRESULT __stdcall SetRecordID(UINT uWaveDevID);
	HRESULT __stdcall GetPlaybackID(UINT *puWaveDevID);
	HRESULT __stdcall SetPlaybackID(UINT uWaveDevID);
	HRESULT __stdcall GetDuplex(BOOL *pbFullDuplex);
	HRESULT __stdcall SetDuplex(BOOL bFullDuplex);
	HRESULT __stdcall GetSilenceLevel(UINT *puLevel);
	HRESULT __stdcall SetSilenceLevel(UINT uLevel);
	HRESULT __stdcall GetAutoMix(BOOL *pbAutoMix);
	HRESULT __stdcall SetAutoMix(BOOL bAutoMix);
	HRESULT __stdcall GetDirectSound(BOOL *pbDS);
	HRESULT __stdcall SetDirectSound(BOOL bDS);
	HRESULT __stdcall GetMixer(HWND hwnd, BOOL bPlayback, IMixer **ppMixer);


protected:
	struct MediaChannel {
	public:
		SendMediaStream *pSendStream;
		RecvMediaStream *pRecvStream;
	}
	m_Audio, m_Video;

	UINT m_uRef;

	// receive thread stuff
	HANDLE m_hRecvThread;
	DWORD m_RecvThId,m_nReceivers;
	HANDLE m_hRecvThreadAckEvent;		// ack from recv thread
	// temp variables for communicating with recv thread
	HANDLE m_hRecvThreadSignalEvent;	// signal to recv thread
	RecvMediaStream *m_pCurRecvStream;	
	UINT m_CurRecvMsg;

	
	friend  DWORD __stdcall StartDPRecvThread(PVOID pDP); // pDP == pointer to DataPump
	DWORD CommonRecvThread(void);
	DWORD CommonWS2RecvThread(void);

	HRESULT RecvThreadMessage(UINT msg, RecvMediaStream *pMS);
	HRESULT SetStreamDuplex(IMediaChannel *pStream, BOOL bFullDuplex);
	
	// datapump only needs to keep track of the device ID for
	// video.  Gets a bit more complicated for Audio.
	UINT m_uVideoCaptureId;

	// IAudioDevice stuff
	UINT m_uWaveInID;
	UINT m_uWaveOutID;
	BOOL m_bFullDuplex;
	UINT m_uSilenceLevel; // 0-999 (manual)   1000- (automatic)
	BOOL m_bAutoMix;
	BOOL m_bDirectSound;

};

// messages used to signal recv thread
// must not conflict with message ids used by AsyncSock
#define MSG_START_RECV	(WM_USER + 20)
#define MSG_STOP_RECV	(WM_USER + 21)
#define MSG_EXIT_RECV	(WM_USER + 22)
#define MSG_PLAY_SOUND	(WM_USER + 23)

#include <poppack.h> /* End byte packing */

#endif	//_DATAPUMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\datapump.cpp ===
/*
	DATAPUMP.C
*/

#include "precomp.h"
#include "confreg.h"
#include "mixer.h"
#include "dscStream.h"

extern UINT g_MinDSEmulAudioDelayMs; // minimum millisecs of introduced playback delay (DirectSound on emulated drivers)
extern UINT g_MinWaveAudioDelayMs;	 // minimum millisecs of introduced playback delay (Wave)
extern UINT g_MaxAudioDelayMs;	// maximum milliesecs of introduced playback delay
extern UINT g_AudioPacketDurationMs;	// preferred packet duration

extern int g_wavein_prepare, g_waveout_prepare;
extern int g_videoin_prepare, g_videoout_prepare;

#define RSVP_KEY	TEXT("RSVP")

HANDLE g_hEventHalfDuplex = NULL;

HWND DataPump::m_hAppWnd = NULL;
HINSTANCE DataPump::m_hAppInst = NULL;


HRESULT WINAPI CreateStreamProvider(IMediaChannelBuilder **lplpSP)
{
	DataPump * pDataPump;
	if(!lplpSP)
		return DPR_INVALID_PARAMETER;
		
    DBG_SAVE_FILE_LINE
	pDataPump = new DataPump;	
	if(NULL == pDataPump)
		return	DPR_OUT_OF_MEMORY;
		
	// the refcount of DataPump is 1.  Don't call pDataPump->QueryInterface(), 
	// just do what QueryInterface() would do except don't increment refcount
	*lplpSP = (IMediaChannelBuilder *)pDataPump; 
	return hrSuccess;
}


DataPump::DataPump(void)
:m_uRef(1)
{
	ClearStruct( &m_Audio );
	ClearStruct( &m_Video );
	InitializeCriticalSection(&m_crs);

    // Create performance counters
    InitCountersAndReports();
}

DataPump::~DataPump(void)
{
	ReleaseResources();

	WSACleanup();
	DeleteCriticalSection(&m_crs);

    // We're done with performance counters
    DoneCountersAndReports();
}

HRESULT __stdcall DataPump::Initialize(HWND hWnd, HINSTANCE hInst)
{
	HRESULT hr = DPR_OUT_OF_MEMORY;
	FX_ENTRY ("DP::Init")
	WSADATA WSAData;
	int status;
	BOOL fDisableWS2;
	UINT uMinDelay;
	TCHAR *szKey = NACOBJECT_KEY TEXT("\\") RSVP_KEY;
	RegEntry reRSVP(szKey, HKEY_LOCAL_MACHINE, FALSE);
	
	if((NULL == hWnd) || (NULL == hInst))
		goto InitError;
		
	m_hAppInst = hInst; 
	m_hAppWnd = hWnd;

	status = WSAStartup(MAKEWORD(1,1), &WSAData);
	if(status !=0)
	{
		ERRORMESSAGE(("CNac::Init:WSAStartup failed\r\n"));
		goto InitError;
	}

		// Introduce scope to allow creation of object after goto statements
	{
	
		// get settings from registry  
		RegEntry reNac(szRegInternetPhone TEXT("\\") szRegInternetPhoneNac, 
						HKEY_LOCAL_MACHINE,
						FALSE,
						KEY_READ);

		g_MaxAudioDelayMs = reNac.GetNumberIniStyle(TEXT ("MaxAudioDelayMs"), g_MaxAudioDelayMs);

		uMinDelay = reNac.GetNumberIniStyle(TEXT ("MinAudioDelayMs"), 0);

		if (uMinDelay != 0)
		{
			g_MinWaveAudioDelayMs = uMinDelay;
			g_MinDSEmulAudioDelayMs = uMinDelay;
		}

		fDisableWS2 = reNac.GetNumberIniStyle(TEXT ("DisableWinsock2"), 0);

	}
#ifdef OLDSTUFF
	// to be safe, only try loading WS2_32 if WSOCK32 is passing
	// thru to it. Once we make sure that we link to the same DLL for all
	// Winsock calls to a socket, this check can possibly be removed.
	if (LOBYTE(WSAData.wHighVersion) >= 2 && !fDisableWS2)
		TryLoadWinsock2();
#endif	
	// Initialize data (should be in constructor)

	g_hEventHalfDuplex = CreateEvent (NULL, FALSE, TRUE, __TEXT ("AVC:HalfDuplex"));
	if (g_hEventHalfDuplex == NULL)
	{
		DEBUGMSG (ZONE_DP, ("%s: CreateEvent failed, LastErr=%lu\r\n", _fx_, GetLastError ()));
		hr = DPR_CANT_CREATE_EVENT;
		return hr;
	}

	// Initialize QoS. If it fails, that's Ok, we'll do without it.
	// No need to set the resource ourselves, this now done by the UI
	hr = CreateQoS (NULL, IID_IQoS, (void **)&m_pIQoS);
	if (hr != DPR_SUCCESS)
		m_pIQoS = (LPIQOS)NULL;

	m_bDisableRSVP = reRSVP.GetNumber("DisableRSVP", FALSE);


	LogInit();	// Initialize log

    //No receive channels yet
    m_nReceivers=0;

	// IVideoDevice initialize
	m_uVideoCaptureId = -1;  // (VIDEO_MAPPER)

	// IAudioDevice initialize
	m_uWaveInID = WAVE_MAPPER;
	m_uWaveOutID = WAVE_MAPPER;
	m_bFullDuplex = FALSE;
	m_uSilenceLevel = 1000;  // automatic silence detection
	m_bAutoMix = FALSE;
	m_bDirectSound = FALSE;


	return DPR_SUCCESS;

InitError:
	ERRORMESSAGE( ("DataPump::Initialize: exit, hr=0x%lX\r\n",  hr));

	return hr;
}


STDMETHODIMP
DataPump::CreateMediaChannel( UINT flags, IMediaChannel **ppIMC)
{
	IUnknown *pUnkOuter = NULL;
	IMediaChannel *pStream = NULL;
	HRESULT hr = E_FAIL;

	// try to be consistant about which parent classes we cast to

	*ppIMC = NULL;

	
	if (flags & MCF_AUDIO)
	{
		if ((flags & MCF_SEND) && !m_Audio.pSendStream)
		{
			if (m_bDirectSound && (DSC_Manager::Initialize() == S_OK))
            {
                DBG_SAVE_FILE_LINE
				pStream = (IMediaChannel*)(SendMediaStream*)new SendDSCStream;
            }
			else
            {
                DBG_SAVE_FILE_LINE
				pStream = (IMediaChannel*)(SendMediaStream*)new SendAudioStream;
            }

		}
		else if ((flags & MCF_RECV) && !m_Audio.pRecvStream)
		{
			if (m_bDirectSound && (DirectSoundMgr::Initialize() == S_OK))
            {
                DBG_SAVE_FILE_LINE
				pStream = (IMediaChannel*)(RecvMediaStream*)new RecvDSAudioStream;
            }
			else
            {
                DBG_SAVE_FILE_LINE
				pStream = (IMediaChannel*)(RecvMediaStream*)new RecvAudioStream;
            }
		}
	}
	else if (flags  & MCF_VIDEO)
	{
		if ((flags & MCF_SEND) && !m_Video.pSendStream)
		{
            DBG_SAVE_FILE_LINE
			pStream =  (IMediaChannel*)(SendMediaStream*) new SendVideoStream;
		}
		else if ((flags & MCF_RECV) && !m_Video.pRecvStream)
		{
            DBG_SAVE_FILE_LINE
			pStream = (IMediaChannel*)(RecvMediaStream*) new RecvVideoStream;
		}
	}
	else
		hr = E_INVALIDARG;

	if (pStream != NULL) {
		// need to inc the refCount of the object
		pStream->AddRef();

		hr = (flags & MCF_SEND) ?
				((SendMediaStream *)pStream)->Initialize( this)
				: ((RecvMediaStream *)pStream)->Initialize(this);

		if (hr == S_OK)
		{
			hr = pStream->QueryInterface(IID_IMediaChannel, (void **)ppIMC);
		}
		if (hr == S_OK)
		{
			AddMediaChannel(flags, pStream);
		}


		// calling to the IVideoDevice and IAudioDevice methods
		// prior to creating the corresponding channel object
		// require when they get created

		// video only needs it's device ID set
		if ((flags & MCF_SEND) && (flags & MCF_VIDEO))
		{
			SetCurrCapDevID(m_uVideoCaptureId);
		}

		// audio streams need several properties set
		if (flags & MCF_AUDIO)
		{
			if (flags & MCF_SEND)
			{
				SetSilenceLevel(m_uSilenceLevel);
				SetAutoMix(m_bAutoMix);
				SetRecordID(m_uWaveInID);
			}
			else if (flags & MCF_RECV)
			{
				SetPlaybackID(m_uWaveOutID);
			}
			SetStreamDuplex(pStream, m_bFullDuplex);
		}

		// to avoid a circular ref-count,
		// dont keep a hard reference to MediaChannel objects 
		// MediaChannel will call RemoveMediaChannel before it goes away..
		pStream->Release();
		pStream = NULL;
	}
	return hr;
}


STDMETHODIMP DataPump::SetStreamEventObj(IStreamEventNotify *pNotify)
{

	EnterCriticalSection(&m_crs);

	if (m_pTEP)
	{
		delete m_pTEP;
		m_pTEP = NULL;
	}

	if (pNotify)
	{
        DBG_SAVE_FILE_LINE
		m_pTEP = new ThreadEventProxy(pNotify, m_hAppInst);
	}

	LeaveCriticalSection(&m_crs);

	return S_OK;

}


// this function gets called by the stream threads when an event occurs
STDMETHODIMP DataPump::StreamEvent(UINT uDirection, UINT uMediaType, 
								   UINT uEventType, UINT uSubCode)
{
	BOOL bRet = FALSE;

	EnterCriticalSection(&m_crs);
	
	if (m_pTEP)
	{
		bRet = m_pTEP->ThreadEvent(uDirection, uMediaType, uEventType, uSubCode);
	}

	LeaveCriticalSection(&m_crs);

	return bRet;
}


void
DataPump::AddMediaChannel(UINT flags, IMediaChannel *pMediaChannel)
{
	EnterCriticalSection(&m_crs);
	if (flags & MCF_SEND)
	{
		SendMediaStream *pS = static_cast<SendMediaStream *> (pMediaChannel);
		if (flags & MCF_AUDIO) 
			m_Audio.pSendStream = pS;
		else if (flags & MCF_VIDEO)
			m_Video.pSendStream = pS;
	}
	else if (flags & MCF_RECV)
	{
		RecvMediaStream *pR = static_cast<RecvMediaStream *> (pMediaChannel);
		if (flags & MCF_AUDIO) 
			m_Audio.pRecvStream = pR;
		else if (flags & MCF_VIDEO)
			m_Video.pRecvStream = pR;
	}
	LeaveCriticalSection(&m_crs);
}

void
DataPump::RemoveMediaChannel(UINT flags, IMediaChannel *pMediaChannel)
{
	EnterCriticalSection(&m_crs);
	if (flags & MCF_SEND)
	{
		if (flags & MCF_AUDIO)
		{
			ASSERT(pMediaChannel == m_Audio.pSendStream);
			if (pMediaChannel == m_Audio.pSendStream)
				m_Audio.pSendStream = NULL;
		}
		else if (flags & MCF_VIDEO)
		{
			ASSERT(pMediaChannel == m_Video.pSendStream);
			m_Video.pSendStream = NULL;
		}
	}
	else if (flags & MCF_RECV)
	{
		if (flags & MCF_AUDIO) 
		{
			ASSERT(pMediaChannel == m_Audio.pRecvStream);
			m_Audio.pRecvStream = NULL;
		}
		else if (flags & MCF_VIDEO)
		{
			ASSERT(pMediaChannel == m_Video.pRecvStream);
			m_Video.pRecvStream = NULL;
		}
	}
	LeaveCriticalSection(&m_crs);
	
}

// called by Record Thread and Receive Thread, usually to get the
// opposite channel
HRESULT DataPump::GetMediaChannelInterface( UINT flags, IMediaChannel **ppI)
{
//	extern IID IID_IMediaChannel;
	
	IMediaChannel *pStream = NULL;

	HRESULT hr;
	EnterCriticalSection(&m_crs);
	if (flags & MCF_AUDIO) {
		if (flags & MCF_SEND) {
			pStream =  m_Audio.pSendStream;
		} else if (flags & MCF_RECV) {
			pStream =  m_Audio.pRecvStream;
		}
	}
	else if (flags & MCF_VIDEO) {
		if (flags & MCF_SEND) {
			pStream =  m_Video.pSendStream;
		} else if (flags & MCF_RECV) {
			pStream =  m_Video.pRecvStream;
		}
	} else
		hr = DPR_INVALID_PARAMETER;
	if (pStream) {
			// need to inc the refCount of the object
			hr = (pStream)->QueryInterface(IID_IMediaChannel, (PVOID *)ppI);
	} else
		hr = E_NOINTERFACE;
	LeaveCriticalSection(&m_crs);
	return hr;
}


DWORD __stdcall StartDPRecvThread(PVOID pVoid)
{
	DataPump *pDP = (DataPump*)pVoid;
	return pDP->CommonWS2RecvThread();
}



STDMETHODIMP DataPump::QueryInterface( REFIID iid,	void ** ppvObject)
{
	// this breaks the rules for the official COM QueryInterface because
	// the interfaces that are queried for are not necessarily real COM
	// interfaces.  The reflexive property of QueryInterface would be broken in
	// that case.
	HRESULT hr = E_NOINTERFACE;
	if(!ppvObject)
		return hr;
		
	*ppvObject = NULL;
	if(iid == IID_IUnknown)// satisfy symmetric property of QI
	{
		*ppvObject = this;
		hr = hrSuccess;
		AddRef();
	}
	else if(iid == IID_IMediaChannelBuilder)
	{
		*ppvObject = (IMediaChannelBuilder *)this;
		hr = hrSuccess;
		AddRef();
	}
	else if (iid == IID_IVideoDevice)
	{
		*ppvObject = (IVideoDevice *)this;
		hr = hrSuccess;
		AddRef();
	}

	else if (iid == IID_IAudioDevice)
	{
		*ppvObject = (IAudioDevice*)this;
		hr = hrSuccess;
		AddRef();
	}
	
	return (hr);
}
ULONG DataPump::AddRef()
{
	m_uRef++;
	return m_uRef;
}

ULONG DataPump::Release()
{
	m_uRef--;
	if(m_uRef == 0)
	{
		m_hAppWnd = NULL;
		m_hAppInst = NULL;
		delete this;
		return 0;
	}
	return m_uRef;
}


void
DataPump::ReleaseResources()
{
	FX_ENTRY ("DP::ReleaseResources")

#ifdef DEBUG
	if (m_Audio.pSendStream)
		ERRORMESSAGE(("%s: Audio Send stream still around => Ref count LEAK!\n", _fx_));
	if (m_Audio.pRecvStream)
		ERRORMESSAGE(("%s: Audio Recv stream still around => Ref count LEAK!\n", _fx_));
	if (m_Video.pSendStream)
		ERRORMESSAGE(("%s: Video Send stream still around => Ref count LEAK!\n", _fx_));
	if (m_Video.pRecvStream)
		ERRORMESSAGE(("%s: Video Recv stream still around => Ref count LEAK!\n", _fx_));
#endif

	// close debug log
	LogClose();

	// Free QoS resources
	if (m_pIQoS)
	{
		m_pIQoS->Release();
		m_pIQoS = (LPIQOS)NULL;
	}

	// Close the receive and transmit streams
	if (g_hEventHalfDuplex)
	{
		CloseHandle (g_hEventHalfDuplex);
		g_hEventHalfDuplex = NULL;
	}

}


HRESULT DataPump::SetStreamDuplex(IMediaChannel *pStream, BOOL bFullDuplex)
{
	BOOL fOn = (pStream->GetState() == MSSTATE_STARTED);
	BOOL bStreamFullDuplex;
	UINT uSize = sizeof(BOOL);

	pStream->GetProperty(PROP_DUPLEX_TYPE, &bStreamFullDuplex, &uSize);

	if (bStreamFullDuplex != bFullDuplex)
	{
		if (fOn)
		{
			pStream->Stop();
		}

		pStream->SetProperty(DP_PROP_DUPLEX_TYPE, &bFullDuplex, sizeof(BOOL));

		if (fOn)
		{
			pStream->Start();
		}
	}
	return S_OK;
}


HRESULT __stdcall DataPump::SetDuplex(BOOL bFullDuplex)
{
	IMediaChannel *pS = m_Audio.pSendStream;
	IMediaChannel *pR = m_Audio.pRecvStream;
	IMediaChannel *pStream;
	BOOL fPlayOn = FALSE;
    BOOL fRecOn = FALSE;
	UINT uSize;
	BOOL bRecDuplex, bPlayDuplex;

	m_bFullDuplex = bFullDuplex ? TRUE : FALSE;

	UPDATE_REPORT_ENTRY(g_prptSystemSettings, (m_bFullDuplex) ? 1 : 0, REP_SYS_AUDIO_DUPLEX);
	RETAILMSG(("NAC: Audio Duplex Type: %s",(m_bFullDuplex) ? "Full Duplex" : "Half Duplex"));


	// no streams ?  No problem.
	if ((pS == NULL) && (pR == NULL))
	{
		return S_OK;
	}


	// only one stream
	if ((pS || pR) && !(pS && pR))
	{
		if (pS)
			pStream = pS;
		else
			pStream = pR;

		return SetStreamDuplex(pStream, m_bFullDuplex);
	}


	// assert - pS && pR

	// both streams exist

	// try to avoid the whole start/stop sequence if the duplex
	// is the same
	uSize=sizeof(BOOL);
	pR->GetProperty(PROP_DUPLEX_TYPE, &bRecDuplex, &uSize);
	uSize=sizeof(BOOL);
	pS->GetProperty(PROP_DUPLEX_TYPE, &bPlayDuplex, &uSize);

	if ( (bPlayDuplex == m_bFullDuplex) &&
	     (bRecDuplex == m_bFullDuplex))
	{
		return S_OK;
	}


	// save the old thread flags
	fPlayOn = (pR->GetState() == MSSTATE_STARTED);
	fRecOn = (pS->GetState() == MSSTATE_STARTED);

	// Ensure the record and playback threads are stopped
	pR->Stop();
	pS->Stop();

	SetStreamDuplex(pR, m_bFullDuplex);
	SetStreamDuplex(pS, m_bFullDuplex);

	// Resume the record/playback
	// Try to let play start before record - DirectS and SB16 prefer that!
	if (fPlayOn)
	{
		pR->Start();
	}

	if (fRecOn)
	{
		pS->Start();
	}

	return DPR_SUCCESS;
}

#define LONGTIME	60000	// 60 seconds

// utility function to synchronously communicate a
// a state change to the recv thread
HRESULT DataPump::RecvThreadMessage(UINT msg, RecvMediaStream *pMS)
{
	BOOL fSignaled;
	DWORD dwWaitStatus;
	HANDLE handle;
	// Unfortunately cant use PostThreadMessage to signal the thread
	// because it doesnt have a message loop
	m_pCurRecvStream = pMS;
	m_CurRecvMsg = msg;
	fSignaled = SetEvent(m_hRecvThreadSignalEvent);
    	
	
	if (fSignaled) {

		handle =  (msg == MSG_EXIT_RECV ? m_hRecvThread : m_hRecvThreadAckEvent);
    	dwWaitStatus = WaitForSingleObject(handle, LONGTIME);
    	ASSERT(dwWaitStatus == WAIT_OBJECT_0);
    	if (dwWaitStatus != WAIT_OBJECT_0)
    		return GetLastError();
    } else
    	return GetLastError();
    
    return S_OK;
}

// start receiving on this stream
// will create the receive thread if necessary.
HRESULT
DataPump::StartReceiving(RecvMediaStream *pMS)
{
	DWORD dwWaitStatus;
	FX_ENTRY("DP::StartReceiving")
	// one more stream
	m_nReceivers++;	
	if (!m_hRecvThread) {
		ASSERT(m_nReceivers==1);
		ASSERT(!m_hRecvThreadAckEvent);
    	//Use this for thread event notifications. I.e. Video started/stopped, audio stopped, et al.
    	//m_hRecvThreadChangeEvent=CreateEvent (NULL,FALSE,FALSE,NULL);
	   	//create the stopping sync event
	   	m_hRecvThreadAckEvent=CreateEvent (NULL,FALSE,FALSE,NULL);
		m_hRecvThreadSignalEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
	   	
	    m_hRecvThread = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)StartDPRecvThread,(PVOID)this,0,&m_RecvThId);
		DEBUGMSG(ZONE_DP,("%s: RecvThread Id=%x\n",_fx_,m_RecvThId));
		// thread will signal event soon as its message loop is ready
    	dwWaitStatus = WaitForSingleObject(m_hRecvThreadAckEvent, LONGTIME);
    	ASSERT(dwWaitStatus == WAIT_OBJECT_0);
	}
    
	//Tell the recv Thread to start receiving on this MediaStream
	return RecvThreadMessage(MSG_START_RECV,pMS);	
    
    
}

// Stop receiving on the stream
// will stop the receive thread if necessary
HRESULT
DataPump::StopReceiving(RecvMediaStream *pMS)
{
	HANDLE rgh[2];
	ASSERT(m_nReceivers > 0);
	ASSERT(m_hRecvThread);
	if (m_nReceivers > 0)
		m_nReceivers--;

	RecvThreadMessage(MSG_STOP_RECV, pMS);
	
	if (!m_nReceivers && m_hRecvThread) {
		// kill the receive thread
		RecvThreadMessage(MSG_EXIT_RECV,NULL);
		
		CloseHandle(m_hRecvThread);
		CloseHandle(m_hRecvThreadAckEvent);
		m_hRecvThread = NULL;
		m_hRecvThreadAckEvent = NULL;
		if (m_hRecvThreadSignalEvent) {
			CloseHandle(m_hRecvThreadSignalEvent);
			m_hRecvThreadSignalEvent = NULL;
		}
	}
	return S_OK;
}


//
// IVideoDevice Methods
//

// Capture device methods

// Gets the number of enabled capture devices
// Returns -1L on error
HRESULT __stdcall DataPump::GetNumCapDev()
{
	FINDCAPTUREDEVICE fcd;

	// scan for broken or unplugged devices
	FindFirstCaptureDevice(&fcd, NULL);

	return (GetNumCaptureDevices());
}

// Gets the max size of the captuire device name
// Returns -1L on error
HRESULT __stdcall DataPump::GetMaxCapDevNameLen()
{
	return (MAX_CAPDEV_NAME + MAX_CAPDEV_DESCRIPTION);
}

// Enum list of enabled capture devices
// Fills up 1st buffer with device IDs, 2nd buffer with device names
// Third parameter is the max number of devices to enum
// Returns number of devices enum-ed
HRESULT __stdcall DataPump::EnumCapDev(DWORD *pdwCapDevIDs, TCHAR *pszCapDevNames, DWORD dwNumCapDev)
{
	FINDCAPTUREDEVICE fcd;
	DWORD dwNumCapDevFound = 0;

	fcd.dwSize = sizeof (FINDCAPTUREDEVICE);
	if (FindFirstCaptureDevice(&fcd, NULL))
	{
		do
		{
			pdwCapDevIDs[dwNumCapDevFound] =  fcd.nDeviceIndex;

			// Build device name out of the capture device strings
			if (fcd.szDeviceDescription && fcd.szDeviceDescription[0] != '\0')
				lstrcpy(pszCapDevNames + dwNumCapDevFound * (MAX_CAPDEV_NAME + MAX_CAPDEV_DESCRIPTION), fcd.szDeviceDescription);
			else
				lstrcpy(pszCapDevNames + dwNumCapDevFound * (MAX_CAPDEV_NAME + MAX_CAPDEV_DESCRIPTION), fcd.szDeviceName);
			if (fcd.szDeviceVersion && fcd.szDeviceVersion[0] != '\0')
			{
				lstrcat(pszCapDevNames + dwNumCapDevFound * (MAX_CAPDEV_NAME + MAX_CAPDEV_DESCRIPTION), ", ");
				lstrcat(pszCapDevNames + dwNumCapDevFound * (MAX_CAPDEV_NAME + MAX_CAPDEV_DESCRIPTION), fcd.szDeviceVersion);
			}
			dwNumCapDevFound++;
		} while ((dwNumCapDevFound < dwNumCapDev) && FindNextCaptureDevice(&fcd));
	}

	return (dwNumCapDevFound);
}

HRESULT __stdcall DataPump::GetCurrCapDevID()
{
	UINT uCapID;
	UINT uSize = sizeof(UINT);

	// even though we know the value of the last call
	// to SetCurrCapDevID, the stream may have resulted in using
	// wave_mapper (-1).  We want to be able to return -1, if this
	// is the case.  However, the channel objects don't do this yet.
	// (they still return the same value as m_uVideoCaptureId)

	if (m_Video.pSendStream)
	{
		m_Video.pSendStream->GetProperty(PROP_CAPTURE_DEVICE, &uCapID, &uSize);
#ifdef DEBUG
		if (uCapID != m_uVideoCaptureId)
		{
			DEBUGMSG(ZONE_DP,("Video capture stream had to revert to MAPPER or some other device"));
		}
#endif
		return uCapID;
	}

	return m_uVideoCaptureId;

}


HRESULT __stdcall DataPump::SetCurrCapDevID(int nCapDevID)
{
	m_uVideoCaptureId = (UINT)nCapDevID;

	if (m_Video.pSendStream)
	{
		m_Video.pSendStream->SetProperty(PROP_CAPTURE_DEVICE, &m_uVideoCaptureId, sizeof(m_uVideoCaptureId));
	}
	return S_OK;
}




// IAudioDevice methods
HRESULT __stdcall DataPump::GetRecordID(UINT *puWaveDevID)
{
	*puWaveDevID = m_uWaveInID;
	return S_OK;
}

HRESULT __stdcall DataPump::SetRecordID(UINT uWaveDevID)
{
	m_uWaveInID = uWaveDevID;

	if (m_Audio.pSendStream)
	{
		m_Audio.pSendStream->SetProperty(PROP_RECORD_DEVICE, &m_uWaveInID, sizeof(m_uWaveInID));
	}
	return S_OK;

}


HRESULT __stdcall DataPump::GetPlaybackID(UINT *puWaveDevID)
{
	// like video, the audio device may have resorted to using
	// WAVE_MAPPER.  We'd like to be able to detect that

	*puWaveDevID = m_uWaveOutID;
	return S_OK;
}

HRESULT __stdcall DataPump::SetPlaybackID(UINT uWaveDevID)
{
	m_uWaveOutID = uWaveDevID;

	if (m_Audio.pRecvStream)
	{
		m_Audio.pRecvStream->SetProperty(PROP_PLAYBACK_DEVICE, &m_uWaveOutID, sizeof(m_uWaveOutID));
	}
	return S_OK;

}

HRESULT __stdcall DataPump::GetSilenceLevel(UINT *puLevel)
{
	*puLevel = m_uSilenceLevel;
	return S_OK;
}


HRESULT __stdcall DataPump::SetSilenceLevel(UINT uLevel)
{
	m_uSilenceLevel = uLevel;

	if (m_Audio.pSendStream)
	{
		m_Audio.pSendStream->SetProperty(PROP_SILENCE_LEVEL, &m_uSilenceLevel, sizeof(m_uSilenceLevel));
	}
	return S_OK;
}


HRESULT __stdcall DataPump::GetDuplex(BOOL *pbFullDuplex)
{
	*pbFullDuplex = m_bFullDuplex;
	return S_OK;
}



HRESULT __stdcall DataPump::GetMixer(HWND hwnd, BOOL bPlayback, IMixer **ppMixer)
{
	CMixerDevice *pMixerDevice;
	DWORD dwFlags;
	HRESULT hr = E_NOINTERFACE;

	// unfortunately, trying to create a mixer when WAVE_MAPPER
	// has been specified as the device ID results in a mixer
	// that doesn't work on Win95.

	*ppMixer = NULL;
	
	if ((bPlayback) && (m_uWaveOutID != WAVE_MAPPER))
	{
		pMixerDevice = CMixerDevice::GetMixerForWaveDevice(hwnd, m_uWaveOutID, MIXER_OBJECTF_WAVEOUT);
	}
	else if (m_uWaveInID != WAVE_MAPPER)
	{
		pMixerDevice = CMixerDevice::GetMixerForWaveDevice(hwnd, m_uWaveInID, MIXER_OBJECTF_WAVEIN);
	}

	if (pMixerDevice)
	{
		hr = pMixerDevice->QueryInterface(IID_IMixer, (void**)ppMixer);
	}

	return hr;
}


HRESULT __stdcall DataPump::GetAutoMix(BOOL *pbAutoMix)
{
	*pbAutoMix = m_bAutoMix;
	return S_OK;
}

HRESULT __stdcall DataPump::SetAutoMix(BOOL bAutoMix)
{
	m_bAutoMix = bAutoMix;
	if (m_Audio.pSendStream)
	{
		m_Audio.pSendStream->SetProperty(PROP_AUDIO_AUTOMIX, &m_bAutoMix, sizeof(m_bAutoMix));
	}
	return S_OK;
}

HRESULT __stdcall DataPump::GetDirectSound(BOOL *pbDS)
{
	*pbDS = m_bDirectSound;
	return S_OK;
}

HRESULT __stdcall DataPump::SetDirectSound(BOOL bDS)
{
	m_bDirectSound = bDS;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\devaudq.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    devaudq.h

Abstract:
	Simple circular queue of MediaPacket structures used to keep track of audio buffers
	while they're being recorded/played.

--*/
#ifndef _DEVAUDQ_H_
#define _DEVAUDQ_H_

#include <pshpack8.h> /* Assume 8 byte packing throughout */

class DevMediaQueue
{
private:

	UINT			m_uBegin;
	UINT			m_uEnd;

	UINT			m_uMaxNum;
	MediaPacket		**m_paPackets;

public:

	DevMediaQueue ( void );
	~DevMediaQueue ( void );

	void SetSize ( UINT uMaxNum );
	void Put ( MediaPacket * p );
	MediaPacket * Get ( void );
	MediaPacket * Peek ( void );
};

#include <poppack.h> /* End byte packing */

#endif // _DEVAUDQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\dscstream.h ===
#ifndef SEND_DSC_STREAM_H
#define SEND_DSC_STREAM_H

#include "agc.h"


#include <pshpack8.h> /* Assume 8 byte packing throughout */


#define MAX_DSC_DESCRIPTION_STRING 200
#define MAX_NUMBER_DSCAPTURE_DEVICES 16
#define NUM_AUDIOPACKETS 2
#define MIN_NUM_DSC_SEGMENTS 5

#define DSOUND_DLL	"dsound.dll"

#define DISABLE_DSC_REGKEY	 "Software\\Microsoft\\Internet Audio\\NacObject"
#define DISABLE_DSC_REGVALUE "DisableDirectSoundCapture"



typedef HRESULT (WINAPI *DS_CAP_CREATE)(LPGUID, LPDIRECTSOUNDCAPTURE *, LPUNKNOWN);
typedef HRESULT (WINAPI *DS_CAP_ENUM)(LPDSENUMCALLBACKA, LPVOID);


struct DSC_CAPTURE_INFO
{
	GUID guid;
	char szDescription[MAX_DSC_DESCRIPTION_STRING];
	UINT uWaveId;
	BOOL bAllocated;
};


// really a namespace
class DSC_Manager
{
public:
	static HRESULT Initialize();
	static HRESULT MapWaveIdToGuid(UINT uwaveId, GUID *pGuid);
	static HRESULT CreateInstance(GUID *pGuid, IDirectSoundCapture **pDSC);

private:
	static BOOL s_bInitialized;

	static DSC_CAPTURE_INFO s_aDSC[MAX_NUMBER_DSCAPTURE_DEVICES];
	static int s_nCaptureDevices; // number in array

	static BOOL CALLBACK DSEnumCallback(LPGUID lpGuid, LPCSTR lpcstrDescription,
	                           LPCSTR lpcstrModule, LPVOID lpContext);

	static HINSTANCE s_hDSCLib;

	static DS_CAP_CREATE s_pDSCapCreate;
	static DS_CAP_ENUM s_pDSCapEnum;

};



class SendDSCStream : public SendMediaStream, public IAudioChannel, public IDTMFSend
{
private:
	AcmFilter *m_pAudioFilter;  // encapsulates codec
	WAVEFORMATEX m_wfPCM;       // uncompressed recording format
	WAVEFORMATEX m_wfCompressed; // compressed format
	AudioSilenceDetector m_AudioMonitor;
	MMIOSRC		m_mmioSrc;  // handle to input file


	static DWORD CALLBACK StartRecordingThread (LPVOID pVoid);
	DWORD RecordingThread();

	STDMETHODIMP_(void) UnConfigure(void);
	LONG m_lRefCount;

	IDirectSoundCapture *m_pDSC; // DSC device object
	IDirectSoundCaptureBuffer *m_pDSCBuffer; // the capture buffer

	HANDLE m_hEvent;  // DSC Notify Event


	DWORD m_dwSamplesPerFrame; // number of PCM samples represented in a frame
	DWORD m_dwNumFrames; // number of individual frames in the DSC Buffer
	DWORD m_dwFrameSize; // the size of a PCM frame in bytes
	DWORD m_dwDSCBufferSize; // the size of the DSC Buffer (== m_dwFrameSize * m_dwNumFrames)
	DWORD m_dwSilenceTime;   // amount of silence accumulated so far in Milliseconds
	DWORD m_dwFrameTimeMS;   // the length of a frame in milliseconds

	HRESULT CreateAudioPackets(MEDIAPACKETINIT *mpi);
	HRESULT ReleaseAudioPackets();
	AudioPacket *m_aPackets[NUM_AUDIOPACKETS];


	// private methods that the thread uses
	HRESULT CreateDSCBuffer();
	HRESULT ReleaseDSCBuffer();
	DWORD ProcessFrame(DWORD dwBufferPos, BOOL fMark);
	DWORD WaitForControl();
	DWORD YieldControl();
	BOOL ThreadExitCheck();
	void UpdateTimestamp();
	HRESULT SendPacket(AudioPacket *pAP);
	BOOL UpdateQosStats(UINT uStatType, UINT uStatValue1, UINT uStatValue2);

	// members used primarily by the recording thread
	BOOL m_bFullDuplex;
	BOOL m_bJammed; // set by the recording thread to indicate an error on the device
	BOOL m_bCanSignalOpen;
	BOOL m_bCanSignalFail;
	int m_nFailCount;
	AGC m_agc; // thread uses AGC object for AutoMix
	BOOL m_bAutoMix;  // indicates if AutoMixing is turned off or on

	// DTMF stuff
	DTMFQueue *m_pDTMF;
	HRESULT __stdcall SendDTMF();

public:
	SendDSCStream();
	virtual ~SendDSCStream();

	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
	virtual ULONG STDMETHODCALLTYPE AddRef(void);
	virtual ULONG STDMETHODCALLTYPE Release(void);

	// IMediaChannel
	virtual STDMETHODIMP GetProperty(DWORD dwProp, PVOID pBuf, LPUINT pcbBuf);
	virtual STDMETHODIMP SetProperty(DWORD dwProp, PVOID pBuf, UINT cbBuf);

	virtual HRESULT STDMETHODCALLTYPE Configure(
		BYTE *pFormat,
		UINT cbFormat,
		BYTE *pChannelParams,
		UINT cbParams,
		IUnknown *pUnknown);

	HRESULT STDMETHODCALLTYPE SetNetworkInterface(IUnknown *pUnknown)
	{
		return SendMediaStream::SetNetworkInterface(pUnknown);
	}

	virtual STDMETHODIMP Start(void);
	virtual STDMETHODIMP Stop(void);


	STDMETHODIMP_(DWORD) GetState() 
	{
		return SendMediaStream::GetState();
	}

	virtual HRESULT STDMETHODCALLTYPE SetMaxBitrate(UINT uMaxBitrate);

	// IAudioChannel
	virtual STDMETHODIMP GetSignalLevel(UINT *pSignalStrength);

	// IDTMFSend
	virtual HRESULT __stdcall AddDigit(int nDigit);
	virtual HRESULT __stdcall ResetDTMF();

	// Other virtual methods
	virtual HRESULT Initialize(DataPump *pdp);
	virtual DWORD Send();
	virtual void EndSend();
};

#include <poppack.h> /* End byte packing */


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\dllmain.cpp ===
// File: nac.cpp


#include "precomp.h"
#include "confreg.h"

EXTERN_C BOOL APIENTRY QoSEntryPoint (HINSTANCE hInstDLL, DWORD dwReason, 
LPVOID lpReserved);

EXTERN_C HINSTANCE g_hInst=NULL;	// global module instance


#ifdef DEBUG
HDBGZONE  ghDbgZoneNac = NULL;
static PTCHAR _rgZonesNac[] = {
	TEXT("nac"),
	TEXT("Init"),
	TEXT("Connection"),
	TEXT("Comm Chan"),
	TEXT("Caps"),
	TEXT("DataPump"),
	TEXT("ACM"),
	TEXT("VCM"),
	TEXT("Verbose"),
	TEXT("Installable Codecs"),
	TEXT("Profile spew"),
	TEXT("Local QoS"),
	TEXT("Keyframe Management")
};

HDBGZONE  ghDbgZoneNMCap = NULL;
static PTCHAR _rgZonesNMCap[] = {
	TEXT("NM Capture"),
	TEXT("Ctor/Dtor"),
	TEXT("Ref Counts"),
	TEXT("Streaming")
};

int WINAPI NacDbgPrintf(LPTSTR lpszFormat, ... )
{
	va_list v1;
	va_start(v1, lpszFormat);
	DbgPrintf("NAC", lpszFormat, v1);
	va_end(v1);
	return TRUE;
}
#endif /* DEBUG */


bool NacShutdown()
{
	vcmReleaseResources();
	DirectSoundMgr::UnInitialize();
	return true;
}



extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE  hinstDLL,
                                     DWORD  fdwReason,
                                     LPVOID  lpvReserved);

BOOL WINAPI DllEntryPoint(
    HINSTANCE  hinstDLL,	// handle to DLL module
    DWORD  fdwReason,	// reason for calling function
    LPVOID  lpvReserved 	// reserved
   )
{
	switch(fdwReason)
	{

		case DLL_PROCESS_ATTACH:
			DBGINIT(&ghDbgZoneNac, _rgZonesNac);
			DBGINIT(&ghDbgZoneNMCap, _rgZonesNMCap);

            DBG_INIT_MEMORY_TRACKING(hinstDLL);

			DisableThreadLibraryCalls(hinstDLL);
			g_hInst = hinstDLL;
            break;

		case DLL_PROCESS_DETACH:

			NacShutdown();  // release all global memory

            DBG_CHECK_MEMORY_TRACKING(hinstDLL);

			DBGDEINIT(&ghDbgZoneNac);
			DBGDEINIT(&ghDbgZoneNMCap);
			break;

		default:
			break;

	}
	// call attach/detach-time functions of cantained libraries
  	QoSEntryPoint(hinstDLL, fdwReason, lpvReserved);


 	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\dsstream.cpp ===
#include "precomp.h"
#include <nmdsprv.h>

//bytes <-> PCM16 samples
inline UINT BYTESTOSAMPLES(UINT bytes) { return bytes/2;}
inline UINT SAMPLESTOBYTES(UINT samples) {return samples*2;}
// 'quick' modulo operator. reason its quick is because it only works if  -mod < x < 2*mod
inline UINT QMOD(const int x, const int mod)
{ 	if (x >= mod)
		return (x-mod);
	if (x < 0)
		return (x+mod);
	else
		return x;
}

#define BUFFER_RECEIVED 1		// used to indicate that the buffer is ready to play
#define BUFFER_SILENT	2		// buffer appears to be silent

#define DSFLAG_ALLOCATED 1

const int MIN_DSBUF_SIZE = 4000;

struct DSINFO {
	struct DSINFO *pNext;
	DWORD flags;
	GUID guid;
	LPSTR pszDescription;
	LPSTR pszModule;
	LPDIRECTSOUND pDS;
	LPDIRECTSOUNDBUFFER pDSPrimaryBuf;
	UINT uRef;
};

// initial all the globals
DSINFO *DirectSoundMgr::m_pDSInfoList = NULL;
BOOL DirectSoundMgr::m_fInitialized = FALSE;
HINSTANCE DirectSoundMgr::m_hDS = NULL;
LPFNDSCREATE DirectSoundMgr::m_pDirectSoundCreate=NULL;
LPFNDSENUM DirectSoundMgr::m_pDirectSoundEnumerate=NULL;

GUID myNullGuid = {0};

HRESULT DirectSoundMgr::Initialize()
{
	HRESULT hr;

	// currently there seems no need to re-enumerate the list of devices
	// but that can be changed if the need arises
	if (m_fInitialized)
		return (m_pDSInfoList == NULL ? DPR_NO_PLAY_CAP : S_OK);

	ASSERT(!m_pDSInfoList);
	m_hDS = ::LoadLibrary("DSOUND");
	if (m_hDS != NULL)
	{
		if (GetProcAddress(m_hDS, "DirectSoundCaptureCreate")	// this identifies DS5 or later
			&& (m_pDirectSoundCreate = (LPFNDSCREATE)GetProcAddress(m_hDS,"DirectSoundCreate"))
			&& (m_pDirectSoundEnumerate = (LPFNDSENUM)GetProcAddress(m_hDS,"DirectSoundEnumerateA"))
			)
		{
			if ((hr=(*m_pDirectSoundEnumerate)(DSEnumCallback, 0)) != S_OK)
			{
				DEBUGMSG(ZONE_DP,("DSEnumerate failed with %x\n",hr));
			} else {
				if (!m_pDSInfoList) {
					DEBUGMSG(ZONE_DP,("DSEnumerate - no devices found\n"));
					hr = DPR_NO_PLAY_CAP;	// no devices were found
				}
			}
		
		} else {
			hr = DPR_INVALID_PLATFORM;	// better error code?
		}
		if (hr != S_OK) {
			FreeLibrary(m_hDS);
			m_hDS = NULL;
		}
	}
	else
	{
		DEBUGMSG(ZONE_INIT,("LoadLibrary(DSOUND) failed"));
		hr = DPR_NO_PLAY_CAP;
	}

	m_fInitialized = TRUE;
	return hr;
}


HRESULT DirectSoundMgr::UnInitialize()
{
	DSINFO *pDSINFO = m_pDSInfoList, *pDSNEXT;
	if (m_fInitialized)
	{

		while (pDSINFO)
		{
			pDSNEXT = pDSINFO->pNext;
			delete [] pDSINFO->pszDescription;
			delete [] pDSINFO->pszModule;
			delete pDSINFO;
			pDSINFO = pDSNEXT;
		}

		m_fInitialized = FALSE;
		m_pDSInfoList = NULL;
	}

	return S_OK;
}



BOOL __stdcall DirectSoundMgr::DSEnumCallback(
	LPGUID lpGuid,
	LPCSTR lpstrDescription,
	LPCSTR lpstrModule,
	LPVOID lpContext
	)
{
	DSINFO *pDSInfo;
	
    DBG_SAVE_FILE_LINE
	pDSInfo = new DSINFO;
	if (pDSInfo) {
		pDSInfo->uRef = 0;
		pDSInfo->guid = (lpGuid ? *lpGuid : GUID_NULL);

        DBG_SAVE_FILE_LINE
		pDSInfo->pszDescription = new CHAR [lstrlen(lpstrDescription)+1];
		if (pDSInfo->pszDescription)
			lstrcpy(pDSInfo->pszDescription, lpstrDescription);

        DBG_SAVE_FILE_LINE
		pDSInfo->pszModule = new CHAR [lstrlen(lpstrModule)+1];
		if (pDSInfo->pszModule)
			lstrcpy(pDSInfo->pszModule, lpstrModule);

		// append to list
		pDSInfo->pNext = m_pDSInfoList;
		m_pDSInfoList = pDSInfo;
	}
	DEBUGMSG(ZONE_DP,("DSound device found: (%s) ; driver (%s);\n",lpstrDescription, lpstrModule));
	return TRUE;
}

HRESULT
DirectSoundMgr::MapWaveIdToGuid(UINT waveId, GUID *pGuid)
{
	// try to figure out which Guid maps to a wave id
	// Do this by opening the wave device corresponding to the wave id and then
	// all the DS devices in sequence and see which one fails.
	// Yes, this is a monstrous hack and clearly unreliable
	HWAVEOUT hWaveOut = NULL;
	MMRESULT mmr;
	HRESULT hr;
	DSINFO *pDSInfo;
	LPDIRECTSOUND pDS;
	DSCAPS dscaps;
	BOOL fEmulFound;
	WAVEFORMATEX wfPCM8K16 = {WAVE_FORMAT_PCM,1,8000,16000,2,16,0};
	WAVEOUTCAPS	waveOutCaps;

	if (!m_fInitialized)
		Initialize();	// get the list of DS devices

	if (!m_pDSInfoList)
		return DPR_CANT_OPEN_DEV;
	else if (waveId == WAVE_MAPPER || waveOutGetNumDevs()==1) {
		// we want the default or there is only one DS device, take the easy way out
		*pGuid =  GUID_NULL;
		return S_OK;
	}


	// try using the IKsProperty interface on a DirectSoundPrivate object
	// to find out what GUID maps to the waveId in question
	// Only likely to work on Win98 and NT 5.
	ZeroMemory(&waveOutCaps, sizeof(WAVEOUTCAPS));
	mmr = waveOutGetDevCaps(waveId, &waveOutCaps, sizeof(WAVEOUTCAPS));
	if (mmr == MMSYSERR_NOERROR)
	{
		hr = DsprvGetWaveDeviceMapping(waveOutCaps.szPname, FALSE, pGuid);
		if (SUCCEEDED(hr))
		{
			return hr;
		}
		// if we failed to make a mapping, fall through to the old code path
	}


	mmr = waveOutOpen(&hWaveOut, waveId,
						  &wfPCM8K16,
						  0, 0, CALLBACK_NULL);
	if (mmr != MMSYSERR_NOERROR) {
		DEBUGMSG(ZONE_DP,("MapWaveIdToGuid - cannot open wave(%d)\n", waveId));
		return DPR_CANT_OPEN_DEV;
	}
	// now open all the DS devices in turn
	for (pDSInfo = m_pDSInfoList; pDSInfo; pDSInfo = pDSInfo->pNext) {
		hr = (*m_pDirectSoundCreate)(&pDSInfo->guid, &pDS, NULL);
		if (hr != S_OK) {
			pDSInfo->flags |= DSFLAG_ALLOCATED;	// this is a candidate
		} else {
			pDSInfo->flags &= ~DSFLAG_ALLOCATED;
			pDS->Release();
		}
	}
	waveOutClose(hWaveOut);
	hr = DPR_CANT_OPEN_DEV;

	dscaps.dwSize = sizeof(dscaps);
	fEmulFound = FALSE;
	// try opening the DS devices that failed the first time
	for (pDSInfo = m_pDSInfoList; pDSInfo; pDSInfo = pDSInfo->pNext) {
		if (pDSInfo->flags & DSFLAG_ALLOCATED) {
			hr = (*m_pDirectSoundCreate)(&pDSInfo->guid, &pDS, NULL);
			if (hr == S_OK) {
				*pGuid = pDSInfo->guid;
				// get dsound capabilities.
				// NOTE: consider putting the caps in DSINFO if its used often
				pDS->GetCaps(&dscaps);
				pDS->Release();
				DEBUGMSG(ZONE_DP,("mapped waveid %d to DS device(%s)\n", waveId, pDSInfo->pszDescription));
				if (dscaps.dwFlags & DSCAPS_EMULDRIVER)
					fEmulFound = TRUE;	// keep looking in case there's also a native driver
				else
					break;	// native DS driver. Look no further
					
			}
		}
	}
	if (fEmulFound)
		hr = S_OK;
		
	if (hr != S_OK) {
		DEBUGMSG(ZONE_DP,("Cant map id %d to DSound guid!\n", waveId));
		hr = DPR_CANT_OPEN_DEV;
	}

	return hr;
}

HRESULT
DirectSoundMgr::Instance(LPGUID pDeviceGuid,LPDIRECTSOUND *ppDS, HWND hwnd,  WAVEFORMATEX *pwf)
{
	DSINFO *pDSInfo = m_pDSInfoList;
	HRESULT hr;
	DSBUFFERDESC dsBufDesc;
	FX_ENTRY("DirectSoundInstance");

	if (pDeviceGuid == NULL)
		pDeviceGuid = &myNullGuid;
	// search for the Guid in the list
	*ppDS = NULL;

	if (!m_fInitialized)
		Initialize();
		
	while (pDSInfo) {
		if (pDSInfo->guid == *pDeviceGuid)
			break;
		pDSInfo = pDSInfo->pNext;
	}
	ASSERT (pDSInfo);

	if (!pDSInfo || !pDSInfo->pDS) {
		// need to create DS object
		PlaySound(NULL,NULL,0);		// hack to stop system sounds
			
		hr = (*m_pDirectSoundCreate)((*pDeviceGuid==GUID_NULL ? NULL: pDeviceGuid), ppDS, NULL);
		//set priority cooperative level, so we can set the format of the primary buffer.
		if (hr == S_OK 	&& 	(hr = (*ppDS)->SetCooperativeLevel(hwnd,DSSCL_PRIORITY)) == S_OK)
 		{
			if (!pDSInfo) {
				DEBUGMSG(ZONE_DP,("%s: GUID not in List!\n",_fx_));
				// BUGBUG: remove this block. Enumerate should have created the entry (except for NULL guid?)

                DBG_SAVE_FILE_LINE
				pDSInfo = new DSINFO;
				if (pDSInfo) {
					pDSInfo->uRef = 0;
					pDSInfo->guid = *pDeviceGuid;
					pDSInfo->pNext = m_pDSInfoList;
					m_pDSInfoList = pDSInfo;
				} else {
					(*ppDS)->Release();
					return DPR_OUT_OF_MEMORY;
				}
					
			}
			pDSInfo->pDS = *ppDS;
			++pDSInfo->uRef;
			// Create a primary buffer only to set the format
			// (what if its already set?)
			ZeroMemory(&dsBufDesc,sizeof(dsBufDesc));
			dsBufDesc.dwSize = sizeof(dsBufDesc);
			dsBufDesc.dwFlags = DSBCAPS_PRIMARYBUFFER|DSBCAPS_STICKYFOCUS;
			// STICKYFOCUS flags is supposed to preserve the format
			// when the app is not in-focus.
			hr = pDSInfo->pDS->CreateSoundBuffer(&dsBufDesc,&pDSInfo->pDSPrimaryBuf,NULL);
			if (hr == S_OK && pwf) {
				pDSInfo->pDSPrimaryBuf->SetFormat(pwf);
			} else {
				DEBUGMSG (ZONE_DP, ("%s: Create PrimarySoundBuffer failed, hr=0x%lX\r\n", _fx_, hr));
				hr = S_OK;	// Non fatal error
			}
			//DEBUGMSG(ZONE_DP, ("%s: Created Direct Sound object (%s)\n", _fx_,pDSInfo->pszDescription));
		} else {
			DEBUGMSG(ZONE_DP, ("%s: Could not create DS object (%s)\n", _fx_,pDSInfo->pszDescription));

		}
		LOG((LOGMSG_DSCREATE, hr));
	} else {
		*ppDS = pDSInfo->pDS;
		++pDSInfo->uRef;
		hr = S_OK;
	}
				
	return hr;	
}

HRESULT
DirectSoundMgr::ReleaseInstance(LPDIRECTSOUND pDS)
{
	// deref the DS object and release it if necessary
	DSINFO *pDSInfo = m_pDSInfoList;

	while (pDSInfo) {
		if (pDSInfo->pDS == pDS) {
			ASSERT(pDSInfo->uRef > 0);
			if (--pDSInfo->uRef == 0) {
				ULONG uref;
				if (pDSInfo->pDSPrimaryBuf) {
					pDSInfo->pDSPrimaryBuf->Release();
					pDSInfo->pDSPrimaryBuf = NULL;
				}
				uref = pDS->Release();
				pDSInfo->pDS = 0;
				LOG((LOGMSG_DSRELEASE, uref));
				//DEBUGMSG(ZONE_DP, ("Release Direct Sound object (%s) uref=%d\n", pDSInfo->pszDescription, uref));
				// dont bother freeing DSINFO. Its okay
				// to keep it around till the process dies
			}
			break;
		}
		pDSInfo = pDSInfo->pNext;
	}
	return (pDSInfo ? S_OK : DPR_INVALID_PARAMETER);
}


void DSTimeout::TimeoutIndication()
{
	ASSERT(m_pRDSStream);
	m_pRDSStream->RecvTimeout();
}


HRESULT STDMETHODCALLTYPE RecvDSAudioStream::QueryInterface(REFIID iid, void **ppVoid)
{
	// resolve duplicate inheritance to the SendMediaStream;

	extern IID IID_IProperty;

	if (iid == IID_IUnknown)
	{
		*ppVoid = (IUnknown*)((RecvMediaStream*)this);
	}
	else if (iid == IID_IMediaChannel)
	{
		*ppVoid = (IMediaChannel*)((RecvMediaStream *)this);
	}
	else if (iid == IID_IAudioChannel)
	{
		*ppVoid = (IAudioChannel*)this;
	}
	else if (iid == IID_IProperty)
	{
		*ppVoid = NULL;
		ERROR_OUT(("Don't QueryInterface for IID_IProperty, use IMediaChannel"));
		return E_NOINTERFACE;
	}
	else
	{
		*ppVoid = NULL;
		return E_NOINTERFACE;
	}
	AddRef();

	return S_OK;

}

ULONG STDMETHODCALLTYPE RecvDSAudioStream::AddRef(void)
{
	return InterlockedIncrement(&m_lRefCount);
}

ULONG STDMETHODCALLTYPE RecvDSAudioStream::Release(void)
{
	LONG lRet;

	lRet = InterlockedDecrement(&m_lRefCount);

	if (lRet == 0)
	{
		delete this;
		return 0;
	}

	else
		return lRet;

}



HRESULT
RecvDSAudioStream::Initialize( DataPump *pDP)
{
	HRESULT hr = DPR_OUT_OF_MEMORY;
	DWORD dwFlags =  DP_FLAG_ACM| DP_FLAG_DIRECTSOUND  | DP_FLAG_HALF_DUPLEX | DP_FLAG_AUTO_SWITCH ;
	MEDIACTRLINIT mcInit;
	FX_ENTRY ("RecvDSAudioStream::Initialize")

	InitializeCriticalSection(&m_crsAudQoS);

	// enable Recv by default
	m_DPFlags = dwFlags | DPFLAG_ENABLE_RECV;
	// store a back pointer to the datapump container
	m_pDP = pDP;
	m_Net = NULL;
	m_dwSrcSize = 0;
	m_pIRTPRecv = NULL;
	m_nFailCount = 0;
	m_bJammed = FALSE;
	m_bCanSignalOpen = TRUE;

	

	// Initialize data (should be in constructor)
	m_DSguid = GUID_NULL;	// use default device

	// Create decode audio filters
	m_hStrmConv = NULL; // replaced by AcmFilter

    DBG_SAVE_FILE_LINE
	m_pAudioFilter = new AcmFilter;
	if (!m_pAudioFilter)
	{
		DEBUGMSG (ZONE_DP, ("%s: AcmManager new failed\r\n", _fx_));
		goto FilterAllocError;
	}

	ZeroMemory (&m_StrmConvHdr, sizeof (ACMSTREAMHEADER));


	// determine if the wave devices are available
	if (waveOutGetNumDevs()) m_DPFlags |= DP_FLAG_PLAY_CAP;
	

	m_DPFlags |= DPFLAG_INITIALIZED;

	UPDATE_REPORT_ENTRY(g_prptSystemSettings, 1, REP_SYS_AUDIO_DSOUND);
	RETAILMSG(("NAC: Audio Subsystem: DirectSound"));

	return DPR_SUCCESS;


FilterAllocError:
	if (m_pAudioFilter) delete m_pAudioFilter;

	ERRORMESSAGE( ("%s: exit, hr=0x%lX\r\n", _fx_, hr));

	return hr;
}

RecvDSAudioStream::~RecvDSAudioStream()
{

	if (m_DPFlags & DPFLAG_INITIALIZED) {
		m_DPFlags &= ~DPFLAG_INITIALIZED;
	
		if (m_DPFlags & DPFLAG_CONFIGURED_RECV)
			UnConfigure();

		if (m_pIRTPRecv)
		{
			m_pIRTPRecv->Release();
			m_pIRTPRecv = NULL;
		}

		if (m_pAudioFilter)
			delete m_pAudioFilter;

		m_pDP->RemoveMediaChannel(MCF_RECV|MCF_AUDIO, (IMediaChannel*)(RecvMediaStream*)this);

	}
	DeleteCriticalSection(&m_crsAudQoS);
}

extern UINT ChoosePacketSize(WAVEFORMATEX *pwf);
extern UINT g_MaxAudioDelayMs;
extern UINT g_MinWaveAudioDelayMs;
extern UINT g_MinDSEmulAudioDelayMs; // emulated DS driver delay


HRESULT STDMETHODCALLTYPE RecvDSAudioStream::Configure(
	BYTE *pFormat,
	UINT cbFormat,
	BYTE *pChannelParams,
	UINT cbParams,
	IUnknown *pUnknown)
{
	HRESULT hr=E_FAIL;
	BOOL fRet;
	DWORD dwMaxDecompressedSize;
	UINT cbSamplesPerPkt;
	DWORD dwPropVal;
	DWORD dwFlags;
	UINT uAudioCodec;
	AUDIO_CHANNEL_PARAMETERS audChannelParams;
	UINT ringSize = MAX_RXRING_SIZE;
	WAVEFORMATEX *pwfRecv;
	UINT maxRingSamples;
	MMRESULT mmr;

	FX_ENTRY ("RecvDSAudioStream::Configure")

//	m_Net = pNet;


	if (m_DPFlags & DPFLAG_STARTED_RECV)
	{
		return DPR_IO_PENDING; // anything better to return
	}

	if (m_DPFlags & DPFLAG_CONFIGURED_RECV)
	{
		DEBUGMSG(ZONE_DP, ("Stream Re-Configuration - calling UnConfigure"));
		UnConfigure();  // a re-configure will release the RTP object, need to call SetNetworkInterface again
	}


	if ((NULL == pFormat) ||
		(NULL == pChannelParams) ||
		(cbParams != sizeof(audChannelParams)) ||
		(cbFormat < sizeof(WAVEFORMATEX)) )

	{
		return DPR_INVALID_PARAMETER;
	}

	audChannelParams = *(AUDIO_CHANNEL_PARAMETERS *)pChannelParams;
	pwfRecv = (WAVEFORMATEX *)pFormat;

	if (! (m_DPFlags & DPFLAG_INITIALIZED))
		return DPR_OUT_OF_MEMORY;		//BUGBUG: return proper error;
		
//	if (m_Net)
//	{
//		hr = m_Net->QueryInterface(IID_IRTPRecv, (void **)&m_pIRTPRecv);
//		if (!SUCCEEDED(hr))
//			return hr;
//	}

	AcmFilter::SuggestDecodeFormat(pwfRecv, &m_fDevRecv);
	
	UPDATE_REPORT_ENTRY(g_prptCallParameters, pwfRecv->wFormatTag, REP_RECV_AUDIO_FORMAT);
	UPDATE_REPORT_ENTRY(g_prptCallParameters, pwfRecv->nSamplesPerSec, REP_RECV_AUDIO_SAMPLING);
	UPDATE_REPORT_ENTRY(g_prptCallParameters, pwfRecv->nAvgBytesPerSec*8, REP_RECV_AUDIO_BITRATE);
	RETAILMSG(("NAC: Audio Recv Format: %s", (pwfRecv->wFormatTag == 66) ? "G723.1" : (pwfRecv->wFormatTag == 112) ? "LHCELP" : (pwfRecv->wFormatTag == 113) ? "LHSB08" : (pwfRecv->wFormatTag == 114) ? "LHSB12" : (pwfRecv->wFormatTag == 115) ? "LHSB16" : (pwfRecv->wFormatTag == 6) ? "MSALAW" : (pwfRecv->wFormatTag == 7) ? "MSULAW" : (pwfRecv->wFormatTag == 130) ? "MSRT24" : "??????"));
	RETAILMSG(("NAC: Audio Recv Sampling Rate (Hz): %ld", pwfRecv->nSamplesPerSec));
	RETAILMSG(("NAC: Audio Recv Bitrate (w/o network overhead - bps): %ld", pwfRecv->nAvgBytesPerSec*8));
	// note that parameters such as samples/packet are channel specific

	cbSamplesPerPkt = audChannelParams.ns_params.wFrameSize
		*audChannelParams.ns_params.wFramesPerPkt;

	// turn on receive silence detection only if the sender is not using
	// silence suppression
	if (!audChannelParams.ns_params.UseSilenceDet)
		m_DPFlags |= DP_FLAG_AUTO_SILENCE_DETECT;	
	else
		m_DPFlags &= ~DP_FLAG_AUTO_SILENCE_DETECT;
	UPDATE_REPORT_ENTRY(g_prptCallParameters, cbSamplesPerPkt, REP_RECV_AUDIO_PACKET);
	RETAILMSG(("NAC: Audio Recv Packetization (ms/packet): %ld", pwfRecv->nSamplesPerSec ? cbSamplesPerPkt * 1000UL / pwfRecv->nSamplesPerSec : 0));
	INIT_COUNTER_MAX(g_pctrAudioReceiveBytes, (pwfRecv->nAvgBytesPerSec * 8 + pwfRecv->nSamplesPerSec * (sizeof(RTP_HDR) + IP_HEADER_SIZE + UDP_HEADER_SIZE) / cbSamplesPerPkt) << 3);


	// make the ring buffer size large enought to hold 4 seconds of audio
	// This seems to be suitable for congested networks, in which
	// packets can get delayed and them for many to suddelnly arrive at once
	maxRingSamples = (pwfRecv->nSamplesPerSec * MIN_DSBUF_SIZE)/1000;


	// describe the DirectSound buffer
	
	ZeroMemory(&m_DSBufDesc,sizeof(m_DSBufDesc));
	m_DSBufDesc.dwSize = sizeof (m_DSBufDesc);
	m_DSBufDesc.dwFlags = DSBCAPS_CTRLVOLUME | DSBCAPS_GLOBALFOCUS | DSBCAPS_GETCURRENTPOSITION2;
	m_DSBufDesc.dwBufferBytes = maxRingSamples * (m_fDevRecv.wBitsPerSample/8);
	m_DSBufDesc.dwReserved = 0;
	m_DSBufDesc.lpwfxFormat = &m_fDevRecv;
	
	m_pDS = NULL;
	m_pDSBuf = NULL;

	
	// Initialize the recv-stream filter manager object
	dwMaxDecompressedSize = cbSamplesPerPkt * (m_fDevRecv.nBlockAlign);


	mmr = m_pAudioFilter->Open(pwfRecv, &m_fDevRecv);
	if (mmr != 0)
	{
		DEBUGMSG (ZONE_DP, ("%s: AcmFilter->Open failed, mmr=%d\r\n", _fx_, mmr));
		hr = DPR_CANT_OPEN_CODEC;
		goto RecvFilterInitError;
	}

	
	// set up the decode buffer
	m_pAudioFilter->SuggestSrcSize(dwMaxDecompressedSize, &m_dwSrcSize);

	ZeroMemory (&m_StrmConvHdr, sizeof (ACMSTREAMHEADER));
	m_StrmConvHdr.cbStruct = sizeof (ACMSTREAMHEADER);

    DBG_SAVE_FILE_LINE
	m_StrmConvHdr.pbSrc = new BYTE[m_dwSrcSize];
	m_StrmConvHdr.cbSrcLength = m_dwSrcSize;  // may change for variable bit rate codecs

    DBG_SAVE_FILE_LINE
	m_StrmConvHdr.pbDst = new BYTE[dwMaxDecompressedSize];
	m_StrmConvHdr.cbDstLength = dwMaxDecompressedSize;

	mmr = m_pAudioFilter->PrepareHeader(&m_StrmConvHdr);
	if (mmr != MMSYSERR_NOERROR)
	{
		DEBUGMSG (ZONE_DP, ("%s: AcmFilter->Open failed, mmr=%d\r\n", _fx_, mmr));
		hr = DPR_CANT_OPEN_CODEC;
		goto RecvFilterInitError;
	}
	
	// Initialize the recv stream
	m_BufSizeT = BYTESTOSAMPLES(m_DSBufDesc.dwBufferBytes);
	m_fEmpty = TRUE;

	m_MinDelayT = 0;
	m_MaxDelayT = g_MaxAudioDelayMs * m_fDevRecv.nSamplesPerSec /1000;
	m_ArrT = m_ArrivalT0 = 0;
	m_ScaledAvgVarDelay = 0;

	m_DelayT = m_MinDelayT;

	m_SilenceDurationT = 0;


	InitAudioFlowspec(&m_flowspec, pwfRecv, m_dwSrcSize);

	m_DPFlags |= DPFLAG_CONFIGURED_RECV;

	return DPR_SUCCESS;

RecvFilterInitError:
	if (m_pIRTPRecv)
	{
		m_pIRTPRecv->Release();
		m_pIRTPRecv = NULL;
	}

	m_pAudioFilter->Close();

	delete [] m_StrmConvHdr.pbSrc;
	delete [] m_StrmConvHdr.pbDst;
	m_StrmConvHdr.pbSrc=NULL;
	m_StrmConvHdr.pbDst = NULL;


	ERRORMESSAGE(("%s:  failed, hr=0%u\r\n", _fx_, hr));
	return hr;
}


void RecvDSAudioStream::UnConfigure()
{

	if ((m_DPFlags & DPFLAG_CONFIGURED_RECV))
	{
		Stop();
		// Close the RTP state if its open
		m_Net = NULL;

		// release DS buffer and DS object
		//ReleaseDSBuffer();
		ASSERT(!m_pDSBuf);	// released in StopRecv()

		// Close the filters
		m_StrmConvHdr.cbSrcLength = m_dwSrcSize;
		m_pAudioFilter->UnPrepareHeader(&m_StrmConvHdr);
		m_pAudioFilter->Close();

		delete [] m_StrmConvHdr.pbSrc;
		delete [] m_StrmConvHdr.pbDst;
		m_StrmConvHdr.pbSrc=NULL;
		m_StrmConvHdr.pbDst = NULL;

		m_nFailCount = 0;
		m_bJammed = FALSE;
		m_bCanSignalOpen = TRUE;

		// Close the receive streams
		//m_RecvStream->Destroy();
        m_DPFlags &= ~(DPFLAG_CONFIGURED_RECV);
	}
}


HRESULT
RecvDSAudioStream::Start()
{
	HRESULT hr;
	IMediaChannel *pISendAudio;
	BOOL fStoppedRecording;
	FX_ENTRY ("RecvDSAudioStream::Start");
	
	if (m_DPFlags & DPFLAG_STARTED_RECV)
		return DPR_SUCCESS;
	// TODO: remove this check once audio UI calls the IComChan PAUSE_RECV prop
	if (!(m_DPFlags & DPFLAG_ENABLE_RECV))
		return DPR_SUCCESS;

	if ((!(m_DPFlags & DPFLAG_CONFIGURED_RECV)) || (!m_pIRTPRecv))
		return DPR_NOT_CONFIGURED;

	ASSERT(!m_hRenderingThread );
	m_ThreadFlags &= ~(DPTFLAG_STOP_PLAY|DPTFLAG_STOP_RECV);

	SetFlowSpec();

	pISendAudio = NULL;
	fStoppedRecording = FALSE;
	if (!(m_DPFlags & DP_FLAG_HALF_DUPLEX))
	{
	// make sure the recording device is closed before creating the DS object
	// Why ? Because SoundBlaster either sounds lousy or doesnt work at all if
	// you open waveIn before  waveOut or DirectSound.
		m_pDP->GetMediaChannelInterface(MCF_AUDIO|MCF_SEND, &pISendAudio);
		if (pISendAudio && pISendAudio->GetState()== MSSTATE_STARTED
		&& pISendAudio->Stop() == S_OK)
		{
			fStoppedRecording = TRUE;
			DEBUGMSG(ZONE_DP,("%s:Stopped Recording\n",_fx_));
		}
	}
	
	// Start receive thread. This will create the DSound object
    m_pDP->StartReceiving(this);

    if (pISendAudio) {
    	if (fStoppedRecording)
    		pISendAudio->Start();
    	pISendAudio->Release();
    }

    m_DPFlags |= DPFLAG_STARTED_RECV;
	return DPR_SUCCESS;
}

// LOOK: Identical to RecvVideoStream version.
HRESULT
RecvDSAudioStream::Stop()
{
	
	
	FX_ENTRY ("RecvDSAudioStream::Stop");

	if(!(m_DPFlags &  DPFLAG_STARTED_RECV))
	{
		return DPR_SUCCESS;
	}

	m_ThreadFlags = m_ThreadFlags  |
		DPTFLAG_STOP_RECV |  DPTFLAG_STOP_PLAY ;

	// delink from receive thread
	m_pDP->StopReceiving(this);

	if (m_pDSBuf)
		m_pDSBuf->Stop();
	
    //This is per channel, but the variable is "DPFlags"
	m_DPFlags &= ~DPFLAG_STARTED_RECV;
	
	return DPR_SUCCESS;
}

//  IProperty::GetProperty / SetProperty
//  (DataPump::MediaChannel::GetProperty)
//      Properties of the MediaChannel. Supports properties for both audio
//      and video channels.

STDMETHODIMP
RecvDSAudioStream::GetProperty(
	DWORD prop,
	PVOID pBuf,
	LPUINT pcbBuf
    )
{
	HRESULT hr = DPR_SUCCESS;
	RTP_STATS RTPStats;
	DWORD dwValue;
	UINT len = sizeof(DWORD);	// most props are DWORDs

	if (!pBuf || *pcbBuf < len)
    {
		*pcbBuf = len;
		return DPR_INVALID_PARAMETER;
	}

	switch (prop)
    {
	case PROP_RECV_AUDIO_STRENGTH:
		{
			return GetSignalLevel((UINT*)pBuf);
		}

#ifdef OLDSTUFF
	case PROP_NET_RECV_STATS:
		if (m_Net && *pcbBuf >= sizeof(RTP_STATS))
        {
			m_Net->GetRecvStats((RTP_STATS *)pBuf);
			*pcbBuf = sizeof(RTP_STATS);
		} else
			hr = DPR_INVALID_PROP_VAL;
			
		break;
#endif
	//case PROP_VOLUME:

	case PROP_DUPLEX_TYPE:
		
		if(m_DPFlags & DP_FLAG_HALF_DUPLEX)
			*(DWORD*)pBuf = DUPLEX_TYPE_HALF;
		else
			*(DWORD*)pBuf =	DUPLEX_TYPE_FULL;
		break;

	case PROP_WAVE_DEVICE_TYPE:
		*(DWORD*)pBuf = m_DPFlags & DP_MASK_WAVE_DEVICE;
		break;
	case PROP_PLAY_ON:
		*(DWORD *)pBuf = (m_ThreadFlags & DPFLAG_ENABLE_RECV)!=0;
		break;
	case PROP_PLAYBACK_DEVICE:
		*(DWORD *)pBuf = m_RenderingDevice;
		break;

	case PROP_VIDEO_AUDIO_SYNC:
		*(DWORD*)pBuf = ((m_DPFlags & DPFLAG_AV_SYNC) != 0);
		break;
	
	default:
		hr = DPR_INVALID_PROP_ID;
		break;
	}
	return hr;
}


// low order word is the signal strength
// high order work contains bits to indicate status
// (0x01 - transmitting)
// (0x02 - audio device is jammed)
STDMETHODIMP RecvDSAudioStream::GetSignalLevel(UINT *pSignalStrength)
{
	DWORD dwLevel;
	DWORD dwJammed;

	if ((!(m_DPFlags & DPFLAG_STARTED_RECV)) || (m_fEmpty) ||
		  (m_ThreadFlags & DPTFLAG_PAUSE_RECV) )
	{
		dwLevel = 0;
	}
	else
	{
		dwLevel = GetSignalStrength();
		dwLevel = LogScale[(dwLevel >> 8) & 0x00ff];

		if (m_bJammed)
		{
			dwLevel |= (2 << 16);
		}

		dwLevel |= (1 << 16);
	}
	*pSignalStrength = dwLevel;
	return S_OK;
};






DWORD
RecvDSAudioStream::GetSignalStrength()
{
	BYTE bMax, bMin, *pb;
	short sMax, sMin, *ps;
	UINT cbSize;
	DWORD dwMaxStrength = 0;
	cbSize = m_StrmConvHdr.cbDstLengthUsed;
	if (cbSize==0)
		return 0;
	switch (m_fDevRecv.wBitsPerSample)
	{
	case 8: // unsigned char

		pb = (PBYTE) (m_StrmConvHdr.pbDst);

		bMax = 0;
		bMin = 255;

		for ( ; cbSize; cbSize--, pb++)
		{
			if (*pb > bMax) bMax = *pb;
			if (*pb < bMin) bMin = *pb;
		}
	
			// 2^9 <-- 2^16 / 2^7
		dwMaxStrength = ((DWORD) (bMax - bMin)) << 8;
		break;

	case 16: // (signed) short

		ps = (short *) (m_StrmConvHdr.pbDst);
		cbSize = m_StrmConvHdr.cbDstLengthUsed;

		sMax = sMin = 0;

		for (cbSize >>= 1; cbSize; cbSize--, ps++)
		{
			if (*ps > sMax) sMax = *ps;
			if (*ps < sMin) sMin = *ps;
		}
	
		dwMaxStrength = (DWORD) (sMax - sMin); // drop sign bit
		break;

	}
	return dwMaxStrength;
}


STDMETHODIMP
RecvDSAudioStream::SetProperty(
	DWORD prop,
	PVOID pBuf,
	UINT cbBuf
    )
{
	DWORD dw;
	HRESULT hr = S_OK;
	
	if (cbBuf < sizeof (DWORD))
		return DPR_INVALID_PARAMETER;

	switch (prop)
    {
	//case PROP_VOLUME:
		

	case PROP_DUPLEX_TYPE:
		ASSERT(0);  // dead code for this case type;
		break;
		
	case DP_PROP_DUPLEX_TYPE:
		// internal version, called by DataPump::SetDuplexMode() after ensuring streams are stopped
		dw = *(DWORD *)pBuf;
		if (dw & DP_FLAG_HALF_DUPLEX)
			m_DPFlags |= DP_FLAG_HALF_DUPLEX;
		else
			m_DPFlags &= ~DP_FLAG_HALF_DUPLEX;
		break;
		

	case PROP_PLAY_ON:
	{

		if (*(DWORD *)pBuf)   // unmute
		{
			m_ThreadFlags &= ~DPTFLAG_PAUSE_RECV;
		}
		else  // mute
		{
			m_ThreadFlags |= DPTFLAG_PAUSE_RECV;
		}
	
//		DWORD flag =  DPFLAG_ENABLE_RECV;
//		if (*(DWORD *)pBuf) {
//			m_DPFlags |= flag; // set the flag
//			hr = Start();
//		}
//		else
//		{
//			m_DPFlags &= ~flag; // clear the flag
//			hr = Stop();
//		}

		RETAILMSG(("NAC: RecvAudioStream: %s", *(DWORD*)pBuf ? "Enabling":"Disabling"));
		break;
	}	
	case PROP_PLAYBACK_DEVICE:
		m_RenderingDevice = *(DWORD*)pBuf;
		RETAILMSG(("NAC: Setting default playback device to %d", m_RenderingDevice));
		if (m_RenderingDevice != WAVE_MAPPER)
			hr = DirectSoundMgr::MapWaveIdToGuid(m_RenderingDevice,&m_DSguid);
		break;

    case PROP_VIDEO_AUDIO_SYNC:
		if (*(DWORD *)pBuf)
    		m_DPFlags |= DPFLAG_AV_SYNC;
		else
			m_DPFlags &= ~DPFLAG_AV_SYNC;
    	break;

	default:
		return DPR_INVALID_PROP_ID;
		break;
	}
	return hr;
}

HRESULT
RecvDSAudioStream::GetCurrentPlayNTPTime(NTP_TS *pNtpTime)
{
	DWORD rtpTime;
#ifdef OLDSTUFF
	if ((m_DPFlags & DPFLAG_STARTED_RECV) && m_fReceiving) {
		if (m_Net->RTPtoNTP(m_PlaybackTimestamp,pNtpTime))
			return S_OK;
	}
#endif
	return 0xff;	// return proper error
		
}

BOOL RecvDSAudioStream::IsEmpty() {
	// check if anything in DSBuffer or in decode buffer
	return (m_fEmpty && !(m_StrmConvHdr.dwDstUser & BUFFER_RECEIVED));
}

/*
	Called by the recv thread to setup the stream for receiving.
	Post the initial recv buffer(s). Subsequently, the buffers are posted
	in the RTPRecvCallback()
*/
HRESULT
RecvDSAudioStream::StartRecv(HWND hWnd)
{
	HRESULT hr = S_OK;
	DWORD dwPropVal = 0;
	FX_ENTRY ("RecvDSAudioStream::StartRecv");
	
	if ((!(m_ThreadFlags & DPTFLAG_STOP_RECV) ) && (m_DPFlags  & DPFLAG_CONFIGURED_RECV)){
		if (!(m_DPFlags & DP_FLAG_HALF_DUPLEX) && !m_pDSBuf) {
		// Create the DS object only if its full-duplex
		// In the half-duplex case the DSbuffer is created
		// when the first packet is received
		// only  reason its here is so that SetDuplexMode can take effect right away
		// BUGBUG: opening waveIn before DS causes death of the waveOut on Memphis!!
			hr = CreateDSBuffer();
			
			if (hr  != S_OK) {
				DEBUGMSG (ZONE_DP, ("%s: CreateSoundBuffer create failed, hr=0x%lX\r\n", _fx_, hr));
				return hr;
			}
		}
		if (m_pDSBuf)
			hr = m_pDSBuf->Play(0,0,DSBPLAY_LOOPING);

//		m_RecvFilter->GetProp (FM_PROP_SRC_SIZE, &dwPropVal);
		//hr = m_Net->SetRecvNotification(&RTPRecvDSCallback, (DWORD)this, 2, dwPropVal, hWnd);	// for WS1 only
		hr =m_pIRTPRecv->SetRecvNotification(&RTPRecvCallback,(DWORD_PTR)this, 2);
			
		
	}
	return hr;
}

/*
	Called by the recv thread to suspend receiving  on this RTP session
	If there are outstanding receive buffers they have to be recovered
*/

HRESULT
RecvDSAudioStream::StopRecv()
{
	// dont recv on this stream
	m_pIRTPRecv->CancelRecvNotification();

	// cancel any pending timeout. (its okay if it wasnt scheduled )
	m_pDP->m_RecvTimer.CancelTimeout(&m_TimeoutObj);

	// Release DirectSound object
	ReleaseDSBuffer();

	return S_OK;		
}

/*
	Create a DirectSound object and a DirectSound secondary buffer.
	This routine is called after the stream is configured, so the wave format has been set
	and the DSBUFFERDESC struct has been initialized.
*/
HRESULT
RecvDSAudioStream::CreateDSBuffer()
{
	HRESULT hr;
	HWAVEOUT hwo=NULL;
	DSCAPS dscaps;
	FX_ENTRY ("RecvDSAudioStream::CreateDSBuffer");

	ASSERT(!m_pDSBuf);
	if (m_DPFlags & DP_FLAG_HALF_DUPLEX) {
		DWORD dwStatus;
		// Got to take the half duplex event
		// BUGBUG: this method wont cut it if there is more than one send and one recv stream
		dwStatus = WaitForSingleObject(g_hEventHalfDuplex, 0);
		if (dwStatus != WAIT_OBJECT_0)
			return DPR_CANT_OPEN_DEV;
	}
	//	Stop any high level ("PlaySound()") usage of wave device.
	
	// Create the direct sound object (if necessary)
	hr = DirectSoundMgr::Instance(m_RenderingDevice==WAVE_MAPPER ? NULL: &m_DSguid, &m_pDS, m_pDP->m_hAppWnd, &m_fDevRecv);

	if (hr == S_OK)
	{
		hr = m_pDS->CreateSoundBuffer(&m_DSBufDesc,&m_pDSBuf,NULL);
		if (hr == DSERR_INVALIDPARAM)
		{
			// if global focus (DX3) is not supported, try sticky focus
			m_DSBufDesc.dwFlags ^= (DSBCAPS_GLOBALFOCUS|DSBCAPS_STICKYFOCUS);
			hr = m_pDS->CreateSoundBuffer(&m_DSBufDesc,&m_pDSBuf,NULL);
		}
		m_PlayPosT = 0;		// DS play position is initially at the start of the buffer

		if (hr != S_OK)
		{
			DEBUGMSG (ZONE_DP, ("%s: CreateSoundBuffer create failed, hr=0x%lX\r\n", _fx_, hr));

			m_nFailCount++;
			if (m_nFailCount == MAX_FAILCOUNT)
			{
				m_pDP->StreamEvent(MCF_RECV, MCF_AUDIO, STREAM_EVENT_DEVICE_FAILURE, 0);
				m_bJammed = TRUE;
				m_bCanSignalOpen = TRUE;
			}
		}

		dscaps.dwSize = sizeof(dscaps);
		dscaps.dwFlags = 0;
		m_pDS->GetCaps(&dscaps);	// get DirectSound object attributes
		m_DSFlags = dscaps.dwFlags;

		if (m_DSFlags & DSCAPS_EMULDRIVER)
		{
			// use g_MinDSEmulAudioDelay since this is the emulated driver
			m_MinDelayT = (m_fDevRecv.nSamplesPerSec * g_MinDSEmulAudioDelayMs) / 1000;
			m_DelayT = m_MinDelayT;
		};
	}

	else
	{
		DEBUGMSG (ZONE_DP, ("%s: DirectSound create failed, hr=0x%lX\r\n", _fx_, hr));

		m_nFailCount++;
		if (m_nFailCount == MAX_FAILCOUNT)
		{
			m_pDP->StreamEvent(MCF_RECV, MCF_AUDIO, STREAM_EVENT_DEVICE_FAILURE, 0);
			m_bJammed = TRUE;
			m_bCanSignalOpen = TRUE;
		}
	}


	if (hr == S_OK)
	{
		if (m_DPFlags & DPFLAG_STARTED_RECV)
		{
			m_pDSBuf->Play(0,0,DSBPLAY_LOOPING);
		}

		if (m_bCanSignalOpen)
		{
			m_pDP->StreamEvent(MCF_RECV, MCF_AUDIO, STREAM_EVENT_DEVICE_OPEN, 0);
			m_bCanSignalOpen = FALSE; // don't signal open condition anymore
		}

		m_bJammed = FALSE;
		m_nFailCount = 0;
	}
	else
	{
		ReleaseDSBuffer();
	}
	return hr;
}

HRESULT
RecvDSAudioStream::ReleaseDSBuffer()
{
	m_fEmpty = TRUE;
	if (m_pDSBuf) {
		ULONG uref;
		uref = m_pDSBuf->Release();
		m_pDSBuf = NULL;
		//DEBUGMSG(ZONE_DP,("Releasing DirectSound buffer (%d)\n", uref));
	}
	if (m_pDS) {
		DirectSoundMgr::ReleaseInstance(m_pDS);
		m_pDS = NULL;
		if (m_DPFlags & DP_FLAG_HALF_DUPLEX)
			SetEvent(g_hEventHalfDuplex);
	}
	return S_OK;
		
}

HRESULT
RecvDSAudioStream::Decode(UCHAR *pData, UINT cbData)
{
	MMRESULT mmr;
	HRESULT hr=S_OK;
	FX_ENTRY ("RecvDSAudioStream::Decode");
	UINT uDstLength;


	if (m_dwSrcSize < cbData)
	{
		DEBUGMSG (ZONE_DP, ("%s: RecvDSAudioStream::Decode failed - buffer larger than expected\r\n", _fx_));
		return DPR_CONVERSION_FAILED;
	}

	CopyMemory(m_StrmConvHdr.pbSrc, pData, cbData);
	m_StrmConvHdr.cbSrcLength = cbData;
	mmr = m_pAudioFilter->Convert(&m_StrmConvHdr);

	if (mmr != MMSYSERR_NOERROR)
	{
		DEBUGMSG (ZONE_DP, ("%s: acmStreamConvert failed, mmr=%ld\r\n", _fx_, (ULONG) mmr));
		hr = DPR_CONVERSION_FAILED;
	}
	else
	{
		m_StrmConvHdr.dwDstUser = BUFFER_RECEIVED;	// buffer is ready to play
		// if receive side silence detection is turned on,
		// check decoded buffer signal level
		if (m_DPFlags & DP_FLAG_AUTO_SILENCE_DETECT)
		{
			if (m_AudioMonitor.SilenceDetect((WORD) GetSignalStrength()))
			{
				m_StrmConvHdr.dwDstUser = BUFFER_SILENT;
			}
		}
	}

	return hr;
	// end
}

// insert the decoded buf at the appropriate location in the DirectSound buffer
HRESULT
RecvDSAudioStream::PlayBuf(DWORD timestamp, UINT seq, BOOL fMark)
{
	UINT lenT = BYTESTOSAMPLES(m_StrmConvHdr.cbDstLengthUsed);
	DWORD curPlayPosT, curWritePosT, curWriteLagT;
	LPVOID p1, p2;
	DWORD cb1, cb2;
	HRESULT hr;
	DWORD dwDSStatus = 0;

	/*
	All of the following are expressed in samples:
	m_NextTimeT is timestamp of next expected packet. Usually timestamp equals m_NextT
	m_BufSizeT is the total buffer size in samples.
	m_NextPosT is the write position corresponding to m_NextT.
	m_PlayPosT is the current play position
	m_DelayT is the ideal playback delay
	*/

	LOG((LOGMSG_DSTIME, GetTickCount()));
	LOG((LOGMSG_DSENTRY, timestamp, seq, fMark));

	m_pDSBuf->GetCurrentPosition(&curPlayPosT,&curWritePosT);
	curPlayPosT = BYTESTOSAMPLES(curPlayPosT);	
	curWritePosT = BYTESTOSAMPLES(curWritePosT);
	m_pDSBuf->GetStatus(&dwDSStatus);

	if (!m_fEmpty)
	{
		// wasn't empty last time we checked but is it empty now?
		if (QMOD(curPlayPosT-m_PlayPosT, m_BufSizeT) > QMOD(m_NextPosT-m_PlayPosT, m_BufSizeT))
		{
			// play cursor has advanced beyond the last written byte
			m_fEmpty = TRUE;
			LOG((LOGMSG_DSEMPTY, curPlayPosT, m_PlayPosT, m_NextPosT));
		}
		// write silence into the part of the buffer that just played
		hr = m_pDSBuf->Lock(SAMPLESTOBYTES(m_PlayPosT),SAMPLESTOBYTES(QMOD(curPlayPosT-m_PlayPosT, m_BufSizeT)), &p1, &cb1, &p2, &cb2, 0);
		if (hr == S_OK)
		{
			ZeroMemory(p1,cb1);
			if (cb2)
				ZeroMemory(p2,cb2);
			m_pDSBuf->Unlock(p1,cb1,p2,cb2);
		}
	}
	hr = S_OK;	
	
	// calculate minimum write-behind margin.
	// This is low for native sound drivers and high for emulated drivers, so , assuming it's accurate
	// there's no need to distinguish between emulated and native drivers.
	curWriteLagT = QMOD(curWritePosT-curPlayPosT, m_BufSizeT);


	if (m_fEmpty)
	{
		// the DS buffer only has silence in it. In this state, m_NextPosT and m_NextTimeT are irrelevant.
		// We get to put the new buffer wherever we choose, so we put it m_DelayT after the current write position.
		curWritePosT = QMOD(curWritePosT+m_DelayT, m_BufSizeT);
		
	}
	else
	{
	
		if (TS_EARLIER(timestamp, m_NextTimeT))
			hr = DPR_OUT_OF_SEQUENCE;	// act dumb and discard misordered packets
		else
		{
			UINT curDelayT = QMOD(m_NextPosT - curPlayPosT, m_BufSizeT);
			if (fMark)
			{
				// we have some leeway in choosing the insertion point, because this is the start of a talkspurt
				if (curDelayT > m_DelayT + curWriteLagT)
				{
					// put it right after the last sample
					curWritePosT = m_NextPosT;
				}
				else
				{
					// put it m_DelayT after the current write position
					curWritePosT = QMOD(curWritePosT+m_DelayT, m_BufSizeT);
				}
			}
			else
			{
				// bytes in
				if ((timestamp-m_NextTimeT + curDelayT) < m_BufSizeT)
				{
					curWritePosT = QMOD(m_NextPosT +timestamp-m_NextTimeT, m_BufSizeT);
				}
				else
				{
					// overflow!! Could either dump whats in buffer or dump the packet
					// dumping the packet is easier for now
					hr = DPR_OUT_OF_SEQUENCE;
				}
			}
		}
	}
	if ((dwDSStatus & DSBSTATUS_PLAYING) && (seq != INVALID_RTP_SEQ_NUMBER))
		UpdateVariableDelay(timestamp,curPlayPosT );
	// When receive silence detection is enabled:
    // dont play the packet if we have received at least a quarter second of silent packets.
    // This will enable switch to talk (in half-duplex mode).
	if (m_StrmConvHdr.dwDstUser == BUFFER_SILENT)
		m_SilenceDurationT += lenT;
	else
		m_SilenceDurationT = 0;	
		
	if (hr == S_OK && m_SilenceDurationT < m_fDevRecv.nSamplesPerSec/4)
	{
		LOG((LOGMSG_DSPLAY,curPlayPosT, curWritePosT, lenT));
		// check if we have space for the whole packet
		if (QMOD(curWritePosT-curPlayPosT, m_BufSizeT) > m_BufSizeT - lenT)
		{
			// no
			curPlayPosT = QMOD(curWritePosT + lenT + 1000, m_BufSizeT);
			hr = m_pDSBuf->SetCurrentPosition(SAMPLESTOBYTES(curPlayPosT));
			LOG((LOGMSG_DSMOVPOS,curPlayPosT, hr));
		}
		
		hr = m_pDSBuf->Lock(SAMPLESTOBYTES(curWritePosT),m_StrmConvHdr.cbDstLengthUsed, &p1, &cb1, &p2, &cb2, 0);
		if (hr == S_OK)
		{
			CopyMemory(p1, m_StrmConvHdr.pbDst, cb1);
			if (cb2)
				CopyMemory(p2, m_StrmConvHdr.pbDst+cb1, cb2);
			m_pDSBuf->Unlock(p1,cb1,p2,cb2);

			m_fEmpty = FALSE;
		}
		else
		{
			DEBUGMSG(ZONE_DP,("DirectSoundBuffer->Lock failed with %x\n",hr));
		}
		m_StrmConvHdr.dwDstUser = 0;	// to indicate that the decode buffer is empty again
		m_NextTimeT = timestamp + lenT;
		m_NextPosT = QMOD(curWritePosT+lenT, m_BufSizeT);
		// now calculate total queued length
		lenT = QMOD(m_NextPosT- curPlayPosT, m_BufSizeT);
		// Reset the timer to trigger shortly after  the last valid sample has played
		// The timer serves two purposes:
		// - ensure that the DS buffer is silenced before it wraps around
		// - allow the DS object to be released in the half-duplex case, once the remote stops sending
		// convert to millisecs
		// Need to make sure the timeout happens before the DS buffer wrapsaround.

		if (lenT > m_BufSizeT/2)
			lenT = m_BufSizeT/2;
		lenT = lenT * 1000/ m_fDevRecv.nSamplesPerSec;
		m_pDP->m_RecvTimer.CancelTimeout(&m_TimeoutObj);
		m_TimeoutObj.SetDueTime(GetTickCount()+lenT+100);
		m_pDP->m_RecvTimer.SetTimeout(&m_TimeoutObj);
	}
	m_PlayPosT = curPlayPosT;
	return hr;
		
}
// This routine is called on every packet to perform the adaptive delay calculation
// Remote time is measured by the RTP timestamp and local time is measured by the DirectSound
// play pointer.
// The general idea is to average how much a packet is later than its 'expected' arrival time,
// assuming the packet with the shortest trip delay is dead on time.
//
void
RecvDSAudioStream::UpdateVariableDelay(DWORD sendT, DWORD curPlayPosT)
{
#define PLAYOUT_DELAY_FACTOR	2
	LONG deltaA, deltaS;
	DWORD delay;
	// update arrival time based on how much the DS play pointer has advanced
	// since the last packet
	m_ArrT += QMOD(curPlayPosT-m_PlayPosT, m_BufSizeT);
	// m_ArrivalT0 and m_SendT0 are the arrival and send timestamps of the packet
	// with the shortest trip delay. We could have just stored (m_ArrivalT0 - m_SendT0)
	// but since the local and remote clocks are completely unsynchronized, there would
	// be signed/unsigned complications.
	deltaS = sendT - m_SendT0;
	deltaA = m_ArrT - m_ArrivalT0;
	if (deltaA < deltaS 		// this packet took less time
		|| deltaA > (int)m_fDevRecv.nSamplesPerSec*8	// reset every 8 secs
		|| deltaS < -(int)m_fDevRecv.nSamplesPerSec	// or after big timestamp jumps
		)	
	{
		delay = 0;
		// delay = deltaS - deltaA
		// replace shortest trip delay times
		m_SendT0 = sendT;
		m_ArrivalT0 = m_ArrT;
	} else {
		// variable delay is how much longer this packet took
		delay = deltaA - deltaS;
	}
	// now update average variable delay according to
	// m_AvgVarDelay = m_AvgVarDelay + (delay - m_AvgVarDelay)*1/16;
	// however we are storing the scaled average, with a scaling
	// factor of 16. So the calculation becomes
	m_ScaledAvgVarDelay = m_ScaledAvgVarDelay + (delay - m_ScaledAvgVarDelay/16);
	// now calculate actual buffering delay we will use
	//  MinDelay adds some slack (may be necessary for some drivers)
	m_DelayT = m_MinDelayT + PLAYOUT_DELAY_FACTOR * m_ScaledAvgVarDelay/16;
	if (m_DelayT > m_MaxDelayT) m_DelayT = m_MaxDelayT;

	LOG((LOGMSG_JITTER,delay, m_ScaledAvgVarDelay/16, m_DelayT));


	UPDATE_COUNTER(g_pctrAudioJBDelay, (m_DelayT * 1000)/m_fDevRecv.nSamplesPerSec);

}

void
RecvDSAudioStream::RecvTimeout()
{
	DWORD curPlayPosT, curWritePosT;
	LPVOID p1, p2;
	DWORD cb1, cb2;
	UINT lenT;
	HRESULT hr;

	if (m_pDSBuf == NULL)
	{
		WARNING_OUT(("RecvDSAudioStream::RecvTimeout - DirectSoundBuffer is not valid\r\n"));
		return;
	}


	m_pDSBuf->GetCurrentPosition(&curPlayPosT,&curWritePosT);
	curPlayPosT = BYTESTOSAMPLES(curPlayPosT);
	curWritePosT = BYTESTOSAMPLES(curWritePosT);

	// this part is cut and pasted from PlayBuf
	if (!m_fEmpty) {
		// wasn't empty last time we checked but is it empty now?
		if (QMOD(curPlayPosT-m_PlayPosT, m_BufSizeT) > QMOD(m_NextPosT-m_PlayPosT, m_BufSizeT)) {
			// play cursor has advanced beyond the last written byte
			m_fEmpty = TRUE;
		}
		// write silence into the part of the buffer that just played
		hr = m_pDSBuf->Lock(SAMPLESTOBYTES(m_PlayPosT),SAMPLESTOBYTES(QMOD(curPlayPosT-m_PlayPosT, m_BufSizeT)), &p1, &cb1, &p2, &cb2, 0);
		if (hr == S_OK) {
			ZeroMemory(p1,cb1);
			if (cb2)
				ZeroMemory(p2,cb2);
			m_pDSBuf->Unlock(p1,cb1,p2,cb2);
		}
	}
	LOG((LOGMSG_DSTIMEOUT, curPlayPosT, m_NextPosT, GetTickCount()));
	
	m_PlayPosT = curPlayPosT;
	if (!m_fEmpty) {
		// The buffer isnt quite empty yet!
		// Reschedule??
		DEBUGMSG(ZONE_DP,("DSBuffer not empty after timeout\n"));
		lenT = QMOD(m_NextPosT- curPlayPosT, m_BufSizeT);
		// Reset the timer to trigger shortly after  the last valid sample has played
		// Need to make sure the timeout happens before the DS buffer wrapsaround.
		if (lenT > m_BufSizeT/2)
			lenT = m_BufSizeT/2;
		// convert to millisecs
		lenT = lenT * 1000/ m_fDevRecv.nSamplesPerSec;
		m_TimeoutObj.SetDueTime(GetTickCount()+lenT+100);
		m_pDP->m_RecvTimer.SetTimeout(&m_TimeoutObj);
	}
	else if (m_DPFlags & DP_FLAG_HALF_DUPLEX)
	{
		// need to release the DSBuffer and DSObject
		ReleaseDSBuffer();
	}
}

HRESULT RecvDSAudioStream::RTPCallback(WSABUF *pWsaBuf, DWORD timestamp, UINT seq, UINT fMark)
{
	HRESULT hr;

    if (m_ThreadFlags & DPTFLAG_PAUSE_RECV)
	{
		return E_FAIL;
    }

	// update number of bits received
	UPDATE_COUNTER(g_pctrAudioReceiveBytes,(pWsaBuf->len + IP_HEADER_SIZE + UDP_HEADER_SIZE)*8);

	hr = Decode((BYTE *)pWsaBuf->buf + sizeof(RTP_HDR), pWsaBuf->len - sizeof(RTP_HDR));
	if (hr == S_OK )
	{
		// Have we initialized DirectSound?
		// Yes, unless its half-duplex
		if (!m_pDSBuf)
		{
			hr = CreateDSBuffer();
		}
		if (hr == S_OK)
		{
			PlayBuf(timestamp, seq, fMark);
		}
	}
	m_pIRTPRecv->FreePacket(pWsaBuf);
	return S_OK;
}

// this method called from the UI thread only
HRESULT RecvDSAudioStream::DTMFBeep()
{
	if ( (!(m_DPFlags & DPFLAG_STARTED_RECV)) ||
		 (m_ThreadFlags & DPTFLAG_PAUSE_RECV) )
	{
		return E_FAIL;
	}

	m_pDP->RecvThreadMessage(MSG_PLAY_SOUND, this);

	return S_OK;
}


HRESULT RecvDSAudioStream::OnDTMFBeep()
{
	int nBeeps;
	DWORD dwBufSize = m_StrmConvHdr.cbDstLength;
	HRESULT hr=S_OK;
	int nIndex;

	if ( (!(m_DPFlags & DPFLAG_STARTED_RECV)) ||
		 (m_ThreadFlags & DPTFLAG_PAUSE_RECV) )
	{
		return E_FAIL;
	}

	if (dwBufSize == 0)
	{
		return E_FAIL;
	}


	nBeeps = DTMF_FEEDBACK_BEEP_MS / ((dwBufSize * 1000) / m_fDevRecv.nAvgBytesPerSec);

	if (nBeeps == 0)
	{
		nBeeps = 1;
	}

	MakeDTMFBeep(&m_fDevRecv, m_StrmConvHdr.pbDst , m_StrmConvHdr.cbDstLength);

	if (!m_pDSBuf)
	{
		hr = CreateDSBuffer();
		if (FAILED(hr))
		{
			return hr;
		}
	}


	m_StrmConvHdr.dwDstUser = BUFFER_RECEIVED;
	PlayBuf(m_NextTimeT , INVALID_RTP_SEQ_NUMBER, true);
	nBeeps--;

	for (nIndex = 0; nIndex < nBeeps; nIndex++)
	{
		m_StrmConvHdr.dwDstUser = BUFFER_RECEIVED;
		PlayBuf(m_NextTimeT, INVALID_RTP_SEQ_NUMBER, false);
	}
	
	return S_OK;

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\dscstream.cpp ===
#include "precomp.h"
#include <nmdsprv.h>

#include "mixer.h"
#include "dscstream.h"
#include "agc.h"


// static member initialization
BOOL DSC_Manager::s_bInitialized = FALSE;
DSC_CAPTURE_INFO DSC_Manager::s_aDSC[MAX_NUMBER_DSCAPTURE_DEVICES];
int DSC_Manager::s_nCaptureDevices = 0;
HINSTANCE DSC_Manager::s_hDSCLib = NULL;
DS_CAP_CREATE DSC_Manager::s_pDSCapCreate = NULL;
DS_CAP_ENUM DSC_Manager::s_pDSCapEnum = NULL;




// static
HRESULT DSC_Manager::Initialize()
{

	if (s_bInitialized)
	{
		return S_OK;
	}


	// failsafe way to to turn DSC off, without turning
	// DirectSound support off.  Otherwise, the UI setting
	// to disable DS will also disable DSC.
	{
		BOOL bDisable;
		RegEntry re(DISABLE_DSC_REGKEY, HKEY_LOCAL_MACHINE, FALSE,0);

		bDisable = re.GetNumber(DISABLE_DSC_REGVALUE, FALSE);
		if (bDisable)
		{
			return E_FAIL;
		}
	}


	// initialize the array of structure descriptions

	s_hDSCLib = LoadLibrary(DSOUND_DLL);

	if (s_hDSCLib == NULL)
		return E_FAIL;


	s_pDSCapCreate = (DS_CAP_CREATE)GetProcAddress(s_hDSCLib, "DirectSoundCaptureCreate");
	s_pDSCapEnum = (DS_CAP_ENUM)GetProcAddress(s_hDSCLib, "DirectSoundCaptureEnumerateA");

	if ((s_pDSCapCreate) && (s_pDSCapEnum))
	{
		// enumerate!

		s_pDSCapEnum(DSC_Manager::DSEnumCallback, 0);

		if (s_nCaptureDevices != 0)
		{
			s_bInitialized = TRUE;
			return S_OK; // success
		}
	}

	FreeLibrary(s_hDSCLib);
	s_hDSCLib = NULL;
	return E_FAIL;

}



// static
BOOL CALLBACK DSC_Manager::DSEnumCallback(LPGUID lpGuid, LPCSTR lpcstrDescription,
	                           LPCSTR lpcstrModule, LPVOID lpContext)
{
	if (lpGuid == NULL)
	{
		s_aDSC[s_nCaptureDevices].guid = GUID_NULL;
	}
	else
	{
		s_aDSC[s_nCaptureDevices].guid = *lpGuid;
	}


	lstrcpyn(s_aDSC[s_nCaptureDevices].szDescription, lpcstrDescription, MAX_DSC_DESCRIPTION_STRING);

	s_aDSC[s_nCaptureDevices].uWaveId = WAVE_MAPPER;
	s_nCaptureDevices++;
	return TRUE;
}


// static
HRESULT DSC_Manager::CreateInstance(GUID *pGuid, IDirectSoundCapture **pDSC)
{
	HRESULT hr;

	if FAILED(Initialize())
	{
		return E_FAIL;
	}

	if (*pGuid == GUID_NULL)
		pGuid = NULL;

	hr = s_pDSCapCreate(pGuid, pDSC, NULL);

	return hr;
}


// static
HRESULT DSC_Manager::MapWaveIdToGuid(UINT uWaveID, GUID *pGuid)
{

	HRESULT hr;
	WAVEINCAPS waveInCaps;
	UINT uNumWaveDevs;
	GUID guid = GUID_NULL;
	int nIndex;
	MMRESULT mmr;
	HWAVEIN hWaveIn;
	WAVEFORMATEX waveFormat = {WAVE_FORMAT_PCM, 1, 8000, 16000, 2, 16, 0};
	IDirectSoundCapture *pDSC=NULL;

	*pGuid = GUID_NULL;
	
	if (FAILED( Initialize() ))
	{
		return E_FAIL;
	}

	// only one wave device, take the easy way out
	uNumWaveDevs = waveInGetNumDevs();

	if ((uNumWaveDevs <= 1) || (uWaveID == WAVE_MAPPER))
	{
		return S_OK;
	}

	// more than one wavein device
	mmr = waveInGetDevCaps(uWaveID, &waveInCaps, sizeof(WAVEINCAPS));
	if (mmr == MMSYSERR_NOERROR)
	{
		hr = DsprvGetWaveDeviceMapping(waveInCaps.szPname, TRUE, &guid);
		if (SUCCEEDED(hr))
		{
			*pGuid = guid;
			return S_OK;
		}
	}


	// scan through the DSC list to see if we've mapped this device
	// previously

	for (nIndex = 0; nIndex < s_nCaptureDevices; nIndex++)
	{
		if (s_aDSC[nIndex].uWaveId == uWaveID)
		{
			*pGuid = s_aDSC[nIndex].guid;
			return S_OK;
		}
	}

	//  hack approach to mapping the device to a guid
	mmr = waveInOpen(&hWaveIn, uWaveID, &waveFormat, 0,0,0);
	if (mmr != MMSYSERR_NOERROR)
	{
		return S_FALSE;
	}

	// find all the DSC devices that fail to open
	for (nIndex = 0; nIndex < s_nCaptureDevices; nIndex++)
	{
		s_aDSC[nIndex].bAllocated = FALSE;
		hr = CreateInstance(&(s_aDSC[nIndex].guid), &pDSC);
		if (FAILED(hr))
		{
			s_aDSC[nIndex].bAllocated = TRUE;
		}
		else
		{
			pDSC->Release();
			pDSC=NULL;
		}
	}

	waveInClose(hWaveIn);

	// scan through the list of allocated devices and
	// see which one opens
	for (nIndex = 0; nIndex < s_nCaptureDevices; nIndex++)
	{
		if (s_aDSC[nIndex].bAllocated)
		{
			hr = CreateInstance(&(s_aDSC[nIndex].guid), &pDSC);
			if (SUCCEEDED(hr))
			{
				// we have a winner
				pDSC->Release();
				pDSC = NULL;
				*pGuid = s_aDSC[nIndex].guid;
				s_aDSC[nIndex].uWaveId = uWaveID;
				return S_OK;
			}
		}
	}
	// if we got to this point, it means we failed to map a device
	// just use GUID_NULL and return an error
	return S_FALSE;
}






SendDSCStream::SendDSCStream() :
SendMediaStream(),
m_pAudioFilter(NULL),
m_lRefCount(0),
m_pDSC(NULL),
m_pDSCBuffer(NULL),
m_hEvent(NULL),
m_dwSamplesPerFrame(0),
m_dwNumFrames(0),
m_dwFrameSize(0),
m_dwDSCBufferSize(0),
m_dwSilenceTime(0),
m_dwFrameTimeMS(0),
m_bFullDuplex(TRUE),
m_bJammed(FALSE),
m_bCanSignalOpen(TRUE),
m_bCanSignalFail(TRUE),
m_nFailCount(0),
m_agc(NULL),
m_bAutoMix(FALSE),
m_pDTMF(NULL)
{
	return;
};


HRESULT SendDSCStream::Initialize(DataPump *pDP)
{
	HRESULT hr;


	m_pDP = pDP;

	hr = DSC_Manager::Initialize();
	if (FAILED(hr))
	{
		return hr;
	}

	m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (m_hEvent == NULL)
	{
		return DPR_CANT_CREATE_EVENT;
	}

    DBG_SAVE_FILE_LINE
	m_pAudioFilter = new AcmFilter();
	if (!m_pAudioFilter)
	{
		return DPR_OUT_OF_MEMORY;
	}

    DBG_SAVE_FILE_LINE
	m_pDTMF = new DTMFQueue;
	if (!m_pDTMF)
	{
		return DPR_OUT_OF_MEMORY;
	}


	m_DPFlags = DP_FLAG_ACM|DP_FLAG_MMSYSTEM|DP_FLAG_DIRECTSOUND|DP_FLAG_SEND;

	m_SendTimestamp = m_SavedTickCount = timeGetTime();

	m_dwDstSize = 0;
	m_fSending = FALSE;

	m_hCapturingThread = NULL;
	m_CaptureThId = 0;
	m_ThreadFlags = 0;

	m_pRTPSend = NULL;
	m_RTPPayload = 0;

	m_CaptureDevice = -1;
	m_pRTPSend = NULL;

	ZeroMemory(m_aPackets, sizeof(m_aPackets));
	ZeroMemory(&m_mmioSrc, sizeof(m_mmioSrc));

	m_DPFlags = DP_FLAG_ACM | DP_FLAG_MMSYSTEM | DP_FLAG_AUTO_SILENCE_DETECT;
	m_DPFlags = (m_DPFlags & DP_MASK_PLATFORM) | DPFLAG_ENABLE_SEND;
	m_DPFlags |= DPFLAG_INITIALIZED;

	return S_OK;

}



SendDSCStream::~SendDSCStream()
{
	if (m_DPFlags & DPFLAG_INITIALIZED)
	{
		if (m_DPFlags & DPFLAG_CONFIGURED_SEND)
		{
			UnConfigure();
		}

		if (m_pRTPSend)
		{
			m_pRTPSend->Release();
			m_pRTPSend = NULL;
		}

		if (m_pDTMF)
		{
			delete m_pDTMF;
			m_pDTMF = NULL;
		}

		if (m_pAudioFilter)
		{
			delete m_pAudioFilter;
		}

		if (m_hEvent)
		{
			CloseHandle(m_hEvent);
		}

		m_pDP->RemoveMediaChannel(MCF_SEND|MCF_AUDIO, (IMediaChannel*)(SendMediaStream*)this);

		m_DPFlags &= ~DPFLAG_INITIALIZED;
	}
	
}



HRESULT STDMETHODCALLTYPE SendDSCStream::Configure(
	BYTE *pFormat,
	UINT cbFormat,
	BYTE *pChannelParams,
	UINT cbParams,
	IUnknown *pUnknown)
{
	AUDIO_CHANNEL_PARAMETERS audChannelParams;
	WAVEFORMATEX *pwfSend;
	MMRESULT mmr;
	MEDIAPACKETINIT mpi;
	DWORD dwSourceSize;
	int nIndex;
	HRESULT hr;

	FX_ENTRY ("SendDSCStream::Configure");


	// basic parameter checking
	if (! (m_DPFlags & DPFLAG_INITIALIZED))
	{
		return DPR_OUT_OF_MEMORY;
	}

	// Not a good idea to change anything while in mid-stream
	if (m_DPFlags & DPFLAG_STARTED_SEND)
	{
		return DPR_IO_PENDING; // anything better to return
	}

	if (m_DPFlags & DPFLAG_CONFIGURED_SEND)
	{
		DEBUGMSG(ZONE_DP, ("Stream Re-Configuration - calling UnConfigure"));
		UnConfigure();
	}

	if ((NULL == pFormat) || (NULL == pChannelParams) ||
		(cbParams < sizeof(AUDIO_CHANNEL_PARAMETERS)) ||
		(cbFormat < sizeof(WAVEFORMATEX)))
	{
		return DPR_INVALID_PARAMETER;
	}

	audChannelParams = *(AUDIO_CHANNEL_PARAMETERS *)pChannelParams;
	pwfSend = (WAVEFORMATEX *)pFormat;
	m_wfCompressed = *pwfSend;
	m_wfCompressed.cbSize = 0;

	// initialize the ACM filter
	mmr = AcmFilter::SuggestDecodeFormat(pwfSend, &m_wfPCM);
	if (mmr != MMSYSERR_NOERROR)
	{
		return DPR_INVALID_PARAMETER;
	}

	mmr = m_pAudioFilter->Open(&m_wfPCM, pwfSend);
	if (mmr != 0)
	{
		DEBUGMSG (ZONE_DP, ("%s: AcmFilter->Open failed, mmr=%d\r\n", _fx_, mmr));
		return DPR_CANT_OPEN_CODEC;
	}

	m_dwSamplesPerFrame = audChannelParams.ns_params.wFrameSize * audChannelParams.ns_params.wFramesPerPkt;
	m_dwFrameTimeMS = (m_dwSamplesPerFrame * 1000) / m_wfPCM.nSamplesPerSec;

	ASSERT(m_dwFrameTimeMS > 0);
	if (m_dwFrameTimeMS <= 0)
	{
		m_pAudioFilter->Close();
		return DPR_INVALID_PARAMETER;
	}

	m_dwNumFrames = 1000 / m_dwFrameTimeMS;
	if (m_dwNumFrames < MIN_NUM_DSC_SEGMENTS)
	{
		m_dwNumFrames = MIN_NUM_DSC_SEGMENTS;
	}


	m_dwFrameSize = m_dwSamplesPerFrame * m_wfPCM.nBlockAlign;
	m_pAudioFilter->SuggestDstSize(m_dwFrameSize, &m_dwDstSize);


	m_dwDSCBufferSize = m_dwFrameSize * m_dwNumFrames;

	// create the packets

	ZeroMemory(&mpi, sizeof(mpi));


	mpi.dwFlags = DP_FLAG_SEND | DP_FLAG_ACM | DP_FLAG_MMSYSTEM;
	mpi.cbOffsetNetData = sizeof(RTP_HDR);
	mpi.cbSizeNetData = m_dwDstSize;
	mpi.cbSizeDevData = m_dwFrameSize;
	mpi.cbSizeRawData = m_dwFrameSize;
	mpi.pDevFmt = &m_wfPCM;
	mpi.pStrmConvSrcFmt = &m_wfPCM;
	mpi.payload = audChannelParams.RTP_Payload;
	mpi.pStrmConvDstFmt = &m_wfCompressed;

	hr = CreateAudioPackets(&mpi);
	if (FAILED(hr))
	{
		m_pAudioFilter->Close();
		return hr;
	}

	AudioFile::OpenSourceFile(&m_mmioSrc, &m_wfPCM);

	m_pDTMF->Initialize(&m_wfPCM);
	m_pDTMF->ClearQueue();


	// Initialize RSVP structures
	InitAudioFlowspec(&m_flowspec, pwfSend, m_dwDstSize);


	// Initialize QOS structures
	if (m_pDP->m_pIQoS)
	{
		// Initialize our requests. One for CPU usage, one for bandwidth usage.
		m_aRRq.cResourceRequests = 2;
		m_aRRq.aResourceRequest[0].resourceID = RESOURCE_OUTGOING_BANDWIDTH;
		if (m_dwFrameTimeMS)
		{
			m_aRRq.aResourceRequest[0].nUnitsMin = (DWORD)(m_dwDstSize + sizeof(RTP_HDR) + IP_HEADER_SIZE + UDP_HEADER_SIZE) * 8000 / m_dwFrameTimeMS;
		}
		else
		{
			m_aRRq.aResourceRequest[0].nUnitsMin = 0;
		}
		m_aRRq.aResourceRequest[1].resourceID = RESOURCE_CPU_CYCLES;
		m_aRRq.aResourceRequest[1].nUnitsMin = 800;

//      BUGBUG. This is, in theory the correct calculation, but until we do more investigation, go with a known value
//		m_aRRq.aResourceRequest[1].nUnitsMin = (audDetails.wCPUUtilizationEncode+audDetails.wCPUUtilizationDecode)*10;

		// Initialize QoS structure
		ZeroMemory(&m_Stats, sizeof(m_Stats));

		// Initialize oldest QoS callback timestamp
		// Register with the QoS module. Even if this call fails, that's Ok, we'll do without the QoS support
		
		// The Callback is defined in SendAudioStream
		m_pDP->m_pIQoS->RequestResources((GUID *)&MEDIA_TYPE_H323AUDIO, (LPRESOURCEREQUESTLIST)&m_aRRq, SendAudioStream::QosNotifyAudioCB, (DWORD_PTR)this);
	}



	// Initialize Statview constats
	UPDATE_REPORT_ENTRY(g_prptCallParameters, pwfSend->wFormatTag, REP_SEND_AUDIO_FORMAT);
	UPDATE_REPORT_ENTRY(g_prptCallParameters, pwfSend->nSamplesPerSec, REP_SEND_AUDIO_SAMPLING);
	UPDATE_REPORT_ENTRY(g_prptCallParameters, pwfSend->nAvgBytesPerSec * 8, REP_SEND_AUDIO_BITRATE);
	RETAILMSG(("NAC: Audio Send Format: %s", (pwfSend->wFormatTag == 66) ? "G723.1" : (pwfSend->wFormatTag == 112) ? "LHCELP" : (pwfSend->wFormatTag == 113) ? "LHSB08" : (pwfSend->wFormatTag == 114) ? "LHSB12" : (pwfSend->wFormatTag == 115) ? "LHSB16" : (pwfSend->wFormatTag == 6) ? "MSALAW" : (pwfSend->wFormatTag == 7) ? "MSULAW" : (pwfSend->wFormatTag == 130) ? "MSRT24" : "??????"));
	RETAILMSG(("NAC: Audio Send Sampling Rate (Hz): %ld", pwfSend->nSamplesPerSec));
	RETAILMSG(("NAC: Audio Send Bitrate (w/o network overhead - bps): %ld", pwfSend->nAvgBytesPerSec*8));

	UPDATE_REPORT_ENTRY(g_prptCallParameters, m_dwSamplesPerFrame, REP_SEND_AUDIO_PACKET);
	RETAILMSG(("NAC: Audio Send Packetization (ms/packet): %ld", pwfSend->nSamplesPerSec ? m_dwSamplesPerFrame * 1000UL / pwfSend->nSamplesPerSec : 0));
	INIT_COUNTER_MAX(g_pctrAudioSendBytes, (pwfSend->nAvgBytesPerSec + pwfSend->nSamplesPerSec * (sizeof(RTP_HDR) + IP_HEADER_SIZE + UDP_HEADER_SIZE) / m_dwSamplesPerFrame) << 3);

	m_DPFlags |= DPFLAG_CONFIGURED_SEND;
	return S_OK;
}

void SendDSCStream::UnConfigure()
{
	if (m_DPFlags & DPFLAG_CONFIGURED_SEND)
	{
		Stop();

		m_pAudioFilter->Close();
		ReleaseAudioPackets();

		AudioFile::CloseSourceFile(&m_mmioSrc);

		m_ThreadFlags = 0;

		if (m_pDP->m_pIQoS)
		{
			m_pDP->m_pIQoS->ReleaseResources((GUID *)&MEDIA_TYPE_H323AUDIO, (LPRESOURCEREQUESTLIST)&m_aRRq);
		}

		m_DPFlags &= ~DPFLAG_CONFIGURED_SEND;

	}
}


DWORD CALLBACK SendDSCStream::StartRecordingThread (LPVOID pVoid)
{
	SendDSCStream *pThisStream = (SendDSCStream*)pVoid;
	return pThisStream->RecordingThread();
}


HRESULT STDMETHODCALLTYPE
SendDSCStream::Start()
{
	FX_ENTRY ("SendDSCStream::Start")

	if (m_DPFlags & DPFLAG_STARTED_SEND)
		return DPR_SUCCESS;

	if (!(m_DPFlags & DPFLAG_ENABLE_SEND))
		return DPR_SUCCESS;

	if ((!(m_DPFlags & DPFLAG_CONFIGURED_SEND)) || (m_pRTPSend==NULL))
		return DPR_NOT_CONFIGURED;

	ASSERT(!m_hCapturingThread);
	m_ThreadFlags &= ~(DPTFLAG_STOP_RECORD|DPTFLAG_STOP_SEND);

	SetFlowSpec();

	// Start recording thread
	if (!(m_ThreadFlags & DPTFLAG_STOP_RECORD))
		m_hCapturingThread = CreateThread(NULL,0, SendDSCStream::StartRecordingThread,(LPVOID)this,0,&m_CaptureThId);

	m_DPFlags |= DPFLAG_STARTED_SEND;

	DEBUGMSG (ZONE_DP, ("%s: Record threadid=%x,\r\n", _fx_, m_CaptureThId));
	return DPR_SUCCESS;
}

HRESULT
SendDSCStream::Stop()
{											
	DWORD dwWait;

	if(!(m_DPFlags & DPFLAG_STARTED_SEND))
	{
		return DPR_SUCCESS;
	}
	
	m_ThreadFlags = m_ThreadFlags  |
		DPTFLAG_STOP_SEND |  DPTFLAG_STOP_RECORD ;

	
	DEBUGMSG (ZONE_DP, ("SendDSCStream::Stop - Waiting for record thread to exit\r\n"));

	if (m_hCapturingThread)
	{
		dwWait = WaitForSingleObject (m_hCapturingThread, INFINITE);

		DEBUGMSG (ZONE_DP, ("SendDSCStream::Stop: Recording thread exited\r\n"));
		ASSERT(dwWait != WAIT_FAILED);
	
		CloseHandle(m_hCapturingThread);
		m_hCapturingThread = NULL;
	}
	m_DPFlags &= ~DPFLAG_STARTED_SEND;
	
	return DPR_SUCCESS;
}


HRESULT STDMETHODCALLTYPE SendDSCStream::SetMaxBitrate(UINT uMaxBitrate)
{
	return S_OK;
}


HRESULT STDMETHODCALLTYPE SendDSCStream::QueryInterface(REFIID iid, void **ppVoid)
{
	// resolve duplicate inheritance to the SendMediaStream;

	if (iid == IID_IUnknown)
	{
		*ppVoid = (IUnknown*)((SendMediaStream*)this);
	}
	else if (iid == IID_IMediaChannel)
	{
		*ppVoid = (IMediaChannel*)((SendMediaStream *)this);
	}
	else if (iid == IID_IAudioChannel)
	{
		*ppVoid = (IAudioChannel*)this;
	}
	else if (iid == IID_IDTMFSend)
	{
		*ppVoid = (IDTMFSend*)this;
	}
	else
	{
		*ppVoid = NULL;
		return E_NOINTERFACE;
	}
	AddRef();

	return S_OK;

}

ULONG STDMETHODCALLTYPE SendDSCStream::AddRef(void)
{
	return InterlockedIncrement(&m_lRefCount);
}

ULONG STDMETHODCALLTYPE SendDSCStream::Release(void)
{
	LONG lRet;

	lRet = InterlockedDecrement(&m_lRefCount);

	if (lRet == 0)
	{
		delete this;
		return 0;
	}

	else
		return lRet;

}

HRESULT STDMETHODCALLTYPE SendDSCStream::GetSignalLevel(UINT *pSignalStrength)
{
	UINT uLevel;
	DWORD dwJammed;

	if(!(m_DPFlags & DPFLAG_STARTED_SEND))
	{
		uLevel = 0;
	}
	else
	{
		uLevel = m_AudioMonitor.GetSignalStrength();

		if (m_bJammed)
		{
			uLevel = (2 << 16);  // 0x0200
		}
		else if (m_fSending)
		{
			uLevel |= (1 << 16); // 0x0100 + uLevel
		}
	}

	*pSignalStrength = uLevel;
	return S_OK;


	return 0;
}

HRESULT STDMETHODCALLTYPE SendDSCStream::GetProperty(DWORD dwProp, PVOID pBuf, LPUINT pcbBuf)
{
	HRESULT hr = DPR_SUCCESS;
	RTP_STATS RTPStats;
	DWORD dwValue;
	UINT len = sizeof(DWORD);	// most props are DWORDs

	if (!pBuf || *pcbBuf < len)
    {
		*pcbBuf = len;
		return DPR_INVALID_PARAMETER;
	}

	switch (dwProp)
    {

	case PROP_SILENCE_LEVEL:
		*(DWORD *)pBuf = m_AudioMonitor.GetSilenceLevel();
		break;

	case PROP_DUPLEX_TYPE:
		if(m_bFullDuplex == TRUE)
			*(DWORD*)pBuf = DUPLEX_TYPE_FULL;
		else
			*(DWORD*)pBuf =	DUPLEX_TYPE_HALF;
		break;

	case PROP_RECORD_ON:
		*(DWORD *)pBuf = (m_DPFlags & DPFLAG_ENABLE_SEND) !=0;
		break;

	case PROP_PAUSE_SEND:
		// To be determined
		break;

	case PROP_AUDIO_AUTOMIX:
		*(DWORD*)pBuf = m_bAutoMix;
		break;

	case PROP_RECORD_DEVICE:
		*(DWORD *)pBuf = m_CaptureDevice;
		break;

	default:
		hr = DPR_INVALID_PROP_ID;
		break;
	}
	return hr;
}


HRESULT STDMETHODCALLTYPE SendDSCStream::SetProperty(DWORD dwProp, PVOID pBuf, UINT cbBuf)
{
	DWORD dw;
	HRESULT hr = S_OK;
	
	if (cbBuf < sizeof (DWORD))
		return DPR_INVALID_PARAMETER;

	switch (dwProp)
    {
	case PROP_SILENCE_LEVEL:
		m_AudioMonitor.SetSilenceLevel(*(DWORD *)pBuf);
		break;


	case DP_PROP_DUPLEX_TYPE:
		m_bFullDuplex = (*(DWORD*)pBuf != 0);
		break;


	case PROP_AUDIO_AUTOMIX:
		m_bAutoMix = *(DWORD*)pBuf;
		break;


	case PROP_RECORD_DEVICE:
		m_CaptureDevice = *(DWORD*)pBuf;
		RETAILMSG(("NAC: Setting default record device to %d", m_CaptureDevice));
		break;

	case PROP_RECORD_ON:
	{
		DWORD flag = DPFLAG_ENABLE_SEND ;
		if (*(DWORD *)pBuf)
		{
			m_DPFlags |= flag; // set the flag
			Start();
		}
		else
		{
			m_DPFlags &= ~flag; // clear the flag
			Stop();
		}
		RETAILMSG(("DSCStream: %s", *(DWORD*)pBuf ? "Enabling Stream":"Pausing stream"));
		break;
	}	

	default:
		return DPR_INVALID_PROP_ID;
		break;
	}
	return hr;



}



void SendDSCStream::EndSend()
{
	return;
}



HRESULT SendDSCStream::CreateAudioPackets(MEDIAPACKETINIT *pmpi)
{
	int nIndex;
	HRESULT hr;

	ReleaseAudioPackets();

	for (nIndex = 0; nIndex < NUM_AUDIOPACKETS; nIndex++)
	{
        DBG_SAVE_FILE_LINE
		m_aPackets[nIndex] = new AudioPacket;
		if (m_aPackets[nIndex] == NULL)
		{
			return DPR_OUT_OF_MEMORY;
		}

		pmpi->index = nIndex;
		hr = m_aPackets[nIndex]->Initialize(pmpi);
		if (FAILED(hr))
		{
			ReleaseAudioPackets();
			return hr;
		}

	}

	m_pAudioFilter->PrepareAudioPackets(m_aPackets, NUM_AUDIOPACKETS, AP_ENCODE);


	return S_OK;
}


HRESULT SendDSCStream::ReleaseAudioPackets()
{


	for (int nIndex = 0; nIndex < NUM_AUDIOPACKETS; nIndex++)
	{
		if (m_aPackets[nIndex])
		{
			m_pAudioFilter->UnPrepareAudioPackets(&m_aPackets[nIndex], 1, AP_ENCODE);
			delete m_aPackets[nIndex];
			m_aPackets[nIndex] = NULL;
		}
	}
	return S_OK;
}


HRESULT SendDSCStream::CreateDSCBuffer()
{
	GUID guid = GUID_NULL;
	HRESULT hr;
	DSCBUFFERDESC dsBufDesc;
	DWORD dwIndex;
	DSBPOSITIONNOTIFY *aNotifyPos;
	IDirectSoundNotify *pNotify = NULL;


	if (!(m_DPFlags & DPFLAG_CONFIGURED_SEND))
	{
		return E_FAIL;
	}


	if (!m_pDSC)
	{
		ASSERT(m_pDSCBuffer==NULL);

		DSC_Manager::MapWaveIdToGuid(m_CaptureDevice, &guid);
		hr = DSC_Manager::CreateInstance(&guid, &m_pDSC);
		if (FAILED(hr))
		{
			return hr;
		}
	}

	if (!m_pDSCBuffer)
	{
		ZeroMemory(&dsBufDesc, sizeof(dsBufDesc));

		dsBufDesc.dwBufferBytes = m_dwDSCBufferSize;
		dsBufDesc.lpwfxFormat = &m_wfPCM;
		dsBufDesc.dwSize = sizeof(dsBufDesc);

		hr = m_pDSC->CreateCaptureBuffer(&dsBufDesc, &m_pDSCBuffer, NULL);
		if (FAILED(hr))
		{
			dsBufDesc.dwFlags = DSCBCAPS_WAVEMAPPED;
			hr = m_pDSC->CreateCaptureBuffer(&dsBufDesc, &m_pDSCBuffer, NULL);
		}

		if (FAILED(hr))
		{
			m_pDSC->Release();
			m_pDSC = NULL;
			return hr;
		}
		else
		{
			// do the notification positions
            DBG_SAVE_FILE_LINE
			aNotifyPos = new DSBPOSITIONNOTIFY[m_dwNumFrames];
			for (dwIndex = 0; dwIndex < m_dwNumFrames; dwIndex++)
			{
				aNotifyPos[dwIndex].hEventNotify = m_hEvent;
				aNotifyPos[dwIndex].dwOffset = m_dwFrameSize * dwIndex;
			}

			hr = m_pDSCBuffer->QueryInterface(IID_IDirectSoundNotify, (void**)&pNotify);
			if (SUCCEEDED(hr))
			{
				hr = pNotify->SetNotificationPositions(m_dwNumFrames, aNotifyPos);
			}
			if (FAILED(hr))
			{
				DEBUGMSG (ZONE_DP, ("Failed to set notification positions on DSC Buffer"));
			}
		}
	}

	if (aNotifyPos)
	{
		delete [] aNotifyPos;
	}
	if (pNotify)
	{
		pNotify->Release();
	}

	return S_OK;
}

HRESULT SendDSCStream::ReleaseDSCBuffer()
{
	if (m_pDSCBuffer)
	{
		m_pDSCBuffer->Stop();
		m_pDSCBuffer->Release();
		m_pDSCBuffer = NULL;
	}
	if (m_pDSC)
	{
		m_pDSC->Release();
		m_pDSC = NULL;
	}

	return S_OK;
}





// DTMF functions don't do anything if we aren't streaming
HRESULT __stdcall SendDSCStream::AddDigit(int nDigit)
{
	IMediaChannel *pIMC = NULL;
	RecvMediaStream *pRecv = NULL;
	BOOL bIsStarted;

	if ((!(m_DPFlags & DPFLAG_CONFIGURED_SEND)) || (m_pRTPSend==NULL))
	{
		return DPR_NOT_CONFIGURED;
	}

	bIsStarted = (m_DPFlags & DPFLAG_STARTED_SEND);

	if (bIsStarted)
	{
		Stop();
	}

	m_pDTMF->AddDigitToQueue(nDigit);
	SendDTMF();

	m_pDP->GetMediaChannelInterface(MCF_RECV | MCF_AUDIO, &pIMC);
	if (pIMC)
	{
		pRecv = static_cast<RecvMediaStream *> (pIMC);
		pRecv->DTMFBeep();
		pIMC->Release();
	}

	if (bIsStarted)
	{
		Start();
	}

	return S_OK;
}


// this function is ALMOST identical to SendAudioStream::SendDTMF
HRESULT __stdcall SendDSCStream::SendDTMF()
{
	HRESULT hr=S_OK;
	MediaPacket *pPacket=NULL;
	ULONG uCount;
	UINT uBufferSize, uBytesSent;
	void *pBuffer;
	bool bMark = true;
	MMRESULT mmr;
	HANDLE hEvent = m_pDTMF->GetEvent();
	UINT uTimerID;
	
	// since the stream is stopped, just grab any packet
	// from the packet ring

	pPacket = m_aPackets[0];
	pPacket->GetDevData(&pBuffer, &uBufferSize);

	timeBeginPeriod(5);
	ResetEvent(hEvent);
	uTimerID = timeSetEvent(m_dwFrameTimeMS-1, 5, (LPTIMECALLBACK )hEvent, 0, TIME_CALLBACK_EVENT_SET|TIME_PERIODIC);


	hr = m_pDTMF->ReadFromQueue((BYTE*)pBuffer, uBufferSize);


	while (SUCCEEDED(hr))
	{
		// there should be only 1 tone in the queue (it can handle more)
		// so assume we only need to set the mark bit on the first packet

		pPacket->m_fMark = bMark;
		bMark = false;

		pPacket->SetProp(MP_PROP_TIMESTAMP, m_SendTimestamp);
		m_SendTimestamp += m_dwSamplesPerFrame;

		pPacket->SetState (MP_STATE_RECORDED);

		// SendPacket will also compress
		SendPacket((AudioPacket*)pPacket);

		pPacket->m_fMark=false;
		pPacket->SetState(MP_STATE_RESET);

		hr = m_pDTMF->ReadFromQueue((BYTE*)pBuffer, uBufferSize);


		// so that we don't overload the receive jitter buffer on the remote
		// side, sleep a few milliseconds between sending packets
		if (SUCCEEDED(hr))
		{
			WaitForSingleObject(hEvent, m_dwFrameTimeMS);
			ResetEvent(hEvent);
		}
	}

	timeKillEvent(uTimerID);
	timeEndPeriod(5);
	return S_OK;
}

HRESULT __stdcall SendDSCStream::ResetDTMF()
{
	if(!(m_DPFlags & DPFLAG_STARTED_SEND))
	{
		return S_OK;
	}

	return m_pDTMF->ClearQueue();
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\dscthread.cpp ===
#include "precomp.h"
#include "datapump.h"
#include "DSCStream.h"
#include "agc.h"


static const int DSC_TIMEOUT = 1000;
static const int DSC_MAX_LAG = 500;

static const int DSC_SUCCESS =			0;
static const int DSC_NEED_TO_EXIT =		1;
static const int DSC_FRAME_SENT =		2;
static const int DSC_SILENCE_DETECT	=	3;
static const int DSC_ERROR =			4;

static const int SILENCE_TIMEOUT=	600; // milliseconds

static const int HEADER_SIZE = 	sizeof(RTP_HDR) + IP_HEADER_SIZE + UDP_HEADER_SIZE;


static const UINT DSC_QOS_INITIALIZE = 100;
static const UINT DSC_QOS_PACKET_SENT = 101;

static inline UINT QMOD(const int x, const int mod)
{
	if (x >= mod)
		return (x-mod);
	if (x < 0)
		return (x+mod);
	else
		return x;
}


BOOL SendDSCStream::UpdateQosStats(UINT uStatType, UINT uStatValue1, UINT uStatValue2)
{
	EnterCriticalSection(&m_crsQos);

	switch (uStatType)
	{
		case DSC_QOS_INITIALIZE:
		{
			m_Stats.dwMsCap = m_Stats.dwMsComp = m_Stats.dwBits = m_Stats.dwCount = 0;
			m_Stats.dwNewestTs = m_Stats.dwOldestTs = timeGetTime();
			break;
		}

		case DSC_QOS_PACKET_SENT:
		{
			// uStatvalue1 is the CPU time, uStatvalue2 is the size in bytes
			m_Stats.dwCount++;
			m_Stats.dwMsComp += uStatValue1;
			m_Stats.dwBits += (uStatValue2) * 8;

			// statview really wants bits per second
		   	UPDATE_COUNTER(g_pctrAudioSendBytes, uStatValue2*8);
			break;
		}

	};

	LeaveCriticalSection(&m_crsQos);
	return TRUE;
}

inline BOOL SendDSCStream::ThreadExitCheck()
{
	return (m_ThreadFlags & DPTFLAG_STOP_RECORD);
}


// resyncs the Timestamp with the last known timestamp

inline void SendDSCStream::UpdateTimestamp()
{
	UINT uTime;
	uTime = (timeGetTime() - m_SavedTickCount)*((m_wfPCM.nSamplesPerSec)/1000);
//	if (uTime < 0)
//		uTime = 0;

	m_SendTimestamp += uTime;
}


// WaitForControl - Thread Function
// opens the DirectSound device or waits for it to become available
// returns either DSC_SUCCESS or DSC_NEED_TO_EXIT
DWORD SendDSCStream::WaitForControl()
{
	DWORD dwRet;
	HRESULT hr=E_FAIL;

	while (!(m_ThreadFlags & DPTFLAG_STOP_RECORD))
	{
		if (m_bFullDuplex == FALSE)
		{
			dwRet = WaitForSingleObject(g_hEventHalfDuplex, 1000);
			if (dwRet == WAIT_TIMEOUT)
				continue;
		}

		hr = CreateDSCBuffer();
		if (FAILED(hr))
		{
			m_nFailCount++;
			Sleep(2000); // wait and try again
			hr = CreateDSCBuffer();
		}
		if (SUCCEEDED(hr))
		{
			break;
		}

		m_nFailCount++;
		if ((m_nFailCount >= MAX_FAILCOUNT) && m_bCanSignalFail)
		{
			m_pDP->StreamEvent(MCF_SEND, MCF_AUDIO, STREAM_EVENT_DEVICE_FAILURE, 0);
			m_bCanSignalOpen = TRUE;
			m_bCanSignalFail = FALSE; // don't signal failure more than once
			m_bJammed = TRUE;
		}

		// if we can't open the device, even after being signaled
		// then yield some time to playback in hopes that it becomes available again

		// check the thread flags again such so that we don't
		// hold up the client for too long when he calls Stop()
		if (!(m_ThreadFlags & DPTFLAG_STOP_RECORD))
		{
			SetEvent(g_hEventHalfDuplex);
			Sleep(2000);
		}
	}

	if (m_ThreadFlags & DPTFLAG_STOP_RECORD)
	{
		return DSC_NEED_TO_EXIT;
	}

	m_bJammed = FALSE;
	m_nFailCount = 0;
	m_bCanSignalFail = TRUE;
	if (m_bCanSignalOpen)
	{
		m_pDP->StreamEvent(MCF_SEND, MCF_AUDIO, STREAM_EVENT_DEVICE_OPEN, 0);
		m_bCanSignalOpen = FALSE; // don't signal more than once per session
	}

	return DSC_SUCCESS;
}


// YieldControl is a thread function
// It releases the DirectSound device
// and signals the half duplex event
DWORD SendDSCStream::YieldControl()
{
	ReleaseDSCBuffer();
	SetEvent(g_hEventHalfDuplex);

	if (m_ThreadFlags & DPTFLAG_STOP_RECORD)
	{
		return DSC_NEED_TO_EXIT;
	}

	// half duplex yielding
	// playback has 100ms to grab device otherwise we take it back
	Sleep(100);
	return DSC_SUCCESS;
}



// ProcessFrame is a thread function
// Given a position in the DirectSoundCapture buffer,
// it will apply silence detection to the frame, and send it if
// appropriate
// returns DSC_FRAME_SENT or DSC_SILENCE_DETECT

DWORD SendDSCStream::ProcessFrame(DWORD dwBufferPos, BOOL fMark)
{
	HRESULT hr;
	DWORD dwSize1=0, dwSize2=0, dwMaxStrength;
	WORD wPeakStrength;
	VOID *pBuf1=NULL, *pBuf2=NULL;
	void *pPacketBuffer = NULL;
	UINT uSize, uLength;
	AudioPacket *pAP = m_aPackets[0];
	BOOL fSilent, bRet;


	pAP->GetDevData(&pPacketBuffer, &uSize);
	pAP->SetProp(MP_PROP_TIMESTAMP,m_SendTimestamp);
	pAP->m_fMark = fMark;

	ASSERT(uSize == m_dwFrameSize);

	// copy the frame out of the DSC buffer and into the packet object
	hr = m_pDSCBuffer->Lock(dwBufferPos, m_dwFrameSize, &pBuf1, &dwSize1, &pBuf2, &dwSize2, 0);
	if (SUCCEEDED(hr))
	{
		CopyMemory((BYTE*)pPacketBuffer, pBuf1, dwSize1);
		if (pBuf2 && dwSize2)
		{
			CopyMemory(((BYTE*)pPacketBuffer)+dwSize1, pBuf2, dwSize2);
		}
		m_pDSCBuffer->Unlock(pBuf1, dwSize2, pBuf2, dwSize2);

		pAP->SetState(MP_STATE_RECORDED);
	}
	else
	{
		DEBUGMSG (ZONE_DP, ("SendDSCStream::ProcessFrame - could not lock DSC buffer\r\n"));
		return DSC_ERROR;
	}

	if (m_mmioSrc.fPlayFromFile && m_mmioSrc.hmmioSrc)
	{
		AudioFile::ReadSourceFile(&m_mmioSrc, (BYTE*)pPacketBuffer, uSize);
	}


	// do silence detection
	pAP->ComputePower(&dwMaxStrength, &wPeakStrength);
	fSilent = m_AudioMonitor.SilenceDetect((WORD)dwMaxStrength);

	if (fSilent)
	{
		m_dwSilenceTime += m_dwFrameTimeMS;
		if (m_dwSilenceTime < SILENCE_TIMEOUT)
		{
			fSilent = FALSE;
		}
	}
	else
	{
		m_dwSilenceTime = 0;

		// only do automix on packets above the silence threshold
		if (m_bAutoMix)
		{
			m_agc.Update(wPeakStrength, m_dwFrameTimeMS);
		}
	}



	m_fSending = !(fSilent);  // m_fSending indicates that we are transmitting

	if (fSilent)
	{
		// we don't send this packet, but we do cache it because
		// if the next one get's sent, we send this one too.
		ASSERT(pAP == m_aPackets[0]);

		// swap the audio packets
		// m_aPackets[1] always holds a cached packet
		pAP = m_aPackets[0];
		m_aPackets[0] = m_aPackets[1];
		m_aPackets[1] = pAP;
		pAP = m_aPackets[0];
		return DSC_SILENCE_DETECT;
	}


	// the packet is valid. send it, and maybe the one before it
	Send();

	return DSC_FRAME_SENT;
}


// this function is called by process frame (thread function)
// sends the current packet, and maybe any packet prior to it.
// returns the number of packets sent
DWORD SendDSCStream::Send()
{
	DWORD dwTimestamp0, dwTimestamp1;
	DWORD dwState0, dwState1;
	DWORD dwCount=0;
	MMRESULT mmr;
	HRESULT hr;

	// we know we have to send m_aPackets[0], and maybe m_aPackets[1]
	// we send m_aPackets[1] if it is actually the beginning of this talk spurt

	dwTimestamp0 = m_aPackets[0]->GetTimestamp();
	dwTimestamp1 = m_aPackets[1]->GetTimestamp();
	dwState0 = m_aPackets[0]->GetState();
	dwState1 = m_aPackets[1]->GetState();


	ASSERT(dwState0 == MP_STATE_RECORDED);

	if (dwState0 != MP_STATE_RECORDED)
		return 0;

	// evaluate if we need to send the prior packet
	if (dwState1 == MP_STATE_RECORDED)
	{
		if ((dwTimestamp1 + m_dwFrameTimeMS) == dwTimestamp0)
		{
			m_aPackets[1]->m_fMark = TRUE;   // set the mark bit on the first packet
			m_aPackets[0]->m_fMark = FALSE;  // reset the mark bit on the next packet
			hr = SendPacket(m_aPackets[1]);
			if (SUCCEEDED(hr))
			{
				dwCount++;
			}
		}
		else
		{
			m_aPackets[1]->SetState(MP_STATE_RESET);
		}
	}

	hr = SendPacket(m_aPackets[0]);
	if (SUCCEEDED(hr))
		dwCount++;

	return dwCount;

}

// thread function called by Send.  Sends a packet to RTP.
HRESULT SendDSCStream::SendPacket(AudioPacket *pAP)
{
	MMRESULT mmr;
	PS_QUEUE_ELEMENT psq;
	UINT uLength;
	UINT uEncodeTime;

	uEncodeTime = timeGetTime();
	mmr = m_pAudioFilter->Convert(pAP, AP_ENCODE);
	uEncodeTime = timeGetTime() - uEncodeTime;

	if (mmr == MMSYSERR_NOERROR)
	{
		pAP->SetState(MP_STATE_ENCODED);  // do we need to do this ?

		psq.pMP = pAP;
		psq.dwPacketType = PS_AUDIO;
		psq.pRTPSend = m_pRTPSend;
		pAP->GetNetData((void**)(&(psq.data)), &uLength);
		ASSERT(psq.data);
		psq.dwSize = uLength;
		psq.fMark = pAP->m_fMark;
		psq.pHeaderInfo = NULL;
		psq.dwHdrSize = 0;
		m_pDP->m_PacketSender.m_SendQueue.PushFront(psq);
		while (m_pDP->m_PacketSender.SendPacket())
		{
			;
		}


		UpdateQosStats(DSC_QOS_PACKET_SENT, uEncodeTime, uLength+HEADER_SIZE);
	}

	pAP->SetState(MP_STATE_RESET);

	return S_OK;
}


DWORD SendDSCStream::RecordingThread()
{
	HRESULT hr;
	DWORD dwWaitTime = DSC_TIMEOUT; // one sec
	DWORD dwRet, dwReadPos, dwCapPos;
	DWORD dwFirstValidFramePos, dwLastValidFramePos, dwNumFrames;
	DWORD dwLag, dwMaxLag, dwLagDiff;
	DWORD dwNextExpected, dwCurrentFramePos, dwIndex;
	BOOL bNeedToYield;
	BOOL fMark;
	IMediaChannel *pIMC = NULL;
	RecvMediaStream *pRecv = NULL;
	CMixerDevice *pMixer = NULL;


	// initialize recording thread
	m_SendTimestamp = timeGetTime();
	m_SavedTickCount = 0;

	m_fSending = TRUE;
	m_bJammed = FALSE;
	m_nFailCount = 0;
	m_bCanSignalOpen = TRUE;
	m_bCanSignalFail = TRUE;

	UpdateQosStats(DSC_QOS_INITIALIZE, 0, 0);
	SetThreadPriority(m_hCapturingThread, THREAD_PRIORITY_HIGHEST);

	// automix object
	pMixer = CMixerDevice::GetMixerForWaveDevice(NULL, m_CaptureDevice, MIXER_OBJECTF_WAVEIN);
	m_agc.SetMixer(pMixer);  // if pMixer is NULL, then it's still ok
	m_agc.Reset();

	LOG((LOGMSG_DSC_STATS, m_dwDSCBufferSize, m_dwFrameSize));

	while (!(ThreadExitCheck()))
	{
		dwRet = WaitForControl();
		if (dwRet == DSC_NEED_TO_EXIT)
		{
			break;
		}

		hr = m_pDSCBuffer->Start(DSCBSTART_LOOPING);
		if (FAILED(hr))
		{
			// ERROR!  We expected this call to succeed
			YieldControl();
			Sleep(1000);
			continue;
		}

		ResetEvent(m_hEvent);
		m_pDSCBuffer->GetCurrentPosition(&dwCapPos, &dwReadPos);


		// set the next expected position to be on the next logical
		// frame boundary up from where it is now

		dwNextExpected = QMOD(m_dwFrameSize + (dwReadPos / m_dwFrameSize) * m_dwFrameSize, m_dwDSCBufferSize);

		dwMaxLag = (m_dwNumFrames/2) * m_dwFrameSize;

		m_dwSilenceTime = 0;
		bNeedToYield = FALSE;
		fMark = TRUE;

		UpdateTimestamp();


		while( (bNeedToYield == FALSE) && (!(ThreadExitCheck())) )
		{
			dwRet = WaitForSingleObject(m_hEvent, dwWaitTime);

			LOG((LOGMSG_DSC_TIMESTAMP, timeGetTime()));

			m_pDSCBuffer->GetCurrentPosition(&dwCapPos, &dwReadPos);

			LOG((LOGMSG_DSC_GETCURRENTPOS, dwCapPos, dwReadPos));

			if (dwRet == WAIT_TIMEOUT)
			{
				DEBUGMSG(ZONE_DP, ("DSCThread.cpp: Timeout on the DSC Buffer has occurred.\r\n"));
				LOG((LOGMSG_DSC_LOG_TIMEOUT));
				dwNextExpected = QMOD(m_dwFrameSize + (dwReadPos / m_dwFrameSize) * m_dwFrameSize, m_dwDSCBufferSize);
				continue;
			}

			dwLag = QMOD(dwReadPos - dwNextExpected, m_dwDSCBufferSize);

			if (dwLag > dwMaxLag)
			{

				// we got here because of one of two conditions

				// 1. WaitFSO above returned earlier than expected.
				// This can happen when the previous interation of
				// the loop has sent multiple packets.  The read cursor
				// is most likely only within one frame behind the expected
				// cursor.

				// In this cases, just keep Waiting for the current
				// read position to (dwReadPos) "catch up" to dwNextExpected


				// 2. A huge delay or something really bad. ("burp")
				// we could simply continue waiting for the read position
				// to catch up to dwNextExpected, but it's probably better
				// to reposition dwNextExpected so that we don't wait
				// too long before sending a frame again
			
				dwLagDiff = QMOD((dwLag + m_dwFrameSize), m_dwDSCBufferSize);
				if (dwLagDiff < m_dwFrameSize)
				{
					LOG((LOGMSG_DSC_EARLY));
					// only lagging behind by one frame
					// WaitFSO probably returned early
					;
				}
				else
				{
					LOG((LOGMSG_DSC_LAGGING, dwLag, dwNextExpected));

					// consider repositioning dwNextExpected, advancing
					// m_SendTimeStamp, and setting fMark if this condition
					// happens a lot
				}

				continue;
			}

	
			dwFirstValidFramePos = QMOD(dwNextExpected - m_dwFrameSize, m_dwDSCBufferSize);
			dwLastValidFramePos = (dwReadPos / m_dwFrameSize) * m_dwFrameSize;
			dwNumFrames = QMOD(dwLastValidFramePos - dwFirstValidFramePos, m_dwDSCBufferSize) / m_dwFrameSize;
			dwCurrentFramePos = dwFirstValidFramePos;

			LOG((LOGMSG_DSC_SENDING, dwNumFrames, dwFirstValidFramePos, dwLastValidFramePos));

			for (dwIndex = 0; dwIndex < dwNumFrames; dwIndex++)
			{
				m_SendTimestamp += m_dwSamplesPerFrame; // increment in terms of samples

				// Send The data
				dwRet = ProcessFrame(dwCurrentFramePos, fMark);

				dwCurrentFramePos = QMOD(dwCurrentFramePos + m_dwFrameSize, m_dwDSCBufferSize);

				if (dwRet == DSC_FRAME_SENT)
				{
					fMark = FALSE;
				}

				else if ((dwRet == DSC_SILENCE_DETECT) && (m_bFullDuplex == FALSE))
				{
					m_pDP->GetMediaChannelInterface(MCF_RECV | MCF_AUDIO, &pIMC);
					fMark = TRUE;

					if (pIMC)
					{
						pRecv = static_cast<RecvMediaStream *> (pIMC);
						if (pRecv->IsEmpty() == FALSE)
						{
							bNeedToYield = TRUE;
						}
						pIMC->Release();
						pIMC = NULL;
						if (bNeedToYield)
						{
							break;
						}
					}
				}

				else
				{
					fMark = TRUE;
				}
			}

			dwNextExpected = QMOD(dwLastValidFramePos + m_dwFrameSize, m_dwDSCBufferSize);

			if (bNeedToYield)
			{
				YieldControl();
				m_SavedTickCount = timeGetTime();
			}
		} // while (!bNeedToYield)
	} // while (!ThreadExitCheck())

	// time to exit
	YieldControl();



	delete pMixer;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\dtmf.cpp ===
#include "precomp.h"
#include "dtmf.h"
#include <math.h>


// has to be #defines, not const int's because our build environment
// doesn't like the embedded structure stuff.
#define DTMF_ROW1_FREQ 697
#define DTMF_ROW2_FREQ 770
#define DTMF_ROW3_FREQ 852
#define DTMF_ROW4_FREQ 941

#define DTMF_COL1_FREQ 1209
#define DTMF_COL2_FREQ 1336
#define DTMF_COL3_FREQ 1477
#define DTMF_COL4_FREQ 1633
// For "A", "B", "C", "D"


// the length of all the tones are the same except for "zero"
// Zero needs longer because it just barely survives G.723 compression

const int DTMF_TONE_RAMP_MS = 60;  // ramp up/down time
const int DTMF_TONE_LENGTH_MS = 240; // includes ramp time!
const int DTMF_SILENCE_LENGTH_MS = 240; // silence gap between tones

const double DTMF_AMP_FREQ1 = 17000;
const double DTMF_AMP_FREQ2 = 14000;

struct DTMF_TONE
{
	int freq1;
	int freq2;
	int nLengthMS; // length in milliseconds
};


const int DTMF_NUM_TONES = 16;
const int DTMF_SILENCE	= -1;

DTMF_TONE DTMF_TONE_DEF_LIST[] =
{
	{DTMF_ROW4_FREQ, DTMF_COL2_FREQ, DTMF_TONE_LENGTH_MS}, //0

	{DTMF_ROW1_FREQ, DTMF_COL1_FREQ, DTMF_TONE_LENGTH_MS}, //1
	{DTMF_ROW1_FREQ, DTMF_COL2_FREQ, DTMF_TONE_LENGTH_MS}, //2
	{DTMF_ROW1_FREQ, DTMF_COL3_FREQ, DTMF_TONE_LENGTH_MS}, //3

	{DTMF_ROW2_FREQ, DTMF_COL1_FREQ, DTMF_TONE_LENGTH_MS}, //4
	{DTMF_ROW2_FREQ, DTMF_COL2_FREQ, DTMF_TONE_LENGTH_MS}, //5
	{DTMF_ROW2_FREQ, DTMF_COL3_FREQ, DTMF_TONE_LENGTH_MS}, //6

	{DTMF_ROW3_FREQ, DTMF_COL1_FREQ, DTMF_TONE_LENGTH_MS}, //7
	{DTMF_ROW3_FREQ, DTMF_COL2_FREQ, DTMF_TONE_LENGTH_MS}, //8
	{DTMF_ROW3_FREQ, DTMF_COL3_FREQ, DTMF_TONE_LENGTH_MS}, //9

	{DTMF_ROW4_FREQ, DTMF_COL1_FREQ, DTMF_TONE_LENGTH_MS}, //STAR
	{DTMF_ROW4_FREQ, DTMF_COL3_FREQ, DTMF_TONE_LENGTH_MS}, //POUND

	{DTMF_ROW1_FREQ, DTMF_COL4_FREQ, DTMF_TONE_LENGTH_MS}, //A
	{DTMF_ROW2_FREQ, DTMF_COL4_FREQ, DTMF_TONE_LENGTH_MS}, //B
	{DTMF_ROW3_FREQ, DTMF_COL4_FREQ, DTMF_TONE_LENGTH_MS}, //C
	{DTMF_ROW4_FREQ, DTMF_COL4_FREQ, DTMF_TONE_LENGTH_MS}, //D
};





DTMFQueue::DTMFQueue() : 
m_aTones(NULL),
m_bInitialized(false),
m_nQueueHead(0),
m_nQueueLength(0),
m_hEvent(NULL)
{
	InitializeCriticalSection(&m_cs);
	m_hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
}

DTMFQueue::~DTMFQueue()
{
	DeleteCriticalSection(&m_cs);
	ReleaseToneBank();
	CloseHandle(m_hEvent);
}


HRESULT DTMFQueue::Initialize(WAVEFORMATEX *pWaveFormat)
{
	if (m_bInitialized)
	{
		ReleaseToneBank();
	}
	m_nQueueLength = 0;
	m_nQueueHead = 0;

	return GenerateTones(pWaveFormat);
};


HRESULT DTMFQueue::GenerateTones(WAVEFORMATEX *pWaveFormat)
{
	int nIndex;
	int nToneLength;  // tone length in bytes
	int nToneLengthMS; // tone length in millisecs

	ReleaseToneBank();

	m_WaveFormat = *pWaveFormat;

    DBG_SAVE_FILE_LINE
	m_aTones = new PBYTE[DTMF_NUM_TONES];  // array of 16 tones

	if (m_aTones == NULL)
	{
		return E_OUTOFMEMORY;
	}

	// allocate memory for each tone
	for (nIndex = 0; nIndex < DTMF_NUM_TONES; nIndex++)
	{
		nToneLengthMS = DTMF_TONE_DEF_LIST[nIndex].nLengthMS;

		nToneLength = (pWaveFormat->nSamplesPerSec) * (pWaveFormat->wBitsPerSample) / 8;
		nToneLength = (nToneLength * nToneLengthMS) / 1000;

        DBG_SAVE_FILE_LINE
		m_aTones[nIndex] = new BYTE[nToneLength];

		if (m_aTones[nIndex] == NULL)
		{
			return E_OUTOFMEMORY;
		}

		CreateDTMFTone(m_aTones[nIndex], nToneLength, nIndex);
	}

	m_bInitialized = true;
	return S_OK;
}



void DTMFQueue::CreateDTMFTone(BYTE *pTone, int nToneLength, int toneID)
{
	ZeroMemory(pTone, nToneLength);

	AddSignal(pTone, DTMF_TONE_DEF_LIST[toneID].freq1, DTMF_AMP_FREQ1, nToneLength);
	AddSignal(pTone, DTMF_TONE_DEF_LIST[toneID].freq2, DTMF_AMP_FREQ2, nToneLength);
}


void DTMFQueue::AddSignal(BYTE *pTone, int nFrequency, double dAmp, int nLength)
{
	double d;
	int nIndex;
	SHORT *aSamples = (SHORT*)pTone;
	SHORT shSample;
	BYTE nSample8;
	double dRampAmpInc, dRampAmp;
	int nRampSamples;
	const double PI = 3.1415926535897932384626433832795;


	nRampSamples = (m_WaveFormat.nSamplesPerSec * DTMF_TONE_RAMP_MS) / 1000;
	dRampAmpInc = 1.0 / nRampSamples;
	dRampAmp = 0.0;


	if (m_WaveFormat.wBitsPerSample == 16)
	{
		nLength = nLength / 2;
		for (nIndex = 0; nIndex < nLength; nIndex++)
		{
			// y = sin((x * 2 * PI * f)/SRATE)

			// d is a value between -1 and +1;
			d = sin((PI * (2.0 * (nIndex * nFrequency))) / m_WaveFormat.nSamplesPerSec);

			if (nIndex < nRampSamples)
			{
				dRampAmp = dRampAmpInc * nIndex;
			}
			else if ((nIndex+nRampSamples) >= nLength)
			{
				dRampAmp = dRampAmpInc * (nLength - nIndex - 1);
			}
			else
			{
				dRampAmp = 1.0;
			}

			shSample =  (SHORT)(dAmp * d * dRampAmp);

			aSamples[nIndex] += shSample;
		}

		return;
	}

	// 8-bit samples have a center point of 128
	// must invert high order bit to compensate
	for (nIndex = 0; nIndex < nLength; nIndex++)
	{
		d = sin((PI * (2.0 * (nIndex * nFrequency))) / m_WaveFormat.nSamplesPerSec);

		if (nIndex < nRampSamples)
		{
			dRampAmp = dRampAmpInc * nIndex;
		}
		else if ((nIndex+nRampSamples) >= nLength)
		{
			dRampAmp = dRampAmpInc * (nLength - nIndex - 1);
		}
		else
		{
			dRampAmp = 1.0;
		}


		shSample =  (SHORT)(dAmp * d * dRampAmp);
		shSample = (shSample >> 8) & 0x00ff;
		nSample8 = (BYTE)shSample;
		nSample8 = nSample8 ^ 0x80;
		pTone[nIndex] = nSample8;
	}
	return;
};




void DTMFQueue::ReleaseToneBank()
{
	int nIndex;
	if (m_aTones)
	{
		for (nIndex = 0; nIndex < DTMF_NUM_TONES; nIndex++)
		{
			delete [] m_aTones[nIndex];
		}
		delete [] m_aTones;
		m_aTones = NULL;
	}
	
	m_bInitialized = false;
}


HRESULT DTMFQueue::AddDigitToQueue(int nDigit)
{
	int nQueueIndex;
	int nToneLength, nToneLengthMS;
	int nSilenceLength;

	if (m_bInitialized == false)
		return E_FAIL;

	if ((nDigit < 0) || (nDigit >= DTMF_NUM_TONES))
	{
		return E_FAIL;
	}

	EnterCriticalSection(&m_cs);
	
	if (m_nQueueLength >= (DTMF_QUEUE_SIZE-1))
	{
		LeaveCriticalSection(&m_cs);
		return E_FAIL;
	}

	nToneLengthMS = DTMF_TONE_DEF_LIST[nDigit].nLengthMS;
	nToneLength = (m_WaveFormat.nSamplesPerSec) * (m_WaveFormat.wBitsPerSample) / 8;

	nSilenceLength = (nToneLength * DTMF_SILENCE_LENGTH_MS) / 1000;
	nToneLength = (nToneLength * nToneLengthMS) / 1000;


	// add silence to pad between tones.  Also helps to "reset" the codec
	// to a good state
	nQueueIndex = (m_nQueueHead + m_nQueueLength) % DTMF_QUEUE_SIZE;
	m_aTxQueue[nQueueIndex].nBytesToCopy = nSilenceLength;
	m_aTxQueue[nQueueIndex].nToneID = DTMF_SILENCE;
	m_aTxQueue[nQueueIndex].nOffsetStart = 0;
	m_nQueueLength++;

	// add the tone to the read queue
	nQueueIndex = (m_nQueueHead + m_nQueueLength) % DTMF_QUEUE_SIZE;
	m_aTxQueue[nQueueIndex].nBytesToCopy = nToneLength;
	m_aTxQueue[nQueueIndex].nToneID = nDigit;
	m_aTxQueue[nQueueIndex].nOffsetStart = 0;
	m_nQueueLength++;


	LeaveCriticalSection(&m_cs);
	return S_OK;
	
}


HRESULT DTMFQueue::ReadFromQueue(BYTE *pBuffer, UINT uSize)
{
	DTMF_TX_ELEMENT *pQueueElement;
	int nSilenceOffset;
	BYTE fillByte;

	if (m_bInitialized == false)
		return E_FAIL;

	if (m_WaveFormat.wBitsPerSample == 8)
	{
		fillByte = 0x80;
	}
	else
	{
		ASSERT((uSize % 2) == 0); // uSize must be even for 16-bit fills
		fillByte = 0;
	}

	EnterCriticalSection(&m_cs);

	if (m_nQueueLength <= 0)
	{
		LeaveCriticalSection(&m_cs);
		return E_FAIL;
	}

	pQueueElement = &m_aTxQueue[m_nQueueHead];

	if (pQueueElement->nBytesToCopy <= (int)uSize)
	{
		if (pQueueElement->nToneID == DTMF_SILENCE)
		{
			FillMemory(pBuffer, uSize, fillByte);
		}
		else
		{
			CopyMemory(pBuffer, pQueueElement->nOffsetStart + m_aTones[pQueueElement->nToneID], pQueueElement->nBytesToCopy);
			FillMemory(pBuffer+(pQueueElement->nBytesToCopy), uSize-(pQueueElement->nBytesToCopy), fillByte);
		}
		m_nQueueHead = (m_nQueueHead + 1) % DTMF_QUEUE_SIZE;
		m_nQueueLength--;
	}


	else
	{
		if (pQueueElement->nToneID == DTMF_SILENCE)
		{
			FillMemory(pBuffer, uSize, fillByte);
		}
		else
		{
			CopyMemory(pBuffer, pQueueElement->nOffsetStart + m_aTones[pQueueElement->nToneID], uSize);
		}
		pQueueElement->nBytesToCopy -= uSize;
		pQueueElement->nOffsetStart += uSize;
	}

	LeaveCriticalSection(&m_cs);

	return S_OK;
}

HRESULT DTMFQueue::ClearQueue()
{
	if (m_bInitialized == false)
		return E_FAIL;


	EnterCriticalSection(&m_cs);
	m_nQueueHead = 0;
	m_nQueueLength = 0;
	LeaveCriticalSection(&m_cs);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\dsstream.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    medistrm.h

Abstract:
	Contains constants and class declarations for the abstract MediaStream object. A MediaStream
	represents a single unidirectional stream, such as a received Video channel.
	
--*/
#ifndef _DSSTREAM_H_
#define _DSSTREAM_H_

class DataPump;

#include <pshpack8.h> /* Assume 8 byte packing throughout */

struct DSINFO;
extern GUID myNullGuid;	// a zero guid

typedef HRESULT (WINAPI *LPFNDSCREATE)(const GUID * , LPDIRECTSOUND * , IUnknown FAR * );
typedef HRESULT (WINAPI *LPFNDSENUM)(LPDSENUMCALLBACK , LPVOID  );

class DirectSoundMgr {
	public:
	static HRESULT Initialize();
	static HRESULT MapWaveIdToGuid(UINT waveId, GUID *pGuid);	// kludge!!
	static HRESULT Instance(LPGUID pDeviceGuid,LPDIRECTSOUND *ppDS, HWND hwnd, WAVEFORMATEX *pwf);
	static HRESULT ReleaseInstance(LPDIRECTSOUND pDS);
	static HRESULT UnInitialize();
	
	private:
	static HINSTANCE m_hDS;						// handle to DSOUND.DLL
	static LPFNDSCREATE m_pDirectSoundCreate;	// used for dynamic linking to DSOUND.DLL
	static LPFNDSENUM m_pDirectSoundEnumerate;	// used for dynamic linking
	static BOOL __stdcall DSEnumCallback(LPGUID, LPCSTR, LPCSTR, LPVOID);
	static DSINFO *m_pDSInfoList;
	static BOOL m_fInitialized ;
};

class DSTimeout : public TTimeout {
public:
	void SetDSStream(class RecvDSAudioStream *pDSS) {m_pRDSStream = pDSS;}
protected:
	class RecvDSAudioStream *m_pRDSStream;
	
	virtual void TimeoutIndication();
};

class RecvDSAudioStream : public RecvMediaStream, public IAudioChannel {
	friend class DataPump;
	friend BOOL RTPRecvDSCallback(DWORD ,WSABUF * );
private:
	WAVEFORMATEX m_fDevRecv;
	CRITICAL_SECTION m_crsAudQoS; // Allows QoS thread to read the audio statistics while recording and compression are running

	BOOL m_fEmpty;
	DWORD m_NextTimeT;
	DWORD m_BufSizeT;
	DWORD m_NextPosT;
	DWORD m_PlayPosT;
	DWORD m_SilenceDurationT;	// tracks "silence" periods in the received stream
	// used for adaptive delay calculations
	DWORD m_DelayT;
	DWORD m_MinDelayT;			// constant lower limit on playback delay
	DWORD m_MaxDelayT;			// constant upper limit on playback delay
	DWORD m_ArrT;				// local (pseudo)timestamp
	DWORD m_SendT0;             // m_SendT0 is the send timestamp of the packet with the shortest trip delay. We could have just stored (m_ArrivalT0 - m_SendT0) but since the local and remote clocks are completely unsynchronized, there would be signed/unsigned complications.
	DWORD m_ArrivalT0;          // m_ArrivalT0 is the arrival timestamp of the packet with the shortest trip delay. We could have just stored (m_ArrivalT0 - m_SendT0) but since the local and remote clocks are completely unsynchronized, there would be signed/unsigned complications.
	LONG m_ScaledAvgVarDelay;   // Average Variable Delay according to m_ScaledAvgVarDelay = m_ScaledAvgVarDelay + (delay - m_ScaledAvgVarDelay/16). This is the m_DelayPos jitter.
	int m_nFailCount;           // number of consecutive times the device failed to open


	GUID m_DSguid;
	LPDIRECTSOUND m_pDS;
	LPDIRECTSOUNDBUFFER m_pDSBuf;
	DSBUFFERDESC m_DSBufDesc;
	DWORD m_DSFlags;			// from DSCAPS.dwFlags

	AcmFilter *m_pAudioFilter;
	ACMSTREAMHEADER m_StrmConvHdr;
	HANDLE m_hStrmConv;
	DSTimeout m_TimeoutObj;
	AudioSilenceDetector m_AudioMonitor;

	BOOL m_bJammed;
	BOOL m_bCanSignalOpen;
	
	// Non virtual methods
	void UpdateVariableDelay(DWORD timestamp, DWORD curPlayT);
	DWORD GetSignalStrength();
	HRESULT CreateDSBuffer();
	HRESULT ReleaseDSBuffer();
	HRESULT Decode(UCHAR *pData, UINT cbData);
	HRESULT PlayBuf(DWORD timestamp, UINT seq, BOOL fMark);

	LONG m_lRefCount;
	
public:	
	RecvDSAudioStream() :RecvMediaStream() {m_Net=NULL; m_lRefCount=0; m_TimeoutObj.SetDSStream(this);};
	~RecvDSAudioStream();

	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
	virtual ULONG STDMETHODCALLTYPE AddRef(void);
	virtual ULONG STDMETHODCALLTYPE Release(void);


	// IMediaChannel APIs
	HRESULT STDMETHODCALLTYPE Configure(
		BYTE *pFormat,
		UINT cbFormat,
		BYTE *pChannelParams,
		UINT cbParams,
		IUnknown *pUnknown);

	STDMETHODIMP Start(void);
	STDMETHODIMP Stop(void);
	STDMETHODIMP_(void) UnConfigure(void);

	HRESULT STDMETHODCALLTYPE SetNetworkInterface(IUnknown *pUnknown)
	{
		return RecvMediaStream::SetNetworkInterface(pUnknown);
	}

	STDMETHODIMP_(DWORD) GetState() 
	{
		return RecvMediaStream::GetState();
	}

	HRESULT STDMETHODCALLTYPE SetMaxBitrate(UINT uMaxBitrate)
	{
		return E_NOTIMPL;
	}

	// IAudioChannel
	STDMETHODIMP GetSignalLevel(UINT *pSignalStrength);


    // IProperty methods
	STDMETHODIMP GetProperty(DWORD dwProp, PVOID pBuf, LPUINT pcbBuf);
	STDMETHODIMP SetProperty(DWORD dwProp, PVOID pBuf, UINT cbBuf);

	// Other virtual inherited methods
	virtual HRESULT Initialize(DataPump *);
	virtual BOOL IsEmpty();
	HRESULT GetCurrentPlayNTPTime(NTP_TS *);
    virtual HRESULT StartRecv(HWND);
    virtual HRESULT StopRecv();

	HRESULT DTMFBeep();
	HRESULT OnDTMFBeep();


	void 	RecvTimeout();

	virtual HRESULT RTPCallback(WSABUF *pWsaBuf, DWORD timestamp, UINT seq, UINT fMark);
};


#include <poppack.h> /* End byte packing */


#endif // _MEDISTRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\intif.h ===
/*
 *  	File: intif.h
 *
 *      
 *
 *		Revision History:
 *
 *		05/06/96	mikev	created
 */
 

#ifndef _INTIF_H
#define _INTIF_H

//
//	Internal interface classes
//
class IConfAdvise;
class IControlChannel;
class IH323PubCap;

typedef IControlChannel *LPIControlChannel;
typedef IConfAdvise* LPIConfAdvise;
typedef IH323PubCap *LPIH323PubCap;

#endif //_INTIF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\dtmf.h ===
#ifndef NAC_DTMF_H
#define NAC_DTMF_H


class DTMFQueue
{
private:
	BYTE **m_aTones; // array of tone signals
	bool m_bInitialized;
	WAVEFORMATEX m_WaveFormat;
	CRITICAL_SECTION m_cs;
	HANDLE m_hEvent;


	void ReleaseToneBank();

	void AddSignal(BYTE *pTone, int nFrequency, double dAmp, int nLength);
	void CreateDTMFTone(BYTE *pTone, int nToneLength, int toneID);
	HRESULT GenerateTones(WAVEFORMATEX *pWaveFormat);


	struct DTMF_TX_ELEMENT
	{
		int nToneID;
		int nBytesToCopy;
		int nOffsetStart;
	};

#define DTMF_QUEUE_SIZE	100
	DTMF_TX_ELEMENT m_aTxQueue[DTMF_QUEUE_SIZE];
	int m_nQueueHead;
	int m_nQueueLength;

public:
	DTMFQueue();
	~DTMFQueue();

	HRESULT Initialize(WAVEFORMATEX *pWaveFormat);
	HRESULT ReadFromQueue(BYTE *pBuffer, UINT uSize);
	HRESULT ClearQueue();
	HRESULT AddDigitToQueue(int nDigit);
	HANDLE GetEvent() {return m_hEvent;}
};



// default length of the DTMF feedback beep (in ms)
#define DTMF_FEEDBACK_BEEP_MS	64


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\iacapapi.cpp ===
/*
 *  	File: connobj.cpp
 *
 *		implementation of Internet Audio capability API interface.
 *
 *		
 *
 *		Revision History:
 *
 *		06/18/96	mikev	created
 */

#include "precomp.h"
	
ULONG CImpAppAudioCap ::AddRef()
{
	 return (m_pCapObject->AddRef());
}
ULONG CImpAppAudioCap ::Release()
{
	 return (m_pCapObject->Release());
}
HRESULT CImpAppAudioCap::GetNumFormats(UINT *puNumFmtOut)
{
	return (m_pCapObject->GetNumFormats(puNumFmtOut));
}
HRESULT CImpAppAudioCap ::GetBasicAudcapInfo (AUDIO_FORMAT_ID Id,
		PBASIC_AUDCAP_INFO pFormatPrefsBuf)
{
 	return (m_pCapObject->GetBasicAudcapInfo (Id, pFormatPrefsBuf));
}		
HRESULT CImpAppAudioCap ::EnumFormats(PBASIC_AUDCAP_INFO pFmtBuf, UINT uBufsize,
	UINT *uNumFmtOut)
{
	 return (m_pCapObject->EnumFormats(pFmtBuf, uBufsize, uNumFmtOut));
}

HRESULT CImpAppAudioCap ::EnumCommonFormats(PBASIC_AUDCAP_INFO pFmtBuf, UINT uBufsize,
	UINT *uNumFmtOut, BOOL bTXCaps)
{
	 return (m_pCapObject->EnumCommonFormats(pFmtBuf, uBufsize, uNumFmtOut, bTXCaps));
}

HRESULT CImpAppAudioCap ::ApplyAppFormatPrefs (PBASIC_AUDCAP_INFO pFormatPrefsBuf,
	UINT uNumFormatPrefs)
{
	 return (m_pCapObject->ApplyAppFormatPrefs (pFormatPrefsBuf, uNumFormatPrefs));
}

HRESULT CImpAppAudioCap ::AddACMFormat (LPWAVEFORMATEX lpwfx, PAUDCAP_INFO pAudCapInfo)
{
	 return (m_pCapObject->AddACMFormat(lpwfx, pAudCapInfo));
}
HRESULT CImpAppAudioCap ::RemoveACMFormat (LPWAVEFORMATEX lpwfx)
{
	 return (m_pCapObject->RemoveACMFormat(lpwfx));
}

LPVOID CImpAppAudioCap::GetFormatDetails (AUDIO_FORMAT_ID Id)
{
	VOID *pFormat;
	UINT uSize;

	m_pCapObject->GetEncodeFormatDetails(Id, &pFormat, &uSize);
	return pFormat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\imp.h ===
#define APP_PORT H323_PORT

#ifdef __cplusplus
	LPIControlChannel CreateControlChannel(GUID PIDofProtocolType);
#endif	// __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\h323caps.cpp ===
/*
 *    File: h323caps.cpp
 *
 *    H.323/H.245 specific implementation of Microsoft A/V capability
 *       interface methods.  (Contained in CMsiaCapability class)
 *
 *    Revision History:
 *
 *    09/10/96 mikev created
 * 	  10/08/96 mikeg - created h323vidc.cpp
 *    11/04/96 mikev - cleanup and merge audio and video capability classes (remove
 * 				common inheritance of IH323PubCap, both audio and video implementation
 *				classes inherit from IH323MediaCap. )
 */


#include "precomp.h"

#define SAMPLE_BASED_SAMPLES_PER_FRAME 8
#define MAX_FRAME_LEN   480      //bytes  -  where did this value come from?
#define MAX_FRAME_LEN_RECV	1440  // 180 ms at 8000hz G.711

//	some utility functions for calculating frame sizes and frames per packet

HRESULT WINAPI CreateMediaCapability(REFGUID mediaId, LPIH323MediaCap * ppMediaCapability)
{
	HRESULT hrLast = E_OUTOFMEMORY;
	
	if (!ppMediaCapability)
		return E_POINTER;
	if (mediaId == MEDIA_TYPE_H323AUDIO)
	{
   		CMsiaCapability * pAudObj = NULL;
   		UINT uAud;

        DBG_SAVE_FILE_LINE
   		pAudObj = new CMsiaCapability;

   		if(pAudObj)
   		{

			hrLast = pAudObj->QueryInterface(IID_IH323MediaCap, (void **)ppMediaCapability);
			pAudObj->Release(); // this balances the refcount of "new CMsiaCapability"
			pAudObj = NULL;
		}


    }
	else if (mediaId == MEDIA_TYPE_H323VIDEO)
	{
		CMsivCapability * pVidObj = NULL;

        DBG_SAVE_FILE_LINE
		pVidObj = new CMsivCapability;
	   	if(pVidObj)
		{
		
			hrLast = pVidObj->QueryInterface(IID_IH323MediaCap, (void **)ppMediaCapability);
			pVidObj->Release(); // this balances the refcount of "new CMsivCapability"
			pVidObj = NULL;
		}
		
	}
	else
		hrLast = E_NOINTERFACE;
	if(HR_SUCCEEDED(hrLast))
	{
		if (!(*ppMediaCapability)->Init())
		{
			(*ppMediaCapability)->Release();
			hrLast = E_FAIL;
			*ppMediaCapability = NULL;
		}
	}
	return hrLast;	
}

//
//	CMsiaCapability
//
UINT CMsiaCapability::GetLocalSendParamSize(MEDIA_FORMAT_ID dwID)
{
	return (sizeof(AUDIO_CHANNEL_PARAMETERS));
}
UINT CMsiaCapability::GetLocalRecvParamSize(PCC_TERMCAP pCapability)
{
	return (sizeof(AUDIO_CHANNEL_PARAMETERS));
}


HRESULT CMsiaCapability::CreateCapList(LPVOID *ppCapBuf)
{
	UINT u;
	AUDCAP_DETAILS *pDecodeDetails = pLocalFormats;
	PCC_TERMCAPLIST   pTermCapList = NULL;
	PPCC_TERMCAP  ppCCThisTermCap = NULL;
		
	PCC_TERMCAP  pCCThisCap = NULL;
	PNSC_AUDIO_CAPABILITY pNSCapNext;
	LPWAVEFORMATEX lpwfx;
	HRESULT hr = hrSuccess;
	FX_ENTRY ("CreateCapList");
	// validate input
	if(!ppCapBuf)
	{
		hr = CAPS_E_INVALID_PARAM;
		goto ERROR_OUT;
	}
	*ppCapBuf = NULL;
	if(!uNumLocalFormats || !pDecodeDetails)
	{
		hr = CAPS_E_NOCAPS;
		goto ERROR_OUT;
	}

	pTermCapList = (PCC_TERMCAPLIST)MemAlloc(sizeof(CC_TERMCAPLIST));
	if(!pTermCapList)
	{
		hr = CAPS_E_NOMEM;
		goto ERROR_OUT;		
	}
	ppCCThisTermCap = (PPCC_TERMCAP)MemAlloc(uNumLocalFormats * sizeof(PCC_TERMCAP));
	if(!ppCCThisTermCap)
	{
		hr = CAPS_E_NOMEM;
		goto ERROR_OUT;		
	}
	pTermCapList->wLength = 0;
	// point the CC_TERMCAPLIST pTermCapArray at the array of PCC_TERMCAP
	pTermCapList->pTermCapArray = ppCCThisTermCap;
	/*
					CC_TERMCAPLIST       PCC_TERMCAP        CC_TERMCAP

  pTermCapList->    {
						wLength
						pTermCapArray--->pTermCap----------->{single capability.....}
					}
										pTermCap----------->{single capability.}
			
										pTermCap----------->{single capability...}

    */

	for(u=0; u <uNumLocalFormats; u++)
	{
		// check if enabled for receive, skip if false
		// also skip if public version of capabilities is to be advertised via a
		// separate local capability entry
		if((!pDecodeDetails->bRecvEnabled ) || (pDecodeDetails->dwPublicRefIndex))
		{
			pDecodeDetails++;
			continue;
		}

		if(pDecodeDetails->H245TermCap.ClientType ==0
				|| pDecodeDetails->H245TermCap.ClientType ==H245_CLIENT_AUD_NONSTD)
		{

			lpwfx = (LPWAVEFORMATEX)pDecodeDetails->lpLocalFormatDetails;
			if(!lpwfx)
			{
				pDecodeDetails++;
				continue;
			}
			// allocate for this one capability
			pCCThisCap = (PCC_TERMCAP)MemAlloc(sizeof(CC_TERMCAP));		
			pNSCapNext = (PNSC_AUDIO_CAPABILITY)MemAlloc(sizeof(NSC_AUDIO_CAPABILITY)
				+ lpwfx->cbSize);
				
			if((!pCCThisCap)|| (!pNSCapNext))
			{
				hr = CAPS_E_NOMEM;
				goto ERROR_OUT;		
			}
			// set type of nonstandard capability
			pNSCapNext->cap_type = NSC_ACM_WAVEFORMATEX;
			// stuff both chunks of nonstandard capability info into buffer
			// first stuff the "channel parameters" (the format independent communication options)
			memcpy(&pNSCapNext->cap_params, &pDecodeDetails->nonstd_params, sizeof(NSC_CHANNEL_PARAMETERS));
			
			// then the ACM stuff
			memcpy(&pNSCapNext->cap_data.wfx, lpwfx, sizeof(WAVEFORMATEX) + lpwfx->cbSize);

			pCCThisCap->ClientType = H245_CLIENT_AUD_NONSTD;
			pCCThisCap->DataType = H245_DATA_AUDIO;
			// is this a "receive only" cap or a send&receive cap
			pCCThisCap->Dir = (pDecodeDetails->bSendEnabled && bPublicizeTXCaps)
				? H245_CAPDIR_LCLRXTX :H245_CAPDIR_LCLRX;

			// convert index of the cap entry to the ID
			pCCThisCap->CapId = (USHORT)IndexToId(u);

			// all nonstandard identifier fields are unsigned short
			// two possibilities for choice are "h221NonStandard_chosen" and "object_chosen"
			pCCThisCap->Cap.H245Aud_NONSTD.nonStandardIdentifier.choice = h221NonStandard_chosen;
			// NOTE: there is some question about the correct byte order
			// of the codes in the h221NonStandard structure
			pCCThisCap->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode = USA_H221_COUNTRY_CODE;
			pCCThisCap->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension = USA_H221_COUNTRY_EXTENSION;
			pCCThisCap->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode = MICROSOFT_H_221_MFG_CODE;

			// set size of buffer
			pCCThisCap->Cap.H245Aud_NONSTD.data.length = sizeof(NSC_AUDIO_CAPABILITY) + lpwfx->cbSize;
			pCCThisCap->Cap.H245Aud_NONSTD.data.value = (BYTE *)pNSCapNext;   // point to nonstandard stuff

			// pNSCapNext is now referenced by the pTermCapList and will
			// be cleaned up via DeleteCapList(). Null the ptr so that error cleanup
			// won't try redundant cleanup.
			pNSCapNext = NULL;
		}
		else
		{
			// allocate for this one capability
			pCCThisCap = (PCC_TERMCAP)MemAlloc(sizeof(CC_TERMCAP));		
			if(!pCCThisCap)
			{
				hr = CAPS_E_NOMEM;
				goto ERROR_OUT;		
			}
			
			pCCThisCap->ClientType = (H245_CLIENT_T)pDecodeDetails->H245TermCap.ClientType;
			pCCThisCap->DataType = H245_DATA_AUDIO;
			// is this a "receive only" cap or a send&receive cap
			pCCThisCap->Dir = (pDecodeDetails->bSendEnabled && bPublicizeTXCaps)
				? H245_CAPDIR_LCLRXTX :H245_CAPDIR_LCLRX;
			
			// convert the index of the cap entry to the ID
			pCCThisCap->CapId = (USHORT)IndexToId(u);//

			// Fixup capability parameters based on local details
			// use parameters that should have been set when codecs were enumerated
			// Special note for sample based codecs: H.225.0 Section 6.2.1 states
			// "Sample based codecs, such as G.711 and G.722 shall be considered to be
			// frame oriented, with a frame size of eight samples."
			switch  (pCCThisCap->ClientType )
			{

				case H245_CLIENT_AUD_G711_ALAW64:
					pCCThisCap->Cap.H245Aud_G711_ALAW64 =
						pDecodeDetails->nonstd_params.wFramesPerPktMax
						/ SAMPLE_BASED_SAMPLES_PER_FRAME;
				break;
				case H245_CLIENT_AUD_G711_ULAW64:
					pCCThisCap->Cap.H245Aud_G711_ULAW64 =
						pDecodeDetails->nonstd_params.wFramesPerPktMax
						/SAMPLE_BASED_SAMPLES_PER_FRAME ;
				break;

				case H245_CLIENT_AUD_G723:
					
					pCCThisCap->Cap.H245Aud_G723.maxAl_sduAudioFrames =   //4
						pDecodeDetails->nonstd_params.wFramesPerPktMax;
					// we know that the G.723 codec can decode SID in any mode, so
					//could we always advertise the *capability* to do silence suppression ????
				
					pCCThisCap->Cap.H245Aud_G723.silenceSuppression = 0;
						// = (pDecodeDetails->nonstd_params.UseSilenceDet)?1:0;
				break;
				default:
				break;
			}
		}
		pDecodeDetails++;
		*ppCCThisTermCap++ = pCCThisCap;// add ptr to this capability to the array
		pTermCapList->wLength++;      	// count this entry
		// pCCThisCap is now referenced by the pTermCapList and will
		// be cleaned up via DeleteCapList(). Null the ptr so that error cleanup
		// won't try redundant cleanup.
		pCCThisCap = NULL;
	}
	*ppCapBuf = pTermCapList;
	return hr;

ERROR_OUT:
	if(pTermCapList)
	{
		DeleteCapList(pTermCapList);
	}
	if(pCCThisCap)
		MemFree(pCCThisCap);
	if(pNSCapNext)
		MemFree(pNSCapNext);
	return hr;


}

HRESULT CMsiaCapability::DeleteCapList(LPVOID pCapBuf)
{
	UINT u;
	PCC_TERMCAPLIST pTermCapList = (PCC_TERMCAPLIST)pCapBuf;
	PCC_TERMCAP  pCCThisCap;
	PNSC_AUDIO_CAPABILITY pNSCap;
	
	if(!pTermCapList)
	{
		return CAPS_E_INVALID_PARAM;
	}

	if(pTermCapList->pTermCapArray)						
	{
		while(pTermCapList->wLength--)
		{
			pCCThisCap = *(pTermCapList->pTermCapArray + pTermCapList->wLength);
			if(pCCThisCap)
			{
				if(pCCThisCap->ClientType == H245_CLIENT_AUD_NONSTD)
				{
					if(pCCThisCap->Cap.H245Aud_NONSTD.data.value)
					{
						MemFree(pCCThisCap->Cap.H245Aud_NONSTD.data.value);
					}
				}
				MemFree(pCCThisCap);
			}
		}
		MemFree(pTermCapList->pTermCapArray);
	}
	MemFree(pTermCapList);
	return hrSuccess;
}


// copies relevant fields from a real H245 TERMCAP struct
// to a local H245TermCap struct
void CopyTermCapInfo(PCC_TERMCAP pSrc, H245_TERMCAP *pDest)
{
	ZeroMemory(pDest, sizeof(*pDest));

	pDest->Dir        = pSrc->Dir;
	pDest->DataType   = pSrc->DataType;
	pDest->ClientType = pSrc->ClientType;
	pDest->CapId      = pSrc->CapId;

	pDest->H245_NonStd    = pSrc->Cap.H245_NonStd;
	pDest->H245Aud_NONSTD = pSrc->Cap.H245Aud_NONSTD;

	pDest->H245Aud_G711_ALAW64 = pSrc->Cap.H245Aud_G711_ALAW64;
	pDest->H245Aud_G711_ULAW64 = pSrc->Cap.H245Aud_G711_ULAW64;
	pDest->H245Aud_G723        = pSrc->Cap.H245Aud_G723;

	return;
}


void CopyLocalTermCapInfo(H245_TERMCAP *pSrc, PCC_TERMCAP pDest)
{
	ZeroMemory(pDest, sizeof(*pDest));

	pDest->Dir        = pSrc->Dir;
	pDest->DataType   = pSrc->DataType;
	pDest->ClientType = pSrc->ClientType;
	pDest->CapId      = pSrc->CapId;

	pDest->Cap.H245_NonStd    = pSrc->H245_NonStd;
	pDest->Cap.H245Aud_NONSTD = pSrc->H245Aud_NONSTD;

	pDest->Cap.H245Aud_G711_ALAW64 = pSrc->H245Aud_G711_ALAW64;
	pDest->Cap.H245Aud_G711_ULAW64 = pSrc->H245Aud_G711_ULAW64;
	pDest->Cap.H245Aud_G723        = pSrc->H245Aud_G723;

	return;
}




// the intent is to keep a copy of the channel parameters used to open a send channel
// that the remote end can decode.

AUDIO_FORMAT_ID CMsiaCapability::AddRemoteDecodeFormat(PCC_TERMCAP pCCThisCap)
{
	FX_ENTRY ("CMsiaCapability::AddRemoteDecodeFormat");

	AUDCAP_DETAILS audcapdetails =
		{WAVE_FORMAT_UNKNOWN, NONSTD_TERMCAP,  STD_CHAN_PARAMS,
		{RTP_DYNAMIC_MIN, 8000, 4},
		0, TRUE, TRUE, 320, 32000,32000,50,0,0,0,NULL,0, NULL,""};

	LPVOID lpData = NULL;
	UINT uSize = 0;
	AUDCAP_DETAILS *pTemp;
	if(!pCCThisCap)
	{
		return INVALID_AUDIO_FORMAT;
	}
	
	// check room
	if(uRemoteDecodeFormatCapacity <= uNumRemoteDecodeFormats)
	{
		// get more mem, realloc memory by CAP_CHUNK_SIZE for pRemoteDecodeFormats
		pTemp = (AUDCAP_DETAILS *)MemAlloc((uNumRemoteDecodeFormats + CAP_CHUNK_SIZE)*sizeof(AUDCAP_DETAILS));
		if(!pTemp)
			goto ERROR_EXIT;
		// remember how much capacity we now have
		uRemoteDecodeFormatCapacity = uNumRemoteDecodeFormats + CAP_CHUNK_SIZE;
		#ifdef DEBUG
		if((uNumRemoteDecodeFormats && !pRemoteDecodeFormats) || (!uNumRemoteDecodeFormats && pRemoteDecodeFormats))
		{
			ERRORMESSAGE(("%s:leak! uNumRemoteDecodeFormats:0x%08lX, pRemoteDecodeFormats:0x%08lX\r\n",
				_fx_, uNumRemoteDecodeFormats,pRemoteDecodeFormats));
		}
		#endif
		// copy old stuff, discard old mem
		if(uNumRemoteDecodeFormats && pRemoteDecodeFormats)
		{
			memcpy(pTemp, pRemoteDecodeFormats, uNumRemoteDecodeFormats*sizeof(AUDCAP_DETAILS));
			MemFree(pRemoteDecodeFormats);
		}
		pRemoteDecodeFormats = pTemp;
	}
	// pTemp is where the stuff is cached
	pTemp = pRemoteDecodeFormats+uNumRemoteDecodeFormats;

	// fixup the capability structure being added.  First thing: initialize defaults
	memcpy(pTemp, &audcapdetails, sizeof(AUDCAP_DETAILS));
	// next, the H245 parameters

//	memcpy(&pTemp->H245Cap, pCCThisCap, sizeof(pTemp->H245Cap));
	CopyTermCapInfo(pCCThisCap, &pTemp->H245TermCap);
	
	// Note: if nonstandard data exists, the nonstd pointers need to be fixed up
	if(pCCThisCap->ClientType == H245_CLIENT_AUD_NONSTD)
	{
		// do we recognize this?
		if(pCCThisCap->Cap.H245Aud_NONSTD.nonStandardIdentifier.choice == h221NonStandard_chosen)
		{
			if((pCCThisCap->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode == USA_H221_COUNTRY_CODE)
			&& (pCCThisCap->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension == USA_H221_COUNTRY_EXTENSION)
			&& (pCCThisCap->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode == MICROSOFT_H_221_MFG_CODE))
			{
				// ok, this is ours so far. Now what data type is contained therein?
				// welllll, lets keep a copy of this regardless ????.  If we can't understand
				// future versions of ourselves, then what???
				uSize = pCCThisCap->Cap.H245Aud_NONSTD.data.length;
				lpData = pCCThisCap->Cap.H245Aud_NONSTD.data.value;
			}
		}
	} else {
		// set up the NSC_CHANNEL_PARAMETERS struct based on the remote H245 parameters
		
		switch(pCCThisCap->ClientType )  {
			case H245_CLIENT_AUD_G711_ALAW64:
				pTemp->nonstd_params.wFramesPerPktMax = pCCThisCap->Cap.H245Aud_G711_ALAW64
							* SAMPLE_BASED_SAMPLES_PER_FRAME;
			break;
			case H245_CLIENT_AUD_G711_ULAW64:
				pTemp->nonstd_params.wFramesPerPktMax = pCCThisCap->Cap.H245Aud_G711_ULAW64
							* SAMPLE_BASED_SAMPLES_PER_FRAME;
			break;

			case H245_CLIENT_AUD_G723:
				
				pTemp->nonstd_params.wFramesPerPktMax =pCCThisCap->Cap.H245Aud_G723.maxAl_sduAudioFrames;
				// do we care about silence suppression?
				pTemp->nonstd_params.UseSilenceDet = pCCThisCap->Cap.H245Aud_G723.silenceSuppression;
			break;
			default:
			break;
		}
	}
			
	pTemp->uLocalDetailsSize = 0; // we're not keeping another copy of local encode details
	pTemp->lpLocalFormatDetails =0; // we're not keeping another copy of local encode details
	
	pTemp->uRemoteDetailsSize = 0;   // clear this now
	if(uSize && lpData)
	{
		pTemp->H245TermCap.H245Aud_NONSTD.data.length = uSize;
		pTemp->H245TermCap.H245Aud_NONSTD.data.value = (unsigned char *)lpData;
		
		pTemp->lpRemoteFormatDetails = MemAlloc(uSize);
		if(pTemp->lpRemoteFormatDetails)
		{
			memcpy(pTemp->lpRemoteFormatDetails, lpData, uSize);
			pTemp->uRemoteDetailsSize = uSize;
				
		}
		#ifdef DEBUG
			else
			{
				ERRORMESSAGE(("%s:allocation failed!\r\n",_fx_));
			}
		#endif
	}
	else
	{
		pTemp->lpRemoteFormatDetails = NULL;
		pTemp->uRemoteDetailsSize =0;
	}
	uNumRemoteDecodeFormats++;
	// use the index as the ID
	return (uNumRemoteDecodeFormats-1);

	ERROR_EXIT:
	return INVALID_AUDIO_FORMAT;
			
}

BOOL CMsiaCapability::IsCapabilityRecognized(PCC_TERMCAP pCCThisCap)
{
	FX_ENTRY ("CMsiaCapability::IsCapabilityRecognized");
	if(pCCThisCap->DataType != H245_DATA_AUDIO)
		return FALSE;
		
	if(pCCThisCap->ClientType == H245_CLIENT_AUD_NONSTD)
	{
		// do we recognize this?
		if(pCCThisCap->Cap.H245Aud_NONSTD.nonStandardIdentifier.choice == h221NonStandard_chosen)
		{
			if((pCCThisCap->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode == USA_H221_COUNTRY_CODE)
			&& (pCCThisCap->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension == USA_H221_COUNTRY_EXTENSION)
			&& (pCCThisCap->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode == MICROSOFT_H_221_MFG_CODE))

			{
				// ok, this is ours so far. Now what data type is contained therein?
				// welllll, lets keep a copy of this regardless ????.  If we can't understand
				// future versions of ourselves, then what???
				return TRUE;
			}
			else
			{
				// unrecognized nonstandard capability
				ERRORMESSAGE(("%s:unrecognized nonstd capability\r\n",_fx_));
#ifdef DEBUG
				VOID DumpNonstdParameters(PCC_TERMCAP pChanCap1, PCC_TERMCAP pChanCap2);
				DumpNonstdParameters(NULL, pCCThisCap);
#endif
				return FALSE;
			}
		}
	}
	return TRUE;
}
HRESULT CMsiaCapability::AddRemoteDecodeCaps(PCC_TERMCAPLIST pTermCapList)
{
	FX_ENTRY ("CMsiaCapability::AddRemoteDecodeCaps");
	HRESULT hr = hrSuccess;
	PPCC_TERMCAP ppCCThisCap;
	PCC_TERMCAP pCCThisCap;

	WORD wNumCaps;

		//ERRORMESSAGE(("%s,\r\n", _fx_));
	if(!pTermCapList)    // additional capability descriptors may be added
	{                                // at any time
		return CAPS_E_INVALID_PARAM;
	}

	// cleanup old term caps if term caps are being added and old caps exist
	FlushRemoteCaps();
	
	wNumCaps = pTermCapList->wLength;
	ppCCThisCap = pTermCapList->pTermCapArray;
	
/*
					CC_TERMCAPLIST       TERMCAPINFO       CC_TERMCAP

	pTermCapList-> {
						wLength
						pTermCapInfo--->pTermCap----------->{single capability.....}
					}
										pTermCap----------->{single capability.}

										pTermCap----------->{single capability...}

*/
	while(wNumCaps--)
	{
		if(!(pCCThisCap = *ppCCThisCap++))
		{
			ERRORMESSAGE(("%s:null pTermCap, 0x%04x of 0x%04x\r\n",
				_fx_, pTermCapList->wLength - wNumCaps, pTermCapList->wLength));
			continue;
		}
		if(!IsCapabilityRecognized(pCCThisCap))
		{
			continue;
		}
		AddRemoteDecodeFormat(pCCThisCap);
	}
	return hr;
}



// Given the ID of a local format, gets the channel parameters that are sent to the
// remote end as part of the capability exchange.  This function is not used by the
// capability exchange code (because it sends more than just these parameters).
// However, this is useful information by itself - it can be used for validating the
// parameters of channel open requests against the expected parameters

HRESULT CMsiaCapability::GetPublicDecodeParams(LPVOID pBufOut, UINT uBufSize, AUDIO_FORMAT_ID id)
{
	UINT uIndex = IDToIndex(id);
	//    validate input
	if(!pBufOut|| (uIndex >= (UINT)uNumLocalFormats))
	{
		return CAPS_E_INVALID_PARAM;
	}
	if(uBufSize < sizeof(CC_TERMCAP))
	{
		return CAPS_E_BUFFER_TOO_SMALL;
	}
//	memcpy(pBufOut, &((pLocalFormats + uIndex)->H245Cap), sizeof(CC_TERMCAP));
	CopyLocalTermCapInfo(&((pLocalFormats + uIndex)->H245TermCap), (PCC_TERMCAP)pBufOut);

	return hrSuccess;
}

HRESULT CMsiaCapability::SetAudioPacketDuration(UINT uPacketDuration)
{
	m_uPacketDuration = uPacketDuration;
	return S_OK;
}

// Given the IDs of  "matching" local and remote formats, gets the preferred channel parameters
// that will be used in requests to open a channel for sending to the remote.

HRESULT CMsiaCapability::GetEncodeParams(LPVOID pBufOut, UINT uBufSize,LPVOID pLocalParams, UINT uSizeLocal,
	AUDIO_FORMAT_ID idRemote, AUDIO_FORMAT_ID idLocal)
{
	UINT uLocalIndex = IDToIndex(idLocal);
	AUDCAP_DETAILS *pLocalDetails  = pLocalFormats + uLocalIndex;
	AUDCAP_DETAILS *pFmtTheirs;
	AUDIO_CHANNEL_PARAMETERS local_params;
	PNSC_CHANNEL_PARAMETERS  pNSRemoteParams;
	LPWAVEFORMATEX lpwfx;

	UINT u;
	PCC_TERMCAP pTermCap = (PCC_TERMCAP)pBufOut;
	//    validate input
	if(!pBufOut)
	{
		return CAPS_E_INVALID_PARAM;
	}
	if(uBufSize < sizeof(CC_TERMCAP))
	{
		return CAPS_E_BUFFER_TOO_SMALL;
	}
	if(!pLocalParams|| uSizeLocal < sizeof(AUDIO_CHANNEL_PARAMETERS)
		||(uLocalIndex >= (UINT)uNumLocalFormats))
	{
		return CAPS_E_INVALID_PARAM;
	}

	pFmtTheirs = pRemoteDecodeFormats;     // start at the beginning of the remote formats
	for(u=0; u<uNumRemoteDecodeFormats; u++)
	{
		if(pFmtTheirs->H245TermCap.CapId == idRemote)
		{
			// copy CC_TERMCAP struct. Any data referenced by CC_TERMCAP now has
			// two references to it.  i.e. pTermCap->extrablah is the same
			// location as pFmtTheirs->extrablah
//			memcpy(pBufOut, &(pFmtTheirs->H245Cap), sizeof(CC_TERMCAP));
			CopyLocalTermCapInfo(&(pFmtTheirs->H245TermCap), (PCC_TERMCAP)pBufOut);

			break;
		}
		pFmtTheirs++;  // next entry in receiver's caps
	}

	// check for an unfound format
	if(u >= uNumRemoteDecodeFormats)
		goto ERROR_EXIT;
		
	// select channel parameters if appropriate.   The audio formats that have variable parameters
	// are :
	
	// H245_CAP_G723_T               H245Aud_G723;
	// H245_CAP_AIS11172_T           H245Aud_IS11172;
	// H245_CAP_IS13818_T            H245Aud_IS13818;
	// and of course all nonstandard formats

	// Select parameters based on local capability info
	
	// initialize local_params with  default settings
	memcpy(&local_params.ns_params,&pLocalDetails->nonstd_params,sizeof(local_params.ns_params));

	// recalculate frames per packet
	lpwfx = (LPWAVEFORMATEX)pLocalDetails->lpLocalFormatDetails;
	local_params.ns_params.wFramesPerPktMax = LOWORD(MaxFramesPerPacket(lpwfx));
	local_params.ns_params.wFramesPerPkt =  LOWORD(MinFramesPerPacket(lpwfx));
	if(local_params.ns_params.wFramesPerPktMin > local_params.ns_params.wFramesPerPkt)
	{
		local_params.ns_params.wFramesPerPktMin = local_params.ns_params.wFramesPerPkt;
	}


	
	if(pTermCap->ClientType == H245_CLIENT_AUD_G723)
	{
		// select frames per packet based on minimum latency value that is acceptable
		pTermCap->Cap.H245Aud_G723.maxAl_sduAudioFrames =  //4
		  min(local_params.ns_params.wFramesPerPkt, pTermCap->Cap.H245Aud_G723.maxAl_sduAudioFrames);
		// pLocalDetails->nonstd_params.wFramesPerPktMax;
		// never request silence suppression
		pTermCap->Cap.H245Aud_G723.silenceSuppression = 0;
			// (pLocalDetails->nonstd_params.UseSilenceDet)?1:0;

		// keep a copy of the selected parameters for use on the local side
		local_params.ns_params.wFramesPerPkt = 	local_params.ns_params.wFramesPerPktMin =
			local_params.ns_params.wFramesPerPktMax = pTermCap->Cap.H245Aud_G723.maxAl_sduAudioFrames;
		local_params.ns_params.UseSilenceDet = pTermCap->Cap.H245Aud_G723.silenceSuppression;
		local_params.RTP_Payload = pLocalDetails->audio_params.RTPPayload;
	}
	else if(pTermCap->ClientType == H245_CLIENT_AUD_G711_ALAW64)
	{
		// select frames per packet based on minimum latency value that is acceptable
		pTermCap->Cap.H245Aud_G711_ALAW64 =
		  min(local_params.ns_params.wFramesPerPkt/SAMPLE_BASED_SAMPLES_PER_FRAME, pTermCap->Cap.H245Aud_G711_ALAW64);
		// keep a copy of the selected parameters for use on the local side
		local_params.ns_params.wFramesPerPkt = 	local_params.ns_params.wFramesPerPktMin =
			local_params.ns_params.wFramesPerPktMax = pTermCap->Cap.H245Aud_G711_ALAW64*SAMPLE_BASED_SAMPLES_PER_FRAME;
		local_params.ns_params.UseSilenceDet = FALSE;
		// note that local_params.RTP_Payload is fixed below
	}
	else if(pTermCap->ClientType == H245_CLIENT_AUD_G711_ULAW64)
	{
		// select frames per packet based on minimum latency value that is acceptable
		pTermCap->Cap.H245Aud_G711_ULAW64 =
		  min(local_params.ns_params.wFramesPerPkt/SAMPLE_BASED_SAMPLES_PER_FRAME, pTermCap->Cap.H245Aud_G711_ULAW64);
		// keep a copy of the selected parameters for use on the local side
		local_params.ns_params.wFramesPerPkt = 	local_params.ns_params.wFramesPerPktMin =
			local_params.ns_params.wFramesPerPktMax = pTermCap->Cap.H245Aud_G711_ULAW64*SAMPLE_BASED_SAMPLES_PER_FRAME;
		local_params.ns_params.UseSilenceDet = FALSE;
		// note that local_params.RTP_Payload is fixed below
	}
	else if (pTermCap->ClientType == H245_CLIENT_AUD_NONSTD)
	{
		
	// note:  "H245_CLIENT_AUD_NONSTD H245Aud_NONSTD;" also has variable parameters in the
	// form of a pointer to a chunk of nonstandard data.  This pointer and the nonstandard
	// data it points to was set when remote caps were received (see AddRemoteDecodeCaps ()).
	// So as of this point, we just copied that nonstandard data back out into the channel
	// parameters.  We will use these parameters to request an open channel.

	// once we fix up a few important parameters. set channel params based on local params
		
		
		pNSRemoteParams = &((PNSC_AUDIO_CAPABILITY)(pTermCap->Cap.H245Aud_NONSTD.data.value))->cap_params;

		// LOOKLOOK ---- which parameters do we really need to select ???
		// For example, if wFrameSizeMin != wFrameSizeMax, do we pick something in the range?
		// or own favorite value?  what else?

		if(pNSRemoteParams->wFrameSizeMax < pNSRemoteParams->wFrameSize) // fixup bogus parameters
		    pNSRemoteParams->wFrameSizeMax = pNSRemoteParams->wFrameSize;
		
		// note that this writes on the memory that is caching remote capabilities
		// set frame size to our preferred size unless remote can't take it that big
		pNSRemoteParams->wFrameSize =
				min(local_params.ns_params.wFrameSize, pNSRemoteParams->wFrameSizeMax);
		pNSRemoteParams->wFramesPerPkt = min( local_params.ns_params.wFramesPerPkt,
				pNSRemoteParams->wFramesPerPktMax);

		// use optional stuff only of both sides have it
		pNSRemoteParams->UseSilenceDet = pNSRemoteParams->UseSilenceDet && local_params.ns_params.UseSilenceDet;
		pNSRemoteParams->UsePostFilter = pNSRemoteParams->UsePostFilter && local_params.ns_params.UsePostFilter;
		
		// keep a copy of the selected parameters for use on the local side
		memcpy(&local_params.ns_params, pNSRemoteParams, sizeof(NSC_CHANNEL_PARAMETERS));
	}

	// fix payload type
	local_params.RTP_Payload = pLocalDetails->audio_params.RTPPayload;
	memcpy(pLocalParams, &local_params, sizeof(AUDIO_CHANNEL_PARAMETERS));
	
	return hrSuccess;

	ERROR_EXIT:
	return CAPS_E_INVALID_PARAM;
}


// Given the ID of the local format, gets the local parameters that are used to configure
// the RECEIVE side of the channel
HRESULT CMsiaCapability::GetLocalDecodeParams(LPVOID lpvBuf,  UINT uBufSize, AUDIO_FORMAT_ID id)
{
	//    validate input
	if(!lpvBuf|| uBufSize < sizeof(NSC_CHANNEL_PARAMETERS) ||(id > (UINT)uNumLocalFormats))
	{
		return CAPS_E_INVALID_PARAM;
	}
	memcpy(lpvBuf, &((pLocalFormats + id)->nonstd_params), sizeof(NSC_CHANNEL_PARAMETERS));
	return hrSuccess;
}

BOOL NonstandardCapsCompareA(AUDCAP_DETAILS *pFmtMine, PNSC_AUDIO_CAPABILITY pCap2,
	UINT uSize2)
{
	LPWAVEFORMATEX lpwfx;
	if(!pFmtMine || !pCap2)
		return FALSE;

	if(!(lpwfx = (LPWAVEFORMATEX)pFmtMine->lpLocalFormatDetails))
		return FALSE;

		
	if(pCap2->cap_type == NSC_ACM_WAVEFORMATEX)
	{
		// check sizes first
		if(lpwfx->cbSize != pCap2->cap_data.wfx.cbSize)
		{
			return FALSE;
		}
		// compare structures, including extra bytes
		if(memcmp(lpwfx, &pCap2->cap_data.wfx,
			sizeof(WAVEFORMATEX) + lpwfx->cbSize )==0)
		{
			return TRUE;
		}
	}
	else if(pCap2->cap_type == NSC_ACMABBREV)
	{
		if((LOWORD(pCap2->cap_data.acm_brief.dwFormatTag) == lpwfx->wFormatTag)
		 && (pCap2->cap_data.acm_brief.dwSamplesPerSec ==  lpwfx->nSamplesPerSec)
		 && (LOWORD(pCap2->cap_data.acm_brief.dwBitsPerSample) ==  lpwfx->wBitsPerSample))
		{
			return TRUE;
		}
	}
	return FALSE;
}


HRESULT CMsiaCapability::ResolveToLocalFormat(MEDIA_FORMAT_ID FormatIDLocal,
		MEDIA_FORMAT_ID * pFormatIDRemote)
{
	AUDCAP_DETAILS *pFmtLocal;
	AUDCAP_DETAILS *pFmtRemote;
	UINT uIndex = IDToIndex(FormatIDLocal);
	UINT i;

	if(!pFormatIDRemote || (FormatIDLocal == INVALID_MEDIA_FORMAT)
		|| (uIndex >= (UINT)uNumLocalFormats))
	{
		return CAPS_E_INVALID_PARAM;
	}
	pFmtLocal = pLocalFormats + uIndex;
	
	pFmtRemote = pRemoteDecodeFormats;     // start at the beginning of the remote formats
	for(i=0; i<uNumRemoteDecodeFormats; i++)
	{
		if(!pFmtLocal->bSendEnabled)
			continue;
			
		// compare capabilities - start by comparing the format tag. a.k.a. "ClientType" in H.245 land
		if(pFmtLocal->H245TermCap.ClientType ==  pFmtRemote->H245TermCap.ClientType)
		{
			// if this is a nonstandard cap, compare nonstandard parameters
			if(pFmtLocal->H245TermCap.ClientType == H245_CLIENT_AUD_NONSTD)
			{
				if(NonstandardCapsCompareA(pFmtLocal,
					(PNSC_AUDIO_CAPABILITY)pFmtRemote->H245TermCap.H245Aud_NONSTD.data.value,
					pFmtRemote->H245TermCap.H245Aud_NONSTD.data.length))
				{
					goto RESOLVED_EXIT;
				}
			}
			else  // compare standard parameters, if any
			{
				// well, so far, there aren't any parameters that are significant enough
				// to affect the match/no match decision
				goto RESOLVED_EXIT;
			}
		}
		pFmtRemote++;  // next entry in receiver's caps
	}

	return CAPS_E_NOMATCH;
	
RESOLVED_EXIT:
	// Match! return ID of remote decoding (receive fmt) caps that match our
	// send caps
	*pFormatIDRemote = pFmtRemote->H245TermCap.CapId;
	return hrSuccess;
}

// resolve using currently cached local and remote formats

HRESULT CMsiaCapability::ResolveEncodeFormat(
	AUDIO_FORMAT_ID *pIDEncodeOut,
	AUDIO_FORMAT_ID *pIDRemoteDecode)
{
	UINT i,j=0;
	AUDCAP_DETAILS *pFmtMine = pLocalFormats;
	AUDCAP_DETAILS *pFmtTheirs;
	// LP_CUSTOM_CAPS lpCustomRemoteCaps = (LP_CUSTOM_CAPS)lpvRemoteCustomFormats;
	// LP_MSIAVC_CUSTOM_CAP_ENTRY lpCustomCaps;
	// LPWAVEFORMATEX lpWFX;
	
	if(!pIDEncodeOut || !pIDRemoteDecode)
	{
		return CAPS_E_INVALID_PARAM;
	}
	if(!uNumLocalFormats || !pLocalFormats)
	{
		*pIDEncodeOut = *pIDRemoteDecode = INVALID_AUDIO_FORMAT;
		return CAPS_E_NOCAPS;
	}
	if(!pRemoteDecodeFormats || !uNumRemoteDecodeFormats)
	{
		*pIDEncodeOut = *pIDRemoteDecode = INVALID_AUDIO_FORMAT;
		return CAPS_E_NOMATCH;
	}

	// decide how to encode.  my caps are ordered by my preference according to
	// the contents of IDsByRank[]

	//If given a salt, find the position and add it
	if (*pIDEncodeOut != INVALID_MEDIA_FORMAT)
	{
	 	UINT uIndex = IDToIndex(*pIDEncodeOut);
		if (uIndex > uNumLocalFormats)
		{
			return CAPS_W_NO_MORE_FORMATS;
		}
		for(i=0; i<uNumLocalFormats; i++)
		{
			if (pLocalFormats[IDsByRank[i]].H245TermCap.CapId == *pIDEncodeOut)
			{
	 			j=i+1;
				break;
			}
		}	
	}

	for(i=j; i<uNumLocalFormats; i++)
	{
		pFmtMine = pLocalFormats + IDsByRank[i];
		// check to see if this format is enabled for encoding
		if(!pFmtMine->bSendEnabled)
			continue;

		pFmtTheirs = pRemoteDecodeFormats;     // start at the beginning of the remote formats
		for(j=0; j<uNumRemoteDecodeFormats; j++)
		{
			// compare capabilities - start by comparing the format tag. a.k.a. "ClientType" in H.245 land
			if(pFmtMine->H245TermCap.ClientType ==  pFmtTheirs->H245TermCap.ClientType)
			{
				// if this is a nonstandard cap, compare nonstandard parameters
				if(pFmtMine->H245TermCap.ClientType == H245_CLIENT_AUD_NONSTD)
				{

					if(NonstandardCapsCompareA(pFmtMine,
					// (PNSC_AUDIO_CAPABILITY)pFmtMine->H245Cap.Cap.H245Aud_NONSTD.data.value,
						(PNSC_AUDIO_CAPABILITY)pFmtTheirs->H245TermCap.H245Aud_NONSTD.data.value,
						//pFmtMine->H245Cap.Cap.H245Aud_NONSTD.data.length,
						pFmtTheirs->H245TermCap.H245Aud_NONSTD.data.length))
					{
						goto RESOLVED_EXIT;
					}
				

				}
				else  // compare standard parameters, if any
				{
					// well, so far, there aren't any parameters that are significant enough
					// to affect the match/no match decision
					goto RESOLVED_EXIT;
				}
			}
			pFmtTheirs++;  // next entry in receiver's caps
		}
		
	}
	return CAPS_E_NOMATCH;
	
RESOLVED_EXIT:
	// Match!
    DEBUGMSG (ZONE_CONN,("Audio resolved (SEND) to Format Tag: %d\r\n",pFmtMine->wFormatTag));
	// return ID of our encoding (sending fmt) caps that match
	*pIDEncodeOut = pFmtMine->H245TermCap.CapId;
	// return ID of remote decoding (receive fmt) caps that match our
	// send caps
	*pIDRemoteDecode = pFmtTheirs->H245TermCap.CapId;
	return hrSuccess;

	
}

HRESULT CMsiaCapability::GetDecodeParams(PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS  pChannelParams,
		AUDIO_FORMAT_ID * pFormatID, LPVOID lpvBuf, UINT uBufSize)
{
	UINT i,j=0;
	PCC_TERMCAP pCapability;
	AUDCAP_DETAILS *pFmtMine = pLocalFormats;
	PAUDIO_CHANNEL_PARAMETERS pAudioParams = (PAUDIO_CHANNEL_PARAMETERS) lpvBuf;

	if(!pChannelParams || !(pCapability = pChannelParams->pChannelCapability) || !pFormatID || !lpvBuf
		|| (uBufSize < sizeof(AUDIO_CHANNEL_PARAMETERS)))
	{
		return CAPS_E_INVALID_PARAM;
	}
	if(!uNumLocalFormats || !pLocalFormats)
	{
		return CAPS_E_NOCAPS;
	}

	for(i=0; i<uNumLocalFormats; i++)
	{
		WORD wFramesPerPkt;
		pFmtMine = pLocalFormats + IDsByRank[i];
	
		// compare capabilities - start by comparing the format tag. a.k.a. "ClientType" in H.245 land
		if(pFmtMine->H245TermCap.ClientType ==  pCapability->ClientType)
		{
			// if this is a nonstandard cap, compare nonstandard parameters
			if(pFmtMine->H245TermCap.ClientType == H245_CLIENT_AUD_NONSTD)
			{
				if(NonstandardCapsCompareA(pFmtMine,
					(PNSC_AUDIO_CAPABILITY)pCapability->Cap.H245Aud_NONSTD.data.value,
					pCapability->Cap.H245Aud_NONSTD.data.length))
				{
					PNSC_AUDIO_CAPABILITY pNSCapRemote;
					pNSCapRemote = (PNSC_AUDIO_CAPABILITY)pCapability->Cap.H245Aud_NONSTD.data.value;
					if (pNSCapRemote->cap_params.wFramesPerPkt <= pFmtMine->nonstd_params.wFramesPerPktMax)
					{
						pAudioParams->ns_params = pNSCapRemote->cap_params;
						goto RESOLVED_EXIT;
					}
				}
			}
			else  // compare standard parameters, if any
			{

				if(pFmtMine->H245TermCap.ClientType == H245_CLIENT_AUD_G723)
				{
					// NEED TO FIND THE G.723 format that results in the largest buffer
					// size calculations so that the larger bitrate format can be used.
					// The buffer size calculations in the datapump are based on the
					// WAVEFORMATEX structure
					// search the remainder of the prioritized list, keep the best
					
					LPWAVEFORMATEX lpwf1, lpwf2;
					AUDCAP_DETAILS *pFmtTry;
					lpwf1 =(LPWAVEFORMATEX)pFmtMine->lpLocalFormatDetails;
					
					for(j = i+1;  j<uNumLocalFormats; j++)
					{
						pFmtTry = pLocalFormats + IDsByRank[j];
						if(pFmtTry->H245TermCap.ClientType != H245_CLIENT_AUD_G723)
							continue;

						lpwf2 =(LPWAVEFORMATEX)pFmtTry->lpLocalFormatDetails;
						if(lpwf2->nAvgBytesPerSec > lpwf1->nAvgBytesPerSec)
						{
							//pFmtMine = pFmtTry;
							lpwf1 = lpwf2;
							// Return value is based on index i.  This one is the
							// one we want so far
							i = j;
						}
						
					}
					
					// We know that the G.723 codec can decode SID in any mode,
					//
					//if(pFmtMine->H245Cap.Cap.H245Aud_G723.silenceSuppression ==
					//  pCapability->Cap.H245Aud_G723.silenceSuppression)
					//{
					//}
				}
				pAudioParams->ns_params = pFmtMine->nonstd_params;
				// update wFramesPerPkt with the actual recv channel parameter
				switch (pCapability->ClientType)
				{
					default:
					case H245_CLIENT_AUD_G711_ALAW64:
						wFramesPerPkt = pCapability->Cap.H245Aud_G711_ALAW64 * SAMPLE_BASED_SAMPLES_PER_FRAME;
						break;
					case H245_CLIENT_AUD_G711_ULAW64:
						wFramesPerPkt = pCapability->Cap.H245Aud_G711_ULAW64 * SAMPLE_BASED_SAMPLES_PER_FRAME;
						break;
					// these have no parameters
					//case H245_CLIENT_AUD_G711_ULAW56:
					//case H245_CLIENT_AUD_G711_ALAW56:
					break;

					case H245_CLIENT_AUD_G723:
						wFramesPerPkt = pCapability->Cap.H245Aud_G723.maxAl_sduAudioFrames;
					break;
				}
				if (wFramesPerPkt <= pFmtMine->nonstd_params.wFramesPerPktMax)
				{
					pAudioParams->ns_params.wFramesPerPkt = wFramesPerPkt;
					goto RESOLVED_EXIT;
				}
				else
				{
	    		DEBUGMSG (ZONE_CONN,("Recv channel wFramesPerPkt mismatch! ours=%d, theirs=%d\r\n",pFmtMine->nonstd_params.wFramesPerPktMax,wFramesPerPkt));
	    		}
			
			}
		}
	}
	return CAPS_E_NOMATCH;

RESOLVED_EXIT:
	// Match!
	// return ID of the decoding caps that match
	*pFormatID = IndexToId(IDsByRank[i]);
	
	pAudioParams->RTP_Payload  = pChannelParams->bRTPPayloadType;
	pAudioParams->ns_params.UseSilenceDet = (BYTE)pChannelParams->bSilenceSuppression;

    DEBUGMSG (ZONE_CONN,("Audio resolved (RECEIVE) to Format Tag: %d\r\n",pFmtMine->wFormatTag));

	return hrSuccess;

}

DWORD CMsiaCapability::MinFramesPerPacket(WAVEFORMATEX *pwf)
{
	UINT sblk, uSize;
	uSize = MinSampleSize(pwf);   // this calculates the minimum # of samples
								// that will still fit in an 80 mS frame
	
	// calculate samples per block ( aka frame)
	sblk = pwf->nBlockAlign* pwf->nSamplesPerSec/ pwf->nAvgBytesPerSec;
	if(!sblk)
		return 0;   // should never happen unless ACM is corrupted,
	// min samples per frame/samples per block = min frames/block.
	return uSize/sblk;
}


//
// determine a reasonable maximum number of frames per packet.
// 4x the Minimum is reasonable, so long as it doesn't make
// the packet too big
DWORD CMsiaCapability::MaxFramesPerPacket(WAVEFORMATEX *pwf)
{
	DWORD dwMin, dwMax;

	dwMin = MinFramesPerPacket(pwf); // minimum number of frames

	dwMax = MAX_FRAME_LEN_RECV / (dwMin * pwf->nBlockAlign);

	dwMax = min((4*dwMin), dwMax*dwMin);

	if (dwMax < dwMin)
	{
		WARNING_OUT(("CMsiaCapability::MaxFramesPerPacket - Max value computed as less than min.  Return Min for Max\r\n"));
		dwMax = dwMin;
	}

	return dwMax;

}

//
//   MinSampleSize() taken from datapump.cpp ChoosePacketSize()
//


// what else depends on it?
UINT CMsiaCapability::MinSampleSize(WAVEFORMATEX *pwf)
{
	// calculate default samples per pkt
	UINT spp, sblk;
	spp = m_uPacketDuration * pwf->nSamplesPerSec / 1000;
	// calculate samples per block ( aka frame)
	sblk = pwf->nBlockAlign* pwf->nSamplesPerSec/ pwf->nAvgBytesPerSec;
	if (sblk <= spp) {
		spp = (spp/sblk)*sblk;
		if ( spp*pwf->nAvgBytesPerSec/pwf->nSamplesPerSec > MAX_FRAME_LEN) {
			// packet too big
			spp = (MAX_FRAME_LEN/pwf->nBlockAlign)*sblk;
		}
	} else
		spp = sblk;
	return spp;
}

HRESULT CMsiaCapability::IsFormatEnabled (MEDIA_FORMAT_ID FormatID, PBOOL bRecv, PBOOL bSend)
{
   UINT uIndex = IDToIndex(FormatID);
   // 	validate input
   if(uIndex >= (UINT)uNumLocalFormats)
   {
	   return CAPS_E_INVALID_PARAM;
   }

   *bSend=((pLocalFormats + uIndex)->bSendEnabled);
   *bRecv=((pLocalFormats + uIndex)->bRecvEnabled);

   return hrSuccess;

}

BOOL CMsiaCapability::IsFormatPublic (MEDIA_FORMAT_ID FormatID)
{
	UINT uIndex = IDToIndex(FormatID);
	// 	validate input
	if(uIndex >= (UINT)uNumLocalFormats)
		return FALSE;
		
	// test if this is format is a duplicate of a public format
	if((pLocalFormats + uIndex)->dwPublicRefIndex)
		return FALSE;	// then we keep this format to ourselves
	else
		return TRUE;
}
MEDIA_FORMAT_ID CMsiaCapability::GetPublicID(MEDIA_FORMAT_ID FormatID)
{
	UINT uIndex = IDToIndex(FormatID);
	// 	validate input
	if(uIndex >= (UINT)uNumLocalFormats)
		return INVALID_MEDIA_FORMAT;
		
	if((pLocalFormats + uIndex)->dwPublicRefIndex)
	{
		return (pLocalFormats + ((pLocalFormats + uIndex)->dwPublicRefIndex))->H245TermCap.CapId;
	}
	else
	{
		return FormatID;
	}
}

#ifdef DEBUG
VOID DumpWFX(LPWAVEFORMATEX lpwfxLocal, LPWAVEFORMATEX lpwfxRemote)
{
	FX_ENTRY("DumpWFX");
	ERRORMESSAGE((" -------- %s Begin --------\r\n",_fx_));
	if(lpwfxLocal)
	{
		ERRORMESSAGE((" -------- Local --------\r\n"));
		ERRORMESSAGE(("wFormatTag:\t0x%04X, nChannels:\t0x%04X\r\n",
			lpwfxLocal->wFormatTag, lpwfxLocal->nChannels));
		ERRORMESSAGE(("nSamplesPerSec:\t0x%08lX, nAvgBytesPerSec:\t0x%08lX\r\n",
			lpwfxLocal->nSamplesPerSec, lpwfxLocal->nAvgBytesPerSec));
		ERRORMESSAGE(("nBlockAlign:\t0x%04X, wBitsPerSample:\t0x%04X, cbSize:\t0x%04X\r\n",
			lpwfxLocal->nBlockAlign, lpwfxLocal->wBitsPerSample, lpwfxLocal->cbSize));
	}
	if(lpwfxRemote)
	{
			ERRORMESSAGE((" -------- Remote --------\r\n"));
		ERRORMESSAGE(("wFormatTag:\t0x%04X, nChannels:\t0x%04X\r\n",
			lpwfxRemote->wFormatTag, lpwfxRemote->nChannels));
		ERRORMESSAGE(("nSamplesPerSec:\t0x%08lX, nAvgBytesPerSec:\t0x%08lX\r\n",
			lpwfxRemote->nSamplesPerSec, lpwfxRemote->nAvgBytesPerSec));
		ERRORMESSAGE(("nBlockAlign:\t0x%04X, wBitsPerSample:\t0x%04X, cbSize:\t0x%04X\r\n",
			lpwfxRemote->nBlockAlign, lpwfxRemote->wBitsPerSample, lpwfxRemote->cbSize));
	}
	ERRORMESSAGE((" -------- %s End --------\r\n",_fx_));
}
VOID DumpChannelParameters(PCC_TERMCAP pChanCap1, PCC_TERMCAP pChanCap2)
{
	FX_ENTRY("DumpChannelParameters");
	ERRORMESSAGE((" -------- %s Begin --------\r\n",_fx_));
	if(pChanCap1)
	{
		ERRORMESSAGE((" -------- Local Cap --------\r\n"));
		ERRORMESSAGE(("DataType:%d(d), ClientType:%d(d)\r\n",pChanCap1->DataType,pChanCap1->ClientType));
		ERRORMESSAGE(("Direction:%d(d), CapId:%d(d)\r\n",pChanCap1->Dir,pChanCap1->CapId));
	}
	if(pChanCap2)
	{
		ERRORMESSAGE((" -------- Remote Cap --------\r\n"));
		ERRORMESSAGE(("DataType:%d(d), ClientType:%d(d)\r\n",pChanCap2->DataType,pChanCap2->ClientType));
		ERRORMESSAGE(("Direction:%d(d), CapId:%d(d)\r\n",pChanCap2->Dir,pChanCap2->CapId));
	}
	ERRORMESSAGE((" -------- %s End --------\r\n",_fx_));
}
VOID DumpNonstdParameters(PCC_TERMCAP pChanCap1, PCC_TERMCAP pChanCap2)
{
	FX_ENTRY("DumpNonstdParameters");
	
	ERRORMESSAGE((" -------- %s Begin --------\r\n",_fx_));
	DumpChannelParameters(pChanCap1, pChanCap2);
	
	if(pChanCap1)
	{
		ERRORMESSAGE((" -------- Local Cap --------\r\n"));
		if(pChanCap1->Cap.H245Aud_NONSTD.nonStandardIdentifier.choice == h221NonStandard_chosen)
		{
			ERRORMESSAGE(("t35CountryCode:%d(d), t35Extension:%d(d)\r\n",
				pChanCap1->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode,
				pChanCap1->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension));
			ERRORMESSAGE(("MfrCode:%d(d), data length:%d(d)\r\n",
				pChanCap1->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode,
				pChanCap1->Cap.H245Aud_NONSTD.data.length));
		}
		else
		{
			ERRORMESSAGE(("unrecognized nonStandardIdentifier.choice: %d(d)\r\n",
				pChanCap1->Cap.H245Aud_NONSTD.nonStandardIdentifier.choice));
		}
	}
	if(pChanCap2)
	{
		ERRORMESSAGE((" -------- Remote Cap --------\r\n"));
		if(pChanCap2->Cap.H245Aud_NONSTD.nonStandardIdentifier.choice == h221NonStandard_chosen)
		{
			ERRORMESSAGE(("t35CountryCode:%d(d), t35Extension:%d(d)\r\n",
				pChanCap2->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode,
				pChanCap2->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension));
			ERRORMESSAGE(("MfrCode:%d(d), data length:%d(d)\r\n",
				pChanCap2->Cap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode,
				pChanCap2->Cap.H245Aud_NONSTD.data.length));
		}
		else
		{
			ERRORMESSAGE(("nonStandardIdentifier.choice: %d(d)\r\n",
				pChanCap2->Cap.H245Aud_NONSTD.nonStandardIdentifier.choice));
		}
	}
	ERRORMESSAGE((" -------- %s End --------\r\n",_fx_));
}
#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\ivcapapi.cpp ===
/*
 *  	File: connobj.cpp
 *
 *		implementation of Internet Video capability API interface.
 *
 *		
 *
 *		Revision History:
 *
 *		06/18/96	mikev	created
 *		07/28/96	philf	added support for video
 */

#include "precomp.h"
	
ULONG CImpAppVidCap ::AddRef()
{
	 return (m_pCapObject->AddRef());
}
ULONG CImpAppVidCap ::Release()
{
	 return (m_pCapObject->Release());
}
HRESULT CImpAppVidCap::GetNumFormats(UINT *puNumFmtOut)
{
	return (m_pCapObject->GetNumFormats(puNumFmtOut));
}
HRESULT CImpAppVidCap ::GetBasicVidcapInfo (VIDEO_FORMAT_ID Id,
		PBASIC_VIDCAP_INFO pFormatPrefsBuf)
{
 	return (m_pCapObject->GetBasicVidcapInfo (Id, pFormatPrefsBuf));
}		
HRESULT CImpAppVidCap ::EnumFormats(PBASIC_VIDCAP_INFO pFmtBuf, UINT uBufsize,
	UINT *uNumFmtOut)
{
	 return (m_pCapObject->EnumFormats(pFmtBuf, uBufsize, uNumFmtOut));
}

HRESULT CImpAppVidCap ::EnumCommonFormats(PBASIC_VIDCAP_INFO pFmtBuf, UINT uBufsize,
	UINT *uNumFmtOut, BOOL bTXCaps)
{
	 return (m_pCapObject->EnumCommonFormats(pFmtBuf, uBufsize, uNumFmtOut, bTXCaps));
}

HRESULT CImpAppVidCap ::ApplyAppFormatPrefs (PBASIC_VIDCAP_INFO pFormatPrefsBuf,
	UINT uNumFormatPrefs)
{
	 return (m_pCapObject->ApplyAppFormatPrefs (pFormatPrefsBuf, uNumFormatPrefs));
}

HRESULT CImpAppVidCap ::AddVCMFormat (PVIDEOFORMATEX pvfx, PVIDCAP_INFO pVidCapInfo)
{
	 return (m_pCapObject->AddVCMFormat(pvfx, pVidCapInfo));
}
HRESULT CImpAppVidCap ::RemoveVCMFormat (PVIDEOFORMATEX pvfx)
{
	 return (m_pCapObject->RemoveVCMFormat(pvfx));
}
PVIDEOFORMATEX CImpAppVidCap::GetVidcapDetails (VIDEO_FORMAT_ID Id)
{
	UINT uSize;
	VIDEOFORMATEX *pFormat;
	m_pCapObject->GetEncodeFormatDetails(Id, (VOID**)&pFormat, &uSize);
	return pFormat;
}
HRESULT CImpAppVidCap::GetPreferredFormatId (VIDEO_FORMAT_ID *pId)
{
	return (pId ? m_pCapObject->GetPreferredFormatId (pId) : (HRESULT)S_FALSE);
}
HRESULT CImpAppVidCap::SetDeviceID(DWORD dwDeviceID)
{
	 return (m_pCapObject->SetDeviceID(dwDeviceID));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\inscodec.h ===
/*
 -  INSCODEC.H
 -
 *	Microsoft NetMeeting
 *	Network Audio Controller (NAC) DLL
 *	Internal header file for installable codecs
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		1.29.97		Yoram Yaacovi		Created
 *
 */

#include <pshpack8.h> /* Assume 8 byte packing throughout */

/*
 *	Macros
 */
#define COMPARE_GUIDS(a,b)	RtlEqualMemory((a), (b), sizeof(GUID))
#define ACQMUTEX(hMutex)											\
	while (WaitForSingleObject(hMutex, 10000) == WAIT_TIMEOUT)		\
	{																\
		ERRORMSG(("Thread 0x%x waits on mutex\n", GetCurrentThreadId()));	\
	}																\
		
#define RELMUTEX(hMutex)	ReleaseMutex(hMutex)

#define IMPL(class, member, pointer) \
	(&((class *)0)->member == pointer, ((class *) (((LONG_PTR) pointer) - offsetof (class, member))))

/*
 *	Data Structures
 */

/****************************************************************************
 *  @doc  INTERNAL DATASTRUC AUDIO
 *
 *	@class CInstallAudioCodecs | Installable Audio codecs
 *
 *	@base public | IInstallAudioCodecs
 *
 ***************************************************************************/
class CInstallAudioCodecs : public IInstallAudioCodecs
{
	public:
	//	IUnknown methods
		STDMETHODIMP QueryInterface (REFIID riid, void **ppv);
		STDMETHODIMP_(ULONG) AddRef (void);
		STDMETHODIMP_(ULONG) Release (void);

	//	IInstallAudioCodecs methods
		STDMETHODIMP AddACMFormat (LPWAVEFORMATEX lpwfx, PBASIC_AUDCAP_INFO pAudCapInfo);
		STDMETHODIMP RemoveACMFormat (LPWAVEFORMATEX lpwfx);
		STDMETHODIMP ReorderFormats (PAUDCAP_INFO_LIST pAudCapInfoList);
		STDMETHODIMP EnumFormats(PAUDCAP_INFO_LIST *ppAudCapInfoList);
		STDMETHODIMP FreeBuffer(LPVOID lpBuffer);

	private:
	// Private functions

	// Debug display functions

	// Variables
};

/****************************************************************************
 *  @doc  INTERNAL DATASTRUC VIDEO
 *
 *	@class CInstallVideoCodecs | Installable Video codecs
 *
 *	@base public | IInstallVideoCodecs
 *
 ***************************************************************************/
class CInstallVideoCodecs : public IInstallVideoCodecs
{
	public:
	//	IUnknown methods
		STDMETHODIMP QueryInterface (REFIID riid, void **ppv);
		STDMETHODIMP_(ULONG) AddRef (void);
		STDMETHODIMP_(ULONG) Release (void);

	//	IInstallVideoCodecs methods
		STDMETHODIMP AddVCMFormat (PVIDCAP_INFO pVidCapInfo);
		STDMETHODIMP RemoveVCMFormat (PVIDCAP_INFO pVidCapInfo);
		STDMETHODIMP ReorderFormats (PVIDCAP_INFO_LIST pVidCapInfoList);
		STDMETHODIMP EnumFormats(PVIDCAP_INFO_LIST *ppVidCapInfoList);
		STDMETHODIMP FreeBuffer(LPVOID lpBuffer);

	private:
	// Private functions
		STDMETHODIMP AddRemoveVCMFormat(PVIDCAP_INFO pVidCapInfo,
										BOOL bAdd);

	// Debug display functions

	// Variables
};

/****************************************************************************
 *  @doc  INTERNAL DATASTRUC
 *
 *	@class CInstallCodecs | Installable codecs
 *
 *	@base public | IUnknown
 *
 ***************************************************************************/
class CInstallCodecs : public IInstallCodecs
{
	friend class CInstallAudioCodecs;
	friend class CInstallVideoCodecs;

	public:
	//	IUnknown methods
		STDMETHODIMP QueryInterface (REFIID riid, void **ppv);
		STDMETHODIMP_(ULONG) AddRef (void);
		STDMETHODIMP_(ULONG) Release (void);

		CInstallCodecs (void);
		~CInstallCodecs (void);
		HRESULT Initialize(REFIID riid);

	private:
	// Functions
		STDMETHODIMP FreeBuffer(LPVOID lpBuffer);
		STDMETHODIMP TranslateHr(HRESULT hr);

	// Audio and video interfaces
		CInstallAudioCodecs ifAudio;
		CInstallVideoCodecs ifVideo;

	// Variables
		// @cmember Reference Count
		int m_cRef;
		// Two public members to allow access from the nested classes
		// @cmember Pointer to an audio capability interface
		LPAPPCAPPIF m_pAudAppCaps;
		// @cmember Pointer to an video capability interface
		LPAPPVIDCAPPIF m_pVidAppCaps;

};

/*
 *	Globals
 */
EXTERN_C HANDLE g_hMutex;
EXTERN_C class CInstallCodecs *g_pIC;

/*
 *	Function prototypes
 */

#include <poppack.h> /* End byte packing */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\mediapkt.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    audpackt.h

Abstract:

    Contains  prototypes for the AudioPacket class, which encapsulates a sound buffer in
    its various states: recorded/encoded/network/decoded/playing etc.

--*/
#ifndef _MEDIAPKT_H_
#define _MEDIAPKT_H_

#include <pshpack8.h> /* Assume 8 byte packing throughout */



class MediaControl;
class FilterManager;
class DataPump;

typedef struct tagNetBuf
{
	// first part looks like a Winsock WSABUF struct
	ULONG		length;
	UCHAR		*data;
	class BufferPool	*pool;
	struct tagNetBuf *next;
}
	NETBUF;


typedef struct tagMediaPacketInit
{
	// flags
	DWORD		dwFlags;
	// if set then MediaPacket doesnt allocate NETBUFs for RawData
	BOOL		fDontAllocRawBufs;
	
	// stream of conversion
	DPHANDLE	hStrmConv;
	PVOID		pStrmConvSrcFmt;
	PVOID		pStrmConvDstFmt;

	// device of mm io
	// DPHANDLE	hDevAudio;
	PVOID		pDevFmt;

	// dev buffer
	// PVOID	pDevData;
	ULONG		cbSizeDevData;
	ULONG		cbOffsetDevData;

	// wave buffer
	// PVOID	pWaveData;
	ULONG		cbSizeRawData;
	ULONG		cbOffsetRawData;

	// net buffer
	ULONG		cbSizeNetData;
	ULONG		cbOffsetNetData;
	ULONG		cbPayloadHeaderSize;
	int			index;
	BYTE		payload;

}
	MEDIAPACKETINIT;


/////////////////////////////////////////////
//
// AudioPacket
//
#define DP_MASK_STATE		  0x000000FFUL

class MediaPacket
{

protected:

	// stream of conversion
	DPHANDLE	m_hStrmConv;
	PVOID		m_pStrmConvHdr;
	PVOID		m_pStrmConvSrcFmt;
	PVOID		m_pStrmConvDstFmt;

	// device of mm io
	DPHANDLE	m_hDev;
	PVOID		m_pDevHdr;
	PVOID		m_pDevFmt;

	// dev related buffer and info
	NETBUF		*m_pDevData;

	// wave related buffer and info
	NETBUF		*m_pRawData;
	UINT        m_cbValidRawData;  // audio only - size of decode results

	// network related buffer and info
	NETBUF		*m_pNetData;
	UINT		m_cbMaxNetData;		// size of allocated net buffer

	// public properties accessible
	DWORD		m_dwState;
	BOOL		m_fBusy;	// set if not owned by rx/txstream
	UINT		m_seq;		// RTP seq num
	UINT		m_index;	// position in queue

	
	// internal properties
	BOOL		m_fInitialized;
	BOOL		m_fDevPrepared;
	BOOL		m_fStrmPrepared;


private:

	void _Construct ( void );
	void _Destruct ( void );

public:
 	BOOL m_fRendering;

	UINT		m_fMark;	// RTP mark bit
	DWORD		m_timestamp;// RTP timestamp
	BYTE		m_payload;	// RTP payload

	MediaPacket ( void );
	~MediaPacket ( void );

	virtual HRESULT Initialize ( MEDIAPACKETINIT * p );
	virtual HRESULT Receive (NETBUF *pNetBuf, DWORD timestamp, UINT seq, UINT fMark);
	virtual HRESULT Play ( MMIODEST *pmmioDest, UINT uDataType )  = 0;
	virtual HRESULT Record ( void ) = 0;
	virtual HRESULT GetProp ( DWORD dwPropId, PDWORD_PTR pdwPropVal );
	virtual HRESULT SetProp ( DWORD dwPropId, DWORD_PTR dwPropVal );
	virtual HRESULT Interpolate ( MediaPacket * pPrev, MediaPacket * pNext) = 0;
	virtual HRESULT Release ( void );
	virtual HRESULT Recycle ( void );
	virtual HRESULT Open ( UINT uType, DPHANDLE hdl ) = 0;	// called by RxStream or TxStream
	virtual HRESULT Close ( UINT uType ) = 0;				// called by RxStream or TxStream
	virtual BOOL IsBufferDone ( void ) = 0;
	virtual BOOL IsSameMediaFormat(PVOID fmt1,PVOID fmt2) = 0;
	virtual void WriteToFile (MMIODEST *pmmioDest) = 0;
	virtual void ReadFromFile (MMIOSRC *pmmioSrc ) = 0;
	virtual HRESULT GetSignalStrength (  PDWORD pdwMaxStrength ) = 0;
	virtual HRESULT MakeSilence ( void ) = 0;
	BOOL SetDecodeBuffer(NETBUF *pNetBuf);
	BOOL Busy(void) { return m_fBusy;}
	void Busy(BOOL fBusy) { m_fBusy = fBusy;}
	UINT GetSeqNum(void) { return m_seq;}
	DWORD GetTimestamp(void) { return m_timestamp;}
	BYTE GetPayload(void) { return m_payload;}
	VOID SetPayload(BYTE bPayload) { m_payload = bPayload;}
	UINT GetIndex(void) {return m_index;}
	UINT GetState(void) { return (m_dwState & DP_MASK_STATE); }
	void SetState(DWORD s) { m_dwState = (m_dwState & ~DP_MASK_STATE) | (s & DP_MASK_STATE); }
	void* GetConversionHeader() {return m_pStrmConvHdr;}

	HRESULT GetDevData(PVOID *ppData, PUINT pcbData) ;
	HRESULT GetNetData(PVOID *ppData, PUINT pcbData);
	HRESULT SetNetLength(UINT uLength);
	virtual DWORD GetDevDataSamples() = 0;
	inline DWORD GetFrameSize() {return ((DWORD)m_pNetData->length);}
	inline void SetRawActual(UINT uRawValid) {m_cbValidRawData = uRawValid;}
};


enum
{
	MP_STATE_RESET,

	MP_STATE_RECORDING,
	MP_STATE_RECORDED,
	MP_STATE_ENCODED,
	MP_STATE_NET_OUT_STREAM,

	MP_STATE_NET_IN_STREAM,
	MP_STATE_DECODED,
	MP_STATE_PLAYING_BACK,
	MP_STATE_PLAYING_SILENCE,
	MP_STATE_PLAYED_BACK,

	MP_STATE_RECYCLED,

	MP_STATE_NumOfStates
};



enum
{
	MP_DATATYPE_FROMWIRE,
	MP_DATATYPE_SILENCE,
	MP_DATATYPE_INTERPOLATED,
	MP_DATATYPE_NumOfDataTypes
};

// types for Open()/Close()
enum
{
	MP_TYPE_RECVSTRMCONV,
	MP_TYPE_STREAMCONV,
	MP_TYPE_DEV,
	MP_TYPE_NumOfTypes
};



enum
{
	MP_PROP_STATE,
	MP_PROP_PLATFORM,
	MP_PROP_DEV_MEDIA_FORMAT,
	MP_PROP_DEV_DATA,
	MP_PROP_DEV_HANDLE,
	MP_PROP_DEV_MEDIA_HDR,
	MP_PROP_IN_STREAM_FORMAT,
	MP_PROP_OUT_STREAM_FORMAT,
	MP_PROP_TIMESTAMP,
	MP_PROP_INDEX,
	MP_PROP_PREAMBLE,
	MP_PROP_SEQNUM,
	MP_PROP_FILTER_HEADER,
	MP_PROP_MAX_NET_LENGTH,
	MP_PROP_NumOfProps
};

#include <poppack.h> /* End byte packing */

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\inscodec.cpp ===
/*
 -  INSCODEC.CPP
 -
 *	Microsoft NetMeeting
 *	Network Access Controller (NAC) DLL
 *	Installable codecs interfaces
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		01.29.96	Yoram Yaacovi		Created
 *
 *	Functions:
 *		CInstallCodecs
 *			QueryInterface
 *			AddRef
 *			Release
 *			Initialize
 *			TranslateHr
 *		CInstallAudioCodecs
 *			QueryInterface
 *			AddRef
 *			Release
 *			AddACMFormat
 *			RemoveACMFormat
 *			ReorderFormats
 *			EnumFormats
 *			FreeBuffer
 *		CInstallVideoCodecs
 *			QueryInterface
 *			AddRef
 *			Release
 *			AddVCMFormat
 *			RemoveVCMFormat
 *			ReorderFormats
 *			EnumFormats
 *			FreeBuffer
 *		Public:
 *		Private:
 *			FreeBuffer
 *		External:
 *			CreateInstallCodecs
 *
 *
 *  @doc  EXTERNAL
 *
 *	Notes:
 *	@topic Implementation Notes | Below are some implementation notes.
 *
 *	@devnote To add an audio or video format for use with NetMeeting, first obtain the
 *	appropriate interface by calling the COM CoCreateInstance, providing the desired
 *	interface (IInstallAudioCodecs or IInstallVideoCodecs). Then call the Add>CMFormat
 *	method on this interface to add a format, or Remove?CMFormat to remove one. Use
 *	the EnumFormats method to enumerate the list of formats known to NetMeeting, or
 *	ReorderFormats to make NetMeeting use these formats in a different priority order
 *	(see comment in the ReorderFormats description).
 *
 *	@devnote When a vendor uses our API to add a codec format for use with NetMeeting,
 *	the information about this format is stored in the registry. Whenever we do
 *	an upgrade install of NetMeeting, we blow away these registry entry,
 *	together with all the standard registry entries. This is required to avoid
 *	incompatibility problems. This means that if a user installed a 3rd party codec,
 *	and then upgraded NetMeeting, he will have to re-add the custom codec.
 *
 */

#include <precomp.h>
#include <confreg.h>	// for setting NetMeeting to manual codec selection
#include <regentry.h>	// for setting NetMeeting to manual codec selection

EXTERN_C int g_cICObjects=0;
EXTERN_C HANDLE g_hMutex=NULL;
class CInstallCodecs *g_pIC;

/***************************************************************************

	CInstallCodecs

***************************************************************************/
/***************************************************************************

    IUnknown Methods

***************************************************************************/
HRESULT CInstallCodecs::QueryInterface (REFIID riid, LPVOID *lppNewObj)
{
    HRESULT hr = NOERROR;

	DEBUGMSG(ZONE_INSTCODEC,("CInstallCodecs::QueryInterface\n"));

#ifdef DEBUG
	// parameter validation
    if (IsBadReadPtr(&riid, (UINT) sizeof(IID)))
    {
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (IsBadWritePtr(lppNewObj, sizeof(LPVOID)))
    {
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }
#endif	// DEBUG
	
	*lppNewObj = 0;

	if (riid == IID_IUnknown || riid == IID_IInstallCodecs)
		*lppNewObj = (IInstallCodecs *) this;
	else if (riid == IID_IInstallAudioCodecs)
		*lppNewObj = (IInstallAudioCodecs *) &ifAudio;
	else if (riid == IID_IInstallVideoCodecs)
		*lppNewObj = (IInstallVideoCodecs *) &ifVideo;
	else
	{
		hr = E_NOINTERFACE;
		goto out;
	}	
	
	((IUnknown *)*lppNewObj)->AddRef ();

out:
	DEBUGMSG(ZONE_INSTCODEC,("CInstallCodecs::QueryInterface - leave, hr=0x%x\n", hr));
	return hr;
}

ULONG CInstallCodecs::AddRef (void)
{
	DEBUGMSG(ZONE_INSTCODEC,("CInstallCodecs::AddRef\n"));

	InterlockedIncrement((long *) &m_cRef);

	DEBUGMSG(ZONE_INSTCODEC,("CInstallCodecs::AddRef - leave, m_cRef=%d\n", m_cRef));

	return m_cRef;
}

ULONG CInstallCodecs::Release (void)
{
	DEBUGMSG(ZONE_INSTCODEC,("CInstallCodecs::Release\n"));

	// if the cRef is already 0 (shouldn't happen), assert, but let it through
	ASSERT(m_cRef);

	if (InterlockedDecrement((long *) &m_cRef) == 0)
	{
		delete this;
	}

	DEBUGMSG(ZONE_INSTCODEC,("CInstallCodecs::Release - leave, m_cRef=%d\n", m_cRef));
	
	return m_cRef;
}

/***************************************************************************

	CInstallAudioCodecs

***************************************************************************/
/****************************************************************************
 *  @doc  EXTERNAL COMPFUNC AUDIO
 *
 *	@interface IInstallAudioCodecs | This interface provides methods for
 *		adding audio codec formats for use with NetMeeting, as well as
 *		removing these formats, enumerating them, and change their use order.
 *
 ***************************************************************************/
/***************************************************************************

    IUnknown Methods

	Calling the containing object respective methods

***************************************************************************/
/****************************************************************************
 *
 *  @method HRESULT | IInstallAudioCodecs | QueryInterface | QueryInterface
 *
 ***************************************************************************/
HRESULT CInstallAudioCodecs::QueryInterface (REFIID riid, LPVOID *lppNewObj)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifAudio, this);	// the containing object

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::QueryInterface\n"));

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::QueryInterface - leave\n"));
	return (This->QueryInterface(riid, lppNewObj));

}

/****************************************************************************
 *
 *  @method ULONG | IInstallAudioCodecs | AddRef | AddRef
 *
 ***************************************************************************/
ULONG CInstallAudioCodecs::AddRef (void)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifAudio, this);	// the containing object

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::AddRef\n"));

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::AddRef - leave\n"));
	return (This->AddRef());
}

/****************************************************************************
 *
 *  @method ULONG | IInstallAudioCodecs | Release | Release
 *
 ***************************************************************************/
ULONG CInstallAudioCodecs::Release (void)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifAudio, this);	// the containing object

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::Release\n"));

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::Release - leave\n"));
	return (This->Release());
}

/****************************************************************************
 *
 *	AddACMFormat
 *
 *  @method HRESULT | IInstallAudioCodecs | AddACMFormat | Adds an ACM encoding
 *		format for use with NetMeeting
 *
 *  @parm LPWAVEFORMATEX | lpwfx | Pointer to the WAVEFORMATEX structure of the
 *		format to add
 *
 *  @parm PAUDCAP_INFO | pAudCapInfo | Additional format info that is not in the
 *		WAVEFORMATEX structure
 *
 *  @rdesc Returns zero (NOERROR) if the function was successful. Otherwise, it returns
 *      a standard HRESULT, with the WIN32 facility code (7), or the specific facility
 *		code for installable codecs (0x301).
 *		Possible error codes:
 *		@flag E_INVALIDARG | Invalid argument
 *      @flag IC_E_NO_SUCH_FORMAT | The specified WAVEFORMATEX was not found with ACM.
 *			The format must be installed with ACM before it can be added for use
 *			with NetMeeting.
 *      @flag IC_E_INTERNAL_ERROR | the Network Audio/Video Controller
 *      reported a system error
 *
 ***************************************************************************/
HRESULT CInstallAudioCodecs::AddACMFormat(LPWAVEFORMATEX lpwfx, PAUDCAP_INFO pAudCapInfo)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifAudio, this);	// the containing object
	HRESULT hr=NOERROR;

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::AddACMFormat\n"));

	/*
	 *	Parameter validation
	 */

	// parameters
	if (!lpwfx || !pAudCapInfo ||
		IsBadReadPtr(lpwfx, (UINT) sizeof(WAVEFORMATEX)) ||
		IsBadReadPtr(pAudCapInfo, (UINT) sizeof(AUDCAP_INFO)))
	{
		hr = E_INVALIDARG;
		goto out;
	}

	// NAC doesn't like a nBlockAlign of 0
	if (lpwfx->nBlockAlign == 0)
	{
		hr = E_INVALIDARG;
		goto out;
	}

	// the format tags in the WAVEFORMAT and the AUDCAP_INFO should match
	if (lpwfx->wFormatTag != pAudCapInfo->wFormatTag)
	{
		hr = E_INVALIDARG;
		goto out;
	}

	// only supporting formats with one audio channel
	if (lpwfx->nChannels != 1)
	{
		hr = E_INVALIDARG;
		goto out;
	}
		
	/*
	 *	Add the format
	 */

	// add
	hr = This->m_pAudAppCaps->AddACMFormat(lpwfx, pAudCapInfo);

out:
	if (FAILED(hr))
	{
		ERRORMSG(("CInstallAudioCodecs::AddACMFormat failed, hr=0x%x\n", hr));
	}

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::AddACMFormat - leave\n"));
	return This->TranslateHr(hr);
}

/****************************************************************************
 *
 *	RemoveACMFormat
 *
 *  @method HRESULT | IInstallAudioCodecs | RemoveACMFormat | Removes an ACM
 *		format from the list of formats used by NetMeeting
 *
 *  @parm LPWAVEFORMATEX | lpwfx | Pointer to the WAVEFORMATEX structure for the
 *		format to remove
 *
 *  @rdesc Returns zero (NOERROR) if the function was successful. Otherwise, it returns
 *      a standard HRESULT, with the WIN32 facility code (0x7), or the specific facility
 *		code for installable codecs (0x301).
 *		Possible error codes:
 *		@flag E_INVALIDARG | Invalid argument
 *      @flag IC_E_NO_SUCH_FORMAT | The specified format was not found.
 *      @flag IC_E_INTERNAL_ERROR | the Network Audio/Video Controller
 *			reported a system error
 *
 ***************************************************************************/
HRESULT CInstallAudioCodecs::RemoveACMFormat(LPWAVEFORMATEX lpwfx)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifAudio, this);	// the containing object
	HRESULT hr=NOERROR;

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::RemoveACMFormat\n"));

	/*
	 *	Parameter validation
	 */

	if (!lpwfx ||
		IsBadReadPtr(lpwfx, (UINT) sizeof(WAVEFORMATEX)))
	{
		hr = E_INVALIDARG;
		goto out;
	}

	// NAC doesn't like a nBlockAlign of 0
	if (lpwfx->nBlockAlign == 0)
	{
		hr = E_INVALIDARG;
		goto out;
	}

	// only supporting formats with one audio channel
	if (lpwfx->nChannels != 1)
	{
		hr = E_INVALIDARG;
		goto out;
	}
		
	hr = This->m_pAudAppCaps->RemoveACMFormat(lpwfx);

out:
	if (FAILED(hr))
	{
		ERRORMSG(("CInstallAudioCodecs::RemoveACMFormat failed, hr=0x%x\n", hr));
	}

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::RemoveACMFormat - leave\n"));
	return This->TranslateHr(hr);
}

/****************************************************************************
 *
 *	ReorderFormats
 *
 *  @method HRESULT | IInstallAudioCodecs | ReorderFormats | Reorders the audio
 *		formats for use with Netmeeting
 *
 *  @parm PAUDCAP_INFO_LIST | pAudCapInfoList | Pointer to a structure with a count
 *		and a pointer to a list of the formats to reorder. The list is of the
 *		format AUDCAP_INFO_LIST.
 *
 *  @rdesc Returns zero (NOERROR) if the function was successful. Otherwise, it returns
 *      a standard HRESULT, with the WIN32 facility code (7), or the specific facility
 *		code for installable codecs (0x301).
 *		Possible error codes:
 *		@flag E_INVALIDARG | Invalid argument
 *      @flag IC_E_INTERNAL_ERROR | the Network Audio/Video Controller
 *      reported a system error
 *
 *	@comm Since ReorderFormats can only reorder formats that are known to NetMeeting,
 *		it is recommended that the caller will first call EnumFormats, to get the
 *		of all formats known to NetMeeting, assign new sort indices (wSortIndex),
 *		and then call ReorderFormats with the modified list.
 *
 *	@comm Arranging the formats in a specific order, by using ReorderFormats, does
 *		not guarantee that the top ranked formats will be used before lower ranked
 *		formats are used. For example, if the sending system is not capable of
 *		encoding a top ranked format, this format will not be used. The same
 *		will happen if the receiving system cannot decode this format.
 *
 ***************************************************************************/
HRESULT CInstallAudioCodecs::ReorderFormats(PAUDCAP_INFO_LIST pAudCapInfoList)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifAudio, this);	// the containing object
	RegEntry re( AUDIO_KEY, HKEY_CURRENT_USER );
	HRESULT hr=NOERROR;

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::ReorderFormats\n"));

	/*
	 *	Parameter validation
	 */

	if (!pAudCapInfoList ||
		IsBadReadPtr(pAudCapInfoList, sizeof(DWORD)) ||
		IsBadReadPtr(pAudCapInfoList,
				sizeof(AUDCAP_INFO_LIST) + ((pAudCapInfoList->cFormats-1) * sizeof(AUDCAP_INFO))))
	{
		hr = E_INVALIDARG;
		goto out;
	}

	// fill in the format buffer here

	hr = This->m_pAudAppCaps->ApplyAppFormatPrefs(pAudCapInfoList->aFormats,
												pAudCapInfoList->cFormats);

	if (FAILED(hr))
		goto out;

	/*
	 *	switch NetMeeting to manual mode
	 */

	// set the registry. failing here won't fail ReorderFormats
	re.SetValue(REGVAL_CODECCHOICE, CODECCHOICE_MANUAL);

out:
	if (FAILED(hr))
	{
		ERRORMSG(("CInstallAudioCodecs::ReorderFormats failed, hr=0x%x\n", hr));
	}
	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::ReorderFormats - leave\n"));
	return This->TranslateHr(hr);
}

/****************************************************************************
 *
 *	EnumFormats
 *
 *  @method HRESULT | IInstallAudioCodecs | EnumFormats | Enumerates the audio
 *		codec formats known to NetMeeting
 *
 *  @parm PAUDCAP_INFO_LIST * | ppAudCapInfoList | Address where this method
 *		will put a pointer to a AUDCAP_INFO_LIST list, where enumerated formats
 *		are listed.
 *
 *  @rdesc Returns zero (NOERROR) if the function was successful. Otherwise, it returns
 *      a standard HRESULT, with the WIN32 facility code (7), or the specific facility
 *		code for installable codecs (0x301).
 *		Possible error codes:
 *		@flag E_INVALIDARG | Invalid argument
 *		@flag E_OUTOFMEMORY | Not enough memory for allocating the enumeration buffer
 *		@flag IC_E_NO_FORMATS | No formats were available to enumerate
 *      @flag IC_E_INTERNAL_ERROR | the Network Audio/Video Controller
 *      reported a system error
 *
 *	@comm The caller is expected to free the returned list, by calling FreeBuffer
 *		on the same interface.
 *
 ***************************************************************************/
HRESULT CInstallAudioCodecs::EnumFormats(PAUDCAP_INFO_LIST *ppAudCapInfoList)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifAudio, this);	// the containing object
	ULONG cFormats = 0;
	UINT uBufSize = 0;
	HRESULT hr=NOERROR;

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::EnumFormats\n"));

	/*
	 *	Parameter validation
	 */

	if (!ppAudCapInfoList ||
		IsBadWritePtr(ppAudCapInfoList, sizeof(PAUDCAP_INFO_LIST)))
	{
		hr = E_INVALIDARG;
		goto out;
	}

	// nothing yet....
	*ppAudCapInfoList = NULL;

	// are there any formats ?
	if (HR_FAILED(This->m_pAudAppCaps->GetNumFormats((UINT *) &cFormats))	||
		(cFormats == 0))
	{
		hr = IC_E_NO_FORMATS;
		goto out;
	}

	// allocate a buffer for the call. the caller is expected to call
	// FreeBuffer to free
	// AUDCAP_INFO_LIST already includes one AUDCAP_INFO
	uBufSize = sizeof(AUDCAP_INFO_LIST) + (cFormats-1) * sizeof(AUDCAP_INFO);
	*ppAudCapInfoList = (PAUDCAP_INFO_LIST) MEMALLOC (uBufSize);
	if (!(*ppAudCapInfoList))
	{
		hr = E_OUTOFMEMORY;
		goto out;
	}
		
	hr = This->m_pAudAppCaps->EnumFormats((*ppAudCapInfoList)->aFormats, uBufSize,
											(UINT *) &((*ppAudCapInfoList)->cFormats));

out:
	if (FAILED(hr))
	{
		ERRORMSG(("CInstallAudioCodecs::EnumFormats failed, hr=0x%x\n", hr));
	}
	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::EnumFormats - leave\n"));
	return This->TranslateHr(hr);
}

/****************************************************************************
 *
 *	FreeBuffer
 *
 *  @method HRESULT | IInstallAudioCodecs | FreeBuffer | Free a buffer that was
 *		returned by the IInstallAudioCodec interface
 *
 *  @parm LPVOID | lpBuffer | Address of the buffer to free. This buffer must have
 *		been allocated by one of the IInstallAudioCodecs methods
 *
 *  @rdesc Returns zero (NOERROR) if the function was successful. Otherwise, it returns
 *      a standard HRESULT, with the WIN32 facility code (7), or the specific facility
 *		code for installable codecs (0x301).
 *		Possible error codes:
 *		None
 *
 ***************************************************************************/
HRESULT CInstallAudioCodecs::FreeBuffer(LPVOID lpBuffer)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifAudio, this);	// the containing object
	HRESULT hr = NOERROR;

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::FreeBuffer\n"));

	hr = This->FreeBuffer(lpBuffer);

	if (FAILED(hr))
	{
		ERRORMSG(("CInstallAudioCodecs::FreeBuffer failed, hr=0x%x\n", hr));
	}

	DEBUGMSG(ZONE_INSTCODEC,("CInstallAudioCodecs::FreeBuffer - leave, hr=0x%x\n", hr));
	return This->TranslateHr(hr);
}

/***************************************************************************

	CInstallVideoCodecs

***************************************************************************/
/****************************************************************************
 *  @doc  EXTERNAL COMPFUNC VIDEO
 ***************************************************************************/
/***************************************************************************

    IUnknown Methods

	Calling the containing object respective methods

***************************************************************************/
/****************************************************************************
 *
 *  @method HRESULT | IInstallVideoCodecs | QueryInterface | QueryInterface
 *
 ***************************************************************************/
HRESULT CInstallVideoCodecs::QueryInterface (REFIID riid, LPVOID *lppNewObj)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifVideo, this);	// the containing object

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::QueryInterface\n"));

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::QueryInterface - leave\n"));
	return (This->QueryInterface(riid, lppNewObj));

}

/****************************************************************************
 *
 *  @method ULONG | IInstallVideoCodecs | AddRef | AddRef
 *
 ***************************************************************************/
ULONG CInstallVideoCodecs::AddRef (void)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifVideo, this);	// the containing object

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::AddRef\n"));

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::AddRef - leave\n"));
	return (This->AddRef());
}

/****************************************************************************
 *
 *  @method ULONG | IInstallVideoCodecs | Release | Release
 *
 ***************************************************************************/
ULONG CInstallVideoCodecs::Release (void)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifVideo, this);	// the containing object

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::Release\n"));

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::Release - leave\n"));
	return (This->Release());
}

/****************************************************************************
 *
 *	AddVCMFormat
 *
 *  @method HRESULT | IInstallVideoCodecs | AddVCMFormat | Adds an video encoding
 *		format for use with	NetMeeting
 *
 *  @parm PAUDCAP_INFO | pVidCapInfo | Information on the format to add
 *
 *  @rdesc Returns zero (NOERROR) if the function was successful. Otherwise, it returns
 *      a standard HRESULT, with the WIN32 facility code (7), or the specific facility
 *		code for installable codecs (0x301).
 *		Possible error codes:
 *		@flag E_INVALIDARG | Invalid argument
 *      @flag IC_E_NO_SUCH_FORMAT | The specified format was not found. The format
 *			must be installed with Video For Windows before it can be added for use
 *			with NetMeeting.
 *      @flag IC_E_INTERNAL_ERROR | the Network Audio/Video Controller
 *			reported a system error
 *
 ***************************************************************************/
HRESULT CInstallVideoCodecs::AddVCMFormat(PVIDCAP_INFO pVidCapInfo)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifVideo, this);	// the containing object
	HRESULT hr=NOERROR;

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::AddVCMFormat\n"));

	/*
	 *	Add the format
	 */

	hr = AddRemoveVCMFormat(pVidCapInfo, TRUE);

	if (FAILED(hr))
	{
		ERRORMSG(("CInstallVideoCodecs::AddVCMFormat failed, hr=0x%x\n", hr));
	}

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::AddVCMFormat - leave\n"));
	return This->TranslateHr(hr);
}

/****************************************************************************
 *
 *	RemoveVCMFormat
 *
 *  @method HRESULT | IInstallVideoCodecs | RemoveVCMFormat | Removes an video
 *		format from the list of formats used by NetMeeting
 *
 *  @parm PVIDCAP_INFO | pVidCapInfo | Pointer to the PVIDCAP_INFO structure
 *		describing the format to remove
 *
 *  @rdesc Returns zero (NOERROR) if the function was successful. Otherwise, it returns
 *      a standard HRESULT, with the WIN32 facility code (0x7), or the specific facility
 *		code for installable codecs (0x301).
 *		Possible error codes:
 *		@flag E_INVALIDARG | Invalid argument
 *      @flag IC_E_NO_SUCH_FORMAT | The specified format was not found.
 *      @flag IC_E_INTERNAL_ERROR | the Network Audio/Video Controller
 *			reported a system error
 *
 ***************************************************************************/
HRESULT CInstallVideoCodecs::RemoveVCMFormat(PVIDCAP_INFO pVidCapInfo)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifVideo, this);	// the containing object
	HRESULT hr=NOERROR;

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::RemoveVCMFormat\n"));

	/*
	 *	Remove the format
	 */

	hr = AddRemoveVCMFormat(pVidCapInfo, FALSE);

	if (FAILED(hr))
	{
		ERRORMSG(("CInstallVideoCodecs::RemoveVCMFormat failed, hr=0x%x\n", hr));
	}

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::RemoveVCMFormat - leave\n"));
	return This->TranslateHr(hr);
}

/****************************************************************************
 *
 *	ReorderFormats
 *
 *  @method HRESULT | IInstallVideoCodecs | ReorderFormats | Reorders the video
 *		formats for use with Netmeeting
 *
 *  @parm PVIDCAP_INFO_LIST | pVidCapInfoList | Pointer to a structure with a count
 *		and a pointer to a list of the formats to reorder. The list is of the
 *		format VIDCAP_INFO_LIST.
 *
 *  @rdesc Returns zero (NOERROR) if the function was successful. Otherwise, it returns
 *      a standard HRESULT, with the WIN32 facility code (7), or the specific facility
 *		code for installable codecs (0x301).
 *		Possible error codes:
 *		@flag E_INVALIDARG | Invalid argument
 *      @flag IC_E_INTERNAL_ERROR | the Network Audio/Video Controller
 *      reported a system error
 *
 *	@comm Since ReorderFormats can only reorder formats that are known to NetMeeting,
 *		it is recommended that the caller will first call EnumFormats, to get the
 *		of all formats known to NetMeeting, assign new sort indices (wSortIndex),
 *		and then call ReorderFormats with the modified list.
 *
 *	@comm Arranging the formats in a specific order, by using ReorderFormats, does
 *		not guarantee that the top ranked formats will be used before lower ranked
 *		formats are used. For example, if the sending system is not capable of
 *		encoding a top ranked format, this format will not be used. The same
 *		will happen if the receiving system cannot decode this format.
 *
 ***************************************************************************/
HRESULT CInstallVideoCodecs::ReorderFormats(PVIDCAP_INFO_LIST pVidCapInfoList)
{
 	CInstallCodecs *This=IMPL(CInstallCodecs, ifVideo, this);	// the containing object
	HRESULT hr=NOERROR;

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::ReorderFormats\n"));

	/*
	 *	Parameter validation
	 */

	if (!pVidCapInfoList ||
		IsBadReadPtr(pVidCapInfoList, sizeof(DWORD)) ||
		IsBadReadPtr(pVidCapInfoList,
				sizeof(VIDCAP_INFO_LIST) + ((pVidCapInfoList->cFormats-1) * sizeof(VIDCAP_INFO))))
	{
		hr = E_INVALIDARG;
		goto out;
	}

	hr = This->m_pVidAppCaps->ApplyAppFormatPrefs(pVidCapInfoList->aFormats,
													pVidCapInfoList->cFormats);

out:
	if (FAILED(hr))
	{
		ERRORMSG(("CInstallVideoCodecs::ReorderFormats failed, hr=0x%x\n", hr));
	}

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::ReorderFormats - leave\n"));
	return This->TranslateHr(hr);
}

/****************************************************************************
 *
 *	EnumFormats
 *
 *  @method HRESULT | IInstallVideoCodecs | EnumFormats | Enumerates the video
 *		codec formats known to NetMeeting
 *
 *  @parm PVIDCAP_INFO_LIST * | ppVidCapInfoList | Address where this method
 *		will put a pointer to a VIDCAP_INFO_LIST list, where enumerated formats
 *		are listed.
 *
 *  @rdesc Returns zero (NOERROR) if the function was successful. Otherwise, it returns
 *      a standard HRESULT, with the WIN32 facility code (7), or the specific facility
 *		code for installable codecs (0x301).
 *		Possible error codes:
 *		@flag E_INVALIDARG | Invalid argument
 *		@flag E_OUTOFMEMORY | Not enough memory for allocating the enumeration buffer
 *		@flag IC_E_NO_FORMATS | No formats were available to enumerate
 *      @flag IC_E_INTERNAL_ERROR | the Network Audio/Video Controller
 *      reported a system error
 *
 *	@comm The caller is expected to free the returned list, by calling FreeBuffer
 *		on the same interface.
 *
 ***************************************************************************/
HRESULT CInstallVideoCodecs::EnumFormats(PVIDCAP_INFO_LIST *ppVidCapInfoList)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifVideo, this);	// the containing object
	ULONG cFormats = 0;
	UINT uBufSize = 0;
	HRESULT hr=NOERROR;

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::EnumFormats\n"));

	/*
	 *	Parameter validation
	 */

	if (!ppVidCapInfoList ||
		IsBadWritePtr(ppVidCapInfoList, sizeof(PVIDCAP_INFO_LIST)))
	{
		hr = E_INVALIDARG;
		goto out;
	}

	// nothing yet....
	*ppVidCapInfoList = NULL;

	// are there any formats ?
	if (HR_FAILED(This->m_pVidAppCaps->GetNumFormats((UINT *) &cFormats))	||
		(cFormats == 0))
	{
		hr = IC_E_NO_FORMATS;
		goto out;
	}

	// allocate a buffer for the call. the caller is expected to call
	// FreeBuffer to free
	// VIDCAP_INFO_LIST already includes one VIDCAP_INFO
	uBufSize = sizeof(VIDCAP_INFO_LIST) + (cFormats-1) * sizeof(VIDCAP_INFO);
	*ppVidCapInfoList = (PVIDCAP_INFO_LIST) MEMALLOC (uBufSize);
	if (!(*ppVidCapInfoList))
	{
		hr = E_OUTOFMEMORY;
		goto out;
	}
		
	hr = This->m_pVidAppCaps->EnumFormats((*ppVidCapInfoList)->aFormats, uBufSize,
											(UINT *) &((*ppVidCapInfoList)->cFormats));

out:
	if (FAILED(hr))
	{
		ERRORMSG(("CInstallVideoCodecs::EnumFormats failed, hr=0x%x\n", hr));
	}

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::EnumFormats - leave\n"));
	return This->TranslateHr(hr);
}

/****************************************************************************
 *
 *	FreeBuffer
 *
 *  @method HRESULT | IInstallVideoCodecs | FreeBuffer | Free a buffer that was
 *		returned by the IInstallVideoCodec interface
 *
 *  @parm LPVOID | lpBuffer | Address of the buffer to free. This buffer must have
 *		been allocated by one of the IInstallVideoCodecs methods
 *
 *  @rdesc Returns zero (NOERROR) if the function was successful. Otherwise, it returns
 *      a standard HRESULT, with the WIN32 facility code (7), or the specific facility
 *		code for installable codecs (0x301).
 *		Possible error codes:
 *		None
 *
 ***************************************************************************/
HRESULT CInstallVideoCodecs::FreeBuffer(LPVOID lpBuffer)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifVideo, this);	// the containing object
	HRESULT hr = NOERROR;

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::FreeBuffer\n"));

	hr = This->FreeBuffer(lpBuffer);

	if (FAILED(hr))
	{
		ERRORMSG(("CInstallVideoCodecs::FreeBuffer failed, hr=0x%x\n", hr));
	}

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::FreeBuffer - leave, hr=0x%x\n", hr));
	return This->TranslateHr(hr);
}

/****************************************************************************
 *  @doc  INTERNAL COMPFUNC
 ***************************************************************************/
/****************************************************************************
 *
 *	AddRemoveVCMFormat
 *
 *  @method HRESULT | IInstallVideoCodecs | AddRemoveVCMFormat | Adds or
 *		removes a VCM format for use with NetMeeting
 *
 *  @parm PAUDCAP_INFO | pVidCapInfo | Information on the format to add/remove
 *
 *	@parm BOOL | bAdd | TRUE = Add the format, FALSE = Remove the format
 *
 *  @rdesc Returns zero (NOERROR) if the function was successful. Otherwise, it returns
 *      a standard HRESULT, with the WIN32 facility code (7), or the specific facility
 *		code for installable codecs (0x301).
 *		Possible error codes:
 *		@flag E_INVALIDARG | Invalid argument
 *      @flag IC_E_NO_SUCH_FORMAT | The specified format was not found. The format
 *			must be installed with Video For Windows before it can be added for use
 *			with NetMeeting.
 *      @flag IC_E_INTERNAL_ERROR | the Network Audio/Video Controller
 *			reported a system error
 *
 ***************************************************************************/
HRESULT CInstallVideoCodecs::AddRemoveVCMFormat(PVIDCAP_INFO pVidCapInfo,
												BOOL bAdd)
{
	CInstallCodecs *This=IMPL(CInstallCodecs, ifVideo, this);	// the containing object
	VIDEOFORMATEX vfx;
	HRESULT hr=NOERROR;

	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::AddVCMFormat\n"));

	/*
	 *	Parameter validation
	 */

	if (!pVidCapInfo ||
		IsBadReadPtr(pVidCapInfo, (UINT) sizeof(VIDCAP_INFO)))
	{
		hr = E_INVALIDARG;
		goto out;
	}

	// some fields should not be zero
	if ((pVidCapInfo->uFrameRate == 0)	||
		(pVidCapInfo->uAvgBitrate == 0)	||
		((pVidCapInfo->dwBitsPerSample == 0) &&
		 (pVidCapInfo->bih.biBitCount == 0)))
	{
		hr = E_INVALIDARG;
		goto out;
	}

	// make sure dwBitsPerSample and biBitCount match
	if (pVidCapInfo->dwBitsPerSample == 0)
		pVidCapInfo->dwBitsPerSample = pVidCapInfo->bih.biBitCount;
	if (pVidCapInfo->bih.biBitCount == 0)
		pVidCapInfo->bih.biBitCount = LOWORD(pVidCapInfo->dwBitsPerSample);
			
	if (LOWORD(pVidCapInfo->dwBitsPerSample) != pVidCapInfo->bih.biBitCount)
	{
		hr = E_INVALIDARG;
		goto out;
	}

	/*
	 *	Make a VIDEOFORMATEX structure
	 */

	RtlZeroMemory((PVOID) &vfx, sizeof(VIDEOFORMATEX));


	// Make sure it's Upper Case
	if (pVidCapInfo->dwFormatTag > 256)
		CharUpperBuff((LPTSTR)&pVidCapInfo->dwFormatTag, sizeof(DWORD));

	vfx.dwFormatTag = pVidCapInfo->dwFormatTag;

	vfx.nSamplesPerSec = pVidCapInfo->uFrameRate;
	vfx.wBitsPerSample = pVidCapInfo->dwBitsPerSample;	// wBitPerSample is a DWORD
	vfx.nAvgBytesPerSec = pVidCapInfo->uAvgBitrate;
	RtlCopyMemory(&vfx.bih,	&pVidCapInfo->bih, sizeof(BITMAPINFOHEADER));

	/*
	 *	Add or remove the format
	 */

	if (bAdd)
		hr = This->m_pVidAppCaps->AddVCMFormat(&vfx, pVidCapInfo);
	else
		hr = This->m_pVidAppCaps->RemoveVCMFormat(&vfx);

out:
	DEBUGMSG(ZONE_INSTCODEC,("CInstallVideoCodecs::AddRemoveVCMFormat - leave\n"));
	return This->TranslateHr(hr);
}


/***************************************************************************

    Name      : CInstallCodecs::CInstallCodecs

    Purpose   : The CInstallCodecs object constructor

    Parameters: none

    Returns   : None

    Comment   :

***************************************************************************/
inline CInstallCodecs::CInstallCodecs (void)
{
	m_cRef = 0;	// will be bumped to 1 by the explicit QI in the create function
	m_pAudAppCaps = NULL;
	m_pVidAppCaps = NULL;

	// can't use ++ because RISC processors may translate to several instructions
	InterlockedIncrement((long *) &g_cICObjects);
}

/***************************************************************************

    Name      : CInstallCodecs::~CInstallCodecs

    Purpose   : The CInstallCodecs object destructor

    Parameters: none

    Returns   : None

    Comment   :

***************************************************************************/
inline CInstallCodecs::~CInstallCodecs (void)
{
	// let the caps interfaces and objects go
	if (m_pAudAppCaps)
		m_pAudAppCaps->Release();
	if (m_pVidAppCaps)
		m_pVidAppCaps->Release();

	// can't use ++ because RISC processors may translate to several instructions
	if (!InterlockedDecrement((long *) &g_cICObjects))
	{
		if (g_hMutex)
			CloseHandle(g_hMutex);
		g_hMutex = NULL;
	}

	g_pIC = (CInstallCodecs *)NULL;

}

/***************************************************************************

    Name      : CInstallCodecs::FreeBuffer

    Purpose   : Frees a buffer allocated by the the installable codecs interfaces.

    Parameters: lpBuffer - a pointer to the buffer to free. This buffer must
					have been allocated by installable codecs interfaces

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CInstallCodecs::FreeBuffer(LPVOID lpBuffer)
{
	HRESULT hr = NOERROR;

	DEBUGMSG(ZONE_INSTCODEC,("CInstallCodecs::FreeBuffer\n"));

	if (lpBuffer)
		MEMFREE(lpBuffer);

	DEBUGMSG(ZONE_INSTCODEC,("CInstallCodecs::FreeBuffer - leave, hr=0x%x\n", hr));
	return TranslateHr(hr);
}

/***************************************************************************

    Name      : CInstallCodecs::TranslateHr

    Purpose   : Translates an HRESULT to an external installable codecs value

    Parameters: hr - [in] the HRESULT value to translate

    Returns   : HRESULT - the translated value

    Comment   :

***************************************************************************/
HRESULT CInstallCodecs::TranslateHr(HRESULT hr)
{
	switch (hr)
	{
	
	case CAPS_E_NOMATCH:
		hr = IC_E_NO_SUCH_FORMAT;
		break;

	case CAPS_E_INVALID_PARAM:
		hr = E_INVALIDARG;
		break;

	case CAPS_E_SYSTEM_ERROR:
		hr = IC_E_INTERNAL_ERROR;
		break;
	
	default:
		break;
	}

	return hr;
}

/****************************************************************************
 *
 *	Initialize
 *
 *  @func HRESULT | Initialize | Initializes the CinstallCodecs object
 *
 *  @parm REFIID | riid | Reference to the identifier of the interface
 *
 *  @rdesc Returns zero (NOERROR) if the function was successful. Otherwise, it returns
 *      a standard HRESULT, with the WIN32 facility code (7), or the specific facility
 *		code for installable codecs (0x301).
 *		Possible error codes:
 *		@flag E_INVALIDARG | Invalid argument
 *		@flag E_OUTOFMEMORY | Not enough memory for creating the object
 *      @flag IC_E_CAPS_INSTANTIATION_FAILURE | Could not instantiate a capability object
 *      @flag IC_E_CAPS_INITIALIZATION_FAILURE | Could not initialize a capability object
 *
 ***************************************************************************/
HRESULT CInstallCodecs::Initialize(REFIID riid)
{
	HRESULT hr=NOERROR;
	CMsiaCapability *pAudCapObj = NULL;
	CMsivCapability *pVidCapObj = NULL;

	/*
	 *	Instantiate
	 */

	ACQMUTEX(g_hMutex);

	/*
	 *	Audio
	 */

	if ((riid == IID_IInstallAudioCodecs)	&&
		!m_pAudAppCaps)
	{
		// instantiate the audio capability object
        DBG_SAVE_FILE_LINE
		pAudCapObj = new CMsiaCapability;

		if (!pAudCapObj)
		{
			hr = IC_E_CAPS_INSTANTIATION_FAILURE;
   			goto out;
		}

		// get an appcap interface on the capability objects
		// this interface will be used for most calls
		hr = pAudCapObj->QueryInterface(IID_IAppAudioCap, (void **)&m_pAudAppCaps);
		if(!HR_SUCCEEDED(hr))
		{
			hr = IC_E_CAPS_INSTANTIATION_FAILURE;
			goto out;
		}
		pAudCapObj->Release(); // this balances the refcount of "new CMsiaCapability"

		// initialize the capability objects
		if (!(pAudCapObj->Init()))
		{
			hr = IC_E_CAPS_INITIALIZATION_FAILURE;
   			goto out;
		}
	}

	/*
	 *	Video
	 */

	if ((riid == IID_IInstallVideoCodecs)	&&
		!m_pVidAppCaps)
	{
		// instantiate the video capability object
        DBG_SAVE_FILE_LINE
		pVidCapObj = new CMsivCapability;

		if (!pVidCapObj)
		{
			hr = IC_E_CAPS_INSTANTIATION_FAILURE;
   			goto out;
		}
		// get an appcap interface on the capability objects
		// this interface will be used for most calls
		hr = pVidCapObj->QueryInterface(IID_IAppVidCap, (void **)&m_pVidAppCaps);
		if(!HR_SUCCEEDED(hr))
		{
			hr = IC_E_CAPS_INSTANTIATION_FAILURE;
			goto out;
		}
		pVidCapObj->Release(); // this balances the refcount of "new CMsivCapability"

		if (!(pVidCapObj->Init()))
		{
			hr = IC_E_CAPS_INITIALIZATION_FAILURE;
   			goto out;
		}
	}

out:
	if (FAILED(hr))
	{
		ERRORMSG(("CInstallCodecs::Initialize failed, hr=0x%x\n", hr));
	}

	RELMUTEX(g_hMutex);
	return TranslateHr(hr);
}


/****************************************************************************
 *  @doc  EXTERNAL COMPFUNC
 ***************************************************************************/
/****************************************************************************
 *
 *	CreateInstallCodecs
 *
 *  @func HRESULT | CreateInstallCodecs | Creates an instance of the CInstallCodecs
 *		object, and returns	the requested interface. This function should only be
 *		called indirectly through CoCreateInstance.
 *  @parm LPUNKNOWN | punkOuter | Pointer to whether object is or isnt part
 *		of an aggregate
 *
 *  @parm REFIID | riid | Reference to the identifier of the interface
 *
 *  @parm LPVOID * | ppv | Indirect pointer to requested interface
 *
 *  @rdesc Returns zero (NOERROR) if the function was successful. Otherwise, it returns
 *      a standard HRESULT, with the WIN32 facility code (7), or the specific facility
 *		code for installable codecs (0x301).
 *		Possible error codes:
 *		@flag E_INVALIDARG | Invalid argument
 *		@flag E_OUTOFMEMORY | Not enough memory for creating the object
 *      @flag CLASS_E_NOAGGREGATION | Aggregation is not supported for this object
 *      @flag IC_E_CAPS_INSTANTIATION_FAILURE | Could not instantiate a capability object
 *      @flag IC_E_CAPS_INITIALIZATION_FAILURE | Could not initialize a capability object
 *
 *	@comm CreateInstallCodecs should not be called directly. Clients of installable
 *		codecs should use the COM CoCreateInstance to instantiate the object, expecting
 *		the same return values.
 *
 ***************************************************************************/
extern "C" HRESULT WINAPI CreateInstallCodecs (	IUnknown *pUnkOuter,
												REFIID riid,
												void **ppv)
{
	CInstallCodecs *pIC;
	HRESULT hr = NOERROR;

	*ppv = 0;
	if (pUnkOuter)
	{
		hr = CLASS_E_NOAGGREGATION;
		goto out;
	}

	/*
	 *	instantiate the object
	 */

	// create a mutex to control access to QoS object data
	//
	// NOTE: I'm taking some chance here: the code that creates the mutex must be
	// executed by one thread at a time, so it should really be in the PROCESS_ATTACH
	// for NAC.DLL. However, since this code is expected to be called rarely, and in
	// order not to add code to the NAC load time, I put it here.
	if (!g_hMutex)
	{
		g_hMutex = CreateMutex(NULL, FALSE, NULL);
		ASSERT(g_hMutex);
		if (!g_hMutex)
		{
			ERRORMSG(("CreateInstallCodecs: CreateMutex failed, 0x%x\n", GetLastError()));
			hr = E_FAIL;
			goto out;
		}
	}

	ACQMUTEX(g_hMutex);


	// only instantiate a new object if it doesn't already exist
	if (!g_pIC)
	{
        DBG_SAVE_FILE_LINE
		if (!(pIC = new CInstallCodecs))
		{
			hr = E_OUTOFMEMORY;
			RELMUTEX(g_hMutex);
			goto out;
		}

		// Save pointer
		g_pIC = pIC;
	}
	else
	{
		// this is the case when the object was already instantiaed in this
		// process, so we only want to return the object pointer.
		pIC = g_pIC;
	}

	// always initialize the object. Initialize will only initialize what
	// is not yet initialized
	hr = pIC->Initialize(riid);

	RELMUTEX(g_hMutex);

	// get the requested interface for the caller
	if (pIC)
	{
		// QueryInterface will get us the interface pointer and will AddRef
		// the object
		hr = pIC->QueryInterface (riid, ppv);
	}
	else
		hr = E_FAIL;

out:
	if (FAILED(hr))
	{
		ERRORMSG(("CreateInstallCodecs failed, hr=0x%x\n", hr));
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\medictrl.cpp ===
#include "precomp.h"

extern HANDLE g_hEventHalfDuplex;


///////////////////////////////////////////////////////
//
//  Public methods
//


MediaControl::MediaControl ( void )
{
	_Construct ();
}


MediaControl::~MediaControl ( void )
{
	_Destruct ();
}

HRESULT MediaControl::Initialize ( MEDIACTRLINIT * p )
{
	HRESULT hr = DPR_SUCCESS;
	DEBUGMSG (ZONE_VERBOSE, ("MediaControl::Initialize: enter.\r\n"));

	m_dwFlags = p->dwFlags;
	m_hEvent = NULL;

	m_uDuration = MC_DEF_DURATION;
	
	DEBUGMSG (ZONE_VERBOSE, ("MediaControl::Initialize: exit, hr=0x%lX\r\n",  hr));

	m_hEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
	if (m_hEvent == NULL)
	{
		hr = DPR_CANT_CREATE_EVENT;
	}

	return hr;
}

HRESULT MediaControl::RegisterData ( PVOID pDataPtrArray, ULONG cElements )
{
	HRESULT hr;

	if (pDataPtrArray == NULL) return DPR_INVALID_PARAMETER;

	m_ppMediaPkt = (MediaPacket **) pDataPtrArray;
	m_cMediaPkt = cElements;
	hr = DPR_SUCCESS;

	return hr;
}


HRESULT MediaControl::FillMediaPacketInit ( MEDIAPACKETINIT * p )
{
	if (p == NULL) return DPR_INVALID_PARAMETER;

	p->pDevFmt = m_pDevFmt;

	p->cbSizeDevData = m_cbSizeDevData;
	p->cbOffsetDevData = 0;

	return DPR_SUCCESS;
}


HRESULT MediaControl::SetProp ( DWORD dwPropId, DWORD_PTR dwPropVal )
{
	HRESULT hr = DPR_SUCCESS;
	MMRESULT mmr;

	switch (dwPropId)
	{
	case MC_PROP_MEDIA_STREAM:
		m_hStrm = (DPHANDLE) dwPropVal;
		break;

	case MC_PROP_MEDIA_DEV_HANDLE:
		m_hDev = (DPHANDLE) dwPropVal;
		break;

	case MC_PROP_MEDIA_DEV_ID:
		m_uDevId = (UINT) dwPropVal;
		break;

	case MC_PROP_MEDIA_FORMAT:
		m_pDevFmt = (PVOID) dwPropVal;
		break;

	case MC_PROP_SIZE:
		m_cbSizeDevData = (DWORD)dwPropVal;
		break;

	case MC_PROP_PLATFORM:
		m_dwFlags = (DWORD)((m_dwFlags & ~DP_MASK_PLATFORM) | (dwPropVal & DP_MASK_PLATFORM));
		break;

	case MC_PROP_DURATION:
		m_uDuration = (DWORD)dwPropVal;
		break;

	case MC_PROP_DUPLEX_TYPE:
		m_dwFlags = (DWORD)((m_dwFlags & ~DP_MASK_DUPLEX) | (dwPropVal & DP_MASK_DUPLEX));
		break;

	case MC_PROP_STATE:
		hr = DPR_IMPOSSIBLE_SET_PROP;
		break;

	case MC_PROP_AUDIO_JAMMED:
		m_fJammed = (DWORD)dwPropVal;
		break;

	default:
		hr = DPR_INVALID_PROP_ID;
		break;
	}

	return hr;
}


HRESULT MediaControl::GetProp ( DWORD dwPropId, PDWORD_PTR pdwPropVal )
{
	HRESULT hr = DPR_SUCCESS;

	if (pdwPropVal)
	{
		switch (dwPropId)
		{
		case MC_PROP_MEDIA_STREAM:
			*pdwPropVal = (DWORD_PTR) m_hStrm;
			break;

		case MC_PROP_MEDIA_DEV_HANDLE:
			*pdwPropVal = (DWORD_PTR) m_hDev;
			break;

		case MC_PROP_MEDIA_DEV_ID:
			*pdwPropVal = (DWORD) m_uDevId;
			break;

		case MC_PROP_MEDIA_FORMAT:
			*pdwPropVal = (DWORD_PTR) m_pDevFmt;
			break;

		case MC_PROP_SIZE:
			*pdwPropVal = (DWORD) m_cbSizeDevData;
			break;

		case MC_PROP_PLATFORM:
			*pdwPropVal = m_dwFlags & DP_MASK_PLATFORM;
			break;

		case MC_PROP_STATE:
			*pdwPropVal = m_uState;
			break;

		case MC_PROP_DURATION:
			*pdwPropVal = m_uDuration;
			break;

		case MC_PROP_DUPLEX_TYPE:
			*pdwPropVal = m_dwFlags & DP_MASK_DUPLEX;
			break;
			
		case MC_PROP_EVENT_HANDLE:
			*pdwPropVal = (DWORD_PTR) m_hEvent;
			break;

		case MC_PROP_AUDIO_JAMMED:
			*pdwPropVal = (DWORD)(m_fJammed ? TRUE : FALSE);
			break;

		default:
			hr = DPR_INVALID_PROP_ID;
			break;
		}
	}
	else
	{
		hr = DPR_INVALID_PARAMETER;
	}

	return hr;
}



HRESULT MediaControl::PrepareHeaders ( void )
{
	HRESULT hr = DPR_SUCCESS;
	MediaPacket **pp;
	ULONG uc;

	if (m_hDev)
	{
		if (m_ppMediaPkt == NULL)
		{
			hr = DPR_INVALID_PARAMETER;
			goto MyExit;
		}

		for (uc = m_cMediaPkt, pp = m_ppMediaPkt; uc--; pp++)
		{
			if (*pp)
			{
				hr = (*pp)->Open (MP_TYPE_DEV, m_hDev);
				if (hr != DPR_SUCCESS)
				{
					goto MyExit;
				}
			}
		}
	}

MyExit:

	return hr;
}


HRESULT MediaControl::UnprepareHeaders ( void )
{
	HRESULT hr = DPR_SUCCESS;
	MediaPacket **pp;
	ULONG uc;

	if (m_hDev)
	{
		if (m_ppMediaPkt == NULL)
		{
			hr = DPR_INVALID_PARAMETER;
			goto MyExit;
		}

		for (uc = m_cMediaPkt, pp = m_ppMediaPkt; uc--; pp++)
		{
			if (*pp)
			{
				hr = (*pp)->Close (MP_TYPE_DEV);
				if (hr != DPR_SUCCESS)
				{
					goto MyExit;
				}
			}
		}

                //
                // LAURABU 11/24/99
                // Messes up pausing/unpausing audio
                // Had added this to fix faults pausing/unpausing video
                //
                // m_cMediaPkt = 0;
                // m_ppMediaPkt = NULL;
                //
	}

MyExit:

	return hr;
}


HRESULT MediaControl::Release ( void )
{
	_Destruct ();
	return DPR_SUCCESS;
}


///////////////////////////////////////////////////////
//
//  Private methods
//


void MediaControl::_Construct ( void )
{
	m_dwFlags = 0;

	m_hStrm = NULL;

	m_uDevId = 0;

	m_hDev = NULL;
	m_pDevFmt = NULL;
	m_uDuration = 0;
	m_cbSizeDevData = 0;

	m_uState = 0;

	m_hEvent = NULL;

	m_ppMediaPkt = NULL;
	m_cMediaPkt = 0;

	m_fJammed = FALSE;
}


void MediaControl::_Destruct ( void )
{
	if (m_hDev) {
	// waveInOut/UnprepareHeaders() and waveIn/OutClose() can fail if the
	// device is still playing.  Need to Reset() first!
		Reset();
		UnprepareHeaders ();
		Close ();
	}

	if (m_hEvent)
	{
		CloseHandle (m_hEvent);
		m_hEvent = NULL;
	}
}

WaveInControl::WaveInControl()
{
}

WaveInControl::~WaveInControl()
{
}

WaveOutControl::WaveOutControl()
{
	m_uPosition = 0;
	m_uVolume = 0;
}

WaveOutControl::~WaveOutControl()
{
}

HRESULT WaveInControl::Initialize ( MEDIACTRLINIT * p )
{
	HRESULT hr = DPR_SUCCESS;
	DEBUGMSG (ZONE_VERBOSE, ("WaveInControl::Initialize: enter.\r\n"));

	if ((hr =MediaControl::Initialize( p)) != DPR_SUCCESS)
		return hr;
	
	m_uTimeout = MC_DEF_RECORD_TIMEOUT;
	
	m_uPrefeed = MC_DEF_RECORD_BUFS;
	
	m_uSilenceDuration = MC_DEF_SILENCE_DURATION;

	DEBUGMSG (ZONE_VERBOSE, ("WaveInControl::Initialize: exit, hr=0x%lX\r\n",  hr));

	return hr;
}



HRESULT WaveOutControl::Initialize ( MEDIACTRLINIT * p )
{
	HRESULT hr = DPR_SUCCESS;
	DEBUGMSG (ZONE_VERBOSE, ("WaveOutControl::Initialize: enter.\r\n"));

	if ((hr =MediaControl::Initialize( p)) != DPR_SUCCESS)
		return hr;
		
	m_uTimeout = MC_DEF_PLAY_TIMEOUT;
	
	m_uPrefeed = MC_DEF_PLAY_BUFS;
	
	m_uVolume = MC_DEF_VOLUME;

	DEBUGMSG (ZONE_VERBOSE, ("WaveOutControl::Initialize: exit, hr=0x%lX\r\n",  hr));

	return hr;
}


HRESULT WaveInControl::Configure ( MEDIACTRLCONFIG * p )
{
	HRESULT hr = DPR_SUCCESS;
	UINT uBlockAlign;

	DEBUGMSG (ZONE_VERBOSE, ("WaveInControl::Configure: enter.\r\n"));


	m_hStrm = p->hStrm;
	m_uDevId = p->uDevId;
	m_pDevFmt = p->pDevFmt;

	if (m_pDevFmt == NULL) return DPR_INVALID_PARAMETER;


	if ((m_uDuration = p->uDuration) == MC_USING_DEFAULT)
	{
		m_cbSizeDevData = ((WAVEFORMAT *) m_pDevFmt)->nAvgBytesPerSec * p->cbSamplesPerPkt
			/((WAVEFORMAT *) m_pDevFmt)->nSamplesPerSec;
		m_uDuration = p->cbSamplesPerPkt*1000 /((WAVEFORMAT *) m_pDevFmt)->nSamplesPerSec;
	} else {
	// roughly calculate the buffer size based on 20ms
	m_cbSizeDevData = ((WAVEFORMAT *) m_pDevFmt)->nAvgBytesPerSec
									* m_uDuration / 1000;

	// need to be on the block alignment boundary
	uBlockAlign = ((WAVEFORMAT *) m_pDevFmt)->nBlockAlign;
	m_cbSizeDevData = ((m_cbSizeDevData + uBlockAlign - 1) / uBlockAlign)
									* uBlockAlign;
	}


	DEBUGMSG (ZONE_VERBOSE, ("WaveInControl::Configure: exit, hr=0x%lX\r\n",  hr));

	return hr;
}


HRESULT WaveOutControl::Configure ( MEDIACTRLCONFIG * p )
{
	HRESULT hr = DPR_SUCCESS;
	UINT uBlockAlign;

	DEBUGMSG (ZONE_VERBOSE, ("WaveOutControl::Configure: enter.\r\n"));


	m_hStrm = p->hStrm;
	m_uDevId = p->uDevId;
	m_pDevFmt = p->pDevFmt;
	
	if (m_pDevFmt == NULL) return DPR_INVALID_PARAMETER;


	if ((m_uDuration = p->uDuration) == MC_USING_DEFAULT)
	{
		m_cbSizeDevData = ((WAVEFORMAT *) m_pDevFmt)->nAvgBytesPerSec * p->cbSamplesPerPkt
			/((WAVEFORMAT *) m_pDevFmt)->nSamplesPerSec;
		m_uDuration = p->cbSamplesPerPkt*1000 /((WAVEFORMAT *) m_pDevFmt)->nSamplesPerSec;
	} else {
	// roughly calculate the buffer size based on 20ms
	m_cbSizeDevData = ((WAVEFORMAT *) m_pDevFmt)->nAvgBytesPerSec
									* m_uDuration / 1000;

	// need to be on the block alignment boundary
	uBlockAlign = ((WAVEFORMAT *) m_pDevFmt)->nBlockAlign;
	m_cbSizeDevData = ((m_cbSizeDevData + uBlockAlign - 1) / uBlockAlign)
									* uBlockAlign;
	}

	DEBUGMSG (ZONE_VERBOSE, ("MediaControl::Configure: exit, hr=0x%lX\r\n",  hr));

	return hr;
}


HRESULT WaveInControl::Open ( void )
{
	HRESULT hr = DPR_INVALID_PLATFORM;
	MMRESULT mmr;
	DWORD dwfOpen;
	UINT uDevId;

	m_hDev = NULL;

	dwfOpen = CALLBACK_EVENT;
	uDevId = (m_uDevId == (UINT) -1) ? WAVE_MAPPER : m_uDevId;
	mmr = waveInOpen ((HWAVEIN *) &m_hDev, uDevId,
					  (WAVEFORMATEX *) m_pDevFmt,
					  (DWORD_PTR) m_hEvent, 0, dwfOpen);
	// begin hack
	if (mmr == WAVERR_BADFORMAT && uDevId != WAVE_MAPPER) {
		// the sound card probably doesnt support our sample size or sample rate
		// (16 bit, 8Khz)
		// Try using the WAVE_MAPPER. The WAVE_MAPPER may end up using
		// a different device than the one we wanted !!
		DEBUGMSG (1, ("MediaControl::Open: bad format, trying WAVE_MAPPER\r\n" ));
		mmr = waveInOpen ((HWAVEIN *) &m_hDev, WAVE_MAPPER,
					  (WAVEFORMATEX *) m_pDevFmt,
					  (DWORD_PTR) m_hEvent, 0, dwfOpen);
		if (mmr == MMSYSERR_NOERROR)
			m_uDevId = (UINT) -1;	// use WAVE_MAPPER next time
	}
	
	// end hack
	if (mmr != MMSYSERR_NOERROR)
	{
		DEBUGMSG (1, ("MediaControl::Open: waveInOpen failed, mmr=%ld\r\n", (ULONG) mmr));
		hr = DPR_CANT_OPEN_WAVE_DEV;
		goto MyExit;
	}
	else
	{
		hr = DPR_SUCCESS;
	}

MyExit:

	return hr;
}



HRESULT WaveOutControl::Open ( void )
{
	HRESULT hr = DPR_INVALID_PLATFORM;
	MMRESULT mmr;
	DWORD dwfOpen;
	UINT uDevId;

	m_hDev = NULL;

	dwfOpen = CALLBACK_EVENT;
	uDevId = (m_uDevId == (UINT) -1) ? WAVE_MAPPER : m_uDevId;
	mmr = waveOutOpen ((HWAVEOUT *) &m_hDev, uDevId,
					   (WAVEFORMATEX *) m_pDevFmt,
					   (DWORD_PTR) m_hEvent, 0, dwfOpen);
	// begin hack
	if (mmr == WAVERR_BADFORMAT && uDevId != WAVE_MAPPER) {
		// the sound card probably doesnt support our sample size or sample rate
		// (16 bit, 8Khz)
		// Try using the WAVE_MAPPER. The WAVE_MAPPER may end up using
		// a different device than the one we wanted !!
		DEBUGMSG (1, ("MediaControl::Open: bad format, trying WAVE_MAPPER\r\n" ));
		mmr = waveOutOpen((HWAVEOUT *) &m_hDev, WAVE_MAPPER,
				   (WAVEFORMATEX *) m_pDevFmt,
				   (DWORD_PTR) m_hEvent, 0, dwfOpen);
		if (mmr == MMSYSERR_NOERROR)
			m_uDevId = (UINT) -1;	// use WAVE_MAPPER next time
	}
	// end hack
	if (mmr != MMSYSERR_NOERROR)
	{
		DEBUGMSG (1, ("MediaControl::Open: waveOutOpen failed, mmr=%ld\r\n", (ULONG) mmr));
		hr = DPR_CANT_OPEN_WAVE_DEV;
		goto MyExit;
	}
	else
	{
		hr = DPR_SUCCESS;
	}
		
MyExit:

	return hr;
}



HRESULT WaveInControl::Close ( void )
{
	HRESULT hr = DPR_INVALID_PLATFORM;
	MMRESULT mmr;

	if (m_hDev)
	{
		mmr = waveInClose ((HWAVEIN) m_hDev);
		if (mmr != MMSYSERR_NOERROR)
		{
			DEBUGMSG (1, ("MediaControl::CloseAudioDev: waveInClose failed, mmr=%ld\r\n", (ULONG) mmr));
			hr = DPR_CANT_CLOSE_WAVE_DEV;
		}
		else
		{
			hr = DPR_SUCCESS;
		}
	}
	else
	{
		hr = DPR_INVALID_HANDLE;
	}

	m_hDev = NULL;

	return hr;
}


HRESULT WaveOutControl::Close ( void )
{
	HRESULT hr = DPR_INVALID_PLATFORM;
	MMRESULT mmr;

	if (m_hDev)
	{
		mmr = waveOutClose ((HWAVEOUT) m_hDev);
		if (mmr != MMSYSERR_NOERROR)
		{
			DEBUGMSG (1, ("MediaControl::CloseAudioDev: waveOutClose failed, mmr=%ld\r\n", (ULONG) mmr));
			hr = DPR_CANT_CLOSE_WAVE_DEV;
		}
		else
		{
			hr = DPR_SUCCESS;
		}
	}
	else
	{
		hr = DPR_INVALID_HANDLE;
	}

	m_hDev = NULL;

	return hr;
}



HRESULT WaveInControl::Start ( void )
{
	HRESULT hr = DPR_INVALID_PLATFORM;
	MMRESULT mmr;

	if (m_hDev)
	{
		mmr = waveInStart ((HWAVEIN) m_hDev);
		if (mmr != MMSYSERR_NOERROR)
		{
			DEBUGMSG (1, ("MediaControl::StartAudioDev: waveInStart failed, mmr=%ld\r\n", (ULONG) mmr));
			hr = DPR_CANT_START_WAVE_DEV;
		}
		else
		{
			hr = DPR_SUCCESS;
		}
	}
	else
	{
		hr = DPR_INVALID_HANDLE;
	}
	
	return hr;
}

HRESULT WaveOutControl::Start ( void )
{
	return DPR_SUCCESS;
}

HRESULT WaveOutControl::Stop( void )
{
	return DPR_INVALID_PARAMETER;
}

HRESULT WaveInControl::Stop ( void )
{
	HRESULT hr = DPR_INVALID_PLATFORM;
	MMRESULT mmr;

	if (m_hDev)
	{
		mmr = waveInStop ((HWAVEIN) m_hDev);
		if (mmr != MMSYSERR_NOERROR)
		{
			DEBUGMSG (1, ("MediaControl::StopAudioDev: waveInStop failed, mmr=%ld\r\n", (ULONG) mmr));
			hr = DPR_CANT_STOP_WAVE_DEV;
		}
		else
		{
			hr = DPR_SUCCESS;
		}
	}
	else
	{
		hr = DPR_INVALID_HANDLE;
	}

	return hr;
}



HRESULT WaveInControl::Reset ( void )
{
	HRESULT hr;
	MMRESULT mmr;

	if (m_hDev)
	{
		mmr = waveInReset ((HWAVEIN) m_hDev);
		if (mmr != MMSYSERR_NOERROR)
		{
			DEBUGMSG (1, ("MediaControl::ResetAudioDev: waveInReset failed, mmr=%ld\r\n", (ULONG) mmr));
			hr = DPR_CANT_RESET_WAVE_DEV;
		}
		else
		{
			hr = DPR_SUCCESS;
		}
	}
	else
	{
		hr = DPR_INVALID_HANDLE;
	}

	return hr;
}



HRESULT WaveOutControl::Reset ( void )
{
	HRESULT hr;
	MMRESULT mmr;

	if (m_hDev)
	{
			
		mmr = waveOutReset ((HWAVEOUT) m_hDev);
		if (mmr != MMSYSERR_NOERROR)
		{
			DEBUGMSG (1, ("MediaControl::ResetAudioDev: waveOutReset failed, mmr=%ld\r\n", (ULONG) mmr));
			hr = DPR_CANT_RESET_WAVE_DEV;
		}
		else
		{
			hr = DPR_SUCCESS;
		}
	}
	else
	{
		hr = DPR_INVALID_HANDLE;
	}

	return hr;
}


HRESULT WaveInControl::SetProp ( DWORD dwPropId, DWORD_PTR dwPropVal )
{
	HRESULT hr = DPR_SUCCESS;
	MMRESULT mmr;

	switch (dwPropId)
	{

	case MC_PROP_VOICE_SWITCH:
		m_dwFlags = (DWORD)((m_dwFlags & ~DP_MASK_VOICESWITCH) | (dwPropVal & DP_MASK_VOICESWITCH));
		break;
		

	case MC_PROP_SILENCE_DURATION:
		if (dwPropVal == MC_USING_DEFAULT)
			m_uSilenceDuration = MC_DEF_SILENCE_DURATION;
		else
			m_uSilenceDuration = (DWORD)dwPropVal;		//ms
		break;

	case MC_PROP_TIMEOUT:
		m_uTimeout = (DWORD)dwPropVal;
		break;

	case MC_PROP_PREFEED:
		m_uPrefeed = (DWORD)dwPropVal;
		break;

	default:
		hr = MediaControl::SetProp(dwPropId, dwPropVal );
		break;
	}

	return hr;
}



HRESULT WaveOutControl::SetProp ( DWORD dwPropId, DWORD_PTR dwPropVal )
{
	HRESULT hr = DPR_SUCCESS;
	MMRESULT mmr;

	switch (dwPropId)
	{

	case MC_PROP_VOICE_SWITCH:
		m_dwFlags = (DWORD)((m_dwFlags & ~DP_MASK_VOICESWITCH) | (dwPropVal & DP_MASK_VOICESWITCH));
		break;
		
	case MC_PROP_VOLUME:
		if (m_dwFlags & DP_FLAG_SEND)
		{
			hr = DPR_INVALID_PARAMETER;
			goto MyExit;
		}
		if (dwPropVal == MC_USING_DEFAULT)	// dont change the volume
			break;
		// this is in units of % of maximum.  Scale it to mmsystem.
		dwPropVal = min(dwPropVal, 100);
		dwPropVal *= 655;
		dwPropVal |= (dwPropVal << 16);
		mmr = waveOutSetVolume ((HWAVEOUT) m_hDev, (DWORD)dwPropVal);
		if (mmr != MMSYSERR_NOERROR)
		{
			hr = DPR_CANT_SET_VOLUME;
			goto MyExit;
		}

		m_uVolume = (DWORD)dwPropVal;
		break;

	case MC_PROP_TIMEOUT:
		m_uTimeout = (DWORD)dwPropVal;
		break;

	case MC_PROP_PREFEED:
		m_uPrefeed = (DWORD)dwPropVal;
		break;

	default:
		hr = MediaControl::SetProp(dwPropId, dwPropVal );
		break;
	}

MyExit:

	return hr;
}


char LogScale[] = {0, 3, 6, 9, 11, 13, 15,
 17, 19, 21, 23, 24, 26, 27, 28, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
 42, 43, 43, 44, 45, 46, 46, 47, 48, 48, 49, 50, 50, 51, 51, 52, 52, 53, 54, 54,
 55, 55, 56, 56, 57, 57, 58, 58, 59, 59, 59, 60, 60, 61, 61, 62, 62, 62, 63, 63,
 64, 64, 64, 65, 65, 65, 66, 66, 66, 67, 67, 67, 68, 68, 68, 69, 69, 69, 70, 70,
 70, 71, 71, 71, 71, 72, 72, 72, 73, 73, 73, 73, 74, 74, 74, 74, 75, 75, 75, 75,
 76, 76, 76, 76, 77, 77, 77, 77, 78, 78, 78, 78, 79, 79, 79, 79, 79, 80, 80, 80,
 80, 81, 81, 81, 81, 81, 82, 82, 82, 82, 82, 83, 83, 83, 83, 83, 84, 84, 84, 84,
 84, 84, 85, 85, 85, 85, 85, 86, 86, 86, 86, 86, 86, 87, 87, 87, 87, 87, 87, 88,
 88, 88, 88, 88, 88, 89, 89, 89, 89, 89, 89, 89, 90, 90, 90, 90, 90, 90, 91, 91,
 91, 91, 91, 91, 91, 92, 92, 92, 92, 92, 92, 92, 93, 93, 93, 93, 93, 93, 93, 93,
 94, 94, 94, 94, 94, 94, 94, 95, 95, 95, 95, 95, 95, 95, 95, 96, 96, 96, 96, 96,
 96, 96, 96, 97, 97, 97, 97, 97, 97, 97, 97, 97, 98, 98, 98, 98, 98, 98, 98, 98,
 99, 99, 99, 99, 99, 99, 99, 99, 100};


HRESULT WaveInControl::GetProp ( DWORD dwPropId, PDWORD_PTR pdwPropVal )
{
	HRESULT hr = DPR_SUCCESS;

	if (pdwPropVal)
	{
		switch (dwPropId)
		{
		case MC_PROP_SILENCE_DURATION:
			*pdwPropVal = m_uSilenceDuration;
			break;
		
		case MC_PROP_TIMEOUT:
			*pdwPropVal = m_uTimeout;
			break;

		case MC_PROP_PREFEED:
			*pdwPropVal = m_uPrefeed;
			break;

		case MC_PROP_VOICE_SWITCH:
			*pdwPropVal = m_dwFlags & DP_MASK_VOICESWITCH;
			break;
		
		case MC_PROP_SPP:
//			*pdwPropVal = (DWORD) ((WAVEFORMATEX *) m_pDevFmt)->nSamplesPerSec
//								* m_uDuration / 100UL;
			*pdwPropVal = m_cbSizeDevData * (DWORD) ((WAVEFORMATEX *) m_pDevFmt)->nSamplesPerSec
						/(DWORD) ((WAVEFORMATEX *) m_pDevFmt)->nAvgBytesPerSec;
			break;

		case MC_PROP_SPS:
			*pdwPropVal = (DWORD) ((WAVEFORMATEX *) m_pDevFmt)->nSamplesPerSec;

			break;

		default:
			hr = MediaControl::GetProp( dwPropId, pdwPropVal );
			break;
		}
	}
	else
	{
		hr = DPR_INVALID_PARAMETER;
	}

	return hr;
}

HRESULT WaveOutControl::GetProp ( DWORD dwPropId, PDWORD_PTR pdwPropVal )
{
	HRESULT hr = DPR_SUCCESS;

	if (pdwPropVal)
	{
		switch (dwPropId)
		{
		case MC_PROP_VOLUME:
			*pdwPropVal = m_uVolume;
			break;

		case MC_PROP_TIMEOUT:
			*pdwPropVal = m_uTimeout;
			break;

		case MC_PROP_PREFEED:
			*pdwPropVal = m_uPrefeed;
			break;

		case MC_PROP_VOICE_SWITCH:
			*pdwPropVal = m_dwFlags & DP_MASK_VOICESWITCH;
			break;
		
		case MC_PROP_SPP:
//			*pdwPropVal = (DWORD) ((WAVEFORMATEX *) m_pDevFmt)->nSamplesPerSec
//								* m_uDuration / 100UL;
			*pdwPropVal = m_cbSizeDevData * (DWORD) ((WAVEFORMATEX *) m_pDevFmt)->nSamplesPerSec
						/(DWORD) ((WAVEFORMATEX *) m_pDevFmt)->nAvgBytesPerSec;
			break;

		case MC_PROP_SPS:
			*pdwPropVal = (DWORD) ((WAVEFORMATEX *) m_pDevFmt)->nSamplesPerSec;

			break;
		
		default:
			hr = MediaControl::GetProp( dwPropId, pdwPropVal );
			break;
		}
	}
	else
	{
		hr = DPR_INVALID_PARAMETER;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\log.cpp ===
// LOG.C
// low overhead logging routines
// can be used in time-critical situations
// LogInit should be called once to create the memory mapped file
// use LOGVIEW.EXE to view the log.

#include "precomp.h"

#ifdef LOGGING
// storage in log.c
// Strings corresponding to LOGMSG_XXX
// Note: cant use %s in format string
char LogStringTable [][MAX_STRING_SIZE] = {
// dont exceed the size of the string below!
//	"123456789012345678901234567890123456789012345678901234567890123"
	"Sent at %d\n",
	"NetRecv ts = %d, seq = %d at %d\n",
	"AP::Send   (%d), %d bytes, ts =%d\n",
	"AP::Silent (%d) %d\n",
	"AP::Record (%d)\n",
	"AP::Recv   (%d) seq = %d len=%d\n",
	"Rx::Reset1 MaxT=%d PlayT=%d PlayPos=%d\n",
	"Rx::Reset2 MaxT=%d PlayT=%d PlayPos=%d\n",
	"AP::Encoded(%d)\n",
	"AP::Decoded(%d)\n",
	"AP::Playing(%d) at %d\n",
	"AP::PlaySil(%d)\n",
	"RcrdTh:: try to open audio dev\n",
	"PlayTh: too many missings and Yield\n",
	"RcrdTh:: too many silence and Yield\n",
	"AP::Recycle(%d)\n",
	"AutoSilence: strength=%d,threshold=%d,avgSilence=%d\n",
	"Tx -Presend(%d)\n",
	"Rx-Skipping(%d)\n",
	"Tx::Reset FreePos=%d SendPos=%d\n",
	"Rx::VarDelay=%d samples, avgVarDelay=%d, delayPos=%d\n",
	"AP::PlayInterpolated(%d)\n",
	"AP::Interpolated (%d) %d\n",
	"VP::Send   (%d), %d bytes, ts =%d\n",
	"VP::Recv   (%d) seq = %d len=%d\n",
	"VP::Recycle(%d)\n",
	"VP::Record (%d)\n",
	"VP::Playing(%d) at %d\n",
	"VP::PlaySil(%d)\n",
	"VP::PlayInterpolated(%d)\n",
	"VP::Interpolated (%d) %d\n",
	"VP::Encoded(%d)\n",
	"VP::Decoded(%d)\n",
	"Vid::Trying to open Capture\n",
	"Vid:GetSendFrame    (%d)\n",
	"Vid:GetRecvFrame    (%d)\n",
	"Vid:ReleaseSendFrame(%d)\n",
	"Vid:ReleaseRecvFrame(%d)\n",
	"Vid:Playing back TS %d aud sync %d\n",
	"DGSOCK:->OnRead (%d)\n",
	"DGSOCK:<-OnRead (%d)\n",
	"DGSOCK:->OnReadDone (%d)\n",
	"DGSOCK:<-OnReadDone (%d)\n",
	"DGSOCK:->RecvFrom (%d)\n",
	"DGSOCK:<-RecvFrom (%d)\n",
	"DGSOCK:ReadWouldBlock (%d)\n",
	"VidSend: VP::Queue %d bytes, ts =%d at %d\n",
	"VidSend: AP::Queue %d bytes, ts =%d at %d\n",
	"VidSend: VP::Send %d bytes, ts =%d at %d\n",
	"VidSend: AP::Send %d bytes, ts =%d at %d\n",
	"VidSend: VP::!Send %d bytes, ts =%d\n",
	"VidSend: AP::!Send %d bytes, ts =%d\n",
	"VidSend: IO Pending\n",
	"VidSend: Audio queue is empty\n",
	"VidSend: Video queue is empty\n",
	"AudSend: VP::Queue %d bytes, ts =%d\n",
	"AudSend: AP::Queue %d bytes, ts =%d at %d\n",
	"AudSend: VP::Send %d bytes, ts =%d\n",
	"AudSend: AP::Send %d bytes, ts =%d at %d\n",
	"AudSend: VP::!Send %d bytes, ts =%d\n",
	"AudSend: AP::!Send %d bytes, ts =%d\n",
	"AudSend: IO Pending\n",
	"AudSend: Audio queue is empty\n",
	"AudSend: Video queue is empty\n",
	"Send blocked for %d ms\n",

	"DS PlayBuf: Play=%d, Write=%d, len=%d\n",
	"DS Empty  : Play=%d, lastPlay=%d, nextWrite=%d\n",
	"DS Timeout: Play=%d, nextWrite=%d at %d\n",
	"DS PlayBuf Overflow! SetPlayPosition to %d (hr=%d)\n",
	"DS Create: (hr = %d)\n",
	"DS Release: (uref = %d)\n",
	"DS PlayBuf: Dropped out of sequence packet\n",
	"DS PlayBuf: timestamp=%d, seq=%d, fMark=%d\n",
	"DS PlayBuf: GetTickCount=%d\n",
	"DS PlayBuf: PlayPos=%d, WritePos=%d\n",
	"DS PlayBuf: Dropping packet due to overflow\n",
	"m_Next=%d, curDelay=%d, bufSize=%d\n",

	"Send Audio Config   took %ld ms\r\n",
	"Send Audio UnConfig took %ld ms\r\n",
	"Send Video Config   took %ld ms\r\n",
	"Send Video UnConfig took %ld ms\r\n",
	"Recv Audio Config   took %ld ms\r\n",
	"Recv Audio UnConfig took %ld ms\r\n",
	"Recv Video Config   took %ld ms\r\n",
	"Recv Video UnConfig took %ld ms\r\n",


	"DSC Timestamp: %d\r\n",
	"DSC GetCurrentPos: capPos=%d  ReadPos=%d\r\n",
	"DSC Timeout: A timeout has occured\r\n",
	"DSC Lagging condition: Lag=%d  NextExpect=%d\r\n",
	"DSC Sending: Num=%d, dwFirstPos=%d, dwLastPos=%d\r\n",
	"DSC Stats: BufferSize=%d, FrameSize=%d\r\n",
	"DSC Early condition detected\r\n"
};

#define MAX_LOG_ENTRIES		2048

// IMPORTANT: should be identical to definition in viewer app.
typedef struct {
	int locked;		// set to TRUE while viewer is accessing log
	int cdwEntrySize;
	int cMaxEntries;
	int cbOffsetBase;	// from start of this struct
	int cbOffsetStringTable;	// from start of this struct
	int cStrings;		// number of strings
	int cCurrent;		// index of current log position
} LOG_HEADER;

struct LogEntry {
	DWORD dw[4];
} *pLogBase;

#define MAX_LOG_SIZE (sizeof(LOG_HEADER)+sizeof(struct LogEntry)*MAX_LOG_ENTRIES + sizeof(LogStringTable))

HANDLE hMapFile = NULL;
char szLogViewMap[] = "LogViewMap";
LOG_HEADER *pLog=NULL;
CRITICAL_SECTION logCritSect;	// not used


void Log (UINT n, UINT arg1, UINT arg2, UINT arg3)
{
	struct LogEntry *pCurEntry;
	if (pLog == NULL || pLog->locked)
		return;


	//EnterCriticalSection(&logCritSect);
	// sideeffect of multiple access are not serious so
	// dont bother with synchronization.
	pLog->cCurrent++;
	if (pLog->cCurrent >= pLog->cMaxEntries) {
		pLog->cCurrent = 0;		//wraparound
	}
	pCurEntry = pLogBase + pLog->cCurrent;
	pCurEntry->dw[0] = n;
	pCurEntry->dw[1] = arg1;
	pCurEntry->dw[2] = arg2;
	pCurEntry->dw[3] = arg3;
	//LeaveCriticalSection(&logCritSect);
}

int LogInit()
{
	int fSuccess;
	hMapFile = CreateFileMapping(INVALID_HANDLE_VALUE,
		NULL,
		PAGE_READWRITE,
		0,
		MAX_LOG_SIZE,
		szLogViewMap);
	if (hMapFile == NULL) {
		//printf("Couldnt open Map: %s\n",szLogViewMap);
		fSuccess = FALSE;
		goto Exit;
	}
	pLog = (LOG_HEADER *)MapViewOfFile(hMapFile,
		FILE_MAP_ALL_ACCESS,
		0,
		0,
		0);	// entire file starting from offset 0
	if (pLog == NULL) {
		//printf("Couldnt map view %s\n",szLogViewMap);
		fSuccess = FALSE;
		goto Exit;
	}
	InitializeCriticalSection(&logCritSect);
	// initialize log
	pLog->locked = 0;
	pLog->cdwEntrySize = sizeof(struct LogEntry)/sizeof(DWORD);	// size in dwords
	pLog->cMaxEntries = MAX_LOG_ENTRIES;
	pLog->cbOffsetBase = sizeof(LOG_HEADER)+sizeof(LogStringTable);
	pLog->cbOffsetStringTable = sizeof(LOG_HEADER);
	pLog->cStrings = sizeof(LogStringTable)/MAX_STRING_SIZE;
	pLog->cCurrent = 0;	// current position

	pLogBase = (struct LogEntry *)((PBYTE)pLog + pLog->cbOffsetBase);

	memcpy((PBYTE)pLog + pLog->cbOffsetStringTable, LogStringTable, sizeof(LogStringTable));
	memset((PBYTE)pLogBase,0,MAX_LOG_ENTRIES*pLog->cdwEntrySize*4);
	fSuccess  = TRUE;
Exit:
	return fSuccess;
}

LogClose()
{
	if (pLog)
	{
		DeleteCriticalSection(&logCritSect);
		UnmapViewOfFile(pLog);
		pLog = NULL;
		CloseHandle(hMapFile);
		hMapFile = NULL;
	}
	return TRUE;
}
#endif // LOGGING enabled

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\mediapkt.cpp ===
#include "precomp.h"


#define ZONE_AP			1



#define _GetPlatform()	(m_dwState & DP_MASK_PLATFORM)
#define _SetPlatform(s)	(m_dwState = (m_dwState & ~DP_MASK_PLATFORM) | (s & DP_MASK_PLATFORM))

///////////////////////////////////////////////////////
//
//  Public methods
//


MediaPacket::MediaPacket ( void )
{
	_Construct ();
}


MediaPacket::~MediaPacket ( void )
{
	_Destruct ();
}


HRESULT MediaPacket::Initialize ( MEDIAPACKETINIT * p )
{
	HRESULT hr = DPR_SUCCESS;

	FX_ENTRY ("AdPckt::Init")

	if (p == NULL)
	{
		DEBUGMSG (ZONE_AP, ("%s: invalid parameter (null ptr)\r\n", _fx_));
		return DPR_INVALID_PARAMETER;
	}

	_Construct ();

	// we need to analyze flags to
	// warn conflicting or insufficient flags
	m_dwState |= p->dwFlags;

	// get handle of stream conversion
	m_hStrmConv = p->hStrmConv;

	// get handle of wave device
	// m_hDev = p->hDevAudio;
	m_hDev = NULL;

	// flags about prepared
	m_fDevPrepared = FALSE;
	m_fStrmPrepared = FALSE;

	// set up wave formats
	m_pStrmConvSrcFmt = p->pStrmConvSrcFmt;
	m_pStrmConvDstFmt = p->pStrmConvDstFmt;
	m_pDevFmt = p->pDevFmt;
	m_payload = p->payload;

	// net buffer
	if (p->cbSizeNetData)
	{ 	// send or recv
		m_pNetData = (NETBUF *) LocalAlloc (LMEM_FIXED, p->cbSizeNetData + p->cbOffsetNetData + p->cbPayloadHeaderSize + sizeof (NETBUF));
		if (m_pNetData == NULL)
		{
			DEBUGMSG (ZONE_AP, ("%s: MemAlloc1 (%ld) failed\r\n",
			_fx_, (ULONG) (p->cbSizeNetData + p->cbOffsetNetData)));
			hr = DPR_OUT_OF_MEMORY;
			goto MyExit;
		}
		m_pNetData->data = (PBYTE) m_pNetData + p->cbOffsetNetData + p->cbPayloadHeaderSize + sizeof (NETBUF);
		m_pNetData->length = p->cbSizeNetData;
		m_cbMaxNetData = p->cbSizeNetData;
		m_pNetData->pool = NULL;
	}
	else
	{
#ifdef PREP_HDR_PER_CONV
		// recv
		m_pNetData = NULL;
#else
		hr = DPR_INVALID_PARAMETER;
		goto MyExit;
#endif
	}

	m_index = p->index;

	// if m_pStrmConvDstFmt == m_pStrmConvSrcFmt,
	// then m_pRawData <-- m_pNetData
	// else allocate it
	if (IsSameMediaFormat (m_pStrmConvSrcFmt, m_pStrmConvDstFmt))
	{
		m_pRawData = m_pNetData;
	}
	else if (p->fDontAllocRawBufs)
	{
		m_pRawData = NULL;
	}
	else
	{
		m_pRawData = (NETBUF *) LocalAlloc (LMEM_FIXED, p->cbSizeRawData + p->cbOffsetRawData + sizeof(NETBUF));
		if (m_pRawData == NULL)
		{
			DEBUGMSG (ZONE_AP, ("%s: MemAlloc2 (%ld) failed\r\n",
			_fx_, (ULONG) (p->cbSizeRawData + p->cbOffsetRawData)));
			hr = DPR_OUT_OF_MEMORY;
			goto MyExit;
		}
		m_pRawData->data = (PBYTE) m_pRawData + sizeof(NETBUF) + p->cbOffsetRawData;
		m_pRawData->length = p->cbSizeRawData;
		m_pRawData->pool = NULL;
	}

	// if m_pDevFmt == m_pStrmConvSrcFmt (when SEND)
	// then m_pDevData <-- m_pRawData
	// else allocate it
	if (((m_dwState & DP_FLAG_SEND) &&
				IsSameMediaFormat (m_pStrmConvSrcFmt, m_pDevFmt)) ||
		((m_dwState & DP_FLAG_RECV) &&
				IsSameMediaFormat (m_pStrmConvDstFmt, m_pDevFmt)))
	{
		// typical case - codec raw format matches that of i/o device
		m_pDevData = m_pRawData;
	}
	else
	{
		// codec raw format doesnt match that of device
		// BUGBUG: we dont really handle this case yet
		m_pDevData = (NETBUF *) LocalAlloc (LMEM_FIXED, p->cbSizeDevData + p->cbOffsetDevData + sizeof(NETBUF));
		if (m_pDevData == NULL)
		{
			DEBUGMSG (ZONE_AP, ("%s: MemAlloc3 (%ld) failed\r\n",
			_fx_, (ULONG) (p->cbSizeDevData + p->cbOffsetDevData)));
			hr = DPR_OUT_OF_MEMORY;
			goto MyExit;
		}
		m_pDevData->data = (PBYTE) m_pDevData + sizeof(NETBUF) + p->cbOffsetDevData;
		m_pDevData->length = p->cbSizeDevData;
		m_pDevData->pool = NULL;
	}

	MakeSilence ();

MyExit:

	if (hr == DPR_SUCCESS)
	{
		m_fInitialized = TRUE;
		SetState (MP_STATE_RESET);
	}

	return hr;
}


HRESULT MediaPacket::Receive ( NETBUF *pNetBuf, DWORD timestamp, UINT seq, UINT fMark )
{
	m_seq = seq;
	m_timestamp = timestamp;
	m_fMark = fMark;

#ifdef PREP_HDR_PER_CONV
	m_pNetData = pNetBuf;
#else
	if (pNetBuf)  // pNetBuf may be NULL for video
	{
		if (pNetBuf->length > m_cbMaxNetData)
			return DPR_INVALID_PARAMETER;
		if (m_pNetData && pNetBuf)
		{
			CopyMemory (m_pNetData->data, pNetBuf->data,
							(m_pNetData->length = pNetBuf->length));

		}
	}
#endif

	LOG(((m_dwState & DP_FLAG_VIDEO)? LOGMSG_VID_RECV: LOGMSG_AUD_RECV,m_index,seq,m_pNetData->length));
	SetState (MP_STATE_NET_IN_STREAM);
	return DPR_SUCCESS;
}


HRESULT MediaPacket::Recycle ( void )
{
	HRESULT hr = DPR_SUCCESS;

	FX_ENTRY ("MdPckt::Recycle")

	LOG(((m_dwState & DP_FLAG_VIDEO)? LOGMSG_VID_RECYCLE: LOGMSG_AUD_RECYCLE, m_index));
	if (m_dwState & DP_FLAG_RECV)
	{
		if (m_pRawData && m_pRawData->pool) {
			m_pRawData->pool->ReturnBuffer((PVOID) m_pRawData);
			if (m_pDevData == m_pRawData)
				m_pDevData = NULL;
			m_pRawData = NULL;
		}
#ifdef PREP_HDR_PER_CONV
		// free net data buffer
		if (m_pNetData && m_pNetData->pool) m_pNetData->pool->ReturnBuffer ((PVOID) m_pNetData);
		if (m_pNetData == m_pRawData) m_pRawData = NULL;
		m_pNetData = NULL;
#endif
	}

	SetState (MP_STATE_RESET);

	return hr;
}


HRESULT MediaPacket::GetProp ( DWORD dwPropId, PDWORD_PTR pdwPropVal )
{
	HRESULT hr = DPR_SUCCESS;

	FX_ENTRY ("AdPckt::GetProp")

	if (pdwPropVal)
	{
		switch (dwPropId)
		{
		case MP_PROP_STATE:
			*pdwPropVal = GetState ();
			break;

		case MP_PROP_PLATFORM:
			*pdwPropVal = _GetPlatform ();
			break;

		case MP_PROP_DEV_MEDIA_FORMAT:
			*pdwPropVal = (DWORD_PTR) m_pDevFmt;
			break;

		case MP_PROP_DEV_DATA:
			*pdwPropVal = (DWORD_PTR) m_pDevData;
			break;

		case MP_PROP_DEV_HANDLE:
			*pdwPropVal = (DWORD_PTR) m_hDev;
			break;

		case MP_PROP_DEV_MEDIA_HDR:
			*pdwPropVal = (DWORD_PTR) m_pDevHdr;
			break;

		case MP_PROP_IN_STREAM_FORMAT:
			*pdwPropVal = (DWORD_PTR) m_pStrmConvSrcFmt;
			break;

		case MP_PROP_OUT_STREAM_FORMAT:
			*pdwPropVal = (DWORD_PTR) m_pStrmConvDstFmt;
			break;

		case MP_PROP_TIMESTAMP:
			*pdwPropVal = (DWORD) m_timestamp;
			break;
	
		case MP_PROP_INDEX:
			*pdwPropVal = (DWORD) m_index;
			break;

		case MP_PROP_PREAMBLE:
			*pdwPropVal = (DWORD) m_fMark;
			break;

		case MP_PROP_FILTER_HEADER:
			*pdwPropVal = (DWORD_PTR) m_pStrmConvHdr;
			break;

		case MP_PROP_MAX_NET_LENGTH:
			*pdwPropVal = m_cbMaxNetData;
			break;


		default:
			hr = DPR_INVALID_PROP_ID;
			break;
		}
	}
	else
	{
		hr = DPR_INVALID_PARAMETER;
	}

	return hr;
}


HRESULT MediaPacket::SetProp ( DWORD dwPropId, DWORD_PTR dwPropVal )
{
	HRESULT hr = DPR_SUCCESS;

	FX_ENTRY ("AdPckt::SetProp")

	switch (dwPropId)
	{
	case MP_PROP_STATE:
		SetState ((DWORD)dwPropVal);
		break;

	case MP_PROP_PLATFORM:
		_SetPlatform ((DWORD)dwPropVal);
		break;

	case MP_PROP_DEV_MEDIA_FORMAT:
	case MP_PROP_IN_STREAM_FORMAT:
	case MP_PROP_OUT_STREAM_FORMAT:
		hr = DPR_IMPOSSIBLE_SET_PROP;
		break;

	case MP_PROP_TIMESTAMP:
		m_timestamp = (DWORD)dwPropVal;
		break;

	case MP_PROP_PREAMBLE:
		m_fMark = dwPropVal ? 1 : 0;
		break;

	default:
		hr = DPR_INVALID_PROP_ID;
		break;
	}

	return hr;
}


HRESULT MediaPacket::Release ( void )
{
	_Destruct ();
	return DPR_SUCCESS;
}

BOOL MediaPacket::SetDecodeBuffer(NETBUF *pBuf)
{
	ASSERT(!m_pRawData);
	m_pRawData = pBuf;
	if (!m_pDevData) m_pDevData = pBuf;
	return TRUE;
}

///////////////////////////////////////////////////////
//
//  Private methods
//


void MediaPacket::_Construct ( void )
{
	m_hStrmConv = NULL;
	m_pStrmConvHdr = NULL;
	m_pStrmConvSrcFmt = NULL;
	m_pStrmConvDstFmt = NULL;

	m_hDev = NULL;
	m_pDevHdr = NULL;
	m_pDevFmt = NULL;

	m_pDevData = NULL;
	m_pRawData = NULL;
	m_pNetData = NULL;

	m_dwState = 0;
	m_fBusy = FALSE;
	m_timestamp = 0;
	m_seq = 0;
	m_index = 0;
	m_fMark = 0;

	m_cbValidRawData = 0;

	m_fRendering = FALSE;

	m_fInitialized = FALSE;

}


void MediaPacket::_Destruct ( void )
{
	if (m_fInitialized)
	{
		if (m_pDevHdr) MemFree (m_pDevHdr);
		m_pDevHdr = NULL;

		if (m_pStrmConvHdr) MemFree (m_pStrmConvHdr);
		m_pStrmConvHdr = NULL;

		if (m_pDevData == m_pRawData) m_pDevData = NULL;
		if (m_pRawData == m_pNetData) m_pRawData = NULL;

		if (m_pDevData) {
			if (m_pDevData->pool)
				m_pDevData->pool->ReturnBuffer((PVOID) m_pDevData);
			else
				LocalFree (m_pDevData);
			m_pDevData = NULL;
		}

		if (m_pRawData) {
			if (m_pRawData->pool)
				m_pRawData->pool->ReturnBuffer((PVOID) m_pRawData);
			else
				LocalFree (m_pRawData);
			m_pRawData = NULL;
		}

		if (m_pNetData && m_pNetData->pool)
			m_pNetData->pool->ReturnBuffer ((PVOID) m_pNetData);
		else if (m_pNetData)
			LocalFree (m_pNetData);
		m_pNetData = NULL;

		SetState (MP_STATE_RESET);

		m_fInitialized = FALSE;
	}
}

HRESULT MediaPacket::GetDevData(PVOID *ppData, PUINT pcbData)
{
	if (!ppData || !pcbData)
		return DPR_INVALID_PARAMETER;

	if (m_pDevData) {
		*ppData = m_pDevData->data;
		*pcbData = m_pDevData->length;
	} else {
		*ppData = NULL;
		*pcbData = 0;
	}

	return DPR_SUCCESS;
}

HRESULT MediaPacket::GetNetData(PVOID *ppData, PUINT pcbData)
{

	if (!ppData || !pcbData)
		return DPR_INVALID_PARAMETER;

	if (m_pNetData) {
		*ppData = m_pNetData->data;
		*pcbData = m_pNetData->length;
	} else {
		*ppData = NULL;
		*pcbData = 0;
	}

	return DPR_SUCCESS;

}


HRESULT MediaPacket::SetNetLength(UINT uLength)
{
	if ((m_pNetData) && (m_pNetData->data))
	{
		m_pNetData->length = uLength;
	}
	else
	{
		return E_FAIL;
	}
	return S_OK;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\medistrm.cpp ===
#include <precomp.h>


// IID_IProperty
IID IID_IProperty = 
	{ /* 4e94d3e0-793e-11d0-8ef0-00a0c90541f4 */
    0x4e94d3e0,
    0x793e,
    0x11d0,
    {0x8e, 0xf0, 0x00, 0xa0, 0xc9, 0x05, 0x41, 0xf4}
  };
 


// default implementations for SetNetworkInterface

HRESULT STDMETHODCALLTYPE SendMediaStream::SetNetworkInterface(IUnknown *pUnknown)
{
	HRESULT hr=S_OK;
	IRTPSend *pRTPSend=NULL;

	if (m_DPFlags & DPFLAG_STARTED_SEND)
	{
		return DPR_IO_PENDING; // anything better to return ?
	}

	if (pUnknown != NULL)
	{
		hr = pUnknown->QueryInterface(IID_IRTPSend, (void**)&pRTPSend);
	}

	if (SUCCEEDED(hr))
	{
		if (m_pRTPSend)
		{
			m_pRTPSend->Release();
		}
		m_pRTPSend = pRTPSend;
		ZeroMemory(&m_RTPStats,sizeof(m_RTPStats));	// reset network stats
	}

	return hr;

}


HRESULT SendMediaStream::SetFlowSpec()
{
	HRESULT hr = DPR_NOT_CONFIGURED;
	IRTPSession *pRtpSession;

	if (m_pDP->m_bDisableRSVP)
		return S_OK;

	if ((m_DPFlags & DPFLAG_CONFIGURED_SEND) && (m_pRTPSend))
	{
		m_pRTPSend->QueryInterface(IID_IRTPSession, (void**)&pRtpSession);

		pRtpSession->SetSendFlowspec(&m_flowspec);
		pRtpSession->Release();
		hr = DPR_SUCCESS;
	}

	return hr;
}


HRESULT RecvMediaStream::SetFlowSpec()
{
	HRESULT hr = DPR_NOT_CONFIGURED;
	IRTPSession *pSession=NULL;

	if (m_pDP->m_bDisableRSVP)
		return S_OK;
	
	if ((m_DPFlags & DPFLAG_CONFIGURED_RECV) && (m_pIRTPRecv))
	{
		// the following is bogus for two reasons
		// 1. when we go multipoint, we really need to set
		//    set the WinsockQos based on the total number
		//    of incoming sessions.
		// 2. The RTP interfaces will eventually be made
		//    so that RTP Session and RTPRecv objects are
		//    distinct.  So QI will fail.
		hr = m_pIRTPRecv->QueryInterface(IID_IRTPSession, (void**)&pSession);
		if (SUCCEEDED(hr))
		{
			pSession->SetRecvFlowspec(&m_flowspec);
			pSession->Release();
			hr = DPR_SUCCESS;
		}
	}

	return hr;
}


HRESULT STDMETHODCALLTYPE RecvMediaStream::SetNetworkInterface(IUnknown *pUnknown)
{
	HRESULT hr=S_OK;
	IRTPRecv *pRTPRecv=NULL;

	// don't try to do change the RTP interface while in mid-stream
	if (m_DPFlags & DPFLAG_STARTED_RECV)
	{
		return DPR_IO_PENDING; // anything better to return ?
	}

	if (pUnknown)
	{
		hr = pUnknown->QueryInterface(IID_IRTPRecv, (void**)&pRTPRecv);
	}
	if (SUCCEEDED(hr))
	{
		if (m_pIRTPRecv)
		{
			m_pIRTPRecv->Release();
		}
		m_pIRTPRecv = pRTPRecv;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\medictrl.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    medictrl.h

Abstract:
	Defines the MediaControl class which encapsulates the multimedia devices, in particular
	WaveIn and WaveOut.

--*/

#ifndef _MEDICTRL_H_
#define _MEDICTRL_H_


#include <pshpack8.h> /* Assume 8 byte packing throughout */

#define MC_USING_DEFAULT			((UINT) -1)

// #define MC_DEF_SILENCE_LEVEL		110	// about 10%
// #define MC_DEF_SILENCE_LEVEL		20	// about 2%
#define MC_DEF_SILENCE_LEVEL		60	// about 6%
#define MC_DEF_SILENCE_DURATION		600	// 600ms
#define MC_DEF_DURATION				40	// 40ms
#define MC_DEF_VOLUME				50	// 50%

#define MC_DEF_RECORD_TIMEOUT		2000 // 1000ms
#define MC_DEF_PLAY_TIMEOUT			2000 // 1000ms

#define MC_DEF_RECORD_BUFS			4
#define MC_DEF_PLAY_BUFS			4


typedef struct tagMediaCtrlInitStruct
{
	DWORD		dwFlags;
	HWND		hAppWnd;		// handle to window that owns the NAVC
	HINSTANCE	hAppInst;		// handle to instance of app
}
	MEDIACTRLINIT;

typedef struct tagMediaCtrlConfigStruct
{
	ULONG		cbSamplesPerPkt;	// samples per buffer (only needed if duration is not specified)
	DPHANDLE	hStrm;		// Rx/Tx audio stream
	UINT		uDevId;
	PVOID		pDevFmt;
	UINT		uDuration;		// buffer duration in units of ms, usually 20ms or 30ms

}MEDIACTRLCONFIG;


class MediaControl
{
protected:

	// flags
	DWORD		m_dwFlags;			// compatible to that of class AudioPacket

	// ptr to stream object
	DPHANDLE	m_hStrm;		// Rx/Tx  queue

	// device id
	UINT		m_uDevId;

	// device of mm io
	DPHANDLE	m_hDev;
	PVOID		m_pDevFmt;
	ULONG		m_cbSizeDevData;	// ATT: the sender must agree on this size
									// this should be done in format negotiation
									// need to talk to MikeV about this!!!
	// properties
	UINT		m_uState;			// state: idle, start, pause, stop
	UINT		m_uDuration;		// duration per frame, in units of 10ms
	BOOL volatile m_fJammed;		// is the device allocated elsewhere

	// notification event
	HANDLE		m_hEvent;

	// references to audio packets
	MediaPacket	**m_ppMediaPkt;
	ULONG		m_cMediaPkt;

protected:

	void _Construct ( void );
	void _Destruct ( void );

public:

	MediaControl ( void );
	~MediaControl ( void );

	virtual HRESULT Initialize ( MEDIACTRLINIT * p );
	virtual HRESULT Configure ( MEDIACTRLCONFIG * p ) = 0;
	virtual HRESULT FillMediaPacketInit ( MEDIAPACKETINIT * p );
	virtual HRESULT SetProp ( DWORD dwPropId, DWORD_PTR dwPropVal );
	virtual HRESULT GetProp ( DWORD dwPropId, PDWORD_PTR pdwPropVal );
	virtual HRESULT Open ( void ) = 0;
	virtual HRESULT Start ( void ) = 0;
	virtual HRESULT Stop ( void ) = 0;
	virtual HRESULT Reset ( void ) = 0;
	virtual HRESULT Close ( void ) = 0;
	virtual HRESULT RegisterData ( PVOID pDataPtrArray, ULONG cElements );
	virtual HRESULT PrepareHeaders ( void );
	virtual HRESULT UnprepareHeaders ( void );
	virtual HRESULT Release ( void );
};

class WaveInControl : public MediaControl {
private:
	UINT		m_uTimeout;			// timeout in notification wait
	UINT		m_uPrefeed;			// num of buffers prefed to device
	UINT		m_uSilenceDuration;	// continuous silence before cutoff

public:	
	WaveInControl ( void );
	~WaveInControl ( void );

	HRESULT Initialize ( MEDIACTRLINIT * p );
	HRESULT Configure ( MEDIACTRLCONFIG * p );
	HRESULT SetProp ( DWORD dwPropId, DWORD_PTR dwPropVal );
	HRESULT GetProp ( DWORD dwPropId, PDWORD_PTR pdwPropVal );
	HRESULT Open ( void );
	HRESULT Start ( void );
	HRESULT Stop ( void );
	HRESULT Reset ( void );
	HRESULT Close ( void );
	
};

class WaveOutControl : public MediaControl {
private:
	UINT		m_uVolume;			// volume of the sound
	UINT		m_uTimeout;			// timeout in notification wait
	UINT		m_uPrefeed;			// num of buffers prefed to device
	UINT		m_uPosition;		// position of the playback stream
public:	
	WaveOutControl ( void );
	~WaveOutControl ( void );
	HRESULT Initialize ( MEDIACTRLINIT * p );
	HRESULT Configure ( MEDIACTRLCONFIG * p );
	HRESULT SetProp ( DWORD dwPropId, DWORD_PTR dwPropVal );
	HRESULT GetProp ( DWORD dwPropId, PDWORD_PTR pdwPropVal );
	HRESULT Open ( void );
	HRESULT Start ( void );
	HRESULT Stop ( void );
	HRESULT Reset ( void );
	HRESULT Close ( void );
};

enum
{
	MC_PROP_MEDIA_STREAM,
	MC_PROP_MEDIA_DEV_HANDLE,
	MC_PROP_MEDIA_FORMAT,
	MC_PROP_SIZE,
	MC_PROP_PLATFORM,
	MC_PROP_VOLUME,
	MC_PROP_SILENCE_LEVEL,
	MC_PROP_SILENCE_DURATION,
	MC_PROP_TIMEOUT,
	MC_PROP_PREFEED,
	MC_PROP_DURATION,
	MC_PROP_DUPLEX_TYPE,
	MC_PROP_EVENT_HANDLE,
	MC_PROP_SPP,
	MC_PROP_SPS,
	MC_PROP_STATE,
	MC_PROP_VOICE_SWITCH,
	MC_PROP_AUDIO_STRENGTH,
	MC_PROP_MEDIA_DEV_ID,
	MC_PROP_AUDIO_JAMMED,
	MC_PROP_NumOfProps
};


enum
{
	MC_TYPE_AUDIO,
	MC_TYPE_NumOfTypes
};


enum
{
	MC_STATE_IDLE,
	MC_STATE_START,
	MC_STATE_PAUSE,
	MC_STATE_STOP,
	MC_STATE_NumOfStates
};


#include <poppack.h> /* End byte packing */

#endif // _MEDICTRL_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\medvctrl.cpp ===
#include "precomp.h"

extern HANDLE g_hVidEventHalfDuplex;


///////////////////////////////////////////////////////
//
//  Public methods
//


VideoInControl::VideoInControl ( void )
{
}


VideoInControl::~VideoInControl ( void )
{
}


VideoOutControl::VideoOutControl ( void )
{
}


VideoOutControl::~VideoOutControl ( void )
{
}


HRESULT VideoInControl::Initialize ( MEDIACTRLINIT * p )
{
	HRESULT hr = DPR_SUCCESS;
	DEBUGMSG (ZONE_VERBOSE, ("VideoInControl::Initialize: enter.\r\n"));

	m_dwFlags = p->dwFlags;
	m_hEvent = NULL;
	m_uDuration = MC_DEF_DURATION;
	m_uTimeout = MC_DEF_RECORD_TIMEOUT;	
	m_uPrefeed = MC_DEF_RECORD_BUFS;
	//Request the max, and let QOS throttle us back
    m_FPSRequested = m_FPSMax = 2997;
	
	DEBUGMSG (ZONE_VERBOSE, ("VideoInControl::Initialize: exit, hr=0x%lX\r\n",  hr));

	return hr;
}


HRESULT VideoOutControl::Initialize ( MEDIACTRLINIT * p )
{
	HRESULT hr = DPR_SUCCESS;
	DEBUGMSG (ZONE_VERBOSE, ("VideoOutControl::Initialize: enter.\r\n"));

	if ((hr =MediaControl::Initialize( p)) != DPR_SUCCESS)
		return hr;

	m_uTimeout = MC_DEF_PLAY_TIMEOUT;
	
	m_uPrefeed = MC_DEF_PLAY_BUFS;
	
	DEBUGMSG (ZONE_VERBOSE, ("VideoOutControl::Initialize: exit, hr=0x%lX\r\n",  hr));

	return hr;
}


HRESULT VideoInControl::Configure ( MEDIACTRLCONFIG * p )
{
	UINT uBlockAlign;

	DEBUGMSG (ZONE_VERBOSE, ("VideoInControl::Configure: enter.\r\n"));


	m_hStrm = p->hStrm;
	m_uDevId = p->uDevId;
	m_pDevFmt = p->pDevFmt;
	
	if (m_pDevFmt == NULL) return DPR_INVALID_PARAMETER;


	if ((m_uDuration = p->uDuration) == MC_USING_DEFAULT)
	{
		m_cbSizeDevData = ((VIDEOFORMATEX *) m_pDevFmt)->nAvgBytesPerSec * p->cbSamplesPerPkt
			/((VIDEOFORMATEX *) m_pDevFmt)->nSamplesPerSec;
		m_uDuration = p->cbSamplesPerPkt*1000 /((VIDEOFORMATEX *) m_pDevFmt)->nSamplesPerSec;
	} else {
	// roughly calculate the buffer size based on 20ms
	m_cbSizeDevData = ((VIDEOFORMATEX *) m_pDevFmt)->nAvgBytesPerSec
									* m_uDuration / 1000;

	// need to be on the block alignment boundary
	uBlockAlign = ((VIDEOFORMATEX *) m_pDevFmt)->nBlockAlign;
	m_cbSizeDevData = ((m_cbSizeDevData + uBlockAlign - 1) / uBlockAlign)
									* uBlockAlign;
	}
	// at configuration we set the max. frame rate
    if (m_uDuration)
    	m_FPSMax = 100000 / m_uDuration;  // convert msec/frame to fps
	m_FPSRequested = ((VIDEOFORMATEX *) m_pDevFmt)->nSamplesPerSec * 100;

	DEBUGMSG (ZONE_VERBOSE, ("VideoInControl::Configure: exit\r\n"));
	return DPR_SUCCESS;
}


HRESULT VideoOutControl::Configure ( MEDIACTRLCONFIG * p )
{
	UINT uBlockAlign;
	
	DEBUGMSG (ZONE_VERBOSE, ("VideoOutControl::Configure: enter.\r\n"));

	m_hStrm = p->hStrm;
	m_uDevId = p->uDevId;
	m_pDevFmt = p->pDevFmt;
	
	if (m_pDevFmt == NULL) return DPR_INVALID_PARAMETER;


	if ((m_uDuration = p->uDuration) == MC_USING_DEFAULT)
	{
		m_cbSizeDevData = ((VIDEOFORMATEX *) m_pDevFmt)->nAvgBytesPerSec * p->cbSamplesPerPkt
			/((VIDEOFORMATEX *) m_pDevFmt)->nSamplesPerSec;
		m_uDuration = p->cbSamplesPerPkt*1000 /((VIDEOFORMATEX *) m_pDevFmt)->nSamplesPerSec;
	} else {
	// roughly calculate the buffer size based on 20ms
	m_cbSizeDevData = ((VIDEOFORMATEX *) m_pDevFmt)->nAvgBytesPerSec
									* m_uDuration / 1000;

	// need to be on the block alignment boundary
	uBlockAlign = ((VIDEOFORMATEX *) m_pDevFmt)->nBlockAlign;
	m_cbSizeDevData = ((m_cbSizeDevData + uBlockAlign - 1) / uBlockAlign)
									* uBlockAlign;
	}

	DEBUGMSG (ZONE_VERBOSE, ("VideoOutControl::Configure: exit\r\n"));
	return DPR_SUCCESS;
}


HRESULT VideoInControl::Open ( void )
{
	HRESULT hr;
    FINDCAPTUREDEVICE fcd;
    HFRAMEBUF hbuf;
    DWORD dwSize, i;
    LPBITMAPINFOHEADER lpbi;
	int iWidth, iHeight;
	char szName[MAX_PATH];

    fcd.dwSize = sizeof (FINDCAPTUREDEVICE);
    if (m_uDevId == -1)
   	    FindFirstCaptureDevice(&fcd, NULL);
	else
	{
        if (!FindFirstCaptureDeviceByIndex(&fcd, m_uDevId))
		{
			// Update m_uDevId with new device index
   	        if (FindFirstCaptureDevice(&fcd, NULL))
				m_uDevId = fcd.nDeviceIndex;
		}
    }

#ifndef NO_QCCOLOR_HACK
    if (fcd.szDeviceName[0] && lstrcmpi(fcd.szDeviceName, "qccolor.drv") == 0) {
        // this hack clears out the [conf] section of qccolor.ini to prevent problems in
        // setformat when the driver initializes to an unknown format that is recorded in
        // the ini file.
        dwSize = GetModuleFileName(NULL, szName, sizeof(szName));
        for (i = dwSize-1; i; i--)
            if (szName[i] == '\\' || szName[i] == ':')
                break;
        i++;
        MoveMemory (szName, &szName[i], dwSize-i+1);
        dwSize -= i;
        for (i = dwSize-1; i; i--)
            if (szName[i] == '.') {
                szName[i] = 0;
                break;
            }

        dwSize = 0;
        WritePrivateProfileSection(szName, (LPCTSTR)&dwSize, "QCCOLOR.INI");
    }
#endif

   	if (!(m_hDev = (DPHANDLE)OpenCaptureDevice(fcd.nDeviceIndex)) && m_uDevId != -1) {
		DEBUGMSG (1, ("MediaVidCtrl::Open: OpenCaptureDevice failed, trying VIDEO_MAPPER\r\n" ));
   	    FindFirstCaptureDevice(&fcd, NULL);
	   	if (m_hDev = (DPHANDLE)OpenCaptureDevice(fcd.nDeviceIndex))
			m_uDevId = (UINT) -1;	// use VIDEO_MAPPER next time
	}
   	
	if (m_hDev) {
		hr = DPR_SUCCESS;
    } else {
		DEBUGMSG (1, ("MediaVidCtrl::Open: OpenCaptureDevice failed\r\n" ));
		hr = DPR_CANT_OPEN_DEV;
    }

	return hr;
}


HRESULT VideoOutControl::Open ( void )
{
	return DPR_SUCCESS;
}


HRESULT VideoInControl::Close ( void )
{
	HRESULT hr = DPR_INVALID_PLATFORM;

	if (m_hDev)
	{
	    CloseCaptureDevice((HCAPDEV)m_hDev);
		hr = DPR_SUCCESS;
	}
	else
	{
		hr = DPR_INVALID_HANDLE;
	}

	m_hDev = NULL;

	return hr;
}


HRESULT VideoOutControl::Close ( void )
{
	return DPR_SUCCESS;
}


HRESULT VideoInControl::Start ( void )
{
	return DPR_SUCCESS;
}


HRESULT VideoOutControl::Start ( void )
{
	return DPR_SUCCESS;
}


HRESULT VideoInControl::Stop ( void )
{
	return DPR_SUCCESS;
}


HRESULT VideoOutControl::Stop ( void )
{
	return DPR_INVALID_PARAMETER;
}


HRESULT VideoInControl::Reset ( void )
{
	return VideoInControl::Stop();
}


HRESULT VideoOutControl::Reset ( void )
{
	return DPR_SUCCESS;
}


HRESULT VideoInControl::DisplayDriverDialog (HWND hwnd, DWORD dwDlgId)
{
	HRESULT hr = DPR_SUCCESS;
	DWORD dwRes;
	PDWORD pdwMask;

   	if (m_hDev) {
        if (dwDlgId & CAPTURE_DIALOG_SOURCE)
            dwDlgId = CAPDEV_DIALOG_SOURCE;
        else
            dwDlgId = CAPDEV_DIALOG_IMAGE;

#if 1
        if (!CaptureDeviceDialog(m_hDev, hwnd, dwDlgId, NULL)) {
#else
        if (!CaptureDeviceDialog(m_hDev, hwnd, dwDlgId, &((VIDEOFORMATEX *)m_pDevFmt)->bih)) {
#endif
            dwRes = GetLastError();
            if (dwRes == ERROR_DCAP_DIALOG_FORMAT || dwRes == ERROR_DCAP_DIALOG_STREAM) {
                DEBUGMSG (1, ("MediaVidCtrl::Open: CaptureDeviceDialog failed\r\n" ));
                hr = DPR_CONVERSION_FAILED; // user did something in the dialog that caused a problem
            }
            else
                hr = DPR_INVALID_PARAMETER;
        }
    }
    else
        hr = DPR_INVALID_HANDLE;

    return hr;
}

HRESULT VideoInControl::SetProp ( DWORD dwPropId, DWORD_PTR dwPropVal )
{
	HRESULT hr = DPR_SUCCESS;
	UINT ms;

	switch (dwPropId)
	{
		
	case MC_PROP_TIMEOUT:
		m_uTimeout = (DWORD)dwPropVal;
		break;

	case MC_PROP_PREFEED:
		m_uPrefeed = (DWORD)dwPropVal;
		break;

	case MC_PROP_VIDEO_FRAME_RATE:
	case MC_PROP_MAX_VIDEO_FRAME_RATE:
		break;

	default:
		hr = MediaControl::SetProp(dwPropId, dwPropVal );
		break;
	}

	return hr;
}


HRESULT VideoOutControl::SetProp ( DWORD dwPropId, DWORD_PTR dwPropVal )
{
	HRESULT hr = DPR_SUCCESS;

	switch (dwPropId)
	{
	case MC_PROP_TIMEOUT:
		m_uTimeout = (DWORD)dwPropVal;
		break;

	case MC_PROP_PREFEED:
		m_uPrefeed = (DWORD)dwPropVal;
		break;

	default:
		hr = MediaControl::SetProp(dwPropId, dwPropVal );
		break;
	}

	return hr;
}


HRESULT VideoInControl::GetProp ( DWORD dwPropId, PDWORD_PTR pdwPropVal )
{
	HRESULT hr = DPR_SUCCESS;
	DWORD dwMask;

	if (pdwPropVal)
	{
		switch (dwPropId)
		{
		case MC_PROP_TIMEOUT:
			*pdwPropVal = m_uTimeout;
			break;

		case MC_PROP_PREFEED:
			*pdwPropVal = m_uPrefeed;
			break;

		case MC_PROP_SPP:
//			*pdwPropVal = (DWORD) ((VIDEOFORMATEX *) m_pDevFmt)->nSamplesPerSec
//								* m_uDuration / 100UL;
			*pdwPropVal = m_cbSizeDevData * (DWORD) ((VIDEOFORMATEX *) m_pDevFmt)->nSamplesPerSec
						/(DWORD) ((VIDEOFORMATEX *) m_pDevFmt)->nAvgBytesPerSec;
			break;

		case MC_PROP_SPS:
			*pdwPropVal = (DWORD) ((VIDEOFORMATEX *) m_pDevFmt)->nSamplesPerSec;

			break;
			
		case MC_PROP_VIDEO_FRAME_RATE:
		case MC_PROP_MAX_VIDEO_FRAME_RATE:
			break;
			
        case MC_PROP_VFW_DIALOGS:
			*pdwPropVal = 0;
			if (vcmGetDevCapsDialogs(m_uDevId, &dwMask) == (MMRESULT)MMSYSERR_NOERROR) {
				if (dwMask & SOURCE_DLG_ON)
					*pdwPropVal = CAPTURE_DIALOG_SOURCE;
				if (dwMask & FORMAT_DLG_ON)
					*pdwPropVal |= CAPTURE_DIALOG_FORMAT;
			}
            break;

		default:
			hr = MediaControl::GetProp( dwPropId, pdwPropVal );
			break;
		}
	}
	else
	{
		hr = DPR_INVALID_PARAMETER;
	}

	return hr;
}


HRESULT VideoOutControl::GetProp ( DWORD dwPropId, PDWORD_PTR pdwPropVal )
{
	HRESULT hr = DPR_SUCCESS;

	if (pdwPropVal)
	{
		switch (dwPropId)
		{
		case MC_PROP_TIMEOUT:
			*pdwPropVal = m_uTimeout;
			break;

		case MC_PROP_PREFEED:
			*pdwPropVal = m_uPrefeed;
			break;

		case MC_PROP_SPP:
//			*pdwPropVal = (DWORD) ((VIDEOFORMATEX *) m_pDevFmt)->nSamplesPerSec
//								* m_uDuration / 100UL;
			*pdwPropVal = m_cbSizeDevData * (DWORD) ((VIDEOFORMATEX *) m_pDevFmt)->nSamplesPerSec
						/(DWORD) ((VIDEOFORMATEX *) m_pDevFmt)->nAvgBytesPerSec;
			break;

		case MC_PROP_SPS:
			*pdwPropVal = (DWORD) ((VIDEOFORMATEX *) m_pDevFmt)->nSamplesPerSec;
			
		default:
			hr = MediaControl::GetProp( dwPropId, pdwPropVal );
			break;
		}
	}
	else
	{
		hr = DPR_INVALID_PARAMETER;
	}

	return hr;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\medistrm.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    medistrm.h

Abstract:
	Contains constants and class declarations for the abstract MediaStream object. A MediaStream
	represents a single unidirectional stream, such as a received Video channel.
	
--*/
#ifndef _MEDISTRM_H_
#define _MEDISTRM_H_

#include "dtmf.h"

#include <pshpack8.h> /* Assume 8 byte packing throughout */


class DataPump;
class TxStream;
class RxStream;
class AcmFilter;
class VcmFilter;
class MediaControl;
class BufferPool;
class AudioPacket;
class VideoPacket;

class SendMediaStream : public IMediaChannel {
	friend class SendAudioStream;
protected:
	DataPump *m_pDP;
	TxStream *m_SendStream;
	MediaControl *m_InMedia;
	UINT m_CaptureDevice;		// device id used for recording
	UINT m_PreviousCaptureDevice;		// device id used for recording
	IRTPSession *m_Net;
	IRTPSend *m_pRTPSend;
	BYTE m_RTPPayload;			// payload type
	//BufferPool *m_NetBufferPool;
	DWORD m_SendTimestamp;
	DWORD m_SavedTickCount;
	DWORD m_ThreadFlags;
	DWORD m_DPFlags;
	BOOL m_fSending;
	MEDIA_FORMAT_ID m_PrevFormatId;
	DWORD m_dwDstSize;


	FLOWSPEC m_flowspec;
	HRESULT SetFlowSpec();


	HANDLE m_hCapturingThread;
	DWORD m_CaptureThId;

	CRITICAL_SECTION m_crsQos;

	// IQOS interface pointer and two resources requests: one for BW and one for CPU
	struct {
		int cResourceRequests;
		RESOURCEREQUEST aResourceRequest[2];
	} m_aRRq;

	// Performance statistics
	struct {
		DWORD dwMsCap;					// Capture CPU usage (ms)
		DWORD dwMsComp;					// Compression CPU usage (ms)
        DWORD dwBits;				    // Compressed audio or video frame size (bits)
		DWORD dwCount;					// Number of video frames captured or audio packets recorded
		DWORD dwOldestTs;				// Oldest QoS callback timestamp
		DWORD dwNewestTs;				// Most recent QoS callback timestamp
		HKEY hPerfKey;					// Handle to CPU perf data collection reg key on Win95/98
		DWORD dwSmoothedCPUUsage;		// Previous CPU usage value - used to compute slow-varying average in CPU usage
		BOOL fWinNT;					// Are we running on WinNT or Win95/98?
		struct {						// Structure used to extract CPU usage performance on NT
			DWORD		cbPerfData;
			PBYTE		pbyPerfData;
			HANDLE		hPerfData;
			LONGLONG	llPerfTime100nSec;
			PLONGLONG	pllCounterValue;
			DWORD		dwProcessorIndex;
			DWORD		dwPercentProcessorIndex;
			DWORD		dwNumProcessors;
		} NtCPUUsage;
	} m_Stats;

	RTP_STATS m_RTPStats;			// network stats
public:
	SendMediaStream()
	{
		InitializeCriticalSection(&m_crsQos);
	};
	virtual ~SendMediaStream()
	{
		DeleteCriticalSection(&m_crsQos);
	}

	// Implementation of IMediaChannel::GetState
	STDMETHODIMP_(DWORD) GetState()
	{
		if (m_DPFlags & DPFLAG_STARTED_SEND) return MSSTATE_STARTED;
		else if (m_DPFlags & DPFLAG_CONFIGURED_SEND) return MSSTATE_CONFIGURED;
		else return MSSTATE_UNCONFIGURED;
	}

	virtual HRESULT Initialize(DataPump *) = 0;
	virtual DWORD Send() = 0;
	virtual void EndSend() = 0;

	virtual HRESULT STDMETHODCALLTYPE SetNetworkInterface(IUnknown *pUnknown);


	} ;

class RecvMediaStream : public IMediaChannel
{
	friend class DataPump;
	friend BOOL RTPRecvCallback(DWORD_PTR,WSABUF *);
protected:
	DataPump *m_pDP;
	RxStream *m_RecvStream;
	MediaControl *m_OutMedia;
	UINT m_RenderingDevice;		// device id used for playback

	IRTPSession *m_Net;
	IRTPRecv *m_pIRTPRecv;

	//BufferPool *m_NetBufferPool;
	DWORD m_ThreadFlags;
	DWORD m_DPFlags;
	BOOL m_fReceiving;
	DWORD m_PlaybackTimestamp;	// last played sample
	
	HANDLE m_hRecvThreadStopEvent;
	HANDLE m_hRenderingThread;
	DWORD m_RenderingThId;
	UINT m_nRecvBuffersPending;

	DWORD m_dwSrcSize;

	FLOWSPEC m_flowspec;
	HRESULT SetFlowSpec();



public:
	RecvMediaStream(){};
	virtual HRESULT Initialize(DataPump *) = 0;
	virtual BOOL IsEmpty() = 0;

	// Implementation of IMediaChannel::GetState
	STDMETHODIMP_(DWORD) GetState()
	{
		if (m_DPFlags & DPFLAG_STARTED_RECV) return MSSTATE_STARTED;
		else if (m_DPFlags & DPFLAG_CONFIGURED_RECV) return MSSTATE_CONFIGURED;
		else return MSSTATE_UNCONFIGURED;
	}

	virtual HRESULT RTPCallback(WSABUF *pWsaBuf, DWORD timestamp, UINT seq, UINT fMark)=0;
	
    virtual HRESULT GetCurrentPlayNTPTime(NTP_TS *)=0;
    virtual HRESULT StartRecv(HWND)=0;
    virtual HRESULT StopRecv()=0;

	virtual HRESULT STDMETHODCALLTYPE SetNetworkInterface(IUnknown *pUnknown);


	virtual HRESULT DTMFBeep() {return S_OK;}
	virtual HRESULT OnDTMFBeep() {return S_OK;}

};


class SendVideoStream : public SendMediaStream, public IVideoRender,
                        public IVideoChannel
{
	friend class DataPump;
protected:
    CCaptureChain* m_pCaptureChain;
	VIDEOFORMATEX  m_fDevSend;
	VIDEOFORMATEX  m_fCodecOutput;
	RECT m_cliprect;
	DWORD m_maxfps;
	DWORD m_frametime;

	int *m_pTSTable; // NULL if table isn't used
	DWORD m_dwCurrentTSSetting;

	VcmFilter *m_pVideoFilter;
	IUnknown *m_pIUnknown;					// Pointer to IUnkown from which we'll query the Stream Signal interface

    class MediaPacket *m_pNextPacketToRender;	// current recv video frame
	UINT m_cRendering;		// count of packets given out by GetFrame()
	HANDLE m_hRenderEvent;	// IVideoRender event for recv notification
	LPFNFRAMEREADY m_pfFrameReadyCallback;	// callback function
	CRITICAL_SECTION m_crs;

	CRITICAL_SECTION m_crsVidQoS; // Allows QoS thread to read the video statistics while capture and compression are running

	// the capture thread (and it's launch function)
	static DWORD CALLBACK StartCaptureThread(LPVOID pVoid);
	DWORD CapturingThread();


	HRESULT SendPacket(VideoPacket *pVP, UINT *puBytesSent);
	STDMETHODIMP_(void) UnConfigure(void);

	LONG m_lRefCount;

public:	
	SendVideoStream(): SendMediaStream(){m_Net=NULL; m_lRefCount=0; };
	virtual ~SendVideoStream();
	
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
	virtual ULONG STDMETHODCALLTYPE AddRef(void);
	virtual ULONG STDMETHODCALLTYPE Release(void);

	
	// IMediaChannel APIs
	// new version of Configure()
	HRESULT STDMETHODCALLTYPE Configure(
		BYTE *pFormat,
		UINT cbFormat,
		BYTE *pChannelParams,
		UINT cbParams,
		IUnknown *pUnknown);

	STDMETHODIMP Start(void);
	STDMETHODIMP Stop(void);

	HRESULT STDMETHODCALLTYPE SetNetworkInterface(IUnknown *pUnknown)
	{
		return SendMediaStream::SetNetworkInterface(pUnknown);
	}

	STDMETHODIMP_(DWORD) GetState()
	{
		return SendMediaStream::GetState();
	}

	HRESULT STDMETHODCALLTYPE SetMaxBitrate(UINT uMaxBitrate);


	// IVideoChannel
	virtual HRESULT __stdcall SetTemporalSpatialTradeOff(DWORD dwVal);
	virtual HRESULT __stdcall GetTemporalSpatialTradeOff(DWORD *pdwVal);
	virtual HRESULT __stdcall SendKeyFrame(void);
	virtual HRESULT __stdcall ShowDeviceDialog(DWORD dwFlags);
	virtual HRESULT __stdcall GetDeviceDialog(DWORD *pdwFlags);

    // IProperty methods
	STDMETHODIMP GetProperty(DWORD dwProp, PVOID pBuf, LPUINT pcbBuf);
	STDMETHODIMP SetProperty(DWORD dwProp, PVOID pBuf, UINT cbBuf);

	// IVideoRender methods
	STDMETHODIMP Init( DWORD_PTR dwUser, LPFNFRAMEREADY pfCallback);
	STDMETHODIMP Done(void);
	STDMETHODIMP GetFrame(FRAMECONTEXT* pfc);
	STDMETHODIMP ReleaseFrame(FRAMECONTEXT *pfc);

	// Other virtual methods
	virtual HRESULT Initialize(DataPump *);

	// Non virtual methods
	static HRESULT CALLBACK QosNotifyVideoCB(LPRESOURCEREQUESTLIST lpResourceRequestList, DWORD_PTR dwThis);
	void UnConfigureSendVideo(BOOL fNewDeviceSettings, BOOL fNewDevice);
	void StartCPUUsageCollection(void);
	BOOL GetCPUUsage(PDWORD pdwOverallCPUUsage);
	void StopCPUUsageCollection(void);
	BOOL SetTargetRates(DWORD dwTargetFrameRate, DWORD dwTargetBitrate);
	DWORD Send();
	void EndSend();


};

class RecvVideoStream : public RecvMediaStream, public IVideoRender {
	friend class DataPump;
protected:
	VIDEOFORMATEX  m_fDevRecv;
	RECT m_cliprect;
	class MediaPacket *m_pNextPacketToRender;	// current recv video frame
	UINT m_cRendering;		// count of packets given out by GetFrame()
	HANDLE m_hRenderEvent;	// IVideoRender event for recv notification
	LPFNFRAMEREADY m_pfFrameReadyCallback;	// callback function
	CRITICAL_SECTION m_crs;
	VcmFilter *m_pVideoFilter;
	IUnknown *m_pIUnknown;					// Pointer to IUnkown from which we'll query the Stream Signal interface
	IStreamSignal *m_pIStreamSignal;		// Pointer to I-Frame request interface
	CRITICAL_SECTION m_crsIStreamSignal;	// Used to serialize access to the interface between Stop() and the RTP callback
	UINT m_ulLastSeq;						// Last received RTP sequence number
	DWORD m_dwLastIFrameRequest;			// When was the last I-frame request sent? Used to make sure we don't send requests too often
	BOOL m_fDiscontinuity;					// Signals that a discontinuity (RTP packet lost or receive frame buffer overflow) was detected

	CRITICAL_SECTION m_crsVidQoS; // Allows QoS thread to read the video statistics while capture and compression are running

	static DWORD CALLBACK StartRenderingThread(PVOID pVoid);
	DWORD RenderingThread();

	STDMETHODIMP_(void) UnConfigure(void);

	LONG m_lRefCount;

public:	
	RecvVideoStream() : RecvMediaStream(){m_Net=NULL; m_lRefCount=0; };
	virtual ~RecvVideoStream();
	
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
	virtual ULONG STDMETHODCALLTYPE AddRef(void);
	virtual ULONG STDMETHODCALLTYPE Release(void);

	// IMediaChannel APIs
	HRESULT STDMETHODCALLTYPE Configure(
		BYTE *pFormat,
		UINT cbFormat,
		BYTE *pChannelParams,
		UINT cbParams,
		IUnknown *pUnknown);


	STDMETHODIMP Start(void);
	STDMETHODIMP Stop(void);

	HRESULT STDMETHODCALLTYPE SetMaxBitrate(UINT uMaxBitrate)
	{
		return E_NOTIMPL;
	}

    // IProperty methods
	STDMETHODIMP GetProperty(DWORD dwProp, PVOID pBuf, LPUINT pcbBuf);
	STDMETHODIMP SetProperty(DWORD dwProp, PVOID pBuf, UINT cbBuf);

	// IVideoRender methods
	STDMETHODIMP Init( DWORD_PTR dwUser, LPFNFRAMEREADY pfCallback);
	STDMETHODIMP Done(void);
	STDMETHODIMP GetFrame(FRAMECONTEXT* pfc);
	STDMETHODIMP ReleaseFrame(FRAMECONTEXT *pfc);

	// Other virtual methods
	virtual HRESULT Initialize(DataPump *);
	virtual BOOL IsEmpty();
	HRESULT GetCurrentPlayNTPTime(NTP_TS *);
    virtual HRESULT StartRecv(HWND);
    virtual HRESULT StopRecv();

	virtual HRESULT RTPCallback(WSABUF *pWsaBuf, DWORD timestamp, UINT seq, UINT fMark);


	// Non virtual methods

};

extern char LogScale[];

class AudioSilenceDetector {
private:
	UINT		m_uManualSilenceLevel;	// silence level in unit of 1/1000
	DWORD 		m_dwMaxStrength;	// signal strength in units of 1/1000
	INT 		m_iSilenceLevel;	// adaptive silence threshold
	INT 		m_iSilenceAvg;		// scale factor 256
	INT 		m_iTalkAvg;			// average strength of non-silent signal

public:
	AudioSilenceDetector();
	void SetSilenceLevel(UINT level) {m_uManualSilenceLevel = level;}
	UINT GetSilenceLevel(void)  {return m_uManualSilenceLevel;}
	UINT GetSignalStrength(void) {return LogScale[m_dwMaxStrength >> 8];}
	BOOL SilenceDetect(WORD strength);
};

class SendAudioStream : public SendMediaStream, public IAudioChannel, public IDTMFSend
{
	friend class DataPump;
private:
	WAVEFORMATEX m_fDevSend;
	WAVEFORMATEX m_wfCompressed;
	AcmFilter *m_pAudioFilter;  // this will replace m_fSendFilter
	MMIOSRC		m_mmioSrc;
	AudioSilenceDetector m_AudioMonitor;
	BOOL	m_bAutoMix;

	static DWORD CALLBACK StartRecordingThread (LPVOID pVoid);
	DWORD RecordingThread();

	HRESULT SendPacket(AudioPacket *pAP, UINT *puBytesSent);
	STDMETHODIMP_(void) UnConfigure(void);

	LONG m_lRefCount;

	DTMFQueue *m_pDTMF;
	HRESULT __stdcall SendDTMF();

public:
	SendAudioStream() : SendMediaStream(){m_Net=NULL;m_lRefCount=0;};
	virtual ~SendAudioStream();


	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
	virtual ULONG STDMETHODCALLTYPE AddRef(void);
	virtual ULONG STDMETHODCALLTYPE Release(void);

	// IMediaChannel APIs
	// new version of Configure()
	HRESULT STDMETHODCALLTYPE Configure(
		BYTE *pFormat,
		UINT cbFormat,
		BYTE *pChannelParams,
		UINT cbParams,
		IUnknown *pUnknown);

	STDMETHODIMP Start(void);
	STDMETHODIMP Stop(void);

	HRESULT STDMETHODCALLTYPE SetNetworkInterface(IUnknown *pUnknown)
	{
		return SendMediaStream::SetNetworkInterface(pUnknown);
	}

	STDMETHODIMP_(DWORD) GetState()
	{
		return SendMediaStream::GetState();
	}

	HRESULT STDMETHODCALLTYPE SetMaxBitrate(UINT uMaxBitrate);

	// IAudioChannel
	STDMETHODIMP GetSignalLevel(UINT *pSignalStrength);

	
	// IDTMFSend
	virtual HRESULT __stdcall AddDigit(int nDigit);
	virtual HRESULT __stdcall ResetDTMF();


    // IProperty methods
	STDMETHODIMP GetProperty(DWORD dwProp, PVOID pBuf, LPUINT pcbBuf);
	STDMETHODIMP SetProperty(DWORD dwProp, PVOID pBuf, UINT cbBuf);

	// Other virtual methods
	virtual HRESULT Initialize(DataPump *pdp);

	// Non virtual methods
	static HRESULT CALLBACK QosNotifyAudioCB(LPRESOURCEREQUESTLIST lpResourceRequestList, DWORD_PTR dwThis);

	HRESULT OpenSrcFile (void);
	HRESULT CloseSrcFile (void);
	DWORD Send();
	void EndSend();

};

class RecvAudioStream : public RecvMediaStream, public IAudioChannel
{
	friend class DataPump;
private:
	WAVEFORMATEX m_fDevRecv;
	IAppAudioCap* m_pAudioCaps;	// pointer to the audio capabilities object
	// mmio file operations
	MMIODEST	m_mmioDest;

	AcmFilter *m_pAudioFilter;  // this will replace m_fSendFilter

	AudioSilenceDetector m_AudioMonitor;
	
	CRITICAL_SECTION m_crsAudQoS; // Allows QoS thread to read the audio statistics while recording and compression are running

	static DWORD CALLBACK StartPlaybackThread(LPVOID pVoid);
	DWORD PlaybackThread();

	STDMETHODIMP_(void) UnConfigure(void);

	LONG m_lRefCount;

	virtual HRESULT DTMFBeep();


public:	
	RecvAudioStream() :RecvMediaStream(){m_Net=NULL;m_lRefCount=0;};
	virtual ~RecvAudioStream();


	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
	virtual ULONG STDMETHODCALLTYPE AddRef(void);
	virtual ULONG STDMETHODCALLTYPE Release(void);


	// IMediaChannel APIs
	HRESULT STDMETHODCALLTYPE Configure(
		BYTE *pFormat,
		UINT cbFormat,
		BYTE *pChannelParams,
		UINT cbParams,
		IUnknown *pUnknown);


	STDMETHODIMP Start(void);
	STDMETHODIMP Stop(void);

	HRESULT STDMETHODCALLTYPE SetNetworkInterface(IUnknown *pUnknown)
	{
		return RecvMediaStream::SetNetworkInterface(pUnknown);
	}

	STDMETHODIMP_(DWORD) GetState()
	{
		return RecvMediaStream::GetState();
	}

	HRESULT STDMETHODCALLTYPE SetMaxBitrate(UINT uMaxBitrate)
	{
		return E_NOTIMPL;
	}

	// IAudioChannel
	STDMETHODIMP GetSignalLevel(UINT *pSignalStrength);


    // IProperty methods
	STDMETHODIMP GetProperty(DWORD dwProp, PVOID pBuf, LPUINT pcbBuf);
	STDMETHODIMP SetProperty(DWORD dwProp, PVOID pBuf, UINT cbBuf);

	// Other virtual inherited methods
	virtual HRESULT Initialize(DataPump *);
	virtual BOOL IsEmpty();
	HRESULT GetCurrentPlayNTPTime(NTP_TS *);
    virtual HRESULT StartRecv(HWND);
    virtual HRESULT StopRecv();

	virtual HRESULT RTPCallback(WSABUF *pWsaBuf, DWORD timestamp, UINT seq, UINT fMark);



};

#include <poppack.h> /* End byte packing */


#endif // _MEDISTRM_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\mixer.h ===
// File: mixer.h

#ifndef _MIXER_H_
#define _MIXER_H_

typedef struct tagMixLine
{
	UINT	ucChannels;
	BOOL	fIdValid;
	DWORD	dwControlId;

	DWORD dwLineId;   // line ID of destination
	DWORD dwCompType; // Component type
	DWORD dwConnections; // number of sources associated with this line
} MIXLINE;

class CMixerDevice : public IMixer
{
private:
	HMIXER	 	m_hMixer;
	MIXERCAPS	m_mixerCaps;
	MIXLINE		m_DstLine;
	MIXLINE		m_SrcLine;

	BOOL		Init( HWND hWnd, UINT_PTR uWaveDevId, DWORD dwFlags);

	LONG m_lRefCount;

protected:
	CMixerDevice() : m_lRefCount(0)
	{
		m_hMixer = NULL;
		ZeroMemory (&m_DstLine, sizeof(m_DstLine));
		ZeroMemory (&m_SrcLine, sizeof(m_SrcLine));
	}

public:
	~CMixerDevice()
	{
		if (NULL != m_hMixer)
		{
			mixerClose(m_hMixer);
		}
	}

	BOOL __stdcall SetVolume (DWORD dwVolume)
	{
		BOOL fSetMain = SetMainVolume(dwVolume);
		BOOL fSetSub = SetSubVolume(dwVolume);
		return fSetMain || fSetSub;
	}
	BOOL __stdcall CanSetVolume () { return m_DstLine.fIdValid || m_SrcLine.fIdValid; }
	BOOL __stdcall SetMainVolume(DWORD dwVolume);
	BOOL __stdcall SetSubVolume(DWORD dwVolume);
	BOOL __stdcall SetAGC(BOOL fOn);
	BOOL __stdcall GetMainVolume(LPDWORD pdwVolume);
	BOOL __stdcall GetSubVolume(LPDWORD pdwVolume);
	BOOL __stdcall GetAGC(BOOL *pfOn);
	BOOL __stdcall EnableMicrophone();
	BOOL __stdcall UnMuteVolume();
	static CMixerDevice* GetMixerForWaveDevice( HWND hWnd, UINT uWaveDevId, DWORD dwFlags);

	// IUnknown
	HRESULT __stdcall QueryInterface(const IID&, void**);
	ULONG __stdcall AddRef();
	ULONG __stdcall Release();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\medvctrl.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    medvctrl.h

Abstract:
	Defines the MediaControl class which encapsulates the multimedia devices, in particular
	videoIn and videoOut.

--*/

#ifndef _MEDVCTRL_H_
#define _MEDVCTRL_H_

#include <pshpack8.h> /* Assume 8 byte packing throughout */

class VideoInControl : public MediaControl {
private:
	UINT		m_uTimeout;			// timeout in notification wait
	UINT		m_uPrefeed;			// num of buffers prefed to device
	UINT 		m_FPSRequested;     // requested frame rate
	UINT		m_FPSMax;           // max frame rate
public:	
	VideoInControl ( void );
	~VideoInControl ( void );

	HRESULT Initialize ( MEDIACTRLINIT * p );
	HRESULT Configure ( MEDIACTRLCONFIG * p );
	HRESULT SetProp ( DWORD dwPropId, DWORD_PTR dwPropVal );
	HRESULT GetProp ( DWORD dwPropId, PDWORD_PTR pdwPropVal );
	HRESULT Open ( void );
	HRESULT Start ( void );
	HRESULT Stop ( void );
	HRESULT Reset ( void );
	HRESULT Close ( void );
	HRESULT DisplayDriverDialog (HWND hwnd, DWORD dwDlgId);
};

class VideoOutControl : public MediaControl {
private:
	UINT		m_uTimeout;			// timeout in notification wait
	UINT		m_uPrefeed;			// num of buffers prefed to device
	UINT		m_uPosition;		// position of the playback stream
public:	
	VideoOutControl ( void );
	~VideoOutControl ( void );

	HRESULT Initialize ( MEDIACTRLINIT * p );
	HRESULT Configure ( MEDIACTRLCONFIG * p );
	HRESULT SetProp ( DWORD dwPropId, DWORD_PTR dwPropVal );
	HRESULT GetProp ( DWORD dwPropId, PDWORD_PTR pdwPropVal );
	HRESULT Open ( void );
	HRESULT Start ( void );
	HRESULT Stop ( void );
	HRESULT Reset ( void );
	HRESULT Close ( void );
};

enum {
	MC_PROP_VIDEO_FRAME_RATE = MC_PROP_NumOfProps,
	MC_PROP_MAX_VIDEO_FRAME_RATE,
	MC_PROP_VFW_DIALOGS
	};

#include <poppack.h> /* End byte packing */

#endif // _MEDVCTRL_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\msh26x.h ===
typedef enum tagFrameSize
{
	FORBIDDEN=0,
	SQCIF=1,
	QCIF=2,
	CIF=3,
	fCIF=4,
	ssCIF=5

}FrameSize;

// MSH26X Configuration Information
typedef struct tagMSH26XCONF{
	BOOL	bInitialized;               // Whether custom msgs can be rcv'd.
	BOOL	bCompressBegin;				// Whether the CompressBegin msg was rcv'd.
	BOOL	bRTPHeader;                 // Whether to generate RTP header info
	/* used if bRTPHeader */
	UINT	unPacketSize;               // Maximum packet size
	BOOL	bEncoderResiliency;         // Whether to use resiliency restrictions
	/* used if bEncoderResiliency */
	UINT	unPacketLoss;
	BOOL	bBitRateState;
	/* used if bBitRateState */
	UINT	unBytesPerSecond;
	/* The following information is determined from the packet loss value.   */
	/*  These values are calculated each time we receive a resiliency msg or */
	/*  the value is changed through the dialog box.  They are not stored in */
	/*  the registry.  Only the above elements are stored in the registry.   */
	BOOL	bDisallowPosVerMVs;   		// if true, disallow positive vertical MVs
	BOOL	bDisallowAllVerMVs;   		// if true, disallow all vertical MVs
	UINT	unPercentForcedUpdate;      // Percent Forced Update per Frame
	UINT	unDefaultIntraQuant;        // Default Intra Quant
	UINT	unDefaultInterQuant;        // Default Inter Quant
} MSH26XCONF;

// MSH26X Compressor Instance information
typedef struct tagMSH26XCOMPINSTINFO{
	BOOL		Initialized;
	WORD		xres, yres;
	FrameSize	FrameSz;		// Which of the supported frame sizes.
	float		FrameRate;
	DWORD		DataRate;		// Data rate in bytes per second.
	HGLOBAL		hEncoderInst;   // Instance data private to encoder.
	LPVOID		EncoderInst;
	WORD		CompressedSize;
	BOOL		Is160x120;
	BOOL		Is240x180;
	BOOL		Is320x240;
	MSH26XCONF	Configuration;
#if !defined(_ALPHA_) && defined(USE_BILINEAR_MSH26X)
	UINT		InputCompression;
	UINT		InputBitWidth;
#endif
} MSH26XCOMPINSTINFO, *PMSH26XCOMPINSTINFO;

// MSH26X BitStream Info Trailer structure
typedef struct tagH26X_RTP_BSINFO_TRAILER {
	DWORD dwVersion;
	DWORD dwFlags;
	DWORD dwUniqueCode;
	DWORD dwCompressedSize;
	DWORD dwNumOfPackets;
	BYTE  bySrc;
	BYTE  byTR;
	BYTE  byTRB;
	BYTE  byDBQ;
} H26X_RTP_BSINFO_TRAILER, *PH26X_RTP_BSINFO_TRAILER;

// MSH263 BitStream Info structure
typedef struct tagRTP_H263_BSINFO {
	DWORD dwFlags;
	DWORD dwBitOffset;
	BYTE  byMode;
	BYTE  byMBA;
	BYTE  byQuant;
	BYTE  byGOBN;
	char  cHMV1;
	char  cVMV1;
	char  cHMV2;
	char  cVMV2;
} RTP_H263_BSINFO, *PRTP_H263_BSINFO;

// MSH261 BitStream Info structure
typedef struct tagRTP_H261_BSINFO {
	DWORD dwFlags;
	DWORD dwBitOffset;
	BYTE  byMBA;
	BYTE  byQuant;
	BYTE  byGOBN;
	char  cHMV;
	char  cVMV;
	BYTE  byPadding0;
	WORD  wPadding1;
} RTP_H261_BSINFO, *PRTP_H261_BSINFO;

// Constants
#define H263_RTP_BS_START_CODE		MakeFOURCC('H','2','6','3')
#define H261_RTP_BS_START_CODE		MakeFOURCC('H','2','6','1')
#define RTP_H26X_INTRA_CODED		0x00000001
#define RTP_H263_PB					0x00000002
#define RTP_H263_AP					0x00000004
#define RTP_H263_SAC				0x00000008
#define RTP_H263_MODE_A				0x00
#define RTP_H263_MODE_B				0x01
#define RTP_H263_MODE_C				0x02
#define H26X_RTP_PAYLOAD_VERSION    0x00000000
#define RTP_H26X_PACKET_LOST		0x00000001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\msivcaps.cpp ===
/*
 *  	File: msivcaps.cpp
 *
 *		VCM implementation of Microsoft Network Video capability object.
 *
 *		Revision History:
 *
 *		06/06/96	mikev	created msiacaps.cpp
 *		07/28/96	philf	created (added support for video)
 */


#define _MSIAV_ TRUE
#include "precomp.h"


BOOL GetFormatBuffer();
extern PVCMFORMATDETAILS pvfd_g;

#define PREF_ORDER_UNASSIGNED 0xffff

//External function (in msiacaps.cpp) to read reg info in one shot
#ifdef DEBUG
extern ULONG ReadRegistryFormats (LPCSTR lpszKeyName,CHAR ***pppName,BYTE ***pppData,PUINT pnFormats,DWORD dwDebugSize);
#else
extern ULONG ReadRegistryFormats (LPCSTR lpszKeyName,CHAR ***pppName,BYTE ***pppData,PUINT pnFormats);
#endif



//This can be used as an export, so give it a unique name!
#ifndef _ALPHA_
VIDCAP_DETAILS default_vid_table[] =
{
#ifdef USE_BILINEAR_MSH26X
	{VIDEO_FORMAT_MSH263,STD_VID_TERMCAP(H245_CLIENT_VID_H263),STD_VID_PARAMS,{RTP_PAYLOAD_H263,0,30, 24, Small, 128, 96},0,TRUE,TRUE,1,245760*8,245760*8,10,10,5,0,NULL,0,NULL,"Microsoft H.263 Video Codec, vidc.M263, 24bit, 30fps, 128x096"},
	{VIDEO_FORMAT_MSH263,STD_VID_TERMCAP(H245_CLIENT_VID_H263),STD_VID_PARAMS,{RTP_PAYLOAD_H263,0,30, 24, Medium, 176, 144},0,TRUE,TRUE,1,245760*8,245760*8,10,10,4,0,NULL,0,NULL,"Microsoft H.263 Video Codec, vidc.M263, 24bit, 30fps, 176x144"},
	{VIDEO_FORMAT_MSH263,STD_VID_TERMCAP(H245_CLIENT_VID_H263),STD_VID_PARAMS,{RTP_PAYLOAD_H263,0,30, 24, Large, 352, 288},0,TRUE,TRUE,1,245760*8*4,245760*8*4,10,10,6,0,NULL,0,NULL,"Microsoft H.263 Video Codec, vidc.M263, 24bit, 30fps, 352x288"},
	{VIDEO_FORMAT_MSH261,STD_VID_TERMCAP(H245_CLIENT_VID_H261),STD_VID_PARAMS,{RTP_PAYLOAD_H261,0,30, 24, Medium, 176, 144},0,TRUE,TRUE,1,245760*8,245760*8,10,10,7,0,NULL,0,NULL,"Microsoft H.261 Video Codec, vidc.M261, 24bit, 30fps, 176x144"},
	{VIDEO_FORMAT_MSH261,STD_VID_TERMCAP(H245_CLIENT_VID_H261),STD_VID_PARAMS,{RTP_PAYLOAD_H261,0,30, 24, Large, 352, 288},0,TRUE,TRUE,1,245760*8*4,245760*8*4,10,10,8,0,NULL,0,NULL,"Microsoft H.261 Video Codec, vidc.M261, 24bit, 30fps, 352x288"},
	{VIDEO_FORMAT_MSH26X,NONSTD_VID_TERMCAP,STD_VID_PARAMS,{RTP_DYNAMIC_MIN+1,0,24, Small, 80, 64},0,TRUE,TRUE,1,245760*8,245760*8,10,10,2,0,NULL,0,NULL,"Microsoft H.263 Video Codec, vidc.M26X, 24bit, 30fps, 080x064"},
	{VIDEO_FORMAT_MSH26X,NONSTD_VID_TERMCAP,STD_VID_PARAMS,{RTP_DYNAMIC_MIN+1,0,30, 24, Medium, 128, 96},0,TRUE,TRUE,1,245760*8,245760*8,10,10,1,0,NULL,0,NULL,"Microsoft H.263 Video Codec, vidc.M26X, 24bit, 30fps, 128x096"},
	{VIDEO_FORMAT_MSH26X,NONSTD_VID_TERMCAP,STD_VID_PARAMS,{RTP_DYNAMIC_MIN+1,0,24, Large, 176, 144},0,TRUE,TRUE,1,245760*8,245760*8,10,10,3,0,NULL,0,NULL,"Microsoft H.263 Video Codec, vidc.M26X, 24bit, 30fps, 176x144"}
#else
	{VIDEO_FORMAT_MSH263,STD_VID_TERMCAP(H245_CLIENT_VID_H263),STD_VID_PARAMS,{RTP_PAYLOAD_H263,0,30, 24, Small, 128, 96},0,TRUE,TRUE,1,245760*8,245760*8,10,10,5,0,NULL,0,NULL,"Microsoft H.263 Video Codec, vidc.M263, 24bit, 30fps, 128x096"},
	{VIDEO_FORMAT_MSH263,STD_VID_TERMCAP(H245_CLIENT_VID_H263),STD_VID_PARAMS,{RTP_PAYLOAD_H263,0,30, 24, Medium, 176, 144},0,TRUE,TRUE,1,245760*8,245760*8,10,10,2,0,NULL,0,NULL,"Microsoft H.263 Video Codec, vidc.M263, 24bit, 30fps, 176x144"},
	{VIDEO_FORMAT_MSH263,STD_VID_TERMCAP(H245_CLIENT_VID_H263),STD_VID_PARAMS,{RTP_PAYLOAD_H263,0,30, 24, Large, 352, 288},0,TRUE,TRUE,1,245760*8*4,245760*8*4,10,10,14,0,NULL,0,NULL,"Microsoft H.263 Video Codec, vidc.M263, 24bit, 30fps, 352x288"},
	{VIDEO_FORMAT_MSH261,STD_VID_TERMCAP(H245_CLIENT_VID_H261),STD_VID_PARAMS,{RTP_PAYLOAD_H261,0,30, 24, Medium, 176, 144},0,TRUE,TRUE,1,245760*8,245760*8,10,10,9,0,NULL,0,NULL,"Microsoft H.261 Video Codec, vidc.M261, 24bit, 30fps, 176x144"},
	{VIDEO_FORMAT_MSH261,STD_VID_TERMCAP(H245_CLIENT_VID_H261),STD_VID_PARAMS,{RTP_PAYLOAD_H261,0,30, 24, Large, 352, 288},0,TRUE,TRUE,1,245760*8*4,245760*8*4,10,10,20,0,NULL,0,NULL,"Microsoft H.261 Video Codec, vidc.M261, 24bit, 30fps, 352x288"},
#endif
};
#else
VIDCAP_DETAILS default_vid_table[] =
{
	{VIDEO_FORMAT_DECH263,STD_VID_TERMCAP(H245_CLIENT_VID_H263),STD_VID_PARAMS,{RTP_PAYLOAD_H263,0,30, 24, Small,128, 96},0,TRUE,TRUE,1,53760,53760,10,10,10,0,0,5,0,NULL,0,NULL,  "Digital H263 Video CODEC, vidc.D263, 24bit, 30fps, 128x096"},
	{VIDEO_FORMAT_DECH263,STD_VID_TERMCAP(H245_CLIENT_VID_H263),STD_VID_PARAMS,{RTP_PAYLOAD_H263,0,30, 24, Medium,176, 144},0,TRUE,TRUE,1,53760,53760,10,10,10,0,0,2,0,NULL,0,NULL,"Digital H263 Video Codec, vidc.D263, 24bit, 30fps, 176x144"},
	{VIDEO_FORMAT_DECH263,STD_VID_TERMCAP(H245_CLIENT_VID_H263),STD_VID_PARAMS,{RTP_PAYLOAD_H263,0,30, 24, Large,352, 288},0,TRUE,TRUE,1,53760,53760,10,10,10,0,0,14,0,NULL,0,NULL,"Digital H263 Video Codec, vidc.D263, 24bit, 30fps, 352x288"},
	{VIDEO_FORMAT_DECH261,STD_VID_TERMCAP(H245_CLIENT_VID_H261),STD_VID_PARAMS,{RTP_PAYLOAD_H261,0,30, 24, Medium,176, 144},0,TRUE,TRUE,1,53760,53760,10,10,10,0,0,9,0,NULL,0,NULL,"Digital H261 Video Codec, vidc.D261, 24bit, 30fps, 176x144"},
	{VIDEO_FORMAT_DECH261,STD_VID_TERMCAP(H245_CLIENT_VID_H261),STD_VID_PARAMS,{RTP_PAYLOAD_H261,0,30, 24, Large,352, 288},0,TRUE,TRUE,1,53760,53760,10,10,10,0,0,20,0,NULL,0,NULL,"Digital H261 Video Codec, vidc.D261, 24bit, 30fps, 352x288"},
};
#endif
static UINT uDefVidTableEntries = sizeof(default_vid_table) /sizeof(VIDCAP_DETAILS);
static BOOL bCreateDefTable = FALSE;

//
//	static members of CMsivCapability
//

MEDIA_FORMAT_ID CMsivCapability::IDsByRank[MAX_CAPS_PRESORT];
UINT CMsivCapability::uNumLocalFormats = 0;			// # of active entries in pLocalFormats
UINT CMsivCapability::uStaticRef = 0;					// global ref count
UINT CMsivCapability::uCapIDBase = 0;					// rebase capability ID to index into IDsByRank
UINT CMsivCapability::uLocalFormatCapacity = 0;		// size of pLocalFormats (in multiples of AUDCAP_DETAILS)
VIDCAP_DETAILS * CMsivCapability::pLocalFormats = NULL;	



CMsivCapability::CMsivCapability()
:uRef(1),
wMaxCPU(95),
uNumRemoteDecodeFormats(0),
uRemoteDecodeFormatCapacity(0),
pRemoteDecodeFormats(NULL),
bPublicizeTXCaps(FALSE),
bPublicizeTSTradeoff(TRUE)
{
	m_IAppVidCap.Init(this);
}


CMsivCapability::~CMsivCapability()
{
	UINT u;
	VIDCAP_DETAILS *pDetails;
	// release global static memory (the local capabilities) if this is the last delete
	if(uStaticRef <= 1)
	{
		if (pLocalFormats)
		{	
			pDetails = pLocalFormats;
			for(u=0; u <uNumLocalFormats; u++)
			{
				if(pDetails->lpLocalFormatDetails)
				{
					MEMFREE(pDetails->lpLocalFormatDetails);
				}
				// there really should never be remote details associated with the local
				// formats........
				if(pDetails->lpRemoteFormatDetails)
				{
					MEMFREE(pDetails->lpRemoteFormatDetails);
				}
				
				pDetails++;
			}
			MEMFREE(pLocalFormats);
			pLocalFormats=NULL;
			uLocalFormatCapacity = 0;
		}
		uStaticRef--;
	}
	else
	{
		uStaticRef--;
	}
	
	if (pRemoteDecodeFormats)
	{	
		pDetails = pRemoteDecodeFormats;
		for(u=0; u <uNumRemoteDecodeFormats; u++)
		{
			if(pDetails->lpLocalFormatDetails)
			{
				MEMFREE(pDetails->lpLocalFormatDetails);
			}
			// there really should never be remote details associated with the local
			// formats........
			if(pDetails->lpRemoteFormatDetails)
			{
				MEMFREE(pDetails->lpRemoteFormatDetails);
			}
			
			pDetails++;
		}
		MEMFREE(pRemoteDecodeFormats);
		pRemoteDecodeFormats=NULL;
		uRemoteDecodeFormatCapacity  = 0;
	}
	
}
UINT CMsivCapability::GetNumCaps(BOOL bRXCaps)
{
	UINT u, uOut=0;
	
	VIDCAP_DETAILS *pDecodeDetails = pLocalFormats;
	if(bRXCaps)
	{
		for(u=0; u <uNumLocalFormats; u++)
		{
			if(pDecodeDetails->bRecvEnabled)
				uOut++;
			
			pDecodeDetails++;
		}
		return uOut;
	}
	else
	{
		for(u=0; u <uNumLocalFormats; u++)
		{
			if(pDecodeDetails->bSendEnabled)
				uOut++;
			
			pDecodeDetails++;
		}
		return uOut;
	}
}



STDMETHODIMP CMsivCapability::QueryInterface( REFIID iid,	void ** ppvObject)
{
	HRESULT hr = E_NOINTERFACE;
	if(!ppvObject)
		return hr;
		
	*ppvObject = 0;
	if(iid == IID_IAppVidCap )
	{
		*ppvObject = (LPAPPVIDCAPPIF)&m_IAppVidCap;
		AddRef();			
		hr = hrSuccess;
	}
	else if(iid == IID_IH323MediaCap)
	{
		*ppvObject = (IH323MediaCap *)this;
		AddRef();
		hr = hrSuccess;
	}
	else if (iid == IID_IUnknown)
	{
		*ppvObject = this;
		AddRef();
		hr = hrSuccess;
	}
	return hr;
}
ULONG CMsivCapability::AddRef()
{
	uRef++;
	return uRef;
}


ULONG CMsivCapability::Release()
{
	uRef--;
	if(uRef == 0)
	{
		delete this;
		return 0;
	}
	return uRef;
}
HRESULT CMsivCapability::GetNumFormats(UINT *puNumFmtOut)
{
	*puNumFmtOut = uNumLocalFormats;
	return hrSuccess;
}
VOID CMsivCapability::FreeRegistryKeyName(LPTSTR lpszKeyName)
{
	if (lpszKeyName)
    {
		LocalFree(lpszKeyName);
    }
}

LPTSTR CMsivCapability::AllocRegistryKeyName(LPTSTR lpDriverName,
		UINT uSampleRate, UINT uBitsPerSample, UINT uBitsPerSec,UINT uWidth,UINT uHeight)
{
	FX_ENTRY(("AllocRegistryKeyName"));
	BOOL bRet = FALSE;
	LPTSTR lpszKeyName = NULL;

	if(!lpDriverName)
	{
		return NULL;
	}	
	// build a subkey name (drivername_samplerate_bitspersample)
	// allow room for THREE underscore chars + 2x17 bytes of string returned
	// from _itoa

	// NOTE: use wsprintf instead of itoa - because of dependency on runtime lib
	//Added 2 UINTs for video...
	lpszKeyName = (LPTSTR)LocalAlloc (LPTR, lstrlen(lpDriverName) * sizeof(*lpDriverName) +5*20);
	if (!lpszKeyName)
	{
		ERRORMESSAGE(("%s: LocalAlloc failed\r\n",_fx_));
        return(NULL);
    }
    // build a subkey name ("drivername_samplerate_bitspersample")
	wsprintf(lpszKeyName,
				"%s_%u_%u_%u_%u_%u",
				lpDriverName,
				uSampleRate,
				uBitsPerSample,
				uBitsPerSec,
				uWidth,
				uHeight);

	return (lpszKeyName);
}

VOID CMsivCapability::SortEncodeCaps(SortMode sortmode)
{
	UINT iSorted=0;
	UINT iInsert = 0;
	UINT iCache=0;
	UINT iTemp =0;
	BOOL bInsert;	
	VIDCAP_DETAILS *pDetails1, *pDetails2;
	
	if(!uNumLocalFormats)
		return;
	if(uNumLocalFormats ==1)
	{
		IDsByRank[0]=0;
		return;
	}
	
	// look at every cached format, build index array
	for(iCache=0;iCache<uNumLocalFormats;iCache++)
	{
		pDetails1 = pLocalFormats+iCache;
		for(iInsert=0;iInsert < iSorted; iInsert++)
		{
			pDetails2 = pLocalFormats+IDsByRank[iInsert];
			// if existing stuff is less than new stuff....
			
			bInsert = FALSE;
			switch(sortmode)
			{
				case SortByAppPref:
					if(pDetails2->wApplicationPrefOrder > pDetails1->wApplicationPrefOrder)
						bInsert = TRUE;
				break;
				default:
				break;
			}
			
			if(bInsert)
			{
				if(iSorted < MAX_CAPS_PRESORT)
				{
					iSorted++;
				}
				// make room, if there is something in the last element,
				// it gets overwritten
				for(iTemp = iSorted-1; iTemp > iInsert; iTemp--)
				{
					IDsByRank[iTemp] = IDsByRank[iTemp-1];
				}
				// insert at iInsert
				IDsByRank[iInsert] = iCache;
				break;
			}
		}
		// check end boundary
		if((iInsert == iSorted) && (iInsert < MAX_CAPS_PRESORT))
		{
			IDsByRank[iInsert] = iCache;
			iSorted++;
		}
	}
}

BOOL CMsivCapability::Init()
{
	BOOL bRet;
	if(uStaticRef == 0)
	{
		if(bRet = ReInit())
		{
			uStaticRef++;
		}
	}
	else
	{
		uStaticRef++;
		bRet = TRUE;
	}
	return bRet;
}

BOOL CMsivCapability::ReInit()
{
	DWORD dwDisposition;
	BOOL bRet = TRUE;
	//CVcmCapability::ReInit();	// base class ReInit MUST ALWAYS BE CALLED
	SYSTEM_INFO si;
	ZeroMemory(&IDsByRank, sizeof(IDsByRank));
	
	// LOOKLOOK - this supports a hack to disable CPU intensive codecs if not running on a pentium
	GetSystemInfo(&si);
	wMaxCPU = (si.dwProcessorType == PROCESSOR_INTEL_PENTIUM )? 100 : 95;
	


	UINT uNumRemoteDecodeFormats;	// # of entries for remote decode capabilities
	UINT uRemoteDecodeFormatCapacity;	// size of pRemoteDecodeFormats (in multiples of VIDCAP_DETAILS)

	if (pLocalFormats)
	{	
		UINT u;
		VIDCAP_DETAILS *pDetails = pLocalFormats;
		for(u=0; u <uNumLocalFormats; u++)
		{
			if(pDetails->lpLocalFormatDetails)
			{
				MEMFREE(pDetails->lpLocalFormatDetails);
			}
			// there really should never be remote details associated with the local
			// formats........
			if(pDetails->lpRemoteFormatDetails)
			{
				MEMFREE(pDetails->lpRemoteFormatDetails);
			}
			
			pDetails++;
		}
		MEMFREE(pLocalFormats);
		pLocalFormats = NULL;
		uLocalFormatCapacity = 0;
	}

	uNumLocalFormats = 0;
	uCapIDBase = 0;					
	uLocalFormatCapacity =0;	

	// m_pAppParam should be non-NULL only if we want to add a VCM format
	// and not for standard enumeration
	m_pAppParam = NULL;

	if(!FormatEnum(this, VCM_FORMATENUMF_APP))
	{
		bRet = FALSE;
		goto RELEASE_AND_EXIT;
	}
 	SortEncodeCaps(SortByAppPref);
RELEASE_AND_EXIT:
	return bRet;
}


STDMETHODIMP CMsivCapability::GetDecodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize)
{
	// validate input
	UINT uIndex = 	IDToIndex(FormatID);
	if(uIndex >= (UINT)uNumLocalFormats)
	{
		*puSize = 0;
		*ppFormat = NULL;
		return E_INVALIDARG;
	}

	*ppFormat = (pLocalFormats + uIndex)->lpLocalFormatDetails;
	*puSize = sizeof(VIDEOFORMATEX);
	return S_OK;

}

STDMETHODIMP CMsivCapability::GetEncodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize)
{
	// same as GetDecodeFormatDetails
	return GetDecodeFormatDetails(FormatID, ppFormat, puSize);
}

VOID CMsivCapability::CalculateFormatProperties(VIDCAP_DETAILS *pFmtBuf, PVIDEOFORMATEX lpvfx)
{
	if(!pFmtBuf)
	{
		return;
	}
	
	// Estimate input bit rate
	UINT uBitrateIn = lpvfx->nSamplesPerSec * WIDTHBYTES(lpvfx->bih.biWidth * lpvfx->bih.biBitCount) * lpvfx->bih.biHeight * 8;
		
	// set the maximum bitrate (uMaxBitrate). we're not setting the average bitrate (uAvgBitrate),
	// since the nAvgBytesPerSec reported by VCM is really worst case. uAvgBitrate will be set
	// from the hardcoded numbers for our known codecs and from the provided VIDCAP_INFO for
	// installable codecs
	pFmtBuf->uMaxBitrate = (lpvfx->nAvgBytesPerSec)? lpvfx->nAvgBytesPerSec*8:uBitrateIn;
	
}

VIDEO_FORMAT_ID CMsivCapability::AddFormat(VIDCAP_DETAILS *pFmtBuf,
	LPVOID lpvMappingData, UINT uSize)
{
	VIDCAP_DETAILS *pTemp;
	VIDEO_PARAMS *pVidCapInfo;
	UINT	 format;

	if(!pFmtBuf)
	{
		return INVALID_VIDEO_FORMAT;
	}
	// check room
	if(uLocalFormatCapacity <= uNumLocalFormats)
	{
		// get more mem, realloc memory by CAP_CHUNK_SIZE for pLocalFormats
		pTemp = (VIDCAP_DETAILS *)MEMALLOC((uNumLocalFormats + CAP_CHUNK_SIZE)*sizeof(VIDCAP_DETAILS));
		if(!pTemp)
			goto ERROR_EXIT;
		// remember how much capacity we now have
		uLocalFormatCapacity = uNumLocalFormats + CAP_CHUNK_SIZE;
		#ifdef DEBUG
		if((uNumLocalFormats && !pLocalFormats) || (!uNumLocalFormats && pLocalFormats))
		{
			ERRORMESSAGE(("AddFormat:leak! uNumLocalFormats:0x%08lX, pLocalFormats:0x%08lX\r\n", uNumLocalFormats,pLocalFormats));
		}
		#endif
		// copy old stuff, discard old mem
		if(uNumLocalFormats && pLocalFormats)
		{
			memcpy(pTemp, pLocalFormats, uNumLocalFormats*sizeof(VIDCAP_DETAILS));
			MEMFREE(pLocalFormats);
		}
		pLocalFormats = pTemp;
	}
	// pTemp is where the stuff is cached
	pTemp = pLocalFormats+uNumLocalFormats;
	memcpy(pTemp, pFmtBuf, sizeof(VIDCAP_DETAILS));	
	
	pTemp->uLocalDetailsSize = 0;	// clear this now
	if(uSize && lpvMappingData)
	{
		pTemp->lpLocalFormatDetails = MEMALLOC(uSize);
		if(pTemp->lpLocalFormatDetails)
		{
			memcpy(pTemp->lpLocalFormatDetails, lpvMappingData, uSize);
			pTemp->uLocalDetailsSize = uSize;
		}
		#ifdef DEBUG
			else
			{
				ERRORMESSAGE(("AddFormat:allocation failed!\r\n"));
			}
		#endif
	}
	else
	{

	}


	// LOOKLOOK NEED TO FIXUP channel parameters

	// pTemp->dwDefaultSamples
	// pTemp->nonstd_params.wFramesPerPkt
	// pTemp->nonstd_params.wFramesPerPktMax
	// pTemp->nonstd_params.wFramesPerPktMin
	// pTemp->nonstd_params.wDataRate
	// pTemp->nonstd_params.wFrameSize
	
	
	// fixup the H245 parameters.  Use the index of the cap entry as the cap ID
	pTemp->H245Cap.CapId = (USHORT)IndexToId(uNumLocalFormats);

	if(pTemp->H245Cap.ClientType ==0
				|| pTemp->H245Cap.ClientType ==H245_CLIENT_VID_NONSTD)
	{

			pTemp->H245Cap.Cap.H245Vid_NONSTD.nonStandardIdentifier.choice = h221NonStandard_chosen;
			// NOTE: there is some question about the correct byte order
			// of the codes in the h221NonStandard structure
			pTemp->H245Cap.Cap.H245Vid_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode = USA_H221_COUNTRY_CODE;
			pTemp->H245Cap.Cap.H245Vid_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension = USA_H221_COUNTRY_EXTENSION;
			pTemp->H245Cap.Cap.H245Vid_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode = MICROSOFT_H_221_MFG_CODE;
			// Set the nonstandard data fields to null for now. The nonstandard cap data will be
			// created when capabilities are serialized.
			
			pTemp->H245Cap.Cap.H245Vid_NONSTD.data.length = 0;
			pTemp->H245Cap.Cap.H245Vid_NONSTD.data.value = NULL;
	}
	else
	{
		switch  (pTemp->H245Cap.ClientType )
		{
			case H245_CLIENT_VID_H263: {

			   pVidCapInfo=&pTemp->video_params;

			   format=get_format (pVidCapInfo->biWidth,pVidCapInfo->biHeight);
			   switch (format) {	
				case SQCIF: {
				     pTemp->H245Cap.Cap.H245Vid_H263.bit_mask =H263VideoCapability_sqcifMPI_present;
				     //MPI minimum interval in units of 1/29.97sec so 30/ (frames/sec) is reasonable
				     pTemp->H245Cap.Cap.H245Vid_H263.sqcifMPI = 30/pVidCapInfo->uSamplesPerSec;
				     pTemp->H245Cap.Cap.H245Vid_H263.H263VdCpblty_qcifMPI =0;
				     pTemp->H245Cap.Cap.H245Vid_H263.H263VdCpblty_cifMPI =0;
				     break;
		

				}
				case QCIF: {
				     pTemp->H245Cap.Cap.H245Vid_H263.bit_mask =H263VideoCapability_qcifMPI_present;

				     pTemp->H245Cap.Cap.H245Vid_H263.sqcifMPI = 0;
				     pTemp->H245Cap.Cap.H245Vid_H263.H263VdCpblty_qcifMPI =30/pVidCapInfo->uSamplesPerSec;
				     pTemp->H245Cap.Cap.H245Vid_H263.H263VdCpblty_cifMPI =0;
				     break;

				}
				case CIF: {
				     pTemp->H245Cap.Cap.H245Vid_H263.bit_mask =H263VideoCapability_cifMPI_present;
				
				     pTemp->H245Cap.Cap.H245Vid_H263.sqcifMPI = 0;
				     pTemp->H245Cap.Cap.H245Vid_H263.H263VdCpblty_qcifMPI =0;
				     pTemp->H245Cap.Cap.H245Vid_H263.H263VdCpblty_cifMPI =30/pVidCapInfo->uSamplesPerSec;
				     break;
	
				}

				  default:
					 break;
			   }
				

			   pTemp->H245Cap.Cap.H245Vid_H263.cif4MPI	=0;
			   pTemp->H245Cap.Cap.H245Vid_H263.cif16MPI	=0;
			   pTemp->H245Cap.Cap.H245Vid_H263.maxBitRate	= pFmtBuf->uMaxBitrate / 100;	// in units of 100 bits/s
					
			   pTemp->H245Cap.Cap.H245Vid_H263.unrestrictedVector = FALSE;
			   pTemp->H245Cap.Cap.H245Vid_H263.arithmeticCoding 	= FALSE;
			   pTemp->H245Cap.Cap.H245Vid_H263.advancedPrediction	= FALSE;
			   pTemp->H245Cap.Cap.H245Vid_H263.pbFrames			= FALSE;
			   pTemp->H245Cap.Cap.H245Vid_H263.tmprlSptlTrdOffCpblty = FALSE;
			   pTemp->H245Cap.Cap.H245Vid_H263.hrd_B				= 0;
			   pTemp->H245Cap.Cap.H245Vid_H263.bppMaxKb			= 0;
/* Optional, and not supported		pTemp->H245Cap.Cap.H245Vid_H263.slowQcifMPI	=0;
			   pTemp->H245Cap.Cap.H245Vid_H263.slowSqcifMPI	=0;
			   pTemp->H245Cap.Cap.H245Vid_H263.slowCifMPI		=0;
			   pTemp->H245Cap.Cap.H245Vid_H263.slowCif4MPI	=0;
			   pTemp->H245Cap.Cap.H245Vid_H263.slowCif16MPI	=0;
*/
			   pTemp->H245Cap.Cap.H245Vid_H263.H263VCy_errrCmpnstn = TRUE;
		     break;
		    }
			case H245_CLIENT_VID_H261:
			   pVidCapInfo=&pTemp->video_params;

			   format=get_format (pVidCapInfo->biWidth,pVidCapInfo->biHeight);
			   switch (format) {	
				case QCIF: {
				     pTemp->H245Cap.Cap.H245Vid_H261.bit_mask =H261VdCpblty_qcifMPI_present;
				     pTemp->H245Cap.Cap.H245Vid_H261.H261VdCpblty_qcifMPI =max (1,min (4,30/pVidCapInfo->uSamplesPerSec));
				     pTemp->H245Cap.Cap.H245Vid_H261.H261VdCpblty_cifMPI =0;
				     break;
				}
				case CIF: {
				     pTemp->H245Cap.Cap.H245Vid_H261.bit_mask =H261VdCpblty_cifMPI_present;
				     pTemp->H245Cap.Cap.H245Vid_H261.H261VdCpblty_qcifMPI =0;
				     pTemp->H245Cap.Cap.H245Vid_H261.H261VdCpblty_cifMPI =max (1,min(4,30/pVidCapInfo->uSamplesPerSec));
				     break;
				}
				  default:
					 break;
			   }
				
			   pTemp->H245Cap.Cap.H245Vid_H261.maxBitRate	= pFmtBuf->uMaxBitrate / 100;	// in units of 100 bits/s
			   pTemp->H245Cap.Cap.H245Vid_H261.tmprlSptlTrdOffCpblty = FALSE;
			   pTemp->H245Cap.Cap.H245Vid_H261.stillImageTransmission = FALSE;
			break;

		}
	}		
	
	uNumLocalFormats++;
	return pTemp->H245Cap.CapId;

	ERROR_EXIT:
	return INVALID_VIDEO_FORMAT;
			
}
		
/***************************************************************************

    Name      : CMsivCapability::BuildFormatName

    Purpose   : Builds a format name for a format, from the format name and
				the tag name

    Parameters:	pVidcapDetails [out] - pointer to an VIDCAP_DETAILS structure, where the
					created value name will be stored
				pszDriverName [in] - pointer to the name of the driver
				pszFormatName [in] - pointer to name of the format

    Returns   : BOOL

    Comment   :

***************************************************************************/
BOOL CMsivCapability::BuildFormatName(	PVIDCAP_DETAILS pVidcapDetails,
										WCHAR *pszDriverName,
										WCHAR *pszFormatName)
{
	int iLen, iLen2;
	BOOL bRet=TRUE;
	char szTemp[260];

	if (!pVidcapDetails ||
		!pszDriverName	||
		!pszFormatName)
	{
		bRet = FALSE;
		goto out;
	}

	// concatenate VCM strings to form the first part of the registry key - the
	// format is szFormatTag (actually pVidcapDetails->szFormat)
	// (the string  which describes the format tag followed by szFormatDetails
	// (the string which describes parameters, e.g. sample rate)
	iLen2 = WideCharToMultiByte(GetACP(), 0, pszDriverName, -1, NULL, 0, NULL, NULL);
	WideCharToMultiByte(GetACP(), 0, pszDriverName, iLen2, szTemp, iLen2, NULL, NULL);
	lstrcpyn(pVidcapDetails->szFormat, szTemp, sizeof(pVidcapDetails->szFormat));
	iLen = lstrlen(pVidcapDetails->szFormat);

	// if the format tag description string takes up all the space, don't
	// bother with the format details (need space for ", " also).
	// we're going to say that if we don't have room for 4 characters
	// of the format details string + " ,", then it's not worth it if the
	// point is generating a unique string -if it is not unique by now, it
	// will be because some VCM driver writer was  misinformed
	if(iLen < (sizeof(pVidcapDetails->szFormat) + 8*sizeof(TCHAR)))
	{
		// ok to concatenate
		lstrcat(pVidcapDetails->szFormat,", ");
		// must check for truncation. so do the final concatenation via lstrcpyn
		// lstrcat(pFormatPrefsBuf->szFormat, pvfd->szFormat);
		iLen2 = WideCharToMultiByte(GetACP(), 0, pszFormatName, -1, NULL, 0, NULL, NULL);
		WideCharToMultiByte(GetACP(), 0, pszFormatName, iLen2, szTemp, iLen2, NULL, NULL);
		iLen = lstrlen(pVidcapDetails->szFormat);
		lstrcpyn(pVidcapDetails->szFormat+iLen, szTemp,
			sizeof(pVidcapDetails->szFormat) - iLen - sizeof(TCHAR));
	}		

out:
	return bRet;
}

/***************************************************************************

    Name      : CMsivCapability::GetFormatName

    Purpose   : Gets a driver and format info from VCM and builds a format name

    Parameters:	pVidcapDetails [out] - pointer to an VIDCAP_DETAILS structure, where the
					created value name will be stored
				pvfx [in] - pointer to the VIDEOFORMATEX structure for which we
					need the driver name and the format name

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CMsivCapability::GetFormatName(	PVIDCAP_DETAILS pVidcapDetails,
										PVIDEOFORMATEX pvfx)
{
	VCMDRIVERDETAILS vdd;
	VCMFORMATDETAILS vfd;
	HRESULT hr=NOERROR;

	// get the driver details info in order to build correct format name
	vdd.fccHandler = pvfx->dwFormatTag;
	if (vcmDriverDetails(&vdd) != MMSYSERR_NOERROR)
	{
		ERRORMESSAGE(("CMsivCapability::GetFormatName: can't get the driver details\r\n"));
		hr = CAPS_E_NOMATCH;
		goto out;
	}

	// have the driver details. get the format details
	vfd.pvfx = pvfx;
	if (vcmFormatDetails(&vfd) != MMSYSERR_NOERROR)
	{
		ERRORMESSAGE(("CMsivCapability::GetFormatName: can't get the format details\r\n"));
		hr = CAPS_E_NOMATCH;
		goto out;
	}

	// have the format details too. build the name to store in the registry
	if (!BuildFormatName(pVidcapDetails, vdd.szDescription, vfd.szFormat))
	{
		ERRORMESSAGE(("CMsivCapability::GetFormatName: can't build format name\r\n"));
		hr = CAPS_E_SYSTEM_ERROR;
		goto out;
	}

out:
	return hr;
}

BOOL CMsivCapability::FormatEnumHandler(HVCMDRIVERID hvdid,
    PVCMFORMATDETAILS pvfd, VCMDRIVERDETAILS *pvdd, DWORD_PTR dwInstance)
{
	CMsivCapability *pCapObject = (CMsivCapability *)dwInstance;
	VIDCAP_DETAILS vidcap_entry;
	UINT i;

	// evaluate the details
	if(IsFormatSpecified(pvfd->pvfx, pvfd, pvdd, &vidcap_entry))
	{
		DEBUGMSG(ZONE_VCM,("FormatEnumHandler: tag 0x%08X\r\n",
			pvfd->pvfx->dwFormatTag));
		DEBUGMSG(ZONE_VCM,("FormatEnumHandler: nSamplesPerSec 0x%08lX, nAvgBytesPerSec 0x%08lX,\r\n",
			pvfd->pvfx->nSamplesPerSec, pvfd->pvfx->nAvgBytesPerSec));
		DEBUGMSG(ZONE_VCM,("FormatEnumHandler: nBlockAlign 0x%08X, wBitsPerSample 0x%04X\r\n",
			pvfd->pvfx->nBlockAlign, pvfd->pvfx->wBitsPerSample));
		DEBUGMSG(ZONE_VCM,("FormatEnumHandler: szFormat %s,\r\n",
			 pvfd->szFormat));

	//	done inside IsFormatSpecified and/or whatever it calls
	//  CalculateFormatProperties(&audcap_details, pvfd->pvfx);
		i=AddFormat(&vidcap_entry, (LPVOID)pvfd->pvfx,
			(pvfd->pvfx) ? sizeof(VIDEOFORMATEX):0);	

		if (i != INVALID_VIDEO_FORMAT) {
		   //Set the Send/Recv Flags...
		   //This now needs to set bSendEnabled, and bRecvEnabled, according to pvfd->dwFlags
		   //So, we need to find the format, and update the flags accordingly.

		   //OUTPUT IS RECV!!!!
		   if (pvfd->dwFlags == VCM_FORMATENUMF_BOTH) {
		      pLocalFormats[i].bSendEnabled=TRUE;
		      pLocalFormats[i].bRecvEnabled=TRUE;
		   }else {
		      if(pvfd->dwFlags == VCM_FORMATENUMF_OUTPUT) {
			 pLocalFormats[i].bSendEnabled=FALSE;
			 pLocalFormats[i].bRecvEnabled=TRUE;
		      } else {
			 pLocalFormats[i].bSendEnabled=TRUE;
			 pLocalFormats[i].bRecvEnabled=FALSE;
		      }
		   }
		}
	}
	
	return TRUE;
}


BOOL CMsivCapability::IsFormatSpecified(PVIDEOFORMATEX lpFormat,  PVCMFORMATDETAILS pvfd,
	VCMDRIVERDETAILS *pvdd,	VIDCAP_DETAILS *pVidcapDetails)
{
	VIDCAP_DETAILS *pcap_entry;
	BOOL bRet = FALSE;
	LPTSTR lpszKeyName = NULL;
	DWORD dwRes;
	UINT i;
	
	if(!lpFormat || !pVidcapDetails)
	{
		return FALSE;
	}
		
	RtlZeroMemory((PVOID) pVidcapDetails, sizeof(VIDCAP_DETAILS));
	
	// fixup the VIDEOFORMAT fields of video_params so that the key name can be built
	pVidcapDetails->video_params.uSamplesPerSec = lpFormat->nSamplesPerSec;
	pVidcapDetails->video_params.uBitsPerSample = MAKELONG(lpFormat->bih.biBitCount,0);
	pVidcapDetails->video_params.biWidth=lpFormat->bih.biWidth;
	pVidcapDetails->video_params.biHeight=lpFormat->bih.biHeight;
	pVidcapDetails->uMaxBitrate=lpFormat->nAvgBytesPerSec * 8;
	
	// build the name of the format out of the driver and the VCM format name
	if ((!pvdd)	||
		!BuildFormatName(pVidcapDetails, pvdd->szDescription, pvfd->szFormat))
	{
		ERRORMESSAGE(("IsFormatSpecified: Coludn't build format name\r\n"));
		return(FALSE);
	}

	lpszKeyName = AllocRegistryKeyName(	pVidcapDetails->szFormat,
										pVidcapDetails->video_params.uSamplesPerSec,
										pVidcapDetails->video_params.uBitsPerSample,
										pVidcapDetails->uMaxBitrate,
										pVidcapDetails->video_params.biWidth,
										pVidcapDetails->video_params.biHeight);
	if (!lpszKeyName)
	{
		ERRORMESSAGE(("IsFormatSpecified: Alloc failed\r\n"));
	    return(FALSE);
    }

	RegEntry reVidCaps(szRegInternetPhone TEXT("\\") szRegInternetPhoneVCMEncodings,
						HKEY_LOCAL_MACHINE,
						FALSE,
						KEY_READ);

	dwRes = reVidCaps.GetBinary(lpszKeyName, (PVOID *) &pcap_entry);

	// use current registry setting if it exists
	if(dwRes && (dwRes == sizeof(VIDCAP_DETAILS)))
	{
		// do a quick sanity check on the contents
		if((lpFormat->dwFormatTag == pcap_entry->dwFormatTag)
			&& (lpFormat->nSamplesPerSec == (DWORD)pcap_entry->video_params.uSamplesPerSec)
			&& (lpFormat->wBitsPerSample == LOWORD(pcap_entry->video_params.uBitsPerSample))
			&& (lpFormat->bih.biWidth == (LONG) pcap_entry->video_params.biWidth)
			&& (lpFormat->bih.biHeight == (LONG) pcap_entry->video_params.biHeight))
		{
			CopyMemory(pVidcapDetails, pcap_entry, sizeof(VIDCAP_DETAILS));
			bRet = TRUE;
		}
	}
	else	// check the static default table, and recreate the default entries
	{
		for(i=0;i< uDefVidTableEntries; i++)
		{
		   if((lpFormat->dwFormatTag == default_vid_table[i].dwFormatTag)
			  && (lpFormat->nSamplesPerSec == (DWORD)default_vid_table[i].video_params.uSamplesPerSec)
			  && (lpFormat->wBitsPerSample == LOWORD(default_vid_table[i].video_params.uBitsPerSample))
			  && (lpFormat->bih.biWidth == (LONG) default_vid_table[i].video_params.biWidth)
			  && (lpFormat->bih.biHeight == (LONG) default_vid_table[i].video_params.biHeight))
			  {
				// found matching default entry - copy stuff from table
				// (but don't overwrite the string)
				memcpy(pVidcapDetails, &default_vid_table[i],
					sizeof(VIDCAP_DETAILS) - sizeof(pVidcapDetails->szFormat));

				// LOOKLOOK - test against CPU limitations.
				// this supports a hack to disable CPU intensive codecs if not running
				//on a pentium
				if(default_vid_table[i].wCPUUtilizationEncode > wMaxCPU)
				{					
					pVidcapDetails->bSendEnabled = FALSE;
					pVidcapDetails->bRecvEnabled = FALSE;		
				}			
				
				// add this to the registry
				CalculateFormatProperties(pVidcapDetails, lpFormat);
				bRet = UpdateFormatInRegistry(pVidcapDetails);
				break;
			}
		}
	}

	if (lpszKeyName)
    {
		FreeRegistryKeyName(lpszKeyName);
    }
    return(bRet);
}


/***************************************************************************

    Name      : CMsivCapability::CopyVidcapInfo

    Purpose   : Copies basic video info from an VIDCAP_INFO structure to an
				VIDCAP_DETAILS structure, or vice versa. VIDCAP_INFO is external
				representation. VIDCAP_DETAILS is internal one.

    Parameters:	pDetails - pointer to an VIDCAP_DETAILS structure
				pInfo - pointer to an VIDCAP_INFO structure
				bDirection - 0 = ->, 1 = <-

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CMsivCapability::CopyVidcapInfo(PVIDCAP_DETAILS pDetails,
										PVIDCAP_INFO pInfo,
										BOOL bDirection)
{
	WORD wSortIndex;
	VIDEO_FORMAT_ID Id;
	UINT uIndex;	
	HRESULT hr=NOERROR;

	if(!pInfo || !pDetails)
	{
		hr = CAPS_E_INVALID_PARAM;
		goto out;
	}

	if (bDirection)
	{
		// VIDCAP_INFO -> VIDCAP_DETAILS

		// the caller cannot modify szFormat, Id, wSortIndex and uMaxBitrate, all calculated fields
		// nAvgBitrate can be provided, but will be overriden if the codec provided a non-zero
		// value in the VIDEOFORMATEX structure

		pDetails->dwFormatTag = pInfo->dwFormatTag;
		pDetails->uAvgBitrate = pInfo->uAvgBitrate;
		pDetails->wCPUUtilizationEncode	= pInfo->wCPUUtilizationEncode;
		pDetails->wCPUUtilizationDecode	= pInfo->wCPUUtilizationDecode;
		pDetails->bSendEnabled =  pInfo->bSendEnabled;
		pDetails->bRecvEnabled = pInfo->bRecvEnabled;
		pDetails->video_params.enumVideoSize = pInfo->enumVideoSize;
		pDetails->video_params.biHeight = pInfo->bih.biHeight;
		pDetails->video_params.biWidth  = pInfo->bih.biWidth;
		// lpLocalFormatDetails is updated in AddFormat
// DO NOT overwrite any of the fields used to construct the regkey name		
//		pDetails->video_params.uSamplesPerSec = pInfo->uFrameRate;
		pDetails->video_params.uBitsPerSample = pInfo->dwBitsPerSample;

		//Re-adjust to frame rate. MPI is Interval in units of 1/29.97 seconds
		//No div by zero error
		pInfo->uFrameRate= max(1,pInfo->uFrameRate);
		pDetails->nonstd_params.MPI = 30/pInfo->uFrameRate;
	}
	else
	{
		// VIDCAP_DETAILS -> VIDCAP_INFO	
		PVIDEOFORMATEX pvfx = (PVIDEOFORMATEX) pDetails->lpLocalFormatDetails;

		// find the sort index.
		uIndex = (UINT)(pDetails - pLocalFormats);
		Id = IndexToId(uIndex);
		for(wSortIndex=0; wSortIndex<uNumLocalFormats && wSortIndex < MAX_CAPS_PRESORT; wSortIndex++)
		{
			if (uIndex == IDsByRank[wSortIndex])
				break; // found it
		}
		// note:  recall that only  MAX_CAPS_PRESORT are sorted and the rest are in random order.
		// the rest all have a value of MAX_CAPS_PRESORT for the sort index
			
		pInfo->dwFormatTag = pDetails->dwFormatTag;	
		pInfo->Id = Id;
		memcpy(pInfo->szFormat, pDetails->szFormat, sizeof(pInfo->szFormat));
		pInfo->wCPUUtilizationEncode = pDetails->wCPUUtilizationEncode;
		pInfo->wCPUUtilizationDecode = pDetails->wCPUUtilizationDecode;
		pInfo->bSendEnabled =  pDetails->bSendEnabled;
		pInfo->bRecvEnabled = pDetails->bRecvEnabled;
		pInfo->wSortIndex = wSortIndex;
		pInfo->enumVideoSize = pDetails->video_params.enumVideoSize;
		if (pvfx)
			RtlCopyMemory(&pInfo->bih, &pvfx->bih, sizeof(BITMAPINFOHEADER));
		//The h.323 nonstd params for bitrate is in units of 100 bits/sec
		pInfo->dwBitsPerSample = pDetails->video_params.uBitsPerSample;
		pInfo->uAvgBitrate = pDetails->uAvgBitrate;
		pInfo->uMaxBitrate = pDetails->nonstd_params.maxBitRate*100;

		//Re-adjust to frame rate. MPI is Interval in units of 1/29.97 seconds
		//No div by zero error
		pDetails->nonstd_params.MPI= max(1,pDetails->nonstd_params.MPI);
		pInfo->uFrameRate =  min(30,30/pDetails->nonstd_params.MPI);
	}

out:
	return hr;
}



HRESULT CMsivCapability::EnumCommonFormats(PBASIC_VIDCAP_INFO pFmtBuf, UINT uBufsize,
	UINT *uNumFmtOut, BOOL bTXCaps)
{
	UINT u, uNumOut = 0;;
	HRESULT hr = hrSuccess;
	VIDCAP_DETAILS *pDetails = pLocalFormats;
	MEDIA_FORMAT_ID FormatIDRemote;
	HRESULT hrIsCommon;
	
	// validate input
	if(!pFmtBuf || !uNumFmtOut || (uBufsize < (sizeof(BASIC_VIDCAP_INFO)*uNumLocalFormats)))
	{
		return CAPS_E_INVALID_PARAM;
	}
	if(!uNumLocalFormats || !pDetails)
	{
		return CAPS_E_NOCAPS;
	}

	// temporary - enumerating requestable receive formats is not yet supported
	if(!bTXCaps)
		return CAPS_E_NOT_SUPPORTED;
		
	for(u=0; (u <uNumLocalFormats) && (u <MAX_CAPS_PRESORT); u++)
	{
		pDetails = pLocalFormats + IDsByRank[u];	
		// if there is a session, then return formats that are common to local and remote.
		if(uNumRemoteDecodeFormats)
		{
			hrIsCommon = ResolveToLocalFormat(IndexToId(IDsByRank[u]), &FormatIDRemote);
			if(HR_SUCCEEDED(hrIsCommon))	
			{
				hr = CopyVidcapInfo (pDetails, pFmtBuf, 0);	
				if(!HR_SUCCEEDED(hr))	
					goto EXIT;
				uNumOut++;
				pFmtBuf++;
			}
		}
		else	// no remote capabilities exist because there is no current session
		{
			hr = CAPS_E_NOCAPS;
		}
	}

	*uNumFmtOut = uNumOut;
EXIT:
	return hr;
}

HRESULT CMsivCapability::EnumFormats(PBASIC_VIDCAP_INFO pFmtBuf, UINT uBufsize,
	UINT *uNumFmtOut)
{
	UINT u;
	HRESULT hr = hrSuccess;
	VIDCAP_DETAILS *pDetails = pLocalFormats;
	
	// validate input
	if(!pFmtBuf || !uNumFmtOut || (uBufsize < (sizeof(BASIC_VIDCAP_INFO)*uNumLocalFormats)))
	{
		return CAPS_E_INVALID_PARAM;
	}
	if(!uNumLocalFormats || !pDetails)
	{
		return CAPS_E_NOCAPS;
	}

	for(u=0; (u <uNumLocalFormats) && (u <MAX_CAPS_PRESORT); u++)
	{
		pDetails = pLocalFormats + IDsByRank[u];	
		hr = CopyVidcapInfo (pDetails, pFmtBuf, 0);	
		if(!HR_SUCCEEDED(hr))	
			goto EXIT;
		pFmtBuf++;
	}

	*uNumFmtOut = min(uNumLocalFormats, MAX_CAPS_PRESORT);
EXIT:
	return hr;
}

HRESULT CMsivCapability::GetBasicVidcapInfo (VIDEO_FORMAT_ID Id, PBASIC_VIDCAP_INFO pFormatPrefsBuf)
{
	VIDCAP_DETAILS *pFmt;
	UINT uIndex = IDToIndex(Id);
	if(!pFormatPrefsBuf || (uNumLocalFormats <= uIndex))
	{
		return CAPS_E_INVALID_PARAM;
	}
	pFmt = pLocalFormats + uIndex;

	return (CopyVidcapInfo(pFmt,pFormatPrefsBuf,0));
}

HRESULT CMsivCapability::ApplyAppFormatPrefs (PBASIC_VIDCAP_INFO pFormatPrefsBuf,
	UINT uNumFormatPrefs)
{
	FX_ENTRY ("CMsivCapability::ApplyAppFormatPrefs");
	UINT u, v;
	PBASIC_VIDCAP_INFO pTemp;
	VIDCAP_DETAILS *pFmt;

	if(!pFormatPrefsBuf || (uNumLocalFormats != uNumFormatPrefs))
	{
		ERRORMESSAGE(("%s invalid param: pFbuf:0x%08lx, uNumIN:%d, uNum:%d\r\n",
			_fx_, pFormatPrefsBuf, uNumFormatPrefs, uNumLocalFormats));
		return CAPS_E_INVALID_PARAM;
	}
	
	// validate
	for(u=0; u <uNumLocalFormats; u++)
	{
		pTemp =  pFormatPrefsBuf+u;
		// make sure that the format ID is real
		if(IDToIndex(pTemp->Id) >= uNumLocalFormats)
		{
			return CAPS_E_INVALID_PARAM;
		}
		// look for bad sort indices, duplicate sort indices and duplicate format IDs
		if(pTemp->wSortIndex >= uNumLocalFormats)
			return CAPS_E_INVALID_PARAM;
			
		for(v=u+1; v <uNumLocalFormats; v++)
		{
			if((pTemp->wSortIndex == pFormatPrefsBuf[v].wSortIndex)
				|| (pTemp->Id == pFormatPrefsBuf[v].Id))
			{
			ERRORMESSAGE(("%s invalid param: wSI1:0x%04x, wSI2:0x%04x, ID1:%d, ID2:%d\r\n",
			_fx_, pTemp->wSortIndex, pFormatPrefsBuf[v].wSortIndex, pTemp->Id,
			pFormatPrefsBuf[v].Id));
				return CAPS_E_INVALID_PARAM;
			}
		}
	}
	// all seems well
	for(u=0; u <uNumLocalFormats; u++)
	{
		pTemp =  pFormatPrefsBuf+u;			// next entry of the input
		pFmt = pLocalFormats + IDToIndex(pTemp->Id);	// identifies this local format

		// apply the new sort order
		pFmt->wApplicationPrefOrder = pTemp->wSortIndex;
		// update the updatable parameters (CPU utilization, bitrate)
		pFmt->bSendEnabled = pTemp->bSendEnabled;
		pFmt->bRecvEnabled	= pTemp->bRecvEnabled;
// DO NOT overwrite any of the fields used to construct the regkey name		
//		pFmt->video_params.uSamplesPerSec = pTemp->uFrameRate;
		//Units of 100 bits/sec
		pFmt->nonstd_params.maxBitRate= (pTemp->uMaxBitrate/100);
//		pFmt->nonstd_params.maxBPP= 0;

		pFmt->nonstd_params.MPI= 30/max(pTemp->uFrameRate, 1);
		
		// only the tuning wizard or other profiling app can write wCPUUtilizationEncode,
		// wCPUUtilizationDecode, uAvgBitrate
		
		// update the registry
		UpdateFormatInRegistry(pFmt);
		
		// now update the sort order contained in VIDsByRank
		// note:  recall that only  MAX_CAPS_PRESORT are sorted and the rest are in random order.
		// LOOKLOOK - maybe need a separate sort order array? - the order in VIDsByRank
		// is being overriden here
		// the array holds the sorted indices into the array of formats in pLocalFormats
		if(pTemp->wSortIndex < MAX_CAPS_PRESORT)
		{
			// insert the format at the position indicated by the input
			IDsByRank[pTemp->wSortIndex] = (MEDIA_FORMAT_ID)(pFmt - pLocalFormats);
		}
		
	}



	return hrSuccess;
}

		// update the registry
BOOL CMsivCapability::UpdateFormatInRegistry(VIDCAP_DETAILS *pVidcapDetails)
{

	FX_ENTRY(("CMsivCapability::UpdateFormatInRegistry"));
	LPTSTR lpszKeyName = NULL;
	BOOL bRet;
	if(!pVidcapDetails)
	{
		return FALSE;
	}	

	lpszKeyName = AllocRegistryKeyName(	pVidcapDetails->szFormat,
										pVidcapDetails->video_params.uSamplesPerSec,
										pVidcapDetails->video_params.uBitsPerSample,
										pVidcapDetails->uMaxBitrate,
										pVidcapDetails->video_params.biWidth,
										pVidcapDetails->video_params.biHeight);
	if (!lpszKeyName)
	{
		ERRORMESSAGE(("%s:Alloc failed\r\n",_fx_));
        return(FALSE);
    }

	DEBUGMSG(ZONE_VCM,("%s:updating %s, wPref:0x%04x, bS:%d, bR:%d\r\n",
			_fx_, lpszKeyName, pVidcapDetails->wApplicationPrefOrder,
			pVidcapDetails->bSendEnabled, pVidcapDetails->bRecvEnabled));
	// add this to the registry
	RegEntry reVidCaps(szRegInternetPhone TEXT("\\") szRegInternetPhoneVCMEncodings,
						HKEY_LOCAL_MACHINE);

	bRet = (ERROR_SUCCESS == reVidCaps.SetValue(lpszKeyName,
												pVidcapDetails,
												sizeof(VIDCAP_DETAILS)));
							
	FreeRegistryKeyName(lpszKeyName);
    return(bRet);				
}


/***************************************************************************

    Name      : CMsivCapability::AddVCMFormat

    Purpose   : Adds an VCM format to the list of formats we support

    Parameters:	pvfx - pointer to the videoformat structure for the added codec
				pVidcapInfo - additional format info that is not in the videoformat
					structure

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CMsivCapability::AddVCMFormat (PVIDEOFORMATEX pvfx, PVIDCAP_INFO pVidcapInfo)
{
	HRESULT hr = hrSuccess;
	// initialize cap entry with default values
	VIDCAP_DETAILS cap_entry =
		{VIDEO_FORMAT_UNKNOWN, NONSTD_VID_TERMCAP,STD_VID_PARAMS,
		{RTP_DYNAMIC_MIN+1,  0, 30, 7680, Small, 0, 0},0,
		TRUE, TRUE,
		1, 				// default number of samples per packet
		245760*8,	// default to 16kbs bitrate
		245760*8, 					// unknown average bitrate
		10, 10,	// default CPU utilization
		PREF_ORDER_UNASSIGNED,	// unassigned sort order
		0,NULL,0,NULL,
		""};
		
	if(!pvfx || !pVidcapInfo)
	{
		hr = CAPS_E_INVALID_PARAM;
		goto out;
	}	

	/*
	 *	Build the VIDCAP_DETAILS structure for this format
	 */

	// now add VIDCAP_INFO information
	CopyVidcapInfo(&cap_entry, pVidcapInfo, 1);

	// calculate whatever parameters can be calculated
	// use actual bits per sample unless the bps field is zero, in which case
	// assume 16 bits (worst case).
	CalculateFormatProperties(&cap_entry, pvfx);

	// Make sure it's an upper case FourCC
	if (cap_entry.dwFormatTag > 256)
		CharUpperBuff((LPTSTR)&cap_entry.dwFormatTag, sizeof(DWORD));

	// set the RTP payload number. We are using a random number from the dynamic range
	// for the installable codecs
	cap_entry.video_params.RTPPayload = RTP_DYNAMIC_MIN+1;

	// get the format name and driver name for this format from VCM and
	// build a format name to add to the registry
	hr = GetFormatName(&cap_entry, pvfx);
	if (FAILED(hr))
		goto out;

	// add this to the registry
	if(!UpdateFormatInRegistry(&cap_entry))
	{
		ERRORMESSAGE(("CMsivCapability::AddVCMFormat: can't update registry\r\n"));
		hr = CAPS_E_SYSTEM_ERROR;
		goto out;
	}

	// reinit to update the list of local formats
    if (!ReInit())
	{
		hr = CAPS_E_SYSTEM_ERROR;
   		goto out;
	}

out:
	return hr;
}

/***************************************************************************

    Name      : CMsivCapability::RemoveVCMFormat

    Purpose   : Removes an VCM format to the list of formats we support

    Parameters:	pvfx - pointer to the videoformat structure for the added codec

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CMsivCapability::RemoveVCMFormat (PVIDEOFORMATEX pvfx)
{
	HRESULT hr = hrSuccess;
    HKEY hKey = NULL;
	LPTSTR lpszValueName = NULL;
    DWORD dwErr;
	VIDCAP_DETAILS cap_entry;
	
	if(!pvfx)
	{
		return CAPS_E_INVALID_PARAM;
	}	

	// get the format name and driver name for this format from VCM and
	// build a format name to add to the registry
	hr = GetFormatName(&cap_entry, pvfx);
	if (FAILED(hr))
		goto out;

	lpszValueName = AllocRegistryKeyName(cap_entry.szFormat,
										pvfx->nSamplesPerSec,
										MAKELONG(pvfx->wBitsPerSample,0),
										pvfx->nAvgBytesPerSec*8,
										pvfx->bih.biWidth,
										pvfx->bih.biHeight);
	if (!lpszValueName)
	{
		ERRORMESSAGE(("CMsivCapability::RemoveVCMFormat: Alloc failed\r\n"));
	    hr = CAPS_E_SYSTEM_ERROR;
	    goto out;
    }

	// Get the key handle
    if (dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
					szRegInternetPhone TEXT("\\") szRegInternetPhoneVCMEncodings,
					0, KEY_ALL_ACCESS, &hKey))
	{
		ERRORMESSAGE(("CMsivCapability::RemoveVCMFormat: can't open key to delete\r\n"));
	    hr = CAPS_E_SYSTEM_ERROR;
	    goto out;
    }

	dwErr = RegDeleteValue(hKey, lpszValueName );	
	if(dwErr != ERROR_SUCCESS)
	{
		hr = CAPS_E_SYSTEM_ERROR;
		goto out;
	}

	// reinit to update the list of local formats
    if (!ReInit())
	{
		hr = CAPS_E_SYSTEM_ERROR;
   		goto out;
	}

out:
    if (hKey)
        RegCloseKey(hKey);
	if(lpszValueName)
		MEMFREE(lpszValueName);		
	return hr;
}
UINT CMsivCapability::GetLocalSendParamSize(MEDIA_FORMAT_ID dwID)
{
	return (sizeof(VIDEO_CHANNEL_PARAMETERS));
}
UINT CMsivCapability::GetLocalRecvParamSize(PCC_TERMCAP pCapability)
{
	return (sizeof(VIDEO_CHANNEL_PARAMETERS));
}

HRESULT CMsivCapability::CreateCapList(LPVOID *ppCapBuf)
{
	HRESULT hr = hrSuccess;
	UINT u;
	VIDCAP_DETAILS *pDecodeDetails = pLocalFormats;
	PCC_TERMCAPLIST   pTermCapList = NULL;
	PPCC_TERMCAP  ppCCThisTermCap = NULL;
	PCC_TERMCAP  pCCThisCap = NULL;
	PNSC_VIDEO_CAPABILITY pNSCapNext;
	PVIDEOFORMATEX lpvcd;
	VIDEO_PARAMS  	*pVidCapInfo;
	UINT format;
	FX_ENTRY ("CreateCapList");
	// validate input
	if(!ppCapBuf)
	{
		hr = CAPS_E_INVALID_PARAM;
		goto ERROR_OUT;
	}
	*ppCapBuf = NULL;
	if(!uNumLocalFormats || !pDecodeDetails)
	{
		hr = CAPS_E_NOCAPS;
		goto ERROR_OUT;
	}

	pTermCapList = (PCC_TERMCAPLIST)MemAlloc(sizeof(CC_TERMCAPLIST));
	if(!pTermCapList)
	{
		hr = CAPS_E_NOMEM;
		goto ERROR_OUT;		
	}
	ppCCThisTermCap = (PPCC_TERMCAP)MemAlloc(uNumLocalFormats * sizeof(PCC_TERMCAP));
	if(!ppCCThisTermCap)
	{
		hr = CAPS_E_NOMEM;
		goto ERROR_OUT;		
	}
	pTermCapList->wLength = 0;
	// point the CC_TERMCAPLIST pTermCapArray at the array of PCC_TERMCAP
	pTermCapList->pTermCapArray = ppCCThisTermCap;
	/*
					CC_TERMCAPLIST       PCC_TERMCAP        CC_TERMCAP

  pTermCapList->    {
						wLength
						pTermCapArray--->pTermCap----------->{single capability.....}
					}
										pTermCap----------->{single capability.}
			
										pTermCap----------->{single capability...}

    */

	for(u=0; u <uNumLocalFormats; u++)
	{
		// check if enabled for receive, skip if false
		// also skip if public version of capabilities is to be advertised via a
		// separate local capability entry
		if((!pDecodeDetails->bRecvEnabled ) || (pDecodeDetails->dwPublicRefIndex))
		{
			pDecodeDetails++;
			continue;
		}

		if(pDecodeDetails->H245Cap.ClientType ==0
				|| pDecodeDetails->H245Cap.ClientType ==H245_CLIENT_VID_NONSTD)
		{

			lpvcd = (PVIDEOFORMATEX)pDecodeDetails->lpLocalFormatDetails;
			if(!lpvcd)
			{	
				pDecodeDetails++;
				continue;
			}
			// allocate for this one capability
			pCCThisCap = (PCC_TERMCAP)MemAlloc(sizeof(CC_TERMCAP));		
			pNSCapNext = (PNSC_VIDEO_CAPABILITY)MemAlloc(sizeof(NSC_VIDEO_CAPABILITY));
				
			if((!pCCThisCap)|| (!pNSCapNext))
			{
				hr = CAPS_E_NOMEM;
				goto ERROR_OUT;		
			}
			// set type of nonstandard capability
			pNSCapNext->cvp_type = NSC_VCM_VIDEOFORMATEX;
			// stuff both chunks of nonstandard capability info into buffer
			// first stuff the "channel parameters" (the format independent communication options)
			memcpy(&pNSCapNext->cvp_params, &pDecodeDetails->nonstd_params, sizeof(NSC_CHANNEL_VIDEO_PARAMETERS));
			
			// then the VCM stuff
			memcpy(&pNSCapNext->cvp_data.vfx, lpvcd, sizeof(VIDEOFORMATEX));

			pCCThisCap->ClientType = H245_CLIENT_VID_NONSTD;
			pCCThisCap->DataType = H245_DATA_VIDEO;
			pCCThisCap->Dir = (pDecodeDetails->bSendEnabled && bPublicizeTXCaps)
				? H245_CAPDIR_LCLRXTX :H245_CAPDIR_LCLRX;

			// LOOKLOOK use the index of the cap entry as the ID
			// The ID is already preset in local formats by AddCapabilityBase()
			// pCCThisCap->CapId = (USHORT)IndexToId(u);
			pCCThisCap->CapId = pDecodeDetails->H245Cap.CapId;

			// all nonstandard identifier fields are unsigned short
			// two possibilities for choice are "h221NonStandard_chosen" and "object_chosen"
			pCCThisCap->Cap.H245Vid_NONSTD.nonStandardIdentifier.choice = h221NonStandard_chosen;
			// NOTE: there is some question about the correct byte order
			// of the codes in the h221NonStandard structure
			pCCThisCap->Cap.H245Vid_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode = USA_H221_COUNTRY_CODE;
			pCCThisCap->Cap.H245Vid_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension = USA_H221_COUNTRY_EXTENSION;
			pCCThisCap->Cap.H245Vid_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode = MICROSOFT_H_221_MFG_CODE;


			// set size of buffer
			pCCThisCap->Cap.H245Vid_NONSTD.data.length = sizeof(NSC_VIDEO_CAPABILITY) - BMIH_SLOP_BYTES;
			pCCThisCap->Cap.H245Vid_NONSTD.data.value = (BYTE *)pNSCapNext;	// point to nonstandard stuff

			// pNSCapNext is now referenced by the pTermCapList and will
			// be cleaned up via DeleteCapList(). Null the ptr so that error cleanup
			// won't try redundant cleanup.
			pNSCapNext = NULL;
		}
		else
		{
			// allocate for this one capability
			pCCThisCap = (PCC_TERMCAP)MemAlloc(sizeof(CC_TERMCAP));		
			if(!pCCThisCap)
			{
				hr = CAPS_E_NOMEM;
				goto ERROR_OUT;		
			}
			
			pCCThisCap->ClientType = (H245_CLIENT_T)pDecodeDetails->H245Cap.ClientType;
			pCCThisCap->DataType = H245_DATA_VIDEO;
			pCCThisCap->Dir = H245_CAPDIR_LCLRX;  // should this be H245_CAPDIR_LCLRX for receive caps?
			pCCThisCap->CapId = pDecodeDetails->H245Cap.CapId;
			pVidCapInfo=&pDecodeDetails->video_params;
			switch  (pCCThisCap->ClientType )
			{
  				case H245_CLIENT_VID_H263:

  				#pragma message ("Collapse H.263 formats")
				// refer to the hack that sets H245Vid_H263 parameters
				// when formats are enumerated.  if that was always done right, then
				// all that needs to happen here is collapsing
  			
  				// This is where the formats need to collapse. H.263 probably
  				// should not be collapsed into 1 format.  Given M specific local
  				// formats, collapse into N.

			       format=get_format (pVidCapInfo->biWidth,pVidCapInfo->biHeight);
			       switch (format) {	
				     case SQCIF: {
					   pCCThisCap->Cap.H245Vid_H263.bit_mask =H263VideoCapability_sqcifMPI_present;
					   //MPI minimum interval in units of 1/29.97sec so 30/ (frames/sec) is reasonable
					   pCCThisCap->Cap.H245Vid_H263.sqcifMPI = max (1,pDecodeDetails->nonstd_params.MPI); //30/pVidCapInfo->uSamplesPerSec;
					   pCCThisCap->Cap.H245Vid_H263.H263VdCpblty_qcifMPI =0;
					   pCCThisCap->Cap.H245Vid_H263.H263VdCpblty_cifMPI =0;
					   break;
		

				     }
				     case QCIF: {
					   pCCThisCap->Cap.H245Vid_H263.bit_mask =H263VideoCapability_qcifMPI_present;

					   pCCThisCap->Cap.H245Vid_H263.sqcifMPI = 0;
					   pCCThisCap->Cap.H245Vid_H263.H263VdCpblty_qcifMPI =max (1,pDecodeDetails->nonstd_params.MPI);//30/pVidCapInfo->uSamplesPerSec; ;;
					   pCCThisCap->Cap.H245Vid_H263.H263VdCpblty_cifMPI =0;
					   break;

				     }
				     case CIF: {
					   pCCThisCap->Cap.H245Vid_H263.bit_mask =H263VideoCapability_cifMPI_present;
				
					   pCCThisCap->Cap.H245Vid_H263.sqcifMPI = 0;
					   pCCThisCap->Cap.H245Vid_H263.H263VdCpblty_qcifMPI =0;
					   pCCThisCap->Cap.H245Vid_H263.H263VdCpblty_cifMPI = max (1,pDecodeDetails->nonstd_params.MPI);//30/pVidCapInfo->uSamplesPerSec;
					   break;
	
				     }
					  default:
						 break;


			       }
				

			       pCCThisCap->Cap.H245Vid_H263.cif4MPI	=0;
			       pCCThisCap->Cap.H245Vid_H263.cif16MPI	=0;
			       pCCThisCap->Cap.H245Vid_H263.maxBitRate	=
			                       pDecodeDetails->nonstd_params.maxBitRate;
					
			       pCCThisCap->Cap.H245Vid_H263.unrestrictedVector = FALSE;
			       pCCThisCap->Cap.H245Vid_H263.arithmeticCoding 	= FALSE;
			       pCCThisCap->Cap.H245Vid_H263.advancedPrediction	= FALSE;
			       pCCThisCap->Cap.H245Vid_H263.pbFrames			= FALSE;
			       pCCThisCap->Cap.H245Vid_H263.tmprlSptlTrdOffCpblty = (ASN1bool_t)bPublicizeTSTradeoff;
			       pCCThisCap->Cap.H245Vid_H263.hrd_B				= 0;
			       pCCThisCap->Cap.H245Vid_H263.bppMaxKb	=
				    pDecodeDetails->nonstd_params.maxBPP;

/* Optional, and not supported		pCCThisCap->Cap.H245Vid_H263.slowQcifMPI	=0;
			       pCCThisCap->Cap.H245Vid_H263.slowSqcifMPI	=0;
			       pCCThisCap->Cap.H245Vid_H263.slowCifMPI		=0;
			       pCCThisCap->Cap.H245Vid_H263.slowCif4MPI	=0;
			       pCCThisCap->Cap.H245Vid_H263.slowCif16MPI	=0;
*/
			       pCCThisCap->Cap.H245Vid_H263.H263VCy_errrCmpnstn = TRUE;
			       break;
				
				case H245_CLIENT_VID_H261:

  				#pragma message ("Collapse H.261 formats")
				// refer to the hack that sets H245Vid_H261 parameters
				// when formats are enumerated.  if that was always done right, then
				// all that needs to happen here is collapsing
  			
  				// This is where the formats need to collapse. H.261 probably
  				// should not be collapsed into 1 format.  Given M specific local
  				// formats, collapse into N.

			       format=get_format (pVidCapInfo->biWidth,pVidCapInfo->biHeight);
			       switch (format) {	
				     case QCIF: {
					   pCCThisCap->Cap.H245Vid_H261.bit_mask =H261VdCpblty_qcifMPI_present;
					   pCCThisCap->Cap.H245Vid_H261.H261VdCpblty_qcifMPI =max (1,min(4,pDecodeDetails->nonstd_params.MPI));//30/pVidCapInfo->uSamplesPerSec; ;;
					   pCCThisCap->Cap.H245Vid_H261.H261VdCpblty_cifMPI =0;
					   break;
				     }
				     case CIF: {
					   pCCThisCap->Cap.H245Vid_H261.bit_mask =H261VdCpblty_cifMPI_present;
					   pCCThisCap->Cap.H245Vid_H261.H261VdCpblty_qcifMPI =0;
					   pCCThisCap->Cap.H245Vid_H261.H261VdCpblty_cifMPI =max  (1,min(4,pDecodeDetails->nonstd_params.MPI));//30/pVidCapInfo->uSamplesPerSec;
					   break;
				     }
					  default:
						 break;
			       }
			       pCCThisCap->Cap.H245Vid_H261.maxBitRate = (ASN1uint16_t)pDecodeDetails->nonstd_params.maxBitRate;
			       pCCThisCap->Cap.H245Vid_H261.tmprlSptlTrdOffCpblty = (ASN1bool_t)bPublicizeTSTradeoff;
			       pCCThisCap->Cap.H245Vid_H261.stillImageTransmission = FALSE;
  				break;

				default:
				case H245_CLIENT_VID_NONSTD:
				break;

			}
		}
		pDecodeDetails++;
		*ppCCThisTermCap++ = pCCThisCap;// add ptr to this capability to the array
		pTermCapList->wLength++;      	// count this entry
		// pCCThisCap is now referenced by the pTermCapList and will
		// be cleaned up via DeleteCapList(). Null the ptr so that error cleanup
		// won't try redundant cleanup.
		pCCThisCap = NULL;
	}
	*ppCapBuf = pTermCapList;
	return hr;

ERROR_OUT:
	if(pTermCapList)
	{
		DeleteCapList(pTermCapList);
	}
	if(pCCThisCap)
		MemFree(pCCThisCap);
	if(pNSCapNext)
		MemFree(pNSCapNext);
	return hr;


}

HRESULT CMsivCapability::DeleteCapList(LPVOID pCapBuf)
{
	UINT u;
	PCC_TERMCAPLIST pTermCapList = (PCC_TERMCAPLIST)pCapBuf;
	PCC_TERMCAP  pCCThisCap;
	PNSC_VIDEO_CAPABILITY pNSCap;
	
	if(!pTermCapList)
	{
		return CAPS_E_INVALID_PARAM;
	}

	if(pTermCapList->pTermCapArray)						
	{
		while(pTermCapList->wLength--)
		{
			pCCThisCap = *(pTermCapList->pTermCapArray + pTermCapList->wLength);
			if(pCCThisCap)
			{
				if(pCCThisCap->ClientType == H245_CLIENT_VID_NONSTD)
				{
					if(pCCThisCap->Cap.H245Vid_NONSTD.data.value)
					{
						MemFree(pCCThisCap->Cap.H245Vid_NONSTD.data.value);
					}
				}
				MemFree(pCCThisCap);
			}
		}
		MemFree(pTermCapList->pTermCapArray);
	}
	MemFree(pTermCapList);
	return hrSuccess;
}

BOOL CMsivCapability::IsCapabilityRecognized(PCC_TERMCAP pCCThisCap)
{
	FX_ENTRY ("CMsivCapability::IsCapabilityRecognized");
	if(pCCThisCap->DataType != H245_DATA_VIDEO)
		return FALSE;
	
	if(pCCThisCap->ClientType == H245_CLIENT_VID_NONSTD)
	{
		// do we recognize this?
		if(pCCThisCap->Cap.H245Vid_NONSTD.nonStandardIdentifier.choice == h221NonStandard_chosen)
		{
			if((pCCThisCap->Cap.H245Vid_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode == USA_H221_COUNTRY_CODE)
			&& (pCCThisCap->Cap.H245Vid_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension == USA_H221_COUNTRY_EXTENSION)
			&& (pCCThisCap->Cap.H245Vid_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode == MICROSOFT_H_221_MFG_CODE))

			{
				// ok, this is ours so far. Now what data type is contained therein?
				// welllll, lets keep a copy of this regardless ????.  If we can't understand
				// future versions of ourselves, then what???
				return TRUE;
			}
			else
			{
				// unrecognized nonstandard capability
				ERRORMESSAGE(("%s:unrecognized nonstd capability\r\n",_fx_));
#ifdef DEBUG
				VOID DumpNonstdParameters(PCC_TERMCAP , PCC_TERMCAP );
				DumpNonstdParameters(NULL, pCCThisCap);
#endif
				return FALSE;
			}
		}
	}
	return TRUE;
}

// the intent is to keep a copy of the channel parameters used to open a send channel
// that the remote end can decode.


VIDEO_FORMAT_ID CMsivCapability::AddRemoteDecodeFormat(PCC_TERMCAP pCCThisCap)
{
	FX_ENTRY ("CMsivCapability::AddRemoteDecodeFormat");

	VIDCAP_DETAILS vidcapdetails =
		{VIDEO_FORMAT_UNKNOWN,NONSTD_VID_TERMCAP, STD_VID_PARAMS,
		{RTP_DYNAMIC_MIN+1, 0, 30, 7680, Small, 0, 0},0,
		TRUE, TRUE, 1, 245760*8,245760*8,10,10,0,0,NULL,0,NULL,""};
	
	VIDCAP_DETAILS *pTemp;
	LPVOID lpData = NULL;
	UINT uSize = 0;
	if(!pCCThisCap)
	{
		return INVALID_VIDEO_FORMAT;
	}	
   // check room
	if(uRemoteDecodeFormatCapacity <= uNumRemoteDecodeFormats)
	{
		// get more mem, realloc memory by CAP_CHUNK_SIZE for pRemoteDecodeFormats
		pTemp = (VIDCAP_DETAILS *)MEMALLOC((uNumRemoteDecodeFormats + CAP_CHUNK_SIZE)*sizeof(VIDCAP_DETAILS));
		if(!pTemp)
			goto ERROR_EXIT;
		// remember how much capacity we now have
		uRemoteDecodeFormatCapacity = uNumRemoteDecodeFormats + CAP_CHUNK_SIZE;
		#ifdef DEBUG
		if((uNumRemoteDecodeFormats && !pRemoteDecodeFormats) || (!uNumRemoteDecodeFormats && pRemoteDecodeFormats))
		{
			ERRORMESSAGE(("%s:leak! uNumRemoteDecodeFormats:0x%08lX, pRemoteDecodeFormats:0x%08lX\r\n",
				_fx_, uNumRemoteDecodeFormats,pRemoteDecodeFormats));
		}
		#endif
		// copy old stuff, discard old mem
		if(uNumRemoteDecodeFormats && pRemoteDecodeFormats)
		{
			memcpy(pTemp, pRemoteDecodeFormats, uNumRemoteDecodeFormats*sizeof(AUDCAP_DETAILS));
			MEMFREE(pRemoteDecodeFormats);
		}
		pRemoteDecodeFormats = pTemp;
	}
	// pTemp is where the stuff is cached
	pTemp = pRemoteDecodeFormats+uNumRemoteDecodeFormats;

	// fixup the capability structure being added.  First thing: initialize defaults
	memcpy(pTemp, &vidcapdetails, sizeof(VIDCAP_DETAILS));
	// next, the H245 parameters
	memcpy(&pTemp->H245Cap, pCCThisCap, sizeof(pTemp->H245Cap));
	
	// Note: if nonstandard data exists, the nonstd pointers need to be fixed up
	if(pCCThisCap->ClientType == H245_CLIENT_VID_NONSTD)
	{
		// do we recognize this?
		if(pCCThisCap->Cap.H245Vid_NONSTD.nonStandardIdentifier.choice == h221NonStandard_chosen)
		{
			if((pCCThisCap->Cap.H245Vid_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode == USA_H221_COUNTRY_CODE)
			&& (pCCThisCap->Cap.H245Vid_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension == USA_H221_COUNTRY_EXTENSION)
			&& (pCCThisCap->Cap.H245Vid_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode == MICROSOFT_H_221_MFG_CODE))
			{
				// ok, this is ours so far. Now what data type is contained therein?
				// welllll, lets keep a copy of this regardless ????.  If we can't understand
				// future versions of ourselves, then what???
				uSize = pCCThisCap->Cap.H245Vid_NONSTD.data.length;
				lpData = pCCThisCap->Cap.H245Vid_NONSTD.data.value;
			}
		}
	}
	// this is not really necessary to set RTP payload type of what is received - it should
	// be obvious.
	else if (pCCThisCap->ClientType == H245_CLIENT_VID_H263 )
	{
		pTemp->video_params.RTPPayload = RTP_PAYLOAD_H263;
	}
	else if(pCCThisCap->ClientType == H245_CLIENT_VID_H261)
	{
		pTemp->video_params.RTPPayload = RTP_PAYLOAD_H261;
	}

	
	pTemp->uLocalDetailsSize = 0;	// we're not keeping another copy of local encode details
	pTemp->lpLocalFormatDetails =0; // we're not keeping another copy of local encode details
	
	pTemp->uRemoteDetailsSize = 0;	// clear this now
	if(uSize && lpData)
	{
		pTemp->H245Cap.Cap.H245Vid_NONSTD.data.length = uSize;
		pTemp->H245Cap.Cap.H245Vid_NONSTD.data.value = (unsigned char *)lpData;
		
		pTemp->lpRemoteFormatDetails = MEMALLOC(uSize);
		if(pTemp->lpRemoteFormatDetails)
		{
			memcpy(pTemp->lpRemoteFormatDetails, lpData, uSize);
			pTemp->uRemoteDetailsSize = uSize;
				
		}
		#ifdef DEBUG
			else
			{
				ERRORMESSAGE(("%s:allocation failed!\r\n",_fx_));
			}
		#endif
	}
	else
	{
		pTemp->lpRemoteFormatDetails = NULL;
		pTemp->uRemoteDetailsSize =0;
	}
	uNumRemoteDecodeFormats++;
	// use the index as the ID
	return (uNumRemoteDecodeFormats-1);

	ERROR_EXIT:
	return INVALID_VIDEO_FORMAT;
			
}
		
VOID CMsivCapability::FlushRemoteCaps()
{
	if(pRemoteDecodeFormats)
	{
		MEMFREE(pRemoteDecodeFormats);
		pRemoteDecodeFormats = NULL;
		uNumRemoteDecodeFormats = 0;
		uRemoteDecodeFormatCapacity = 0;
	}
}

HRESULT CMsivCapability::AddRemoteDecodeCaps(PCC_TERMCAPLIST pTermCapList)
{
	FX_ENTRY ("CMsivCapability::AddRemoteDecodeCaps");
	HRESULT hr = hrSuccess;
	PPCC_TERMCAP ppCCThisCap;
	PCC_TERMCAP pCCThisCap;
	WORD wNumCaps;

	   //ERRORMESSAGE(("%s,\r\n", _fx_));
	if(!pTermCapList) 			// additional capability descriptors may be added
	{							// at any time
		return CAPS_E_INVALID_PARAM;
	}

	// cleanup old term caps if term caps are being addded and old caps exist
	FlushRemoteCaps();
				
	wNumCaps = pTermCapList->wLength;			
	ppCCThisCap = pTermCapList->pTermCapArray;
	
/*
					CC_TERMCAPLIST			TERMCAPINFO			CC_TERMCAP

	pTermCapList->	{
						wLength
						pTermCapInfo--->pTermCap----------->{single capability.....}
					}					
										pTermCap----------->{single capability.}

										pTermCap----------->{single capability...}

*/
	while(wNumCaps--)
	{
		if(!(pCCThisCap = *ppCCThisCap++))		
		{
			ERRORMESSAGE(("%s:null pTermCap, 0x%04x of 0x%04x\r\n",
				_fx_, pTermCapList->wLength - wNumCaps, pTermCapList->wLength));
			continue;
		}	
		if(!IsCapabilityRecognized(pCCThisCap))
		{
			continue;
		}
		AddRemoteDecodeFormat(pCCThisCap);
	}
	return hr;
}




// Given the ID of a local format, gets the channel parameters that are sent to the
// remote end as part of the capability exchange.  This function is not used by the
// capability exchange code (because it sends more than just these parameters).
// However, this is useful information by itself - it can be used for validating the
// parameters of channel open requests against the expected parameters

HRESULT CMsivCapability::GetPublicDecodeParams(LPVOID pBufOut, UINT uBufSize, VIDEO_FORMAT_ID id)
{
	UINT uIndex = IDToIndex(id);
	// 	validate input
	if(!pBufOut|| (uIndex >= (UINT)uNumLocalFormats))
	{
		return CAPS_E_INVALID_PARAM;
	}
	if(uBufSize < sizeof(CC_TERMCAP))
	{
		return CAPS_E_BUFFER_TOO_SMALL;
	}
	memcpy(pBufOut, &((pLocalFormats + uIndex)->H245Cap), sizeof(CC_TERMCAP));

	return hrSuccess;
}

HRESULT CMsivCapability::SetAudioPacketDuration(UINT uPacketDuration)
{
	return CAPS_E_INVALID_PARAM;
}
	
// Given the IDs of  "matching" local and remote formats, gets the preferred channel parameters
// that will be used in requests to open a channel for sending to the remote.

HRESULT CMsivCapability::GetEncodeParams(LPVOID pBufOut, UINT uBufSize,LPVOID pLocalParams, UINT uSizeLocal,
	VIDEO_FORMAT_ID idRemote, VIDEO_FORMAT_ID idLocal)
{
	UINT uLocalIndex = IDToIndex(idLocal);
   	VIDCAP_DETAILS *pLocalDetails  = pLocalFormats + uLocalIndex;
	VIDCAP_DETAILS *pFmtTheirs;
	VIDEO_CHANNEL_PARAMETERS local_params;
	UINT u;
	PCC_TERMCAP pTermCap = (PCC_TERMCAP)pBufOut;
	
	// 	validate input
	// AddCapabilityBase adds to the ID below. Make sure we're checking Video Formats
	if(!pBufOut)
	{
		return CAPS_E_INVALID_PARAM;
	}
	if(uBufSize < sizeof(CC_TERMCAP))
	{
		return CAPS_E_BUFFER_TOO_SMALL;
	}
	if(!pLocalParams|| uSizeLocal < sizeof(VIDEO_CHANNEL_PARAMETERS)
		||(uLocalIndex >= (UINT)uNumLocalFormats))
	{
		return CAPS_E_INVALID_PARAM;
	}

	pFmtTheirs = pRemoteDecodeFormats; 		// start at the beginning of the remote formats
	for(u=0; u<uNumRemoteDecodeFormats; u++)
	{
		if(pFmtTheirs->H245Cap.CapId == idRemote)
		{
			// copy CC_TERMCAP struct. Any data referenced by CC_TERMCAP now has
			// two references to it.  i.e. pTermCap->extrablah is the same
			// location as pFmtTheirs->extrablah
			memcpy(pBufOut, &(pFmtTheirs->H245Cap), sizeof(CC_TERMCAP));
			break;
		}
		pFmtTheirs++;	// next entry in receiver's caps
	}

	// check for an unfound format
	if(u >= uNumRemoteDecodeFormats)
		goto ERROR_EXIT;
		
	// select channel parameters if appropriate.   The audio formats that have variable parameters
	// are :

#pragma message ("Are H.26? variable parameter formats?")
	// H245_CAP_H261               H245Vid_H261;
	// H245_CAP_H263               H245Vid_H263;
	// and of course all nonstandard formats

	// Select parameters based on local capability info
	
	if(pTermCap->ClientType == H245_CLIENT_VID_H263)	
	{
		unsigned short bit_mask;	
		// select frames per packet based on minimum latency value that is acceptable
#define H263_QCIF	0x4000
#define H263_MAXBP	0x0200
//H263_QCIF | H263_MAXBP;

	
	   pTermCap->Cap.H245Vid_H263.bit_mask= H263_MAXBP | pLocalDetails->H245Cap.Cap.H245Vid_H263.bit_mask;


	   local_params.ns_params.maxBitRate = pTermCap->Cap.H245Vid_H263.maxBitRate
	   	= min (pLocalDetails->nonstd_params.maxBitRate , pFmtTheirs->H245Cap.Cap.H245Vid_H263.maxBitRate);
	   local_params.ns_params.maxBPP = pTermCap->Cap.H245Vid_H263.bppMaxKb
	   	= min (pLocalDetails->nonstd_params.maxBPP, pFmtTheirs->H245Cap.Cap.H245Vid_H263.bppMaxKb);


		// we (the local end) need to know that actual MPI is going to be used!
		// like everywhere else in this module, the assumption is that local H.263 capabilities are
		// fanned out with one local cap entry per frame size.
		// MPI minimum interval in units of 1/29.97sec so take the longest interval
		// there is no pretty way to do this	
		bit_mask = pLocalDetails->H245Cap.Cap.H245Vid_H263.bit_mask;
		if(bit_mask & H263VideoCapability_sqcifMPI_present)
		{
			local_params.ns_params.MPI = pTermCap->Cap.H245Vid_H263.sqcifMPI =
				max(pLocalDetails->nonstd_params.MPI,
					pTermCap->Cap.H245Vid_H263.sqcifMPI);
		}
		else if (bit_mask &  H263VideoCapability_qcifMPI_present)
		{
			local_params.ns_params.MPI = pTermCap->Cap.H245Vid_H263.H263VdCpblty_qcifMPI =
				max(pLocalDetails->nonstd_params.MPI,
					pTermCap->Cap.H245Vid_H263.H263VdCpblty_qcifMPI);
		}
		else if (bit_mask &  H263VideoCapability_cifMPI_present)
		{
			local_params.ns_params.MPI = pTermCap->Cap.H245Vid_H263.H263VdCpblty_cifMPI =
				max(pLocalDetails->nonstd_params.MPI,
					pTermCap->Cap.H245Vid_H263.H263VdCpblty_cifMPI);
		}
		else if (bit_mask &  H263VideoCapability_cif4MPI_present)
		{
			local_params.ns_params.MPI = pTermCap->Cap.H245Vid_H263.cif4MPI =
				max(pLocalDetails->H245Cap.Cap.H245Vid_H263.cif4MPI,
					pTermCap->Cap.H245Vid_H263.cif4MPI);
		}
		else if (bit_mask &  H263VideoCapability_cif16MPI_present)
		{
			local_params.ns_params.MPI = pTermCap->Cap.H245Vid_H263.cif16MPI =
				max(pLocalDetails->nonstd_params.MPI,
					pTermCap->Cap.H245Vid_H263.cif16MPI);
		}
		// else	// impossible.  Doom, as MikeG and JonT would say

	}
	else if(pTermCap->ClientType == H245_CLIENT_VID_H261)	
	{
		unsigned short bit_mask;	
		// select frames per packet based on minimum latency value that is acceptable
	
	   pTermCap->Cap.H245Vid_H261.bit_mask= pLocalDetails->H245Cap.Cap.H245Vid_H261.bit_mask;


	   local_params.ns_params.maxBitRate = pTermCap->Cap.H245Vid_H261.maxBitRate
	   	= min (pLocalDetails->nonstd_params.maxBitRate , pFmtTheirs->H245Cap.Cap.H245Vid_H261.maxBitRate);
	
		// we (the local end) need to know that actual MPI is going to be used!
		// like everywhere else in this module, the assumption is that local H.261 capabilities are
		// fanned out with one local cap entry per frame size.
		// MPI minimum interval in units of 1/29.97sec so take the longest interval
		// there is no pretty way to do this	
		bit_mask = pLocalDetails->H245Cap.Cap.H245Vid_H261.bit_mask;
		if (bit_mask &  H261VdCpblty_qcifMPI_present)
		{
			local_params.ns_params.MPI = pTermCap->Cap.H245Vid_H261.H261VdCpblty_qcifMPI =
				max(pLocalDetails->nonstd_params.MPI,
					pTermCap->Cap.H245Vid_H261.H261VdCpblty_qcifMPI);
		}
		else if (bit_mask &  H261VdCpblty_cifMPI_present)
		{
			local_params.ns_params.MPI = pTermCap->Cap.H245Vid_H261.H261VdCpblty_cifMPI =
				max(pLocalDetails->nonstd_params.MPI,
					pTermCap->Cap.H245Vid_H261.H261VdCpblty_cifMPI);
		}
		// else	// impossible.  Doom, as MikeG and JonT would say

	}
	else if (pTermCap->ClientType == H245_CLIENT_VID_NONSTD)
	{
		// NOT YET IMPLEMENTED!!!!.  even the nonstandard parameters need to be fixed
		// up here based on mutual maxes and mins
		memcpy(&local_params.ns_params, &pLocalDetails->nonstd_params,
			sizeof(NSC_CHANNEL_VIDEO_PARAMETERS));
	}
	local_params.RTP_Payload = pLocalDetails->video_params.RTPPayload;
	//Fixup local
	memcpy(pLocalParams, &local_params, sizeof(VIDEO_CHANNEL_PARAMETERS));

	
	return hrSuccess;

	ERROR_EXIT:
	return CAPS_E_INVALID_PARAM;
}	



BOOL NonStandardCapsCompareV(VIDCAP_DETAILS *pFmtMine, PNSC_VIDEO_CAPABILITY pCap2,
	UINT uSize2)
{
	PVIDEOFORMATEX lpvcd;
	if(!pFmtMine || !pCap2)
		return FALSE;

	if(!(lpvcd = (PVIDEOFORMATEX)pFmtMine->lpLocalFormatDetails))
		return FALSE;

		
	if(pCap2->cvp_type == NSC_VCM_VIDEOFORMATEX)
	{
		// check sizes first
		if(lpvcd->bih.biSize != pCap2->cvp_data.vfx.bih.biSize)
		{
			return FALSE;
		}
		// compare structures, including extra bytes
		if(memcmp(lpvcd, &pCap2->cvp_data.vfx,
			sizeof(VIDEOFORMATEX) - BMIH_SLOP_BYTES)==0)
		{
			return TRUE;										
		}
	}
	else if(pCap2->cvp_type == NSC_VCMABBREV)
	{
	        if((LOWORD(pCap2->cvp_data.vcm_brief.dwFormatTag) == lpvcd->dwFormatTag)
		 && (pCap2->cvp_data.vcm_brief.dwSamplesPerSec ==  lpvcd->nSamplesPerSec)
		 && (LOWORD(pCap2->cvp_data.vcm_brief.dwBitsPerSample) ==  lpvcd->wBitsPerSample))
 		{
			return TRUE;
 		}
	}
	return FALSE;
}


BOOL HasNonStandardCapsTS(VIDCAP_DETAILS *pFmtMine, PNSC_VIDEO_CAPABILITY pCap2)
{
	PVIDEOFORMATEX lpvcd;

	if(!pFmtMine || !pCap2)
		return FALSE;

	if(!(lpvcd = (PVIDEOFORMATEX)pFmtMine->lpLocalFormatDetails))
		return FALSE;
		
	if(pCap2->cvp_type == NSC_VCM_VIDEOFORMATEX)
		if(lpvcd->dwSupportTSTradeOff && pCap2->cvp_data.vfx.dwSupportTSTradeOff)
			return TRUE;

	return FALSE;
}



HRESULT CMsivCapability::ResolveToLocalFormat(MEDIA_FORMAT_ID FormatIDLocal,
		MEDIA_FORMAT_ID * pFormatIDRemote)
{
	VIDCAP_DETAILS *pFmtLocal;
	VIDCAP_DETAILS *pFmtRemote;
	UINT format_mask;
	UINT uIndex = IDToIndex(FormatIDLocal);
	UINT i;

	if(!pFormatIDRemote || (FormatIDLocal == INVALID_MEDIA_FORMAT)
		|| (uIndex >= (UINT)uNumLocalFormats))
	{
		return CAPS_E_INVALID_PARAM;
	}
	pFmtLocal = pLocalFormats + uIndex;
	
	pFmtRemote = pRemoteDecodeFormats;     // start at the beginning of the remote formats
	for(i=0; i<uNumRemoteDecodeFormats; i++)
	{
		if(!pFmtLocal->bSendEnabled)
			continue;
			
		// compare capabilities - start by comparing the format tag. a.k.a. "ClientType" in H.245 land
		if(pFmtLocal->H245Cap.ClientType ==  pFmtRemote->H245Cap.ClientType)
		{
			// if this is a nonstandard cap, compare nonstandard parameters
			if(pFmtLocal->H245Cap.ClientType == H245_CLIENT_VID_NONSTD)
			{
				if(NonStandardCapsCompareV(pFmtLocal,
					(PNSC_VIDEO_CAPABILITY)pFmtRemote->H245Cap.Cap.H245Vid_NONSTD.data.value,
					pFmtRemote->H245Cap.Cap.H245Vid_NONSTD.data.length))
				{
					goto RESOLVED_EXIT;
				}
			}
			else	// compare standard parameters, if any
			{
				// well, so far, there aren't any parameters that are significant enough
				// to affect the match/no match decision
				if (pFmtLocal->H245Cap.ClientType == H245_CLIENT_VID_H263)
				{
				       format_mask=  H263VideoCapability_sqcifMPI_present
				       	| H263VideoCapability_qcifMPI_present | H263VideoCapability_cifMPI_present	
				       	| H263VideoCapability_cif4MPI_present | H263VideoCapability_cif16MPI_present;
				       if ((pFmtRemote->H245Cap.Cap.H245Vid_H263.bit_mask & format_mask) & (pFmtLocal->H245Cap.Cap.H245Vid_H263.bit_mask & format_mask))
				       {
				       		// compatible basic format
						  	goto RESOLVED_EXIT;
				       }
				}
				else if (pFmtLocal->H245Cap.ClientType == H245_CLIENT_VID_H261)
				{
				       format_mask=  H261VdCpblty_qcifMPI_present | H261VdCpblty_cifMPI_present;
				       if ((pFmtRemote->H245Cap.Cap.H245Vid_H261.bit_mask & format_mask) & (pFmtLocal->H245Cap.Cap.H245Vid_H261.bit_mask & format_mask))
				       {
				       		// compatible basic format
						  	goto RESOLVED_EXIT;
				       }
				}
				else
				{
				   //Some other standard format
				   goto RESOLVED_EXIT;
				}
			}
		}		
		pFmtRemote++;	// next entry in remote caps
	}
	return CAPS_E_NOMATCH;
	
RESOLVED_EXIT:
// Match!
	// return ID of remote decoding (receive fmt) caps that match our
	// send caps
	*pFormatIDRemote = pFmtRemote->H245Cap.CapId;
	return hrSuccess;
}

// resolve using currently cached local and remote formats

HRESULT CMsivCapability::ResolveEncodeFormat(
 	VIDEO_FORMAT_ID *pIDEncodeOut,
	VIDEO_FORMAT_ID *pIDRemoteDecode)
{
	UINT i,j=0,format_mask;
	VIDCAP_DETAILS *pFmtMine = pLocalFormats;
	VIDCAP_DETAILS *pFmtTheirs;
	
	if(!pIDEncodeOut || !pIDRemoteDecode)
	{
		return CAPS_E_INVALID_PARAM;
	}
	if(!uNumLocalFormats || !pLocalFormats)
	{
		*pIDEncodeOut = *pIDRemoteDecode = INVALID_VIDEO_FORMAT;
		return CAPS_E_NOCAPS;
	}
	if(!pRemoteDecodeFormats || !uNumRemoteDecodeFormats)
	{
		*pIDEncodeOut = *pIDRemoteDecode = INVALID_VIDEO_FORMAT;
		return CAPS_E_NOMATCH;
	}

	// decide how to encode.  my caps are ordered by my preference according to
	// the contents of IDsByRank[]
	//If given a salt, find the position and add it
	if (*pIDEncodeOut != INVALID_MEDIA_FORMAT)
	{
		UINT uIndex = IDToIndex(*pIDEncodeOut);
		if (uIndex > uNumLocalFormats)
		{
			return CAPS_W_NO_MORE_FORMATS;
		}
		for(i=0; i<uNumLocalFormats; i++)
		{
			if (pLocalFormats[IDsByRank[i]].H245Cap.CapId == *pIDEncodeOut)
			{
	 			j=i+1;
				break;
			}
		}	
	}

	// start at index j
	for(i=j; i<uNumLocalFormats; i++)
	{
		pFmtMine = pLocalFormats + IDsByRank[i];	
		// check to see if this format is enabled for encoding
		if(!pFmtMine->bSendEnabled)
			continue;

		pFmtTheirs = pRemoteDecodeFormats; 		// start at the beginning of the remote formats
		for(j=0; j<uNumRemoteDecodeFormats; j++)
		{
			// compare capabilities - start by comparing the format tag. a.k.a. "ClientType" in H.245 land
			if(pFmtMine->H245Cap.ClientType ==  pFmtTheirs->H245Cap.ClientType)
			{
				// if this is a nonstandard cap, compare nonstandard parameters
				if(pFmtMine->H245Cap.ClientType == H245_CLIENT_VID_NONSTD)
				{

					if(NonStandardCapsCompareV(pFmtMine,
						(PNSC_VIDEO_CAPABILITY)pFmtTheirs->H245Cap.Cap.H245Vid_NONSTD.data.value,
						pFmtTheirs->H245Cap.Cap.H245Vid_NONSTD.data.length))
					{
						goto RESOLVED_EXIT;
					}
				

				}
				else	// compare standard parameters, if any
				{
					// well, so far, there aren't any parameters that are significant enough
					// to affect the match/no match decision
					if (pFmtMine->H245Cap.ClientType == H245_CLIENT_VID_H263)
					{
					       format_mask=  H263VideoCapability_sqcifMPI_present| H263VideoCapability_qcifMPI_present
					       	|H263VdCpblty_cifMPI_present	
					       	|H263VideoCapability_cif4MPI_present
					       	|H263VideoCapability_cif16MPI_present;
					       if ((pFmtTheirs->H245Cap.Cap.H245Vid_H263.bit_mask & format_mask) & (pFmtMine->H245Cap.Cap.H245Vid_H263.bit_mask & format_mask))
					       {
					       		// compatible basic format
							  	goto RESOLVED_EXIT;
					       }
					}
					else if (pFmtMine->H245Cap.ClientType == H245_CLIENT_VID_H261)
					{
					       format_mask=  H261VdCpblty_qcifMPI_present | H261VdCpblty_cifMPI_present;
					       if ((pFmtTheirs->H245Cap.Cap.H245Vid_H261.bit_mask & format_mask) & (pFmtMine->H245Cap.Cap.H245Vid_H261.bit_mask & format_mask))
					       {
					       		// compatible basic format
							  	goto RESOLVED_EXIT;
					       }
					} else {
					   //Some other standard format
					   goto RESOLVED_EXIT;

					}

				}
			}		
			pFmtTheirs++;	// next entry in receiver's caps
		}
		
	}
	return CAPS_E_NOMATCH;
	
RESOLVED_EXIT:
// Match!
// return ID of our encoding (sending fmt) caps that match
	
	*pIDEncodeOut = pFmtMine->H245Cap.CapId;
	// return ID of remote decoding (receive fmt) caps that match our
	// send caps
	*pIDRemoteDecode = pFmtTheirs->H245Cap.CapId;
	return hrSuccess;

	
}

HRESULT CMsivCapability::GetDecodeParams(PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS  pChannelParams,
		VIDEO_FORMAT_ID * pFormatID, LPVOID lpvBuf, UINT uBufSize)
{
	UINT i,j=0;
	VIDCAP_DETAILS *pFmtMine = pLocalFormats;
	VIDCAP_DETAILS *pFmtTheirs = pRemoteDecodeFormats; 	

	VIDEO_CHANNEL_PARAMETERS local_params;
	PNSC_CHANNEL_VIDEO_PARAMETERS pNSCap = &local_params.ns_params;
	PCC_TERMCAP pCapability;
	
	if(!pChannelParams || !(pCapability = pChannelParams->pChannelCapability) || !pFormatID || !lpvBuf ||
		(uBufSize < sizeof(VIDEO_CHANNEL_PARAMETERS)))
	{
		return CAPS_E_INVALID_PARAM;
	}
	if(!uNumLocalFormats || !pLocalFormats)
	{
		return CAPS_E_NOCAPS;
	}
	
	local_params.TS_Tradeoff = FALSE;		// initialize TS tradeoff
	for(i=0; i<uNumLocalFormats; i++)
	{
		pFmtMine = pLocalFormats + IDsByRank[i];	
	
		// compare capabilities - start by comparing the format tag. a.k.a. "ClientType" in H.245 land
		if(pFmtMine->H245Cap.ClientType ==  pCapability->ClientType)
		{
		   // if this is a nonstandard cap, compare nonstandard parameters
		   if(pFmtMine->H245Cap.ClientType == H245_CLIENT_VID_NONSTD)
		   {
				if(NonStandardCapsCompareV(pFmtMine, (PNSC_VIDEO_CAPABILITY)pCapability->Cap.H245Vid_NONSTD.data.value,
					pCapability->Cap.H245Vid_NONSTD.data.length))
				{
					#pragma message ("someday may need need fixup of nonstd params")
					// for now, the remote & local nonstandard params are what we want
					// and the remote's version of NSC_CHANNEL_VIDEO_PARAMETERS will
					// be copied out
					pNSCap = (PNSC_CHANNEL_VIDEO_PARAMETERS)
						&((PNSC_VIDEO_CAPABILITY)pCapability->Cap.H245Vid_NONSTD.data.value)->cvp_params;

					// Does this format support temporal/spatial tradeoff
					if(HasNonStandardCapsTS(pFmtMine, (PNSC_VIDEO_CAPABILITY)pCapability->Cap.H245Vid_NONSTD.data.value))
						local_params.TS_Tradeoff = TRUE;	
					else
						local_params.TS_Tradeoff = FALSE;

					goto RESOLVED_EXIT;
				}
			}
			else	// compare standard parameters, if any
			{
				switch (pFmtMine->H245Cap.ClientType)
				{
					unsigned short bit_mask, format_mask, usMyMPI, usTheirMPI;

					case H245_CLIENT_VID_H263:
					// like everywhere else in this module, the assumption is that
					// local H.263 capabilities are fanned out with one local cap entry
					// per frame size.
						
						format_mask=  H263VideoCapability_sqcifMPI_present
							| H263VideoCapability_qcifMPI_present
							| H263VideoCapability_cifMPI_present	
							| H263VideoCapability_cif4MPI_present
							| H263VideoCapability_cif16MPI_present;
						// bail out if no match or nonexistent frame size
						if (!((pCapability->Cap.H245Vid_H263.bit_mask & format_mask) & (pFmtMine->H245Cap.Cap.H245Vid_H263.bit_mask & format_mask)))
							continue;
								
						//  get the maximum bitrate
						local_params.ns_params.maxBitRate = min(pFmtMine->H245Cap.Cap.H245Vid_H263.maxBitRate,
						 	pCapability->Cap.H245Vid_H263.maxBitRate);
						local_params.ns_params.maxBPP = min (pFmtMine->H245Cap.Cap.H245Vid_H263.bppMaxKb ,
							pCapability->Cap.H245Vid_H263.bppMaxKb);
	
						// FIND THE MAXIMUM MPI!!!!. (minimum frame rate)
						// there is no pretty way to do this	
						bit_mask = pFmtMine->H245Cap.Cap.H245Vid_H263.bit_mask;
						if(bit_mask & H263VideoCapability_sqcifMPI_present)
						{
							local_params.ns_params.MPI =
								max(pFmtMine->H245Cap.Cap.H245Vid_H263.sqcifMPI,
									pCapability->Cap.H245Vid_H263.sqcifMPI);
						}
						else if (bit_mask &  H263VideoCapability_qcifMPI_present)
						{
							local_params.ns_params.MPI =
								max(pFmtMine->H245Cap.Cap.H245Vid_H263.H263VdCpblty_qcifMPI,
									pCapability->Cap.H245Vid_H263.H263VdCpblty_qcifMPI);
						}
						else if (bit_mask &  H263VideoCapability_cifMPI_present)
						{
							local_params.ns_params.MPI =
								max(pFmtMine->H245Cap.Cap.H245Vid_H263.H263VdCpblty_cifMPI,
									pCapability->Cap.H245Vid_H263.H263VdCpblty_cifMPI);
						}
						else if (bit_mask &  H263VideoCapability_cif4MPI_present)
						{
							local_params.ns_params.MPI =
								max(pFmtMine->H245Cap.Cap.H245Vid_H263.cif4MPI,
									pCapability->Cap.H245Vid_H263.cif4MPI);
						}
						else if (bit_mask &  H263VideoCapability_cif16MPI_present)
						{
							local_params.ns_params.MPI =
								max(pFmtMine->H245Cap.Cap.H245Vid_H263.cif16MPI,
									pCapability->Cap.H245Vid_H263.cif16MPI);

						}
						else	// impossible.  Doom, as MikeG and JonT would say
							continue;

						// Fallout (And the format is found!)
						
						// And one more special thing: find out if the other end
						// advertised Temporal/Spatial tradeoff in it's send capabilities.
						// First try the obvious.  Technically, it only makes sense for
						// transmit capabilities, but if the channel params have it, then
						// the other end must have the capability
						if(pCapability->Cap.H245Vid_H263.tmprlSptlTrdOffCpblty)
						{
							local_params.TS_Tradeoff = TRUE;	
						}
						else
						{
							// Search for a H.263 SEND capability that has the T/S tradoff set
							for(j=0; j<uNumRemoteDecodeFormats; j++)
							{
								if((pFmtTheirs->H245Cap.ClientType == H245_CLIENT_VID_H263)
								// exclude RX capabilities
									&&  (pFmtTheirs->H245Cap.Dir != H245_CAPDIR_LCLRX)
									&&  (pFmtTheirs->H245Cap.Dir != H245_CAPDIR_RMTRX))
								{
									if ((pFmtTheirs->H245Cap.Cap.H245Vid_H263.bit_mask & format_mask) & (pFmtMine->H245Cap.Cap.H245Vid_H263.bit_mask & format_mask))
									{
										local_params.TS_Tradeoff = TRUE;
										break;
									}
								}		
								pFmtTheirs++;	// next entry in receiver's caps
							}

						}
						goto RESOLVED_EXIT;
						
					break;
		
					case H245_CLIENT_VID_H261:
					// like everywhere else in this module, the assumption is that
					// local H.261 capabilities are fanned out with one local cap entry
					// per frame size.
						
						format_mask=  H261VdCpblty_qcifMPI_present |H261VdCpblty_cifMPI_present;
						// bail out if no match or nonexistent frame size
						if (!((pCapability->Cap.H245Vid_H261.bit_mask & format_mask) & (pFmtMine->H245Cap.Cap.H245Vid_H261.bit_mask & format_mask)))
							continue;
								
						//  get the maximum bitrate
						local_params.ns_params.maxBitRate = min(pFmtMine->H245Cap.Cap.H245Vid_H261.maxBitRate,
						 	pCapability->Cap.H245Vid_H261.maxBitRate);
	
						// FIND THE MAXIMUM MPI!!!!. (minimum frame rate)
						// there is no pretty way to do this	
						bit_mask = pFmtMine->H245Cap.Cap.H245Vid_H261.bit_mask;
						if (bit_mask &  H261VdCpblty_qcifMPI_present)
						{
							local_params.ns_params.MPI =
								max(pFmtMine->H245Cap.Cap.H245Vid_H261.H261VdCpblty_qcifMPI,
									pCapability->Cap.H245Vid_H261.H261VdCpblty_qcifMPI);
						}
						else if (bit_mask &  H261VdCpblty_cifMPI_present)
						{
							local_params.ns_params.MPI =
								max(pFmtMine->H245Cap.Cap.H245Vid_H261.H261VdCpblty_cifMPI,
									pCapability->Cap.H245Vid_H261.H261VdCpblty_cifMPI);
						}
						else	// impossible.  Doom, as MikeG and JonT would say
							continue;

						// Fallout (And the format is found!)
						
						// And one more special thing: find out if the other end
						// advertised Temporal/Spatial tradeoff in it's send capabilities.
						// First try the obvious.  Technically, it only makes sense for
						// transmit capabilities, but if the channel params have it, then
						// the other end must have the capability
						if(pCapability->Cap.H245Vid_H261.tmprlSptlTrdOffCpblty)
						{
							local_params.TS_Tradeoff = TRUE;	
						}
						else
						{
							// Search for a H.261 SEND capability that has the T/S tradoff set
							for(j=0; j<uNumRemoteDecodeFormats; j++)
							{
								if((pFmtTheirs->H245Cap.ClientType == H245_CLIENT_VID_H261)
								// exclude RX capabilities
									&&  (pFmtTheirs->H245Cap.Dir != H245_CAPDIR_LCLRX)
									&&  (pFmtTheirs->H245Cap.Dir != H245_CAPDIR_RMTRX))
								{
									if ((pFmtTheirs->H245Cap.Cap.H245Vid_H261.bit_mask
										& format_mask)
										& (pFmtMine->H245Cap.Cap.H245Vid_H261.bit_mask
										& format_mask))
									{
										local_params.TS_Tradeoff = TRUE;
										break;
									}
								}		
								pFmtTheirs++;	// next entry in receiver's caps
							}

						}
						goto RESOLVED_EXIT;
					break;

					default:
						goto RESOLVED_EXIT;
					break;
			
					
				}
			}// end else compare standard parameters, if any	
		}// end if(pFmtMine->H245Cap.ClientType ==  pCapability->ClientType)
	}
	return CAPS_E_NOMATCH;

RESOLVED_EXIT:
	// Match!
	// return ID of the decoding caps that match
	*pFormatID = pFmtMine->H245Cap.CapId;
	local_params.RTP_Payload = pChannelParams->bRTPPayloadType;;
	memcpy(lpvBuf, &local_params, sizeof(VIDEO_CHANNEL_PARAMETERS));
	return hrSuccess;
}



HRESULT CMsivCapability::SetCapIDBase (UINT uNewBase)
{
	uCapIDBase = uNewBase;	
	UINT u;
	for (u=0;u<uNumLocalFormats;u++)
	{
    	pLocalFormats[u].H245Cap.CapId = u + uCapIDBase;
	}
   	return hrSuccess;
}

BOOL CMsivCapability::IsHostForCapID(MEDIA_FORMAT_ID CapID)
{
	if((CapID >= uCapIDBase) && ((CapID - uCapIDBase) < uNumLocalFormats))
		return TRUE;
	else
		return FALSE;
	
}



HRESULT CMsivCapability::IsFormatEnabled (MEDIA_FORMAT_ID FormatID, PBOOL bRecv, PBOOL bSend)
{
   UINT uIndex = IDToIndex(FormatID);
   // 	validate input
   if(uIndex >= (UINT)uNumLocalFormats)
   {
	   return CAPS_E_INVALID_PARAM;
   }
   *bSend=((pLocalFormats + uIndex)->bSendEnabled);
   *bRecv=((pLocalFormats + uIndex)->bRecvEnabled);

   return hrSuccess;

}

BOOL CMsivCapability::IsFormatPublic (MEDIA_FORMAT_ID FormatID)
{
	UINT uIndex = IDToIndex(FormatID);
	// 	validate input
	if(uIndex >= (UINT)uNumLocalFormats)
		return FALSE;
		
	// test if this is format is a duplicate of a public format
	if((pLocalFormats + uIndex)->dwPublicRefIndex)
		return FALSE;	// then we keep this format to ourselves
	else
		return TRUE;
}
MEDIA_FORMAT_ID CMsivCapability::GetPublicID(MEDIA_FORMAT_ID FormatID)
{
	UINT uIndex = IDToIndex(FormatID);
	// 	validate input
	if(uIndex >= (UINT)uNumLocalFormats)
		return INVALID_MEDIA_FORMAT;
		
	if((pLocalFormats + uIndex)->dwPublicRefIndex)
	{
		return (pLocalFormats + ((pLocalFormats + uIndex)->dwPublicRefIndex))->H245Cap.CapId;
	}
	else
	{
		return FormatID;
	}
}

// Returns the Id of the format with the smallest wSortIndex - preferred format.
HRESULT CMsivCapability::GetPreferredFormatId (VIDEO_FORMAT_ID *pId)
{
	HRESULT			hr = hrSuccess;
	VIDCAP_DETAILS	*pDetails = pLocalFormats;
	UINT			u, uIndex;	
	WORD			wSortIndex, wMinSortIndex = SHRT_MAX;

	// Validate input param
	if (!pId)
		return((HRESULT)CAPS_E_INVALID_PARAM);

	// Validate state
	if(!uNumLocalFormats || !pDetails)
		return((HRESULT)CAPS_E_NOCAPS);

	// Look for the format with the smallest wSortIndex
	for (u = 0; (u < uNumLocalFormats) && (u < MAX_CAPS_PRESORT); u++)
	{
		pDetails = pLocalFormats + IDsByRank[u];	
		// Find the sort index.
		uIndex = (UINT)(pDetails - pLocalFormats);
		for (wSortIndex = 0; (wSortIndex < uNumLocalFormats) && (wSortIndex < MAX_CAPS_PRESORT); wSortIndex++)
		{
			if (uIndex == IDsByRank[wSortIndex])
				break; // Found it
		}
		if (wSortIndex <= wMinSortIndex)
		{
			*pId = IndexToId(uIndex);
			wMinSortIndex = wSortIndex;
		}
	}

	return(hr);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\mixer.cpp ===
#include "precomp.h"
#include <mixer.h>

//
// private APIs
//


#define MAX_MICROPHONE_DEVS 10

static MMRESULT mixerGetControlValue ( HMIXER, DWORD *, DWORD, UINT );
static MMRESULT mixerSetControlValue ( HMIXER, DWORD *, DWORD, UINT );
static MMRESULT mixerGetControlId ( HMIXER, DWORD *, DWORD, DWORD );
static MMRESULT mixerGetControlByType ( HMIXER, DWORD, DWORD, MIXERCONTROL *pMixerControl);


struct AGCDetails
{
	WORD wMID; // manufacturer ID
	WORD wPID; // product ID
	DWORD dwAGCID; // AGC ID
};


static const AGCDetails AGCList[] =
{
//  MID    PID   AGCID
    {1,     323,   27},  // Creative Labs (NT)
    {1,     104,   21},  // Creative Labs (NT 5)
    {2,     409,   27},  // Creative Labs
    {21,     42,   13},  // Turtle Beach Tropez
    {132,     3, 2072},  // Crystal MMX
    {384,     7,   28},  // Xitel Storm 3d PCI
    {385,    32,   35}   // Aztech PCI-331
};


static BOOL GetAGCID(WORD wMID, WORD wPID, DWORD *pdwAGCID)
{
	int nIndex;
	int nAGCEntries = sizeof(AGCList) / sizeof(AGCDetails);

	for (nIndex = 0; nIndex < nAGCEntries; nIndex++)
	{
		if ( (AGCList[nIndex].wMID == wMID) &&
		     (AGCList[nIndex].wPID == wPID))
		{
			*pdwAGCID = AGCList[nIndex].dwAGCID;
			return TRUE;
		}
	}
	return FALSE;
}



//
//	Init
//
//	Enumerate all existing mixers in the system. For each mixer,
//	we enumerate all lines with destination Speaker and WaveIn.
//	For each such line, we cache the control id and control value
//	of volume control. An invalid flag will be tagged to any control
//  not supported by this mixer.
//	When an application is finished with all mixers operations,
//	it must call ReleaseAllMixers to free all memory resources and
//	mixers.
//
//	THIS MUST BE THE FIRST API TO CALL TO START MIXER OPERATIONS.
//
//	Input: The handle of the window which will handle all callback
//	messages MM_MIXM_CONTROL_CHANGE and MM_MIXM_LINE_CHANGE.
//
//	Output: TRUE if success; otherwise, FALSE.
//
BOOL CMixerDevice::Init( HWND hWnd, UINT_PTR uWaveDevId, DWORD dwFlags)
{
	UINT uDstIdx, uSrcIdx, uMixerIdCheck, uMixerIdx;
	MMRESULT mmr = MMSYSERR_NOERROR;
	MIXERLINE mlDst, mlSrc;
	UINT_PTR nMixers, nWaveInDevs,  uIndex;

	//get the mixer device corresponding to the wave device
	mmr = mixerGetID((HMIXEROBJ)uWaveDevId, &uMixerIdx, dwFlags);
	if ((mmr != MMSYSERR_NOERROR) && (mmr != MMSYSERR_NODRIVER)) {
		return FALSE;
	}

	// a simple fix for cheesy sound cards that don't make a
	// direct mapping between waveDevice and mixer device
	// e.g. MWAVE cards and newer SB NT 4 drivers
	// If there is only ONE mixer device  and if no other waveIn device
	// uses it, then it is probably valid.

	if ((mmr == MMSYSERR_NODRIVER) && (dwFlags == MIXER_OBJECTF_WAVEIN))
	{
		nMixers = mixerGetNumDevs();
		nWaveInDevs = waveInGetNumDevs();
		if (nMixers == 1)
		{
			uMixerIdx = 0;
			for (uIndex = 0; uIndex < nWaveInDevs; uIndex++)
			{
				mmr = mixerGetID((HMIXEROBJ)uIndex, &uMixerIdCheck, dwFlags);
				if ((mmr == MMSYSERR_NOERROR) && (uMixerIdCheck == uMixerIdx))
				{
					return FALSE;  // the mixer belongs to another waveIn Device
				}
			}
		}
		else
		{
			return FALSE;
		}
	}


	// open the mixer such that we can get notification messages
	mmr = mixerOpen (
			&m_hMixer,
			uMixerIdx,
			(DWORD_PTR) hWnd,
			0,
			(hWnd ? CALLBACK_WINDOW : 0) | MIXER_OBJECTF_MIXER);
	if (mmr != MMSYSERR_NOERROR) {
		return FALSE;
	}

	// get mixer caps
	mmr = mixerGetDevCaps (uMixerIdx, &(m_mixerCaps), sizeof (MIXERCAPS));
	if ((mmr != MMSYSERR_NOERROR) || (0 == m_mixerCaps.cDestinations)) {
		mixerClose(m_hMixer);
		return FALSE;
	}

	for (uDstIdx = 0; uDstIdx < m_mixerCaps.cDestinations; uDstIdx++)
	{
		ZeroMemory (&mlDst, sizeof (mlDst));
		mlDst.cbStruct = sizeof (mlDst);
		mlDst.dwDestination = uDstIdx;

		// get the mixer line for this destination
		mmr = mixerGetLineInfo ((HMIXEROBJ)m_hMixer, &mlDst,
					MIXER_GETLINEINFOF_DESTINATION | MIXER_OBJECTF_HMIXER);
		if (mmr != MMSYSERR_NOERROR) continue;

		// examine the type of this destination line
		if (((MIXER_OBJECTF_WAVEOUT == dwFlags) &&
			 (MIXERLINE_COMPONENTTYPE_DST_SPEAKERS == mlDst.dwComponentType)) ||
			((MIXER_OBJECTF_WAVEIN == dwFlags) &&
			 (MIXERLINE_COMPONENTTYPE_DST_WAVEIN == mlDst.dwComponentType)))
		{
			 // fill in more info about DstLine
			m_DstLine.ucChannels = mlDst.cChannels;
			if (!(mlDst.fdwLine & MIXERLINE_LINEF_DISCONNECTED))
			{
				// get id and value of volume control
				mmr = mixerGetControlId (
						m_hMixer,
						&m_DstLine.dwControlId,
						mlDst.dwLineID,
						MIXERCONTROL_CONTROLTYPE_VOLUME);
				m_DstLine.fIdValid = (mmr == MMSYSERR_NOERROR);

				m_DstLine.dwLineId = mlDst.dwLineID;
				m_DstLine.dwCompType = mlDst.dwComponentType;
				m_DstLine.dwConnections = mlDst.cConnections;

				// -----------------------------------------------------
				// enumerate all sources for this destination
				for (uSrcIdx = 0; uSrcIdx < mlDst.cConnections; uSrcIdx++)
				{
					// get the info of the line with specific src and dst...
					ZeroMemory (&mlSrc, sizeof (mlSrc));
					mlSrc.cbStruct = sizeof (mlSrc);
					mlSrc.dwDestination = uDstIdx;
					mlSrc.dwSource = uSrcIdx;

					mmr = mixerGetLineInfo (
							(HMIXEROBJ)m_hMixer,
							&mlSrc,
							MIXER_GETLINEINFOF_SOURCE | MIXER_OBJECTF_HMIXER);
					if (mmr == MMSYSERR_NOERROR)
					{
						if (((MIXERLINE_COMPONENTTYPE_DST_SPEAKERS == mlDst.dwComponentType) &&
							 (MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT == mlSrc.dwComponentType)) ||
							((MIXERLINE_COMPONENTTYPE_DST_WAVEIN == mlDst.dwComponentType) &&
							 (MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE == mlSrc.dwComponentType)))
						{
							// fill in more info about this source
							m_SrcLine.ucChannels = mlSrc.cChannels;

							// get id and value of volume control
							mmr = mixerGetControlId (
									m_hMixer,
									&m_SrcLine.dwControlId,
									mlSrc.dwLineID,
									MIXERCONTROL_CONTROLTYPE_VOLUME);
							m_SrcLine.fIdValid = (mmr == MMSYSERR_NOERROR);

							m_SrcLine.dwLineId = mlSrc.dwLineID;
							m_SrcLine.dwCompType = mlSrc.dwComponentType;
							m_SrcLine.dwConnections = mlSrc.cConnections;

							break;
						}
					}
				}
			}
			break;
		}
	}
		
    return TRUE;
}

CMixerDevice* CMixerDevice::GetMixerForWaveDevice( HWND hWnd, UINT uWaveDevId, DWORD dwFlags)
{
    DBG_SAVE_FILE_LINE
	CMixerDevice* pMixerDev = new CMixerDevice;
	if (NULL != pMixerDev)
	{
		if (!pMixerDev->Init(hWnd, uWaveDevId, dwFlags))
		{
			delete pMixerDev;
			pMixerDev = NULL;
		}
	}
	return pMixerDev;
}

BOOL CMixerDevice::SetMainVolume(DWORD dwVolume)
{
	MMRESULT mmr = MMSYSERR_ERROR;
	DWORD adwVolume[2];

	adwVolume[0] = adwVolume[1] = (DWORD) LOWORD (dwVolume);

	if (m_DstLine.fIdValid) {
		mmr = mixerSetControlValue (
				m_hMixer,
				adwVolume,
				m_DstLine.dwControlId,
				2);
	}
	return (mmr == MMSYSERR_NOERROR);
}

BOOL CMixerDevice::SetSubVolume(DWORD dwVolume)
{
	MMRESULT mmr = MMSYSERR_ERROR;
	DWORD adwVolume[2];

	adwVolume[0] = adwVolume[1] = (DWORD) LOWORD (dwVolume);

	if (m_SrcLine.fIdValid)
	{
		mmr = mixerSetControlValue (
			m_hMixer,
			adwVolume,
			m_SrcLine.dwControlId,
			m_SrcLine.ucChannels);
	}
	return (mmr == MMSYSERR_NOERROR);
}

//
// Gets the volume (0 - 65535) of the master volume
// returns TRUE if succesful,
// returns FALSE if it fails or if this control is not available
//

BOOL CMixerDevice::GetMainVolume(LPDWORD pdwVolume)
{
	BOOL fRet = FALSE;

	if (m_DstLine.fIdValid)
	{
		DWORD adwVolume[2];
		MMRESULT mmr = ::mixerGetControlValue(
									m_hMixer,
									adwVolume,
									m_DstLine.dwControlId,
									2);
		fRet = (mmr == MMSYSERR_NOERROR);
		if (fRet)
		{
			// BUGBUG: is this the left channel only?
			*pdwVolume = LOWORD(adwVolume[0]);
		}
	}

	return fRet;
}

//
// Gets the volume (0 - 65535) of the sub volume
// returns TRUE if succesful,
// returns FALSE if it fails or if this control is not available
//

BOOL CMixerDevice::GetSubVolume(LPDWORD pdwVolume)
{
	BOOL fRet = FALSE;

	if (m_SrcLine.fIdValid)
	{
		DWORD adwVolume[2];
		MMRESULT mmr = ::mixerGetControlValue(
									m_hMixer,
									adwVolume,
									m_SrcLine.dwControlId,
									m_SrcLine.ucChannels);
		fRet = (mmr == MMSYSERR_NOERROR);
		if (fRet)
		{
			// BUGBUG: is this the left channel only?
			*pdwVolume = LOWORD(adwVolume[0]);
		}
	}

	return fRet;
}


// Return the value of the Auto Gain Control on SB16/AWE32 cards
// Returns FALSE if the control is not supported.
// pfOn is OUTPUT, OPTIONAL - value of AGC
BOOL CMixerDevice::GetAGC(BOOL *pfOn)
{
	MMRESULT mmr;
	DWORD dwAGCId;
	DWORD dwValue;

	if (FALSE == GetAGCID(m_mixerCaps.wMid, m_mixerCaps.wPid, &dwAGCId))
		return FALSE;

	mmr = mixerGetControlValue(m_hMixer, &dwValue, dwAGCId, 1);
	if (mmr != MMSYSERR_NOERROR)
		return FALSE;

	if (pfOn)
		*pfOn = dwValue;
	
	return TRUE;
}

/*
	Hack API to turn MIC Auto Gain Control on or off.
	Its a hack because it only works on SB16/AWE32 cards.
*/
BOOL CMixerDevice::SetAGC(BOOL fOn)
{
	DWORD dwAGCId;
	DWORD dwValue;
	MMRESULT mmr;

	if (FALSE == GetAGCID(m_mixerCaps.wMid, m_mixerCaps.wPid, &dwAGCId))
		return FALSE;

	mmr = mixerGetControlValue(m_hMixer, &dwValue, dwAGCId, 1);
	if (mmr != MMSYSERR_NOERROR)
		return FALSE;
	if (dwValue == (DWORD)fOn)
		return TRUE;
	dwValue = fOn;
	mmr = mixerSetControlValue(m_hMixer, &dwValue, dwAGCId, 1);
	return (mmr == MMSYSERR_NOERROR);
}

BOOL CMixerDevice::EnableMicrophone()
{
	MIXERLINE mixerLine;
	MIXERCONTROL mixerControl;
	MIXERCONTROLDETAILS mixerControlDetails, mixerControlDetailsOrig;
	UINT uIndex, numItems, numMics, numMicsSet, fMicFound;
	UINT uMicIndex = 0;
	UINT aMicIndices[MAX_MICROPHONE_DEVS];
	MIXERCONTROLDETAILS_LISTTEXT *aListText = NULL;
	MIXERCONTROLDETAILS_BOOLEAN *aEnableList = NULL;
	MMRESULT mmr;

	// check to see if component type is valid (which means the line exists!)
	// even if the volume control doesn't exist or isn't slidable,
	// there may still be a select switch
	if ((m_SrcLine.dwCompType != MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE) ||
	    (m_DstLine.dwCompType != MIXERLINE_COMPONENTTYPE_DST_WAVEIN))
	{
		return FALSE;
	}

	// try to find the mixer list
	if (    (MMSYSERR_NOERROR != mixerGetControlByType(m_hMixer, m_DstLine.dwLineId, MIXERCONTROL_CT_CLASS_LIST, &mixerControl))
	    &&  (MMSYSERR_NOERROR != mixerGetControlByType(m_hMixer, m_DstLine.dwLineId, MIXERCONTROL_CONTROLTYPE_MIXER, &mixerControl))
	    &&  (MMSYSERR_NOERROR != mixerGetControlByType(m_hMixer, m_DstLine.dwLineId, MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT, &mixerControl))
	    &&  (MMSYSERR_NOERROR != mixerGetControlByType(m_hMixer, m_DstLine.dwLineId, MIXERCONTROL_CONTROLTYPE_MUX, &mixerControl))
	    &&  (MMSYSERR_NOERROR != mixerGetControlByType(m_hMixer, m_DstLine.dwLineId, MIXERCONTROL_CONTROLTYPE_SINGLESELECT, &mixerControl))
	   )
	{
		TRACE_OUT(("CMixerDevice::EnableMicrophone-Unable to find mixer list!"));
		return FALSE;
	}

	ZeroMemory(&mixerControlDetails, sizeof(MIXERCONTROLDETAILS));

	mixerControlDetails.cbStruct = sizeof(MIXERCONTROLDETAILS);
	mixerControlDetails.dwControlID = mixerControl.dwControlID;
	if (MIXERCONTROL_CONTROLF_UNIFORM & mixerControl.fdwControl)
		mixerControlDetails.cChannels = 1;
	else
		mixerControlDetails.cChannels = m_DstLine.ucChannels;

	if (MIXERCONTROL_CONTROLF_MULTIPLE & mixerControl.fdwControl)
		mixerControlDetails.cMultipleItems = (UINT)mixerControl.cMultipleItems;
	else
		mixerControlDetails.cMultipleItems = 1;

	// weirdness - you have to set cbDetails to the size of a single LISTTEXT item
	// setting it to anything larger will make the call fail
	mixerControlDetails.cbDetails = sizeof(MIXERCONTROLDETAILS_LISTTEXT);


	numItems = mixerControlDetails.cMultipleItems;
	if (m_DstLine.dwConnections > numItems)
		numItems = m_DstLine.dwConnections;

    DBG_SAVE_FILE_LINE
	aListText = new MIXERCONTROLDETAILS_LISTTEXT[numItems];

    DBG_SAVE_FILE_LINE
	aEnableList = new MIXERCONTROLDETAILS_BOOLEAN[numItems];
	if ((aListText == NULL) || (aEnableList == NULL))
	{
		WARNING_OUT(("CMixerDevice::EnableMicrophone-Out of memory"));
		return FALSE;
	}

	ZeroMemory(aListText, sizeof(MIXERCONTROLDETAILS_LISTTEXT)*numItems);
	ZeroMemory(aEnableList, sizeof(MIXERCONTROLDETAILS_BOOLEAN)*numItems);

	mixerControlDetails.paDetails = aListText;

	// preserve the settings, some values will change after this call
	mixerControlDetailsOrig = mixerControlDetails;

	// query for the text of the list
	mmr = mixerGetControlDetails((HMIXEROBJ)m_hMixer, &mixerControlDetails,
	                             MIXER_GETCONTROLDETAILSF_LISTTEXT
	                             |MIXER_OBJECTF_HMIXER);

	// some sound cards don't specify CONTROLF_MULTIPLE
	// try doing what sndvol32 does for MUX controls
	if (mmr != MMSYSERR_NOERROR)
	{
		mixerControlDetails = mixerControlDetailsOrig;
		mixerControlDetails.cChannels = 1;
		mixerControlDetails.cMultipleItems = m_DstLine.dwConnections;
		mixerControlDetailsOrig = mixerControlDetails;
		mmr = mixerGetControlDetails((HMIXEROBJ)m_hMixer, &mixerControlDetails,
		                             MIXER_GETCONTROLDETAILSF_LISTTEXT
		                             |MIXER_OBJECTF_HMIXER);
	}

	if (mmr != MMSYSERR_NOERROR)
	{
		delete [] aListText;
		delete [] aEnableList;
		return FALSE;
	}

	// enumerate for the microphone
	numMics = 0;
	fMicFound = FALSE;
	for (uIndex = 0; uIndex < mixerControlDetails.cMultipleItems; uIndex++)
	{
		// dwParam1 of the listText structure is the LineID of the source
		// dwParam2 should be the component type, but unfoturnately not
		// all sound cards obey this rule.
		ZeroMemory (&mixerLine, sizeof(MIXERLINE));
		mixerLine.cbStruct = sizeof(MIXERLINE);
		mixerLine.dwLineID = aListText[uIndex].dwParam1;

		mmr = mixerGetLineInfo ((HMIXEROBJ)m_hMixer, &mixerLine,
					MIXER_GETLINEINFOF_LINEID | MIXER_OBJECTF_HMIXER);

		if ((mmr == MMSYSERR_NOERROR) &&
		    (mixerLine.dwComponentType == m_SrcLine.dwCompType) &&
			 (numMics < MAX_MICROPHONE_DEVS))
		{
			aMicIndices[numMics] = uIndex;
			numMics++;
		}

		if (aListText[uIndex].dwParam1 == m_SrcLine.dwLineId)
		{
			uMicIndex = uIndex;
			fMicFound = TRUE;  // can't rely on uIndex or uNumMics not zero
		}
	}

	if (fMicFound == FALSE)
	{
		delete [] aListText;
		delete [] aEnableList;
		return FALSE;
	}

	// now we know which position in the array to set, let's do it.

	mixerControlDetails = mixerControlDetailsOrig;
	mixerControlDetails.paDetails = aEnableList;
	mixerControlDetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);

	// find out what's already marked as set.
	mmr = mixerGetControlDetails((HMIXEROBJ)m_hMixer, &mixerControlDetails,
	        MIXER_SETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_HMIXER);

	if ((mmr == MMSYSERR_NOERROR) && (aEnableList[uMicIndex].fValue != 1))
	{
		// how many microphone's are already enabled ?
		// if another microphone is already enabled and if the device is MUX type
		// we won't attempt to turn one on.
		numMicsSet = 0;
		for (uIndex = 0; uIndex < numMics; uIndex++)
		{
			if ((aEnableList[aMicIndices[uIndex]].fValue == 1) &&
			    (uIndex != uMicIndex))
			{
				numMicsSet++;
			}
		}


		if ( (mixerControl.dwControlType == MIXERCONTROL_CONTROLTYPE_MUX)
		   ||(mixerControl.dwControlType == MIXERCONTROL_CONTROLTYPE_SINGLESELECT))
		{
			ZeroMemory(aEnableList, sizeof(aEnableList)*numItems);
			aEnableList[uMicIndex].fValue = 1;
			if (numMicsSet == 0)
			{
				mmr = mixerSetControlDetails((HMIXEROBJ)m_hMixer, &mixerControlDetails,
			                             MIXER_SETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_HMIXER);
			}
			else
			{
				mmr = MMSYSERR_ERROR;  // a mike has already been enabled
			}
		}
		else
		{
			mixerControlDetails = mixerControlDetailsOrig;
			mixerControlDetails.paDetails = aEnableList;
			mixerControlDetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
			aEnableList[uMicIndex].fValue = 1;
			mmr = mixerSetControlDetails((HMIXEROBJ)m_hMixer, &mixerControlDetails,
		                             MIXER_GETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_HMIXER);
		}
	}

	delete []aEnableList;
	delete []aListText;

	return (mmr == MMSYSERR_NOERROR);

}


BOOL CMixerDevice::UnMuteVolume()
{
	MIXERCONTROL mixerControl;
	MIXERCONTROLDETAILS mixerControlDetails;
	MIXERCONTROLDETAILS_BOOLEAN mcdb;
	MMRESULT mmrMaster, mmrSub;

	// try to unmute the master volume
	// this could be used on both the recording and playback mixers

	mmrMaster = mixerGetControlByType(m_hMixer,
	            m_DstLine.dwLineId, MIXERCONTROL_CONTROLTYPE_MUTE,
	              &mixerControl);

	if (mmrMaster == MMSYSERR_NOERROR)
	{
		ZeroMemory(&mixerControlDetails, sizeof(MIXERCONTROLDETAILS));
		mixerControlDetails.cbStruct = sizeof(MIXERCONTROLDETAILS);
		mixerControlDetails.dwControlID = mixerControl.dwControlID;

		mixerControlDetails.cChannels = 1;
		mixerControlDetails.cMultipleItems = 0;

		mcdb.fValue = 0;
		mixerControlDetails.paDetails = &mcdb;
		mixerControlDetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);

		mmrMaster = mixerSetControlDetails((HMIXEROBJ)m_hMixer,
		            &mixerControlDetails,
		            MIXER_SETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_HMIXER);
		
	}


	// only try to unmute waveOut
    if ( (m_DstLine.dwCompType != MIXERLINE_COMPONENTTYPE_DST_SPEAKERS)
	   || (m_SrcLine.dwCompType == 0))
	{
		return (mmrMaster == MMSYSERR_NOERROR);
	}

	
	mmrSub = mixerGetControlByType(m_hMixer,
	         m_SrcLine.dwLineId, MIXERCONTROL_CONTROLTYPE_MUTE,
	         &mixerControl);

	if (mmrSub == MMSYSERR_NOERROR)
	{
		ZeroMemory(&mixerControlDetails, sizeof(MIXERCONTROLDETAILS));
		mixerControlDetails.cbStruct = sizeof(MIXERCONTROLDETAILS);
		mixerControlDetails.dwControlID = mixerControl.dwControlID;

		mixerControlDetails.cChannels = 1;
		mixerControlDetails.cMultipleItems = 0;

		mcdb.fValue = 0;
		mixerControlDetails.paDetails = &mcdb;
		mixerControlDetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);

		mmrSub =  mixerSetControlDetails((HMIXEROBJ)m_hMixer,
		          &mixerControlDetails,
		          MIXER_SETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_HMIXER);
	}


	return ((mmrSub == MMSYSERR_NOERROR) || (mmrMaster == MMSYSERR_NOERROR));

}



//////////////////////////////////////////////////
//
// The following are private APIs
//

static MMRESULT mixerGetControlValue ( HMIXER hMixer, DWORD *pdwValue,
								DWORD dwControlId, UINT ucChannels )
{
	MIXERCONTROLDETAILS mxcd;
	MMRESULT mmr;

	ZeroMemory (&mxcd, sizeof (mxcd));
	mxcd.cbStruct = sizeof (mxcd);
	mxcd.dwControlID = dwControlId;
	mxcd.cChannels = ucChannels;
	mxcd.cbDetails = sizeof (DWORD);
	mxcd.paDetails = (PVOID) pdwValue;
	mmr = mixerGetControlDetails ((HMIXEROBJ) hMixer, &mxcd,
			MIXER_GETCONTROLDETAILSF_VALUE | MIXER_OBJECTF_HMIXER);
	return mmr;
}


static MMRESULT mixerSetControlValue ( HMIXER hMixer, DWORD *pdwValue,
								DWORD dwControlId, UINT ucChannels )
{
	MIXERCONTROLDETAILS mxcd;
	MMRESULT mmr;

	ZeroMemory (&mxcd, sizeof (mxcd));
	mxcd.cbStruct = sizeof (mxcd);
	mxcd.dwControlID = dwControlId;
	mxcd.cChannels = ucChannels;
	mxcd.cbDetails = sizeof (DWORD);
	mxcd.paDetails = (PVOID) pdwValue;
	mmr = mixerSetControlDetails ((HMIXEROBJ) hMixer, &mxcd,
			MIXER_SETCONTROLDETAILSF_VALUE | MIXER_OBJECTF_HMIXER);
	return mmr;
}


static MMRESULT mixerGetControlId ( HMIXER hMixer, DWORD *pdwControlId,
							 DWORD dwLineId, DWORD dwControlType )
{
	MIXERLINECONTROLS mxlc;
	MIXERCONTROL mxc;
	MMRESULT mmr;

	ZeroMemory (&mxlc, sizeof (mxlc));
	ZeroMemory (&mxc, sizeof (mxc));
	mxlc.cbStruct = sizeof (mxlc);
	mxlc.dwLineID = dwLineId;
	mxlc.dwControlType = dwControlType;
	mxlc.cControls = 1;
	mxlc.cbmxctrl = sizeof (mxc);
	mxlc.pamxctrl = &mxc;
	mmr = mixerGetLineControls ((HMIXEROBJ) hMixer, &mxlc,
				MIXER_GETLINECONTROLSF_ONEBYTYPE | MIXER_OBJECTF_HMIXER);
	*pdwControlId = mxc.dwControlID;
	return mmr;
}


// similar to above, except returns the whole control
static MMRESULT mixerGetControlByType ( HMIXER hMixer, DWORD dwLineId, DWORD dwControlType, MIXERCONTROL *pMixerControl)
{
	MIXERLINECONTROLS mxlc;
	MMRESULT mmr;

	ZeroMemory (&mxlc, sizeof (mxlc));
	ZeroMemory (pMixerControl, sizeof (MIXERCONTROL));
	mxlc.cbStruct = sizeof (mxlc);
	mxlc.dwLineID = dwLineId;
	mxlc.dwControlType = dwControlType;
	mxlc.cControls = 1;
	mxlc.cbmxctrl = sizeof (MIXERCONTROL);
	mxlc.pamxctrl = pMixerControl;
	mmr = mixerGetLineControls ((HMIXEROBJ) hMixer, &mxlc,
				MIXER_GETLINECONTROLSF_ONEBYTYPE | MIXER_OBJECTF_HMIXER);
	
	return mmr;
}

// IUnknown stuff
ULONG __stdcall CMixerDevice::AddRef()
{
	InterlockedIncrement(&m_lRefCount);
	return m_lRefCount;
}

ULONG __stdcall CMixerDevice::Release()
{
	if (0 == InterlockedDecrement(&m_lRefCount))
	{
		delete this;
		return 0;
	}
	return m_lRefCount;
}

HRESULT __stdcall CMixerDevice::QueryInterface(const IID& iid, void **ppVoid)
{

	if ((iid == IID_IUnknown) || (iid == IID_IMixer))
	{
		*ppVoid = this;
	}
	else
	{
		*ppVoid = NULL;
		return E_NOINTERFACE;
	}
	AddRef();
	return S_OK;
	
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\plog.cpp ===
#include "precomp.h"

#ifdef PLS_DEBUG
#include "plog.h"



CCallLog::CCallLog(int size)
{
	m_bValid = false;

    DBG_SAVE_FILE_LINE
	m_pLogEntry = new CPacketLogEntry[size];
	if (m_pLogEntry == NULL)
	{
		WARNING_OUT(("CCallLog:Out of memory"));
		return;
	}

	m_currentIndex = 0;
	m_size = size;
	m_bValid = true;
}

CCallLog::~CCallLog()
{
	if (m_bValid)
	{
		delete [] m_pLogEntry;
	}
}



bool CCallLog::AddEntry(DWORD dwTimeStamp, DWORD dwSeqNum, LARGE_INTEGER LL_ArrivalTime, DWORD dwSize, bool fMark)
{
	CPacketLogEntry Entry;

	if (m_bValid == false) return false;

	Entry.dwTimeStamp = dwTimeStamp;
	Entry.dwSequenceNumber = dwSeqNum;
	Entry.LL_ArrivalTime = LL_ArrivalTime;
	Entry.dwSize = dwSize;
	Entry.dwLosses = 0;
	Entry.bLate = false;
	Entry.bMark = fMark;

	if (SizeCheck() == false)
		return false;

	m_pLogEntry[m_currentIndex++] = Entry;
	return true;

}

bool CCallLog::SizeCheck()
{
	if (m_bValid == false)
		return false;

	if (m_currentIndex < m_size)
		return true;
	return false;
}


bool CCallLog::Flush(HANDLE hFile)
{
	int index;
	CPacketLogEntry *pEntry;
	char szOutputLine[80];
	DWORD dwNumWritten;
   __int64 ArrivalTime64;
	__int64 PerfFreq64;
	LARGE_INTEGER LL_PerfFreq;
	
	if (m_bValid == false)
		return false;

	if (hFile == INVALID_HANDLE_VALUE)
		return false;

	PerformStats();

	// what's the performance frequency of this machine
	QueryPerformanceFrequency(&LL_PerfFreq);
	PerfFreq64 = LL_PerfFreq.QuadPart;

	for (index = 0; index < m_currentIndex; index++)
	{
		pEntry = &m_pLogEntry[index];

		ArrivalTime64 = pEntry->LL_ArrivalTime.QuadPart * 1000;
		ArrivalTime64 = ArrivalTime64 / PerfFreq64;

		sprintf(szOutputLine, "%d\t%d\t%d\t%d\t%d",
		        pEntry->dwTimeStamp,
		        pEntry->dwSequenceNumber,
		        (int)ArrivalTime64,
		        pEntry->dwSize,
		        pEntry->dwLosses);
		
		if (pEntry->bMark)
			strcat(szOutputLine, "\tMARK");
		else strcat(szOutputLine, "\t");

		if (pEntry->bLate)
			strcat(szOutputLine, "\tLATE");
		
		strcat(szOutputLine, "\n");

		WriteFile(hFile, szOutputLine, strlen(szOutputLine), &dwNumWritten, NULL);

	}
	return true;
}


CCallLog& CCallLog::operator=(const CCallLog& log)
{
	WARNING_OUT(("CCallLog:Assignment not supported"));
	return *this;
}

CCallLog::CCallLog(const CCallLog& log)
{
	WARNING_OUT(("CCallLog:Copy constructor not supported"));
	return;
}

bool CCallLog::PerformStats()
{
	int index, probeIndex;
	DWORD nextExpected;
	bool bFound;

	if (m_bValid == false)
		return false;

	if (m_currentIndex == 0)
		return false;

	// Set the current "loss" value for each entry to 0
	for (index = 0; index < m_currentIndex; index++)
	{
		m_pLogEntry[index].dwLosses = 0;
		m_pLogEntry[index].bLate = false;
	}

	// the first packet will always be a match with nextExpected
	nextExpected = m_pLogEntry[0].dwSequenceNumber;

	for (index = 0; index < m_currentIndex; index++)
	{
		if (nextExpected > 65535)
			nextExpected = 0;
		// if the packet has the next expected seq num, then everything is ok
		if (m_pLogEntry[index].dwSequenceNumber == nextExpected)
		{
			nextExpected++;
			continue;
		}

		// we've detected a missing packet... time to go hunting
		else if (m_pLogEntry[index].dwSequenceNumber > nextExpected)
		{
			bFound = false;
			probeIndex = index+1;
			while ((probeIndex < m_currentIndex) &&
			       (probeIndex < (index+PLOG_MAX_NOT_LATE)) )
			{
				if (m_pLogEntry[index].dwSequenceNumber == nextExpected)
					bFound = true;
				probeIndex++;
			}

			// the packet was merely out of sequence
			if (bFound == true)
			{
				nextExpected++;
				continue;
			}

			// the packet is probably lost
			// notice that we are simply incrementing dwLoss measure,
			// rolling the index back one
			m_pLogEntry[index].dwLosses++;
			nextExpected++;
			index--; // this is so we can continue to count additional
			         // loss packets for the same index
			continue; // back to the top of the for-loop
		}

		// a packet that was either previously thought of as lost or late
		else
		{
			m_pLogEntry[index].bLate = true;	
		}


	}


	return true;
}


// --------------------------------------------------------------

CPacketLog::CPacketLog(LPTSTR szDiskFile):
	m_hFile(INVALID_HANDLE_VALUE),
	m_nExtension(0)
{
	m_pCallLog = NULL;
	strcpy(m_szDiskFile, szDiskFile);
}


// initializes an output file.  Closes the current file if still open
bool CPacketLog::InitFile()
{
	char szFileName[120];

	if (m_hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
	}

	sprintf(szFileName, "%s%d%s", m_szDiskFile, m_nExtension, PLOG_FILE_EXT);
	m_hFile = CreateFile(szFileName, 
									GENERIC_READ|GENERIC_WRITE, 
									0, NULL, OPEN_EXISTING,
									FILE_ATTRIBUTE_NORMAL, NULL);

	while ((m_hFile != INVALID_HANDLE_VALUE) && (m_nExtension < 100))
	{
		CloseHandle(m_hFile);
		sprintf(szFileName, "%s%d%s", m_szDiskFile, m_nExtension, PLOG_FILE_EXT);
		m_hFile = CreateFile(szFileName, 
									GENERIC_READ|GENERIC_WRITE, 
									0, NULL, OPEN_EXISTING,
									FILE_ATTRIBUTE_NORMAL, NULL);
		m_nExtension++;
	}
			

	m_hFile = CreateFile(szFileName,
	                     GENERIC_READ|GENERIC_WRITE, 
	                     FILE_SHARE_READ,
	                     NULL,
	                     CREATE_ALWAYS,
	                     FILE_ATTRIBUTE_NORMAL,
	                     NULL);
	                     
	                     
	if (m_hFile == INVALID_HANDLE_VALUE)
	{
		WARNING_OUT(("CPacketLog:Unable to initialize output file"));
		return false;
	}

	return true;

}


CPacketLog::CPacketLog(const CPacketLog& packet_log)
{
	// it wouldn't be an error if duphandle was used correctly
	ERROR_OUT(("CPacketLog:Invalid to create a new packetLog via a copy constructor"));
	return;
}



CPacketLog& CPacketLog::operator=(const CPacketLog& packet_log)
{
	// it wouldn't be an error if duphandle was used correctly
	ERROR_OUT(("CPacketLog:Invalid to create a new packetLog via the assignment operator"));
	return *this;	
}


CPacketLog::~CPacketLog()
{
	if (m_pCallLog != NULL)
	{
		Flush();
		delete (m_pCallLog);
	}

	if (m_hFile != INVALID_HANDLE_VALUE)
		CloseHandle(m_hFile);

}


bool CPacketLog::Flush()
{
	char *szCallHeader = "CALLSTART\n";
	DWORD dwNumWritten;

	if (m_pCallLog == NULL)
		return false;

	WriteFile(m_hFile, szCallHeader, strlen(szCallHeader), &dwNumWritten, NULL);
	m_pCallLog->Flush(m_hFile);		

	return true;
}



bool CPacketLog::MarkCallStart()
{
	// write the previous call to file
	if (m_pCallLog != NULL)
	{
		Flush();
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
		delete m_pCallLog;
	}

	if (false == InitFile())
	{
		return false;
	}

    DBG_SAVE_FILE_LINE
	m_pCallLog = new CCallLog(PLOG_MAX_PACKETS_CALL);
	if (m_pCallLog == NULL)
		return false;

	return true;
}


bool CPacketLog::AddEntry(DWORD dwTimeStamp, DWORD dwSeqNum, LARGE_INTEGER LL_ArrivalTime, DWORD dwSize, bool fMark)
{
	if (m_pCallLog == NULL)
	{
		if (false == MarkCallStart())
			return false;
	}

	return (m_pCallLog->AddEntry(dwTimeStamp, dwSeqNum, LL_ArrivalTime, dwSize, fMark));

}


// if-def pls_debug
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\nac.h ===
/*
 *  	File: nac.h
 *
 *      Microsoft Network Audio Controller (NAC) header file
 *
 *		Revision History:
 *
 *		11/28/95	mikev	created
 */


#ifndef _NAC_H
#define _NAC_H
#define _NAVC_

#ifdef __cplusplus
class CConnection;
class DataPump;
class CNac;
typedef class CConnection CIPPhoneConnection;


//
//	temporary defs
//
typedef CNac **LPLPNAC;
HRESULT WINAPI CreateNac(LPLPNAC lplpNac);

#endif	// __cplusplus

// windows messages
#define WNAC_START		WM_USER+0x100
#define	WNAC_CONNECTREQ WNAC_START+0x0000
#define WCON_STATUS 	WNAC_START+0x0001

//
//	end of temporary defs
//

//
//  utility functions
//
VOID FreeTranslatedAliasList(PCC_ALIASNAMES pDoomed);
HRESULT AllocTranslatedAliasList(PCC_ALIASNAMES *ppDest, P_H323ALIASLIST pSource);

#define DEF_AP_BWMAX	14400


/*
 *	Class definitions
 */

#ifdef __cplusplus

class CNac : public INac
{
	
protected:
    PCC_ALIASNAMES m_pLocalAliases;
    
	LPWSTR	m_pUserName;
	UINT	uRef;
	HRESULT hrLast;
	UINT m_uMaximumBandwidth;
	// application data
	CNOTIFYPROC pProcNotifyConnect;	// connection notification callback
	HWND hWndNotifyConnect;	// connection notification hwnd
	HWND hAppWnd;			// hwnd of the process that owns the NAC
	HINSTANCE hAppInstance;	// instance of the process that owns the NAC

	// subcomponent object references
	LPIH323PubCap m_pCapabilityResolver;
	CConnection *m_pListenLine;	// connection object listening for incoming
	CConnection *m_pCurrentLine;	// active connection object(talking), if there is one
	CConnection *m_pLineList;	
	int m_numlines;	// # of objects in m_pLineList

	ImpICommChan 	*m_pSendAudioChannel;	
	ImpICommChan	*m_pSendVideoChannel;	
	
//  Internal interfaces	
	BOOL Init();	// internal initialization

	OBJ_CPT;		// profiling timer
	
public:
	CConnection *m_pNextToAccept;
	HWND GetAppWnd(){return hAppWnd;};
	HINSTANCE GetAppInstance() {return hAppInstance;};
	LPWSTR GetUserDisplayName() {return m_pUserName;};
    PCC_ALIASNAMES GetUserAliases() {return m_pLocalAliases;};
    PCC_ALIASITEM GetUserDisplayAlias();
	CNac();
	~CNac();
	HRESULT CreateConnection(CConnection **lplpConnection, GUID PIDofProtocolType);
	HRESULT RemoveConnection(CConnection *lpConnection);
	HRESULT LastHR() {return hrLast;};
	VOID SetLastHR(HRESULT hr) {hrLast = hr;};
	HRESULT GetConnobjArray(CConnection **lplpArray, UINT uSize);
	ICtrlCommChan *QueryPreviewChannel(LPGUID lpMID);

	STDMETHOD_( CREQ_RESPONSETYPE, ConnectionRequest(CConnection *pConnection));
	STDMETHOD_( CREQ_RESPONSETYPE, FilterConnectionRequest(CConnection *pConnection,
	    P_APP_CALL_SETUP_DATA pAppData));

// INacInterface stuff
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR * ppvObj);
	STDMETHOD_(ULONG, AddRef());
	STDMETHOD_(ULONG, Release());
	STDMETHOD( Initialize(HWND hWnd, HINSTANCE hInst, PORT *lpPort));
	STDMETHOD( SetMaxPPBandwidth(UINT Bandwidth));
	STDMETHOD( RegisterConnectionNotify(HWND hWnd, CNOTIFYPROC pConnectRequestHandler));
	STDMETHOD( DeregisterConnectionNotify(HWND hWnd, CNOTIFYPROC pConnectRequestHandler));
	STDMETHOD( GetNumConnections(ULONG *lp));
	STDMETHOD( GetConnectionArray(LPCONNECTIONIF *lplpArray, UINT uSize));
	STDMETHOD( CreateConnection(LPCONNECTIONIF *lplpLine, GUID PIDofProtocolType));
	STDMETHOD( DeleteConnection(LPCONNECTIONIF lpLine));
	STDMETHOD( SetUserDisplayName(LPWSTR lpwName));
	STDMETHODIMP CreateLocalCommChannel(ICommChannel** ppCommChan, LPGUID lpMID,
		IMediaChannel* pMediaStream);
	STDMETHODIMP SetUserAliasNames(P_H323ALIASLIST pAliases);
	STDMETHODIMP EnableGatekeeper(BOOL bEnable, PSOCKADDR_IN pGKAddr);
};

#else	// not __cplusplus


#endif	//  __cplusplus


#endif	//#ifndef _NAC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\msiacaps.cpp ===
/*
 *  	File: msiacaps.cpp
 *
 *		ACM implementation of Microsoft Network Audio capability object.
 *
 *		Revision History:
 *
 *		06/06/96	mikev	created
 */


#include "precomp.h"

//Prototypes....
ULONG ReadRegistryFormats (LPCSTR lpszKeyName,CHAR ***pppName,BYTE ***pppData,PUINT pnFormats,DWORD dwDebugSize);
void FreeRegistryFormats (PRRF_INFO pRegFmts);

static BOOL bUseDefault;


#define szRegMSIPAndH323Encodings	TEXT("ACMH323Encodings")


AUDCAP_DETAILS default_id_table[] =
{


{WAVE_FORMAT_ADPCM, NONSTD_TERMCAP, STD_CHAN_PARAMS, {RTP_DYNAMIC_MIN, 0, 8000, 4},
	0, TRUE, TRUE, 500, 32000,32000,50,0,PREF_ORDER_UNASSIGNED,0,NULL,0, NULL,
	"Microsoft ADPCM"},


	{WAVE_FORMAT_LH_CELP, NONSTD_TERMCAP, STD_CHAN_PARAMS,{RTP_DYNAMIC_MIN,  0, 8000, 16},
		0, TRUE, TRUE, 640, 5600,5600,LNH_48_CPU,0,3,0,NULL,0,NULL,
		"Lernout & Hauspie CELP 4.8kbit/s"},
	{WAVE_FORMAT_LH_SB8,  NONSTD_TERMCAP, STD_CHAN_PARAMS,{RTP_DYNAMIC_MIN,  0, 8000, 16},
		0, TRUE, TRUE, 640, 8000,8000,LNH_8_CPU,0,0,0,NULL,0,NULL,
		"Lernout & Hauspie SBC 8kbit/s"},
	{WAVE_FORMAT_LH_SB12, NONSTD_TERMCAP, STD_CHAN_PARAMS, {RTP_DYNAMIC_MIN,  0, 8000, 16},
		0, TRUE, TRUE, 640, 12000,12000,LNH_12_CPU,0,1,0,NULL,0,NULL,
		"Lernout & Hauspie SBC 12kbit/s"},
	{WAVE_FORMAT_LH_SB16, NONSTD_TERMCAP, STD_CHAN_PARAMS,{RTP_DYNAMIC_MIN,  0, 8000, 16},
		0, TRUE, TRUE, 640, 16000,16000,LNH_16_CPU,0,2,0,NULL,0,NULL,
		"Lernout & Hauspie SBC 16kbit/s"},
	{WAVE_FORMAT_MSRT24, NONSTD_TERMCAP, STD_CHAN_PARAMS,{RTP_DYNAMIC_MIN,  0, 8000, 16},
		0, TRUE, TRUE, 720, 2400,2400,MSRT24_CPU,0,4,0,NULL,0,NULL,
		"Voxware RT 2.4kbit/s"},
	{WAVE_FORMAT_MSG723,  STD_TERMCAP(H245_CLIENT_AUD_G723), 	// client type H245_CLIENT_AUD_G723,
		STD_CHAN_PARAMS, {RTP_PAYLOAD_G723,  0, 8000, 0},
		0, TRUE, TRUE, 960, 5600,5600,MS_G723_CPU,0,
		0,	// priority
		0,NULL,0,NULL, "Microsoft G.723.1"},
	{WAVE_FORMAT_ALAW,	STD_TERMCAP( H245_CLIENT_AUD_G711_ALAW64),
		STD_CHAN_PARAMS, {RTP_PAYLOAD_G711_ALAW,  0, 8000, 8},
		0, TRUE, TRUE, 500, 64000,64000,CCITT_A_CPU,0,0,
		0, NULL, 0, NULL, "CCITT A-Law"},
	{WAVE_FORMAT_MULAW,	STD_TERMCAP( H245_CLIENT_AUD_G711_ULAW64),
		STD_CHAN_PARAMS, {RTP_PAYLOAD_G711_MULAW,  0, 8000, 8},
		0, TRUE, TRUE, 500, 64000,64000,CCITT_U_CPU,0,0,
		0, NULL, 0, NULL, "CCITT u-Law"},
		
#if(0)
// do not use this version of the G.723 codec
	{WAVE_FORMAT_INTELG723,  STD_TERMCAP(H245_CLIENT_AUD_G723), 	// client type H245_CLIENT_AUD_G723,
		STD_CHAN_PARAMS, {RTP_DYNAMIC_MIN,  0, 8000, 0},
		0, TRUE, TRUE, 960, 16000,16000,99,0,
		0,	// priority
		0,NULL,0,NULL, "G.723"},
		
	{WAVE_FORMAT_DSPGROUP_TRUESPEECH, {
		NONSTD_TERMCAP, {RTP_DYNAMIC_MIN,  0, 5510, 4},
		0, TRUE, TRUE, 500, 5510,5510,50,0,0,0,NULL},
		"DSP Group TrueSpeech(TM)"},
    {WAVE_FORMAT_PCM, {{RTP_DYNAMIC_MIN,  0, 8000, 8}, TRUE, TRUE, 160, 64000,64000,50,0,0,0,NULL,0,NULL}, "MS-ADPCM"},
	{WAVE_FORMAT_PCM, {{RTP_DYNAMIC_MIN,  0, 5510, 8}, TRUE, TRUE, 160, 44080,44080,50,0,0,0,NULL,0,NULL}, "MS-ADPCM"},
	{WAVE_FORMAT_PCM, {{RTP_DYNAMIC_MIN,  0, 11025, 8}, TRUE, TRUE, 160, 88200,88200,50,0,0,0,NULL,0,NULL},"MS-ADPCM"},
	{WAVE_FORMAT_PCM, {{RTP_DYNAMIC_MIN,  0, 8000, 16}, TRUE, TRUE, 160, 128000,128000,50,0,0,0,NULL,0,NULL},"MS-ADPCM"},
	{WAVE_FORMAT_ADPCM, {{RTP_DYNAMIC_MIN,  0, 8000, 4}, TRUE, TRUE, 500, 16000,16000,50,0,,0,0,NULL,0,NULL}, "MS-ADPCM"},
	{WAVE_FORMAT_GSM610, 	 STD_CHAN_PARAMS,{RTP_DYNAMIC_MIN,  0, 8000, 0},
		0, TRUE, TRUE, 320, 8000,8000,96,0,PREF_ORDER_UNASSIGNED,0,NULL,0,NULL,
		//"Microsoft GSM 6.10"
		"GSM 6.10"},
#endif	// DEF_USE_ALLPCM	


};


UINT uDefTableEntries = sizeof(default_id_table) /sizeof(AUDCAP_DETAILS);
static BOOL bCreateDefTable = FALSE;


//
//	static members of CMsiaCapability
//

MEDIA_FORMAT_ID CMsiaCapability::IDsByRank[MAX_CAPS_PRESORT];
UINT CMsiaCapability::uNumLocalFormats = 0;			// # of active entries in pLocalFormats
UINT CMsiaCapability::uStaticRef = 0;					// global ref count
UINT CMsiaCapability::uCapIDBase = 0;					// rebase capability ID to index into IDsByRank
UINT CMsiaCapability::uLocalFormatCapacity = 0;		// size of pLocalFormats (in multiples of AUDCAP_DETAILS)
AUDCAP_DETAILS * CMsiaCapability::pLocalFormats = NULL;	

CMsiaCapability::CMsiaCapability()
:uRef(1),
wMaxCPU(95),
m_uPacketDuration(90),
uNumRemoteDecodeFormats(0),
uRemoteDecodeFormatCapacity(0),
pRemoteDecodeFormats(NULL),
bPublicizeTXCaps(FALSE),
bPublicizeTSTradeoff(FALSE),
pRegFmts(NULL)

{
	m_IAppCap.Init(this);
}

CMsiaCapability::~CMsiaCapability()
{
	CloseACMDriver();
	UINT u;
	AUDCAP_DETAILS *pDetails;
	// release global static memory (the local capabilities) if this is the last delete
	if(uStaticRef <= 1)
	{
		if (pLocalFormats)
		{	
			pDetails = pLocalFormats;
			for(u=0; u <uNumLocalFormats; u++)
			{
				if(pDetails->lpLocalFormatDetails)
				{
					MEMFREE(pDetails->lpLocalFormatDetails);
				}
				// there really should never be remote details associated with the local
				// formats........
				if(pDetails->lpRemoteFormatDetails)
				{
					MEMFREE(pDetails->lpRemoteFormatDetails);
				}
				
				pDetails++;
			}
			MEMFREE(pLocalFormats);
			pLocalFormats=NULL;
			uLocalFormatCapacity = 0;
		}
		uStaticRef--;

        //Clean up the format cache. - This was the audio format information that
        //Was in the registry. A list of names, ptrs to AUDCAP_DETAILS blocks
        //and a count of formats. Memory is allocated in ReadRegistryFormats,
        //called from ReInit()

	}
	else
	{
		uStaticRef--;
	}
	
	if (pRemoteDecodeFormats)
	{	
		pDetails = pRemoteDecodeFormats;
		for(u=0; u <uNumRemoteDecodeFormats; u++)
		{
			if(pDetails->lpLocalFormatDetails)
			{
				MEMFREE(pDetails->lpLocalFormatDetails);
			}
			// there really should never be remote details associated with the local
			// formats........
			if(pDetails->lpRemoteFormatDetails)
			{
				MEMFREE(pDetails->lpRemoteFormatDetails);
			}
			
			pDetails++;
		}
		MEMFREE(pRemoteDecodeFormats);
		pRemoteDecodeFormats=NULL;
		uRemoteDecodeFormatCapacity  = 0;
	}

	FreeRegistryFormats(pRegFmts);
}

BOOL CMsiaCapability::Init()
{
	BOOL bRet;
	if(uStaticRef == 0)
	{
		if(bRet = ReInit())
		{
			uStaticRef++;
		}
	}
	else
	{
		uStaticRef++;
		bRet = TRUE;
	}
	return bRet;
}


BOOL CMsiaCapability::ReInit()
{
	SYSTEM_INFO si;
	DWORD dwDisposition;
	BOOL bRet = TRUE;
	ACM_APP_PARAM sAppParam={this, NULL, ACMAPP_FORMATENUMHANDLER_ENUM, NULL, NULL, 0, NULL};
	ACMFORMATTAGDETAILS aftd;
	AUDCAP_DETAILS audcapDetails;
	UINT i;

	ZeroMemory(&IDsByRank, sizeof(IDsByRank));

	// LOOKLOOK - this supports a hack to disable CPU intensive codecs if not running on a pentium
	GetSystemInfo(&si);
#ifdef _M_IX86
	wMaxCPU = (si.dwProcessorType == PROCESSOR_INTEL_PENTIUM )? 100 : 50;
#endif
#ifdef _ALPHA_
	wMaxCPU = 100;
#endif
	if (pLocalFormats)
	{	
		UINT u;
		AUDCAP_DETAILS *pDetails = pLocalFormats;
		for(u=0; u <uNumLocalFormats; u++)
		{
			if(pDetails->lpLocalFormatDetails)
			{
				MEMFREE(pDetails->lpLocalFormatDetails);
			}
			// there really should never be remote details associated with the local
			// formats........
			if(pDetails->lpRemoteFormatDetails)
			{
				MEMFREE(pDetails->lpRemoteFormatDetails);
			}
			
			pDetails++;
		}
		MEMFREE(pLocalFormats);
		pLocalFormats = NULL;
		uLocalFormatCapacity = 0;
	}

	uNumLocalFormats = 0;
	uCapIDBase=0;				

    /*
	 *	Format cache
	 */


    if (!pRegFmts) {	
        if (!(pRegFmts=(PRRF_INFO)MemAlloc (sizeof (RRF_INFO)))) {
            bRet = FALSE;
            goto RELEASE_AND_EXIT;
        }

   		bUseDefault=FALSE;

        if (ReadRegistryFormats (szRegInternetPhone TEXT("\\") szRegMSIPAndH323Encodings,
				&pRegFmts->pNames,(BYTE ***)&pRegFmts->pData,&pRegFmts->nFormats,sizeof (AUDCAP_DETAILS)) != ERROR_SUCCESS) {
    		bUseDefault=TRUE;
    		MemFree ((void *) pRegFmts);
    		pRegFmts=NULL;
        }
    }

	// pass the registry formats through ACM to the handler
    sAppParam.pRegCache=pRegFmts;

	if(!DriverEnum((DWORD_PTR) &sAppParam))
	{
		bRet = FALSE;
		goto RELEASE_AND_EXIT;
	}
				
 	SortEncodeCaps(SortByAppPref);
RELEASE_AND_EXIT:
	return bRet;
}


STDMETHODIMP CMsiaCapability::QueryInterface( REFIID iid,	void ** ppvObject)
{
	// this breaks the rules for the official COM QueryInterface because
	// the interfaces that are queried for are not necessarily real COM
	// interfaces.  The reflexive property of QueryInterface would be broken in
	// that case.

	HRESULT hr = E_NOINTERFACE;
	if(!ppvObject)
		return hr;
		
	*ppvObject = 0;
	if(iid == IID_IAppAudioCap )
	{
		*ppvObject = (LPAPPCAPPIF)&m_IAppCap;
		AddRef();
		hr = hrSuccess;
	}
	else if(iid == IID_IH323MediaCap)
	{
		*ppvObject = (IH323MediaCap *)this;
		AddRef();
		hr = hrSuccess;
	}
	else if (iid == IID_IUnknown)
	{
		*ppvObject = this;
		AddRef();
		hr = hrSuccess;
	}
	
	return hr;
}


ULONG CMsiaCapability::AddRef()
{
	uRef++;
	return uRef;
}

ULONG CMsiaCapability::Release()
{
	uRef--;
	if(uRef == 0)
	{
		delete this;
		return 0;
	}
	return uRef;
}
VOID CMsiaCapability::FreeRegistryKeyName(LPTSTR lpszKeyName)
{
	if (lpszKeyName)
    {
		LocalFree(lpszKeyName);
    }
}

LPTSTR CMsiaCapability::AllocRegistryKeyName(LPTSTR lpDriverName,
		UINT uSampleRate, UINT uBitsPerSample, UINT uBytesPerSec)
{
	FX_ENTRY(("MsiaCapability::AllocRegistryKeyName"));
	BOOL bRet = FALSE;
	LPTSTR lpszKeyName = NULL;

	if(!lpDriverName)
	{
		return NULL;
	}	
	// build a subkey name (drivername_samplerate_bitspersample)
	// allow room for THREE underscore chars + 2x17 bytes of string returned
	// from _itoa

	// NOTE: use wsprintf instead of itoa - because of dependency on runtime lib
	lpszKeyName = (LPTSTR)LocalAlloc (LPTR, lstrlen(lpDriverName) * sizeof(*lpDriverName)+3*20);
	if (!lpszKeyName)
	{
		ERRORMESSAGE(("%s: LocalAlloc failed\r\n",_fx_));
        return(NULL);
    }
    // build a subkey name ("drivername_samplerate_bitspersample")
	wsprintf(lpszKeyName,
				"%s_%u_%u_%u",
				lpDriverName,
				uSampleRate,
				uBitsPerSample,
				uBytesPerSec);

	return (lpszKeyName);
}


VOID CMsiaCapability::SortEncodeCaps(SortMode sortmode)
{
	UINT iSorted=0;
	UINT iInsert = 0;
	UINT iCache=0;
	UINT iTemp =0;
	BOOL bInsert;	
	AUDCAP_DETAILS *pDetails1, *pDetails2;
	
	if(!uNumLocalFormats)
		return;
	if(uNumLocalFormats ==1)
	{
		IDsByRank[0]=0;
		return;
	}
	
	// look at every cached format, build index array
	for(iCache=0;iCache<uNumLocalFormats;iCache++)
	{
		pDetails1 = pLocalFormats+iCache;
		for(iInsert=0;iInsert < iSorted; iInsert++)
		{
			pDetails2 = pLocalFormats+IDsByRank[iInsert];
			// if existing stuff is less than new stuff....
			
			bInsert = FALSE;
			switch(sortmode)
			{
				case SortByAppPref:
					if(pDetails2->wApplicationPrefOrder > pDetails1->wApplicationPrefOrder)
						bInsert = TRUE;
				break;
				default:
				break;
			}
			
			if(bInsert)
			{
				if(iSorted < MAX_CAPS_PRESORT)
				{
					iSorted++;
				}
				// make room, if there is something in the last element,
				// it gets overwritten
				for(iTemp = iSorted-1; iTemp > iInsert; iTemp--)
				{
					IDsByRank[iTemp] = IDsByRank[iTemp-1];
				}
				// insert at iInsert
				IDsByRank[iInsert] = iCache;
				break;
			}
		}
		// check end boundary
		if((iInsert == iSorted) && (iInsert < MAX_CAPS_PRESORT))
		{
			IDsByRank[iInsert] = iCache;
			iSorted++;
		}
	}
}



STDMETHODIMP CMsiaCapability::GetDecodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize)
{
	// validate input
	UINT uIndex = 	IDToIndex(FormatID);
	if(uIndex >= (UINT)uNumLocalFormats)
	{
		*puSize = 0;
		*ppFormat = NULL;
		return E_INVALIDARG;
	}

	*ppFormat = (pLocalFormats + uIndex)->lpLocalFormatDetails;
	*puSize = SIZEOF_WAVEFORMATEX((WAVEFORMATEX*)(*ppFormat));
	return S_OK;

}

STDMETHODIMP CMsiaCapability::GetEncodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize)
{
	// same as GetDecodeFormatDetails
	return GetDecodeFormatDetails(FormatID, ppFormat, puSize);
}

VOID CMsiaCapability::CalculateFormatProperties(AUDCAP_DETAILS *pFmtBuf,LPWAVEFORMATEX lpwfx)
{
	WORD wFrames;
	if(!pFmtBuf)
	{
		return;
	}
	
	// use actual bits per sample unless the bps field is zero, in which case
	// assume 16 bits (worst case).  This is a typical GSM scenario
	UINT uBitrateIn = (pFmtBuf->audio_params.uSamplesPerSec) *
		((pFmtBuf->audio_params.uBitsPerSample)
		? pFmtBuf->audio_params.uBitsPerSample
		:16);

	// set the maximum bitrate (uMaxBitrate). we're not setting the average bitrate (uAvgBitrate),
	// since the nAvgBytesPerSec reported by ACM is really worst case. uAvgBitrate will be set
	// from the hardcoded numbers for our known codecs and from the provided AUDCAP_INFO for
	// installable codecs
	pFmtBuf->uMaxBitrate = (lpwfx->nAvgBytesPerSec)? lpwfx->nAvgBytesPerSec*8:uBitrateIn;

	pFmtBuf->dwDefaultSamples = MinSampleSize(lpwfx);
	
	// nonstandard channel parameters.  This
	// might be a good point to calculate values that don't have valid defaults set.
	wFrames = pFmtBuf->nonstd_params.wFramesPerPktMax;
	if(!pFmtBuf->nonstd_params.wFramesPerPktMax)	
	{
		pFmtBuf->nonstd_params.wFramesPerPktMax=
			wFrames = LOWORD(MaxFramesPerPacket(lpwfx));
	}
	// if the preferred frames/packet is 0 or greater than the max, set it to min
	if((pFmtBuf->nonstd_params.wFramesPerPkt ==0) ||
		(pFmtBuf->nonstd_params.wFramesPerPkt > wFrames))
	{
		pFmtBuf->nonstd_params.wFramesPerPkt =
			LOWORD(MinFramesPerPacket(lpwfx));
	}
	// if the min is more than preferred, fix it
	if(pFmtBuf->nonstd_params.wFramesPerPktMin > pFmtBuf->nonstd_params.wFramesPerPkt)
	{
		pFmtBuf->nonstd_params.wFramesPerPktMin =
			LOWORD(MinFramesPerPacket(lpwfx));
	}

	pFmtBuf->nonstd_params.wDataRate =0;  // default
	pFmtBuf->nonstd_params.wFrameSize = (pFmtBuf->nonstd_params.wFramesPerPkt)
			? LOWORD(pFmtBuf->dwDefaultSamples / pFmtBuf->nonstd_params.wFramesPerPkt): 0;
	pFmtBuf->nonstd_params.UsePostFilter = 0;
	pFmtBuf->nonstd_params.UseSilenceDet = 0;

}


AUDIO_FORMAT_ID CMsiaCapability::AddFormat(AUDCAP_DETAILS *pFmtBuf,LPVOID lpvMappingData, UINT uSize)
{
	FX_ENTRY(("CMsiaCapability::AddFormat"));
	AUDCAP_DETAILS *pTemp;
	WORD wFrames;
	UINT uSamples;
	if(!pFmtBuf || !lpvMappingData || !uSize)
	{
		return INVALID_AUDIO_FORMAT;
	}
	// check room
	if(uLocalFormatCapacity <= uNumLocalFormats)
	{
		// get more mem, realloc memory by CAP_CHUNK_SIZE for pLocalFormats
		pTemp = (AUDCAP_DETAILS *)MEMALLOC((uNumLocalFormats + CAP_CHUNK_SIZE)*sizeof(AUDCAP_DETAILS));
		if(!pTemp)
			goto ERROR_EXIT;
		// remember how much capacity we now have
		uLocalFormatCapacity = uNumLocalFormats + CAP_CHUNK_SIZE;
		#ifdef DEBUG
		if((uNumLocalFormats && !pLocalFormats) || (!uNumLocalFormats && pLocalFormats))
		{
			ERRORMESSAGE(("%s:leak! uNumLocalFormats:0x%08lX, pLocalFormats:0x%08lX\r\n",
				_fx_, uNumLocalFormats,pLocalFormats));
		}
		#endif
		// copy old stuff, discard old mem
		if(uNumLocalFormats && pLocalFormats)
		{
			memcpy(pTemp, pLocalFormats, uNumLocalFormats*sizeof(AUDCAP_DETAILS));
			MEMFREE(pLocalFormats);
		}
		pLocalFormats = pTemp;
	}
	// pTemp is where the stuff is cached
	pTemp = pLocalFormats+uNumLocalFormats;
	memcpy(pTemp, pFmtBuf, sizeof(AUDCAP_DETAILS));	
	
	pTemp->uLocalDetailsSize = 0;	// clear this now
	//if(uSize && lpvMappingData)
	//{
		pTemp->lpLocalFormatDetails = MEMALLOC(uSize);
		if(pTemp->lpLocalFormatDetails)
		{
			memcpy(pTemp->lpLocalFormatDetails, lpvMappingData, uSize);
			pTemp->uLocalDetailsSize = uSize;
		}
		#ifdef DEBUG
			else
			{
				ERRORMESSAGE(("%s:allocation failed!\r\n",_fx_));
			}
		#endif
	//}
	//else
	//{
	//}

	// in all cases, fixup channel parameters.

	pTemp->dwDefaultSamples = uSamples =pTemp->dwDefaultSamples;
	
	wFrames = pTemp->nonstd_params.wFramesPerPktMax;
	if(!pTemp->nonstd_params.wFramesPerPktMax)	
	{
		pTemp->nonstd_params.wFramesPerPktMax=
			wFrames = LOWORD(MaxFramesPerPacket((LPWAVEFORMATEX)lpvMappingData));
	}
	// if the preferred frames/packet is 0 or greater than the max, set it to min
	if((pTemp->nonstd_params.wFramesPerPkt ==0) ||
		(pTemp->nonstd_params.wFramesPerPkt > wFrames))
	{
		pTemp->nonstd_params.wFramesPerPkt =
			LOWORD(MinFramesPerPacket((LPWAVEFORMATEX)lpvMappingData));
	}
	// if the min is more than preferred, fix it
	if(pTemp->nonstd_params.wFramesPerPktMin > pTemp->nonstd_params.wFramesPerPkt)
	{
		pTemp->nonstd_params.wFramesPerPktMin =
			LOWORD(MinFramesPerPacket((LPWAVEFORMATEX)lpvMappingData));
	}
	pTemp->nonstd_params.wDataRate =0;  // default
	pTemp->nonstd_params.wFrameSize = (pTemp->nonstd_params.wFramesPerPkt)
			?uSamples / pTemp->nonstd_params.wFramesPerPkt: 0;
    if(pTemp->nonstd_params.wFrameSizeMax < pTemp->nonstd_params.wFrameSize)
        pTemp->nonstd_params.wFrameSizeMax = pTemp->nonstd_params.wFrameSize;

	pTemp->nonstd_params.UsePostFilter = 0;
	pTemp->nonstd_params.UseSilenceDet = 0;


	// fixup the H245 parameters.  Use the REBASED index of the cap entry as the cap ID
	pTemp->H245TermCap.CapId = (USHORT)IndexToId(uNumLocalFormats);

	if(pTemp->H245TermCap.ClientType ==0
				|| pTemp->H245TermCap.ClientType ==H245_CLIENT_AUD_NONSTD)
	{
		LPWAVEFORMATEX lpwfx;
		lpwfx = (LPWAVEFORMATEX)pTemp->lpLocalFormatDetails;
		if(lpwfx)
		{	
			pTemp->H245TermCap.ClientType = H245_CLIENT_AUD_NONSTD;

			// all nonstandard identifier fields are unsigned short
			// two possibilities for choice are "h221NonStandard_chosen" and "object_chosen"
			pTemp->H245TermCap.H245Aud_NONSTD.nonStandardIdentifier.choice = h221NonStandard_chosen;
		
			pTemp->H245TermCap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35CountryCode = USA_H221_COUNTRY_CODE;
			pTemp->H245TermCap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.t35Extension = USA_H221_COUNTRY_EXTENSION;
			pTemp->H245TermCap.H245Aud_NONSTD.nonStandardIdentifier.u.h221NonStandard.manufacturerCode = MICROSOFT_H_221_MFG_CODE;

			// Set the nonstandard data fields to null for now. The nonstandard cap data will be
			// created when capabilities are serialized.
			// set size of buffer
			pTemp->H245TermCap.H245Aud_NONSTD.data.length = 0;
			pTemp->H245TermCap.H245Aud_NONSTD.data.value = NULL;
		}
	}
	else
	{
		// the following should already have been set in *pFmtBuf by the calling function
		// and it should have already been copied to *pTemp
		
		//pTemp->ClientType = (H245_CLIENT_T)pDecodeDetails->H245Cap.ClientType;
		//pTemp->DataType = H245_DATA_AUDIO;
		//pTemp->Dir = H245_CAPDIR_LCLTX;  // should this be H245_CAPDIR_LCLRX for receive caps?
		
		// issue:special case G723 params ???
		if(pTemp->H245TermCap.ClientType == H245_CLIENT_AUD_G723) 	
		{
			pTemp->H245TermCap.H245Aud_G723.maxAl_sduAudioFrames = 4;
// mikev 9/10/96 - we may NOT want to advertise silence suppression capability of
// the codec because our silence detection scheme works out-of-band for any codec
// 9/29/96 - this gets overwritten in SerializeH323DecodeFormats() anyway
			pTemp->H245TermCap.H245Aud_G723.silenceSuppression = 0;
		}
		
		// check for pre-existing capability with the same standard ID.
		pTemp->dwPublicRefIndex = 0;	// forget old association, assume that there
										// is no pre-existing capability with the same
										//standard ID.
		UINT i;
		AUDCAP_DETAILS *pFmtExisting = pLocalFormats;
		BOOL bRefFound = FALSE; // this var needed only to support backward
								// compatibility with Netmeeting 2.0 Beta 1
		if(uNumLocalFormats && pLocalFormats)
		{
			for(i=0; i<uNumLocalFormats; i++)
			{
				pFmtExisting = pLocalFormats + i;
				// see if it is the same defined codepoint
				if(pFmtExisting->H245TermCap.ClientType == pTemp->H245TermCap.ClientType)
				{
					// mark this capability entry as being publically advertised
					// by the existing entry.  If the existing entry also refs
					// another, follow the reference
					pTemp->dwPublicRefIndex = (pFmtExisting->dwPublicRefIndex)?
						pFmtExisting->dwPublicRefIndex : i;
					bRefFound = TRUE;
					break;
				}
			}
		}

	}		

	uNumLocalFormats++;
	
	// return the capability ID.
	//return (uNumLocalFormats-1);
	return pTemp->H245TermCap.CapId;
	
	ERROR_EXIT:
	return INVALID_AUDIO_FORMAT;
			
}

UINT CMsiaCapability::GetNumCaps(BOOL bRXCaps)
{
	UINT u, uOut=0;
	
	AUDCAP_DETAILS *pDecodeDetails = pLocalFormats;
	if(bRXCaps)
	{
		for(u=0; u <uNumLocalFormats; u++)
		{
			if(pDecodeDetails->bRecvEnabled)
				uOut++;
			
			pDecodeDetails++;
		}
		return uOut;
	}
	else
		return uNumLocalFormats;
}

VOID CMsiaCapability::FlushRemoteCaps()
{
	if(pRemoteDecodeFormats)
	{
		MEMFREE(pRemoteDecodeFormats);
		pRemoteDecodeFormats = NULL;
		uNumRemoteDecodeFormats = 0;
		uRemoteDecodeFormatCapacity = 0;
	}
}
HRESULT CMsiaCapability::GetNumFormats(UINT *puNumFmtOut)
{
	*puNumFmtOut = uNumLocalFormats;
	return hrSuccess;
}


/***************************************************************************

    Name      : CMsiaCapability::FormatEnumHandler

    Purpose   : Enumerate ACM formats coming from ACM, and see if they
					are ones that we use.

    Parameters:	Standard ACM EnumFormatCallback parameters

    Returns   : BOOL

    Comment   :

***************************************************************************/
BOOL CMsiaCapability::FormatEnumHandler(HACMDRIVERID hadid,
    LPACMFORMATDETAILS pafd, DWORD_PTR dwInstance, DWORD fdwSupport)
{
	PACM_APP_PARAM pAppParam = (PACM_APP_PARAM) dwInstance;
	LPACMFORMATTAGDETAILS paftd = pAppParam->paftd;
	AUDCAP_DETAILS audcap_entry;

	// look at the passed in dwInstance. this will tell us which format handler
	// to call
	if ((pAppParam->dwFlags && ACMAPP_FORMATENUMHANDLER_MASK) == ACMAPP_FORMATENUMHANDLER_ADD)
	{
		// this one was called for add format purposes
		return AddFormatEnumHandler(hadid, pafd, dwInstance, fdwSupport);
	}

	// evaluate the details
	if(pafd->pwfx->nChannels ==1)
	{
		if(IsFormatSpecified(pafd->pwfx, pafd, paftd, &audcap_entry))
		{
			DEBUGMSG(ZONE_ACM,("FormatEnumHandler: tag 0x%04X, nChannels %d\r\n",
				pafd->pwfx->wFormatTag, pafd->pwfx->nChannels));
			DEBUGMSG(ZONE_ACM,("FormatEnumHandler: nSamplesPerSec 0x%08lX, nAvgBytesPerSec 0x%08lX,\r\n",
				pafd->pwfx->nSamplesPerSec, pafd->pwfx->nAvgBytesPerSec));
			DEBUGMSG(ZONE_ACM,("FormatEnumHandler: nBlockAlign 0x%04X, wBitsPerSample 0x%04X, cbSize 0x%04X\r\n",
				pafd->pwfx->nBlockAlign, pafd->pwfx->wBitsPerSample, pafd->pwfx->cbSize));
			DEBUGMSG(ZONE_ACM,("FormatEnumHandler: szFormat %s,\r\n",
				 pafd->szFormat));

		//	done inside IsFormatSpecified and/or whatever it calls
		//  CalculateFormatProperties(&audcap_details, pafd->pwfx);
			AddFormat(&audcap_entry, (LPVOID)pafd->pwfx,
				(pafd->pwfx) ? (sizeof(WAVEFORMATEX)+pafd->pwfx->cbSize):0);	
				
		}
		//#define BUILD_TEST_ENTRIES
#ifdef BUILD_TEST_ENTRIES
		else
		{
			AUDCAP_INFO sAudCapInfo;

			if(paftd)
			{		
				if((lstrcmp(paftd->szFormatTag, "G.723" ) ==0)
				/*	||  (lstrcmp(paftd->szFormatTag, "MSN Audio" ) ==0) */
					||  (lstrcmp(paftd->szFormatTag, "GSM 6.10" ) ==0))
				{
					lstrcpyn(audcap_entry.szFormat, paftd->szFormatTag,
						sizeof(audcap_entry.szFormat));
					int iLen = lstrlen(audcap_entry.szFormat);
					if(iLen < (sizeof(audcap_entry.szFormat) + 8*sizeof(TCHAR)))
					{
						// ok to concatenate
						lstrcat(audcap_entry.szFormat,", ");
						// must check for truncation. so do the final concatenation via lstrcpyn
						// lstrcat(audcap_entry.szFormat, pafd->szFormat);
						iLen = lstrlen(audcap_entry.szFormat);
						lstrcpyn(&audcap_entry.szFormat[iLen], pafd->szFormat,
							sizeof(audcap_entry.szFormat) - iLen - sizeof(TCHAR));
					}
					lstrcpyn(sAudCapInfo.szFormat, audcap_entry.szFormat,
								sizeof(sAudCapInfo.szFormat); 		
					AddACMFormat (pafd->pwfx, &sAudCapInfo);						
				}
			}
		}
#endif	// BUILD_TEST_ENTRIES
	}

	return TRUE;

}


/***************************************************************************

    Name      : CMsiaCapability::BuildFormatName

    Purpose   : Builds a format name for a format, from the format name and
				the tag name

    Parameters:	pAudcapDetails [out] - pointer to an AUDCAP_DETAILS structure, where the
					created value name will be stored
				pszFormatTagName [in] - pointer to the name of the format tag
				pszFormatName [in] - pointer to the name of the format

    Returns   : BOOL

    Comment   :

***************************************************************************/
BOOL CMsiaCapability::BuildFormatName(	AUDCAP_DETAILS *pAudcapDetails,
													char *pszFormatTagName,
													char *pszFormatName)
{
	BOOL bRet = TRUE;
	int iLen=0;

	if (!pAudcapDetails ||
		!pszFormatTagName	||
		!pszFormatName)
	{
		bRet = FALSE;
		goto out;
	}

	// concatenate ACM strings to form the first part of the registry key - the
	// format is szFormatTag (actually pAudcapDetails->szFormat)
	// (the string  which describes the format tag followed by szFormatDetails
	// (the string which describes parameters, e.g. sample rate)

	lstrcpyn(pAudcapDetails->szFormat, pszFormatTagName, sizeof(pAudcapDetails->szFormat));
	iLen = lstrlen(pAudcapDetails->szFormat);
	// if the format tag description string takes up all the space, don't
	// bother with the format details (need space for ", " also).
	// we're going to say that if we don't have room for 4 characters
	// of the format details string + " ,", then it's not worth it if the
	// point is generating a unique string -if it is not unique by now, it
	// will be because some ACM driver writer was  misinformed
	if(iLen < (sizeof(pAudcapDetails->szFormat) + 8*sizeof(TCHAR)))
	{
		// ok to concatenate
		lstrcat(pAudcapDetails->szFormat,", ");
		// must check for truncation. so do the final concatenation via lstrcpyn
		// lstrcat(pFormatPrefsBuf->szFormat, pafd->szFormat);
		iLen = lstrlen(pAudcapDetails->szFormat);
		lstrcpyn(pAudcapDetails->szFormat+iLen, pszFormatName,
					sizeof(pAudcapDetails->szFormat) - iLen - sizeof(TCHAR));
	}		

out:
	return bRet;
}

// Free a a structure of registry formats info (PRRF_INFO), including memory pointed
// from this structure
void FreeRegistryFormats (PRRF_INFO pRegFmts)
{
	UINT u;

    if (pRegFmts) {
        for (u=0;u<pRegFmts->nFormats;u++) {
            MemFree ((void *) pRegFmts->pNames[u]);
            MemFree ((void *) pRegFmts->pData[u]);
        }
        MemFree ((void *) pRegFmts->pNames);
        MemFree ((void *) pRegFmts->pData);
        MemFree ((void *) pRegFmts);

    }
}

ULONG ReadRegistryFormats (LPCSTR lpszKeyName,CHAR ***pppName,BYTE ***pppData,PUINT pnFormats,DWORD dwDebugSize)
{

    HKEY hKeyParent;
    DWORD nSubKey,nMaxSubLen,nValues=0,nValNamelen,nValDatalen,nValTemp,nDataTemp,i;
    ULONG hRes;

    //Not neccessary but makes life easier
    CHAR **pNames=NULL;
    BYTE **pData=NULL;

    *pnFormats=0;


    //Get the top level node.
    hRes=RegOpenKeyEx (HKEY_LOCAL_MACHINE,lpszKeyName,0,KEY_READ,&hKeyParent);

    if (hRes != ERROR_SUCCESS)
    {
        return hRes;
    }

    //Get some info about this key
    hRes=RegQueryInfoKey (hKeyParent,NULL,NULL,NULL,&nSubKey,&nMaxSubLen,NULL,&nValues,&nValNamelen,&nValDatalen,NULL,NULL);

    if (hRes != ERROR_SUCCESS)
    {
        goto Error_Out;
    }


    if (nValDatalen != dwDebugSize) {
        DEBUGMSG (ZONE_ACM,("Largest Data Value not expected size!\r\n"));
        hRes=ERROR_INVALID_DATA;
        goto Error_Out;
    }

    //Allocate some memory for the various pointers.
    if (!(pNames=(char **) MemAlloc (sizeof(char *)*nValues))) {
        hRes=ERROR_OUTOFMEMORY;
        goto Error_Out;
    }
    ZeroMemory (pNames,sizeof (char *)*nValues);

    if (!(pData = (BYTE **) MemAlloc (sizeof(BYTE *)*nValues))) {
        hRes=ERROR_OUTOFMEMORY;
        goto Error_Out;
    }
    ZeroMemory (pData,sizeof (BYTE *)*nValues);


    //Walk the value list.
    for (i=0;i<nValues;i++)
    {
        //Yes, we're wasting memory here, oh well it's not a lot.
        //probably 40 bytes. We free it later
        if (!(pNames[i] = (char *)MemAlloc (nValNamelen))) {
            hRes=ERROR_OUTOFMEMORY;
            goto Error_Out;
        }

        if (!(pData[i] = (BYTE *)MemAlloc (nValDatalen))) {
            hRes=ERROR_OUTOFMEMORY;
            goto Error_Out;
        }

        //This needs to be able to be smashed, but is an in/out param.
        nValTemp=nValNamelen;
        nDataTemp=nValDatalen;

        hRes=RegEnumValue (hKeyParent,i,(pNames[i]),&nValTemp,NULL,NULL,(pData[i]),&nDataTemp);

#ifdef DEBUG
        if (nDataTemp != dwDebugSize) {
            DEBUGMSG (ZONE_ACM, ("ReadRegistryFormats: Data block not expected size!\r\n"));
            //Return?
        }
#endif

    }

    //Fill in the output.
    *pnFormats=nValues;
    *pppName=pNames;
    *pppData=pData;

    RegCloseKey (hKeyParent);

    return (ERROR_SUCCESS);

Error_Out:
        RegCloseKey (hKeyParent);
        //Free any allocations
        if(pNames)
        {
        	for (i=0;i<nValues;i++)
        	{
            	if (pNames[i])
            	{
                	MemFree (pNames[i]);
            	}
        	}
            MemFree (pNames);
        }

        if (pData)
        {
           	for (i=0;i<nValues;i++)
           	{
           		if (pData[i])
           		{
                	MemFree (pData[i]);
                }
           	}
        	
            MemFree (pData);
        }
        return hRes;
}


BOOL CMsiaCapability::IsFormatSpecified(LPWAVEFORMATEX lpwfx,  LPACMFORMATDETAILS pafd,
	LPACMFORMATTAGDETAILS paftd, AUDCAP_DETAILS *pAudcapDetails)
{
	AUDCAP_DETAILS cap_entry;
	BOOL bRet = FALSE;
	LPTSTR lpszValueName = NULL;
	DWORD dwRes;
	UINT i;


	if(!lpwfx || !pAudcapDetails)
	{
		return FALSE;
	}


    if (!bUseDefault) {
        for (i=0;i<pRegFmts->nFormats;i++) {
            // do a quick sanity check on the contents
            if ( (lpwfx->wFormatTag == ((AUDCAP_DETAILS *)pRegFmts->pData[i])->wFormatTag) &&
                 (lpwfx->nSamplesPerSec == ((DWORD)((AUDCAP_DETAILS *)pRegFmts->pData[i])->audio_params.uSamplesPerSec)) &&
                 ((lpwfx->nAvgBytesPerSec * 8) == (((AUDCAP_DETAILS *)pRegFmts->pData[i])->uMaxBitrate))) {
                break;
            }
        }

        if (i == pRegFmts->nFormats) {
            //Check the case that some (but not all) of the default formats are missing.
            for (i=0;i<uDefTableEntries;i++) {
                if ((paftd->dwFormatTag == default_id_table[i].wFormatTag)
                    && (lpwfx->nSamplesPerSec == (DWORD)default_id_table[i].audio_params.uSamplesPerSec)
                    && (lpwfx->wBitsPerSample == LOWORD(default_id_table[i].audio_params.uBitsPerSample))) {

                    //Arrgh!! Jump down, and rebuild this format
                    goto RebuildFormat;
                }
            }
            if (i==uDefTableEntries) {
                //We don't care about this format, it's not in the cache, or default list
                return FALSE;
            }

        }

        memcpy(pAudcapDetails, pRegFmts->pData[i], sizeof(AUDCAP_DETAILS));
        bRet=TRUE;
    } else {

RebuildFormat:
    	RtlZeroMemory((PVOID) pAudcapDetails, sizeof(AUDCAP_DETAILS));

    	// fixup the bits per sample and sample rate fields of audio_params so that the key name can be built
    	pAudcapDetails->audio_params.uSamplesPerSec = lpwfx->nSamplesPerSec;
    	pAudcapDetails->audio_params.uBitsPerSample = MAKELONG(lpwfx->wBitsPerSample,0);
    	pAudcapDetails->uMaxBitrate = lpwfx->nAvgBytesPerSec * 8;	

    	if (!paftd	||
    		(!BuildFormatName(	pAudcapDetails,
    							paftd->szFormatTag,
    							pafd->szFormat)))
    	{
    		ERRORMESSAGE(("IsFormatSpecified: Couldn't build format name\r\n"));
    		return(FALSE);
    	}

        for(i=0;i< uDefTableEntries; i++)
        {
            if((lpwfx->wFormatTag == default_id_table[i].wFormatTag)
                && (lpwfx->nSamplesPerSec == (DWORD)default_id_table[i].audio_params.uSamplesPerSec)
                && (lpwfx->wBitsPerSample == LOWORD(default_id_table[i].audio_params.uBitsPerSample)))
                //&& strnicmp(lpwfx->szFormat, default_id_table[i].szFormat)
            {
                // found matching default entry - copy stuff from table
                // (but don't overwrite the string)
                memcpy(pAudcapDetails, &default_id_table[i],
                    sizeof(AUDCAP_DETAILS) - sizeof(pAudcapDetails->szFormat));

                // LOOKLOOK - test against CPU limitations.
                // this supports a hack to disable CPU intensive codecs if not running
                //on a pentium

                if(default_id_table[i].wCPUUtilizationEncode > wMaxCPU)
                {					
                    pAudcapDetails->bSendEnabled = FALSE;
                }			
                if(default_id_table[i].wCPUUtilizationDecode > wMaxCPU)
                {					
                    pAudcapDetails->bRecvEnabled = FALSE;		
                }			

                // add this to the registry
                CalculateFormatProperties(pAudcapDetails, lpwfx);
                bRet = UpdateFormatInRegistry(pAudcapDetails);
                break;
            }
        }

    }



    return bRet;
}


/***************************************************************************

    Name      : CMsiaCapability::CopyAudcapInfo

    Purpose   : Copies basic audio info from an AUDCAP_INFO structure to an
				AUDCAP_DETAILS structure, or vice versa. AUDCAP_INFO is external
				representation. AUDCAP_DETAILS is internal one.

    Parameters:	pDetails - pointer to an AUDCAP_DETAILS structure
				pInfo - pointer to an AUDCAP_INFO structure
				bDirection - 0 = ->, 1 = <-

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CMsiaCapability::CopyAudcapInfo (PAUDCAP_DETAILS pDetails,
	PAUDCAP_INFO pInfo, BOOL bDirection)
{
	WORD wSortIndex;
	UINT uIndex;
	AUDIO_FORMAT_ID Id;
	HRESULT hr=NOERROR;
	
	if(!pInfo || !pDetails)
	{
		hr = CAPS_E_INVALID_PARAM;
		goto out;
	}

	if (bDirection)
	{
		// AUDCAP_INFO -> AUDCAP_DETAILS
		// the caller cannot modify szFormat, Id, wSortIndex and uMaxBitrate, all calculated fields

		pDetails->wFormatTag = pInfo->wFormatTag;	
		pDetails->uAvgBitrate = pInfo->uAvgBitrate;
		pDetails->wCPUUtilizationEncode	= pInfo->wCPUUtilizationEncode;
		pDetails->wCPUUtilizationDecode	= pInfo->wCPUUtilizationDecode;
		pDetails->bSendEnabled =  pInfo->bSendEnabled;
		pDetails->bRecvEnabled = pInfo->bRecvEnabled;
	}
	else
	{		
		// find the sort index.
		uIndex = (UINT)(pDetails - pLocalFormats);
		Id = IndexToId(uIndex);
		for(wSortIndex=0; wSortIndex<uNumLocalFormats && wSortIndex < MAX_CAPS_PRESORT; wSortIndex++)
		{
			if (uIndex == IDsByRank[wSortIndex])
				break; // found it
		}
		// note:  recall that only  MAX_CAPS_PRESORT are sorted and the rest are in random order.
		// the rest all have a value of MAX_CAPS_PRESORT for the sort index

		memcpy(pInfo->szFormat, pDetails->szFormat, sizeof(pInfo->szFormat));

		// AUDCAP_DETAILS -> AUDCAP_INFO	
		pInfo->wFormatTag = pDetails->wFormatTag;	
		pInfo->Id = Id;
		pInfo->uMaxBitrate = pDetails->uMaxBitrate;
		pInfo->uAvgBitrate = pDetails->uAvgBitrate;
		pInfo->wCPUUtilizationEncode	= pDetails->wCPUUtilizationEncode;
		pInfo->wCPUUtilizationDecode	= pDetails->wCPUUtilizationDecode;
		pInfo->bSendEnabled =  pDetails->bSendEnabled;
		pInfo->bRecvEnabled = pDetails->bRecvEnabled;
		pInfo->wSortIndex = wSortIndex;
	}

out:
	return hr;
}


HRESULT CMsiaCapability::EnumCommonFormats(PBASIC_AUDCAP_INFO pFmtBuf, UINT uBufsize,
	UINT *uNumFmtOut, BOOL bTXCaps)
{
	UINT u, uNumOut =0;
	HRESULT hr = hrSuccess;
	MEDIA_FORMAT_ID FormatIDRemote;
	HRESULT hrIsCommon;	
	
	AUDCAP_DETAILS *pDetails = pLocalFormats;
	// validate input
	if(!pFmtBuf || !uNumFmtOut || (uBufsize < (sizeof(BASIC_AUDCAP_INFO)*uNumLocalFormats)))
	{
		return CAPS_E_INVALID_PARAM;
	}
	if(!uNumLocalFormats || !pDetails)
	{
		return CAPS_E_NOCAPS;
	}
	// temporary - enumerating requestable receive formats is not yet supported
	if(!bTXCaps)
		return CAPS_E_NOT_SUPPORTED;
		
	for(u=0; (u <uNumLocalFormats) && (u <MAX_CAPS_PRESORT); u++)
	{
		pDetails = pLocalFormats + IDsByRank[u];	
		// if there is a session, then return formats that are common to local and remote.
		if(uNumRemoteDecodeFormats)
		{
			hrIsCommon = ResolveToLocalFormat(IndexToId(IDsByRank[u]), &FormatIDRemote);
			if(HR_SUCCEEDED(hrIsCommon))	
			{
				hr = CopyAudcapInfo (pDetails, pFmtBuf, 0);	
				if(!HR_SUCCEEDED(hr))	
					goto EXIT;
				uNumOut++;
				pFmtBuf++;
			}
		}
		else	// no remote capabilities exist because there is no current session
		{
			hr = CAPS_E_NOCAPS;
		}
	}

	*uNumFmtOut = uNumOut;
EXIT:
	return hr;
}

HRESULT CMsiaCapability::EnumFormats(PBASIC_AUDCAP_INFO pFmtBuf, UINT uBufsize,
	UINT *uNumFmtOut)
{
	UINT u;
	HRESULT hr = hrSuccess;
	AUDCAP_DETAILS *pDetails = pLocalFormats;
	// validate input
	if(!pFmtBuf || !uNumFmtOut || (uBufsize < (sizeof(BASIC_AUDCAP_INFO)*uNumLocalFormats)))
	{
		return CAPS_E_INVALID_PARAM;
	}
	if(!uNumLocalFormats || !pDetails)
	{
		return CAPS_E_NOCAPS;
	}

	for(u=0; (u <uNumLocalFormats) && (u <MAX_CAPS_PRESORT); u++)
	{
		pDetails = pLocalFormats + IDsByRank[u];	
		hr = CopyAudcapInfo (pDetails, pFmtBuf, 0);	
		if(!HR_SUCCEEDED(hr))	
			goto EXIT;
		pFmtBuf++;
	}

	*uNumFmtOut = min(uNumLocalFormats, MAX_CAPS_PRESORT);
EXIT:
	return hr;
}

HRESULT CMsiaCapability::GetBasicAudcapInfo (AUDIO_FORMAT_ID Id, PBASIC_AUDCAP_INFO pFormatPrefsBuf)
{
	AUDCAP_DETAILS *pFmt;
	UINT uIndex = IDToIndex(Id);
	if(!pFormatPrefsBuf || (uNumLocalFormats <= uIndex))
	{
		return CAPS_E_INVALID_PARAM;
	}
	pFmt = pLocalFormats + uIndex;

	return (CopyAudcapInfo(pFmt,pFormatPrefsBuf, 0));
}

HRESULT CMsiaCapability::ApplyAppFormatPrefs (PBASIC_AUDCAP_INFO pFormatPrefsBuf,
	UINT uNumFormatPrefs)
{
	FX_ENTRY ("CMsiaCapability::ApplyAppFormatPrefs");
	UINT u, v;
	PBASIC_AUDCAP_INFO pTemp;
	AUDCAP_DETAILS *pFmt;

	if(!pFormatPrefsBuf || (uNumLocalFormats != uNumFormatPrefs))
	{
		ERRORMESSAGE(("%s invalid param: pFbuf:0x%08lx, uNumIN:%d, uNum:%d\r\n",
			_fx_, pFormatPrefsBuf, uNumFormatPrefs, uNumLocalFormats));
		return CAPS_E_INVALID_PARAM;
	}
	
	// validate
	for(u=0; u <uNumLocalFormats; u++)
	{
		pTemp =  pFormatPrefsBuf+u;
		// make sure that the format ID is real
		if(IDToIndex(pTemp->Id) >= uNumLocalFormats)
		{
			return CAPS_E_INVALID_PARAM;
		}
		// look for bad sort indices, duplicate sort indices and duplicate format IDs
		if(pTemp->wSortIndex >= uNumLocalFormats)
			return CAPS_E_INVALID_PARAM;
			
		for(v=u+1; v <uNumLocalFormats; v++)
		{
			if((pTemp->wSortIndex == pFormatPrefsBuf[v].wSortIndex)
				|| (pTemp->Id == pFormatPrefsBuf[v].Id))
			{
			ERRORMESSAGE(("%s invalid param: wSI1:0x%04x, wSI2:0x%04x, ID1:%d, ID2:%d\r\n",
			_fx_, pTemp->wSortIndex, pFormatPrefsBuf[v].wSortIndex, pTemp->Id,
			pFormatPrefsBuf[v].Id));
				return CAPS_E_INVALID_PARAM;
			}
		}
	}
	// all seems well
	for(u=0; u <uNumLocalFormats; u++)
	{
		pTemp =  pFormatPrefsBuf+u;			// next entry of the input
		pFmt = pLocalFormats + IDToIndex(pTemp->Id);	// identifies this local format

		// apply the new sort order
		pFmt->wApplicationPrefOrder = pTemp->wSortIndex;
		// update the updatable parameters (CPU utilization, bitrate)
		pFmt->bSendEnabled = pTemp->bSendEnabled;
		pFmt->bRecvEnabled	= pTemp->bRecvEnabled;
		
// only the tuning wizard or other profiling app can write these (via other apis only)
		pFmt->wCPUUtilizationEncode	= pTemp->wCPUUtilizationEncode;
		pFmt->wCPUUtilizationDecode	= pTemp->wCPUUtilizationDecode;
//		pFmt->wApplicationPrefOrder	= pTemp->wApplicationPrefOrder;
//		pFmt->uAvgBitrate	= pTemp->
//		pFmt->wCompressionRatio	= pTemp->
		
		// update the registry
		UpdateFormatInRegistry(pFmt);
		
		// now update the sort order contained in IDsByRank
		// note:  recall that only  MAX_CAPS_PRESORT are sorted and the rest are in random order.
		// LOOKLOOK - maybe need a separate sort order array? - the order in IDsByRank
		// is being overriden here
		// the array holds the sorted indices into the array of formats in pLocalFormats
		if(pTemp->wSortIndex < MAX_CAPS_PRESORT)
		{
			// insert the format at the position indicated by the input
			IDsByRank[pTemp->wSortIndex] = (MEDIA_FORMAT_ID)(pFmt - pLocalFormats);
		}
		
	}

#ifdef DEBUG
	for(u=0; u <uNumLocalFormats; u++) {
		pTemp =  pFormatPrefsBuf+u;			// next entry of the input
		pFmt = pLocalFormats + IDToIndex(pTemp->Id);	// identifies this local format
	    DEBUGMSG (ZONE_ACM,("Format %s: Sort Index: %d\r\n",pTemp->szFormat,pTemp->wSortIndex));
    }
#endif

	return hrSuccess;
}

		// update the registry
BOOL CMsiaCapability::UpdateFormatInRegistry(AUDCAP_DETAILS *pAudcapDetails)
{

	FX_ENTRY(("CMsiaCapability::UpdateFormatInRegistry"));
	LPTSTR lpszKeyName = NULL;
	BOOL bRet;
	UINT i;
	if(!pAudcapDetails)
	{
		return FALSE;
	}	

    //Update the CACHE info!!!
    if (pRegFmts) {
        for (i=0;i<pRegFmts->nFormats;i++) {
            if (!lstrcmp (((AUDCAP_DETAILS *)pRegFmts->pData[i])->szFormat,pAudcapDetails->szFormat) &&
				pAudcapDetails->audio_params.uSamplesPerSec == ((AUDCAP_DETAILS *)pRegFmts->pData[i])->audio_params.uSamplesPerSec &&
				pAudcapDetails->audio_params.uBitsPerSample == ((AUDCAP_DETAILS *)pRegFmts->pData[i])->audio_params.uBitsPerSample &&
				pAudcapDetails->uMaxBitrate == ((AUDCAP_DETAILS *)pRegFmts->pData[i])->uMaxBitrate) {

                memcpy (pRegFmts->pData[i],pAudcapDetails,sizeof (AUDCAP_DETAILS));
                break;
            }
        }
    }


	lpszKeyName = AllocRegistryKeyName(	pAudcapDetails->szFormat,
										pAudcapDetails->audio_params.uSamplesPerSec,
										pAudcapDetails->audio_params.uBitsPerSample,
										pAudcapDetails->uMaxBitrate);
	if (!lpszKeyName)
	{
		ERRORMESSAGE(("%s:Alloc failed\r\n",_fx_));
        return(FALSE);
    }

	DEBUGMSG(ZONE_ACM,("%s:updating %s, wPref:0x%04x, bS:%d, bR:%d\r\n",
			_fx_, lpszKeyName, pAudcapDetails->wApplicationPrefOrder,
			pAudcapDetails->bSendEnabled, pAudcapDetails->bRecvEnabled));
	// add this to the registry
	RegEntry reAudCaps(szRegInternetPhone TEXT("\\") szRegMSIPAndH323Encodings,
						HKEY_LOCAL_MACHINE);

	bRet = (ERROR_SUCCESS == reAudCaps.SetValue(lpszKeyName,
												pAudcapDetails,
												sizeof(AUDCAP_DETAILS)));

	FreeRegistryKeyName(lpszKeyName);
    return(bRet);				
}

/***************************************************************************

    Name      : CMsiaCapability::AddFormatEnumHandler

    Purpose   : Enumerates the ACM formats for the case in which we want
				to see all formats, and find the one we need. Used for installable
				codecs when we want to find more info on the format being added

    Parameters:	Standard ACM EnumFormatCallback parameters

    Returns   : BOOL (somewhat upside down logic)
				TRUE - not out format. keep calling.
				FALSE - found our format. don't call anymore

    Comment   :

***************************************************************************/
BOOL CMsiaCapability::AddFormatEnumHandler(HACMDRIVERID hadid,
    LPACMFORMATDETAILS pafd, DWORD_PTR dwInstance, DWORD fdwSupport)
{
	PACM_APP_PARAM pAppParam = (PACM_APP_PARAM) dwInstance;
	LPWAVEFORMATEX lpwfx = pAppParam->lpwfx;
	LPACMFORMATTAGDETAILS paftd = pAppParam->paftd;
	AUDCAP_DETAILS *pAudcapDetails = pAppParam->pAudcapDetails;
	BOOL bRet = TRUE;

	if (pAppParam->hr == NOERROR)
	{
		// already got what we wanted
		bRet = FALSE;
		goto out;
	}
	
	// check to see if this is the format we're looking for
	if ((lpwfx->cbSize != pafd->pwfx->cbSize) ||
		!RtlEqualMemory(lpwfx, pafd->pwfx, sizeof(WAVEFORMATEX)+lpwfx->cbSize))
	{
		// not the one. out of here asap, but tell ACM to keep calling us
		bRet = TRUE;
		goto out;
	}

	// this is the format tag we're looking for
	if (BuildFormatName(pAudcapDetails,
						paftd->szFormatTag,
						pafd->szFormat))
	{
		pAppParam->hr = NOERROR;
	}
	
	// either an error or we found what we want. tell ACM not to call us anymore
	bRet = FALSE;	

out:
	return bRet;
}

/***************************************************************************

    Name      : NormalizeCPUUtilization

    Purpose   : Normalize CPU utilization numbers for an audio format

    Parameters:	pAudcapDetails [in/out] pointer to an AUDCAP_DETAILS structure
					with the wCPUUtilizationEncode and wCPUUtilizationDecode
					correctly initialized. These fields will be scaled in place
					per the machine CPU.

    Returns   : FALSE for error

***************************************************************************/
BOOL NormalizeCPUUtilization (PAUDCAP_DETAILS pAudcapDetails)
{
#define wCPUEncode pAudcapDetails->wCPUUtilizationEncode
#define wCPUDecode pAudcapDetails->wCPUUtilizationDecode
#define BASE_PENTIUM 90
	int nNormalizedSpeed, iFamily=0;

	if (!pAudcapDetails)
	{
		ASSERT(pAudcapDetails);
		return FALSE;
	}

#ifdef	_M_IX86
	GetNormalizedCPUSpeed (&nNormalizedSpeed,&iFamily);
#else
	// profile the CPU on, say, an Alpha
	// see ui\conf\audiocpl.cpp
	iFamily=5;
	nNormalizedSpeed=300;
#endif

	// base is Pentium 90Mhz.
	if (iFamily < 5)
	{	// 486 or below, inlcuding Cyrix parts
		if (nNormalizedSpeed > 50)
		{	// Cyrix or friends. 1.5 the utilization of a P5-90. Make it so.
			wCPUEncode += max(1, wCPUEncode / 2);
			wCPUDecode += max(1, wCPUDecode / 2);
		}
		else
		{	// 486 is half a P5-90. This is not accurate, but good enough
			wCPUEncode = max(1, wCPUEncode * 2);
			wCPUDecode = max(1, wCPUDecode * 2);
		}
	}
	else
	{	// it's a Pentium or TNGs
		// nNormalizedSpeed ALREADY accounts for P-Pro and later families
		wCPUEncode=max(1,((wCPUEncode*BASE_PENTIUM)/nNormalizedSpeed));
		wCPUDecode=max(1,((wCPUDecode*BASE_PENTIUM)/nNormalizedSpeed));
	}

	// disable this format if encode utilization is too high
	// we compare to 80%, since there's no QoS CPU utilization number at
	// this point, and if there was, it would usually select 81%
	if (wCPUEncode > 80)
		pAudcapDetails->bSendEnabled = FALSE;

	return TRUE;
}

/***************************************************************************

    Name      : CMsiaCapability::AddACMFormat

    Purpose   : Adds an ACM format to the list of formats we support

    Parameters:	lpwfx - pointer to the waveformat structure for the added codec
				pAudCapInfo - additional format info that is not in the waveformat
					structure

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CMsiaCapability::AddACMFormat (LPWAVEFORMATEX lpwfx, PBASIC_AUDCAP_INFO pAudcapInfo)
{
	HRESULT hr = hrSuccess;
	// initialize cap entry with default values
	AUDCAP_DETAILS cap_entry =
		{WAVE_FORMAT_UNKNOWN,  NONSTD_TERMCAP, STD_CHAN_PARAMS,
		{RTP_DYNAMIC_MIN,  0, 8000, 16},
		0, TRUE, TRUE,
		960, 				// default number of samples per packet
		16000,				// default to 16kbs bitrate
		0, 					// unknown average bitrate
		90, 90,	// default CPU utilization
		PREF_ORDER_UNASSIGNED,	// unassigned sort order
		0,NULL,0,NULL,
		""};
	ACM_APP_PARAM sAppParam = {	this, &cap_entry, ACMAPP_FORMATENUMHANDLER_ADD,
								lpwfx, NULL, CAPS_E_SYSTEM_ERROR, NULL};
		
	/*
	 *	Parameter validation
	 */

	if (!lpwfx || !pAudcapInfo)
	{
		hr = CAPS_E_INVALID_PARAM;
		goto out;
	}
		
	// nBlockAlign of 0 is illegal and will crash NAC
	if (lpwfx->nBlockAlign == 0)
	{
		hr = CAPS_E_INVALID_PARAM;
		goto out;
	}
		
	// only supporting formats with one audio channel
	if (lpwfx->nChannels != 1)
	{
		hr = CAPS_E_INVALID_PARAM;
		goto out;
	}
		
	/*
	 *	Build the AUDCAP_DETALS structure for this format
	 */

	// WAVEFORMAT info first
	// fixup the bits per sample and sample rate fields of audio_params so that
	// the key name can be built
	cap_entry.audio_params.uSamplesPerSec = lpwfx->nSamplesPerSec;
	cap_entry.audio_params.uBitsPerSample = MAKELONG(lpwfx->wBitsPerSample,0);

	// fill in info given in lpwfx, calculate whatever parameters can be calculated
	// use actual bits per sample unless the bps field is zero, in which case
	// assume 16 bits (worst case).
	cap_entry.wFormatTag = lpwfx->wFormatTag;

	// now add in the caller AUDCAP_INFO information
	CopyAudcapInfo(&cap_entry, pAudcapInfo, 1);

	// normalize the encode and decode CPU utilization numbers
	NormalizeCPUUtilization(&cap_entry);

	// get the values we need to get from the WAVEFORMATEX structure
	CalculateFormatProperties(&cap_entry, lpwfx);

	// set the RTP payload number. We are using a random number from the dynamic range
	// for the installable codecs
	cap_entry.audio_params.RTPPayload = RTP_DYNAMIC_MIN;

	// get ACM to enumerate all formats, and see if we can find this one
	// this call will make ACM call into AddFormatEnumHandler, which will try to
	// match formats returned by ACM with the added format, and if successful,
	// will create a format name for it into cap_entry.szFormat;
	if(!DriverEnum((DWORD_PTR) &sAppParam))
	{
		hr = CAPS_E_NOMATCH;
		goto out;
	}
				
	if (HR_FAILED(sAppParam.hr))
	{
		ERRORMESSAGE(("CMsiaCapability::AddACMFormat: format enum problem\r\n"));
		hr = CAPS_E_NOMATCH;
		goto out;
	}

	// add this to the registry
	if(!UpdateFormatInRegistry(&cap_entry))
	{
		ERRORMESSAGE(("CMsiaCapability::AddACMFormat: can't update registry\r\n"));
		hr = CAPS_E_SYSTEM_ERROR;
		goto out;
	}
	// free the old format cache...
    FreeRegistryFormats(pRegFmts);
	pRegFmts=NULL;

	// reinit to update the list of local formats
    if (!ReInit())
	{
		ERRORMESSAGE(("CMsiaCapability::AddACMFormat: Reinit failed\r\n"));
		hr = CAPS_E_SYSTEM_ERROR;
   		goto out;
	}

out:
	return hr;
}

/***************************************************************************

    Name      : CMsiaCapability::RemoveACMFormat

    Purpose   : Removes an ACM format from the list of formats we support

    Parameters:	lpwfx - pointer to the waveformat structure for the added codec

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CMsiaCapability::RemoveACMFormat (LPWAVEFORMATEX lpwfx)
{
	HRESULT hr = hrSuccess;
    HKEY hKey = NULL;
	LPTSTR lpszValueName = NULL;
    DWORD dwErr;
	AUDCAP_DETAILS cap_entry;
	ACM_APP_PARAM sAppParam = {	this, &cap_entry, ACMAPP_FORMATENUMHANDLER_ADD,
								lpwfx, NULL, CAPS_E_SYSTEM_ERROR, NULL};
	
	/*
	 *	Parameter validation
	 */

	if(!lpwfx)
	{
		ERRORMESSAGE(("CMsiaCapability::RemoveACMFormat: NULL WAVEFORMAT pointer\r\n"));
		return CAPS_E_INVALID_PARAM;
	}	

	// nBlockAlign of 0 is illegal and will crash NAC
	if (lpwfx->nBlockAlign == 0)
	{
		hr = CAPS_E_INVALID_PARAM;
		goto out;
	}
		
	// only supporting formats with one audio channel
	if (lpwfx->nChannels != 1)
	{
		hr = CAPS_E_INVALID_PARAM;
		goto out;
	}
		
	/*
	 *	Enumerate ACM formats
	 */

	if(!DriverEnum((DWORD_PTR) &sAppParam))
	{
		ERRORMESSAGE(("CMsiaCapability::RemoveACMFormat: Couldn't find format\r\n"));
		hr = CAPS_E_NOMATCH;
		goto out;
	}
				
	if (HR_FAILED(sAppParam.hr))
	{
		ERRORMESSAGE(("CMsiaCapability::RemoveACMFormat: format enum problem\r\n"));
		hr = CAPS_E_SYSTEM_ERROR;
		goto out;
	}

	lpszValueName = AllocRegistryKeyName(cap_entry.szFormat,
										lpwfx->nSamplesPerSec,
										MAKELONG(lpwfx->wBitsPerSample,0),
										lpwfx->nAvgBytesPerSec * 8);
	if (!lpszValueName)
	{
		ERRORMESSAGE(("CMsiaCapability::RemoveACMFormat: Alloc failed\r\n"));
	    hr = CAPS_E_SYSTEM_ERROR;
	    goto out;
    }

	// Get the key handle
    if (dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
					szRegInternetPhone TEXT("\\") szRegMSIPAndH323Encodings, 0,
					KEY_ALL_ACCESS, &hKey))
	{
		ERRORMESSAGE(("CMsiaCapability::RemoveACMFormat: can't open key to delete\r\n"));
	    hr = CAPS_E_SYSTEM_ERROR;
	    goto out;
    }

	dwErr = RegDeleteValue(hKey, lpszValueName );	
	if(dwErr != ERROR_SUCCESS)
	{
		hr = CAPS_E_SYSTEM_ERROR;
		goto out;
	}

	// free the old format cache...
    FreeRegistryFormats(pRegFmts);
    pRegFmts=NULL;

	// reinit to update the list of local formats
    if (!ReInit())
	{
		hr = CAPS_E_SYSTEM_ERROR;
   		goto out;
	}

out:
    if (hKey)
        RegCloseKey(hKey);
	if(lpszValueName)
		MEMFREE(lpszValueName);		
	return hr;
}

HRESULT CMsiaCapability::SetCapIDBase (UINT uNewBase)
{
	uCapIDBase = uNewBase;	
	UINT u;
	for (u=0;u<uNumLocalFormats;u++)
	{
    	pLocalFormats[u].H245TermCap.CapId = u + uCapIDBase;
	}
   	return hrSuccess;
}

BOOL CMsiaCapability::IsHostForCapID(MEDIA_FORMAT_ID CapID)
{
	if((CapID >= uCapIDBase) && ((CapID - uCapIDBase) < uNumLocalFormats))
		return TRUE;
	else
		return FALSE;
	
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\plog.h ===
#ifndef PLOG_H
#define PLOG_H

#define PLOG_MAX_CALLS	20
#define PLOG_MAX_PACKETS_CALL 20000
#define PLOG_FILE_AUDIO "C:\\AuPacketLog"
#define PLOG_FILE_VIDEO "C:\\VidPacketLog"
#define PLOG_FILE_EXT    ".txt"

// number of packets until the missing packet
// is declared "lost" instead of late
#define PLOG_MAX_NOT_LATE	20

struct CPacketLogEntry
{
	DWORD dwSequenceNumber;
	DWORD dwTimeStamp;
	LARGE_INTEGER LL_ArrivalTime;
	DWORD dwSize;
	DWORD dwLosses;
	bool bLate;  // is the packet late ?
	bool bMark;  // is the M bit set in the RTP packet
};


class CCallLog
{
private:
	CPacketLogEntry *m_pLogEntry;
	int m_size;  // max num of entries this list can hold
	int m_currentIndex;
	bool m_bValid;
public:
	CCallLog(int size=PLOG_MAX_PACKETS_CALL);
	~CCallLog();
	bool AddEntry(DWORD dwTimeStamp, DWORD dwSeqNum, LARGE_INTEGER LL_ArrivalTime, DWORD dwSize, bool fMark); 
	bool Flush(HANDLE hFile);
	bool SizeCheck();

	CCallLog& operator=(const CCallLog&);
	CCallLog(const CCallLog&);

	bool PerformStats();
};



// PacketLog maintains a list of CPacketLogEntry's
class CPacketLog
{
private:
	HANDLE m_hFile;         // handle to disk file where logs are kept
	CCallLog *m_pCallLog;   // pointer to CCallLog instance
	char m_szDiskFile[80];  // base name of the disk file
	int m_nExtension;	// current file extension index number

	bool InitFile();

public :
	CPacketLog(LPTSTR szDiskFile);
	CPacketLog(const CPacketLog&);

	CPacketLog& operator=(const CPacketLog&);

	~CPacketLog();
	bool Flush();

	bool MarkCallStart();
	bool AddEntry(DWORD dwTimeStamp, DWORD dwSeqNum, LARGE_INTEGER LL_ArrivalTime, DWORD dwSize, bool fMark); 

};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\packetsender.cpp ===
#include "precomp.h"
#include "NacList.h"
#include "PacketSender.h"



PacketSender::PacketSender() : 
m_SendQueue(PS_INITSIZE, PS_GROWRATE) // shouldn't ever get big
{
	InitializeCriticalSection(&m_cs);
}

PacketSender::~PacketSender()
{
	DeleteCriticalSection(&m_cs);
}




// takes the first packets out of the queue and sends it
// returns true if a packet was taken out of the queue and sent
BOOL PacketSender::SendPacket()
{
	BOOL bRet;
	PS_QUEUE_ELEMENT pqe;
	WSABUF wsabuf;
	RTP_HDR *pRtpHdr;
	DWORD dwType=PS_AUDIO;

	EnterCriticalSection(&m_cs);

	bRet = m_SendQueue.PopFront(&pqe);
	if (bRet)
	{
		ASSERT(pqe.data);

		pRtpHdr = (RTP_HDR*)(pqe.data - sizeof(RTP_HDR));
		*(DWORD *)pRtpHdr = 0;
		pRtpHdr->ts = pqe.pMP->GetTimestamp();
		pRtpHdr->m = pqe.fMark;
		pRtpHdr->payload = pqe.pMP->GetPayload();

		if (pqe.pHeaderInfo && pqe.dwHdrSize && (pqe.dwPacketType==PS_VIDEO))
		{
			CopyMemory(pqe.data, pqe.pHeaderInfo, pqe.dwHdrSize);
		}

		wsabuf.buf = (char *)pRtpHdr;
		wsabuf.len = pqe.dwSize + sizeof(RTP_HDR);

		if (FAILED(pqe.pRTPSend->Send(&wsabuf, 1, NULL, NULL)))
		{
			LOG(((pqe.dwPacketType == PS_VIDEO) ? LOGMSG_VIDSEND_AUD_NOT_SEND : LOGMSG_AUDSEND_AUD_NOT_SEND, pqe.dwSize + sizeof (RTP_HDR), pqe.pMP->m_timestamp));
			DEBUGMSG (ZONE_DP, ("Check_Send: pRTPSend->Send failed\r\n" ));
		}
		else
		{
			LOG(((pqe.dwPacketType == PS_VIDEO) ? LOGMSG_VIDSEND_AUD_SEND : LOGMSG_AUDSEND_AUD_SEND, pqe.dwSize + sizeof (RTP_HDR), pqe.pMP->m_timestamp, GetTickCount()));
		}

    	if (pqe.pHeaderInfo)
		{
    	    MemFree ((BYTE *)(pqe.pHeaderInfo));
        }

	}

	LeaveCriticalSection(&m_cs);

	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\naclist.h ===
#ifndef NAC_LIST_H
#define NAC_LIST_H


#include <wtypes.h>

// generic List template to be used as
// a Queue or Stack



template <class T> class NacList
{
private:
	typedef T *PTR_T;
	typedef T **PTR_PTR_T;

	T *m_aElements;  // array of pointers

	int m_nSize;  // number of Appended elements
	int m_nHeadIndex;
	int m_nTotalSize;  // total size of queue (used+unsed slots)
	int m_nGrowthRate;

	int Grow();

public:
	NacList(int nInitialSize, int nGrowthRate);
	~NacList();

	bool PeekFront(T *ptr);   // returns list's front (doesn't remove)
	bool PeekRear(T *ptr);    // returns list's rear (doesn't remove)

	bool PushFront(const T &t);      // adds to the front of the list
	bool PushRear(const T &t);       // adds to the rear of the list

	bool PopFront(T *ptr);    // returns and removes list's front
	bool PopRear(T *ptr);     // returns and removes list's rear

	void Flush();            // marks as list empty
	inline int Size() {return m_nSize;}
};


// Thread safe version of above
template <class T> class ThreadSafeList : public NacList<T>
{
private:
	CRITICAL_SECTION m_cs;

public:
	ThreadSafeList(int nInitialSize, int nGrowthRate);
	~ThreadSafeList();

	bool PeekFront(T *ptr);   // returns list's front (doesn't remove)
	bool PeekRear(T *ptr);    // returns list's rear (doesn't remove)

	bool PushFront(const T &t);      // adds to the front of the list
	bool PushRear(const T &t);       // adds to the rear of the list

	bool PopFront(T *ptr);    // returns and removes list's front
	bool PopRear(T *ptr);     // returns and removes list's rear

	void Flush();
	int Size();

	// note: we don't inherit "Grow" because it will only get
	// called while we are in the Critical SEction
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\nacguids.c ===
#define  INITGUIDS
#include <objbase.h>
#include <initguid.h>
#include <mmsystem.h>
#include "ibitmap.h"
#include "effect.h"

// the following is yanked from "VidPool.h" {36447655-7089-11d0-BC25-00AA00A13C86}
DEFINE_GUID(BFID_PRIVATEDIB, 0x36447655, 0x7089, 0x11d0, 0xbc, 0x25, 0x0, 0xaa, 0x0, 0xa1, 0x3c, 0x86); 

#include "common.h"
#include "nacguids.h"
#include "qos.h"
#include "codecs.h"
#include <irtp_i.c>

// {D2E97231-0C18-11d0-AD53-00AA004A80A3}
//static const GUID OID_CAP_ACM_TO_MSIA = 
//{ 0xd2e97231, 0xc18, 0x11d0, { 0xad, 0x53, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3 } 
//};

// {D2E97230-0C18-11d0-AD53-00AA004A80A3}
//static const GUID OID_CAP_ACM_TO_H323 = 
//{ 0xd2e97230, 0xc18, 0x11d0, { 0xad, 0x53, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3 } 
//};

// {A4209190-14B4-11d0-AD55-00AA004A80A3}
//static const GUID PID_H323 = 
//{ 0xa4209190, 0x14b4, 0x11d0, { 0xad, 0x55, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3 
//} };

// {A4209191-14B4-11d0-AD55-00AA004A80A3}
//static const GUID PID_MSICCP = 
//{ 0xa4209191, 0x14b4, 0x11d0, { 0xad, 0x55, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3 
//} };

// {A4209192-14B4-11d0-AD55-00AA004A80A3}
//static const GUID PID_MNM10_DUAL = 
//{ 0xa4209192, 0x14b4, 0x11d0, { 0xad, 0x55, 0x0, 0xaa, 0x0, 0x4a, 0x80, 0xa3 
//} };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\naclist.cpp ===
#include "precomp.h"
#include "NacList.h"


template <class T>
NacList<T>::NacList(int nInitialSize, int nGrowthRate) : 
m_nSize(0), m_nHeadIndex(0), m_nTotalSize(nInitialSize), m_nGrowthRate(nGrowthRate)
{

	ASSERT(nInitialSize > 0);
	ASSERT(nGrowthRate > 0);

    DBG_SAVE_FILE_LINE
	m_aElements = new T[nInitialSize];
	if (m_aElements == NULL)
	{
		ERROR_OUT(("NacList::NacList - Out of memory"));
	}
}

template <class T>
NacList<T>::~NacList()
{
	Flush();
	delete [] m_aElements;
}

template <class T>
void NacList<T>::Flush()
{
	m_nHeadIndex = 0;
	m_nSize = 0;
}

template <class T>
bool NacList<T>::PeekFront(T *pT)
{
	if (m_nSize <= 0)
	{
		return false;
	}

	*pT = m_aElements[m_nHeadIndex];
	return true;
}

template <class T>
bool NacList<T>::PeekRear(T *pT)
{
	int nRearIndex;

	if (m_nSize <= 0)
	{
		return false;
	}

	nRearIndex = (m_nHeadIndex + m_nSize - 1) % m_nTotalSize;

	*pT = m_aElements[nRearIndex];
	return true;
}

template <class T>
bool NacList<T>::PushFront(const T &t)
{
	int nInsertIndex;

	// do we need to grow
	if (m_nSize >= m_nTotalSize)
	{
		Grow();
	}

	if (m_nHeadIndex == 0)
	{
		m_nHeadIndex = m_nTotalSize - 1;
	}
	else
	{
		--m_nHeadIndex;
	}

	m_aElements[m_nHeadIndex] = t;
	m_nSize++;

	return true;
}

template <class T>
bool NacList<T>::PushRear(const T &t)
{
	int nInsertIndex;

	// do we need to grow
	if (m_nSize >= m_nTotalSize)
	{
		Grow();
	}

	nInsertIndex = (m_nHeadIndex + m_nSize) % m_nTotalSize;
	m_aElements[nInsertIndex] = t;

	m_nSize++;

	return true;
}


template <class T>
bool NacList<T>::PopFront(T *pT)
{
	ASSERT(m_nSize >= 0);

	if (m_nSize <= 0)
	{
		return false;
	}

	*pT = m_aElements[m_nHeadIndex];


	m_nHeadIndex = (m_nHeadIndex + 1) % m_nTotalSize;
	m_nSize--;

	return true;
}


template <class T>
bool NacList<T>::PopRear(T *pT)
{
	int nRearIndex;

	ASSERT(m_nSize >= 0);

	if (m_nSize <= 0)
	{
		return false;
	}

	nRearIndex = (m_nHeadIndex + m_nSize - 1) % m_nTotalSize;

	*pT = m_aElements[nRearIndex];
	m_nSize--;
	return true;
}



template <class T>
int NacList<T>::Grow()
{
	T *aNew;
	int nTotalSize;
	int nIndex, nCopyIndex;

	nTotalSize = m_nTotalSize + m_nGrowthRate;

    DBG_SAVE_FILE_LINE
	aNew = new T[nTotalSize];
	if (aNew == NULL)
	{
		ERROR_OUT(("Out of Memory"));
		return 0;
	}

	for (nIndex = 0; nIndex < m_nSize; nIndex++)
	{
		nCopyIndex = (nIndex + m_nHeadIndex) % m_nTotalSize;
		aNew[nIndex] = m_aElements[nCopyIndex];
	}

	delete [] m_aElements;
	m_aElements = aNew;

	m_nTotalSize = nTotalSize;
	m_nHeadIndex = 0;

	return (nTotalSize);
}



// Thread Safe List


template <class T>
ThreadSafeList<T>::ThreadSafeList(int nInitialSize, int nGrowthRate) : 
NacList<T>(nInitialSize, nGrowthRate)
{
	InitializeCriticalSection(&m_cs);
}

template <class T>
ThreadSafeList<T>::~ThreadSafeList()
{
	DeleteCriticalSection(&m_cs);
}

template <class T>
void ThreadSafeList<T>::Flush()
{
	EnterCriticalSection(&m_cs);
	NacList<T>::Flush();
	LeaveCriticalSection(&m_cs);
}

template <class T>
bool ThreadSafeList<T>::PeekFront(T *pT)
{
	bool bRet;
	EnterCriticalSection(&m_cs);
	bRet = NacList<T>::PeekFront(pT);
	LeaveCriticalSection(&m_cs);
	return bRet;
}

template <class T>
bool ThreadSafeList<T>::PeekRear(T *pT)
{
	bool bRet;
	EnterCriticalSection(&m_cs);
	bRet = NacList<T>::PeekRear(pT);
	LeaveCriticalSection(&m_cs);
	return bRet;
}

template <class T>
bool ThreadSafeList<T>::PushFront(const T &t)
{
	bool bRet;
	EnterCriticalSection(&m_cs);
	bRet = NacList<T>::PushFront(t);
	LeaveCriticalSection(&m_cs);
	return bRet;
}

template <class T>
bool ThreadSafeList<T>::PushRear(const T &t)
{
	bool bRet;
	EnterCriticalSection(&m_cs);
	bRet = NacList<T>::PushRear(t);
	LeaveCriticalSection(&m_cs);
	return bRet;
}


template <class T>
bool ThreadSafeList<T>::PopFront(T *pT)
{
	bool bRet;
	EnterCriticalSection(&m_cs);
	bRet = NacList<T>::PopFront(pT);
	LeaveCriticalSection(&m_cs);
	return bRet;
}


template <class T>
bool ThreadSafeList<T>::PopRear(T *pT)
{
	bool bRet;
	EnterCriticalSection(&m_cs);
	bRet = NacList<T>::PopRear(pT);
	LeaveCriticalSection(&m_cs);
	return bRet;
}

template <class T>
int ThreadSafeList<T>::Size()
{
	int nRet;
	EnterCriticalSection(&m_cs);
	nRet = NacList<T>::Size();
	LeaveCriticalSection(&m_cs);
	return nRet;
}



// each instance type of the template needs to be declared here
// For example:
//   template class NacList<int>;  // list of integers
//   template class NacList<int*>; // list of pointers to integers


// you have to disable warnings for the following error, else
// the compiler thinks that a second instantiation is occuring
// when it's really only a second declaration
// This generates a warning which becomes an error
#pragma warning(disable:4660)

#include "PacketSender.h"
template class ThreadSafeList<PS_QUEUE_ELEMENT>;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\packetsender.h ===
#ifndef _NAC_PACKET_SENDER_H_
#define _NAC_PACKET_SENDER_H_


#define PS_INITSIZE 32
#define PS_GROWRATE	10

#define PS_AUDIO	1
#define PS_VIDEO	2

#include "NacList.h"

class MediaPacket;
class TxStream;

typedef struct _psqelement
{
	MediaPacket *pMP;
	DWORD dwPacketType;
	IRTPSend *pRTPSend;
	BYTE    *data;
	DWORD   dwSize;
	UINT    fMark;
	BYTE    *pHeaderInfo;
	DWORD   dwHdrSize;
} PS_QUEUE_ELEMENT;



class PacketSender
{
private:

	// adding to the queue is done via the interface exposed by
	// m_SendQueue.  It's thread safe, but we don't want both
	// threads trying to send from this queue at the same time,
	// we may accidentally send packets our of order

	CRITICAL_SECTION m_cs;
public:

	// audio thread will "PushFront" elements containing packets
	// to this queue.  VideoThread will PushRear packets.
	ThreadSafeList<PS_QUEUE_ELEMENT> m_SendQueue;
	BOOL SendPacket();  // sends one packet in a thread safe manner

	PacketSender();
	~PacketSender();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\precomp.h ===
/* precomp.h for NAC.DLL */

// typedefs are useful for dynamic linking to Winsock APIs
#define INCL_WINSOCK_API_TYPEDEFS 1

#include <windows.h>
#include <windowsx.h>
#include <winsock2.h>
#include <winperf.h>

// NetMeeting standard includes
#include <oprahcom.h>
#include <confdbg.h>
#include <avutil.h>
#include <oblist.h>
#include <regentry.h>

#include <limits.h>
#include <mmreg.h>
#include <mmsystem.h>
#include <msacm.h>
#include <vfw.h>


#ifndef _WINSOCK2API_ // { _WINSOCK2API_

typedef struct _OVERLAPPED *    LPWSAOVERLAPPED;

typedef struct _WSABUF {
    u_long      len;     /* the length of the buffer */
    char FAR *  buf;     /* the pointer to the buffer */
} WSABUF, FAR * LPWSABUF;

typedef
void
(CALLBACK * LPWSAOVERLAPPED_COMPLETION_ROUTINE)(
    DWORD dwError,
    DWORD cbTransferred,
    LPWSAOVERLAPPED lpOverlapped,
    DWORD dwFlags
    );

#define WSA_IO_PENDING          (ERROR_IO_PENDING)

#endif // } _WINSOCK2API_
#include "com.h"
#include "nacguids.h"
#include "Dcap.h"
#include "capture.h"
#include "vidinout.h"
#include "vcmStrm.h"
#include "msh26x.h"
#ifdef USE_MPEG4_SCRUNCH
#include "mpeg4.h"
#endif
#include "mperror.h"
#include "common.h"
#include "irtp.h"
#include "iacapapi.h"
#include "ih323cc.h"
#include "icomchan.h"	// only for IVideoDevice
#include "incommon.h"
#include "callcont.h"
#include "h245api.h"	// for some h245 constants
#include "intif.h"
#include "rtp.h"
#include "imstream.h"
#include "codecs.h"
#include "mediacap.h"
#include "acmcaps.h"
#include "vcmcaps.h"
#include "nmqos.h"
#include "iprop.h"
#include "ividrdr.h"
#include "datapump.h"
#include "medistrm.h"
#include "dsound.h"
#include "dsstream.h"
#include "auformats.h"
#include "imp.h"
#include "utils.h"
#include "bufpool.h"
#include "mediapkt.h"
#include "audpackt.h"
#include "vidpackt.h"
#include "rxstream.h"
#include "rvstream.h"
#include "txstream.h"
#include "medictrl.h"
#include "medvctrl.h"
#include "AcmFilter.h"
#include "VcmFilter.h"
#include "devaudq.h"
#include "vidutils.h"
#include "counters.h"
#include "inscodec.h"
#include "avcommon.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\rvstream.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    rvstream.h

Abstract:
	The RVStream class maintains a circular list of MediaPackets. RTP packets received
	from the network are put into the ring (PutNextNetIn), then decoded and removed from the
	ring when the time comes to play them (GetNextPlay). After playback, the packets are
	returned to the ring (Release).
	The ring is implemented as an array and under normal operation the index of the next 
	MediaPacket to play (m_PlayPos) advances by one when GetNextPlay is called.
	RVstream is intended for video packets. Each entry in the ring corresponds to a
	RTP packet as opposed to a time slot.
--*/
#ifndef _RVSTREAM_H_
#define _RVSTREAM_H_

#include <pshpack8.h> /* Assume 8 byte packing throughout */
void FreeNetBufList(NETBUF *pNB);
void AppendNetBufList(NETBUF *pFirstNB, NETBUF *pNB);


class RVStream : public RxStream {
public:
	RVStream(UINT size): RxStream(size){ m_NetBufList = NULL; m_LastGoodSeq=0xFFFF; m_pVideoFilter=NULL; m_NetBufPool.Initialize(40, sizeof(NETBUF)+sizeof(WSABUF **)); };
	virtual MediaPacket *GetNextPlay();
	virtual HRESULT PutNextNetIn(WSABUF *pNetBuf, DWORD timestamp, UINT seq, UINT fMark, BOOL *pfSkippedData, BOOL *pfSyncPoint);
	virtual BOOL ReleaseNetBuffers() ;
	virtual HRESULT FastForward( BOOL fSilenceOnly);
	HRESULT Reset(UINT seq,DWORD timestamp);
	virtual HRESULT SetLastGoodSeq(UINT seq);
	virtual Destroy();
	virtual Initialize(UINT flags, UINT size, IRTPRecv *, MEDIAPACKETINIT *papi, ULONG ulSamplesPerPacket, ULONG ulSamplesPerSec, VcmFilter *pVideoFilter);
	HRESULT RestorePacket(NETBUF *pNetBuf, MediaPacket *pVP, DWORD timestamp, UINT seq, UINT fMark, BOOL *pfReceivedKeyframe);

private:
	HRESULT ReassembleFrame(NETBUF *pNetBuf, UINT seq, UINT fMark);
	BufferPool m_NetBufPool;
	NETBUF *m_NetBufList;
	WORD m_LastGoodSeq;

	VcmFilter *m_pVideoFilter;

	virtual void StartDecode();
};


#include <poppack.h> /* End byte packing */



#endif // _RVSTREAM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\rxstream.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    rxstream.h

Abstract:
	The RxStream class maintains a circular list of MediaPackets. RTP packets received
	from the network are put into the ring (PutNextNetIn), then decoded and removed from the
	ring when the time comes to play them (GetNextPlay). After playback, the packets are
	returned to the ring (Release).
	The ring is implemented as an array and under normal operation the index of the next 
	MediaPacket to play (m_PlayPos) advances by one when GetNextPlay is called.
--*/
#ifndef _RXSTREAM_H_
#define _RXSTREAM_H_

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#define MAX_RXRING_SIZE 64
#define MAX_RXVRING_SIZE 64

// these macros are for comparing timestamps that
// are within 2^31 of each other.
#define TS_EARLIER(A,B) ((signed) ((A)-(B)) < 0)
#define TS_LATER(A,B) ((signed) ((A)-(B)) > 0)


class RxStream {
public:
	RxStream(UINT size);
	virtual ~RxStream();
	virtual Initialize(UINT flags, UINT size, IRTPRecv *, MEDIAPACKETINIT *papi, ULONG ulSamplesPerPacket, ULONG ulSamplesPerSec, AcmFilter *pAcmFilter = NULL);
	virtual MediaPacket *GetNextPlay();
	MediaPacket *PeekPrevPlay();
	MediaPacket *PeekNextPlay();
	virtual void Release(MediaPacket *);
	virtual HRESULT PutNextNetIn(WSABUF *pNetBuf, DWORD timestamp, UINT seq, UINT fMark, BOOL *pfSkippedData, BOOL *pfSyncPoint);
	virtual BOOL ReleaseNetBuffers() {return FALSE;}
	HRESULT Reset(DWORD);
	virtual HRESULT SetLastGoodSeq(UINT seq);
	virtual HRESULT FastForward( BOOL fSilenceOnly);
	void SetRTP(IRTPRecv *pRTPRecv) {m_pRTP = pRTPRecv;}
	int IsEmpty() ;
	BOOL NextPlayablePacketTime(DWORD *pTS);
	UINT BufferDelay(void) { return m_MinDelayPos;}
	HRESULT GetSignalStrength(PDWORD pdw);
	void GetRing ( MediaPacket ***pppAudPckt, ULONG *puSize ) { *pppAudPckt = &m_Ring[0]; *puSize = (ULONG) m_RingSize; }
	virtual Destroy();

	void InjectBeeps(int nBeeps);

protected:
	DWORD m_dwFlags;
	IRTPRecv *m_pRTP;
	MediaPacket *m_Ring[MAX_RXRING_SIZE];
	BufferPool *m_pDecodeBufferPool;	// pool of free bufs
	UINT m_RingSize;            // Size of ring of MediaPackets. Initialized at 32.
	UINT m_PlayPos;             // Ring position of the packet to be played. Initialized to 0.
	DWORD m_PlayT;              // Timestamp of the packet to be played. Initialized to 0.
	UINT m_PlaySeq;             // Unused!!!
	UINT m_MaxPos;              // Maximum position in the ring of all the packets received so far. Initialized to 0. Equal to the position of the last packet received, unless this last packet is late.
	DWORD m_MaxT;               // Maximum timestamp of all the packets received so far. Initialized to 0. Equal to the timestamp of the last packet received, unless this last packet is late.
	UINT m_DelayPos;            // Current delay position with the maximum position in the ring of all the packets received so far. m_MinDelayPos <= m_DelayPos <= m_MaxDelayPos.
	UINT m_MinDelayPos;         // Minimum offset in position in the ring (delay) with the packet to be played. m_MinDelayPos <= m_DelayPos <= m_MaxDelayPos. Minimum value is 2. Initial value is m_SamplesPerSec/4/m_SamplesPerPkt == 250ms.
	UINT m_MaxDelayPos;         // Maximum offset in position in the ring (delay) with the packet to be played. m_MinDelayPos <= m_DelayPos <= m_MaxDelayPos. Minimum value is ???. Initial value is m_SamplesPerSec*3/4/m_SamplesPerPkt == 750ms.
	UINT m_FreePos;             // Maximum ring position of a free buffer. Initialized to m_RingSize - 1. Usually, m_FreePos == m_PlayPos - 1 or smaller if the buffer before m_PlayPos are still busy.
	DWORD m_SendT0;             // m_SendT0 is the send timestamp of the packet with the shortest trip delay. We could have just stored (m_ArrivalT0 - m_SendT0) but since the local and remote clocks are completely unsynchronized, there would be signed/unsigned complications.
	DWORD m_ArrivalT0;          // m_ArrivalT0 is the arrival timestamp of the packet with the shortest trip delay. We could have just stored (m_ArrivalT0 - m_SendT0) but since the local and remote clocks are completely unsynchronized, there would be signed/unsigned complications.
	LONG m_ScaledAvgVarDelay;   // Average Variable Delay according to m_ScaledAvgVarDelay = m_ScaledAvgVarDelay + (delay - m_ScaledAvgVarDelay/16). This is the m_DelayPos jitter.
	UINT m_SamplesPerPkt;       // Number of samples per audio packet. We're talking PCM samples here, even for compressed data. Initialized to 640. Usually worth several compressed audio frames.
	UINT m_SamplesPerSec;       // Sample rate, in samples per second (hertz), that each channel should be played or recorded. m_SamplesPerSec's initialization value is 8.0 kHz.
	CRITICAL_SECTION m_CritSect;
	UINT ModRing(UINT i) {return (i & (m_RingSize-1));}
	virtual void StartDecode(void);     // overrided in RVStream
	MediaPacket *GetNextDecode();
	void UpdateVariableDelay(DWORD sendT, DWORD arrT);
	DWORD MsToTimestamp(DWORD ms) {return ms*m_SamplesPerSec/1000;}	//BUGBUG: Chance of overflow?
	BOOL m_fPreamblePacket;
	AudioSilenceDetector m_AudioMonitor;
	UINT m_SilenceDurationT;

	AcmFilter *m_pAudioFilter;
	WAVEFORMATEX m_wfxSrc;
	WAVEFORMATEX m_wfxDst;

	int m_nBeeps;
};

#include <poppack.h> /* End byte packing */



#endif // _RXSTREAM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\rxstream.cpp ===
/*
	RXSTREAM.C
*/

#include "precomp.h"
extern UINT g_MinWaveAudioDelayMs;	// minimum millisecs of introduced playback delay
extern UINT g_MaxAudioDelayMs;	// maximum milliesecs of introduced playback delay


RxStream::RxStream(UINT size)
{
	UINT i;
	for (i =0; i < size; i++) {
		m_Ring[i] = NULL;
	}
	// initialize object critical section
	InitializeCriticalSection(&m_CritSect);
}

RxStream::~RxStream()
{
	DeleteCriticalSection(&m_CritSect);
}

RxStream::Initialize(
	UINT flags,
	UINT size,		// MB power of 2
	IRTPRecv *pRTP,
	MEDIAPACKETINIT *papi,
	ULONG ulSamplesPerPacket,
	ULONG ulSamplesPerSec,
	AcmFilter *pAcmFilter)  // this param may be NULL for video
{
	UINT i;
	MediaPacket *pAP;

	m_fPreamblePacket = TRUE;
	m_pDecodeBufferPool = NULL;

	m_RingSize = size;
	m_dwFlags = flags;
	if (flags & DP_FLAG_MMSYSTEM)
	{
		if (m_RingSize > MAX_RXRING_SIZE)
			return FALSE;
	}
	else if (flags & DP_FLAG_VIDEO)
	{
		if (m_RingSize > MAX_RXVRING_SIZE)
			return FALSE;
		if (!IsSameFormat (papi->pStrmConvSrcFmt, papi->pStrmConvDstFmt)) {
			// the video decode bufs are not allocated per MediaPacket object.
			// instead we use a BufferPool with a few buffers.
			papi->fDontAllocRawBufs = TRUE;

            DBG_SAVE_FILE_LINE
			m_pDecodeBufferPool = new BufferPool;
			// Three seems to be the minimum number of frame bufs 
			// One is being rendered and at least two are needed
			// so the rendering can catch up with the received frames
			// (another alternative is to dump frames to catch up)
			if (m_pDecodeBufferPool->Initialize(3,
				sizeof(NETBUF)+papi->cbSizeRawData + papi->cbOffsetRawData) != S_OK)
			{
				DEBUGMSG(ZONE_DP,("Couldnt initialize decode bufpool!\n"));
				delete m_pDecodeBufferPool;
				m_pDecodeBufferPool = NULL;
				return FALSE;
			}
		}
	}

	m_pRTP = pRTP;

	for (i=0; i < m_RingSize; i++)
	{
		if (flags & DP_FLAG_MMSYSTEM)
        {
            DBG_SAVE_FILE_LINE
			pAP = new AudioPacket;
        }
		else if (flags & DP_FLAG_VIDEO)
        {
            DBG_SAVE_FILE_LINE
			pAP = new VideoPacket;
        }
		m_Ring[i] = pAP;
		papi->index = i;
		if (!pAP || pAP->Initialize(papi) != DPR_SUCCESS)
			break;
	}
	if (i < m_RingSize)
	{
		for (UINT j=0; j<=i; j++)
		{
			if (m_Ring[j]) {
				m_Ring[j]->Release();
				delete m_Ring[j];
			}
		}
		return FALSE;
	}


	m_SamplesPerPkt = ulSamplesPerPacket;
	m_SamplesPerSec  = ulSamplesPerSec;
	// initialize pointers
	m_PlaySeq = 0;
	m_PlayT = 0;
	m_MaxT = m_PlayT - 1; // m_MaxT < m_PlayT indicates queue is empty
	m_MaxPos = 0;
	m_PlayPos = 0;
	m_FreePos = m_RingSize - 1;
	m_MinDelayPos = m_SamplesPerSec*g_MinWaveAudioDelayMs/1000/m_SamplesPerPkt;	//  fixed 250 ms delay
	if (m_MinDelayPos < 3) m_MinDelayPos = 3;
	
	m_MaxDelayPos = m_SamplesPerSec*g_MaxAudioDelayMs/1000/m_SamplesPerPkt;	//fixed 750 ms delay
	m_DelayPos = m_MinDelayPos;
	m_ScaledAvgVarDelay = 0;
	m_SilenceDurationT = 0;
	//m_DeltaT = MAX_TIMESTAMP;

	m_pAudioFilter = pAcmFilter;

	// go ahead and cache the WAVEFORMATEX structures
	// it's handy to have around
	if (m_dwFlags & DP_FLAG_AUDIO)
	{
		m_wfxSrc = *(WAVEFORMATEX*)(papi->pStrmConvSrcFmt);
		m_wfxDst = *(WAVEFORMATEX*)(papi->pStrmConvDstFmt);
	}
	m_nBeeps = 0;

	return TRUE;
}

#define PLAYOUT_DELAY_FACTOR	2
void RxStream::UpdateVariableDelay(DWORD sendT, DWORD arrT)
{
	LONG deltaA, deltaS;
	DWORD delay,delayPos;
// m_ArrivalT0 and m_SendT0 are the arrival and send timestamps of the packet
// with the shortest trip delay. We could have just stored (m_ArrivalT0 - m_SendT0)
// but since the local and remote clocks are completely unsynchronized, there would
// be signed/unsigned complications.
	deltaS = sendT - m_SendT0;
	deltaA = arrT - m_ArrivalT0;
	
	if (deltaA < deltaS)	{
		// this packet took less time
		delay = deltaS - deltaA;
		// replace shortest trip delay times
		m_SendT0 = sendT;
		m_ArrivalT0 = arrT;
	} else {
		// variable delay is how much longer this packet took
		delay = deltaA - deltaS;
	}
	// update average variable delay according to
	// m_AvgVarDelay = m_AvgVarDelay + (delay - m_AvgVarDelay)*1/16;
	// however we are storing the scaled average, with a scaling
	// factor of 16. So the calculation becomes
	m_ScaledAvgVarDelay = m_ScaledAvgVarDelay + (delay - m_ScaledAvgVarDelay/16);
	// now calculate delayPos
	delayPos = m_MinDelayPos + PLAYOUT_DELAY_FACTOR * m_ScaledAvgVarDelay/16/m_SamplesPerPkt;
	if (delayPos >= m_MaxDelayPos) delayPos = m_MaxDelayPos;

	LOG((LOGMSG_JITTER,delay, m_ScaledAvgVarDelay/16, delayPos));
	if (m_DelayPos != delayPos) {
		DEBUGMSG(ZONE_VERBOSE,("Changing m_DelayPos from %d to %d\n",m_DelayPos, delayPos));
		m_DelayPos = delayPos;
	}

	UPDATE_COUNTER(g_pctrAudioJBDelay, m_DelayPos*(m_SamplesPerPkt*1000)/m_SamplesPerSec);
}

// This function is only used for audio packets
HRESULT
RxStream::PutNextNetIn(WSABUF *pWsaBuf, DWORD timestamp, UINT seq, UINT fMark, BOOL *pfSkippedData, BOOL *pfSyncPoint)
{
	DWORD deltaTicks;
	MediaPacket *pAP;
	HRESULT hr;
	UINT samples;
	NETBUF netbuf;
	
	netbuf.data = (PBYTE) pWsaBuf->buf + sizeof(RTP_HDR);
	netbuf.length = pWsaBuf->len - sizeof(RTP_HDR);
	
	EnterCriticalSection(&m_CritSect);

	deltaTicks = (timestamp - m_PlayT)/m_SamplesPerPkt;
	
	if (deltaTicks > ModRing(m_FreePos - m_PlayPos)) {
	// the packet is too late or packet overrun
	// if the timestamp is earlier than the max. received so far
	// then reject it if there are packets queued up
		if (TS_EARLIER(timestamp, m_MaxT) && !IsEmpty()) {
			hr = DPR_LATE_PACKET;				// deltaTicks is -ve
			goto ErrorExit;
		}
		// restart the receive stream with this packet
		Reset(timestamp);
		m_SendT0 = timestamp;
		m_ArrivalT0 = MsToTimestamp(timeGetTime());
		deltaTicks = (timestamp - m_PlayT)/m_SamplesPerPkt;

	}

	// insert into ring
	pAP = m_Ring[ModRing(m_PlayPos+deltaTicks)];
	if (pAP->Busy() || pAP->GetState() != MP_STATE_RESET) {
		hr = DPR_DUPLICATE_PACKET;
		goto ErrorExit;
	}
	
	// update number of bits received
	UPDATE_COUNTER(g_pctrAudioReceiveBytes,(netbuf.length + sizeof(RTP_HDR) + IP_HEADER_SIZE + UDP_HEADER_SIZE)*8);

	hr = pAP->Receive(&netbuf, timestamp, seq, fMark);
	if (hr != DPR_SUCCESS)
		goto ErrorExit;
		
//	m_pRTP->FreePacket(pWsaBuf);	// return the buffer to RTP
	
	if (TS_LATER(timestamp, m_MaxT)) { // timestamp > m_MaxT
		if (timestamp - m_MaxT > m_SamplesPerPkt * 4) {
			// probably beginning of talkspurt - reset minimum delay timestamps
			// Note: we should use the Mark flag in RTP header to detect this
			m_SendT0 = timestamp;
			m_ArrivalT0 = MsToTimestamp(timeGetTime());
		}
		m_MaxT = timestamp;
		m_MaxPos = ModRing(m_PlayPos + deltaTicks);
	}
	// Calculate variable delay (sort of jitter)
	UpdateVariableDelay(timestamp, MsToTimestamp(timeGetTime()));

	LeaveCriticalSection(&m_CritSect);
	StartDecode();

	// Some implementations packetize audio in smaller chunks than they negotiated 
	// We deal with this by checking the length of the decoded packet and change
	// the constant m_SamplesPerPkt. Hopefully this will only happen once per session
	// (and never for NM-to-NM calls). Randomly varying packet sizes are still going
	// to sound lousy, because the recv queue management has the implicit assumption
	// that all packets (at least those in the queue) have the same length
	if (pAP->GetState() == MP_STATE_DECODED && (samples = pAP->GetDevDataSamples())) {
		if (samples != m_SamplesPerPkt) {
			// we're getting different sized (typically smaller) packets than we expected
			DEBUGMSG(ZONE_DP,("Changing SamplesPerPkt from %d to %d\n",m_SamplesPerPkt, samples));
			m_SamplesPerPkt = samples;
			m_MinDelayPos = m_SamplesPerSec*g_MinWaveAudioDelayMs/1000/m_SamplesPerPkt;	//  fixed 250 ms delay
			if (m_MinDelayPos < 2) m_MinDelayPos = 2;
			
			m_MaxDelayPos = m_SamplesPerSec*g_MaxAudioDelayMs/1000/m_SamplesPerPkt;	//fixed 750 ms delay
		}
	}
	return DPR_SUCCESS;
ErrorExit:
//	m_pRTP->FreePacket(pWsaBuf);
	LeaveCriticalSection(&m_CritSect);
	return hr;

}

// called when restarting after a pause (fSilenceOnly == FALSE) or
// to catch up when latency is getting too much (fSilenceOnly == TRUE)
// determine new play position by skipping any
// stale packets
HRESULT RxStream::FastForward( BOOL fSilenceOnly)
{
	UINT pos;
	DWORD timestamp = 0;
	// restart the receive stream
	EnterCriticalSection(&m_CritSect);
	if (!TS_EARLIER(m_MaxT ,m_PlayT)) {
		// there are buffers waiting to be played
		// dump them!
		if (ModRing(m_MaxPos - m_PlayPos) <= m_DelayPos)
			goto Exit;	// not too many stale packets
		for (pos=m_PlayPos;pos != ModRing(m_MaxPos -m_DelayPos);pos = ModRing(pos+1)) {
			if (m_Ring[pos]->Busy()
				|| (m_Ring[pos]->GetState() != MP_STATE_RESET
					&& (fSilenceOnly ||ModRing(m_MaxPos-pos) <= m_MaxDelayPos)))
			{	// non-empty packet
				if (m_Ring[pos]->Busy())	// uncommon case
					goto Exit;	// bailing out
				timestamp =m_Ring[pos]->GetTimestamp();
				break;
			}
			m_Ring[pos]->Recycle();	// free NETBUF and Reset state
			LOG((LOGMSG_RX_SKIP,pos));
		}
		if (timestamp)	// starting from non-empty packet
			m_PlayT = timestamp;
		else			// starting from (possibly) empty packet
			m_PlayT = m_MaxT - m_DelayPos*m_SamplesPerPkt;

		// probably also need to update FreePos
		if (m_FreePos == ModRing(m_PlayPos-1))
			m_FreePos = ModRing(pos-1);
		m_PlayPos = pos;
		/*
		if (pos == ModRing(m_MaxPos+1)) {
			DEBUGMSG(1,("Reset:: m_MaxT inconsisten!\n"));
		}
		*/

		LOG((LOGMSG_RX_RESET2,m_MaxT,m_PlayT,m_PlayPos));
	}
Exit:
	LeaveCriticalSection(&m_CritSect);
	return DPR_SUCCESS;
}


HRESULT
RxStream::Reset(DWORD timestamp)
{
	UINT pos;
	DWORD T;
	// restart the receive stream
	EnterCriticalSection(&m_CritSect);
	LOG((LOGMSG_RX_RESET,m_MaxT,m_PlayT,m_PlayPos));
	if (!TS_EARLIER(m_MaxT, m_PlayT)) {
		// there are buffers waiting to be played
		// dump them!
		// Empty the RxStream and set PlayT appropriately
		for (pos = m_PlayPos;
			pos != ModRing(m_PlayPos-1);
			pos = ModRing(pos+1))
			{
			if (m_Ring[pos]->Busy ())
			{
				ERRORMESSAGE(("RxStream::Reset: packet is busy, pos=%d\r\n", pos));
				ASSERT(1);
			}
			T = m_Ring[pos]->GetTimestamp();
			m_Ring[pos]->Recycle();	// free NETBUF and Reset state
			if (T == m_MaxT)
				break;
		}
	}
	if (timestamp !=0)
		m_PlayT = timestamp - m_DelayPos*m_SamplesPerPkt;
	m_MaxT = m_PlayT - 1;	// max must be less than play

	LOG((LOGMSG_RX_RESET2,m_MaxT,m_PlayT,m_PlayPos));
	LeaveCriticalSection(&m_CritSect);
	return DPR_SUCCESS;		
}

BOOL RxStream::IsEmpty()
{
	BOOL fEmpty;

	EnterCriticalSection(&m_CritSect);
	if (TS_EARLIER(m_MaxT, m_PlayT) || m_RingSize == 0) 
		fEmpty = TRUE;
	else if (m_dwFlags & DP_FLAG_AUTO_SILENCE_DETECT)
	{
		UINT pos;
		// we could have received packets that
		// are deemed silent. Walk the packets between
		// PlayPos and MaxPos and check if they're all empty
		pos = m_PlayPos;
		fEmpty = TRUE;
		do {
			if (m_Ring[pos]->Busy() || (m_Ring[pos]->GetState() != MP_STATE_RESET ))
			{
				fEmpty = FALSE; // no point scanning further
				break;
			}
			pos = ModRing(pos+1);
		} while (pos != ModRing(m_MaxPos+1));
		
	}
	else 
	{
	// not doing receive silence detection
	// every received packet counts
		fEmpty = FALSE;
	}
	LeaveCriticalSection(&m_CritSect);
	return fEmpty;
}

void RxStream::StartDecode()
{
	MediaPacket *pAP;
	MMRESULT mmr;

	// if we have a separate decode thread this will signal it.
	// for now we insert the decode loop here
	while (pAP = GetNextDecode())
	{
//		if (pAP->Decode() != DPR_SUCCESS)
//		{
//			pAP->Recycle();
//		}

		mmr = m_pAudioFilter->Convert((AudioPacket *)pAP, AP_DECODE);
		if (mmr != MMSYSERR_NOERROR)
		{
			pAP->Recycle();
		}


		else
		{
			pAP->SetState(MP_STATE_DECODED);

			if (m_dwFlags & DP_FLAG_AUTO_SILENCE_DETECT) {
	    // dont play the packet if we have received at least a quarter second of silent packets.
	    // This will enable switch to talk (in half-duplex mode).
				DWORD dw;
				pAP->GetSignalStrength(&dw);
				if (m_AudioMonitor.SilenceDetect((WORD)dw)) {
					m_SilenceDurationT += m_SamplesPerPkt;
					if (m_SilenceDurationT > m_SamplesPerSec/4)
						pAP->Recycle();
				} else {
					m_SilenceDurationT = 0;
				}
			}
		}
		Release(pAP);
	}
}

MediaPacket *RxStream::GetNextDecode(void)
{
	MediaPacket *pAP = NULL;
	UINT pos;
	NETBUF *pBuf;
	EnterCriticalSection(&m_CritSect);
	// do we have any packets in the queue
	if (! TS_EARLIER(m_MaxT , m_PlayT)) {
		pos = m_PlayPos;
		do {
			if (!m_Ring[pos]->Busy() && m_Ring[pos]->GetState() == MP_STATE_NET_IN_STREAM ) {
				if (m_pDecodeBufferPool) {
					// MediaPacket needs to be given a decode buffer
					if ( pBuf = (NETBUF *)m_pDecodeBufferPool->GetBuffer()) {
						// init the buffer
						pBuf->pool = m_pDecodeBufferPool;
						pBuf->length = m_pDecodeBufferPool->GetMaxBufferSize()-sizeof(NETBUF);
						pBuf->data = (PBYTE)(pBuf + 1);
						m_Ring[pos]->SetDecodeBuffer(pBuf);
					} else {
						break;	// no buffers available
					}
				}
				pAP = m_Ring[pos];
				pAP->Busy(TRUE);
				break;
			}
			pos = ModRing(pos+1);
		} while (pos != ModRing(m_MaxPos+1));
	}
	
	LeaveCriticalSection(&m_CritSect);
	return pAP;
}

MediaPacket *RxStream::GetNextPlay(void)
{
	MediaPacket *pAP = NULL;
	UINT pos;
	EnterCriticalSection(&m_CritSect);


	pAP = m_Ring[m_PlayPos];
	if (pAP->Busy() || (pAP->GetState() != MP_STATE_RESET && pAP->GetState() != MP_STATE_DECODED)) {
		// bad - the next packet is not decoded yet
		pos = ModRing(m_FreePos-1);
		if (pos != m_PlayPos && !m_Ring[m_FreePos]->Busy()
			&& m_Ring[m_FreePos]->GetState() == MP_STATE_RESET) {
			// give an empty buffer from the end
			pAP = m_Ring[m_FreePos];
			m_FreePos = pos;
		} else {
			// worse - no free packets
			// this can only happen if packets are not released
			// or we-re backed up all the way with new packets
			// Reset?
			LeaveCriticalSection(&m_CritSect);
			return NULL;
		}
	} else {
	// If there are empty buffer(s) at the head of the q followed
	// by  a talkspurt (non-empty buffers) and if the talkspurt is excessively
	// delayed then squeeze out the silence.
	//
		if (pAP->GetState() == MP_STATE_RESET)
			FastForward(TRUE);	// skip silence packets if necessary
		pAP = m_Ring[m_PlayPos];	// in case the play position changed
	}

	if (pAP->GetState() == MP_STATE_RESET) {
		// give missing packets a timestamp
		pAP->SetProp(MP_PROP_TIMESTAMP,m_PlayT);
	}
	pAP->Busy(TRUE);
	m_PlayPos = ModRing(m_PlayPos+1);
	m_PlayT += m_SamplesPerPkt;


	// the worst hack in all of NAC.DLL - the injection of the 
	// DTMF "feedback tone".  Clearly, this waveout stream stuff needs
	// to be rewritten!
	if (m_nBeeps > 0)
	{
		PVOID pBuffer=NULL;
		UINT uSize=0;
		WAVEFORMATEX wfx;

		if ((pAP) && (m_dwFlags & DP_FLAG_AUDIO))
		{
			pAP->GetDevData(&pBuffer, &uSize);
			if (pBuffer)
			{
				MakeDTMFBeep(&m_wfxDst, (PBYTE)pBuffer, uSize);
				pAP->SetState(MP_STATE_DECODED);
				pAP->SetRawActual(uSize);
			}
		}

		m_nBeeps--;
	}


	LeaveCriticalSection(&m_CritSect);
	return pAP;
}



void RxStream::InjectBeeps(int nBeeps)
{
	EnterCriticalSection(&m_CritSect);

	m_nBeeps = nBeeps;

	LeaveCriticalSection(&m_CritSect);

}

/*************************************************************************

	Function:	PeekPrevPlay(void)

	Purpose :	Get previous audio packet played back.

	Returns :	Pointer to that packet.

	Params  :	None.

	Comments:

	History :	Date		Reason

				06/02/96	Created - PhilF

*************************************************************************/
MediaPacket *RxStream::PeekPrevPlay(void)
{
	MediaPacket *pAP = NULL;
	EnterCriticalSection(&m_CritSect);

	// Get packet previously scheduled for playback from the ring
	pAP = m_Ring[ModRing(m_PlayPos+m_RingSize-2)];

	LeaveCriticalSection(&m_CritSect);
	return pAP;
}

/*************************************************************************

	Function:	PeekNextPlay(void)

	Purpose :	Get next next audio packet to be played.

	Returns :	Pointer to that packet.

	Params  :	None.

	Comments:

	History :	Date		Reason

				06/02/96	Created - PhilF

*************************************************************************/
MediaPacket *RxStream::PeekNextPlay(void)
{
	MediaPacket *pAP = NULL;
	EnterCriticalSection(&m_CritSect);

	// Get packet next scheduled for playback from the ring
	pAP = m_Ring[ModRing(m_PlayPos)];

	LeaveCriticalSection(&m_CritSect);
	return pAP;
}

HRESULT RxStream::GetSignalStrength(PDWORD pdw)
{
	MediaPacket *pAP;
	EnterCriticalSection(&m_CritSect);
	pAP = m_Ring[m_PlayPos];
	if (!pAP || pAP->Busy() || pAP->GetState() != MP_STATE_DECODED)
		*pdw = 0;
	else {
		pAP->GetSignalStrength(pdw);
	}
	LeaveCriticalSection(&m_CritSect);
	return DPR_SUCCESS;
}

// Scan thru the ring, looking for the next
// decoded packet and report its RTP timestamp
BOOL RxStream::NextPlayablePacketTime(DWORD *pTS)	
{
	UINT pos;
	if (IsEmpty())
		return FALSE;
	pos = m_PlayPos;
	do {
		if (m_Ring[pos]->Busy())
			return FALSE; // no point scanning further
		if (m_Ring[pos]->GetState() == MP_STATE_DECODED ) {
			*pTS = m_Ring[pos]->GetTimestamp();
			return TRUE;
		}
		pos = ModRing(pos+1);
	} while (pos != ModRing(m_MaxPos+1));
	// no decoded packets
	return FALSE;
}

void RxStream::Release(MediaPacket *pAP)
{
	UINT pos;
	DWORD thisPos;

	DWORD T;
	EnterCriticalSection(&m_CritSect);
	if (pAP->GetState() == MP_STATE_DECODED) {
		// if its playout time has pAPt reset it
		T = pAP->GetTimestamp();
		if (TS_EARLIER(T ,m_PlayT)) {
			pAP->MakeSilence();
		}
	}
	pAP->Busy(FALSE);
	// Advance the free position if we are freeing the next one
	pos = ModRing(m_FreePos+1);
	thisPos = pAP->GetIndex();
	if (pos == thisPos) {
		// Releasing one packet may advance FreePos several
		while (pos != m_PlayPos && !m_Ring[pos]->Busy()) {
			m_FreePos = pos;
			pos = ModRing(pos+1);
		}
	}
	
	LeaveCriticalSection(&m_CritSect);
}

HRESULT
RxStream::SetLastGoodSeq(UINT seq)
{
	return DPR_SUCCESS;
}


RxStream::Destroy(void)
{
	UINT i;
	EnterCriticalSection(&m_CritSect);
	for (i=0; i < m_RingSize; i++) {
		if (m_Ring[i]) {
			m_Ring[i]->Release();
			delete m_Ring[i];
			m_Ring[i] = NULL;
		}
	}
	m_RingSize = 0;

	if (m_pDecodeBufferPool) {
		delete m_pDecodeBufferPool;
		m_pDecodeBufferPool = NULL;
	}
	LeaveCriticalSection(&m_CritSect);
	return DPR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\sendaudio.cpp ===
#include "precomp.h"
#include "dtmf.h"


HRESULT
SendAudioStream::Initialize( DataPump *pDP)
{
	HRESULT hr = DPR_OUT_OF_MEMORY;
	DWORD dwFlags =  DP_FLAG_FULL_DUPLEX | DP_FLAG_AUTO_SWITCH ;
	MEDIACTRLINIT mcInit;
	FX_ENTRY ("SendAudioStream::Initialize")

	dwFlags |= DP_FLAG_ACM | DP_FLAG_MMSYSTEM | DP_FLAG_AUTO_SILENCE_DETECT;

	// store the platform flags
	// enable Send and Recv by default
	m_DPFlags = (dwFlags & DP_MASK_PLATFORM) | DPFLAG_ENABLE_SEND;
	// store a back pointer to the datapump container
	m_pDP = pDP;

	m_Net = NULL; // this object (RTPSession) no longer used;
	m_pRTPSend = NULL;  // replaced with this object (RTPSend)

	// Initialize data (should be in constructor)
	m_CaptureDevice = (UINT) -1;	// use VIDEO_MAPPER



	// Create and Transmit audio streams
	
    DBG_SAVE_FILE_LINE
	m_SendStream = new TxStream();
	if ( !m_SendStream)
	{
		DEBUGMSG (ZONE_DP, ("%s: TxStream new failed\r\n", _fx_));
 		goto StreamAllocError;
	}


	// Create Input and Output audio filters
    DBG_SAVE_FILE_LINE
	m_pAudioFilter = new AcmFilter();  // audio filter will replace m_SendFilter
	if (!m_pAudioFilter)
	{
		DEBUGMSG (ZONE_DP, ("%s: FilterManager new failed\r\n", _fx_));
		goto FilterAllocError;
	}
	
	//Create MultiMedia device control objects
    DBG_SAVE_FILE_LINE
	m_InMedia = new WaveInControl();
	if (!m_InMedia )
	{
		DEBUGMSG (ZONE_DP, ("%s: MediaControl new failed\r\n", _fx_));
		goto MediaAllocError;
	}

	// Initialize the send-stream media control object
	mcInit.dwFlags = dwFlags | DP_FLAG_SEND;
	hr = m_InMedia->Initialize(&mcInit);
	if (hr != DPR_SUCCESS)
	{
		DEBUGMSG (ZONE_DP, ("%s: IMedia->Init failed, hr=0x%lX\r\n", _fx_, hr));
		goto MediaAllocError;
	}

    DBG_SAVE_FILE_LINE
	m_pDTMF = new DTMFQueue;
	if (!m_pDTMF)
	{
		return DPR_OUT_OF_MEMORY;
	}



	// determine if the wave devices are available
	if (waveInGetNumDevs()) m_DPFlags |= DP_FLAG_RECORD_CAP;
	
	// set media to half duplex mode by default
	m_InMedia->SetProp(MC_PROP_DUPLEX_TYPE, DP_FLAG_HALF_DUPLEX);

	m_SavedTickCount = timeGetTime();	//so we start with low timestamps
	m_DPFlags |= DPFLAG_INITIALIZED;

	m_bAutoMix = FALSE; // where else do you initialize this ?

	return DPR_SUCCESS;


MediaAllocError:
	if (m_InMedia) delete m_InMedia;
FilterAllocError:
	if (m_pAudioFilter) delete m_pAudioFilter;
StreamAllocError:
	if (m_SendStream) delete m_SendStream;

	ERRORMESSAGE( ("%s: exit, hr=0x%lX\r\n", _fx_, hr));

	return hr;
}


SendAudioStream::~SendAudioStream()
{

	if (m_DPFlags & DPFLAG_INITIALIZED) {
		m_DPFlags &= ~DPFLAG_INITIALIZED;
	
		if (m_DPFlags & DPFLAG_CONFIGURED_SEND )
			UnConfigure();

		if (m_pRTPSend)
		{
			m_pRTPSend->Release();
			m_pRTPSend = NULL;
		}

		if (m_pDTMF)
		{
			delete m_pDTMF;
			m_pDTMF = NULL;
		}

		// Close the receive and transmit streams
		if (m_SendStream) delete m_SendStream;

		// Close the wave devices
		if (m_InMedia) { delete m_InMedia;}


		if (m_pAudioFilter)
			delete m_pAudioFilter;

		m_pDP->RemoveMediaChannel(MCF_SEND|MCF_AUDIO, (IMediaChannel*)(SendMediaStream*)this);
	}
}


HRESULT STDMETHODCALLTYPE SendAudioStream::QueryInterface(REFIID iid, void **ppVoid)
{
	// resolve duplicate inheritance to the SendMediaStream;

	extern IID IID_IProperty;

	if (iid == IID_IUnknown)
	{
		*ppVoid = (IUnknown*)((SendMediaStream*)this);
	}
	else if (iid == IID_IMediaChannel)
	{
		*ppVoid = (IMediaChannel*)((SendMediaStream *)this);
	}
	else if (iid == IID_IAudioChannel)
	{
		*ppVoid = (IAudioChannel*)this;
	}
	else if (iid == IID_IDTMFSend)
	{
		*ppVoid = (IDTMFSend*)this;
	}
	else if (iid == IID_IProperty)
	{
		*ppVoid = NULL;
		ERROR_OUT(("Don't QueryInterface for IID_IProperty, use IMediaChannel"));
		return E_NOINTERFACE;
	}
	else
	{
		*ppVoid = NULL;
		return E_NOINTERFACE;
	}
	AddRef();

	return S_OK;

}

ULONG STDMETHODCALLTYPE SendAudioStream::AddRef(void)
{
	return InterlockedIncrement(&m_lRefCount);
}

ULONG STDMETHODCALLTYPE SendAudioStream::Release(void)
{
	LONG lRet;

	lRet = InterlockedDecrement(&m_lRefCount);

	if (lRet == 0)
	{
		delete this;
		return 0;
	}

	else
		return lRet;

}



	
HRESULT STDMETHODCALLTYPE SendAudioStream::Configure(
	BYTE *pFormat,
	UINT cbFormat,
	BYTE *pChannelParams,
	UINT cbParams,
	IUnknown *pUnknown)
{
	HRESULT hr;
	BOOL fRet;
	MEDIAPACKETINIT apInit;
	MEDIACTRLCONFIG mcConfig;
	MediaPacket **ppAudPckt;
	ULONG cAudPckt;
	DWORD_PTR dwPropVal;
    DWORD dwSourceSize, dwDestSize;
	UINT ringSize = MAX_RXRING_SIZE;
	WAVEFORMATEX *pwfSend;
	DWORD dwPacketDuration, dwPacketSize;
	AUDIO_CHANNEL_PARAMETERS audChannelParams;
	audChannelParams.RTP_Payload = 0;
	MMRESULT mmr;
	int nIndex;
	
	FX_ENTRY ("SendAudioStream::Configure")

	// basic parameter checking
	if (! (m_DPFlags & DPFLAG_INITIALIZED))
		return DPR_OUT_OF_MEMORY;		//BUGBUG: return proper error;

	// Not a good idea to change anything while in mid-stream
	if (m_DPFlags & DPFLAG_STARTED_SEND)
	{
		return DPR_IO_PENDING; // anything better to return
	}

	if (m_DPFlags & DPFLAG_CONFIGURED_SEND)
	{
		DEBUGMSG(ZONE_DP, ("Stream Re-Configuration - calling UnConfigure"));
		UnConfigure();
	}


	if ((NULL == pFormat) || (NULL == pChannelParams) ||
		(cbParams < sizeof(AUDIO_CHANNEL_PARAMETERS)) ||
		(cbFormat < sizeof(WAVEFORMATEX)))
	{
		return DPR_INVALID_PARAMETER;
	}

	audChannelParams = *(AUDIO_CHANNEL_PARAMETERS *)pChannelParams;
	pwfSend = (WAVEFORMATEX *)pFormat;
	m_wfCompressed = *pwfSend;
	m_wfCompressed.cbSize = 0;

	mmr = AcmFilter::SuggestDecodeFormat(pwfSend, &m_fDevSend);

	UPDATE_REPORT_ENTRY(g_prptCallParameters, pwfSend->wFormatTag, REP_SEND_AUDIO_FORMAT);
	UPDATE_REPORT_ENTRY(g_prptCallParameters, pwfSend->nSamplesPerSec, REP_SEND_AUDIO_SAMPLING);
	UPDATE_REPORT_ENTRY(g_prptCallParameters, pwfSend->nAvgBytesPerSec * 8, REP_SEND_AUDIO_BITRATE);
	RETAILMSG(("NAC: Audio Send Format: %s", (pwfSend->wFormatTag == 66) ? "G723.1" : (pwfSend->wFormatTag == 112) ? "LHCELP" : (pwfSend->wFormatTag == 113) ? "LHSB08" : (pwfSend->wFormatTag == 114) ? "LHSB12" : (pwfSend->wFormatTag == 115) ? "LHSB16" : (pwfSend->wFormatTag == 6) ? "MSALAW" : (pwfSend->wFormatTag == 7) ? "MSULAW" : (pwfSend->wFormatTag == 130) ? "MSRT24" : "??????"));
	RETAILMSG(("NAC: Audio Send Sampling Rate (Hz): %ld", pwfSend->nSamplesPerSec));
	RETAILMSG(("NAC: Audio Send Bitrate (w/o network overhead - bps): %ld", pwfSend->nAvgBytesPerSec*8));

// Initialize the send-stream media control object
	mcConfig.uDuration = MC_USING_DEFAULT;	// set duration by samples per pkt
	mcConfig.pDevFmt = &m_fDevSend;
	mcConfig.hStrm = (DPHANDLE) m_SendStream;
	mcConfig.uDevId = m_CaptureDevice;
	mcConfig.cbSamplesPerPkt = audChannelParams.ns_params.wFrameSize
		*audChannelParams.ns_params.wFramesPerPkt;

	UPDATE_REPORT_ENTRY(g_prptCallParameters, mcConfig.cbSamplesPerPkt, REP_SEND_AUDIO_PACKET);
	RETAILMSG(("NAC: Audio Send Packetization (ms/packet): %ld", pwfSend->nSamplesPerSec ? mcConfig.cbSamplesPerPkt * 1000UL / pwfSend->nSamplesPerSec : 0));
	INIT_COUNTER_MAX(g_pctrAudioSendBytes, (pwfSend->nAvgBytesPerSec + pwfSend->nSamplesPerSec * (sizeof(RTP_HDR) + IP_HEADER_SIZE + UDP_HEADER_SIZE) / mcConfig.cbSamplesPerPkt) << 3);

	hr = m_InMedia->Configure(&mcConfig);
	if (hr != DPR_SUCCESS)
	{
		DEBUGMSG (ZONE_DP, ("%s: IMedia->Config failed, hr=0x%lX\r\n", _fx_, hr));
		goto IMediaInitError;
	}

	
	// initialize the ACM filter
	mmr = m_pAudioFilter->Open(&m_fDevSend, pwfSend);
	if (mmr != 0)
	{
		DEBUGMSG (ZONE_DP, ("%s: AcmFilter->Open failed, mmr=%d\r\n", _fx_, mmr));
		hr = DPR_CANT_OPEN_CODEC;
		goto SendFilterInitError;
	}


	// Initialize the send stream and the packets
	ZeroMemory (&apInit, sizeof (apInit));

	apInit.dwFlags = DP_FLAG_SEND | DP_FLAG_ACM | DP_FLAG_MMSYSTEM;
	m_InMedia->FillMediaPacketInit (&apInit);

	m_InMedia->GetProp (MC_PROP_SIZE, &dwPropVal);
    dwSourceSize = (DWORD)dwPropVal;

	m_pAudioFilter->SuggestDstSize(dwSourceSize, &dwDestSize);

	apInit.cbSizeRawData = dwSourceSize;
	apInit.cbOffsetRawData = 0;
	apInit.cbSizeNetData = dwDestSize;
	dwPacketSize = dwDestSize;

	apInit.pStrmConvSrcFmt = &m_fDevSend;
	apInit.pStrmConvDstFmt = &m_wfCompressed;


	m_InMedia->GetProp (MC_PROP_DURATION, &dwPropVal);
    dwPacketDuration = (DWORD)dwPropVal;

	apInit.cbOffsetNetData = sizeof (RTP_HDR);
	apInit.payload = audChannelParams.RTP_Payload;
	fRet = m_SendStream->Initialize (DP_FLAG_MMSYSTEM, MAX_TXRING_SIZE, m_pDP, &apInit);
	if (! fRet)
	{
		DEBUGMSG (ZONE_DP, ("%s: TxStream->Init failed, fRet=0%u\r\n", _fx_, fRet));
		hr = DPR_CANT_INIT_TX_STREAM;
		goto TxStreamInitError;
	}

	// prepare headers for TxStream
	m_SendStream->GetRing (&ppAudPckt, &cAudPckt);
	m_InMedia->RegisterData (ppAudPckt, cAudPckt);
	m_InMedia->PrepareHeaders ();

	m_pAudioFilter->PrepareAudioPackets((AudioPacket**)ppAudPckt, cAudPckt, AP_ENCODE);

	// Open the play from wav file
	OpenSrcFile();


	// Initialize DTMF support
	m_pDTMF->Initialize(&m_fDevSend);
	m_pDTMF->ClearQueue();


	// WS2Qos will be called in Start to communicate stream reservations to the
	// remote endpoint using a RESV message
	//
	// We use a peak-rate allocation approach based on our target bitrates
	// Note that for the token bucket size and the maximum SDU size, we now
	// account for IP header overhead, and use the max frame fragment size
	// instead of the maximum compressed image size returned by the codec
	//
	// Some of the parameters are left unspecified because they are set
	// in the sender Tspec.


	InitAudioFlowspec(&m_flowspec, pwfSend, dwPacketSize);

	if (m_pDP->m_pIQoS)
	{
		// Initialize our requests. One for CPU usage, one for bandwidth usage.
		m_aRRq.cResourceRequests = 2;
		m_aRRq.aResourceRequest[0].resourceID = RESOURCE_OUTGOING_BANDWIDTH;
		if (dwPacketDuration)
			m_aRRq.aResourceRequest[0].nUnitsMin = (DWORD)(dwPacketSize + sizeof(RTP_HDR) + IP_HEADER_SIZE + UDP_HEADER_SIZE) * 8000 / dwPacketDuration;
		else
			m_aRRq.aResourceRequest[0].nUnitsMin = 0;
		m_aRRq.aResourceRequest[1].resourceID = RESOURCE_CPU_CYCLES;
		m_aRRq.aResourceRequest[1].nUnitsMin = 800;

/*
        BUGBUG. This is, in theory the correct calculation, but until we do more investigation, go with a known value

		m_aRRq.aResourceRequest[1].nUnitsMin = (audDetails.wCPUUtilizationEncode+audDetails.wCPUUtilizationDecode)*10;

*/
		// Initialize QoS structure
		ZeroMemory(&m_Stats, sizeof(m_Stats));

		// Initialize oldest QoS callback timestamp
		// Register with the QoS module. Even if this call fails, that's Ok, we'll do without the QoS support
		m_pDP->m_pIQoS->RequestResources((GUID *)&MEDIA_TYPE_H323AUDIO, (LPRESOURCEREQUESTLIST)&m_aRRq, QosNotifyAudioCB, (DWORD_PTR)this);
	}

	m_DPFlags |= DPFLAG_CONFIGURED_SEND;


	return DPR_SUCCESS;

TxStreamInitError:
SendFilterInitError:
	m_InMedia->Close();
	m_pAudioFilter->Close();
IMediaInitError:
	ERRORMESSAGE(("%s:  failed, hr=0%u\r\n", _fx_, hr));
	return hr;
}




void SendAudioStream::UnConfigure()
{
	AudioPacket **ppAudPckt;
	ULONG uPackets;


	if ((m_DPFlags & DPFLAG_CONFIGURED_SEND)) {
	
		if (m_hCapturingThread) {
			Stop();
		}
		
		// Close the wave devices
		m_InMedia->Reset();
		m_InMedia->UnprepareHeaders();
		m_InMedia->Close();
		// Close the play from wav file
		CloseSrcFile();

		// Close the filters
		m_SendStream->GetRing ((MediaPacket***)&ppAudPckt, &uPackets);
		m_pAudioFilter->UnPrepareAudioPackets(ppAudPckt, uPackets, AP_ENCODE);
		m_pAudioFilter->Close();

		// Close the transmit streams
		m_SendStream->Destroy();
		m_DPFlags &= ~DPFLAG_CONFIGURED_SEND;
		m_ThreadFlags = 0;  // invalidate previous call to SetMaxBitrate


		// Release the QoS Resources
		// If the associated RequestResources had failed, the ReleaseResources can be
		// still called... it will just come back without having freed anything.
		if (m_pDP->m_pIQoS)
		{
			m_pDP->m_pIQoS->ReleaseResources((GUID *)&MEDIA_TYPE_H323AUDIO, (LPRESOURCEREQUESTLIST)&m_aRRq);
		}
	}
}


DWORD CALLBACK SendAudioStream::StartRecordingThread (LPVOID pVoid)
{
	SendAudioStream *pThisStream = (SendAudioStream*)pVoid;
	return pThisStream->RecordingThread();
}




// LOOK: identical to SendVideoStream version.
HRESULT
SendAudioStream::Start()
{
	FX_ENTRY ("SendAudioStream::Start")
	if (m_DPFlags & DPFLAG_STARTED_SEND)
		return DPR_SUCCESS;
	// TODO: remove this check once audio UI calls the IComChan PAUSE_ prop
	if (!(m_DPFlags & DPFLAG_ENABLE_SEND))
		return DPR_SUCCESS;
	if ((!(m_DPFlags & DPFLAG_CONFIGURED_SEND)) || (m_pRTPSend==NULL))
		return DPR_NOT_CONFIGURED;
	ASSERT(!m_hCapturingThread);
	m_ThreadFlags &= ~(DPTFLAG_STOP_RECORD|DPTFLAG_STOP_SEND);

	SetFlowSpec();

	// Start recording thread
	if (!(m_ThreadFlags & DPTFLAG_STOP_RECORD))
		m_hCapturingThread = CreateThread(NULL,0, SendAudioStream::StartRecordingThread,(LPVOID)this,0,&m_CaptureThId);

	m_DPFlags |= DPFLAG_STARTED_SEND;

	DEBUGMSG (ZONE_DP, ("%s: Record threadid=%x,\r\n", _fx_, m_CaptureThId));
	return DPR_SUCCESS;
}

// LOOK: identical to SendVideoStream version.
HRESULT
SendAudioStream::Stop()
{											
	DWORD dwWait;

	if(!(m_DPFlags & DPFLAG_STARTED_SEND))
	{
		return DPR_SUCCESS;
	}
	
	m_ThreadFlags = m_ThreadFlags  |
		DPTFLAG_STOP_SEND |  DPTFLAG_STOP_RECORD ;

	if(m_SendStream)
		m_SendStream->Stop();
	
DEBUGMSG (ZONE_VERBOSE, ("STOP1: Waiting for record thread to exit\r\n"));

	/*
	 *	we want to wait for all the threads to exit, but we need to handle windows
	 *	messages (mostly from winsock) while waiting.
	 */

	if(m_hCapturingThread)
	{
		dwWait = WaitForSingleObject (m_hCapturingThread, INFINITE);

		DEBUGMSG (ZONE_VERBOSE, ("STOP2: Recording thread exited\r\n"));
		ASSERT(dwWait != WAIT_FAILED);
	
		CloseHandle(m_hCapturingThread);
		m_hCapturingThread = NULL;
	}
	m_DPFlags &= ~DPFLAG_STARTED_SEND;
	
	return DPR_SUCCESS;
}



// low order word is the signal strength
// high order work contains bits to indicate status
// (0x01 - transmitting)
// (0x02 - audio device is jammed)
STDMETHODIMP SendAudioStream::GetSignalLevel(UINT *pSignalStrength)
{
	UINT uLevel;
	DWORD dwJammed;
    DWORD_PTR dwPropVal;

	if(!(m_DPFlags & DPFLAG_STARTED_SEND))
	{
		uLevel = 0;
	}
	else
	{
		uLevel = m_AudioMonitor.GetSignalStrength();

		m_InMedia->GetProp(MC_PROP_AUDIO_JAMMED, &dwPropVal);
        dwJammed = (DWORD)dwPropVal;

		if (dwJammed)
		{
			uLevel = (2 << 16);  // 0x0200
		}
		else if (m_fSending)
		{
			uLevel |= (1 << 16); // 0x0100 + uLevel
		}
	}

	*pSignalStrength = uLevel;
	return S_OK;
};



// this interface method is primarily for H.245 flow control messages
// it will pause the stream if uMaxBitrate is less than the codec
// output bitrate.  Only valid on a Configure'd stream.
HRESULT STDMETHODCALLTYPE SendAudioStream::SetMaxBitrate(UINT uMaxBitrate)
{
	UINT uMinBitrate;
	
	if (!(m_DPFlags & DPFLAG_CONFIGURED_SEND))
	{
		return DPR_NOT_CONFIGURED;
	}

	uMinBitrate = 8 * m_wfCompressed.nAvgBytesPerSec;

	if (uMaxBitrate < uMinBitrate)
	{
		DEBUGMSG(1, ("SendAudioStream::SetMaxBitrate - PAUSING"));
		m_ThreadFlags |= DPTFLAG_PAUSE_SEND;
	}
	else
	{
		DEBUGMSG(1, ("SendAudioStream::SetMaxBitrate - UnPausing"));
		m_ThreadFlags = m_ThreadFlags & ~(DPTFLAG_PAUSE_SEND);
	}

	return S_OK;
}

//  IProperty::GetProperty / SetProperty
//  (DataPump::MediaChannel::GetProperty)
//      Properties of the MediaChannel. Supports properties for both audio
//      and video channels.

STDMETHODIMP
SendAudioStream::GetProperty(
	DWORD prop,
	PVOID pBuf,
	LPUINT pcbBuf
    )
{
	HRESULT hr = DPR_SUCCESS;
	RTP_STATS RTPStats;
	DWORD_PTR dwPropVal;
	UINT len = sizeof(DWORD);	// most props are DWORDs

	if (!pBuf || *pcbBuf < len)
    {
		*pcbBuf = len;
		return DPR_INVALID_PARAMETER;
	}

	switch (prop)
    {
	case PROP_AUDIO_STRENGTH:
		return GetSignalLevel((UINT *)pBuf);

	case PROP_AUDIO_JAMMED:
		hr = m_InMedia->GetProp(MC_PROP_AUDIO_JAMMED, &dwPropVal);
        *(DWORD *)pBuf = (DWORD)dwPropVal;
		break;

#ifdef OLDSTUFF
	case PROP_NET_SEND_STATS:
		if (m_Net && *pcbBuf >= sizeof(RTP_STATS))
        {
			m_Net->GetSendStats((RTP_STATS *)pBuf);
			*pcbBuf = sizeof(RTP_STATS);
		} else
			hr = DPR_INVALID_PROP_VAL;
			
		break;
#endif

	case PROP_DURATION:
		hr = m_InMedia->GetProp(MC_PROP_DURATION, &dwPropVal);
        *(DWORD *)pBuf = (DWORD)dwPropVal;
		break;

	case PROP_SILENCE_LEVEL:
		*(DWORD *)pBuf = m_AudioMonitor.GetSilenceLevel();
		break;

	case PROP_SILENCE_DURATION:
		hr = m_InMedia->GetProp(MC_PROP_SILENCE_DURATION, &dwPropVal);
        *(DWORD *)pBuf = (DWORD)dwPropVal;
		break;

	case PROP_DUPLEX_TYPE:
		hr = m_InMedia->GetProp(MC_PROP_DUPLEX_TYPE, &dwPropVal);
		if(HR_SUCCEEDED(hr))
		{
			if(dwPropVal & DP_FLAG_FULL_DUPLEX)
				*(DWORD *)pBuf = DUPLEX_TYPE_FULL;
			else
				*(DWORD *)pBuf = DUPLEX_TYPE_HALF;
		}
		break;

	case PROP_AUDIO_SPP:
		hr = m_InMedia->GetProp(MC_PROP_SPP, &dwPropVal);
        *(DWORD *)pBuf = (DWORD)dwPropVal;
		break;

	case PROP_AUDIO_SPS:
		hr = m_InMedia->GetProp(MC_PROP_SPS, &dwPropVal);
        *(DWORD *)pBuf = (DWORD)dwPropVal;
		break;

	case PROP_WAVE_DEVICE_TYPE:
		*(DWORD *)pBuf = m_DPFlags & DP_MASK_WAVE_DEVICE;
		break;

	case PROP_RECORD_ON:
		*(DWORD *)pBuf = (m_DPFlags & DPFLAG_ENABLE_SEND) !=0;
		break;

	case PROP_AUDIO_AUTOMIX:
		*(DWORD *)pBuf = m_bAutoMix;
		break;

	case PROP_RECORD_DEVICE:
		*(DWORD *)pBuf = m_CaptureDevice;
		break;

	default:
		hr = DPR_INVALID_PROP_ID;
		break;
	}

	return hr;
}


STDMETHODIMP
SendAudioStream::SetProperty(
	DWORD prop,
	PVOID pBuf,
	UINT cbBuf
    )
{
	DWORD dw;
	HRESULT hr = S_OK;
	
	if (cbBuf < sizeof (DWORD))
		return DPR_INVALID_PARAMETER;

	switch (prop)
    {
	case PROP_SILENCE_LEVEL:
		m_AudioMonitor.SetSilenceLevel(*(DWORD *)pBuf);
		RETAILMSG(("NAC: Silence Level set to %d / 1000",*(DWORD*)pBuf));
		break;

	case PROP_DUPLEX_TYPE:
		ASSERT(0);
		break;


	case DP_PROP_DUPLEX_TYPE:
		dw = *(DWORD*)pBuf;
		if (dw)
		{
			dw = DP_FLAG_FULL_DUPLEX;
		}
		else
		{
			dw = DP_FLAG_HALF_DUPLEX;
		}

		m_InMedia->SetProp(MC_PROP_DUPLEX_TYPE, dw);
		break;

	case PROP_VOICE_SWITCH:
		// set duplex type of both input and output
		dw = *(DWORD*)pBuf;
		switch(dw)
		{
			case VOICE_SWITCH_MIC_ON:
				dw = DP_FLAG_MIC_ON;
			break;
			case VOICE_SWITCH_MIC_OFF:
				dw = DP_FLAG_MIC_OFF;
			break;
			default:
			case VOICE_SWITCH_AUTO:
				dw = DP_FLAG_AUTO_SWITCH;
			break;
		}
	
		hr = m_InMedia->SetProp(MC_PROP_VOICE_SWITCH, dw);
		RETAILMSG(("NAC: Setting voice switch to %s", (DP_FLAG_AUTO_SWITCH & dw) ? "Auto" : ((DP_FLAG_MIC_ON & dw)? "MicOn":"MicOff")));
		break;

	case PROP_SILENCE_DURATION:
		hr = m_InMedia->SetProp(MC_PROP_SILENCE_DURATION, *(DWORD*)pBuf);
		RETAILMSG(("NAC: setting silence duration to %d ms",*(DWORD*)pBuf));
		break;
// TODO: remove this property once UI calls IComChan version
	case PROP_RECORD_ON:
	{
		DWORD flag =  DPFLAG_ENABLE_SEND ;
		if (*(DWORD *)pBuf) {
			m_DPFlags |= flag; // set the flag
			Start();
		}
		else
		{
			m_DPFlags &= ~flag; // clear the flag
			Stop();
		}
		RETAILMSG(("NAC: %s", *(DWORD*)pBuf ? "Enabling":"Disabling"));
		break;
	}	

	case PROP_AUDIO_AUTOMIX:
		m_bAutoMix = *(DWORD*)pBuf;
		break;


	case PROP_RECORD_DEVICE:
		m_CaptureDevice = *(DWORD*)pBuf;
		RETAILMSG(("NAC: Setting default record device to %d", m_CaptureDevice));
		break;

	default:
		return DPR_INVALID_PROP_ID;
		break;
	}
	return hr;
}

void SendAudioStream::EndSend()
{
}








/*************************************************************************

  Function: SendAudioStream::OpenSrcFile(void)

  Purpose : Opens wav file to read audio data from.

  Returns : HRESULT.

  Params  : None

  Comments: * Registry keys:
            \\HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Audio\PlayFromFile\fPlayFromFile
              If set to zero, data will not be read from wav file.
              If set to a non null value <= INT_MAX, data will be read from wav file.
            \\HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Audio\PlayFromFile\szInputFileName
              Name of the wav file to read audio data from.
            \\HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Audio\PlayFromFile\fLoop
              If set to zero, the file will only be read once.
              If set to a non null value <= INT_MAX, the file will be read circularly.
            \\HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Audio\PlayFromFile\cchIOBuffer
              If set to zero, size of the MM IO buffer is set to its default value (8Kbytes).
              If set to one, size of the MM IO buffer is set to match maximum size of the wav file.
              If set a non null value between 2 and INT_MAX, size of the MM IO buffer is set to cchIOBuffer bytes.

  History : Date      Reason
            06/02/96  Created - PhilF

*************************************************************************/
HRESULT SendAudioStream::OpenSrcFile (void)
{
	return AudioFile::OpenSourceFile(&m_mmioSrc, &m_fDevSend);
}


/*************************************************************************

  Function: DataPump::CloseSrcFile(void)

  Purpose : Close wav file used to read audio data from.

  Returns : HRESULT.

  Params  : None

  Comments:

  History : Date      Reason
            06/02/96  Created - PhilF

*************************************************************************/
HRESULT SendAudioStream::CloseSrcFile (void)
{
	return AudioFile::CloseSourceFile(&m_mmioSrc);
}


HRESULT CALLBACK SendAudioStream::QosNotifyAudioCB(LPRESOURCEREQUESTLIST lpResourceRequestList, DWORD_PTR dwThis)
{
	HRESULT hr=NOERROR;
	LPRESOURCEREQUESTLIST prrl=lpResourceRequestList;
	int i;
#ifdef LOGSTATISTICS_ON
	int iMaxBWUsage, iMaxCPUUsage;
	char szDebug[256];
#endif
	DWORD dwCPUUsage, dwBWUsage;
	int iCPUUsageId, iBWUsageId;
	UINT dwSize = sizeof(int);
	SendMediaStream *pThis = (SendMediaStream *)dwThis;

	// Enter critical section to allow QoS thread to read the statistics while recording
	EnterCriticalSection(&(pThis->m_crsQos));

	// Record the time of this callback call
	pThis->m_Stats.dwNewestTs = timeGetTime();

	// Only do anything if we have at least captured a frame in the previous epoch
	if ((pThis->m_Stats.dwCount) && (pThis->m_Stats.dwNewestTs > pThis->m_Stats.dwOldestTs))
	{
#ifdef LOGSTATISTICS_ON
		wsprintf(szDebug, "    Epoch = %ld\r\n", pThis->m_Stats.dwNewestTs - pThis->m_Stats.dwOldestTs);
		OutputDebugString(szDebug);
#endif
		// Read the stats
		dwCPUUsage = pThis->m_Stats.dwMsComp * 1000UL / (pThis->m_Stats.dwNewestTs - pThis->m_Stats.dwOldestTs);
		dwBWUsage = pThis->m_Stats.dwBits * 1000UL / (pThis->m_Stats.dwNewestTs - pThis->m_Stats.dwOldestTs);

		// Initialize QoS structure. Only the four first fields should be zeroed.
		ZeroMemory(&(pThis->m_Stats), 4UL * sizeof(DWORD));

		// Record the time of this call for the next callback call
		pThis->m_Stats.dwOldestTs = pThis->m_Stats.dwNewestTs;
	}
	else
		dwBWUsage = dwCPUUsage = 0UL;

	// Get the latest RTCP stats and update the counters.
	// we do this here because it is called periodically.
	if (pThis->m_pRTPSend)
	{
		UINT lastPacketsLost = pThis->m_RTPStats.packetsLost;
		if (g_pctrAudioSendLost &&  SUCCEEDED(pThis->m_pRTPSend->GetSendStats(&pThis->m_RTPStats)))
			UPDATE_COUNTER(g_pctrAudioSendLost, pThis->m_RTPStats.packetsLost-lastPacketsLost);
	}
		
	// Leave critical section
	LeaveCriticalSection(&(pThis->m_crsQos));


	// Get the max for the resources.
#ifdef LOGSTATISTICS_ON
	iMaxCPUUsage = -1L; iMaxBWUsage = -1L;
#endif
	for (i=0, iCPUUsageId = -1L, iBWUsageId = -1L; i<(int)lpResourceRequestList->cRequests; i++)
		if (lpResourceRequestList->aRequests[i].resourceID == RESOURCE_OUTGOING_BANDWIDTH)
			iBWUsageId = i;
		else if (lpResourceRequestList->aRequests[i].resourceID == RESOURCE_CPU_CYCLES)
			iCPUUsageId = i;

#ifdef LOGSTATISTICS_ON
	if (iBWUsageId != -1L)
		iMaxBWUsage = lpResourceRequestList->aRequests[iBWUsageId].nUnitsMin;
	if (iCPUUsageId != -1L)
		iMaxCPUUsage = lpResourceRequestList->aRequests[iCPUUsageId].nUnitsMin;
#endif

	// Update the QoS resources (only if you need less than what's available)
	if (iCPUUsageId != -1L)
	{
		if ((int)dwCPUUsage < lpResourceRequestList->aRequests[iCPUUsageId].nUnitsMin)
			lpResourceRequestList->aRequests[iCPUUsageId].nUnitsMin = dwCPUUsage;
	}
	
	if (iBWUsageId != -1L)
	{
		if ((int)dwBWUsage < lpResourceRequestList->aRequests[iBWUsageId].nUnitsMin)
			lpResourceRequestList->aRequests[iBWUsageId].nUnitsMin = dwBWUsage;
	}

#ifdef LOGSTATISTICS_ON
	// How are we doing?
	if (iCPUUsageId != -1L)
	{
		wsprintf(szDebug, " A: Max CPU Usage: %ld, Current CPU Usage: %ld\r\n", iMaxCPUUsage, dwCPUUsage);
		OutputDebugString(szDebug);
	}
	if (iBWUsageId != -1L)
	{
		wsprintf(szDebug, " A: Max BW Usage: %ld, Current BW Usage: %ld\r\n", iMaxBWUsage, dwBWUsage);
		OutputDebugString(szDebug);
	}
#endif

	return hr;
}



HRESULT __stdcall SendAudioStream::AddDigit(int nDigit)
{
	IMediaChannel *pIMC = NULL;
	RecvMediaStream *pRecv = NULL;
	BOOL bIsStarted;

	if ((!(m_DPFlags & DPFLAG_CONFIGURED_SEND)) || (m_pRTPSend==NULL))
	{
		return DPR_NOT_CONFIGURED;
	}

	bIsStarted = (m_DPFlags & DPFLAG_STARTED_SEND);

	if (bIsStarted)
	{
		Stop();
	}

	m_pDTMF->AddDigitToQueue(nDigit);
	SendDTMF();



	m_pDP->GetMediaChannelInterface(MCF_RECV | MCF_AUDIO, &pIMC);
	if (pIMC)
	{
		pRecv = static_cast<RecvMediaStream *> (pIMC);
		pRecv->DTMFBeep();
		pIMC->Release();
	}

	if (bIsStarted)
	{
		Start();
	}

	return S_OK;
}


HRESULT __stdcall SendAudioStream::SendDTMF()
{
	HRESULT hr;
	MediaPacket **ppAudPckt, *pPacket;
	ULONG uCount;
	UINT uBufferSize, uBytesSent;
	void *pBuffer;
	bool bMark = true;
	DWORD dwSamplesPerPkt;
	MMRESULT mmr;
	DWORD dwSamplesPerSec;
	DWORD dwPacketTimeMS;
    DWORD_PTR dwPropVal;
	UINT uTimerID;
	HANDLE hEvent = m_pDTMF->GetEvent();
	
	
	m_InMedia->GetProp (MC_PROP_SPP, &dwPropVal);
    dwSamplesPerPkt = (DWORD)dwPropVal;

	m_InMedia->GetProp (MC_PROP_SPS, &dwPropVal);
    dwSamplesPerSec = (DWORD)dwPropVal;

	dwPacketTimeMS = (dwSamplesPerPkt * 1000) / dwSamplesPerSec;

	timeBeginPeriod(5);
	ResetEvent(hEvent);
	uTimerID = timeSetEvent(dwPacketTimeMS-1, 5, (LPTIMECALLBACK)hEvent, 0, TIME_CALLBACK_EVENT_SET|TIME_PERIODIC);

	// since the stream is stopped, just grab any packet
	// from the TxStream

	m_SendStream->GetRing(&ppAudPckt, &uCount);
	pPacket = ppAudPckt[0];
	pPacket->GetDevData(&pBuffer, &uBufferSize);

	hr = m_pDTMF->ReadFromQueue((BYTE*)pBuffer, uBufferSize);

	while (SUCCEEDED(hr))
	{

		// there should be only 1 tone in the queue (it can handle more)
		// so assume we only need to set the mark bit on the first packet


		pPacket->m_fMark = bMark;
		bMark = false;

		pPacket->SetProp(MP_PROP_TIMESTAMP, m_SendTimestamp);
		m_SendTimestamp += dwSamplesPerPkt;

		pPacket->SetState (MP_STATE_RECORDED);

		// compress
		mmr = m_pAudioFilter->Convert((AudioPacket*)pPacket, AP_ENCODE);
		if (mmr == MMSYSERR_NOERROR)
		{
			pPacket->SetState(MP_STATE_ENCODED);
			SendPacket((AudioPacket*)pPacket, &uBytesSent);
			pPacket->m_fMark=false;
			pPacket->SetState(MP_STATE_RESET);
		}

		hr = m_pDTMF->ReadFromQueue((BYTE*)pBuffer, uBufferSize);

		// so that we don't overload the receive jitter buffer on the remote
		// side, sleep a few milliseconds between sending packets
		if (SUCCEEDED(hr))
		{
			WaitForSingleObject(hEvent, dwPacketTimeMS);
			ResetEvent(hEvent);
		}
	}

	timeKillEvent(uTimerID);
	timeEndPeriod(5);
	return S_OK;
}


HRESULT __stdcall SendAudioStream::ResetDTMF()
{
	if(!(m_DPFlags & DPFLAG_STARTED_SEND))
	{
		return S_OK;
	}

	return m_pDTMF->ClearQueue();
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\rtp.h ===
/*
  RTP.H

  RTP structures and prototypes
*/

#ifndef _RTP_H_
#define _RTP_H_

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#define RTP_VERSION		2

/* Defined in rrcm_dll.h
typedef enum {
  RTCP_SDES_END	=  0,
  RTCP_SDES_CNAME  =  1,
  RTCP_SDES_NAME   =  2,
  RTCP_SDES_EMAIL  =  3,
  RTCP_SDES_PHONE  =  4,
  RTCP_SDES_LOC	=  5,
  RTCP_SDES_TOOL   =  6,
  RTCP_SDES_NOTE   =  7,
  RTCP_SDES_PRIV   =  8, 
  RTCP_SDES_IMG	=  9,
  RTCP_SDES_DOOR   = 10,
  RTCP_SDES_SOURCE = 11
} SDES_TYPE;
*/

typedef enum {
  RTCP_TYPE_SR   = 200,		// sender report
  RTCP_TYPE_RR   = 201,		// receiver report
  RTCP_TYPE_SDES = 202,		// source description
  RTCP_TYPE_BYE  = 203,		// end of session
  RTCP_TYPE_APP  = 204		// app. specific
} RTCP_TYPE;

typedef unsigned __int64 NTP_TS;

typedef struct {
	// !!! WARNING !!!
	// The following word doesn't need to be swapped for NtoH()
	unsigned short cc:4;	   /* CSRC count */
	unsigned short x:1;		/* header extension flag */
	unsigned short p:1;		/* padding flag */
	unsigned short version:2;  /* protocol version */
  	unsigned short payload:7;	   /* payload type */
	unsigned short m:1;		/* marker bit */

  	WORD seq;			 /* sequence number */
  	DWORD ts;			  /* timestamp */
  	DWORD ssrc;			/* synchronization source */
  //DWORD csrc[1];		 /* optional CSRC list */
} RTP_HDR;

// common part of RTCP header
typedef struct {
  	unsigned short version:2;  /* protocol version */
  	unsigned short p:1;		/* padding flag */
  	unsigned short count:5;	/* varies by payload type */
	unsigned short rtcpType:8;	   	/* payload type */
  	WORD length;		  /* packet length in dwords, without this hdr */
} RTCP_HDR;

/* reception report */
typedef struct {
  DWORD ssrc;			/* data source being reported */
  BYTE fracLost; /* fraction lost since last SR/RR */
  BYTE lostHi;			 /* cumulative number of packets lost (signed!) */
  WORD lostLo;
  DWORD lastSeq;		/* extended last sequence number received */
  DWORD jitter;		  /* interarrival jitter */
  DWORD lastSR;			 /* last SR packet from this source */
  DWORD delayLastSR;			/* delay since last SR packet */
} RTCP_RR;

/* sender report (SR) */
typedef struct {
  DWORD ssrc;		/* source this RTCP packet refers to */
  DWORD ntpHi;	/* NTP timestamp - seconds */
  DWORD ntpLo;	  /* mantissa */
  DWORD timestamp;	  /* RTP timestamp */
  DWORD packetsSent;	   /* packets sent */
  DWORD bytesSent;	   /* octets sent */ 
  /* variable-length list */
  //RTCP_RR rr[1];
} RTCP_SR;

/* BYE */
typedef struct {
  DWORD src[1];	  /* list of sources */
  /* can't express trailing text */
} RTCP_BYE;

typedef struct {
  BYTE type;			 /* type of SDES item (rtcp_sdes_type_t) */
  BYTE length;		   /* length of SDES item (in octets) */
  char data[1];			/* text, not zero-terminated */
} RTCP_SDES_ITEM;

/* source description (SDES) */
typedef struct  {
  DWORD src;			  /* first SSRC/CSRC */
  RTCP_SDES_ITEM item[1]; /* list of SDES items */
} RTCP_SDES;



#define INVALID_RTP_SEQ_NUMBER	0xffffffff

#include <poppack.h> /* End byte packing */

#endif // _RTP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\rvstream.cpp ===
/*
	RVSTREAM.C
*/

#include "precomp.h"

#define PLAYOUT_DELAY_FACTOR	2
#ifndef MAX_MISORDER
#define MAX_MISORDER 30
#endif

void FreeNetBufList(NETBUF *pNB, IRTPRecv *pRTP)
{
	NETBUF *pNBTemp;
	while (pNB) {
		pNBTemp = pNB;
		pNB = pNB->next;
		if (pRTP) pRTP->FreePacket(*(WSABUF **)(pNBTemp + 1));
		pNBTemp->pool->ReturnBuffer(pNBTemp);
	}	
}

void AppendNetBufList(NETBUF *pFirstNB, NETBUF *pNB)
{
	NETBUF *pNB1 = pFirstNB;
	while (pNB1->next) {
		ASSERT(pNB != pNB1);
		pNB1 = pNB1->next;
	}
	ASSERT(pNB != pNB1);
	pNB1->next = pNB;
}



int RVStream::Initialize(UINT flags, UINT size, IRTPRecv *pRTP, MEDIAPACKETINIT *papi, ULONG ulSamplesPerPacket, ULONG ulSamplesPerSec, VcmFilter *pVideoFilter)
{
	m_pVideoFilter = pVideoFilter;
	return ((RxStream*)this)->Initialize(flags, size, pRTP, papi, ulSamplesPerPacket, ulSamplesPerSec);
}




/*
	Queues a received RTP packet.
	The packet is described by pNetBuf.
	This routine will take care of freeing pNetBuf (even in error cases)
*/
HRESULT
RVStream::PutNextNetIn(WSABUF *pWsaBuf, DWORD timestamp, UINT seq, UINT fMark, BOOL *pfSkippedData, BOOL *pfSyncPoint)
{
	FX_ENTRY("RVStream::PutNextNetIn");

	UINT pos;
	MediaPacket *pAP;
	NETBUF *pNB_Packet;
	HRESULT hr;
	NETBUF *pNetBuf = (NETBUF *)m_NetBufPool.GetBuffer();
	ASSERT(pNetBuf);

	EnterCriticalSection(&m_CritSect);

	*pfSkippedData = FALSE;
	*pfSyncPoint = FALSE;

	if (pNetBuf == NULL)
	{
		hr = E_OUTOFMEMORY;
		WARNING_OUT(("RVStream::PutNextNetIn - Out of memory in buffer pool"));
		m_pRTP->FreePacket(pWsaBuf);
		goto ErrorExit;
	}

	*(WSABUF **)(pNetBuf+1) = pWsaBuf;	// cache the WSABUF pointer so it can be returned later
	pNetBuf->data = (PBYTE) pWsaBuf->buf + sizeof(RTP_HDR);
	pNetBuf->length = pWsaBuf->len - sizeof(RTP_HDR);
	pNetBuf->next = NULL;
	pNetBuf->pool = &m_NetBufPool;

	hr = ReassembleFrame(pNetBuf, seq, fMark);

	if (hr != DPR_SUCCESS)
	{
		// free pNetBuf since its not yet on m_NetBufList.
		// m_NetBufList will be freed at ErrorExit
		::FreeNetBufList(pNetBuf,m_pRTP);
		goto ErrorExit;
	}

	// not the end of the frame
	if (!fMark)
	{
		LeaveCriticalSection(&m_CritSect);
		return S_FALSE;  // success, but not a new frame yet
	}

	// If we get here we think we have a complete encoded video frame (fMark was
	// set on the last packet)
	
	// if the ring is full or the timestamp is earlier, dump everything.This may be too drastic
	// and the reset action could be refined to dump only the older
	// packets. However, need to make sure the ring doesnt get "stuck"
	pos = ModRing(m_MaxPos+1);
	if (pos == m_FreePos || TS_EARLIER(timestamp, m_MaxT)) {
		Reset(seq,timestamp);
		*pfSkippedData = TRUE;
		pos = ModRing(m_MaxPos + 1); // check again
		if (pos == m_FreePos) {
			hr = DPR_OUT_OF_MEMORY;
			m_LastGoodSeq -= MAX_MISORDER; //make sure we dont accidentally synchronize
			goto ErrorExit;
		}
	}

	// insert frame into ring

	pAP = m_Ring[pos];
	if (pAP->Busy() || pAP->GetState() != MP_STATE_RESET) {
		hr = DPR_DUPLICATE_PACKET;
		goto ErrorExit;
	}

	// new stuff
	hr = RestorePacket(m_NetBufList, pAP, timestamp, seq, fMark, pfSyncPoint);
	if (FAILED(hr))
	{
		goto ErrorExit;
	}

	if (*pfSyncPoint)
	{
		DEBUGMSG (ZONE_IFRAME, ("%s: Received a keyframe\r\n", _fx_));
	}

	::FreeNetBufList(m_NetBufList,m_pRTP);
	m_NetBufList = NULL;
#ifdef DEBUG
	if (!TS_LATER(timestamp, m_MaxT))
	{
			DEBUGMSG (ZONE_DP, ("PutNextNetIn(): Reconstructed frame's timestamp <= to previous frame's!\r\n"));
	}
#endif
	m_MaxT = timestamp;
	m_MaxPos = pos;		// advance m_MaxPos
// end new stuff

		
	LeaveCriticalSection(&m_CritSect);
	StartDecode();
	return hr;
ErrorExit:
	// if we're in the middle of assembling a frame, free buffers
	if (m_NetBufList){
		::FreeNetBufList(m_NetBufList,m_pRTP);
		m_NetBufList = NULL;
	}
	LeaveCriticalSection(&m_CritSect);
	return hr;

}

// Called to force the release of any accumulated NETBUFs back to the owner (RTP).
// This can be called at shutdown or to escape from a out-of-buffer situation
BOOL RVStream::ReleaseNetBuffers()
{
	::FreeNetBufList(m_NetBufList, m_pRTP);
	m_NetBufList = NULL;
	return TRUE;
}

// Take a packet and reassemble it into a frame.
// Doesnt currently process out-of-order packets (ie) the entire frame is
// discarded
// The NETBUF is held onto, unless an error is returned
HRESULT
RVStream::ReassembleFrame(NETBUF *pNetBuf, UINT seq, UINT fMark)
{

	++m_LastGoodSeq;
	if (seq != m_LastGoodSeq) {
		// dont handle out of sequence packets
		if (fMark)
			m_LastGoodSeq = (WORD)seq;
		else
			--m_LastGoodSeq;	// LastGoodSeq left unchanged

		return DPR_OUT_OF_SEQUENCE;
	}

	
	if (m_NetBufList ) {
		// append to list of fragments
		::AppendNetBufList(m_NetBufList,pNetBuf);
	} else {
		// start of frame
		m_NetBufList = pNetBuf;
	}

	return DPR_SUCCESS;	
}

HRESULT
RVStream::SetLastGoodSeq(UINT seq)
{
	m_LastGoodSeq = seq ? (WORD)(seq-1) : (WORD)0xFFFF;
	return DPR_SUCCESS;
}

// called when restarting after a pause (fSilenceOnly == FALSE) or
// to catch up when latency is getting too much (fSilenceOnly == TRUE)
// determine new play position by skipping any
// stale packets

HRESULT RVStream::FastForward( BOOL fSilenceOnly)
{
	UINT pos;
	DWORD timestamp = 0;
	// restart the receive stream
	EnterCriticalSection(&m_CritSect);
	if (!TS_EARLIER(m_MaxT , m_PlayT)) {
		// there are buffers waiting to be played
		// dump them!
		if (ModRing(m_MaxPos - m_PlayPos) <= m_DelayPos)
			goto Exit;	// not too many stale packets;

		for (pos=m_PlayPos;pos != ModRing(m_MaxPos -m_DelayPos);pos = ModRing(pos+1),m_PlaySeq++) {
			if (m_Ring[pos]->Busy()
				|| (m_Ring[pos]->GetState() != MP_STATE_RESET
					&& (fSilenceOnly ||ModRing(m_MaxPos-pos) <= m_MaxDelayPos)))
			{	// non-empty packet
				if (m_Ring[pos]->Busy())	// uncommon case
					goto Exit;	// bailing out
				timestamp = m_Ring[pos]->GetTimestamp();
				break;
			}
			m_Ring[pos]->Recycle();	// free NETBUF and Reset state
			LOG((LOGMSG_RX_SKIP,pos));
		}
		if (timestamp)	{// starting from non-empty packet
			m_PlayT = timestamp;
			//m_Ring[pos]->GetProp(MP_PROP_SEQNUM, &m_PlaySeq);
		} else {		// starting from (possibly) empty packet
			m_PlayT++;
		}

		// probably also need to update FreePos
		if (m_FreePos == ModRing(m_PlayPos-1))
			m_FreePos = ModRing(pos-1);
		m_PlayPos = pos;
		/*
		if (pos == ModRing(m_MaxPos+1)) {
			DEBUGMSG(1,("Reset:: m_MaxT inconsisten!\n"));
		}
		*/
		LOG((LOGMSG_RX_RESET2,m_MaxT,m_PlayT,m_PlayPos));
	}
Exit:
	LeaveCriticalSection(&m_CritSect);
	return DPR_SUCCESS;
}


HRESULT
RVStream::Reset(UINT seq,DWORD timestamp)
{
	UINT pos;
	HRESULT hr;
	// restart the receive stream
	EnterCriticalSection(&m_CritSect);
	LOG((LOGMSG_RX_RESET,m_MaxPos,m_PlayT,m_PlayPos));
	/*if (!TS_EARLIER(m_MaxT , m_PlayT)) */
	{
		// there are buffers waiting to be played
		// dump them!
		// Empty the RVStream and set PlayT appropriately
		for (pos = m_PlayPos;
			pos != m_FreePos;
			pos = ModRing(pos+1))
		{
			if (m_Ring[pos]->Busy ())
			{
				DEBUGMSG (1, ("RVStream::Reset: packet is busy, pos=%d\r\n", pos));
				ASSERT(1);
				hr = DPR_INVALID_PARAMETER;
				goto Failed;
			}
			m_Ring[pos]->Recycle();	// free NETBUF and Reset state
		}
	}
	m_MaxPos = ModRing(m_PlayPos-1);
	m_PlayT = timestamp;
	m_MaxT = m_PlayT -1;	// m_MaxT must be less than m_PlayT
	m_PlaySeq = seq;
	
	LOG((LOGMSG_RX_RESET2,m_MaxPos,m_PlayT,m_PlayPos));
	hr = DPR_SUCCESS;
Failed:
	LeaveCriticalSection(&m_CritSect);
	return hr;		
}

MediaPacket *RVStream::GetNextPlay(void)
{
	MediaPacket *pAP = NULL;
	UINT pos,seq;
	DWORD timestamp = 0, dwVal;
	EnterCriticalSection(&m_CritSect);


	pAP = m_Ring[m_PlayPos];
	if (pAP->Busy() ||
	(pAP->GetState() != MP_STATE_RESET && pAP->GetState() != MP_STATE_DECODED)
	 || ModRing(m_PlayPos+1) == m_FreePos) {
		LeaveCriticalSection(&m_CritSect);
		return NULL;
	} else {
	// If there are empty buffer(s) at the head of the q followed
	// by  a talkspurt (non-empty buffers) and if the talkspurt is excessively
	// delayed then squeeze out the silence.
	//
		if (pAP->GetState() == MP_STATE_RESET)
			FastForward(TRUE);	// skip silence packets if necessary
		pAP = m_Ring[m_PlayPos];	// in case the play position changed
		if (pAP->GetState() == MP_STATE_DECODED) {
			timestamp = pAP->GetTimestamp();
			seq = pAP->GetSeqNum();
		}
			
	}

	pAP->Busy(TRUE);
	m_PlayPos = ModRing(m_PlayPos+1);
	if (timestamp) {
		m_PlayT = timestamp+1;
		m_PlaySeq = seq+1;
	} else {
		m_PlaySeq++;
		// we dont really know the timestamp of the next frame to play
		// without looking at it, and it may not have arrived
		// so m_PlayT is just a lower bound
		m_PlayT++;	
	}
	LeaveCriticalSection(&m_CritSect);
	return pAP;
}

RVStream::Destroy()
{
	ASSERT (!m_NetBufList);
	//::FreeNetBufList(m_NetBufList,m_pRTP);
	m_NetBufList = NULL;
	RxStream::Destroy();
	return DPR_SUCCESS;
}


void RVStream::StartDecode()
{
	MediaPacket *pVP;
	MMRESULT mmr;

	// if we have a separate decode thread this will signal it.
	// for now we insert the decode loop here
	while (pVP = GetNextDecode())
	{
		mmr = m_pVideoFilter->Convert((VideoPacket*)pVP, VP_DECODE);
		if (mmr != MMSYSERR_NOERROR)
			pVP->Recycle();
		else
			pVP->SetState(MP_STATE_DECODED);

		Release(pVP);
	}
}


HRESULT RVStream::RestorePacket(NETBUF *pNetBuf, MediaPacket *pVP, DWORD timestamp, UINT seq, UINT fMark, BOOL *pfReceivedKeyframe)
{
	VOID *pNet;
	UINT uSizeNet;
	WSABUF bufDesc[MAX_VIDEO_FRAGMENTS];		// limit to at most 32 fragments
	UINT i;
	DWORD dwReceivedBytes=0;
	NETBUF *pnb;
	DWORD dwLength;
    DWORD_PTR dwPropVal;
	MMRESULT mmr;

	i = 0;
	pnb = pNetBuf;
	while (pnb && i < MAX_VIDEO_FRAGMENTS) {
		bufDesc[i].buf = (char *)pnb->data;
		bufDesc[i].len = pnb->length;
		dwReceivedBytes += pnb->length + sizeof(RTP_HDR) + IP_HEADER_SIZE + UDP_HEADER_SIZE;
		pnb = pnb->next;
		i++;
	}
	ASSERT(!pnb); // fail if we get a frame with more than MAX_VIDEO_FRAGMENTS

    // Write the bits per second counter
    UPDATE_COUNTER(g_pctrVideoReceiveBytes, dwReceivedBytes * 8);


	pVP->GetNetData(&pNet, &uSizeNet);

	// Initialize length to maximum reconstructed frame size
	pVP->GetProp(MP_PROP_MAX_NET_LENGTH, &dwPropVal);
    dwLength = (DWORD)dwPropVal;

	if (pnb==NULL)
	{
		mmr = m_pVideoFilter->RestorePayload(bufDesc, i, (BYTE*)pNet, &dwLength, pfReceivedKeyframe);
		if (mmr == MMSYSERR_NOERROR)
		{
			pVP->SetNetLength(dwLength);
			pVP->Receive(NULL, timestamp, seq, fMark);
			return S_OK;
		}
	}

	return E_FAIL;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\recvaudio.cpp ===
#include "precomp.h"

#ifdef PLS_DEBUG
#include "plog.h"
extern CPacketLog *g_pPacketLog;
#endif

// #define LOGSTATISTICS_ON 1

UINT g_MinWaveAudioDelayMs=240;	// minimum millisecs of introduced playback delay (Wave)
UINT g_MaxAudioDelayMs=750;	// maximum milliesecs of introduced playback delay
UINT g_MinDSEmulAudioDelayMs=240; // minimum delay (DirectSound on emulated driver)

HRESULT STDMETHODCALLTYPE RecvAudioStream::QueryInterface(REFIID iid, void **ppVoid)
{
	// resolve duplicate inheritance to the RecvMediaStream;

	extern IID IID_IProperty;

	if (iid == IID_IUnknown)
	{
		*ppVoid = (IUnknown*)((RecvMediaStream*)this);
	}
	else if (iid == IID_IMediaChannel)
	{
		*ppVoid = (IMediaChannel*)((RecvMediaStream *)this);
	}
	else if (iid == IID_IAudioChannel)
	{
		*ppVoid = (IAudioChannel*)this;
	}
	else if (iid == IID_IProperty)
	{
		*ppVoid = NULL;
		ERROR_OUT(("Don't QueryInterface for IID_IProperty, use IMediaChannel"));
		return E_NOINTERFACE;
	}
	else
	{
		*ppVoid = NULL;
		return E_NOINTERFACE;
	}
	AddRef();

	return S_OK;

}

ULONG STDMETHODCALLTYPE RecvAudioStream::AddRef(void)
{
	return InterlockedIncrement(&m_lRefCount);
}

ULONG STDMETHODCALLTYPE RecvAudioStream::Release(void)
{
	LONG lRet;
	lRet = InterlockedDecrement(&m_lRefCount);
	if (lRet == 0)
	{
		delete this;
		return 0;
	}
	else
		return lRet;
}


HRESULT
RecvAudioStream::Initialize( DataPump *pDP)
{
	HRESULT hr = DPR_OUT_OF_MEMORY;
	DWORD dwFlags =  DP_FLAG_FULL_DUPLEX | DP_FLAG_AUTO_SWITCH ;
	MEDIACTRLINIT mcInit;
	FX_ENTRY ("RecvAudioStream::Initialize")

	InitializeCriticalSection(&m_crsAudQoS);
	dwFlags |= DP_FLAG_ACM | DP_FLAG_MMSYSTEM | DP_FLAG_AUTO_SILENCE_DETECT;

	// store the platform flags
	// enable Send and Recv by default
	m_DPFlags = (dwFlags & DP_MASK_PLATFORM) | DPFLAG_ENABLE_SEND | DPFLAG_ENABLE_RECV;
	// store a back pointer to the datapump container
	m_pDP = pDP;
	m_pIRTPRecv = NULL;
	m_Net = NULL;  // this object (m_Net) no longer used (at least for now)
	m_dwSrcSize = 0;
	

	// Initialize data (should be in constructor)
	m_RenderingDevice = (UINT) -1;	// use VIDEO_MAPPER



	// Create Receive and Transmit audio streams
    DBG_SAVE_FILE_LINE
	m_RecvStream = new RxStream(MAX_RXRING_SIZE);
		
	if (!m_RecvStream )
	{
		DEBUGMSG (ZONE_DP, ("%s: RxStream or TxStream new failed\r\n", _fx_));
 		goto StreamAllocError;
	}


	// Create Input and Output audio filters
    DBG_SAVE_FILE_LINE
	m_pAudioFilter = new AcmFilter();
	if (!m_pAudioFilter)
	{
		DEBUGMSG (ZONE_DP, ("%s: AcmManager new failed\r\n", _fx_));
		goto FilterAllocError;
	}
	
	//Create MultiMedia device control objects
    DBG_SAVE_FILE_LINE
	m_OutMedia = new WaveOutControl();
	if ( !m_OutMedia)
	{
		DEBUGMSG (ZONE_DP, ("%s: MediaControl new failed\r\n", _fx_));
		goto MediaAllocError;
	}

	// Initialize the recv-stream media control object
	mcInit.dwFlags = dwFlags | DP_FLAG_RECV;
	hr = m_OutMedia->Initialize(&mcInit);
	if (hr != DPR_SUCCESS)
	{
		DEBUGMSG (ZONE_DP, ("%s: OMedia->Init failed, hr=0x%lX\r\n", _fx_, hr));
		goto MediaAllocError;
	}

	// determine if the wave devices are available
	if (waveOutGetNumDevs()) m_DPFlags |= DP_FLAG_PLAY_CAP;
	
	// set media to half duplex mode by default
	m_OutMedia->SetProp(MC_PROP_DUPLEX_TYPE, DP_FLAG_HALF_DUPLEX);

	m_DPFlags |= DPFLAG_INITIALIZED;

	UPDATE_REPORT_ENTRY(g_prptSystemSettings, 0, REP_SYS_AUDIO_DSOUND);
	RETAILMSG(("NAC: Audio Subsystem: WAVE"));

	return DPR_SUCCESS;


MediaAllocError:
	if (m_OutMedia) delete m_OutMedia;
FilterAllocError:
	if (m_pAudioFilter) delete m_pAudioFilter;
StreamAllocError:
	if (m_RecvStream) delete m_RecvStream;

	ERRORMESSAGE( ("%s: exit, hr=0x%lX\r\n", _fx_, hr));

	return hr;
}

RecvAudioStream::~RecvAudioStream()
{

	if (m_DPFlags & DPFLAG_INITIALIZED) {
		m_DPFlags &= ~DPFLAG_INITIALIZED;
	
		if (m_DPFlags & DPFLAG_CONFIGURED_RECV)
			UnConfigure();

		if (m_pIRTPRecv)
		{
			m_pIRTPRecv->Release();
			m_pIRTPRecv = NULL;
		}

		// Close the receive and transmit streams
		if (m_RecvStream) delete m_RecvStream;

		// Close the wave devices
		if (m_OutMedia) { delete m_OutMedia;}

		// close the filter
		if (m_pAudioFilter)
			delete m_pAudioFilter;

		m_pDP->RemoveMediaChannel(MCF_RECV|MCF_AUDIO, (IMediaChannel*)(RecvMediaStream*)this);
	}
	DeleteCriticalSection(&m_crsAudQoS);
}



HRESULT STDMETHODCALLTYPE RecvAudioStream::Configure(
	BYTE *pFormat,
	UINT cbFormat,
	BYTE *pChannelParams,
	UINT cbParams,
	IUnknown *pUnknown)
{
	HRESULT hr;
	BOOL fRet;
	MEDIAPACKETINIT apInit;
	MEDIACTRLCONFIG mcConfig;
	MediaPacket **ppAudPckt;
	ULONG cAudPckt;
	DWORD_PTR dwPropVal;
	DWORD dwFlags;
	AUDIO_CHANNEL_PARAMETERS audChannelParams;
	UINT uAudioCodec;
	UINT ringSize = MAX_RXRING_SIZE;
	WAVEFORMATEX *pwfRecv;
	UINT maxRingSamples;
	MMRESULT mmr;

	
	FX_ENTRY ("RecvAudioStream::Configure")


	if (m_DPFlags & DPFLAG_STARTED_RECV)
	{
		return DPR_IO_PENDING; // anything better to return
	}

	if (m_DPFlags & DPFLAG_CONFIGURED_RECV)
	{
		DEBUGMSG(ZONE_DP, ("Stream Re-Configuration - calling UnConfigure"));
		UnConfigure();
	}

	// get format details
	if ((NULL == pFormat) || (NULL == pChannelParams) ||
	    (cbFormat < sizeof(WAVEFORMATEX)) )

	{
		return DPR_INVALID_PARAMETER;
	}


	audChannelParams = *(AUDIO_CHANNEL_PARAMETERS *)pChannelParams;
	pwfRecv = (WAVEFORMATEX *)pFormat;

	if (! (m_DPFlags & DPFLAG_INITIALIZED))
		return DPR_OUT_OF_MEMORY;		//BUGBUG: return proper error;
		
	// full or half duplex ? get flags from media control - use the record side
	hr = m_OutMedia->GetProp(MC_PROP_DUPLEX_TYPE, &dwPropVal);
    dwFlags = (DWORD)dwPropVal;

	if(!HR_SUCCEEDED(hr))
	{
		dwFlags = DP_FLAG_HALF_DUPLEX | DP_FLAG_AUTO_SWITCH;
	}
//	if (m_Net)
//	{
//		hr = m_Net->QueryInterface(IID_IRTPRecv, (void **)&m_pIRTPRecv);
//		if (!SUCCEEDED(hr))
//			return hr;
//	}
	
	
	mcConfig.uDuration = MC_USING_DEFAULT;	// set duration by samples per pkt
	

	mmr = AcmFilter::SuggestDecodeFormat(pwfRecv, &m_fDevRecv);

	UPDATE_REPORT_ENTRY(g_prptCallParameters, pwfRecv->wFormatTag, REP_RECV_AUDIO_FORMAT);
	UPDATE_REPORT_ENTRY(g_prptCallParameters, pwfRecv->nSamplesPerSec, REP_RECV_AUDIO_SAMPLING);
	UPDATE_REPORT_ENTRY(g_prptCallParameters, pwfRecv->nAvgBytesPerSec*8, REP_RECV_AUDIO_BITRATE);
	RETAILMSG(("NAC: Audio Recv Format: %s", (pwfRecv->wFormatTag == 66) ? "G723.1" : (pwfRecv->wFormatTag == 112) ? "LHCELP" : (pwfRecv->wFormatTag == 113) ? "LHSB08" : (pwfRecv->wFormatTag == 114) ? "LHSB12" : (pwfRecv->wFormatTag == 115) ? "LHSB16" : (pwfRecv->wFormatTag == 6) ? "MSALAW" : (pwfRecv->wFormatTag == 7) ? "MSULAW" : (pwfRecv->wFormatTag == 130) ? "MSRT24" : "??????"));
	RETAILMSG(("NAC: Audio Recv Sampling Rate (Hz): %ld", pwfRecv->nSamplesPerSec));
	RETAILMSG(("NAC: Audio Recv Bitrate (w/o network overhead - bps): %ld", pwfRecv->nAvgBytesPerSec*8));

	// Initialize the recv-stream media control object
	mcConfig.pDevFmt = &m_fDevRecv;
	mcConfig.hStrm = (DPHANDLE) m_RecvStream;
	mcConfig.uDevId = m_RenderingDevice;
	mcConfig.cbSamplesPerPkt = audChannelParams.ns_params.wFrameSize
									*audChannelParams.ns_params.wFramesPerPkt;

	UPDATE_REPORT_ENTRY(g_prptCallParameters, mcConfig.cbSamplesPerPkt, REP_RECV_AUDIO_PACKET);
	RETAILMSG(("NAC: Audio Recv Packetization (ms/packet): %ld", pwfRecv->nSamplesPerSec ? mcConfig.cbSamplesPerPkt * 1000UL / pwfRecv->nSamplesPerSec : 0));
	INIT_COUNTER_MAX(g_pctrAudioReceiveBytes, (pwfRecv->nAvgBytesPerSec + pwfRecv->nSamplesPerSec * (sizeof(RTP_HDR) + IP_HEADER_SIZE + UDP_HEADER_SIZE) / mcConfig.cbSamplesPerPkt) << 3);

	hr = m_OutMedia->Configure(&mcConfig);
	// Check if we can open the wave device. This is just to give advance notice of
	// sound card being busy.
	//	Stop any high level ("PlaySound()") usage of wave device.
	//
	PlaySound(NULL,NULL, 0);
//	if (hr == DPR_SUCCESS && !(dwFlags & DP_FLAG_HALF_DUPLEX)) {
//		hr = m_OutMedia->Open ();
//	}
	
//	if (hr != DPR_SUCCESS)
//	{
//		DEBUGMSG (ZONE_DP, ("%s: OMedia->Config failed, hr=0x%lX\r\n", _fx_, hr));
//		goto OMediaInitError;
//	}
	
	mmr = m_pAudioFilter->Open(pwfRecv, &m_fDevRecv);
	if (mmr != 0)
	{
		DEBUGMSG (ZONE_DP, ("%s: AcmFilter->Open failed, mmr=%d\r\n", _fx_, mmr));
		hr = DPR_CANT_OPEN_CODEC;
		goto RecvFilterInitError;
	}


	// Initialize the recv stream
	ZeroMemory (&apInit, sizeof (apInit));

	apInit.dwFlags = DP_FLAG_RECV | DP_FLAG_ACM | DP_FLAG_MMSYSTEM;
	apInit.pStrmConvSrcFmt = pwfRecv;
	apInit.pStrmConvDstFmt = &m_fDevRecv;


	m_OutMedia->FillMediaPacketInit (&apInit);

	apInit.cbSizeRawData = apInit.cbSizeDevData;

	m_pAudioFilter->SuggestSrcSize(apInit.cbSizeDevData, &m_dwSrcSize);


	apInit.cbSizeNetData = m_dwSrcSize;
	apInit.cbOffsetNetData = sizeof (RTP_HDR);

	m_OutMedia->GetProp (MC_PROP_SPP, &dwPropVal);
	// set our total receive buffering capacity to somewhere between
	// 2 and 4 seconds.
	// Also make sure that the buffering capacity is at least one
	// second more than maxAudioDelay
	maxRingSamples = pwfRecv->nSamplesPerSec + pwfRecv->nSamplesPerSec*g_MaxAudioDelayMs/1000;

	if (maxRingSamples < 4*pwfRecv->nSamplesPerSec)
		maxRingSamples = 4*pwfRecv->nSamplesPerSec;
	while (ringSize* dwPropVal > maxRingSamples && ringSize > 8)
		ringSize = ringSize/2;
	dwFlags = DP_FLAG_MMSYSTEM;
	// if sender is not doing silence detection, we do it
	// on the receive side
	if (!audChannelParams.ns_params.UseSilenceDet)
		dwFlags |= DP_FLAG_AUTO_SILENCE_DETECT;
	fRet = m_RecvStream->Initialize (dwFlags, ringSize, NULL, &apInit, (DWORD)dwPropVal, pwfRecv->nSamplesPerSec, m_pAudioFilter);
	if (! fRet)
	{
		DEBUGMSG (ZONE_DP, ("%s: RxStream->Init failed, fRet=0%u\r\n", _fx_, fRet));
		hr = DPR_CANT_INIT_RX_STREAM;
		goto RxStreamInitError;
	}

	// WS2Qos will be called in Start to communicate stream reservations to the
	// remote endpoint using a RESV message
	//
	// We use a peak-rate allocation approach based on our target bitrates
	// Note that for the token bucket size and the maximum SDU size, we now
	// account for IP header overhead, and use the max frame fragment size
	// instead of the maximum compressed image size returned by the codec
	//
	// Some of the parameters are left unspecified because they are set
	// in the sender Tspec.

	InitAudioFlowspec(&m_flowspec, pwfRecv, m_dwSrcSize);


	// prepare headers for RxStream
	m_RecvStream->GetRing (&ppAudPckt, &cAudPckt);
	m_OutMedia->RegisterData (ppAudPckt, cAudPckt);
//	m_OutMedia->PrepareHeaders ();

	m_pAudioFilter->PrepareAudioPackets((AudioPacket**)ppAudPckt, cAudPckt, AP_DECODE);

	// Open the record to wav file
	AudioFile::OpenDestFile(&m_mmioDest, &m_fDevRecv);

	m_DPFlags |= DPFLAG_CONFIGURED_RECV;

#ifdef TEST
	LOG((LOGMSG_TIME_RECV_AUDIO_CONFIGURE,GetTickCount() - dwTicks));
#endif

	return DPR_SUCCESS;

RxStreamInitError:
RecvFilterInitError:
	m_pAudioFilter->Close();
	m_OutMedia->Close();
//OMediaInitError:
	if (m_pIRTPRecv)
	{
		m_pIRTPRecv->Release();
		m_pIRTPRecv = NULL;
	}
	ERRORMESSAGE(("%s:  failed, hr=0%u\r\n", _fx_, hr));
	return hr;
}


void RecvAudioStream::UnConfigure()
{

	AudioPacket **ppAudPckt=NULL;
	ULONG uPackets;

#ifdef TEST
	DWORD dwTicks;

	dwTicks = GetTickCount();
#endif

	if ((m_DPFlags & DPFLAG_CONFIGURED_RECV)) {


		Stop();


		// Close the RTP state if its open
		//m_Net->Close(); We should be able to do this in Disconnect()
	
		m_Net = NULL;

		m_OutMedia->Reset();
		m_OutMedia->UnprepareHeaders();
		m_OutMedia->Close();
		// Close the record to wav file
		AudioFile::CloseDestFile(&m_mmioDest);

		// Close the filters
		m_RecvStream->GetRing ((MediaPacket***)&ppAudPckt, &uPackets);
		m_pAudioFilter->UnPrepareAudioPackets(ppAudPckt, uPackets, AP_DECODE);

		m_pAudioFilter->Close();


		// Close the receive streams
		m_RecvStream->Destroy();

        m_DPFlags &= ~(DPFLAG_CONFIGURED_RECV);

	}
#ifdef TEST
	LOG((LOGMSG_TIME_RECV_AUDIO_UNCONFIGURE,GetTickCount() - dwTicks));
#endif

}

DWORD CALLBACK RecvAudioStream::StartPlaybackThread(LPVOID pVoid)
{
	RecvAudioStream *pThisStream = (RecvAudioStream *)pVoid;
	return pThisStream->PlaybackThread();
}



HRESULT
RecvAudioStream::Start()
{
	FX_ENTRY ("RecvAudioStream::Start");
	
	if (m_DPFlags & DPFLAG_STARTED_RECV)
		return DPR_SUCCESS;
	// TODO: remove this check once audio UI calls the IComChan PAUSE_RECV prop
	if (!(m_DPFlags & DPFLAG_ENABLE_RECV))
		return DPR_SUCCESS;
	if ((!(m_DPFlags & DPFLAG_CONFIGURED_RECV)) || (NULL==m_pIRTPRecv))
		return DPR_NOT_CONFIGURED;
	ASSERT(!m_hRenderingThread );
	m_ThreadFlags &= ~(DPTFLAG_STOP_PLAY|DPTFLAG_STOP_RECV);

	SetFlowSpec();

	// Start playback thread
	if (!(m_ThreadFlags & DPTFLAG_STOP_PLAY))
		m_hRenderingThread = CreateThread(NULL,0,RecvAudioStream::StartPlaybackThread,this,0,&m_RenderingThId);
	// Start receive thread
    m_pDP->StartReceiving(this);
    m_DPFlags |= DPFLAG_STARTED_RECV;
	DEBUGMSG (ZONE_DP, ("%s: Play ThId=%x\r\n",_fx_, m_RenderingThId));
	return DPR_SUCCESS;
}

// LOOK: Identical to RecvVideoStream version.
HRESULT
RecvAudioStream::Stop()
{
	DWORD dwWait;
	
	FX_ENTRY ("RecvAudioStream::Stop");

	if(!(m_DPFlags &  DPFLAG_STARTED_RECV))
	{
		return DPR_SUCCESS;
	}

	m_ThreadFlags = m_ThreadFlags  |
		DPTFLAG_STOP_RECV |  DPTFLAG_STOP_PLAY ;

	m_pDP->StopReceiving(this);
	
DEBUGMSG (ZONE_VERBOSE, ("%s: hRenderingThread=%x\r\n",_fx_, m_hRenderingThread));

	/*
	 *	we want to wait for all the threads to exit, but we need to handle windows
	 *	messages (mostly from winsock) while waiting.
	 */

	if(m_hRenderingThread)
	{
		dwWait = WaitForSingleObject(m_hRenderingThread, INFINITE);

		DEBUGMSG (ZONE_VERBOSE, ("%s: dwWait =%d\r\n", _fx_,  dwWait));
		ASSERT(dwWait != WAIT_FAILED);

		CloseHandle(m_hRenderingThread);
		m_hRenderingThread = NULL;
	}

    //This is per channel, but the variable is "DPFlags"
 	m_DPFlags &= ~DPFLAG_STARTED_RECV;

	
	return DPR_SUCCESS;
}


// low order word is the signal strength
// high order work contains bits to indicate status
// (0x01 - receiving (actually playing))
// (0x02 - audio device is jammed)
STDMETHODIMP RecvAudioStream::GetSignalLevel(UINT *pSignalStrength)
{
	DWORD dwLevel;
	DWORD dwJammed;
    DWORD_PTR dwPropVal;

	if ( (!(m_DPFlags & DPFLAG_STARTED_RECV)) ||
		 (m_ThreadFlags & DPTFLAG_PAUSE_RECV))
	{
		dwLevel = 0;
	}
	else
	{
		m_RecvStream->GetSignalStrength(&dwLevel);
		dwLevel = (dwLevel >> 8) & 0x00ff;
		dwLevel = LogScale[dwLevel];

		m_OutMedia->GetProp(MC_PROP_AUDIO_JAMMED, &dwPropVal);
        dwJammed = (DWORD)dwPropVal;

		if (dwJammed)
		{
			dwLevel = (2 << 16);
		}
		else if (m_fReceiving)
		{
			dwLevel |= (1 << 16);
		}
	}
	*pSignalStrength = dwLevel;
	return S_OK;
};




//  IProperty::GetProperty / SetProperty
//  (DataPump::MediaChannel::GetProperty)
//      Properties of the MediaChannel. Supports properties for both audio
//      and video channels.

STDMETHODIMP
RecvAudioStream::GetProperty(
	DWORD prop,
	PVOID pBuf,
	LPUINT pcbBuf
    )
{
	HRESULT hr = DPR_SUCCESS;
	RTP_STATS RTPStats;
	DWORD_PTR dwPropVal;
	UINT len = sizeof(DWORD);	// most props are DWORDs

	if (!pBuf || *pcbBuf < len)
    {
		*pcbBuf = len;
		return DPR_INVALID_PARAMETER;
	}

	switch (prop)
    {
	case PROP_RECV_AUDIO_STRENGTH:
		return GetSignalLevel((UINT *)pBuf);
		

	case PROP_AUDIO_JAMMED:
		hr = m_OutMedia->GetProp(MC_PROP_AUDIO_JAMMED, &dwPropVal);
        *(DWORD *)pBuf = (DWORD)dwPropVal;
		break;

#ifdef OLDSTUFF
	case PROP_NET_RECV_STATS:
		if (m_Net && *pcbBuf >= sizeof(RTP_STATS))
        {
			m_Net->GetRecvStats((RTP_STATS *)pBuf);
			*pcbBuf = sizeof(RTP_STATS);
		} else
			hr = DPR_INVALID_PROP_VAL;
			
		break;
#endif

	case PROP_DURATION:
		hr = m_OutMedia->GetProp(MC_PROP_DURATION, &dwPropVal);
        *(DWORD *)pBuf = (DWORD)dwPropVal;
		break;

	case PROP_VOLUME:
		hr = m_OutMedia->GetProp(MC_PROP_VOLUME, &dwPropVal);
        *(DWORD *)pBuf = (DWORD)dwPropVal;
		break;

	case PROP_DUPLEX_TYPE:
		hr = m_OutMedia->GetProp(MC_PROP_DUPLEX_TYPE, &dwPropVal);
		if(HR_SUCCEEDED(hr))
		{
			if(dwPropVal & DP_FLAG_FULL_DUPLEX)
				*(DWORD *)pBuf = DUPLEX_TYPE_FULL;
			else
				*(DWORD *)pBuf = DUPLEX_TYPE_HALF;
		}
		break;

	case PROP_AUDIO_SPP:
		hr = m_OutMedia->GetProp(MC_PROP_SPP, &dwPropVal);
        *(DWORD *)pBuf = (DWORD)dwPropVal;
		break;

	case PROP_AUDIO_SPS:
		hr = m_OutMedia->GetProp(MC_PROP_SPS, &dwPropVal);
        *(DWORD *)pBuf = (DWORD)dwPropVal;
		break;

	case PROP_WAVE_DEVICE_TYPE:
		*(DWORD *)pBuf = m_DPFlags & DP_MASK_WAVE_DEVICE;
		break;

	case PROP_PLAY_ON:
		*(DWORD *)pBuf = (m_ThreadFlags & DPFLAG_ENABLE_RECV)!=0;
		break;

	case PROP_PLAYBACK_DEVICE:
		*(DWORD *)pBuf = m_RenderingDevice;
		break;

	case PROP_VIDEO_AUDIO_SYNC:
		*(DWORD *)pBuf = ((m_DPFlags & DPFLAG_AV_SYNC) != 0);
		break;
	
	default:
		hr = DPR_INVALID_PROP_ID;
		break;
	}

	return hr;
}


STDMETHODIMP
RecvAudioStream::SetProperty(
	DWORD prop,
	PVOID pBuf,
	UINT cbBuf
    )
{
	DWORD_PTR dwPropVal;
	HRESULT hr = S_OK;
	
	if (cbBuf < sizeof (DWORD))
		return DPR_INVALID_PARAMETER;

	switch (prop)
    {
    case PROP_VOLUME:
        dwPropVal = *(DWORD *)pBuf;
		hr = m_OutMedia->SetProp(MC_PROP_VOLUME, dwPropVal);
		break;

	case PROP_DUPLEX_TYPE:
		ASSERT(0);
		break;
		
	case DP_PROP_DUPLEX_TYPE:
		// internal version, called by DataPump::SetDuplexMode() after ensuring streams are stopped
		dwPropVal = *(DWORD *)pBuf;
		if (dwPropVal)
		{
			dwPropVal = DP_FLAG_FULL_DUPLEX;
		}
		else
		{
			dwPropVal = DP_FLAG_HALF_DUPLEX;
		}
		m_OutMedia->SetProp(MC_PROP_DUPLEX_TYPE, dwPropVal);
		break;

	case PROP_PLAY_ON:
	{
		if (*(DWORD *)pBuf)   // unmute
		{
			m_ThreadFlags &= ~DPTFLAG_PAUSE_RECV;
		}
		else  // mute
		{
			m_ThreadFlags |= DPTFLAG_PAUSE_RECV;
		}

//		DWORD flag =  DPFLAG_ENABLE_RECV;
//		if (*(DWORD *)pBuf) {
//			m_DPFlags |= flag; // set the flag
//			hr = Start();
//		}
//		else
//		{
//			m_DPFlags &= ~flag; // clear the flag
//			hr = Stop();
//		}

		RETAILMSG(("NAC: %s", *(DWORD *)pBuf ? "Enabling":"Disabling"));
		break;
	}	
	case PROP_PLAYBACK_DEVICE:
		m_RenderingDevice = *(DWORD *)pBuf;
		RETAILMSG(("NAC: Setting default playback device to %d", m_RenderingDevice));
		break;
	
    case PROP_VIDEO_AUDIO_SYNC:
		if (*(DWORD *)pBuf)
    		m_DPFlags |= DPFLAG_AV_SYNC;
		else
			m_DPFlags &= ~DPFLAG_AV_SYNC;
    	break;

	default:
		return DPR_INVALID_PROP_ID;
		break;
	}

	return hr;
}

HRESULT
RecvAudioStream::GetCurrentPlayNTPTime(NTP_TS *pNtpTime)
{
	DWORD rtpTime;
#ifdef OLDSTUFF
	if ((m_DPFlags & DPFLAG_STARTED_RECV) && m_fReceiving) {
		if (m_Net->RTPtoNTP(m_PlaybackTimestamp,pNtpTime))
			return S_OK;
	}
#endif
	return 0xff;	// return proper error
		
}

BOOL RecvAudioStream::IsEmpty() {
	return m_RecvStream->IsEmpty();
}

/*
	Called by the recv thread to setup the stream for receiving.
	Post the initial recv buffer(s). Subsequently, the buffers are posted
	in the RTPRecvCallback()
*/
HRESULT
RecvAudioStream::StartRecv(HWND hWnd)
{
	HRESULT hr = S_OK;
	DWORD dwPropVal = 0;
	if ((!(m_ThreadFlags & DPTFLAG_STOP_RECV) ) && (m_DPFlags  & DPFLAG_CONFIGURED_RECV)){
//		m_RecvFilter->GetProp (FM_PROP_SRC_SIZE, &dwPropVal);
		hr =m_pIRTPRecv->SetRecvNotification(&RTPRecvCallback, (DWORD_PTR)this, 2);
		
	}

	return hr;
}

/*
	Called by the recv thread to suspend receiving  on this RTP session
	If there are outstanding receive buffers they have to be recovered
*/

HRESULT
RecvAudioStream::StopRecv()
{
	// dont recv on this stream

	m_pIRTPRecv->CancelRecvNotification();

	return S_OK;		
}

HRESULT RecvAudioStream::RTPCallback(WSABUF *pWsaBuf, DWORD timestamp, UINT seq, UINT fMark)
{
	HRESULT hr;
	DWORD_PTR dwPropVal;

	// if we are paused, reject the packet
	if (m_ThreadFlags & DPTFLAG_PAUSE_RECV)
	{
		return E_FAIL;
	}

	// The last two parameters are only used by the recv video stream
	hr = m_RecvStream->PutNextNetIn(pWsaBuf, timestamp, seq, fMark, NULL, NULL);

	m_pIRTPRecv->FreePacket(pWsaBuf);

	if (SUCCEEDED(hr))
	{
		m_OutMedia->GetProp (MC_PROP_EVENT_HANDLE, &dwPropVal);
		if (dwPropVal)
		{
			SetEvent( (HANDLE) dwPropVal);
		}
		else
		{
			DEBUGMSG(ZONE_DP,("PutNextNetIn (ts=%d,seq=%d,fMark=%d) failed with 0x%lX\r\n",timestamp,seq,fMark,hr));
		}
	}

	return S_OK;

}


// global RTP callback function for all receive streams
BOOL
RTPRecvCallback(
	DWORD_PTR dwCallback,
	WSABUF *pNetRecvBuf
	)
{
	HRESULT hr;
	DWORD timestamp;
	UINT seq;
	BOOL fMark;
	RecvMediaStream *pRecvMC = (RecvMediaStream *)dwCallback;
	
	RTP_HDR *pRTPHdr;
	pRTPHdr = (RTP_HDR *)pNetRecvBuf->buf;
	
	timestamp = pRTPHdr->ts;
	seq = pRTPHdr->seq;
	fMark = pRTPHdr->m;
		
		// packet looks okay
	LOG((LOGMSG_NET_RECVD,timestamp,seq,GetTickCount()));

	hr = pRecvMC->RTPCallback(pNetRecvBuf,timestamp,seq,fMark);
	if (SUCCEEDED(hr))
	{
		return TRUE;
	}
	return FALSE;
}

#define MAX_SILENCE_LEVEL 75*256
#define MIN_SILENCE_LEVEL 10*256


AudioSilenceDetector::AudioSilenceDetector()
{
 	// initialize silence detector stats
	// start with a high value because the estimator falls fast but rises slowly
	m_iSilenceAvg = MAX_SILENCE_LEVEL - MIN_SILENCE_LEVEL;
	m_iTalkAvg = 0;
	m_iSilenceLevel = MAX_SILENCE_LEVEL;

	m_uManualSilenceLevel = 1000;	// use auto mode.
}

// update adaptive silence threshold variables in SendAudioStats
// using m_dwMaxStrength (the max. peak to peak value in a buffer)
// return TRUE if below threshold
BOOL AudioSilenceDetector::SilenceDetect(WORD wStrength)
{
	int fSilence;
	INT strength;

	m_dwMaxStrength = wStrength;
	strength = LogScale[m_dwMaxStrength >> 8] << 8;

	// UI sets the silence threshold high ( == 1000/1000) to indicate
	// automatic silence detection
	if (m_uManualSilenceLevel >= 1000) {
		LOG((LOGMSG_AUTO_SILENCE,strength >> 8,m_iSilenceLevel >> 8,m_iSilenceAvg>>8));
		if (strength > m_iSilenceLevel) {
			// talking
			// increase threshold slowly
			// BUGBUG: should depend on time interval
			m_iSilenceLevel += 50;	//increased from 25- GJ
			m_iTalkAvg += (strength -m_iTalkAvg)/16;
			fSilence = FALSE;
		} else {
			// silence
			// update the average silence level
			m_iSilenceAvg += (strength - m_iSilenceAvg)/16;
			// set the threshold to the avg silence + a constant
			m_iSilenceLevel = m_iSilenceAvg + MIN_SILENCE_LEVEL;
			fSilence = TRUE;
		}
		if (m_iSilenceLevel > MAX_SILENCE_LEVEL)
			m_iSilenceLevel = MAX_SILENCE_LEVEL;
	} else {
		// use the user-specified silence threshold
		// oddly, the manual silence level is in a different range [0,1000]
		DWORD dwSilenceLevel = m_uManualSilenceLevel * 65536/1000;
		fSilence = (m_dwMaxStrength < dwSilenceLevel);
		LOG((LOGMSG_AUTO_SILENCE,m_dwMaxStrength, dwSilenceLevel ,0));
	}
	return fSilence;
}


// this method called from the UI thread only
HRESULT RecvAudioStream::DTMFBeep()
{
	int nBeeps;
	MediaPacket **ppAudPckt=NULL, *pPacket=NULL;
	void *pBuffer;
	ULONG uCount;
	UINT uBufferSize=0;

	if ( (!(m_DPFlags & DPFLAG_STARTED_RECV)) ||
		 (m_ThreadFlags & DPTFLAG_PAUSE_RECV) )
	{
		return E_FAIL;
	}

	// how many packets do we inject into the stream ?
	m_RecvStream->GetRing(&ppAudPckt, &uCount);
	pPacket = ppAudPckt[0];
	pPacket->GetDevData(&pBuffer, &uBufferSize);

	if (uBufferSize == 0)
	{
		return E_FAIL;
	}

	nBeeps = DTMF_FEEDBACK_BEEP_MS / ((uBufferSize * 1000) / m_fDevRecv.nAvgBytesPerSec);

	if (nBeeps == 0)
	{
		nBeeps = 1;
	}

	m_RecvStream->InjectBeeps(nBeeps);

	return S_OK;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\threadevent.cpp ===
#include "precomp.h"
#include "ThreadEvent.h"

const int WM_TEP_MESSAGE = WM_USER+101;

// static members
BOOL ThreadEventProxy::s_bWndClassRegistered = FALSE;
const LPTSTR ThreadEventProxy::s_szWndClassName = "NAC_TEP_HIDDENWINDOW";

ThreadEventProxy::ThreadEventProxy(IStreamEventNotify *pNotify, HINSTANCE hInst)
{
	WNDCLASSEX wndClass;


	if (s_bWndClassRegistered == FALSE)
	{
		ZeroMemory(&wndClass, sizeof(wndClass));
		wndClass.cbSize = sizeof(wndClass);
		wndClass.style = CS_HREDRAW | CS_VREDRAW;
		wndClass.lpfnWndProc = WndProc;
		wndClass.hInstance = hInst;
		wndClass.lpszClassName = s_szWndClassName;
		RegisterClassEx(&wndClass);
		s_bWndClassRegistered = TRUE;
	}

	m_hwnd = CreateWindow(s_szWndClassName, "Hidden Window",
                          WS_OVERLAPPEDWINDOW, 0, 0, 0, 0,
						  NULL,
						  NULL,
						  hInst,
						  NULL);

	if (m_hwnd)
		SetWindowLongPtr(m_hwnd, GWLP_USERDATA, (LPARAM)this);

	m_pNotify = pNotify;

	return;
}

ThreadEventProxy::~ThreadEventProxy()
{
	MSG msg;

	// just in case there is an outstanding message posted in the
	// queue for this window, clear the 
	if (m_hwnd)
	{
		SetWindowLongPtr(m_hwnd, GWLP_USERDATA, 0);
	}

	while (PeekMessage(&msg, m_hwnd, 0, 0, PM_REMOVE))
	{
		;
	}

	DestroyWindow(m_hwnd);
	m_hwnd = NULL;

}




// static
LPARAM ThreadEventProxy::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	ThreadEventProxy *pTEP;

	pTEP = (ThreadEventProxy*)GetWindowLongPtr(hwnd, GWLP_USERDATA);

	if (pTEP != NULL)
	{
		switch (uMsg)
		{

			case WM_TEP_MESSAGE:
			{
				// the message codes for the stream notifcation are
				// contained
				if (pTEP->m_pNotify)
					pTEP->m_pNotify->EventNotification(HIWORD(wParam), LOWORD(wParam), HIWORD(lParam), LOWORD(lParam));
				return 0;
			}
		}
	}

	return DefWindowProc(hwnd, uMsg, wParam, lParam);

}


BOOL ThreadEventProxy::ThreadEvent(UINT uDirection, UINT uMediaType,
                                   UINT uEventCode, UINT uSubCode)
{
	WPARAM wParam;
	LPARAM lParam;

	wParam = MAKELONG(uMediaType, uDirection);
	lParam = MAKELONG(uSubCode, uEventCode);

	if (m_hwnd)
	{
		PostMessage(m_hwnd, WM_TEP_MESSAGE, wParam, lParam);
		return TRUE;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\txstream.cpp ===
/*
	TxStream.cpp
  */

#include "precomp.h"

TxStream::Initialize ( UINT flags, UINT numBufs, DataPump *pdp, MEDIAPACKETINIT *papi )
{
	UINT i;
	MediaPacket *pAP;


	m_RingSize = numBufs;
	if (flags & DP_FLAG_MMSYSTEM)
	{
		if (m_RingSize > MAX_TXRING_SIZE)
			return FALSE;
	}
	else if (flags & DP_FLAG_VIDEO)
	{
		if (m_RingSize > MAX_TXVRING_SIZE)
			return FALSE;
	}

	m_pDataPump = pdp;
	for (i=0; i < m_RingSize; i++)
	{
		if (flags & DP_FLAG_MMSYSTEM)
        {
            DBG_SAVE_FILE_LINE
			pAP = new AudioPacket;
        }
		else if (flags & DP_FLAG_VIDEO)
        {
            DBG_SAVE_FILE_LINE
			pAP = new VideoPacket;
        }
		else
			break;
		m_Ring[i] = pAP;
		papi->index = i;
		if (!pAP || pAP->Initialize(papi) != DPR_SUCCESS)
			break;
	}
	if (i < m_RingSize)
	{
		for (UINT j=0; j<=i; j++)
		{
			m_Ring[j]->Release();
			delete m_Ring[j];
		}
		return FALSE;
	}

	// queue is empty
	m_SendPos = m_FreePos = 0;
	m_PreSendCount = 1;	// cached silent buffers

	m_TxFlags = 0;

	// initialize object critical section
	InitializeCriticalSection(&m_CritSect);

	return TRUE;
}

TxStream::PutNextRecorded(MediaPacket *pAP)
{
	// insert into queue
	UINT thispos,pos;
	UINT unsent,cb;
	DWORD timestamp,ts;
	UINT spp;
	PVOID pUnused;
	BOOL fMarked;

	EnterCriticalSection(&m_CritSect);
	if (pAP->GetState() == MP_STATE_RECORDED) {
		if ( m_fTalkspurt == FALSE) {
			// beginning of a talkspurt
			thispos = pAP->GetIndex();
			timestamp = pAP->GetTimestamp();
			// figure out the samples per pkt
			//
			spp = 0;	// in case the below call fails
			if (pAP->GetDevData(&pUnused,&cb) == DPR_SUCCESS) {
				spp = cb/2;	// convert bytes to samples assuming 16 bit samples
			}

			// find the number of packets in send queue
			unsent = ModRing(thispos - m_SendPos);
			if (unsent > m_PreSendCount)
				unsent = m_PreSendCount;
			pos = ModRing(thispos - unsent);
			timestamp = timestamp - unsent*spp;
			// if there are (upto PreSendCount) unsent packets before this one, then
			// relabel 'silent' ones as 'recorded'.
			fMarked = FALSE;
			while (pos != thispos) {
				if (m_Ring[pos]->GetState() != MP_STATE_RECORDED) {
					// make sure the buffer is chronologically adjacent
					ts =m_Ring[pos]->GetTimestamp();
					if (ts == timestamp) {
						m_Ring[pos]->SetState(MP_STATE_RECORDED);
						if (!fMarked) {
							fMarked = TRUE;
							m_Ring[pos]->SetProp(MP_PROP_PREAMBLE, 1); // set the RTP Mark bit
						}
						LOG((LOGMSG_PRESEND,pos));
					}
				}
				timestamp += spp;
				pos = ModRing(pos+1);
			}
			m_fTalkspurt = TRUE;
		}
	} else {
		m_fTalkspurt = FALSE;
	}
	pAP->Busy(FALSE);
	LeaveCriticalSection(&m_CritSect);
	return TRUE;
}

// blocking call
// Get Audio packet from head of Transmit queue
// Called by the send thread
#if 0
MediaPacket *TxStream::GetNext()
{
	DWORD waitResult;
	MediaPacket *pAP = NULL;
	UINT pos;

	while (1) {
		// Recorded Packets are queued between SendPos and FreePos
		// Packets owned by the Play device are marked busy 
		EnterCriticalSection(&m_CritSect);
		while (m_SendPos != m_FreePos && !m_Ring[m_SendPos]->Busy()) {
			pos = m_SendPos;
			m_SendPos = ModRing(m_SendPos+1);
			// skip non-data (silence) packets
			if (m_Ring[pos]->GetState() == MP_STATE_RECORDED)  {
				// found a packet
				pAP = m_Ring[pos];
				pAP->Busy(TRUE);
				LeaveCriticalSection(&m_CritSect);
				if (m_fPreamblePacket)
				{
					pAP->SetProp (MP_PROP_PREAMBLE, TRUE);
					m_fPreamblePacket = FALSE;
				}
				return (pAP);
			}
						
		}

		LeaveCriticalSection(&m_CritSect);
		// nothing in the queue
		if (m_TxFlags & DPTFLAG_STOP_SEND)
			break;	// return NULL;
		waitResult = WaitForSingleObject(m_hQEvent, INFINITE);
	}
	return (NULL);
}
#endif
MediaPacket *TxStream::GetNext()
{
	DWORD waitResult;
	MediaPacket *pAP = NULL;
	UINT pos,recpos;

	{
		EnterCriticalSection(&m_CritSect);
		// Recorded Packets are queued between SendPos and FreePos
		// Packets owned by the Play device are marked busy 
		pos = m_SendPos;
		while (pos != m_FreePos && !m_Ring[pos]->Busy()) {
			pos = ModRing(pos+1);
		}
		recpos = pos;	// end marker
		if (recpos != m_SendPos) {

			// skip all but  'm_PreSendCount' silent packets.
			// (later we may decide some of these are not silent after all)
			while (ModRing(recpos-m_SendPos) > m_PreSendCount && m_Ring[m_SendPos]->GetState() != MP_STATE_RECORDED) {
				m_SendPos = ModRing(m_SendPos+1);
			}
			if (m_Ring[m_SendPos]->GetState() == MP_STATE_RECORDED) {
				// found a packet
				pAP = m_Ring[m_SendPos];
				pAP->Busy(TRUE);
				m_SendPos = ModRing(m_SendPos+1);
			}
		} // else recpos == m_SendPos 
		LeaveCriticalSection(&m_CritSect);
	}

	return pAP;

}
MediaPacket *TxStream::GetFree()
{
	UINT pos;
	MediaPacket *pAP;

	EnterCriticalSection(&m_CritSect);
	pos = ModRing(m_FreePos+1);

	if (pos == m_SendPos || m_Ring[pos]->Busy()) {
		LeaveCriticalSection(&m_CritSect);
		return NULL;

	}
	// ASSERT(m_Ring[pos]->GetState() == MP_STATE_RESET);
	// ASSERT(m_Ring[m_FreePos]->GetState() == MP_STATE_RESET);
	// 
	pAP = m_Ring[m_FreePos];
	pAP->Busy(TRUE);
	m_FreePos = pos;
	LeaveCriticalSection(&m_CritSect);
	return pAP;
}

// called by the send thread to free an MediaPacket
void TxStream::Release(MediaPacket *pAP)
{
	pAP->Busy(FALSE);
}

// Try to empty the queue by dumping unsent packets.
// However, we cant do anything about busy packets
UINT TxStream::Reset(void)
{
	UINT pos;
	BOOL success;
	EnterCriticalSection(&m_CritSect);
	pos = m_FreePos;
	// allow send thread to block on new packets
	m_TxFlags &= ~DPTFLAG_STOP_SEND;
	while (pos != m_SendPos && !m_Ring[pos]->Busy()) {
		pos = ModRing(pos+1);
	}
	if (pos == m_SendPos) {
		// good - no buffers with send thread
		while ( pos != m_FreePos && !m_Ring[pos]->Busy()) {
			m_Ring[pos]->MakeSilence();
			pos = ModRing(pos+1);
		}
		m_SendPos = pos;
		success = TRUE;
	} else {
		// bad - buffers have not been released by send thread
		// could sleep
		success = FALSE;
	}
	LOG((LOGMSG_TX_RESET, m_FreePos, m_SendPos));
	LeaveCriticalSection(&m_CritSect);
	return success;
}

void TxStream::Stop(void)
{
	EnterCriticalSection(&m_CritSect);
	m_TxFlags |= DPTFLAG_STOP_SEND;
	LeaveCriticalSection(&m_CritSect);
	
	return;

}

TxStream::Destroy(void)
{
	UINT i;
	for (i=0; i < m_RingSize; i++) {
		if (m_Ring[i]) {
			m_Ring[i]->Release();
			delete m_Ring[i];
		}
	}

	DeleteCriticalSection(&m_CritSect);
	return DPR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\threadsv.cpp ===
#include "precomp.h"

// #define LOGSTATISTICS_ON 1

#define RTPTIMEPERMS	90	// RTP timestamps use a 90Khz clock
DWORD g_iPost = 0UL;

// Constants
#define POLL_PERIOD 30


void
CALLBACK
TimeCallback(
    UINT uID,	
    UINT uMsg,	
    HANDLE hEvent,	
    DWORD dw1,	
    DWORD dw2	
    )
{
    SetEvent (hEvent);    // signal to initiate frame grab
}


DWORD SendVideoStream::CapturingThread (void )
{
    DWORD lasttime;
    IBitmapSurface* pBS;
	VideoPacket *pPacket;
	DWORD dwWait;
	HANDLE hEvent;
	HCAPDEV hCapDev;
	DWORD_PTR dwPropVal;
	DWORD dwBeforeCapture;
	DWORD dwFrames = 0;
	DWORD dwOver = 0;
	DWORD dwStart;
	UINT u;
	UINT uPreambleCount = 2;
	UINT uTimeout = 0;
	DevMediaQueue dq;
    SendVideoStream     *pMC = this;
	TxStream			*pStream = pMC->m_SendStream;
	MediaControl		*pMediaCtrl = pMC->m_InMedia;
    UINT    timerID;
    LPBITMAPINFOHEADER pbmih;
	HRESULT hr = DPR_SUCCESS;

#ifdef LOGSTATISTICS_ON
	char szDebug[256];
	HANDLE hDebugFile;
	DWORD d;
	DWORD dwDebugPrevious = 0UL;
#endif
	DWORD dwDelta;

	FX_ENTRY ("DP::CaptTh:")

	// get thread context
	if (pStream == NULL || m_pVideoFilter == NULL || pMediaCtrl == NULL)
	{
		return DPR_INVALID_PARAMETER;
	}

	// get thresholds
	pMediaCtrl->GetProp (MC_PROP_TIMEOUT, &dwPropVal);
	uTimeout = (DWORD)dwPropVal;

	// set dq size
	dq.SetSize (MAX_TXVRING_SIZE);

	pMediaCtrl->GetProp (MC_PROP_MEDIA_DEV_HANDLE, &dwPropVal);
	if (!dwPropVal)
	{
		DEBUGMSG (ZONE_DP, ("%s: capture device not open (0x%lX)\r\n", _fx_));
    	goto MyEndThread;
	}
    hCapDev = (HCAPDEV)dwPropVal;

#if 0
	// hey, in the very beginning, let's 'Start' it
	hr = pMediaCtrl->Start ();
	if (hr != DPR_SUCCESS)
	{
		DEBUGMSG (ZONE_DP, ("%s: MedVidCtrl::Start failed, hr=0x%lX\r\n", _fx_, hr));
		goto MyEndThread;
	}
#endif

	// update timestamp to account for the 'sleep' period
	dwPropVal = timeGetTime();
	pMC->m_SendTimestamp += ((DWORD)dwPropVal - pMC->m_SavedTickCount)*RTPTIMEPERMS;
	pMC->m_SavedTickCount = (DWORD)dwPropVal;

	// Enter critical section: QoS thread also reads the statistics
	EnterCriticalSection(&pMC->m_crsVidQoS);

	// Initialize QoS structure
	ZeroMemory(&pMC->m_Stats, 4UL * sizeof(DWORD));

	// Initialize oldest QoS callback timestamp
	pMC->m_Stats.dwNewestTs = pMC->m_Stats.dwOldestTs = (DWORD)dwPropVal;

	// Leave critical section
	LeaveCriticalSection(&pMC->m_crsVidQoS);

	// let's get into the loop
	pMC->m_fSending= TRUE;

    // get event handle
    if (!(hEvent = CreateEvent(NULL, FALSE, FALSE, NULL))) {
        DEBUGMSG (ZONE_DP, ("%s: invalid event\r\n", _fx_));
        hr = DPR_CANT_CREATE_EVENT;
        goto MyEndThread;
    }

    if (!(timerID = timeSetEvent(POLL_PERIOD, 1, (LPTIMECALLBACK)&TimeCallback, (DWORD_PTR)hEvent, TIME_PERIODIC))) {
        DEBUGMSG (ZONE_DP, ("%s: failed to init MM timer\r\n", _fx_));
        CloseHandle (hEvent);
        hr = DPR_CANT_CREATE_EVENT;
        goto MyEndThread;
    }

	// force I-Frames to be sent for the first few frames
	// to make sure that the receiver gets one
	pMC->m_ThreadFlags |= DPTFLAG_SEND_PREAMBLE;

    pPacket = NULL;
    lasttime = timeGetTime();
    dwStart = lasttime;
	while (!(pMC->m_ThreadFlags & DPTFLAG_STOP_RECORD))
    {
		dwWait = WaitForSingleObject (hEvent, uTimeout);

		// see why I don't need to wait
		if ((dwWait != WAIT_TIMEOUT) && !(pMC->m_ThreadFlags & DPTFLAG_PAUSE_CAPTURE)) {
            if (!pPacket) {
	            if (pPacket = (VideoPacket *)pStream->GetFree()) {
                    if ((hr = pPacket->Record()) != DPR_SUCCESS) {
			    	    DEBUGMSG (ZONE_DP, ("%s: Capture FAILED, hr=0x%lX\r\n", _fx_, hr));
				        break;
    				}
	    		}
		    }

            dwBeforeCapture = timeGetTime();

	    	if (pPacket && pMC->m_pCaptureChain && dwBeforeCapture - lasttime >= pMC->m_frametime) {
                // If there's no frame ready, bail out of the loop and wait
                // until we get signaled.

#ifdef LOGSTATISTICS_ON
				hDebugFile = CreateFile("C:\\Timings.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
				SetFilePointer(hDebugFile, 0, NULL, FILE_END);
				wsprintf(szDebug, "Delta: %ld\r\n", dwBeforeCapture - dwDebugPrevious);
				WriteFile(hDebugFile, szDebug, strlen(szDebug), &d, NULL);
				CloseHandle(hDebugFile);
				dwDebugPrevious = dwBeforeCapture;
#endif

				dwDelta = dwBeforeCapture - lasttime - pMC->m_frametime;

#if 0
                if ((ci_state & CAPSTATE_INDLG) && lpbmih) {
                    lpbmih->biSize = GetCaptureDeviceFormatHeaderSize(g_hcapdev);
                    if (!GetCaptureDeviceFormat(g_hcapdev, lpbmih) ||
                        g_lpbmi->biSize != lpbmih->biSize ||
                        g_lpbmi->biSizeImage != lpbmih->biSizeImage)
                        continue;   // skip capture
                }
#endif

                pMC->m_pCaptureChain->GrabFrame(&pBS);

                if (pBS) {
                    // deal with captured frame

            	    if (!(pMC->m_DPFlags & DPFLAG_REAL_THING)) {
            	        dwWait = timeGetTime();
            	        dwOver += (dwWait - dwBeforeCapture);
                        if (++dwFrames == 20) {
                            dwWait -= dwStart;
                            dwOver = (dwOver * 13) / 10;    // 130%
                            pMC->m_frametime = (pMC->m_frametime * dwOver) / dwWait;
                            pMC->m_frametime = (pMC->m_frametime * 13) / 10;    // 130%
                            if (pMC->m_frametime < 50)
                                pMC->m_frametime = 50;
                            else if (pMC->m_frametime > 1000)
                                pMC->m_frametime = 1000;
                    	    dwOver = dwFrames = 0;   // restart tracking
                    	    dwStart = timeGetTime();
                        }
                    }

				    if (pMC->m_fSending) {
	    			    dwPropVal = timeGetTime();	// returns time in millisec

						// Enter critical section: QoS thread also reads the statistics
						EnterCriticalSection(&pMC->m_crsVidQoS);
						
						// If this is the first frame captured with a new frame rate value,
						// the delta isn't valid anymore -> reset it
						if (pMC->m_Stats.dwCount == 0)
							dwDelta = 0;

						// Update total number of frames captured
						pMC->m_Stats.dwCount++;

						// Add this capture time to total capture time
						// If we can access the CPU perf counters Ok, we won't use this value
						pMC->m_Stats.dwMsCap += (DWORD)dwPropVal - dwBeforeCapture;

						// Leave critical section
						LeaveCriticalSection(&pMC->m_crsVidQoS);
						
	    			    // convert to RTP time units (1/90Khz for video)
    				    pMC->m_SendTimestamp += ((DWORD)dwPropVal- pMC->m_SavedTickCount) * RTPTIMEPERMS;
						pMC->m_SavedTickCount = (DWORD)dwPropVal;

    				    pPacket->SetProp(MP_PROP_TIMESTAMP,pMC->m_SendTimestamp);
                    	pPacket->SetSurface(pBS);
					    pPacket->SetState(MP_STATE_RECORDED);
	    			    pStream->PutNextRecorded (pPacket);
		    		    pMC->Send();
				    	if (uPreambleCount) {
				    		if (!--uPreambleCount) {
				    			// return to default I-frame spacing
				    			pMC->m_ThreadFlags &= ~DPTFLAG_SEND_PREAMBLE;
				    		}
				    	}
				    	pPacket = NULL;

                        // Indicate that another frame was sent
                        UPDATE_COUNTER(g_pctrVideoSend, 1);
                    }

                    // release captured frame
                    pBS->Release();
                    lasttime = dwBeforeCapture - dwDelta;
            	}
#ifdef LOGSTATISTICS_ON
				else
				{
					hDebugFile = CreateFile("C:\\Timings.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
					SetFilePointer(hDebugFile, 0, NULL, FILE_END);
					WriteFile(hDebugFile, "No Frame grabbed\r\n", 16, &d, NULL);
					CloseHandle(hDebugFile);
				}
#endif
	        }
#ifdef LOGSTATISTICS_ON
			else
			{
				hDebugFile = CreateFile("C:\\Timings.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
				SetFilePointer(hDebugFile, 0, NULL, FILE_END);
				if (!pPacket)
					WriteFile(hDebugFile, "No Frame Ready (pPacket is NULL)\r\n", 35, &d, NULL);
				else
				{
					if (!pMC->m_pCaptureChain)
						WriteFile(hDebugFile, "No Frame Ready (CapChain is NULL)\r\n", 33, &d, NULL);
					else
						WriteFile(hDebugFile, "No Frame Ready (Timings are bad)\r\n", 32, &d, NULL);
				}
				CloseHandle(hDebugFile);
			}
#endif
		}
    }

	// Enter critical section: QoS thread also reads the statistics
	EnterCriticalSection(&pMC->m_crsVidQoS);

	// Reset number of captured frames
	pMC->m_Stats.dwCount = 0;

	// Leave critical section
	LeaveCriticalSection(&pMC->m_crsVidQoS);

    if (pPacket) {
    	pPacket->Recycle();
		pStream->Release(pPacket);
    	pPacket = NULL;
    }

    timeKillEvent(timerID);

    CloseHandle (hEvent);

	// Ensure no outstanding preview frames
	pMC->EndSend();

	// stop and reset capture device
	pMediaCtrl->Reset ();

	// save real time so we can update the timestamp when we restart
	pMC->m_SavedTickCount = timeGetTime();

MyEndThread:

	pMC->m_fSending = FALSE;
	DEBUGMSG (ZONE_DP, ("%s: Exiting.\r\n", _fx_));
	return hr;
}


DWORD RecvVideoStream::RenderingThread ( void)
{
	HRESULT hr = DPR_SUCCESS;
	MediaPacket * pPacket;
	DWORD dwWait;
	DWORD rtpTs, rtpSyncTs;
	HANDLE hEvent;
	DWORD_PTR dwPropVal;
	UINT uTimeout = 0;
	UINT uGoodPacketsQueued = 0;
	RecvVideoStream *pMC = this;
	RxStream			*pStream = pMC->m_RecvStream;
	MediaControl		*pMediaCtrl = pMC->m_OutMedia;

	FX_ENTRY ("DP::RenderingTh")

	if (pStream == NULL || pMediaCtrl == NULL)
	{
		return DPR_INVALID_PARAMETER;
	}

	// get event handle
	pMediaCtrl->GetProp (MC_PROP_EVENT_HANDLE, &dwPropVal);
	hEvent = (HANDLE) dwPropVal;
	if (hEvent == NULL)
	{
		DEBUGMSG (ZONE_DP, ("%s: invalid event\r\n", _fx_));
		return DPR_CANT_CREATE_EVENT;
	}


	// get thresholds
	pMediaCtrl->GetProp (MC_PROP_TIMEOUT, &dwPropVal);
	uTimeout = (DWORD)dwPropVal;

	pMC->m_RecvStream->FastForward(FALSE);	// flush receive queue

	// Notification is not used. if needed do it thru Channel
	//if (pMC->m_Connection)
	//	pMC->m_Connection->DoNotification(CONNECTION_OPEN_REND);

	pMC->m_fReceiving = TRUE;

	// Since we dont have reliable sender RTP timestamps yet,
	// follow the simplistic approach of playing
	// back frames as soon as they are available
	// with no attempt at reconstructing the timing

	// The RecvVidThread will signal an event when
	// it has received and decoded a frame. We wake up on
	// that event and call GetNextPlay().
	// This will keep the Recv queue moving with the
	// latest decoded packet ready to be given to the
	// app for rendering.
	
	while (!(pMC->m_ThreadFlags & DPTFLAG_STOP_PLAY))
    {
		dwWait = WaitForSingleObject (hEvent, uTimeout);
		ASSERT(dwWait != WAIT_FAILED);
		// see why I don't need to wait
		if (dwWait != WAIT_TIMEOUT) {
			if (pMC->m_DPFlags & DPFLAG_AV_SYNC) {
				// find out the timestamp of the frame to be played
				//
				NTP_TS ntpTs;
				rtpSyncTs = 0;
#ifdef OLDSTUFF
				if (m_Audio.pRecvStream && m_Audio.pRecvStream->GetCurrentPlayNTPTime(&ntpTs) == DPR_SUCCESS)
					pMC->m_Net->NTPtoRTP(ntpTs,&rtpSyncTs);
#endif
			}
			while (pStream->NextPlayablePacketTime(&rtpTs)) {
				// there is a playable packet in the queue
				if ((pMC->m_DPFlags & DPFLAG_AV_SYNC) && rtpSyncTs != 0) {
					LOG((LOGMSG_TESTSYNC,rtpTs, rtpSyncTs));
					if (TS_LATER(rtpTs,rtpSyncTs))
						break; // its time has not come
				}
				// get the packet.
				pPacket = pStream->GetNextPlay ();	
				if (pPacket  != NULL)
				{
					if (pPacket->GetState () != MP_STATE_DECODED) {
						pPacket->Recycle();
						pStream->Release(pPacket);
					} else
					{
						LOG((LOGMSG_VID_PLAY,pPacket->GetIndex(), GetTickCount()));
						EnterCriticalSection(&pMC->m_crs);
						pPacket->SetState(MP_STATE_PLAYING_BACK);
						pMC->m_PlaybackTimestamp = pPacket->GetTimestamp();
						if (pMC->m_pNextPacketToRender) {
							if (!pMC->m_pNextPacketToRender->m_fRendering) {
								// the app is not referencing the frame.
								pMC->m_pNextPacketToRender->Recycle();
								pStream->Release(pMC->m_pNextPacketToRender);
							} else {
								// it will get Recycled and Released later when the app
								// calls ReleaseFrame()
							}
							uGoodPacketsQueued--;
						}
						pMC->m_pNextPacketToRender = pPacket;
						LeaveCriticalSection(&pMC->m_crs);
						if(pMC->m_pfFrameReadyCallback)
						{
							(pMC->m_pfFrameReadyCallback)((DWORD_PTR)pMC->m_hRenderEvent);
						}
						else if (pMC->m_hRenderEvent)
							SetEvent(pMC->m_hRenderEvent);
						
						uGoodPacketsQueued++;

                        // Indicate that another frame was sent
                        UPDATE_COUNTER(g_pctrVideoReceive, 1);
					}
				}	// if (pPacket != NULL)
			}	// while
		}
	}



	pMC->m_fReceiving = FALSE;

	// Notification is not used. if needed do it thru Channel
	//if (pMC->m_Connection)
	//	pMC->m_Connection->DoNotification(CONNECTION_CLOSE_REND);

	// wait till all frames being rendered are returned
	// typically wont be more than one
	while (pMC->m_cRendering || pMC->m_pNextPacketToRender) {
		EnterCriticalSection(&pMC->m_crs);
		if (pMC->m_pNextPacketToRender && !pMC->m_pNextPacketToRender->m_fRendering) {
			// the app is not referencing the current frame.
			pMC->m_pNextPacketToRender->Recycle();
			pStream->Release(pMC->m_pNextPacketToRender);
			// no more frames till the thread is restarted
			pMC->m_pNextPacketToRender = NULL;
			LeaveCriticalSection(&pMC->m_crs);
		} else {
			// wait till the app  Releases it
			//
			LeaveCriticalSection(&pMC->m_crs);
			Sleep(100);
			DEBUGMSG(ZONE_DP, ("%s: Waiting for final ReleaseFrame()\n",_fx_));
		}
	}
	// reset the event we're waiting on.
	ResetEvent (hEvent);


	DEBUGMSG(ZONE_DP, ("%s: Exiting.\n", _fx_));
	return hr;
}

DWORD SendVideoStream::Send(void)
{
	BOOL fNewPreviewFrame = FALSE, bRet;
	MediaPacket *pVP;
	DWORD dwBeforeEncode;
	DWORD dwAfterEncode;
	UINT uBytesSent;
	MMRESULT mmr;
	DWORD dwEncodeFlags;
#ifdef LOGSTATISTICS_ON
	char szDebug[256];
	DWORD dwDebugSaveBits;
#endif

	while (pVP = m_SendStream->GetNext()) {
		EnterCriticalSection(&m_crs);
		if (m_pNextPacketToRender) {
			// free the last preview packet if its not being referenced
			// thru the IVideoRender API.
			// if it is being referenced ( fRendering is set), then it
			// will be freed in IVideoRender->ReleaseFrame()
			if (!m_pNextPacketToRender->m_fRendering) {
				m_pNextPacketToRender->Recycle();
				m_SendStream->Release(m_pNextPacketToRender);
			}
		}
		m_pNextPacketToRender = pVP;
		fNewPreviewFrame = TRUE;
		LeaveCriticalSection(&m_crs);
		
		if (!(m_ThreadFlags & DPTFLAG_PAUSE_SEND)) {
			dwBeforeEncode = timeGetTime();


			if (m_ThreadFlags & DPTFLAG_SEND_PREAMBLE)
				dwEncodeFlags = VCM_STREAMCONVERTF_FORCE_KEYFRAME;
			else
				dwEncodeFlags = 0;

			mmr = m_pVideoFilter->Convert((VideoPacket*)pVP, VP_ENCODE, dwEncodeFlags);
			if (mmr == MMSYSERR_NOERROR)
			{
				pVP->SetState(MP_STATE_ENCODED);
			}

			// Save the perfs in our stats structure for QoS
			dwAfterEncode = timeGetTime() - dwBeforeEncode;

			//HACKHACK bugbug, until we support fragmentation, set the marker bit always.
			pVP->SetProp (MP_PROP_PREAMBLE,TRUE);

			if (mmr == MMSYSERR_NOERROR)
			{
				SendPacket((VideoPacket*)pVP, &uBytesSent);
			}
			else
			{
				uBytesSent = 0;
			}

			// reset the packet and return it to the free queue
			pVP->m_fMark=0;
			pVP->SetState(MP_STATE_RESET);
			m_SendStream->Release(pVP);

			UPDATE_COUNTER(g_pctrVideoSendBytes, uBytesSent * 8);

			// Enter critical section: QoS thread also reads the statistics
			EnterCriticalSection(&m_crsVidQoS);

			// Add this compression time to total compression time
			// If we can access the CPU perf counters Ok, we won't use this value
			m_Stats.dwMsComp += dwAfterEncode;

#ifdef LOGSTATISTICS_ON
			dwDebugSaveBits = m_Stats.dwBits;
#endif
			// Add this new frame size to the cumulated size
			m_Stats.dwBits += uBytesSent * 8;

#ifdef LOGSTATISTICS_ON
			wsprintf(szDebug, " V: dwBits = %ld up from %ld (file: %s line: %ld)\r\n", m_Stats.dwBits, dwDebugSaveBits, __FILE__, __LINE__);
			OutputDebugString(szDebug);
#endif
			// Leave critical section
			LeaveCriticalSection(&m_crsVidQoS);

			//LOG((LOGMSG_SENT,GetTickCount()));
		}
		//m_SendStream->Release(pVP);
	}
	// Signal the IVideoRender event if we have a new frame.
	
	if (fNewPreviewFrame)
	{
		if(m_pfFrameReadyCallback)
		{
			(m_pfFrameReadyCallback)((DWORD_PTR)m_hRenderEvent);
		}
		else if(m_hRenderEvent)
			SetEvent(m_hRenderEvent);
	}	
	return DPR_SUCCESS;
}


/* Wait till all preview packets are released by the UI.
	Typically there wont be more than one
*/
void SendVideoStream::EndSend()
{
	while (m_cRendering || m_pNextPacketToRender) {
		EnterCriticalSection(&m_crs);
	
		// free the last preview packet if its not being referenced
		// thru the IVideoRender API.
		if (m_pNextPacketToRender && !m_pNextPacketToRender->m_fRendering) {
			m_pNextPacketToRender->Recycle();
			m_SendStream->Release(m_pNextPacketToRender);
			m_pNextPacketToRender = NULL;
			LeaveCriticalSection(&m_crs);
		} else {
			LeaveCriticalSection(&m_crs);
			Sleep(100);
			DEBUGMSG(ZONE_DP,("DP::EndSendVideo: Waiting for final Release Frame\n"));
		}
	}
}


HRESULT SendVideoStream::SendPacket(VideoPacket *pVP, UINT *puBytesSent)
{
	PS_QUEUE_ELEMENT psq;
	UINT uLength;
	DWORD dwPacketSize, dwHdrSize, dwHdrSizeAlloc, dwPacketCount=0;
	int nPacketsSent=0;
	UINT uPacketIndex, fMark=0;
	MMRESULT mmr;
	PBYTE pHdrInfo, netData, netDataPacket;

	*puBytesSent = 0;

	if (pVP->GetState() != MP_STATE_ENCODED)
	{
		DEBUGMSG (ZONE_VCM, ("SendVideoStream::SendPacket: Packet not compressed\r\n"));
		return E_FAIL;
	}


//	m_Net->QueryInterface(IID_IRTPSend, (void**)&pIRTPSend);
	ASSERT(m_pRTPSend);


	// these stay the same for video
	psq.pMP = pVP;
	psq.dwPacketType = PS_VIDEO;
//	psq.pRTPSend = pIRTPSend;
	psq.pRTPSend = m_pRTPSend;

	pVP->GetNetData((void**)(&netData), &uLength);
	ASSERT(netData);

	m_pVideoFilter->GetPayloadHeaderSize(&dwHdrSizeAlloc);

	do
	{

		if (dwHdrSizeAlloc)
			pHdrInfo = (BYTE*)MemAlloc(dwHdrSizeAlloc);
		else
			pHdrInfo = NULL;

		mmr = m_pVideoFilter->FormatPayload(netData,
		                                    uLength,
		                                    &netDataPacket,
		                                    &dwPacketSize,
		                                    &dwPacketCount,
		                                    &fMark,
		                                    &pHdrInfo,
		                                    &dwHdrSize);

		if (mmr == MMSYSERR_NOERROR)
		{
			psq.data = netDataPacket;
			psq.dwSize = dwPacketSize;
			psq.fMark = fMark;
			psq.pHeaderInfo = pHdrInfo;
			psq.dwHdrSize = dwHdrSize;
			m_pDP->m_PacketSender.m_SendQueue.PushRear(psq);
			*puBytesSent = *puBytesSent + dwPacketSize + sizeof(RTP_HDR) + IP_HEADER_SIZE + UDP_HEADER_SIZE;
		}
		else
		{
			MemFree((BYTE *)pHdrInfo);
		}

	} while (mmr == MMSYSERR_NOERROR);


	while (m_pDP->m_PacketSender.SendPacket())
	{
		;
	}



//	pIRTPSend->Release();

	return S_OK;

};



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\threadevent.h ===
#ifndef _NAC_TEP_H_
#define _NAC_TEP_H_

#include "imstream.h"

extern const int WM_TEP_MESSAGE;

#include <pshpack8.h> /* Assume 8 byte packing throughout */


class ThreadEventProxy
{
public:

	ThreadEventProxy(IStreamEventNotify *pNotify, HINSTANCE hInstance);
	~ThreadEventProxy();

	BOOL ThreadEvent(UINT uDirection, UINT uMediaType,
	            UINT uEventCode, UINT uSubCode);

private:
	HWND m_hwnd;  // hidden Window
	IStreamEventNotify *m_pNotify;


	static LPARAM __stdcall WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	static BOOL s_bWndClassRegistered;
	static const LPTSTR s_szWndClassName;
};

#include <poppack.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\txstream.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    txstream.h

Abstract:
	The TxStream class maintains a queue of MediaPackets. The record thread gets a free buffer
	(GetFree), records into the buffer and puts it in the queue (PutNextWaveIn) from where it is
	removed (GetNext),	decoded and sent on the network.
	The queue is implemented as a circular array with m_SendPos marking the index
	of the next recorded buffer.

--*/
#ifndef _TXSTREAM_H_
#define _TXSTREAM_H_


#include <pshpack8.h> /* Assume 8 byte packing throughout */

#define MAX_TXRING_SIZE 8
#define MAX_TXVRING_SIZE 4

class TxStream {
public:
	BOOL Initialize(UINT flags, UINT size, DataPump *pdp, MEDIAPACKETINIT *papi);
	BOOL PutNextRecorded(MediaPacket *);
	MediaPacket *GetFree();
	MediaPacket *GetNext();
	void Release(MediaPacket *);
	void Stop();
	UINT Reset();
	void GetRing ( MediaPacket ***pppAudPckt, ULONG *puSize ) { *pppAudPckt = &m_Ring[0]; *puSize = (ULONG) m_RingSize; }
	BOOL Destroy();
private:
	MediaPacket *m_Ring[MAX_TXRING_SIZE];
	UINT m_RingSize;
	UINT m_FreePos;
	UINT m_SendPos;
	UINT m_PreSendCount;
	HANDLE m_hQEvent;
	UINT m_TxFlags;
	CRITICAL_SECTION m_CritSect;
	DataPump *m_pDataPump;
	UINT ModRing(UINT i) {return (i & (m_RingSize-1));}
	BOOL m_fPreamblePacket;
	BOOL m_fTalkspurt;
};

#include <poppack.h> /* End byte packing */

#endif // _TXSTREAM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\threads.cpp ===
#include "precomp.h"
#include "mixer.h"
#include "agc.h"

// #define LOGSTATISTICS_ON 1

DWORD SendAudioStream::RecordingThread ()
{
	HRESULT hr = DPR_SUCCESS;
	MediaPacket *pPacket;
	DWORD dwWait;
	HANDLE hEvent;
	DWORD dwDuplexType;
	DWORD dwVoiceSwitch;
	DWORD_PTR dwPropVal;
	DWORD dwSamplesPerPkt;
	DWORD dwSamplesPerSec;
	DWORD dwSilenceLimit, dwMaxStrength, dwLengthMS;
	WORD wPeakStrength;
	UINT u, uBufferSize;
	UINT uSilenceCount = 0;
	UINT uPrefeed = 0;
	UINT uTimeout = 0;
	DevMediaQueue dq;
	BOOL  fSilent;
	AGC agc(NULL);  // audio gain control object
	CMixerDevice *pMixer = NULL;
	int nFailCount = 0;
	bool bCanSignalOpen=true;  // should we signal that the device is open

	// note: pMC is an artifact of when this thread was in the Datapump
	// namespace.  We can probably start phasing this variable out.
	// in the mean time:  "pMC = this" will suffice

	// SendAudioStream *pMC = (SendAudioStream *)(m_pDP->m_Audio.pSendStream);
	SendAudioStream *pMC = this;

	ASSERT(pMC && (pMC->m_DPFlags  & DPFLAG_INITIALIZED));
	
	TxStream		*pStream = pMC->m_SendStream;
	AcmFilter	*pAudioFilter = pMC->m_pAudioFilter;
	// warning: typecasting a base class ptr to a derived class ptr.
	WaveInControl	*pMediaCtrl = (WaveInControl *)pMC->m_InMedia;

	FX_ENTRY ("DP::RcrdTh:")

	// get thread context
	if (pStream == NULL || pAudioFilter == NULL || pMediaCtrl == NULL)
	{
		return DPR_INVALID_PARAMETER;
	}

	// Enter critical section: QoS thread also reads the statistics
	EnterCriticalSection(&pMC->m_crsQos);

	// Initialize QoS structure
	ZeroMemory(&pMC->m_Stats, 4UL * sizeof(DWORD));

	// Initialize oldest QoS callback timestamp
	pMC->m_Stats.dwNewestTs = pMC->m_Stats.dwOldestTs = timeGetTime();

	// Leave critical section
	LeaveCriticalSection(&pMC->m_crsQos);

	pMediaCtrl->GetProp(MC_PROP_MEDIA_DEV_ID, &dwPropVal);
	if (dwPropVal != (DWORD)WAVE_MAPPER)
	{
		pMixer = CMixerDevice::GetMixerForWaveDevice(NULL, (DWORD)dwPropVal, MIXER_OBJECTF_WAVEIN);
	}

	// even if pMixer is null, this is fine, AGC will catch subsequent errors
	agc.SetMixer(pMixer);

	// get thresholds
	pMediaCtrl->GetProp (MC_PROP_TIMEOUT, &dwPropVal);
	uTimeout = (DWORD)dwPropVal;
	pMediaCtrl->GetProp (MC_PROP_PREFEED, &dwPropVal);
	uPrefeed = (DWORD)dwPropVal;

	// get duplex type
	pMediaCtrl->GetProp (MC_PROP_DUPLEX_TYPE, &dwPropVal);
    dwDuplexType = (DWORD)dwPropVal;

	// get Samples/Pkt and Samples/Sec
	pMediaCtrl->GetProp (MC_PROP_SPP, &dwPropVal);
    dwSamplesPerPkt = (DWORD)dwPropVal;

	pMediaCtrl->GetProp (MC_PROP_SPS, &dwPropVal);
    dwSamplesPerSec = (DWORD)dwPropVal;

	pMediaCtrl->GetProp (MC_PROP_SILENCE_DURATION, &dwPropVal);
    dwSilenceLimit = (DWORD)dwPropVal;

	// calculate silence limit in units of packets
	// silence_time_in_ms/packet_duration_in_ms
	dwSilenceLimit = dwSilenceLimit*dwSamplesPerSec/(dwSamplesPerPkt*1000);

	// length of a packet in millisecs
	dwLengthMS = (dwSamplesPerPkt * 1000) / dwSamplesPerSec;


	dq.SetSize (MAX_TXRING_SIZE);

WaitForSignal:

	// DEBUGMSG (1, ("%s: WaitForSignal\r\n", _fx_));


	{
		pMediaCtrl->GetProp (MC_PROP_MEDIA_DEV_HANDLE, &dwPropVal);
		if (dwPropVal)
		{
			DEBUGMSG (ZONE_DP, ("%s: already open\r\n", _fx_));
			goto SendLoop; // sound device already open
		}

		// in the full-duplex case, open and prepare the device  and charge ahead.
		// in the half duplex case wait for playback's signal before opening the device
		while (TRUE)
		{
			// should I stop now???
			if (pMC->m_ThreadFlags & DPTFLAG_STOP_RECORD)
			{
				DEBUGMSG (ZONE_DP, ("%s: STOP_1\r\n", _fx_));
				goto MyEndThread;
			}
			dwWait = (dwDuplexType & DP_FLAG_HALF_DUPLEX) ? WaitForSingleObject (g_hEventHalfDuplex, uTimeout)
				: WAIT_OBJECT_0;

			// now, let's check why I don't need to wait
			if (dwWait == WAIT_OBJECT_0)
			{
				//DEBUGMSG (ZONE_DP, ("%s: try to open audio dev\r\n", _fx_));
				LOG((LOGMSG_OPEN_AUDIO));
				hr = pMediaCtrl->Open ();
				if (hr != DPR_SUCCESS)
				{
					DEBUGMSG (ZONE_DP, ("%s: MediaCtrl::Open failed, hr=0x%lX\r\n", _fx_, hr));
					
					pMediaCtrl->SetProp(MC_PROP_AUDIO_JAMMED, TRUE);

					SetEvent(g_hEventHalfDuplex);

					nFailCount++;

					if (nFailCount == MAX_FAILCOUNT)
					{
						// three attempts to open the device have failed
						// signal to the UI that something is wrong
						m_pDP->StreamEvent(MCF_SEND, MCF_AUDIO, STREAM_EVENT_DEVICE_FAILURE, 0);
						bCanSignalOpen = true;
					}

					Sleep(2000);	// Sleep for two seconds

					continue;
				}
				// Notification is not used. if needed do it thru Channel
				//pMC->m_Connection->DoNotification(CONNECTION_OPEN_MIC);
				pMediaCtrl->PrepareHeaders ();
				goto SendLoop;
			}

		} // while
	}	


SendLoop:
	nFailCount = 0;

	pMediaCtrl->SetProp(MC_PROP_AUDIO_JAMMED, FALSE);
	if (bCanSignalOpen)
	{
		m_pDP->StreamEvent(MCF_SEND, MCF_AUDIO, STREAM_EVENT_DEVICE_OPEN, 0);
		bCanSignalOpen = false; // don't signal more than once per session
	}

	// DEBUGMSG (1, ("%s: SendLoop\r\n", _fx_));
	// get event handle
	pMediaCtrl->GetProp (MC_PROP_EVENT_HANDLE, &dwPropVal);
	hEvent = (HANDLE) dwPropVal;
	if (hEvent == NULL)
	{
		DEBUGMSG (ZONE_DP, ("%s: invalid event\r\n", _fx_));
		return DPR_CANT_CREATE_EVENT;
	}


	// hey, in the very beginning, let's 'Start' it
	hr = pMediaCtrl->Start ();
	if (hr != DPR_SUCCESS)
	{
		DEBUGMSG (ZONE_DP, ("%s: MediaControl::Start failed, hr=0x%lX\r\n", _fx_, hr));
		goto MyEndThread;
	}

	// update timestamp to account for the 'sleep' period
	pMC->m_SendTimestamp += (GetTickCount() - pMC->m_SavedTickCount)*dwSamplesPerSec/1000;

	// let's feed four buffers first
	for (u = 0; u < uPrefeed; u++)
	{
		if ((pPacket = pStream->GetFree ()) != NULL)
		{
			if ((hr = pPacket->Record ()) != DPR_SUCCESS)
			{
				DEBUGMSG (ZONE_DP, ("%s: Record failed, hr=0x%lX\r\n", _fx_, hr));
			}
			dq.Put (pPacket);
		}
	}

	// let's get into the loop, mm system notification loop
	pMC->m_fSending= FALSE;
	while (TRUE)
	{
		dwWait = WaitForSingleObject (hEvent, uTimeout);

		// should I stop now???
		if (pMC->m_ThreadFlags & DPTFLAG_STOP_RECORD)
		{
			DEBUGMSG (ZONE_DP, ("%s: STOP_3\r\n", _fx_));
			goto HalfDuplexYield;
		}
		
		// get current voice switching mode
		pMediaCtrl->GetProp (MC_PROP_VOICE_SWITCH, &dwPropVal);
        dwVoiceSwitch = (DWORD)dwPropVal;

		// see why I don't need to wait
		if (dwWait != WAIT_TIMEOUT)
		{
			while (TRUE)
			{
				if ((pPacket = dq.Peek ()) != NULL)
				{
					if (! pPacket->IsBufferDone ())
					{
						break;
					}
					else
					{
						if (pMC->m_mmioSrc.fPlayFromFile && pMC->m_mmioSrc.hmmioSrc)
							pPacket->ReadFromFile (&pMC->m_mmioSrc);
						u--;	// one less buffer with the wave device
					}
				}
				else
				{
					DEBUGMSG (ZONE_VERBOSE, ("%s: Peek is NULL\r\n", _fx_));
					break;
				}

				pPacket = dq.Get ();


				((AudioPacket*)pPacket)->ComputePower (&dwMaxStrength, &wPeakStrength);

				// is this packet silent?

				fSilent = pMC->m_AudioMonitor.SilenceDetect((WORD)dwMaxStrength);
	
				if((dwVoiceSwitch == DP_FLAG_AUTO_SWITCH)
				&& fSilent)
				{
					// pPacket->SetState (MP_STATE_RESET); // note: done in Recycle
					if (++uSilenceCount >= dwSilenceLimit)
					{
						pMC->m_fSending = FALSE;	// stop sending packets
						// if half duplex mode and playback thread may be waiting
						if (dwDuplexType & DP_FLAG_HALF_DUPLEX)
						{
							IMediaChannel *pIMC = NULL;
							RecvMediaStream *pRecv;
							m_pDP->GetMediaChannelInterface(MCF_RECV | MCF_AUDIO, &pIMC);
							if (pIMC)
							{
								pRecv = static_cast<RecvMediaStream *> (pIMC);
								if (pRecv->IsEmpty()==FALSE)
								{
							//DEBUGMSG (ZONE_DP, ("%s: too many silence and Yield\r\n", _fx_));

									LOG((LOGMSG_REC_YIELD));
									pPacket->Recycle ();
									pStream->PutNextRecorded (pPacket);
									uSilenceCount = 0;
									pIMC->Release();
									goto HalfDuplexYield;
								}
								pIMC->Release();
							}
						}
					}
				}
				else
				{
					switch(dwVoiceSwitch)
					{	
						// either there was NO silence, or manual switching is in effect
						default:
						case DP_FLAG_AUTO_SWITCH:	// this proves no silence (in this path because of non-silence)
						case DP_FLAG_MIC_ON:
							pMC->m_fSending = TRUE;
							uSilenceCount = 0;
						break;
						case DP_FLAG_MIC_OFF:
							pMC->m_fSending = FALSE;
						break;
					}

				}
				if (pMC->m_fSending)
				{
					pPacket->SetState (MP_STATE_RECORDED);

					// do AUTOMIX, but ignore DTMF tones
					if (pMC->m_bAutoMix)
					{
						agc.Update(wPeakStrength, dwLengthMS);
					}
				}
				else
				{
					pPacket->Recycle();

					// Enter critical section: QoS thread also reads the statistics
					EnterCriticalSection(&pMC->m_crsQos);

					// Update total number of packets recorded
					pMC->m_Stats.dwCount++;

					// Leave critical section
					LeaveCriticalSection(&pMC->m_crsQos);
				}

				pPacket->SetProp(MP_PROP_TIMESTAMP,pMC->m_SendTimestamp);
				// pPacket->SetProp(MP_PROP_TIMESTAMP,GetTickCount());
				pMC->m_SendTimestamp += dwSamplesPerPkt;
				
				pStream->PutNextRecorded (pPacket);

			} // while
		}
		else
		{
			if (dwDuplexType & DP_FLAG_HALF_DUPLEX)
			{
				DEBUGMSG (ZONE_DP, ("%s: Timeout and Yield\r\n", _fx_));
				goto HalfDuplexYield;
			}
		} // if
		pMC->Send();

		// Make sure the recorder has an adequate number of buffers
		while ((pPacket = pStream->GetFree()) != NULL)
		{
			if ((hr = pPacket->Record ()) == DPR_SUCCESS)
			{
				dq.Put (pPacket);
			}
			else
			{
				dq.Put (pPacket);
				DEBUGMSG (ZONE_DP, ("%s: Record FAILED, hr=0x%lX\r\n", _fx_, hr));
				break;
			}
			u++;
		}
		if (u < uPrefeed)
		{
			DEBUGMSG (ZONE_DP, ("%s: NO FREE BUFFERS\r\n", _fx_));
		}
	} // while TRUE

	goto MyEndThread;


HalfDuplexYield:

	// stop and reset audio device
	pMediaCtrl->Reset ();

	// flush dq
	while ((pPacket = dq.Get ()) != NULL)
	{
		pStream->PutNextRecorded (pPacket);
		pPacket->Recycle ();
	}

	// save real time so we can update the timestamp when we restart
	pMC->m_SavedTickCount = GetTickCount();

	// reset the event
	ResetEvent (hEvent);

	// close audio device
	pMediaCtrl->UnprepareHeaders ();
	pMediaCtrl->Close ();

	// signal playback thread to start
	SetEvent (g_hEventHalfDuplex);

	if (!(pMC->m_ThreadFlags & DPTFLAG_STOP_RECORD)) {

		// yield
		// playback has to claim the device within 100ms or we take it back.
		Sleep (100);

		// wait for playback's signal
		goto WaitForSignal;
	}


MyEndThread:

	if (pMixer)
		delete pMixer;

	pMediaCtrl->SetProp(MC_PROP_AUDIO_JAMMED, FALSE);

	pMC->m_fSending = FALSE;
	DEBUGMSG (ZONE_DP, ("%s: Exiting.\r\n", _fx_));
	return hr;
}


DWORD RecvAudioStream::PlaybackThread ( void)
{
	HRESULT hr = DPR_SUCCESS;
	MediaPacket * pPacket;
	MediaPacket * pPrevPacket;
	MediaPacket * pNextPacket;
	DWORD dwWait;
	HANDLE hEvent;
	DWORD dwDuplexType;
	DWORD_PTR dwPropVal;
	UINT u;
	UINT uMissingCount = 0;
	UINT uPrefeed = 0;
	UINT uTimeout = 0;
	UINT uSamplesPerPkt=0;
	DevMediaQueue dq;
	UINT uGoodPacketsQueued = 0;
	int nFailCount = 0;
	bool bCanSignalOpen=true;
	//warning: casting from base to dervied class


	// note: pMC is an artifact of when this thread was in the Datapump
	// namespace.  We can probably start phasing this variable out.
	// in the mean time:  "pMC = this" will suffice
	// RecvAudioStream *pMC = (RecvAudioStream *)(m_pDP->m_Audio.pRecvStream);

	RecvAudioStream *pMC = this;
	
	RxStream		*pStream = pMC->m_RecvStream;
	MediaControl	*pMediaCtrl = pMC->m_OutMedia;

#if 0
	NETBUF * pStaticNetBuf;
#endif

	FX_ENTRY ("DP::PlayTh")

	if (pStream == NULL ||	m_pAudioFilter == NULL || pMediaCtrl == NULL)
	{
		return DPR_INVALID_PARAMETER;
	}

	// get event handle
	pMediaCtrl->GetProp (MC_PROP_EVENT_HANDLE, &dwPropVal);
	hEvent = (HANDLE) dwPropVal;
	if (hEvent == NULL)
	{
		DEBUGMSG (ZONE_DP, ("%s: invalid event\r\n", _fx_));
		return DPR_CANT_CREATE_EVENT;
	}


	// get thresholds
	pMediaCtrl->GetProp (MC_PROP_TIMEOUT, &dwPropVal);
	uTimeout = (DWORD)dwPropVal;

	uPrefeed = pStream->BufferDelay();

	// get samples per pkt
	pMediaCtrl->GetProp(MC_PROP_SPP, &dwPropVal);
	uSamplesPerPkt = (DWORD)dwPropVal;
	
	// get duplex type
	pMediaCtrl->GetProp (MC_PROP_DUPLEX_TYPE, &dwPropVal);
    dwDuplexType = (DWORD)dwPropVal;

	// set dq size
	dq.SetSize (uPrefeed);

WaitForSignal:

	// DEBUGMSG (1, ("%s: WaitForSignal\r\n", _fx_));

		pMediaCtrl->GetProp (MC_PROP_MEDIA_DEV_HANDLE, &dwPropVal);
		if (dwPropVal)
		{
			DEBUGMSG (ZONE_DP, ("%s: already open\r\n", _fx_));
			goto RecvLoop; // already open
		}

		// in the full-duplex case, open and prepare the device  and charge ahead.
		// in the half duplex case wait for playback's signal before opening the device
		while (TRUE)
		{
			// should I stop now???
			if (pMC->m_ThreadFlags & DPTFLAG_STOP_PLAY)
			{
				DEBUGMSG (ZONE_VERBOSE, ("%s: STOP_1\r\n", _fx_));
				goto MyEndThread;
			}
			dwWait = (dwDuplexType & DP_FLAG_HALF_DUPLEX) ? WaitForSingleObject (g_hEventHalfDuplex, uTimeout)
				: WAIT_OBJECT_0;


			// to see why I don't need to wait
			if (dwWait == WAIT_OBJECT_0)
			{
				// DEBUGMSG (1, ("%s: try to open audio dev\r\n", _fx_));
				pStream->FastForward(FALSE);	// GJ - flush receive queue
				hr = pMediaCtrl->Open ();
				if (hr != DPR_SUCCESS)
				{
					// somebody may have commandeered the wave out device
					// this could be a temporary problem so lets give it some time
					DEBUGMSG (ZONE_DP, ("%s: MediaControl::Open failed, hr=0x%lX\r\n", _fx_, hr));
					pMediaCtrl->SetProp(MC_PROP_AUDIO_JAMMED, TRUE);

					SetEvent(g_hEventHalfDuplex);

					nFailCount++;

					if (nFailCount == MAX_FAILCOUNT)
					{
						// three attempts to open the device have failed
						// signal to the UI that something is wrong
						m_pDP->StreamEvent(MCF_RECV, MCF_AUDIO, STREAM_EVENT_DEVICE_FAILURE, 0);
						bCanSignalOpen = true;
					}

					Sleep(2000);	// sleep for two seconds
					continue;
				}
				// Notification is not used. if needed do it thru Channel
				//pMC->m_Connection->DoNotification(CONNECTION_OPEN_SPK);
				pMediaCtrl->PrepareHeaders ();

				goto RecvLoop;
			}
		} // while

RecvLoop:
	nFailCount = 0;
	pMediaCtrl->SetProp(MC_PROP_AUDIO_JAMMED, FALSE);
	if (bCanSignalOpen)
	{
		m_pDP->StreamEvent(MCF_RECV, MCF_AUDIO, STREAM_EVENT_DEVICE_OPEN, 0);
		bCanSignalOpen = false;  // don't signal open more than once per session
	}


	// Set my thread priority high
	// This thread doesnt do any compute intensive work (except maybe
	// interpolate?).
	// Its sole purpose is to stream ready buffers to the sound device
	SetThreadPriority(pMC->m_hRenderingThread, THREAD_PRIORITY_HIGHEST);
	
	// DEBUGMSG (1, ("%s: SendLoop\r\n", _fx_));


	// let's feed four buffers first
	// But make sure the receive stream has enough buffering delay
	// so we dont read past the last packet.
	//if (uPrefeed > pStream->BufferDelay())
	uGoodPacketsQueued = 0;
	for (u = 0; u < uPrefeed; u++)
	{
		if ((pPacket = pStream->GetNextPlay ()) != NULL)
		{
			if (pPacket->GetState () == MP_STATE_RESET)
			{
				// hr = pPacket->Play (pStaticNetBuf);
				hr = pPacket->Play (&pMC->m_mmioDest, MP_DATATYPE_SILENCE);
			}
			else
			{
				// hr = pPacket->Play ();
				hr = pPacket->Play (&pMC->m_mmioDest, MP_DATATYPE_FROMWIRE);
				uGoodPacketsQueued++;
			}

			if (hr != DPR_SUCCESS)
			{
				DEBUGMSG (ZONE_DP, ("%s: Play failed, hr=0x%lX\r\n", _fx_, hr));
				SetEvent(hEvent);
			}

			dq.Put (pPacket);
		}
	}

	pMC->m_fReceiving = TRUE;
	// let's get into the loop
	uMissingCount = 0;
	while (TRUE)
	{
		
		dwWait = WaitForSingleObject (hEvent, uTimeout);

		// should I stop now???
		if (pMC->m_ThreadFlags & DPTFLAG_STOP_PLAY)
		{
			DEBUGMSG (ZONE_VERBOSE, ("%s: STOP_3\r\n", _fx_));
			goto HalfDuplexYield;
		}

		// see why I don't need to wait
		if (dwWait != WAIT_TIMEOUT)
		{
			while (TRUE)
			{
				if ((pPacket = dq.Peek ()) != NULL)
				{
					if (! pPacket->IsBufferDone ())
					{
						break;
					}
				}
				else
				{
					DEBUGMSG (ZONE_VERBOSE, ("%s: Peek is NULL\r\n", _fx_));
					break;
				}

				pPacket = dq.Get ();
				if (pPacket->GetState() != MP_STATE_PLAYING_SILENCE)
					uGoodPacketsQueued--;	// a non-empty buffer just got done
				pMC->m_PlaybackTimestamp = pPacket->GetTimestamp() + uSamplesPerPkt;
				pPacket->Recycle ();
				pStream->Release (pPacket);

				if ((pPacket = pStream->GetNextPlay ()) != NULL)
				{
					// check if we are in half-duplex mode and also if
					// the recording thread is around.
					if (dwDuplexType & DP_FLAG_HALF_DUPLEX)
					{
						IMediaChannel *pIMC = NULL;
						BOOL fSending = FALSE;
						m_pDP->GetMediaChannelInterface(MCF_SEND | MCF_AUDIO, &pIMC);
						if (pIMC)
						{
							fSending = (pIMC->GetState() == MSSTATE_STARTED);
							pIMC->Release();
						}
						if (fSending) {
							if (pPacket->GetState () == MP_STATE_RESET)
							{
								// Decide if its time to yield
								// Dont want to yield until we've finished playing all data packets
								//
								if (!uGoodPacketsQueued &&
									(pStream->IsEmpty() || ++uMissingCount >= DEF_MISSING_LIMIT))
								{
									//DEBUGMSG (ZONE_DP, ("%s: too many missings and Yield\r\n", _fx_));
									LOG( (LOGMSG_PLAY_YIELD));
									pPacket->Recycle ();
									pStream->Release (pPacket);
									goto HalfDuplexYield;
								}
							}
							else
							{
								uMissingCount = 0;
							}
						}
					}

					if (pPacket->GetState () == MP_STATE_RESET)
					{
						pPrevPacket = pStream->PeekPrevPlay ();
						pNextPacket = pStream->PeekNextPlay ();
						hr = pPacket->Interpolate(pPrevPacket, pNextPacket);
						if (hr != DPR_SUCCESS)
						{
							//DEBUGMSG (ZONE_DP, ("%s: Interpolate failed, hr=0x%lX\r\n", _fx_, hr));
							hr = pPacket->Play (&pMC->m_mmioDest, MP_DATATYPE_SILENCE);
						}
						else
							hr = pPacket->Play (&pMC->m_mmioDest, MP_DATATYPE_INTERPOLATED);
					}
					else
					{
						// hr = pPacket->Play ();
						hr = pPacket->Play (&pMC->m_mmioDest, MP_DATATYPE_FROMWIRE);
						uGoodPacketsQueued++;
					}

					if (hr != DPR_SUCCESS)
					{
						DEBUGMSG (ZONE_DP, ("%s: Play failed, hr=0x%lX\r\n", _fx_, hr));
						SetEvent(hEvent);
					}

					dq.Put (pPacket);
				} else {
					DEBUGMSG( ZONE_DP, ("%s: NO PLAY BUFFERS!",_fx_));
				}
			} // while
		}
		else
		{
			if (dwDuplexType & DP_FLAG_HALF_DUPLEX)
			{
				DEBUGMSG (ZONE_DP, ("%s: Timeout and Yield!\r\n", _fx_));
				goto HalfDuplexYield;
			}
		}
	} // while TRUE

	goto MyEndThread;


HalfDuplexYield:

	pMC->m_fReceiving = FALSE;
	// stop and reset audio device
	pMediaCtrl->Reset ();

	// flush dq
	while ((pPacket = dq.Get ()) != NULL)
	{
		pPacket->Recycle ();
		pStream->Release (pPacket);
	}

	// reset the event
	ResetEvent (hEvent);

	// close audio device
	pMediaCtrl->UnprepareHeaders ();
	pMediaCtrl->Close ();

	// signal recording thread to start
	SetEvent (g_hEventHalfDuplex);

	if (!(pMC->m_ThreadFlags & DPTFLAG_STOP_PLAY)) {
		// yield
		Sleep (0);

		// wait for recording's signal
		// restore thread priority
		SetThreadPriority(pMC->m_hRenderingThread,THREAD_PRIORITY_NORMAL);
		goto WaitForSignal;
	}

MyEndThread:

	pMediaCtrl->SetProp(MC_PROP_AUDIO_JAMMED, FALSE);


	DEBUGMSG(ZONE_DP, ("%s: Exiting.\n", _fx_));
	return hr;
}

DWORD SendAudioStream::Send()

{
	MMRESULT mmr;
 	MediaPacket *pAP;
	void *pBuffer;
	DWORD dwBeforeEncode;
	DWORD dwAfterEncode;
	DWORD dwPacketSize;
	UINT uBytesSent;
#ifdef LOGSTATISTICS_ON
	char szDebug[256];
	DWORD dwDebugSaveBits;
#endif

 	while ( pAP = m_SendStream->GetNext()) {
 		if (!(m_ThreadFlags & DPTFLAG_PAUSE_SEND)) {

			dwBeforeEncode = timeGetTime();
			mmr = m_pAudioFilter->Convert((AudioPacket*)pAP, AP_ENCODE);
			if (mmr == MMSYSERR_NOERROR)
			{
				pAP->SetState(MP_STATE_ENCODED);
			}

			// Time the encoding operation
			dwAfterEncode = timeGetTime() - dwBeforeEncode;

			if (mmr == MMSYSERR_NOERROR)
			{
				SendPacket((AudioPacket*)pAP, &uBytesSent);
			}
			else
			{
				uBytesSent = 0;
			}


		   	UPDATE_COUNTER(g_pctrAudioSendBytes, uBytesSent*8);

			// Enter critical section: QoS thread also reads the statistics
			EnterCriticalSection(&m_crsQos);

			// Update total number of packets recorded
			m_Stats.dwCount++;

			// Save the perfs in our stats structure for QoS
#ifdef LOGSTATISTICS_ON
			dwDebugSaveBits = m_Stats.dwBits;
#endif
			// Add this new frame size to the cumulated size
			m_Stats.dwBits += (uBytesSent * 8);

			// Add this compression time to total compression time
			m_Stats.dwMsComp += dwAfterEncode;

#ifdef LOGSTATISTICS_ON
			wsprintf(szDebug, " A: (Voiced) dwBits = %ld up from %ld (file: %s line: %ld)\r\n", m_Stats.dwBits, dwDebugSaveBits, __FILE__, __LINE__);
			OutputDebugString(szDebug);
#endif
			// Leave critical section
			LeaveCriticalSection(&m_crsQos);
 		}

		// whether or not we sent the packet, we need to return
		// it to the free queue
		pAP->m_fMark=0;
		pAP->SetState(MP_STATE_RESET);
		m_SendStream->Release(pAP);
	}
 	return DPR_SUCCESS;
}



// queues and sends the packet
// if the packet failed the encode process, it doesn't get sent

HRESULT SendAudioStream::SendPacket(AudioPacket *pAP, UINT *puBytesSent)
{
	PS_QUEUE_ELEMENT psq;
	UINT uLength;
	int nPacketsSent=0;


	if (pAP->GetState() != MP_STATE_ENCODED)
	{
		DEBUGMSG (ZONE_ACM, ("SendAudioStream::SendPacket: Packet not compressed\r\n"));
		*puBytesSent = 0;
		return E_FAIL;
	}

	ASSERT(m_pRTPSend);

	psq.pMP = pAP;
	psq.dwPacketType = PS_AUDIO;
	psq.pRTPSend = m_pRTPSend;
	pAP->GetNetData((void**)(&(psq.data)), &uLength);
	ASSERT(psq.data);
	psq.dwSize = uLength;
	psq.fMark = pAP->m_fMark;
	psq.pHeaderInfo = NULL;
	psq.dwHdrSize = 0;

	*puBytesSent = uLength + sizeof(RTP_HDR) + IP_HEADER_SIZE + UDP_HEADER_SIZE;

	// add audio packets to the front of the queue
	m_pDP->m_PacketSender.m_SendQueue.PushFront(psq);

	while (m_pDP->m_PacketSender.SendPacket())
	{
		;
	}

	return S_OK;

};


#ifdef OLDSTUFF
/*
// Winsock 1 receive thread
// Creates a hidden window and a message loop to process WINSOCK window
// messages. Also processes private messages from the datapump to start/stop
// receiving on a particular media stream
 */
DWORD
DataPump::CommonRecvThread (void )
{

	HRESULT hr;
	HWND hWnd = (HWND)NULL;
	RecvMediaStream *pRecvMC;
	BOOL fChange = FALSE;
	MSG msg;
	DWORD curTime, nextUpdateTime = 0, t;
	UINT timerId = 0;
	
	FX_ENTRY ("DP::RecvTh")


	// Create hidden window
	hWnd =
	CreateWindowEx(
		WS_EX_NOPARENTNOTIFY,
        "SockMgrWClass", 	/* See RegisterClass() call.          */
        NULL,
        WS_CHILD ,    		/* Window style.                      */
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        m_hAppWnd,			/* the application window is the parent. */
        (HMENU)this,      	/* hardcoded ID         */
        m_hAppInst,   		/* the application owns this window.    */
        NULL				/* Pointer not needed.                */
    );

	if(!hWnd)
	{	
		hr = GetLastError();
		DEBUGMSG(ZONE_DP,("CreateWindow returned %d\n",hr));
		goto CLEANUPEXIT;
	}
	SetThreadPriority(m_hRecvThread, THREAD_PRIORITY_ABOVE_NORMAL);

    // This function is guaranteed to create a queue on this thread
    PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);

	// notify thread creator that we're ready to recv messages
	SetEvent(m_hRecvThreadAckEvent);


	// Wait for control messages from Start()/Stop() or Winsock messages directed to
	// our hidden window
	while (GetMessage(&msg, NULL, 0, 0)) {
		switch(msg.message) {
		case MSG_START_RECV:
			// Start receiving on the specified media stream
			DEBUGMSG(ZONE_VERBOSE,("%s: MSG_START_RECV\n",_fx_));
			pRecvMC = (RecvMediaStream *)msg.lParam;
			// call the stream to post recv buffers and
			// tell Winsock to start sending socket msgs to our window
			pRecvMC->StartRecv(hWnd);
			fChange = TRUE;
			break;
			
		case MSG_STOP_RECV:
			// Stop receiving on the specified media stream
			DEBUGMSG(ZONE_VERBOSE,("%s: MSG_STOP_RECV\n",_fx_));
			pRecvMC = (RecvMediaStream *)msg.lParam;
			// call the stream to cancel outstanding recvs etc.
			// currently we assume this can be done synchronously
			pRecvMC->StopRecv();
			fChange = TRUE;
			break;
		case MSG_EXIT_RECV:
			// Exit the recv thread.
			// Assume that we are not currently receving on any stream.
			DEBUGMSG(ZONE_VERBOSE,("%s: MSG_EXIT_RECV\n",_fx_));
			fChange = TRUE;
			if (DestroyWindow(hWnd)) {
				break;
			}
			DEBUGMSG(ZONE_DP,("DestroyWindow returned %d\n",GetLastError()));
			// fall thru to PostQuitMessage()
			
		case WM_DESTROY:
			PostQuitMessage(0);
			break;
		case WM_TIMER:
			if (msg.hwnd == NULL) {
				// this timer is for the benefit of ThreadTimer::UpdateTime()
				// however, we are calling UpdateTime after every message (see below)
				// so we dont do anything special here.
				break;
			}
		default:
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        if (fChange) {
			// the thread MSGs need to be acked
			SetEvent(m_hRecvThreadAckEvent);
			fChange = FALSE;
		}
		
		t = m_RecvTimer.UpdateTime(curTime=GetTickCount());
		if (t != nextUpdateTime)  {
			// Thread timer wants to change its update time
			nextUpdateTime = t;
			if (timerId) {
				KillTimer(NULL,timerId);
				timerId = 0;
			}
			// if nextTime is zero, there are no scheduled timeouts so we dont need to call UpdateTime
			if (nextUpdateTime)
				timerId = SetTimer(NULL, 0, nextUpdateTime - curTime + 50, NULL);
		}
		

    }


	CLEANUPEXIT:
	DEBUGMSG(ZONE_DP,("%s terminating.\n", _fx_));

	return hr;

}

#endif
/*
	Winsock 2 receive thread. Main differnce here is that it has a WaitEx loop
	where we wait for Start/Stop commands from the datapump while allowing
	WS2 APCs to be handled.
	Note: Only way to use the same thread routine for WS1 and WS2 is with
	MsgWaitForMultipleObjectsEx, which unfortunately is not implemented in Win95
*/
DWORD
DataPump::CommonWS2RecvThread (void )
{

	HRESULT hr;
	RecvMediaStream *pRecvMC;
	BOOL fChange = FALSE, fExit = FALSE;
	DWORD dwWaitStatus;
	DWORD curTime,  t;
	
	FX_ENTRY ("DP::WS2RecvTh")


	SetThreadPriority(m_hRecvThread, THREAD_PRIORITY_ABOVE_NORMAL);


	// notify thread creator that we're ready to recv messages
	SetEvent(m_hRecvThreadAckEvent);


	while (!fExit) {
		// Wait for control messages from Start()/Stop() or Winsock async
		// thread callbacks

		// dispatch expired timeouts and check how long we need to wait
		t = m_RecvTimer.UpdateTime(curTime=GetTickCount());
		t = (t ? t-curTime+50 : INFINITE);
			
		dwWaitStatus = WaitForSingleObjectEx(m_hRecvThreadSignalEvent,t,TRUE);
		if (dwWaitStatus == WAIT_OBJECT_0) {
			switch(m_CurRecvMsg) {
			case MSG_START_RECV:
				// Start receiving on the specified media stream
				DEBUGMSG(ZONE_VERBOSE,("%s: MSG_START_RECV\n",_fx_));
				pRecvMC = m_pCurRecvStream;
				// call the stream to post recv buffers and
				// tell Winsock to start sending socket msgs to our window
				pRecvMC->StartRecv(NULL);
				fChange = TRUE;
				break;
				
			case MSG_STOP_RECV:
				// Stop receiving on the specified media stream
				DEBUGMSG(ZONE_VERBOSE,("%s: MSG_STOP_RECV\n",_fx_));
				pRecvMC = m_pCurRecvStream;
				// call the stream to cancel outstanding recvs etc.
				//  currently we assume this can be done synchronously
				pRecvMC->StopRecv();
				fChange = TRUE;
				break;
			case MSG_EXIT_RECV:
				// Exit the recv thread.
				// Assume that we are not currently receving on any stream.
				DEBUGMSG(ZONE_VERBOSE,("%s: MSG_EXIT_RECV\n",_fx_));
				fChange = TRUE;
				fExit = TRUE;
				break;

			case MSG_PLAY_SOUND:
				fChange = TRUE;
				pRecvMC->OnDTMFBeep();
				break;
				
			default:
				// shouldnt be anything else
				ASSERT(0);
	        }

	        if (fChange) {
				// the thread MSGs need to be acked
				SetEvent(m_hRecvThreadAckEvent);
				fChange = FALSE;
			}

	    } else if (dwWaitStatus == WAIT_IO_COMPLETION) {
	    	// nothing to do here
	    } else if (dwWaitStatus != WAIT_TIMEOUT) {
	    	DEBUGMSG(ZONE_DP,("%s: Wait failed with %d",_fx_,GetLastError()));
	    	fExit=TRUE;
	    }
	}

	DEBUGMSG(ZONE_DP,("%s terminating.\n", _fx_));

	return 0;

}


void ThreadTimer::SetTimeout(TTimeout *pTObj)
{
	DWORD time = pTObj->GetDueTime();
	// insert in increasing order of timeout
	for (TTimeout *pT = m_TimeoutList.pNext; pT != &m_TimeoutList; pT = pT->pNext) {
		if ((int)(pT->m_DueTime- m_CurTime) > (int) (time - m_CurTime))
			break;
	}
	pTObj->InsertAfter(pT->pPrev);
	
}

void ThreadTimer::CancelTimeout(TTimeout *pTObj)
{
	pTObj->Remove();	// remove from list
}

// Called by thread with the current time as input (usually obtained from GetTickCount())
// Returns the time by which UpdateTime() should be called again or currentTime+0xFFFFFFFF if there
// are no scheduled timeouts
DWORD ThreadTimer::UpdateTime(DWORD curTime)
{
	TTimeout *pT;
	m_CurTime = curTime;
	// figure out which timeouts have elapsed and do the callbacks
	while (!IsEmpty()) {
		pT = m_TimeoutList.pNext;
		if ((int)(pT->m_DueTime-m_CurTime) <= 0) {
			pT->Remove();
			pT->TimeoutIndication();
		} else
			break;
	}
	return (IsEmpty() ? m_CurTime+INFINITE : m_TimeoutList.pNext->m_DueTime);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\utils.cpp ===
#include "precomp.h"


// SHORT g_BeepSamples[] = {195,-4352,-14484,-8778,397,-1801,2376,12278,6830,-2053};
SHORT g_BeepSamples[] = {195,-4352,-12484,-8778,397,-1801,2376,10278,6830,-2053};


#define BL  1024


#if 0
DEFWAVEFORMAT g_wfDefList[] =
{
    {WAVE_FORMAT_PCM,   1, 22050, 22050, 1, 8, 0},
    {WAVE_FORMAT_PCM,   1, 11025, 11025, 1, 8, 0},
    {WAVE_FORMAT_PCM,   1, 8000,  8000,  1, 8, 0},
    {WAVE_FORMAT_PCM,   1, 5510,  5510,  1, 8, 0},
    {WAVE_FORMAT_ADPCM, 1, 11025, 11025/2, BL, 4, 32, (BL-7)*2+2, 7, 0x0100,0x0000,0x0200,0xFF00,0x0000,0x0000,0x00C0,0x0040,0x00F0,0x0000,0x01CC,0xFF30,0x0188,0xFF18},
    {WAVE_FORMAT_ADPCM, 1, 8000,  8000/2,  BL, 4, 32, (BL-7)*2+2, 7, 0x0100,0x0000,0x0200,0xFF00,0x0000,0x0000,0x00C0,0x0040,0x00F0,0x0000,0x01CC,0xFF30,0x0188,0xFF18},
    {WAVE_FORMAT_ADPCM, 1, 5510,  5510/2,  BL, 4, 32, (BL-7)*2+2, 7, 0x0100,0x0000,0x0200,0xFF00,0x0000,0x0000,0x00C0,0x0040,0x00F0,0x0000,0x01CC,0xFF30,0x0188,0xFF18},
    {WAVE_FORMAT_PCM,   1, 11025, 11025, 1, 8, 0},
};
#endif


DEFWAVEFORMAT g_wfDefList[] =
{
	{WAVE_FORMAT_VOXWARE,1,8000, 16000,  2,   16, 0},
    {WAVE_FORMAT_PCM,   1, 8000,  8000,  1,   8,  0},
    {WAVE_FORMAT_PCM,   1, 5510,  5510,  1,   8,  0},
    {WAVE_FORMAT_ADPCM, 1, 8000,  4096,  256, 4,  32, 500, 7, 0x0100,0x0000,0x0200,0xFF00,0x0000,0x0000,0x00C0,0x0040,0x00F0,0x0000,0x01CC,0xFF30,0x0188,0xFF18},
    {WAVE_FORMAT_ADPCM, 1, 5510,  2755,  256, 4,  32, 500, 7, 0x0100,0x0000,0x0200,0xFF00,0x0000,0x0000,0x00C0,0x0040,0x00F0,0x0000,0x01CC,0xFF30,0x0188,0xFF18},
    {WAVE_FORMAT_GSM610,1, 8000,  1625,  65,  0,  2, 320, 240, 0},
    {WAVE_FORMAT_ALAW,  1, 8000,  8000,  1,   8,  0},
    {WAVE_FORMAT_PCM,   1, 11025, 11025, 1,   8,  0},
    {WAVE_FORMAT_PCM,   1, 8000,  16000, 2,   16, 0},
};


WAVEFORMATEX * GetDefWaveFormat ( int idx )
{
    return ((idx < DWF_NumOfWaveFormats) ?
            (WAVEFORMATEX *) &g_wfDefList[idx] :
            (WAVEFORMATEX *) NULL);
}


ULONG GetWaveFormatSize ( PVOID pwf )
{
    return (((WAVEFORMAT *) pwf)->wFormatTag == WAVE_FORMAT_PCM  
        ? sizeof (PCMWAVEFORMAT)
        : sizeof (PCMWAVEFORMAT) + sizeof (WORD) + ((WAVEFORMATEX *) pwf)->cbSize);
}


BOOL IsSameWaveFormat ( PVOID pwf1, PVOID pwf2 )
{
    UINT u1 = GetWaveFormatSize (pwf1);
    UINT u2 = GetWaveFormatSize (pwf2);
    BOOL fSame = FALSE;

    if (u1 == u2)
    {
        fSame = ! CompareMemory1 ((char *)pwf1, (char *)pwf2, u1);
    }

    return fSame;
}


void FillSilenceBuf ( WAVEFORMATEX *pwf, PBYTE pb, ULONG cb )
{
	if (pwf && pb)
	{
		if ((pwf->wFormatTag == WAVE_FORMAT_PCM) && (pwf->wBitsPerSample == 8))
		{
			FillMemory (pb, cb, (BYTE) 0x80);
		}
		else
		{
			ZeroMemory (pb, cb);
		}
	}
}


void MakeDTMFBeep(WAVEFORMATEX *pwf, PBYTE pb, ULONG cb)
{
	SHORT *pShort = (SHORT*)pb;
	int nBeepMod = sizeof (g_BeepSamples) / sizeof(g_BeepSamples[0]);
	int nIndex, nLoops = 0;
	BYTE bSample;

	if (pwf->wBitsPerSample == 16)
	{
		nLoops = cb / 2;
		for (nIndex=0; nIndex < nLoops; nIndex++)
		{
			pShort[nIndex] = g_BeepSamples[(nIndex % nBeepMod)];
		}
	}
	else
	{
		nLoops = cb;
		for (nIndex=0; nIndex < nLoops; nIndex++)
		{
			bSample = (g_BeepSamples[(nIndex % nBeepMod)] >> 8) & 0x00ff;
			bSample = bSample ^ 0x80;
			pb[nIndex] = bSample;
		}
	}
}



char CompareMemory1 ( char * p1, char * p2, UINT u )
{
    char i;

    while (u--)
    {
        i = *p1++ - *p2++;
        if (i) return i;
    }

    return 0;
}


short CompareMemory2 ( short * p1, short * p2, UINT u )
{
    short i;

    while (u--)
    {
        i = *p1++ - *p2++;
        if (i) return i;
    }

    return 0;
}


long CompareMemory4 ( long * p1, long * p2, UINT u )
{
    long i;

    while (u--)
    {
        i = *p1++ - *p2++;
        if (i) return i;
    }

    return 0;
}


const DWORD WIN98GOLDBUILD = 1998;
const DWORD WIN98GOLDMAJOR = 4;
const DWORD WIN98GOLDMINOR = 10;


inline bool ISWIN98GOLD()
{
	OSVERSIONINFO osVersion;
	BOOL bRet;

	osVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	bRet = GetVersionEx(&osVersion);


	if ( bRet && 
	        ( (osVersion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
	          (osVersion.dwMajorVersion == WIN98GOLDMAJOR) &&
	          (osVersion.dwMinorVersion == WIN98GOLDMINOR) // && 
//	          (osVersion.dwBuildNumber == WIN98GOLDBUILD)
            )
		)
	{
		return true;
	}

	return false;

}

// dwPacketSize is the size of the audio payload (excludes RTP header)
// pwf represents the compressed audio format
HRESULT InitAudioFlowspec(FLOWSPEC *pFlowspec, WAVEFORMATEX *pwf, DWORD dwPacketSize)
{

	DWORD dwPacketOverhead = 0;
	OSVERSIONINFO osVersion;
	DWORD dwTotalSize;
	BOOL bRet;


	// on Windows 2000 and Win98 OSR, the FLOWSPEC needs to be set without regard
	// to the UDP/IP headers.

	// On Win98 Gold, FLOWSPEC needs to account for IP/UDP headers

	// no way to detect this without explicitly checking the version number

	if (ISWIN98GOLD())
	{
		dwPacketOverhead = IP_HEADER_SIZE + UDP_HEADER_SIZE;
	}

	dwTotalSize = dwPacketOverhead + dwPacketSize + sizeof(RTP_HDR);

	// rather than specify the exact minimum bandwidth we need for audio,
	// make it slightly larger (10%) to account for bursts and beginning
	// of talk spurts

	// peakbandwidth is set another increment above TR, and bucket size
	// is adjusted high as well


	pFlowspec->TokenRate = (dwTotalSize * pwf->nAvgBytesPerSec) / dwPacketSize;
	pFlowspec->TokenRate = (11 * pFlowspec->TokenRate) / 10;

	// peak bandwidth is an ADDITIONAL 10% greater than TokenRate, so it's
	// really a 21% increase over the theoretical minimum
	pFlowspec->PeakBandwidth = (11 * pFlowspec->TokenRate) / 10;
	pFlowspec->TokenBucketSize = dwTotalSize * 4;
	pFlowspec->MinimumPolicedSize = dwTotalSize;
	pFlowspec->MaxSduSize = pFlowspec->MinimumPolicedSize;
	pFlowspec->Latency = QOS_NOT_SPECIFIED;
	pFlowspec->DelayVariation = QOS_NOT_SPECIFIED;
	pFlowspec->ServiceType = SERVICETYPE_GUARANTEED;

	return S_OK;

}



HRESULT InitVideoFlowspec(FLOWSPEC *pFlowspec, DWORD dwMaxBitRate, DWORD dwMaxFrag, DWORD dwAvgPacketSize)
{
	DWORD dwPacketOverhead = 0;


	// I-Frames will be fragmented into 3 or 4 packets
	// and will be about 1000 bytes each

	// P-Frames average about 250 - 500 bytes each

	// we'll assume the reservation is a NetMeeting to NetMeeting call
	// so there will be few I-Frames sent



	if (ISWIN98GOLD())
	{
		dwPacketOverhead = IP_HEADER_SIZE + UDP_HEADER_SIZE;
	}

	// for 28.8 modems, 11kbits/sec have already been allocated for audio
	// so only allocate 17kbits/sec for video.  This means that some packets
	// will be "non-conforming" and may receive less than a best-effort services.
	// but this is believed to be better than having no RSVP/QOS at all

	// if this becomes an issue, then it may be better to have no RSVP/QOS at all

	// maxBitRate will be equal to 14400 (14.4 modem), 28000 (28.8 modem), 85000 (ISDN/DSL), or 621700 (LAN)
	// (* .70, so really it can be: 10080, 20160, 59500, 435190)


	if (dwMaxBitRate <= BW_144KBS_BITS)
	{
		dwMaxBitRate = 4000;  // is it worth it to attempt QOS at 14.4 ?
	}
	else if (dwMaxBitRate <= BW_288KBS_BITS)
	{
		dwMaxBitRate = 17000;
	}



	pFlowspec->TokenRate = dwMaxBitRate / 8;
	pFlowspec->MaxSduSize = dwMaxFrag + dwPacketOverhead + sizeof(RTP_HDR);
	pFlowspec->MinimumPolicedSize = dwAvgPacketSize + dwPacketOverhead;
	pFlowspec->PeakBandwidth = (DWORD)(pFlowspec->TokenRate * 1.2);
	pFlowspec->TokenBucketSize = dwMaxFrag * 3;

	pFlowspec->Latency = QOS_NOT_SPECIFIED;
	pFlowspec->DelayVariation = QOS_NOT_SPECIFIED;
	pFlowspec->ServiceType = SERVICETYPE_CONTROLLEDLOAD;

	return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\utils.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    utils.h

Abstract:
	Assorted support and debugging routines used by the Network Audio Controller.

--*/
#ifndef _UTILS_H_
#define _UTILS_H_


#include <pshpack8.h> /* Assume 8 byte packing throughout */

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


typedef struct tagDefWaveFormat
{
    WORD    wFormatTag;        /* format type */
    WORD    nChannels;         /* number of channels (i.e. mono, stereo...) */
    DWORD   nSamplesPerSec;    /* sample rate */
    DWORD   nAvgBytesPerSec;   /* for buffer estimation */
    WORD    nBlockAlign;       /* block size of data */
    WORD    wBitsPerSample;    /* Number of bits per sample of mono data */
    WORD    cbSize;            /* The count in bytes of the size of extra information (after cbSize) */
    WORD    awExtra[32];       /* room for ADPCM coeff...*/
}
    DEFWAVEFORMAT;


enum
{
    //  NAME_SamplesPerSec_BitsPerSample
	DWF_VOX_8K_16,
    DWF_PCM_8K_8,
    DWF_PCM_5510_8,
    DWF_ADPCM_8K_4,
    DWF_ADPCM_5510_4,
    DWF_GSM610_8K,
    DWF_ALAW_8K_8,
    DWF_PCM_11025_8,
    DWF_PCM_8K_16,
    DWF_NumOfWaveFormats
};

extern DEFWAVEFORMAT g_wfDefList[];




WAVEFORMATEX * GetDefWaveFormat ( int idx );
ULONG GetWaveFormatSize ( PVOID pwf );
BOOL IsSameWaveFormat ( PVOID pwf1, PVOID pwf2 );
void FillSilenceBuf ( WAVEFORMATEX *pwf, PBYTE pb, ULONG cb );
void MakeDTMFBeep(WAVEFORMATEX *pwf, PBYTE pb, ULONG cb);

char CompareMemory1 ( char * p1, char * p2, UINT u );
short CompareMemory2 ( short * p1, short * p2, UINT u );
long CompareMemory4 ( long * p1, long * p2, UINT u );


#ifndef SIZEOF_WAVEFORMATEX
#define SIZEOF_WAVEFORMATEX(pwfx)   ((WAVE_FORMAT_PCM==(pwfx)->wFormatTag)?sizeof(PCMWAVEFORMAT):(sizeof(WAVEFORMATEX)+(pwfx)->cbSize))
#endif



#ifdef _DEBUG
#	ifndef DEBUG
#		define DEBUG
#	endif // !DEBUG
#endif // _DEBUG


#ifdef DEBUG // { DEBUG

int WINAPI NacDbgPrintf ( LPTSTR lpszFormat, ... );
extern HDBGZONE  ghDbgZoneNac;

#define ZONE_INIT (GETMASK(ghDbgZoneNac) & 0x0001)
#define ZONE_CONN (GETMASK(ghDbgZoneNac) & 0x0002)
#define ZONE_COMMCHAN (GETMASK(ghDbgZoneNac) & 0x0004)
#define ZONE_CAPS (GETMASK(ghDbgZoneNac) & 0x0008)
#define ZONE_DP   (GETMASK(ghDbgZoneNac) & 0x0010)
#define ZONE_ACM  (GETMASK(ghDbgZoneNac) & 0x0020)
#define ZONE_VCM  (GETMASK(ghDbgZoneNac) & 0x0040)
#define ZONE_VERBOSE (GETMASK(ghDbgZoneNac) & 0x0080)
#define ZONE_INSTCODEC (GETMASK(ghDbgZoneNac) & 0x0100)
#define ZONE_PROFILE (GETMASK(ghDbgZoneNac) & 0x0200)
#define ZONE_QOS (GETMASK(ghDbgZoneNac) & 0x0400)
#define ZONE_IFRAME (GETMASK(ghDbgZoneNac) & 0x0800)

extern HDBGZONE  ghDbgZoneNMCap;
#define ZONE_NMCAP_CDTOR (GETMASK(ghDbgZoneNMCap) & 0x0001)
#define ZONE_NMCAP_REFCOUNT (GETMASK(ghDbgZoneNMCap) & 0x0002)
#define ZONE_NMCAP_STREAMING (GETMASK(ghDbgZoneNMCap) & 0x0004)

#ifndef DEBUGMSG // { DEBUGMSG
#define DEBUGMSG(z,s)	( (z) ? (NacDbgPrintf s ) : 0)
#endif // } DEBUGMSG
#ifndef FX_ENTRY // { FX_ENTRY
#define FX_ENTRY(s)	static TCHAR _this_fx_ [] = (s);
#define _fx_		((LPTSTR) _this_fx_)
#endif // } FX_ENTRY
#define ERRORMESSAGE(m) (NacDbgPrintf m)
#else // }{ DEBUG
#ifndef FX_ENTRY // { FX_ENTRY
#define FX_ENTRY(s)	
#endif // } FX_ENTRY
#ifndef DEBUGMSG // { DEBUGMSG
#define DEBUGMSG(z,s)
#define ERRORMESSAGE(m)
#endif  // } DEBUGMSG
#define _fx_		
#define ERRORMESSAGE(m)
#endif // } DEBUG

// Message ids.
// Ensure ids correspond to  message strings in LogStringTable[]

enum LogMsgs {
	LOGMSG_SENT		=	1,
	LOGMSG_NET_RECVD,
	LOGMSG_AUD_SEND,
	LOGMSG_SILENT,
	LOGMSG_RECORD,
	LOGMSG_AUD_RECV,
	LOGMSG_RX_RESET,
	LOGMSG_RX_RESET2,
	LOGMSG_ENCODED,
	LOGMSG_DECODED,
	LOGMSG_PLAY,
	LOGMSG_PLAY_SILENT,
	LOGMSG_OPEN_AUDIO,
	LOGMSG_PLAY_YIELD,
	LOGMSG_REC_YIELD,
	LOGMSG_AUD_RECYCLE,
	LOGMSG_AUTO_SILENCE,
	LOGMSG_PRESEND,
	LOGMSG_RX_SKIP,
	LOGMSG_TX_RESET,
	LOGMSG_JITTER,
	LOGMSG_PLAY_INTERPOLATED,
	LOGMSG_INTERPOLATED,
	LOGMSG_VID_SEND,
	LOGMSG_VID_RECV,
	LOGMSG_VID_RECYCLE,
	LOGMSG_VID_RECORD,
	LOGMSG_VID_PLAY,
	LOGMSG_VID_PLAY_SILENT,
	LOGMSG_VID_PLAY_INTERPOLATED,
	LOGMSG_VID_INTERPOLATED,
	LOGMSG_VID_ENCODED,
	LOGMSG_VID_DECODED,
	LOGMSG_OPEN_VIDEO,
	LOGMSG_GET_SEND_FRAME,
	LOGMSG_GET_RECV_FRAME,
	LOGMSG_RELEASE_SEND_FRAME,
	LOGMSG_RELEASE_RECV_FRAME,
	LOGMSG_TESTSYNC,
	LOGMSG_ONREAD1,
	LOGMSG_ONREAD2,
	LOGMSG_ONREADDONE1,
	LOGMSG_ONREADDONE2,
	LOGMSG_RECVFROM1,
	LOGMSG_RECVFROM2,
	LOGMSG_READWOULDBLOCK,
	LOGMSG_VIDSEND_VID_QUEUING,
	LOGMSG_VIDSEND_AUD_QUEUING,
	LOGMSG_VIDSEND_VID_SEND,
	LOGMSG_VIDSEND_AUD_SEND,
	LOGMSG_VIDSEND_VID_NOT_SEND,
	LOGMSG_VIDSEND_AUD_NOT_SEND,
	LOGMSG_VIDSEND_IO_PENDING,
	LOGMSG_VIDSEND_AUDIO_QUEUE_EMPTY,
	LOGMSG_VIDSEND_VIDEO_QUEUE_EMPTY,
	LOGMSG_AUDSEND_VID_QUEUING,
	LOGMSG_AUDSEND_AUD_QUEUING,
	LOGMSG_AUDSEND_VID_SEND,
	LOGMSG_AUDSEND_AUD_SEND,
	LOGMSG_AUDSEND_VID_NOT_SEND,
	LOGMSG_AUDSEND_AUD_NOT_SEND,
	LOGMSG_AUDSEND_IO_PENDING,
	LOGMSG_AUDSEND_AUDIO_QUEUE_EMPTY,
	LOGMSG_AUDSEND_VIDEO_QUEUE_EMPTY,
	LOGMSG_SEND_BLOCKED,

	LOGMSG_DSPLAY,
	LOGMSG_DSEMPTY,
	LOGMSG_DSTIMEOUT,
	LOGMSG_DSMOVPOS,
	LOGMSG_DSCREATE,
	LOGMSG_DSRELEASE,
	LOGMSG_DSDROPOOS, // out of sequence
	LOGMSG_DSENTRY,
	LOGMSG_DSTIME,
	LOGMSG_DSSTATUS,
	LOGMSG_DSDROPOVERFLOW, // overflow
	LOGMSG_DSOFCONDITION,

	LOGMSG_TIME_SEND_AUDIO_CONFIGURE,
	LOGMSG_TIME_SEND_AUDIO_UNCONFIGURE,
	LOGMSG_TIME_SEND_VIDEO_CONFIGURE,
	LOGMSG_TIME_SEND_VIDEO_UNCONFIGURE,
	LOGMSG_TIME_RECV_AUDIO_CONFIGURE,
	LOGMSG_TIME_RECV_AUDIO_UNCONFIGURE,
	LOGMSG_TIME_RECV_VIDEO_CONFIGURE,
	LOGMSG_TIME_RECV_VIDEO_UNCONFIGURE,

	LOGMSG_DSC_TIMESTAMP,
	LOGMSG_DSC_GETCURRENTPOS,
	LOGMSG_DSC_LOG_TIMEOUT,
	LOGMSG_DSC_LAGGING,
	LOGMSG_DSC_SENDING,
	LOGMSG_DSC_STATS,
	LOGMSG_DSC_EARLY
};

#ifdef DEBUG
#define LOGGING	1
#else
#ifdef TEST
#define LOGGING 1
#endif
#endif

#ifdef LOGGING
#define MAX_STRING_SIZE		64

void Log (UINT n, UINT arg1=0, UINT arg2=0, UINT arg3=0);
LogInit();
LogClose();
#define LOG(x) Log x

#else

#define LOG(x)
#define LogInit()
#define LogClose()
#endif	// LOGGING


HRESULT InitAudioFlowspec(FLOWSPEC *pFlowSpec, WAVEFORMATEX *pwf, DWORD dwPacketSize);
HRESULT InitVideoFlowspec(FLOWSPEC *pFlowspec, DWORD dwMaxBitrate, DWORD dwMaxFrag, DWORD dwAvgPacketSize);


#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#include <poppack.h> /* End byte packing */

#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\vidpackt.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    vidpackt.h

Abstract:

    Contains  prototypes for the VideoPacket class, which encapsulates a video buffer in
    its various states: recorded/encoded/network/decoded/playing etc.

--*/
#ifndef _VIDPACKT_H_
#define _VIDPACKT_H_

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#define VP_NUM_PREAMBLE_PACKETS		6

#define MAX_CIF_VIDEO_FRAGMENTS		40
#define MAX_QCIF_VIDEO_FRAGMENTS 	20
#define MAX_VIDEO_FRAGMENTS		 	MAX_CIF_VIDEO_FRAGMENTS

class VideoPacket : public MediaPacket
{
 private:
    IBitmapSurface *m_pBS;
 public:
	virtual HRESULT Initialize ( MEDIAPACKETINIT * p );
	virtual HRESULT Play ( MMIODEST *pmmioDest, UINT uDataType );
	virtual HRESULT Record ( void );
	virtual HRESULT Interpolate ( MediaPacket * pPrev, MediaPacket * pNext);
	virtual HRESULT GetSignalStrength ( PDWORD pdwMaxStrength );
	virtual HRESULT MakeSilence ( void );
	virtual HRESULT Recycle ( void );
	virtual HRESULT Open ( UINT uType, DPHANDLE hdl );	// called by RxStream or TxStream
	virtual HRESULT Close ( UINT uType );				// called by RxStream or TxStream
	virtual BOOL IsBufferDone ( void );
	virtual BOOL IsSameMediaFormat(PVOID fmt1,PVOID fmt2);
	virtual DWORD GetDevDataSamples();
	void WriteToFile (MMIODEST *pmmioDest);
	void ReadFromFile (MMIOSRC *pmmioSrc );
	HRESULT SetSurface (IBitmapSurface *pBS);
};


#include <poppack.h> /* End byte packing */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\vidpackt.cpp ===
#include "precomp.h"

#define ZONE_AP			ZONE_DP


#define _GetState()		(m_dwState & DP_MASK_STATE)
#define _SetState(s)	(m_dwState = (m_dwState & ~DP_MASK_STATE) | (s & DP_MASK_STATE))

#define _GetPlatform()	(m_dwState & DP_MASK_PLATFORM)
#define _SetPlatform(s)	(m_dwState = (m_dwState & ~DP_MASK_PLATFORM) | (s & DP_MASK_PLATFORM))


int g_videoin_prepare = 0;
int g_videoout_prepare = 0;


///////////////////////////////////////////////////////
//
//  Public methods
//

HRESULT VideoPacket::Initialize ( MEDIAPACKETINIT * p )
{
	HRESULT hr = DPR_SUCCESS;
	ULONG		cbSizeDevData;
	ULONG		cbSizeRawData;

	FX_ENTRY ("VdPckt::Init")

    m_pBS = NULL;

	if (p == NULL)
	{
		DEBUGMSG (ZONE_AP, ("%s: invalid parameter (null ptr)\r\n", _fx_));
		return DPR_INVALID_PARAMETER;
	}

	if (p->dwFlags & DP_FLAG_SEND) {
    	cbSizeDevData = p->cbSizeDevData;
	    cbSizeRawData = p->cbSizeRawData;
    	if (IsSameMediaFormat(p->pStrmConvSrcFmt, p->pDevFmt))
    	    p->cbSizeRawData = 0;
    	p->cbSizeDevData = 0;
	}
	
	hr = MediaPacket::Initialize( p);

// LOOKLOOK RP - if DP_FLAG_SEND, then we've allocated a memory header for the dev buffer,
// but haven't actually allocated memory for the buffer
	if (p->dwFlags & DP_FLAG_SEND) {
		m_pDevData->data = NULL;
   		m_pDevData->length = cbSizeDevData;
	}

	if (hr != DPR_SUCCESS)
		goto MyExit;
		
	// allocate conversion header only if m_pWaveData != m_pNetData
	if (m_pRawData != m_pNetData)
	{
		if (m_dwState & DP_FLAG_VCM)
		{
			m_pStrmConvHdr = MemAlloc (sizeof (VCMSTREAMHEADER));
			if (m_pStrmConvHdr == NULL)
			{
				DEBUGMSG (ZONE_AP, ("%s: MemAlloc4 (%ld) failed\r\n",
				_fx_, (ULONG) sizeof (VCMSTREAMHEADER)));
				hr = DPR_OUT_OF_MEMORY;
				goto MyExit;
			}
		}
		else
		{
			DEBUGMSG (ZONE_AP, ("%s: invalid platform (vcm)\r\n", _fx_));
			hr = DPR_INVALID_PLATFORM;
			goto MyExit;
		}
	}
	else
	{
		m_pStrmConvHdr = NULL;
	}

	MakeSilence ();

MyExit:

	if (hr != DPR_SUCCESS)
	{
		m_fInitialized = FALSE;
		Release();
	}

	return hr;
}


HRESULT VideoPacket::Play ( MMIODEST *pmmioDest, UINT uDataType )
{
	return DPR_INVALID_HANDLE;
}



HRESULT VideoPacket::Record ( void )
{
	FX_ENTRY ("VdPckt::Record")

	LOG((LOGMSG_VID_RECORD,m_index));

	if (_GetState () != MP_STATE_RESET)
	{
		DEBUGMSG (ZONE_AP, ("%s: out of seq, state=0x%lX\r\n", _fx_, m_dwState));
		return DPR_OUT_OF_SEQUENCE;
	}
	
	if (m_pBS && m_pDevData->data) {
	    m_pBS->UnlockBits(NULL, m_pDevData->data);
        m_pBS->Release();
		m_pDevData->data = NULL;
        m_pBS = NULL;
	}
	
	_SetState (MP_STATE_RECORDING);
	return DPR_SUCCESS;
}


HRESULT VideoPacket::SetSurface (IBitmapSurface *pBS)
{
    void* pBits;
    long pitch;

	FX_ENTRY ("VdPckt::SetSurface")
	
    if (pBS) {
        m_pBS = pBS;
        m_pBS->LockBits(NULL, 0, &pBits, &pitch);
        if (!pBits) {
            m_pBS->UnlockBits(NULL, pBits);
            return ERROR_IO_INCOMPLETE;
        }
        m_pBS->AddRef();
        m_pDevData->data = (UCHAR *)pBits;
        return DPR_SUCCESS;
    }
    return E_INVALIDARG;
}


HRESULT VideoPacket::Recycle ( void )
{
	if (m_pBS && m_pDevData->data) {
	    m_pBS->UnlockBits(NULL, m_pDevData->data);
        m_pBS->Release();
		m_pDevData->data = NULL;
        m_pBS = NULL;
	}
    return MediaPacket::Recycle();
}


BOOL VideoPacket::IsBufferDone ( void )
{
	FX_ENTRY ("VdPckt::IsBufferDone")

	if (m_hDev)
	{
		if (m_dwState & DP_FLAG_VIDEO)
		{
//LOOKLOOK RP - what does this need to do?
#if 1
            return TRUE;
#else
~~~			return (((VIDEOINOUTHDR *) m_pDevHdr)->dwFlags & WHDR_DONE);
#endif
		}
	}

	return FALSE;
}


HRESULT VideoPacket::MakeSilence ( void )
{
	// create white noise!!!

	FX_ENTRY ("VdPckt::MakeSilence")

	if (m_pDevFmt)
	{
		if (m_pDevData)
		{
			// Don't need to do anything, what's on screen should do it.
			CopyPreviousBuf ((VIDEOFORMATEX *) m_pDevFmt, (PBYTE) m_pDevData->data,
											(ULONG) m_pDevData->length);
		}
	}

	_SetState(MP_STATE_RESET);
	return DPR_SUCCESS;
}


HRESULT VideoPacket::GetSignalStrength ( PDWORD pdwMaxStrength )
{

	FX_ENTRY ("VdPckt::GetSignalStrength")

	// For now send each and every frame.
	// But you should consider sending only the frames if they
	// are really different of the previously sent one.
	// This will save quite some bandwidth when there is no or
	// very little activity in the video frames.


	return DPR_NOT_YET_IMPLEMENTED;
}


HRESULT VideoPacket::Interpolate ( MediaPacket * pPrev, MediaPacket * pNext)
{
	HRESULT			hr = DPR_SUCCESS;
	DPHANDLE		hPrevDev;
	NETBUF			*pPrevDevData;
	PVOID			pPrevDevHdr;
	VIDEOFORMATEX	*pPrevpfDev;
	VIDEOFORMATEX	*pNextpfDev;
	NETBUF			*pNextDevData;
	PVOID			pNextDevHdr;

	FX_ENTRY ("VdPckt::Interpolate")

	DEBUGMSG (ZONE_AP, ("%s: can't interpolate\r\n", _fx_));
	hr = DPR_INVALID_HANDLE;

	return hr;

}


HRESULT VideoPacket::Open ( UINT uType, DPHANDLE hdl )
// called by RxStream or TxStream
{
	HRESULT hr = DPR_SUCCESS;
	MMRESULT mmr;

	FX_ENTRY ("VdPckt::Open")

	switch (uType)
	{
#ifdef PREP_HDR_PER_CONV
	case MP_TYPE_RECVSTRMCONV:
		m_hStrmConv = hdl;
		break;
#endif

	case MP_TYPE_STREAMCONV:
		if ((m_hStrmConv = hdl) != NULL)
		{
			if (m_dwState & DP_FLAG_VCM)
			{
				// initialize the header
				ZeroMemory (m_pStrmConvHdr, sizeof (VCMSTREAMHEADER));
				((VCMSTREAMHEADER *) m_pStrmConvHdr)->cbStruct = sizeof (VCMSTREAMHEADER);
				((VCMSTREAMHEADER *) m_pStrmConvHdr)->fdwStatus = 0;
				((VCMSTREAMHEADER *) m_pStrmConvHdr)->dwUser = 0;
				((VCMSTREAMHEADER *) m_pStrmConvHdr)->dwSrcUser = 0;
				((VCMSTREAMHEADER *) m_pStrmConvHdr)->cbSrcLengthUsed = 0;
				((VCMSTREAMHEADER *) m_pStrmConvHdr)->dwDstUser = 0;
				((VCMSTREAMHEADER *) m_pStrmConvHdr)->cbDstLengthUsed = 0;
				
				if (m_pNetData && m_pRawData)
				{
					
					if (m_dwState & DP_FLAG_SEND)
					{
					    if (m_pRawData->data) {
						    ((VCMSTREAMHEADER *) m_pStrmConvHdr)->pbSrc = m_pRawData->data;
						    ((VCMSTREAMHEADER *) m_pStrmConvHdr)->cbSrcLength = m_pRawData->length;
						}
						else {
						    // don't have a static raw buffer, so let vcmStreamPrepareHeader
						    // lock the net buffer twice
						    ((VCMSTREAMHEADER *) m_pStrmConvHdr)->pbSrc = m_pNetData->data;
						    ((VCMSTREAMHEADER *) m_pStrmConvHdr)->cbSrcLength = m_pNetData->length;
						}
						((VCMSTREAMHEADER *) m_pStrmConvHdr)->pbDst = m_pNetData->data;
						((VCMSTREAMHEADER *) m_pStrmConvHdr)->cbDstLength = m_pNetData->length;
					}
					else
					if (m_dwState & DP_FLAG_RECV)
					{
						((VCMSTREAMHEADER *) m_pStrmConvHdr)->pbSrc = m_pNetData->data;
						((VCMSTREAMHEADER *) m_pStrmConvHdr)->cbSrcLength = m_pNetData->length;
						((VCMSTREAMHEADER *) m_pStrmConvHdr)->pbDst = m_pRawData->data;
						((VCMSTREAMHEADER *) m_pStrmConvHdr)->cbDstLength = m_pRawData->length;
					}

					// prepare the header
					mmr = vcmStreamPrepareHeader ((HVCMSTREAM) m_hStrmConv,
												  (VCMSTREAMHEADER *) m_pStrmConvHdr, 0);
					if (mmr != MMSYSERR_NOERROR)
					{
						DEBUGMSG (ZONE_AP, ("%s: vcmStreamPrepareHeader failed, mmr=%ld\r\n", _fx_, (ULONG) mmr));
						hr = DPR_CANT_PREPARE_HEADER;
						goto MyExit;
					}

					m_fStrmPrepared = TRUE;
				}
				else
					m_fStrmPrepared = FALSE;
			}
			else
			{
				hr = DPR_INVALID_PLATFORM;
				goto MyExit;
			}
		}
		break;

	case MP_TYPE_DEV:
		if ((m_hDev = hdl) != NULL)
		{
			if (m_dwState & DP_FLAG_VIDEO)
			{
				if (m_dwState & DP_FLAG_SEND)
				{
					g_videoin_prepare++;
				}
				else
				if (m_dwState & DP_FLAG_RECV)
				{
					g_videoout_prepare++;
				}
				else
				{
					hr = DPR_INVALID_PARAMETER;
					goto MyExit;
				}

				m_fDevPrepared = TRUE;
			}
			else
			{
				hr = DPR_INVALID_PLATFORM;
				goto MyExit;
			}
		}
		else
		{
			hr = DPR_INVALID_HANDLE;
			goto MyExit;
		}
		break;

	default:
		hr = DPR_INVALID_PARAMETER;
		goto MyExit;
	}

MyExit:

	return hr;
}


HRESULT VideoPacket::Close ( UINT uType )
// called by RxStream or TxStream
{
	HRESULT hr = DPR_SUCCESS;
	MMRESULT mmr;

	FX_ENTRY ("VdPckt::Close")

	switch (uType)
	{
	case MP_TYPE_RECVSTRMCONV:

	case MP_TYPE_STREAMCONV:
		if (m_hStrmConv)
		{
			if (m_dwState & DP_FLAG_VCM)
			{
				if (m_fStrmPrepared)
				{
					// unprepare the header
				    if ((m_dwState & DP_FLAG_SEND) && !m_pRawData->data)
				    {
					    // don't have a static raw buffer, so let vcmStreamUnprepareHeader
					    // unlock the net buffer twice to unwind what Open did
					    ((VCMSTREAMHEADER *) m_pStrmConvHdr)->pbSrc = m_pNetData->data;
					    ((VCMSTREAMHEADER *) m_pStrmConvHdr)->cbSrcLength = m_pNetData->length;
					}
					mmr = vcmStreamUnprepareHeader ((HVCMSTREAM) m_hStrmConv,
													(VCMSTREAMHEADER *) m_pStrmConvHdr, 0);

					m_fStrmPrepared = FALSE; // don't care about any error

					if (mmr != MMSYSERR_NOERROR)
					{
						DEBUGMSG (ZONE_AP, ("%s: vcmStreamUnprepareHeader failed, mmr=%ld\r\n", _fx_, (ULONG) mmr));
						hr = DPR_CANT_UNPREPARE_HEADER;
						goto MyExit;
					}
				}
			}

			if (uType == MP_TYPE_STREAMCONV) m_hStrmConv = NULL;
		}
		break;

	case MP_TYPE_DEV:
		if (m_hDev)
		{
			if (m_fDevPrepared)
			{
				if (m_dwState & DP_FLAG_SEND)
				{
					g_videoin_prepare--;
				}
				else
				if (m_dwState & DP_FLAG_RECV)
				{
					g_videoout_prepare--;
				}
				else
				{
					hr = DPR_INVALID_PARAMETER;
					goto MyExit;
				}

				m_fDevPrepared = FALSE; // don't care about any error

			}

			m_hDev = NULL;
		}
		else
		{
			hr = DPR_INVALID_HANDLE;
			goto MyExit;
		}
		break;

	default:
		hr = DPR_INVALID_PARAMETER;
		goto MyExit;
	}

MyExit:

	return hr;
}


void VideoPacket::WriteToFile (MMIODEST *pmmioDest)
{
	MMRESULT mmr;
	long dwDataLength;

	FX_ENTRY ("VdPckt::WriteToFile")

#ifdef need_video_file_io
// BUGBUG - this stuff doesn't work
	if (dwDataLength = (DWORD)(pmmioDest->dwDataLength + m_pDevData->length) > pmmioDest->dwMaxDataLength ? (DWORD)(pmmioDest->dwMaxDataLength - pmmioDest->dwDataLength) : m_pDevData->length)
	{
		if (mmioWrite(pmmioDest->hmmioDst, (char *) m_pDevData->data, dwDataLength) != (LONG)m_pDevData->length)
			mmr = MMSYSERR_ERROR;
		else
			pmmioDest->dwDataLength += dwDataLength;
		if ((mmr == MMSYSERR_ERROR) || (pmmioDest->dwDataLength == pmmioDest->dwMaxDataLength))
		{
			mmr = mmioAscend(pmmioDest->hmmioDst, &(pmmioDest->ckDst), 0);
			mmr = mmioAscend(pmmioDest->hmmioDst, &(pmmioDest->ckDstRIFF), 0);
			mmr = mmioClose(pmmioDest->hmmioDst, 0);
			pmmioDest->hmmioDst = NULL;
		}
	}
#endif
}

void VideoPacket::ReadFromFile (MMIOSRC *pmmioSrc)
{
	long lNumBytesRead;

	FX_ENTRY ("VdPckt::ReadFromFile")

#ifdef need_video_file_io
// BUGBUG - this stuff doesn't work

	if (((VIDEOINOUTHDR *) m_pDevHdr)->dwBytesUsed)
	{
MyRead:
		if ((pmmioSrc->dwDataLength + ((VIDEOINOUTHDR *) m_pDevHdr)->dwBytesUsed) <= pmmioSrc->dwMaxDataLength)
		{
			lNumBytesRead = mmioRead(pmmioSrc->hmmioSrc, ((VIDEOINOUTHDR *) m_pDevHdr)->pData, ((VIDEOINOUTHDR *) m_pDevHdr)->dwBytesUsed);
			pmmioSrc->dwDataLength += lNumBytesRead;
		}
		else
		{
			lNumBytesRead = mmioRead(pmmioSrc->hmmioSrc, ((VIDEOINOUTHDR *) m_pDevHdr)->pData, pmmioSrc->dwMaxDataLength - pmmioSrc->dwDataLength);
			pmmioSrc->dwDataLength += lNumBytesRead;
			CopyPreviousBuf ((VIDEOFORMATEX *) m_pDevFmt, (PBYTE) ((VIDEOINOUTHDR *) m_pDevHdr)->pData + lNumBytesRead, ((VIDEOINOUTHDR *) m_pDevHdr)->dwBytesUsed - lNumBytesRead);
			pmmioSrc->dwDataLength = 0;
			lNumBytesRead = 0;
		}
		
		if (!lNumBytesRead)
		{
			if (pmmioSrc->fLoop && !pmmioSrc->fDisconnectAfterPlayback)
			{
				// Reset file pointer to beginning of data
				mmioAscend(pmmioSrc->hmmioSrc, &(pmmioSrc->ckSrc), 0);
				if (-1L == mmioSeek(pmmioSrc->hmmioSrc, pmmioSrc->ckSrcRIFF.dwDataOffset + sizeof(FOURCC), SEEK_SET))
				{
					DEBUGMSG (1, ("MediaControl::OpenSrcFile: Couldn't seek in file, mmr=%ld\r\n", (ULONG) 0L));
					goto MyMMIOErrorExit2;
				}
				pmmioSrc->ckSrc.ckid = mmioFOURCC('d', 'a', 't', 'a');
				if (mmioDescend(pmmioSrc->hmmioSrc, &(pmmioSrc->ckSrc), &(pmmioSrc->ckSrcRIFF), MMIO_FINDCHUNK))
				{
					DEBUGMSG (1, ("MediaControl::OpenSrcFile: Couldn't locate 'data' chunk, mmr=%ld\r\n", (ULONG) 0L));
					goto MyMMIOErrorExit2;
				}

				// At this point, the src file is sitting at the very
				// beginning of its data chunks--so we can read from the src file...
				goto MyRead;
MyMMIOErrorExit2:
				mmioAscend(pmmioSrc->hmmioSrc, &(pmmioSrc->ckSrcRIFF), 0);
				mmioClose(pmmioSrc->hmmioSrc, 0);
				pmmioSrc->hmmioSrc = NULL;
			}
			else
			{
				mmioAscend(pmmioSrc->hmmioSrc, &(pmmioSrc->ckSrcRIFF), 0);
				mmioClose(pmmioSrc->hmmioSrc, 0);
				pmmioSrc->hmmioSrc = NULL;
				/* Dont want to disconnect the whole connection
				 * TODO: investigate closing the channel
				if (pmmioSrc->fDisconnectAfterPlayback)
					pConnection->SetMode(CMT_Disconnect);
				*/
			}
		}
	}
#endif
}


BOOL VideoPacket::IsSameMediaFormat(PVOID fmt1,PVOID fmt2)
{
	return IsSameFormat(fmt1,fmt2);
}


// returns length of uncompressed video data in buffer
// NOTE: not used yet
DWORD
VideoPacket::GetDevDataSamples()
{
	// samples == frames for video and we only deal with one frame per pkt for now.
	return 1;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\vcmfilter.h ===
#ifndef VCM_FILTER_H
#define VCM_FILTER_H


#define VP_ENCODE	1
#define VP_DECODE	2







enum
{
	FM_PROP_POSTPROCESSING_SUPPORTED,
	FM_PROP_VIDEO_BRIGHTNESS,
	FM_PROP_VIDEO_CONTRAST,
	FM_PROP_VIDEO_SATURATION,
	FM_PROP_VIDEO_IMAGE_QUALITY,
	FM_PROP_VIDEO_RESET_BRIGHTNESS,
	FM_PROP_VIDEO_RESET_CONTRAST,
	FM_PROP_VIDEO_RESET_SATURATION,
	FM_PROP_VIDEO_RESET_IMAGE_QUALITY,
	FM_PROP_PAYLOAD_HEADER_SIZE,
	FM_PROP_VIDEO_MAX_PACKET_SIZE,
	FM_PROP_PERIODIC_IFRAMES,
	FM_PROP_NumOfProps
};







class VcmFilter
{

private:
	VIDEOFORMATEX m_vfSrc;  // source format
	VIDEOFORMATEX m_vfDst;  // destination format

	HVCMSTREAM m_hStream;   // handle to vcm stream

	DWORD m_dwBrightness;
	DWORD m_dwContrast;
	DWORD m_dwImageQuality;
	DWORD m_dwSaturation;

	BOOL m_bOpen;
	BOOL m_bSending;  // TRUE if compressing for send
	                 // FALSE if decompressing for receive 
	              
public:
	VcmFilter();
	~VcmFilter();

	MMRESULT Open(VIDEOFORMATEX *pVfSrc, VIDEOFORMATEX *pVfDst, DWORD dwMaxFragSize);
	MMRESULT PrepareHeader(PVCMSTREAMHEADER pVcmHdr);
	MMRESULT UnprepareHeader(PVCMSTREAMHEADER pVcmHdr);
	MMRESULT Close();

	MMRESULT Convert(PVCMSTREAMHEADER pVcmHdr, DWORD dwEncodeFlags=0, BOOL bPrepareHeader=FALSE);
	MMRESULT Convert(BYTE *pSrcBuffer, DWORD dwSrcSize,
	                 BYTE *pDstBuffer, DWORD dwDstSize,
	                 DWORD dwEncodeFlags=0);

	MMRESULT Convert(VideoPacket *pVP, UINT uDirection, DWORD dwEncodeFlags=0);



	HRESULT GetProperty(DWORD dwPropId, PDWORD pdwPropVal);
	HRESULT SetProperty(DWORD dwPropID, DWORD dwPropVal);

	MMRESULT SuggestSrcSize(DWORD dwDestSize, DWORD *p_dwSuggestedSourceSize);
	MMRESULT SuggestDstSize(DWORD dwSourceSize, DWORD *p_dwSuggestedDstSize);

	MMRESULT RestorePayload(WSABUF *ppDataPkt, DWORD dwPktCount, PBYTE pbyFrame, PDWORD pdwFrameSize, BOOL *pfReceivedKeyframe);
	MMRESULT FormatPayload(PBYTE pDataSrc, DWORD dwDataSize, PBYTE *ppDataPkt,
	                       PDWORD pdwPktSize, PDWORD pdwPktCount, UINT *pfMark,
						   PBYTE *pHdrInfo,	PDWORD pdwHdrSize);

	// inline wrappers to vcm functions
	MMRESULT GetPayloadHeaderSize(DWORD *pdwSize) {return vcmStreamGetPayloadHeaderSize(m_hStream, pdwSize);}
	MMRESULT RequestIFrame() {return vcmStreamRequestIFrame(m_hStream);}
	MMRESULT SetTargetRates(DWORD dwTargetFrameRate, DWORD dwTargetByteRate)
	{return vcmStreamSetTargetRates(m_hStream, dwTargetFrameRate, dwTargetByteRate);}


	static MMRESULT SuggestDecodeFormat(VIDEOFORMATEX *pVfSrc, VIDEOFORMATEX *pVfDst);
	static MMRESULT SuggestEncodeFormat(UINT uDevice, VIDEOFORMATEX *pfEnc, VIDEOFORMATEX *pfDec);


};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\vcmfilter.cpp ===
#include "precomp.h"
#include "VcmFilter.h"





VcmFilter::VcmFilter() :
m_hStream(NULL),
m_dwBrightness(VCM_RESET_BRIGHTNESS),
m_dwContrast(VCM_RESET_CONTRAST),
m_dwImageQuality(VCM_RESET_IMAGE_QUALITY),
m_dwSaturation(VCM_RESET_SATURATION),
m_bOpen(FALSE),
m_bSending(FALSE)
{;}


VcmFilter::~VcmFilter()
{
	Close();
}



// we should figure out based on the Src and Dst parameters
// whether or not this is a send or receive filter
MMRESULT VcmFilter::Open(VIDEOFORMATEX *pVfSrc, VIDEOFORMATEX *pVfDst, DWORD dwMaxFragSize)
{
	MMRESULT mmr;

	// just in case, we are open in some other context:
	Close();


	// are we sending (compressing) or are we receiving (uncompressing)
	ASSERT((pVfSrc->bih.biCompression) || (pVfDst->bih.biCompression));
	m_bSending = ((pVfSrc->bih.biCompression == BI_RGB) ||
	              (pVfDst->bih.biCompression != BI_RGB));

	if (m_bSending == FALSE)
	{
		m_dwBrightness = VCM_DEFAULT_BRIGHTNESS;
		m_dwContrast = VCM_DEFAULT_CONTRAST;
		m_dwSaturation = VCM_DEFAULT_SATURATION;
	}
	else
	{
		m_dwImageQuality = VCM_DEFAULT_IMAGE_QUALITY;
	}

	
	mmr = vcmStreamOpen ((PHVCMSTREAM) &m_hStream, NULL,
								 pVfSrc,
								 pVfDst,
								 m_dwImageQuality, dwMaxFragSize, 0, 0, 0);
	if (mmr != MMSYSERR_NOERROR)
	{
		ERRORMESSAGE( ("VcmFilter::Open - failed, mmr=%ld\r\n", (ULONG) mmr));
		m_bOpen = FALSE;
	}
	else
	{
		m_vfSrc = *pVfSrc;
		m_vfDst = *pVfDst;
		m_bOpen = TRUE;
	}
	return mmr;

}


MMRESULT VcmFilter::Close()
{
	MMRESULT mmr=MMSYSERR_NOERROR;

	if (m_bOpen)
	{
		mmr = vcmStreamClose(m_hStream);
	}

	m_hStream = NULL;
	m_bOpen = FALSE;
	return mmr;
}



MMRESULT VcmFilter::PrepareHeader(PVCMSTREAMHEADER pVcmHdr)
{
	MMRESULT mmr;

	if (m_bOpen == FALSE)
	{
		return MMSYSERR_INVALHANDLE;
	}

	mmr = vcmStreamPrepareHeader(m_hStream, pVcmHdr, 0);
	return mmr;
}


MMRESULT VcmFilter::UnprepareHeader(PVCMSTREAMHEADER pVcmHdr)
{
	MMRESULT mmr;

	if (m_bOpen == FALSE)
	{
		return MMSYSERR_INVALHANDLE;
	}

	mmr = vcmStreamUnprepareHeader(m_hStream, pVcmHdr, 0);
	return mmr;
}



MMRESULT VcmFilter::SuggestSrcSize(DWORD dwDstSize, DWORD *p_dwSuggestedSrcSize)
{
	MMRESULT mmr;

	if (m_bOpen == FALSE)
		return MMSYSERR_INVALHANDLE;

	mmr = vcmStreamSize ( m_hStream, dwDstSize,
	                      p_dwSuggestedSrcSize, VCM_STREAMSIZEF_DESTINATION);

	if (mmr == VCMERR_NOTPOSSIBLE)
	{
		*p_dwSuggestedSrcSize = min (dwDstSize, 256);
		ERROR_OUT(("VcmFilter::SuggestSrcSize() failed (VCMERR_NOTPOSSIBLE) - defaulting to %d as source size\r\n", *p_dwSuggestedSrcSize));
		mmr = MMSYSERR_NOERROR;
	}

	else if (mmr != MMSYSERR_NOERROR)
	{
		*p_dwSuggestedSrcSize = 0;
		DEBUGMSG(ZONE_VCM, ("VcmFilter::SuggestSrcSize() failed (%d)\r\n", mmr));
	}

	return mmr;

}


MMRESULT VcmFilter::SuggestDstSize(DWORD dwSrcSize, DWORD *p_dwSuggestedDecodeSize)
{
	MMRESULT mmr;

	if (m_bOpen == FALSE)
		return MMSYSERR_INVALHANDLE;

	mmr = vcmStreamSize ( m_hStream, dwSrcSize,
	                      p_dwSuggestedDecodeSize, VCM_STREAMSIZEF_SOURCE);

	if (mmr == VCMERR_NOTPOSSIBLE)
	{
		*p_dwSuggestedDecodeSize = min (dwSrcSize, 256);
		ERROR_OUT(("VcmFilter::SuggestDstSize() failed (VCMERR_NOTPOSSIBLE) - defaulting to %d as source size\r\n", *p_dwSuggestedDecodeSize));
		mmr = MMSYSERR_NOERROR;
	}

	else if (mmr != MMSYSERR_NOERROR)
	{
		*p_dwSuggestedDecodeSize = 0;
		DEBUGMSG(ZONE_VCM, ("VcmFilter::SuggestDstSize() failed (%d)\r\n", mmr));
	}

	return mmr;
}


MMRESULT VcmFilter::Convert(PVCMSTREAMHEADER pVcmHdr, DWORD dwEncodeFlags, BOOL bPrepareHeader)
{
	MMRESULT mmr;

	if (m_bOpen == FALSE)
		return MMSYSERR_INVALHANDLE;

	if (bPrepareHeader)
	{
		mmr = PrepareHeader(pVcmHdr);
		if (mmr != MMSYSERR_NOERROR)
			return mmr;
	}


	// encoding...
	// The codec has its own agenda to generate I frames. But we lose the first
	// frames sent. So we need to send more I frames at the beginning. We force this
	// by setting the VCM_STREAMCONVERTF_FORCE_KEYFRAME flag.
	dwEncodeFlags |= VCM_STREAMCONVERTF_START | VCM_STREAMCONVERTF_END;

	mmr = vcmStreamConvert (m_hStream, pVcmHdr, dwEncodeFlags);

	if (mmr != MMSYSERR_NOERROR)
	{
		DEBUGMSG(ZONE_VCM, ("VcmFilter::Convert() failed (%d)\r\n", mmr));
	}

	if (bPrepareHeader)
	{
		UnprepareHeader(pVcmHdr);
	}

	return mmr;
}


MMRESULT VcmFilter::Convert(BYTE *pSrcBuffer, DWORD dwSrcSize,
	                 BYTE *pDstBuffer, DWORD dwDstSize,
	                 DWORD dwEncodeFlags)
{
	VCMSTREAMHEADER vcmHdr;
	MMRESULT mmr;

	if (m_bOpen == FALSE)
		return MMSYSERR_INVALHANDLE;


	ZeroMemory(&vcmHdr, sizeof(vcmHdr));

	vcmHdr.cbStruct = sizeof(vcmHdr);
	vcmHdr.pbSrc = pSrcBuffer;
	vcmHdr.cbSrcLength = dwSrcSize;
	vcmHdr.pbDst = pDstBuffer;
	vcmHdr.cbDstLength = dwDstSize;

	mmr = Convert(&vcmHdr, dwEncodeFlags, TRUE);

	return mmr;

}

MMRESULT VcmFilter::Convert(VideoPacket *pVP, UINT uDirection, DWORD dwEncodeFlags)
{
	VCMSTREAMHEADER *pVcmHdr;
	DWORD_PTR dwPropVal;
	BYTE *pRaw, *pNet;
	UINT uSizeRaw, uSizeNet;
	MMRESULT mmr = MMSYSERR_INVALHANDLE;

	if (m_bOpen == FALSE)
		return MMSYSERR_INVALHANDLE;


	pVP->GetDevData((PVOID*)&pRaw, &uSizeRaw);
	pVP->GetNetData((PVOID*)&pNet, &uSizeNet);
	pVP->GetProp(MP_PROP_FILTER_HEADER, &dwPropVal);
	pVcmHdr = (VCMSTREAMHEADER*)dwPropVal;


	ASSERT(pRaw);
	ASSERT(pNet);

	ZeroMemory(pVcmHdr, sizeof(VCMSTREAMHEADER));
	pVcmHdr->cbStruct = sizeof(VCMSTREAMHEADER);


	if (uDirection == VP_DECODE)
	{
		pVcmHdr->pbSrc = pNet;
		pVcmHdr->cbSrcLength = uSizeNet;
		pVcmHdr->pbDst = pRaw;
		pVcmHdr->cbDstLength = uSizeRaw;

		mmr = Convert(pVcmHdr, dwEncodeFlags, TRUE);

	}
	else if (uDirection == VP_ENCODE)
	{
		pVcmHdr->pbSrc = pRaw;
		pVcmHdr->cbSrcLength = uSizeRaw;
		pVcmHdr->pbDst = pNet;
		pVcmHdr->cbDstLength = uSizeNet;

		mmr = Convert(pVcmHdr, dwEncodeFlags, TRUE);
		if (mmr == MMSYSERR_NOERROR)
		{
			pVP->SetNetLength(pVcmHdr->cbDstLengthUsed);
		}
	}

	return mmr;

}


// this method is static
MMRESULT VcmFilter::SuggestDecodeFormat(VIDEOFORMATEX *pVfSrc, VIDEOFORMATEX *pVfDst)
{
	MMRESULT mmr;


	pVfDst->nSamplesPerSec = pVfSrc->nSamplesPerSec;
	pVfDst->dwFormatTag = VIDEO_FORMAT_BI_RGB;

	mmr = vcmFormatSuggest(VIDEO_MAPPER, NULL, pVfSrc, (VIDEOFORMATEX *)pVfDst, sizeof(VIDEOFORMATEX),
			VCM_FORMATSUGGESTF_DST_NSAMPLESPERSEC | VCM_FORMATSUGGESTF_DST_WFORMATTAG);

	if (mmr != MMSYSERR_NOERROR)
	{
		ERRORMESSAGE( ("VcmFilter::SuggestDecodeFormat failed, mmr=%ld\r\n", (ULONG) mmr));
	}
	return mmr;
}


// this method is static
MMRESULT VcmFilter::SuggestEncodeFormat(UINT uDevice, VIDEOFORMATEX *pfEnc, VIDEOFORMATEX *pfDec)
{
	MMRESULT mmr;
	DWORD dwFormatTag;

	pfEnc->nSamplesPerSec = pfDec->nSamplesPerSec;

	// Get the preferred format of the capture device
	if ((mmr = vcmGetDevCapsPreferredFormatTag(uDevice, &dwFormatTag)) != MMSYSERR_NOERROR)
		return mmr;

	pfEnc->dwFormatTag = dwFormatTag;

	mmr = vcmFormatSuggest(uDevice, NULL, pfEnc, (VIDEOFORMATEX *)pfDec, sizeof(VIDEOFORMATEX),
			VCM_FORMATSUGGESTF_SRC_NSAMPLESPERSEC | VCM_FORMATSUGGESTF_SRC_WFORMATTAG);

	if (mmr != MMSYSERR_NOERROR)
	{
		ERRORMESSAGE( ("VcmFilter::SuggestEncodeFormat failed, mmr=%ld\r\n", (ULONG) mmr));
	}

	return mmr;

}


HRESULT VcmFilter::SetProperty(DWORD dwPropId, DWORD dwPropVal)
{
	HRESULT hr = DPR_SUCCESS;

	switch (dwPropId)
	{
		case FM_PROP_VIDEO_BRIGHTNESS:
			m_dwBrightness = dwPropVal;
			vcmStreamSetBrightness (m_hStream, m_dwBrightness);
			break;

		case FM_PROP_VIDEO_CONTRAST:
			m_dwContrast = dwPropVal;
			vcmStreamSetContrast (m_hStream, m_dwContrast);
			break;

		case FM_PROP_VIDEO_SATURATION:
			m_dwSaturation = dwPropVal;
			vcmStreamSetSaturation (m_hStream, m_dwSaturation);
			break;

		case FM_PROP_VIDEO_IMAGE_QUALITY:
			m_dwImageQuality = dwPropVal;
			vcmStreamSetImageQuality (m_hStream, m_dwImageQuality);
			break;
		
		case FM_PROP_VIDEO_RESET_BRIGHTNESS:
			m_dwBrightness = VCM_DEFAULT_BRIGHTNESS;
			vcmStreamSetBrightness (m_hStream, VCM_RESET_BRIGHTNESS);
			break;

		case FM_PROP_VIDEO_RESET_CONTRAST:
			m_dwContrast = VCM_DEFAULT_CONTRAST;
			vcmStreamSetContrast (m_hStream, VCM_RESET_CONTRAST);
			break;

		case FM_PROP_VIDEO_RESET_SATURATION:
			m_dwSaturation = VCM_DEFAULT_SATURATION;
			vcmStreamSetSaturation (m_hStream, VCM_RESET_SATURATION);
			break;

		case FM_PROP_VIDEO_RESET_IMAGE_QUALITY:
			m_dwImageQuality = VCM_DEFAULT_IMAGE_QUALITY;
			vcmStreamSetImageQuality (m_hStream, VCM_RESET_IMAGE_QUALITY);
			break;

		case FM_PROP_VIDEO_MAX_PACKET_SIZE:
			vcmStreamSetMaxPacketSize (m_hStream, dwPropVal);
			break;

		case FM_PROP_PERIODIC_IFRAMES:
			vcmStreamPeriodicIFrames (m_hStream, (BOOL)dwPropVal);
			break;


	default:
		ASSERT(0);
		hr = DPR_INVALID_PROP_ID;
		break;
	}

	return hr;
}

HRESULT VcmFilter::GetProperty(DWORD dwPropId, PDWORD pdwPropVal)
{
	HRESULT hr = DPR_SUCCESS;

	if (pdwPropVal)
	{
		switch (dwPropId)
		{
			case FM_PROP_POSTPROCESSING_SUPPORTED:
				*pdwPropVal = vcmStreamIsPostProcessingSupported(m_hStream);
				break;

			case FM_PROP_VIDEO_BRIGHTNESS:
				*pdwPropVal = m_dwBrightness;
				break;

			case FM_PROP_VIDEO_CONTRAST:
				*pdwPropVal = m_dwContrast;
				break;

			case FM_PROP_VIDEO_SATURATION:
				*pdwPropVal = m_dwSaturation;
				break;

			case FM_PROP_VIDEO_IMAGE_QUALITY:
				*pdwPropVal = m_dwImageQuality;
				break;

			case FM_PROP_PAYLOAD_HEADER_SIZE:
				vcmStreamGetPayloadHeaderSize (m_hStream, pdwPropVal);
				break;

		default:
			ASSERT(0);
			hr = DPR_INVALID_PROP_ID;
			break;
		}
	}
	else
	{
		hr = DPR_INVALID_PARAMETER;
	}

	return hr;
}


MMRESULT VcmFilter::RestorePayload(WSABUF *ppDataPkt, DWORD dwPktCount, PBYTE pbyFrame, PDWORD pdwFrameSize, BOOL *pfReceivedKeyframe)
{
	MMRESULT mmr;

	if (m_bOpen == FALSE)
		return MMSYSERR_INVALHANDLE;

	mmr = vcmStreamRestorePayload(m_hStream, ppDataPkt, dwPktCount, pbyFrame, pdwFrameSize, pfReceivedKeyframe);
	return mmr;
}


MMRESULT VcmFilter::FormatPayload(PBYTE pDataSrc, DWORD dwDataSize, PBYTE *ppDataPkt,
	                       PDWORD pdwPktSize, PDWORD pdwPktCount, UINT *pfMark,
						   PBYTE *pHdrInfo,	PDWORD pdwHdrSize)
{
	MMRESULT mmr;
	if (m_bOpen == FALSE)
		return MMSYSERR_INVALHANDLE;

	mmr = vcmStreamFormatPayload(m_hStream, pDataSrc, dwDataSize, ppDataPkt,
	                             pdwPktSize, pdwPktCount, pfMark,
	                             pHdrInfo, pdwHdrSize);
	return mmr;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\vcmstrm.cpp ===
#include "precomp.h"

// #define LOG_COMPRESSION_PARAMS 1
// #define LOGPAYLOAD_ON 1

#ifdef LOGPAYLOAD_ON
HANDLE			g_DebugFile = (HANDLE)NULL;
HANDLE			g_TDebugFile = (HANDLE)NULL;
#endif

// #define VALIDATE_SBIT_EBIT 1

#ifdef VALIDATE_SBIT_EBIT // { VALIDATE_SBIT_EBIT
DWORD g_dwPreviousEBIT = 0;
#endif // } VALIDATE_SBIT_EBIT

#define BUFFER_SIZE 50
#define NUM_FPS_ENTRIES 1
#define NUM_BITDEPTH_ENTRIES 9
#define NUM_RGB_BITDEPTH_ENTRIES 4
#define VIDEO_FORMAT_NUM_RESOLUTIONS 6
#define MAX_NUM_REGISTERED_SIZES 3
#define MAX_VERSION 80 // Needs to be in sync with the MAX_VERSION in dcap\inc\idcap.h

// String resources
#define IDS_FORMAT_1	TEXT("%4.4hs.%4.4hs, %02dbit, %02dfps, %03dx%03d")
#define IDS_FORMAT_2	TEXT("%4.4hs.%04d, %02dbit, %02dfps, %03dx%03d")

#define szRegDeviceKey			TEXT("SOFTWARE\\Microsoft\\Conferencing\\CaptureDevices")
#define szRegCaptureDefaultKey	TEXT("SOFTWARE\\Microsoft\\Conferencing\\CaptureDefaultFormats")
#define szRegConferencingKey	TEXT("SOFTWARE\\Microsoft\\Conferencing")
#define szTotalRegDeviceKey		TEXT("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Conferencing\\CaptureDevices")
#define szRegCaptureKey			TEXT("CaptureDevices")
#define szRegdwImageSizeKey		TEXT("dwImageSize")
#define szRegImageSizesKey		TEXT("aImageSizes")
#define szRegNumImageSizesKey	TEXT("nNumSizes")
#define szRegdwNumColorsKey		TEXT("dwNumColors")
#define szRegdwStreamingModeKey	TEXT("dwStreamingMode")
#define szRegdwDialogsKey		TEXT("dwDialogs")
#define szRegbmi4bitColorsKey	TEXT("bmi4bitColors")
#define szRegbmi8bitColorsKey	TEXT("bmi8bitColors")
#define szRegDefaultFormatKey	TEXT("DefaultFormat")

EXTERN_C HINSTANCE	g_hInst; // Our module handle. defined in nac.cpp

//External function (in msiacaps.cpp) to read reg info in one shot
extern ULONG ReadRegistryFormats (LPCSTR lpszKeyName,CHAR ***pppName,BYTE ***pppData,PUINT pnFormats,DWORD dwDebugSize);

PVCM_APP_ICINFO g_aVCMAppInfo;

int             g_nNumVCMAppInfoEntries;
int             g_nNumFrameSizesEntries;
BOOL            g_fNewCodecsInstalled;

#ifdef LOGFILE_ON


DWORD			g_CompressTime;
DWORD			g_DecompressTime;
HANDLE			g_CompressLogFile;
HANDLE			g_DecompressLogFile;
DWORD			g_dwCompressBytesWritten;
DWORD			g_dwDecompressBytesWritten;
char			g_szCompressBuffer[256];
char			g_szDecompressBuffer[256];
DWORD			g_OrigCompressTime;
DWORD			g_OrigDecompressTime;
DWORD			g_AvgCompressTime;
DWORD			g_AvgDecompressTime;
DWORD			g_aCompressTime[4096];
DWORD			g_aDecompressTime[4096];
SYSTEMTIME		g_SystemTime;
#endif

typedef struct tagDejaVu
{
	VIDEOFORMATEX	vfx;
	DWORD			dwFlags;
} DEJAVU, *PDEJAVU;

#if 1
// Array of known ITU sizes
MYFRAMESIZE g_ITUSizes[8] =
		{
		{    0,   0 },
		{  128,  96 },
		{  176, 144 },
		{  352, 288 },
#if !defined(_ALPHA_) && defined(USE_BILINEAR_MSH26X)
		{   80,  64 },
#else
		{  704, 576 },
#endif
		{ 1408,1152 },
		{    0,   0 },
		{    0,   0 }
		};

// For now, the size of the VIDEOFORMATEX being 1118 even if
// there is no palette, do not enumerate all of the possible
// formats. As soon as you have replaced the BITMAPINFOHEADER
// + Palette by pointers to such structure, enable all the
// sizes.
NCAP_APP_INFO g_awResolutions[VIDEO_FORMAT_NUM_RESOLUTIONS] =
		{
//		VIDEO_FORMAT_IMAGE_SIZE_40_30,
//		VIDEO_FORMAT_IMAGE_SIZE_64_48,
//		VIDEO_FORMAT_IMAGE_SIZE_80_60,
//		VIDEO_FORMAT_IMAGE_SIZE_96_64,
//		VIDEO_FORMAT_IMAGE_SIZE_112_80,
//		VIDEO_FORMAT_IMAGE_SIZE_120_90,
		{ VIDEO_FORMAT_IMAGE_SIZE_128_96, 128, 96 },
//		VIDEO_FORMAT_IMAGE_SIZE_144_112,
		{ VIDEO_FORMAT_IMAGE_SIZE_160_120, 160, 120 },
//		VIDEO_FORMAT_IMAGE_SIZE_160_128,
		{ VIDEO_FORMAT_IMAGE_SIZE_176_144, 176, 144 },
//		VIDEO_FORMAT_IMAGE_SIZE_192_160,
//		VIDEO_FORMAT_IMAGE_SIZE_200_150,
//		VIDEO_FORMAT_IMAGE_SIZE_208_176,
//		VIDEO_FORMAT_IMAGE_SIZE_224_192,
		{ VIDEO_FORMAT_IMAGE_SIZE_240_180, 240, 180 },
//		VIDEO_FORMAT_IMAGE_SIZE_240_208,
//		VIDEO_FORMAT_IMAGE_SIZE_256_224,
//		VIDEO_FORMAT_IMAGE_SIZE_272_240,
//		VIDEO_FORMAT_IMAGE_SIZE_280_210,
//		VIDEO_FORMAT_IMAGE_SIZE_288_256,
//		VIDEO_FORMAT_IMAGE_SIZE_304_272,
		{ VIDEO_FORMAT_IMAGE_SIZE_320_240, 320, 240 },
//		VIDEO_FORMAT_IMAGE_SIZE_320_288,
//		VIDEO_FORMAT_IMAGE_SIZE_336_288,
		{ VIDEO_FORMAT_IMAGE_SIZE_352_288, 352, 288 },
//		VIDEO_FORMAT_IMAGE_SIZE_640_480,
		};

#else

// For now, the size of the VIDEOFORMATEX being 1118 even if
// there is no palette, do not enumerate all of the possible
// formats. As soon as you have replaced the BITMAPINFOHEADER
// + Palette by pointers to such structure, enable all the
// sizes.
DWORD g_awResolutions[VIDEO_FORMAT_NUM_RESOLUTIONS] =
		{
//		VIDEO_FORMAT_IMAGE_SIZE_40_30,
//		VIDEO_FORMAT_IMAGE_SIZE_64_48,
//		VIDEO_FORMAT_IMAGE_SIZE_80_60,
//		VIDEO_FORMAT_IMAGE_SIZE_96_64,
//		VIDEO_FORMAT_IMAGE_SIZE_112_80,
//		VIDEO_FORMAT_IMAGE_SIZE_120_90,
		VIDEO_FORMAT_IMAGE_SIZE_160_120,
//		VIDEO_FORMAT_IMAGE_SIZE_144_112,
		VIDEO_FORMAT_IMAGE_SIZE_128_96,
//		VIDEO_FORMAT_IMAGE_SIZE_160_128,
		VIDEO_FORMAT_IMAGE_SIZE_240_180,
//		VIDEO_FORMAT_IMAGE_SIZE_192_160,
//		VIDEO_FORMAT_IMAGE_SIZE_200_150,
//		VIDEO_FORMAT_IMAGE_SIZE_208_176,
//		VIDEO_FORMAT_IMAGE_SIZE_224_192,
		VIDEO_FORMAT_IMAGE_SIZE_176_144,
//		VIDEO_FORMAT_IMAGE_SIZE_240_208,
//		VIDEO_FORMAT_IMAGE_SIZE_256_224,
//		VIDEO_FORMAT_IMAGE_SIZE_272_240,
//		VIDEO_FORMAT_IMAGE_SIZE_280_210,
//		VIDEO_FORMAT_IMAGE_SIZE_288_256,
//		VIDEO_FORMAT_IMAGE_SIZE_304_272,
		VIDEO_FORMAT_IMAGE_SIZE_320_240,
//		VIDEO_FORMAT_IMAGE_SIZE_320_288,
//		VIDEO_FORMAT_IMAGE_SIZE_336_288,
		VIDEO_FORMAT_IMAGE_SIZE_352_288,
//		VIDEO_FORMAT_IMAGE_SIZE_640_480,
		};
#endif

//int	g_aiFps[NUM_FPS_ENTRIES] = {3, 7, 15};
int	g_aiFps[NUM_FPS_ENTRIES] = {30};
// The order of the bit depths matches what I think is the
// preferred format if more than one is supported.
// For color, 16bit is almost as good as 24 but uses less memory
// and is faster for color QuickCam.
// For greyscale, 16 greyscale levels is Ok, not as good as 64,
// but Greyscale QuickCam is too slow at 64 levels.
int g_aiBitDepth[NUM_BITDEPTH_ENTRIES] = {9, 12, 12, 16, 16, 16, 24, 4, 8};
int g_aiNumColors[NUM_BITDEPTH_ENTRIES] = {VIDEO_FORMAT_NUM_COLORS_YVU9, VIDEO_FORMAT_NUM_COLORS_I420, VIDEO_FORMAT_NUM_COLORS_IYUV, VIDEO_FORMAT_NUM_COLORS_YUY2, VIDEO_FORMAT_NUM_COLORS_UYVY, VIDEO_FORMAT_NUM_COLORS_65536, VIDEO_FORMAT_NUM_COLORS_16777216, VIDEO_FORMAT_NUM_COLORS_16, VIDEO_FORMAT_NUM_COLORS_256};
int g_aiFourCCCode[NUM_BITDEPTH_ENTRIES] = {VIDEO_FORMAT_YVU9, VIDEO_FORMAT_I420, VIDEO_FORMAT_IYUV, VIDEO_FORMAT_YUY2, VIDEO_FORMAT_UYVY, VIDEO_FORMAT_BI_RGB, VIDEO_FORMAT_BI_RGB, VIDEO_FORMAT_BI_RGB, VIDEO_FORMAT_BI_RGB};
int	g_aiClrUsed[NUM_BITDEPTH_ENTRIES] = {0, 0, 0, 0, 0, 0, 0, 16, 256};

PVCMSTREAMHEADER DeQueVCMHeader(PVCMSTREAM pvs);
MMRESULT VCMAPI vcmDefaultFormatWriteToReg(LPSTR szDeviceName, LPSTR szDeviceVersion, LPBITMAPINFOHEADER lpbmih);

#define IsVCMHeaderPrepared(pvh)    ((pvh)->fdwStatus &  VCMSTREAMHEADER_STATUSF_PREPARED)
#define MarkVCMHeaderPrepared(pvh)     ((pvh)->fdwStatus |= VCMSTREAMHEADER_STATUSF_PREPARED)
#define MarkVCMHeaderUnprepared(pvh)   ((pvh)->fdwStatus &=~VCMSTREAMHEADER_STATUSF_PREPARED)
#define IsVCMHeaderInQueue(pvh)        ((pvh)->fdwStatus &  VCMSTREAMHEADER_STATUSF_INQUEUE)
#define MarkVCMHeaderInQueue(pvh)      ((pvh)->fdwStatus |= VCMSTREAMHEADER_STATUSF_INQUEUE)
#define MarkVCMHeaderUnQueued(pvh)     ((pvh)->fdwStatus &=~VCMSTREAMHEADER_STATUSF_INQUEUE)
#define IsVCMHeaderDone(pvh)        ((pvh)->fdwStatus &  VCMSTREAMHEADER_STATUSF_DONE)
#define MarkVCMHeaderDone(pvh)         ((pvh)->fdwStatus |= VCMSTREAMHEADER_STATUSF_DONE)
#define MarkVCMHeaderNotDone(pvh)      ((pvh)->fdwStatus &=~VCMSTREAMHEADER_STATUSF_DONE)


/****************************************************************************
 *  @doc  EXTERNAL COMPFUNC
 *
 *  @func MMRESULT | vcmMetrics | This function returns various metrics for the Video
 *      Compression Manager (VCM) or related VCM objects.
 *
 *  @parm HVCMOBJ | hvo | Specifies the VCM object to query for the metric
 *      specified in <p uMetric>. This argument may be NULL for some
 *      queries.
 *
 *  @parm UINT | uMetric | Specifies the metric index to be returned in
 *      <p pMetric>.
 *
 *      @flag VCM_METRIC_COUNT_COMPRESSORS | Specifies that the returned value is
 *      the number of global VCM compressors in
 *      the system. The <p hvo> argument must be NULL for this metric index.
 *      The <p pMetric> argument must point to a buffer of a size equal to a
 *      DWORD.
 *
 *      @flag VCM_METRIC_COUNT_DECOMPRESSORS | Specifies that the returned value is
 *      the number of global VCM decompressors in
 *      the system. The <p hvo> argument must be NULL for this metric index.
 *      The <p pMetric> argument must point to a buffer of a size equal to a
 *      DWORD.
 *
 *      @flag VCM_METRIC_MAX_SIZE_FORMAT | Specifies that the returned value
 *      is the size of the largest <t VIDEOFORMATEX> structure. If <p hvo>
 *      is NULL, then the return value is the largest <t VIDEOFORMATEX>
 *      structure in the system. If <p hvo> identifies an open instance
 *      of an VCM driver (<t HVCMDRIVER>) or a VCM driver identifier
 *      (<t HVCMDRIVERID>), then the largest <t VIDEOFORMATEX>
 *      structure for that driver is returned. The <p pMetric> argument must
 *      point to a buffer of a size equal to a DWORD. This metric is not allowed
 *      for a VCM stream handle (<t HVCMSTREAM>).
 *
 *  @parm LPVOID | pMetric | Specifies a pointer to the buffer that will
 *      receive the metric details. The exact definition depends on the
 *      <p uMetric> index.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *      @flag MMSYSERR_INVALPARAM | The <p pMetric> parameter is invalid.
 *      @flag MMSYSERR_NOTSUPPORTED | The <p uMetric> index is not supported.
 *      @flag VCMERR_NOTPOSSIBLE | The <p uMetric> index cannot be returned
 *      for the specified <p hvo>.
 *
 ***************************************************************************/
MMRESULT VCMAPI vcmMetrics(HVCMOBJ hao, UINT uMetric, LPVOID pMetric)
{
	MMRESULT	mmr;
	ICINFO		ICinfo;

	if (!pMetric)
	{
		ERRORMESSAGE(("vcmMetrics: Specified pointer is invalid, pMetric=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	 switch (uMetric)
	 {
		case VCM_METRIC_MAX_SIZE_FORMAT:
			// For now, assume all VIDEOFORMATEX structures have identical sizes
			*(LPDWORD)pMetric = (DWORD)sizeof(VIDEOFORMATEX);
			mmr = (MMRESULT)MMSYSERR_NOERROR;
			break;
		case VCM_METRIC_MAX_SIZE_BITMAPINFOHEADER:
			// For now, assume all BITMAPINFOHEADER structures have identical sizes
			*(LPDWORD)pMetric = (DWORD)sizeof(BITMAPINFOHEADER);
			mmr = (MMRESULT)MMSYSERR_NOERROR;
			break;
		case VCM_METRIC_COUNT_DRIVERS:
		case VCM_METRIC_COUNT_COMPRESSORS:
			for (*(LPDWORD)pMetric = 0; ICInfo(ICTYPE_VIDEO, *(LPDWORD)pMetric, &ICinfo); (*(LPDWORD)pMetric)++)
				;
			mmr = (MMRESULT)MMSYSERR_NOERROR;
			break;
		default:
			ERRORMESSAGE(("vcmMetrics: Specified index is invalid, uMetric=%ld\r\n", uMetric));
			mmr = (MMRESULT)MMSYSERR_NOTSUPPORTED;
			break;
	}

	return (mmr);
}

/****************************************************************************
 *  @doc EXTERNAL COMPFUNC
 *
 *  @func MMRESULT | vcmDriverDetails | This function queries a specified
 *      Video Compression Manager (VCM) driver to determine its driver details.
 *
 *  @parm PVCMDRIVERDETAILS | pvdd | Pointer to a <t VCMDRIVERDETAILS>
 *      structure that will receive the driver details. The
 *      <e VCMDRIVERDETAILS.cbStruct> member must be initialized to the
 *      size, in bytes, of the structure. The <e VCMDRIVERDETAILS.fccType> member
 *      must be initialized to the four-character code indicating the type of
 *      stream being compressed or decompressed. Specify VCMDRIVERDETAILS_FCCTYPE_VIDEOCODEC
 *      for video streams. The <e VCMDRIVERDETAILS.fccHandler> member must be initialized
 *      to the four-character code identifying the compressor.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *      @flag MMSYSERR_NODRIVER | No matching codec is present.
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed is invalid.
 *
 *  @xref <f vcmDriverEnum>
 ***************************************************************************/
MMRESULT VCMAPI vcmDriverDetails(PVCMDRIVERDETAILS pvdd)
{
	DWORD	fccHandler;
	ICINFO	ICinfo;
	HIC		hIC;

	// Check input params
	if (!pvdd)
	{
		ERRORMESSAGE(("vcmDriverDetails: Specified pointer is invalid, pvdd=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Make fccHandler uppercase and back it up
	fccHandler = pvdd->fccHandler;
	if (fccHandler > 256)
		CharUpperBuff((LPTSTR)&fccHandler, sizeof(DWORD));

	// Try to open the codec
	if (hIC = ICOpen(ICTYPE_VIDEO, fccHandler, ICMODE_QUERY))
	{
		// Get the details
		ICGetInfo(hIC, &ICinfo, sizeof(ICINFO));

		// Restore fccHandler
		ICinfo.fccHandler = fccHandler;

		// VCMDRIVERDETAILS and ICINFO are identical structures
		CopyMemory(pvdd, &ICinfo, sizeof(VCMDRIVERDETAILS));

		// Close the codec
		ICClose(hIC);
	}
	else
		return ((MMRESULT)MMSYSERR_NODRIVER);

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 *  @doc  EXTERNAL COMPFUNC
 *
 *  @func MMRESULT | vcmFormatDetails | This function queries the Video Compression
 *      Manager (VCM) for details on format for a specific video format.
 *
 *  @parm PVCMFORMATDETAILS | pvfd | Specifies a pointer to the
 *      <t VCMFORMATDETAILS> structure that is to receive the format
 *      details for the given embedded pointer to a <t VIDEOFORMATEX> structure.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *      @flag MMSYSERR_NODRIVER | No matching codec is present.
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed is invalid.
 *
 *  @xref <f vcmDriverDetails>
 ***************************************************************************/
MMRESULT VCMAPI vcmFormatDetails(PVCMFORMATDETAILS pvfd)
{
	MMRESULT	mmr = (MMRESULT)MMSYSERR_NOERROR;
	DWORD		fccHandler;
	DWORD		fccType;
	HIC			hIC;
	char		szBuffer[BUFFER_SIZE]; // Could be smaller.
	int			iLen;

	// Check input params
	if (!pvfd)
	{
		ERRORMESSAGE(("vcmDriverDetails: Specified pointer is invalid, pvdd=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!pvfd->pvfx)
	{
		ERRORMESSAGE(("vcmDriverDetails: Specified pointer is invalid, pvdd->pvfx=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Make fccHandler uppercase and back it up
	fccHandler = pvfd->pvfx->dwFormatTag;
	fccType = ICTYPE_VIDEO;
	if (fccHandler > 256)
		CharUpperBuff((LPTSTR)&fccHandler, sizeof(DWORD));

	// Try to open the codec
	if (hIC = ICOpen(fccType, pvfd->pvfx->dwFormatTag, ICMODE_QUERY))
	{
		// Check if the codec supports the format
		if (ICDecompressQuery(hIC, &pvfd->pvfx->bih, (LPBITMAPINFOHEADER)NULL) == ICERR_OK)
		{
#if 0
			if (ICCompressQuery(hIC, (LPBITMAPINFOHEADER)NULL, &pvfd->pvfx->bih) == ICERR_OK)
			{
#endif
				// Now complete the format details info, overwrite some of the fields of
				// the VIDEOFORMATEX structure too, just in case we were passed bogus values...
				pvfd->pvfx->nSamplesPerSec = g_aiFps[0];

				if (pvfd->pvfx->dwFormatTag > 256)
					wsprintf(szBuffer, IDS_FORMAT_1, (LPSTR)&fccType, (LPSTR)&fccHandler,
							pvfd->pvfx->bih.biBitCount, pvfd->pvfx->nSamplesPerSec,
							pvfd->pvfx->bih.biWidth, pvfd->pvfx->bih.biHeight);
				else
					wsprintf(szBuffer, IDS_FORMAT_2, (LPSTR)&fccType, fccHandler,
							pvfd->pvfx->bih.biBitCount, pvfd->pvfx->nSamplesPerSec,
							pvfd->pvfx->bih.biWidth, pvfd->pvfx->bih.biHeight);
				iLen = MultiByteToWideChar(GetACP(), 0, szBuffer, -1, pvfd->szFormat, 0);
				MultiByteToWideChar(GetACP(), 0, szBuffer, -1, pvfd->szFormat, iLen);
#if 0
			}
			else
				mmr = (MMRESULT)MMSYSERR_NODRIVER;
#endif
		}
		else
			mmr = (MMRESULT)MMSYSERR_NODRIVER;

		// Close the codec
		ICClose(hIC);
	}
	else
		mmr = (MMRESULT)MMSYSERR_NODRIVER;

	return (mmr);
}


/*****************************************************************************
 * @doc EXTERNAL DEVCAPSFUNC
 *
 * @func MMRESULT | vcmGetDevCaps | This function queries a specified
 *   video capture input device to determine its capabilities.
 *
 * @parm UINT | uDevice | Specifies the video capture input device ID.
 *
 * @parm PVIDEOINCAPS | pvc | Specifies a pointer to a <t VIDEOINCAPS>
 *   structure. This structure is filled with information about the
 *   capabilities of the device.
 *
 * @parm UINT | cbvc | Specifies the size of the <t VIDEOINCAPS> structure.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_BADDEVICEID | Specified device device ID is invalid.
 *   @flag MMSYSERR_INVALPARAM | Specified pointer to structure is invalid.
 *   @flag MMSYSERR_NODRIVER | No capture device driver or device is present.
 *   @flag VCMERR_NONSPECIFIC | The capture driver failed to provide description information.
 *
 * @comm Only <p cbwc> bytes (or less) of information is copied to the location
 *   pointed to by <p pvc>. If <p cbwc> is zero, nothing is copied, and
 *   the function returns zero.
 *
 *   If the ID of the capture device passed is VIDEO_MAPPER, the first device in the list
 *   of installed capture devices is considered.
 *
 * @devnote You never return MMSYSERR_NODRIVER. Is there a way to make a difference
 *   between a call failing because there is no device, or because of a device failure?
 *
 * @xref <f videoDevCapsProfile> <f videoDevCapsReadFromReg> <f videoDevCapsWriteToReg>
 ****************************************************************************/
MMRESULT VCMAPI vcmGetDevCaps(UINT uDevice, PVIDEOINCAPS pvc, UINT cbvc)
{
	MMRESULT	mmr;
	FINDCAPTUREDEVICE fcd;

	// Check input params
	if ((uDevice >= MAXVIDEODRIVERS) && (uDevice != VIDEO_MAPPER))
	{
		ERRORMESSAGE(("vcmGetDevCaps: Specified capture device ID is invalid, uDevice=%ld (expected values are 0x%lX or between 0 and %ld)\r\n", uDevice, VIDEO_MAPPER, MAXVIDEODRIVERS-1));
		return ((MMRESULT)MMSYSERR_BADDEVICEID);
	}
	if (!pvc)
	{
		ERRORMESSAGE(("vcmGetDevCaps: Specified pointer is invalid, pvc=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!cbvc)
	{
		ERRORMESSAGE(("vcmGetDevCaps: Specified structure size is invalid, cbvc=%ld\r\n", cbvc));
		return ((MMRESULT)MMSYSERR_NOERROR);
	}

	// Get the driver name and version number
    fcd.dwSize = sizeof (FINDCAPTUREDEVICE);
	if (uDevice == VIDEO_MAPPER)
	{
		if (!FindFirstCaptureDevice(&fcd, NULL))
		{
			ERRORMESSAGE(("vcmGetDevCaps: FindFirstCaptureDevice() failed\r\n"));
			return ((MMRESULT)VCMERR_NONSPECIFIC);
		}
	}
	else
	{
		if (!FindFirstCaptureDeviceByIndex(&fcd, uDevice))
		{
			ERRORMESSAGE(("vcmGetDevCaps: FindFirstCaptureDevice() failed\r\n"));
			return ((MMRESULT)VCMERR_NONSPECIFIC);
		}
	}

	// Set default values
	pvc->dwImageSize = pvc->dwNumColors = (DWORD)NULL;
	pvc->dwStreamingMode = STREAMING_PREFER_FRAME_GRAB;
	pvc->dwDialogs = FORMAT_DLG_OFF | SOURCE_DLG_ON;

    //Look for a specific version of the driver first....
    lstrcpy(pvc->szDeviceName, fcd.szDeviceDescription);
    lstrcpy(pvc->szDeviceVersion, fcd.szDeviceVersion);

	// Based on the name and version number of the driver, set capabilities.
	// We first try to look them up from the registry. If this is a very popular
	// board/camera, chances are that we have set the key at install time already.
	// If we can't find the key, we profile the hardware and save the results
	// to the registry.
	if (vcmDevCapsReadFromReg(pvc->szDeviceName, pvc->szDeviceVersion,pvc, cbvc) != MMSYSERR_NOERROR)
	{

        //Didn't find the specific version, try it again, with NULL version info
        pvc->szDeviceVersion[0]= (char) NULL;
        if (vcmDevCapsReadFromReg(pvc->szDeviceName, NULL,pvc, cbvc) != MMSYSERR_NOERROR)
        {
    		DEBUGMSG (ZONE_VCM, ("vcmGetDevCaps: Unknown capture hardware found. Profiling...\r\n"));
            lstrcpy(pvc->szDeviceVersion, fcd.szDeviceVersion);

    		if ((mmr = vcmDevCapsProfile(uDevice, pvc, cbvc)) == MMSYSERR_NOERROR)
            {
                // record this default in the registry
                if (pvc->szDeviceName[0] != '\0')
                {
                    vcmDevCapsWriteToReg(pvc->szDeviceName, pvc->szDeviceVersion, pvc, cbvc);
                }
                else
                {
                    //fcd.szDeviceName is the Driver Name
                    vcmDevCapsWriteToReg(fcd.szDeviceName, pvc->szDeviceVersion, pvc, cbvc);
                }

            }
    		else
    		{
    			ERRORMESSAGE(("vcmGetDevCaps: vcmDevCapsProfile() failed\r\n"));
    			return (mmr);
    		}
        }
	}

	return ((MMRESULT)MMSYSERR_NOERROR);
}

/****************************************************************************
 *  @doc  INTERNAL COMPFUNC
 *
 *  @func MMRESULT | AppICInfo | The <f AppICInfo> function
 *      will either call the standard ICInfo function
 *      function continues enumerating until there are no more suitable
 *      formats for the format tag or the callback function returns FALSE.
 *
 ***************************************************************************/

/*
 *	NOTE:
 *
 *	ICInfo returns TRUE on success and FALSE on failure. The documentation suggests
 *	otherwise and is wrong. AppICInfo returns the same.
 */

BOOL VFWAPI AppICInfo(DWORD fccType, DWORD fccHandler, ICINFO FAR * lpicinfo, DWORD fdwEnum)
{
	if ((fdwEnum & VCM_FORMATENUMF_ALLMASK) == VCM_FORMATENUMF_ALL)
	{
		// enumerating all formats, just do the standard ICInfo
		return ICInfo(fccType, fccHandler, lpicinfo);
	}
	else
	{
		// only enumerating specific formats

		// are we done ?
		if (fccHandler >= (DWORD)g_nNumVCMAppInfoEntries)
		{
			// we're done enumerating app-specific formats
			return FALSE;
		}

		lpicinfo->fccType = g_aVCMAppInfo[fccHandler].fccType;
		lpicinfo->fccHandler = g_aVCMAppInfo[fccHandler].fccHandler;
		return TRUE;
	}
}

BOOL vcmBuildDefaultEntries (void)
{

    //Yikes! Reg. problem (or first boot) instantiate only the minimum...
#if !defined(_ALPHA_) && defined(USE_BILINEAR_MSH26X)
    g_nNumVCMAppInfoEntries=3;
#else
    g_nNumVCMAppInfoEntries=2;
#endif
    g_nNumFrameSizesEntries=MAX_NUM_REGISTERED_SIZES;
    g_fNewCodecsInstalled=FALSE;

    //Allocate space for the VCM_APP_ICINFO structure (zero init'd)
    if (!(g_aVCMAppInfo = (VCM_APP_ICINFO *)MemAlloc (g_nNumVCMAppInfoEntries*sizeof (VCM_APP_ICINFO)))) {
        //Aiiie!
        ERRORMESSAGE (("vcmBDE: Memory Allocation Failed!\r\n"));
        return FALSE;
    }

    //H.263
    g_aVCMAppInfo[0].fccType=ICTYPE_VIDEO;
#ifndef _ALPHA_
    g_aVCMAppInfo[0].fccHandler=VIDEO_FORMAT_MSH263;
#else
    g_aVCMAppInfo[0].fccHandler=VIDEO_FORMAT_DECH263;
#endif
    g_aVCMAppInfo[0].framesize[0].biWidth=128;
    g_aVCMAppInfo[0].framesize[0].biHeight=96;
    g_aVCMAppInfo[0].framesize[1].biWidth=176;
    g_aVCMAppInfo[0].framesize[1].biHeight=144;
    g_aVCMAppInfo[0].framesize[2].biWidth=352;
    g_aVCMAppInfo[0].framesize[2].biHeight=288;


    //H.261
    g_aVCMAppInfo[1].fccType=ICTYPE_VIDEO;
#ifndef _ALPHA_
    g_aVCMAppInfo[1].fccHandler=VIDEO_FORMAT_MSH261;
#else
    g_aVCMAppInfo[1].fccHandler=VIDEO_FORMAT_DECH261;
#endif
    g_aVCMAppInfo[1].framesize[0].biWidth=0;
    g_aVCMAppInfo[1].framesize[0].biHeight=0;
    g_aVCMAppInfo[1].framesize[1].biWidth=176;
    g_aVCMAppInfo[1].framesize[1].biHeight=144;
    g_aVCMAppInfo[1].framesize[2].biWidth=352;
    g_aVCMAppInfo[1].framesize[2].biHeight=288;

#if !defined(_ALPHA_) && defined(USE_BILINEAR_MSH26X)
    //H.26X
    g_aVCMAppInfo[2].fccType=ICTYPE_VIDEO;
    g_aVCMAppInfo[2].fccHandler=VIDEO_FORMAT_MSH26X;
    g_aVCMAppInfo[2].framesize[0].biWidth=80;
    g_aVCMAppInfo[2].framesize[0].biHeight=64;
    g_aVCMAppInfo[2].framesize[1].biWidth=128;
    g_aVCMAppInfo[2].framesize[1].biHeight=96;
    g_aVCMAppInfo[2].framesize[2].biWidth=176;
    g_aVCMAppInfo[2].framesize[2].biHeight=144;
#endif

    return TRUE;
}


BOOL vcmFillGlobalsFromRegistry (void)
{

    int i,j,k,iFormats,iOffset;
    DWORD *pTmp;
    BOOL bKnown;
    MYFRAMESIZE *pTmpFrame;
	char            **pVCMNames;
    VIDCAP_DETAILS  **pVCMData;
    UINT            nFormats;


    //Read the registry for all the keys that we care about
    //We're loading the values of HKLM\Software\Microsoft\Internet Audio\VCMEncodings

    if (ReadRegistryFormats(szRegInternetPhone TEXT("\\") szRegInternetPhoneVCMEncodings,
			&pVCMNames,(BYTE ***)&pVCMData,&nFormats,sizeof (VIDCAP_DETAILS)) != ERROR_SUCCESS) {
        ERRORMESSAGE (("vcmFillGlobalsFromRegistry, couldn't build formats from registry\r\n"));
        return (vcmBuildDefaultEntries());
    }

    //Minimum number of frame and format sizes;
    g_nNumFrameSizesEntries=MAX_NUM_REGISTERED_SIZES;
    g_nNumVCMAppInfoEntries=0;
    g_fNewCodecsInstalled=FALSE;


    //Allocate a temp buffer of size of nFormats, use this to track various things
    if (!(pTmp = (DWORD *)MemAlloc (nFormats * sizeof (DWORD)))) {

        ERRORMESSAGE (("vcmFillGlobalsFromRegistry: Memory Allocation Failed!\r\n"));
        return FALSE;
    }


    //Find the number of formats,
    for (i=0;i< (int )nFormats;i++) {
        bKnown=FALSE;
        for (j=0;j<g_nNumVCMAppInfoEntries;j++) {
            if (pVCMData[i]->dwFormatTag == pTmp[j]) {
                bKnown=TRUE;
                break;
            }
        }
        if (!bKnown) {
            //something new
            pTmp[g_nNumVCMAppInfoEntries++]=pVCMData[i]->dwFormatTag;
            g_fNewCodecsInstalled=TRUE;
        }
    }

    //Allocate space for the VCM_APP_ICINFO structure (zero init'd)

	if (g_aVCMAppInfo != NULL)
	{
		MemFree(g_aVCMAppInfo);
	}

    if (!(g_aVCMAppInfo = (VCM_APP_ICINFO *)MemAlloc (g_nNumVCMAppInfoEntries*sizeof (VCM_APP_ICINFO))))
	{
        //Aiiie!
        MemFree (pTmp);
        ERRORMESSAGE (("vcmFillGlobalsFromRegistry: Memory Allocation Failed!\r\n"));
        return FALSE;
    }

    //Fill out the basic information.
    //All elements have a certain commonality
    for (j=0;j<g_nNumVCMAppInfoEntries;j++) {

        g_aVCMAppInfo[j].fccType=ICTYPE_VIDEO;
        g_aVCMAppInfo[j].fccHandler=pTmp[j];

        //Known local formats
        iFormats=0;

        for (i=0;i<(int )nFormats;i++) {
            if (pTmp[j] == pVCMData[i]->dwFormatTag) {
                //Ok, add the registry size, if we don't have it listed
                bKnown=FALSE;
                for (k=0;k<iFormats;k++) {
                    if (g_aVCMAppInfo[j].framesize[k].biWidth == pVCMData[i]->video_params.biWidth &&
                        g_aVCMAppInfo[j].framesize[k].biHeight == pVCMData[i]->video_params.biHeight ) {

                        bKnown=TRUE;
                        break;
                    }
                }
                if (!bKnown) {
                    iOffset=pVCMData[i]->video_params.enumVideoSize;
                    g_aVCMAppInfo[j].framesize[iOffset].biWidth = (WORD)pVCMData[i]->video_params.biWidth;
                    g_aVCMAppInfo[j].framesize[iOffset].biHeight = (WORD)pVCMData[i]->video_params.biHeight;
                    iFormats++;
                }
            }
        }

    }

    //Now, build the DCAP_APP_INFO ptr

    //Max * is #entries * MAX_NUM_REGISTERED_SIZES
    if (!(pTmpFrame = (MYFRAMESIZE *)MemAlloc ((g_nNumVCMAppInfoEntries*MAX_NUM_REGISTERED_SIZES)*sizeof (DWORD)))) {
        //Aiiie!
        MemFree (pTmp);
        ERRORMESSAGE (("vcmFillGlobalsFromRegistry: Memory Allocation Failed!\r\n"));
        return FALSE;
    }

    iFormats=0;

    for (j=0;j<g_nNumVCMAppInfoEntries;j++) {

        //Magic # of frame sizes per format
        for (k=0;k < MAX_NUM_REGISTERED_SIZES;k++) {
            bKnown=FALSE;
            for (i=0;i<iFormats;i++) {
                if ( (g_aVCMAppInfo[j].framesize[k].biWidth == pTmpFrame[i].biWidth &&
                    g_aVCMAppInfo[j].framesize[k].biHeight == pTmpFrame[i].biHeight)
					|| (!g_aVCMAppInfo[j].framesize[k].biWidth && !g_aVCMAppInfo[j].framesize[k].biHeight) ){
                    bKnown=TRUE;
                    break;
                }
            }
            if (!bKnown) {
                    pTmpFrame[iFormats].biWidth  = g_aVCMAppInfo[j].framesize[k].biWidth;
                    pTmpFrame[iFormats++].biHeight = g_aVCMAppInfo[j].framesize[k].biHeight;
            }
        }
    }

    g_nNumFrameSizesEntries=iFormats;

    //Free up the ReadRegistryEntries memory...
    for (i=0;i<(int) nFormats; i++) {
        MemFree (pVCMNames[i]);
        MemFree (pVCMData[i]);
    }

    MemFree (pVCMNames);
    MemFree (pVCMData);

    MemFree (pTmp);
    MemFree (pTmpFrame);

    return TRUE;
}


/****************************************************************************
 *  @doc  EXTERNAL COMPFUNC
 *
 *  @func MMRESULT | vcmFormatEnum | The <f vcmFormatEnum> function
 *      enumerates video formats available. The <f vcmFormatEnum>
 *      function continues enumerating until there are no more suitable
 *      formats for the format tag or the callback function returns FALSE.
 *
 *  @parm UINT | uDevice | Specifies the capture device ID.
 *
 *  @parm VCMFORMATENUMCB | fnCallback | Specifies the procedure-instance
 *      address of the application-defined callback function.
 *
 *  @parm PVCMDRIVERDETAILS | pvdd | Specifies a pointer to the
 *      <t VCMDRIVERDETAILS> structure that is to receive the driver details
 *      passed to the <p fnCallback> function.
 *
 *  @parm PVCMFORMATDETAILS | pvfd | Specifies a pointer to the
 *      <t VCMFORMATDETAILS> structure that is to receive the format details
 *      passed to the <p fnCallback> function. This structure must have the
 *      <e VCMFORMATDETAILS.cbStruct>, <e VCMFORMATDETAILS.pvfx>, and
 *      <e VCMFORMATDETAILS.cbvfx> members of the <t VCMFORMATDETAILS>
 *      structure initialized. The <e VCMFORMATDETAILS.dwFormatTag> member
 *      must also be initialized to either VIDEO_FORMAT_UNKNOWN or a
 *      valid format tag.
 *
 *  @parm DWORD | dwInstance | Specifies a 32-bit, application-defined value
 *      that is passed to the callback function along with VCM format details.
 *
 *  @parm DWORD | fdwEnum | Specifies flags for enumerating formats that can be
 *      generated, or formats that can be decompressed.
 *
 *      @flag VCM_FORMATENUMF_INPUT | Specifies that the format enumeration should only
 *      return the video formats that can be transmitted.
 *
 *      @flag VCM_FORMATENUMF_OUTPUT | Specifies that the format enumeration should only
 *      return the video formats that can be received.
 *
 *      @flag VCM_FORMATENUMF_BOTH | Specifies that the format enumeration should
 *      return the video formats that can be received and transmitted.
 *
 *      @flag VCM_FORMATENUMF_APP | Specifies that the format enumeration should
 *      enumerate only video formats known to the application
 *
 *      @flag VCM_FORMATENUMF_ALL | Specifies that the format enumeration should
 *      enumerate all video formats known to VCM
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *      @flag MMSYSERR_NOMEM | A memory allocation failed.
 *      @flag MMSYSERR_BADDEVICEID | Specified device device ID is invalid.
 *      @flag VCMERR_NOTPOSSIBLE | The details for the format cannot be
 *      returned.
 *
 *  @comm The <f vcmFormatEnum> function will return MMSYSERR_NOERROR
 *      (zero) if no suitable VCM drivers are installed. Moreover, the
 *      callback function will not be called.
 *
 *  @xref <f vcmFormatEnumCallback>
 ***************************************************************************/
MMRESULT VCMAPI vcmFormatEnum(	UINT uDevice, VCMFORMATENUMCB fnCallback, PVCMDRIVERDETAILS pvdd,
								PVCMFORMATDETAILS pvfd, DWORD_PTR dwInstance, DWORD fdwEnum)
{
	int				i, j, k, l, m;
	HIC				hIC;
	ICINFO			ICinfo;
	BITMAPINFO		bmi;
	DWORD			dw;
	char			szBuffer[BUFFER_SIZE]; // Could be smaller.
	int				iLen;
	VIDEOINCAPS		vic;
	PDEJAVU			pdvDejaVuCurr, pdvDejaVu;
	BOOL			bDejaVu, fUnsupportedInputSize, fUnsupportedBitDepth;
	DWORD			fccHandler;
	int				iNumCaps = 0; // Num of valid caps into the advDejaVu matrix


	// Check input params
	if (!pvdd)
	{
		ERRORMESSAGE(("vcmFormatEnum: Specified pointer is invalid, pvdd=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!pvfd)
	{
		ERRORMESSAGE(("vcmFormatEnum: Specified pointer is invalid, pvfd=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!(VCM_FORMATENUMF_TYPEMASK & fdwEnum))
	{
		ERRORMESSAGE(("vcmFormatEnum: Specified mask is invalid, fdwEnum=0x%lX\r\n", fdwEnum));
		return ((MMRESULT)MMSYSERR_INVALFLAG);
	}
	if ((uDevice >= MAXVIDEODRIVERS) && (uDevice != VIDEO_MAPPER))
	{
		ERRORMESSAGE(("vcmFormatEnum: Specified capture device ID is invalid, uDevice=%ld (expected values are 0x%lX or between 0 and %ld)\r\n", uDevice, VIDEO_MAPPER, MAXVIDEODRIVERS-1));
		return ((MMRESULT)MMSYSERR_BADDEVICEID);
	}

    //Build the system VCM globals
    if (!vcmFillGlobalsFromRegistry ())
	{
        ERRORMESSAGE (("vcmFormatEnum, couldn't build formats from registry\r\n"));
        return (VCMERR_NOTPOSSIBLE);
    }

	// We need to remember what we have already enumerated
	// The formats already enumerated are stored in the following matrix
	if (!(pdvDejaVu = (PDEJAVU)MemAlloc(g_nNumFrameSizesEntries *
	                                        NUM_BITDEPTH_ENTRIES *
	                                        NUM_FPS_ENTRIES * sizeof(DEJAVU))))
	{
		ERRORMESSAGE(("vcmFormatEnum: A memory allocation failed\r\n"));
		return ((MMRESULT)MMSYSERR_NOMEM);
	}

	// If we enumerate formats we can generate, they need to be in sync with what
	// the capture hardware can actually produce, that is RGB4, RGB8, RGB16, RGB24, YUY2, UYVY, YVU9, I420 or IYUV.
	if ((fdwEnum & VCM_FORMATENUMF_INPUT) || (fdwEnum & VCM_FORMATENUMF_BOTH))
	{
		if (vcmGetDevCaps(uDevice, &vic, sizeof(VIDEOINCAPS)) != MMSYSERR_NOERROR)
		{
			if (fdwEnum & VCM_FORMATENUMF_INPUT)
				return ((MMRESULT)MMSYSERR_NOERROR);
			else
				fdwEnum = VCM_FORMATENUMF_OUTPUT;
		}
	}

	// We're asked to enumerate all the formats that this machine can render or transmit.
	// We can send or render all the RGB formats, in which case they will not be
	// compressed/decompressed, but directly transmitted/rendered by the UI. But still, someone needs
	// to enumerate these. This is done here.
	// We, of course, also enumerate the formats that we can decompress and the ones we can generate.
	bmi.bmiHeader.biSize			= sizeof(BITMAPINFOHEADER);
	bmi.bmiHeader.biPlanes			= 1;
	bmi.bmiHeader.biCompression		= BI_RGB;
	bmi.bmiHeader.biXPelsPerMeter	= 0;
	bmi.bmiHeader.biYPelsPerMeter	= 0;
	bmi.bmiHeader.biClrUsed			= 0;
	bmi.bmiHeader.biClrImportant	= 0;


	// Now enumerate real compressors
	// for (i=0; ICInfo(ICTYPE_VIDEO, i, &ICinfo); i++) == NO GOOD:
	// We need to enumerate everything and then filter on
	// the value of fccHandler, because some codecs will fail to
	// enum entirely if the fccType parameter to ICInfo is non null.
	// SOMEONE should be shot...
	for (i=0; AppICInfo(0, i, &ICinfo, fdwEnum); i++, iNumCaps = 0)
	{
		// Get the details of the ICINFO structure
		if ((ICinfo.fccType == ICTYPE_VIDEO)  && (ICInfo(ICinfo.fccType, ICinfo.fccHandler, &ICinfo)))
		{
			// Make fccHandler uppercase and back it up
			if (ICinfo.fccHandler > 256)
				CharUpperBuff((LPTSTR)&ICinfo.fccHandler, sizeof(DWORD));
			fccHandler = ICinfo.fccHandler;

			// If the client returns FALSE we need to terminate the enumeration process
			if (hIC = ICOpen(ICinfo.fccType, ICinfo.fccHandler, ICMODE_QUERY))
			{
				// Enable H.26x codecs
#ifndef _ALPHA_
#ifdef USE_BILINEAR_MSH26X
				if ((ICinfo.fccHandler == VIDEO_FORMAT_MSH263) || (ICinfo.fccHandler == VIDEO_FORMAT_MSH261) || (ICinfo.fccHandler == VIDEO_FORMAT_MSH26X))
#else
				if ((ICinfo.fccHandler == VIDEO_FORMAT_MSH263) || (ICinfo.fccHandler == VIDEO_FORMAT_MSH261))
#endif
#else
				if ((ICinfo.fccHandler == VIDEO_FORMAT_DECH263) || (ICinfo.fccHandler == VIDEO_FORMAT_DECH261))
#endif
					ICSendMessage(hIC, CUSTOM_ENABLE_CODEC, G723MAGICWORD1, G723MAGICWORD2);

				ICGetInfo(hIC, &ICinfo, sizeof(ICINFO));
				// The VDEC codec sets the fccType to the same
				// value than the fccHandler! Correct that hereticism:
				if ((ICinfo.fccType == VIDEO_FORMAT_VDEC) && (ICinfo.fccHandler == VIDEO_FORMAT_VDEC))
					ICinfo.fccType = ICTYPE_VIDEO;

				// Restore fccHandler
				ICinfo.fccHandler = fccHandler;

				// VCMDRIVERDETAILS and ICINFO are identical structures
				CopyMemory(pvdd, &ICinfo, sizeof(VCMDRIVERDETAILS));

				// For all the built-in sizes we support
				for (l=0; l<MAX_NUM_REGISTERED_SIZES; l++)
				{
					if ((g_aVCMAppInfo[i].framesize[l].biWidth != 0) && (g_aVCMAppInfo[i].framesize[l].biHeight != 0))
					{
						fUnsupportedInputSize = FALSE;

#ifndef NO_LARGE_SIZE_EXCLUSION_HACK
// HACK for version 2
// Since we didn't get general scaling code into version 2, we want to disable the largest size
// if the capture device doesn't support it.  Otherwise we'll put a smaller size into the middle
// of a large black field which looks ugly.  For version 3, we should be able to add the general
// scaling code and remove this hack.

                        if (l == MAX_NUM_REGISTERED_SIZES-1) {
                            // find largest size supported by capture device
                            // NOTE: we assume that the bit definitions for sizes are sorted
                            for (k = VIDEO_FORMAT_NUM_RESOLUTIONS-1; k >= 0 && !(g_awResolutions[k].dwRes & vic.dwImageSize); k--)
                            {}

                            // if we don't find a size, or the size is not greater than half the current size
                            // then mark the size as not supported
                            if ((k < 0) ||
                                (g_awResolutions[k].framesize.biWidth <= (LONG)g_aVCMAppInfo[i].framesize[l].biWidth/2) ||
                                (g_awResolutions[k].framesize.biHeight <= (LONG)g_aVCMAppInfo[i].framesize[l].biHeight/2)) {
                                // capture doesn't support this size
                                if (fdwEnum & VCM_FORMATENUMF_INPUT)
                        			continue;   // we're done
                                else if (fdwEnum & VCM_FORMATENUMF_BOTH)
                        			fUnsupportedInputSize = TRUE;
                        	}
                        }
#endif

						// The new capture stuff can generate data at any size
						bmi.bmiHeader.biWidth  = (LONG)g_aVCMAppInfo[i].framesize[l].biWidth;
						bmi.bmiHeader.biHeight = (LONG)g_aVCMAppInfo[i].framesize[l].biHeight;

						// For all the bit depths we support
						for (k=0; k<NUM_BITDEPTH_ENTRIES; k++)
						{
							// Try the non-RGB formats only if no RGB format
							fUnsupportedBitDepth = FALSE;

							if (((fdwEnum & VCM_FORMATENUMF_INPUT)  || (fdwEnum & VCM_FORMATENUMF_BOTH)) && !((g_aiNumColors[k] & vic.dwNumColors)))
								fUnsupportedBitDepth = TRUE;

							if ((fdwEnum & VCM_FORMATENUMF_INPUT) && fUnsupportedBitDepth)
								goto NextCompressedBitDepth;

							// Set the direction flag appropriately
							if (fdwEnum & VCM_FORMATENUMF_OUTPUT)
								pvfd->dwFlags = VCM_FORMATENUMF_OUTPUT;
							else if (fdwEnum & VCM_FORMATENUMF_INPUT)
								pvfd->dwFlags = VCM_FORMATENUMF_INPUT;
							else if (fdwEnum & VCM_FORMATENUMF_BOTH)
							{
								if (fUnsupportedInputSize || fUnsupportedBitDepth)
									pvfd->dwFlags = VCM_FORMATENUMF_OUTPUT;
								else
									pvfd->dwFlags = VCM_FORMATENUMF_BOTH;
							}

							bmi.bmiHeader.biBitCount      = (WORD)g_aiBitDepth[k];
							bmi.bmiHeader.biCompression   = g_aiFourCCCode[k];
							bmi.bmiHeader.biSizeImage     = (DWORD)WIDTHBYTES(bmi.bmiHeader.biWidth * bmi.bmiHeader.biBitCount) * bmi.bmiHeader.biHeight;

							// Check if the compressor supports the format
							if (ICCompressQuery(hIC, &bmi, (LPBITMAPINFOHEADER)NULL) == ICERR_OK)
							{
								// Now get the size required to hold the format
								dw = ICCompressGetFormatSize(hIC, &bmi);
								// PHILF's BUGBUG: pvfd->cbvfx is the size of the whole structure, not the bitmap info header
								if ((dw >= sizeof(BITMAPINFOHEADER)) && (dw <= pvfd->cbvfx))
								{
									if (ICCompressGetFormat(hIC, &bmi, &pvfd->pvfx->bih) == ICERR_OK)
									{
										// Check if it has alreay been enumerated
										for (m=0, bDejaVu=FALSE, pdvDejaVuCurr = pdvDejaVu; m<iNumCaps; m++, pdvDejaVuCurr++)
										{
											bDejaVu = (!((pdvDejaVuCurr->vfx.bih.biWidth != pvfd->pvfx->bih.biWidth)
											|| (pdvDejaVuCurr->vfx.bih.biHeight != pvfd->pvfx->bih.biHeight)
											|| (pdvDejaVuCurr->vfx.bih.biBitCount != pvfd->pvfx->bih.biBitCount)
											|| (pdvDejaVuCurr->vfx.bih.biCompression != pvfd->pvfx->bih.biCompression)));

											if (bDejaVu)
											{
												// Only remember the maximum compressed size
												if (pdvDejaVuCurr->vfx.bih.biSizeImage < pvfd->pvfx->bih.biSizeImage)
													pdvDejaVuCurr->vfx.bih.biSizeImage = pvfd->pvfx->bih.biSizeImage;
												break;
											}
										}
										if (!bDejaVu)
										{
											// Add new format to the list of DejaVus
											CopyMemory(&(pdvDejaVu + iNumCaps)->vfx, pvfd->pvfx, sizeof(VIDEOFORMATEX));
											(pdvDejaVu + iNumCaps)->dwFlags = pvfd->dwFlags;

											// Update count of caps
											iNumCaps++;

										}
										else
											if ((pvfd->dwFlags == VCM_FORMATENUMF_BOTH) && ((pdvDejaVu + m)->dwFlags != VCM_FORMATENUMF_BOTH))
												(pdvDejaVu + m)->dwFlags = VCM_FORMATENUMF_BOTH;
									}
								}
							}
	NextCompressedBitDepth:;
						}
					}
				}
				ICClose(hIC);

				// For all the caps we have found
				for (m=0; m<iNumCaps; m++)
				{
					// For all the frame rates we support
					for (j=0; j<NUM_FPS_ENTRIES; j++)
					{
						// Copy the cap and flags
						CopyMemory(pvfd->pvfx, &(pdvDejaVu + m)->vfx, sizeof(VIDEOFORMATEX));
						pvfd->dwFlags = (pdvDejaVu + m)->dwFlags;
						// Update rest of the fields
						pvfd->pvfx->nSamplesPerSec = g_aiFps[j];
						pvfd->pvfx->wBitsPerSample = pvfd->pvfx->bih.biBitCount;
#if 0
						if (pvfd->pvfx->bih.biCompression > 256)
						{
							CharUpperBuff((LPTSTR)&pvfd->pvfx->bih.biCompression, sizeof(DWORD));
							pvdd->fccHandler = pvfd->dwFormatTag = pvfd->pvfx->dwFormatTag = pvfd->pvfx->bih.biCompression;
						}
						else
#endif
							pvfd->pvfx->dwFormatTag = pvfd->dwFormatTag = pvdd->fccHandler;
						pvfd->pvfx->nAvgBytesPerSec = pvfd->pvfx->nMinBytesPerSec = pvfd->pvfx->nMaxBytesPerSec = pvfd->pvfx->nSamplesPerSec * pvfd->pvfx->bih.biSizeImage;
						pvfd->pvfx->nBlockAlign = pvfd->pvfx->bih.biSizeImage;
						// The following fields should probably not be modified...
						pvfd->pvfx->dwRequestMicroSecPerFrame = 1000000L / g_aiFps[j];
						pvfd->pvfx->dwPercentDropForError = 10UL;
						// pvfd->pvfx->dwNumVideoRequested = 2UL;
						pvfd->pvfx->dwNumVideoRequested = g_aiFps[j];
						pvfd->pvfx->dwSupportTSTradeOff = 1UL;
						pvfd->pvfx->bLive = TRUE;
						pvfd->pvfx->dwFormatSize = sizeof(VIDEOFORMATEX);

						// Copy the palette if there is one
						if (pvfd->pvfx->wBitsPerSample == 4)
						{	
                            pvfd->pvfx->bih.biClrUsed = 0;
                            if (vic.dwFlags & VICF_4BIT_TABLE) {
    							// Copy the 16 color palette
	    						CopyMemory(&pvfd->pvfx->bihSLOP[0], &vic.bmi4bitColors[0], NUM_4BIT_ENTRIES * sizeof(RGBQUAD));
	    						pvfd->pvfx->bih.biClrUsed = 16;
	    				    }
						}
						else if (pvfd->pvfx->wBitsPerSample == 8)
						{
                            pvfd->pvfx->bih.biClrUsed = 0;
                            if (vic.dwFlags & VICF_8BIT_TABLE) {
    							// Copy the 256 color palette
	    						CopyMemory(&pvfd->pvfx->bihSLOP[0], &vic.bmi8bitColors[0], NUM_8BIT_ENTRIES * sizeof(RGBQUAD));
	    						pvfd->pvfx->bih.biClrUsed = 256;
	    				    }
						}

						if (pvdd->fccHandler > 256)
							wsprintf(szBuffer, IDS_FORMAT_1, (LPSTR)&pvdd->fccType, (LPSTR)&pvdd->fccHandler,
									pvfd->pvfx->bih.biBitCount, pvfd->pvfx->nSamplesPerSec,
									pvfd->pvfx->bih.biWidth, pvfd->pvfx->bih.biHeight);
						else
							wsprintf(szBuffer, IDS_FORMAT_2, (LPSTR)&pvdd->fccType, pvdd->fccHandler,
									pvfd->pvfx->bih.biBitCount, pvfd->pvfx->nSamplesPerSec,
									pvfd->pvfx->bih.biWidth, pvfd->pvfx->bih.biHeight);
						iLen = MultiByteToWideChar(GetACP(), 0, szBuffer, -1, pvfd->szFormat, 0);
						MultiByteToWideChar(GetACP(), 0, szBuffer, -1, pvfd->szFormat, iLen);
						if (!((* fnCallback)((HVCMDRIVERID)hIC, pvdd, pvfd, dwInstance)))
							break;
					}
				}
			}
		}
	}

	// Free table of capabilities
	if (pdvDejaVu)
  	    MemFree((HANDLE)pdvDejaVu);

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 *  @doc  EXTERNAL COMPFUNC
 *
 *  @func MMRESULT | vcmFormatSuggest | This function asks the Video Compression Manager
 *      (VCM) or a specified VCM driver to suggest a destination format for
 *      the supplied source format, or the recommended source format for a supplied destination
 *      format. For example, an application can use this function to determine one or more
 *      valid RGB formats to which a compressed format can be decompressed.
 *
 *  @parm UINT | uDevice | Identifies the capture device ID.
 *
 *  @parm HVCMDRIVER | hvd | Identifies an optional open instance of a
 *      driver to query for a suggested destination format. If this
 *      argument is NULL, the VCM attempts to find the best driver to suggest
 *      a destination format or a source format.
 *
 *  @parm PVIDEOFORMATEX | pvfxSrc | Specifies a pointer to a <t VIDEOFORMATEX>
 *      structure that identifies the source format to suggest a destination
 *      format to be used for a conversion, or that will receive the suggested
 *      source format for the <p pvfxDst> format. Note
 *      that based on the <p fdwSuggest> argument, some members of the structure
 *      pointed to by <p pvfxSrc> may require initialization.
 *
 *  @parm PVIDEOFORMATEX | pvfxDst | Specifies a pointer to a <t VIDEOFORMATEX>
 *      data structure that will receive the suggested destination format
 *      for the <p pvfxSrc> format, or that identifies the destination format to
 *      suggest a recommended source format to be used for a conversion. Note
 *      that based on the <p fdwSuggest> argument, some members of the structure
 *      pointed to by <p pvfxDst> may require initialization.
 *
 *  @parm DWORD | cbvfxDst | Specifies the size in bytes available for
 *      the destination, or the source format. The <f vcmMetrics>
 *      functions can be used to determine the maximum size required for any
 *      format available for the specified driver (or for all installed VCM
 *      drivers).
 *
 *  @parm DWORD | fdwSuggest | Specifies flags for matching the desired
 *      destination format, or source format.
 *
 *      @flag VCM_FORMATSUGGESTF_DST_WFORMATTAG | Specifies that the
 *      <e VIDEOFORMATEX.dwFormatTag> member of the <p pvfxDst> structure is
 *      valid. The VCM will query acceptable installed drivers that can
 *      use the <p pvfxSrc> structure as their source format and output a
 *      destination format matching the <e VIDEOFORMATEX.dwFormatTag>
 *      member, or fail. The <p pvfxDst> structure is updated with the complete
 *      destination format.
 *
 *      @flag VCM_FORMATSUGGESTF_DST_NSAMPLESPERSEC | Specifies that the
 *      <e VIDEOFORMATEX.nSamplesPerSec> member of the <p pvfxDst> structure
 *      is valid. The VCM will query acceptable installed drivers that can
 *      use the <p pvfxSrc> structure as their source format and output a
 *      destination format matching the <e VIDEOFORMATEX.nSamplesPerSec>
 *      member, or fail. The <p pvfxDst> structure is updated with the complete
 *      destination format.
 *
 *      @flag VCM_FORMATSUGGESTF_DST_WBITSPERSAMPLE | Specifies that the
 *      <e VIDEOFORMATEX.wBitsPerSample> member of the <p pvfxDst> structure
 *      is valid. The VCM will query acceptable installed drivers that can
 *      use the <p pvfxSrc> structure as their source format and output a
 *      destination format matching the <e VIDEOFORMATEX.wBitsPerSample>
 *      member, or fail. The <p pvfxDst> structure is updated with the complete
 *      destination format.
 *
 *      @flag VCM_FORMATSUGGESTF_SRC_WFORMATTAG | Specifies that the
 *      <e VIDEOFORMATEX.dwFormatTag> member of the <p pvfxSrc> structure is
 *      valid. The VCM will query acceptable installed drivers that can
 *      use the <p pvfxDst> structure as their destination format and accept a
 *      source format matching the <e VIDEOFORMATEX.dwFormatTag>
 *      member, or fail. The <p pvfxSrc> structure is updated with the complete
 *      source format.
 *
 *      @flag VCM_FORMATSUGGESTF_SRC_NSAMPLESPERSEC | Specifies that the
 *      <e VIDEOFORMATEX.nSamplesPerSec> member of the <p pvfxSrc> structure
 *      is valid. The VCM will query acceptable installed drivers that can
 *      use the <p pvfxDst> structure as their destination format and accept a
 *      source format matching the <e VIDEOFORMATEX.nSamplesPerSec>
 *      member or fail. The <p pvfxSrc> structure is updated with the complete
 *      source format.
 *
 *      @flag VCM_FORMATSUGGESTF_SRC_WBITSPERSAMPLE | Specifies that the
 *      <e VIDEOFORMATEX.wBitsPerSample> member of the <p pvfxSrc> structure
 *      is valid. The VCM will query acceptable installed drivers that can
 *      use the <p pvfxDst> structure as their destination format and accept a
 *      source format matching the <e VIDEOFORMATEX.wBitsPerSample>
 *      member, or fail. The <p pvfxSrc> structure is updated with the complete
 *      source format.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag MMSYSERR_NOTSUPPORTED | One or more of the restriction bits is not supported.
 *
 *      @flag MMSYSERR_NODRIVER | No capture device driver or device is present.
 *
 *  @devnote PhilF: For now, only the VCM_FORMATSUGGESTF_DST_WFORMATTAG and VCM_FORMATSUGGESTF_SRC_WFORMATTAG
 *      are supported. The other flags are just ignored. Add real support for other flags
 *      if  they would really make a difference. But for the two current Data Pump calls,
 *      they don't influence the outcome of the call.
 *
 *      The cbvfxDst is never used. Should we still pass it? How can I make a good use of it?
 *
 *      Should there also be cbvfxSrc parameter?
 *
 *      This function is used to determine what should the (source) capture format of the capture
 *      device be in order to generate a specific compressed destination format.
 *      Now, there are two possibilities. Either we can directly capture at a frame size
 *      identical to the one in the <p pvfxDst> structure, or we can't, but still, once compressed
 *      the output frame has the same size than the one in the <p pvfxDst> structure.
 *      Typical example: Greyscale QuickCam. If the output format were set to 128x96 (SQCIF)
 *      and we were to try capturing directly at this size, this would fail, since 128x96
 *      is not supported by the hardware. On the other hand, if we capture at 160x120,
 *      the codec will truncate to 128x96. Now, how can we figure this out programmatically?
 *      For now, the next largest size is ASSUMED to be truncatable by the codec to the right size.
 *      This needs to be actually run through the codec for validation. Fix that.
 *
 *      If the capture driver capture with a format that is not RGB, this call will fail to suggest
 *      a valid source format and will return MMSYSERR_NODRIVER. Fix that.
 *
 *  @xref <f vcmMetrics> <f vcmFormatEnum>
 ***************************************************************************/
MMRESULT VCMAPI vcmFormatSuggest(UINT uDevice, HVCMDRIVER hvd, PVIDEOFORMATEX pvfxSrc, PVIDEOFORMATEX pvfxDst, DWORD cbvfxDst, DWORD fdwSuggest)
{
	DWORD		dwSize;
	MMRESULT	mmr;
	WORD		wFlags;
	HIC			hIC;
	DWORD		fdwSuggestL;
	DWORD		dwFormatTag;
	VIDEOINCAPS	vic;
	int			i, delta, best, tmp;

#define VCM_FORMAT_SUGGEST_SUPPORT VCM_FORMATSUGGESTF_TYPEMASK

	// Check input params
	if (!pvfxSrc)
	{
		ERRORMESSAGE(("vcmFormatSuggest: Specified pointer is invalid, pvfxSrc=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!pvfxDst)
	{
		ERRORMESSAGE(("vcmFormatSuggest: Specified pointer is invalid, pvfxSrc=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if ((uDevice >= MAXVIDEODRIVERS) && (uDevice != VIDEO_MAPPER))
	{
		ERRORMESSAGE(("vcmFormatSuggest: Specified capture device ID is invalid, uDevice=%ld (expected values are 0x%lX or between 0 and %ld)\r\n", uDevice, VIDEO_MAPPER, MAXVIDEODRIVERS-1));
		return ((MMRESULT)MMSYSERR_BADDEVICEID);
	}

	// Grab the suggestion restriction bits and verify that we support
	// the ones that are specified
	fdwSuggestL = (VCM_FORMATSUGGESTF_TYPEMASK & fdwSuggest);

	if (~VCM_FORMAT_SUGGEST_SUPPORT & fdwSuggestL)
	{
		ERRORMESSAGE(("vcmFormatSuggest: Specified mask is invalid, fdwSuggest=0x%lX\r\n", fdwSuggest));
		return ((MMRESULT)MMSYSERR_NOTSUPPORTED);
	}

	// Get the size of the largest bitmap info header
	if (((mmr = vcmMetrics((HVCMOBJ)NULL, VCM_METRIC_MAX_SIZE_BITMAPINFOHEADER, &dwSize)) == MMSYSERR_NOERROR) && (dwSize >= sizeof(BITMAPINFOHEADER)))
	{
		if (fdwSuggest & VCM_FORMATSUGGESTF_DST_WFORMATTAG)
		{
			if (pvfxSrc->bih.biCompression == BI_RGB)
			{
				if (pvfxDst->bih.biCompression == BI_RGB)
				{
					// Input and output format are uncompressed
					CopyMemory(pvfxDst, pvfxSrc, pvfxSrc->dwFormatSize);
					return ((MMRESULT)MMSYSERR_NOERROR);
				}
				else
				{
					wFlags = ICMODE_COMPRESS;
					dwFormatTag = pvfxDst->dwFormatTag;
				}
			}
			else
			{
				wFlags = ICMODE_DECOMPRESS;
				dwFormatTag = pvfxSrc->dwFormatTag;
			}

#ifndef _ALPHA_
#ifdef USE_BILINEAR_MSH26X
			if ((dwFormatTag == VIDEO_FORMAT_MSH263) || (dwFormatTag == VIDEO_FORMAT_MSH261) || (dwFormatTag == VIDEO_FORMAT_MSH26X))
#else
			if ((dwFormatTag == VIDEO_FORMAT_MSH263) || (dwFormatTag == VIDEO_FORMAT_MSH261))
#endif
#else
			if ((dwFormatTag == VIDEO_FORMAT_DECH263) || (dwFormatTag == VIDEO_FORMAT_DECH261))
#endif
			{
				hIC = ICOpen(VCMDRIVERDETAILS_FCCTYPE_VIDEOCODEC, dwFormatTag, wFlags);

				if (hIC && (wFlags == ICMODE_COMPRESS))
					ICSendMessage(hIC, CUSTOM_ENABLE_CODEC, G723MAGICWORD1, G723MAGICWORD2);
			}
			else
				hIC = ICLocate(VCMDRIVERDETAILS_FCCTYPE_VIDEOCODEC, dwFormatTag, (LPBITMAPINFOHEADER)&pvfxSrc->bih, (LPBITMAPINFOHEADER)NULL, wFlags);

			if (hIC)
			{
				if (wFlags == ICMODE_COMPRESS)
				{
					// Now get the size required to hold the format
					dwSize = ICCompressGetFormatSize(hIC, &pvfxSrc->bih);
					if ((dwSize >= sizeof(BITMAPINFOHEADER)) && (dwSize <= cbvfxDst))
					{
						if (ICCompressGetFormat(hIC, &pvfxSrc->bih, &pvfxDst->bih) == ICERR_OK)
						{
							pvfxDst->nSamplesPerSec = pvfxSrc->nSamplesPerSec;
							pvfxDst->wBitsPerSample = pvfxDst->bih.biBitCount;
							pvfxDst->dwFormatTag = pvfxDst->bih.biCompression;
							pvfxDst->nAvgBytesPerSec = pvfxDst->nMinBytesPerSec = pvfxDst->nMaxBytesPerSec = pvfxDst->nSamplesPerSec * pvfxDst->bih.biSizeImage;
							pvfxDst->nBlockAlign = pvfxDst->bih.biSizeImage;
							// The following fields should probably not be modified...
							pvfxDst->dwRequestMicroSecPerFrame = pvfxSrc->dwRequestMicroSecPerFrame;
							pvfxDst->dwPercentDropForError = pvfxSrc->dwPercentDropForError;
							pvfxDst->dwNumVideoRequested = pvfxSrc->dwNumVideoRequested;
							pvfxDst->dwSupportTSTradeOff = pvfxSrc->dwSupportTSTradeOff;
							pvfxDst->bLive = pvfxSrc->bLive;
							pvfxDst->dwFormatSize = sizeof(VIDEOFORMATEX);
						}
					}
				}
				else
				{
					// Now get the size required to hold the format
					dwSize = ICDecompressGetFormatSize(hIC, &pvfxSrc->bih);
					if ((dwSize >= sizeof(BITMAPINFOHEADER)) && (dwSize <= cbvfxDst))
					{
						if (ICDecompressGetFormat(hIC, &pvfxSrc->bih, &pvfxDst->bih) == ICERR_OK)
						{
							pvfxDst->nSamplesPerSec = pvfxSrc->nSamplesPerSec;
							pvfxDst->wBitsPerSample = pvfxDst->bih.biBitCount;
							pvfxDst->dwFormatTag = pvfxDst->bih.biCompression;
							pvfxDst->nAvgBytesPerSec = pvfxDst->nMinBytesPerSec = pvfxDst->nMaxBytesPerSec = pvfxDst->nSamplesPerSec * pvfxDst->bih.biSizeImage;
							pvfxDst->nBlockAlign = pvfxDst->bih.biSizeImage;
							pvfxDst->dwRequestMicroSecPerFrame = pvfxSrc->dwRequestMicroSecPerFrame;
							// The following fields should probably not be modified...
							pvfxDst->dwRequestMicroSecPerFrame = pvfxSrc->dwRequestMicroSecPerFrame;
							pvfxDst->dwPercentDropForError = pvfxSrc->dwPercentDropForError;
							pvfxDst->dwNumVideoRequested = pvfxSrc->dwNumVideoRequested;
							pvfxDst->dwSupportTSTradeOff = pvfxSrc->dwSupportTSTradeOff;
							pvfxDst->bLive = pvfxSrc->bLive;
							pvfxDst->dwFormatSize = sizeof(VIDEOFORMATEX);
						}
					}
				}
				ICClose(hIC);
			}
		}
		else if (fdwSuggest & VCM_FORMATSUGGESTF_SRC_WFORMATTAG)
		{

			// In case only the format tag was initialized, copy it to the biCompression field
			pvfxSrc->bih.biCompression = pvfxSrc->dwFormatTag;

			if (pvfxSrc->bih.biCompression == BI_RGB)
			{
				if (pvfxDst->bih.biCompression == BI_RGB)
				{
					// Input and output format are uncompressed
					CopyMemory(pvfxSrc, pvfxDst, pvfxDst->dwFormatSize);
					return ((MMRESULT)MMSYSERR_NOERROR);
				}
				else
				{
					wFlags = ICMODE_COMPRESS;
					dwFormatTag = pvfxDst->dwFormatTag;
				}
			}
			else
			{
				if (pvfxDst->bih.biCompression == BI_RGB)
				{
					wFlags = ICMODE_DECOMPRESS;
					dwFormatTag = pvfxSrc->dwFormatTag;
				}
				else
				{
					wFlags = ICMODE_COMPRESS;
					dwFormatTag = pvfxDst->dwFormatTag;
				}
			}

			if (wFlags == ICMODE_COMPRESS)
			{
				// Now, there are two possibilities. Either we can directly capture at a frame size
				// identical to the one in the pvfxDst structure, or we can't, but once compressed
				// the output frame has the same size than the one in the pvfxDst structure.
				// Typical example, Greyscale QuickCam. If the output format were set to 128x96 (SQCIF)
				// and we were to try capturing directly at this size, this would fail, since 128x96
				// is not supported by the hardware. On the other hand, if we capture at 160x120,
				// the codec will truncate to 128x96. Now, how can we figure this out programmatically?

				// The color and greyscale capability field will let us know what bit depth to use.
				// We should probably have a field that also says which bit depth is preferred in the
				// case more than one are supported. For now, assume the priority order is: 16, 24, 4, 8
				if ((mmr = vcmGetDevCaps(uDevice, &vic, sizeof(VIDEOINCAPS))) != MMSYSERR_NOERROR)
					return (mmr);

                if (vic.dwImageSize & VIDEO_FORMAT_IMAGE_SIZE_USE_DEFAULT) {
               		ERRORMESSAGE(("vcmFormatSuggest: suggest using default\r\n"));
               		return ((MMRESULT)MMSYSERR_NOTSUPPORTED);
                }

				CopyMemory(&pvfxSrc->bih, &pvfxDst->bih, sizeof(BITMAPINFOHEADER));

				// Assume the next resolution will be correctly truncated to the output size
				best = -1;
				delta = 999999;
				for (i=0; i<VIDEO_FORMAT_NUM_RESOLUTIONS; i++) {
					if (g_awResolutions[i].dwRes & vic.dwImageSize) {
						tmp = g_awResolutions[i].framesize.biWidth - pvfxDst->bih.biWidth;
						if (tmp < 0) tmp = -tmp;
						if (tmp < delta) {
							delta = tmp;
							best = i;
						}
						tmp = g_awResolutions[i].framesize.biHeight - pvfxDst->bih.biHeight;
						if (tmp < 0) tmp = -tmp;
						if (tmp < delta) {
							delta = tmp;
							best = i;
						}
					}
				}
        		if (best < 0) {
                    ERRORMESSAGE(("vcmFormatSuggest: no available formats\r\n"));
                    return ((MMRESULT)MMSYSERR_NOTSUPPORTED);
        		}
				// Actually, you don't have to assume it will work. You can directly ask the codec
				// is this would work...
				pvfxSrc->bih.biWidth = g_awResolutions[best].framesize.biWidth;
				pvfxSrc->bih.biHeight = g_awResolutions[best].framesize.biHeight;

				// Now, we assume that the captured format is an RGB format. Once in place, you should
				// verify this from the capability set of the capture device.
				if (pvfxSrc->bih.biSize != sizeof(BITMAPINFOHEADER))
					pvfxSrc->bih.biSize = sizeof(BITMAPINFOHEADER);

				// If the capture hardware does not support RGB, we need to use its compressed format
				for (i=0; i<NUM_BITDEPTH_ENTRIES; i++)
				{
					if (vic.dwNumColors & g_aiNumColors[i])
					{
						pvfxSrc->bih.biBitCount = (WORD)g_aiBitDepth[i];
						pvfxSrc->bih.biCompression = g_aiFourCCCode[i];
						break;
					}
				}
				
				// Copy the palette if there is one
				if (pvfxSrc->bih.biBitCount == 4)
				{	
        			pvfxSrc->bih.biClrUsed = 0;
                    if (vic.dwFlags & VICF_4BIT_TABLE) {
						// Copy the 16 color palette
						CopyMemory(&pvfxSrc->bihSLOP[0], &vic.bmi4bitColors[0], NUM_4BIT_ENTRIES * sizeof(RGBQUAD));
   						pvfxSrc->bih.biClrUsed = 16;
				    }
				}
				else if (pvfxSrc->bih.biBitCount == 8)
				{
        			pvfxSrc->bih.biClrUsed = 0;
                    if (vic.dwFlags & VICF_8BIT_TABLE) {
						// Copy the 256 color palette
						CopyMemory(&pvfxSrc->bihSLOP[0], &vic.bmi8bitColors[0], NUM_8BIT_ENTRIES * sizeof(RGBQUAD));
   						pvfxSrc->bih.biClrUsed = 256;
				    }
				}

				pvfxSrc->bih.biSizeImage = WIDTHBYTES(pvfxSrc->bih.biWidth * pvfxSrc->bih.biBitCount) * pvfxSrc->bih.biHeight;
			}
			else
			{
#ifndef _ALPHA_
#ifdef USE_BILINEAR_MSH26X
				if ((dwFormatTag == VIDEO_FORMAT_MSH263) || (dwFormatTag == VIDEO_FORMAT_MSH261) || (dwFormatTag == VIDEO_FORMAT_MSH26X))
#else
				if ((dwFormatTag == VIDEO_FORMAT_MSH263) || (dwFormatTag == VIDEO_FORMAT_MSH261))
#endif
#else
				if ((dwFormatTag == VIDEO_FORMAT_DECH263) || (dwFormatTag == VIDEO_FORMAT_DECH261))
#endif
					hIC = ICOpen(VCMDRIVERDETAILS_FCCTYPE_VIDEOCODEC, dwFormatTag, wFlags);
				else
					hIC = ICLocate(VCMDRIVERDETAILS_FCCTYPE_VIDEOCODEC, dwFormatTag, (LPBITMAPINFOHEADER)&pvfxSrc->bih, (LPBITMAPINFOHEADER)NULL, wFlags);

				if (hIC)
				{
					// Now get the size required to hold the format
					dwSize = ICDecompressGetFormatSize(hIC, &pvfxSrc->bih);
					if ((dwSize >= sizeof(BITMAPINFOHEADER)) && (dwSize <= cbvfxDst))
					{
						if (ICDecompressGetFormat(hIC, &pvfxSrc->bih, &pvfxDst->bih) == ICERR_OK)
						{
							pvfxSrc->nSamplesPerSec = pvfxSrc->nSamplesPerSec;
							pvfxSrc->wBitsPerSample = pvfxDst->bih.biBitCount;
							pvfxSrc->dwFormatTag = pvfxDst->bih.biCompression;
							pvfxDst->nAvgBytesPerSec = pvfxDst->nMinBytesPerSec = pvfxDst->nMaxBytesPerSec = pvfxDst->nSamplesPerSec * pvfxDst->bih.biSizeImage;
							pvfxDst->nBlockAlign = pvfxDst->bih.biSizeImage;
							pvfxDst->dwRequestMicroSecPerFrame = pvfxSrc->dwRequestMicroSecPerFrame;
							// The following fields should probably not be modified...
							pvfxDst->dwRequestMicroSecPerFrame = pvfxSrc->dwRequestMicroSecPerFrame;
							pvfxDst->dwPercentDropForError = pvfxSrc->dwPercentDropForError;
							pvfxDst->dwNumVideoRequested = pvfxSrc->dwNumVideoRequested;
							pvfxDst->dwSupportTSTradeOff = pvfxSrc->dwSupportTSTradeOff;
							pvfxDst->bLive = pvfxSrc->bLive;
							pvfxDst->dwFormatSize = sizeof(VIDEOFORMATEX);
						}
					}
    				ICClose(hIC);
				}
			}
		}
	}

	return (mmr);
}


/****************************************************************************
 *  @doc EXTERNAL COMPFUNC
 *
 *  @func MMRESULT | vcmStreamOpen | The vcmStreamOpen function opens a Video Compression
 *      Manager (VCM) conversion stream. Conversion streams are used to convert data from
 *      one specified video format to another.
 *
 *  @parm PHVCMSTREAM | phvs | Specifies a pointer to a <t HVCMSTREAM>
 *      handle that will receive the new stream handle that can be used to
 *      perform conversions. Use this handle to identify the stream
 *      when calling other VCM stream conversion functions. This parameter
 *      should be NULL if the VCM_STREAMOPENF_QUERY flag is specified.
 *
 *  @parm HVCMDRIVER | hvd | Specifies an optional handle to a VCM driver.
 *      If specified, this handle identifies a specific driver to be used
 *      for a conversion stream. If this argument is NULL, then all suitable
 *      installed VCM drivers are queried until a match is found.
 *
 *  @parm PVIDEOFORMATEX | pvfxSrc | Specifies a pointer to a <t VIDEOFORMATEX>
 *      structure that identifies the desired source format for the
 *      conversion.
 *
 *  @parm PVIDEOFORMATEX | pvfxDst | Specifies a pointer to a <t VIDEOFORMATEX>
 *      structure that identifies the desired destination format for the
 *      conversion.
 *
 * @parm DWORD | dwImageQuality | Specifies an image quality value (between 0
 *      and 31. The lower number indicates a high spatial quality at a low frame
 *      rate, the larger number indiocates a low spatial quality at a high frame
 *      rate.
 *
 *  @parm DWORD | dwCallback | Specifies the address of a callback function
 *      or a handle to a window called after each buffer is converted. A
 *      callback will only be called if the conversion stream is opened with
 *      the VCM_STREAMOPENF_ASYNC flag. If the conversion stream is opened
 *     without the CCM_STREAMOPENF_ASYNC flag, then this parameter should
 *     be set to zero.
 *
 *  @parm DWORD | dwInstance | Specifies user-instance data passed on to the
 *      callback specified by <p dwCallback>. This argument is not used with
 *      window callbacks. If the conversion stream is opened without the
 *     VCM_STREAMOPENF_ASYNC flag, then this parameter should be set to zero.
 *
 *  @parm DWORD | fdwOpen | Specifies flags for opening the conversion stream.
 *
 *      @flag VCM_STREAMOPENF_QUERY | Specifies that the VCM will be queried
 *      to determine whether it supports the given conversion. A conversion
 *      stream will not be opened and no <t HVCMSTREAM> handle will be
 *      returned.
 *
 *      @flag VCM_STREAMOPENF_NONREALTIME | Specifies that the VCM will not
 *      consider time constraints when converting the data. By default, the
 *      driver will attempt to convert the data in real time. Note that for
 *      some formats, specifying this flag might improve the video quality
 *      or other characteristics.
 *
 *      @flag VCM_STREAMOPENF_ASYNC | Specifies that conversion of the stream should
 *      be performed asynchronously. If this flag is specified, the application
 *      can use a callback to be notified on open and close of the conversion
 *      stream, and after each buffer is converted. In addition to using a
 *      callback, an application can examine the <e VCMSTREAMHEADER.fdwStatus>
 *      of the <t VCMSTREAMHEADER> structure for the VCMSTREAMHEADER_STATUSF_DONE
 *      flag.
 *
 *      @flag CALLBACK_WINDOW | Specifies that <p dwCallback> is assumed to
 *      be a window handle.
 *
 *      @flag CALLBACK_FUNCTION | Specifies that <p dwCallback> is assumed to
 *      be a callback procedure address. The function prototype must conform
 *      to the <f vcmStreamConvertCallback> convention.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag MMSYSERR_NOMEM | Unable to allocate resources.
 *
 *      @flag VCMERR_NOTPOSSIBLE | The requested operation cannot be performed.
 *
 *  @comm Note that if a VCM driver cannot perform real-time conversions,
 *      and the VCM_STREAMOPENF_NONREALTIME flag is not specified for
 *      the <p fdwOpen> argument, the open will fail returning an
 *      VCMERR_NOTPOSSIBLE error code. An application can use the
 *      VCM_STREAMOPENF_QUERY flag to determine if real-time conversions
 *      are supported for the input arguments.
 *
 *    If a window is chosen to receive callback information, the
 *      following messages are sent to the window procedure function to
 *      indicate the progress of the conversion stream: <m MM_VCM_OPEN>,
 *      <m MM_VCM_CLOSE>, and <m MM_VCM_DONE>. The <p wParam>  parameter identifies
 *      the <t HVCMSTREAM> handle. The <p lParam>  parameter identifies the
 *      <t VCMSTREAMHEADER> structure for <m MM_VCM_DONE>, but is not used
 *      for <m MM_VCM_OPEN> and <m MM_VCM_CLOSE>.
 *
 *      If a function is chosen to receive callback information, the
 *      following messages are sent to the function to indicate the progress
 *      of output: <m MM_VCM_OPEN>, <m MM_VCM_CLOSE>, and
 *      <m MM_VCM_DONE>. The callback function must reside in a DLL. You do
 *      not need to use <f MakeProcInstance> to get a procedure-instance
 *      address for the callback function.
 *
 *  @xref <f vcmStreamClose> <f vcmStreamConvert>
 *      <f vcmFormatSuggest> <f vcmStreamConvertCallback>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamOpen(PHVCMSTREAM phvs, HVCMDRIVER hvd, PVIDEOFORMATEX pvfxSrc, PVIDEOFORMATEX pvfxDst, DWORD dwImageQuality, DWORD dwPacketSize, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen)
{
	MMRESULT			mmr;
	DWORD				dwFlags;
	DWORD				fccHandler;
	HIC					hIC;
	VIDEOFORMATEX		*pvfxS;
	VIDEOFORMATEX		*pvfxD;
	BITMAPINFOHEADER	*pbmiPrev;		// Pointer to reconstructed frame bitmap info header (for now assume it is the same than the input format...)
	ICINFO				icInfo;
	PVOID				pvState;		// Pointer to codec configuration information
	DWORD				dw;				// Size of codec configuration information or destination BITAMPINFO
	ICCOMPRESSFRAMES	iccf = {0};			// Structure used to set compression parameters
	PMSH26XCOMPINSTINFO	pciMSH26XInfo;	// Pointer to MS H26X configuration information
#ifdef USE_MPEG4_SCRUNCH
	PMPEG4COMPINSTINFO	pciMPEG4Info;	// Pointer to MPEG4 Scrunch configuration information
#endif

	// Check input params
	if (!pvfxSrc)
	{
		ERRORMESSAGE(("vcmStreamOpen: Specified pointer is invalid, pvfxSrc=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!pvfxDst)
	{
		ERRORMESSAGE(("vcmStreamOpen: Specified pointer is invalid, pvfxSrc=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!pvfxSrc->dwFormatSize)
	{
		ERRORMESSAGE(("vcmStreamOpen: Specified format size is invalid, pvfxSrc->dwFormatSize=%ld\r\n", pvfxSrc->dwFormatSize));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!pvfxDst->dwFormatSize)
	{
		ERRORMESSAGE(("vcmStreamOpen: Specified format size is invalid, pvfxDst->dwFormatSize=%ld\r\n", pvfxDst->dwFormatSize));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if ((dwImageQuality < VCM_MIN_IMAGE_QUALITY) || (dwImageQuality > VCM_MAX_IMAGE_QUALITY))
		dwImageQuality = VCM_DEFAULT_IMAGE_QUALITY;

	// Set default values
	*phvs = (HVCMSTREAM)NULL;

	// Are we compressing of decompressing?
	if (pvfxSrc->bih.biCompression == BI_RGB)
	{
		dwFlags = ICMODE_COMPRESS;
		fccHandler = (DWORD)pvfxDst->bih.biCompression;
	}
	else
	{
		if (pvfxDst->bih.biCompression == BI_RGB)
		{
			dwFlags = ICMODE_DECOMPRESS;
			fccHandler = (DWORD)pvfxSrc->bih.biCompression;
		}
		else
		{
			dwFlags = ICMODE_COMPRESS;
			fccHandler = (DWORD)pvfxDst->bih.biCompression;
		}
	}

	// Get a handle to the compressor/decompressor
#ifndef _ALPHA_
#ifdef USE_BILINEAR_MSH26X
	if ((fccHandler == VIDEO_FORMAT_MSH263) || (fccHandler == VIDEO_FORMAT_MSH261) || (fccHandler == VIDEO_FORMAT_MSH26X))
#else
	if ((fccHandler == VIDEO_FORMAT_MSH263) || (fccHandler == VIDEO_FORMAT_MSH261))
#endif
#else
	if ((fccHandler == VIDEO_FORMAT_DECH263) || (fccHandler == VIDEO_FORMAT_DECH261))
#endif
	{
		hIC = ICOpen(VCMDRIVERDETAILS_FCCTYPE_VIDEOCODEC, fccHandler, (WORD)dwFlags);
		if (hIC && (dwFlags == ICMODE_COMPRESS))
			ICSendMessage(hIC, CUSTOM_ENABLE_CODEC, G723MAGICWORD1, G723MAGICWORD2);
	}
	else
		hIC = ICLocate(VCMDRIVERDETAILS_FCCTYPE_VIDEOCODEC, fccHandler, (LPBITMAPINFOHEADER)&pvfxSrc->bih, (LPBITMAPINFOHEADER)&pvfxDst->bih, (WORD)dwFlags);

	if (hIC)
	{
		// Get info about this compressor
		ICGetInfo(hIC, &icInfo, sizeof(ICINFO));

		// Allocate VCM stream structure
		if (!(*phvs = (HVCMSTREAM)MemAlloc(sizeof(VCMSTREAM))))
		{
			ERRORMESSAGE(("vcmStreamOpen: Memory allocation of a VCM stream structure failed\r\n"));
			mmr = (MMRESULT)MMSYSERR_NOMEM;
			goto MyExit0;
		}
		else
		{
			((PVCMSTREAM)(*phvs))->hIC = (HVCMDRIVER)hIC;
			((PVCMSTREAM)(*phvs))->dwICInfoFlags = icInfo.dwFlags;
			((PVCMSTREAM)(*phvs))->dwQuality = dwImageQuality;
			((PVCMSTREAM)(*phvs))->dwMaxPacketSize = dwPacketSize;
			((PVCMSTREAM)(*phvs))->dwFrame = 0L;
			// For now, issue a key frame every 15 seconds
			((PVCMSTREAM)(*phvs))->dwLastIFrameTime = GetTickCount();
			((PVCMSTREAM)(*phvs))->fPeriodicIFrames = TRUE;
			((PVCMSTREAM)(*phvs))->dwCallback = dwCallback;
			((PVCMSTREAM)(*phvs))->dwCallbackInstance = dwInstance;
			((PVCMSTREAM)(*phvs))->fdwOpen = fdwOpen;
			((PVCMSTREAM)(*phvs))->fdwStream = dwFlags;
			((PVCMSTREAM)(*phvs))->dwLastTimestamp = ULONG_MAX;


			// We need the following crs to make sure we don't miss any of the I-Frame requests
			// emittted by the UI. Problematic scenario: pvs->dwFrame is at 123 for instance.
			// The UI thread requests an I-Frame by setting pvs->dwFrame. If the capture/compression
			// thread was in ICCompress() (which is very probable since it takes quite some time
			// to compress a frame), pvs->dwFrame will be incremented by one when ICCompress()
			// returns. We failed to handle the I-Frame request correctly, since the next time
			// ICCompress() gets called pvs->dwFrame will be equal to 1, for which we do not
			// generate an I-Frame.
			if ((dwFlags == ICMODE_COMPRESS) || (dwFlags == ICMODE_FASTCOMPRESS))	// Hmmm... where could you have set the second mode?
				InitializeCriticalSection(&(((PVCMSTREAM)(*phvs))->crsFrameNumber));

			// Allocate the video formats
			if (!(pvfxS = (VIDEOFORMATEX *)MemAlloc(pvfxSrc->dwFormatSize)))
			{
				ERRORMESSAGE(("vcmStreamOpen: Memory allocation of source video format failed\r\n"));
				mmr = (MMRESULT)MMSYSERR_NOMEM;
				goto MyExit1;
			}
			else
			{
				if (!(pvfxD = (VIDEOFORMATEX *)MemAlloc(pvfxDst->dwFormatSize)))
				{
					ERRORMESSAGE(("vcmStreamOpen: Memory allocation of destination video format failed\r\n"));
					mmr = (MMRESULT)MMSYSERR_NOMEM;
					goto MyExit2;
				}
				else
				{	// This is naive. You need to query the codec for its decompressed format size and data
					if (!(pbmiPrev = (BITMAPINFOHEADER *)MemAlloc(sizeof(BITMAPINFOHEADER))))
					{
						ERRORMESSAGE(("vcmStreamOpen: Memory allocation of previous video frame failed\r\n"));
						mmr = (MMRESULT)MMSYSERR_NOMEM;
						goto MyExit3;
					}
					else
					{
						CopyMemory(((PVCMSTREAM)(*phvs))->pvfxSrc = pvfxS, pvfxSrc, pvfxSrc->dwFormatSize);
						CopyMemory(((PVCMSTREAM)(*phvs))->pvfxDst = pvfxD, pvfxDst, pvfxDst->dwFormatSize);
						CopyMemory(((PVCMSTREAM)(*phvs))->pbmiPrev = pbmiPrev, &pvfxSrc->bih, sizeof(BITMAPINFOHEADER));
					}
				}
			}

			if ((dwFlags == ICMODE_COMPRESS) || (dwFlags == ICMODE_FASTCOMPRESS))	// Hmmm... where could you have set the second mode?
			{
				// Get the state of the compressor
				if (dw = ICGetStateSize(hIC))
				{
					if (!(pvState = (PVOID)MemAlloc(dw)))
					{
						ERRORMESSAGE(("vcmStreamOpen: Memory allocation of codec configuration information structure failed\r\n"));
						mmr = (MMRESULT)MMSYSERR_NOMEM;
						goto MyExit4;
					}
					if (((DWORD) ICGetState(hIC, pvState, dw)) != dw)
					{
						ERRORMESSAGE(("vcmStreamOpen: ICGetState() failed\r\n"));
						mmr = (MMRESULT)VCMERR_FAILED;
						goto MyExit5;
					}
				}

				// Do any of the stuff that is MS H.263 or MS H.261 specific right here
#ifndef _ALPHA_
#ifdef USE_BILINEAR_MSH26X
				if ((pvfxDst->bih.biCompression == VIDEO_FORMAT_MSH263) || (pvfxDst->bih.biCompression == VIDEO_FORMAT_MSH261) || (pvfxDst->bih.biCompression == VIDEO_FORMAT_MSH26X))
#else
				if ((pvfxDst->bih.biCompression == VIDEO_FORMAT_MSH263) || (pvfxDst->bih.biCompression == VIDEO_FORMAT_MSH261))
#endif
#else
				if ((pvfxDst->bih.biCompression == VIDEO_FORMAT_DECH263) || (pvfxDst->bih.biCompression == VIDEO_FORMAT_DECH261))
#endif
				{
					pciMSH26XInfo = (PMSH26XCOMPINSTINFO)pvState;

					// Really configure the codec for compression
					pciMSH26XInfo->Configuration.bRTPHeader = TRUE;
					pciMSH26XInfo->Configuration.unPacketSize = ((PVCMSTREAM)(*phvs))->dwMaxPacketSize;
					pciMSH26XInfo->Configuration.bEncoderResiliency = FALSE;
					pciMSH26XInfo->Configuration.unPacketLoss = 0;
					// PhilF-: Make this work on the alpha
#ifndef _ALPHA_
					pciMSH26XInfo->Configuration.bBitRateState = TRUE;
#else
					pciMSH26XInfo->Configuration.bBitRateState = FALSE;
#endif
					pciMSH26XInfo->Configuration.unBytesPerSecond = 1664;
					if (((DWORD) ICSetState(hIC, (PVOID)pciMSH26XInfo, dw)) != dw)
					{
						ERRORMESSAGE(("vcmStreamOpen: ICSetState() failed\r\n"));
						mmr = (MMRESULT)VCMERR_FAILED;
						goto MyExit5;
					}

					// Get rid of the state structure
					MemFree((HANDLE)pvState);
				}
#ifdef USE_MPEG4_SCRUNCH
				else if ((pvfxDst->bih.biCompression == VIDEO_FORMAT_MPEG4_SCRUNCH))
				{
					pciMPEG4Info = (PMPEG4COMPINSTINFO)pvState;

					// Configure the codec for compression
					pciMPEG4Info->lMagic = MPG4_STATE_MAGIC;
					pciMPEG4Info->dDataRate = 20;
					pciMPEG4Info->lCrisp = CRISP_DEF;
					pciMPEG4Info->lKeydist = 30;
					pciMPEG4Info->lPScale = MPG4_PSEUDO_SCALE;
					pciMPEG4Info->lTotalWindowMs = MPG4_TOTAL_WINDOW_DEFAULT;
					pciMPEG4Info->lVideoWindowMs = MPG4_VIDEO_WINDOW_DEFAULT;
					pciMPEG4Info->lFramesInfoValid = FALSE;
					pciMPEG4Info->lBFrameOn = MPG4_B_FRAME_ON;
					pciMPEG4Info->lLiveEncode = MPG4_LIVE_ENCODE;
					if (((DWORD) ICSetState(hIC, (PVOID)pciMPEG4Info, dw)) != dw)
					{
						ERRORMESSAGE(("vcmStreamOpen: ICSetState() failed\r\n"));
						mmr = (MMRESULT)VCMERR_FAILED;
						goto MyExit5;
					}

					// Get rid of the state structure
					MemFree((HANDLE)pvState);
				}
#endif

				// Initialize ICCOMPRESSFRAMES structure
				iccf.dwFlags = icInfo.dwFlags;
				((PVCMSTREAM)(*phvs))->dwQuality = dwImageQuality;
				iccf.lQuality = 10000UL - (dwImageQuality * 322UL);
				iccf.lDataRate = 1664;			// Look into this...
				iccf.lKeyRate = LONG_MAX;
				iccf.dwRate = 1000UL;
#ifdef USE_MPEG4_SCRUNCH
				iccf.dwScale = 142857;
#else
				iccf.dwScale = pvfxDst->dwRequestMicroSecPerFrame / 1000UL;
#endif
				((PVCMSTREAM)(*phvs))->dwTargetFrameRate = iccf.dwScale;
				((PVCMSTREAM)(*phvs))->dwTargetByterate = iccf.lDataRate;

				// Send this guy to the compressor
				if ((mmr = ICSendMessage(hIC, ICM_COMPRESS_FRAMES_INFO, (DWORD_PTR)&iccf, sizeof(iccf)) != ICERR_OK))
				{
					ERRORMESSAGE(("vcmStreamOpen: Codec failed to handle ICM_COMPRESS_FRAMES_INFO message correctly\r\n"));
					mmr = (MMRESULT)VCMERR_FAILED;
					goto MyExit4;
				}

				// Start the compressor/decompressor with the right format
				if ((dw = ICCompressGetFormatSize(hIC, &pvfxSrc->bih) < sizeof(BITMAPINFOHEADER)))
				{
					ERRORMESSAGE(("vcmStreamOpen: Codec failed to answer request for compressed format size\r\n"));
					mmr = (MMRESULT)VCMERR_FAILED;
					goto MyExit4;
				}

				// BUG_BUG: Where has pvfxDst been re-allocated ???
				if ((dw = (DWORD)ICCompressGetFormat(hIC, &pvfxSrc->bih, &pvfxD->bih)) != ICERR_OK)
				{
					ERRORMESSAGE(("vcmStreamOpen: Codec failed to answer request for compressed format\r\n"));
					mmr = (MMRESULT)VCMERR_FAILED;
					goto MyExit4;
				}

				if ((mmr = (MMRESULT)ICCompressBegin(hIC, &pvfxSrc->bih, &pvfxD->bih)) != MMSYSERR_NOERROR)
				{
					ERRORMESSAGE(("vcmStreamOpen: Codec failed to start\r\n"));
					mmr = (MMRESULT)VCMERR_FAILED;
					goto MyExit4;
				}

				DEBUGMSG (1, ("vcmStreamOpen: Opening %.4s compression stream\r\n", (LPSTR)&pvfxDst->bih.biCompression));

				// Update the passed destination video format. The caller really needs to use
				// that information to allocate the buffer sizes appropriately.
				CopyMemory(pvfxDst, pvfxD, sizeof(VIDEOFORMATEX));

				// Here, you can probably get the size of the compressed frames and update the destination format
				// with the real size of the compressed video buffer so that the DP can allocate the right set
				// of video buffers.

			}
			else if ((dwFlags == ICMODE_DECOMPRESS) || (dwFlags == ICMODE_FASTDECOMPRESS))
			{
				if (mmr = ICDecompressBegin(hIC, &pvfxSrc->bih, &pvfxDst->bih) != MMSYSERR_NOERROR)
				{
					ERRORMESSAGE(("vcmStreamOpen: Codec failed to start\r\n"));
					mmr = (MMRESULT)VCMERR_FAILED;
					goto MyExit4;
				}

				DEBUGMSG (1, ("vcmStreamOpen: Opening %.4s decompression stream\r\n", (LPSTR)&pvfxSrc->bih.biCompression));

#ifndef _ALPHA_
#ifdef USE_BILINEAR_MSH26X
				if ((pvfxSrc->bih.biCompression == VIDEO_FORMAT_MSH263) || (pvfxSrc->bih.biCompression == VIDEO_FORMAT_MSH261) || (pvfxSrc->bih.biCompression == VIDEO_FORMAT_MSH26X))
#else
				if ((pvfxSrc->bih.biCompression == VIDEO_FORMAT_MSH263) || (pvfxSrc->bih.biCompression == VIDEO_FORMAT_MSH261))
#endif
#else
				if ((pvfxSrc->bih.biCompression == VIDEO_FORMAT_DECH263) || (pvfxSrc->bih.biCompression == VIDEO_FORMAT_DECH261))
#endif
					vcmStreamMessage(*phvs, CUSTOM_ENABLE_CODEC, G723MAGICWORD1, G723MAGICWORD2);
			}

		}

#ifdef LOGFILE_ON
		if ((dwFlags == ICMODE_COMPRESS) || (dwFlags == ICMODE_FASTCOMPRESS))
		{
			if ((g_CompressLogFile = CreateFile("C:\\VCMCLog.txt", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL)) != INVALID_HANDLE_VALUE)
			{
    			GetLocalTime(&g_SystemTime);
				wsprintf(g_szCompressBuffer, "Date %hu/%hu/%hu, Time %hu:%hu\r\n", g_SystemTime.wMonth, g_SystemTime.wDay, g_SystemTime.wYear, g_SystemTime.wHour, g_SystemTime.wMinute);
				WriteFile(g_CompressLogFile, g_szCompressBuffer, strlen(g_szCompressBuffer), &g_dwCompressBytesWritten, NULL);
				wsprintf(g_szCompressBuffer, "Frame#\t\tSize\t\tArrival Time\t\tCompression Time\r\n");
				WriteFile(g_CompressLogFile, g_szCompressBuffer, strlen(g_szCompressBuffer), &g_dwCompressBytesWritten, NULL);
				CloseHandle(g_CompressLogFile);
			}
		}
		else if ((dwFlags == ICMODE_DECOMPRESS) || (dwFlags == ICMODE_FASTDECOMPRESS))
		{
			if ((g_DecompressLogFile = CreateFile("C:\\VCMDLog.txt", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL)) != INVALID_HANDLE_VALUE)
			{
    			GetLocalTime(&g_SystemTime);
				wsprintf(g_szDecompressBuffer, "Date %hu/%hu/%hu, Time %hu:%hu\r\n", g_SystemTime.wMonth, g_SystemTime.wDay, g_SystemTime.wYear, g_SystemTime.wHour, g_SystemTime.wMinute);
				WriteFile(g_DecompressLogFile, g_szDecompressBuffer, strlen(g_szDecompressBuffer), &g_dwDecompressBytesWritten, NULL);
				wsprintf(g_szDecompressBuffer, "Frame#\t\tSize\t\tArrival Time\t\tDecompression Time\r\n");
				WriteFile(g_DecompressLogFile, g_szDecompressBuffer, strlen(g_szDecompressBuffer), &g_dwDecompressBytesWritten, NULL);
				CloseHandle(g_DecompressLogFile);
			}
		}
#endif

		return ((MMRESULT)MMSYSERR_NOERROR);

	}
	else
		return ((MMRESULT)VCMERR_NOTPOSSIBLE);

MyExit5:
	if (pvState)
		MemFree(pvState);
MyExit4:
	if (pbmiPrev)
		MemFree(pbmiPrev);
MyExit3:
	if (pvfxD)
		MemFree(pvfxD);
MyExit2:
	if (pvfxS)
		MemFree(pvfxS);
MyExit1:
	if ((dwFlags == ICMODE_COMPRESS) || (dwFlags == ICMODE_FASTCOMPRESS))	// Hmmm... where could you have set the second mode?
		DeleteCriticalSection(&(((PVCMSTREAM)(*phvs))->crsFrameNumber));
	if (*phvs)
		MemFree(*phvs);
	*phvs = (HVCMSTREAM)(PVCMSTREAM)NULL;
MyExit0:
	return (mmr);

}


/****************************************************************************
 *  @doc EXTERNAL COMPFUNC
 *
 *  @func MMRESULT | vcmStreamClose | The vcmStreamClose function closes a previously
 *      opened Video Compression Manager (VCM) conversion stream. If the function is
 *      successful, the handle is invalidated.
 *
 *  @parm HVCMSTREAM | hvs | Identifies the open conversion stream to be closed.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag VCMERR_BUSY | The conversion stream cannot be closed because
 *      an asynchronous conversion is still in progress.
 *
 *  @xref <f vcmStreamOpen> <f vcmStreamReset>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamClose(HVCMSTREAM hvs)
{
	PVCMSTREAM	pvs = (PVCMSTREAM)hvs;
#ifdef LOGFILE_ON
	DWORD		i;
#endif

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamClose: Specified HVCMSTREAM handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}

	// Stop the compressor/decompressor
	if ((pvs->fdwStream == ICMODE_COMPRESS) || (pvs->fdwStream == ICMODE_FASTCOMPRESS))
	{
#ifdef LOGFILE_ON
		g_OrigCompressTime = GetTickCount() - g_OrigCompressTime;
		if (pvs->dwFrame)
		{
			for (i=0, g_AvgCompressTime=0; i<pvs->dwFrame && i<4096; i++)
				g_AvgCompressTime += g_aCompressTime[i];
			g_AvgCompressTime /= i;
		}
		if ((g_CompressLogFile = CreateFile("C:\\VCMCLog.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL)) != INVALID_HANDLE_VALUE)
		{
			SetFilePointer(g_CompressLogFile, 0, NULL, FILE_END);
			if (pvs->dwFrame)
			{
				wsprintf(g_szCompressBuffer, "Frames/s\tAvg. Comp. Time\r\n");
				WriteFile(g_CompressLogFile, g_szCompressBuffer, strlen(g_szCompressBuffer), &g_dwCompressBytesWritten, NULL);
				wsprintf(g_szCompressBuffer, "%04d\t\t%03d\r\n", pvs->dwFrame * 1000 / g_OrigCompressTime, g_AvgCompressTime);
				WriteFile(g_CompressLogFile, g_szCompressBuffer, strlen(g_szCompressBuffer), &g_dwCompressBytesWritten, NULL);
			}
			else
			{
				wsprintf(g_szCompressBuffer, "No frames were compressed!");
				WriteFile(g_CompressLogFile, g_szCompressBuffer, strlen(g_szCompressBuffer), &g_dwCompressBytesWritten, NULL);
			}
			CloseHandle(g_CompressLogFile);
		}
#endif
		if (ICCompressEnd((HIC)pvs->hIC) != MMSYSERR_NOERROR)
		{
			ERRORMESSAGE(("vcmStreamClose: Codec failed to stop\r\n"));
			return ((MMRESULT)VCMERR_FAILED);
		}
	}
	else if ((pvs->fdwStream == ICMODE_DECOMPRESS) || (pvs->fdwStream == ICMODE_FASTDECOMPRESS))
	{
#ifdef LOGFILE_ON
		g_OrigDecompressTime = GetTickCount() - g_OrigDecompressTime;
		if (pvs->dwFrame)
		{
			for (i=0, g_AvgDecompressTime=0; i<pvs->dwFrame && i<4096; i++)
				g_AvgDecompressTime += g_aDecompressTime[i];
			g_AvgDecompressTime /= i;
		}
		if ((g_DecompressLogFile = CreateFile("C:\\VCMDLog.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL)) != INVALID_HANDLE_VALUE)
		{
			SetFilePointer(g_DecompressLogFile, 0, NULL, FILE_END);
			if (pvs->dwFrame)
			{
				wsprintf(g_szDecompressBuffer, "Frames/s\tAvg. Decomp. Time\r\n");
				WriteFile(g_DecompressLogFile, g_szDecompressBuffer, strlen(g_szDecompressBuffer), &g_dwDecompressBytesWritten, NULL);
				wsprintf(g_szDecompressBuffer, "%04d\t\t%03d\r\n", pvs->dwFrame * 1000 / g_OrigDecompressTime, g_AvgDecompressTime);
				WriteFile(g_DecompressLogFile, g_szDecompressBuffer, strlen(g_szDecompressBuffer), &g_dwDecompressBytesWritten, NULL);
			}
			else
			{
				wsprintf(g_szDecompressBuffer, "No frames were decompressed!");
				WriteFile(g_DecompressLogFile, g_szDecompressBuffer, strlen(g_szDecompressBuffer), &g_dwDecompressBytesWritten, NULL);
			}
			CloseHandle(g_DecompressLogFile);
		}
#endif
		if (ICDecompressEnd((HIC)pvs->hIC) != MMSYSERR_NOERROR)
		{
			ERRORMESSAGE(("vcmStreamClose: Codec failed to stop\r\n"));
			return ((MMRESULT)VCMERR_FAILED);
		}
	}

	// Close compressor/decompressor
	if (pvs->hIC)
		ICClose((HIC)pvs->hIC);

	// Nuke critical section
	if ((pvs->fdwStream == ICMODE_COMPRESS) || (pvs->fdwStream == ICMODE_FASTCOMPRESS))
		DeleteCriticalSection(&pvs->crsFrameNumber);

	// Free video format buffers
	if (pvs->pvfxSrc)
		MemFree(pvs->pvfxSrc);
	if (pvs->pvfxDst)
		MemFree(pvs->pvfxDst);
	if (pvs->pbmiPrev)
		MemFree(pvs->pbmiPrev);

	// Free main VCM structure
	MemFree(pvs);
	
	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 *  @doc EXTERNAL COMPFUNC
 *
 *  @func MMRESULT | vcmStreamSize | The vcmStreamSize function returns a recommended size for a
 *      source or destination buffer on an Video Compression Manager (VCM)
 *      stream.
 *
 *  @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 *  @parm DWORD | cbInput | Specifies the size in bytes of either the source
 *      or destination buffer. The <p fdwSize> flags specify what the
 *      input argument defines. This argument must be non-zero.
 *
 *  @parm LPDWORD | pdwOutputBytes | Specifies a pointer to a <t DWORD>
 *      that contains the size in bytes of the source or destination buffer.
 *      The <p fdwSize> flags specify what the output argument defines.
 *      If the <f vcmStreamSize> function succeeds, this location will
 *      always be filled with a non-zero value.
 *
 *  @parm DWORD | fdwSize | Specifies flags for the stream-size query.
 *
 *      @flag VCM_STREAMSIZEF_SOURCE | Indicates that <p cbInput> contains
 *      the size of the source buffer. The <p pdwOutputBytes> argument will
 *      receive the recommended destination buffer size in bytes.
 *
 *      @flag VCM_STREAMSIZEF_DESTINATION | Indicates that <p cbInput>
 *      contains the size of the destination buffer. The <p pdwOutputBytes>
 *      argument will receive the recommended source buffer size in bytes.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *      @flag VCMERR_NOTPOSSIBLE | The requested operation cannot be performed.
 *
 *  @comm An application can use the <f vcmStreamSize> function to determine
 *      suggested buffer sizes for either source or destination buffers.
 *      The buffer sizes returned might be only an estimation of the
 *      actual sizes required for conversion. Because actual conversion
 *      sizes cannot always be determined without performing the conversion,
 *      the sizes returned will usually be overestimated.
 *
 *      In the event of an error, the location pointed to by
 *      <p pdwOutputBytes> will receive zero. This assumes that the pointer
 *      specified by <p pdwOutputBytes> is valid.
 *
 *  @xref <f vcmStreamPrepareHeader> <f vcmStreamConvert>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamSize(HVCMSTREAM hvs, DWORD cbInput, PDWORD pdwOutputBytes, DWORD fdwSize)
{
	PVCMSTREAM  pvs = (PVCMSTREAM)hvs;
	DWORD    dwNumFrames;

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamSize: Specified HVCMSTREAM handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}

	// Do the math
	switch (VCM_STREAMSIZEF_QUERYMASK & fdwSize)
	{
		case VCM_STREAMSIZEF_SOURCE:
			if (pvs->pvfxSrc->dwFormatTag != VIDEO_FORMAT_BI_RGB)
			{
				// How many destination RGB bytes are needed to hold the decoded source
				// buffer of cbInput compressed bytes
				if (!(dwNumFrames = cbInput / pvs->pvfxSrc->nBlockAlign))
				{
					ERRORMESSAGE(("vcmStreamSize: The requested operation cannot be performed\r\n"));
					return ((MMRESULT)VCMERR_NOTPOSSIBLE);
				}
				else
					*pdwOutputBytes = dwNumFrames * pvs->pvfxDst->nBlockAlign;
			}
			else
			{
				// How many destination compressed bytes are needed to hold the encoded	source
				// buffer of cbInput RGB bytes
				if (!(dwNumFrames = cbInput / pvs->pvfxSrc->nBlockAlign))
				{
					ERRORMESSAGE(("vcmStreamSize: The requested operation cannot be performed\r\n"));
					return ((MMRESULT)VCMERR_NOTPOSSIBLE);
				}
				else
				{
					if (cbInput % pvs->pvfxSrc->nBlockAlign)
						dwNumFrames++;
					*pdwOutputBytes = dwNumFrames * pvs->pvfxDst->nBlockAlign;
				}
			}
			return ((MMRESULT)MMSYSERR_NOERROR);

		case VCM_STREAMSIZEF_DESTINATION:
			if (pvs->pvfxDst->dwFormatTag != VIDEO_FORMAT_BI_RGB)
			{
				// How many source RGB bytes can be encoded into a destination buffer
				// of cbInput bytes
				if (!(dwNumFrames = cbInput / pvs->pvfxDst->nBlockAlign))
				{
					ERRORMESSAGE(("vcmStreamSize: The requested operation cannot be performed\r\n"));
					return ((MMRESULT)VCMERR_NOTPOSSIBLE);
				}
				else
					*pdwOutputBytes = dwNumFrames * pvs->pvfxSrc->nBlockAlign;
			}
			else
			{
				// How many source encoded bytes can be decoded into a destination buffer
				// of cbInput RGB bytes
				if (!(dwNumFrames = cbInput / pvs->pvfxDst->nBlockAlign))
				{
					ERRORMESSAGE(("vcmStreamSize: The requested operation cannot be performed\r\n"));
					return ((MMRESULT)VCMERR_NOTPOSSIBLE);
				}
				else
					*pdwOutputBytes = dwNumFrames * pvs->pvfxSrc->nBlockAlign;
			}
			return ((MMRESULT)MMSYSERR_NOERROR);

		default:
					ERRORMESSAGE(("vcmStreamSize: One or more flags are invalid\r\n"));
			return ((MMRESULT)MMSYSERR_NOTSUPPORTED);
	}

}


/****************************************************************************
 *  @doc EXTERNAL COMPFUNC
 *
 *  @func MMRESULT | vcmStreamReset | The vcmStreamReset function stops conversions
 *      for a given Video Compression Manager (VCM) stream. All pending
 *      buffers are marked as done and returned to the application.
 *
 *  @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *  @comm Resetting a VCM conversion stream is only necessary to reset
 *      asynchronous conversion streams. However, resetting a synchronous
 *      conversion stream will succeed, but no action will be taken.
 *
 *  @xref <f vcmStreamConvert> <f vcmStreamClose>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamReset(HVCMSTREAM hvs)
{
	PVCMSTREAM        pvs = (PVCMSTREAM)hvs;
	PVCMSTREAMHEADER  pvsh;

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmSreamReset: Specified HVCMSTREAM handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}

	while (pvsh = DeQueVCMHeader(pvs))
	{
		MarkVCMHeaderDone(pvsh);
		// Look into how this would be best handled
		// What if the capture driver sends us those exact same
		// messages for its own buffers?

		// Test for the validity of the callback before doing this...
		switch (pvs->fdwOpen)
		{
			case CALLBACK_FUNCTION:
				(*(VCMSTREAMPROC)pvs->dwCallback)(hvs, VCM_DONE, pvs->dwCallbackInstance, (DWORD_PTR)pvsh, 0);
				break;

			case CALLBACK_EVENT:
				SetEvent((HANDLE)pvs->dwCallback);
				break;

			case CALLBACK_WINDOW:
				PostMessage((HWND)pvs->dwCallback, MM_VCM_DONE, (WPARAM)hvs, (LPARAM)pvsh);
				break;

			case CALLBACK_THREAD:
				PostThreadMessage((DWORD)pvs->dwCallback, MM_VCM_DONE, (WPARAM)hvs, (LPARAM)pvsh);
				break;

			case CALLBACK_NULL:
				break;

			default:
				break;
		}
	}

	pvs->pvhFirst = NULL;
	pvs->pvhLast = NULL;

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 *  @doc EXTERNAL COMPFUNC
 *
 *  @func MMRESULT | vcmStreamMessage | This function sends a user-defined
 *      message to a given Video Compression Manager (VCM) stream instance.
 *
 *  @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 *  @parm UINT | uMsg | Specifies the message that the VCM stream must
 *      process. This message must be in the <m VCMDM_USER> message range
 *      (above or equal to <m VCMDM_USER> and less than
 *      <m VCMDM_RESERVED_LOW>). The exception to this restriction is
 *      the <m VCMDM_STREAM_UPDATE> message.
 *
 *  @parm LPARAM | lParam1 | Specifies the first message parameter.
 *
 *  @parm LPARAM | lParam2 | Specifies the second message parameter.
 *
 *  @rdesc The return value is specific to the user-defined VCM driver
 *      message <p uMsg> sent. However, the following return values are
 *      possible:
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *      @flag MMSYSERR_INVALPARAM | <p uMsg> is not in the VCMDM_USER range.
 *      @flag MMSYSERR_NOTSUPPORTED | The VCM driver did not process the message.
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamMessage(HVCMSTREAM hvs, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
{
	PVCMSTREAM	pvs = (PVCMSTREAM)hvs;

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamMessage: Specified HVCMSTREAM handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}

	// Check input params
	if ((uMsg > VCMDM_RESERVED_HIGH) || (uMsg < VCMDM_RESERVED_LOW))
	{
		ERRORMESSAGE(("vcmStreamMessage: Specified message is out of range, uMsg=0x%lX (expected value is between 0x%lX and 0x%lX)\r\n", uMsg, VCMDM_RESERVED_LOW, VCMDM_RESERVED_HIGH));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Send the message to the codec.
	if (pvs->hIC)
		if (ICSendMessage((HIC)(HVCMDRIVERID)pvs->hIC, uMsg, lParam1, lParam2) != ICERR_OK)
		{
			ERRORMESSAGE(("vcmStreamMessage: Codec failed to handle user-defined message correctly\r\n"));
			return ((MMRESULT)MMSYSERR_NOTSUPPORTED);
		}

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 *  @doc EXTERNAL COMPFUNC
 *
 *  @func MMRESULT | vcmStreamConvert | The vcmStreamConvert function requests the Video
 *      Compression Manager (VCM) to perform a conversion on the specified conversion stream. A
 *      conversion may be synchronous or asynchronous depending on how the
 *      stream was opened.
 *
 *  @parm HVCMSTREAM | has | Identifies the open conversion stream.
 *
 *  @parm PVCMSTREAMHEADER | pash | Specifies a pointer to a stream header
 *      that describes source and destination buffers for a conversion. This
 *      header must have been prepared previously using the
 *      <f vcmStreamPrepareHeader> function.
 *
 *  @parm  DWORD | fdwConvert | Specifies flags for doing the conversion.
 *
 *      @flag VCM_STREAMCONVERTF_BLOCKALIGN | Specifies that only integral
 *      numbers of blocks will be converted. Converted data will end on
 *      block aligned boundaries. An application should use this flag for
 *      all conversions on a stream until there is not enough source data
 *      to convert to a block-aligned destination. In this case, the last
 *      conversion should be specified without this flag.
 *
 *      @flag VCM_STREAMCONVERTF_START | Specifies that the VCM conversion
 *      stream should reinitialize its instance data. For example, if a
 *      conversion stream holds instance data, such as delta or predictor
 *      information, this flag will restore the stream to starting defaults.
 *      Note that this flag can be specified with the VCM_STREAMCONVERTF_END
 *      flag.
 *
 *      @flag VCM_STREAMCONVERTF_END | Specifies that the VCM conversion
 *      stream should begin returning pending instance data. For example, if
 *      a conversion stream holds instance data, such as the tail end of an
 *      echo filter operation, this flag will cause the stream to start
 *      returning this remaining data with optional source data. Note that
 *      this flag can be specified with the VCM_STREAMCONVERTF_START flag.
 *
 *      @flag VCM_STREAMCONVERTF_FORCE_KEYFRAME | Specifies that the VCM conversion
 *      stream should compress the current frame as a key frame.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag VCMERR_BUSY | The stream header <p pash> is currently in use
 *      and cannot be reused.
 *
 *      @flag VCMERR_UNPREPARED | The stream header <p pash> is currently
 *      not prepared by the <f vcmStreamPrepareHeader> function.
 *
 *  @comm The source and destination data buffers must be prepared with
 *      <f vcmStreamPrepareHeader> before they are passed to <f vcmStreamConvert>.
 *
 *      If an asynchronous conversion request is successfully queued by
 *      the VCM or driver, and later the conversion is determined to
 *      be impossible, then the <t VCMSTREAMHEADER> will be posted back to
 *      the application's callback with the <e VCMSTREAMHEADER.cbDstLengthUsed>
 *      member set to zero.
 *
 *  @xref <f vcmStreamOpen> <f vcmStreamReset> <f vcmStreamPrepareHeader>
 *      <f vcmStreamUnprepareHeader>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamConvert(HVCMSTREAM hvs, PVCMSTREAMHEADER pvsh, DWORD fdwConvert)
{
	MMRESULT	mmr;
	PVCMSTREAM  pvs = (PVCMSTREAM)hvs;
	BOOL		fKeyFrame;
	BOOL		fTemporalCompress;
	BOOL		fFastTemporal;
    DWORD		dwMaxSizeThisFrame = 0xffffff;
	DWORD		ckid = 0UL;
	DWORD		dwFlags;
	DWORD		dwTimestamp;

#ifdef LOGFILE_ON
	if ((pvs->fdwStream == ICMODE_COMPRESS) || (pvs->fdwStream == ICMODE_FASTCOMPRESS))
		g_CompressTime = GetTickCount();
	else if ((pvs->fdwStream == ICMODE_DECOMPRESS) || (pvs->fdwStream == ICMODE_FASTDECOMPRESS))
		g_DecompressTime = GetTickCount();
#endif

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamConvert: Specified HVCMSTREAM handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}
	if (!pvsh)
	{
		ERRORMESSAGE(("vcmStreamConvert: Specified PVCMSTREAMHEADER pointer is invalid, pvsh=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}
	if (pvsh->cbStruct < sizeof(VCMSTREAMHEADER))
	{
		ERRORMESSAGE(("vcmStreamConvert: The size of the VCM stream header is invalid, pvsh->cbStruct=%ld (expected value is %ld)\r\n", pvsh->cbStruct, sizeof(VCMSTREAMHEADER)));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}

	// Return if buffer is already being converted
	if (IsVCMHeaderInQueue(pvsh))
	{
		ERRORMESSAGE(("vcmStreamConvert: Buffer is already being converted\r\n"));
		return ((MMRESULT)VCMERR_BUSY);
	}

	// Return if buffer has not been prepared
	if (!IsVCMHeaderPrepared(pvsh))
	{
		ERRORMESSAGE(("vcmStreamConvert: Buffer has not been prepared\r\n"));
		return ((MMRESULT)VCMERR_UNPREPARED);
	}

	// Set flags
	MarkVCMHeaderNotDone(pvsh);
	pvsh->cbSrcLengthUsed = pvsh->cbSrcLength;
	pvsh->cbDstLengthUsed = pvsh->cbDstLength;
	pvsh->cbPrevLengthUsed = pvsh->cbPrevLength;
	MarkVCMHeaderInQueue(pvsh);

	// Queue buffer
	pvsh->pNext = NULL;
	if (pvs->pvhLast)
		pvs->pvhLast->pNext = pvsh;
	else
		pvs->pvhFirst = pvsh;
	pvs->pvhLast = pvsh;

	if ((pvs->fdwStream == ICMODE_COMPRESS) || (pvs->fdwStream == ICMODE_FASTCOMPRESS))
	{
		// Save the current time
		dwTimestamp = GetTickCount();

		// We need the following crs to make sure we don't miss any of the I-Frame requests
		// emittted by the UI. Problematic scenario: pvs->dwFrame is at 123 for instance.
		// The UI thread requests an I-Frame by setting pvs->dwFrame to 0. If the capture/compression
		// thread was in ICCompress() (which is very probable since it takes quite some time
		// to compress a frame), pvs->dwFrame will be incremented by one when ICCompress()
		// returns. We failed to handle the I-Frame request correctly, since the next time
		// ICCompress() gets called pvs->dwFrame will be equal to 1, for which we do not
		// generate an I-Frame.
		EnterCriticalSection(&pvs->crsFrameNumber);

		// Compress
		fTemporalCompress = pvs->dwICInfoFlags & VIDCF_TEMPORAL;
		fFastTemporal = pvs->dwICInfoFlags & VIDCF_FASTTEMPORALC;
		fKeyFrame = !fTemporalCompress || (fTemporalCompress && !fFastTemporal && ((pvsh->pbPrev == (PBYTE)NULL) || (pvsh->cbPrevLength == (DWORD)NULL))) ||
				(pvs->fPeriodicIFrames && (((dwTimestamp > pvs->dwLastIFrameTime) && ((dwTimestamp - pvs->dwLastIFrameTime) > MIN_IFRAME_REQUEST_INTERVAL)))) || (pvs->dwFrame == 0) || (fdwConvert & VCM_STREAMCONVERTF_FORCE_KEYFRAME);
		dwFlags = fKeyFrame ? AVIIF_KEYFRAME : 0;
#if 0
		dwMaxSizeThisFrame = fKeyFrame ? 0xffffff : pvs->dwTargetFrameRate ? pvs->dwTargetByterate * pvs->dwTargetFrameRate / 1000UL : 0;
#else
		dwMaxSizeThisFrame = pvs->dwTargetFrameRate ? pvs->dwTargetByterate * 100UL / pvs->dwTargetFrameRate : 0;
#endif

		// We need to modify the frame number so that the codec can generate
		// a valid TR. TRs use MPIs as their units. So we need to generate a
		// frame number assuming a 29.97Hz capture rate, even though we will be
		// capturing at some other rate.
		if (pvs->dwLastTimestamp == ULONG_MAX)
		{
			// This is the first frame
			pvs->dwFrame = 0UL;

			// Save the current time
			pvs->dwLastTimestamp = dwTimestamp;

			// DEBUGMSG (ZONE_VCM, ("vcmStreamConvert: Last Timestamp = ULONG_MAX => Frame # = 0\r\n"));
		}
		else
		{
			// Compare the current timestamp to the last one we saved. The difference
			// will let us normalize the frame count to 29.97Hz.
			if (fKeyFrame)
			{
				pvs->dwFrame = 0UL;
				pvs->dwLastTimestamp = dwTimestamp;
			}
			else
				pvs->dwFrame = (dwTimestamp - pvs->dwLastTimestamp) * 2997 / 100000UL;

			// DEBUGMSG (ZONE_VCM, ("vcmStreamConvert: Last Timestamp = %ld => Frame # = %ld\r\n", pvs->dwLastTimestamp, pvs->dwFrame));
		}

		if (fKeyFrame)
		{
			pvs->dwLastIFrameTime = dwTimestamp;
			DEBUGMSG (ZONE_VCM, ("vcmStreamConvert: Generating an I-Frame...\r\n"));
		}

		mmr = ICCompress((HIC)pvs->hIC, fKeyFrame ? ICCOMPRESS_KEYFRAME : 0, (LPBITMAPINFOHEADER)&pvs->pvfxDst->bih, pvsh->pbDst, (LPBITMAPINFOHEADER)&pvs->pvfxSrc->bih, pvsh->pbSrc, &ckid, &dwFlags,
					pvs->dwFrame++, dwMaxSizeThisFrame, 10000UL - (pvs->dwQuality * 322UL), fKeyFrame | fFastTemporal ? NULL : (LPBITMAPINFOHEADER)&pvs->pbmiPrev, fKeyFrame | fFastTemporal ? NULL : pvsh->pbPrev);

		// Allow the UI to modify the frame number on its own thread
		LeaveCriticalSection(&pvs->crsFrameNumber);

		if (mmr != MMSYSERR_NOERROR)
		{
#ifdef LOGFILE_ON
			if (pvs->dwFrame < 4096)
			{
				if (pvs->dwFrame ==1)
					g_OrigCompressTime = g_CompressTime;
				g_aCompressTime[pvs->dwFrame-1] = g_CompressTime = GetTickCount() - g_CompressTime;
				if ((g_CompressLogFile = CreateFile("C:\\VCMCLog.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL)) != INVALID_HANDLE_VALUE)
				{
					SetFilePointer(g_CompressLogFile, 0, NULL, FILE_END);
					wsprintf(g_szCompressBuffer, "%04d\t\t%08d\t\t.o0Failed!0o.\r\n", pvs->dwFrame-1, g_OrigCompressTime);
					WriteFile(g_CompressLogFile, g_szCompressBuffer, strlen(g_szCompressBuffer), &g_dwCompressBytesWritten, NULL);
					CloseHandle(g_CompressLogFile);
				}
			}
#endif
			ERRORMESSAGE(("vcmStreamConvert: ICCompress() failed, mmr=%ld\r\n", mmr));
			// Get the handle to the video device associated to the capture window
			pvsh = DeQueVCMHeader(pvs);
			MarkVCMHeaderDone(pvsh);

			return ((MMRESULT)VCMERR_FAILED);
		}

		pvsh->cbDstLengthUsed = pvs->pvfxDst->bih.biSizeImage;

		if ((fTemporalCompress) && (!fFastTemporal))
		{
			if (!pvsh->pbPrev)
				pvsh->pbPrev = (PBYTE)MemAlloc(pvs->pvfxSrc->bih.biSizeImage);

			if (pvsh->pbPrev)
			{
				// What about fast temporal?
				if (mmr = ICDecompress((HIC)pvs->hIC, 0, (LPBITMAPINFOHEADER)&pvs->pvfxDst->bih, pvsh->pbDst, (LPBITMAPINFOHEADER)&pvs->pvfxSrc->bih, pvsh->pbPrev) != MMSYSERR_NOERROR)
				{
					ERRORMESSAGE(("vcmStreamConvert: ICCompress() failed, mmr=%ld\r\n", mmr));
					// Get the handle to the video device associated to the capture window
	                pvsh = DeQueVCMHeader(pvs);
	                MarkVCMHeaderDone(pvsh);
					return ((MMRESULT)VCMERR_FAILED); // Do we really want to quit?
				}
			}
		}
	}
	else if ((pvs->fdwStream == ICMODE_DECOMPRESS) || (pvs->fdwStream == ICMODE_FASTDECOMPRESS))
	{
		// Decompress
		pvs->dwFrame++;

		pvs->pvfxSrc->bih.biSizeImage = pvsh->cbSrcLength;

		if (mmr = ICDecompress((HIC)pvs->hIC, 0, (LPBITMAPINFOHEADER)&pvs->pvfxSrc->bih, pvsh->pbSrc, (LPBITMAPINFOHEADER)&pvs->pvfxDst->bih, pvsh->pbDst) != MMSYSERR_NOERROR)
		{
#ifdef LOGFILE_ON
			if (pvs->dwFrame < 4096)
			{
				if (pvs->dwFrame ==1)
					g_OrigDecompressTime = g_DecompressTime;
				g_aDecompressTime[pvs->dwFrame-1] = g_DecompressTime = GetTickCount() - g_DecompressTime;
				if ((g_DecompressLogFile = CreateFile("C:\\VCMDLog.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL)) != INVALID_HANDLE_VALUE)
				{
					SetFilePointer(g_DecompressLogFile, 0, NULL, FILE_END);
					wsprintf(g_szDecompressBuffer, "%04d\t\t%08d\t\t.o0Failed!0o.\r\n", pvs->dwFrame-1, g_OrigDecompressTime);
					WriteFile(g_DecompressLogFile, g_szDecompressBuffer, strlen(g_szDecompressBuffer), &g_dwDecompressBytesWritten, NULL);
					CloseHandle(g_DecompressLogFile);
				}
			}
#endif
			ERRORMESSAGE(("vcmStreamConvert: ICDecompress() failed, mmr=%ld\r\n", mmr));
			// Get the handle to the video device associated to the capture window
			pvsh = DeQueVCMHeader(pvs);
			MarkVCMHeaderDone(pvsh);
			return ((MMRESULT)VCMERR_FAILED);
		}

	}

#ifdef LOGFILE_ON
	if (pvs->dwFrame < 4096)
	{
		if ((pvs->fdwStream == ICMODE_COMPRESS) || (pvs->fdwStream == ICMODE_FASTCOMPRESS))
		{
			if (pvs->dwFrame == 1)
				g_OrigCompressTime = g_CompressTime;
			g_aCompressTime[pvs->dwFrame-1] = g_CompressTime = GetTickCount() - g_CompressTime;
			if ((g_CompressLogFile = CreateFile("C:\\VCMCLog.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL)) != INVALID_HANDLE_VALUE)
			{
				SetFilePointer(g_CompressLogFile, 0, NULL, FILE_END);
				wsprintf(g_szCompressBuffer, "%04d\t\t%08d\t\t%05d\t\t%03d\r\n", pvs->dwFrame-1, g_OrigCompressTime, pvs->pvfxDst->bih.biSizeImage, g_CompressTime);
				WriteFile(g_CompressLogFile, g_szCompressBuffer, strlen(g_szCompressBuffer), &g_dwCompressBytesWritten, NULL);
				CloseHandle(g_CompressLogFile);
			}
		}
		else if ((pvs->fdwStream == ICMODE_DECOMPRESS) || (pvs->fdwStream == ICMODE_FASTDECOMPRESS))
		{
			if (pvs->dwFrame == 1)
				g_OrigDecompressTime = g_DecompressTime;
			g_aDecompressTime[pvs->dwFrame-1] = g_DecompressTime = GetTickCount() - g_DecompressTime;
			if ((g_DecompressLogFile = CreateFile("C:\\VCMDLog.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL)) != INVALID_HANDLE_VALUE)
			{
				SetFilePointer(g_DecompressLogFile, 0, NULL, FILE_END);
				wsprintf(g_szDecompressBuffer, "%04d\t\t%08d\t\t%05d\t\t%03d\r\n", pvs->dwFrame-1, g_OrigDecompressTime, pvs->pvfxDst->bih.biSizeImage, g_DecompressTime);
				WriteFile(g_DecompressLogFile, g_szDecompressBuffer, strlen(g_szDecompressBuffer), &g_dwDecompressBytesWritten, NULL);
				CloseHandle(g_DecompressLogFile);
			}
		}
	}
#endif

	// Get the handle to the video device associated to the capture window
	pvsh = DeQueVCMHeader(pvs);
	MarkVCMHeaderDone(pvsh);

	// Test for the validity of the callback before doing this...
	switch (pvs->fdwOpen)
	{
		case CALLBACK_FUNCTION:
			(*(VCMSTREAMPROC)pvs->dwCallback)(hvs, VCM_DONE, pvs->dwCallbackInstance, (DWORD_PTR)pvsh, 0);
			break;

		case CALLBACK_EVENT:
			SetEvent((HANDLE)pvs->dwCallback);
			break;

		case CALLBACK_WINDOW:
			PostMessage((HWND)pvs->dwCallback, MM_VCM_DONE, (WPARAM)hvs, (LPARAM)pvsh);
			break;

		case CALLBACK_THREAD:
			PostThreadMessage((DWORD)pvs->dwCallback, MM_VCM_DONE, (WPARAM)hvs, (LPARAM)pvsh);
			break;

		case CALLBACK_NULL:
		default:
			break;
	}

	return ((MMRESULT)MMSYSERR_NOERROR);

}


/****************************************************************************
 *  @doc EXTERNAL COMPFUNC
 *
 *  @func MMRESULT | vcmStreamPrepareHeader | The vcmStreamPrepareHeader
 * function prepares an <t VCMSTREAMHEADER> for an Video Compression
 * Manager (VCM) stream conversion. This function must be called for
 * every stream header before it can be used in a conversion stream. An
 * application only needs to prepare a stream header once for the life of
 * a given stream; the stream header can be reused as long as the same
 * source and destiniation buffers are used, and the size of the source
 * and destination buffers do not exceed the sizes used when the stream
 * header was originally prepared.
 *
 *  @parm HVCMSTREAM | has | Specifies a handle to the conversion steam.
 *
 *  @parm PVCMSTREAMHEADER | pash | Specifies a pointer to an <t VCMSTREAMHEADER>
 *      structure that identifies the source and destination data buffers to
 *      be prepared.
 *
 *  @parm DWORD | fdwPrepare | This argument is not used and must be set to
 *      zero.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_NOMEM | Unable to allocate resources.
 *
 *  @comm Preparing a stream header that has already been prepared has no
 *      effect, and the function returns zero. However, an application should
 *      take care to structure code so multiple prepares do not occur.
 *
 *  @xref <f vcmStreamUnprepareHeader> <f vcmStreamOpen>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamPrepareHeader(HVCMSTREAM hvs, PVCMSTREAMHEADER pvsh, DWORD fdwPrepare)
{
	MMRESULT mmr = (MMRESULT)MMSYSERR_NOERROR;

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamPrepareHeader: Specified handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}
	if (!pvsh)
	{
		ERRORMESSAGE(("vcmStreamPrepareHeader: Specified pointer is invalid, pvsh=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}

	// Return if buffer has already been prepared
	if (IsVCMHeaderPrepared(pvsh))
	{
		ERRORMESSAGE(("vcmStreamPrepareHeader: Buffer has already been prepared\r\n"));
		return (mmr);
	}

#ifdef REALLY_LOCK
	// Lock the buffers
	if (!VirtualLock(pvsh, (DWORD)sizeof(VCMSTREAMHEADER)))
	{
		ERRORMESSAGE(("vcmStreamPrepareHeader: VirtualLock() failed\r\n"));
		mmr = (MMRESULT)MMSYSERR_NOMEM;
	}
	else
	{
		if (!VirtualLock(pvsh->pbSrc, pvsh->cbSrcLength))
		{
			ERRORMESSAGE(("vcmStreamPrepareHeader: VirtualLock() failed\r\n"));
			VirtualUnlock(pvsh, (DWORD)sizeof(VCMSTREAMHEADER));
			mmr = (MMRESULT)MMSYSERR_NOMEM;
		}
		else
		{
			if (!VirtualLock(pvsh->pbDst, pvsh->cbDstLength))
			{
				ERRORMESSAGE(("vcmStreamPrepareHeader: VirtualLock() failed\r\n"));
				VirtualUnlock(pvsh->pbSrc, pvsh->cbSrcLength);
				VirtualUnlock(pvsh, (DWORD)sizeof(VCMSTREAMHEADER));
				mmr = (MMRESULT)MMSYSERR_NOMEM;
			}
		}
	}
#endif

	// Update flag
	if (mmr == MMSYSERR_NOERROR)
		MarkVCMHeaderPrepared(pvsh);

	return (mmr);
}


/****************************************************************************
 *  @doc EXTERNAL COMPFUNC
 *
 *  @func MMRESULT | vcmStreamUnprepareHeader | The vcmStreamUnprepareHeader function
 *      cleans up the preparation performed by the <f vcmStreamPrepareHeader>
 *      function for an Video Compression Manager (VCM) stream. This function must
 *      be called after the VCM is finished with the given buffers. An
 *      application must call this function before freeing the source and
 *      destination buffers.
 *
 *  @parm HVCMSTREAM | has | Specifies a handle to the conversion steam.
 *
 *  @parm PVCMSTREAMHEADER | pash | Specifies a pointer to an <t VCMSTREAMHEADER>
 *      structure that identifies the source and destination data buffers to
 *      be unprepared.
 *
 *  @parm DWORD | fdwUnprepare | This argument is not used and must be set to
 *      zero.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *      @flag VCMERR_BUSY | The stream header <p pash> is currently in use
 *      and cannot be unprepared.
 *      @flag VCMERR_UNPREPARED | The stream header <p pash> was
 *      not prepared by the <f vcmStreamPrepareHeader> function.
 *
 *  @comm Unpreparing a stream header that has already been unprepared is
 *      an error. An application must specify the source and destination
 *      buffer lengths (<e VCMSTREAMHEADER.cbSrcLength> and
 *      <e VCMSTREAMHEADER.cbDstLength> respectively) that were used
 *      during the corresponding <f vcmStreamPrepareHeader> call. Failing
 *      to reset these member values will cause <f vcmStreamUnprepareHeader>
 *      to fail with MMSYSERR_INVALPARAM.
 *
 *      Note that there are some errors that the VCM can recover from. The
 *      VCM will return a non-zero error, yet the stream header will be
 *      properly unprepared. To determine whether the stream header was
 *      actually unprepared an application can examine the
 *      VCMSTREAMHEADER_STATUSF_PREPARED flag. The header will always be
 *      unprepared if <f vcmStreamUnprepareHeader> returns success.
 *
 *  @xref <f vcmStreamPrepareHeader> <f vcmStreamClose>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamUnprepareHeader(HVCMSTREAM hvs, PVCMSTREAMHEADER pvsh, DWORD fdwUnprepare)
{
	MMRESULT mmr = (MMRESULT)MMSYSERR_NOERROR;

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamUnprepareHeader: Specified handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}
	if (!pvsh)
	{
		ERRORMESSAGE(("vcmStreamUnprepareHeader: Specified pointer is invalid, pvsh=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Return if buffer is currently in use
	if (IsVCMHeaderInQueue(pvsh))
	{
		ERRORMESSAGE(("vcmStreamUnprepareHeader: Buffer is currently in use\r\n"));
		return ((MMRESULT)VCMERR_BUSY);
	}

	// Return if buffer has not been prepared
	if (!IsVCMHeaderPrepared(pvsh))
	{
		ERRORMESSAGE(("vcmStreamUnprepareHeader: Buffer has not been prepared\r\n"));
		return ((MMRESULT)VCMERR_UNPREPARED);
	}

#ifdef REALLY_LOCK
	// Unlock the buffers
	VirtualUnlock(pvsh->pbSrc, pvsh->cbSrcLength);
	VirtualUnlock(pvsh->pbDst, pvsh->cbDstLength);
	VirtualUnlock(pvsh, (DWORD)sizeof(VCMSTREAMHEADER));
#endif

	// Update flag
	MarkVCMHeaderUnprepared(pvsh);

	return ((MMRESULT)MMSYSERR_NOERROR);
}

PVCMSTREAMHEADER DeQueVCMHeader(PVCMSTREAM pvs)
{
	PVCMSTREAMHEADER pvsh;

	if (pvsh = pvs->pvhFirst)
	{
		MarkVCMHeaderUnQueued(pvsh);
		pvs->pvhFirst = pvsh->pNext;
		if (pvs->pvhFirst == NULL)
			pvs->pvhLast = NULL;
	}

	return (pvsh);
}

/*****************************************************************************
 * @doc INTERNAL DEVCAPSFUNC
 *
 * @func MMRESULT | vcmDevCapsReadFromReg | This function looks up the
 *   capabilities of a specified video capture input device from the registry.
 *
 * @parm UINT | szDeviceName | Specifies the video capture input device driver name.
 *
 * @parm UINT | szDeviceVersion | Specifies the video capture input device driver version.
 *   May be NULL.
 *
 * @parm PVIDEOINCAPS | pvc | Specifies a pointer to a <t VIDEOINCAPS>
 *   structure. This structure is filled with information about the
 *   capabilities of the device.
 *
 * @parm UINT | cbvc | Specifies the size of the <t VIDEOINCAPS> structure.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALPARAM | Specified pointer is invalid, or its content is invalid.
 *   @flag VCMERR_NOREGENTRY | No registry entry for specified capture device driver was found.
 *
 * @comm Only <p cbwc> bytes (or less) of information is copied to the location
 *   pointed to by <p pvc>. If <p cbwc> is zero, nothing is copied, and
 *   the function returns zero.
 *
 * @xref <f vcmGetDevCaps> <f vcmDevCapsProfile> <f vcmDevCapsWriteToReg>
 ****************************************************************************/
MMRESULT VCMAPI vcmDevCapsReadFromReg(LPSTR szDeviceName, LPSTR szDeviceVersion,PVIDEOINCAPS pvc, UINT cbvc)
{
	MMRESULT	mmr = (MMRESULT)MMSYSERR_NOERROR;
	HKEY		hDeviceKey, hKey;
	DWORD		dwSize, dwType;
	char		szKey[MAX_PATH + MAX_VERSION + 2];
	LONG lRet;

	// Check input params
	if (!szDeviceName)
	{
		ERRORMESSAGE(("vcmDevCapsReadFromReg: Specified pointer is invalid, szDeviceName=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (szDeviceName[0] == '\0')
	{
		ERRORMESSAGE(("vcmDevCapsReadFromReg: Video capture input device driver name is empty\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!pvc)
	{
		ERRORMESSAGE(("vcmDevCapsReadFromReg: Specified pointer is invalid, pvc=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!cbvc)
	{
		ERRORMESSAGE(("vcmDevCapsReadFromReg: Specified structure size is invalid, cbvc=0\r\n"));
		return ((MMRESULT)MMSYSERR_NOERROR);
	}

	// Check if the main capture devices key is there
	if (RegOpenKey(HKEY_LOCAL_MACHINE, szRegDeviceKey, &hDeviceKey) != ERROR_SUCCESS)
		return ((MMRESULT)VCMERR_NOREGENTRY);


    //If we have version info use that to build the key name
    if (szDeviceVersion) {
        wsprintf(szKey, "%s, %s", szDeviceName, szDeviceVersion);
    } else {
        wsprintf(szKey, "%s", szDeviceName);
    }

    // Check if there already is a key for the current device
	if (RegOpenKey(hDeviceKey, szKey, &hKey) != ERROR_SUCCESS)
	{
		mmr = (MMRESULT)VCMERR_NOREGENTRY;
		goto MyExit0;
	}

	// Get the values stored in the key
	dwSize = sizeof(DWORD);
	RegQueryValueEx(hKey, (LPTSTR)szRegdwImageSizeKey, NULL, &dwType, (LPBYTE)&pvc->dwImageSize, &dwSize);
	dwSize = sizeof(DWORD);
	RegQueryValueEx(hKey, (LPTSTR)szRegdwNumColorsKey, NULL, &dwType, (LPBYTE)&pvc->dwNumColors, &dwSize);
	dwSize = sizeof(DWORD);
	pvc->dwStreamingMode = STREAMING_PREFER_FRAME_GRAB;
	RegQueryValueEx(hKey, (LPTSTR)szRegdwStreamingModeKey, NULL, &dwType, (LPBYTE)&pvc->dwStreamingMode, &dwSize);
	dwSize = sizeof(DWORD);
	pvc->dwDialogs = FORMAT_DLG_OFF | SOURCE_DLG_ON;
	RegQueryValueEx(hKey, (LPTSTR)szRegdwDialogsKey, NULL, &dwType, (LPBYTE)&pvc->dwDialogs, &dwSize);



	// Check dwNumColors to figure out if we need to read the palettes too
	if (pvc->dwNumColors & VIDEO_FORMAT_NUM_COLORS_16)
	{
		dwSize = NUM_4BIT_ENTRIES * sizeof(RGBQUAD);
		if (RegQueryValueEx(hKey, (LPTSTR)szRegbmi4bitColorsKey, NULL, &dwType,
                    		(LPBYTE)&pvc->bmi4bitColors[0], &dwSize) == ERROR_SUCCESS) {
            pvc->dwFlags |= VICF_4BIT_TABLE;
        }
        else
            FillMemory ((LPBYTE)&pvc->bmi4bitColors[0], NUM_4BIT_ENTRIES * sizeof(RGBQUAD), 0);
	}
	if (pvc->dwNumColors & VIDEO_FORMAT_NUM_COLORS_256)
	{
		dwSize = NUM_8BIT_ENTRIES * sizeof(RGBQUAD);
		if (RegQueryValueEx(hKey, (LPTSTR)szRegbmi8bitColorsKey, NULL, &dwType,
		                    (LPBYTE)&pvc->bmi8bitColors[0], &dwSize) == ERROR_SUCCESS) {
            pvc->dwFlags |= VICF_8BIT_TABLE;
        }
        else
            FillMemory ((LPBYTE)&pvc->bmi8bitColors[0], NUM_8BIT_ENTRIES * sizeof(RGBQUAD), 0);
	}

	// Close the registry keys
	RegCloseKey(hKey);
MyExit0:
	RegCloseKey(hDeviceKey);

	return (mmr);

}


/*****************************************************************************
 * @doc INTERNAL DEVCAPSFUNC
 *
 * @func MMRESULT | vcmDevCapsProfile | This function profiles the video capture
 *   input device to figure out its capabilities.
 *
 * @parm PVIDEOINCAPS | pvc | Specifies a pointer to a <t VIDEOINCAPS>
 *   structure. This structure is filled with information about the
 *   capabilities of the device.
 *
 * @parm UINT | cbvc | Specifies the size of the <t VIDEOINCAPS> structure.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALPARAM | Specified pointer is invalid, or its content is invalid.
 *   @flag MMSYSERR_NOMEM | A memory allocation failed.
 *   @flag MMSYSERR_NODRIVER | No capture device driver or device is present.
 *   @flag VCMERR_NONSPECIFIC | The capture driver failed to provide description information.
 *
 * @comm Only <p cbwc> bytes (or less) of information is copied to the location
 *   pointed to by <p pvc>. If <p cbwc> is zero, nothing is copied, and
 *   the function returns zero.
 *
 * @xref <f vcmGetDevCaps> <f videoDevCapsReadFromReg> <f videoDevCapsWriteToReg>
 ****************************************************************************/
MMRESULT VCMAPI vcmDevCapsProfile(UINT uDevice, PVIDEOINCAPS pvc, UINT cbvc)
{
	MMRESULT			mmr = (MMRESULT)MMSYSERR_NOERROR;
	FINDCAPTUREDEVICE	fcd;
	LPBITMAPINFO		lpbmi;
	HCAPDEV				hCapDev = (HCAPDEV)NULL;
	int					k,l;
	BOOL				b4bitPalInitialized = FALSE;
	BOOL				b8bitPalInitialized = FALSE;
	BOOL				bRet;

	// Check input params
	if (!pvc)
	{
		ERRORMESSAGE(("vcmDevCapsProfile: Specified pointer is invalid, pvc=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!cbvc)
	{
		ERRORMESSAGE(("vcmDevCapsProfile: Specified structure size is invalid, cbvc=0\r\n"));
		return ((MMRESULT)MMSYSERR_NOERROR);
	}

	// Check input params
	if ((uDevice >= MAXVIDEODRIVERS) && (uDevice != VIDEO_MAPPER))
	{
		ERRORMESSAGE(("vcmGetDevCaps: Specified capture device ID is invalid, uDevice=%ld (expected values are 0x%lX or between 0 and %ld)\r\n", uDevice, VIDEO_MAPPER, MAXVIDEODRIVERS-1));
		return ((MMRESULT)MMSYSERR_BADDEVICEID);
	}

	// Allocate space for BMIH and palette
	if ((lpbmi = (LPBITMAPINFO)MemAlloc(sizeof(BITMAPINFOHEADER) + NUM_8BIT_ENTRIES * sizeof(RGBQUAD))) == NULL)
	{
		ERRORMESSAGE(("vcmDevCapsProfile: BMIH and palette allocation failed\r\n"));
		return ((MMRESULT)MMSYSERR_NOMEM);
	}

	// For now, always set the preferred streaming mode to STREAMING_PREFER_FRAME_GRAB
	// But in the future, do some real profiling...
	pvc->dwStreamingMode = STREAMING_PREFER_FRAME_GRAB;
	pvc->dwDialogs = FORMAT_DLG_OFF | SOURCE_DLG_OFF;

	lpbmi->bmiHeader.biPlanes = 1;

	// if VIDEO_MAPPER: use first capture device
	fcd.dwSize = sizeof (FINDCAPTUREDEVICE);

	if (uDevice == VIDEO_MAPPER)
	{
		bRet = FindFirstCaptureDevice(&fcd, NULL);
	}

	else
		bRet = FindFirstCaptureDeviceByIndex(&fcd, uDevice);

	if (bRet)
		hCapDev = OpenCaptureDevice(fcd.nDeviceIndex);
	

	if (hCapDev != NULL)
	{
		// If the driver exposes a source dialog, there is no need to go further:
		// we advertise this dialog and that's it. On the other hand, if there isn't
		// a source dialog per se, it may be hidden in the format dialog, in which case
		// we advertise the format dialog.
		if (CaptureDeviceDialog(hCapDev, (HWND)NULL, CAPDEV_DIALOG_SOURCE | CAPDEV_DIALOG_QUERY, NULL))
			pvc->dwDialogs |= SOURCE_DLG_ON;
		else
			if (CaptureDeviceDialog(hCapDev, (HWND)NULL, CAPDEV_DIALOG_IMAGE | CAPDEV_DIALOG_QUERY, NULL))
				pvc->dwDialogs |= FORMAT_DLG_ON;

        // since we don't know anything about this adapter, we just use its default format
        // and report that we can get any size, which we will do through conversion
        // we will report the correct color depth only if the default size matches one of
        // our sizes, we'll always report 24bit color

        pvc->dwImageSize |= VIDEO_FORMAT_IMAGE_SIZE_USE_DEFAULT;

        // get the device's default format
        lpbmi->bmiHeader.biSize = GetCaptureDeviceFormatHeaderSize(hCapDev);
        GetCaptureDeviceFormat(hCapDev, (LPBITMAPINFOHEADER)lpbmi);

        // record this default in the registry
        if (pvc->szDeviceName[0] != '\0') {
            vcmDefaultFormatWriteToReg(pvc->szDeviceName, pvc->szDeviceVersion, (LPBITMAPINFOHEADER)lpbmi);
        } else {
            //Fall back and use driver name as the key
            vcmDefaultFormatWriteToReg(fcd.szDeviceName, pvc->szDeviceVersion, (LPBITMAPINFOHEADER)lpbmi);
        }

        if ((lpbmi->bmiHeader.biCompression == VIDEO_FORMAT_BI_RGB) ||
            (lpbmi->bmiHeader.biCompression == VIDEO_FORMAT_YVU9) ||
            (lpbmi->bmiHeader.biCompression == VIDEO_FORMAT_YUY2) ||
            (lpbmi->bmiHeader.biCompression == VIDEO_FORMAT_UYVY) ||
            (lpbmi->bmiHeader.biCompression == VIDEO_FORMAT_I420) ||
            (lpbmi->bmiHeader.biCompression == VIDEO_FORMAT_IYUV)) {
            if (lpbmi->bmiHeader.biCompression == VIDEO_FORMAT_YVU9)
                k = VIDEO_FORMAT_NUM_COLORS_YVU9;
            else if (lpbmi->bmiHeader.biCompression == VIDEO_FORMAT_YUY2)
                k = VIDEO_FORMAT_NUM_COLORS_YUY2;
            else if (lpbmi->bmiHeader.biCompression == VIDEO_FORMAT_UYVY)
                k = VIDEO_FORMAT_NUM_COLORS_UYVY;
            else if (lpbmi->bmiHeader.biCompression == VIDEO_FORMAT_I420)
                k = VIDEO_FORMAT_NUM_COLORS_I420;
            else if (lpbmi->bmiHeader.biCompression == VIDEO_FORMAT_IYUV)
                k = VIDEO_FORMAT_NUM_COLORS_IYUV;
            else {
                for (k = 0; k < NUM_BITDEPTH_ENTRIES; k++) {
        			if (lpbmi->bmiHeader.biBitCount == g_aiBitDepth[k])
        			    break;
    	        }
    	        if (k < NUM_BITDEPTH_ENTRIES)
    	            k = g_aiNumColors[k];
    	        else
    	            k = 0;
    	    }
        }

        // converted sizes will probably get to RGB24, so always say that we support it
        pvc->dwNumColors |= VIDEO_FORMAT_NUM_COLORS_16777216;

        // always say that we support these 2 standard formats
        pvc->dwImageSize |= VIDEO_FORMAT_IMAGE_SIZE_176_144 | VIDEO_FORMAT_IMAGE_SIZE_128_96;
   		for (l=0; l<VIDEO_FORMAT_NUM_RESOLUTIONS; l++) {
            if ((lpbmi->bmiHeader.biWidth == (LONG)g_awResolutions[l].framesize.biWidth) &&
                 (lpbmi->bmiHeader.biHeight == (LONG)g_awResolutions[l].framesize.biHeight)) {
   		        pvc->dwImageSize |= g_awResolutions[l].dwRes;
    			pvc->dwNumColors |= k;
   		        break;
   		    }
	    }
	}
	else
		mmr = (MMRESULT)MMSYSERR_NODRIVER;

	// Close capture device
	if (hCapDev)
		CloseCaptureDevice(hCapDev);

	// Free BMIH + palette space
	if (lpbmi)
		MemFree(lpbmi);

	return (mmr);

}


/*****************************************************************************
 * @doc EXTERNAL DEVCAPSFUNC
 *
 * @func MMRESULT | vcmDevCapsWriteToReg | This function writes the
 *   capabilities of a specified video capture input device into the registry.
 *
 * @parm UINT | szDeviceName | Specifies the video capture input device driver name.
 *
 * @parm UINT | szDeviceVersion | Specifies the video capture input device driver version.
 *   May be NULL.
 *
 * @parm PVIDEOINCAPS | pvc | Specifies a pointer to a <t VIDEOINCAPS>
 *   structure. This structure is filled with information about the
 *   capabilities of the device.
 *
 * @parm UINT | cbvc | Specifies the size of the <t VIDEOINCAPS> structure.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALPARAM | Specified pointer is invalid, or its content is invalid.
 *   @flag VCMERR_NOREGENTRY | No registry entry could be created for the specified capture device driver.
 *
 * @comm Only <p cbwc> bytes (or less) of information is copied to the location
 *   pointed to by <p pvc>. If <p cbwc> is zero, nothing is copied, and
 *   the function returns zero.
 *
 * @xref <f vcmGetDevCaps> <f videoDevCapsProfile> <f videoDevCapsWriteToReg>
 ****************************************************************************/
MMRESULT VCMAPI vcmDevCapsWriteToReg(LPSTR szDeviceName, LPSTR szDeviceVersion, PVIDEOINCAPS pvc, UINT cbvc)
{
	HKEY	hDeviceKey;
	HKEY	hKey;
	DWORD	dwDisposition;
	DWORD	dwSize;
	char	szKey[MAX_PATH + MAX_VERSION + 2];

	// Check input params
	if (!szDeviceName)
	{
		ERRORMESSAGE(("vcmDevCapsWriteToReg: Specified pointer is invalid, szDeviceName=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (szDeviceName[0] == '\0')
	{
		ERRORMESSAGE(("vcmDevCapsWriteToReg: Video capture input device driver name is empty\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!pvc)
	{
		ERRORMESSAGE(("vcmDevCapsWriteToReg: Specified pointer is invalid, pvc=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!cbvc)
	{
		ERRORMESSAGE(("vcmDevCapsWriteToReg: Specified structure size is invalid, cbvc=0\r\n"));
		return ((MMRESULT)MMSYSERR_NOERROR);
	}

	// Open the main capture devices key, or create it if it doesn't exist
	if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegDeviceKey, 0, 0, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hDeviceKey, &dwDisposition) != ERROR_SUCCESS)
		return ((MMRESULT)VCMERR_NOREGENTRY);

    //If we have version info use that to build the key name
    if (szDeviceVersion && szDeviceVersion[0] != '\0') {
        wsprintf(szKey, "%s, %s", szDeviceName, szDeviceVersion);
    } else {
        wsprintf(szKey, "%s", szDeviceName);
    }


	// Check if there already is a key for the current device
	// Open the key for the current device, or create the key if it doesn't exist
	if (RegCreateKeyEx(hDeviceKey, szKey, 0, 0, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dwDisposition) != ERROR_SUCCESS)
		return ((MMRESULT)VCMERR_NOREGENTRY);

	// Set the values in the key
	dwSize = sizeof(DWORD);
	RegSetValueEx(hKey, (LPTSTR)szRegdwImageSizeKey, (DWORD)NULL, REG_DWORD, (LPBYTE)&pvc->dwImageSize, dwSize);
	dwSize = sizeof(DWORD);
	RegSetValueEx(hKey, (LPTSTR)szRegdwNumColorsKey, (DWORD)NULL, REG_DWORD, (LPBYTE)&pvc->dwNumColors, dwSize);
	dwSize = sizeof(DWORD);
	RegSetValueEx(hKey, (LPTSTR)szRegdwStreamingModeKey, (DWORD)NULL, REG_DWORD, (LPBYTE)&pvc->dwStreamingMode, dwSize);
	dwSize = sizeof(DWORD);
	RegSetValueEx(hKey, (LPTSTR)szRegdwDialogsKey, (DWORD)NULL, REG_DWORD, (LPBYTE)&pvc->dwDialogs, dwSize);

	// Check dwNumColors to figure out if we need to set the palettes too
	if (pvc->dwNumColors & VIDEO_FORMAT_NUM_COLORS_16)
	{
		dwSize = NUM_4BIT_ENTRIES * sizeof(RGBQUAD);
		RegSetValueEx(hKey, (LPTSTR)szRegbmi4bitColorsKey, (DWORD)NULL, REG_BINARY, (LPBYTE)&pvc->bmi4bitColors[0], dwSize);
	}
	if (pvc->dwNumColors & VIDEO_FORMAT_NUM_COLORS_256)
	{
		dwSize = NUM_8BIT_ENTRIES * sizeof(RGBQUAD);
		RegSetValueEx(hKey, (LPTSTR)szRegbmi8bitColorsKey, (DWORD)NULL, REG_BINARY, (LPBYTE)&pvc->bmi8bitColors[0], dwSize);
	}

	// Close the keys
	RegCloseKey(hKey);
	RegCloseKey(hDeviceKey);

	return ((MMRESULT)MMSYSERR_NOERROR);

}


MMRESULT VCMAPI vcmDefaultFormatWriteToReg(LPSTR szDeviceName, LPSTR szDeviceVersion, LPBITMAPINFOHEADER lpbmih)
{
	HKEY	hDeviceKey;
	HKEY	hKey;
	DWORD	dwDisposition;
	DWORD	dwSize;
	char	szKey[MAX_PATH + MAX_VERSION + 2];
	char    szFOURCC[5];

	// Check input params
	if (!szDeviceName)
	{
		ERRORMESSAGE(("vcmDefaultFormatWriteToReg: Specified pointer is invalid, szDeviceName=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (szDeviceName[0] == '\0')
	{
		ERRORMESSAGE(("vcmDefaultFormatWriteToReg: Video capture input device driver name is empty\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!lpbmih)
	{
		ERRORMESSAGE(("vcmDefaultFormatWriteToReg: Specified pointer is invalid, lpbmih=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Open the main capture devices key, or create it if it doesn't exist
	if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegCaptureDefaultKey, 0, 0, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hDeviceKey, &dwDisposition) != ERROR_SUCCESS)
		return ((MMRESULT)VCMERR_NOREGENTRY);

    //If we have version info use that to build the key name
    if (szDeviceVersion && szDeviceVersion[0] != '\0') {
        wsprintf(szKey, "%s, %s", szDeviceName, szDeviceVersion);
    } else {
        wsprintf(szKey, "%s", szDeviceName);
    }

	// Check if there already is a key for the current device
	// Open the key for the current device, or create the key if it doesn't exist
	if (RegCreateKeyEx(hDeviceKey, szKey, 0, 0, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dwDisposition) != ERROR_SUCCESS)
		return ((MMRESULT)VCMERR_NOREGENTRY);

    if (lpbmih->biCompression == BI_RGB)
        wsprintf(szFOURCC, "RGB");
    else {
        *((DWORD*)&szFOURCC) = lpbmih->biCompression;
        szFOURCC[4] = '\0';
    }

	dwSize = wsprintf(szKey, "%s, %dx%dx%d", szFOURCC, lpbmih->biWidth, lpbmih->biHeight, lpbmih->biBitCount);
	RegSetValueEx(hKey, (LPTSTR)szRegDefaultFormatKey, (DWORD)NULL, REG_SZ, (CONST BYTE *)szKey, dwSize+1);

	// Close the keys
	RegCloseKey(hKey);
	RegCloseKey(hDeviceKey);

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/*****************************************************************************
 * @doc EXTERNAL DEVCAPSFUNC
 *
 * @func MMRESULT | vcmGetDevCapsPreferredFormatTag | This function queries a specified
 *   video capture input device to determine the format tag it will be effectively
 *   capturing at.
 *
 * @parm UINT | uDevice | Specifies the video capture input device ID.
 *
 * @parm PINT | pbiWidth | Specifies a pointer to the actual width
 *   the capture will be performed at.
 *
 * @parm PINT | pbiHeight | Specifies a pointer to the actual height
 *   the capture will be performed at.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALPARAM | Specified pointer to structure is invalid.
 *   @flag MMSYSERR_BADDEVICEID | Specified device device ID is invalid.
 *   @flag VCMERR_NONSPECIFIC | The capture driver failed to provide valid information.
 *
 * @xref <f vcmGetDevCaps>
 ****************************************************************************/
MMRESULT VCMAPI vcmGetDevCapsPreferredFormatTag(UINT uDevice, PDWORD pdwFormatTag)
{
	MMRESULT	mmr = (MMRESULT)MMSYSERR_NOERROR;
	VIDEOINCAPS vic;
	int			i;

	// Check input params
	if (!pdwFormatTag)
	{
		ERRORMESSAGE(("vcmGetDevCapsPreferredFormatTag: Specified pointer is invalid, pdwFormatTag=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if ((uDevice >= MAXVIDEODRIVERS) && (uDevice != VIDEO_MAPPER))
	{
		ERRORMESSAGE(("vcmGetDevCapsPreferredFormatTag: Specified capture device ID is invalid, uDevice=%ld (expected values are 0x%lX or between 0 and %ld)\r\n", uDevice, VIDEO_MAPPER, MAXVIDEODRIVERS-1));
		return ((MMRESULT)MMSYSERR_BADDEVICEID);
	}

	// Get the capabilities of the capture hardware
	if ((mmr = vcmGetDevCaps(uDevice, &vic, sizeof(VIDEOINCAPS))) != MMSYSERR_NOERROR)
		return (mmr);

	// WE prefer to use I420 or IYUV, YVU9, YUY2, UYVY, RGB16, RGB24, RGB4, RGB8 in that order.
	for (i=0; i<NUM_BITDEPTH_ENTRIES; i++)
		if (g_aiNumColors[i] & vic.dwNumColors)
			break;
	
	if (i == NUM_BITDEPTH_ENTRIES)
		return ((MMRESULT)VCMERR_NONSPECIFIC);
	else
		*pdwFormatTag = g_aiFourCCCode[i];

	return ((MMRESULT)MMSYSERR_NOERROR);

}


/*****************************************************************************
 * @doc EXTERNAL DEVCAPSFUNC
 *
 * @func MMRESULT | vcmGetDevCapsStreamingMode | This function queries a specified
 *   video capture input device to determine its preferred streaming mode.
 *
 * @parm UINT | uDevice | Specifies the video capture input device ID.
 *
 * @parm PDWORD | pdwStreamingMode | Specifies a pointer to the preferred streaming mode.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALPARAM | Specified pointer to structure is invalid.
 *   @flag MMSYSERR_BADDEVICEID | Specified device device ID is invalid.
 *   @flag VCMERR_NONSPECIFIC | The capture driver failed to provide valid information.
 *
 * @xref <f vcmGetDevCaps>
 ****************************************************************************/
MMRESULT VCMAPI vcmGetDevCapsStreamingMode(UINT uDevice, PDWORD pdwStreamingMode)
{
	MMRESULT	mmr = (MMRESULT)MMSYSERR_NOERROR;
	VIDEOINCAPS vic;

	// Check input params
	if (!pdwStreamingMode)
	{
		ERRORMESSAGE(("vcmGetDevCapsStreamingMode: Specified pointer is invalid, pdwStreamingMode=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if ((uDevice >= MAXVIDEODRIVERS) && (uDevice != VIDEO_MAPPER))
	{
		ERRORMESSAGE(("vcmGetDevCapsStreamingMode: Specified capture device ID is invalid, uDevice=%ld (expected values are 0x%lX or between 0 and %ld)\r\n", uDevice, VIDEO_MAPPER, MAXVIDEODRIVERS-1));
		return ((MMRESULT)MMSYSERR_BADDEVICEID);
	}

	// Get the capabilities of the capture hardware
	if ((mmr = vcmGetDevCaps(uDevice, &vic, sizeof(VIDEOINCAPS))) != MMSYSERR_NOERROR)
		return (mmr);

	// Get the streaming mode.
	*pdwStreamingMode = vic.dwStreamingMode;

	return ((MMRESULT)MMSYSERR_NOERROR);

}




/*****************************************************************************
 * @doc EXTERNAL DEVCAPSFUNC
 *
 * @func MMRESULT | vcmGetDevCapsDialogs | This function queries a specified
 *   video capture input device to determine if its dialog and source format
 *   its should be exposed.
 *
 * @parm UINT | uDevice | Specifies the video capture input device ID.
 *
 * @parm PDWORD | pdwDialogs | Specifies a pointer to the dialogs to be exposed.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALPARAM | Specified pointer to structure is invalid.
 *   @flag MMSYSERR_BADDEVICEID | Specified device device ID is invalid.
 *   @flag VCMERR_NONSPECIFIC | The capture driver failed to provide valid information.
 *
 * @xref <f vcmGetDevCaps>
 ****************************************************************************/
MMRESULT VCMAPI vcmGetDevCapsDialogs(UINT uDevice, PDWORD pdwDialogs)
{
	MMRESULT	mmr = (MMRESULT)MMSYSERR_NOERROR;
	VIDEOINCAPS vic;

	// Check input params
	if (!pdwDialogs)
	{
		ERRORMESSAGE(("vcmGetDevCapsDialogs: Specified pointer is invalid, pdwDialogs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if ((uDevice >= MAXVIDEODRIVERS) && (uDevice != VIDEO_MAPPER))
	{
		ERRORMESSAGE(("vcmGetDevCapsDialogs: Specified capture device ID is invalid, uDevice=%ld (expected values are 0x%lX or between 0 and %ld)\r\n", uDevice, VIDEO_MAPPER, MAXVIDEODRIVERS-1));
		return ((MMRESULT)MMSYSERR_BADDEVICEID);
	}

	// Get the capabilities of the capture hardware
	if ((mmr = vcmGetDevCaps(uDevice, &vic, sizeof(VIDEOINCAPS))) != MMSYSERR_NOERROR)
		return (mmr);

	// Get the streaming mode.
	*pdwDialogs = vic.dwDialogs;

	return ((MMRESULT)MMSYSERR_NOERROR);

}


/****************************************************************************
 * @doc EXTERNAL COMPFUNC
 *
 * @func MMRESULT | vcmStreamSetBrightness | This function sends a user-defined
 *   message to a given Video Compression Manager (VCM) stream instance to set
 *   the brightness of the decompressed images. The brightness is a value defined
 *   between 0 and 255. The brightness can also be reset by passing a value equal
 *   to VCM_RESET_BRIGHTNESS.
 *
 * @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 * @parm DWORD | dwBrightness | Specifies the value of the brightness requested.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *   @flag MMSYSERR_INVALPARAM | Specified brightness value is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | The VCM driver cannot set the brightness.
 *
 * @xref <f vcmStreamMessage>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamSetBrightness(HVCMSTREAM hvs, DWORD dwBrightness)
{
	PVCMSTREAM	pvs = (PVCMSTREAM)hvs;

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamSetBrightness: Specified HVCMSTREAM handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}
	if ((dwBrightness != VCM_RESET_BRIGHTNESS) && ((dwBrightness > VCM_MAX_BRIGHTNESS) || (dwBrightness < VCM_MIN_BRIGHTNESS)))
	{
		ERRORMESSAGE(("vcmStreamSetBrightness: Specified brightness value is invalid, dwBrightness=%ld (expected value is between %ld and %ld)\r\n", dwBrightness, VCM_MIN_BRIGHTNESS, VCM_MAX_BRIGHTNESS));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Only our (intel h.263) codec supports this. If the codec used is different,
	// that's Ok: no need to return an error.
#if !defined(_ALPHA_) && defined(USE_BILINEAR_MSH26X)
	if (pvs->pvfxSrc && ((pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_MSH263) || (pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_MSH26X)))
#else
	if (pvs->pvfxSrc && (pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_MSH263))
#endif
		vcmStreamMessage(hvs, PLAYBACK_CUSTOM_CHANGE_BRIGHTNESS, (dwBrightness != VCM_RESET_BRIGHTNESS) ? (LPARAM)dwBrightness : (LPARAM)VCM_DEFAULT_BRIGHTNESS, (LPARAM)0);

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 * @doc EXTERNAL COMPFUNC
 *
 * @func MMRESULT | vcmStreamSetContrast | This function sends a user-defined
 *   message to a given Video Compression Manager (VCM) stream instance to set
 *   the contrast of the decompressed images. The contrast is a value defined
 *   between 0 and 255. The contrast can also be reset by passing a value equal
 *   to VCM_RESET_CONTRAST.
 *
 * @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 * @parm DWORD | dwContrast | Specifies the value of the contrast requested.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *   @flag MMSYSERR_INVALPARAM | Specified contrast value is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | The VCM driver cannot set the contrast.
 *
 * @xref <f vcmStreamMessage>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamSetContrast(HVCMSTREAM hvs, DWORD dwContrast)
{
	PVCMSTREAM	pvs = (PVCMSTREAM)hvs;

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamSetContrast: Specified handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}
	if ((dwContrast != VCM_RESET_CONTRAST) && ((dwContrast > VCM_MAX_CONTRAST) || (dwContrast < VCM_MIN_CONTRAST)))
	{
		ERRORMESSAGE(("vcmStreamSetContrast: Specified contrast value is invalid, dwContrast=%ld (expected value is between %ld and %ld)\r\n", dwContrast, VCM_MIN_CONTRAST, VCM_MAX_CONTRAST));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Only our (intel ) codec supports this. If the codec used is different,
	// that's Ok: no need to return an error.
#if !defined(_ALPHA_) && defined(USE_BILINEAR_MSH26X)
	if (pvs->pvfxSrc && ((pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_MSH263) || (pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_MSH26X)))
#else
	if (pvs->pvfxSrc && (pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_MSH263))
#endif
		vcmStreamMessage(hvs, PLAYBACK_CUSTOM_CHANGE_CONTRAST, (dwContrast != VCM_RESET_CONTRAST) ? (LPARAM)dwContrast : (LPARAM)VCM_DEFAULT_CONTRAST, (LPARAM)0);

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 * @doc EXTERNAL COMPFUNC
 *
 * @func MMRESULT | vcmStreamSetSaturation | This function sends a user-defined
 *   message to a given Video Compression Manager (VCM) stream instance to set
 *   the saturation of the decompressed images. The saturation is a value defined
 *   between 0 and 255. The saturation can also be reset by passing a value equal
 *   to VCM_RESET_SATURATION.
 *
 * @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 * @parm DWORD | dwSaturation | Specifies the value of the saturation requested.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *   @flag MMSYSERR_INVALPARAM | Specified saturation value is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | The VCM driver cannot set the saturation.
 *
 * @xref <f vcmStreamMessage>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamSetSaturation(HVCMSTREAM hvs, DWORD dwSaturation)
{
	PVCMSTREAM	pvs = (PVCMSTREAM)hvs;

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamSetSaturation: Specified handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}
	if ((dwSaturation != VCM_RESET_SATURATION) && ((dwSaturation > VCM_MAX_SATURATION) || (dwSaturation < VCM_MIN_SATURATION)))
	{
		ERRORMESSAGE(("vcmStreamSetSaturation: Specified saturation value is invalid, dwSaturation=%ld (expected value is between %ld and %ld)\r\n", dwSaturation, VCM_MIN_SATURATION, VCM_MAX_SATURATION));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Only our (H.263 intel)  codec supports this. If the codec used is different,
	// that's Ok: no need to return an error.
#if !defined(_ALPHA_) && defined(USE_BILINEAR_MSH26X)
	if (pvs->pvfxSrc && ((pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_MSH263) || (pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_MSH26X)))
#else
	if (pvs->pvfxSrc && (pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_MSH263))
#endif
		vcmStreamMessage(hvs, PLAYBACK_CUSTOM_CHANGE_SATURATION, (dwSaturation != VCM_RESET_SATURATION) ? (LPARAM)dwSaturation : (LPARAM)VCM_DEFAULT_SATURATION, (LPARAM)0);

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 * @doc EXTERNAL COMPFUNC
 *
 * @func MMRESULT | vcmStreamIsPostProcessingSupported | This function is used to find
 *   out if the decompressor can post-process the decompressed image to, for
 *   instance, modify its brightness, contrast or saturation.
 *
 * @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 * @rdesc The return value is TRUE if the decompressor supports post-processing. Otherwise, it returns FALSE.
 *
 * @xref <f vcmStreamMessage>
 ***************************************************************************/
BOOL VCMAPI vcmStreamIsPostProcessingSupported(HVCMSTREAM hvs)
{
	// Check input params
	if (!hvs)
		return (FALSE);

	// Put the code that checks this property right here!!!

	return (FALSE);
}


/****************************************************************************
 * @doc EXTERNAL COMPFUNC
 *
 * @func MMRESULT | vcmStreamSetImageQuality | This function sends the image
 *   quality compression parameter.
 *
 * @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 * @parm DWORD | dwImageQuality | Specifies an image quality value (between 0
 *   and 31. The lower number indicates a high spatial quality at a low frame
 *   rate, the larger number indiocates a low spatial quality at a high frame
 *   rate.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *   @flag MMSYSERR_INVALPARAM | Specified image quality value is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | The VCM driver cannot set the compression ratio.
 *
 * @xref <f vcmStreamMessage>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamSetImageQuality(HVCMSTREAM hvs, DWORD dwImageQuality)
{
	PVCMSTREAM	pvs = (PVCMSTREAM)hvs;
#ifdef USE_MPEG4_SCRUNCH
	PVOID				pvState;
	DWORD				dw;
	PMPEG4COMPINSTINFO	pciMPEG4Info;
#endif
#ifdef LOG_COMPRESSION_PARAMS
	char szDebug[100];
#endif

	// Check input param
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamSetImageQuality: Specified handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}
	// Set to default value if out or range
	if ((dwImageQuality > VCM_MIN_IMAGE_QUALITY))
	{
		pvs->dwQuality = VCM_DEFAULT_IMAGE_QUALITY;
		ERRORMESSAGE(("vcmStreamSetImageQuality: Specified image quality value is invalid, dwImageQuality=%ld (expected value is between %ld and %ld)\r\n", dwImageQuality, VCM_MAX_IMAGE_QUALITY, VCM_MIN_IMAGE_QUALITY));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Put the code that sets this property right here!!!
	pvs->dwQuality = dwImageQuality;

#ifdef USE_MPEG4_SCRUNCH
	// Get the state of the compressor
	if (dw = ICGetStateSize((HIC)pvs->hIC))
	{
		if (pvState = (PVOID)MemAlloc(dw))
		{
			if (((DWORD) ICGetState((HIC)pvs->hIC, pvState, dw)) == dw)
			{
				pciMPEG4Info = (PMPEG4COMPINSTINFO)pvState;

				// Configure the codec for compression
				pciMPEG4Info->lMagic = MPG4_STATE_MAGIC;
				pciMPEG4Info->dDataRate = 20;
				pciMPEG4Info->lCrisp = dwImageQuality * 3;
				pciMPEG4Info->lKeydist = 30;
				pciMPEG4Info->lPScale = MPG4_PSEUDO_SCALE;
				pciMPEG4Info->lTotalWindowMs = MPG4_TOTAL_WINDOW_DEFAULT;
				pciMPEG4Info->lVideoWindowMs = MPG4_VIDEO_WINDOW_DEFAULT;
				pciMPEG4Info->lFramesInfoValid = FALSE;
				pciMPEG4Info->lBFrameOn = MPG4_B_FRAME_ON;
				pciMPEG4Info->lLiveEncode = MPG4_LIVE_ENCODE;

				ICSetState((HIC)pvs->hIC, (PVOID)pciMPEG4Info, dw);

				// Get rid of the state structure
				MemFree((HANDLE)pvState);
			}
		}
	}
#endif

#ifdef LOG_COMPRESSION_PARAMS
	wsprintf(szDebug, "New image quality: %ld\r\n", dwImageQuality);
	OutputDebugString(szDebug);
#endif

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 * @doc EXTERNAL COMPFUNC
 *
 * @func MMRESULT | vcmStreamSetMaxPacketSize | This function sets the maximum
 *   video packet size.
 *
 * @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 * @parm DWORD | dwMaxPacketSize | Specifies the maximum packet size.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *   @flag MMSYSERR_INVALPARAM | Specified image quality value is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | The VCM driver cannot set the size.
 *
 * @xref <f vcmStreamMessage>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamSetMaxPacketSize(HVCMSTREAM hvs, DWORD dwMaxPacketSize)
{
	PVCMSTREAM	pvs = (PVCMSTREAM)hvs;

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamSetMaxPacketSize: Specified handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}
	if ((dwMaxPacketSize != VCM_RESET_PACKET_SIZE) && ((dwMaxPacketSize > VCM_MAX_PACKET_SIZE) || (dwMaxPacketSize < VCM_MIN_PACKET_SIZE)))
	{
		ERRORMESSAGE(("vcmStreamSetMaxPacketSize: Specified max packet size value is invalid, dwMaxPacketSize=%ld (expected value is between %ld and %ld)\r\n", dwMaxPacketSize, VCM_MIN_PACKET_SIZE, VCM_MAX_PACKET_SIZE));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Only our (H.26x intel) codecs supports this. If the codec used is different,
	// just return an 'unsupported' error.
#if !defined(_ALPHA_) && defined(USE_BILINEAR_MSH26X)
	if (pvs->pvfxDst && ((pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_MSH263) || (pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_MSH261) || (pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_MSH26X)))
#else
	if (pvs->pvfxDst && ((pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_MSH263) || (pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_MSH261)))
#endif
	{
		if (dwMaxPacketSize != VCM_RESET_PACKET_SIZE)
			pvs->dwMaxPacketSize = dwMaxPacketSize;
		else
			pvs->dwMaxPacketSize = VCM_DEFAULT_PACKET_SIZE;
		vcmStreamMessage(hvs, CODEC_CUSTOM_ENCODER_CONTROL, MAKELONG(EC_PACKET_SIZE,EC_SET_CURRENT), (LPARAM)pvs->dwMaxPacketSize);
	}
	else
		return ((MMRESULT)MMSYSERR_NOTSUPPORTED);

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 * @doc EXTERNAL COMPFUNC
 *
 * @func MMRESULT | vcmStreamSetTargetRates | This function sets the target
 *   bitrate and frame rate to be used in the estimation of the target frame
 *   size at compression time.
 *
 * @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 * @parm DWORD | dwTargetFrameRate | Specifies a target frame rate value.
 *
 * @parm DWORD | dwTargetByterate | Specifies a target byterate value.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise,
 *   it returns an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *   @flag MMSYSERR_INVALPARAM | Specified target frame rate value is
 *   invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | The VCM driver cannot set the compression
 *   ratio.
 *
 * @xref <f vcmStreamMessage>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamSetTargetRates(HVCMSTREAM hvs, DWORD dwTargetFrameRate, DWORD dwTargetByterate)
{
	FX_ENTRY("vcmStreamSetTargetRates");

	// IP + UDP + RTP + payload mode C header - worst case
	#define TRANSPORT_HEADER_SIZE (20 + 8 + 12 + 12)

	PVCMSTREAM			pvs = (PVCMSTREAM)hvs;
	ICCOMPRESSFRAMES	iccf = {0};

	ASSERT(hvs && ((dwTargetFrameRate == VCM_RESET_FRAME_RATE) || ((dwTargetFrameRate <= VCM_MAX_FRAME_RATE) && (dwTargetFrameRate >= VCM_MIN_FRAME_RATE))) && ((dwTargetByterate == VCM_RESET_BYTE_RATE) || ((dwTargetByterate <= VCM_MAX_BYTE_RATE) && (dwTargetByterate >= VCM_MIN_BYTE_RATE))));

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("%s: Specified handle is invalid, hvs=NULL\r\n", _fx_));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}
	if ((dwTargetFrameRate != VCM_RESET_FRAME_RATE) && (dwTargetFrameRate > VCM_MAX_FRAME_RATE) && (dwTargetFrameRate < VCM_MIN_FRAME_RATE))
	{
		ERRORMESSAGE(("%s: Specified target frame rate value is invalid, dwTargetFrameRate=%ld (expected value is between %ld and %ld)\r\n", _fx_, dwTargetFrameRate, VCM_MIN_FRAME_RATE, VCM_MAX_FRAME_RATE));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if ((dwTargetByterate != VCM_RESET_BYTE_RATE) && (dwTargetByterate > VCM_MAX_BYTE_RATE)  && (dwTargetByterate < VCM_MIN_BYTE_RATE))
	{
		ERRORMESSAGE(("%s: Specified target bitrate value is invalid, dwTargetBitrate=%ld bps (expected value is between %ld and %ld bps)\r\n", _fx_, dwTargetByterate << 3, VCM_MIN_BYTE_RATE << 3, VCM_MAX_BYTE_RATE << 3));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Don't change the state of the codec while it's compressing a frame
	EnterCriticalSection(&pvs->crsFrameNumber);

	// Set the new rates on the codec
	iccf.lQuality = 10000UL - (pvs->dwQuality * 322UL);
	if (pvs->dwMaxPacketSize)
		iccf.lDataRate = pvs->dwTargetByterate = dwTargetByterate - (dwTargetByterate / pvs->dwMaxPacketSize + 1) * TRANSPORT_HEADER_SIZE;
	else
		iccf.lDataRate = pvs->dwTargetByterate = dwTargetByterate;
	iccf.lKeyRate = LONG_MAX;
	iccf.dwRate = 1000UL;
	pvs->dwTargetFrameRate = dwTargetFrameRate;
	iccf.dwScale = iccf.dwRate * 100UL / dwTargetFrameRate;
	if (ICSendMessage((HIC)(HVCMDRIVERID)pvs->hIC, ICM_COMPRESS_FRAMES_INFO, (DWORD_PTR)&iccf, sizeof(iccf)) != ICERR_OK)
	{
		LeaveCriticalSection(&pvs->crsFrameNumber);

		ERRORMESSAGE(("%s: Codec failed to handle ICM_COMPRESS_FRAMES_INFO message correctly\r\n", _fx_));

		return ((MMRESULT)VCMERR_FAILED);
	}

	LeaveCriticalSection(&pvs->crsFrameNumber);

	DEBUGMSG(ZONE_VCM, ("%s: New targets:\r\n  Frame rate: %ld.%ld fps\r\n  Bitrate (minus network overhead): %ld bps\r\n  Frame size: %ld bits\r\n", _fx_, pvs->dwTargetFrameRate / 100UL, (DWORD)(pvs->dwTargetFrameRate - (DWORD)(pvs->dwTargetFrameRate / 100UL) * 100UL), pvs->dwTargetByterate << 3, (pvs->dwTargetByterate << 3) * 100UL / pvs->dwTargetFrameRate));

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 * @doc EXTERNAL COMPFUNC
 *
 * @func MMRESULT | vcmStreamRestorePayload | This function takes a list of video
 *   packets and recreates the video payload of a complete frame from these.
 *
 * @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 * @parm WSABUF* | ppDataPkt | Specifies a pointer to the list of video packets.
 *
 * @parm DWORD | dwPktCount | Specifies the number of packets in the list.
 *
 * @parm PBYTE | pbyFrame | Specifies a pointer to the reconstructed video data.
 *
 * @parm DWORD* | pdwFrameSize | Specifies a pointer to the size of reconstructed video data.
 *
 * @parm BOOL* | pfReceivedKeyframe | Specifies a pointer to receive the type (I or P) of a frame.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *   @flag MMSYSERR_INVALPARAM | Specified data pointer is invalid.
 *
 * @comm The <p pdwFrameSize> parameter should be initialized to the maximum frame
 *   size, before calling the <f vcmStreamRestorePayload> function.
 *
 * @xref <f vcmStreamFormatPayload>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamRestorePayload(HVCMSTREAM hvs, WSABUF *ppDataPkt, DWORD dwPktCount, PBYTE pbyFrame, PDWORD pdwFrameSize, BOOL *pfReceivedKeyframe)
{
	PVCMSTREAM	pvs = (PVCMSTREAM)hvs;
	DWORD		dwHeaderSize = 0UL;
	DWORD		dwPSCBytes = 0UL;
	DWORD		dwMaxFrameSize;
#ifdef DEBUG
	char		szTDebug[256];
#endif
#ifdef LOGPAYLOAD_ON
	PBYTE		p = pbyFrame;
	HANDLE		g_TDebugFile;
	DWORD		d, GOBn;
	long		j = (long)(BYTE)ppDataPkt->buf[3];
#endif

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamRestorePayload: Specified handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}
	if (!ppDataPkt)
	{
		ERRORMESSAGE(("vcmStreamRestorePayload: Specified pointer is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!dwPktCount)
	{
		ERRORMESSAGE(("vcmStreamRestorePayload: Specified packet count is invalid, dwPktCount=0\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!pbyFrame)
	{
		ERRORMESSAGE(("vcmStreamRestorePayload: Specified pointer is invalid, pbyFrame=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}
	if (!pdwFrameSize)
	{
		ERRORMESSAGE(("vcmStreamRestorePayload: Specified pointer is invalid, pdwFrameSize=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Save maximum payload size
	dwMaxFrameSize = *pdwFrameSize;

	// Initialize payload size
	*pdwFrameSize = 0;

	// Initialize default frame type
	*pfReceivedKeyframe = FALSE;

	// What is the type of this payload
#ifndef _ALPHA_
#ifdef USE_BILINEAR_MSH26X
	if ((pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_MSH263) || (pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_MSH26X))
#else
	if (pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_MSH263)
#endif
#else
	if (pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_DECH263)
#endif
	{
		// Strip the header of each packet and copy the payload in the video buffer
		while (dwPktCount--)
		{
			// Look for the first two bits to figure out what's the mode used.
			// This will dictate the size of the header to be removed.
			// Mode A is 4 bytes: first bit is set to 1,
			// Mode B is 8 bytes: first bit is set to 0, second bit is set to 0,
			// Mode C is 12 bytes: first bit is set to 0, second bit is set to 1.
			dwHeaderSize = ((ppDataPkt->buf[0] & 0x80) ? ((ppDataPkt->buf[0] & 0x40) ? 12 : 8) : 4);

			// Look at the payload header to figure out if the frame is a keyframe
			*pfReceivedKeyframe |= (BOOL)(ppDataPkt->buf[2] & 0x80);

#ifdef LOGPAYLOAD_ON
			// Output some debug stuff
			if (dwHeaderSize == 4)
			{
				GOBn = (DWORD)((BYTE)ppDataPkt->buf[4]) << 24 | (DWORD)((BYTE)ppDataPkt->buf[5]) << 16 | (DWORD)((BYTE)ppDataPkt->buf[6]) << 8 | (DWORD)((BYTE)ppDataPkt->buf[7]);
				GOBn >>= (DWORD)(10 - (DWORD)((ppDataPkt->buf[0] & 0x38) >> 3));
				GOBn &= 0x0000001F;
				wsprintf(szTDebug, "Header content: Frame %3ld, GOB %0ld\r\n", (DWORD)(ppDataPkt->buf[3]), GOBn);
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, (ppDataPkt->buf[0] & 0x80) ? "     F:   '1' => Mode B or C\r\n" : "     F:   '0' => Mode A\r\n");
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, (ppDataPkt->buf[0] & 0x40) ? "     P:   '1' => PB-frame\r\n" : "     P:   '0' => I or P frame\r\n");
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "  SBIT:    %01ld\r\n", (DWORD)((ppDataPkt->buf[0] & 0x38) >> 3));
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "  EBIT:    %01ld\r\n", (DWORD)(ppDataPkt->buf[0] & 0x07));
				OutputDebugString(szTDebug);
				switch ((DWORD)(ppDataPkt->buf[1] >> 5))
				{
					case 0:
						wsprintf(szTDebug, "   SRC: '000' => Source format forbidden!\r\n");
						break;
					case 1:
						wsprintf(szTDebug, "   SRC: '001' => Source format sub-QCIF\r\n");
						break;
					case 2:
						wsprintf(szTDebug, "   SRC: '010' => Source format QCIF\r\n");
						break;
					case 3:
						wsprintf(szTDebug, "   SRC: '011' => Source format CIF\r\n");
						break;
					case 4:
						wsprintf(szTDebug, "   SRC: '100' => Source format 4CIF\r\n");
						break;
					case 5:
						wsprintf(szTDebug, "   SRC: '101' => Source format 16CIF\r\n");
						break;
					case 6:
						wsprintf(szTDebug, "   SRC: '110' => Source format reserved\r\n");
						break;
					case 7:
						wsprintf(szTDebug, "   SRC: '111' => Source format reserved\r\n");
						break;
					default:
						wsprintf(szTDebug, "   SRC: %ld => Source format unknown!\r\n", (DWORD)(ppDataPkt->buf[1] >> 5));
						break;
				}
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "     R:   %02ld  => Reserved, must be 0\r\n", (DWORD)((ppDataPkt->buf[1] & 0x1F) >> 5));
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, (ppDataPkt->buf[2] & 0x80) ? "     I:   '1' => Intra-coded\r\n" : "     I:   '0' => Not Intra-coded\r\n");
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, (ppDataPkt->buf[2] & 0x40) ? "     A:   '1' => Optional Advanced Prediction mode ON\r\n" : "     A:   '0' => Optional Advanced Prediction mode OFF\r\n");
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, (ppDataPkt->buf[2] & 0x20) ? "     S:   '1' => Optional Syntax-based Arithmetic Code mode ON\r\n" : "     S:   '0' => Optional Syntax-based Arithmetic Code mode OFF\r\n");
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "   DBQ:    %01ld  => Should be 0\r\n", (DWORD)((ppDataPkt->buf[2] & 0x18) >> 3));
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "   TRB:    %01ld  => Should be 0\r\n", (DWORD)(ppDataPkt->buf[2] & 0x07));
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "    TR:  %03ld\r\n", (DWORD)(ppDataPkt->buf[3]));
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "Header: %02lX %02lX %02lX %02lX\r\n", (BYTE)ppDataPkt->buf[0], (BYTE)ppDataPkt->buf[1], (BYTE)ppDataPkt->buf[2], (BYTE)ppDataPkt->buf[3]);
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "dword1: %02lX %02lX %02lX %02lX\r\n", (BYTE)ppDataPkt->buf[4], (BYTE)ppDataPkt->buf[5], (BYTE)ppDataPkt->buf[6], (BYTE)ppDataPkt->buf[7]);
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "dword2: %02lX %02lX %02lX %02lX\r\n", (BYTE)ppDataPkt->buf[8], (BYTE)ppDataPkt->buf[9], (BYTE)ppDataPkt->buf[10], (BYTE)ppDataPkt->buf[11]);
				OutputDebugString(szTDebug);
			}
			else if (dwHeaderSize == 8)
			{
				wsprintf(szTDebug, "Header content:\r\n");
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, (ppDataPkt->buf[0] & 0x80) ? "     F:   '1' => Mode B or C\r\n" : "     F:   '0' => Mode A\r\n");
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, (ppDataPkt->buf[0] & 0x40) ? "     P:   '1' => PB-frame\r\n" : "     P:   '0' => I or P frame\r\n");
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "  SBIT:    %01ld\r\n", (DWORD)((ppDataPkt->buf[0] & 0x38) >> 3));
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "  EBIT:    %01ld\r\n", (DWORD)(ppDataPkt->buf[0] & 0x07));
				OutputDebugString(szTDebug);
				switch ((DWORD)(ppDataPkt->buf[1] >> 5))
				{
					case 0:
						wsprintf(szTDebug, "   SRC: '000' => Source format forbidden!\r\n");
						break;
					case 1:
						wsprintf(szTDebug, "   SRC: '001' => Source format sub-QCIF\r\n");
						break;
					case 2:
						wsprintf(szTDebug, "   SRC: '010' => Source format QCIF\r\n");
						break;
					case 3:
						wsprintf(szTDebug, "   SRC: '011' => Source format CIF\r\n");
						break;
					case 4:
						wsprintf(szTDebug, "   SRC: '100' => Source format 4CIF\r\n");
						break;
					case 5:
						wsprintf(szTDebug, "   SRC: '101' => Source format 16CIF\r\n");
						break;
					case 6:
						wsprintf(szTDebug, "   SRC: '110' => Source format reserved\r\n");
						break;
					case 7:
						wsprintf(szTDebug, "   SRC: '111' => Source format reserved\r\n");
						break;
					default:
						wsprintf(szTDebug, "   SRC: %ld => Source format unknown!\r\n", (DWORD)(ppDataPkt->buf[1] >> 5));
						break;
				}
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, " QUANT:   %02ld\r\n", (DWORD)((ppDataPkt->buf[1] & 0x1F) >> 5));
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, (ppDataPkt->buf[2] & 0x80) ? "     I:   '1' => Intra-coded\r\n" : "     I:   '0' => Not Intra-coded\r\n");
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, (ppDataPkt->buf[2] & 0x40) ? "     A:   '1' => Optional Advanced Prediction mode ON\r\n" : "     A:   '0' => Optional Advanced Prediction mode OFF\r\n");
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, (ppDataPkt->buf[2] & 0x20) ? "     S:   '1' => Optional Syntax-based Arithmetic Code mode ON\r\n" : "     S:   '0' => Optional Syntax-based Arithmetic Code mode OFF\r\n");
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "  GOBN:  %03ld\r\n", (DWORD)(ppDataPkt->buf[2] & 0x1F));
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "   MBA:  %03ld\r\n", (DWORD)(ppDataPkt->buf[3]));
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "  HMV1:  %03ld\r\n", (DWORD)(ppDataPkt->buf[7]));
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "  VMV1:  %03ld\r\n", (DWORD)(ppDataPkt->buf[6]));
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "  HMV2:  %03ld\r\n", (DWORD)(ppDataPkt->buf[5]));
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "  VMV2:  %03ld\r\n", (DWORD)(ppDataPkt->buf[4]));
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "Header: %02lX %02lX %02lX %02lX %02lX %02lX %02lX %02lX\r\n", (BYTE)ppDataPkt->buf[0], (BYTE)ppDataPkt->buf[1], (BYTE)ppDataPkt->buf[2], (BYTE)ppDataPkt->buf[3], (BYTE)ppDataPkt->buf[4], (BYTE)ppDataPkt->buf[5], (BYTE)ppDataPkt->buf[6], (BYTE)ppDataPkt->buf[7]);
				OutputDebugString(szTDebug);
				wsprintf(szTDebug, "dword1: %02lX %02lX %02lX %02lX\r\n", (BYTE)ppDataPkt->buf[8], (BYTE)ppDataPkt->buf[9], (BYTE)ppDataPkt->buf[10], (BYTE)ppDataPkt->buf[11]);
				OutputDebugString(szTDebug);
			}
#endif

			// The purpose of this code is to look for the presence of the
			// Picture Start Code at the beginning of the frame. If it is
			// not present, we should break in debug mode.

			// Only look for PSC at the beginning of the frame
			if (!*pdwFrameSize)
			{
				// The start of the frame may not be at a byte boundary. The SBIT field
				// of the header ((BYTE)ppDataPkt->buf[0] & 0xE0) will tell us exactly where
				// our frame starts. We then look for the PSC (0000 0000 0000 0000 1000 00 bits)
				*((BYTE *)&dwPSCBytes + 3) = *(BYTE *)&(ppDataPkt->buf[dwHeaderSize]);
				*((BYTE *)&dwPSCBytes + 2) = *(BYTE *)&(ppDataPkt->buf[dwHeaderSize + 1]);
				*((BYTE *)&dwPSCBytes + 1) = *(BYTE *)&(ppDataPkt->buf[dwHeaderSize + 2]);
				*((BYTE *)&dwPSCBytes + 0) = *(BYTE *)&(ppDataPkt->buf[dwHeaderSize + 3]);
				dwPSCBytes <<= ((DWORD)((BYTE)ppDataPkt->buf[0] & 0x38) >> 3);
				if ((dwPSCBytes & 0xFFFFFC00) != 0x00008000)
				{
#ifdef DEBUG
					wsprintf(szTDebug, "VCMSTRM: The first packet to reassemble is missing a PSC!\r\n");
					OutputDebugString(szTDebug);
					// DebugBreak();
#endif
					return ((MMRESULT)VCMERR_PSCMISSING);
				}
			}

			// The end of a buffer and the start of the next buffer could belong to the
			// same byte. If this is the case, the first byte of the next buffer was already
			// copied in the video data buffer, with the previous packet. It should not be copied
			// twice. The SBIT field of the payload header allows us to figure out if this is the case.
			if (*pdwFrameSize && (ppDataPkt->buf[0] & 0x38))
				dwHeaderSize++;

#if 0
			//
			// THIS IS FOR EXPERIMENTATION ONLY !!!
			//

			// For I frames, ditch their middle GOB
			if (((dwHeaderSize == 4) || (dwHeaderSize == 5)) && (GOBn == 8) && (ppDataPkt->buf[2] & 0x80))
			{
				wsprintf(szTDebug, "Ditched GOB %2ld of I frame %3ld!\r\n", GOBn, (DWORD)(ppDataPkt->buf[3]));
				OutputDebugString(szTDebug);
				ppDataPkt++;
			}
			else if (((dwHeaderSize == 4) || (dwHeaderSize == 5)) && GOBn && !(ppDataPkt->buf[2] & 0x80))
			{
				wsprintf(szTDebug, "Ditched all GOBs after GOB %2ld of P frame %3ld!\r\n", GOBn, (DWORD)(ppDataPkt->buf[3]));
				OutputDebugString(szTDebug);
				ppDataPkt++;
			}
			else
#endif
			// Verify that the source format has the same video resolution than the conversion stream
			// Test for invalid packets that have a length below the size of the payload header
			if ( (g_ITUSizes[(DWORD)(((BYTE)ppDataPkt->buf[1]) >> 5)].biWidth == pvs->pvfxSrc->bih.biWidth)
				&& (g_ITUSizes[(DWORD)(((BYTE)ppDataPkt->buf[1]) >> 5)].biHeight == pvs->pvfxSrc->bih.biHeight)
				&& (ppDataPkt->len >= dwHeaderSize)
				&& ((*pdwFrameSize + ppDataPkt->len - dwHeaderSize) <= dwMaxFrameSize) )
			{
				// Copy the payload
				CopyMemory(pbyFrame + *pdwFrameSize, ppDataPkt->buf + dwHeaderSize, ppDataPkt->len - dwHeaderSize);

				// Update the payload size and pointer to the input video packets
				*pdwFrameSize += ppDataPkt->len - dwHeaderSize;
			}
			else
			{
				// The total size of the reassembled packet would be larger than the maximum allowed!!!
				// Or the packet has a length less than the payload header size
				// Dump the frame
#ifdef DEBUG
				wsprintf(szTDebug, (ppDataPkt->len >= dwHeaderSize) ? "VCMSTRM: Cumulative size of the reassembled packets is too large: discarding frame!\r\n" : "VCMSTRM: Packet length is smaller than payload header size: discarding frame!\r\n");
				OutputDebugString(szTDebug);
#endif
				return ((MMRESULT)VCMERR_NONSPECIFIC);
			}
			ppDataPkt++;

		}

#ifdef LOGPAYLOAD_ON
		g_TDebugFile = CreateFile("C:\\RecvLog.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
		SetFilePointer(g_TDebugFile, 0, NULL, FILE_END);
		wsprintf(szTDebug, "Frame #%03ld\r\n", (DWORD)j);
		WriteFile(g_TDebugFile, szTDebug, strlen(szTDebug), &d, NULL);
		for (j=*pdwFrameSize; j>0; j-=4, p+=4)
		{
			wsprintf(szTDebug, "%02lX %02lX %02lX %02lX\r\n", *((BYTE *)p), *((BYTE *)p+1), *((BYTE *)p+2), *((BYTE *)p+3));
			WriteFile(g_TDebugFile, szTDebug, strlen(szTDebug), &d, NULL);
		}
		CloseHandle(g_TDebugFile);
#endif

	}
#ifndef _ALPHA_
	else if (pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_MSH261)
#else
	else if (pvs->pvfxSrc->dwFormatTag == VIDEO_FORMAT_DECH261)
#endif
	{
		// Strip the header of each packet and copy the payload in the video buffer
		while (dwPktCount--)
		{

#ifdef LOGPAYLOAD_ON
			// wsprintf(szDebug, "Header: %02lX %02lX %02lX %02lX\r\ndword1: %02lX %02lX %02lX %02lX\r\ndword2: %02lX %02lX %02lX %02lX\r\n", ppDataPkt->buf[0], ppDataPkt->buf[1], ppDataPkt->buf[2], ppDataPkt->buf[3], ppDataPkt->buf[4], ppDataPkt->buf[5], ppDataPkt->buf[6], ppDataPkt->buf[7], ppDataPkt->buf[8], ppDataPkt->buf[9], ppDataPkt->buf[10], ppDataPkt->buf[11]);
			wsprintf(szTDebug, "Header: %02lX %02lX %02lX %02lX\r\n", (BYTE)ppDataPkt->buf[0], (BYTE)ppDataPkt->buf[1], (BYTE)ppDataPkt->buf[2], (BYTE)ppDataPkt->buf[3]);
			OutputDebugString(szTDebug);
			wsprintf(szTDebug, "dword1: %02lX %02lX %02lX %02lX\r\n", (BYTE)ppDataPkt->buf[4], (BYTE)ppDataPkt->buf[5], (BYTE)ppDataPkt->buf[6], (BYTE)ppDataPkt->buf[7]);
			OutputDebugString(szTDebug);
			wsprintf(szTDebug, "dword2: %02lX %02lX %02lX %02lX\r\n", (BYTE)ppDataPkt->buf[8], (BYTE)ppDataPkt->buf[9], (BYTE)ppDataPkt->buf[10], (BYTE)ppDataPkt->buf[11]);
			OutputDebugString(szTDebug);
#endif

			// The H.261 payload header size is always 4 bytes long
			dwHeaderSize = 4;

			// Look at the payload header to figure out if the frame is a keyframe
			*pfReceivedKeyframe |= (BOOL)(ppDataPkt->buf[0] & 0x02);

			// The purpose of this code is to look for the presence of the
			// Picture Start Code at the beginning of the frame. If it is
			// not present, we should break in debug mode.

			// Only look for PSC at the beginning of the frame
			if (!*pdwFrameSize)
			{
				// The start of the frame may not be at a byte boundary. The SBIT field
				// of the header ((BYTE)ppDataPkt->buf[0] & 0xE0) will tell us exactly where
				// our frame starts. We then look for the PSC (0000 0000 0000 0001 0000 bits)
				*((BYTE *)&dwPSCBytes + 3) = *(BYTE *)&(ppDataPkt->buf[dwHeaderSize]);
				*((BYTE *)&dwPSCBytes + 2) = *(BYTE *)&(ppDataPkt->buf[dwHeaderSize + 1]);
				*((BYTE *)&dwPSCBytes + 1) = *(BYTE *)&(ppDataPkt->buf[dwHeaderSize + 2]);
				*((BYTE *)&dwPSCBytes + 0) = *(BYTE *)&(ppDataPkt->buf[dwHeaderSize + 3]);
				dwPSCBytes <<= ((DWORD)((BYTE)ppDataPkt->buf[0] & 0xE0) >> 5);
				if ((dwPSCBytes & 0xFFFFF000) != 0x00010000)
				{
#ifdef DEBUG
					wsprintf(szTDebug, "VCMSTRM: The first packet to reassemble is missing a PSC!\r\n");
					OutputDebugString(szTDebug);
					// DebugBreak();
#endif
					return ((MMRESULT)VCMERR_PSCMISSING);
				}
			}

			// The end of a buffer and the start of the next buffer could belong to the
			// same byte. If this is the case, the first byte of the next buffer was already
			// copied in the video data buffer, with the previous packet. It should not be copied
			// twice. The SBIT field of the payload header allows us to figure out if this is the case.
			if (*pdwFrameSize && (ppDataPkt->buf[0] & 0xE0))
				dwHeaderSize++;

			// Copy the payload
			// Test for invalid packets that have a length below the size of the payload header
			if ( (ppDataPkt->len >= dwHeaderSize) && ((*pdwFrameSize + ppDataPkt->len - dwHeaderSize) <= dwMaxFrameSize) )
			{
				// Copy the payload
				CopyMemory(pbyFrame + *pdwFrameSize, ppDataPkt->buf + dwHeaderSize, ppDataPkt->len - dwHeaderSize);

				// Update the payload size and pointer to the input video packets
				*pdwFrameSize += ppDataPkt->len - dwHeaderSize;
				ppDataPkt++;
			}
			else
			{
				// The total size of the reassembled packet would be larger than the maximum allowed!!!
				// Or the packet has a length less than the payload header size
				// Dump the frame
#ifdef DEBUG
				wsprintf(szTDebug, (ppDataPkt->len >= dwHeaderSize) ? "VCMSTRM: Cumulative size of the reassembled packets is too large: discarding frame!\r\n" : "VCMSTRM: Packet length is smaller than payload header size: discarding frame!\r\n");
				OutputDebugString(szTDebug);
				// DebugBreak();
#endif
				return ((MMRESULT)VCMERR_NONSPECIFIC);
			}

		}

#ifdef LOGPAYLOAD_ON
		g_TDebugFile = CreateFile("C:\\RecvLog.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
		SetFilePointer(g_TDebugFile, 0, NULL, FILE_END);
		wsprintf(szTDebug, "Frame #%03ld\r\n", (DWORD)j);
		WriteFile(g_TDebugFile, szTDebug, strlen(szTDebug), &d, NULL);
		for (j=*pdwFrameSize; j>0; j-=4, p+=4)
		{
			wsprintf(szTDebug, "%02lX %02lX %02lX %02lX\r\n", *((BYTE *)p), *((BYTE *)p+1), *((BYTE *)p+2), *((BYTE *)p+3));
			WriteFile(g_TDebugFile, szTDebug, strlen(szTDebug), &d, NULL);
		}
		CloseHandle(g_TDebugFile);
#endif

	}
	else
	{
		// Strip the header of each packet and copy the payload in the video buffer
		while (dwPktCount--)
		{
			// Copy the payload
			// Test for invalid packets that have a length below the size of the payload header
			if ( (ppDataPkt->len >= dwHeaderSize) && ((*pdwFrameSize + ppDataPkt->len - dwHeaderSize) <= dwMaxFrameSize))
			{
				// Copy the payload
				CopyMemory(pbyFrame + *pdwFrameSize, ppDataPkt->buf + dwHeaderSize, ppDataPkt->len - dwHeaderSize);

				// Update the payload size and pointer to the input video packets
				*pdwFrameSize += ppDataPkt->len - dwHeaderSize;
				ppDataPkt++;
			}
			else
			{
				// The total size of the reassembled packet would be larger than the maximum allowed!!!
				// Or the packet has a length less than the payload header size
				// Dump the frame
#ifdef DEBUG
				wsprintf(szTDebug, (ppDataPkt->len >= dwHeaderSize) ? "VCMSTRM: Cumulative size of the reassembled packets is too large: discarding frame!\r\n" : "VCMSTRM: Packet length is smaller than payload header size: discarding frame!\r\n");
				OutputDebugString(szTDebug);
				// DebugBreak();
#endif
				return ((MMRESULT)VCMERR_NONSPECIFIC);
			}

		}
	}

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 * @doc EXTERNAL COMPFUNC
 *
 * @func MMRESULT | vcmStreamFormatPayload | This function returns compressed data
 *   spread into data packets with a payload header for the specific format of the
 *   compressed data.
 *
 * @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 * @parm PBYTE | pDataSrc | Specifies a pointer to the whole compressed data.
 *
 * @parm DWORD | dwDataSize | Specifies the size of the input data in bytes.
 *
 * @parm PBYTE* | ppDataPkt | Specifies a pointer to a pointer to a packet.
 *
 * @parm DWORD* | pdwPktSize | Specifies a pointer to the size of the packet.
 *
 * @parm DWORD | dwPktCount | Specifies what packet to return (0 first packet, 1 second packet, ...)
 *
 * @parm DWORD | dwMaxFragSize | Specifies the maximum packet size
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *   @flag MMSYSERR_INVALPARAM | Specified data pointer is invalid.
 *   @flag VCMERR_NOMOREPACKETS | There is no more data for the requested packet number, or there isn't any handler for this payload.
 *   @flag VCMERR_NONSPECIFIC | We were asked to put a header we do not know how to generate.
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamFormatPayload(	HVCMSTREAM hvs,
										PBYTE pDataSrc,
										DWORD dwDataSize,
										PBYTE *ppDataPkt,
										PDWORD pdwPktSize,
										PDWORD pdwPktCount,
										UINT *pfMark,
										PBYTE *pHdrInfo,
										PDWORD pdwHdrSize)
{
	PVCMSTREAM					pvs = (PVCMSTREAM)hvs;
	PH26X_RTP_BSINFO_TRAILER	pbsiT;
	PRTP_H263_BSINFO			pbsi263;
	PRTP_H261_BSINFO			pbsi261;
	PBYTE						pb;
	DWORD						dwHeaderHigh = 0UL; // most significant
	DWORD						dwHeaderMiddle = 0UL;
	DWORD						dwHeaderLow = 0UL; // least significant
	BOOL						bOneFrameOnePacket;
#ifdef DEBUG
	char						szDebug[256];
#endif
	long						i;
#ifdef LOGPAYLOAD_ON
	PBYTE						p;
	DWORD						d;
	DWORD						dwLastChunk;
	DWORD						wPrevOffset;
#endif

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamFormatPayload: Specified handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}
	if (!pDataSrc)
	{
		ERRORMESSAGE(("vcmStreamFormatPayload: Specified pointer is invalid, pDataSrc=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Initialize packet pointer
	*ppDataPkt  = pDataSrc;
	*pdwPktSize = dwDataSize;
	*pfMark = 1;
	bOneFrameOnePacket = FALSE;

	// Put the code that builds the packets right here!!!
#ifndef _ALPHA_
#ifdef USE_BILINEAR_MSH26X
	if ((pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_MSH263) || (pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_MSH26X))
#else
	if (pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_MSH263)
#endif
#else
	if (pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_DECH263)
#endif
	{
		// Look for the bitstream info trailer
		pbsiT = (PH26X_RTP_BSINFO_TRAILER)(pDataSrc + dwDataSize - sizeof(H26X_RTP_BSINFO_TRAILER));

		// If the whole frame can fit in pvs->dwMaxPacketSize, send it non fragmented
		if ((pbsiT->dwCompressedSize + 4) < pvs->dwMaxPacketSize)
			bOneFrameOnePacket = TRUE;

		// Look for the packet to receive a H.263 payload header
		if ((*pdwPktCount < pbsiT->dwNumOfPackets) && !(bOneFrameOnePacket && *pdwPktCount))
		{

#ifdef _ALPHA_
			// Verify that the content of the bistream info structures is correct
			// If not, do not parse the frame, and fail the call
			// This is to solve problems with the data returned by the DEC codecs
			if (!*pdwPktCount)
			{
				pbsi263 = (PRTP_H263_BSINFO)((PBYTE)pbsiT - pbsiT->dwNumOfPackets * sizeof(RTP_H263_BSINFO));
				for (i=1; i<(long)pbsiT->dwNumOfPackets; i++, pbsi263++)
				{
					if ((pbsi263->dwBitOffset >= (pbsi263+1)->dwBitOffset) || ((pbsiT->dwCompressedSize*8) <= pbsi263->dwBitOffset))
					{
#ifdef DEBUG
						OutputDebugString("VCMSTRM: The content of the extended bitstream info structures is invalid!\r\n");
#endif
						// return ((MMRESULT)VCMERR_NONSPECIFIC);
						bOneFrameOnePacket = TRUE;
					}
				}

				// Test last info strucure
				if ( !bOneFrameOnePacket && ((pbsiT->dwCompressedSize*8) <= pbsi263->dwBitOffset))
				{
#ifdef DEBUG
					OutputDebugString("VCMSTRM: The content of the extended bitstream info structures is invalid!\r\n");
#endif
					// return ((MMRESULT)VCMERR_NONSPECIFIC);
					bOneFrameOnePacket = TRUE;
				}
			}
#endif

#ifdef LOGPAYLOAD_ON
			// Dump the whole frame in the debug window for comparison with receive side
			if (!*pdwPktCount)
			{
				g_DebugFile = CreateFile("C:\\SendLog.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
				SetFilePointer(g_DebugFile, 0, NULL, FILE_END);
				wsprintf(szDebug, "Frame #%03ld\r\n", (DWORD)pbsiT->byTR);
				WriteFile(g_DebugFile, szDebug, strlen(szDebug), &d, NULL);
				wsprintf(szDebug, "Frame #%03ld has %1ld packets of size ", (DWORD)pbsiT->byTR, (DWORD)pbsiT->dwNumOfPackets);
				OutputDebugString(szDebug);
				pbsi263 = (PRTP_H263_BSINFO)((PBYTE)pbsiT - pbsiT->dwNumOfPackets * sizeof(RTP_H263_BSINFO));
				for (i=1; i<(long)pbsiT->dwNumOfPackets; i++)
				{
					wPrevOffset = pbsi263->dwBitOffset;
					pbsi263++;
					wsprintf(szDebug, "%04ld, ", (DWORD)(pbsi263->dwBitOffset - wPrevOffset) >> 3);
					OutputDebugString(szDebug);
				}
				wsprintf(szDebug, "%04ld\r\n", (DWORD)(pbsiT->dwCompressedSize * 8 - pbsi263->dwBitOffset) >> 3);
				OutputDebugString(szDebug);
				for (i=pbsiT->dwCompressedSize, p=pDataSrc; i>0; i-=4, p+=4)
				{
					wsprintf(szDebug, "%02lX %02lX %02lX %02lX\r\n", *((BYTE *)p), *((BYTE *)p+1), *((BYTE *)p+2), *((BYTE *)p+3));
					WriteFile(g_DebugFile, szDebug, strlen(szDebug), &d, NULL);
				}
				CloseHandle(g_DebugFile);
			}
#endif
			
			// Look for the bitstream info structure
			pbsi263 = (PRTP_H263_BSINFO)((PBYTE)pbsiT - (pbsiT->dwNumOfPackets - *pdwPktCount) * sizeof(RTP_H263_BSINFO));
			
			// Set the marker bit: as long as this is not the last packet of the frame
			// this bit needs to be set to 0
			if (!bOneFrameOnePacket)
			{
				// Count the number of GOBS that could fit in pvs->dwMaxPacketSize
				for (i=1; (i<(long)(pbsiT->dwNumOfPackets - *pdwPktCount)) && (pbsi263->byMode != RTP_H263_MODE_B); i++)
				{
					// Don't try to add a Mode B packet to the end of another Mode A or Mode B packet
					if (((pbsi263+i)->dwBitOffset - pbsi263->dwBitOffset > (pvs->dwMaxPacketSize * 8)) || ((pbsi263+i)->byMode == RTP_H263_MODE_B))
						break;
				}

				if (i < (long)(pbsiT->dwNumOfPackets - *pdwPktCount))
				{
					*pfMark = 0;
					if (i>1)
						i--;
				}
				else
				{
					// Hey! You 're forgetting the last GOB! It could make the total
					// size of the last packet larger than pvs->dwMaxPacketSize... Imbecile!
					if ((pbsiT->dwCompressedSize * 8 - pbsi263->dwBitOffset > (pvs->dwMaxPacketSize * 8)) && (i>1))
					{
						*pfMark = 0;
						i--;
					}
				}

#if 0
				//
				// THIS IS FOR EXPERIMENTATION ONLY !!!
				//

				// Ditch the last GOB
				if ((*pfMark == 1) && (i == 1))
					return ((MMRESULT)VCMERR_NOMOREPACKETS);
#endif
			}

			// Go to the beginning of the data
			pb = pDataSrc + pbsi263->dwBitOffset / 8;

#if 0
			//
			// THIS IS FOR EXPERIMENTATION ONLY !!!
			//

			// Trash the PSC once in a while to see how the other end reacts
			if (!*pdwPktCount && (((*pb == 0) && (*(pb+1) == 0) && ((*(pb+2) & 0xFC) == 0x80))))
			{
				// The previous test guarantees that it is in fact a PSC that we trash...
				if ((DWORD)(RAND_MAX - rand()) < (DWORD)(RAND_MAX / 10))
					*pb = 0xFF;
			}
#endif

#ifdef DEBUG
			if (!*pdwPktCount && (((*pb != 0) || (*(pb+1) != 0) || ((*(pb+2) & 0xFC) != 0x80))))
			{
				wsprintf(szDebug, "VCMSTRM: This compressed frame is missing a PSC!\r\n");
				OutputDebugString(szDebug);
				// DebugBreak();
			}
#endif

			// Look for the kind of header to be built
			if (pbsi263->byMode == RTP_H263_MODE_A)
			{
				// Build a header in mode A

				// 0                   1                   2                   3
				// 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
				//|F|P|SBIT |EBIT | SRC | R       |I|A|S|DBQ| TRB |    TR         |
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
				// But that's the network byte order...

				// F bit already set to 0

				// Set the SRC bits
				dwHeaderHigh |= ((DWORD)(pbsiT->bySrc)) << 21;

				// R bits already set to 0

				// Set the P bit
				dwHeaderHigh |= (pbsiT->dwFlags & RTP_H263_PB) << 29;

				// Set the I bit
				dwHeaderHigh |= (pbsiT->dwFlags & RTP_H26X_INTRA_CODED) << 15;

				// Set the A bit
				dwHeaderHigh |= (pbsiT->dwFlags & RTP_H263_AP) << 12;

				// Set the S bit
				dwHeaderHigh |= (pbsiT->dwFlags & RTP_H263_SAC) << 10;

				// Set the DBQ bits
				dwHeaderHigh |= ((DWORD)(pbsiT->byDBQ)) << 11;

				// Set the TRB bits
				dwHeaderHigh |= ((DWORD)(pbsiT->byTRB)) << 8;

				// Set the TR bits
				dwHeaderHigh |= ((DWORD)(pbsiT->byTR));

				// Special case: 1 frame = 1 packet
				if (bOneFrameOnePacket)
				{
					// SBIT is already set to 0

					// EBIT is already set to 0

#ifdef VALIDATE_SBIT_EBIT // { VALIDATE_SBIT_EBIT
					ERRORMESSAGE(("vcmFormatPayload: (1F1P) Previous EBIT=%ld, current SBIT=%ld, current EBIT=%ld (New frame)\r\n", g_dwPreviousEBIT, (DWORD)(dwHeaderHigh & 0x38000000) >> 27, (DWORD)(dwHeaderHigh & 0x07000000) >> 24));
#endif // } VALIDATE_SBIT_EBIT

					// Update the packet size
					*pdwPktSize = pbsiT->dwCompressedSize + 4;

					// Update the packet count
					*pdwPktCount = pbsiT->dwNumOfPackets;

				}
				else
				{
#ifdef VALIDATE_SBIT_EBIT // { VALIDATE_SBIT_EBIT
					DWORD dwCurrentSBIT;
#endif // } VALIDATE_SBIT_EBIT

					// Set the SBIT bits
					dwHeaderHigh |= (pbsi263->dwBitOffset % 8) << 27;

					// Set the EBIT bits
					if ((pbsiT->dwNumOfPackets - *pdwPktCount - i) >= 1)
						dwHeaderHigh |= (DWORD)((8UL - ((pbsi263+i)->dwBitOffset % 8)) & 0x00000007) << 24;

#ifdef VALIDATE_SBIT_EBIT // { VALIDATE_SBIT_EBIT
					// Compare this to the previous EBIT. If the sum of the two
					// is not equal to 8 or 0, something's broken
					if (*pdwPktCount)
						ERRORMESSAGE(("vcmFormatPayload: Previous EBIT=%ld, current SBIT=%ld, current EBIT=%ld\r\n", g_dwPreviousEBIT, (DWORD)(dwHeaderHigh & 0x38000000) >> 27, (DWORD)(dwHeaderHigh & 0x07000000) >> 24));
					else
						ERRORMESSAGE(("vcmFormatPayload: Previous EBIT=%ld, current SBIT=%ld, current EBIT=%ld (New frame)\r\n", g_dwPreviousEBIT, (DWORD)(dwHeaderHigh & 0x38000000) >> 27, (DWORD)(dwHeaderHigh & 0x07000000) >> 24));

					// Only test this if this is the first packet
					dwCurrentSBIT = (DWORD)(dwHeaderHigh & 0x38000000) >> 27;
					if ((*pdwPktCount) && (((dwCurrentSBIT + g_dwPreviousEBIT) != 8) && (((dwCurrentSBIT + g_dwPreviousEBIT) != 0))))
						DebugBreak();

					g_dwPreviousEBIT = (dwHeaderHigh & 0x07000000) >> 24;
#endif // } VALIDATE_SBIT_EBIT

					// Update the packet size
					if ((pbsiT->dwNumOfPackets - *pdwPktCount - i) >= 1)
						*pdwPktSize = (((pbsi263+i)->dwBitOffset - 1) / 8) - (pbsi263->dwBitOffset / 8) + 1 + 4;
					else
						*pdwPktSize = pbsiT->dwCompressedSize - pbsi263->dwBitOffset / 8 + 4;

					// Update the packet count
					*pdwPktCount += i;

				}

#if 0
				// Save the header right before the data chunk
				*ppDataPkt = pDataSrc + (pbsi263->dwBitOffset / 8) - 4;

				// Convert to network byte order
				*((BYTE *)*ppDataPkt+3) = (BYTE)(dwHeaderHigh & 0x000000FF);
				*((BYTE *)*ppDataPkt+2) = (BYTE)((dwHeaderHigh >> 8) & 0x000000FF);
				*((BYTE *)*ppDataPkt+1) = (BYTE)((dwHeaderHigh >> 16) & 0x000000FF);
				*((BYTE *)*ppDataPkt) = (BYTE)((dwHeaderHigh >> 24) & 0x000000FF);
#else
				// Save the header right before the data chunk
				*ppDataPkt = pDataSrc + (pbsi263->dwBitOffset / 8) - 4;
                *pdwHdrSize=4;

				// Convert to network byte order
				*((BYTE *)*pHdrInfo+3) = (BYTE)(dwHeaderHigh & 0x000000FF);
				*((BYTE *)*pHdrInfo+2) = (BYTE)((dwHeaderHigh >> 8) & 0x000000FF);
				*((BYTE *)*pHdrInfo+1) = (BYTE)((dwHeaderHigh >> 16) & 0x000000FF);
				*((BYTE *)*pHdrInfo) = (BYTE)((dwHeaderHigh >> 24) & 0x000000FF);
#endif

#ifdef LOGPAYLOAD_ON
				// Output some debug stuff
				wsprintf(szDebug, "Header content:\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, (*(BYTE *)*ppDataPkt & 0x80) ? "     F:   '1' => Mode B or C\r\n" : "     F:   '0' => Mode A\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, (*(BYTE *)*ppDataPkt & 0x40) ? "     P:   '1' => PB-frame\r\n" : "     P:   '0' => I or P frame\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, "  SBIT:    %01ld\r\n", (DWORD)((*(BYTE *)*ppDataPkt & 0x38) >> 3));
				OutputDebugString(szDebug);
				wsprintf(szDebug, "  EBIT:    %01ld\r\n", (DWORD)(*(BYTE *)*ppDataPkt & 0x07));
				OutputDebugString(szDebug);
				switch ((DWORD)(*((BYTE *)*ppDataPkt+1) >> 5))
				{
					case 0:
						wsprintf(szDebug, "   SRC: '000' => Source format forbidden!\r\n");
						break;
					case 1:
						wsprintf(szDebug, "   SRC: '001' => Source format sub-QCIF\r\n");
						break;
					case 2:
						wsprintf(szDebug, "   SRC: '010' => Source format QCIF\r\n");
						break;
					case 3:
						wsprintf(szDebug, "   SRC: '011' => Source format CIF\r\n");
						break;
					case 4:
						wsprintf(szDebug, "   SRC: '100' => Source format 4CIF\r\n");
						break;
					case 5:
						wsprintf(szDebug, "   SRC: '101' => Source format 16CIF\r\n");
						break;
					case 6:
						wsprintf(szDebug, "   SRC: '110' => Source format reserved\r\n");
						break;
					case 7:
						wsprintf(szDebug, "   SRC: '111' => Source format reserved\r\n");
						break;
					default:
						wsprintf(szDebug, "   SRC: %ld => Source format unknown!\r\n", (DWORD)(*((BYTE *)*ppDataPkt+1) >> 5));
						break;
				}
				OutputDebugString(szDebug);
				wsprintf(szDebug, "     R:   %02ld  => Reserved, must be 0\r\n", (DWORD)((*((BYTE *)*ppDataPkt+1) & 0x1F) >> 5));
				OutputDebugString(szDebug);
				wsprintf(szDebug, (*((BYTE *)*ppDataPkt+2) & 0x80) ? "     I:   '1' => Intra-coded\r\n" : "     I:   '0' => Not Intra-coded\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, (*((BYTE *)*ppDataPkt+2) & 0x40) ? "     A:   '1' => Optional Advanced Prediction mode ON\r\n" : "     A:   '0' => Optional Advanced Prediction mode OFF\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, (*((BYTE *)*ppDataPkt+2) & 0x20) ? "     S:   '1' => Optional Syntax-based Arithmetic Code mode ON\r\n" : "     S:   '0' => Optional Syntax-based Arithmetic Code mode OFF\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, "   DBQ:    %01ld  => Should be 0\r\n", (DWORD)((*((BYTE *)*ppDataPkt+2) & 0x18) >> 3));
				OutputDebugString(szDebug);
				wsprintf(szDebug, "   TRB:    %01ld  => Should be 0\r\n", (DWORD)(*((BYTE *)*ppDataPkt+2) & 0x07));
				OutputDebugString(szDebug);
				wsprintf(szDebug, "    TR:  %03ld\r\n", (DWORD)(*((BYTE *)*ppDataPkt+3)));
				OutputDebugString(szDebug);
				wsprintf(szDebug, "Packet: %02lX\r\n Header: %02lX %02lX %02lX %02lX\r\n dword1: %02lX %02lX %02lX %02lX\r\n dword2: %02lX %02lX %02lX %02lX\r\n", *pdwPktCount, *((BYTE *)*ppDataPkt), *((BYTE *)*ppDataPkt+1), *((BYTE *)*ppDataPkt+2), *((BYTE *)*ppDataPkt+3), *((BYTE *)*ppDataPkt+4), *((BYTE *)*ppDataPkt+5), *((BYTE *)*ppDataPkt+6), *((BYTE *)*ppDataPkt+7), *((BYTE *)*ppDataPkt+8), *((BYTE *)*ppDataPkt+9), *((BYTE *)*ppDataPkt+10), *((BYTE *)*ppDataPkt+11));
				OutputDebugString(szDebug);
				if (*pdwPktCount == pbsiT->dwNumOfPackets)
					wsprintf(szDebug, " Tail  : %02lX %02lX XX XX\r\n", *((BYTE *)*ppDataPkt+*pdwPktSize-2), *((BYTE *)*ppDataPkt+*pdwPktSize-1));
				else
					wsprintf(szDebug, " Tail  : %02lX %02lX %02lX %02lX\r\n", *((BYTE *)*ppDataPkt+*pdwPktSize-2), *((BYTE *)*ppDataPkt+*pdwPktSize-1), *((BYTE *)*ppDataPkt+*pdwPktSize), *((BYTE *)*ppDataPkt+*pdwPktSize+1));
				OutputDebugString(szDebug);
				if (*pfMark == 1)
					wsprintf(szDebug, " Marker: ON\r\n");
				else
					wsprintf(szDebug, " Marker: OFF\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, "Frame #%03ld, Packet of size %04ld\r\n", (DWORD)pbsiT->byTR, *pdwPktSize);
				OutputDebugString(szDebug);
#endif
			}
			else if (pbsi263->byMode == RTP_H263_MODE_B)
			{
				// Build a header in mode B

				// 0                   1                   2                   3
				// 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
				//|F|P|SBIT |EBIT | SRC | QUANT   |I|A|S|  GOBN   |   MBA         |
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
				//| HMV1          |  VMV1         |  HMV2         |   VMV2        |
				//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

				// But that's the network byte order...

				// Set the F bit to 1
				dwHeaderHigh = 0x80000000;

				// Set the SRC bits
				dwHeaderHigh |= ((DWORD)(pbsiT->bySrc)) << 21;

				// Set the QUANT bits
				dwHeaderHigh |= ((DWORD)(pbsi263->byQuant)) << 16;

				// Set the P bit
				dwHeaderHigh |= (pbsiT->dwFlags & RTP_H263_PB) << 29;

				// Set the I bit
				dwHeaderHigh |= (pbsiT->dwFlags & RTP_H26X_INTRA_CODED) << 15;

				// Set the A bit
				dwHeaderHigh |= (pbsiT->dwFlags & RTP_H263_AP) << 12;

				// Set the S bit
				dwHeaderHigh |= (pbsiT->dwFlags & RTP_H263_SAC) << 10;

				// Set the GOBN bits
				dwHeaderHigh |= ((DWORD)(pbsi263->byGOBN)) << 8;

				// Set the TR bits
				dwHeaderHigh |= ((DWORD)(pbsi263->byMBA));

				// Set the HMV1 bits
				dwHeaderLow |= ((DWORD)(BYTE)(pbsi263->cHMV1)) << 24;

				// Set the VMV1 bits
				dwHeaderLow |= ((DWORD)(BYTE)(pbsi263->cVMV1)) << 16;

				// Set the HMV2 bits
				dwHeaderLow |= ((DWORD)(BYTE)(pbsi263->cHMV2)) << 8;

				// Set the VMV2 bits
				dwHeaderLow |= ((DWORD)(BYTE)(pbsi263->cVMV2));

				// Special case: 1 frame = 1 packet
				if (bOneFrameOnePacket)
				{
					// SBIT is already set to 0

					// EBIT is already set to 0

#ifdef VALIDATE_SBIT_EBIT // { VALIDATE_SBIT_EBIT
					ERRORMESSAGE(("vcmFormatPayload: (1F1P) Previous EBIT=%ld, current SBIT=%ld, current EBIT=%ld (New frame)\r\n", g_dwPreviousEBIT, (DWORD)(dwHeaderHigh & 0x38000000) >> 27, (DWORD)(dwHeaderHigh & 0x07000000) >> 24));
#endif // } VALIDATE_SBIT_EBIT

					// Update the packet size
					*pdwPktSize = pbsiT->dwCompressedSize + 8;

					// Update the packet count
					*pdwPktCount = pbsiT->dwNumOfPackets;

				}
				else
				{

#ifdef VALIDATE_SBIT_EBIT // { VALIDATE_SBIT_EBIT
					DWORD dwCurrentSBIT;
#endif // } VALIDATE_SBIT_EBIT

					// Set the SBIT bits
					dwHeaderHigh |= (pbsi263->dwBitOffset % 8) << 27;

					// Set the EBIT bits
					if ((pbsiT->dwNumOfPackets - *pdwPktCount - i) >= 1)
						dwHeaderHigh |= (DWORD)((8UL - ((pbsi263+i)->dwBitOffset % 8)) & 0x00000007) << 24;

#ifdef VALIDATE_SBIT_EBIT // { VALIDATE_SBIT_EBIT
					// Compare this to the previous EBIT. If the sum of the two
					// is not equal to 8 or 0, something's broken
					if (*pdwPktCount)
						ERRORMESSAGE(("vcmFormatPayload: Previous EBIT=%ld, current SBIT=%ld, current EBIT=%ld\r\n", g_dwPreviousEBIT, (DWORD)(dwHeaderHigh & 0x38000000) >> 27, (DWORD)(dwHeaderHigh & 0x07000000) >> 24));
					else
						ERRORMESSAGE(("vcmFormatPayload: Previous EBIT=%ld, current SBIT=%ld, current EBIT=%ld (New frame)\r\n", g_dwPreviousEBIT, (DWORD)(dwHeaderHigh & 0x38000000) >> 27, (DWORD)(dwHeaderHigh & 0x07000000) >> 24));

					// Only test this if this is the first packet
					dwCurrentSBIT = (DWORD)(dwHeaderHigh & 0x38000000) >> 27;
					if ((*pdwPktCount) && (((dwCurrentSBIT + g_dwPreviousEBIT) != 8) && (((dwCurrentSBIT + g_dwPreviousEBIT) != 0))))
						DebugBreak();

					g_dwPreviousEBIT = (dwHeaderHigh & 0x07000000) >> 24;
#endif // } VALIDATE_SBIT_EBIT

					// Update the packet size
					if ((pbsiT->dwNumOfPackets - *pdwPktCount - i) >= 1)
						*pdwPktSize = (((pbsi263+i)->dwBitOffset - 1) / 8) - (pbsi263->dwBitOffset / 8) + 1 + 8;
					else
						*pdwPktSize = pbsiT->dwCompressedSize - pbsi263->dwBitOffset / 8 + 8;

					// Update the packet count
					*pdwPktCount += i;

				}

#if 0
				// Save the header right before the data chunk
				*ppDataPkt = pDataSrc + (pbsi263->dwBitOffset / 8) - 8;

				// Convert to network byte order
				*((BYTE *)*ppDataPkt+3) = (BYTE)(dwHeaderHigh & 0x000000FF);
				*((BYTE *)*ppDataPkt+2) = (BYTE)((dwHeaderHigh >> 8) & 0x000000FF);
				*((BYTE *)*ppDataPkt+1) = (BYTE)((dwHeaderHigh >> 16) & 0x000000FF);
				*((BYTE *)*ppDataPkt) = (BYTE)((dwHeaderHigh >> 24) & 0x000000FF);
				*((BYTE *)*ppDataPkt+7) = (BYTE)(dwHeaderLow & 0x000000FF);
				*((BYTE *)*ppDataPkt+6) = (BYTE)((dwHeaderLow >> 8) & 0x000000FF);
				*((BYTE *)*ppDataPkt+5) = (BYTE)((dwHeaderLow >> 16) & 0x000000FF);
				*((BYTE *)*ppDataPkt+4) = (BYTE)((dwHeaderLow >> 24) & 0x000000FF);
#else
				// Save the header right before the data chunk
				*ppDataPkt = pDataSrc + (pbsi263->dwBitOffset / 8) - 8;
                *pdwHdrSize=8;

				// Convert to network byte order
				*((BYTE *)*pHdrInfo+3) = (BYTE)(dwHeaderHigh & 0x000000FF);
				*((BYTE *)*pHdrInfo+2) = (BYTE)((dwHeaderHigh >> 8) & 0x000000FF);
				*((BYTE *)*pHdrInfo+1) = (BYTE)((dwHeaderHigh >> 16) & 0x000000FF);
				*((BYTE *)*pHdrInfo) = (BYTE)((dwHeaderHigh >> 24) & 0x000000FF);
				*((BYTE *)*pHdrInfo+7) = (BYTE)(dwHeaderLow & 0x000000FF);
				*((BYTE *)*pHdrInfo+6) = (BYTE)((dwHeaderLow >> 8) & 0x000000FF);
				*((BYTE *)*pHdrInfo+5) = (BYTE)((dwHeaderLow >> 16) & 0x000000FF);
				*((BYTE *)*pHdrInfo+4) = (BYTE)((dwHeaderLow >> 24) & 0x000000FF);
#endif

#ifdef LOGPAYLOAD_ON
				// Output some info
				wsprintf(szDebug, "Header content:\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, (*(BYTE *)*ppDataPkt & 0x80) ? "     F:   '1' => Mode B or C\r\n" : "     F:   '0' => Mode A\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, (*(BYTE *)*ppDataPkt & 0x40) ? "     P:   '1' => PB-frame\r\n" : "     P:   '0' => I or P frame\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, "  SBIT:    %01ld\r\n", (DWORD)((*(BYTE *)*ppDataPkt & 0x38) >> 3));
				OutputDebugString(szDebug);
				wsprintf(szDebug, "  EBIT:    %01ld\r\n", (DWORD)(*(BYTE *)*ppDataPkt & 0x07));
				OutputDebugString(szDebug);
				switch ((DWORD)(*((BYTE *)*ppDataPkt+1) >> 5))
				{
					case 0:
						wsprintf(szDebug, "   SRC: '000' => Source format forbidden!\r\n");
						break;
					case 1:
						wsprintf(szDebug, "   SRC: '001' => Source format sub-QCIF\r\n");
						break;
					case 2:
						wsprintf(szDebug, "   SRC: '010' => Source format QCIF\r\n");
						break;
					case 3:
						wsprintf(szDebug, "   SRC: '011' => Source format CIF\r\n");
						break;
					case 4:
						wsprintf(szDebug, "   SRC: '100' => Source format 4CIF\r\n");
						break;
					case 5:
						wsprintf(szDebug, "   SRC: '101' => Source format 16CIF\r\n");
						break;
					case 6:
						wsprintf(szDebug, "   SRC: '110' => Source format reserved\r\n");
						break;
					case 7:
						wsprintf(szDebug, "   SRC: '111' => Source format reserved\r\n");
						break;
					default:
						wsprintf(szDebug, "   SRC: %ld => Source format unknown!\r\n", (DWORD)(*((BYTE *)*ppDataPkt+1) >> 5));
						break;
				}
				OutputDebugString(szDebug);
				wsprintf(szDebug, " QUANT:   %02ld\r\n", (DWORD)((*((BYTE *)*ppDataPkt+1) & 0x1F) >> 5));
				OutputDebugString(szDebug);
				wsprintf(szDebug, (*((BYTE *)*ppDataPkt+2) & 0x80) ? "     I:   '1' => Intra-coded\r\n" : "     I:   '0' => Not Intra-coded\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, (*((BYTE *)*ppDataPkt+2) & 0x40) ? "     A:   '1' => Optional Advanced Prediction mode ON\r\n" : "     A:   '0' => Optional Advanced Prediction mode OFF\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, (*((BYTE *)*ppDataPkt+2) & 0x20) ? "     S:   '1' => Optional Syntax-based Arithmetic Code mode ON\r\n" : "     S:   '0' => Optional Syntax-based Arithmetic Code mode OFF\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, "  GOBN:  %03ld\r\n", (DWORD)(*((BYTE *)*ppDataPkt+2) & 0x1F));
				OutputDebugString(szDebug);
				wsprintf(szDebug, "   MBA:  %03ld\r\n", (DWORD)(*((BYTE *)*ppDataPkt+3)));
				OutputDebugString(szDebug);
				wsprintf(szDebug, "  HMV1:  %03ld\r\n", (DWORD)(*((BYTE *)*ppDataPkt+7)));
				OutputDebugString(szDebug);
				wsprintf(szDebug, "  VMV1:  %03ld\r\n", (DWORD)(*((BYTE *)*ppDataPkt+6)));
				OutputDebugString(szDebug);
				wsprintf(szDebug, "  HMV2:  %03ld\r\n", (DWORD)(*((BYTE *)*ppDataPkt+5)));
				OutputDebugString(szDebug);
				wsprintf(szDebug, "  VMV2:  %03ld\r\n", (DWORD)(*((BYTE *)*ppDataPkt+4)));
				OutputDebugString(szDebug);
				wsprintf(szDebug, "Packet: %02lX\r\n Header: %02lX %02lX %02lX %02lX %02lX %02lX %02lX %02lX\r\n dword1: %02lX %02lX %02lX %02lX\r\n", *pdwPktCount, *((BYTE *)*ppDataPkt), *((BYTE *)*ppDataPkt+1), *((BYTE *)*ppDataPkt+2), *((BYTE *)*ppDataPkt+3), *((BYTE *)*ppDataPkt+4), *((BYTE *)*ppDataPkt+5), *((BYTE *)*ppDataPkt+6), *((BYTE *)*ppDataPkt+7), *((BYTE *)*ppDataPkt+8), *((BYTE *)*ppDataPkt+9), *((BYTE *)*ppDataPkt+10), *((BYTE *)*ppDataPkt+11));
				OutputDebugString(szDebug);
				if (*pdwPktCount == pbsiT->dwNumOfPackets)
					wsprintf(szDebug, " Tail  : %02lX %02lX XX XX\r\n", *((BYTE *)*ppDataPkt+*pdwPktSize-2), *((BYTE *)*ppDataPkt+*pdwPktSize-1));
				else
					wsprintf(szDebug, " Tail  : %02lX %02lX %02lX %02lX\r\n", *((BYTE *)*ppDataPkt+*pdwPktSize-2), *((BYTE *)*ppDataPkt+*pdwPktSize-1), *((BYTE *)*ppDataPkt+*pdwPktSize), *((BYTE *)*ppDataPkt+*pdwPktSize+1));
				OutputDebugString(szDebug);
				if (*pfMark == 1)
					wsprintf(szDebug, " Marker: ON\r\n");
				else
					wsprintf(szDebug, " Marker: OFF\r\n");
				OutputDebugString(szDebug);
				wsprintf(szDebug, "Frame #%03ld, Packet of size %04ld\r\n", (DWORD)pbsiT->byTR, *pdwPktSize);
				OutputDebugString(szDebug);
#endif
			}
			else if (pbsi263->byMode == RTP_H263_MODE_C)
			{
				// Build a header in mode C
#ifdef DEBUG
				wsprintf(szDebug, "VCMSTRM: We were asked to generate a MODE C H.263 payload header!");
				OutputDebugString(szDebug);
				// DebugBreak();
#endif
				return ((MMRESULT)VCMERR_NONSPECIFIC);
			}
		}
		else
			return ((MMRESULT)VCMERR_NOMOREPACKETS);
	}
#ifndef _ALPHA_
	else if (pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_MSH261)
#else
	else if (pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_DECH261)
#endif
	{
		// Look for the bitstream info trailer
		pbsiT = (PH26X_RTP_BSINFO_TRAILER)(pDataSrc + dwDataSize - sizeof(H26X_RTP_BSINFO_TRAILER));

		// If the whole frame can fit in dwMaxFragSize, send it non fragmented
		if ((pbsiT->dwCompressedSize + 4) < pvs->dwMaxPacketSize)
			bOneFrameOnePacket = TRUE;

		// Look for the packet to receive a H.261 payload header
		if ((*pdwPktCount < pbsiT->dwNumOfPackets) && !(bOneFrameOnePacket && *pdwPktCount))
		{

#ifdef _ALPHA_
			// Verify that the content of the bistream info structures is correct
			// If not, do not parse the frame, and fail the call
			// This is to solve problems with the data returned by the DEC codecs
			if (!*pdwPktCount)
			{
				pbsi261 = (PRTP_H261_BSINFO)((PBYTE)pbsiT - pbsiT->dwNumOfPackets * sizeof(RTP_H261_BSINFO));
				for (i=1; i<(long)pbsiT->dwNumOfPackets; i++, pbsi261++)
				{
					if ((pbsi261->dwBitOffset >= (pbsi261+1)->dwBitOffset) || ((pbsiT->dwCompressedSize*8) <= pbsi261->dwBitOffset))
					{
#ifdef DEBUG
						OutputDebugString("VCMSTRM: The content of the extended bitstream info structures is invalid!\r\n");
#endif
						// return ((MMRESULT)VCMERR_NONSPECIFIC);
						bOneFrameOnePacket = TRUE;
					}
				}

				// Test last info strucure
				if ( !bOneFrameOnePacket && ((pbsiT->dwCompressedSize*8) <= pbsi261->dwBitOffset))
				{
#ifdef DEBUG
					OutputDebugString("VCMSTRM: The content of the extended bitstream info structures is invalid!\r\n");
#endif
					// return ((MMRESULT)VCMERR_NONSPECIFIC);
					bOneFrameOnePacket = TRUE;
				}
			}
#endif

#ifdef LOGPAYLOAD_ON
			// Dump the whole frame in the debug window for comparison with receive side
			if (!*pdwPktCount)
			{
				g_DebugFile = CreateFile("C:\\SendLog.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
				SetFilePointer(g_DebugFile, 0, NULL, FILE_END);
				wsprintf(szDebug, "Frame #%03ld\r\n", (DWORD)pbsiT->byTR);
				WriteFile(g_DebugFile, szDebug, strlen(szDebug), &d, NULL);
				wsprintf(szDebug, "Frame #%03ld has %1ld GOBs of size ", (DWORD)pbsiT->byTR, (DWORD)pbsiT->dwNumOfPackets);
				OutputDebugString(szDebug);
				pbsi261 = (PRTP_H261_BSINFO)((PBYTE)pbsiT - pbsiT->dwNumOfPackets * sizeof(RTP_H261_BSINFO));
				for (i=1; i<(long)pbsiT->dwNumOfPackets; i++)
				{
					wPrevOffset = pbsi261->dwBitOffset;
					pbsi261++;
					wsprintf(szDebug, "%04ld, ", (DWORD)(pbsi261->dwBitOffset - wPrevOffset) >> 3);
					OutputDebugString(szDebug);
				}
				wsprintf(szDebug, "%04ld\r\n", (DWORD)(pbsiT->dwCompressedSize * 8 - pbsi261->dwBitOffset) >> 3);
				OutputDebugString(szDebug);
				for (i=pbsiT->dwCompressedSize, p=pDataSrc; i>0; i-=4, p+=4)
				{
					wsprintf(szDebug, "%02lX %02lX %02lX %02lX\r\n", *((BYTE *)p), *((BYTE *)p+1), *((BYTE *)p+2), *((BYTE *)p+3));
					WriteFile(g_DebugFile, szDebug, strlen(szDebug), &d, NULL);
				}
				CloseHandle(g_DebugFile);
			}
#endif
			
			// Look for the bitstream info structure
			pbsi261 = (PRTP_H261_BSINFO)((PBYTE)pbsiT - (pbsiT->dwNumOfPackets - *pdwPktCount) * sizeof(RTP_H261_BSINFO));
			
			// Set the marker bit: as long as this is not the last packet of the frame
			// this bit needs to be set to 0
			if (!bOneFrameOnePacket)
			{
				// Count the number of GOBS that could fit in dwMaxFragSize
				for (i=1; i<(long)(pbsiT->dwNumOfPackets - *pdwPktCount); i++)
				{
					if ((pbsi261+i)->dwBitOffset - pbsi261->dwBitOffset > (pvs->dwMaxPacketSize * 8))
						break;
				}

				if (i < (long)(pbsiT->dwNumOfPackets - *pdwPktCount))
				{
					*pfMark = 0;
					if (i>1)
						i--;
				}
				else
				{
					// Hey! You 're forgetting the last GOB! It could make the total
					// size of the last packet larger than dwMaxFragSize... Imbecile!
					if ((pbsiT->dwCompressedSize * 8 - pbsi261->dwBitOffset > (pvs->dwMaxPacketSize * 8)) && (i>1))
					{
						*pfMark = 0;
						i--;
					}
				}
			}

			// Go to the beginning of the data
			pb = pDataSrc + pbsi261->dwBitOffset / 8;

#ifdef DEBUG
			if (!*pdwPktCount && ((*pb != 0) || (*(pb+1) != 1)))
			{
				wsprintf(szDebug, "VCMSTRM: This GOB is missing a GOB Start!");
				OutputDebugString(szDebug);
				// DebugBreak();
			}
#endif

			// Build a header to this thing!

			// 0                   1                   2                   3
			// 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
			//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
			//|SBIT |EBIT |I|V| GOBN  |   MBAP  |  QUANT  |  HMVD   |  VMVD   |
			//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
			// But that's the network byte order...

			// Set the V bit to 1
			dwHeaderHigh |= 0x01000000;

			// Set the I bit
			dwHeaderHigh |= (pbsiT->dwFlags & RTP_H26X_INTRA_CODED) << 25;

			// Set the GOBn bits
			dwHeaderHigh |= ((DWORD)(pbsi261->byGOBN)) << 20;

			// Set the MBAP bits
			dwHeaderHigh |= ((DWORD)(pbsi261->byMBA)) << 15;

			// Set the QUANT bits
			dwHeaderHigh |= ((DWORD)(pbsi261->byQuant)) << 10;

			// Set the HMVD bits
			dwHeaderHigh |= ((DWORD)(BYTE)(pbsi261->cHMV)) << 5;

			// Set the VMVD bits
			dwHeaderHigh |= ((DWORD)(BYTE)(pbsi261->cVMV));

			// Special case: 1 frame = 1 packet
			if (bOneFrameOnePacket)
			{
				// SBIT is already set to 0

				// EBIT is already set to 0

#ifdef VALIDATE_SBIT_EBIT // { VALIDATE_SBIT_EBIT
				ERRORMESSAGE(("vcmFormatPayload: (1F1P) Previous EBIT=%ld, current SBIT=%ld, current EBIT=%ld (New frame)\r\n", g_dwPreviousEBIT, (DWORD)(dwHeaderHigh & 0xE0000000) >> 29, (DWORD)(dwHeaderHigh & 0x1C000000) >> 26));
#endif // } VALIDATE_SBIT_EBIT

				// Update the packet size
				*pdwPktSize = pbsiT->dwCompressedSize + 4;

				// Update the packet count
				*pdwPktCount = pbsiT->dwNumOfPackets;

			}
			else
			{
#ifdef VALIDATE_SBIT_EBIT // { VALIDATE_SBIT_EBIT
				DWORD dwCurrentSBIT;
#endif // } VALIDATE_SBIT_EBIT
				// Set the SBIT bits
				dwHeaderHigh |= (pbsi261->dwBitOffset % 8) << 29;

				// Set the EBIT bits
				if ((pbsiT->dwNumOfPackets - *pdwPktCount - i) >= 1)
					dwHeaderHigh |= (DWORD)((8UL - ((pbsi261+i)->dwBitOffset % 8)) & 0x00000007) << 26;

#ifdef VALIDATE_SBIT_EBIT // { VALIDATE_SBIT_EBIT
				// Compare this to the previous EBIT. If the sum of the two
				// is not equal to 8, something's broken
				if (*pdwPktCount)
					ERRORMESSAGE(("vcmFormatPayload: Previous EBIT=%ld, current SBIT=%ld, current EBIT=%ld\r\n", g_dwPreviousEBIT, (DWORD)(dwHeaderHigh & 0xE0000000) >> 29, (DWORD)(dwHeaderHigh & 0x1C000000) >> 26));
				else
					ERRORMESSAGE(("vcmFormatPayload: Previous EBIT=%ld, current SBIT=%ld, current EBIT=%ld (New frame)\r\n", g_dwPreviousEBIT, (DWORD)(dwHeaderHigh & 0xE0000000) >> 29, (DWORD)(dwHeaderHigh & 0x1C000000) >> 26));

				// Only test this if this is the first packet
				dwCurrentSBIT = (DWORD)(dwHeaderHigh & 0xE0000000) >> 29;
				if ((*pdwPktCount) && (((dwCurrentSBIT + g_dwPreviousEBIT) != 8) && (((dwCurrentSBIT + g_dwPreviousEBIT) != 0))))
					DebugBreak();

				g_dwPreviousEBIT = (dwHeaderHigh & 0x1C000000) >> 26;
#endif // } VALIDATE_SBIT_EBIT

				// Update the packet size
				if ((pbsiT->dwNumOfPackets - *pdwPktCount - i) >= 1)
					*pdwPktSize = (((pbsi261+i)->dwBitOffset - 1) / 8) - (pbsi261->dwBitOffset / 8) + 1 + 4;
				else
					*pdwPktSize = pbsiT->dwCompressedSize - pbsi261->dwBitOffset / 8 + 4;

				// Update the packet count
				*pdwPktCount += i;

			}

#if 0
			// Save the header right before the data chunk
			*ppDataPkt = pDataSrc + (pbsi261->dwBitOffset / 8) - 4;

			// Convert to network byte order
			*((BYTE *)*ppDataPkt+3) = (BYTE)(dwHeaderHigh & 0x000000FF);
			*((BYTE *)*ppDataPkt+2) = (BYTE)((dwHeaderHigh >> 8) & 0x000000FF);
			*((BYTE *)*ppDataPkt+1) = (BYTE)((dwHeaderHigh >> 16) & 0x000000FF);
			*((BYTE *)*ppDataPkt) = (BYTE)((dwHeaderHigh >> 24) & 0x000000FF);
#else
			// Save the header right before the data chunk
			*ppDataPkt = pDataSrc + (pbsi261->dwBitOffset / 8) - 4;
            *pdwHdrSize=4;

			// Convert to network byte order
			*((BYTE *)*pHdrInfo+3) = (BYTE)(dwHeaderHigh & 0x000000FF);
			*((BYTE *)*pHdrInfo+2) = (BYTE)((dwHeaderHigh >> 8) & 0x000000FF);
			*((BYTE *)*pHdrInfo+1) = (BYTE)((dwHeaderHigh >> 16) & 0x000000FF);
			*((BYTE *)*pHdrInfo) = (BYTE)((dwHeaderHigh >> 24) & 0x000000FF);
#endif

#ifdef LOGPAYLOAD_ON
			// Output some debug stuff
			wsprintf(szDebug, "Packet: %02lX\r\n Header: %02lX %02lX %02lX %02lX\r\n dword1: %02lX %02lX %02lX %02lX\r\n dword2: %02lX %02lX %02lX %02lX\r\n", *pdwPktCount, *((BYTE *)*ppDataPkt), *((BYTE *)*ppDataPkt+1), *((BYTE *)*ppDataPkt+2), *((BYTE *)*ppDataPkt+3), *((BYTE *)*ppDataPkt+4), *((BYTE *)*ppDataPkt+5), *((BYTE *)*ppDataPkt+6), *((BYTE *)*ppDataPkt+7), *((BYTE *)*ppDataPkt+8), *((BYTE *)*ppDataPkt+9), *((BYTE *)*ppDataPkt+10), *((BYTE *)*ppDataPkt+11));
			OutputDebugString(szDebug);
			if (*pdwPktCount == pbsiT->dwNumOfPackets)
				wsprintf(szDebug, " Tail  : %02lX %02lX XX XX\r\n", *((BYTE *)*ppDataPkt+*pdwPktSize-2), *((BYTE *)*ppDataPkt+*pdwPktSize-1));
			else
				wsprintf(szDebug, " Tail  : %02lX %02lX %02lX %02lX\r\n", *((BYTE *)*ppDataPkt+*pdwPktSize-2), *((BYTE *)*ppDataPkt+*pdwPktSize-1), *((BYTE *)*ppDataPkt+*pdwPktSize), *((BYTE *)*ppDataPkt+*pdwPktSize+1));
			OutputDebugString(szDebug);
			if (*pfMark == 1)
				wsprintf(szDebug, " Marker: ON\r\n");
			else
				wsprintf(szDebug, " Marker: OFF\r\n");
			OutputDebugString(szDebug);
			wsprintf(szDebug, "Frame #%03ld, Packet of size %04ld\r\n", (DWORD)pbsiT->byTR, *pdwPktSize);
			OutputDebugString(szDebug);
#endif
		}
		else
			return ((MMRESULT)VCMERR_NOMOREPACKETS);
	}
	else
	{
		if (!*pdwPktCount)
		{
			*pdwPktCount = 1;
            *pdwHdrSize  = 0;
		}
		else
			return ((MMRESULT)VCMERR_NOMOREPACKETS);
	}

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 * @doc EXTERNAL COMPFUNC
 *
 * @func MMRESULT | vcmStreamGetPayloadHeaderSize | This function gets the size
 *   of the RTP payload header associated to a video codec.
 *
 * @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 * @parm PDWORD | pdwPayloadHeaderSize | Specifies a pointer to the payload header size.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *   @flag MMSYSERR_INVALPARAM | Specified saturation value is invalid.
 *
 * @xref <f vcmStreamFormatPayload>
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamGetPayloadHeaderSize(HVCMSTREAM hvs, PDWORD pdwPayloadHeaderSize)
{
	PVCMSTREAM	pvs = (PVCMSTREAM)hvs;

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamGetPayloadHeaderSize: Specified handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}
	if (!pdwPayloadHeaderSize)
	{
		ERRORMESSAGE(("vcmStreamGetPayloadHeaderSize: Specified pointer is invalid, pdwPayloadHeaderSize=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALPARAM);
	}

	// Set default payload header size to 0
	*pdwPayloadHeaderSize = 0;

	// The name of the codec will tell us how to get to the payload header size info
#ifndef _ALPHA_
#ifdef USE_BILINEAR_MSH26X
	if ((pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_MSH263) || (pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_MSH26X))
#else
	if (pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_MSH263)
#endif
#else
	if (pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_DECH263)
#endif
	{
		// H.263 has a max payload header size of 12 bytes
		*pdwPayloadHeaderSize = 12;
	}
#ifndef _ALPHA_
	else if (pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_MSH261)
#else
	else if (pvs->pvfxDst->dwFormatTag == VIDEO_FORMAT_DECH261)
#endif
	{
		// H.261 has a unique payload header size of 4 bytes
		*pdwPayloadHeaderSize = 4;
	}

	return ((MMRESULT)MMSYSERR_NOERROR);
}

/****************************************************************************
 * @doc EXTERNAL COMPFUNC
 *
 * @func MMRESULT | vcmStreamRequestIFrame | This function forces the
 *   codec to generate an I-Frame.
 *
 * @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamRequestIFrame(HVCMSTREAM hvs)
{
	PVCMSTREAM	pvs = (PVCMSTREAM)hvs;

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamRequestIFrame: Specified handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}

	DEBUGMSG (ZONE_VCM, ("vcmStreamRequestIFrame: Requesting an I-Frame...\r\n"));

	// We need the following crs to make sure we don't miss any of the I-Frame requests
	// emitted by the UI. Problematic scenario: pvs->dwFrame is at 123 for instance.
	// The UI thread requests an I-Frame by setting pvs->dwFrame to 0. If the capture/compression
	// thread was in ICCompress() (which is very probable since it takes quite some time
	// to compress a frame), pvs->dwFrame will be incremented by one when ICCompress()
	// returns. We fail to handle the I-Frame request correctly, since the next time
	// ICCompress() gets called pvs->dwFrame will be equal to 1, for which we do not
	// generate an I-Frame.
	EnterCriticalSection(&pvs->crsFrameNumber);

	// Set the frame number to 0. This will force the codec to generate an I-Frame
	pvs->dwFrame = 0;

	// Allow the capture/compression thread to proceed.
	LeaveCriticalSection(&pvs->crsFrameNumber);

	return ((MMRESULT)MMSYSERR_NOERROR);
}


/****************************************************************************
 * @doc EXTERNAL COMPFUNC
 *
 * @func MMRESULT | vcmStreamPeriodicIFrames | This function enables or
 *   disables generation of I-Frames periodically.
 *
 * @parm HVCMSTREAM | hvs | Specifies the conversion stream.
 *
 * @parm BOOL | fPeriodicIFrames | Set to TRUE to generate I-Frames
 *   periodically, FALSE otherwise.
 *
 * @rdesc The return value is zero if the function is successful. Otherwise, it returns
 *   an error number. Possible error values include the following:
 *   @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 ***************************************************************************/
MMRESULT VCMAPI vcmStreamPeriodicIFrames(HVCMSTREAM hvs, BOOL fPeriodicIFrames)
{
	PVCMSTREAM	pvs = (PVCMSTREAM)hvs;

	// Check input params
	if (!hvs)
	{
		ERRORMESSAGE(("vcmStreamDisablePeriodicIFrames: Specified handle is invalid, hvs=NULL\r\n"));
		return ((MMRESULT)MMSYSERR_INVALHANDLE);
	}

	DEBUGMSG (ZONE_VCM, ("vcmStreamDisablePeriodicIFrames: Disabling periodic generation of I-Frames...\r\n"));

	// No more periodic I-Frames
	pvs->fPeriodicIFrames = fPeriodicIFrames;

	return ((MMRESULT)MMSYSERR_NOERROR);
}


// frees memory prior to shutdown
MMRESULT VCMAPI vcmReleaseResources()
{
	if (g_aVCMAppInfo)
	{
		MemFree(g_aVCMAppInfo);
		g_aVCMAppInfo = NULL;
	}	

	return MMSYSERR_NOERROR;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\vcmcaps.cpp ===
/*
 *  	File: vcmcaps.cpp
 *
 *		Base VCM implementation of Microsoft Network Audio capability object.
 *
 *		Revision History:
 *
 *		12/20/95	mikev	created
 *		06/11/96	mikev	separated protocol implementation specifics into
 *							msiacaps.cpp (the original proprietary version) and
 *							vcmh323.cpp (H.323/H.245 implementation)
 *		07/28/96	philf	added support for video
 */


#include "precomp.h"


//UINT uVidNumLocalFormats =0;		// # of active entries in pLocalFormats
//UINT uVidLocalFormatCapacity=0;	// size of pLocalFormats (in multiples of VIDCAP_DETAILS)
//UINT uVidStaticRef = 0;			// global ref count
//UINT uVidNumCustomDecodeFormats=0;	// # of custom entries for decode

//VIDEO_FORMAT_ID VIDsByRank[MAX_CAPS_PRESORT];		// the best 16 ranked formats, sorted (descending, best first)
//AUDIO_FORMAT_ID IDsByBandwidth[MAX_CAPS_PRESORT];	// ascending, least BW reqirement first
//AUDIO_FORMAT_ID IDsByLossTolerance[MAX_CAPS_PRESORT];	// descending, most tolerant first
//AUDIO_FORMAT_ID IDsByCPULoad[MAX_CAPS_PRESORT];		// ascending, lightest load first

//#pragma data_seg()


PVCMFORMATDETAILS pvfd_g;
static UINT uMaxFormatSize =0;
	
PVIDEOFORMATEX lpScratchFormat = NULL;

BOOL __stdcall VCMFormatEnumCallback(HVCMDRIVERID hvdid, PVCMDRIVERDETAILS pvdd, PVCMFORMATDETAILS pvfd, DWORD_PTR dwInstance);


CVcmCapability::CVcmCapability()
:m_dwDeviceID(VIDEO_MAPPER)
{
}

CVcmCapability::~CVcmCapability()
{
}

//	FormatEnum() is the root level enumeration of VCM formats. Each permutation of
//  format tag, bits per sample, and sample rate is considered a unique format
//  and will have a unique registry entry if it is "enabled" for internet video
//	vcmFormatEnum() calls VCMFormatEnumCallback().
BOOL CVcmCapability::FormatEnum(CVcmCapability *pCapObject, DWORD dwFlags)
{
	MMRESULT mResult;
	VCMDRIVERDETAILS vdd;
	VCMFORMATDETAILS vfd;

	if(!GetVideoFormatBuffer())
		return FALSE;
	
	vdd.dwSize = sizeof(VCMDRIVERDETAILS);
	vfd.cbStruct = sizeof(VCMFORMATDETAILS);
	vfd.pvfx = lpScratchFormat;
	vfd.cbvfx = uMaxFormatSize;
	vfd.szFormat[0]=(WCHAR)0;

	mResult = vcmFormatEnum(m_dwDeviceID, VCMFormatEnumCallback, &vdd, &vfd, (DWORD_PTR)pCapObject,
							dwFlags | VCM_FORMATENUMF_BOTH);

	if(lpScratchFormat) {
	   MemFree(lpScratchFormat);
	   lpScratchFormat=NULL;
	}

	if(mResult != MMSYSERR_NOERROR)
   	{
		return FALSE;
   	}
	return TRUE;
}

// default implementation of FormatEnumHandler does nothing
BOOL  CVcmCapability::FormatEnumHandler(HVCMDRIVERID hvdid,
	    PVCMFORMATDETAILS pvfd, VCMDRIVERDETAILS *pvdd, DWORD_PTR dwInstance)
{
	return FALSE;
}

BOOL __stdcall VCMFormatEnumCallback(HVCMDRIVERID hvdid,
    PVCMDRIVERDETAILS pvdd, PVCMFORMATDETAILS pvfd, DWORD_PTR dwInstance)
{
	CVcmCapability *pCapability = (CVcmCapability *)dwInstance;

	return pCapability->FormatEnumHandler(hvdid, pvfd, pvdd, dwInstance);
}


BOOL GetVideoFormatBuffer()
{
	// Get size of largest VIDEOFORMATEX structure in the system
	MMRESULT mResult;

	if((mResult = vcmMetrics(NULL, VCM_METRIC_MAX_SIZE_FORMAT, (LPVOID) &uMaxFormatSize)) != MMSYSERR_NOERROR)
	{
		ERRORMESSAGE(("GetFormatBuffer: vcmMetrics failed:0x%08lX\r\n",mResult));
		return FALSE;
	}


	if(!(lpScratchFormat = (PVIDEOFORMATEX) MemAlloc(uMaxFormatSize)))
	{
		ERRORMESSAGE(("GetFormatBuffer: allocation failed\r\n"));
		return FALSE;
	}

	ZeroMemory(lpScratchFormat, uMaxFormatSize);

	return TRUE;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\vcmcaps.h ===
/*
 *  	File: vcmcaps.h
 *
 *
 *		VCM implementation of Microsoft Network Video capability object.
 *
 *		Additional methods supported by this implementation:
 *	
 *		VIDEO_FORMAT_ID AddEncodeFormat(VIDCAP_DETAILS *pFmtBuf,LPVOID lpvMappingData, UINT uSize);
 *		VIDEO_FORMAT_ID AddDecodeFormat(VIDCAP_DETAILS *pFmtBuf,LPVOID lpvMappingData, UINT uSize);
 *
 *		Revision History:
 *
 *		12/27/95	mikev	created
 *		07/28/96	philf	added support for video
 */


#ifndef _VCMCAPS_H
#define _VCMCAPS_H
#include <pshpack8.h>

// VCM enumeration support functions
BOOL GetVideoFormatBuffer(VOID);
BOOL __stdcall FormatTagEnumCallback(HVCMDRIVERID hadid, PVCMFORMATTAGDETAILS paftd,
    DWORD dwInstance,  DWORD fdwSupport);
BOOL __stdcall FormatEnumCallback(HVCMDRIVERID hadid,
    PVCMFORMATDETAILS pafd, DWORD_PTR dwInstance, DWORD fdwSupport);
BOOL __stdcall DriverEnumCallback(HVCMDRIVERID hadid,
    DWORD_PTR dwInstance, DWORD fdwSupport);

#ifdef __cplusplus

class CVcmCapability
{
protected:
	HACMDRIVER hAcmDriver;	
	DWORD m_dwDeviceID;
public:
	CVcmCapability();
	~CVcmCapability();
	BOOL FormatEnum(CVcmCapability *pCapObject, DWORD dwFlags);
	BOOL DriverEnum(CVcmCapability *pCapObject);
	HACMDRIVER GetDriverHandle() {return hAcmDriver;};
	virtual BOOL FormatEnumHandler(HVCMDRIVERID hadid,
	    PVCMFORMATDETAILS pafd, VCMDRIVERDETAILS *padd, DWORD_PTR dwInstance);
};

#define SQCIF 	0x1
#define QCIF 	0x2
#define CIF 	0x4
#define UNKNOWN 0x8
#define get_format(w,h) ((w == 128 && h == 96 ) ? SQCIF : ((w == 176 && h == 144 )? QCIF: ((w == 352 && h == 288 ) ? CIF :UNKNOWN)))



#define NONSTD_VID_TERMCAP {H245_CAPDIR_LCLRX, H245_DATA_VIDEO,H245_CLIENT_VID_NONSTD, 0, {0}}
#define STD_VID_TERMCAP(tc) {H245_CAPDIR_LCLRX, H245_DATA_VIDEO,(tc), 0, {0}}

//Advertise the maximum possible rate, and assume we can do below this.
//H.261 defines a max MPI of 4!

#define STD_VID_PARAMS {0,0,1}

typedef struct VideoParameters
{
	BYTE	RTPPayload;		// RTP payload type
	DWORD	dwFormatDescriptor;	// the unique ID of this format
	UINT	uSamplesPerSec;	// the number of frames per second
	UINT	uBitsPerSample;	// the number of bits per pixel
	VIDEO_SIZES enumVideoSize;	// enum. Use Small, Medium, Large
	UINT	biWidth;		// the frame width in pixels
	UINT	biHeight;		// the frame height in pixels
}VIDEO_PARAMS;


typedef struct VidCapDetails
{
	DWORD	dwFormatTag;
	CC_TERMCAP H245Cap;
	NSC_CHANNEL_VIDEO_PARAMETERS nonstd_params;
	VIDEO_PARAMS video_params;	// this has a dependency on protocol.h
	DWORD dwPublicRefIndex;	// index of the local capability entry that will be
							// advertized.  Zero if this entry is the one to advertize
	
	BOOL bSendEnabled;
	BOOL bRecvEnabled;	
	DWORD dwDefaultSamples;		// default number of samples per packet
	UINT uMaxBitrate;			// max bandwidth used by this format (calculated: bits per sample * sample rate)
	UINT uAvgBitrate;			// average bandwidth used by this format (we get this from the codec)
	WORD wCPUUtilizationEncode;
	WORD wCPUUtilizationDecode;	
	WORD wApplicationPrefOrder;	// overriding preference - lower number means more preferred
	UINT uLocalDetailsSize;		// size in bytes of what lpLocalFormatDetails points to
	LPVOID lpLocalFormatDetails;
	UINT uRemoteDetailsSize;	// size in bytes of what lpRemoteFormatDetails points to
	LPVOID lpRemoteFormatDetails;
	char szFormat[VCMFORMATDETAILS_FORMAT_CHARS];
} VIDCAP_DETAILS, *PVIDCAP_DETAILS;

/*
 *	VCM interface
 *	Definitions for interfacing with VCM
 */

typedef struct
{
	PVIDCAP_DETAILS pVidcapDetails;	// a pointer to an VIDCAP_DETAILS structure
	DWORD dwFlags;					// misc flags...
	PVIDEOFORMATEX pvfx;			// pointer to video format structure. used when adding formats
	HRESULT hr;
} VCM_APP_PARAM, *PVCM_APP_PARAM;


//
//  implementation class of the Video Interface
//

class CImpAppVidCap : public IAppVidCap
{
	public:
	STDMETHOD_(ULONG,  AddRef());
	STDMETHOD_(ULONG, Release());
	
	STDMETHOD(GetNumFormats(UINT *puNumFmtOut));
    STDMETHOD(ApplyAppFormatPrefs(PBASIC_VIDCAP_INFO pFormatPrefsBuf,
		UINT uNumFormatPrefs));
    STDMETHOD(EnumFormats(PBASIC_VIDCAP_INFO pFmtBuf, UINT uBufsize,
		UINT *uNumFmtOut));
	STDMETHOD(EnumCommonFormats(PBASIC_VIDCAP_INFO pFmtBuf, UINT uBufsize,
		UINT *uNumFmtOut, BOOL bTXCaps));
	STDMETHOD( GetBasicVidcapInfo (VIDEO_FORMAT_ID Id,
		PBASIC_VIDCAP_INFO pFormatPrefsBuf));
	STDMETHOD( AddVCMFormat (PVIDEOFORMATEX lpvfx, PVIDCAP_INFO pVidCapInfo));
	STDMETHOD( RemoveVCMFormat (PVIDEOFORMATEX lpvfx));
	STDMETHOD_ (PVIDEOFORMATEX, GetVidcapDetails(THIS_ VIDEO_FORMAT_ID Id));
	STDMETHOD( GetPreferredFormatId (VIDEO_FORMAT_ID *pId));
	STDMETHOD (SetDeviceID(DWORD dwDeviceID));

 	void Init(class CMsivCapability * pCapObject) {m_pCapObject = pCapObject;};

protected:
	class CMsivCapability * m_pCapObject;
};


class CMsivCapability : public IH323MediaCap, public CVcmCapability
{

protected:
	UINT uRef;
	BOOL bPublicizeTXCaps;
	BOOL bPublicizeTSTradeoff;
	//LOOKLOOK this supports a hack to disable CPU intensive codecs if not running on a pentium
	WORD wMaxCPU;	
	static MEDIA_FORMAT_ID IDsByRank[MAX_CAPS_PRESORT];
	
	static UINT uNumLocalFormats;			// # of active entries in pLocalFormats
	static UINT uStaticRef;					// global ref count
	static UINT uCapIDBase;					// rebase capability ID to index into IDsByRank
	static VIDCAP_DETAILS *pLocalFormats;	// cached list of formats that we can receive
	static UINT uLocalFormatCapacity;		// size of pLocalFormats (in multiples of VIDCAP_DETAILS)

	PVIDCAP_DETAILS pRemoteDecodeFormats;	// cached list of formats that the
											// other end can receive/decode
	UINT uNumRemoteDecodeFormats;	// # of entries for remote decode capabilities
	UINT uRemoteDecodeFormatCapacity;		// size of pRemoteDecodeFormats (in multiples of VIDCAP_DETAILS)

	PVCM_APP_PARAM	m_pAppParam;			// a pointer to a PVCM_APP_PARAM structure. Used to carry
											// a information through the enumeration process
											// but can be used for other purposes		
//
// embedded interface classes
//
	CImpAppVidCap m_IAppVidCap;
protected:

// Internal functions
	UINT IDToIndex(MEDIA_FORMAT_ID id) {return id - uCapIDBase;};
	MEDIA_FORMAT_ID IndexToId(UINT uIndex){return uIndex + uCapIDBase;};

	LPTSTR AllocRegistryKeyName(LPTSTR lpDriverName,
		UINT uSampleRate, UINT uBitsPerSample, UINT uBytesPerSec,UINT uWidth,UINT uHeight);
	VOID FreeRegistryKeyName(LPTSTR lpszKeyName);
	

	VOID CalculateFormatProperties(VIDCAP_DETAILS *pFmtBuf, PVIDEOFORMATEX lpvfx);
	BOOL IsFormatSpecified(PVIDEOFORMATEX lpFormat, PVCMFORMATDETAILS pvfd,
		VCMDRIVERDETAILS *pvdd, VIDCAP_DETAILS *pVidcapDetails);
	virtual VOID SortEncodeCaps(SortMode sortmode);
	virtual VIDEO_FORMAT_ID AddFormat(VIDCAP_DETAILS *pFmtBuf,LPVOID lpvMappingData, UINT uSize);
	BOOL UpdateFormatInRegistry(VIDCAP_DETAILS *pFmt);
	BOOL BuildFormatName(	PVIDCAP_DETAILS pVidcapDetails,
							WCHAR *pszDriverName,
							WCHAR *pszFormatName);
	HRESULT GetFormatName(PVIDCAP_DETAILS pVidcapDetails, PVIDEOFORMATEX pvfx);

public:
	STDMETHOD_(BOOL, Init());
	STDMETHOD_(BOOL, ReInit());
	CMsivCapability();
	~CMsivCapability();
	
// handler for codec enumeration callback	
	virtual BOOL FormatEnumHandler(HVCMDRIVERID hvdid,
	        PVCMFORMATDETAILS pvfd, VCMDRIVERDETAILS *pvdd, DWORD_PTR dwInstance);

//
// Common interface methods
//
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR * ppvObj);
	STDMETHOD_(ULONG,  AddRef());
	STDMETHOD_(ULONG, Release());

//		
// IVCapApi methods		
//
	STDMETHOD(GetNumFormats(UINT *puNumFmtOut));
	STDMETHOD(ApplyAppFormatPrefs(PBASIC_VIDCAP_INFO pFormatPrefsBuf,
		UINT uNumFormatPrefs));
    STDMETHOD(EnumFormats(PBASIC_VIDCAP_INFO pFmtBuf, UINT uBufsize,
		UINT *uNumFmtOut));
	STDMETHOD(EnumCommonFormats(PBASIC_VIDCAP_INFO pFmtBuf, UINT uBufsize,
		UINT *uNumFmtOut, BOOL bTXCaps));		
	STDMETHOD( GetBasicVidcapInfo (VIDEO_FORMAT_ID Id,
		PBASIC_VIDCAP_INFO pFormatPrefsBuf));
	STDMETHOD( AddVCMFormat (PVIDEOFORMATEX lpvfx, PVIDCAP_INFO pVidCapInfo));
	STDMETHOD( RemoveVCMFormat (PVIDEOFORMATEX lpvfx));
	STDMETHOD( GetPreferredFormatId (VIDEO_FORMAT_ID *pId));
	STDMETHOD (SetDeviceID(DWORD dwDeviceID)) {m_dwDeviceID = dwDeviceID; return hrSuccess;};			

// support of IVCapApi methods	
	virtual HRESULT CopyVidcapInfo (PVIDCAP_DETAILS pDetails, PVIDCAP_INFO pInfo,
									BOOL bDirection);
//
//	IH323MediaCap methods
//
	STDMETHOD_(VOID, FlushRemoteCaps());
	STDMETHOD( AddRemoteDecodeCaps(PCC_TERMCAPLIST pTermCapList));
	STDMETHOD_(VIDEO_FORMAT_ID, AddRemoteDecodeFormat(PCC_TERMCAP pCCThisCap));

	// Get local and remote channel parameters for a specific encode capability
	STDMETHOD( GetEncodeParams(LPVOID pBufOut, UINT uBufSize, LPVOID pLocalParams,
			UINT uLocalSize,MEDIA_FORMAT_ID idRemote,MEDIA_FORMAT_ID idLocal));
	STDMETHOD( GetPublicDecodeParams(LPVOID pBufOut, UINT uBufSize, VIDEO_FORMAT_ID id));
   	STDMETHOD( GetDecodeParams(PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS  pChannelParams,
		VIDEO_FORMAT_ID * pFormatID, LPVOID lpvBuf, UINT uBufSize));
		
	STDMETHOD_(UINT, GetNumCaps()){return uNumLocalFormats;};
	STDMETHOD_(UINT, GetNumCaps(BOOL bRXCaps));
	STDMETHOD_(BOOL, IsHostForCapID(MEDIA_FORMAT_ID CapID));
	STDMETHOD_(BOOL, IsCapabilityRecognized(PCC_TERMCAP pCCThisCap));
	STDMETHOD(SetCapIDBase(UINT uNewBase));
	STDMETHOD_(UINT, GetCapIDBase()) {return uCapIDBase;};
	STDMETHOD (IsFormatEnabled (MEDIA_FORMAT_ID FormatID, PBOOL bRecv, PBOOL bSend));
	STDMETHOD_(BOOL, IsFormatPublic(MEDIA_FORMAT_ID FormatID));
	STDMETHOD_(MEDIA_FORMAT_ID, GetPublicID(MEDIA_FORMAT_ID FormatID));

	STDMETHOD_ (VOID, EnableTXCaps(BOOL bSetting)) {bPublicizeTXCaps = bSetting;};
	STDMETHOD_ (VOID, EnableRemoteTSTradeoff(BOOL bSetting)) {bPublicizeTSTradeoff= bSetting;};
	STDMETHOD (SetAudioPacketDuration( UINT durationInMs));
	STDMETHOD (ResolveToLocalFormat(MEDIA_FORMAT_ID FormatIDLocal,
		MEDIA_FORMAT_ID * pFormatIDRemote));
	STDMETHOD_(UINT, GetLocalSendParamSize(MEDIA_FORMAT_ID dwID));
	STDMETHOD_(UINT, GetLocalRecvParamSize(PCC_TERMCAP pCapability));
	STDMETHOD( CreateCapList(LPVOID *ppCapBuf));
	STDMETHOD( DeleteCapList(LPVOID pCapBuf));
	STDMETHOD( ResolveEncodeFormat(VIDEO_FORMAT_ID *pIDVidEncodeOut,VIDEO_FORMAT_ID * pIDVidRemoteDecode));

// methods provided to the Data pump, common to H.323 and MSICCP
	STDMETHOD(GetDecodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize));
	STDMETHOD(GetEncodeFormatDetails(MEDIA_FORMAT_ID FormatID, VOID **ppFormat, UINT *puSize));
};

#endif	// __cplusplus
#include <poppack.h>

#endif	//#ifndef _VCMCAPS_H




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\vidstrm.cpp ===
#include "precomp.h"

#ifndef SIZEOF_VIDEOFORMATEX
#define SIZEOF_VIDEOFORMATEX(pwfx)   (sizeof(VIDEOFORMATEX))
#endif

// #define LOGSTATISTICS_ON 1

// Used to translate between frame sizes and the FRAME_* bit flags
#define NON_STANDARD    0x80000000
#define SIZE_TO_FLAG(s) (s == Small  ? FRAME_SQCIF : s == Medium ? FRAME_QCIF: s == Large ? FRAME_CIF : NON_STANDARD)


const int VID_AVG_PACKET_SIZE = 450; // avg from NetMon stats


// maps temporal spatial tradeoff to a target frame rate

// assume the MAX frame rate for QCIF and SQCIF is 10 on modem
// let the "best quality" be 2 frames/sec
int g_TSTable_Modem_QCIF[] =
{
	200, 225, 250, 275,  // best quality
	300, 325, 350, 375,
	400, 425, 450, 475,
	500, 525, 550, 575,
	600, 625, 650, 675,
	700, 725, 750, 775,
	800, 825, 850, 875,
	900, 925, 950, 1000   // fast frames
};



// max frame rate for CIF be 2.5 frames/sec on modem
// best quality will be .6 frame/sec
int g_TSTable_Modem_CIF[] =
{
	60,   66,  72,  78,
	84,   90,  96, 102,
	108, 114, 120, 126,
	132, 140, 146, 152,
	158, 164, 170, 174,
	180, 186, 192, 198,
	208, 216, 222, 228,
	232, 238, 244, 250
};




#ifdef USE_NON_LINEAR_FPS_ADJUSTMENT
// this table and related code anc be used for non-linear adjustment of our frame rate based
// on QOS information in QosNotifyVideoCB
int g_QoSMagic[19][19] =
{
	{-90,-90,-90,-90,-90,-90,-90,-90,-90,-90,-90,-90,-90,-90,-90,-90,-90,-90,-90},
	{-90,-80,-80,-80,-80,-80,-80,-80,-80,-80,-80,-80,-80,-80,-80,-80,-80,-80,-80},
	{-90,-80,-70,-70,-70,-70,-70,-70,-70,-70,-70,-70,-70,-70,-70,-70,-70,-70,-70},
	{-90,-80,-70,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60,-60},
	{-90,-80,-70,-60,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50,-50},
	{-90,-80,-70,-60,-50,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40},
	{-90,-80,-70,-60,-50,-40,-30,-30,-30,-30,-30,-30,-30,-30,-30,-30,-30,-30,-30},
	{-90,-80,-70,-60,-50,-40,-30,-20,-20,-20,-20,-20,-20,-20,-20,-20,-20,-20,-20},
	{-90,-80,-70,-60,-50,-40,-30,-20,-10,-10,-10,-10,-10,-10,-10,-10,-10,-10,-10},
	{-90,-80,-70,-60,-50,-40,-30,-20,-10,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
	{-90,-80,-70,-60,-50,-40,-30,-20,-10,  0, 10, 10, 10, 10, 10, 10, 10, 10, 10},
	{-90,-80,-70,-60,-50,-40,-30,-20,-10,  0, 10, 20, 20, 20, 20, 20, 20, 20, 20},
	{-90,-80,-70,-60,-50,-40,-30,-20,-10,  0, 10, 20, 30, 30, 30, 30, 30, 30, 30},
	{-90,-80,-70,-60,-50,-40,-30,-20,-10,  0, 10, 20, 30, 40, 40, 40, 40, 40, 40},
	{-90,-80,-70,-60,-50,-40,-30,-20,-10,  0, 10, 20, 30, 40, 50, 50, 50, 50, 50},
	{-90,-80,-70,-60,-50,-40,-30,-20,-10,  0, 10, 20, 30, 40, 50, 60, 60, 60, 60},
	{-90,-80,-70,-60,-50,-40,-30,-20,-10,  0, 10, 20, 30, 40, 50, 60, 70, 70, 70},
	{-90,-80,-70,-60,-50,-40,-30,-20,-10,  0, 10, 20, 30, 40, 50, 60, 70, 80, 80},
	{-90,-80,-70,-60,-50,-40,-30,-20,-10,  0, 10, 20, 30, 40, 50, 60, 70, 80, 90},
};
#endif

BOOL SortOrder(IAppVidCap *pavc, BASIC_VIDCAP_INFO* pvidcaps, DWORD dwcFormats,
        DWORD dwFlags, WORD wDesiredSortOrder, int nNumFormats);


UINT ChoosePacketSize(VIDEOFORMATEX *pvf)
{
	// set default samples per pkt to 1
	UINT spp, sblk;
	spp = 1;
	// calculate samples per block ( aka frame)
	sblk = pvf->nBlockAlign* pvf->nSamplesPerSec/ pvf->nAvgBytesPerSec;
	if (sblk <= spp) {
		spp = (spp/sblk)*sblk;
	} else
		spp = sblk;
	return spp;
}



HRESULT STDMETHODCALLTYPE SendVideoStream::QueryInterface(REFIID iid, void **ppVoid)
{
	// resolve duplicate inheritance to the SendMediaStream;

	extern IID IID_IProperty;

	if (iid == IID_IUnknown)
	{
		*ppVoid = (IUnknown*)((RecvMediaStream*)this);
	}
	else if (iid == IID_IMediaChannel)
	{
		*ppVoid = (IMediaChannel*)((RecvMediaStream *)this);
	}
	else if (iid == IID_IVideoChannel)
	{
		*ppVoid = (IVideoChannel*)this;
	}
	else if (iid == IID_IProperty)
	{
		*ppVoid = NULL;
		ERROR_OUT(("Don't QueryInterface for IID_IProperty, use IMediaChannel"));
		return E_NOINTERFACE;
	}

	else if (iid == IID_IVideoRender)// satisfy symmetric property of QI
	{
		*ppVoid = (IVideoRender *)this;
	}

	else
	{
		*ppVoid = NULL;
		return E_NOINTERFACE;
	}

	AddRef();

	return S_OK;

}

ULONG STDMETHODCALLTYPE SendVideoStream::AddRef(void)
{
	return InterlockedIncrement(&m_lRefCount);
}

ULONG STDMETHODCALLTYPE SendVideoStream::Release(void)
{
	LONG lRet;

	lRet = InterlockedDecrement(&m_lRefCount);

	if (lRet == 0)
	{
		delete this;
		return 0;
	}

	else
		return lRet;

}


DWORD CALLBACK SendVideoStream::StartCaptureThread(LPVOID pVoid)
{
	SendVideoStream *pThisStream = (SendVideoStream*)pVoid;
	return pThisStream->CapturingThread();
}

HRESULT
SendVideoStream::Initialize(DataPump *pDP)
{
	HRESULT hr = DPR_OUT_OF_MEMORY;
	DWORD dwFlags =  DP_FLAG_FULL_DUPLEX | DP_FLAG_AUTO_SWITCH ;
	MEDIACTRLINIT mcInit;
	FX_ENTRY ("DP::InitChannel")
    FINDCAPTUREDEVICE fcd;

	m_pIUnknown = (IUnknown *)NULL;

	InitializeCriticalSection(&m_crsVidQoS);
	InitializeCriticalSection(&m_crs);
	dwFlags |= DP_FLAG_VCM | DP_FLAG_VIDEO ;

    m_maxfps = 2997;            // max of 29.97 fps
    m_frametime = 1000 / 30;     // default of 30 fps  (time in ms) QOS will slow us, if
                                 // need be

	// Modem connections will use a frame rate control table
	// to implement TS-Tradeoff
	m_pTSTable = NULL;
	m_dwCurrentTSSetting = VCM_DEFAULT_IMAGE_QUALITY;

	// store the platform flags
	// enable Send and Recv by default
	m_DPFlags = (dwFlags & DP_MASK_PLATFORM) | DPFLAG_ENABLE_SEND ;
	// store a back pointer to the datapump container
	m_pDP = pDP;
	m_pRTPSend = NULL;
	
//    m_PrevFormatId = INVALID_MEDIA_FORMAT;
	ZeroMemory(&m_fCodecOutput, sizeof(VIDEOFORMATEX));

	// Initialize data (should be in constructor)
	m_CaptureDevice =  (UINT) -1;	// use VIDEO_MAPPER
	m_PreviousCaptureDevice = (UINT) -1;


    DBG_SAVE_FILE_LINE
	m_SendStream = new TxStream();
	if (!m_SendStream)
	{
		DEBUGMSG (ZONE_DP, ("%s:  TxStream new failed\r\n", _fx_));
 		goto StreamAllocError;
	}


	// Create Input and Output video filters
    DBG_SAVE_FILE_LINE
	m_pVideoFilter = new VcmFilter();
	m_dwDstSize = 0;
	if (m_pVideoFilter==NULL)
	{
		DEBUGMSG (ZONE_DP, ("%s: VcmFilter new failed\r\n", _fx_));
		goto FilterAllocError;
	}
	

	//Create Video MultiMedia device control objects
    DBG_SAVE_FILE_LINE
	m_InMedia = new VideoInControl();
	if (!m_InMedia )
	{
		DEBUGMSG (ZONE_DP, ("%s: MediaControl new failed\r\n", _fx_));
		goto MediaAllocError;
	}

	// Initialize the send-stream media control object
	mcInit.dwFlags = dwFlags | DP_FLAG_SEND;
	hr = m_InMedia->Initialize(&mcInit);
	if (hr != DPR_SUCCESS)
	{
		DEBUGMSG (ZONE_DP, ("%s: IMedia->Init failed, hr=0x%lX\r\n", _fx_, hr));
		goto MediaAllocError;
	}


	// determine if the video devices are available
    fcd.dwSize = sizeof (FINDCAPTUREDEVICE);
    if (FindFirstCaptureDevice(&fcd, NULL)) {
		DEBUGMSG (ZONE_DP, ("%s: OMedia->have capture cap\r\n", _fx_));
		m_DPFlags |= DP_FLAG_RECORD_CAP ;
	}
	
	// set media to half duplex mode by default
	m_InMedia->SetProp(MC_PROP_DUPLEX_TYPE, DP_FLAG_HALF_DUPLEX);

	m_SavedTickCount = timeGetTime();	//so we start with low timestamps
	m_DPFlags |= DPFLAG_INITIALIZED;

	return DPR_SUCCESS;


MediaAllocError:
	if (m_InMedia) delete m_InMedia;
FilterAllocError:
	if (m_pVideoFilter) delete m_pVideoFilter;
StreamAllocError:
	if (m_SendStream) delete m_SendStream;

	ERRORMESSAGE( ("SendVideoStream::Initialize: exit, hr=0x%lX\r\n",  hr));

	return hr;
}

// LOOK: identical to SendAudioStream version.
SendVideoStream::~SendVideoStream()
{

	if (m_DPFlags & DPFLAG_INITIALIZED) {
		m_DPFlags &= ~DPFLAG_INITIALIZED;

		// TEMP:Make sure preview stops
		m_DPFlags &= ~DPFLAG_ENABLE_PREVIEW;
		
		if (m_DPFlags & DPFLAG_CONFIGURED_SEND )
		{
			UnConfigure();
		}

		if (m_pRTPSend)
		{
			m_pRTPSend->Release();
			m_pRTPSend = NULL;
		}


		// Close the receive and transmit streams
		if (m_SendStream) delete m_SendStream;

		// Close the wave devices
		if (m_InMedia) { delete m_InMedia;}
		// Close the filters
		if (m_pVideoFilter)
		{
			delete m_pVideoFilter;
		}
		m_pDP->RemoveMediaChannel(MCF_SEND| MCF_VIDEO, (IMediaChannel*)(RecvMediaStream *)this);

	}
	DeleteCriticalSection(&m_crs);
	DeleteCriticalSection(&m_crsVidQoS);
}



HRESULT STDMETHODCALLTYPE SendVideoStream::Configure(
	BYTE *pFormat,
	UINT cbFormat,
	BYTE *pChannelParams,
	UINT cbParams,
	IUnknown *pUnknown)
{
	HRESULT hr;
	BOOL fRet;
	MEDIAPACKETINIT pcktInit;
	MEDIACTRLCONFIG mcConfig;
	MediaPacket **ppPckt;
	ULONG cPckt, uIndex;
	DWORD_PTR dwPropVal;
	VIDEOFORMATEX *pfSend = (VIDEOFORMATEX*)pFormat;
	DWORD maxBitRate=0;
	DWORD i, dwSrcSize, dwMaxFragSize=0;
	int iXOffset, iYOffset;
	VIDEO_CHANNEL_PARAMETERS vidChannelParams;
	struct {
		int cResources;
		RESOURCE aResources[1];
	} m_aLocalRs;
	vidChannelParams.RTP_Payload = 0;
	int optval = 0 ;
	CCaptureChain *pChain;
	HCAPDEV hCapDev=NULL;
    LPBITMAPINFOHEADER lpcap, lpsend;
	BOOL fNewDeviceSettings = TRUE;
	BOOL fNewDevice = TRUE;
	BOOL fLive = FALSE, fReconfiguring;
	MMRESULT mmr;
	DWORD dwStreamingMode = STREAMING_PREFER_FRAME_GRAB;


	FX_ENTRY ("SendVideoStream::Configure")

    if (pfSend)
    {
    	// for now, don't allow SendVideoStream to be re-configured
	    // if we are already streaming.
        if (m_DPFlags & DPFLAG_STARTED_SEND)
        {
            return DPR_IO_PENDING;
        }
    }
    else
    {
        ASSERT(!pChannelParams);
    }

	if(NULL != pChannelParams)
	{
		// get channel parameters
		if (cbParams != sizeof(vidChannelParams))
		{
			hr = DPR_INVALID_PARAMETER;
			goto IMediaInitError;
		}

		vidChannelParams = *(VIDEO_CHANNEL_PARAMETERS *)pChannelParams;
		fLive = TRUE;
	}
    else
    {
        //
    	// else this is configuring for preview or is unconfiguring. There are
        // no channel parameters
        //
    }
	
    if (m_DPFlags & DPFLAG_CONFIGURED_SEND)
	{
        if (pfSend)
        {
            if (m_CaptureDevice == m_PreviousCaptureDevice)
    			fNewDevice = FALSE;
	    	if (IsSimilarVidFormat(&m_fCodecOutput, pfSend))
    			fNewDeviceSettings = FALSE;
        }

		// When using a different capture device, we systematically configure everyting
		// although it would probably be possible to optimize the configuration
		// of the filters and transmit stream
        EndSend();
		UnConfigureSendVideo(fNewDeviceSettings, fNewDevice);
    }

    if (!pfSend)
    {
        return DPR_SUCCESS;
    }

	if (fLive)
		m_DPFlags |= DPFLAG_REAL_THING;

//	m_Net = pNet;
	
	if (! (m_DPFlags & DPFLAG_INITIALIZED))
		return DPR_OUT_OF_MEMORY;		//BUGBUG: return proper error;
		
	if (fNewDeviceSettings || fNewDevice)
	{
		m_ThreadFlags |= DPTFLAG_PAUSE_CAPTURE;

		mcConfig.uDuration = MC_USING_DEFAULT;	// set duration by samples per pkt
		// force an unknown device to be profiled by fetching
		// it's streaming capabilites BEFORE opening it
		mmr = vcmGetDevCapsStreamingMode(m_CaptureDevice, &dwStreamingMode);
		if (mmr != MMSYSERR_NOERROR)
		{
			dwStreamingMode = STREAMING_PREFER_FRAME_GRAB;
		}


		m_InMedia->GetProp (MC_PROP_MEDIA_DEV_HANDLE, &dwPropVal);

		if (!dwPropVal) {
			// if capture device isn't already open, then open it
			m_InMedia->SetProp(MC_PROP_MEDIA_DEV_ID, (DWORD)m_CaptureDevice);
			if (fNewDevice)
			{
				hr = m_InMedia->Open();
    			if (hr != DPR_SUCCESS) {
	    			DEBUGMSG (ZONE_DP, ("%s: m_InMedia->Open failed to open capture, hr=0x%lX\r\n", _fx_, hr));
					goto IMediaInitError;
				}
			}
			m_InMedia->GetProp (MC_PROP_MEDIA_DEV_HANDLE, &dwPropVal);
    		if (!dwPropVal) {
	    		DEBUGMSG (ZONE_DP, ("%s: capture device not open (0x%lX)\r\n", _fx_));
				goto IMediaInitError;
			}
		}
		hCapDev = (HCAPDEV)dwPropVal;

		if (m_pCaptureChain) {
			delete m_pCaptureChain;
			m_pCaptureChain = NULL;
		}

		i = 0;  // assume no colortable

		// m_fDevSend is the uncompressed format
		// pfSend is the compressed format
		mmr = VcmFilter::SuggestEncodeFormat(m_CaptureDevice, &m_fDevSend, pfSend);

		if (mmr == MMSYSERR_NOERROR) {
			i = m_fDevSend.bih.biClrUsed;   // non-zero, if vcmstrm gave us a colortable
			SetCaptureDeviceFormat(hCapDev, &m_fDevSend.bih, 0, 0);
		}

		dwPropVal = GetCaptureDeviceFormatHeaderSize(hCapDev);
		while (1) {
			if (lpcap = (LPBITMAPINFOHEADER)MemAlloc((UINT)dwPropVal)) {
				lpcap->biSize = (DWORD)dwPropVal;
				if (!GetCaptureDeviceFormat(hCapDev, lpcap)) {
					MemFree(lpcap);
            		DEBUGMSG (ZONE_DP, ("%s: failed to set/get capture format\r\n", _fx_));
					goto IMediaInitError;
				}
				UPDATE_REPORT_ENTRY(g_prptSystemSettings, (lpcap->biWidth << 22) | (lpcap->biHeight << 12) | ((lpcap->biCompression == VIDEO_FORMAT_UYVY) ? VIDEO_FORMAT_NUM_COLORS_UYVY : (lpcap->biCompression == VIDEO_FORMAT_YUY2) ? VIDEO_FORMAT_NUM_COLORS_YUY2 : (lpcap->biCompression == VIDEO_FORMAT_IYUV) ? VIDEO_FORMAT_NUM_COLORS_IYUV : (lpcap->biCompression == VIDEO_FORMAT_I420) ? VIDEO_FORMAT_NUM_COLORS_I420 : (lpcap->biCompression == VIDEO_FORMAT_YVU9) ? VIDEO_FORMAT_NUM_COLORS_YVU9 : (lpcap->biCompression == 0) ? ((lpcap->biBitCount == 24) ? VIDEO_FORMAT_NUM_COLORS_16777216 : (lpcap->biBitCount == 16) ? VIDEO_FORMAT_NUM_COLORS_65536 : (lpcap->biBitCount == 8) ? VIDEO_FORMAT_NUM_COLORS_256 : (lpcap->biBitCount == 4) ? VIDEO_FORMAT_NUM_COLORS_16 : 0x00000800) : 0x00000800), REP_DEVICE_IMAGE_SIZE);
				if (lpcap->biBitCount > 8)
					break;
				else if (dwPropVal > 256 * sizeof(RGBQUAD)) {
					if (i) {
						// vcmstrm gave us a colortable in m_fDevSend, so use it
						CopyMemory(((BYTE*)lpcap) + lpcap->biSize, (BYTE*)&m_fDevSend.bih + m_fDevSend.bih.biSize,
								   256 * sizeof(RGBQUAD));
					}
					else {
						CAPTUREPALETTE pal;
						LPRGBQUAD lprgb;

						GetCaptureDevicePalette(hCapDev, &pal);
						lprgb = (LPRGBQUAD)(((BYTE*)lpcap) + lpcap->biSize);
						for (i = 0; i < 256; i++) {
               				lprgb->rgbRed = pal.pe[i].peRed;
               				lprgb->rgbGreen = pal.pe[i].peGreen;
                   			lprgb->rgbBlue = pal.pe[i].peBlue;
                   			lprgb++;
						}
					}
					break;
				}

				dwPropVal += 256 * sizeof(RGBQUAD);
				MemFree(lpcap);  // free this lpcap, and alloc a new with room for palette
			}
			else {
       			DEBUGMSG (ZONE_DP, ("%s: failed to set/get capture format\r\n", _fx_));
    			goto IMediaInitError;
			}
		}

        DBG_SAVE_FILE_LINE
		if (pChain = new CCaptureChain) {
    		VIDEOFORMATEX *capfmt;

			// if pfSend is 128x96, but capture is greater, then InitCaptureChain with a larger size so
			// that the codec will just crop to 128x96
			iXOffset = pfSend->bih.biWidth;
			iYOffset = pfSend->bih.biHeight;
			if ((iXOffset == 128) && (iYOffset == 96)) {
				if (lpcap->biWidth == 160) {
					iXOffset = lpcap->biWidth;
					iYOffset = lpcap->biHeight;
				}
				else if (lpcap->biWidth == 320) {
					iXOffset = lpcap->biWidth / 2;
					iYOffset = lpcap->biHeight / 2;
				}
			}
			if ((hr = pChain->InitCaptureChain(hCapDev,
				(dwStreamingMode==STREAMING_PREFER_STREAMING),
								 lpcap, iXOffset, iYOffset, 0, &lpsend)) != NO_ERROR) {
       			DEBUGMSG (ZONE_DP, ("%s: failed to init capture chain\r\n", _fx_));
    			MemFree(lpcap);
       			delete pChain;
    			goto IMediaInitError;
			}
		}
		else {
   			DEBUGMSG (ZONE_DP, ("%s: failed allocate capture chain\r\n", _fx_));
   			MemFree((HANDLE)lpcap);
   			hr = DPR_OUT_OF_MEMORY;
			goto IMediaInitError;
		}
		MemFree((HANDLE)lpcap);

		m_pCaptureChain = pChain;

		// build m_fDevSend format as format that will be input to codec
		CopyMemory(&m_fDevSend, pfSend, sizeof(VIDEOFORMATEX)-sizeof(BITMAPINFOHEADER)-BMIH_SLOP_BYTES);

		// m_fDevSend.bih is the output format of the CaptureChain
		CopyMemory(&m_fDevSend.bih, lpsend, lpsend->biSize);
		//LOOKLOOK RP - need to get colortable too?

		m_fDevSend.dwFormatSize = sizeof(VIDEOFORMATEX);
		m_fDevSend.dwFormatTag = lpsend->biCompression;
		m_fDevSend.nAvgBytesPerSec = m_fDevSend.nMinBytesPerSec =
			m_fDevSend.nMaxBytesPerSec = m_fDevSend.nSamplesPerSec * lpsend->biSizeImage;
		m_fDevSend.nBlockAlign = lpsend->biSizeImage;
		m_fDevSend.wBitsPerSample = lpsend->biBitCount;
		LocalFree((HANDLE)lpsend);

		mcConfig.pDevFmt = &m_fDevSend;
		UPDATE_REPORT_ENTRY(g_prptCallParameters, pfSend->dwFormatTag, REP_SEND_VIDEO_FORMAT);
		RETAILMSG(("NAC: Video Send Format: %.4s", (LPSTR)&pfSend->dwFormatTag));

		// Initialize the send-stream media control object
		mcConfig.hStrm = (DPHANDLE) m_SendStream;
		m_InMedia->GetProp(MC_PROP_MEDIA_DEV_ID, &dwPropVal);
        mcConfig.uDevId = (DWORD)dwPropVal;

		mcConfig.cbSamplesPerPkt = ChoosePacketSize(pfSend);

		hr = m_InMedia->Configure(&mcConfig);
		if (hr != DPR_SUCCESS)
		{
			DEBUGMSG (ZONE_DP, ("%s: IVMedia->Config failed, hr=0x%lX\r\n", _fx_, hr));
			goto IMediaInitError;
		}

		// initialize m_cliprect
		iXOffset = 0; iYOffset = 0;
		if (m_fDevSend.bih.biWidth > pfSend->bih.biWidth)
			iXOffset = (m_fDevSend.bih.biWidth - pfSend->bih.biWidth) >> 1;
		if (m_fDevSend.bih.biHeight > pfSend->bih.biHeight)
			iYOffset = (m_fDevSend.bih.biHeight - pfSend->bih.biHeight) >> 1;
		SetRect(&m_cliprect, iXOffset, iYOffset, pfSend->bih.biWidth + iXOffset, pfSend->bih.biHeight + iYOffset);

		dwMaxFragSize = 512;	// default video packet size
		CopyMemory (&m_fCodecOutput, pfSend, sizeof(VIDEOFORMATEX));
		m_InMedia->GetProp (MC_PROP_SIZE, &dwPropVal);
        dwSrcSize = (DWORD)dwPropVal;

		mmr = m_pVideoFilter->Open(&m_fDevSend, &m_fCodecOutput, dwMaxFragSize);

		if (mmr != MMSYSERR_NOERROR)
		{
			DEBUGMSG (ZONE_DP, ("%s: VcmFilter->Open failed, mmr=%d\r\n", _fx_, mmr));
			hr = DPR_CANT_OPEN_CODEC;
			goto SendFilterInitError;
		}

		// Initialize the send queue
		ZeroMemory (&pcktInit, sizeof (pcktInit));

		pcktInit.dwFlags = DP_FLAG_SEND | DP_FLAG_VCM | DP_FLAG_VIDEO;
		pcktInit.pStrmConvSrcFmt = &m_fDevSend;
		pcktInit.pStrmConvDstFmt = &m_fCodecOutput;
		pcktInit.cbSizeRawData = dwSrcSize;
		pcktInit.cbOffsetRawData = 0;


		m_InMedia->FillMediaPacketInit (&pcktInit);
		m_InMedia->GetProp (MC_PROP_SIZE, &dwPropVal);


		m_pVideoFilter->SuggestDstSize(dwSrcSize, &m_dwDstSize);
		pcktInit.cbSizeNetData = m_dwDstSize;
			
		m_pVideoFilter->GetProperty(FM_PROP_PAYLOAD_HEADER_SIZE,
                                    &pcktInit.cbPayloadHeaderSize);


		pcktInit.cbOffsetNetData = sizeof (RTP_HDR);
		pcktInit.payload = vidChannelParams.RTP_Payload;



		fRet = m_SendStream->Initialize (DP_FLAG_VIDEO, MAX_TXVRING_SIZE, m_pDP, &pcktInit);
		if (!fRet)
		{
			DEBUGMSG (ZONE_DP, ("%s: TxvStream->Init failed, fRet=0%u\r\n", _fx_, fRet));
			hr = DPR_CANT_INIT_TXV_STREAM;
			goto TxStreamInitError;
		}

		// Prepare headers for TxvStream
		m_SendStream->GetRing (&ppPckt, &cPckt);
		m_InMedia->RegisterData (ppPckt, cPckt);
		m_InMedia->PrepareHeaders ();
	}
	else
	{
		// The following fields may change with the capabilities of the other end point
		dwMaxFragSize = 512;	// default video packet size
		if (pChannelParams)
		{
			m_pVideoFilter->GetProperty(FM_PROP_PAYLOAD_HEADER_SIZE,
                                        &pcktInit.cbPayloadHeaderSize);

			pcktInit.cbOffsetNetData = sizeof (RTP_HDR);
		}
	}
	
	if(pChannelParams)
	{
		// Update the bitrate
		maxBitRate = vidChannelParams.ns_params.maxBitRate*100;
		if (maxBitRate < BW_144KBS_BITS)
			maxBitRate = BW_144KBS_BITS;

		// set the max. fragment size
		DEBUGMSG(ZONE_DP,("%s: Video Send: maxBitRate=%d, maxBPP=%d, MPI=%d\r\n",
			_fx_,maxBitRate,
			vidChannelParams.ns_params.maxBPP*1024,	vidChannelParams.ns_params.MPI*33));

		// Initialize the max frame rate with the negociated max
		if ((vidChannelParams.ns_params.MPI > 0UL) && (vidChannelParams.ns_params.MPI < 33UL))
		{
			dwPropVal = 2997UL / vidChannelParams.ns_params.MPI;
			m_maxfps = (DWORD)dwPropVal;
			INIT_COUNTER_MAX(g_pctrVideoSend, (m_maxfps + 50) / 100);
			UPDATE_REPORT_ENTRY(g_prptCallParameters, (m_maxfps + 50) / 100, REP_SEND_VIDEO_MAXFPS);
			RETAILMSG(("NAC: Video Send Max Frame Rate (negotiated - fps): %ld", (m_maxfps + 50) / 100));
			DEBUGMSG(1,("%s: Video Send: Negociated max fps = %d.%d\r\n", _fx_, m_maxfps/100, m_maxfps - m_maxfps / 100 * 100));
		}

		UPDATE_REPORT_ENTRY(g_prptCallParameters, maxBitRate, REP_SEND_VIDEO_BITRATE);
		RETAILMSG(("NAC: Video Send Max Bitrate (negotiated - bps): %ld", maxBitRate));
		INIT_COUNTER_MAX(g_pctrVideoSendBytes, maxBitRate * 75 / 100);

		// At this point we actually know what is the minimum bitrate chosen
		// by the sender and the receiver. Let's reset the resources reserved
		// by the QoS with those more meaningfull values.
		if (m_pDP->m_pIQoS)
		{
			// Fill in the resource list
			m_aLocalRs.cResources = 1;
			m_aLocalRs.aResources[0].resourceID = RESOURCE_OUTGOING_BANDWIDTH;

			// Do a sanity check on the minimal bit rate
			m_aLocalRs.aResources[0].nUnits = maxBitRate;
			m_aLocalRs.aResources[0].ulResourceFlags = m_aLocalRs.aResources[0].reserved = 0;

			DEBUGMSG(1,("%s: Video Send: Negociated max bps = %d\r\n", _fx_, maxBitRate));

			// Set the resources on the QoS object
			hr = m_pDP->m_pIQoS->SetResources((LPRESOURCELIST)&m_aLocalRs);
		}

		// if we're sending on the LAN, fragment video frames into Ethernet packet sized chunks
		// On slower links use smaller packets for better bandwidth sharing
		// NOTE: codec packetizer can occasionally exceed the fragment size limit
		if (maxBitRate > BW_ISDN_BITS)
			dwMaxFragSize = 1350;

		m_pVideoFilter->SetProperty(FM_PROP_VIDEO_MAX_PACKET_SIZE, dwMaxFragSize);

		// To correctly initialize the flow spec structure we need to get the values that
		// our QoS module will be effectively using. Typically, we only use 70% of the max
		// advertized. On top of that, some system administrator may have significantly
		// reduced the maximum bitrate on this machine.
		if (m_pDP->m_pIQoS)
		{
			LPRESOURCELIST pResourceList = NULL;

			// Get a list of all resources from QoS
			hr = m_pDP->m_pIQoS->GetResources(&pResourceList);
			if (SUCCEEDED(hr) && pResourceList)
			{
				// Find the BW resource
				for (i=0; i < pResourceList->cResources; i++)
				{
					if (pResourceList->aResources[i].resourceID == RESOURCE_OUTGOING_BANDWIDTH)
					{
						maxBitRate = min(maxBitRate, (DWORD)pResourceList->aResources[i].nUnits);
						break;
					}
				}

				// Release memory
				m_pDP->m_pIQoS->FreeBuffer(pResourceList);
			}
		}

		// WS2Qos will be called in Start to communicate stream information to the
		// remote endpoint using a PATH message
		//
		// We use a peak-rate allocation approach based on our target bitrates
		// Note that for the token bucket size and the maximum SDU size, we now
		// account for IP header overhead, and use the max frame fragment size
		// instead of the maximum compressed image size returned by the codec

		ASSERT(maxBitRate > 0);

		InitVideoFlowspec(&m_flowspec, maxBitRate, dwMaxFragSize, VID_AVG_PACKET_SIZE);

		// Update RTCP send address and payload type. It should be known now
		// We have to explicitly set the payload again because the preview
		// channel configuration has already set it to zero.
		m_RTPPayload = vidChannelParams.RTP_Payload;
		m_SendStream->GetRing (&ppPckt, &cPckt);
		for (uIndex = 0; uIndex < cPckt; uIndex++)
		{
			ppPckt[uIndex]->SetPayload(m_RTPPayload);
		}

		// Keep a weak reference to the IUnknown interface
		// We will use it to query a Stream Signal interface pointer in Start()
		m_pIUnknown = pUnknown;
	}

	if (m_DPFlags & DPFLAG_REAL_THING)
	{
		if (m_pDP->m_pIQoS)
		{
			// Initialize our requests. One for CPU usage, one for bandwidth usage.
			m_aRRq.cResourceRequests = 2;
			m_aRRq.aResourceRequest[0].resourceID = RESOURCE_OUTGOING_BANDWIDTH;
			m_aRRq.aResourceRequest[0].nUnitsMin = 0;
			m_aRRq.aResourceRequest[1].resourceID = RESOURCE_CPU_CYCLES;
			m_aRRq.aResourceRequest[1].nUnitsMin = 0;

			// Initialize QoS structure
			ZeroMemory(&m_Stats, sizeof(m_Stats));

			// Start collecting CPU performance data from the registry
			StartCPUUsageCollection();

			// Register with the QoS module. This call should NEVER fail. If it does, we'll do without the QoS
			m_pDP->m_pIQoS->RequestResources((GUID *)&MEDIA_TYPE_H323VIDEO, (LPRESOURCEREQUESTLIST)&m_aRRq, QosNotifyVideoCB, (DWORD_PTR)this);
		}
	}

	// reset the temporal spatial tradeoff to best quality
	// it's expected that the UI will re-specify the TS setting
	// sometime after the stream is started
	m_pVideoFilter->SetProperty(FM_PROP_VIDEO_RESET_IMAGE_QUALITY ,VCM_RESET_IMAGE_QUALITY);
	m_pTSTable = NULL;
	m_dwCurrentTSSetting = VCM_MAX_IMAGE_QUALITY;



    //Before we start, reset the frame frame rate to the channel max.
    //If the previous call had been slower than possible, resume
    //previewing at the desired FPS.
	if (pChannelParams && (m_DPFlags & DPFLAG_REAL_THING))
	{
		int iSlowStartFrameRate;

		// us a frame-rate table for temporal spatial tradeoff settings
		// if the bandwidth is a modem setting
		if (maxBitRate <= BW_288KBS_BITS)
		{
			if (pfSend->bih.biWidth >= CIF_WIDTH)
			{
				m_pTSTable = g_TSTable_Modem_CIF;
			}
			else
			{
				m_pTSTable = g_TSTable_Modem_QCIF;
			}
		}

		// Let's do a slow start and then catch up with the negociated max

		if (m_pTSTable == NULL)
		{
			iSlowStartFrameRate = m_maxfps >> 1;
		}
		else
		{
			iSlowStartFrameRate = m_pTSTable[VCM_MAX_IMAGE_QUALITY];
		}


		SetProperty(PROP_VIDEO_FRAME_RATE, &iSlowStartFrameRate, sizeof(int));

		// Initialize the codec with the new target bitrates and frame rates
		// PhilF-: This assumes that we start with a silent audio channel...
		SetTargetRates(iSlowStartFrameRate, maxBitRate);


	}
	else
	{
		INIT_COUNTER_MAX(g_pctrVideoSend, 30);
		SetProperty(PROP_VIDEO_FRAME_RATE, &m_maxfps, sizeof(int));
	}

    m_ThreadFlags &= ~DPTFLAG_PAUSE_CAPTURE;
	m_DPFlags |= DPFLAG_CONFIGURED_SEND;
	m_PreviousCaptureDevice = m_CaptureDevice;
//	m_PrevFormatId = SendVidFmt;

	return DPR_SUCCESS;


TxStreamInitError:
	m_pVideoFilter->Close();
SendFilterInitError:
IMediaInitError:
    if (m_pCaptureChain) {
        delete m_pCaptureChain;
        m_pCaptureChain = NULL;
    }
	// We need to close the video controller object on failure to open the capture device,
	// otherwise we get a pure virtual function call on NM shutdown!
	if (m_InMedia)
		m_InMedia->Close();
	ERRORMESSAGE(("%s:  failed, hr=0%u\r\n", _fx_, hr));
	return hr;
}


void SendVideoStream::UnConfigure()
{
	// By default, unconfigure all resources
	UnConfigureSendVideo(TRUE, TRUE);
}


void SendVideoStream::UnConfigureSendVideo(BOOL fNewDeviceSettings, BOOL fNewDevice)
{

#ifdef TEST
	DWORD dwTicks;

	dwTicks = GetTickCount();
#endif

	if (m_DPFlags & DPFLAG_CONFIGURED_SEND)
	{
		if (m_hCapturingThread)
			Stop();

		if (fNewDeviceSettings || fNewDevice)
		{
//			m_PrevFormatId = INVALID_MEDIA_FORMAT;
			ZeroMemory(&m_fCodecOutput, sizeof(VIDEOFORMATEX));

			m_Net = NULL;

			if (m_pCaptureChain)
			{
				delete m_pCaptureChain;
				m_pCaptureChain = NULL;
			}

			// Close the devices
			m_InMedia->Reset();
			m_InMedia->UnprepareHeaders();
			if (fNewDevice)
			{
				m_PreviousCaptureDevice = -1L; // VIDEO_MAPPER
				m_InMedia->Close();
			}

			// Close the filters
			m_pVideoFilter->Close();

			// Close the transmit streams
			m_SendStream->Destroy();
		}

		m_DPFlags &= ~DPFLAG_CONFIGURED_SEND;

		// Release the QoS Resources
		// If the associated RequestResources had failed, the ReleaseResources can be
		// still called... it will just come back without having freed anything.
		if (m_pDP->m_pIQoS)
		{
			if (m_DPFlags & DPFLAG_REAL_THING)
			{
				m_pDP->m_pIQoS->ReleaseResources((GUID *)&MEDIA_TYPE_H323VIDEO, (LPRESOURCEREQUESTLIST)&m_aRRq);

				// Terminate CPU usage data collection
				StopCPUUsageCollection();

			}
			m_DPFlags &= ~DPFLAG_REAL_THING;
		}
	}

#ifdef TEST
	LOG((LOGMSG_TIME_SEND_VIDEO_UNCONFIGURE,GetTickCount() - dwTicks));
#endif

}




HRESULT
SendVideoStream::Start()
{
	int nRet= IFRAMES_CAPS_UNKNOWN;

	FX_ENTRY ("SendVideoStream::Start")

	if (m_DPFlags & DPFLAG_STARTED_SEND)
		return DPR_SUCCESS;
	if (!(m_DPFlags & DPFLAG_CONFIGURED_SEND))
		return DPR_NOT_CONFIGURED;

	// to fix:  if we optimize SetNetworkInterface to allow
	// us to transition from preview->sending without having
	// to call stop/start, we need to make sure the flowspec/QOS
	// stuff get's called there.

	SetFlowSpec();
		
	ASSERT(!m_hCapturingThread);
	m_ThreadFlags &= ~(DPTFLAG_STOP_RECORD|DPTFLAG_STOP_SEND);
	// Start recording thread
	if (!(m_ThreadFlags & DPTFLAG_STOP_RECORD))
		m_hCapturingThread = CreateThread(NULL,0, SendVideoStream::StartCaptureThread,this,0,&m_CaptureThId);

// ------------------------------------------------------------------------
	// Decide whether or not we need to send periodic I-Frames during this call

	// Who are we talking to?
	if ((m_pIUnknown) && (m_DPFlags & DPFLAG_REAL_THING))
	{
		HRESULT hr;
		IStreamSignal *pIStreamSignal=NULL;

		hr = m_pIUnknown->QueryInterface(IID_IStreamSignal, (void **)&pIStreamSignal);
		if (HR_SUCCEEDED(hr))
		{
			nRet = GetIFrameCaps(pIStreamSignal);
			pIStreamSignal->Release();
		}
	}

	// only disable sending of I Frames if and only if we know the remote party
	// can handle it.  In this case, NetMeeting 3.0 or TAPI 3.1
	if (nRet == IFRAMES_CAPS_NM3)
	{
		m_pVideoFilter->SetProperty(FM_PROP_PERIODIC_IFRAMES, FALSE);
	}
	else
	{
		m_pVideoFilter->SetProperty(FM_PROP_PERIODIC_IFRAMES, TRUE);
	}
// ------------------------------------------------------------------------


	m_DPFlags |= DPFLAG_STARTED_SEND;

	DEBUGMSG (ZONE_DP, ("%s: Record threadid=%x,\r\n", _fx_, m_CaptureThId));
	return DPR_SUCCESS;
}

// LOOK: identical to SendAudioStream version.
HRESULT
SendVideoStream::Stop()
{
	DWORD dwWait;
	

	if(!(m_DPFlags & DPFLAG_STARTED_SEND))
	{
		return DPR_SUCCESS;
	}
	
	m_ThreadFlags = m_ThreadFlags  | DPTFLAG_STOP_SEND |  DPTFLAG_STOP_RECORD;

	if(m_SendStream) {
		m_SendStream->Stop();
		m_SendStream->Reset();
    }
	/*
	 *	we want to wait for all the threads to exit, but we need to handle windows
	 *	messages (mostly from winsock) while waiting.
	 */

 	if(m_hCapturingThread) {
		dwWait = WaitForSingleObject (m_hCapturingThread, INFINITE);

        DEBUGMSG (ZONE_VERBOSE, ("STOP2: dwWait =%d\r\n", dwWait));
    	ASSERT(dwWait != WAIT_FAILED);

		CloseHandle(m_hCapturingThread);
    	m_hCapturingThread = NULL;
    }

	m_DPFlags &= ~DPFLAG_STARTED_SEND;
	
	return DPR_SUCCESS;
}





HRESULT STDMETHODCALLTYPE SendVideoStream::SetMaxBitrate(UINT uMaxBitrate)
{
	DWORD dwFrameRate=0;
	UINT uSize=sizeof(DWORD);
	BOOL bRet;
	HRESULT hr;

	hr = GetProperty(PROP_VIDEO_FRAME_RATE, &dwFrameRate, &uSize);

	if (SUCCEEDED(hr))
	{
		bRet = SetTargetRates(dwFrameRate, (DWORD)uMaxBitrate);
		if (bRet)
			hr = S_OK;
		else
			hr = E_FAIL;
	}

	return hr;
}





//  IProperty::GetProperty / SetProperty
//  (DataPump::MediaChannel::GetProperty)
//      Properties of the MediaStream.

STDMETHODIMP
SendVideoStream::GetProperty(
	DWORD prop,
	PVOID pBuf,
	LPUINT pcbBuf
    )
{
	HRESULT hr = DPR_SUCCESS;
	DWORD dwValue;
    DWORD_PTR dwPropVal;
	UINT len = sizeof(DWORD);	// most props are DWORDs

	if (!pBuf || *pcbBuf < len)
    {
		*pcbBuf = len;
		return DPR_INVALID_PARAMETER;
	}

	switch (prop)
    {
#ifdef OLDSTUFF
	case PROP_NET_SEND_STATS:
		if (m_Net && *pcbBuf >= sizeof(RTP_STATS))
        {
			m_Net->GetSendStats((RTP_STATS *)pBuf);
			*pcbBuf = sizeof(RTP_STATS);
		} else
			hr = DPR_INVALID_PROP_VAL;
			
		break;
#endif
	case PROP_DURATION:
		hr = m_InMedia->GetProp(MC_PROP_DURATION, &dwPropVal);
        *(DWORD *)pBuf = (DWORD)dwPropVal;
		break;


	case PROP_RECORD_ON:
		*(DWORD *)pBuf = ((m_DPFlags & DPFLAG_ENABLE_SEND) !=0);
		break;
	case PROP_CAPTURE_DEVICE:
		*(UINT *)pBuf = m_CaptureDevice;
		break;

	case PROP_VIDEO_FRAME_RATE:
	    *((DWORD *)pBuf) = 100000 / m_frametime;
		break;

	case PROP_VIDEO_IMAGE_QUALITY:
		hr = GetTemporalSpatialTradeOff((DWORD *)pBuf);
		break;

    case PROP_VIDEO_CAPTURE_AVAILABLE:
        *(DWORD *)pBuf = (m_DPFlags & DP_FLAG_RECORD_CAP) != 0;
        break;

    case PROP_VIDEO_CAPTURE_DIALOGS_AVAILABLE:
		hr = m_InMedia->GetProp(MC_PROP_VFW_DIALOGS, &dwPropVal);
        *(DWORD *)pBuf = (DWORD)dwPropVal;
        break;

    case PROP_VIDEO_PREVIEW_ON:
		*(DWORD *)pBuf = ((m_DPFlags & DPFLAG_ENABLE_PREVIEW) != 0);
		break;

	case PROP_PAUSE_SEND:
		*(DWORD *)pBuf = ((m_ThreadFlags & DPTFLAG_PAUSE_SEND) != 0);
		break;
	
	default:
		hr = DPR_INVALID_PROP_ID;
		break;
	}
	return hr;
}


STDMETHODIMP
SendVideoStream::SetProperty(
	DWORD prop,
	PVOID pBuf,
	UINT cbBuf
    )
{
	DWORD dw;
	HRESULT hr = S_OK;
	
	if (cbBuf < sizeof (DWORD))
		return DPR_INVALID_PARAMETER;

	switch (prop)
    {
		
	case PROP_CAPTURE_DEVICE:
		if (m_DPFlags & DPFLAG_ENABLE_PREVIEW)
		{
			return DPR_INVALID_PARAMETER;
		}
		else
		{
			m_CaptureDevice = *(UINT*)pBuf;
			m_InMedia->SetProp(MC_PROP_MEDIA_DEV_ID, (DWORD)m_CaptureDevice);
		}

		break;

	case PROP_VIDEO_FRAME_RATE:
		if (*(DWORD*)pBuf <= m_maxfps) {
    		DEBUGMSG(ZONE_VERBOSE, ("DP: setting fps = %d \n", *(DWORD*)pBuf));
			// set frame rate here
            m_frametime = 100000 / *(DWORD*)pBuf;
        }
		break;

	case PROP_VIDEO_IMAGE_QUALITY:
		hr = SetTemporalSpatialTradeOff(*(DWORD*)pBuf);
		break;

	case PROP_VIDEO_RESET_IMAGE_QUALITY:
		hr = m_pVideoFilter->SetProperty(FM_PROP_VIDEO_IMAGE_QUALITY, VCM_DEFAULT_IMAGE_QUALITY);
		break;

    case PROP_VIDEO_CAPTURE_DIALOG:
        hr = ((VideoInControl *)m_InMedia)->DisplayDriverDialog(GetActiveWindow(), *(DWORD *)pBuf);
        break;

    case PROP_VIDEO_SIZE:
		ASSERT(0);
		break;

    case PROP_VIDEO_PREVIEW_ON:
		ASSERT(0);  	
    	break;
    case PROP_VIDEO_AUDIO_SYNC:
		if (*(DWORD *)pBuf)
    		m_DPFlags |= DPFLAG_AV_SYNC;
		else
			m_DPFlags &= ~DPFLAG_AV_SYNC;
    	break;

	case PROP_PAUSE_SEND:
		if (*(DWORD *)pBuf)
			m_ThreadFlags |= DPTFLAG_PAUSE_SEND;
		else
			m_ThreadFlags &= ~DPTFLAG_PAUSE_SEND;
		break;
	default:
		return DPR_INVALID_PROP_ID;
		break;
	}
	return hr;
}



//---------------------------------------------------------------------
//  IVideoRender implementation and support functions



//  IVideoRender::Init
//  (DataPump::Init)

STDMETHODIMP
SendVideoStream::Init(
    DWORD_PTR dwUser,
    LPFNFRAMEREADY pfCallback
    )
{
    // Save the event away. Note that we DO allow both send and receive to
    // share an event
	m_hRenderEvent = (HANDLE) dwUser;
	// if pfCallback is NULL then dwUser is an event handle
	m_pfFrameReadyCallback = pfCallback;
		
	
	return DPR_SUCCESS;
}


//  IVideoRender::Done
//  (DataPump::Done)

STDMETHODIMP
SendVideoStream::Done( )
{
	m_hRenderEvent = NULL;
	m_pfFrameReadyCallback = NULL;
    return DPR_SUCCESS;
}


//  IVideoRender::GetFrame
//  (DataPump::GetFrame)

STDMETHODIMP
SendVideoStream::GetFrame(
    FRAMECONTEXT* pfc
    )
{
	HRESULT hr;
	PVOID pData = NULL;
	UINT cbData = 0;

    // Validate parameters
    if (!pfc )
        return DPR_INVALID_PARAMETER;

    // Don't arbitrarily call out while holding this crs or you may deadlock...
    EnterCriticalSection(&m_crs);

	if ((m_DPFlags & DPFLAG_CONFIGURED_SEND) && m_pNextPacketToRender && !m_pNextPacketToRender->m_fRendering)
    {
		m_pNextPacketToRender->m_fRendering = TRUE;
		m_pNextPacketToRender->GetDevData(&pData,&cbData);
		pfc->lpData = (PUCHAR) pData;
		pfc->dwReserved = (DWORD_PTR) m_pNextPacketToRender;
		// set bmi length?
		pfc->lpbmi = (PBITMAPINFO)&m_fDevSend.bih;
		pfc->lpClipRect = &m_cliprect;
		m_cRendering++;
		hr = S_OK;
		LOG((LOGMSG_GET_SEND_FRAME,m_pNextPacketToRender->GetIndex()));
	} else
		hr = S_FALSE; // nothing ready to render

    LeaveCriticalSection(&m_crs);

	return hr;	
}


//  IVideoRender::ReleaseFrame
//  (DataPump::ReleaseFrame)

STDMETHODIMP
SendVideoStream::ReleaseFrame(
    FRAMECONTEXT* pfc
    )
{
	HRESULT hr;
	MediaPacket *pPacket;

    // Validate parameters
    if (!pfc)
        return DPR_INVALID_PARAMETER;

    // Handle a send frame
    {
        EnterCriticalSection(&m_crs);

        // Don't arbitrarily call out while holding this crs or you may deadlock...

		if ((m_DPFlags & DPFLAG_CONFIGURED_SEND) && (pPacket = (MediaPacket *)pfc->dwReserved) && pPacket->m_fRendering)
        {
			LOG((LOGMSG_RELEASE_SEND_FRAME,pPacket->GetIndex()));
			pPacket->m_fRendering = FALSE;
			pfc->dwReserved = 0;
			// if its not the current frame
			if (m_pNextPacketToRender != pPacket) {
				pPacket->Recycle();
				m_SendStream->Release(pPacket);
			}
			m_cRendering--;
			hr = S_OK;
		}
        else
			hr = DPR_INVALID_PARAMETER;

        LeaveCriticalSection(&m_crs);
	}
		
	return hr;
}

HRESULT __stdcall SendVideoStream::SendKeyFrame(void)
{
	MMRESULT mmr;
	HVCMSTREAM hvs;

	ASSERT(m_pVideoFilter);

	if ((mmr = m_pVideoFilter->RequestIFrame()) != MMSYSERR_NOERROR)
	{
		return S_FALSE;
	}
	return S_OK;

}

// IVideoChannel
HRESULT __stdcall SendVideoStream::SetTemporalSpatialTradeOff(DWORD dwVal)
{
	HRESULT hr=DPR_NOT_CONFIGURED;

	ASSERT(m_pVideoFilter);

	if (m_pVideoFilter)
	{
		if (m_pTSTable == NULL)
		{
			hr = m_pVideoFilter->SetProperty(FM_PROP_VIDEO_IMAGE_QUALITY, dwVal);
		}
		m_dwCurrentTSSetting = dwVal;
		return S_OK;
	}

	return hr;
}

HRESULT __stdcall SendVideoStream::GetTemporalSpatialTradeOff(DWORD *pdwVal)
{
	HRESULT hr=DPR_NOT_CONFIGURED;

	ASSERT(m_pVideoFilter);

	if (m_pVideoFilter)
	{
		if (m_pTSTable == NULL)
		{
			*pdwVal	= m_dwCurrentTSSetting;	
			hr = S_OK;
		}
		else
		{
			hr = m_pVideoFilter->GetProperty(FM_PROP_VIDEO_IMAGE_QUALITY, pdwVal);
		}
	}
	return hr;
}



HRESULT STDMETHODCALLTYPE RecvVideoStream::QueryInterface(REFIID iid, void **ppVoid)
{
	// resolve duplicate inheritance to the SendMediaStream;

	extern IID IID_IProperty;

	if (iid == IID_IUnknown)
	{
		*ppVoid = (IUnknown*)((RecvMediaStream*)this);
	}
	else if (iid == IID_IMediaChannel)
	{
		*ppVoid = (IMediaChannel*)((RecvMediaStream *)this);
	}
//	else if (iid == IID_IVideoChannel)
//	{
//		*ppVoid = (IVideoChannel*)this;
//	}
	else if (iid == IID_IProperty)
	{
		*ppVoid = NULL;
		ERROR_OUT(("Don't QueryInterface for IID_IProperty, use IMediaChannel"));
		return E_NOINTERFACE;
	}

	else if (iid == IID_IVideoRender)// satisfy symmetric property of QI
	{
		*ppVoid = (IVideoRender *)this;
	}

	else
	{
		*ppVoid = NULL;
		return E_NOINTERFACE;
	}

	AddRef();

	return S_OK;

}

ULONG STDMETHODCALLTYPE RecvVideoStream::AddRef(void)
{
	return InterlockedIncrement(&m_lRefCount);
}

ULONG STDMETHODCALLTYPE RecvVideoStream::Release(void)
{
	LONG lRet;

	lRet = InterlockedDecrement(&m_lRefCount);

	if (lRet == 0)
	{
		delete this;
		return 0;
	}

	else
		return lRet;
}

DWORD CALLBACK RecvVideoStream::StartRenderingThread(PVOID pVoid)
{
	RecvVideoStream *pThisStream = (RecvVideoStream*)pVoid;
	return pThisStream->RenderingThread();
}

HRESULT
RecvVideoStream::Initialize(DataPump *pDP)
{
	HRESULT hr = DPR_OUT_OF_MEMORY;
	DWORD dwFlags =  DP_FLAG_FULL_DUPLEX | DP_FLAG_AUTO_SWITCH ;
	MEDIACTRLINIT mcInit;
	FX_ENTRY ("DP::RecvVideoStream")

	m_pIUnknown = (IUnknown *)NULL;

	InitializeCriticalSection(&m_crs);
	InitializeCriticalSection(&m_crsVidQoS);
	InitializeCriticalSection(&m_crsIStreamSignal);

	dwFlags |= DP_FLAG_VCM | DP_FLAG_VIDEO ;

	// store the platform flags
	// enable Send and Recv by default
	m_DPFlags = (dwFlags & DP_MASK_PLATFORM) | DPFLAG_ENABLE_RECV;
	// store a back pointer to the datapump container
	m_pDP = pDP;
	m_Net = NULL;
	m_pIRTPRecv = NULL;
	

	// Initialize data (should be in constructor)
	m_RenderingDevice = (UINT) -1;	// use VIDEO_MAPPER


	// Create Receive and Transmit video streams
    DBG_SAVE_FILE_LINE
	m_RecvStream = new RVStream(MAX_RXVRING_SIZE);
		
	if (!m_RecvStream )
	{
		DEBUGMSG (ZONE_DP, ("%s: RxStream  new failed\r\n", _fx_));
 		goto StreamAllocError;
	}


	// Create Input and Output video filters
    DBG_SAVE_FILE_LINE
	m_pVideoFilter = new VcmFilter();
	m_dwSrcSize = 0;
	if (m_pVideoFilter == NULL)
	{
		DEBUGMSG (ZONE_DP, ("%s: VcmFilter new failed\r\n", _fx_));
		goto FilterAllocError;
	}
	

	//Create Video MultiMedia device control objects
    DBG_SAVE_FILE_LINE
	m_OutMedia = new VideoOutControl();
	if ( !m_OutMedia)
	{
		DEBUGMSG (ZONE_DP, ("%s: MediaControl new failed\r\n", _fx_));
		goto MediaAllocError;
	}


	// Initialize the recv-stream media control object
	mcInit.dwFlags = dwFlags | DP_FLAG_RECV;
	hr = m_OutMedia->Initialize(&mcInit);
	if (hr != DPR_SUCCESS)
	{
		DEBUGMSG (ZONE_DP, ("%s: OMedia->Init failed, hr=0x%lX\r\n", _fx_, hr));
		goto MediaAllocError;
	}


	m_DPFlags |= DP_FLAG_RECORD_CAP ;
	
	// set media to half duplex mode by default
	m_OutMedia->SetProp(MC_PROP_DUPLEX_TYPE, DP_FLAG_HALF_DUPLEX);
	m_DPFlags |= DPFLAG_INITIALIZED;

	return DPR_SUCCESS;


MediaAllocError:
	if (m_OutMedia) delete m_OutMedia;
FilterAllocError:
	if (m_pVideoFilter) delete m_pVideoFilter;
StreamAllocError:
	if (m_RecvStream) delete m_RecvStream;

	ERRORMESSAGE( ("%s: exit, hr=0x%lX\r\n", _fx_,  hr));

	return hr;
}

// LOOK: identical to RecvAudioStream version.
RecvVideoStream::~RecvVideoStream()
{

	if (m_DPFlags & DPFLAG_INITIALIZED) {
		m_DPFlags &= ~DPFLAG_INITIALIZED;
	
		if (m_DPFlags & DPFLAG_CONFIGURED_RECV)
			UnConfigure();

		// Close the receive and transmit streams
		if (m_RecvStream) delete m_RecvStream;

		// Close the wave devices
		if (m_OutMedia) { delete m_OutMedia;}
		// Close the filters
		if (m_pVideoFilter)
			delete m_pVideoFilter;

		m_pDP->RemoveMediaChannel(MCF_RECV| MCF_VIDEO, this);

	}
	DeleteCriticalSection(&m_crs);
	DeleteCriticalSection(&m_crsVidQoS);
	DeleteCriticalSection(&m_crsIStreamSignal);
}


HRESULT
RecvVideoStream::Configure(
	BYTE __RPC_FAR *pFormat,
	UINT cbFormat,
	BYTE __RPC_FAR *pChannelParams,
	UINT cbParams,
	IUnknown *pUnknown)
{
	MMRESULT mmr;
	DWORD dwSrcSize;
	HRESULT hr;
	BOOL fRet;
	MEDIAPACKETINIT pcktInit;
	MEDIACTRLCONFIG mcConfig;
	MediaPacket **ppPckt;
	ULONG cPckt;
	DWORD_PTR dwPropVal;
	UINT ringSize = MAX_RXVRING_SIZE;
	DWORD dwFlags, dwSizeDst, dwMaxFrag, dwMaxBitRate = 0;

	VIDEOFORMATEX *pfRecv = (VIDEOFORMATEX*)pFormat;
	VIDEO_CHANNEL_PARAMETERS vidChannelParams;
	int optval=8192*4; // Use max SQCIF, QCIF I frame size
#ifdef TEST
	DWORD dwTicks;
#endif

	FX_ENTRY ("RecvVideoStream::Configure")

#ifdef TEST
	dwTicks = GetTickCount();
#endif

//	m_Net = pNet;

	// get format details
	if ((NULL == pFormat) || (NULL == pChannelParams)
			|| (cbParams != sizeof(vidChannelParams)))
	{
		return DPR_INVALID_PARAMETER;
	}

	vidChannelParams = *(VIDEO_CHANNEL_PARAMETERS *)pChannelParams;
		
	if (! (m_DPFlags & DPFLAG_INITIALIZED))
		return DPR_OUT_OF_MEMORY;		//BUGBUG: return proper error;
		
//	if (m_Net)
//	{
//		hr = m_Net->QueryInterface(IID_IRTPRecv, (void **)&m_pIRTPRecv);
//		if (!SUCCEEDED(hr))
//			return hr;
//	}
	

	mmr = VcmFilter::SuggestDecodeFormat(pfRecv, &m_fDevRecv);

	// initialize m_cliprect
	SetRect(&m_cliprect, 0, 0, m_fDevRecv.bih.biWidth, m_fDevRecv.bih.biHeight);

	// Initialize the recv-stream media control object
	mcConfig.uDuration = MC_USING_DEFAULT;	// set duration by samples per pkt
	mcConfig.pDevFmt = &m_fDevRecv;
	UPDATE_REPORT_ENTRY(g_prptCallParameters, pfRecv->dwFormatTag, REP_RECV_VIDEO_FORMAT);
	RETAILMSG(("NAC: Video Recv Format: %.4s", (LPSTR)&pfRecv->dwFormatTag));

	mcConfig.hStrm = (DPHANDLE) m_RecvStream;
	mcConfig.uDevId = m_RenderingDevice;
	mcConfig.cbSamplesPerPkt = ChoosePacketSize(pfRecv);
	hr = m_OutMedia->Configure(&mcConfig);
	
	m_OutMedia->GetProp (MC_PROP_SIZE, &dwPropVal);
    dwSizeDst = (DWORD)dwPropVal;

	// BUGBUG - HARDCODED platform flags.  The right way to do this is to
	// have a smart filter object create() that creates a platform-aware
	// instance of the object

	dwFlags = DP_FLAG_RECV | DP_FLAG_VCM | DP_FLAG_VIDEO;

	mmr = m_pVideoFilter->Open(pfRecv, &m_fDevRecv, 0); // maxfragsize == 0

	if (hr != DPR_SUCCESS)
	{
		DEBUGMSG (ZONE_DP, ("%s: RecvVideoFilter->Init failed, hr=0x%lX\r\n", _fx_, hr));
		hr = DPR_CANT_OPEN_CODEC;
		goto RecvFilterInitError;
	}
	
	// set the max. fragment size
	DEBUGMSG(ZONE_DP,("%s: Video Recv: maxBitRate=%d, maxBPP=%d, MPI=%d\r\n", _fx_ ,vidChannelParams.ns_params.maxBitRate*100, vidChannelParams.ns_params.maxBPP*1024, vidChannelParams.ns_params.MPI ? 30 / vidChannelParams.ns_params.MPI : 30));
	UPDATE_REPORT_ENTRY(g_prptCallParameters, vidChannelParams.ns_params.MPI ? 30 / vidChannelParams.ns_params.MPI : 30, REP_RECV_VIDEO_MAXFPS);
	UPDATE_REPORT_ENTRY(g_prptCallParameters, vidChannelParams.ns_params.maxBitRate*100, REP_RECV_VIDEO_BITRATE);
	RETAILMSG(("NAC: Video Recv Max Frame Rate (negotiated - fps): %ld", vidChannelParams.ns_params.MPI ? 30 / vidChannelParams.ns_params.MPI : 30));
	RETAILMSG(("NAC: Video Recv Max Bitrate (negotiated - bps): %ld", vidChannelParams.ns_params.maxBitRate*100));
	INIT_COUNTER_MAX(g_pctrVideoReceive, vidChannelParams.ns_params.MPI ? 30 / vidChannelParams.ns_params.MPI : 30);
	INIT_COUNTER_MAX(g_pctrVideoReceiveBytes, vidChannelParams.ns_params.maxBitRate*100);

	// Initialize the recv stream
	ZeroMemory (&pcktInit, sizeof (pcktInit));

	pcktInit.pStrmConvSrcFmt = pfRecv;
	pcktInit.pStrmConvDstFmt = &m_fDevRecv;
	pcktInit.dwFlags = dwFlags;
	pcktInit.cbOffsetRawData = 0;
	pcktInit.cbSizeRawData = dwSizeDst;

	m_OutMedia->FillMediaPacketInit (&pcktInit);

	m_pVideoFilter->SuggestSrcSize(dwSizeDst, &m_dwSrcSize);

	pcktInit.cbSizeNetData = m_dwSrcSize;

	pcktInit.cbOffsetNetData = sizeof (RTP_HDR);

	m_OutMedia->GetProp (MC_PROP_SPP, &dwPropVal);
	
	ringSize = 8;		// reserve space for 8 video frames
						// may need to increase the number if a/v sync is enabled.
	fRet = ((RVStream*)m_RecvStream)->Initialize (DP_FLAG_VIDEO, ringSize, NULL, &pcktInit, (DWORD)dwPropVal, pfRecv->nSamplesPerSec, m_pVideoFilter);
	if (! fRet)
	{
		DEBUGMSG (ZONE_DP, ("%s: RxvStream->Init failed, fRet=0%u\r\n", _fx_, fRet));
		hr = DPR_CANT_INIT_RXV_STREAM;
		goto RxStreamInitError;
	}

	// WS2Qos will be called in Start to communicate stream reservations to the
	// remote endpoint using a RESV message
	//
	// We use a peak-rate allocation approach based on our target bitrates
	// Note that for the token bucket size and the maximum SDU size, we now
	// account for IP header overhead, and use the max frame fragment size
	// instead of the maximum compressed image size returned by the codec
	//
	// Some of the parameters are left unspecified because they are set
	// in the sender Tspec.


	// Computer of actual bandwidth 70 % (but it's already been divided by 100)
	dwMaxBitRate = vidChannelParams.ns_params.maxBitRate*70;
	if (dwMaxBitRate > BW_ISDN_BITS)
	{
		dwMaxFrag = 1350;
	}
	else
	{
		dwMaxFrag = 512;
	}

	InitVideoFlowspec(&m_flowspec, dwMaxBitRate, dwMaxFrag, VID_AVG_PACKET_SIZE);


	/*
	// assume no more than 32 fragments for CIF and
	// 20 fragments for SQCIF, QCIF
	//BLOAT WARNING: this could be quite a bit of memory
	// need to fix this to use a heap instead of fixed size buffers.
	
	*/

	// prepare headers for RxvStream
	m_RecvStream->GetRing (&ppPckt, &cPckt);
	m_OutMedia->RegisterData (ppPckt, cPckt);
	m_OutMedia->PrepareHeaders ();

	// Keep a weak reference to the IUnknown interface
	// We will use it to query a Stream Signal interface pointer in Start()
	m_pIUnknown = pUnknown;

	m_DPFlags |= DPFLAG_CONFIGURED_RECV;

#ifdef TEST
	LOG((LOGMSG_TIME_RECV_VIDEO_CONFIGURE,GetTickCount() - dwTicks));
#endif

	return DPR_SUCCESS;

RxStreamInitError:
	m_pVideoFilter->Close();
RecvFilterInitError:
	m_OutMedia->Close();
	if (m_pIRTPRecv)
	{
		m_pIRTPRecv->Release();
		m_pIRTPRecv = NULL;
	}
	DEBUGMSG (1, ("%s:  failed, hr=0%u\r\n", _fx_, hr));
	return hr;
}



void RecvVideoStream::UnConfigure()
{
	

#ifdef TEST
	DWORD dwTicks;

	dwTicks = GetTickCount();
#endif

	if ( (m_DPFlags & DPFLAG_CONFIGURED_RECV)) {
	
		Stop();

		// Close the RTP state if its open
		//m_Net->Close(); We should be able to do this in Disconnect()
		m_Net = NULL;
		if (m_pIRTPRecv)
		{
			m_pIRTPRecv->Release();
			m_pIRTPRecv = NULL;
		}
		m_OutMedia->Reset();
		m_OutMedia->UnprepareHeaders();
		m_OutMedia->Close();

		// Close the filter
		m_pVideoFilter->Close();

		// Close the receive stream
		m_RecvStream->Destroy();

        m_DPFlags &= ~(DPFLAG_CONFIGURED_RECV);
	}

#ifdef TEST
	LOG((LOGMSG_TIME_RECV_VIDEO_UNCONFIGURE,GetTickCount() - dwTicks));
#endif

}



// NOTE: Identical to RecvAudioStream. Move up?
HRESULT
RecvVideoStream::Start()
{
	int nRet=IFRAMES_CAPS_UNKNOWN;
	FX_ENTRY ("RecvVideoStream::Start");

	if (m_DPFlags & DPFLAG_STARTED_RECV)
		return DPR_SUCCESS;

	if ((!(m_DPFlags & DPFLAG_CONFIGURED_RECV)) || (m_pIRTPRecv==NULL))
		return DPR_NOT_CONFIGURED;
		
	ASSERT(!m_hRenderingThread);

	m_ThreadFlags &= ~(DPTFLAG_STOP_PLAY|DPTFLAG_STOP_RECV);

	m_RecvStream->SetRTP(m_pIRTPRecv);

	SetFlowSpec();

// --------------------------------------------------------------------------
//	Decide whether or not we will be making I-Frame requests for lost packets
//  This should be done for all scenarios except when we are calling
//	NetMeeting 2.x.  NM 2.x will send us periodic I-Frames.

	m_fDiscontinuity = FALSE;
	m_dwLastIFrameRequest = 0UL;
	m_ulLastSeq = UINT_MAX;


	if (m_pIUnknown)
	{
		HRESULT hr;

		if (!m_pIStreamSignal)
		{
			hr = m_pIUnknown->QueryInterface(IID_IStreamSignal, (void **)&m_pIStreamSignal);
			if (!HR_SUCCEEDED(hr))
			{
				m_pIStreamSignal = (IStreamSignal *)NULL;
				m_pIUnknown = (IUnknown *)NULL;
			}
		}

		if (m_pIStreamSignal)
		{
			nRet = GetIFrameCaps(m_pIStreamSignal);

			if (nRet == IFRAMES_CAPS_NM2)
			{
				m_pIStreamSignal->Release();
				m_pIStreamSignal = NULL;
				m_pIUnknown = NULL;
			}
		}
	}
// --------------------------------------------------------------------------

	// Start playback thread
	if (!(m_ThreadFlags & DPTFLAG_STOP_PLAY))
		m_hRenderingThread = CreateThread(NULL,0,RecvVideoStream::StartRenderingThread,this,0,&m_RenderingThId);
	// Start receive thread
	#if 0
	if (!m_pDP->m_hRecvThread) {
	    m_pDP->m_hRecvThread = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)&StartDPRecvThread,m_pDP,0,&m_pDP->m_RecvThId);
	    //Tell the recv Thread we've turned on
	    if (m_pDP->m_hRecvThreadChangeEvent)
	        SetEvent (m_pDP->m_hRecvThreadChangeEvent);
	}
    m_pDP->m_nReceivers++;
	#else
	m_pDP->StartReceiving(this);
	#endif
	m_DPFlags |= DPFLAG_STARTED_RECV;
	DEBUGMSG (ZONE_DP, ("%s: Rendering ThId =%x\r\n",_fx_, m_RenderingThId));
	return DPR_SUCCESS;
}


// LOOK: Identical to RecvAudioStream version.
HRESULT
RecvVideoStream::Stop()
{
	
	DWORD dwWait;
	
	FX_ENTRY ("RecvVideoStream::Stop");

	if(!(m_DPFlags &  DPFLAG_STARTED_RECV))
	{
		return DPR_SUCCESS;
	}

	m_ThreadFlags = m_ThreadFlags  |
		DPTFLAG_STOP_RECV |  DPTFLAG_STOP_PLAY ;

	m_pDP->StopReceiving(this);
	
DEBUGMSG (ZONE_VERBOSE, ("%s: m_hRenderingThread =%x\r\n",_fx_, m_hRenderingThread));

	/*
	 *	we want to wait for all the threads to exit, but we need to handle windows
	 *	messages (mostly from winsock) while waiting.
	 *	we made several attempts at that. When we wait for messages in addition
	 *	to the thread exit events, we crash in rrcm.dll, possibly because we
	 *	process a winsock message to a thread that is terminating.
	 *
	 *	needs more investigation before putting in code that handles messages
	 */

	if(m_hRenderingThread)
	{
		dwWait = WaitForSingleObject (m_hRenderingThread, INFINITE);

		DEBUGMSG (ZONE_VERBOSE, ("%s: dwWait =%d\r\n", _fx_,  dwWait));
		ASSERT(dwWait != WAIT_FAILED);


		CloseHandle(m_hRenderingThread);
		m_hRenderingThread = NULL;
	}

	// Access to the stream signal interface needs to be serialized. We could crash
	// if we release the interface here and we are still using that interface in the
	// RTP callback.
	if (m_pIStreamSignal)
	{
		EnterCriticalSection(&m_crsIStreamSignal);
		m_pIStreamSignal->Release();
		m_pIStreamSignal = (IStreamSignal *)NULL;
		LeaveCriticalSection(&m_crsIStreamSignal);
	}

    //This is per channel, but the variable is "DPFlags"
	m_DPFlags &= ~DPFLAG_STARTED_RECV;

	return DPR_SUCCESS;
}


//  IProperty::GetProperty / SetProperty
//      Properties of the MediaChannel.

STDMETHODIMP
RecvVideoStream::GetProperty(
	DWORD prop,
	PVOID pBuf,
	LPUINT pcbBuf
    )
{
	HRESULT hr = DPR_SUCCESS;
	RTP_STATS RTPStats;
	DWORD dwValue;
    DWORD_PTR dwPropVal;
	UINT len = sizeof(DWORD);	// most props are DWORDs

	if (!pBuf || *pcbBuf < len)
    {
		*pcbBuf = len;
		return DPR_INVALID_PARAMETER;
	}

	switch (prop)
    {
 #ifdef OLDSTUFF
	case PROP_NET_RECV_STATS:
		if (m_Net && *pcbBuf >= sizeof(RTP_STATS))
        {
			m_Net->GetRecvStats((RTP_STATS *)pBuf);
			*pcbBuf = sizeof(RTP_STATS);
		} else
			hr = DPR_INVALID_PROP_VAL;
			
		break;

#endif
	case PROP_DURATION:
		hr = m_OutMedia->GetProp(MC_PROP_DURATION, &dwPropVal);
        *(DWORD *)pBuf = (DWORD)dwPropVal;
		break;

	case PROP_PLAY_ON:
		*(DWORD *)pBuf = ((m_ThreadFlags & DPFLAG_ENABLE_RECV)!=0);
		break;

	case PROP_PLAYBACK_DEVICE:
		*(DWORD *)pBuf = m_RenderingDevice;
		break;

	case PROP_VIDEO_BRIGHTNESS:
		hr = m_pVideoFilter->GetProperty(FM_PROP_VIDEO_BRIGHTNESS, (DWORD *)pBuf);
		break;

	case PROP_VIDEO_CONTRAST:
		hr = m_pVideoFilter->GetProperty(FM_PROP_VIDEO_CONTRAST, (DWORD *)pBuf);
		break;

	case PROP_VIDEO_SATURATION:
		hr = m_pVideoFilter->GetProperty(FM_PROP_VIDEO_SATURATION, (DWORD *)pBuf);
		break;

	case PROP_VIDEO_AUDIO_SYNC:
		*(DWORD *)pBuf = ((m_DPFlags & DPFLAG_AV_SYNC) != 0);
		break;

	case PROP_PAUSE_RECV:
		*(DWORD *)pBuf = ((m_ThreadFlags & DPTFLAG_PAUSE_RECV) != 0);
		break;
	default:
		hr = DPR_INVALID_PROP_ID;
		break;
	}

	return hr;
}


STDMETHODIMP
RecvVideoStream::SetProperty(
	DWORD prop,
	PVOID pBuf,
	UINT cbBuf
    )
{
	DWORD dw;
	HRESULT hr = S_OK;
	
	if (cbBuf < sizeof (DWORD))
		return DPR_INVALID_PARAMETER;

	switch (prop)
    {

#if 0
	case PROP_PLAY_ON:
	{
		DWORD flag = (DPFLAG_ENABLE_RECV);
		if (*(DWORD *)pBuf) {
			m_DPFlags |= flag; // set the flag
			Start();
		}
		else
		{
			m_DPFlags &= ~flag; // clear the flag
			Stop();
		}
		RETAILMSG(("NAC: %s", *(DWORD*)pBuf ? "Enabling":"Disabling"));
		//hr =  EnableStream( *(DWORD*)pBuf);
		break;
	}	
#endif
	case PROP_PLAYBACK_DEVICE:
		m_RenderingDevice = *(DWORD*)pBuf;
	//	RETAILMSG(("NAC: Setting default playback device to %d", m_RenderingDevice));
		break;


	case PROP_VIDEO_BRIGHTNESS:
		hr = m_pVideoFilter->SetProperty(FM_PROP_VIDEO_BRIGHTNESS, *(DWORD*)pBuf);
		break;

	case PROP_VIDEO_CONTRAST:
		hr = m_pVideoFilter->SetProperty(FM_PROP_VIDEO_CONTRAST, *(DWORD*)pBuf);
		break;

	case PROP_VIDEO_SATURATION:
		hr = m_pVideoFilter->SetProperty(FM_PROP_VIDEO_SATURATION, *(DWORD*)pBuf);
		break;

	case PROP_VIDEO_RESET_BRIGHTNESS:
		hr = m_pVideoFilter->SetProperty(FM_PROP_VIDEO_BRIGHTNESS, VCM_DEFAULT_BRIGHTNESS);
		break;

	case PROP_VIDEO_RESET_CONTRAST:
		hr = m_pVideoFilter->SetProperty(FM_PROP_VIDEO_CONTRAST, VCM_DEFAULT_CONTRAST);
		break;

	case PROP_VIDEO_RESET_SATURATION:
		hr = m_pVideoFilter->SetProperty(FM_PROP_VIDEO_SATURATION, VCM_DEFAULT_SATURATION);
		break;

    case PROP_VIDEO_SIZE:
		// For now, do not change anything if we already are connected
		ASSERT(0);
		//return SetVideoSize(m_pDP->m_pNac, *(DWORD*)pBuf);

    case PROP_VIDEO_AUDIO_SYNC:
		if (*(DWORD *)pBuf)
    		m_DPFlags |= DPFLAG_AV_SYNC;
		else
			m_DPFlags &= ~DPFLAG_AV_SYNC;
    	break;
	case PROP_PAUSE_RECV:
		if (*(DWORD *)pBuf)
			m_ThreadFlags |= DPTFLAG_PAUSE_RECV;
		else
			m_ThreadFlags &= ~DPTFLAG_PAUSE_RECV;
		break;

	default:
		return DPR_INVALID_PROP_ID;
		break;
	}
	return hr;
}
//---------------------------------------------------------------------
//  IVideoRender implementation and support functions



//  IVideoRender::Init
//  (DataPump::Init)
// identical to SendVideoStream::Init

STDMETHODIMP
RecvVideoStream::Init(
    DWORD_PTR dwUser,
    LPFNFRAMEREADY pfCallback
    )
{
    // Save the event away. Note that we DO allow both send and receive to
    // share an event
	m_hRenderEvent = (HANDLE)dwUser;
	// if pfCallback is NULL then dwUser is an event handle
	m_pfFrameReadyCallback = pfCallback;
		
	
	return DPR_SUCCESS;
}


//  IVideoRender::Done
// idnentical to SendVideoStream::Done
STDMETHODIMP
RecvVideoStream::Done( )
{
	m_hRenderEvent = NULL;
	m_pfFrameReadyCallback = NULL;
    return DPR_SUCCESS;
}





//  IVideoRender::GetFrame
//  (RecvVideoStream::GetFrame)
//  NOTE: subtly different from SendVideoStream implementation!

STDMETHODIMP
RecvVideoStream::GetFrame(
    FRAMECONTEXT* pfc
    )
{
	HRESULT hr;
	PVOID pData = NULL;
	UINT cbData = 0;

    // Validate parameters
    if (!pfc )
        return DPR_INVALID_PARAMETER;

    // Don't arbitrarily call out while holding this crs or you may deadlock...
    EnterCriticalSection(&m_crs);

	if ((m_DPFlags & DPFLAG_CONFIGURED_RECV) && m_pNextPacketToRender && !m_pNextPacketToRender->m_fRendering)
    {
		m_pNextPacketToRender->m_fRendering = TRUE;
		m_pNextPacketToRender->GetDevData(&pData,&cbData);
		pfc->lpData = (PUCHAR) pData;
		pfc->dwReserved = (DWORD_PTR) m_pNextPacketToRender;
		// set bmi length?
		pfc->lpbmi = (PBITMAPINFO)&m_fDevRecv.bih;
		pfc->lpClipRect = &m_cliprect;
		m_cRendering++;
		hr = S_OK;
		LOG((LOGMSG_GET_RECV_FRAME,m_pNextPacketToRender->GetIndex()));
	} else
		hr = S_FALSE; // nothing ready to render

    LeaveCriticalSection(&m_crs);

	return hr;	
}



//  IVideoRender::ReleaseFrame
//  NOTE: subtly different from SendVideoStream implementation!

STDMETHODIMP
RecvVideoStream::ReleaseFrame(
    FRAMECONTEXT* pfc
    )
{
	HRESULT hr;
	MediaPacket *pPacket;

    // Validate parameters
    if (!pfc)
        return DPR_INVALID_PARAMETER;

    // Handle a send frame
    {
        EnterCriticalSection(&m_crs);

        // Don't arbitrarily call out while holding this crs or you may deadlock...

		if ((m_DPFlags & DPFLAG_CONFIGURED_RECV) && (pPacket = (MediaPacket *)pfc->dwReserved) && pPacket->m_fRendering)
        {
			LOG((LOGMSG_RELEASE_SEND_FRAME,pPacket->GetIndex()));
			pPacket->m_fRendering = FALSE;
			pfc->dwReserved = 0;
			// if its not the current frame
			if (m_pNextPacketToRender != pPacket) {
				pPacket->Recycle();
				m_RecvStream->Release(pPacket);
			}
			m_cRendering--;
			hr = S_OK;
		}
        else
			hr = DPR_INVALID_PARAMETER;

        LeaveCriticalSection(&m_crs);
	}
		
	return hr;
}


HRESULT CALLBACK SendVideoStream::QosNotifyVideoCB(LPRESOURCEREQUESTLIST lpResourceRequestList, DWORD_PTR dwThis)
{
	HRESULT hr=NOERROR;
	LPRESOURCEREQUESTLIST prrl=lpResourceRequestList;
	int i;
	int iMaxBWUsage, iMaxCPUUsage;
	DWORD dwCPUUsage, dwBWUsage;
	int iCPUUsageId, iBWUsageId;
	int iCPUDelta, iBWDelta, deltascale;
	int iFrameRate, iMaxFrameRate, iOldFrameRate;
	UINT dwSize = sizeof(int);
	DWORD dwOverallCPUUsage;
#ifdef LOGSTATISTICS_ON
	char szDebug[256];
	HANDLE hDebugFile;
	DWORD d;
#endif
	DWORD dwEpoch;
	SendVideoStream *pThis = (SendVideoStream *)dwThis;

	FX_ENTRY("QosNotifyVideoCB");


	// Get the max for the resources.
	iMaxCPUUsage = -1L; iMaxBWUsage = -1L;
	for (i=0, iCPUUsageId = -1L, iBWUsageId = -1L; i<(int)lpResourceRequestList->cRequests; i++)
		if (lpResourceRequestList->aRequests[i].resourceID == RESOURCE_OUTGOING_BANDWIDTH)
			iBWUsageId = i;
		else if (lpResourceRequestList->aRequests[i].resourceID == RESOURCE_CPU_CYCLES)
			iCPUUsageId = i;

	// Enter critical section to allow QoS thread to read the statistics while capturing
	EnterCriticalSection(&(pThis->m_crsVidQoS));

	// Record the time of this callback call
	pThis->m_Stats.dwNewestTs = timeGetTime();

	// Only do anything if we have at least captured a frame in the previous epoch
	if ((pThis->m_Stats.dwCount) && (pThis->m_Stats.dwNewestTs > pThis->m_Stats.dwOldestTs))
	{

		// Measure the epoch
		dwEpoch = pThis->m_Stats.dwNewestTs - pThis->m_Stats.dwOldestTs;

#ifdef LOGSTATISTICS_ON
		wsprintf(szDebug, "    Epoch = %ld\r\n", dwEpoch);
		OutputDebugString(szDebug);
#endif
		// Compute the current average frame rate
		iOldFrameRate = pThis->m_Stats.dwCount * 100000 / dwEpoch;

		if (iCPUUsageId != -1L)
			iMaxCPUUsage = lpResourceRequestList->aRequests[iCPUUsageId].nUnitsMin;
		if (iBWUsageId != -1L)
			iMaxBWUsage = lpResourceRequestList->aRequests[iBWUsageId].nUnitsMin;

		// Get general BW usage
		dwBWUsage = pThis->m_Stats.dwBits * 1000UL / dwEpoch;

		// Get general CPU usage. In order to reduce oscillations, apply low-pass filtering operation
		// We will use our own CPU usage number ONLY if the call to GetCPUUsage() fails.
		if (pThis->GetCPUUsage(&dwOverallCPUUsage))
		{
			if (pThis->m_Stats.dwSmoothedCPUUsage)
					dwCPUUsage = (pThis->m_Stats.dwSmoothedCPUUsage + dwOverallCPUUsage) >> 1;
			else
				dwCPUUsage = dwOverallCPUUsage;
		}
		else
			dwCPUUsage = (pThis->m_Stats.dwMsCap + pThis->m_Stats.dwMsComp) * 1000UL / dwEpoch;

		// Record current CPU usage
		pThis->m_Stats.dwSmoothedCPUUsage = dwCPUUsage;

#ifdef LOGSTATISTICS_ON
		hDebugFile = CreateFile("C:\\QoS.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
		SetFilePointer(hDebugFile, 0, NULL, FILE_END);
		wsprintf(szDebug, "    Overall CPU usage = %ld\r\n", dwOverallCPUUsage);
		WriteFile(hDebugFile, szDebug, strlen(szDebug), &d, NULL);
		OutputDebugString(szDebug);
		CloseHandle(hDebugFile);

		wsprintf(szDebug, "    Number of frames dwCount = %ld\r\n", pThis->m_Stats.dwCount);
		OutputDebugString(szDebug);
#endif

		// For this first implementation, the only output variable is the frame rate of the
		// video capture
#ifdef USE_NON_LINEAR_FPS_ADJUSTMENT
		if (iCPUUsageId != -1L)
		{
			if (dwCPUUsage)
			{
				iCPUDelta = (iMaxCPUUsage - (int)dwCPUUsage) * 10 / (int)dwCPUUsage;
				if (iCPUDelta >= 10)
					iCPUDelta = 9;
				else if (iCPUDelta <= -1)
					iCPUDelta = -9;
			}
			else
				iCPUDelta = 9;
		}
		else
			iCPUDelta = 0;

		if (iBWUsageId != -1L)
		{
			if (dwBWUsage)
			{
				iBWDelta = (iMaxBWUsage - (int)dwBWUsage) * 10 / (int)dwBWUsage;
				if (iBWDelta >= 10)
					iBWDelta = 9;
				else if (iBWDelta <= -1)
					iBWDelta = -9;
			}
			else
				iBWDelta = 9;
		}
		else
			iBWDelta = 0;
#else
		if (iCPUUsageId != -1L)
		{
			if (dwCPUUsage)
				iCPUDelta = (iMaxCPUUsage - (int)dwCPUUsage) * 100 / (int)dwCPUUsage;
			else
				iCPUDelta = 90;
		}
		else
			iCPUDelta = 0;

		if (iBWUsageId != -1L)
		{
			if (dwBWUsage)
				iBWDelta = (iMaxBWUsage - (int)dwBWUsage) * 100 / (int)dwBWUsage;
			else
				iBWDelta = 90;
		}
		else
			iBWDelta = 0;
#endif

		UPDATE_COUNTER(g_pctrVideoCPUuse, iCPUDelta);
		UPDATE_COUNTER(g_pctrVideoBWuse, iBWDelta);

#ifdef USE_NON_LINEAR_FPS_ADJUSTMENT
		iFrameRate = iOldFrameRate + iOldFrameRate * g_QoSMagic[iCPUDelta + 9][iBWDelta + 9] / 100;
#else
		deltascale = iCPUDelta;
		if (deltascale > iBWDelta) deltascale = iBWDelta;
		if (deltascale > 90) deltascale = 90;
		if (deltascale < -90) deltascale = -90;
		iFrameRate = iOldFrameRate + (iOldFrameRate * deltascale) / 100;
#endif
		
		// Initialize QoS structure. Only the four first fields should be zeroed.
		// The handle to the CPU performance key should not be cleared.
		ZeroMemory(&(pThis->m_Stats), 4UL * sizeof(DWORD));

		// The video should reduce its CPU and bandwidth usage quickly, but probably shouldn't
		// be allowed to increase its CPU and bandwidth usage as fast. Let's increase the
		// frame rate at half the speed it would be decreased when we are above 5fps.
		if ((iFrameRate > iOldFrameRate) && (iFrameRate > 500))
			iFrameRate -= (iFrameRate - iOldFrameRate) >> 1;

		// We should keep our requirements between a minimum that will allow us to catch up
		// quickly and the current max frame rate
		iMaxFrameRate = pThis->m_maxfps;  // max negotiated for call

		// if using a modem, then the frame rate is determined by the
		// temporal spatial tradeoff

		if (pThis->m_pTSTable)
		{
			iMaxFrameRate = min(iMaxFrameRate, pThis->m_pTSTable[pThis->m_dwCurrentTSSetting]);
		}


		if (iFrameRate > iMaxFrameRate)
			iFrameRate = iMaxFrameRate;
		if (iFrameRate < 50)               // make sure framerate is > 0 (this does not mean 50 fps; it is .50 fps)
			iFrameRate = 50;
		
		// Update the frame rate
		if (iFrameRate != iOldFrameRate)
			pThis->SetProperty(PROP_VIDEO_FRAME_RATE, &iFrameRate, sizeof(int));



		// Record the time of this call for the next callback call
		pThis->m_Stats.dwOldestTs = pThis->m_Stats.dwNewestTs;

		// Get the latest RTCP stats and update the counters.
		// we do this here because it is called periodically.
		if (pThis->m_pRTPSend)
		{
			UINT lastPacketsLost = pThis->m_RTPStats.packetsLost;
			if (g_pctrVideoSendLost &&  SUCCEEDED(pThis->m_pRTPSend->GetSendStats(&pThis->m_RTPStats)))
				UPDATE_COUNTER(g_pctrVideoSendLost, pThis->m_RTPStats.packetsLost-lastPacketsLost);
		}

		// Leave critical section
		LeaveCriticalSection(&(pThis->m_crsVidQoS));

		DEBUGMSG(ZONE_QOS, ("%s: Over the last %ld.%lds, video used %ld%% of the CPU (max allowed %ld%%) and %ld bps (max allowed %ld bps)\r\n", _fx_, dwEpoch / 1000UL, dwEpoch - (dwEpoch / 1000UL) * 1000UL, dwCPUUsage / 10UL, iMaxCPUUsage / 10UL, dwBWUsage, iMaxBWUsage));
		DEBUGMSG(ZONE_QOS, ("%s: Ajusting target frame rate from %ld.%ld fps to %ld.%ld fps\r\n", _fx_, iOldFrameRate / 100UL, iOldFrameRate - (iOldFrameRate / 100UL) * 100UL, iFrameRate / 100UL, iFrameRate - (iFrameRate / 100UL) * 100UL));

		// Set the target bitrates and frame rates on the codec
		pThis->SetTargetRates(iFrameRate, iMaxBWUsage);

#ifdef LOGSTATISTICS_ON
		// How are we doing?
		if (iCPUUsageId != -1L)
		{
			if (iCPUDelta > 0)
				wsprintf(szDebug, "Max CPU Usage: %ld, Current CPU Usage: %ld, Increase CPU Usage by: %li, Old Frame Rate: %ld, New Frame Rate: %ld\r\n", lpResourceRequestList->aRequests[iCPUUsageId].nUnitsMin, dwCPUUsage, iCPUDelta, iOldFrameRate, iFrameRate);
			else
				wsprintf(szDebug, "Max CPU Usage: %ld, Current CPU Usage: %ld, Decrese CPU Usage by: %li, Old Frame Rate: %ld, New Frame Rate: %ld\r\n", lpResourceRequestList->aRequests[iCPUUsageId].nUnitsMin, dwCPUUsage, iCPUDelta, iOldFrameRate, iFrameRate);
			hDebugFile = CreateFile("C:\\QoS.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
			SetFilePointer(hDebugFile, 0, NULL, FILE_END);
			WriteFile(hDebugFile, szDebug, strlen(szDebug), &d, NULL);
			CloseHandle(hDebugFile);
			OutputDebugString(szDebug);
		}

		if (iBWUsageId != -1L)
		{
			if (iBWDelta > 0)
				wsprintf(szDebug, "Max BW Usage: %ld, Current BW Usage: %ld, Increase BW Usage by: %li\r\n", lpResourceRequestList->aRequests[iBWUsageId].nUnitsMin, dwBWUsage, iBWDelta);
			else
				wsprintf(szDebug, "Max BW Usage: %ld, Current BW Usage: %ld, Decrease BW Usage by: %li\r\n", lpResourceRequestList->aRequests[iBWUsageId].nUnitsMin, dwBWUsage, iBWDelta);
			hDebugFile = CreateFile("C:\\QoS.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
			SetFilePointer(hDebugFile, 0, NULL, FILE_END);
			WriteFile(hDebugFile, szDebug, strlen(szDebug), &d, NULL);
			CloseHandle(hDebugFile);
			OutputDebugString(szDebug);
		}
#endif
	}
	else
	{
		// Leave critical section
		LeaveCriticalSection(&(pThis->m_crsVidQoS));

#ifdef LOGSTATISTICS_ON
		hDebugFile = CreateFile("C:\\QoS.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);
		SetFilePointer(hDebugFile, 0, NULL, FILE_END);
		wsprintf(szDebug, "Not enough data captured -> Leave without any change\r\n");
		WriteFile(hDebugFile, szDebug, strlen(szDebug), &d, NULL);
		CloseHandle(hDebugFile);
		OutputDebugString(szDebug);
#endif
	}

	return hr;
}



//  SortOrder
//      Helper function to search for the specific format type and set its sort
//      order to the desired number
BOOL
SortOrder(
	IAppVidCap *pavc,
    BASIC_VIDCAP_INFO* pvidcaps,
    DWORD dwcFormats,
    DWORD dwFlags,
    WORD wDesiredSortOrder,
	int nNumFormats
    )
{
    int i, j;
	int nNumSizes = 0;
	int *aFrameSizes = (int *)NULL;
	int *aMinFrameSizes = (int *)NULL;
	int iMaxPos;
	WORD wTempPos, wMaxSortIndex;

	// Scale sort value
	wDesiredSortOrder *= (WORD)nNumFormats;

	// Local buffer of sizes that match dwFlags
    if (!(aFrameSizes = (int *)MEMALLOC(nNumFormats * sizeof (int))))
        goto out;

    // Look through all the formats until we find the ones we want
	// Save the position of these entries
    for (i=0; i<(int)dwcFormats; i++)
        if (SIZE_TO_FLAG(pvidcaps[i].enumVideoSize) == dwFlags)
			aFrameSizes[nNumSizes++] = i;

	// Now order those entries from highest to lowest sort index
	for (i=0; i<nNumSizes; i++)
	{
		for (iMaxPos = -1L, wMaxSortIndex=0UL, j=i; j<nNumSizes; j++)
		{
			if (pvidcaps[aFrameSizes[j]].wSortIndex > wMaxSortIndex)
			{
				wMaxSortIndex = pvidcaps[aFrameSizes[j]].wSortIndex;
				iMaxPos = j;
			}
		}
		if (iMaxPos != -1L)
		{
			wTempPos = (WORD)aFrameSizes[i];
			aFrameSizes[i] = aFrameSizes[iMaxPos];
			aFrameSizes[iMaxPos] = wTempPos;
		}
	}

	// Change the sort index of the sorted entries
	for (; nNumSizes--;)
		pvidcaps[aFrameSizes[nNumSizes]].wSortIndex = wDesiredSortOrder++;

	// Release memory
	MEMFREE(aFrameSizes);

	return TRUE;

out:
	return FALSE;
}

// LOOK: this is identical to the RecvAudioStream implementation
HRESULT
RecvVideoStream::GetCurrentPlayNTPTime(NTP_TS *pNtpTime)
{
	DWORD rtpTime;
#ifdef OLDSTUFF
	if ((m_DPFlags & DPFLAG_STARTED_RECV) && m_fReceiving) {
		if (m_Net->RTPtoNTP(m_PlaybackTimestamp,pNtpTime))
			return S_OK;
	}
#endif
	return 0xff;	// return proper error
		
}

BOOL RecvVideoStream::IsEmpty() {
	return m_RecvStream->IsEmpty();
}

/*
	Called by the recv thread to setup the stream for receiving.
	Call RTP object to post the initial recv buffer(s).
*/
// NOTE: identical to audio version except for choice of number of packet buffers
HRESULT
RecvVideoStream::StartRecv(HWND hWnd)
{
	HRESULT hr = S_OK;
	DWORD dwPropVal = 0;
	UINT numPackets;
	if ((!(m_ThreadFlags & DPTFLAG_STOP_RECV) ) && (m_DPFlags  & DPFLAG_CONFIGURED_RECV))
	{
		numPackets = m_dwSrcSize > 10000 ? MAX_VIDEO_FRAGMENTS : MAX_QCIF_VIDEO_FRAGMENTS;	

		hr = m_pIRTPRecv->SetRecvNotification(&RTPRecvCallback, (DWORD_PTR)this, numPackets);
			
		
	}
	return hr;
}


// NOTE: identical to audio version
HRESULT
RecvVideoStream::StopRecv()
{
	// Free any RTP buffers that we're holding on to
	m_RecvStream->ReleaseNetBuffers();
	// dont recv on this stream
	m_pIRTPRecv->CancelRecvNotification();

	return S_OK;		
}


HRESULT RecvVideoStream::RTPCallback(WSABUF *pWsaBuf, DWORD timestamp, UINT seq, UINT fMark)
{
	HRESULT hr;
	DWORD_PTR dwPropVal;
	BOOL fSkippedAFrame;
	BOOL fReceivedKeyframe;

	FX_ENTRY("RecvVideoStream::RTPCallback");

	// if we are paused, reject the packet
	if (m_ThreadFlags & DPTFLAG_PAUSE_RECV)
	{
		return E_FAIL;
	}

	// PutNextNetIn will return DPR_SUCESS to indicate a new frame
	// S_FALSE if success, but no new frame
	// error otherwise
	// It always takes care of freeing the RTP buffers
	hr = m_RecvStream->PutNextNetIn(pWsaBuf, timestamp, seq, fMark, &fSkippedAFrame, &fReceivedKeyframe);

	if (m_pIUnknown)
	{
		// Check out the sequence number
		// If there is a gap between the new sequence number and the last
		// one, a frame got lost. Generate an I-Frame request then, but no more
		// often than one every 15 seconds. How should we go about NM2.0? Other
		// clients that don't support I-Frame requests.
		//
		// Is there a discontinuity in sequence numbers that was detected
		// in the past but not handled because an I-Frame request had alreay
		// been sent less than 15s ago? Is there a new discontinuity?
		if (FAILED(hr) || fSkippedAFrame || m_fDiscontinuity || ((seq > 0) && (m_ulLastSeq != UINT_MAX) && ((seq - 1) > m_ulLastSeq)))
		{
			DWORD dwNow = GetTickCount();

			// Was the last time we issued an I-Frame request more than 15s ago?
			if ((dwNow > m_dwLastIFrameRequest) && ((dwNow - m_dwLastIFrameRequest) > MIN_IFRAME_REQUEST_INTERVAL))
			{
				DEBUGMSG (ZONE_IFRAME, ("%s: Loss detected - Sending I-Frame request...\r\n", _fx_));

				m_dwLastIFrameRequest = dwNow;
				m_fDiscontinuity = FALSE;

				// Access to the stream signal interface needs to be serialized. We could crash
				// if we used the interface here while Stop() is releasing it.
				EnterCriticalSection(&m_crsIStreamSignal);
				if (m_pIStreamSignal)
					m_pIStreamSignal->PictureUpdateRequest();
				LeaveCriticalSection(&m_crsIStreamSignal);
			}
			else
			{
				if (!fReceivedKeyframe)
				{
					DEBUGMSG (ZONE_IFRAME, ("%s: Loss detected but too soon to send I-Frame request. Wait %ld ms.\r\n", _fx_, MIN_IFRAME_REQUEST_INTERVAL - (dwNow - m_dwLastIFrameRequest)));
					m_fDiscontinuity = TRUE;
				}
				else
				{
					DEBUGMSG (ZONE_IFRAME, ("%s: Received a keyframe - resetting packet loss detector\r\n", _fx_));
					m_fDiscontinuity = FALSE;
				}
			}
		}

		m_ulLastSeq = seq;
	}

	if (hr == DPR_SUCCESS)
	{
		m_OutMedia->GetProp (MC_PROP_EVENT_HANDLE, &dwPropVal);
		if (dwPropVal)
		{
			SetEvent( (HANDLE) dwPropVal);
		}
	}
	else if (FAILED(hr))
	{
		DEBUGMSG(ZONE_DP,("RVStream::PutNextNetIn (ts=%d,seq=%d,fMark=%d) failed with 0x%lX\r\n",timestamp,seq,fMark,hr));
	}

	return S_OK;
}

#define TOTAL_BYTES		8192
#define BYTE_INCREMENT	1024

/****************************************************************************
 * @doc EXTERNAL QOSFUNC
 *
 * @func void | StartCPUUsageCollection | This function does all necessary
 * initialization for CPU usage data collection.
 *
 * @rdesc Although this function doesn't ever fail, m_Stats.hPerfKey is set to a
 *   valid HKEY value if initialization occured correctly, and NULL otherwise.
 *
 * @comm This functions executes two different code paths: one for NT and one
 *   for Win95-98.
 *
 * @devnote MSDN references:
 *   Microsoft Knowledge Base, Article ID Q174631
 *   "HOWTO: Access the Performance Registry Under Windows 95"
 *
 *   Microsoft Knowledge Base, Article ID Q107728
 *   "Retrieving Counter Data from the Registry"
 *
 *   Microsoft Knowledge Base, Article ID Q178887
 *   "INFO: Troubleshooting Performance Registry Access Violations"
 *
 *   Also, used section "Platform SDK\Windows Base Services\Windows NT Features\Performance Data Helper"
 ***************************************************************************/
void SendVideoStream::StartCPUUsageCollection(void)
{
	PPERF_DATA_BLOCK pPerfDataBlock;
	PPERF_OBJECT_TYPE pPerfObjectType;
	PPERF_COUNTER_DEFINITION pPerfCounterDefinition;
	PPERF_INSTANCE_DEFINITION pPerfInstanceDefinition;
	PPERF_COUNTER_BLOCK pPerfCounterBlock;
	OSVERSIONINFO osvInfo = {0};
	DWORD cbCounterData;
	DWORD cbTryCounterData;
	DWORD dwType;
	HANDLE hPerfData;
	char *pszData;
	char *pszIndex;
	char szProcessorIndex[16];
	long lRet;

	FX_ENTRY("SendVideoStream::StartCPUUsageCollection");

	// Are we on NT or Win95/98 ?
	osvInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&osvInfo);

	if (m_Stats.fWinNT = (BOOL)(osvInfo.dwPlatformId == VER_PLATFORM_WIN32_NT))
	{
		// Enable the collection of CPU performance data on Win NT

		// Open the registry key that contains the performance counter indices and names.
		// 009 is the U.S. English language id. In a non-English version of Windows NT,
		// performance counters are stored both in the native language of the system and
		// in English.
		if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib\\009", NULL, KEY_READ, &m_Stats.hPerfKey) != ERROR_SUCCESS)
			goto MyError0;
		else
		{
			// Get all the counter indices and names.

			// Read the performance data from the registry. The size of that data may change
			// between each call to the registry. We first get the current size of the buffer,
			// allocate it, and try to read from the registry into it. If there already isn't
			// enough room in the buffer, we realloc() it until we manage to read all the data.
			if (RegQueryValueEx(m_Stats.hPerfKey, "Counters", NULL, &dwType, NULL, &cbCounterData) != ERROR_SUCCESS)
				cbCounterData = TOTAL_BYTES;

			// Allocate buffer for counter indices and names
			if (!(m_Stats.NtCPUUsage.hPerfData = (PBYTE)LocalAlloc (LMEM_MOVEABLE, cbCounterData)))
			{
				m_Stats.NtCPUUsage.pbyPerfData = (PBYTE)NULL;
				RegCloseKey(m_Stats.hPerfKey);
				goto MyError0;
			}
			else
			{
				m_Stats.NtCPUUsage.pbyPerfData = (PBYTE)LocalLock(m_Stats.NtCPUUsage.hPerfData);

				cbTryCounterData = cbCounterData;
				while((lRet = RegQueryValueEx(m_Stats.hPerfKey, "Counters", NULL, NULL, m_Stats.NtCPUUsage.pbyPerfData, &cbTryCounterData)) == ERROR_MORE_DATA)
				{
					cbCounterData += BYTE_INCREMENT;
					LocalUnlock(m_Stats.NtCPUUsage.hPerfData);
					hPerfData = LocalReAlloc(m_Stats.NtCPUUsage.hPerfData, cbCounterData, LMEM_MOVEABLE);
					if (!hPerfData)
						goto MyError1;
					m_Stats.NtCPUUsage.hPerfData = hPerfData;
					m_Stats.NtCPUUsage.pbyPerfData = (PBYTE)LocalLock(hPerfData);
					cbTryCounterData = cbCounterData;
				}

				// We don't need that key anymore
				RegCloseKey(m_Stats.hPerfKey);

				if (lRet != ERROR_SUCCESS)
					goto MyError1;
				else
				{
					// The data is stored as MULTI_SZ strings. This data type consists
					// of a list of strings, each terminated with NULL. The last string
					// is followed by an additional NULL. The strings are listed in
					// pairs. The first string of each pair is the string of the index,
					// and the second string is the actual name of the index. The Counter
					// data uses only even-numbered indexes. For example, the Counter
					// data contains the following object and counter name strings.
					// Examples:
					// 2    System
					// 4    Memory
					// 6    % Processor Time
					//
					// Look for the "% Processor Time" counter
					pszData = (char *)m_Stats.NtCPUUsage.pbyPerfData;
					pszIndex = (char *)m_Stats.NtCPUUsage.pbyPerfData;

					while (*pszData && lstrcmpi(pszData, "% Processor Time"))
					{
						pszIndex = pszData;
						pszData += lstrlen(pszData) + 1;
					}

					if (!pszData)
					{
						// Couldn't find "% Processor Time" counter!!!
						goto MyError1;
					}
					else
					{
						m_Stats.NtCPUUsage.dwPercentProcessorIndex = atol(pszIndex);

						// Look for the "Processor" object
						pszIndex = pszData = (char *)m_Stats.NtCPUUsage.pbyPerfData;

						while (*pszData && lstrcmpi(pszData, "Processor"))
						{
							pszIndex = pszData;
							pszData += lstrlen(pszData) + 1;
						}

						if (!pszData)
						{
							// Couldn't find "Processor" counter!!!
							goto MyError1;
						}
						else
						{
							m_Stats.NtCPUUsage.dwProcessorIndex = atol(pszIndex);
							CopyMemory(szProcessorIndex, pszIndex, lstrlen(pszIndex));

							// Read the PERF_DATA_BLOCK header structure. It describes the system
							// and the performance data. The PERF_DATA_BLOCK structure is followed
							// by a list of object information blocks (one per object). We use the
							// counter index to retrieve object information.

							// Under some cicumstances (cf. Q178887 for details) the RegQueryValueEx
							// function may cause an Access Violation because of a buggy performance
							// extension DLL such as SQL's.
							__try
							{
								m_Stats.NtCPUUsage.cbPerfData = cbCounterData;
								while((lRet = RegQueryValueEx(HKEY_PERFORMANCE_DATA, szProcessorIndex, NULL, NULL, m_Stats.NtCPUUsage.pbyPerfData, &cbCounterData)) == ERROR_MORE_DATA)
								{
									m_Stats.NtCPUUsage.cbPerfData += BYTE_INCREMENT;
									LocalUnlock(m_Stats.NtCPUUsage.hPerfData);
									hPerfData = LocalReAlloc(m_Stats.NtCPUUsage.hPerfData, m_Stats.NtCPUUsage.cbPerfData, LMEM_MOVEABLE);
									if (!hPerfData)
										goto MyError1;
									m_Stats.NtCPUUsage.hPerfData = hPerfData;
									m_Stats.NtCPUUsage.pbyPerfData = (PBYTE)LocalLock(hPerfData);
									cbCounterData = m_Stats.NtCPUUsage.cbPerfData;
								}
							}
							__except(EXCEPTION_EXECUTE_HANDLER)
							{
								ERRORMESSAGE(("%s: Performance Registry Access Violation -> don't use perf counters for CPU measurements\r\n", _fx_));
								goto MyError1;
							}

							if (lRet != ERROR_SUCCESS)
								goto MyError1;
							else
							{
								// Each object information block contains a PERF_OBJECT_TYPE structure,
								// which describes the performance data for the object. Look for the one
								// that applies to CPU usage based on its index value.
								pPerfDataBlock = (PPERF_DATA_BLOCK)m_Stats.NtCPUUsage.pbyPerfData;
								pPerfObjectType = (PPERF_OBJECT_TYPE)(m_Stats.NtCPUUsage.pbyPerfData + pPerfDataBlock->HeaderLength);
								for (int i = 0; i < (int)pPerfDataBlock->NumObjectTypes; i++)
								{
									if (pPerfObjectType->ObjectNameTitleIndex == m_Stats.NtCPUUsage.dwProcessorIndex)
									{
										// The PERF_OBJECT_TYPE structure is followed by a list of PERF_COUNTER_DEFINITION
										// structures, one for each counter defined for the object. The list of PERF_COUNTER_DEFINITION
										// structures is followed by a list of instance information blocks (one for each instance).
										//
										// Each instance information block contains a PERF_INSTANCE_DEFINITION structure and
										// a PERF_COUNTER_BLOCK structure, followed by the data for each counter.
										//
										// Look for the counter defined for % processor time.
										pPerfCounterDefinition = (PPERF_COUNTER_DEFINITION)((PBYTE)pPerfObjectType + pPerfObjectType->HeaderLength);
										for (int j = 0; j < (int)pPerfObjectType->NumCounters; j++)
										{
											if (pPerfCounterDefinition->CounterNameTitleIndex == m_Stats.NtCPUUsage.dwPercentProcessorIndex)
											{
												// Note: looking at the CounterType filed of the PERF_COUNTER_DEFINITION
												// structure shows that the '% Processor Time' counter has the following properties:
												//   The counter data is a large integer (PERF_SIZE_LARGE set)
												//   The counter data is an increasing numeric value (PERF_TYPE_COUNTER set)
												//   The counter value should be divided by the elapsed time (PERF_COUNTER_RATE set)
												//   The time base units of the 100-nanosecond timer should be used as the base (PERF_TIMER_100NS set)
												//   The difference between the previous counter value and the current counter value is computed before proceeding (PERF_DELTA_BASE set)
												//   The display suffix is '%' (PERF_DISPLAY_PERCENT set)

												// Save the number of object instances for the CPU counter, as well as the
												// starting time.
												m_Stats.NtCPUUsage.dwNumProcessors = pPerfObjectType->NumInstances;
												if (!(m_Stats.NtCPUUsage.pllCounterValue = (PLONGLONG)LocalAlloc(LMEM_FIXED, m_Stats.NtCPUUsage.dwNumProcessors * sizeof(LONGLONG))))
													goto MyError1;
												m_Stats.NtCPUUsage.llPerfTime100nSec = *(PLONGLONG)&pPerfDataBlock->PerfTime100nSec;

												pPerfInstanceDefinition = (PPERF_INSTANCE_DEFINITION)((PBYTE)pPerfObjectType + pPerfObjectType->DefinitionLength);
												for (int k = 0; k < pPerfObjectType->NumInstances; k++)
												{
													// Get a pointer to the PERF_COUNTER_BLOCK
													pPerfCounterBlock = (PPERF_COUNTER_BLOCK)((PBYTE)pPerfInstanceDefinition + pPerfInstanceDefinition->ByteLength);

													// This last offset steps us over any other counters to the one we need
													m_Stats.NtCPUUsage.pllCounterValue[k] = *(PLONGLONG)((PBYTE)pPerfInstanceDefinition + pPerfInstanceDefinition->ByteLength + pPerfCounterDefinition->CounterOffset);

													// Get to the next instance information block
													pPerfInstanceDefinition = (PPERF_INSTANCE_DEFINITION)((PBYTE)pPerfInstanceDefinition + pPerfInstanceDefinition->ByteLength + pPerfCounterBlock->ByteLength);
												}

												// We're done!
												return;
											}
											else
												pPerfCounterDefinition = (PPERF_COUNTER_DEFINITION)((PBYTE)pPerfCounterDefinition + pPerfCounterDefinition->ByteLength);
										}
										break;
									}
									else
										pPerfObjectType = (PPERF_OBJECT_TYPE)((PBYTE)pPerfObjectType + pPerfObjectType->TotalByteLength);
								}

								// If we get here, we haven't found the counters we were looking for
								goto MyError2;
							}
						}
					}
				}
			}
		}
	}
	else
	{
		// Enable the collection of CPU performance data on Win 95-98 by starting the kernel stat server
		if (RegOpenKeyEx(HKEY_DYN_DATA, "PerfStats\\StartSrv", NULL, KEY_READ, &m_Stats.hPerfKey) != ERROR_SUCCESS)
			m_Stats.hPerfKey = (HKEY)NULL;
		else
		{
			DWORD cbData = sizeof(DWORD);
			DWORD dwType;
			DWORD dwData;

			if (RegQueryValueEx(m_Stats.hPerfKey, "KERNEL", NULL, &dwType, (LPBYTE)&dwData, &cbData) != ERROR_SUCCESS)
			{
				RegCloseKey(m_Stats.hPerfKey);
				m_Stats.hPerfKey = (HKEY)NULL;
			}
			else
			{
				RegCloseKey(m_Stats.hPerfKey);

				// The kernel stat server is now started. Now start the CPUUsage data collection on the kernel stat server.
				if (RegOpenKeyEx(HKEY_DYN_DATA, "PerfStats\\StartStat", NULL, KEY_READ, &m_Stats.hPerfKey) != ERROR_SUCCESS)
					m_Stats.hPerfKey = (HKEY)NULL;
				else
				{
					if (RegQueryValueEx(m_Stats.hPerfKey, "KERNEL\\CPUUsage", NULL, &dwType, (LPBYTE)&dwData, &cbData) != ERROR_SUCCESS)
					{
						RegCloseKey(m_Stats.hPerfKey);
						m_Stats.hPerfKey = (HKEY)NULL;
					}
					else
					{
						RegCloseKey(m_Stats.hPerfKey);

						// The data and stat servers are now started. Let's get ready to collect actual data.
						if (RegOpenKeyEx(HKEY_DYN_DATA, "PerfStats\\StatData", NULL, KEY_READ, &m_Stats.hPerfKey) != ERROR_SUCCESS)
							m_Stats.hPerfKey = (HKEY)NULL;
					}
				}
			}
		}
	}

	return;

MyError2:
	if (m_Stats.NtCPUUsage.pllCounterValue)
		LocalFree(m_Stats.NtCPUUsage.pllCounterValue);
	m_Stats.NtCPUUsage.pllCounterValue = (PLONGLONG)NULL;
MyError1:
	if (m_Stats.NtCPUUsage.hPerfData)
	{
		LocalUnlock(m_Stats.NtCPUUsage.hPerfData);
		LocalFree(m_Stats.NtCPUUsage.hPerfData);
	}
	m_Stats.NtCPUUsage.hPerfData = (HANDLE)NULL;
	m_Stats.NtCPUUsage.pbyPerfData = (PBYTE)NULL;
MyError0:
	m_Stats.hPerfKey = (HKEY)NULL;
	
}

/****************************************************************************
 * @doc EXTERNAL QOSFUNC
 *
 * @func void | StopCPUUsageCollection | This function does all necessary
 * CPU usage data collection cleanup.
 *
 * @comm This function executes two different code paths: one for NT and one
 *   for Win95-98.
 *
 * @devnote MSDN references:
 *   Microsoft Knowledge Base, Article ID Q174631
 *   "HOWTO: Access the Performance Registry Under Windows 95"
 *
 *   Microsoft Knowledge Base, Article ID Q107728
 *   "Retrieving Counter Data from the Registry"
 *
 *   Also, used section "Platform SDK\Windows Base Services\Windows NT Features\Performance Data Helper"
 ***************************************************************************/
void SendVideoStream::StopCPUUsageCollection(void)
{
	DWORD dwType;
	DWORD cbData;

	if (m_Stats.fWinNT)
	{
		if (m_Stats.NtCPUUsage.hPerfData)
		{
			LocalUnlock(m_Stats.NtCPUUsage.hPerfData);
			LocalFree(m_Stats.NtCPUUsage.hPerfData);
		}
		m_Stats.NtCPUUsage.hPerfData = (HANDLE)NULL;
		m_Stats.NtCPUUsage.pbyPerfData = (PBYTE)NULL;
		if (m_Stats.NtCPUUsage.pllCounterValue)
			LocalFree(m_Stats.NtCPUUsage.pllCounterValue);
		m_Stats.NtCPUUsage.pllCounterValue = (PLONGLONG)NULL;
	}
	else
	{
		if (m_Stats.hPerfKey)
		{
			// Close the data collection key
			RegCloseKey(m_Stats.hPerfKey);

			// Stop the CPUUsage data collection on the kernel stat server
			if (RegOpenKeyEx(HKEY_DYN_DATA, "PerfStats\\StopStat", 0, KEY_READ, &m_Stats.hPerfKey) == ERROR_SUCCESS)
			{
				RegQueryValueEx(m_Stats.hPerfKey, "KERNEL\\CPUUsage", NULL, &dwType, NULL, &cbData);
				RegCloseKey(m_Stats.hPerfKey);
			}

			// Stop the kernel stat server
			if (RegOpenKeyEx(HKEY_DYN_DATA, "PerfStats\\StopSrv", 0, KEY_READ, &m_Stats.hPerfKey) == ERROR_SUCCESS)
			{
				RegQueryValueEx(m_Stats.hPerfKey, "KERNEL", NULL, &dwType, NULL, &cbData);
				RegCloseKey(m_Stats.hPerfKey);
			}

			m_Stats.hPerfKey = (HKEY)NULL;
		}
	}
}

/****************************************************************************
 * @doc EXTERNAL QOSFUNC
 *
 * @func void | GetCPUUsage | This function does all necessary
 * initialization for CPU usage data collection.
 *
 * @parm PDWORD | [OUT] pdwOverallCPUUsage | Specifies a pointer to a DWORD to
 *   receive the current CPU usage.
 *
 * @rdesc Returns TRUE on success, and FALSE otherwise.
 *
 * @comm This functions executes two different code paths: one for NT and one
 *   for Win95-98. Note that we collect data on all CPUs on NT MP machines.
 *
 * @devnote MSDN references:
 *   Microsoft Knowledge Base, Article ID Q174631
 *   "HOWTO: Access the Performance Registry Under Windows 95"
 *
 *   Microsoft Knowledge Base, Article ID Q107728
 *   "Retrieving Counter Data from the Registry"
 *
 *   Also, used section "Platform SDK\Windows Base Services\Windows NT Features\Performance Data Helper"
 ***************************************************************************/
BOOL SendVideoStream::GetCPUUsage(PDWORD pdwOverallCPUUsage)
{

	PPERF_DATA_BLOCK pPerfDataBlock;
	PPERF_OBJECT_TYPE pPerfObjectType;
	PPERF_COUNTER_DEFINITION pPerfCounterDefinition;
	PPERF_INSTANCE_DEFINITION pPerfInstanceDefinition;
	PPERF_COUNTER_BLOCK pPerfCounterBlock;
	DWORD dwType;
	DWORD cbData = sizeof(DWORD);
	DWORD cbTryCounterData;
	HANDLE hPerfData;
	LONGLONG llDeltaPerfTime100nSec;
	LONGLONG llDeltaCPUUsage = (LONGLONG)NULL;
	char szProcessorIndex[16];
	long lRet;

	FX_ENTRY("SendVideoStream::GetCPUUsage");

	// We use the handle to the perf key as a way to figure out if we have been initialized correctly
	if (m_Stats.hPerfKey && pdwOverallCPUUsage)
	{
		// Initialize result value
		*pdwOverallCPUUsage = 0UL;

		if (m_Stats.fWinNT && m_Stats.NtCPUUsage.pbyPerfData)
		{
			// Make a string out of the processor object index.
			_ltoa(m_Stats.NtCPUUsage.dwProcessorIndex, szProcessorIndex, 10);

			// Under some cicumstances (cf. Q178887 for details) the RegQueryValueEx
			// function may cause an Access Violation because of a buggy performance
			// extension DLL such as SQL's.
			__try
			{
				// Read the performance data. Its size may change between each 'registry' access.
				cbTryCounterData = m_Stats.NtCPUUsage.cbPerfData;
				while((lRet = RegQueryValueEx(HKEY_PERFORMANCE_DATA, szProcessorIndex, NULL, &dwType, m_Stats.NtCPUUsage.pbyPerfData, &cbTryCounterData)) == ERROR_MORE_DATA)
				{
					m_Stats.NtCPUUsage.cbPerfData += BYTE_INCREMENT;
					LocalUnlock(m_Stats.NtCPUUsage.hPerfData);
					hPerfData = LocalReAlloc(m_Stats.NtCPUUsage.hPerfData, m_Stats.NtCPUUsage.cbPerfData, LMEM_MOVEABLE);
					if (!hPerfData)
						goto MyError;
					m_Stats.NtCPUUsage.hPerfData = hPerfData;
					m_Stats.NtCPUUsage.pbyPerfData = (PBYTE)LocalLock(hPerfData);
					cbTryCounterData = m_Stats.NtCPUUsage.cbPerfData;
				}
			}
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				ERRORMESSAGE(("%s: Performance Registry Access Violation -> don't use perf counters for CPU measurements\r\n", _fx_));
				goto MyError;
			}

			if (lRet != ERROR_SUCCESS)
				goto MyError;
			else
			{
				// Read the PERF_DATA_BLOCK header structure. It describes the system
				// and the performance data. The PERF_DATA_BLOCK structure is followed
				// by a list of object information blocks (one per object). We use the
				// counter index to retrieve object information.
				//
				// Each object information block contains a PERF_OBJECT_TYPE structure,
				// which describes the performance data for the object. Look for the one
				// that applies to CPU usage based on its index value.
				pPerfDataBlock = (PPERF_DATA_BLOCK)m_Stats.NtCPUUsage.pbyPerfData;
				pPerfObjectType = (PPERF_OBJECT_TYPE)(m_Stats.NtCPUUsage.pbyPerfData + pPerfDataBlock->HeaderLength);
				for (int i = 0; i < (int)pPerfDataBlock->NumObjectTypes; i++)
				{
					if (pPerfObjectType->ObjectNameTitleIndex == m_Stats.NtCPUUsage.dwProcessorIndex)
					{
						// The PERF_OBJECT_TYPE structure is followed by a list of PERF_COUNTER_DEFINITION
						// structures, one for each counter defined for the object. The list of PERF_COUNTER_DEFINITION
						// structures is followed by a list of instance information blocks (one for each instance).
						//
						// Each instance information block contains a PERF_INSTANCE_DEFINITION structure and
						// a PERF_COUNTER_BLOCK structure, followed by the data for each counter.
						//
						// Look for the counter defined for % processor time.
						pPerfCounterDefinition = (PPERF_COUNTER_DEFINITION)((PBYTE)pPerfObjectType + pPerfObjectType->HeaderLength);
						for (int j = 0; j < (int)pPerfObjectType->NumCounters; j++)
						{
							if (pPerfCounterDefinition->CounterNameTitleIndex == m_Stats.NtCPUUsage.dwPercentProcessorIndex)
							{
								// Measure elapsed time
								llDeltaPerfTime100nSec = *(PLONGLONG)&pPerfDataBlock->PerfTime100nSec - m_Stats.NtCPUUsage.llPerfTime100nSec;

								// Save the timestamp for the next round
								m_Stats.NtCPUUsage.llPerfTime100nSec = *(PLONGLONG)&pPerfDataBlock->PerfTime100nSec;

								pPerfInstanceDefinition = (PPERF_INSTANCE_DEFINITION)((PBYTE)pPerfObjectType + pPerfObjectType->DefinitionLength);
								for (int k = 0; k < (int)pPerfObjectType->NumInstances && k < (int)m_Stats.NtCPUUsage.dwNumProcessors; k++)
								{
									// Get a pointer to the PERF_COUNTER_BLOCK
									pPerfCounterBlock = (PPERF_COUNTER_BLOCK)((PBYTE)pPerfInstanceDefinition + pPerfInstanceDefinition->ByteLength);

									// Get the CPU usage
									llDeltaCPUUsage += *(PLONGLONG)((PBYTE)pPerfInstanceDefinition + pPerfInstanceDefinition->ByteLength + pPerfCounterDefinition->CounterOffset) - m_Stats.NtCPUUsage.pllCounterValue[k];

									// Save the value for the next round
									m_Stats.NtCPUUsage.pllCounterValue[k] = *(PLONGLONG)((PBYTE)pPerfInstanceDefinition + pPerfInstanceDefinition->ByteLength + pPerfCounterDefinition->CounterOffset);

									// Go to the next instance information block
									pPerfInstanceDefinition = (PPERF_INSTANCE_DEFINITION)((PBYTE)pPerfInstanceDefinition + pPerfInstanceDefinition->ByteLength + pPerfCounterBlock->ByteLength);
								}

								// Do a bit of checking on the return value and change its unit to match QoS unit
								if ((llDeltaPerfTime100nSec != (LONGLONG)0) && pPerfObjectType->NumInstances)
									if ((*pdwOverallCPUUsage = (DWORD)((LONGLONG)1000 - (LONGLONG)1000 * llDeltaCPUUsage / llDeltaPerfTime100nSec / (LONGLONG)pPerfObjectType->NumInstances)) > 1000UL)
									{
										*pdwOverallCPUUsage = 0UL;
										return FALSE;
									}

								// We're done!
								return TRUE;
							}
							else
								pPerfCounterDefinition = (PPERF_COUNTER_DEFINITION)((PBYTE)pPerfCounterDefinition + pPerfCounterDefinition->ByteLength);
						}
						break;
					}
					else
						pPerfObjectType = (PPERF_OBJECT_TYPE)((PBYTE)pPerfObjectType + pPerfObjectType->TotalByteLength);
				}

				// If we get here, we haven't found the counters we were looking for
				goto MyError;
			}
		}
		else
		{
			// Do a bit of checking on the return value and change its unit to match QoS unit.
			if ((RegQueryValueEx(m_Stats.hPerfKey, "KERNEL\\CPUUsage", NULL, &dwType, (LPBYTE)pdwOverallCPUUsage, &cbData) == ERROR_SUCCESS) && (*pdwOverallCPUUsage > 0) && (*pdwOverallCPUUsage <= 100))
			{
				*pdwOverallCPUUsage *= 10UL;
				return TRUE;
			}
			else
			{
				*pdwOverallCPUUsage = 0UL;
				return FALSE;
			}
		}
	}
	
	return FALSE;

MyError:
	if (m_Stats.NtCPUUsage.pllCounterValue)
		LocalFree(m_Stats.NtCPUUsage.pllCounterValue);
	m_Stats.NtCPUUsage.pllCounterValue = (PLONGLONG)NULL;
	if (m_Stats.NtCPUUsage.hPerfData)
	{
		LocalUnlock(m_Stats.NtCPUUsage.hPerfData);
		LocalFree(m_Stats.NtCPUUsage.hPerfData);
	}
	m_Stats.NtCPUUsage.hPerfData = (HANDLE)NULL;
	m_Stats.NtCPUUsage.pbyPerfData = (PBYTE)NULL;
	m_Stats.hPerfKey = (HKEY)NULL;

	return FALSE;
}

BOOL SendVideoStream::SetTargetRates(DWORD dwTargetFrameRate, DWORD dwTargetBitrate)
{
	MMRESULT mmr;
	ASSERT(m_pVideoFilter);

	mmr = m_pVideoFilter->SetTargetRates(dwTargetFrameRate, dwTargetBitrate >> 3);
	return (mmr == MMSYSERR_NOERROR);
}


// dwFlags must be one of the following:
// CAPTURE_DIALOG_FORMAT
// CAPTURE_DIALOG_SOURCE
HRESULT __stdcall SendVideoStream::ShowDeviceDialog(DWORD dwFlags)
{
	DWORD dwQueryFlags = 0;
    DWORD_PTR dwPropVal;
	HRESULT hr=DPR_INVALID_PARAMETER;

	// the device must be "open" for us to display the dialog box
	if (!(m_DPFlags & DPFLAG_CONFIGURED_SEND))
		return DPR_NOT_CONFIGURED;

	((VideoInControl*)m_InMedia)->GetProp(MC_PROP_VFW_DIALOGS, &dwPropVal);
    dwQueryFlags = (DWORD)dwPropVal;

	if ((dwQueryFlags & CAPTURE_DIALOG_SOURCE) && (dwFlags & CAPTURE_DIALOG_SOURCE))
	{
		hr = ((VideoInControl *)m_InMedia)->DisplayDriverDialog(GetActiveWindow(), CAPTURE_DIALOG_SOURCE);
	}
	else if ((dwQueryFlags & CAPTURE_DIALOG_FORMAT) && (dwFlags & CAPTURE_DIALOG_FORMAT))
	{
		hr = ((VideoInControl *)m_InMedia)->DisplayDriverDialog(GetActiveWindow(), CAPTURE_DIALOG_FORMAT);
	}

	return hr;

}


// will set dwFlags to one or more of the following bits
// CAPTURE_DIALOG_FORMAT
// CAPTURE_DIALOG_SOURCE
HRESULT __stdcall SendVideoStream::GetDeviceDialog(DWORD *pdwFlags)
{
    HRESULT hr;
    DWORD_PTR dwPropVal;

	hr = ((VideoInControl*)m_InMedia)->GetProp(MC_PROP_VFW_DIALOGS, &dwPropVal);
    *pdwFlags = (DWORD)dwPropVal;
    return hr;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nmcap\filters.h ===
//  FILTERS.H
//
//      Headers for a simple C-callable filter manager
//
//  Created 15-Jan-97 [JonT]

#ifndef __filters_h__
#define __filters_h__

// This file and interfaces contained here will be used by both C and C++

#include <ibitmap.h>
#include <effect.h>

// Equates
#define MAX_FILTER_NAME     256

// Types

typedef struct _FINDFILTER
{
    CLSID clsid;
    char szFilterName[MAX_FILTER_NAME];
    DWORD_PTR dwReserved;
} FINDFILTER;

// Prototypes

HRESULT     FindFirstRegisteredFilter(FINDFILTER* pFF);
HRESULT     FindNextRegisteredFilter(FINDFILTER* pFF);
HRESULT     FindCloseRegisteredFilter(FINDFILTER* pFF);
HRESULT     GetRegisteredFilterCount(LONG* plCount);
HRESULT     GetDescriptionOfFilter(CLSID* pCLSID, char* pszDescription);
HRESULT     LoadFilter(CLSID* pCLSID, IBitmapEffect** ppbe);

#endif  // __filters_h__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nmcap\filters.cpp ===
//  FILTERS.CPP
//
//      Test code for filter chains
//
//  Created 17-Jan-97 [JonT] (by adapting original vftest code by RichP)

#include <windows.h>
#include <comcat.h>
#include <ocidl.h>
#include <olectl.h>
#include "filters.h"

//--------------------------------------------------------------------
//  Filter manager code

typedef struct tagFILTERINFO* PFILTERINFO;
typedef struct tagFILTERINFO
{
    IBitmapEffect *pbe;
    CLSID clsid;
    TCHAR szFilterName[MAX_FILTER_NAME];
    DWORD dwFlags;
} FILTERINFO;

#define ERROREXIT(s,hrFail) \
    {   hr = (hrFail); \
        OutputDebugString(TEXT("VFTEST:"##s##"\r\n")); \
        goto Error; }


void
StringFromGUID(
    const CLSID* piid,
    LPTSTR pszBuf
    )
{
    wsprintf(pszBuf, TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"), piid->Data1,
            piid->Data2, piid->Data3, piid->Data4[0], piid->Data4[1], piid->Data4[2],
            piid->Data4[3], piid->Data4[4], piid->Data4[5], piid->Data4[6], piid->Data4[7]);
}


//  FindFirstRegisteredFilter
//      Returns info on the first registered filter

HRESULT
FindFirstRegisteredFilter(
    FINDFILTER* pFF
    )
{
    HRESULT hr;
    IEnumGUID* penum;
    ICatInformation* pci;

    // Get the Component Category interface
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatInformation, (void**)&pci);
	if (FAILED(hr))
        ERROREXIT("Couldn't get IID_ICatInformation from StdComponentCategoriesMgr", E_UNEXPECTED);

    // Get the enumerator for the filter category
    hr = pci->EnumClassesOfCategories(1, (GUID*)&CATID_BitmapEffect, 0, NULL, &penum);
    pci->Release();
    if (FAILED(hr))
        ERROREXIT("Couldn't get enumerator for CATID_BitmapEffect", E_UNEXPECTED);

    // Save away the enumerator for the findnext/close
    pFF->dwReserved = (DWORD_PTR)penum;

    // Use FindNext to get the information (it only needs dwReserved to be set)
    return FindNextRegisteredFilter(pFF);

Error:
    return hr;
}


//  FindNextRegisteredFilter
//      Returns info on the next registered filter

HRESULT
FindNextRegisteredFilter(
    FINDFILTER* pFF
    )
{
    ULONG ulGUIDs;
    IEnumGUID* penum = (IEnumGUID*)pFF->dwReserved;

    // Use the enumerator to get the CLSID
    if (FAILED(penum->Next(1, &pFF->clsid, &ulGUIDs)) || ulGUIDs != 1)
        return HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES);

    // Read and return the description
    return GetDescriptionOfFilter(&pFF->clsid, pFF->szFilterName);
}


//  FindCloseRegisteredFilter
//      Signals done with findfirst/next on registered filters so we
//      can free resources

HRESULT
FindCloseRegisteredFilter(
    FINDFILTER* pFF
    )
{
    IEnumGUID* penum = (IEnumGUID*)pFF->dwReserved;

    // Simply free the enumerator
    if (penum)
        penum->Release();

    return NO_ERROR;
}


//  GetRegisteredFilterCount
//      Counts the number of registered filters.
//      The caller of this routine should still be careful for the possibility
//      of filters being installed between this count being made and the findfirst/next.

HRESULT
GetRegisteredFilterCount(
    LONG* plCount
    )
{
    HRESULT hr;
    IEnumGUID* penum = NULL;
    ICatInformation* pci;
    ULONG ulGUIDs;
    CLSID clsid;

    // Get the Component Category interface
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatInformation, (void**)&pci);
	if (FAILED(hr))
        ERROREXIT("Couldn't get IID_ICatInformation from StdComponentCategoriesMgr", E_UNEXPECTED);

    // Get the enumerator for the filter category
    hr = pci->EnumClassesOfCategories(1, (GUID*)&CATID_BitmapEffect, 0, NULL, &penum);
    pci->Release();
    pci = NULL;
    if (FAILED(hr))
        ERROREXIT("Couldn't get enumerator for CATID_BitmapEffect", E_UNEXPECTED);

    // Use the enumerator to walk through and count the items
    *plCount = 0;
    while (TRUE)
    {
        if (FAILED(penum->Next(1, &clsid, &ulGUIDs)) || ulGUIDs != 1)
            break;
        (*plCount)++;
    }
    penum->Release();
    return NO_ERROR;

Error:
    return hr;
}


//  LoadFilter
HRESULT
LoadFilter(
    CLSID* pclsid,
    IBitmapEffect** ppbe
    )
{
    HRESULT hr;

    // Load the filter
    if (FAILED(CoCreateInstance(*pclsid, NULL, CLSCTX_INPROC_SERVER, IID_IBitmapEffect, (LPVOID*)ppbe)))
        ERROREXIT("CoCreateInstance on filter failed", E_UNEXPECTED);

    return NO_ERROR;

Error:
    return hr;
}


#if 0
//  GetFilterInterface
//      Returns the filter's status flags

HRESULT
GetFilterStatusBits(
    HANDLE* hFilter,
    DWORD *status
    )
{
    *status = ((PFILTERINFO)hFilter)->dwFlags;
    return NO_ERROR;
}


//  GetFilterInterface
//      Returns an IUnknown pointer for the given handle.
//      The caller must release this pointer.

HRESULT
GetFilterInterface(
    HANDLE hFilter,
    void** ppvoid
    )
{
    return ((PFILTERINFO)hFilter)->pbe->QueryInterface(IID_IUnknown, ppvoid);
}
#endif

//  GetDescriptionOfFilter
//      Returns the description of a filter from the CLSID

HRESULT
GetDescriptionOfFilter(
    CLSID* pCLSID,
    char* pszDescription
    )
{
    HRESULT hr;
    const TCHAR szCLSID[] = TEXT("CLSID");
    HKEY hkCLSID;
    HKEY hkGUID;
    TCHAR szGUID[80];
    unsigned err;
    LONG len;

    if (RegOpenKey(HKEY_CLASSES_ROOT, szCLSID, &hkCLSID) == ERROR_SUCCESS)
    {
        StringFromGUID(pCLSID, szGUID);
        err = RegOpenKey(hkCLSID, szGUID, &hkGUID);
        RegCloseKey(hkCLSID);
        if (err == ERROR_SUCCESS)
        {
            len = MAX_FILTER_NAME;
            err = RegQueryValue(hkGUID, NULL, pszDescription, &len);
            RegCloseKey(hkGUID);
            if (err != ERROR_SUCCESS)
                ERROREXIT("Couldn't read value associated with filter GUID", E_UNEXPECTED);
        }
    }
    else
        ERROREXIT("Couldn't open HKEY_CLASSES_ROOT!", E_UNEXPECTED);

    return NO_ERROR;

Error:
    return hr;
}


#if 0
#define MAX_PAGES   20      // Can't have more than this many pages in frame (arbitrary)

//  DisplayFilterProperties
//      Displays the property pages for a filter

HRESULT
DisplayFilterProperties(
    HANDLE hFilter,
    HWND hwndParent
    )
{
    PFILTERINFO pfi = (PFILTERINFO)hFilter;
    CLSID clsidTable[MAX_PAGES];
    LONG lcCLSIDs;
    IUnknown* punk;
    ISpecifyPropertyPages* pspp;
    CAUUID cauuid;
    HRESULT hr;

    // Make sure the object supports property pages. If not, just bail
    if (FAILED(pfi->pbe->QueryInterface(IID_ISpecifyPropertyPages, (void**)&pspp)))
        return ERROR_NOT_SUPPORTED;

    // Get the page CLSIDs
    pspp->GetPages(&cauuid);
    lcCLSIDs = cauuid.cElems;
    if (lcCLSIDs > MAX_PAGES)
        lcCLSIDs = MAX_PAGES;
    memcpy(clsidTable, cauuid.pElems, lcCLSIDs * sizeof (CLSID));
    CoTaskMemFree(cauuid.pElems);
    pspp->Release();

    // Get the IUnknown we need
    pfi->pbe->QueryInterface(IID_IUnknown, (void**)&punk);

    hr = OleCreatePropertyFrame(hwndParent, 0, 0, L"Filter",
        1, &punk, lcCLSIDs, clsidTable,
        MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT), SORT_DEFAULT),
        0, NULL);

    // Clean up
    punk->Release();

    return hr;
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\vidutils.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    utils.h

Abstract:
	Assorted support and debugging routines used by the Network Audio Controller.

--*/
#ifndef _VIDUTILS_H_
#define _VIDUTILS_H_


#include <pshpack8.h> /* Assume 8 byte packing throughout */

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

enum
{
    //  NAME_FramesPerSec_BitsPerSample
	DVF_DEFAULT_7FPS_4,
    DVF_NumOfFormats
};

//extern VIDEOFORMATEX g_vfDefList[];

VIDEOFORMATEX * GetDefFormat ( int idx );
ULONG GetFormatSize ( PVOID pwf );
BOOL IsSameFormat ( PVOID pwf1, PVOID pwf2 );
BOOL IsSimilarVidFormat(VIDEOFORMATEX *pFormat1, VIDEOFORMATEX *pFormat2);
void CopyPreviousBuf (VIDEOFORMATEX *pwf, PBYTE pb, ULONG cb);

#define IFRAMES_CAPS_NM3        101
#define IFRAMES_CAPS_NM2        102
#define IFRAMES_CAPS_3RDPARTY   103
#define IFRAMES_CAPS_UNKNOWN    104

int GetIFrameCaps(IStreamSignal *pStreamSignal);


#define SQCIF_WIDTH		128
#define SQCIF_HEIGHT	96

#define QCIF_WIDTH		176
#define QCIF_HEIGHT		144

#define CIF_WIDTH		352
#define CIF_HEIGHT		288


#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#include <poppack.h> /* End byte packing */

#endif // _VIDUTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nmcap\capture.h ===
#include <windows.h>
#include <ibitmap.h>
#include <frameop.h>
#include <dcap.h>

#ifndef _capture_h
#define _capture_h

class CCaptureChain
{
private:
    CFrameOp*           m_opchain;
    CFilterChain*       m_filterchain;
    DWORD_PTR           m_filtertags;
    CRITICAL_SECTION    m_capcs;

public:
    CCaptureChain();
    ~CCaptureChain();

	STDMETHODIMP InitCaptureChain(HCAPDEV hcapdev, BOOL streaming,
	                               LPBITMAPINFOHEADER lpcap,
                                   LONG desiredwidth, LONG desiredheight,
                                   DWORD desiredformat,
                                   LPBITMAPINFOHEADER *plpdsp);
    STDMETHODIMP GrabFrame(IBitmapSurface** ppBS);
	STDMETHODIMP AddFilter(CLSID* pclsid, LPBITMAPINFOHEADER lpbmhIn,
	                        HANDLE* phNew, HANDLE hAfter);
	STDMETHODIMP RemoveFilter(HANDLE hNew);
	STDMETHODIMP DisplayFilterProperties(HANDLE hFilter, HWND hwndParent);
};

#endif //#ifndef _capture_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nmcap\frameop.cpp ===
#include <windows.h>
#include <qos.h>
#include <winsock2.h>
#include "frameop.h"
#include <confdbg.h>
#include <avutil.h>
#include "..\nac\utils.h"
#include "vidinout.h"
#include "vcmstrm.h"


#ifdef DEBUG
extern "C" BOOL g_framedebug = TRUE;
#endif

// Base class methods
STDMETHODIMP_(ULONG)
CFrameOp::AddRef(
    void
    )
{
	FX_ENTRY("CFrameOp::AddRef");

	DEBUGMSG(ZONE_NMCAP_REFCOUNT,("%s: refcnt+(0x%08lX [CFrameOp])=%d\r\n", _fx_, this, m_cRef+1));

    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CFrameOp::Release(
    void
    )
{
    LONG res;

	FX_ENTRY("CFrameOp::Release");

	DEBUGMSG(ZONE_NMCAP_REFCOUNT,("%s: refcnt-(0x%08lX [CFrameOp])=%d\r\n", _fx_, this, m_cRef-1));

    res = InterlockedDecrement(&m_cRef);
    if (res == 0) {
        if (m_pool) {
            m_pool->Release();
        }
        if (m_next)
            m_next->Release();

		DEBUGMSG(ZONE_NMCAP_CDTOR,("%s: deleting (0x%08lX [CFrameOp])\r\n", _fx_, this));

        delete this;
    }
    return res;
}

// CCaptureFrame methods
CCaptureFrame::~CCaptureFrame(
    )
{
    if (m_hbuf1)
        FreeFrameBuffer(m_hcapdev, m_hbuf1);
    if (m_hbuf2)
        FreeFrameBuffer(m_hcapdev, m_hbuf2);
}

STDMETHODIMP
CCaptureFrame::DoOp(
    IBitmapSurface** ppbs
    )
{
    HFRAMEBUF hbuf;
    BYTE* pBits;

    m_pool->GetBuffer(ppbs, &hbuf);
    if (*ppbs) {
        pBits = CaptureFrame(m_hcapdev, hbuf);
        return NO_ERROR;
    }
    return E_OUTOFMEMORY;
}

BOOL
CCaptureFrame::InitCapture(
    HCAPDEV hcapdev,
    LPBITMAPINFOHEADER lpbmh
    )
{
	FX_ENTRY("CCaptureFrame::InitCapture");

    if ((m_hbuf1 = AllocFrameBuffer(hcapdev)) &&
        (m_hbuf2 = AllocFrameBuffer(hcapdev))) {
        if ((m_pool = new CVidPool)) {
            m_pool->AddRef();

            if (m_pool->InitPool(0, lpbmh) == NO_ERROR) {
  	            m_pool->AddExternalBuffer(GetFrameBufferPtr(hcapdev, m_hbuf1), (void*)m_hbuf1);
                m_pool->AddExternalBuffer(GetFrameBufferPtr(hcapdev, m_hbuf2), (void*)m_hbuf2);
                m_hcapdev = hcapdev;
				DEBUGMSG(ZONE_NMCAP_CDTOR,("%s: init capture (0x%08lX [CCaptureFrame])\r\n", _fx_, this));
                return TRUE;
            }
            else {
				ERRORMESSAGE(("%s: Failed to init capture pool", _fx_));
                m_pool->Release();
            }
        }
        else
		{
			ERRORMESSAGE(("%s: Failed to alloc capture pool", _fx_));
		}
        FreeFrameBuffer(hcapdev, m_hbuf2);
    }
    else
	{
		ERRORMESSAGE(("%s: Failed to allocate frame buffer", _fx_));
	}

    if (m_hbuf1)
        FreeFrameBuffer(hcapdev, m_hbuf1);
    return FALSE;
}


// CStreamCaptureFrame methods
CStreamCaptureFrame::~CStreamCaptureFrame(
    )
{
    StopStreaming(m_hcapdev);
    UninitializeStreaming(m_hcapdev);
}

STDMETHODIMP
CStreamCaptureFrame::DoOp(
    IBitmapSurface** ppbs
    )
{
    long pitch;
    CAPFRAMEINFO cfi;
    CBitmap *pcb;

	FX_ENTRY ("CStreamCaptureFrame::DoOp")

    m_pool->GetBuffer(&pcb, NULL);
    if (pcb) {
        if (pcb->m_bits) {
            PutBufferIntoStream(m_hcapdev, (BYTE*)pcb->m_bits);
            pcb->m_bits = NULL;
        }
        GetNextReadyBuffer(m_hcapdev, &cfi);
        if (pcb->m_bits = (LPBYTE)cfi.lpData) {
            *ppbs = (IBitmapSurface*)pcb;
            return NO_ERROR;
        }
		DEBUGMSG(ZONE_NMCAP_STREAMING,("%s: Failed to get buffer from DCAP\r\n", _fx_));
        pcb->Release();
    }
    *ppbs = NULL;
    return E_OUTOFMEMORY;
}

void GiveBufferToDriver (CBitmap *pBitmap, DWORD_PTR refdata)
{
    if (pBitmap->m_bits && refdata) {
        PutBufferIntoStream((HCAPDEV)refdata, (BYTE*)pBitmap->m_bits);
        pBitmap->m_bits = NULL;
    }
}

BOOL
CStreamCaptureFrame::InitCapture(
    HCAPDEV hcapdev,
    LPBITMAPINFOHEADER lpbmh
    )
{
    CAPSTREAM cs;
    CAPFRAMEINFO cfi;

	FX_ENTRY("CStreamCaptureFrame::InitCapture");

    // Initialize streaming
    cs.dwSize = sizeof (CAPSTREAM);
    cs.nFPSx100 = 30 * 100;
    cs.ncCapBuffers = 5;
    if (InitializeStreaming(hcapdev, &cs, 0)) {
        if (StartStreaming(hcapdev)) {
            if (WaitForSingleObject(cs.hevWait, 5000) != WAIT_TIMEOUT) {
                if ((m_pool = new CVidPool)) {
                    m_pool->AddRef();

                    if (m_pool->InitPool(0, lpbmh) == NO_ERROR) {
                        m_pool->m_pAddingToFree = &GiveBufferToDriver;
                        m_pool->m_refdata = (DWORD_PTR)hcapdev;
                        m_pool->AddExternalBuffer(NULL, (void*)1);
                        m_pool->AddExternalBuffer(NULL, (void*)2);
                        m_hcapdev = hcapdev;
						DEBUGMSG(ZONE_NMCAP_CDTOR,("%s: init stream capture (0x%08lX [CStreamCaptureFrame])\r\n", _fx_, this));
                        return TRUE;
                    }
                    else
					{
						ERRORMESSAGE(("%s: Failed to init capture pool", _fx_));
                        m_pool->Release();
                    }
                }
                else
				{
					ERRORMESSAGE(("%s: Failed to alloc capture pool", _fx_));
				}
            }
            else
			{
				ERRORMESSAGE(("%s: Error no frame events received", _fx_));
			}
        }
        else
		{
			ERRORMESSAGE(("%s: Error starting streaming", _fx_));
		}
        UninitializeStreaming(hcapdev);
    }
    else
	{
		ERRORMESSAGE(("%s: Error initializing streaming", _fx_));
	}
    return FALSE;
}


// CICMcvtFrame methods
CICMcvtFrame::~CICMcvtFrame(
    )
{
    if (m_hic) {
        ICDecompressEnd(m_hic);
        ICClose(m_hic);
    }
    if (m_inlpbmh)
        LocalFree((HANDLE)m_inlpbmh);
    if (m_outlpbmh)
        LocalFree((HANDLE)m_outlpbmh);
}

STDMETHODIMP
CICMcvtFrame::DoOp(
    IBitmapSurface** ppbs
    )
{
    BYTE* pBits;
    BYTE* pCvtBits;
    long pitch;
    IBitmapSurface *pBS;

    m_pool->GetBuffer(&pBS, NULL);
    if (pBS) {
        (*ppbs)->LockBits(NULL, 0, (void**)&pBits, &pitch);
        pBS->LockBits(NULL, 0, (void**)&pCvtBits, &pitch);
        ICDecompress(m_hic, 0, m_inlpbmh, pBits, m_outlpbmh, pCvtBits);
        (*ppbs)->UnlockBits(NULL, pBits);
        pBS->UnlockBits(NULL, pCvtBits);
        (*ppbs)->Release(); // done with the capture buffer
        *ppbs = pBS;
        return NO_ERROR;
    }
    return E_OUTOFMEMORY;
}

BOOL
CICMcvtFrame::InitCvt(
    LPBITMAPINFOHEADER lpbmh,
    DWORD bmhLen,
    LPBITMAPINFOHEADER *plpbmhdsp
    )
{
    DWORD dwLen;
    HIC hic;

	FX_ENTRY("CICMcvtFrame::InitCvt");

    *plpbmhdsp = lpbmh;
    if (lpbmh->biCompression != BI_RGB) {
        *plpbmhdsp = NULL;
        // make internal copy of input BITMAPINFOHEADER
        m_inlpbmh = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, bmhLen);
        if (!m_inlpbmh) {
			ERRORMESSAGE(("%s: No memory for display bitmapinfoheader", _fx_));
            return FALSE;
        }
        CopyMemory(m_inlpbmh, lpbmh, bmhLen);

        // alloc space for display BITMAPINFOHEADER
        dwLen = sizeof(BITMAPINFOHEADER) + 256*sizeof(RGBQUAD);
        m_outlpbmh = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, dwLen);
        if (!m_outlpbmh) {
            LocalFree((HANDLE)m_inlpbmh);
			ERRORMESSAGE(("%s: No memory for display bitmapinfoheader", _fx_));
            return FALSE;
        }

        // First attempt to find a codec to convert to RGB24
        hic = ICGetDisplayFormat(NULL, lpbmh, m_outlpbmh, 24, 0, 0);
        if (!hic) {
            // nothing available to convert to RGB24, so see what we can get
            hic = ICGetDisplayFormat(NULL, lpbmh, m_outlpbmh, 0, 0, 0);
        }
        if (hic) {
            if (m_outlpbmh->biCompression == BI_RGB) {
                // we got a codec that can convert to RGB
                *plpbmhdsp = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, dwLen);
                if (*plpbmhdsp) {
                    CopyMemory(*plpbmhdsp, m_outlpbmh, dwLen);
                    if ((m_pool = new CVidPool)) {
                        m_pool->AddRef();
                        if (m_pool->InitPool(2, m_outlpbmh) == NO_ERROR) {
                            m_hic = hic;
                            ICDecompressBegin(m_hic, m_inlpbmh, m_outlpbmh);
							DEBUGMSG(ZONE_NMCAP_CDTOR,("%s: init ICM cvt (0x%08lX [CICMcvtFrame])\r\n", _fx_, this));
                            return TRUE;
                        }
                        else {
							ERRORMESSAGE(("%s: Failed to init codec pool", _fx_));
                            m_pool->Release();
                        }
                    }
                    else
					{
						ERRORMESSAGE(("%s: Failed to alloc codec pool", _fx_));
					}
                    LocalFree((HANDLE)*plpbmhdsp);
                }
                else
				{
					ERRORMESSAGE(("%s: Failed to init codec pool", _fx_));
				}
            }
            ICClose(hic);  // close the opened codec
        }
        else
		{
			ERRORMESSAGE(("%s: No available codecs to decode format", _fx_));
		}

        // free allocate BITMAPINFOHEADER memory
       	LocalFree((HANDLE)m_inlpbmh);
       	m_inlpbmh = NULL;
       	LocalFree((HANDLE)m_outlpbmh);
       	m_outlpbmh = NULL;
    }
    return FALSE;
}


//CFilterChain methods
CFilterChain::~CFilterChain(
    )
{
    if (m_head)
        m_head->Release();
}

STDMETHODIMP
CFilterChain::DoOp(
    IBitmapSurface** ppbs
    )
{
    CFilterFrame *cfo;
    HRESULT hres;

    cfo = m_head;
    while (cfo) {
        if (cfo->m_enabled) {
            if ((hres = cfo->DoOp(ppbs)) != NOERROR) {
                return hres;
            }
        }
        cfo = (CFilterFrame*)cfo->m_next;
    }
    return NOERROR;
}


//CFilterFrame methods
CFilterFrame::~CFilterFrame(
    )
{
    if (m_effect)
        m_effect->Release();
}

STDMETHODIMP
CFilterFrame::DoOp(
    IBitmapSurface** ppbs
    )
{
    HRESULT hres;
    IBitmapSurface* pBS;

    if (m_inplace) {
        return m_effect->DoEffect(*ppbs, NULL, NULL, NULL);
    }
    else {
        m_pool->GetBuffer(&pBS, NULL);
        if (pBS) {
            hres = m_effect->DoEffect(*ppbs, pBS, NULL, NULL);
            (*ppbs)->Release();
            *ppbs = pBS;
            return hres;
        }
        return E_OUTOFMEMORY;
    }
}

BOOL
CFilterFrame::InitFilter(
    IBitmapEffect *effect,
    LPBITMAPINFOHEADER lpbmhIn,
    CVidPool *pool
    )
{
    DWORD dwFlags;

	FX_ENTRY("CFilterFrame::InitFilter");

    m_effect = effect;
    if (effect->GetMiscStatusBits(&dwFlags) == NO_ERROR) {
        m_inplace = (dwFlags & BITMAP_EFFECT_INPLACE);
    }
    else
        m_inplace = TRUE;   // assumption!

    if (!m_inplace) {
        // we'll need a pool
        if (!pool || !(pool->Growable()))
            return FALSE;
        m_pool = pool;
        m_pool->AddRef();
    }
	DEBUGMSG(ZONE_NMCAP_CDTOR,("%s: init filter (0x%08lX [CFilterFrame])\r\n", _fx_, this));
    return TRUE;
}


//CConvertFrame internal routines
//CConvertFrame methods
CConvertFrame::~CConvertFrame()
{
    if (m_refdata)
        LocalFree((HANDLE)m_refdata);
}

STDMETHODIMP
CConvertFrame::DoOp(
    IBitmapSurface** ppbs
    )
{
    IBitmapSurface* pBS;

    if (m_convert) {
        m_pool->GetBuffer(&pBS, NULL);
        if (pBS) {
            if (m_convert(*ppbs, pBS, m_refdata)) {
                (*ppbs)->Release();
                *ppbs = pBS;
                return NO_ERROR;
            }
            else {
                pBS->Release();
                return E_FAIL;
            }
        }
        else
            return E_OUTOFMEMORY;
    }
    return E_UNEXPECTED;
}

BOOL
CConvertFrame::InitConverter(
    LPBITMAPINFOHEADER lpbmh,
    FRAMECONVERTPROC *convertproc,
    LPVOID refdata
    )
{
    if (convertproc) {
        if ((m_pool = new CVidPool)) {
            m_pool->AddRef();
            if (m_pool->InitPool(2, lpbmh) == NO_ERROR) {
                m_convert = convertproc;
                m_refdata = refdata;
                return TRUE;
            }
            m_pool->Release();
            m_pool = NULL;
        }
    }
    return FALSE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nac\vidutils.cpp ===
#include "precomp.h"

#define INTEL_PRO 1

#ifdef INTEL_PRO
#define WIDTH 176
#define HEIGHT 144
#define NUMBPP 24
#ifndef _ALPHA_
#define VIDEO_FORMAT VIDEO_FORMAT_MSH263
#else
#define VIDEO_FORMAT VIDEO_FORMAT_DECH263
#endif
#define SIZE_IMAGE 8192
#else
#define WIDTH 160
#define HEIGHT 120
#define NUMBPP 16
#define VIDEO_FORMAT VIDEO_FORMAT_BI_RGB
#define SIZE_IMAGE (WIDTHBYTES(WIDTH * NUMBPP) * HEIGHT)
#endif
#define NUMFPS 7
#define BITRATE (SIZE_IMAGE * NUMFPS)

VIDEOFORMATEX g_vfDefList[DVF_NumOfFormats] =
	{
#if 1
#if 1
        {
		VIDEO_FORMAT,                // dwFormatTag
		NUMFPS,                             // nSamplesPerSec
		BITRATE,                            // nAvgBytesPerSec
		BITRATE,                            // nMinBytesPerSec
		BITRATE,                            // nMaxBytesPerSec
		SIZE_IMAGE,// nBlockAlign
		NUMBPP,                             // wBitsPerSample
		// Temporal fields
		142857UL,                           // dwRequestMicroSecPerFrame
		10UL,                               // dwPersentDropForError
		NUMFPS,                             // dwNumVideoRequested
		1UL,                                // dwSupportTSTradeOff
		TRUE,                               // bLive
		sizeof(VIDEOFORMATEX),              // dwFormatSize
		// Spatial fields (BITMAPINFOHEADER compatible)
			{
			sizeof(BITMAPINFOHEADER),           // bih.biSize
			WIDTH,                              // bih.biWidth
			HEIGHT,                             // bih.biHeight
			1,                                  // bih.biPlanes
			NUMBPP,                             // bih.biBitCount
			VIDEO_FORMAT,                // bih.biCompression
			SIZE_IMAGE,// bih.biSizeImage
			0, 0,                               // bih.bi(X,Y)PelsPerMeter
			0,                                  // bih.biClrUsed
			0                                   // bih.biClrImportant
			}
		}
#else
        {
		VIDEO_FORMAT_BI_RGB,                // dwFormatTag
		NUMFPS,                             // nSamplesPerSec
		BITRATE,                            // nAvgBytesPerSec
		BITRATE,                            // nMinBytesPerSec
		BITRATE,                            // nMaxBytesPerSec
		WIDTHBYTES(WIDTH * NUMBPP) * HEIGHT,// nBlockAlign
		NUMBPP,                             // wBitsPerSample
		// Temporal fields
		142857UL,                           // dwRequestMicroSecPerFrame
		10UL,                               // dwPersentDropForError
		NUMFPS,                             // dwNumVideoRequested
		1UL,                                // dwSupportTSTradeOff
		TRUE,                               // bLive
		sizeof(VIDEOFORMATEX),              // dwFormatSize
		// Spatial fields (BITMAPINFOHEADER compatible)
			{
			sizeof(BITMAPINFOHEADER),           // bih.biSize
			WIDTH,                              // bih.biWidth
			HEIGHT,                             // bih.biHeight
			1,                                  // bih.biPlanes
			NUMBPP,                             // bih.biBitCount
			VIDEO_FORMAT_BI_RGB,                // bih.biCompression
			WIDTHBYTES(WIDTH * NUMBPP) * HEIGHT,// bih.biSizeImage
			0, 0,                               // bih.bi(X,Y)PelsPerMeter
			0,                                  // bih.biClrUsed
			0                                   // bih.biClrImportant
			}
		}
#endif
#else
		{
		// Wave format compatibility fields
		(WORD)0, 7UL, 9600UL, 9600UL, 9600UL, (DWORD)1, (WORD)4,
		// Temporal fields
		142857UL, 10UL, 2UL, 142857UL, TRUE, sizeof(VIDEOFORMATEX),
		// Spatial fields (BITMAPINFOHEADER compatible)
		sizeof(BITMAPINFOHEADER), WIDTH, HEIGHT, 1, 4, BI_RGB, (DWORD)WIDTHBYTES(WIDTH * 4) * HEIGHT, 0, 0, 16, 0
		}
#endif
	};		
#if 0
		// Color information fields (Array of 256 RGBQUAD)
		  0,   0,   0, 0, 255, 255, 255, 0, 238, 238, 238, 0, 221, 221, 221, 0, 204, 204, 204, 0,
		187, 187, 187, 0, 170, 170, 170, 0, 153, 153, 153, 0, 136, 136, 136, 0, 119, 119, 119, 0,
		102, 102, 102, 0,  85,  85,  85, 0,  68,  68,  68, 0,  51,  51,  51, 0,  34,  34,  34, 0,  17,  17,  17, 0
		}
	};
		{  0,   0,   0, 0}, {255, 255, 255, 0}, {238, 238, 238, 0}, {221, 221, 221, 0}, {204, 204, 204, 0},
		{187, 187, 187, 0}, {170, 170, 170, 0}, {153, 153, 153, 0}, {136, 136, 136, 0}, {119, 119, 119, 0},
		{102, 102, 102, 0}, { 85,  85,  85, 0}, { 68,  68,  68, 0}, { 51,  51,  51, 0}, { 34,  34,  34, 0}, { 17,  17,  17, 0}
#endif

VIDEOFORMATEX * GetDefFormat ( int idx )
{
    return ((idx < DVF_NumOfFormats) ?
            (VIDEOFORMATEX *) &g_vfDefList[idx] :
            (VIDEOFORMATEX *) NULL);
}

// Move all this into VideoPacket... same for AudioPacket and utils.c
ULONG GetFormatSize ( PVOID pwf )
{
    return (((VIDEOFORMATEX *) pwf)->dwFormatSize);
}

BOOL IsSameFormat ( PVOID pwf1, PVOID pwf2 )
{
    UINT u1 = GetFormatSize (pwf1);
    UINT u2 = GetFormatSize (pwf2);
    BOOL fSame = FALSE;
	VIDEOFORMATEX *pvfx1 = (VIDEOFORMATEX *)pwf1;
	VIDEOFORMATEX *pvfx2 = (VIDEOFORMATEX *)pwf2;

	// Only compare relevant fields
	if (pvfx1->dwFormatTag != pvfx2->dwFormatTag)
		return FALSE;
	if (pvfx1->nSamplesPerSec != pvfx2->nSamplesPerSec)
		return FALSE;
	if (pvfx1->nAvgBytesPerSec != pvfx2->nAvgBytesPerSec)
		return FALSE;
	if (pvfx1->nMinBytesPerSec != pvfx2->nMinBytesPerSec)
		return FALSE;
	if (pvfx1->nMaxBytesPerSec != pvfx2->nMaxBytesPerSec)
		return FALSE;
	if (pvfx1->nBlockAlign != pvfx2->nBlockAlign)
		return FALSE;
	if (pvfx1->wBitsPerSample != pvfx2->wBitsPerSample)
		return FALSE;
	if (pvfx1->bih.biSize != pvfx2->bih.biSize)
		return FALSE;
	if (pvfx1->bih.biWidth != pvfx2->bih.biWidth)
		return FALSE;
	if (pvfx1->bih.biHeight != pvfx2->bih.biHeight)
		return FALSE;
	if (pvfx1->bih.biPlanes != pvfx2->bih.biPlanes)
		return FALSE;
	if (pvfx1->bih.biBitCount != pvfx2->bih.biBitCount)
		return FALSE;
	if (pvfx1->bih.biCompression != pvfx2->bih.biCompression)
		return FALSE;
	if (pvfx1->bih.biSizeImage != pvfx2->bih.biSizeImage)
		return FALSE;
	if (pvfx1->bih.biClrUsed != pvfx2->bih.biClrUsed)
		return FALSE;

	return TRUE;
}

// Repeat previous frame. This is probably not necessary
// since it is already painted on screen
void CopyPreviousBuf (VIDEOFORMATEX *pwf, PBYTE pb, ULONG cb)
{

	return;

}


// similar to the above "IsSameFormat" call, but similifed to satisfy
// the needs of SendVideoStream::Configure
BOOL IsSimilarVidFormat(VIDEOFORMATEX *pvfx1, VIDEOFORMATEX *pvfx2)
{
	// Only compare relevant fields
	if (pvfx1->bih.biWidth != pvfx2->bih.biWidth)
		return FALSE;
	if (pvfx1->bih.biHeight != pvfx2->bih.biHeight)
		return FALSE;
	if (pvfx1->bih.biCompression != pvfx2->bih.biCompression)
		return FALSE;

	return TRUE;
}


int GetIFrameCaps(IStreamSignal *pStreamSignal)
{
	HRESULT hr;
	PCC_VENDORINFO pLocalVendorInfo, pRemoteVendorInfo;
	int nStringLength20, nStringLength21, nStringLength211, nStringLengthTAPI;
	int nStringLength21sp1;
	bool bIsNetMeeting = false;  // contains NetMeeting in the product string
	char *szProductCompare=NULL;
	char *szVersionCompare=NULL;
	int nLengthProduct, nLengthVersion;
	int nRet = IFRAMES_CAPS_3RDPARTY;

	if (pStreamSignal == NULL)
	{
		return IFRAMES_CAPS_UNKNOWN;
	}

	hr = pStreamSignal->GetVersionInfo(&pLocalVendorInfo, &pRemoteVendorInfo);

	if (FAILED(hr) || (NULL == pRemoteVendorInfo))
	{
		return IFRAMES_CAPS_UNKNOWN;
	}


	// make sure we are dealing with a Microsoft product
	if ((pRemoteVendorInfo->bCountryCode != USA_H221_COUNTRY_CODE) ||
	    (pRemoteVendorInfo->wManufacturerCode != MICROSOFT_H_221_MFG_CODE) ||
	    (pRemoteVendorInfo->pProductNumber == NULL) ||
		(pRemoteVendorInfo->pVersionNumber == NULL)
	   )
	{
		return IFRAMES_CAPS_3RDPARTY;
	}


	// strings aren't guaranteed to be NULL terminated
	// so let's make a quick copy of them that so that we can
	// do easy string comparisons
	nLengthProduct = pRemoteVendorInfo->pProductNumber->wOctetStringLength;
	nLengthVersion = pRemoteVendorInfo->pVersionNumber->wOctetStringLength;

	szProductCompare = new char[nLengthProduct+1];
	szVersionCompare = new char[nLengthVersion+1];

	if ((szProductCompare == NULL) || (szVersionCompare == NULL))
	{
		return IFRAMES_CAPS_3RDPARTY;
	}

	ZeroMemory(szProductCompare, nLengthProduct+1);
	ZeroMemory(szVersionCompare, nLengthVersion+1);
	
	CopyMemory(szProductCompare, pRemoteVendorInfo->pProductNumber->pOctetString, nLengthProduct);
	CopyMemory(szVersionCompare, pRemoteVendorInfo->pVersionNumber->pOctetString, nLengthVersion);

	// a redundant check to make sure that it is indeed a Microsoft product
	if (NULL == _StrStr(szProductCompare, H323_COMPANYNAME_STR))
	{
		return IFRAMES_CAPS_3RDPARTY;
	}


	// quick check to see if this is NetMeeting or something else
	if (NULL != _StrStr(szProductCompare, H323_PRODUCTNAME_SHORT_STR))
	{
		bIsNetMeeting = true;
	}

	// filter out NetMeeting 2.x
	if (bIsNetMeeting)
	{
		if (
		     (0 == lstrcmp(szVersionCompare, H323_20_PRODUCTRELEASE_STR)) ||
		     (0 == lstrcmp(szVersionCompare, H323_21_PRODUCTRELEASE_STR)) ||
		     (0 == lstrcmp(szVersionCompare, H323_211_PRODUCTRELEASE_STR)) ||
		     (0 == lstrcmp(szVersionCompare, H323_21_SP1_PRODUCTRELEASE_STR))
		   )
		{
			delete [] szVersionCompare;
			delete [] szProductCompare;
			return IFRAMES_CAPS_NM2;
		}
	}


	if (bIsNetMeeting == false)
	{
		// filter out TAPI v3.0
		// their version string is "Version 3.0", NetMeeting is "3.0"
		if (0 == lstrcmp(szVersionCompare, H323_TAPI30_PRODUCTRELEASE_STR))
		{
			delete [] szVersionCompare;
			delete [] szProductCompare;
			return IFRAMES_CAPS_3RDPARTY;
		}

		// a Microsoft product that isn't TAPI 3.0 or NetMeeting ?
		// assume compliance with the I-Frames stuff
		DEBUGMSG (ZONE_IFRAME, ("Microsoft H.323 product that isn't NetMeeting !\r\n"));
		DEBUGMSG (ZONE_IFRAME, ("Assuming that that remote knows about I-Frames!\r\n"));
	}

	delete [] szVersionCompare;
	delete [] szProductCompare;

	// must be NetMeeting 3.0, TAPI 3.1, or later
	return IFRAMES_CAPS_NM3;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nmcap\capture.cpp ===
#include <objbase.h>
#include <qos.h>
#include <winsock2.h>
#define INITGUID        // Only do this in one file
#include "capture.h"
#include "frameop.h"
#include "filters.h"
#include <confdbg.h>
#include <avutil.h>
#include "..\nac\utils.h"
#include "vidinout.h"
#include "vcmstrm.h"

CCaptureChain::CCaptureChain(void)
{
    m_opchain = NULL;
    m_filterchain = NULL;
    m_filtertags = NULL;
    InitializeCriticalSection(&m_capcs);
}

CCaptureChain::~CCaptureChain(void)
{
    CFrameOp *pchain;

    EnterCriticalSection(&m_capcs);
    pchain = m_opchain;
    m_opchain = NULL;
    LeaveCriticalSection(&m_capcs);
    if (pchain)
        pchain->Release();
    DeleteCriticalSection(&m_capcs);
}


STDMETHODIMP
CCaptureChain::GrabFrame(
    IBitmapSurface** ppBS
    )
{
    CFrameOp *cfo;
    HRESULT hres;

    *ppBS = NULL;
    EnterCriticalSection(&m_capcs);
    if (m_opchain) {
        m_opchain->AddRef();   // lock chain - prevents chain from being released
        cfo = m_opchain;
        while (cfo && ((hres = cfo->DoOp(ppBS)) == NOERROR)) {
            cfo = cfo->m_next;
        }
        if (*ppBS && hres != NOERROR) {
            // failed conversion, so discard last pBSin frame
            (*ppBS)->Release();
            *ppBS = NULL;
        }
        m_opchain->Release();   // unlock chain
    }
    else
        hres = E_UNEXPECTED;

    LeaveCriticalSection(&m_capcs);
    return hres;
}


typedef struct _CONVERTINFO
{
    long ci_width;
    long ci_height;
    long ci_dstwidth;
    long ci_dstheight;
    long ci_delta;
    long ci_UVDownSampling;
    long ci_ZeroingDWORD;
    void (*ci_Copy) (LPBYTE *, LPBYTE *);
    RGBQUAD ci_colortable[1];
} CONVERTINFO, FAR* PCONVERTINFO;

#ifdef ENABLE_ZOOM_CODE
typedef struct _rv
{
    long x_i;
    long p;
    long p1;
} ROW_VALUES;

typedef struct _ZOOMCONVERTINFO
{
    long ci_width;
    long ci_height;
    long ci_dstwidth;
    long ci_dstheight;
    ROW_VALUES *ci_rptr;
    RGBQUAD ci_colortable[1];
} ZOOMCONVERTINFO, FAR* PZOOMCONVERTINFO;
#endif // ENABLE_ZOOM_CODE


// sub worker routines for conversion of RGB16, RGB24 and RGB32 to RGB24
BYTE Byte16[32] = {0,8,16,25,33,41,49,58,66,74,82,91,99,107,115,123,132,140,148,156,165,173,
                   181,189,197,206,214,222,230,239,247,255};

void Copy16(LPBYTE *ppsrc, LPBYTE *ppdst)
{
    DWORD tmp;

    tmp = *(WORD *)(*ppsrc);
    *(*ppdst)++ = Byte16[tmp & 31];            // blue
    *(*ppdst)++ = Byte16[(tmp >> 5) & 31];     // green
    *(*ppdst)++ = Byte16[(tmp >> 10) & 31];    // red
    *ppsrc += 2;
}

void Copy24(LPBYTE *ppsrc, LPBYTE *ppdst)
{
    *(*ppdst)++ = *(*ppsrc)++;   // blue
    *(*ppdst)++ = *(*ppsrc)++;   // green
    *(*ppdst)++ = *(*ppsrc)++;   // red
}

void Copy32(LPBYTE *ppsrc, LPBYTE *ppdst)
{
    *(*ppdst)++ = *(*ppsrc)++;   // blue
    *(*ppdst)++ = *(*ppsrc)++;   // green
    *(*ppdst)++ = *(*ppsrc)++;   // red
    (*ppsrc)++;
}


// worker routine to shrink an RGB16, RGB24 or RGB32 in half (width & height)
//   result is RGB24
BOOL DoHalfSize(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn, pOut;
    long ipitch, opitch;
    long x, y;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &ipitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &opitch);

    ipitch = (ipitch * 2) - (refdata->ci_dstwidth * 2 * refdata->ci_delta);
    opitch -= refdata->ci_dstwidth * 3;      // bytes at end of each row
    pIn = pBits;
    pOut = pCvtBits;
    for (y = 0; y < refdata->ci_dstheight; y++) {
        for (x = 0; x < refdata->ci_dstwidth; x++) {
            refdata->ci_Copy(&pIn, &pOut);
            pIn += refdata->ci_delta;     // skip to next pixel
        }
        pIn += ipitch;          // get to start of row after next
        pOut += opitch;         // get to start of next row
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

// worker routine to shrink an RGB4 in half (width & height)
//   result is RGB24
BOOL DoHalfSize4(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn, pOut;
    long ipitch, opitch;
    long x, y;
    BYTE pixel;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &ipitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &opitch);

    ipitch = (ipitch * 2) - refdata->ci_dstwidth;
    opitch -= refdata->ci_dstwidth * 3;      // bytes at end of each row
    pIn = pBits;
    pOut = pCvtBits;
    for (y = 0; y < refdata->ci_dstheight; y++) {
        for (x = 0; x < refdata->ci_dstwidth; x++) {
            pixel = (*pIn++/16) & 15;
            *pOut++ = refdata->ci_colortable[pixel].rgbBlue;
            *pOut++ = refdata->ci_colortable[pixel].rgbGreen;
            *pOut++ = refdata->ci_colortable[pixel].rgbRed;
        }
        pIn += ipitch;          // get to start of row after next
        pOut += opitch;         // get to start of next row
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

// worker routine to shrink an RGB8 in half (width & height)
//   result is RGB24
BOOL DoHalfSize8(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn, pOut;
    long ipitch, opitch;
    long x, y;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &ipitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &opitch);

    ipitch = (ipitch * 2) - refdata->ci_dstwidth * 2;
    opitch -= refdata->ci_dstwidth * 3;      // bytes at end of each row
    pIn = pBits;
    pOut = pCvtBits;
    for (y = 0; y < refdata->ci_dstheight; y++) {
        for (x = 0; x < refdata->ci_dstwidth; x++) {
            *pOut++ = refdata->ci_colortable[*pIn].rgbBlue;
            *pOut++ = refdata->ci_colortable[*pIn].rgbGreen;
            *pOut++ = refdata->ci_colortable[*pIn].rgbRed;
            pIn += 2;
        }
        pIn += ipitch;          // get to start of row after next
        pOut += opitch;         // get to start of next row
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

// worker routine to shrink a YVU9 or YUV12 in half (width & height)
//   result is YVU9 or YUV12
BOOL DoHalfSizeYUVPlanar(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn, pIn2, pOut;
    long pitch;
    long x, y, w, h;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &pitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &pitch);

	// Do the Y component first
	pitch = refdata->ci_width * 2 - refdata->ci_dstwidth * 2;   // amount to add for skip
    pIn = pBits;
    pOut = pCvtBits;
    for (y = 0; y < refdata->ci_dstheight; y++) {
        for (x = 0; x < refdata->ci_dstwidth; x++) {
            *pOut++ = *pIn++;
            pIn++;              // skip to next pixel
        }
        pIn += pitch;           // get to start of row after next
    }
    // if source height is odd, then we've added 1 line too many onto pIn
    if (refdata->ci_height & 1)
        pIn -= refdata->ci_width;

    // Do the first color component next
    h = refdata->ci_dstheight / refdata->ci_UVDownSampling;
    w = refdata->ci_dstwidth / refdata->ci_UVDownSampling;
    pitch = refdata->ci_width / refdata->ci_UVDownSampling * 2 - w * 2;
    pIn2 = pIn + refdata->ci_width / refdata->ci_UVDownSampling;
    for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
            *pOut++ = (*pIn++ + *(++pIn) + *pIn2++ + *(++pIn2)) / 4;
        }
        pIn += pitch;           // get to start of row after next
        pIn2 += pitch;          // get to start of row after next
    }
    // if source height is odd, then we've added 1 line too many onto pIn
    if (refdata->ci_height & 1)
        pIn -= refdata->ci_width / refdata->ci_UVDownSampling;
    
    // Do the second color component next
    pIn2 = pIn + refdata->ci_width / refdata->ci_UVDownSampling;
    for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
            *pOut++ = (*pIn++ + *(++pIn) + *pIn2++ + *(++pIn2)) / 4;
        }
        pIn += pitch;           // get to start of row after next
        pIn2 += pitch;          // get to start of row after next
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

// worker routine to shrink a YUV packed DIB in half (width & height)
//   result is YUY2, or UYVY
BOOL DoHalfSizeYUVPacked(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits;
	LPDWORD pIn, pOut;
    long ipitch, opitch;
    long x, y;
    long prelines, postlines, prebytes, postbytes, ibytes, obytes;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &ipitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &opitch);

    pIn = (LPDWORD)pBits;
    pOut = (LPDWORD)pCvtBits;

    // copy one line out of two
    for (y = 0; y < refdata->ci_dstheight; y++) {
		// copy one pixel out of two
        for (x = 0; x < refdata->ci_dstwidth / 2; x++) {
            *pOut++ = *pIn++;
            pIn++;              // skip to next pixel
        }
        pIn += refdata->ci_width / 2;              // skip to next line
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);

    return TRUE;
}

// worker routine to shrink an RGB16, RGB24 or RGB32 by cropping
//   result is RGB24
BOOL Crop(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn, pOut;
    long ipitch, opitch;
    long extra, x, y;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &ipitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &opitch);

    pOut = pCvtBits;

    // pIn starts by skipping half of the height change
    pIn = pBits + (refdata->ci_height - refdata->ci_dstheight) / 2 * ipitch;

    // extra = # of source bytes per scan line that are to be cropped
    extra = (refdata->ci_width - refdata->ci_dstwidth) * refdata->ci_delta;

    // advance pIn by half of extra to crop left most pixels
    pIn += extra / 2;

    // adjust ipitch so we can add it at the end of each scan to get to start of next scan
    ipitch = ipitch - (refdata->ci_width * refdata->ci_delta) + extra;
    opitch -= refdata->ci_dstwidth * 3;      // bytes at end of each row

    for (y = 0; y < refdata->ci_dstheight; y++) {
        for (x = 0; x < refdata->ci_dstwidth; x++) {
            refdata->ci_Copy(&pIn, &pOut);
        }
        pIn += ipitch;          // get to start of next row
        pOut += opitch;         // get to start of next row
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

// worker routine to shrink an RGB4 by cropping
//   result is RGB24
BOOL Crop4(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn, pOut;
    long ipitch, opitch;
    long extra, x, y;
    BYTE val, pixel;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &ipitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &opitch);

    pOut = pCvtBits;

    // pIn starts by skipping half of the height change
    pIn = pBits + (refdata->ci_height - refdata->ci_dstheight) / 2 * ipitch;

    // extra = # of source bytes per scan line that are to be cropped
    extra = (refdata->ci_width - refdata->ci_dstwidth) / 2;

    // advance pIn by half of extra to crop left most pixels
    pIn += extra / 2;

    // adjust ipitch so we can add it at the end of each scan to get to start of next scan
    ipitch = ipitch - (refdata->ci_width / 2) + extra;
    opitch -= refdata->ci_dstwidth * 3;      // bytes at end of each row

    for (y = 0; y < refdata->ci_dstheight; y++) {
        for (x = 0; x < refdata->ci_dstwidth/2; x++) {
            val = *pIn++;
            pixel = (val/16) & 15;
            *pOut++ = refdata->ci_colortable[pixel].rgbBlue;
            *pOut++ = refdata->ci_colortable[pixel].rgbGreen;
            *pOut++ = refdata->ci_colortable[pixel].rgbRed;
            pixel = val & 15;
            *pOut++ = refdata->ci_colortable[pixel].rgbBlue;
            *pOut++ = refdata->ci_colortable[pixel].rgbGreen;
            *pOut++ = refdata->ci_colortable[pixel].rgbRed;
        }
        pIn += ipitch;          // get to start of next row
        pOut += opitch;         // get to start of next row
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

// worker routine to shrink an RGB8 by cropping
//   result is RGB24
BOOL Crop8(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn, pOut;
    long ipitch, opitch;
    long extra, x, y;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &ipitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &opitch);

    pOut = pCvtBits;

    // pIn starts by skipping half of the height change
    pIn = pBits + (refdata->ci_height - refdata->ci_dstheight) / 2 * ipitch;

    // extra = # of source bytes per scan line that are to be cropped
    extra = refdata->ci_width - refdata->ci_dstwidth;

    // advance pIn by half of extra to crop left most pixels
    pIn += extra / 2;

    // adjust ipitch so we can add it at the end of each scan to get to start of next scan
    ipitch = ipitch - refdata->ci_width + extra;
    opitch -= refdata->ci_dstwidth * 3;      // bytes at end of each row

    for (y = 0; y < refdata->ci_dstheight; y++) {
        for (x = 0; x < refdata->ci_dstwidth; x++) {
            *pOut++ = refdata->ci_colortable[*pIn].rgbBlue;
            *pOut++ = refdata->ci_colortable[*pIn].rgbGreen;
            *pOut++ = refdata->ci_colortable[*pIn++].rgbRed;
        }
        pIn += ipitch;          // get to start of next row
        pOut += opitch;         // get to start of next row
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

// worker routine to shrink a YVU9 or YUV12 by cropping
//   result is YVU9 or YUV12
BOOL CropYUVPlanar(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn, pOut;
    long pitch, prelines, bytes, prebytes;
    long extra, y;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &pitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &pitch);

    pOut = pCvtBits;

    // pIn starts by skipping half of the height change
    prelines = ((refdata->ci_height - refdata->ci_dstheight) >> 1) / refdata->ci_UVDownSampling * refdata->ci_UVDownSampling;
    pIn = pBits + prelines * refdata->ci_width;

    // extra = # of source bytes per scan line that are to be cropped
    extra = refdata->ci_width - refdata->ci_dstwidth;
    prebytes = (extra >> 1) / refdata->ci_UVDownSampling * refdata->ci_UVDownSampling;

    // advance pIn by half of extra to crop left most pixels
    pIn += prebytes;

	// Do the Y component first
	pitch = extra + refdata->ci_dstwidth;
    for (y = 0; y < refdata->ci_dstheight; y++) {
        CopyMemory (pOut, pIn, refdata->ci_dstwidth);
        pIn += pitch;
        pOut += refdata->ci_dstwidth;
    }

	// Do the first color component next
    prelines /= refdata->ci_UVDownSampling;
    prebytes /= refdata->ci_UVDownSampling;
	pIn = pBits + (refdata->ci_width * refdata->ci_height) +    // skip Y section
	        prelines * refdata->ci_width / refdata->ci_UVDownSampling +  // skip half of the crop lines
	        prebytes;                                           // skip half of the crop pixels

    pitch /= refdata->ci_UVDownSampling;
    bytes = refdata->ci_dstwidth / refdata->ci_UVDownSampling;
	for (y=0; y < refdata->ci_dstheight / refdata->ci_UVDownSampling; y++)
	{
        CopyMemory (pOut, pIn, bytes);
        pIn += pitch;
        pOut += bytes;
	}

	// Do the second color component next
	pIn = pBits + (refdata->ci_width * refdata->ci_height) +    // skip Y section
	        (refdata->ci_width * refdata->ci_height) / (refdata->ci_UVDownSampling * refdata->ci_UVDownSampling) +     // skip first color component section
	        prelines * refdata->ci_width / refdata->ci_UVDownSampling +                  // skip half of the crop lines
	        prebytes;                                           // skip half of the crop pixels
	for (y=0; y < refdata->ci_dstheight / refdata->ci_UVDownSampling; y++)
	{
        CopyMemory (pOut, pIn, bytes);
        pIn += pitch;
        pOut += bytes;
	}

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

// worker routine to shrink a YUV packed DIB by cropping
//   result is YUY2 or UYVY
BOOL CropYUVPacked(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn, pOut;
    long ipitch, opitch;
    long extra, x, y;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &ipitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &opitch);

    pOut = pCvtBits;

    // pIn starts by skipping half of the height change
    pIn = pBits + (refdata->ci_height - refdata->ci_dstheight) * refdata->ci_width * 2;

    // extra = # of source bytes per scan line that are to be cropped
    extra = (refdata->ci_width - refdata->ci_dstwidth) * 2;

    // advance pIn by half of extra to crop left most pixels
    pIn += extra / 2;

    // adjust ipitch so we can add it at the end of each scan to get to start of next scan
    ipitch = refdata->ci_width * 2;
    opitch = refdata->ci_dstwidth * 2;      // bytes at end of each row

    for (y = 0; y < refdata->ci_dstheight; y++) {
        for (x = 0; x < refdata->ci_dstwidth; x++) {
            CopyMemory(pOut, pIn, refdata->ci_dstwidth * 2);
        }
        pIn += ipitch;          // get to start of next row
        pOut += opitch;         // get to start of next row
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

// routine to prepare for calling shrink worker routines
// it allocates and initializes a reference data structure
BOOL
InitShrink(
    LPBITMAPINFOHEADER lpbmhIn,
    long desiredwidth,
    long desiredheight,
    LPBITMAPINFOHEADER *lpbmhOut,
    FRAMECONVERTPROC **convertproc,
    LPVOID *refdata
    )
{
    PCONVERTINFO pcvt;
    DWORD dwSize;
    long crop_ratio, black_ratio, target_size;

    *convertproc = NULL;
    *refdata = NULL;

    if ((lpbmhIn->biCompression != VIDEO_FORMAT_BI_RGB) &&
        (lpbmhIn->biCompression != VIDEO_FORMAT_YVU9) &&
        (lpbmhIn->biCompression != VIDEO_FORMAT_YUY2) &&
        (lpbmhIn->biCompression != VIDEO_FORMAT_UYVY) &&
        (lpbmhIn->biCompression != VIDEO_FORMAT_I420) &&
        (lpbmhIn->biCompression != VIDEO_FORMAT_IYUV))
        return FALSE;

    // calculate size of convertinfo struct, if we need a colortable, then add 256 entries
    // else subtract off the 1 built into the struct definition
    dwSize = sizeof(CONVERTINFO) - sizeof(RGBQUAD);
    if (lpbmhIn->biBitCount <= 8)
        dwSize += 256 * sizeof(RGBQUAD);

    // for RGB, and YUV input formats, we know that the output format will never need
    // an attached color table, so we can allocate lpbmhOut without one
    if ((pcvt = (PCONVERTINFO)LocalAlloc(LPTR, dwSize)) &&
        (*lpbmhOut = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, lpbmhIn->biSize))) {
        CopyMemory(*lpbmhOut, lpbmhIn, lpbmhIn->biSize);
        pcvt->ci_width = lpbmhIn->biWidth;
        pcvt->ci_height = lpbmhIn->biHeight;

        target_size = desiredwidth * desiredheight;
        crop_ratio = pcvt->ci_width * pcvt->ci_height;
        black_ratio = ((target_size - (crop_ratio / 4)) * 100) / target_size;
        crop_ratio = ((crop_ratio - target_size) * 100) / crop_ratio;
        if (crop_ratio < black_ratio) {
            // cropping the source makes more sense
            pcvt->ci_dstwidth = desiredwidth;
            pcvt->ci_dstheight = desiredheight;
            crop_ratio = 1; // flag that we'll crop
        }
        else {
            // halfsizing makes more sense
            pcvt->ci_dstwidth = lpbmhIn->biWidth / 2;
            pcvt->ci_dstheight = lpbmhIn->biHeight / 2;
            crop_ratio = 0; // flag that we'll half size
        }
        (*lpbmhOut)->biWidth = pcvt->ci_dstwidth;
        (*lpbmhOut)->biHeight = pcvt->ci_dstheight;

        // copy colortable from input bitmapinfoheader
        if (lpbmhIn->biBitCount <= 8)
            CopyMemory(&pcvt->ci_colortable[0], (LPBYTE)lpbmhIn + lpbmhIn->biSize, 256 * sizeof(RGBQUAD));

        if (lpbmhIn->biCompression == VIDEO_FORMAT_BI_RGB) {
            (*lpbmhOut)->biBitCount = 24;
            (*lpbmhOut)->biSizeImage = pcvt->ci_dstwidth * pcvt->ci_dstheight * 3;
            if (lpbmhIn->biBitCount == 4) {
                if (crop_ratio)
                    *convertproc = (FRAMECONVERTPROC*)&Crop4;
                else
                    *convertproc = (FRAMECONVERTPROC*)&DoHalfSize4;
            }
            else if (lpbmhIn->biBitCount == 8) {
                if (crop_ratio)
                    *convertproc = (FRAMECONVERTPROC*)&Crop8;
                else
                    *convertproc = (FRAMECONVERTPROC*)&DoHalfSize8;
            }
            else {
                if (crop_ratio)
                    *convertproc = (FRAMECONVERTPROC*)&Crop;
                else
                    *convertproc = (FRAMECONVERTPROC*)&DoHalfSize;
                pcvt->ci_delta = lpbmhIn->biBitCount / 8;
                if (lpbmhIn->biBitCount == 16) {
                    pcvt->ci_Copy = &Copy16;
                }
                else if (lpbmhIn->biBitCount == 24) {
                    pcvt->ci_Copy = &Copy24;
                }
                else if (lpbmhIn->biBitCount == 32) {
                    pcvt->ci_Copy = &Copy32;
                }
            }
        }
        else if (lpbmhIn->biCompression == VIDEO_FORMAT_YVU9) {
            (*lpbmhOut)->biBitCount = lpbmhIn->biBitCount;
            (*lpbmhOut)->biSizeImage = pcvt->ci_dstwidth * pcvt->ci_dstheight + (pcvt->ci_dstwidth * pcvt->ci_dstheight)/8;
            if (crop_ratio)
                *convertproc = (FRAMECONVERTPROC*)&CropYUVPlanar;
            else
                *convertproc = (FRAMECONVERTPROC*)&DoHalfSizeYUVPlanar;
			pcvt->ci_UVDownSampling = 4;
        }
        else if ((lpbmhIn->biCompression == VIDEO_FORMAT_YUY2) || (lpbmhIn->biCompression == VIDEO_FORMAT_UYVY)) {
            (*lpbmhOut)->biBitCount = lpbmhIn->biBitCount;
            (*lpbmhOut)->biSizeImage = (DWORD)WIDTHBYTES(pcvt->ci_dstwidth * lpbmhIn->biBitCount) * pcvt->ci_dstheight;
            if (crop_ratio)
                *convertproc = (FRAMECONVERTPROC*)&CropYUVPacked;
            else
                *convertproc = (FRAMECONVERTPROC*)&DoHalfSizeYUVPacked;
        }
        else if ((lpbmhIn->biCompression == VIDEO_FORMAT_I420) || (lpbmhIn->biCompression == VIDEO_FORMAT_IYUV)) {
            (*lpbmhOut)->biBitCount = lpbmhIn->biBitCount;
            (*lpbmhOut)->biSizeImage = (DWORD)WIDTHBYTES(pcvt->ci_dstwidth * lpbmhIn->biBitCount) * pcvt->ci_dstheight;
            if (crop_ratio)
                *convertproc = (FRAMECONVERTPROC*)&CropYUVPlanar;
            else
                *convertproc = (FRAMECONVERTPROC*)&DoHalfSizeYUVPlanar;
			pcvt->ci_UVDownSampling = 2;
        }

        *refdata = (LPVOID)pcvt;
        return TRUE;
    }
    else {
        if (pcvt)
            LocalFree((HANDLE)pcvt);
    }
    return FALSE;
}

// worker routine to expand an RGB16, RGB24 or RGB32 by copying source into middle of destination
//   result is RGB24
BOOL DoBlackBar(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn, pOut;
    long ipitch, opitch, oextra;
    long x, y;
    long prelines, postlines, prebytes, postbytes, bytes;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &ipitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &opitch);

    prelines = (refdata->ci_dstheight - refdata->ci_height) / 2;
    postlines = refdata->ci_dstheight - refdata->ci_height - prelines;

    prebytes = (refdata->ci_dstwidth - refdata->ci_width) / 2;
    postbytes = (refdata->ci_dstwidth - refdata->ci_width - prebytes) * 3;
    prebytes *= 3;

    ipitch -= refdata->ci_width * refdata->ci_delta;        // bytes at end of each src row
    bytes = refdata->ci_dstwidth * 3;
    oextra = opitch - bytes + postbytes;                    // bytes at end of each dst row
    
    pIn = pBits;
    pOut = pCvtBits;

    // do blank lines at front of destination
    for (y = 0; y < prelines; y++) {
        ZeroMemory (pOut, bytes);
        pOut += opitch;
    }

    // copy source lines with blank space at front and rear        
    for (y = 0; y < refdata->ci_height; y++) {
        ZeroMemory (pOut, prebytes);
        pOut += prebytes;

        for (x = 0; x < refdata->ci_width; x++) {
            refdata->ci_Copy(&pIn, &pOut);
        }

        ZeroMemory (pOut, postbytes);
        pIn += ipitch;
        pOut += oextra;
    }

    // do blank lines at end of destination
    for (y = 0; y < postlines; y++) {
        ZeroMemory (pOut, bytes);
        pOut += opitch;
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

// worker routine to expand an RGB4 by copying source into middle of destination
//   result is RGB24
BOOL DoBlackBar4(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn, pOut;
    long ipitch, opitch, oextra;
    long x, y;
    long prelines, postlines, prebytes, postbytes, bytes;
    BYTE val, pixel;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &ipitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &opitch);

    prelines = (refdata->ci_dstheight - refdata->ci_height) / 2;
    postlines = refdata->ci_dstheight - refdata->ci_height - prelines;

    prebytes = (refdata->ci_dstwidth - refdata->ci_width) / 2;
    postbytes = (refdata->ci_dstwidth - refdata->ci_width - prebytes) * 3;
    prebytes *= 3;

    ipitch -= refdata->ci_width/2;          // bytes at end of each src row
    bytes = refdata->ci_dstwidth * 3;
    oextra = opitch - bytes + postbytes;    // bytes at end of each dst row
    
    pIn = pBits;
    pOut = pCvtBits;

    // do blank lines at front of destination
    for (y = 0; y < prelines; y++) {
        ZeroMemory (pOut, bytes);
        pOut += opitch;
    }

    // copy source lines with blank space at front and rear        
    for (y = 0; y < refdata->ci_height; y++) {
        ZeroMemory (pOut, prebytes);
        pOut += prebytes;

        for (x = 0; x < refdata->ci_width/2; x++) {
            val = *pIn++;
            pixel = (val/16) & 15;
            *pOut++ = refdata->ci_colortable[pixel].rgbBlue;
            *pOut++ = refdata->ci_colortable[pixel].rgbGreen;
            *pOut++ = refdata->ci_colortable[pixel].rgbRed;
            pixel = val & 15;
            *pOut++ = refdata->ci_colortable[pixel].rgbBlue;
            *pOut++ = refdata->ci_colortable[pixel].rgbGreen;
            *pOut++ = refdata->ci_colortable[pixel].rgbRed;
        }

        ZeroMemory (pOut, postbytes);
        pIn += ipitch;
        pOut += oextra;
    }

    // do blank lines at end of destination
    for (y = 0; y < postlines; y++) {
        ZeroMemory (pOut, bytes);
        pOut += opitch;
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

// worker routine to expand an RGB8 by copying source into middle of destination
//   result is RGB24
BOOL DoBlackBar8(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn, pOut;
    long ipitch, opitch, oextra;
    long x, y;
    long prelines, postlines, prebytes, postbytes, bytes;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &ipitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &opitch);

    prelines = (refdata->ci_dstheight - refdata->ci_height) / 2;
    postlines = refdata->ci_dstheight - refdata->ci_height - prelines;

    prebytes = (refdata->ci_dstwidth - refdata->ci_width) / 2;
    postbytes = (refdata->ci_dstwidth - refdata->ci_width - prebytes) * 3;
    prebytes *= 3;

    ipitch -= refdata->ci_width;                // bytes at end of each src row
    bytes = refdata->ci_dstwidth * 3;
    oextra = opitch - bytes + postbytes;        // bytes at end of each dst row
    
    pIn = pBits;
    pOut = pCvtBits;

    // do blank lines at front of destination
    for (y = 0; y < prelines; y++) {
        ZeroMemory (pOut, bytes);
        pOut += opitch;
    }

    // copy source lines with blank space at front and rear        
    for (y = 0; y < refdata->ci_height; y++) {
        ZeroMemory (pOut, prebytes);
        pOut += prebytes;

        for (x = 0; x < refdata->ci_width; x++) {
            *pOut++ = refdata->ci_colortable[*pIn].rgbBlue;
            *pOut++ = refdata->ci_colortable[*pIn].rgbGreen;
            *pOut++ = refdata->ci_colortable[*pIn++].rgbRed;
        }

        ZeroMemory (pOut, postbytes);
        pIn += ipitch;
        pOut += oextra;
    }

    // do blank lines at end of destination
    for (y = 0; y < postlines; y++) {
        ZeroMemory (pOut, bytes);
        pOut += opitch;
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

// worker routine to expand a YVU9 or YUV12 by copying source into middle of destination
//   result is YVU9 or YUV12
BOOL DoBlackBarYUVPlanar(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits;
    LONG prelines, postlines, bytesperpixel, prebytes, postbytes, y, bytes;
    LONG prelinebytes, postlinebytes;
    LPBYTE lpsrc, lpdst;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &bytes);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &bytes);

	lpsrc = pBits;
	lpdst = pCvtBits;

	// Do the Y component first
    prelines = ((refdata->ci_dstheight - refdata->ci_height) / (refdata->ci_UVDownSampling << 1)) * refdata->ci_UVDownSampling;
    postlines = refdata->ci_dstheight - refdata->ci_height - prelines;

    prebytes = ((refdata->ci_dstwidth - refdata->ci_width) / (refdata->ci_UVDownSampling << 1)) * refdata->ci_UVDownSampling;
    postbytes = (refdata->ci_dstwidth - refdata->ci_width - prebytes);

    bytes = prelines * refdata->ci_dstwidth + prebytes;
    FillMemory (lpdst, bytes, 0x10);
    lpdst += bytes;

	bytes = refdata->ci_width;
    prebytes += postbytes;
	for (y=0; y < refdata->ci_height; y++)
	{
        MoveMemory (lpdst, lpsrc, bytes);
        lpsrc += bytes;
        lpdst += bytes;
        FillMemory (lpdst, prebytes, 0x10);
        lpdst += prebytes;
	}

	// already filled the prebytes of the first postline in loop above
	prebytes -= postbytes;
	bytes = postlines * refdata->ci_dstwidth - prebytes;
	FillMemory (lpdst, bytes, (BYTE)0x10);
	lpdst += bytes;

	// Do the first color component next
    prelines /= refdata->ci_UVDownSampling;
    postlines = refdata->ci_dstheight / refdata->ci_UVDownSampling - refdata->ci_height / refdata->ci_UVDownSampling - prelines;

    prebytes = prebytes / refdata->ci_UVDownSampling;
    postbytes = refdata->ci_dstwidth / refdata->ci_UVDownSampling - refdata->ci_width / refdata->ci_UVDownSampling - prebytes;

    prelinebytes = prelines * refdata->ci_dstwidth / refdata->ci_UVDownSampling + prebytes;
    FillMemory (lpdst, prelinebytes, 0x80);
    lpdst += prelinebytes;
    
	bytes = refdata->ci_width / refdata->ci_UVDownSampling;
    prebytes += postbytes;
	for (y=0; y < refdata->ci_height / refdata->ci_UVDownSampling; y++)
	{
        MoveMemory (lpdst, lpsrc, bytes);
        lpsrc += bytes;
        lpdst += bytes;
        FillMemory (lpdst, prebytes, 0x80);
        lpdst += prebytes;
	}

	// already filled the prebytes of the first postline in loop above
	postlinebytes = postlines * refdata->ci_dstwidth / refdata->ci_UVDownSampling - (prebytes - postbytes);
	FillMemory (lpdst, postlinebytes, 0x80);
	lpdst += postlinebytes;
	
	// Do the second color component next
    FillMemory (lpdst, prelinebytes, 0x80);
    lpdst += prelinebytes;    
	for (y=0; y < refdata->ci_height / refdata->ci_UVDownSampling; y++)
	{
        MoveMemory (lpdst, lpsrc, bytes);
        lpsrc += bytes;
        lpdst += bytes;
        FillMemory (lpdst, prebytes, 0x80);
        lpdst += prebytes;
	}
	FillMemory (lpdst, postlinebytes, 0x80);

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

// worker routine to expand a YUV packed DIB by copying source into middle of destination
//   result is YUY2 or UYVY
BOOL DoBlackBarYUVPacked(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn, pOut;
    long ipitch, opitch;
    long x, y;
    long prelines, postlines, prebytes, postbytes, ibytes, obytes;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &ipitch);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &opitch);

    prelines = (refdata->ci_dstheight - refdata->ci_height) / 2;
    postlines = refdata->ci_dstheight - refdata->ci_height - prelines;

    prebytes = (refdata->ci_dstwidth - refdata->ci_width) / 2;
    postbytes = (refdata->ci_dstwidth - refdata->ci_width - prebytes) / 2;
    prebytes /= 2;

    ibytes = refdata->ci_width * 2;
    obytes = refdata->ci_dstwidth / 2;
    
    pIn = pBits;
    pOut = pCvtBits;

    // do blank lines at front of destination
    for (y = 0; y < prelines; y++) {
		for (x = 0; x < obytes; x++) {
			*(DWORD *)pOut = refdata->ci_ZeroingDWORD;
			pOut += sizeof(DWORD);
		}
    }

    // copy source lines with blank space at front and rear        
    for (y = 0; y < refdata->ci_height; y++) {
		for (x = 0; x < prebytes; x++) {
			*(DWORD *)pOut = refdata->ci_ZeroingDWORD;
			pOut += sizeof(DWORD);
		}

        CopyMemory(pOut, pIn, ibytes);
		pOut += ibytes;
		pIn += ibytes;

		for (x = 0; x < postbytes; x++) {
			*(DWORD *)pOut = refdata->ci_ZeroingDWORD;
			pOut += sizeof(DWORD);
		}
    }

    // do blank lines at end of destination
    for (y = 0; y < postlines; y++) {
		for (x = 0; x < obytes; x++) {
			*(DWORD *)pOut = refdata->ci_ZeroingDWORD;
			pOut += sizeof(DWORD);
		}
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);

    return TRUE;
}

// routine to prepare for calling blackbar worker routines
// it allocates and initializes a reference data structure
BOOL
InitBlackbar(
    LPBITMAPINFOHEADER lpbmhIn,
    long desiredwidth,
    long desiredheight,
    LPBITMAPINFOHEADER *lpbmhOut,
    FRAMECONVERTPROC **convertproc,
    LPVOID *refdata
    )
{
    PCONVERTINFO pcvt;
    DWORD dwSize;

    *convertproc = NULL;
    *refdata = NULL;

    if ((lpbmhIn->biCompression != VIDEO_FORMAT_BI_RGB) &&
        (lpbmhIn->biCompression != VIDEO_FORMAT_YVU9) &&
        (lpbmhIn->biCompression != VIDEO_FORMAT_YUY2) &&
        (lpbmhIn->biCompression != VIDEO_FORMAT_UYVY) &&
        (lpbmhIn->biCompression != VIDEO_FORMAT_I420) &&
        (lpbmhIn->biCompression != VIDEO_FORMAT_IYUV))
        return FALSE;

    // calculate size of convertinfo struct, if we need a colortable, then add 256 entries
    // else subtract off the 1 built into the struct definition
    dwSize = sizeof(CONVERTINFO) - sizeof(RGBQUAD);
    if (lpbmhIn->biBitCount <= 8)
        dwSize += 256 * sizeof(RGBQUAD);

    // for RGB, YUV input formats, we know that the output format will never need
    // an attached color table, so we can allocate lpbmhOut without one
    if ((pcvt = (PCONVERTINFO)LocalAlloc(LPTR, dwSize)) &&
        (*lpbmhOut = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, lpbmhIn->biSize))) {
        CopyMemory(*lpbmhOut, lpbmhIn, lpbmhIn->biSize);
        pcvt->ci_width = lpbmhIn->biWidth;
        pcvt->ci_height = lpbmhIn->biHeight;
        pcvt->ci_dstwidth = desiredwidth;
        pcvt->ci_dstheight = desiredheight;
        (*lpbmhOut)->biWidth = desiredwidth;
        (*lpbmhOut)->biHeight = desiredheight;

        // copy colortable from input bitmapinfoheader
        if (lpbmhIn->biBitCount <= 8)
            CopyMemory(&pcvt->ci_colortable[0], (LPBYTE)lpbmhIn + lpbmhIn->biSize, 256 * sizeof(RGBQUAD));

        if (lpbmhIn->biCompression == VIDEO_FORMAT_BI_RGB) {
            (*lpbmhOut)->biBitCount = 24;
            (*lpbmhOut)->biSizeImage = desiredwidth * desiredheight * 3;

            if (lpbmhIn->biBitCount == 4) {
                *convertproc = (FRAMECONVERTPROC*)&DoBlackBar4;
            }
            else if (lpbmhIn->biBitCount == 8) {
                *convertproc = (FRAMECONVERTPROC*)&DoBlackBar8;
            }
            else {
                *convertproc = (FRAMECONVERTPROC*)&DoBlackBar;
                pcvt->ci_delta = lpbmhIn->biBitCount / 8;
                if (lpbmhIn->biBitCount == 16) {
                    pcvt->ci_Copy = &Copy16;
                }
                else if (lpbmhIn->biBitCount == 24) {
                    pcvt->ci_Copy = &Copy24;
                }
                else if (lpbmhIn->biBitCount == 32) {
                    pcvt->ci_Copy = &Copy32;
                }
            }
        }
        else if (lpbmhIn->biCompression == VIDEO_FORMAT_YVU9) {
            (*lpbmhOut)->biBitCount = lpbmhIn->biBitCount;
            (*lpbmhOut)->biSizeImage = desiredwidth * desiredheight + (desiredwidth * desiredheight)/8;
            *convertproc = (FRAMECONVERTPROC*)&DoBlackBarYUVPlanar;
			pcvt->ci_UVDownSampling = 4;
        }
        else if (lpbmhIn->biCompression == VIDEO_FORMAT_YUY2) {
            (*lpbmhOut)->biBitCount = lpbmhIn->biBitCount;
            (*lpbmhOut)->biSizeImage = (DWORD)WIDTHBYTES(desiredwidth * lpbmhIn->biBitCount) * desiredheight;
			pcvt->ci_ZeroingDWORD = 0x80108010;
            *convertproc = (FRAMECONVERTPROC*)&DoBlackBarYUVPacked;
        }
        else if (lpbmhIn->biCompression == VIDEO_FORMAT_UYVY) {
            (*lpbmhOut)->biBitCount = lpbmhIn->biBitCount;
            (*lpbmhOut)->biSizeImage = (DWORD)WIDTHBYTES(desiredwidth * lpbmhIn->biBitCount) * desiredheight;
			pcvt->ci_ZeroingDWORD = 0x10801080;
            *convertproc = (FRAMECONVERTPROC*)&DoBlackBarYUVPacked;
        }
        else if ((lpbmhIn->biCompression == VIDEO_FORMAT_I420) || (lpbmhIn->biCompression == VIDEO_FORMAT_IYUV)) {
            (*lpbmhOut)->biBitCount = lpbmhIn->biBitCount;
            (*lpbmhOut)->biSizeImage = (DWORD)WIDTHBYTES(desiredwidth * lpbmhIn->biBitCount) * desiredheight;
            *convertproc = (FRAMECONVERTPROC*)&DoBlackBarYUVPlanar;
			pcvt->ci_UVDownSampling = 2;
        }

        *refdata = (LPVOID)pcvt;
        return TRUE;
    }
    else {
        if (pcvt)
            LocalFree((HANDLE)pcvt);
    }
    return FALSE;
}


#ifdef ENABLE_ZOOM_CODE
BOOL Zoom4(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PZOOMCONVERTINFO refdata
    )
{
    return FALSE;
}

BOOL Zoom8(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PZOOMCONVERTINFO refdata
    )
{
    return FALSE;
}

BOOL Zoom16(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PZOOMCONVERTINFO refdata
    )
{
    return FALSE;
}

BOOL Zoom24(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PZOOMCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn1, pIn2, pTmp, pOut;
    ROW_VALUES *rptr;
    long i, j, yfac_inv, src_y, src_y_i, q, q1;
    long a;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &i);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &i);

    pOut = pCvtBits;

    yfac_inv = refdata->ci_height * 256 / refdata->ci_dstheight;

    for (i = 0; i < refdata->ci_dstheight; i++) {
        src_y = i * yfac_inv;
        src_y_i = src_y / 256;
        q = src_y - src_y_i * 256;
        q1 = 256 - q;
        rptr = refdata->ci_rptr;

        pIn1 = pBits + src_y_i * refdata->ci_width * 3;
        pIn2 = pIn1 + refdata->ci_width * 3;
        for (j = 0; j < refdata->ci_dstwidth; j++, rptr++) {
            a = rptr->x_i * 3;
            pIn1 += a;
            pIn2 += a;
            a = (((*pIn1) * rptr->p1 + (*(pIn1+3)) * rptr->p) * q1 +
                   ((*pIn2) * rptr->p1 + (*(pIn2+3)) * rptr->p) * q) / 256 / 256;
            if (a > 256) a = 255;
            *pOut++ = (BYTE)a;                  // blue
            pIn1++;
            pIn2++;

            a = (((*pIn1) * rptr->p1 + (*(pIn1+3)) * rptr->p) * q1 +
                   ((*pIn2) * rptr->p1 + (*(pIn2+3)) * rptr->p) * q) / 256 / 256;
            if (a > 256) a = 255;
            *pOut++ = (BYTE)a;                  // green
            pIn1++;
            pIn2++;

            a = (((*pIn1) * rptr->p1 + (*(pIn1+3)) * rptr->p) * q1 +
                   ((*pIn2) * rptr->p1 + (*(pIn2+3)) * rptr->p) * q) / 256 / 256;
            if (a > 256) a = 255;
            *pOut++ = (BYTE)a;                  // red
            pIn1 -= 2;
            pIn2 -= 2;
        }        
    }


    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

BOOL ZoomYVU9(
    IBitmapSurface* pbsIn,
    IBitmapSurface* pbsOut,
    PZOOMCONVERTINFO refdata
    )
{
    LPBYTE pBits, pCvtBits, pIn1, pIn2, pOut, pOut2, pU1;
    ROW_VALUES *rptr;
    long i, j, yfac_inv, src_y, src_y_i, q, q1;
    long a, b, c, d;

    pbsIn->LockBits(NULL, 0, (void**)&pBits, &i);
    pbsOut->LockBits(NULL, 0, (void**)&pCvtBits, &i);

    pOut = pCvtBits;

    yfac_inv = refdata->ci_height * 256 / refdata->ci_dstheight;

    // Do the Y component first as a bilinear zoom
    for (i = 0; i < refdata->ci_dstheight; i++) {
        src_y = i * yfac_inv;
        src_y_i = src_y / 256;
        q = src_y - src_y_i * 256;
        q1 = 256 - q;
        rptr = refdata->ci_rptr;

        pIn1 = pBits + src_y_i * refdata->ci_width;
        pIn2 = pIn1 + refdata->ci_width;
        for (j = 0; j < refdata->ci_dstwidth; j++, rptr++) {
            pIn1 += rptr->x_i;
            pIn2 += rptr->x_i;
            a = *pIn1;
            b = *(pIn1+1);
            c = *pIn2;
            d = *(pIn2+1);
            a = ((a * rptr->p1 + b * rptr->p) * q1 +
                (c * rptr->p1 + d * rptr->p) * q) / 256 / 256;
            if (a > 256) a = 255;
            *pOut++ = (BYTE)a;
        }        
    }

    // Do the V and U components next as a nearest neighbor zoom
    pIn1 = pBits + refdata->ci_width * refdata->ci_height;      // start of source V table
    pU1 = pIn1 + (refdata->ci_width * refdata->ci_height) / 16; // start of source U table
    pOut2 = pOut + (refdata->ci_dstwidth * refdata->ci_dstheight) / 16; // start of dest U table
    src_y = 0;
    for (i = 0; i < refdata->ci_dstheight; i += 4) {
        src_y_i = (i * yfac_inv) / 256 / 4;
        d = (src_y_i - src_y) * refdata->ci_width / 4;
        pIn1 += d;
        pU1 += d;
        src_y = src_y_i;

        a = 0;
        rptr = refdata->ci_rptr;
        for (j = 0; j < refdata->ci_dstwidth/4; j++) {
            *pOut++ = *(pIn1+a/4);
            *pOut2++ = *(pU1+a/4);

            a += rptr->x_i;
            rptr++;
            a += rptr->x_i;
            rptr++;
            a += rptr->x_i;
            rptr++;
            a += rptr->x_i;
            rptr++;
        }
    }

    pbsIn->UnlockBits(NULL, pBits);
    pbsOut->UnlockBits(NULL, pCvtBits);
    return TRUE;
}

BOOL
InitScale(
    LPBITMAPINFOHEADER lpbmhIn,
    long desiredwidth,
    long desiredheight,
    LPBITMAPINFOHEADER *lpbmhOut,
    FRAMECONVERTPROC **convertproc,
    LPVOID *refdata
    )
{
    PZOOMCONVERTINFO pcvt;
    DWORD dwSize, dwBaseSize;
    ROW_VALUES *rptr;
    long i, x, xfac_inv, x_i_last, tmp;

    *convertproc = NULL;
    *refdata = NULL;

    if ((lpbmhIn->biCompression != VIDEO_FORMAT_BI_RGB) &&
        (lpbmhIn->biCompression != VIDEO_FORMAT_YVU9))
        return FALSE;

    // calculate size of zoomconvertinfo struct, if we need a colortable, then add 256 entries
    // else subtract off the 1 built into the struct definition
    dwBaseSize = sizeof(ZOOMCONVERTINFO) - sizeof(RGBQUAD);
    if (lpbmhIn->biBitCount <= 8)
        dwBaseSize += 256 * sizeof(RGBQUAD);

    dwSize = dwBaseSize + desiredwidth * sizeof(ROW_VALUES);

    // for RGB and YVU9 input formats, we know that the output format will never need
    // an attached color table, so we can allocate lpbmhOut without one
    if ((pcvt = (PZOOMCONVERTINFO)LocalAlloc(LPTR, dwSize)) &&
        (*lpbmhOut = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, lpbmhIn->biSize))) {
        CopyMemory(*lpbmhOut, lpbmhIn, lpbmhIn->biSize);
        pcvt->ci_width = lpbmhIn->biWidth;
        pcvt->ci_height = lpbmhIn->biHeight;
        pcvt->ci_dstwidth = desiredwidth;
        pcvt->ci_dstheight = desiredheight;
        (*lpbmhOut)->biWidth = desiredwidth;
        (*lpbmhOut)->biHeight = desiredheight;

        pcvt->ci_rptr = (ROW_VALUES *)(((BYTE *)pcvt) + dwBaseSize);
        rptr = pcvt->ci_rptr;
        xfac_inv = lpbmhIn->biWidth * 256 / desiredwidth;
        x_i_last = 0;
        for (i = 0; i < desiredwidth; i++) {
            x = i * xfac_inv;
            tmp = x / 256;
            rptr->x_i = tmp - x_i_last;
            x_i_last = tmp;
            rptr->p = x - x_i_last * 256;
            rptr->p1 = 256 - rptr->p;
            rptr++;
        }

        // copy colortable from input bitmapinfoheader
        if (lpbmhIn->biBitCount <= 8)
            CopyMemory(&pcvt->ci_colortable[0], (LPBYTE)lpbmhIn + lpbmhIn->biSize, 256 * sizeof(RGBQUAD));

        if (lpbmhIn->biCompression == VIDEO_FORMAT_BI_RGB) {
            (*lpbmhOut)->biBitCount = 24;
            (*lpbmhOut)->biSizeImage = desiredwidth * desiredheight * 3;

            if (lpbmhIn->biBitCount == 4) {
                *convertproc = (FRAMECONVERTPROC*)&Zoom4;
            }
            else if (lpbmhIn->biBitCount == 8) {
                *convertproc = (FRAMECONVERTPROC*)&Zoom8;
            }
            else if (lpbmhIn->biBitCount == 16) {
                *convertproc = (FRAMECONVERTPROC*)&Zoom16;
            }
            else {
                *convertproc = (FRAMECONVERTPROC*)&Zoom24;
            }
        }
        else if (lpbmhIn->biCompression == VIDEO_FORMAT_YVU9) {
            (*lpbmhOut)->biBitCount = lpbmhIn->biBitCount;
            (*lpbmhOut)->biSizeImage = desiredwidth * desiredheight + (desiredwidth * desiredheight)/8;
            *convertproc = (FRAMECONVERTPROC*)&ZoomYVU9;
        }

        *refdata = (LPVOID)pcvt;
        return TRUE;
    }
    else {
        if (pcvt)
            LocalFree((HANDLE)pcvt);
    }
    return FALSE;
}
#endif // ENABLE_ZOOM_CODE

STDMETHODIMP
CCaptureChain::InitCaptureChain(
    HCAPDEV hcapdev,
    BOOL streaming,
	LPBITMAPINFOHEADER lpcap,
    LONG desiredwidth,
    LONG desiredheight,
    DWORD desiredformat,
    LPBITMAPINFOHEADER *plpdsp
    )
{
    CFrameOp *ccf;
    CFrameOp *clast;
    CFilterChain *cfilterchain;
    LPBITMAPINFOHEADER lpcvt;
    DWORD lpcapsize;

	FX_ENTRY("CCaptureChain::InitCaptureChain");

    *plpdsp = NULL;

#ifndef SUPPORT_DESIRED_FORMAT
    if (desiredformat != 0) {
        ERRORMESSAGE(("%s: Invalid desiredformat parameter", _fx_));
        return E_FAIL;
    }
#endif

    if (streaming) {
        if ((ccf = new CStreamCaptureFrame)) {
            ccf->AddRef();
            if (hcapdev && !((CStreamCaptureFrame*)ccf)->InitCapture(hcapdev, lpcap)) {
				ERRORMESSAGE(("%s: Failed to init capture object", _fx_));
                ccf->Release();
                return E_FAIL;
            }
        }
    }
    else {
        if ((ccf = new CCaptureFrame)) {
            ccf->AddRef();
            if (hcapdev && !((CCaptureFrame*)ccf)->InitCapture(hcapdev, lpcap)) {
				ERRORMESSAGE(("%s: Failed to init capture object", _fx_));
                ccf->Release();
                return E_FAIL;
            }
        }
    }

    if (!ccf) {
		ERRORMESSAGE(("%s: Failed to alloc capture object", _fx_));
        return E_OUTOFMEMORY;
    }
    clast = ccf;

    lpcapsize = lpcap->biSize;
    if (lpcap->biBitCount <= 8)
        lpcapsize += 256 * sizeof(RGBQUAD);

#if 0
    if ((lpcap->biCompression != BI_RGB) &&
        (lpcap->biCompression != VIDEO_FORMAT_YVU9) &&
        (lpcap->biCompression != VIDEO_FORMAT_INTELI420)) {
#else
    if ((lpcap->biCompression != BI_RGB) &&
        (lpcap->biCompression != VIDEO_FORMAT_YVU9) &&
        (lpcap->biCompression != VIDEO_FORMAT_YUY2) &&
        (lpcap->biCompression != VIDEO_FORMAT_UYVY) &&
        (lpcap->biCompression != VIDEO_FORMAT_I420) &&
        (lpcap->biCompression != VIDEO_FORMAT_IYUV)) {
#endif
        // attempt to instantiate an ICM CFrameOp
        CICMcvtFrame *cicm;

        if ((cicm = new CICMcvtFrame)) {
            cicm->AddRef();
#if 0
            if (cicm->InitCvt(lpcap, lpcapsize, plpdsp, BI_RGB)) {
#else
            if (cicm->InitCvt(lpcap, lpcapsize, plpdsp)) {
#endif
                clast->m_next = (CFrameOp*)cicm; // add ICM FrameOp into chain
                clast = (CFrameOp*)cicm;
            }
            else {
                cicm->Release();

                if (!*plpdsp)
				{
					ERRORMESSAGE(("%s: Failed to find a codec", _fx_));
				}
            }
        }
        else
		{
			ERRORMESSAGE(("%s: Failed to alloc codec object", _fx_));
		}
    }
    else if (!*plpdsp) {
        if (*plpdsp = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, lpcapsize))
            CopyMemory(*plpdsp, lpcap, lpcapsize);
        else
		{
			ERRORMESSAGE(("%s: Failed to alloc display bitmapinfoheader", _fx_));
		}
    }

#ifdef SUPPORT_DESIRED_FORMAT
#if 0
// LOOKLOOK RP - this isn't done yet, something to do beyond NM2.0
    if ((desiredformat == VIDEO_FORMAT_INTELI420) &&
        ((*plpdsp)->biCompression != VIDEO_FORMAT_INTELI420)) {
        CConvertFrame *ccvt;

        if (ccvt = new CConvertFrame) {
            ccvt->AddRef();
            if (ccvt->InitConverter(lpcvt, convertproc, refdata)) {
                LocalFree((HANDLE)*plpdsp);
                *plpdsp = lpcvt;
                clast->m_next = (CFrameOp*)ccvt; // add FrameOp into chain
                clast = (CFrameOp*)ccvt;
            }
            else
                ccvt->Release();
        }
    }
#endif

#if 0
    if (((desiredformat == VIDEO_FORMAT_YVU9) &&
         ((*plpdsp)->biCompression != VIDEO_FORMAT_YVU9)) ||
        ((desiredformat == VIDEO_FORMAT_INTELI420) &&
         ((*plpdsp)->biCompression != VIDEO_FORMAT_INTELI420))) {
#else
    if (((desiredformat == VIDEO_FORMAT_YVU9) &&
        ((*plpdsp)->biCompression != VIDEO_FORMAT_YVU9)) ||
        ((desiredformat == VIDEO_FORMAT_YUY2) &&
        ((*plpdsp)->biCompression != VIDEO_FORMAT_YUY2)) ||
        ((desiredformat == VIDEO_FORMAT_UYVY) &&
        ((*plpdsp)->biCompression != VIDEO_FORMAT_UYVY)) ||
        ((desiredformat == VIDEO_FORMAT_I420) &&
        ((*plpdsp)->biCompression != VIDEO_FORMAT_I420)) ||
        ((desiredformat == VIDEO_FORMAT_IYUV) &&
        ((*plpdsp)->biCompression != VIDEO_FORMAT_IYUV))) {
#endif
        // attempt to instantiate an ICM CFrameOp
        CICMcvtFrame *cicm;

        if ((cicm = new CICMcvtFrame)) {
            cicm->AddRef();
            if (cicm->InitCvt(*plpdsp, lpcapsize, &lpcvt, desiredformat)) {
                clast->m_next = (CFrameOp*)cicm; // add ICM FrameOp into chain
                clast = (CFrameOp*)cicm;
                LocalFree((HANDLE)*plpdsp);
                *plpdsp = lpcvt;
            }
            else {
                cicm->Release();

                if (!*plpdsp)
				{
					ERRORMESSAGE(("%s: Failed to find a codec", _fx_));
				}
            }
        }
        else
		{
			ERRORMESSAGE(("%s: Failed to alloc codec object", _fx_));
		}
    }
#endif // SUPPORT_DESIRED_FORMAT

    {
        CConvertFrame *ccvt;
        FRAMECONVERTPROC *convertproc;
        LPVOID refdata;

#ifdef ENABLE_ZOOM_CODE
        BOOL attemptzoom;

        attemptzoom = TRUE;
#endif

        while (*plpdsp && (((*plpdsp)->biWidth != desiredwidth) ||
                           ((*plpdsp)->biHeight != desiredheight) ||
                           (((*plpdsp)->biCompression == BI_RGB) && ((*plpdsp)->biBitCount <= 8)))) {
            lpcvt = NULL;
#ifdef ENABLE_ZOOM_CODE
            if (attemptzoom) {
                InitScale(*plpdsp, desiredwidth, desiredheight, &lpcvt, &convertproc, &refdata);
                attemptzoom = FALSE;
            }
#endif
            if (!lpcvt) {
                if (((*plpdsp)->biWidth >= desiredwidth) && ((*plpdsp)->biHeight >= desiredheight)) {
                    // try to shrink
                    InitShrink(*plpdsp, desiredwidth, desiredheight, &lpcvt, &convertproc, &refdata);
                }
                else {
                    // try to blackbar
                    InitBlackbar(*plpdsp, desiredwidth, desiredheight, &lpcvt, &convertproc, &refdata);
                }
            }
            if (lpcvt) {
                if (ccvt = new CConvertFrame) {
                    ccvt->AddRef();
                    if (ccvt->InitConverter(lpcvt, convertproc, refdata)) {
                        LocalFree((HANDLE)*plpdsp);
                        *plpdsp = lpcvt;
                        clast->m_next = (CFrameOp*)ccvt; // add FrameOp into chain
                        clast = (CFrameOp*)ccvt;
                        continue;
                    }
                    else
                        ccvt->Release();
                }
            }
            else {
				ERRORMESSAGE(("%s: Can't convert", _fx_));
                LocalFree((HANDLE)*plpdsp);
                *plpdsp = NULL;
            }
        }
    }

    if (*plpdsp) {
        // allocate a placeholder for a filter chain
        if (cfilterchain = new CFilterChain) {
            cfilterchain->AddRef();
            // placeholder needs reference to a pool to pass to added filters
            if (clast->m_pool && clast->m_pool->Growable()) {
                cfilterchain->m_pool = clast->m_pool;
                cfilterchain->m_pool->AddRef();
            }
            else {
                if ((cfilterchain->m_pool = new CVidPool)) {
                    cfilterchain->m_pool->AddRef();
                    if (cfilterchain->m_pool->InitPool(2, *plpdsp) != NO_ERROR) {
						ERRORMESSAGE(("%s: Failed to init filter pool", _fx_));
                        cfilterchain->m_pool->Release();
                        cfilterchain->m_pool = NULL;
                    }
                }
                else
				{
					ERRORMESSAGE(("%s: Failed to alloc filter pool", _fx_));
				}
            }
            if (cfilterchain->m_pool) {
                clast->m_next = (CFrameOp*)cfilterchain; // add placeholder FrameOp into chain
                clast = (CFrameOp*)cfilterchain;
            }
            else {
                cfilterchain->Release();
                cfilterchain = NULL;
            }
        }

        if (m_opchain)
            m_opchain->Release();
        m_opchain = ccf;
        m_filterchain = cfilterchain;
        return NO_ERROR;
    }
    ccf->Release(); // discard partial chain
    return E_FAIL;
}

//  AddFilter
//      Adds a filter to the chain.  If hAfter is NULL, the filter is added
//      to the head of the chain.

STDMETHODIMP
CCaptureChain::AddFilter(
    CLSID* pclsid,
    LPBITMAPINFOHEADER lpbmhIn,
    HANDLE* phNew,
    HANDLE hAfter
    )
{
    HRESULT hres;
    IBitmapEffect *effect;
    CFilterFrame *cff;
    CFilterChain *chain;
    CFilterFrame *previous;

    if (m_filterchain) {
        m_filterchain->AddRef();    // lock chain from destruction

        // find insertion point
        previous = m_filterchain->m_head;
        if (hAfter) {
            while (previous && (previous->m_tag != hAfter))
                previous = (CFilterFrame*)previous->m_next;
            if (!previous) {
                // can't find hAfter, so fail call
                m_filterchain->Release();   // unlock m_filterchain
                return E_INVALIDARG;
            }
        }

        // load, init and link in new filter
        if (cff = new CFilterFrame) {
            cff->AddRef();
            if ((hres = LoadFilter(pclsid, &effect)) == NO_ERROR) {
                m_filterchain->m_pool->AddRef();
                if (cff->InitFilter(effect, lpbmhIn, m_filterchain->m_pool))
                    hres = NO_ERROR;
                else
                    hres = E_OUTOFMEMORY;
                m_filterchain->m_pool->Release();
                if (hres == NO_ERROR) {
                    cff->m_clsid = *pclsid;
                    cff->m_tag = (HANDLE)(++m_filtertags);
                    if (phNew)
                        *phNew = (HANDLE)cff->m_tag;

                    EnterCriticalSection(&m_capcs);
                    if (previous) {
                        cff->m_next = previous->m_next;
                        previous->m_next = cff;
                    }
                    else {
                        cff->m_next = m_filterchain->m_head;
                        m_filterchain->m_head = cff;
                    }
                    LeaveCriticalSection(&m_capcs);
                    m_filterchain->Release();
                    return NO_ERROR;
                }
            }
            cff->Release();
        }
        else
            hres = E_OUTOFMEMORY;
        m_filterchain->Release();   // unlock m_filterchain
        return hres;
    }
    return E_UNEXPECTED;
}

STDMETHODIMP
CCaptureChain::RemoveFilter(
    HANDLE hFilter
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CCaptureChain::DisplayFilterProperties(
    HANDLE hFilter,
    HWND hwndParent
    )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nmcap\frameop.h ===
#include <windows.h>
#include <vfw.h>
#include <dcap.h>
#include "vidpool.h"
#include "effect.h"

#ifndef _FRAMEOP_H
#define _FRAMEOP_H

class CFrameOp
{
private:
    LONG m_cRef;

public:
    CFrameOp *m_next;
    CVidPool *m_pool;

    CFrameOp() {m_cRef = 0; m_next = NULL; m_pool = NULL; }
    virtual ~CFrameOp() {};

    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP DoOp(IBitmapSurface** ppbs) = 0;
};

class CCaptureFrame :
    public CFrameOp
{
private:
    HCAPDEV m_hcapdev;
    HFRAMEBUF m_hbuf1;
    HFRAMEBUF m_hbuf2;

public:
    CCaptureFrame() { m_hcapdev = NULL; m_hbuf1 = NULL; m_hbuf2 = NULL; }
    ~CCaptureFrame();

    STDMETHODIMP DoOp(IBitmapSurface** ppbs);

    BOOL InitCapture(HCAPDEV hcapdev, LPBITMAPINFOHEADER lpbmh);
};

class CStreamCaptureFrame :
    public CFrameOp
{
private:
    HCAPDEV m_hcapdev;

public:
    CStreamCaptureFrame() { m_hcapdev = NULL; }
    ~CStreamCaptureFrame();

    STDMETHODIMP DoOp(IBitmapSurface** ppbs);

    BOOL InitCapture(HCAPDEV hcapdev, LPBITMAPINFOHEADER lpbmh);
};

class CICMcvtFrame :
    public CFrameOp
{
private:
    HIC m_hic;
    LPBITMAPINFOHEADER m_inlpbmh;
    LPBITMAPINFOHEADER m_outlpbmh;

public:
    CICMcvtFrame() { m_hic = NULL; m_inlpbmh = NULL; m_outlpbmh = NULL; }
    ~CICMcvtFrame();

    STDMETHODIMP DoOp(IBitmapSurface** ppbs);

    BOOL InitCvt(LPBITMAPINFOHEADER lpbmh, DWORD bmhLen,
                 LPBITMAPINFOHEADER *plpbmhdsp);
        // if TRUE, then plpbmhdsp will point to allocated memory that the caller will
        // be responsible for deallocating
        // if FALSE, then plpbmhdsp will point to a copy lpbmh, if no conversion necessary,
        //      else it will be NULL to indicate that converion is not possible
};


class CFilterFrame :
    public CFrameOp
{
private:
    IBitmapEffect *m_effect;
    BOOL m_inplace;

public:
    CLSID m_clsid;
    HANDLE m_tag;
    BOOL m_enabled;

    CFilterFrame() { m_effect = NULL; m_inplace = TRUE; m_enabled = TRUE; m_tag = 0; }
    ~CFilterFrame();

    STDMETHODIMP DoOp(IBitmapSurface** ppbs);

    BOOL InitFilter(IBitmapEffect *effect, LPBITMAPINFOHEADER lpbmhIn, CVidPool *pool);
};

class CFilterChain :
    public CFrameOp
{
private:

public:
    CFilterFrame *m_head;

    CFilterChain() { m_head = NULL; }
    ~CFilterChain();

    STDMETHODIMP DoOp(IBitmapSurface** ppbs);
};

typedef BOOL (FRAMECONVERTPROC) (IBitmapSurface*, IBitmapSurface*, LPVOID);

class CConvertFrame :
    public CFrameOp
{
private:
    FRAMECONVERTPROC *m_convert;
    LPVOID m_refdata;

public:
    CConvertFrame() { m_convert = NULL; m_refdata = NULL; }
    ~CConvertFrame();

    STDMETHODIMP DoOp(IBitmapSurface** ppbs);

    BOOL InitConverter(LPBITMAPINFOHEADER lpbmh, FRAMECONVERTPROC *convertproc, LPVOID refdata);
};

#endif // #ifndef _FRAMEOP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\qos\guids.cpp ===
/*
 -  GUIDS.CPP
 -
 *	Microsoft NetMeeting
 *	Quality of Service DLL
 *	QoS GUID definitions
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		10.28.96	Yoram Yaacovi		Created
 *
 *	Functions:
 *
 */

#include "precomp.h"

// define the GUID as "public"
#define INITGUID
#include <initguid.h>

// {DFC1F900-2DCE-11d0-92DD-00A0C922E6B2}
DEFINE_GUID(IID_IQoS, 0xdfc1f900, 0x2dce, 0x11d0, 0x92, 0xdd, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xb2);
// {085C06A0-3CAA-11d0-A00E-00A024A85A2C}
DEFINE_GUID(CLSID_QoS, 0x085c06a0, 0x3caa, 0x11d0, 0xa0, 0x0e, 0x0, 0xa0, 0x24, 0xa8, 0x5a, 0x2c);

// DEFINE_OLEGUID(IID_IUnknown, 0x00000000L, 0, 0);

#undef INITGUID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nmcap\mydebug.h ===
#ifndef _MYDEBUG_H
#define _MYDEBUG_H

#include <windows.h>
#include <confdbg.h>
#include <avutil.h>

#include "..\nac\utils.h"

#endif //_MYDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nmcap\vidpool.cpp ===
#include <windows.h>
#include <windowsx.h>
#include <objbase.h>
#include <qos.h>
#include <mmsystem.h>
#include "ibitmap.h"
#include "ividpool.h"
#include "vidpool.h"
#include <confdbg.h>
#include <avutil.h>
#include "..\nac\utils.h"

#ifdef DEBUG
extern "C" BOOL g_pooldebug = TRUE;
#endif

STDMETHODIMP
CBitmap::QueryInterface(
    REFIID riid,
    LPVOID * ppvObj
    )
{
    if (riid == IID_IUnknown || riid == IID_IBitmapSurface)
        *ppvObj = (IBitmapSurface*)this;
    else
    {
        *ppvObj = 0;
        return E_NOINTERFACE;
    }
    ((IUnknown*)*ppvObj)->AddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG)
CBitmap::AddRef(
    void
    )
{
	FX_ENTRY("CBitmap::AddRef");

	DEBUGMSG(ZONE_NMCAP_REFCOUNT,("%s: refcnt+(0x%08lX [CBitmap])=%d\r\n", _fx_, this, m_cRef+1));

    return InterlockedIncrement(&m_cRef)+1; // make sure that we return something > 0
}

STDMETHODIMP_(ULONG)
CBitmap::Release(
    void
    )
{
    LONG res;

	FX_ENTRY("CBitmap::Release");

	DEBUGMSG(ZONE_NMCAP_REFCOUNT,("%s: refcnt-(0x%08lX [CBitmap])=%d\r\n", _fx_, this, m_cRef-1));

    res = InterlockedDecrement(&m_cRef);
    if (res == 0) {
        if (m_factory) {
            m_factory->AddToFreeList(this);
        }
        else {
            if (!m_ext)
                LocalFree((HANDLE)m_bits);
			DEBUGMSG(ZONE_NMCAP_CDTOR,("%s: released (0x%08lX [CBitmap]) from vidpool (0x%08lX [m_factory])\r\n", _fx_, this, m_factory));
			DEBUGMSG(ZONE_NMCAP_CDTOR,("%s: deleting (0x%08lX [CBitmap])\r\n", _fx_, this));
            delete this;
        }
    }
    return res;
}

STDMETHODIMP
CBitmap::Clone(
    IBitmapSurface** ppBitmapSurface
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CBitmap::GetFormat(
    BFID* pBFID
    )
{
    *pBFID = *(m_factory->GetFormat());
    return NOERROR;
}

STDMETHODIMP
CBitmap::GetFactory(
    IBitmapSurfaceFactory** ppBitmapSurfaceFactory
    )
{
    *ppBitmapSurfaceFactory = (IBitmapSurfaceFactory*)m_factory;
    m_factory->AddRef();
    return NOERROR;
}

STDMETHODIMP
CBitmap::GetSize(
    long* pWidth,
    long* pHeight
    )
{
	*pWidth = m_factory->GetWidth();
	*pHeight = m_factory->GetHeight();
    return NOERROR;
}

STDMETHODIMP
CBitmap::LockBits(
    RECT* prcBounds,
    DWORD dwLockFlags,
    void** ppBits,
    long* pPitch
    )
{
    if (!prcBounds) {
        *ppBits = m_bits;
        *pPitch = m_pitch;
        m_lockcount++;
        return NO_ERROR;
    }
    return E_NOTIMPL;
}

STDMETHODIMP
CBitmap::UnlockBits(
    RECT* prcBounds,
    void* pBits
    )
{
    if (!prcBounds && pBits == m_bits) {
        m_lockcount--;
        return NO_ERROR;
    }
    return E_NOTIMPL;
}


CVidPool::CVidPool(void)
{
    m_cRef = 0;
    m_growable = FALSE;
    m_nbufs = 0;
    m_free = NULL;
    m_pitch = 0;
    ZeroMemory(&m_format, sizeof(BFID));
    InitializeCriticalSection(&m_cs);
    m_pAddingToFree = NULL;
}

STDMETHODIMP
CVidPool::QueryInterface(
    REFIID riid,
    LPVOID * ppvObj
    )
{
    if (riid == IID_IUnknown || riid == IID_IBitmapSurfaceFactory)
        *ppvObj = (IBitmapSurfaceFactory*)this;
    else
    {
        *ppvObj = 0;
        return E_NOINTERFACE;
    }
    ((IUnknown*)*ppvObj)->AddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG)
CVidPool::AddRef(
    void
    )
{
	FX_ENTRY("CVidPool::AddRef");

	DEBUGMSG(ZONE_NMCAP_REFCOUNT,("%s: refcnt+(0x%08lX [CVidPool])=%d\r\n", _fx_, this, m_cRef+1));

    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CVidPool::Release(
    void
    )
{
    CBitmap* pbs;

	FX_ENTRY("CVidPool::Release");

	DEBUGMSG(ZONE_NMCAP_REFCOUNT,("%s: refcnt-(0x%08lX [CVidPool])=%d\r\n", _fx_, this, m_cRef-1));

    if (InterlockedDecrement(&m_cRef) == 0) {

		DEBUGMSG(ZONE_NMCAP_CDTOR,("%s: freeing (0x%08lX [CVidPool])\r\n", _fx_, this));

        EnterCriticalSection(&m_cs);
        while (m_free) {
            pbs = m_free->m_next;
            m_free->AddRef();       // ref the buffer so that release will cause a delete
            m_free->Release();      // this will cause the buffer to be deleted
            m_free = pbs;
#ifdef DEBUG
            m_nbufs--;
#endif
        }
        LeaveCriticalSection(&m_cs);
        LocalFree((HANDLE)m_pbmh);
        DeleteCriticalSection(&m_cs);

		// Buffers not all released
        ASSERT(!m_nbufs);

        delete this;
        return 0;
    }
    return m_cRef;
}

STDMETHODIMP
CVidPool::CreateBitmapSurface(
    long width,
    long height,
    BFID* pBFID,
    DWORD dwHintFlags,
    IBitmapSurface** ppBitmapSurface
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CVidPool::GetSupportedFormatsCount(
    long* pcFormats
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CVidPool::GetSupportedFormats(
    long cFormats,
    BFID* pBFIDs
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CVidPool::InitPool(
    int nBuffers,
    LPBITMAPINFOHEADER lpcap
    )
{
    CBitmap* pbs;
    void *pbuf;

	FX_ENTRY("CVidPool::InitPool");

    if (m_pbmh = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, lpcap->biSize)) {
        CopyMemory(m_pbmh, lpcap, lpcap->biSize);
        if (lpcap->biCompression == BI_RGB) {
            m_pitch = lpcap->biWidth*lpcap->biBitCount/8;
            switch (lpcap->biBitCount) {
                case 1:
                    m_format = (BFID*)&BFID_MONOCHROME;
                    break;

                case 4:
                    m_format = (BFID*)&BFID_RGB_4;
                    break;

                case 8:
                    m_format = (BFID*)&BFID_RGB_8;
                    break;

                case 16:
                    m_format = (BFID*)&BFID_RGB_555;
                    break;

                case 24:
                    m_format = (BFID*)&BFID_RGB_24;
                    break;

                case 32:
                    m_format = (BFID*)&BFID_RGB_32;
            }
        }
        else {
            m_format = (BFID*)&BFID_PRIVATEDIB;
            m_pitch = 1;
        }

        for (m_nbufs = 0; m_nbufs < nBuffers; m_nbufs++) {
            if (pbuf = LocalAlloc(LMEM_FIXED, lpcap->biSizeImage)) {
                if (pbs = new CBitmap) {
                //  pbs->AddRef();  - don't AddRef, we want inpool objects to be 0 based
                    pbs->m_bits = (LPBYTE)pbuf;
                    pbs->m_pitch = m_pitch;
                    EnterCriticalSection(&m_cs);
                    pbs->m_next = m_free;
                    m_free = pbs;
                    LeaveCriticalSection(&m_cs);
                }
                else {
                    LocalFree((HANDLE)pbuf);
                    break;
                }
            }
            else
                break;        
        }
        if (m_nbufs == nBuffers) {
            m_growable = (nBuffers > 0);
			DEBUGMSG(ZONE_NMCAP_CDTOR,("%s: init vidpool (0x%08lX [CVidPool])\r\n", _fx_, this));
            return NO_ERROR;
        }

        EnterCriticalSection(&m_cs);
        while (m_free) {
            pbs = m_free->m_next;
            m_free->Release();
            m_free = pbs;
        }
        LeaveCriticalSection(&m_cs);
    }
    return E_OUTOFMEMORY;
}

STDMETHODIMP
CVidPool::AddExternalBuffer(
    void* pBits,
    void* refdata
    )
{
    CBitmap* pbs;

	FX_ENTRY("CVidPool::AddExternalBuffer");

    if (pbs = new CBitmap) {
    //  pbs->AddRef();  - don't AddRef, because we want inpool objects to be 0 based
        pbs->m_bits = (LPBYTE)pBits;
        pbs->m_pitch = m_pitch;
        pbs->m_ext = TRUE;
        EnterCriticalSection(&m_cs);
        pbs->m_next = m_free;
        pbs->m_refdata = refdata;
        m_free = pbs;
        m_nbufs++;
        LeaveCriticalSection(&m_cs);
		DEBUGMSG(ZONE_NMCAP_CDTOR,("%s: added bitmap (0x%08lX [CBitmap]) to vidpool (0x%08lX [CVidPool])\r\n", _fx_, pbs, this));
    }
    return E_OUTOFMEMORY;
}

STDMETHODIMP
CVidPool::GetBuffer(
    CBitmap** ppBitmap,
    void** prefdata
    )
{
    CBitmap* pbs = NULL;
    void *pbuf;

	FX_ENTRY("CVidPool::GetBuffer");

    if (ppBitmap) {
        if (prefdata)
            *prefdata = NULL;
        EnterCriticalSection(&m_cs);
        if (pbs = m_free) {
            m_free = pbs->m_next;
            LeaveCriticalSection(&m_cs);
        }
        else {
            LeaveCriticalSection(&m_cs);
            if (m_growable) {
                if (pbuf = LocalAlloc(LMEM_FIXED, m_pbmh->biSizeImage)) {
                    if (pbs = new CBitmap) {
                        pbs->m_bits = (LPBYTE)pbuf;
                        pbs->m_pitch = m_pitch;
                        pbs->m_next = m_free;
                        m_nbufs++;
						DEBUGMSG(ZONE_NMCAP_CDTOR,("%s: grew vidpool (0x%08lX [CVidPool]) to %d with cbitmap (0x%08lX [CBitmap])\r\n", _fx_, this, m_nbufs, pbs));
                    }
                    else
                        LocalFree((HANDLE)pbuf);
                }
            }
        }
        if (*ppBitmap = pbs) {
            pbs->m_factory = this;
            AddRef();
            pbs->AddRef();
            if (prefdata)
                *prefdata = pbs->m_refdata;
            return NO_ERROR;
        }
        else
            return E_OUTOFMEMORY;        
    }
    return E_INVALIDARG;
}

STDMETHODIMP
CVidPool::GetBuffer(
    IBitmapSurface** ppBitmap,
    void** prefdata
    )
{
    CBitmap* pbs = NULL;
    GetBuffer (&pbs, prefdata);
    *ppBitmap = (IBitmapSurface*)pbs;
    return NO_ERROR;
}

void
CVidPool::AddToFreeList(
    CBitmap* pBitmap
    )
{
	FX_ENTRY("CVidPool::AddToFreeList");

	DEBUGMSG(ZONE_NMCAP_CDTOR,("%s: queuing cbitmap (0x%08lX [CBitmap]) to vidpool (0x%08lX [CVidPool])\r\n", _fx_, pBitmap, this));

    // notify pool creator, if interested
    if (m_pAddingToFree)
        m_pAddingToFree(pBitmap, m_refdata);

    EnterCriticalSection(&m_cs);
    pBitmap->m_next = m_free;
    m_free = pBitmap;
    LeaveCriticalSection(&m_cs);
    pBitmap->m_factory = NULL;
    Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\qos\debug.cpp ===
/*
 -  DEBUG.CPP
 -
 *	Microsoft NetMeeting
 *	Quality of Service DLL
 *	Debug code
 *
 *      Revision History:
 *
 *      When		Who                 What
 *      --------	------------------  ---------------------------------------
 *      10.23.96	Yoram Yaacovi       Created
 *      01.04.97	Robert Donner       Added NetMeeting utility routines
 *		01.09.97	Yoram Yaacovi		Added DisplayRequestList
 *
 *	Functions:
 *		DisplayQoSObject
 *		DisplayRequestList
 *		DisplayRequestListInt
 *
 */

#include "precomp.h"

#ifdef DEBUG

int QoSDbgPrintf(LPCSTR lpszFormat, ...)
{
	va_list v1;
	va_start(v1, lpszFormat);
	DbgPrintf("QoS:", lpszFormat, v1);
	va_end(v1);

	return 0;
}

/***************************************************************************

    Name      : DisplayParameters

    Purpose   : Displays parameters of a given function

    Parameters: nFunctionID - ID of the function for which to display parameters
				p1 - p5: up to 5 32-bit function parameters

	Returns   :

    Comment   :
***************************************************************************/
void CQoS::DisplayParameters(ULONG nFunctionID, ULONG_PTR p1, ULONG_PTR p2, ULONG_PTR p3, ULONG_PTR p4, ULONG_PTR p5)
{
	BOOL fDisplay=FALSE;
	TCHAR szGuid[40 /* CCHSZGUID */];

	fDisplay = (m_bInNotify ?
				(ZONE_THREAD && ZONE_PARAMETERS) :
				ZONE_PARAMETERS);

	if (!fDisplay)
		return;

	switch (nFunctionID)
	{
		case REQUEST_RESOURCES_ID:
			GuidToSz((LPGUID) p1 /* lpClientGUID */, szGuid);
			DEBUGMSG(fDisplay, ("Client: %s\n", szGuid));
			DisplayRequestList((LPRESOURCEREQUESTLIST) p2 /* lpResourceRequestList */);
			break;

		case RELEASE_RESOURCES_ID:
			GuidToSz((LPGUID) p1 /* lpClientGUID */, szGuid);
			DEBUGMSG(fDisplay, ("Client: %s\n", szGuid));
			DisplayRequestList((LPRESOURCEREQUESTLIST) p2 /* lpResourceRequestList */);
			break;

		case SET_RESOURCES_ID:
			DisplayResourceList((LPRESOURCELIST) p1 /* lpResourceList */);
			break;

		case SET_CLIENTS_ID:
			DisplayClientList((LPCLIENTLIST) p1 /* lpClientList */);
			break;

		default:
			break;
	}
}

/***************************************************************************

    Name      : DisplayClientList

    Purpose   : Displays a client list given a pointer to the list

    Parameters: pCl - pointer to the list

	Returns   :

    Comment   :
***************************************************************************/
void CQoS::DisplayClientList(LPCLIENTLIST pcl)
{
	BOOL fDisplay=FALSE;
	ULONG i=0;
	LPCLIENT pc=NULL;
	TCHAR szGuid[40 /* CCHSZGUID */];
	char szNoName[]="No Name";
	PSTR pszClientName=szNoName;

	fDisplay = (m_bInNotify ? (ZONE_THREAD && ZONE_PARAMETERS) : ZONE_PARAMETERS);

	DEBUGMSG(fDisplay, ("Number of clients: %d\n", pcl->cClients));
	DEBUGMSG(fDisplay, ("Client              priority  GUID\n"));

	for (i=0; i < pcl->cClients; i++)
	{
		pc = &(pcl->aClients[i]);
		GuidToSz(&(pc->guidClientGUID), szGuid);

		// assuming DEBUGMSG always prints non-Unicode
		if (*(pc->wszName) && (pszClientName = UnicodeToAnsi(pc->wszName)))
		{
			// display the client	
			DEBUGMSG(fDisplay, (" %-20s%-9d %s",
								pszClientName,
								pc->priority,
								szGuid));
			delete pszClientName;
		}
		else
		{
			pszClientName = szNoName;
			// display the client	
			DEBUGMSG(fDisplay, ("   %-20s%-9d %s",
								pszClientName,
								pc->priority,
								szGuid));
		}
	}
}

/***************************************************************************

    Name      : DisplayResourceList

    Purpose   : Displays a resource list given a pointer to the list

    Parameters: prl - pointer to the list

	Returns   :

    Comment   :
***************************************************************************/
void CQoS::DisplayResourceList(LPRESOURCELIST prl)
{
	BOOL fDisplay=FALSE;
	ULONG i=0;
	LPRESOURCE pr=NULL;

	fDisplay = (m_bInNotify ? (ZONE_THREAD && ZONE_PARAMETERS) : ZONE_PARAMETERS);
	
	DEBUGMSG(fDisplay, ("Number of resources: %d\n", prl->cResources));
	DEBUGMSG(fDisplay, ("Resource  Flags   MinUnits MaxUnits Level hResult\n"));

	for (i=0; i < prl->cResources; i++)
	{
		pr = &(prl->aResources[i]);

		// display the resource	
		DEBUGMSG(fDisplay, ("   %-10d%-8x%-9d",
							pr->resourceID,
							pr->ulResourceFlags,
							pr->nUnits));
		
	}
}

/***************************************************************************

    Name      : DisplayRequestList

    Purpose   : Displays a request list given a pointer to the list

    Parameters: prrl - pointer to the list

	Returns   :

    Comment   :
***************************************************************************/
void CQoS::DisplayRequestList(LPRESOURCEREQUESTLIST prrl)
{
	BOOL fDisplay=FALSE;
	ULONG i=0;
	LPRESOURCEREQUEST prr=NULL;

	fDisplay = (m_bInNotify ? (ZONE_THREAD && ZONE_PARAMETERS) : ZONE_PARAMETERS);
	
	DEBUGMSG(fDisplay, ("Number of requests: %d\n", prrl->cRequests));
	DEBUGMSG(fDisplay, ("Resource  Flags   MinUnits MaxUnits Level hResult\n"));

	for (i=0; i < prrl->cRequests; i++)
	{
		prr = &(prrl->aRequests[i]);

		// display the resource	
		DEBUGMSG(fDisplay, ("   %-10d%-8x%-9d%-9d%-6d%-8x",
							prr->resourceID,
							prr->ulRequestFlags,
							prr->nUnitsMin,
							prr->nUnitsMax,
							prr->levelOfGuarantee,
							prr->hResult));
		
	}
}

/***************************************************************************

    Name      : DisplayRequestListInt

    Purpose   : Displays an internal request list given a pointer to the list

    Parameters: prr - pointer to the first request in the list
				fDisplay - a flag to tell DisplayRequestListInt whether to display
					or no. This might seem dumb, since why call DisplayRequestListInt
					if it's not going to display, but this parameter really conveys
					the zone information that thcaller wants.

	Returns   :

    Comment   :
***************************************************************************/
void CQoS::DisplayRequestListInt(LPRESOURCEREQUESTINT prr, BOOL fDisplay)
{
	TCHAR szGuid[40 /* CCHSZGUID */];

	while (prr)
	{
		GuidToSz(&(prr->guidClientGUID), szGuid);

		// display the resource	
		DEBUGMSG(fDisplay, ("   %-10x%-10x%-10d%-8x%-6d%-7d%-11x %s",
							prr,
							prr->fLink,
							prr->sResourceRequest.resourceID,
							prr->sResourceRequest.ulRequestFlags,
							prr->sResourceRequest.levelOfGuarantee,
							prr->sResourceRequest.nUnitsMin,
							prr->pfnQoSNotify,
							szGuid));
		
		// next request
		prr = prr->fLink;
	}
}

/***************************************************************************

    Name      : DisplayQoSObject

    Purpose   : Displays the containing QoS object

    Parameters: none

	Returns   : none

    Comment   :
***************************************************************************/
void CQoS::DisplayQoSObject(void)
{
	LPRESOURCEINT pr=NULL;
	LPRESOURCEREQUESTINT prr=NULL;
	LPCLIENTINT pc=NULL;
	BOOL fDisplay=FALSE;

	// don't waste time if we are not going to print
	fDisplay = (m_bInNotify ? (ZONE_THREAD && ZONE_STRUCTURES) : ZONE_STRUCTURES);
	if (!fDisplay)
		return;

	DEBUGMSG(fDisplay, ("Start object display\n"));
	DEBUGMSG(fDisplay, ("=========================================\n"));

	/*
	 *	Print resources and requests
	 */
	DEBUGMSG(fDisplay, ("Resources\n"));
	DEBUGMSG(fDisplay, ("*********\n"));
	pr = m_pResourceList;
	if (!pr)
	{
		DEBUGMSG(fDisplay, ("No Resources\n"));
	}
	else
	{
		DEBUGMSG(fDisplay, ("Address   fLink     Resource  Flags   Units  Avail\n"));
		DEBUGMSG(fDisplay, ("   Address   fLink     Resource  Flags   Level Units  NotifyProc Client GUID\n"));
	}
	while (pr)
	{
		// display the resource	
		DEBUGMSG(fDisplay, ("Resource: %d\n", pr->resource.resourceID));
		DEBUGMSG(fDisplay, ("%-10x%-10x%-10d%-8x%-7d%-7d\n",
							pr,
							pr->fLink,
							pr->resource.resourceID,
							pr->resource.ulResourceFlags,
							pr->resource.nUnits,
							pr->nNowAvailUnits));

		// display the request list for this reasource
		prr = pr->pRequestList;
		DisplayRequestListInt(prr, fDisplay);			

		//next resource
		pr = pr->fLink;
	}

	/*
	 *	Print clients
	 */
	DEBUGMSG(fDisplay, ("\n"));
	DEBUGMSG(fDisplay, ("Clients\n"));
	DEBUGMSG(fDisplay, ("*******\n"));
	pc = m_pClientList;
	if (!pc)
	{
		DEBUGMSG(fDisplay, ("No Clients\n"));
	}
	else
	{
		DEBUGMSG(fDisplay, ("Address   fLink     Priority\n"));
		DEBUGMSG(fDisplay, ("   Address   fLink     Resource  Flags   Level Units  NotifyProc Client GUID\n"));
	}
	while (pc)
	{
		TCHAR szGuid[40 /* CCHSZGUID */];
		PSTR pszClientName=NULL;
		
		GuidToSz(&(pc->client.guidClientGUID), szGuid);

		// update the list of requests for this client
		// doing this if in the notify thread is bad !!
		if (!m_bInNotify)
			UpdateRequestsForClient (&(pc->client.guidClientGUID));

		// display the client
		// assuming DEBUGMSG always prints non-Unicode
		if (*(pc->client.wszName)	&&
			(pszClientName = UnicodeToAnsi(pc->client.wszName)))
		{
			DEBUGMSG(fDisplay, ("Client: %s   %s", pszClientName, szGuid));
			delete pszClientName;
		}
		else
		{
			DEBUGMSG(fDisplay, ("Client: %s", szGuid));
		}

		DEBUGMSG(fDisplay, ("%-10x%-10x%-10d",
				pc, pc->fLink, pc->client.priority));
				
		// display the request list for this reasource
		prr = pc->pRequestList;
		DisplayRequestListInt(prr, fDisplay);			

		//next resource
		pc = pc->fLink;
	}

	
	
	DEBUGMSG(fDisplay, ("=========================================\n"));
	DEBUGMSG(fDisplay, ("End object display\n"));
}

#else	// DEBUG

void CQoS::DisplayQoSObject(void)
{}
void CQoS::DisplayRequestList(LPRESOURCEREQUESTLIST)
{}
void CQoS::DisplayRequestListInt(LPRESOURCEREQUESTINT, BOOL)
{}
void CQoS::DisplayResourceList(LPRESOURCELIST prl)
{}
void CQoS::DisplayParameters(ULONG nFunctionID, ULONG_PTR P1, ULONG_PTR P2, ULONG_PTR P3, ULONG_PTR P4, ULONG_PTR P5)
{}

#endif	// DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\qos\precomp.h ===
/*
 -  PRECOMP.H
 -
 *	Microsoft NetMeeting
 *	Quality of Service DLL
 *	QoS pre-compiled header file
 *
 *      Revision History:
 *
 *      When	   Who                 What
 *      --------   ------------------  ---------------------------------------
 *      10.24.96   Yoram Yaacovi       Created
 *      01.04.97   Robert Donner       Added NetMeeting utility routines
 *
 */

#include <windows.h>
#include <windowsx.h>
#include <objbase.h>
#include <winsock2.h>
#include <limits.h>

#include <oprahcom.h>
#include <confdbg.h>
#include <confreg.h>
#include <avUtil.h>
#include <regentry.h>
#include <strutil.h>    // for GuidToSz
#include <dcap.h>       // for R0 services

// including common.h for DECLARE_INTERFACE_PTR
#include "common.h"
#include "nmqos.h"
#include "qosint.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nmcap\ividpool.h ===
//  IVIDPOOL.H
//
//      Contains the interfaces IVidPool
//
//  Created 17-Jan-97 [RichP]

#ifndef _IVIDPOOL_H
#define _IVIDPOOL_H

// IIDs
// {36447652-7089-11d0-BC25-00AA00A13C86}
DEFINE_GUID(IID_IVidPool, 0x36447652, 0x7089, 0x11d0, 0xbc, 0x25, 0x0, 0xaa, 0x0, 0xa1, 0x3c, 0x86);

// Interfaces

#undef  INTERFACE
#define INTERFACE   IVidPool

DECLARE_INTERFACE_(IVidPool, IBitmapSurfaceFactory)
{
	// IUnknown methods
	STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (THIS) PURE;
	STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IBitmapSurfaceFactory methods
    STDMETHOD(CreateBitmapSurface)(THIS_ long width, long height, BFID* pBFID, DWORD dwHintFlags, IBitmapSurface** ppBitmapSurface) PURE;
	STDMETHOD(GetSupportedFormatsCount)(THIS_ long* pcFormats) PURE;
	STDMETHOD(GetSupportedFormats)(THIS_ long cFormats, BFID* pBFIDs) PURE;

	// IVidPool methods
	STDMETHOD(InitPool)(THIS_ int nBuffers, BFID* format, long size, int pitch) PURE;
	STDMETHOD(AddExternalBuffer)(THIS_ void* pBits, int pitch, void* refdata) PURE;
    STDMETHOD(InvalidatePool)(void) PURE;
	STDMETHOD(GetBuffer)(THIS_ IBitmapSurface** ppBitmapSurface, void** prefdata) PURE;
};

#endif // #ifndef _IVIDPOOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\nmcap\vidpool.h ===
#include <windows.h>
#include "ibitmap.h"

#ifndef _VIDPOOL_H
#define _VIDPOOL_H

// {36447655-7089-11d0-BC25-00AA00A13C86}
DEFINE_GUID(BFID_PRIVATEDIB, 0x36447655, 0x7089, 0x11d0, 0xbc, 0x25, 0x0, 0xaa, 0x0, 0xa1, 0x3c, 0x86);

class CVidPool;

class CBitmap :
	public IBitmapSurface
{
private:
    LONG m_cRef;

public:
    LPBYTE m_bits;
    LONG m_pitch;
    int m_lockcount;
    BOOL m_ext;
    CBitmap* m_next;
    CVidPool* m_factory;
    void *m_refdata;

    CBitmap() {m_cRef = 0; m_bits = NULL; m_pitch = 0; m_lockcount = 0; m_ext = FALSE;
               m_next = NULL; m_factory = NULL; m_refdata = NULL;}

    // IUnknown methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IBitmapSurface methods
	virtual STDMETHODIMP Clone(IBitmapSurface** ppBitmapSurface);
	virtual STDMETHODIMP GetFormat(BFID* pBFID);
	virtual STDMETHODIMP GetFactory(IBitmapSurfaceFactory** ppBitmapSurfaceFactory);
	virtual STDMETHODIMP GetSize(long* pWidth, long* pHeight);
	virtual STDMETHODIMP LockBits(RECT* prcBounds, DWORD dwLockFlags, void** ppBits, long* pPitch);
	virtual STDMETHODIMP UnlockBits(RECT* prcBounds, void* pBits);
};


typedef void (NotifyAddingToFreeProc) (CBitmap *pBitmap, DWORD_PTR refdata);

class CVidPool :
	public IBitmapSurfaceFactory
{
private:
    LONG m_cRef;
    BOOL m_growable;
    LONG m_nbufs;
    CBitmap* m_free;
    int m_pitch;
    BFID* m_format;
    CRITICAL_SECTION m_cs;
    LPBITMAPINFOHEADER m_pbmh;

public:
    NotifyAddingToFreeProc *m_pAddingToFree;
    DWORD_PTR m_refdata;

    CVidPool(void);

    // IUnknown methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID* ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IBitmapSurfaceFactory methods
    virtual STDMETHODIMP CreateBitmapSurface(long width, long height, BFID* pBFID, DWORD dwHintFlags, IBitmapSurface** ppBitmapSurface);
	virtual STDMETHODIMP GetSupportedFormatsCount(long* pcFormats);
	virtual STDMETHODIMP GetSupportedFormats(long cFormats, BFID* pBFIDs);

	// private to implementation of CVidPool
	STDMETHODIMP InitPool(int nBuffers, LPBITMAPINFOHEADER lpcap);
	STDMETHODIMP AddExternalBuffer(void* pBits, void* refdata);
	STDMETHODIMP GetBuffer(CBitmap** ppBitmap, void** prefdata);
	STDMETHODIMP GetBuffer(IBitmapSurface** ppBitmap, void** prefdata);

	void AddToFreeList(CBitmap* pBitmap);

    BOOL Growable(void) { return m_growable; }
	BFID* GetFormat(void) {return m_format;}
	long GetWidth(void) { if (m_pbmh)
	                        return m_pbmh->biWidth;
	                      else
	                        return 0; }
	long GetHeight(void) { if (m_pbmh)
	                         return m_pbmh->biHeight;
	                       else
	                         return 0; }
};

#endif // #ifndef _VIDPOOL_H


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\qos\qosmain.cpp ===
/*
 -  QOSMAIN.CPP
 -
 *	Microsoft NetMeeting
 *	Quality of Service DLL
 *	DLL entry
 *
 *      Revision History:
 *
 *      When	   Who                 What
 *      --------   ------------------  ---------------------------------------
 *      10.23.96   Yoram Yaacovi       Created
 *      01.04.97   Robert Donner       Added NetMeeting utility routines
 *
 *	Functions:
 *
 */

#include <precomp.h>

#ifdef DEBUG
HDBGZONE    ghDbgZone = NULL;

static PTCHAR _rgZonesQos[] = {
	TEXT("qos"),
	TEXT("Init"),
	TEXT("IQoS"),
	TEXT("Thread"),
	TEXT("Structures"),
	TEXT("Parameters"),
};
#endif /* DEBUG */


/****************************************************************************
    FUNCTION:	DllEntryPoint

    PURPOSE:	The DLL entry point. Called by Windows on DLL attach/Detach. Used to
				do DLL initialization/termination.

	PARAMETERS: hInstDLL - instance of the DLL
				fdwReason - the reason the DLL is attached/detached.
				lpvReserved

****************************************************************************/
extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE  hinstDLL,
                               DWORD  fdwReason,
                               LPVOID  lpvReserved);

BOOL WINAPI DllEntryPoint(HINSTANCE hInstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
	BOOL fInit;

	switch (fdwReason)
	{

	case DLL_PROCESS_ATTACH:
		DBGINIT(&ghDbgZone, _rgZonesQos);
		INIT_MEM_TRACK("QoS");

		DisableThreadLibraryCalls(hInstDLL);

		DEBUGMSG(ZONE_INIT, ("DllEntryPoint: 0x%x PROCESS_ATTACH\n", GetCurrentThreadId()));

		// create a no-name mutex to control access to QoS object data
		g_hQoSMutex = CreateMutex(NULL, FALSE, NULL);
		ASSERT(g_hQoSMutex);
		if (!g_hQoSMutex)
		{
			ERRORMSG(("DllEntryPoint: CreateMutex failed, 0x%x\n", GetLastError()));
			return FALSE;
		}

		g_pQoS = (CQoS *)NULL;

		// no break. The attaching process need to go through THREAD_ATTACH.

	case DLL_THREAD_ATTACH:
		break;

	case DLL_PROCESS_DETACH:
		CloseHandle(g_hQoSMutex);

		DEBUGMSG(ZONE_INIT, ("DllEntryPoint: 0x%x PROCESS_DETACH\n", GetCurrentThreadId()));

		UNINIT_MEM_TRACK(0);

		DBGDEINIT(&ghDbgZone);

		// fall through to deinit last thread

	case DLL_THREAD_DETACH:
		break;

	default:
		break;

	}
	
	return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\qos\props.cpp ===
/*
 -  PROPS.CPP
 -
 *	Microsoft NetMeeting
 *	Quality of Service DLL
 *	IProp interfaces
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		11.06.96	Yoram Yaacovi		Created
 *
 *	Functions:
 *		IProp
 *			CQoS::GetProps
 *			CQoS::SetProps
 */

#include "precomp.h"

/***************************************************************************

    Name      : CQoS::SetProps

    Purpose   : Set properties on the QoS object

    Parameters: cValues - number of properties to set
				pPropArray - pointer to the array of the properties to set

    Returns   : HRESULT

    Comment   : 

***************************************************************************/
HRESULT CQoS::SetProps (ULONG cValues,
						PPROPERTY pPropArray)
{
	HRESULT hr=NOERROR;
	ULONG i;

	DEBUGMSG(ZONE_IQOS,("IQoS::SetProps\n"));

	/*
	 *	Parameter validation
	 */
	if (!pPropArray)
	{
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
	}

	/*
	 *	Set the properties
	 */
	// for every property to set...
	for (i=0; i < cValues; i++)
	{
		// just handle the props I know of
		switch (pPropArray[i].ulPropTag)
		{
		case PR_QOS_WINDOW_HANDLE:
			m_hWnd = (HWND) pPropArray[i].Value.ul;
			pPropArray[i].hResult = NOERROR;
			break;
		default:
			pPropArray[i].hResult = QOS_E_NO_SUCH_PROPERTY;
			hr = QOS_E_REQ_ERRORS;
			break;
		}
	}

out:
	DEBUGMSG(ZONE_IQOS,("IQoS::SetProps - leave, hr=0x%x\n", hr));
	return hr;
}

/***************************************************************************

    Name      : CQoS::GetProps

    Purpose   : Get properties from the QoS object

    Parameters: pPropTagArray - array of tags of properties to get
				ulFlags
				pcValues - address of a ULONG into which the function will
					put the number of the properties returned in *ppPropArray
				ppPropArray - address of a pointer where the function will 
					put the address of the returned properties buffer. The 
					caller must free this buffer when done.

    Returns   : HRESULT

    Comment   : Not implemented

***************************************************************************/
HRESULT CQoS::GetProps (PPROPTAGARRAY pPropTagArray,
						ULONG ulFlags,
						ULONG *pcValues,
						PPROPERTY *ppPropArray)
{
	HRESULT hr=NOERROR;

	DEBUGMSG(ZONE_IQOS,("IQoS::GetProps\n"));

	hr = E_NOTIMPL;

	goto out;

out:
	DEBUGMSG(ZONE_IQOS,("QoS::GetProps - leave, hr=0x%x\n", hr));
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\qos\qosint.h ===
/*
 -  QOSINT.H
 -
 *	Microsoft NetMeeting
 *	Quality of Service DLL
 *	Internal QoS header file
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		10.24.96	Yoram Yaacovi		Created
 *
 */

#include <pshpack8.h> /* Assume 8 byte packing throughout */


#ifdef DEBUG
/*
 *	Debug stuff
 */

extern HDBGZONE		ghDbgZoneQoS;

#define ZONE_INIT (GETMASK(ghDbgZoneQoS) & 0x0001)
#define ZONE_IQOS (GETMASK(ghDbgZoneQoS) & 0x0002)
#define ZONE_THREAD (GETMASK(ghDbgZoneQoS) & 0x0004)
#define ZONE_STRUCTURES (GETMASK(ghDbgZoneQoS) & 0x0008)
#define ZONE_PARAMETERS (GETMASK(ghDbgZoneQoS) & 0x0010)

int QoSDbgPrintf(LPCSTR lpszFormat, ...);

//	MACRO: DEBUGMSG(zone,message-to-print)
//	PURPOSE: If the zone is enabled, prints a message to the debug output
//	NOTE: in debug build - if the zone is turned on
#define DEBUGMSG(z,s)	( (z) ? (QoSDbgPrintf s) : 0)
//	MACRO: DISPLAYQOSOBJECT()
//	PURPOSE: Displays the internal structures of the QoS object
//	NOTE: in debug build - if the zone is turned on
#define DISPLAYQOSOBJECT()	DisplayQoSObject()
//	MACRO: DISPLAYPARAMETERS(nFunctionID)
//	PURPOSE: Displays the parameters of a given function
//	NOTE: in debug build - if the zone is turned on
#define DISPLAYPARAMETERS(fid, p1, p2, p3, p4, p5)				\
		DisplayParameters(fid, (ULONG_PTR) p1, (ULONG_PTR) p2, (ULONG_PTR) p3, (ULONG_PTR) p4, (ULONG_PTR) p5)
//	MACRO: QOSDEBUGINIT
//	PURPOSE: Initializes the QoS debug zones, ONLY IF not initialized yet
//	NOTE:
#define QOSDEBUGINIT()	\
	if (!ghDbgZoneQoS)	\
		DBGINIT(&ghDbgZoneQoS, _rgZonesQos);

#define WAIT_ON_MUTEX_MSEC	20000

#else	// retail
#define DISPLAYQOSOBJECT()
#define DISPLAYPARAMETERS(fid, p1, p2, p3, p4, p5)
#define DEBUGMSG(z,s)
#define QOSDEBUGINIT()
#define WAIT_ON_MUTEX_MSEC	5000
#endif

/*
 *	Constants
 */
// IDs for parameters display (debug use only)
#define REQUEST_RESOURCES_ID	1
#define SET_RESOURCES_ID		2
#define RELEASE_RESOURCES_ID	3
#define SET_CLIENTS_ID			4

#define QOS_LOWEST_PRIORITY		10

/*
 *	Macros
 */
#define COMPARE_GUIDS(a,b)	RtlEqualMemory((a), (b), sizeof(GUID))
#define ACQMUTEX(hMutex)											\
	while (WaitForSingleObject(hMutex, WAIT_ON_MUTEX_MSEC) == WAIT_TIMEOUT)		\
	{																\
		ERRORMSG(("Thread 0x%x waits on mutex\n", GetCurrentThreadId()));	\
	}																\
		
#define RELMUTEX(hMutex)	ReleaseMutex(hMutex)

/*
 *	Data Structures
 */

// internal resource request structure
typedef struct _resourcerequestint
{
	struct _resourcerequestint	*fLink;
	RESOURCEREQUEST		sResourceRequest;
	GUID				guidClientGUID;
	LPFNQOSNOTIFY		pfnQoSNotify;
	DWORD_PTR			dwParam;

} RESOURCEREQUESTINT, *LPRESOURCEREQUESTINT;

// internal resource structure
typedef struct _resourceint
{
	struct _resourceint	*fLink;
	RESOURCE			resource;
	int					nNowAvailUnits;
	RESOURCEREQUESTINT	*pRequestList;

} RESOURCEINT, *LPRESOURCEINT;

// internal client structure
typedef struct _clientint
{
	struct _clientint	*fLink;
	CLIENT				client;
	RESOURCEREQUESTINT	*pRequestList;

} CLIENTINT, *LPCLIENTINT;

class CQoS : public IQoS
{
public:
//	IUnknown methods
	STDMETHODIMP QueryInterface (REFIID riid, void **ppv);
	STDMETHODIMP_(ULONG) AddRef (void);
	STDMETHODIMP_(ULONG) Release (void);

//	IQoS methods
	STDMETHODIMP RequestResources (LPGUID lpStreamGUID,
										LPRESOURCEREQUESTLIST lpResourceRequestList,
										LPFNQOSNOTIFY lpfnQoSNotify,
										DWORD_PTR dwParam);
	STDMETHODIMP ReleaseResources (LPGUID lpStreamGUID,
										LPRESOURCEREQUESTLIST lpResourceRequestList);
	STDMETHODIMP GetResources (LPRESOURCELIST *lppResourceList);
	STDMETHODIMP SetResources (LPRESOURCELIST lpResourceList);
	STDMETHODIMP SetClients(LPCLIENTLIST lpClientList);
	STDMETHODIMP NotifyNow(void);
	STDMETHODIMP FreeBuffer(LPVOID lpBuffer);

//	IProps methods
	STDMETHODIMP SetProps (ULONG cValues,
							PPROPERTY pPropArray);
	STDMETHODIMP GetProps (PPROPTAGARRAY pPropTagArray,
							ULONG ulFlags,
							ULONG FAR *pcValues,
							PPROPERTY *ppPropArray);


	CQoS (void);
	~CQoS (void);
	HRESULT Initialize(void);

private:
// Private functions
	HRESULT QoSCleanup(void);
	BOOL AnyRequests(void);
	HRESULT FindClientsForResource(	DWORD dwResourceID,
									LPCLIENTINT pc,
									ULONG *puSamePriClients,
									ULONG *puLowerPriClients);
	HRESULT FreeListOfRequests(LPRESOURCEREQUESTINT *lppList);
	HRESULT StoreResourceRequest(LPGUID pClientGUID,
						LPRESOURCEREQUEST pResourceRequest,
						LPFNQOSNOTIFY pfnQoSNotify,
						DWORD_PTR dwParam,
						LPRESOURCEINT pResourceInt);
	HRESULT FreeResourceRequest(LPGUID pClientGUID,
								LPRESOURCEINT pResourceInt,
								int *pnUnits);
	HRESULT UpdateClientInfo (	LPGUID pClientGUID,
								LPFNQOSNOTIFY pfnQoSNotify);
	HRESULT UpdateRequestsForClient (LPGUID pClientGUID);
	HRESULT FindClient(LPGUID pClientGUID, LPCLIENTINT *ppClient);
	HRESULT StartQoSThread(void);
	HRESULT StopQoSThread(void);
	DWORD QoSThread(void);
	HRESULT NotifyQoSClient(void);

// Debug display functions
	void DisplayQoSObject(void);
	void DisplayRequestListInt(LPRESOURCEREQUESTINT prr, BOOL fDisplay);
	void DisplayRequestList(LPRESOURCEREQUESTLIST prrl);
	void DisplayParameters(ULONG nFunctionID, ULONG_PTR P1, ULONG_PTR P2, ULONG_PTR P3, ULONG_PTR P4, ULONG_PTR P5);
	void DisplayResourceList(LPRESOURCELIST prl);
	void DisplayClientList(LPCLIENTLIST pcl);

	friend DWORD QoSThreadWrapper(CQoS *pQoS);

// Variables
	int m_cRef;
	LPRESOURCEINT m_pResourceList;
	ULONG m_cResources;
	LPCLIENTINT m_pClientList;
	HANDLE m_evThreadExitSignal;
	HANDLE m_evImmediateNotify;
	HANDLE m_hThread;			// handle of the QoS notify thread
	BOOL m_bQoSEnabled;			// whether QoS is enabled or not
	BOOL m_bInNotify;
	ULONG m_nSkipHeartBeats;	// how many heartbeats should the QoS notify thread skip
	HWND m_hWnd;
	ULONG m_nLeaveForNextPri;	// percentage of the rsrc to leave for lower priority clients
    BOOL bWin9x;                //Windows 9x (TRUE) or NT (FALSE)
};

/*
 *	QoS Class factory
 */
typedef HRESULT (STDAPICALLTYPE *PFNCREATE)(IUnknown *, REFIID, void **);
class CClassFactory : public IClassFactory
{
    public:
        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, void **);
        STDMETHODIMP         LockServer(BOOL);

        CClassFactory(PFNCREATE);
        ~CClassFactory(void);

    protected:
        ULONG	m_cRef;
		PFNCREATE m_pfnCreate;
};

/*
 *	Globals
 */
EXTERN_C HANDLE g_hQoSMutex;
EXTERN_C class CQoS *g_pQoS;

/*
 *	Function prototypes
 */

#include <poppack.h> /* End byte packing */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\md5\md5c.c ===
/* MD5C.C - RSA Data Security, Inc., MD5 message-digest algorithm
 */

/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
rights reserved.

License to copy and use this software is granted provided that it
is identified as the "RSA Data Security, Inc. MD5 Message-Digest
Algorithm" in all material mentioning or referencing this software
or this function.

License is also granted to make and use derivative works provided
that such works are identified as "derived from the RSA Data
Security, Inc. MD5 Message-Digest Algorithm" in all material
mentioning or referencing the derived work.

RSA Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided "as is"
without express or implied warranty of any kind.

These notices must be retained in any copies of any part of this
documentation and/or software.
 */

#include "global.h"
#include "md5.h"

#include <memory.h>


/* Constants for MD5Transform routine.
 */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21


#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)

static void MD5Transform PROTO_LIST ((UINT4 [4], unsigned char [64]));
static void Encode PROTO_LIST
  ((unsigned char *, UINT4 *, unsigned int));
static void Decode PROTO_LIST
  ((UINT4 *, unsigned char *, unsigned int));
static void MD5_memcpy PROTO_LIST ((POINTER, POINTER, unsigned int));
static void MD5_memset PROTO_LIST ((POINTER, int, unsigned int));

#if defined(__cplusplus)
}
#endif  // (__cplusplus)



static unsigned char PADDING[64] = {
  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

/* F, G, H and I are basic MD5 functions.
 */
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))

/* ROTATE_LEFT rotates x left n bits.
 */
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
Rotation is separate from addition to prevent recomputation.
 */
#define FF(a, b, c, d, x, s, ac) { \
 (a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define GG(a, b, c, d, x, s, ac) { \
 (a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define HH(a, b, c, d, x, s, ac) { \
 (a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define II(a, b, c, d, x, s, ac) { \
 (a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }

/* MD5 initialization. Begins an MD5 operation, writing a new context.
 */
void MD5Init (context)
MD5_CTX *context;                                        /* context */
{
  context->count[0] = context->count[1] = 0;
  /* Load magic initialization constants.
*/
  context->state[0] = 0x67452301;
  context->state[1] = 0xefcdab89;
  context->state[2] = 0x98badcfe;
  context->state[3] = 0x10325476;
}

/* MD5 block update operation. Continues an MD5 message-digest
  operation, processing another message block, and updating the
  context.
 */
void MD5Update (context, input, inputLen)
MD5_CTX *context;                                        /* context */
unsigned char *input;                                /* input block */
unsigned int inputLen;                     /* length of input block */
{
  unsigned int i, index, partLen;

  /* Compute number of bytes mod 64 */
  index = (unsigned int)((context->count[0] >> 3) & 0x3F);

  /* Update number of bits */
  if ((context->count[0] += ((UINT4)inputLen << 3))
   < ((UINT4)inputLen << 3))
 context->count[1]++;
  context->count[1] += ((UINT4)inputLen >> 29);

  partLen = 64 - index;

  /* Transform as many times as possible.
*/
  if (inputLen >= partLen) {
 MD5_memcpy
   ((POINTER)&context->buffer[index], (POINTER)input, partLen);
 MD5Transform (context->state, context->buffer);

 for (i = partLen; i + 63 < inputLen; i += 64)
   MD5Transform (context->state, &input[i]);

 index = 0;
  }
  else
 i = 0;

  /* Buffer remaining input */
  MD5_memcpy
 ((POINTER)&context->buffer[index], (POINTER)&input[i],
  inputLen-i);
}

/* MD5 finalization. Ends an MD5 message-digest operation, writing the
  the message digest and zeroizing the context.
 */
void MD5Final (digest, context)
unsigned char digest[16];                         /* message digest */
MD5_CTX *context;                                       /* context */
{
  unsigned char bits[8];
  unsigned int index, padLen;

  /* Save number of bits */
  Encode (bits, context->count, 8);

  /* Pad out to 56 mod 64.
*/
  index = (unsigned int)((context->count[0] >> 3) & 0x3f);
  padLen = (index < 56) ? (56 - index) : (120 - index);
  MD5Update (context, PADDING, padLen);

  /* Append length (before padding) */
  MD5Update (context, bits, 8);
  /* Store state in digest */
  Encode (digest, context->state, 16);

  /* Zeroize sensitive information.
*/
  MD5_memset ((POINTER)context, 0, sizeof (*context));
}

/* MD5 basic transformation. Transforms state based on block.
 */
static void MD5Transform (state, block)
UINT4 state[4];
unsigned char block[64];
{
  UINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];

  Decode (x, block, 64);

  /* Round 1 */
  FF (a, b, c, d, x[ 0], S11, 0xd76aa478); /* 1 */
  FF (d, a, b, c, x[ 1], S12, 0xe8c7b756); /* 2 */
  FF (c, d, a, b, x[ 2], S13, 0x242070db); /* 3 */
  FF (b, c, d, a, x[ 3], S14, 0xc1bdceee); /* 4 */
  FF (a, b, c, d, x[ 4], S11, 0xf57c0faf); /* 5 */
  FF (d, a, b, c, x[ 5], S12, 0x4787c62a); /* 6 */
  FF (c, d, a, b, x[ 6], S13, 0xa8304613); /* 7 */
  FF (b, c, d, a, x[ 7], S14, 0xfd469501); /* 8 */
  FF (a, b, c, d, x[ 8], S11, 0x698098d8); /* 9 */
  FF (d, a, b, c, x[ 9], S12, 0x8b44f7af); /* 10 */
  FF (c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */
  FF (b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */
  FF (a, b, c, d, x[12], S11, 0x6b901122); /* 13 */
  FF (d, a, b, c, x[13], S12, 0xfd987193); /* 14 */
  FF (c, d, a, b, x[14], S13, 0xa679438e); /* 15 */
  FF (b, c, d, a, x[15], S14, 0x49b40821); /* 16 */

 /* Round 2 */
  GG (a, b, c, d, x[ 1], S21, 0xf61e2562); /* 17 */
  GG (d, a, b, c, x[ 6], S22, 0xc040b340); /* 18 */
  GG (c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */
  GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa); /* 20 */
  GG (a, b, c, d, x[ 5], S21, 0xd62f105d); /* 21 */
  GG (d, a, b, c, x[10], S22,  0x2441453); /* 22 */
  GG (c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */
  GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8); /* 24 */
  GG (a, b, c, d, x[ 9], S21, 0x21e1cde6); /* 25 */
  GG (d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */
  GG (c, d, a, b, x[ 3], S23, 0xf4d50d87); /* 27 */
  GG (b, c, d, a, x[ 8], S24, 0x455a14ed); /* 28 */
  GG (a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
  GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
  GG (c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
  GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */

  /* Round 3 */
  HH (a, b, c, d, x[ 5], S31, 0xfffa3942); /* 33 */
  HH (d, a, b, c, x[ 8], S32, 0x8771f681); /* 34 */
  HH (c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */
  HH (b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */
  HH (a, b, c, d, x[ 1], S31, 0xa4beea44); /* 37 */
  HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
  HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
  HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
  HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
  HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
  HH (c, d, a, b, x[ 3], S33, 0xd4ef3085); /* 43 */
  HH (b, c, d, a, x[ 6], S34,  0x4881d05); /* 44 */
  HH (a, b, c, d, x[ 9], S31, 0xd9d4d039); /* 45 */
  HH (d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */
  HH (c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
  HH (b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 */

  /* Round 4 */
  II (a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */
  II (d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */
  II (c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */
  II (b, c, d, a, x[ 5], S44, 0xfc93a039); /* 52 */
  II (a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */
  II (d, a, b, c, x[ 3], S42, 0x8f0ccc92); /* 54 */
  II (c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */
  II (b, c, d, a, x[ 1], S44, 0x85845dd1); /* 56 */
  II (a, b, c, d, x[ 8], S41, 0x6fa87e4f); /* 57 */
  II (d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */
  II (c, d, a, b, x[ 6], S43, 0xa3014314); /* 59 */
  II (b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */
  II (a, b, c, d, x[ 4], S41, 0xf7537e82); /* 61 */
  II (d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */
  II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb); /* 63 */
  II (b, c, d, a, x[ 9], S44, 0xeb86d391); /* 64 */

  state[0] += a;
  state[1] += b;
  state[2] += c;
  state[3] += d;

  /* Zeroize sensitive information.
*/
  MD5_memset ((POINTER)x, 0, sizeof (x));
}

/* Encodes input (UINT4) into output (unsigned char). Assumes len is
  a multiple of 4.
 */
static void Encode (output, input, len)
unsigned char *output;
UINT4 *input;
unsigned int len;
{
  unsigned int i, j;

  for (i = 0, j = 0; j < len; i++, j += 4) {
 output[j] = (unsigned char)(input[i] & 0xff);
 output[j+1] = (unsigned char)((input[i] >> 8) & 0xff);
 output[j+2] = (unsigned char)((input[i] >> 16) & 0xff);
 output[j+3] = (unsigned char)((input[i] >> 24) & 0xff);
  }
}

/* Decodes input (unsigned char) into output (UINT4). Assumes len is
  a multiple of 4.
 */
static void Decode (output, input, len)
UINT4 *output;
unsigned char *input;
unsigned int len;
{
  unsigned int i, j;

  for (i = 0, j = 0; j < len; i++, j += 4)
 output[i] = ((UINT4)input[j]) | (((UINT4)input[j+1]) << 8) |
   (((UINT4)input[j+2]) << 16) | (((UINT4)input[j+3]) << 24);
}

/* Note: Replace "for loop" with standard memcpy if possible.
 */

static void MD5_memcpy (output, input, len)
POINTER output;
POINTER input;
unsigned int len;
{
/*
  unsigned int i;

  for (i = 0; i < len; i++)
 output[i] = input[i];
*/
  memcpy(output,input,len);
}

/* Note: Replace "for loop" with standard memset if possible.
 */
static void MD5_memset (output, value, len)
POINTER output;
int value;
unsigned int len;
{
/*
  unsigned int i;

  for (i = 0; i < len; i++)
 ((char *)output)[i] = (char)value;
*/
  memset(output,value,len);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\md5\md5.h ===
/* MD5.H - header file for MD5C.C
 */

/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
rights reserved.

License to copy and use this software is granted provided that it
is identified as the "RSA Data Security, Inc. MD5 Message-Digest
Algorithm" in all material mentioning or referencing this software
or this function.

License is also granted to make and use derivative works provided
that such works are identified as "derived from the RSA Data
Security, Inc. MD5 Message-Digest Algorithm" in all material
mentioning or referencing the derived work.

RSA Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided "as is"
without express or implied warranty of any kind.

These notices must be retained in any copies of any part of this
documentation and/or software.
 */

/* MD5 context. */

typedef struct {
  unsigned int state[4];        /* state (ABCD) */
  unsigned int count[2];        /* number of bits, modulo 2^64 (lsb first) */
  unsigned char buffer[64];     /* input buffer */
} MD5_CTX;


#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)

void MD5Init (MD5_CTX *);
void MD5Update (MD5_CTX *, unsigned char *, unsigned int);
void MD5Final (unsigned char [16], MD5_CTX *);

#if defined(__cplusplus)
}
#endif  // (__cplusplus)

// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\qos\thread.cpp ===
/*
 -  THREAD.CPP
 -
 *	Microsoft NetMeeting
 *	Quality of Service DLL
 *	Quality of Service Notification Thread
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		10.30.96	Yoram Yaacovi		Created
 *
 *	Functions:
 *		CQoS::StartQoSThread
 *		CQoS::StopQoSThread
 *		CQoS::QoSThread
 *		QoSThreadWrapper
 */

#include "precomp.h"

/***************************************************************************

    Name      : CQoS::StartQoSThread

    Purpose   : Starts a QoS notification thread

    Parameters: None

	Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::StartQoSThread(void)
{
	HRESULT hr=NOERROR;
	HANDLE hThread;
	DWORD idThread;

	// prepare the structrue for the thread

	// now spwan the thread
	hThread = CreateThread (NULL,
							0,						// Default (same as main thread) stack size
							(LPTHREAD_START_ROUTINE) QoSThreadWrapper,
							(LPVOID) this,			// Pass the object pointer to thread
							0,						// Run thread now
							&idThread);
	ASSERT(hThread);
	if (!hThread)
	{
		ERRORMSG(("StartQoSThread: failed to create thread: %x\n", GetLastError()));
		hr = E_FAIL;
	}

	m_hThread = hThread;
		
	return hr;
}

/***************************************************************************

    Name      : CQoS::StopQoSThread

    Purpose   : Stops a QoS notification thread

    Parameters: None

	Returns   : HRESULT

    Comment   : It is assumed that when the thread that calls StopQoSThread
				has the QoS mutex.

***************************************************************************/
HRESULT CQoS::StopQoSThread(void)
{
	HRESULT hr=NOERROR;
	HANDLE evExitSignal=m_evThreadExitSignal;
	DWORD dwExitCode=0;
	ULONG i=0;
	HANDLE hThread=NULL;

	if (m_hThread)
	{
		// tell the thread to exit
		SetEvent(evExitSignal);

		hThread = m_hThread;
		m_hThread = NULL;

		// the thread might need the mutex to exit
		RELMUTEX(g_hQoSMutex);

		// wait for the thread to terminate
		if (WaitForSingleObject(hThread, 1000) == WAIT_TIMEOUT)
		{
			// if it didn't take its own life, you take it...
			DEBUGMSG(ZONE_THREAD,("StopQoSThread: QoS thread didn't properly terminate within 1 second. Terminating it\n"));
			TerminateThread(hThread, 0);
		}

		// re-acquire the mutex (for balance)
		ACQMUTEX(g_hQoSMutex);

		CloseHandle(hThread);
	}
		
	return hr;
}


/***************************************************************************

    Name      : CQoS::NotifyQoSClient

    Purpose   : Notifies a QoS client on change in resource availability

    Parameters:

	Returns   : HRESULT

    Comment   : prrl is a pointer to a list of resource requests. This
				list has two purposes:
				1.	The QoS module will fill the list with the current
					availability of resources
				2.	The client will fill the list with its resource requests
				The QoS module is allocating the memory for the resource
				requests list. It will allocate one resource request per
				each available resource.

***************************************************************************/
HRESULT CQoS::NotifyQoSClient(void)
{
	HRESULT hr=NOERROR;
	LPRESOURCEREQUESTLIST prrl=NULL;
	LPRESOURCEINT pr=NULL;
	LPCLIENTINT pc=NULL;
	ULONG cResources=m_cResources;
	LPRESOURCEINT pResourceList=m_pResourceList;
	ULONG i=0;
	LPFNQOSNOTIFY pNotifyProc=NULL;
	DWORD dwParam=NULL;

	/*
	 *	here's what happens:
	 *
	 *	the QoS module creates a new resource list from the old one,
	 *	making all resources fully available. It satisfies the new
	 *	client resource requests from this new list.
	 */

	// don't bother if no clients or no resources
	if (!m_pClientList || !m_pResourceList)
	{
		goto out;
	}

	// first update the request list for all clients
	pc = m_pClientList;
	while (pc)
	{
		UpdateRequestsForClient (&(pc->client.guidClientGUID));
		pc = pc->fLink;
	}

	// we are going to wipe all requests from the resource
	// lists, and set all resources back to full availability
	pr = m_pResourceList;
	while (pr)
	{
		// free the request list
		FreeListOfRequests(&(pr->pRequestList));

		// set the resource back to full availability
		pr->nNowAvailUnits = pr->resource.nUnits;

		// next resource
		pr = pr->fLink;
	}

	/*
	 *	Build resource request lists for each client and call it
	 */
	// allocate space for the resource list (which already includes
	// space for one resource), plus (cResources-1) more resources
	prrl = (LPRESOURCEREQUESTLIST) MEMALLOC(sizeof(RESOURCEREQUESTLIST) +
									(cResources-1)*sizeof(RESOURCEREQUEST));
	if (!prrl)
	{
		hr = E_OUTOFMEMORY;
		ERRORMSG(("NotifyQoSClient: MEMALLOC failed in NotifyQoSClient\n"));
		goto out;
	}

	RtlZeroMemory((PVOID) prrl, sizeof(RESOURCEREQUESTLIST) +
									(cResources-1)*sizeof(RESOURCEREQUEST));

	// call each client, in order of priority, with the available resource list
	pc = m_pClientList;
	while (pc)
	{
		LPFNQOSNOTIFY pNotifyProc=NULL;
		DWORD_PTR dwParam=0;
		LPGUID lpGUID=NULL;
		ULONG i=0;
		LPRESOURCEREQUESTINT pcrr=NULL;
		ULONG nSamePriClients=1;
		ULONG nLowerPriClients=0;

		/*
		 *	Building the request list
		 */

		pcrr = pc->pRequestList;
		while (pcrr)
		{
			// remember the address of the notify proc for this client and its GUID
			pNotifyProc = pcrr->pfnQoSNotify;
			dwParam = pcrr->dwParam;
			lpGUID = &(pcrr->guidClientGUID);

			// add the resource to the requestlist we'll send to this client
			prrl->aRequests[i].resourceID = pcrr->sResourceRequest.resourceID;

			// find current availability of the resource
			pr = m_pResourceList;
			while (pr)
			{
				if (pr->resource.resourceID == pcrr->sResourceRequest.resourceID)
				{
					ULONG nNowAvailUnits=pr->nNowAvailUnits;

					// find if there are other clients for this resource
					FindClientsForResource(	pr->resource.resourceID,
											pc,
											&nSamePriClients,
											&nLowerPriClients);

					// leave some of the resource for the next priority clients, if any
					if (nLowerPriClients)
						nNowAvailUnits  = (nNowAvailUnits * (100 - m_nLeaveForNextPri)) / 100;

					prrl->aRequests[i].nUnitsMin = nNowAvailUnits / nSamePriClients;
					prrl->aRequests[i].nUnitsMax = nNowAvailUnits;
					break;
				}

				// next resource
				pr = pr->fLink;
			}

			// next request in the list we're making
			i++;

			// next request
			pcrr = pcrr->fLink;
		}


		// if we have requests from this client, call its notify callback
		prrl->cRequests = i;
		if (pNotifyProc)
		{
			// call the notify callback
			hr = (pNotifyProc)(prrl, dwParam);

			if (SUCCEEDED(hr))
			{
				// the returned request list contains what the client wants
				// request them on behalf of the client
				// let RequestResources know that we're calling from the notify proc
				m_bInNotify = TRUE;
				hr = RequestResources(lpGUID, prrl, pNotifyProc, dwParam);
				if (FAILED(hr))
				{
					ERRORMSG(("NotifyQoSClient: client returned bad resource request list\n"));
				}
				m_bInNotify = FALSE;
			}
		}

		pc = pc->fLink;
	}

out:
	if (prrl)
		MEMFREE(prrl);

	return hr;
}

/***************************************************************************

    Name      : CQoS::QoSThread

    Purpose   : QoS notification thread

    Parameters: None

	Returns   :

    Comment   :

***************************************************************************/
DWORD CQoS::QoSThread(void)
{
	int nTimeout;
	ULONG rc=0;
	HANDLE evSignalExit=m_evThreadExitSignal;
	HANDLE aHandles[2] = {m_evThreadExitSignal, m_evImmediateNotify};

	// wake up every N seconds and notify clients
	RegEntry reQoS(QOS_KEY,
					HKEY_LOCAL_MACHINE,
					FALSE,
					KEY_READ);

	nTimeout = reQoS.GetNumberIniStyle(TEXT("Timeout"), 3000);

	while (1)
	{
		rc = WaitForMultipleObjects(2, aHandles, FALSE, nTimeout);

		// if a timeout or a signal to do an immediate notify cycle...
		if ((rc == WAIT_TIMEOUT) || ((rc - WAIT_OBJECT_0) == 1))
		{	// ..do it
			ACQMUTEX(g_hQoSMutex);

			// NOTE: it is possible that while waiting on the mutex, the thread
			// was stopped (no more requests). In this case, the thread will do
			// a unnecessary (though harmless, since no requests) notify cycle

			DEBUGMSG(ZONE_THREAD,("QoSThread: Notify thread heartbeat, why=%s\n",
						(rc == WAIT_TIMEOUT ? "timeout" : "notify")));
		
			// notify clients, unless this heartbeat should be skipped
			if (m_nSkipHeartBeats == 0)
			{
				DEBUGMSG(ZONE_THREAD,("QoSThread: Notifying client\n"));
				NotifyQoSClient();
			}

			// update the skip counter
			(m_nSkipHeartBeats ? m_nSkipHeartBeats-- : 0);

			RELMUTEX(g_hQoSMutex);
		}

		// anything else (WAIT_FAILED, Exit signal), bail out
		else
			break;
	}
		
	// this is just like ExitThread()
	DEBUGMSG(ZONE_THREAD,("QoSThread: Notify thread exiting...\n"));
	return 0L;

}

/***************************************************************************

    Name      : QoSThreadWrapper

    Purpose   : Wrapper for the QoS notification thread

    Parameters: pQoS - pointer to the QoS object

	Returns   :

    Comment   :

***************************************************************************/
DWORD QoSThreadWrapper(CQoS *pQoS)
{
	return pQoS->QoSThread();
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\md5\global.h ===
/* GLOBAL.H - RSAREF types and constants
 */

/* PROTOTYPES should be set to one if and only if the compiler supports
  function argument prototyping.
The following makes PROTOTYPES default to 0 if it has not already
  been defined with C compiler flags.
 */
#ifndef PROTOTYPES
#define PROTOTYPES 0
#endif

/* POINTER defines a generic pointer type */
typedef unsigned char *POINTER;

/* UINT2 defines a two byte word */
typedef unsigned short int UINT2;

/* UINT4 defines a four byte word */
#if defined(__alpha)
typedef unsigned int UINT4;
#else
typedef unsigned long int UINT4;
#endif

/* PROTO_LIST is defined depending on how PROTOTYPES is defined above.
If using PROTOTYPES, then PROTO_LIST returns the list, otherwise it
  returns an empty list.
 */
#if PROTOTYPES
#define PROTO_LIST(list) list
#else
#define PROTO_LIST(list) ()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\qos\qos.cpp ===
/*
 -  QOS.CPP
 -
 *	Microsoft NetMeeting
 *	Quality of Service DLL
 *	IQoS interfaces
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		10.23.96	Yoram Yaacovi		Created
 *
 *	Functions:
 *		IQoS
 *			CQoS::QueryInterface
 *			CQoS::AddRef
 *			CQoS::Release
 *			CQoS::RequestResources
 *			CQoS::ReleaseResources
 *			CQoS::SetClients
 *			CQoS::SetResources
 *			CQoS::GetResources
 *			CQoS::FreeBuffer
 *		Public:
 *			CQoS::CQoS
 *			CQoS::~CQoS
 *			CQoS::Initialize
 *		Private
 *			CQoS::AnyRequests
 *			CQoS::FindClientsForResource
 *			CQoS::StoreResourceRequest
 *			CQoS::FreeResourceRequest
 *			CQoS::UpdateClientInfo
 *			CQoS::QoSCleanup
 *			CQoS::FindClient
 *			CQoS::UpdateRequestsForClient
 *		External
 *			CreateQoS
 *			QoSEntryPoint
 */

#include "precomp.h"

EXTERN_C int g_cQoSObjects=0;
EXTERN_C HANDLE g_hQoSMutex=NULL;
class CQoS *g_pQoS;

#ifdef DEBUG
HDBGZONE    ghDbgZoneQoS = NULL;

static PTCHAR _rgZonesQos[] = {
	TEXT("qos"),
	TEXT("Init"),
	TEXT("IQoS"),
	TEXT("Thread"),
	TEXT("Structures"),
	TEXT("Parameters"),
};
#endif /* DEBUG */

/***************************************************************************

    Name      : QoSCleanup

    Purpose   : Cleans up a QoS object before releasing (free memory, etc)

    Parameters: pqos - pointer to a QoS pbject

	Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::QoSCleanup ()
{
	HRESULT hr=NOERROR;
	LPRESOURCEINT pr=NULL;
	LPCLIENTINT pc=NULL;

	ACQMUTEX(g_hQoSMutex);

	/*
	 *	Free memory
	 */
	// traverse and free all the memory allocated by the QoS object
	// resources and requests first
	pr = m_pResourceList;
	while (pr)
	{
		LPRESOURCEINT prNext=pr->fLink;

		// first, delete the request list for this resource
		FreeListOfRequests(&(pr->pRequestList));

		MEMFREE(pr);
		pr = prNext;
	}
	m_pResourceList = 0;

	// next is clients
	pc = m_pClientList;
	while (pc)
	{
		LPCLIENTINT pcNext=pc->fLink;
		
		// delete the request list for this client
		FreeListOfRequests(&(pc->pRequestList));

		// now delete the client itself
		MEMFREE(pc);
		pc = pcNext;
	}
	m_pClientList = 0;

	// terminate the QoS thread and let it exit
	// the thread should really be terminated when the last request
	// is released, so this is just a safety measure
	StopQoSThread();

	// delete the events
	if (m_evImmediateNotify)
		CloseHandle(m_evImmediateNotify);
	m_evImmediateNotify = NULL;

	if (m_evThreadExitSignal)
		CloseHandle(m_evThreadExitSignal);
	m_evThreadExitSignal = NULL;

	RELMUTEX(g_hQoSMutex);

	return hr;
}

/***************************************************************************

    Name      : AnyRequests

    Purpose   : Finds out if there are any resource requests

    Parameters: none

	Returns   : TRUE - there is at least one request

    Comment   :

***************************************************************************/
BOOL CQoS::AnyRequests(void)
{
	LPRESOURCEINT pr=NULL;
	BOOL bAnyRequests=FALSE;

	pr = m_pResourceList;
	while (pr)
	{
		if (pr->pRequestList)
		{
			bAnyRequests=TRUE;
			break;
		}

		// next resource
		pr = pr->fLink;
	}

	return bAnyRequests;
}

/***************************************************************************

    Name      : FindClientsForResource

    Purpose   : Finds if there are clients for a specific resource

    Parameters: [in] dwResourceID = the ID of the resource
				[in] pc = client pointer to start searching from
				[out] puSamePriClients = number of clients with the same
					priority for this resource is returned here
				[out] puLowerPriClients = number of clients with lower
					priority for this resource is returned here

	Returns   : HRESULT

    Comment   : This function is NOT general purpose. It only counts clients
				with the same priority DOWN the list.

***************************************************************************/
HRESULT CQoS::FindClientsForResource(	DWORD dwResourceID,
										LPCLIENTINT pc,
										ULONG *puSamePriClients,
										ULONG *puLowerPriClients)
{
	LPCLIENTINT pctemp=pc->fLink;
	LPRESOURCEREQUESTINT pcrr=NULL;

	*puLowerPriClients = 0;
	*puSamePriClients = 1;	// the first client (at 'pc')
	while (pctemp)
	{
		LPRESOURCEINT pr=NULL;
		
		// does this client need this specific resource ?
		pcrr = pctemp->pRequestList;
		while (pcrr)
		{
			if (pcrr->sResourceRequest.resourceID == dwResourceID)
			{
				// it is either a same priority client or a lower priority
				// client (the list is sorted)
				(pctemp->client.priority == pc->client.priority ?
					(*puSamePriClients)++ :
					(*puLowerPriClients)++);
				break;
			}

			// next request for this client
			pcrr = pcrr->fLink;
		}
		
		pctemp = pctemp->fLink;
	}	

	return NOERROR;
}

/***************************************************************************

    Name      : FreeListOfRequests

    Purpose   : Free all records of a linked list of requests, given the
				address of the list pointer. Zero's the list pointer

    Parameters: lppRequestList - address of the pointer to the beginning
					of the list

	Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::FreeListOfRequests(LPRESOURCEREQUESTINT *lppRequestList)
{
	LPRESOURCEREQUESTINT prr=*lppRequestList;
	HRESULT hr=NOERROR;

	while (prr)
	{
		LPRESOURCEREQUESTINT prrNext=prr->fLink;

		MEMFREE(prr);
		prr = prrNext;
	}

	*lppRequestList = NULL;

	return hr;
}

/***************************************************************************

    Name      : FreeResourceRequest

    Purpose   : Frees resource units and respective resource requests

    Parameters: pClientGUID - the GUID of the calling client (stream)
				pnUnits - a pointer of where to return the number of units freed
				pResourceInt - pointer to the resource being freed

	Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::FreeResourceRequest (	LPGUID pClientGUID,
									LPRESOURCEINT pResourceInt,
									int *pnUnits)
{
	HRESULT hr=NOERROR;
	LPRESOURCEREQUESTINT prr=NULL, *prrPrev=NULL;

	// find the request from this client
	prr = pResourceInt->pRequestList;
	prrPrev = &(pResourceInt->pRequestList);
	while (prr)
	{
		if (COMPARE_GUIDS(&(prr->guidClientGUID), pClientGUID))
		{
			// we do have a request from this client.
			// reclaim the units...
			*pnUnits = prr->sResourceRequest.nUnitsMin;

			// ...and remove it
			*prrPrev = prr->fLink;
			MEMFREE(prr);

			// we're done.
			hr = NOERROR;
			goto out;
		}

		prrPrev = &(prr->fLink);
		prr = prr->fLink;
	}

	hr = QOS_E_NO_SUCH_REQUEST;

out:
	return hr;
}

/***************************************************************************

    Name      : StoreResourceRequest

    Purpose   : Stores a resource request with the resource

    Parameters: pClientGUID - the GUID of the calling client (stream)
				pResourceRequest - the request to store
				pfnQoSNotify - a pointer to a notification function for the
					requesting client
				pResourceInt - pointer to the resource on which to store the
					request

	Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::StoreResourceRequest (LPGUID pClientGUID,
									LPRESOURCEREQUEST pResourceRequest,
									LPFNQOSNOTIFY pfnQoSNotify,
									DWORD_PTR dwParam,
									LPRESOURCEINT pResourceInt)
{
	HRESULT hr=NOERROR;
	LPRESOURCEREQUESTINT prr=NULL, *prrPrev=NULL;
	BOOL fRequestFound=FALSE;

	/*
	 *	Store the request
	 */

	// do we already have a request from this client ?
	prr = pResourceInt->pRequestList;
	prrPrev = &(pResourceInt->pRequestList);
	while (prr)
	{
		if (COMPARE_GUIDS(&(prr->guidClientGUID), pClientGUID))
		{
			// we do have a request from this client. override it.
			RtlCopyMemory(	&(prr->sResourceRequest),
							pResourceRequest,
							sizeof(RESOURCEREQUEST));
			RtlCopyMemory(&(prr->guidClientGUID), pClientGUID, sizeof(GUID));
			prr->pfnQoSNotify = pfnQoSNotify;
			prr->dwParam = dwParam;

			// we're done.
			hr = NOERROR;
			fRequestFound = TRUE;
			break;
		}

		prrPrev = &(prr->fLink);
		prr = prr->fLink;
	}

	if (!fRequestFound)
	{
		// not found. make one
		prr = (LPRESOURCEREQUESTINT) MEMALLOC(sizeof(RESOURCEREQUESTINT));
		ASSERT(prr);
		if (!prr)
		{
			ERRORMSG(("StoreResourceRequest: MEMALLOC failed on RESOURCEREQUESTINT\n"));
			hr = E_OUTOFMEMORY;
			goto out;
		}
		
		*prrPrev = prr;
		prr->fLink = NULL;

	}

	// whether found or made, copy the contents in
	RtlCopyMemory(	&(prr->sResourceRequest),
					pResourceRequest,
					sizeof(RESOURCEREQUEST));
	RtlCopyMemory(&(prr->guidClientGUID), pClientGUID, sizeof(GUID));
	prr->pfnQoSNotify = pfnQoSNotify;
	prr->dwParam = dwParam;

out:
	return hr;
}

/***************************************************************************

    Name      : UpdateClientInfo

    Purpose   : Updates the client info when a resource request is granted

    Parameters: pClientGUID - the GUID of the calling client (stream)
				pfnQoSNotify - a pointer to a notification function for the
					requesting client

	Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::UpdateClientInfo (LPGUID pClientGUID,
								LPFNQOSNOTIFY pfnQoSNotify)
{
	HRESULT hr=NOERROR;
	LPCLIENTLIST pcl=NULL;

	/*
	 *	Update client info
	 */

	// we'll do this through calling the SetClients method
	// allocate and fill a CLIENTLIST structure
	pcl = (LPCLIENTLIST) MEMALLOC(sizeof(CLIENTLIST));
	if (!pcl)
	{
		ERRORMSG(("UpdateClientInfo: MEMALLOC failed\n"));
		hr = E_OUTOFMEMORY;
		goto out;
	}

	RtlZeroMemory((PVOID) pcl, sizeof(CLIENTLIST));

	// fill in the resource list
	pcl->cClients = 1;
	RtlCopyMemory(&(pcl->aClients[0].guidClientGUID), pClientGUID, sizeof(GUID));
	pcl->aClients[0].priority = QOS_LOWEST_PRIORITY;

	// set the clients info on the QoS module
	hr = SetClients(pcl);

out:
	if (pcl)
		MEMFREE(pcl);

	return hr;
}

/***************************************************************************

    Name      : UpdateRequestsForClient

    Purpose   : Update a client's request list by finding all existing resource
					requests for this client

    Parameters: pClientGUID - the GUID of the calling client (stream)

	Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::UpdateRequestsForClient (LPGUID pClientGUID)
{
	HRESULT hr=NOERROR;
	LPRESOURCEINT pr=NULL;
	LPCLIENTINT pc=NULL;
	LPRESOURCEREQUESTINT prr=NULL, *pcrrfLink=NULL, pcrr=NULL;

	/*
	 *	get rid of the current request list for this client
	 */
	// find the client first
	hr = FindClient(pClientGUID, &pc);
	if (FAILED(hr) || !pc)
	{
		hr = QOS_E_NO_SUCH_CLIENT;
		goto out;
	}

	// now delete old request list
	FreeListOfRequests(&(pc->pRequestList));

	/*
	 *	create and add the new request list
	 */
	pr = m_pResourceList;
	pcrrfLink = &(pc->pRequestList);
	while (pr)
	{
		prr = pr->pRequestList;
		while (prr)
		{
			if (COMPARE_GUIDS(&(prr->guidClientGUID), pClientGUID))
			{
				// we found a request from this client.
				// allocate memory for it, and copy it in
				pcrr = (LPRESOURCEREQUESTINT) MEMALLOC(sizeof(RESOURCEREQUESTINT));
				ASSERT(pcrr);
				if (!pcrr)
				{
					ERRORMSG(("UpdateRequestsForClient: MEMALLOC failed on RESOURCEREQUESTINT\n"));
					hr = E_OUTOFMEMORY;
					goto out;
				}
		
				// copy the contents in
				RtlCopyMemory(pcrr, prr, sizeof(RESOURCEREQUESTINT));

				// need a different fLink for the client request list
				*pcrrfLink = pcrr;
				pcrr->fLink = NULL;
				pcrrfLink = &(pcrr->fLink);
			}

			// next request
			prr = prr->fLink;
		}

		// next resource
		pr = pr->fLink;
	}

out:
	return hr;
}

/***************************************************************************

    Name      : FindClient

    Purpose   : Finds and returns a client record

    Parameters: pClientGUID - the GUID whose record to find
				ppClient - address of where to put a pointer to the client found

	Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::FindClient(LPGUID pClientGUID, LPCLIENTINT *ppClient)
{
	LPCLIENTINT pc=NULL;
	HRESULT hr=NOERROR;

	*ppClient = NULL;
	pc = m_pClientList;
	while (pc)
	{
		if (COMPARE_GUIDS(&(pc->client.guidClientGUID), pClientGUID))
		{
			*ppClient = pc;
			goto out;
		}

		// next client
		pc = pc->fLink;
	}

	hr = QOS_E_NO_SUCH_CLIENT;

out:
	return hr;
}

/***************************************************************************

    IUnknown Methods

***************************************************************************/
HRESULT CQoS::QueryInterface (REFIID riid, LPVOID *lppNewObj)
{
    HRESULT hr = NOERROR;

	DEBUGMSG(ZONE_IQOS,("IQoS::QueryInterface\n"));

    if (IsBadReadPtr(&riid, (UINT) sizeof(IID)))
    {
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }

    if (IsBadWritePtr(lppNewObj, sizeof(LPVOID)))
    {
        hr = ResultFromScode(E_INVALIDARG);
        goto out;
    }
	
	*lppNewObj = 0;
	if (riid == IID_IUnknown || riid == IID_IQoS)
		*lppNewObj = (IQoS *) this;
	else
	{
		hr = E_NOINTERFACE;
		goto out;
	}	
	
	((IUnknown *)*lppNewObj)->AddRef ();

out:
	DEBUGMSG(ZONE_IQOS,("IQoS::QueryInterface - leave, hr=0x%x\n", hr));
	return hr;
}

ULONG CQoS::AddRef (void)
{
	DEBUGMSG(ZONE_IQOS,("IQoS::AddRef\n"));

	InterlockedIncrement((long *) &m_cRef);

	DEBUGMSG(ZONE_IQOS,("IQoS::AddRef - leave, m_cRef=%d\n", m_cRef));

	return m_cRef;
}

ULONG CQoS::Release (void)
{
	DEBUGMSG(ZONE_IQOS,("IQoS::Release\n"));

	// if the cRef is already 0 (shouldn't happen), assert, but let it through
	ASSERT(m_cRef);

	if (InterlockedDecrement((long *) &m_cRef) == 0)
	{
		if (m_bQoSEnabled)
			QoSCleanup();
		delete this;
		DEBUGMSG(ZONE_IQOS,("IQoS::Final Release\n"));
		return 0;
	}

	DEBUGMSG(ZONE_IQOS,("IQoS::Release - leave, m_cRef=%d\n", m_cRef));
	
	return m_cRef;
}

/***************************************************************************

    Name      : CQoS::RequestResources

    Purpose   : Requests resources

    Parameters: lpStreamGUID - the GUID of the calling client (stream)
				lpResourceRequestList - a list of resource requests that
					the caller wants to reserve
				lpfnQoSNotify - a pointer to a notification function for the
					requesting client

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::RequestResources (LPGUID lpClientGUID,
								LPRESOURCEREQUESTLIST lpResourceRequestList,
								LPFNQOSNOTIFY lpfnQoSNotify,
								DWORD_PTR dwParam)
{
	HRESULT hr = NOERROR;
	ULONG i;
	BOOL fResourceFound=FALSE, fRequestGranted=FALSE;
	LPRESOURCEINT pResourceInt=NULL, *pPrevResourcefLink=NULL;
	RESOURCEREQUEST *pResourceRequest=NULL;

	DEBUGMSG(ZONE_IQOS,("IQoS::RequestResources\n"));
	
	/*
	 *	Parameter validation
	 */

	// lpResourceRequestList should at least have a count DWORD
	// must have a GUID and a notify callback
	if (!lpResourceRequestList ||
		IsBadReadPtr(lpResourceRequestList, (UINT) sizeof(DWORD)) ||
		!lpClientGUID	||
		!lpfnQoSNotify)
	{
		hr = E_INVALIDARG;
		goto out_nomutex;
	}

	DISPLAYPARAMETERS(	REQUEST_RESOURCES_ID,
						lpClientGUID,
						lpResourceRequestList,
						lpfnQoSNotify,
						dwParam,
						0);

	ACQMUTEX(g_hQoSMutex);
	
	if (!m_bQoSEnabled)
		// just return
		goto out;

	/*
	 *	Find and allocate the resources
	 */

	// for each requested resource
	pResourceRequest=lpResourceRequestList->aRequests;
	for (i=0; i < lpResourceRequestList->cRequests; i++)
	{
		pResourceInt = m_pResourceList;
		fResourceFound = FALSE;
		// find the resource
		while (pResourceInt)
		{
			if (pResourceInt->resource.resourceID == pResourceRequest[i].resourceID)
			{	// resource found
				// see if the resource is available
				// priority will be handled at the first notify callback
				// CHECK: add nUnitsMax handling
				if (pResourceRequest[i].nUnitsMin <= pResourceInt->nNowAvailUnits)
				{
					// resource is available. take the requested share.
					pResourceInt->nNowAvailUnits -= pResourceRequest[i].nUnitsMin;

					// store a local copy of the request
					pResourceRequest[i].hResult = StoreResourceRequest(lpClientGUID,
										&(pResourceRequest[i]),
										lpfnQoSNotify,
										dwParam,
										pResourceInt);
					// if we failed storing, propagate the result to the bottom line
					// returned result
					if (FAILED(pResourceRequest[i].hResult))
					{
						hr = pResourceRequest[i].hResult;
					}
					else
					{	// at least one request was granted to this client
						fRequestGranted = TRUE;
					}
				}
				else	// resource not available
				{
					// let the client know how much is available
					pResourceRequest[i].nUnitsMin = pResourceInt->nNowAvailUnits;
					pResourceRequest[i].hResult = QOS_E_RES_NOT_ENOUGH_UNITS;
					hr = QOS_E_REQ_ERRORS;
				}
				
				fResourceFound = TRUE;

				break;
			}

			// not this one. try next one.
			pResourceInt = pResourceInt->fLink;
		
		}	// while

		if (!fResourceFound)
		{
			pResourceRequest[i].hResult = QOS_E_RES_NOT_AVAILABLE;
			hr = QOS_E_REQ_ERRORS;
		}

		// next request
	}	// for
			
	// if we allocated resources to this client, add it to the client list,
	// provided that it is not already in the list
	// special case: if the call to RequestResources was made from the QoS
	// notification proc, no need to update the client info. Actually, it will
	// be bad to do this, since we are traversing the client list in the
	// notify proc right at this moment...
	if (fRequestGranted && !m_bInNotify)
	{	// add (or update) the client list with this client
		HRESULT hrTemp=NOERROR;
		LPCLIENTINT pc=NULL;

		// if the client is not already in the client list - add it
		FindClient(lpClientGUID, &pc);
		if (!pc)
		{
			hrTemp = UpdateClientInfo (lpClientGUID, lpfnQoSNotify);
			if (FAILED(hrTemp))
				hr = hrTemp;
		}

		// also, make a note that RequestResources has been called. This will
		// make the QoS thread skip one heartbeat in order not call a client
		// too early
		m_nSkipHeartBeats = 1;

		// we have at least one request, so spawn the QoS thread, if not
		// already running
		if (!m_hThread)
			hrTemp = StartQoSThread();

	}
	
out:
	DISPLAYQOSOBJECT();
	RELMUTEX(g_hQoSMutex);
out_nomutex:
	DEBUGMSG(ZONE_IQOS,("IQoS::RequestResources - leave, hr=0x%x\n", hr));
	return hr;
}

/***************************************************************************

    Name      : CQoS::ReleaseResources

    Purpose   : Releases resources

    Parameters: lpClientGUID - the GUID of the calling client (stream)
				lpResourceRequestList - a list of resource requests that
					the caller wants to reserve

    Returns   : HRESULT

    Comment   : The values in the resource list are ignored. The resources
				specified are freed.

***************************************************************************/
HRESULT CQoS::ReleaseResources (LPGUID lpClientGUID,
								LPRESOURCEREQUESTLIST lpResourceRequestList)
{
	ULONG i;
	int nUnits=0;
	BOOL fResourceFound=FALSE;
	LPRESOURCEINT pResourceInt=NULL, *pPrevResourcefLink=NULL;
	RESOURCEREQUEST *pResourceRequest=NULL;
	HRESULT hr = NOERROR;

	DEBUGMSG(ZONE_IQOS,("IQoS::ReleaseResources\n"));

	/*
	 *	parameter validation
	 */

	// lpResourceRequestList should at least have a count DWORD
	if (!lpResourceRequestList ||
		IsBadReadPtr(lpResourceRequestList, (UINT) sizeof(DWORD)))
	{
		hr = E_INVALIDARG;
		goto out_nomutex;
	}

	DISPLAYPARAMETERS(	RELEASE_RESOURCES_ID,
						lpClientGUID,
						lpResourceRequestList,
						0,
						0,
						0);

	ACQMUTEX(g_hQoSMutex);

	if (!m_bQoSEnabled)
		// just return
		goto out;

	// for each requested resource
	pResourceRequest=lpResourceRequestList->aRequests;
	for (i=0; i < lpResourceRequestList->cRequests; i++)
	{
		// make sure we start with no error (caller might not cleared last hresult)
		pResourceRequest[i].hResult = NOERROR;
		pResourceInt = m_pResourceList;
		fResourceFound = FALSE;
		// find the resource
		while (pResourceInt)
		{
			if (pResourceInt->resource.resourceID == pResourceRequest[i].resourceID)
			{	// resource found
				// free the local copy of the request
				pResourceRequest[i].hResult = FreeResourceRequest(lpClientGUID,
									pResourceInt,
									&nUnits);
				
				// if succeeded, claim the units back
				if (SUCCEEDED(pResourceRequest[i].hResult) && (nUnits >= 0))
				{
					// add the freed units
					pResourceInt->nNowAvailUnits += nUnits;
					// in case something went wrong and we now have more available units
					// than total ones
					// NOTE: the ASSERT below is no longer proper. If SetResources was called,
					// and decreased the total units for a resource while there were
					// requests on this resource, the available units for this resource
					// might exceed the total one if released. Since QoS will auto-repair
					// this in the next notify cycle, the window for this is very small
					// ASSERT(!(pResourceInt->nNowAvailUnits > pResourceInt->resource.nUnits));
					if (pResourceInt->nNowAvailUnits > pResourceInt->resource.nUnits)
					{	// we don't want to have more available units than total
						pResourceInt->nNowAvailUnits = pResourceInt->resource.nUnits;
					}
				}
				else
				{
					// no such request
					pResourceRequest[i].hResult = QOS_E_NO_SUCH_REQUEST;
					hr = QOS_E_REQ_ERRORS;
				}
				
				fResourceFound = TRUE;

				break;
			}

			// not this one. try next one.
			pResourceInt = pResourceInt->fLink;
		
		}	// while

		if (!fResourceFound)
		{
			pResourceRequest[i].hResult = QOS_E_NO_SUCH_RESOURCE;
			hr = QOS_E_REQ_ERRORS;
		}
	
		// next request
	}

	// if no requests left, can let the notification thread go...
	if (m_hThread	&&
		!AnyRequests())
	{
		// stop the thread
		StopQoSThread();
	}

out:
	DISPLAYQOSOBJECT();
	RELMUTEX(g_hQoSMutex);

out_nomutex:
	DEBUGMSG(ZONE_IQOS,("IQoS::ReleaseResources - leave, hr=0x%x\n", hr));
	return hr;
}

/***************************************************************************

    Name      : CQoS::SetResources

    Purpose   : Sets the available resources on the QoS module

    Parameters: lpResourceList - list of resources and their availability

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::SetResources (LPRESOURCELIST lpResourceList)
{
	HRESULT hr = NOERROR;
	ULONG i;
	BOOL fResourceFound=FALSE;
	LPRESOURCEINT pResourceInt=NULL, *pPrevResourcefLink=NULL;
	RESOURCE *pResource=NULL;

	RegEntry reQoSResourceRoot(REGKEY_QOS_RESOURCES,
								HKEY_LOCAL_MACHINE,
								FALSE,
								KEY_READ);

	DEBUGMSG(ZONE_IQOS,("IQoS::SetResources\n"));

	/*
	 *	parameter validation
	 */

	// lpResourceList should at least have a count DWORD
	if (!lpResourceList || IsBadReadPtr(lpResourceList, (UINT) sizeof(DWORD)))
	{
		hr = E_INVALIDARG;
		goto out_nomutex;
	}

	DISPLAYPARAMETERS(	SET_RESOURCES_ID,
						lpResourceList,
						0,
						0,
						0,
						0);

	ACQMUTEX(g_hQoSMutex);

	if (!m_bQoSEnabled)
		// just return
		goto out;

	/*
	 *	Get configurable resource info
	 */

	pResource=lpResourceList->aResources;
	for (i=0; i < lpResourceList->cResources; i++)
	{
		TCHAR szKey[10];		// should be way enough for a resource ID
		int nUnits=INT_MAX;
		int nLeaveUnused=0;

		// build and open the key
		wsprintf(szKey, "%d", pResource[i].resourceID);

		RegEntry reQosResource(szKey, reQoSResourceRoot.GetKey(), FALSE, KEY_READ);

		
		// MaxUnits:
		// run through the list of resources and make sure none of the
		// resources was set to a number of units above the allowed maximum
		// if it was, trim and warn

		// get maximum numbers for the resource, if any, from the registry
		nUnits = reQosResource.GetNumberIniStyle(TEXT("MaxUnits"), INT_MAX);
	
		// is the client trying to set the resource to a higher value ?
		if (pResource[i].nUnits > nUnits)
		{
			pResource[i].nUnits = nUnits;
			hr = QOS_W_MAX_UNITS_EXCEEDED;
		}
		
		// LeaveUnused:
		// leave some of the resource unused, as configured	

		// use different default value depending on the resource
		switch (pResource[i].resourceID)
		{
		case RESOURCE_OUTGOING_BANDWIDTH:
			nLeaveUnused = 30;
			break;
		default:
			nLeaveUnused = 10;
			break;
		}

		nLeaveUnused = reQosResource.GetNumberIniStyle(	TEXT("LeaveUnused"),
														nLeaveUnused);

		pResource[i].nUnits = (pResource[i].nUnits * (100 - nLeaveUnused)) / 100;
	}

	/*
	 *	Add the resource to the list
	 */

	// run through the input resource list and store the resources
	// resource availability is NOT accumulative
	pResource=lpResourceList->aResources;
	for (i=0; i < lpResourceList->cResources; i++)
	{
		pResourceInt = m_pResourceList;
		pPrevResourcefLink = &m_pResourceList;
		fResourceFound = FALSE;
		while (pResourceInt != 0)
		{
			if (pResourceInt->resource.resourceID == pResource[i].resourceID)
			{	// found a match
				// did the total number of units change for this resource ?
				if (pResourceInt->resource.nUnits != pResource[i].nUnits)
				{
					// update the now available units
					// since we could end up with less units than what was allocated
					// we are issuing a NotifyNow at the end of this call
					pResourceInt->nNowAvailUnits =	pResource[i].nUnits -
													(pResourceInt->resource.nUnits -
													pResourceInt->nNowAvailUnits);
					if (pResourceInt->nNowAvailUnits < 0)
						pResourceInt->nNowAvailUnits = 0;
				}

				// override the previous setting
				RtlCopyMemory(	&(pResourceInt->resource),
								&(pResource[i]),
								sizeof(RESOURCE));
				fResourceFound = TRUE;
				break;
			}

			// not this one. try next one.
			pPrevResourcefLink = &(pResourceInt->fLink);
			pResourceInt = pResourceInt->fLink;
		
		}	// while

		if (fResourceFound)
			continue;

		// not found. add the resource
		pResourceInt = (LPRESOURCEINT) MEMALLOC(sizeof(RESOURCEINT));
		ASSERT(pResourceInt);
		if (!pResourceInt)
		{
			ERRORMSG(("IQoS::SetResources: MEMALLOC failed on RESOURCEINT\n"));
			hr = E_OUTOFMEMORY;
			goto out;
		}

		// copy the resource in
		RtlCopyMemory(	&(pResourceInt->resource),
						&(pResource[i]),
						sizeof(RESOURCE));
		pResourceInt->fLink = NULL;
		pResourceInt->nNowAvailUnits = pResourceInt->resource.nUnits;
		*pPrevResourcefLink = pResourceInt;

		// increment the number of resources we're tracking
		// this number will never go down
		m_cResources++;

		// next resource

	}	// for

	// since there was a possible change in the resource availability,
	// run an immediate notification cycle
	if (SUCCEEDED(hr))
		NotifyNow();

out:
	DISPLAYQOSOBJECT();
	RELMUTEX(g_hQoSMutex);

out_nomutex:
	DEBUGMSG(ZONE_IQOS,("IQoS::SetResources - leave, hr=0x%x\n", hr));
	return hr;
}

/***************************************************************************

    Name      : CQoS::GetResources

    Purpose   : Gets the list of resources available to the QoS module

    Parameters: lppResourceList - an address where QoS will place a pointer
					to a buffer with the list of resources available to QoS.
					The caller must use CQoS::FreeBuffer to free this buffer.

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::GetResources (LPRESOURCELIST *lppResourceList)
{
	HRESULT hr = NOERROR;
	ULONG i;
	LPRESOURCELIST prl=NULL;
	LPRESOURCEINT pResourceInt=NULL;
	RESOURCE *pResource=NULL;

	DEBUGMSG(ZONE_IQOS,("IQoS::GetResources\n"));

	/*
	 *	parameter validation
	 */

	// lpResourceList should at least have a count DWORD
	if (!lppResourceList || IsBadWritePtr(lppResourceList, (UINT) sizeof(DWORD)))
	{
		hr = E_INVALIDARG;
		goto out_nomutex;
	}

	// no list yet
	*lppResourceList = NULL;

	if (!m_bQoSEnabled)
		// just return
		goto out_nomutex;

	ACQMUTEX(g_hQoSMutex);

	/*
	 *	Get resource info
	 */

	// allocate a buffer for the resources info
	prl = (LPRESOURCELIST) MEMALLOC(sizeof(RESOURCELIST) +
									((LONG_PTR)m_cResources-1)*sizeof(RESOURCE));
	if (!prl)
	{
		hr = E_OUTOFMEMORY;
		ERRORMSG(("GetResources: MEMALLOC failed\n"));
		goto out;
	}

	RtlZeroMemory((PVOID) prl, sizeof(RESOURCELIST) +
									((LONG_PTR)m_cResources-1)*sizeof(RESOURCE));

	// now fill in the information
	prl->cResources = m_cResources;
	pResourceInt=m_pResourceList;
	for (i=0; i < m_cResources; i++)
	{
		ASSERT(pResourceInt);

		// see if we have a NULL resource pointer
		// shouldn't happen, but we shouldn't crash if it does
		if (!pResourceInt)
		{
			hr = QOS_E_INTERNAL_ERROR;
			ERRORMSG(("GetResources: bad QoS internal resource list\n"));
			goto out;
		}

		// copy the resource info into the buffer
		RtlCopyMemory(	&(prl->aResources[i]),
						&(pResourceInt->resource),
						sizeof(RESOURCE));
		
		// next resource
		pResourceInt = pResourceInt->fLink;
	}	// for

	*lppResourceList = prl;
		
out:
	DISPLAYQOSOBJECT();
	RELMUTEX(g_hQoSMutex);

out_nomutex:
	DEBUGMSG(ZONE_IQOS,("IQoS::GetResources - leave, hr=0x%x\n", hr));
	return hr;
}

/***************************************************************************

    Name      : CQoS::SetClients

    Purpose   : Tells the QoS module what are the priorities of the requesting
				streams. This allows the QoS module to allocate resources
				appropriately.

    Parameters: lpClientList - list of clients and their respective
				priorities

    Returns   : HRESULT

    Comment   : client info will override an already existing info for this
				client

***************************************************************************/
HRESULT CQoS::SetClients(LPCLIENTLIST lpClientList)
{
	HRESULT hr = NOERROR;
	ULONG i;
	BOOL fClientFound=FALSE;
	LPCLIENTINT pClientInt=NULL, *pPrevClientfLink=NULL, pClientNew=NULL;;
	LPCLIENT pClient=NULL;

	DEBUGMSG(ZONE_IQOS,("IQoS::SetClients\n"));

	/*
	 *	parameter validation
	 */

	// lpClientList should at least have a count DWORD
	if (!lpClientList || IsBadReadPtr(lpClientList, (UINT) sizeof(DWORD)))
	{
		hr = E_INVALIDARG;
		goto out_nomutex;
	}

	DISPLAYPARAMETERS(	SET_CLIENTS_ID,
						lpClientList,
						0,
						0,
						0,
						0);

	ACQMUTEX(g_hQoSMutex);

	if (!m_bQoSEnabled)
		// just return
		goto out;

	// first remove existing clients that are being set again
	// this will make it easier to store clients in a priority order
	pClient=lpClientList->aClients;
	for (i=0; i < lpClientList->cClients; i++)
	{
		pClientInt = m_pClientList;
		pPrevClientfLink = &m_pClientList;
		fClientFound = FALSE;
		while (pClientInt != 0)
		{
			if (COMPARE_GUIDS(	&(pClientInt->client.guidClientGUID),
								&(pClient[i].guidClientGUID)))
			{	// found a match
				LPCLIENTINT pClientIntNext=pClientInt->fLink;

				// special case for internal calls from RequestResources
				// we want to preserve the original priority before freeing
				if (pClient[i].priority == QOS_LOWEST_PRIORITY)
					pClient[i].priority = pClientInt->client.priority;

				// free the requests for this client
				// NOTE: we're not going to recreate the request list from
				// the one in the resource list. it will be created on the
				// fly when needed.
				FreeListOfRequests(&(pClientInt->pRequestList));

				// free the client record
				MEMFREE(pClientInt);
				*pPrevClientfLink = pClientIntNext;
				fClientFound = TRUE;
				break;
			}

			// not this one. try next one.
			pPrevClientfLink = &(pClientInt->fLink);
			pClientInt = pClientInt->fLink;
		
		}	// while

		// next resource

	}	// for

	// now store the clients in the input list in priority order
	pClient=lpClientList->aClients;
	for (i=0; i < lpClientList->cClients; i++)
	{
		pClientInt = m_pClientList;
		pPrevClientfLink = &m_pClientList;
		while (pClientInt != 0)
		{
			// as long as the priority of the new client is higher than or equal to the one
			// in the list, we continue to traverse the list
			if (pClient[i].priority < pClientInt->client.priority)
			{	// this is the place to insert this client
				break;
			}

			// not time to insert yet. next client
			pPrevClientfLink = &(pClientInt->fLink);
			pClientInt = pClientInt->fLink;
		
		}	// while

		// not found. add the client
		pClientNew = (LPCLIENTINT) MEMALLOC(sizeof(CLIENTINT));
		ASSERT(pClientNew);
		if (!pClientNew)
		{
			ERRORMSG(("IQoS::SetClients: MEMALLOC failed on CLIENTINT\n"));
			hr = E_OUTOFMEMORY;
			goto out;
		}

		// copy the resource in
		RtlCopyMemory(	&(pClientNew->client),
						&(pClient[i]),
						sizeof(CLIENT));
		pClientNew->fLink = pClientInt;
		*pPrevClientfLink = pClientNew;

		// next resource

	}	// for

out:
	DISPLAYQOSOBJECT();
	RELMUTEX(g_hQoSMutex);

out_nomutex:
	DEBUGMSG(ZONE_IQOS,("IQoS::SetClients -leave, hr=0x%x\n", hr));
	return hr;
}


/***************************************************************************

    Name      : CQoS::NotifyNow

    Purpose   : Tells the QoS module to initiate a notification cycle as
				soon as possible.

    Parameters: None

    Returns   : HRESULT

    Comment   : Don't call from within a notify proc.

***************************************************************************/
HRESULT CQoS::NotifyNow(void)
{
	HRESULT hr = NOERROR;

	DEBUGMSG(ZONE_IQOS,("IQoS::NotifyNow\n"));

	SetEvent(m_evImmediateNotify);

	DEBUGMSG(ZONE_IQOS,("IQoS::NotifyNow - leave, hr=0x%x\n", hr));
	return hr;
}

/***************************************************************************

    Name      : CQoS::FreeBuffer

    Purpose   : Frees a buffer allocated by the QoS module.

    Parameters: lpBuffer - a pointer to the buffer to free. This buffer must
					have been allocated by QoS

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::FreeBuffer(LPVOID lpBuffer)
{
	HRESULT hr = NOERROR;

	DEBUGMSG(ZONE_IQOS,("IQoS::FreeBuffer\n"));

	if (lpBuffer)
		MEMFREE(lpBuffer);

	DEBUGMSG(ZONE_IQOS,("IQoS::FreeBuffer - leave, hr=0x%x\n", hr));
	return hr;
}

/***************************************************************************

    Name      : CQoS::CQoS

    Purpose   : The CQoS object constructor

    Parameters: none

    Returns   : None

    Comment   :

***************************************************************************/
inline CQoS::CQoS (void)
{
	m_cRef = 0;	// will be bumped to 1 by the explicit QI in CreateQoS
	m_pResourceList = NULL;
	m_cResources = 0;
	m_pClientList = NULL;
	m_evThreadExitSignal = NULL;
	m_evImmediateNotify = NULL;
	m_hThread = NULL;
	m_bQoSEnabled = TRUE;
	m_bInNotify = FALSE;
	m_nSkipHeartBeats = 0;
	m_hWnd = NULL;
	m_nLeaveForNextPri = 5;
	// can't use ++ because RISC processors may translate to several instructions
	InterlockedIncrement((long *) &g_cQoSObjects);
}

/***************************************************************************

    Name      : CQoS::~CQoS

    Purpose   : The CQoS object destructor

    Parameters: none

    Returns   : None

    Comment   :

***************************************************************************/
inline CQoS::~CQoS (void)
{
	// can't use ++ because RISC processors may translate to several instructions
	InterlockedDecrement((long *) &g_cQoSObjects);
	g_pQoS = (CQoS *)NULL;
}

/***************************************************************************

    Name      : CQoS::Initialize

    Purpose   : Initializes the QoS object

    Parameters:	None

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CQoS::Initialize(void)
{
	HRESULT hr=NOERROR;
    OSVERSIONINFO tVersionInfo;

	/*
	 *	Initialize the object
	 */

	ACQMUTEX(g_hQoSMutex);


	// first see if QoS is enabled
	RegEntry reQoS(QOS_KEY,
					HKEY_LOCAL_MACHINE,
					FALSE,
					KEY_READ);

	m_bQoSEnabled = reQoS.GetNumberIniStyle(TEXT("Enable"), TRUE);
	
	if (!m_bQoSEnabled)
	{
		// don't create a thread, but return success
		DEBUGMSG(ZONE_IQOS,("Initialize: QoS not enabled\n"));
		hr = NOERROR;
		goto out;
	}

	/*
	 *	QoS notification thread
	 */

	// create an event that will be used to signal the thread to terminate
	// CreateEvent(No security attr's, no manual reset, not signalled, no name)
	m_evThreadExitSignal = CreateEvent(NULL, FALSE, FALSE, NULL);
	ASSERT(m_evThreadExitSignal);
	if (!(m_evThreadExitSignal))
	{
		ERRORMSG(("Initialize: Exit event creation failed: %x\n", GetLastError()));
		hr = E_FAIL;
		goto out;
	}

	// create an event that will be used to signal the thread to initiate
	// an immediate notify cycle
	// CreateEvent(No security attr's, no manual reset, not signalled, no name)
	m_evImmediateNotify = CreateEvent(NULL, FALSE, FALSE, NULL);
	ASSERT(m_evImmediateNotify);
	if (!(m_evImmediateNotify))
	{
		ERRORMSG(("Initialize: Immediate notify event creation failed: %x\n", GetLastError()));
		hr = E_FAIL;
		goto out;
	}


    //Set the OS flag
    tVersionInfo.dwOSVersionInfoSize=sizeof (OSVERSIONINFO);
    if (!(GetVersionEx (&tVersionInfo))) {
		ERRORMSG(("Initialize: Couldn't get version info: %x\n", GetLastError()));
		hr = E_FAIL;
		goto out;
    }

    if (tVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {
        bWin9x=TRUE;
    }else {
        if (tVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
            bWin9x=FALSE;
        }else {
            //How on earth did we get here?
            ASSERT (0);
            hr=E_FAIL;
            goto out;

        }
    }


out:
	RELMUTEX(g_hQoSMutex);
	return hr;
}


/***************************************************************************

    Name      : CreateQoS

    Purpose   : Creates the QoS object and return an IQoS interface pointer

    Parameters:

    Returns   : HRESULT

    Comment   : CreateQoS will only create one instance of the QoS object.
				Additional calls will return the same interface pointer

***************************************************************************/
extern "C" HRESULT WINAPI CreateQoS (	IUnknown *punkOuter,
										REFIID riid,
										void **ppv)
{
	CQoS *pQoS;
	HRESULT hr = NOERROR;

	*ppv = 0;
	if (punkOuter)
		 return CLASS_E_NOAGGREGATION;

	/*
	 *	instantiate the QoS object
	 */

	ACQMUTEX(g_hQoSMutex);

	// only instantiate a new object if it doesn't already exist
	if (g_cQoSObjects == 0)
	{
		if (!(pQoS = new CQoS))
		{
			hr = E_OUTOFMEMORY;
			goto out;
		}

		// Save pointer
		g_pQoS = pQoS;
	
		// initialize the QoS object
		hr = pQoS->Initialize();
	
	}
	else
	{
		// this is the case when the object was already instantiaed in this
		// process, so we only want to return the object pointer.
		pQoS = g_pQoS;
	}

	// must have only one QoS object at this point
	ASSERT(g_cQoSObjects == 1);
	
	RELMUTEX(g_hQoSMutex);

	// get the IQoS interface for the caller
	if (pQoS)
	{
		// QueryInterface will get us the interface pointer and will AddRef
		// the object
		hr = pQoS->QueryInterface (riid, ppv);
	}
	else
		hr = E_FAIL;

out:
	return hr;
}

/***************************************************************************

    Name      : QoSEntryPoint

    Purpose   : Called by nac.dll (where the QoS lives these days) to make
				the necessary process attach and detach initializations

    Parameters:	same as a standard DllEntryPoint

    Returns   :


***************************************************************************/
extern "C" BOOL APIENTRY QoSEntryPoint(	HINSTANCE hInstDLL,
										DWORD dwReason,
										LPVOID lpReserved)
{
	BOOL fRet=TRUE;

	switch (dwReason)
	{
		case DLL_PROCESS_ATTACH:
			QOSDEBUGINIT();

			// create a no-name mutex to control access to QoS object data
			if (!g_hQoSMutex)
			{
				g_hQoSMutex = CreateMutex(NULL, FALSE, NULL);
				ASSERT(g_hQoSMutex);
				if (!g_hQoSMutex)
				{
					ERRORMSG(("QoSEntryPoint: CreateMutex failed, 0x%x\n", GetLastError()));
					fRet = FALSE;
				}
			}
			break;

		case DLL_PROCESS_DETACH:
			if (g_hQoSMutex)
				CloseHandle(g_hQoSMutex);
			g_hQoSMutex = NULL;
			DBGDEINIT(&ghDbgZoneQoS);
			break;

		default:
			break;
	}

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rrcminc\interop.h ===
#ifndef __INTEROP_H
#define __INTEROP_H

#include <windows.h>

#define INTEROP_EXPORT  __declspec(dllexport)

#define DLLName "CPLS.DLL"


typedef int    (WINAPI *CPLInitialize_t)(const char*);
typedef int    (WINAPI *CPLUninitialize_t)(int) ;
typedef int    (WINAPI *CPLOpen_t)(int, 
							const char*, 
							int);
typedef int    (WINAPI *CPLClose_t)( int );
typedef int    (WINAPI *CPLOutput_t)(int, 
							BYTE*, 
							int,
							unsigned long);



typedef struct {
    CPLInitialize_t       CPLInitialize;
	CPLUninitialize_t     CPLUninitialize;
    CPLOpen_t			  CPLOpen;
    CPLClose_t			  CPLClose;
    CPLOutput_t			  CPLOutput;
	int					  g_ComplianceProtocolLogger;
	int					  g_ProtocolLogID;
	HINSTANCE hInst;
} *LPInteropLogger, InteropLogger;

#ifdef __cplusplus
extern "C" {
#endif

LPInteropLogger INTEROP_EXPORT InteropLoad(const char*  Protocol);
void INTEROP_EXPORT InteropUnload(LPInteropLogger Logger);
void INTEROP_EXPORT InteropOutput(LPInteropLogger Logger, BYTE* buf, int length, unsigned long userData);

#ifdef __cplusplus
}
#endif


#endif  // __CPLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\md5\md5c_opt.c ===
/* MD5C.C - RSA Data Security, Inc., MD5 message-digest algorithm
 */

/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
rights reserved.

License to copy and use this software is granted provided that it
is identified as the "RSA Data Security, Inc. MD5 Message-Digest
Algorithm" in all material mentioning or referencing this software
or this function.

License is also granted to make and use derivative works provided
that such works are identified as "derived from the RSA Data
Security, Inc. MD5 Message-Digest Algorithm" in all material
mentioning or referencing the derived work.

RSA Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided "as is"
without express or implied warranty of any kind.

These notices must be retained in any copies of any part of this
documentation and/or software.
 */

#include "global.h"
#include "md5.h"

#include <memory.h>

/* Constants for MD5Transform routine.
 */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21

static void MD5Transform PROTO_LIST ((UINT4 [4], unsigned char [64]));
static void Encode PROTO_LIST
  ((unsigned char *, UINT4 *, unsigned int));
static void Decode PROTO_LIST
  ((UINT4 *, unsigned char *, unsigned int));
static void MD5_memcpy PROTO_LIST ((POINTER, POINTER, unsigned int));
static void MD5_memset PROTO_LIST ((POINTER, int, unsigned int));

static unsigned char PADDING[64] = {
  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

/* F, G, H and I are basic MD5 functions.
 */
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))

/* ROTATE_LEFT rotates x left n bits.
 */
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
Rotation is separate from addition to prevent recomputation.
 */
#define FF(a, b, c, d, x, s, ac) { \
 (a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define GG(a, b, c, d, x, s, ac) { \
 (a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define HH(a, b, c, d, x, s, ac) { \
 (a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define II(a, b, c, d, x, s, ac) { \
 (a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }

/* MD5 initialization. Begins an MD5 operation, writing a new context.
 */
void MD5Init (context)
MD5_CTX *context;                                        /* context */
{
  context->count[0] = context->count[1] = 0;
  /* Load magic initialization constants.
*/
  context->state[0] = 0x67452301;
  context->state[1] = 0xefcdab89;
  context->state[2] = 0x98badcfe;
  context->state[3] = 0x10325476;
}

/* MD5 block update operation. Continues an MD5 message-digest
  operation, processing another message block, and updating the
  context.
 */
void MD5Update (context, input, inputLen)
MD5_CTX *context;                                        /* context */
unsigned char *input;                                /* input block */
unsigned int inputLen;                     /* length of input block */
{
  unsigned int i, index, partLen;

  /* Compute number of bytes mod 64 */
  index = (unsigned int)((context->count[0] >> 3) & 0x3F);

  /* Update number of bits */
  if ((context->count[0] += ((UINT4)inputLen << 3))
   < ((UINT4)inputLen << 3))
 context->count[1]++;
  context->count[1] += ((UINT4)inputLen >> 29);

  partLen = 64 - index;

  /* Transform as many times as possible.
*/
  if (inputLen >= partLen) {
 MD5_memcpy
   ((POINTER)&context->buffer[index], (POINTER)input, partLen);
 MD5Transform (context->state, context->buffer);

 for (i = partLen; i + 63 < inputLen; i += 64)
   MD5Transform (context->state, &input[i]);

 index = 0;
  }
  else
 i = 0;

  /* Buffer remaining input */
  MD5_memcpy
 ((POINTER)&context->buffer[index], (POINTER)&input[i],
  inputLen-i);
}

/* MD5 finalization. Ends an MD5 message-digest operation, writing the
  the message digest and zeroizing the context.
 */
void MD5Final (digest, context)
unsigned char digest[16];                         /* message digest */
MD5_CTX *context;                                       /* context */
{
  unsigned char bits[8];
  unsigned int index, padLen;

  /* Save number of bits */
  Encode (bits, context->count, 8);

  /* Pad out to 56 mod 64.
*/
  index = (unsigned int)((context->count[0] >> 3) & 0x3f);
  padLen = (index < 56) ? (56 - index) : (120 - index);
  MD5Update (context, PADDING, padLen);

  /* Append length (before padding) */
  MD5Update (context, bits, 8);
  /* Store state in digest */
  Encode (digest, context->state, 16);

  /* Zeroize sensitive information.
*/
  MD5_memset ((POINTER)context, 0, sizeof (*context));
}

/* MD5 basic transformation. Transforms state based on block.
 */
static void MD5Transform (state, block)
UINT4 state[4];
unsigned char block[64];
{
  register UINT4 a = state[0], b = state[1], c = state[2], d = state[3];
  UINT4 x[16];

#if !(defined(i386) | defined(__alpha))
  Decode (x, block, 64);

  /* Round 1 */
  FF (a, b, c, d, x[ 0], S11, 0xd76aa478); /* 1 */
  FF (d, a, b, c, x[ 1], S12, 0xe8c7b756); /* 2 */
  FF (c, d, a, b, x[ 2], S13, 0x242070db); /* 3 */
  FF (b, c, d, a, x[ 3], S14, 0xc1bdceee); /* 4 */
  FF (a, b, c, d, x[ 4], S11, 0xf57c0faf); /* 5 */
  FF (d, a, b, c, x[ 5], S12, 0x4787c62a); /* 6 */
  FF (c, d, a, b, x[ 6], S13, 0xa8304613); /* 7 */
  FF (b, c, d, a, x[ 7], S14, 0xfd469501); /* 8 */
  FF (a, b, c, d, x[ 8], S11, 0x698098d8); /* 9 */
  FF (d, a, b, c, x[ 9], S12, 0x8b44f7af); /* 10 */
  FF (c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */
  FF (b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */
  FF (a, b, c, d, x[12], S11, 0x6b901122); /* 13 */
  FF (d, a, b, c, x[13], S12, 0xfd987193); /* 14 */
  FF (c, d, a, b, x[14], S13, 0xa679438e); /* 15 */
  FF (b, c, d, a, x[15], S14, 0x49b40821); /* 16 */

 /* Round 2 */
  GG (a, b, c, d, x[ 1], S21, 0xf61e2562); /* 17 */
  GG (d, a, b, c, x[ 6], S22, 0xc040b340); /* 18 */
  GG (c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */
  GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa); /* 20 */
  GG (a, b, c, d, x[ 5], S21, 0xd62f105d); /* 21 */
  GG (d, a, b, c, x[10], S22,  0x2441453); /* 22 */
  GG (c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */
  GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8); /* 24 */
  GG (a, b, c, d, x[ 9], S21, 0x21e1cde6); /* 25 */
  GG (d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */
  GG (c, d, a, b, x[ 3], S23, 0xf4d50d87); /* 27 */
  GG (b, c, d, a, x[ 8], S24, 0x455a14ed); /* 28 */
  GG (a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
  GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
  GG (c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
  GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */

  /* Round 3 */
  HH (a, b, c, d, x[ 5], S31, 0xfffa3942); /* 33 */
  HH (d, a, b, c, x[ 8], S32, 0x8771f681); /* 34 */
  HH (c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */
  HH (b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */
  HH (a, b, c, d, x[ 1], S31, 0xa4beea44); /* 37 */
  HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
  HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
  HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
  HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
  HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
  HH (c, d, a, b, x[ 3], S33, 0xd4ef3085); /* 43 */
  HH (b, c, d, a, x[ 6], S34,  0x4881d05); /* 44 */
  HH (a, b, c, d, x[ 9], S31, 0xd9d4d039); /* 45 */
  HH (d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */
  HH (c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
  HH (b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 */

  /* Round 4 */
  II (a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */
  II (d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */
  II (c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */
  II (b, c, d, a, x[ 5], S44, 0xfc93a039); /* 52 */
  II (a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */
  II (d, a, b, c, x[ 3], S42, 0x8f0ccc92); /* 54 */
  II (c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */
  II (b, c, d, a, x[ 1], S44, 0x85845dd1); /* 56 */
  II (a, b, c, d, x[ 8], S41, 0x6fa87e4f); /* 57 */
  II (d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */
  II (c, d, a, b, x[ 6], S43, 0xa3014314); /* 59 */
  II (b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */
  II (a, b, c, d, x[ 4], S41, 0xf7537e82); /* 61 */
  II (d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */
  II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb); /* 63 */
  II (b, c, d, a, x[ 9], S44, 0xeb86d391); /* 64 */
#else
  /* Round 1 */
  FF (a, b, c, d, ((UINT4 *)block)[ 0], S11, 0xd76aa478); /* 1 */
  FF (d, a, b, c, ((UINT4 *)block)[ 1], S12, 0xe8c7b756); /* 2 */
  FF (c, d, a, b, ((UINT4 *)block)[ 2], S13, 0x242070db); /* 3 */
  FF (b, c, d, a, ((UINT4 *)block)[ 3], S14, 0xc1bdceee); /* 4 */
  FF (a, b, c, d, ((UINT4 *)block)[ 4], S11, 0xf57c0faf); /* 5 */
  FF (d, a, b, c, ((UINT4 *)block)[ 5], S12, 0x4787c62a); /* 6 */
  FF (c, d, a, b, ((UINT4 *)block)[ 6], S13, 0xa8304613); /* 7 */
  FF (b, c, d, a, ((UINT4 *)block)[ 7], S14, 0xfd469501); /* 8 */
  FF (a, b, c, d, ((UINT4 *)block)[ 8], S11, 0x698098d8); /* 9 */
  FF (d, a, b, c, ((UINT4 *)block)[ 9], S12, 0x8b44f7af); /* 10 */
  FF (c, d, a, b, ((UINT4 *)block)[10], S13, 0xffff5bb1); /* 11 */
  FF (b, c, d, a, ((UINT4 *)block)[11], S14, 0x895cd7be); /* 12 */
  FF (a, b, c, d, ((UINT4 *)block)[12], S11, 0x6b901122); /* 13 */
  FF (d, a, b, c, ((UINT4 *)block)[13], S12, 0xfd987193); /* 14 */
  FF (c, d, a, b, ((UINT4 *)block)[14], S13, 0xa679438e); /* 15 */
  FF (b, c, d, a, ((UINT4 *)block)[15], S14, 0x49b40821); /* 16 */

 /* Round 2 */
  GG (a, b, c, d, ((UINT4 *)block)[ 1], S21, 0xf61e2562); /* 17 */
  GG (d, a, b, c, ((UINT4 *)block)[ 6], S22, 0xc040b340); /* 18 */
  GG (c, d, a, b, ((UINT4 *)block)[11], S23, 0x265e5a51); /* 19 */
  GG (b, c, d, a, ((UINT4 *)block)[ 0], S24, 0xe9b6c7aa); /* 20 */
  GG (a, b, c, d, ((UINT4 *)block)[ 5], S21, 0xd62f105d); /* 21 */
  GG (d, a, b, c, ((UINT4 *)block)[10], S22,  0x2441453); /* 22 */
  GG (c, d, a, b, ((UINT4 *)block)[15], S23, 0xd8a1e681); /* 23 */
  GG (b, c, d, a, ((UINT4 *)block)[ 4], S24, 0xe7d3fbc8); /* 24 */
  GG (a, b, c, d, ((UINT4 *)block)[ 9], S21, 0x21e1cde6); /* 25 */
  GG (d, a, b, c, ((UINT4 *)block)[14], S22, 0xc33707d6); /* 26 */
  GG (c, d, a, b, ((UINT4 *)block)[ 3], S23, 0xf4d50d87); /* 27 */
  GG (b, c, d, a, ((UINT4 *)block)[ 8], S24, 0x455a14ed); /* 28 */
  GG (a, b, c, d, ((UINT4 *)block)[13], S21, 0xa9e3e905); /* 29 */
  GG (d, a, b, c, ((UINT4 *)block)[ 2], S22, 0xfcefa3f8); /* 30 */
  GG (c, d, a, b, ((UINT4 *)block)[ 7], S23, 0x676f02d9); /* 31 */
  GG (b, c, d, a, ((UINT4 *)block)[12], S24, 0x8d2a4c8a); /* 32 */

  /* Round 3 */
  HH (a, b, c, d, ((UINT4 *)block)[ 5], S31, 0xfffa3942); /* 33 */
  HH (d, a, b, c, ((UINT4 *)block)[ 8], S32, 0x8771f681); /* 34 */
  HH (c, d, a, b, ((UINT4 *)block)[11], S33, 0x6d9d6122); /* 35 */
  HH (b, c, d, a, ((UINT4 *)block)[14], S34, 0xfde5380c); /* 36 */
  HH (a, b, c, d, ((UINT4 *)block)[ 1], S31, 0xa4beea44); /* 37 */
  HH (d, a, b, c, ((UINT4 *)block)[ 4], S32, 0x4bdecfa9); /* 38 */
  HH (c, d, a, b, ((UINT4 *)block)[ 7], S33, 0xf6bb4b60); /* 39 */
  HH (b, c, d, a, ((UINT4 *)block)[10], S34, 0xbebfbc70); /* 40 */
  HH (a, b, c, d, ((UINT4 *)block)[13], S31, 0x289b7ec6); /* 41 */
  HH (d, a, b, c, ((UINT4 *)block)[ 0], S32, 0xeaa127fa); /* 42 */
  HH (c, d, a, b, ((UINT4 *)block)[ 3], S33, 0xd4ef3085); /* 43 */
  HH (b, c, d, a, ((UINT4 *)block)[ 6], S34,  0x4881d05); /* 44 */
  HH (a, b, c, d, ((UINT4 *)block)[ 9], S31, 0xd9d4d039); /* 45 */
  HH (d, a, b, c, ((UINT4 *)block)[12], S32, 0xe6db99e5); /* 46 */
  HH (c, d, a, b, ((UINT4 *)block)[15], S33, 0x1fa27cf8); /* 47 */
  HH (b, c, d, a, ((UINT4 *)block)[ 2], S34, 0xc4ac5665); /* 48 */

  /* Round 4 */
  II (a, b, c, d, ((UINT4 *)block)[ 0], S41, 0xf4292244); /* 49 */
  II (d, a, b, c, ((UINT4 *)block)[ 7], S42, 0x432aff97); /* 50 */
  II (c, d, a, b, ((UINT4 *)block)[14], S43, 0xab9423a7); /* 51 */
  II (b, c, d, a, ((UINT4 *)block)[ 5], S44, 0xfc93a039); /* 52 */
  II (a, b, c, d, ((UINT4 *)block)[12], S41, 0x655b59c3); /* 53 */
  II (d, a, b, c, ((UINT4 *)block)[ 3], S42, 0x8f0ccc92); /* 54 */
  II (c, d, a, b, ((UINT4 *)block)[10], S43, 0xffeff47d); /* 55 */
  II (b, c, d, a, ((UINT4 *)block)[ 1], S44, 0x85845dd1); /* 56 */
  II (a, b, c, d, ((UINT4 *)block)[ 8], S41, 0x6fa87e4f); /* 57 */
  II (d, a, b, c, ((UINT4 *)block)[15], S42, 0xfe2ce6e0); /* 58 */
  II (c, d, a, b, ((UINT4 *)block)[ 6], S43, 0xa3014314); /* 59 */
  II (b, c, d, a, ((UINT4 *)block)[13], S44, 0x4e0811a1); /* 60 */
  II (a, b, c, d, ((UINT4 *)block)[ 4], S41, 0xf7537e82); /* 61 */
  II (d, a, b, c, ((UINT4 *)block)[11], S42, 0xbd3af235); /* 62 */
  II (c, d, a, b, ((UINT4 *)block)[ 2], S43, 0x2ad7d2bb); /* 63 */
  II (b, c, d, a, ((UINT4 *)block)[ 9], S44, 0xeb86d391); /* 64 */
#endif

  state[0] += a;
  state[1] += b;
  state[2] += c;
  state[3] += d;

  /* Zeroize sensitive information.
*/
#if !(defined(i386) | defined(__alpha))
  MD5_memset ((POINTER)x, 0, sizeof (x));
#endif
}

/* Encodes input (UINT4) into output (unsigned char). Assumes len is
  a multiple of 4.
 */
static void Encode (output, input, len)
unsigned char *output;
UINT4 *input;
unsigned int len;
{
  unsigned int i, j;

  for (i = 0, j = 0; j < len; i++, j += 4) {
 output[j] = (unsigned char)(input[i] & 0xff);
 output[j+1] = (unsigned char)((input[i] >> 8) & 0xff);
 output[j+2] = (unsigned char)((input[i] >> 16) & 0xff);
 output[j+3] = (unsigned char)((input[i] >> 24) & 0xff);
  }
}

/* Decodes input (unsigned char) into output (UINT4). Assumes len is
  a multiple of 4.
 */
static void Decode (output, input, len)
UINT4 *output;
unsigned char *input;
unsigned int len;
{
  unsigned int i, j;
  register UINT4 out,other;

/*
  for (i = 0, j = 0; j < len; i++, j += 4)
 output[i] = ((UINT4)input[j]) | (((UINT4)input[j+1]) << 8) |
   (((UINT4)input[j+2]) << 16) | (((UINT4)input[j+3]) << 24);
*/
#if (!defined(hpux))
#define swapbyte(src,dst) { \
     out = ROTATE_LEFT((src),16); \
     other = out >> 8; \
     other &= 0x00ff00ff; \
     out &= 0x00ff00ff; \
     out <<= 8; \
     (dst) = out | other; \
     }
#else
#define swapbyte(src,dst) { \
     (dst) = (ROTATE_LEFT((src),8) & 0x00ff00ff) | ROTATE_LEFT((src) & 0x00ff00ff,24); \
     }
#endif

swapbyte(((UINT4 *)input)[0],output[0]);
swapbyte(((UINT4 *)input)[1],output[1]);
swapbyte(((UINT4 *)input)[2],output[2]);
swapbyte(((UINT4 *)input)[3],output[3]);
swapbyte(((UINT4 *)input)[4],output[4]);
swapbyte(((UINT4 *)input)[5],output[5]);
swapbyte(((UINT4 *)input)[6],output[6]);
swapbyte(((UINT4 *)input)[7],output[7]);
swapbyte(((UINT4 *)input)[8],output[8]);
swapbyte(((UINT4 *)input)[9],output[9]);
swapbyte(((UINT4 *)input)[10],output[10]);
swapbyte(((UINT4 *)input)[11],output[11]);
swapbyte(((UINT4 *)input)[12],output[12]);
swapbyte(((UINT4 *)input)[13],output[13]);
swapbyte(((UINT4 *)input)[14],output[14]);
swapbyte(((UINT4 *)input)[15],output[15]);

}

/* Note: Replace "for loop" with standard memcpy if possible.
 */

static void MD5_memcpy (output, input, len)
POINTER output;
POINTER input;
unsigned int len;
{
/*
  unsigned int i;

  for (i = 0; i < len; i++)
 output[i] = input[i];
*/
  memcpy(output,input,len);
}

/* Note: Replace "for loop" with standard memset if possible.
 */
static void MD5_memset (output, value, len)
POINTER output;
int value;
unsigned int len;
{
/*
  unsigned int i;

  for (i = 0; i < len; i++)
 ((char *)output)[i] = (char)value;
*/
  memset(output,value,len);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\md5\mddriver.c ===
/* MDDRIVER.C - test driver for MD2, MD4 and MD5
 */

/* Copyright (C) 1990-2, RSA Data Security, Inc. Created 1990. All
rights reserved.

RSA Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided "as is"
without express or implied warranty of any kind.

These notices must be retained in any copies of any part of this
documentation and/or software.
 */

/* The following makes MD default to MD5 if it has not already been
  defined with C compiler flags.
 */
#ifndef MD
#define MD MD5
#endif

#include <stdio.h>
#include <string.h>
#include <sys/time.h>
#include <sys/resource.h>
#include "global.h"
#if MD == 2
#include "md2.h"
#endif
#if MD == 4
#include "md4.h"
#endif
#if MD == 5
#include "md5.h"
#endif

/* Length of test block, number of test blocks.
 */
#define TEST_BLOCK_LEN 1000
#define TEST_BLOCK_COUNT 1000

extern char *calloc();
long test_block_len = TEST_BLOCK_LEN;
long test_block_count = TEST_BLOCK_COUNT;
int skip_init = 0;
int random_init = 0;
int double_block = 0;

static void MDString PROTO_LIST ((char *));
static void MDTimeTrial PROTO_LIST ((void));
static void MDTestSuite PROTO_LIST ((void));
static void MDFile PROTO_LIST ((char *));
static void MDFilter PROTO_LIST ((void));
static void MDPrint PROTO_LIST ((unsigned char [16]));

#if MD == 2
#define MD_CTX MD2_CTX
#define MDInit MD2Init
#define MDUpdate MD2Update
#define MDFinal MD2Final
#endif
#if MD == 4
#define MD_CTX MD4_CTX
#define MDInit MD4Init
#define MDUpdate MD4Update
#define MDFinal MD4Final
#endif
#if MD == 5
#define MD_CTX MD5_CTX
#define MDInit MD5Init
#define MDUpdate MD5Update
#define MDFinal MD5Final
#endif

/* Main driver.

Arguments (may be any combination):
  -sstring - digests string
  -t       - runs time trial
  -x       - runs test script
  filename - digests file
  (none)   - digests standard input

Used with -t:
  -l       - test block length
  -c       - test block count
  -s       - skip test init
  -r       - randomized (pseudo) test initialization
  -d       - double-buffer the block 
		(split in half - OK to use with -c; doesn't have cache effects)
 */
int main (argc, argv)
int argc;
char *argv[];
{
  int i;

  if (argc > 1)
 for (i = 1; i < argc; i++)
   if (argv[i][0] == '-' && argv[i][1] == 's')
     MDString (argv[i] + 2);
   else if (strcmp (argv[i], "-c") == 0)
       test_block_count = atol(argv[++i]);
   else if (strcmp (argv[i], "-l") == 0)
       test_block_len = atol(argv[++i]);
   else if (strcmp (argv[i], "-s") == 0)
       skip_init = 1;
   else if (strcmp (argv[i], "-r") == 0)
       random_init = 1;
   else if (strcmp (argv[i], "-d") == 0)
       double_block = 1;
   else if (strcmp (argv[i], "-t") == 0)
     MDTimeTrial ();
   else if (strcmp (argv[i], "-x") == 0)
     MDTestSuite ();
   else
     MDFile (argv[i]);
  else
 MDFilter ();

  return (0);
}

/* Digests a string and prints the result.
 */
static void MDString (string)
char *string;
{
  MD_CTX context;
  unsigned char digest[16];
  unsigned int len = strlen (string);

  MDInit (&context);
  MDUpdate (&context, string, len);
  MDFinal (digest, &context);

  printf ("MD%d (\"%s\") = ", MD, string);
  MDPrint (digest);
  printf ("\n");
}

/* Measures the time to digest TEST_BLOCK_COUNT TEST_BLOCK_LEN-byte
  blocks.
 */
static void MDTimeTrial ()
{
  MD_CTX context;
  unsigned char *block, digest[16];
  unsigned char *block2;
  unsigned int count;
  unsigned int i;
  struct timeval randtime;
#if (defined(hpux))
  struct timeval starttime;
  struct timeval stoptime;
#else
  struct rusage starttime;
  struct rusage stoptime;
#endif
  double usecs,ssecs,tsecs;

  block = (unsigned char *)malloc(test_block_len);
  block2 = (unsigned char *)malloc(test_block_len);

  printf
 ("MD%d time trial. Digesting %d %d-byte blocks ...", MD,
  test_block_count, test_block_len);

  /* Initialize block */
  if (!skip_init) {
    if (random_init) {
      gettimeofday(&randtime,(char *)0);
      count = (unsigned int)(randtime.tv_usec);
    } else
      count = 0;
    for (i = 0; i < test_block_len; i++,count++)
      block[i] = block2[i] = (unsigned char)(count & 0xff);
  }
      
  /* Start timer */
#if (defined(hpux))
  gettimeofday(&starttime,(char *)0);
#else
  getrusage(RUSAGE_SELF,&starttime);
#endif

  /* Digest blocks */
  MDInit (&context);
  if (double_block)
  for (i = 0; i < test_block_count/2; i++) {
    MDUpdate (&context, block, test_block_len);
    MDUpdate (&context, block2, test_block_len);
  }
  else {
  for (i = 0; i < test_block_count; i++)
 MDUpdate (&context, block, test_block_len);
  }
  MDFinal (digest, &context);

  /* Stop timer */
#if (defined(hpux))
  gettimeofday(&stoptime,(char *)0);
  tsecs = stoptime.tv_sec - starttime.tv_sec;
  tsecs += (stoptime.tv_usec - starttime.tv_usec) * 1e-6;
  usecs = 0;
  ssecs = 0;
#else
  getrusage(RUSAGE_SELF,&stoptime);
  usecs = stoptime.ru_utime.tv_sec - starttime.ru_utime.tv_sec;
  usecs += (stoptime.ru_utime.tv_usec - starttime.ru_utime.tv_usec) * 1e-6;
  ssecs = stoptime.ru_stime.tv_sec - starttime.ru_stime.tv_sec;
  ssecs += (stoptime.ru_stime.tv_usec - starttime.ru_stime.tv_usec) * 1e-6;
  tsecs = usecs + ssecs;
#endif

  printf (" done\n");
  printf ("Digest = ");
  MDPrint (digest);
  printf ("\nTime = %g U : %g S :: %g seconds\n", usecs,ssecs,tsecs);
  /*
   * Be careful that endTime-startTime is not zero.
   * (Bug fix from Ric Anderson, ric@Artisoft.COM.)
   */
  printf
 ("Speed = %g bytes/second,     %g bits/sec\n",
  (long)test_block_len * (long)test_block_count/((tsecs != 0) ? tsecs : 1),
  8 * (long)test_block_len * (long)test_block_count/((tsecs != 0) ? tsecs : 1));
  printf("minflt %d    majflt %d    nswap %d    nvcsw %d    nivcsw %d\n",
#if (!defined(hpux))
	 stoptime.ru_minflt - starttime.ru_minflt,
	 stoptime.ru_majflt - starttime.ru_majflt,
	 stoptime.ru_nswap - starttime.ru_nswap,
	 stoptime.ru_nvcsw - starttime.ru_nvcsw,
	 stoptime.ru_nivcsw - starttime.ru_nivcsw
#else
	 -1,-1,-1,-1,-1
#endif
	 );

}

/* Digests a reference suite of strings and prints the results.
 */
static void MDTestSuite ()
{
  printf ("MD%d test suite:\n", MD);

  MDString ("");
  MDString ("a");
  MDString ("abc");
  MDString ("message digest");
  MDString ("abcdefghijklmnopqrstuvwxyz");
  MDString
 ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
  MDString
 ("1234567890123456789012345678901234567890\
1234567890123456789012345678901234567890");
}

/* Digests a file and prints the result.
 */
static void MDFile (filename)
char *filename;
{
  FILE *file;
  MD_CTX context;
  int len;
  unsigned char buffer[1024], digest[16];

  if ((file = fopen (filename, "rb")) == NULL)
 printf ("%s can't be opened\n", filename);

  else {
 MDInit (&context);
 while (len = fread (buffer, 1, 1024, file))
   MDUpdate (&context, buffer, len);
 MDFinal (digest, &context);

 fclose (file);

 printf ("MD%d (%s) = ", MD, filename);
 MDPrint (digest);
 printf ("\n");
  }
}

/* Digests the standard input and prints the result.
 */
static void MDFilter ()
{
  MD_CTX context;
  int len;
  unsigned char buffer[16], digest[16];

  MDInit (&context);
  while (len = fread (buffer, 1, 16, stdin))
 MDUpdate (&context, buffer, len);
  MDFinal (digest, &context);

  MDPrint (digest);
  printf ("\n");
}

/* Prints a message digest in hexadecimal.
 */
static void MDPrint (digest)
unsigned char digest[16];
{
  unsigned int i;

  for (i = 0; i < 16; i++)
 printf ("%02x", digest[i]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rrcminc\isdmapi2.h ===
#ifndef __ISDMAPI2_H__
#define __ISDMAPI2_H__

/****************************************************************************
 *
 *	$Archive: /rtp/RRCM32/rrcminc/ISDMAPI2.H $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision: 1 $
 *	$Date: 8/13/96 12:16p $
 *	$Author: Bnkeany $
 *
 *	Deliverable:
 *
 *	Abstract:
 *
 *	Notes:
 *
 ***************************************************************************/

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus

#ifndef DllExport
#define DllExport	__declspec( dllexport )
#endif	// DllExport


//reserved key define for backwards compatability with old API
//all ISDM1 data falls under this key
#define BACKCOMP_KEY	"BackCompatability"
//value type defines
#define DWORD_VALUE			2
#define STRING_VALUE		3
#define BINARY_VALUE		4

//handle prefix bit codes(these get appended to the actual memmap offset to generate a handle)
#define	KEYBITCODE		0x6969
#define VALUEBITCODE	0xABBA
#define ROOTBITCODE		0x1234

//in case we want multiple roots, this can expand
#define ROOT_MAIN	0x0000

//this is the main root keys handle define
#define MAIN_ROOT_KEY MAKELONG(ROOT_MAIN,ROOTBITCODE)

//typedefs for each kind of handle
typedef DWORD KEY_HANDLE,*LPKEY_HANDLE;
typedef DWORD VALUE_HANDLE,*LPVALUE_HANDLE;
typedef DWORD EVENT_HANDLE,*LPEVENT_HANDLE;

//this structure is an internal status structure
//my test app accesses this for debug. You should never need this.
typedef struct INFODATASTRUCT
{
	UINT			uBindCount;
	UINT			uNumKeys;
	UINT			uMaxKeys;
	UINT			uNumValues;
	UINT			uMaxValues;
	UINT			uNumTableEntries;
	UINT			uMaxTableEntries;
	UINT			uNumEvents;
	UINT			uMaxEvents;
	DWORD			dwBytesFree;
	DWORD			dwMaxChars;
} INFO_DATA, *LPINFO_DATA;

//function typedefs
//supplier
typedef HRESULT (*ISD_CREATEKEY)		(KEY_HANDLE, LPCTSTR, LPKEY_HANDLE);
typedef HRESULT (*ISD_CREATEVALUE)		(KEY_HANDLE, LPCTSTR, DWORD,CONST BYTE *,DWORD,LPVALUE_HANDLE);
typedef HRESULT (*ISD_SETVALUE)			(KEY_HANDLE, VALUE_HANDLE, LPCTSTR, DWORD, CONST BYTE *, DWORD);
//consumer
typedef HRESULT (*ISD_OPENKEY)			(KEY_HANDLE, LPCSTR, LPKEY_HANDLE);
typedef HRESULT (*ISD_ENUMKEY)			(KEY_HANDLE, DWORD, LPTSTR, LPDWORD, LPKEY_HANDLE);
typedef HRESULT (*ISD_ENUMVALUE)		(KEY_HANDLE, DWORD, LPDWORD, LPDWORD, LPBYTE, LPDWORD, LPDWORD, LPVALUE_HANDLE);
typedef HRESULT (*ISD_QUERYINFOKEY)		(KEY_HANDLE, LPSTR, LPDWORD, LPDWORD, LPDWORD);
typedef HRESULT (*ISD_QUERYINFOVALUE)	(VALUE_HANDLE, LPSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD, LPDWORD, LPKEY_HANDLE);
typedef HRESULT (*ISD_NOTIFYCHANGEVALUE)	(VALUE_HANDLE, HANDLE);
//used by either
typedef HRESULT (*ISD_DELETEKEY)		(KEY_HANDLE);
typedef HRESULT	(*ISD_DELETEVALUE)		(KEY_HANDLE, VALUE_HANDLE, LPCSTR);
typedef BOOL	(*ISD_GETSTRUCTDATA)	(LPINFO_DATA);
typedef BOOL	(*ISD_ISVALIDKEYHANDLE)	(KEY_HANDLE);
typedef BOOL	(*ISD_ISVALIDVALUEHANDLE)	(VALUE_HANDLE);
typedef HRESULT (*ISD_COMPACTMEMORY)	();

//structure for ISDM entry points
typedef struct _ISDM2API
{
	ISD_CREATEKEY			ISD_CreateKey;
	ISD_CREATEVALUE			ISD_CreateValue;
	ISD_SETVALUE			ISD_SetValue;
	ISD_OPENKEY				ISD_OpenKey;
	ISD_ENUMKEY				ISD_EnumKey;
	ISD_ENUMVALUE			ISD_EnumValue;
	ISD_QUERYINFOKEY		ISD_QueryInfoKey;
	ISD_QUERYINFOVALUE		ISD_QueryInfoValue;
	ISD_NOTIFYCHANGEVALUE	ISD_NotifyChangeValue;
	ISD_DELETEKEY			ISD_DeleteKey;
	ISD_DELETEVALUE			ISD_DeleteValue;
	ISD_GETSTRUCTDATA		ISD_GetStructData;
	ISD_ISVALIDKEYHANDLE	ISD_IsValidKeyHandle;
	ISD_ISVALIDVALUEHANDLE	ISD_IsValidValueHandle;
	ISD_COMPACTMEMORY		ISD_CompactMemory;
}
ISDM2API, *LPISDM2API;

//HRESULT error defines
#define ISDM_ERROR_BASEB 0x8000

#define ERROR_INVALID_KEY_HANDLE		ISDM_ERROR_BASEB + 1
#define ERROR_MORE_DATA_AVAILABLE		ISDM_ERROR_BASEB + 2
#define ERROR_INVALID_STRING_POINTER	ISDM_ERROR_BASEB + 3
#define ERROR_KEY_NOT_FOUND				ISDM_ERROR_BASEB + 4
#define ERROR_VALUE_NOT_FOUND			ISDM_ERROR_BASEB + 5
#define ERROR_NO_MORE_SESSIONS			ISDM_ERROR_BASEB + 6
#define ERROR_INVALID_VALUE_HANDLE		ISDM_ERROR_BASEB + 7
#define ERROR_FAILED_TO_GET_MEM_KEY		ISDM_ERROR_BASEB + 8
#define ERROR_NO_PARENT					ISDM_ERROR_BASEB + 9
#define ERROR_NO_PREV_SIBLING			ISDM_ERROR_BASEB + 10
#define ERROR_NO_NEXT_SIBLING			ISDM_ERROR_BASEB + 11
#define ERROR_NO_CHILD					ISDM_ERROR_BASEB + 12
#define ERROR_INVALID_VALUE_TYPE		ISDM_ERROR_BASEB + 13
#define ERROR_MALLOC_FAILURE			ISDM_ERROR_BASEB + 14
#define ERROR_CREATE_KEY_FAILURE		ISDM_ERROR_BASEB + 15
#define ERROR_NULL_PARAM				ISDM_ERROR_BASEB + 16
#define ERROR_VALUE_EXISTS				ISDM_ERROR_BASEB + 17
#define ERROR_FAILED_TO_GET_MEM_VALUE	ISDM_ERROR_BASEB + 18
#define ERROR_NO_MORE_STR_SPACE			ISDM_ERROR_BASEB + 19
#define ERROR_KEY_EXISTS				ISDM_ERROR_BASEB + 20
#define ERROR_NO_MORE_KEY_SPACE			ISDM_ERROR_BASEB + 21
#define ERROR_NO_MORE_VALUE_SPACE		ISDM_ERROR_BASEB + 22
#define ERROR_INVALID_PARAM				ISDM_ERROR_BASEB + 23
#define ERROR_ROOT_DELETE				ISDM_ERROR_BASEB + 24
#define ERROR_NULL_STRING_TABLE_ENTRY	ISDM_ERROR_BASEB + 25
#define ERROR_NO_MORE_TABLE_ENTRIES		ISDM_ERROR_BASEB + 26
#define ERROR_ISDM_UNKNOWN				ISDM_ERROR_BASEB + 27
#define ERROR_NOT_IMPLEMENTED			ISDM_ERROR_BASEB + 28
#define ERROR_MALLOC_FAILED				ISDM_ERROR_BASEB + 29
#define ERROR_FAILED_TO_GET_MEM_TABLE	ISDM_ERROR_BASEB + 30
#define ERROR_SEMAPHORE_WAIT_FAIL		ISDM_ERROR_BASEB + 31
#define ERROR_NO_MORE_EVENTS			ISDM_ERROR_BASEB + 32
#define ERROR_INVALID_EVENT				ISDM_ERROR_BASEB + 33
#define ERROR_INVALID_EVENT_HANDLE		ISDM_ERROR_BASEB + 34
#define ERROR_EVENT_NONEXISTANT			ISDM_ERROR_BASEB + 35

//token defines..these may just disappear
//RRCM
#define RRCM_LOCAL_STREAM				1
#define RRCM_REMOTE_STREAM				2
#define ISDM_RRCM_BASE 0x1000

#define ISDM_SSRC						ISDM_RRCM_BASE + 1
#define ISDM_NUM_PCKT_SENT				ISDM_RRCM_BASE + 2
#define ISDM_NUM_BYTES_SENT				ISDM_RRCM_BASE + 3
#define ISDM_FRACTION_LOST				ISDM_RRCM_BASE + 4
#define ISDM_CUM_NUM_PCKT_LOST			ISDM_RRCM_BASE + 5
#define ISDM_XTEND_HIGHEST_SEQ_NUM		ISDM_RRCM_BASE + 6
#define ISDM_INTERARRIVAL_JITTER		ISDM_RRCM_BASE + 7
#define ISDM_LAST_SR					ISDM_RRCM_BASE + 8
#define ISDM_DLSR						ISDM_RRCM_BASE + 9
#define ISDM_NUM_BYTES_RCVD				ISDM_RRCM_BASE + 10
#define ISDM_NUM_PCKT_RCVD				ISDM_RRCM_BASE + 11
#define ISDM_NTP_FRAC					ISDM_RRCM_BASE + 12
#define ISDM_NTP_SEC					ISDM_RRCM_BASE + 13
#define ISDM_WHO_AM_I					ISDM_RRCM_BASE + 14

//
//Supplier API
//

//NOTE: always refer to the Win32 Registry equivalent call for more information on the functionality of the call
 
//The create key call is similar to the RegCreateKeyEx call from Win32 in functionality
//NOTE: This call will create the new key or simply return the handle of the key if it already
//exists
extern DllExport HRESULT ISD_CreateKey
(
	KEY_HANDLE hParentKey,	//The key from which to create the new key(can be MAIN_ROOT_KEY)
	LPCTSTR lpSubKey,		//the subkey to create.(see RegCreateKeyEx for details)
	LPKEY_HANDLE lphReturnKey//the handle of the newly created key
);

//The create value call is not part of the Win32 reg calls. It is here for symmetry in my API
//I prefer to use CreateValue then SetValue for my values, you can simply use SetValue and ignore
//CreateValue if you wish. The reason the registry has no such call is because they don't have
//a notion of a handle to a value. I felt it was very useful to have direct handles to the values for
//subsequent update calls.
extern DllExport HRESULT ISD_CreateValue
(
	KEY_HANDLE hKey,				//handle to the key that will own the new value
	LPCTSTR lpName,					//string ID of the value to be create
	DWORD dwType,					//type of value to create(DWORD,STRING,BINARY)
	CONST BYTE *lpData,				//pointer to value data	
	DWORD cbData,					//size of the value data buffer
	LPVALUE_HANDLE lphReturnValue	//return handle to the newly created value
);

//SetValue is similar to the Win32 RegSetValueEx call
DllExport HRESULT ISD_SetValue
(
	KEY_HANDLE hKey,		//handle of valid key
	VALUE_HANDLE hValue,	//handle of value to set
	LPCTSTR lpName,			//address of value name of value to set 
	DWORD dwType,			//flag for value type 
	CONST BYTE *lpData,		//address of value data 
	DWORD cbData 			//size of value data 
);

//
//Consumer API
//

//The OpenKey call is similar to the Win32 RegOpenKeyEx call
DllExport HRESULT ISD_OpenKey
(
	KEY_HANDLE hKey,				//handle of a valid key(can be MAIN_ROOT_KEY)
	LPCSTR lpSubKey,				//name of subkey to open
	LPKEY_HANDLE lphReturnKey		//handle of the opened key
);


//The EnumKey call is similar to the Win32 RegEnumKey call
//NOTES:
//	If lpName is null the size of the name is returned into lpcbName and NOERROR is returned
DllExport HRESULT ISD_EnumKey
(
	KEY_HANDLE hKey,				//key to enumerate
	DWORD dwIndex,					//index of subkey to enumerate
	LPTSTR lpName,					//address of buffer for subkey name(can be NULL)
	LPDWORD lpcbName,				//address for size of subkey buffer (acts like the RegEnumKeyEx version of this param)
	LPKEY_HANDLE lphReturnKey		//handle of subkey(can be NULL) 
);

//The EnumValue call is similar to the Win32 RegEnumValue call
DllExport HRESULT ISD_EnumValue
(
	KEY_HANDLE hKey,				//handle of key where value resides
	DWORD dwIndex,					//index of value to enum
	LPTSTR lpName,					//address of buffer for value name(can be NULL)
	LPDWORD lpcbName,				//address for size of value name buffer(can be NULL only if lpName is NULL)
	LPDWORD lpType,					//address for type of value(can be NULL if you don't care about type)
	LPBYTE lpData,					//address of buffer to receive the value data(can be NULL)
	LPDWORD lpcbData,				//address of size of buffer to receive the value data(can be NULL only if lpData is NULL)
	LPDWORD lpTimeStamp,			//address for timestamp on value(when last updated)(can be NULL)
	LPVALUE_HANDLE lphReturnValue	//address for handle of value(can be NULL)
);

//The QueryKeyInfo call is similar to the RegQueryInfoKey
DllExport HRESULT ISD_QueryInfoKey
(
	KEY_HANDLE hKey,				//handle of a valid key(can be MAIN_ROOT_KEY)
	LPSTR lpKeyName,			    //buffer to receive the name of the key(can be NULL)
	LPDWORD lpcbKeyName,			//address of size of name buffer(can be null only if lpKeyName is NULL)
	LPDWORD lpcNumKeys,				//address for number of direct children of the key(can be NULL)
	LPDWORD lpcNumValues			//address for number of values under the key(can be NULL)
);

//The QueryValueInfo call is NOT similar to the Win32 RegQueryValueEx call
//you must supply a value handle, the Win32 call doesn't have a notion of such a thing
//You can get the handle with subsequent calls to EnumKey
//This is my consumer call to retrieve statistical data
//NOTES:
//		If lpData is NULL and lpcbData is not, the function will return NOERROR with
//		lpcbData containing the buffer size needed for the value
//		If lpName is NULL and lpcbName is not, the function will return NOERROR with
//		lpcbName containing the buffer size needed for the value
DllExport HRESULT ISD_QueryInfoValue
(
	VALUE_HANDLE hValue,		//handle of value to query 
	LPSTR lpName,				//buffer to receive the name of the value(can be NULL)
	LPDWORD lpcbName,			//size of the name buffer(can only be NULL if lpName is NULL)
	LPDWORD lpValueType,		//address to receive the value type
	LPBYTE lpData,				//buffer to receive the value data(can be NULL)
	LPDWORD lpcbData,			//size of the value data buffer(can only be NULL if lpData is NULL)
	LPDWORD lpTime,				//address for timestamp on value(when last updated)(can be NULL)
	LPKEY_HANDLE lphParentKey	//return handle of the key that owns the value(can be NULL) 
);

//NotifyChangeValue is somewhat similar to the Win32 RegNotifyChangeValue call
//I limit you to async notification and also to value notification(no key level notify..yet)
DllExport HRESULT ISD_NotifyChangeValue
(
	VALUE_HANDLE hValue,	//handle of the value to trigger an event from
	HANDLE hEvent			//handle to the event you want triggered when value changes
);

//
//shared API
//

//The DeleteKey call is similar to RegDeleteKey
DllExport HRESULT ISD_DeleteKey
(
	KEY_HANDLE hKey					//handle of key to delete
);

//The DeleteValue call is similar to the RegDeleteValue call
//NOTE: You must supply either hValue or lpValueName. If you have the hValue, use it 
//and pass NULL for the value name.
DllExport HRESULT ISD_DeleteValue
(
	KEY_HANDLE hKey,				//handle of key that owns the value..if you have the value handle..pass NULL
	VALUE_HANDLE hValue,			//handle of value to delete(if known)..if known..pass NULL for key handle and name value
	LPCSTR lpValueName				//buffer holding name of value to delete(if known) pass NULL when hValue is known
);

//The GetStructData call is for retrieving structural info on ISDM itself. This is exposed so
//my test app can check the data structs. You should not need to call this.
DllExport BOOL ISD_GetStructData
(
	LPINFO_DATA pInfo				//structure holding ISDM structural info
);

//
//Handle validation calls
//
//use these anytime you want to check the validity of a handle to an ISDM object
DllExport BOOL ISD_IsValidKeyHandle
(
	KEY_HANDLE		hKey	//handle to key
);

DllExport BOOL ISD_IsValidValueHandle
(
	VALUE_HANDLE	hValue	//handle to value
);

//CompactMemory is my garbage collection function for ISDM. It is exported for
//test purposes with my browser app. You don't ever need to call this.
DllExport HRESULT ISD_CompactMemory
(
);

#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#endif // __ISDMAPI2_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rrcminc\isdmapi.h ===
#ifndef _ISDMAPI_H_
#define _ISDMAPI_H_

/****************************************************************************
 *
 *	$Archive: /rtp/support/isdm/ISDMAPI.H $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision: 5 $
 *	$Date: 6/13/96 2:55p $
 *	$Author: Cmaciocc $
 *
 *	Deliverable:
 *
 *	Abstract:
 *
 *	Notes:
 *
 ***************************************************************************/


#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus

#ifndef DllExport
#define DllExport	__declspec( dllexport )
#endif	// DllExport

typedef DWORD	HSTATSESSION,	*LPHSTATSESSION;

#define MAX_SESSNAME_LENGTH		25 
#define MAX_MODNAME_LENGTH		20
#define MAX_SESSIDENT_LENGTH	256 //consistant with max cName length
#define MAX_STATNAME_LENGTH		256
//stat item string name
typedef char STATNAME[MAX_STATNAME_LENGTH], *LPSTATNAME;
//session string name
typedef char SESSIONNAME[MAX_SESSNAME_LENGTH], *LPSESSIONNAME;
//module name
typedef char MODULENAME[MAX_MODNAME_LENGTH], *LPMODULENAME;
//identifier length
typedef char SESSIONIDENT[MAX_SESSIDENT_LENGTH], *LPSESSIONIDENT;


typedef struct STATSTRUCT
{
	DWORD		dwStructSize;				// size of the structure
	STATNAME	szStatName;					// string name of the stat item
	DWORD		dwToken;					// session unique id of the stat item
	DWORD		dwValue;					// value(data) of the stat item
	DWORD		dwLow;						// low value for range of value
	DWORD		dwHigh;						// hi value for range of value
	DWORD		dwLastUpdate;				// time stamp of last update
} STAT, *LPSTAT;

// Typedefs for ISDM application entry points to ensure stricter checking
// when functions are called via pointers
//
typedef HRESULT		(*ISD_REGISTER_SESSION)		(LPMODULENAME, LPSESSIONNAME, LPSESSIONIDENT, LPHSTATSESSION);
typedef HRESULT		(*ISD_CREATESTAT)			(HSTATSESSION, LPSTAT, WORD);
typedef HRESULT		(*ISD_UNREGISTERSESSION)	(HSTATSESSION);
typedef HRESULT		(*ISD_DELETESTAT)			(HSTATSESSION, LPSTAT, WORD);
typedef HRESULT		(*ISD_UPDATESTAT)			(HSTATSESSION, LPSTAT, WORD);
typedef HRESULT		(*ISD_GETFIRSTSESSION)		(LPMODULENAME, LPSESSIONNAME, LPSESSIONIDENT, LPHSTATSESSION);
typedef HRESULT		(*ISD_GETNEXTSESSION)		(HSTATSESSION, LPMODULENAME, LPSESSIONNAME, LPSESSIONIDENT, LPHSTATSESSION);
typedef HRESULT		(*ISD_GETNUMSESSIONS)		(WORD *);
typedef HRESULT		(*ISD_GETFIRSTSTAT)			(HSTATSESSION, LPSTAT);
typedef HRESULT		(*ISD_GETNEXTSTAT)			(HSTATSESSION, LPSTAT, LPSTAT);
typedef HRESULT		(*ISD_GETNUMSTATS)			(HSTATSESSION, WORD *);
typedef HRESULT		(*ISD_GETSESSIONSTATS)		(HSTATSESSION, LPSTAT, WORD);

typedef struct _ISDMAPI
{
	ISD_REGISTER_SESSION	ISD_RegisterSession;
	ISD_CREATESTAT			ISD_CreateStat;
	ISD_UNREGISTERSESSION	ISD_UnregisterSession;
	ISD_DELETESTAT			ISD_DeleteStat;
	ISD_UPDATESTAT			ISD_UpdateStat;
	ISD_GETFIRSTSESSION		ISD_GetFirstSession;
	ISD_GETNEXTSESSION		ISD_GetNextSession;
	ISD_GETNUMSESSIONS		ISD_GetNumSessions;
	ISD_GETFIRSTSTAT		ISD_GetFirstStat;
	ISD_GETNEXTSTAT			ISD_GetNextStat;
	ISD_GETNUMSTATS			ISD_GetNumStats;
	ISD_GETSESSIONSTATS		ISD_GetSessionStats;
}
ISDMAPI, *LPISDMAPI;

//HRESULT error defines
#define ISDM_ERROR_BASE 0x7000

#define ERROR_HIT_MAX_SESSIONS		ISDM_ERROR_BASE + 1
#define ERROR_HIT_MAX_STATS			ISDM_ERROR_BASE + 2
#define ERROR_ACCESSING_SESSION		ISDM_ERROR_BASE + 3
#define ERROR_SESSION_EXISTS		ISDM_ERROR_BASE + 4
#define ERROR_INVALID_SESS_HANDLE	ISDM_ERROR_BASE + 5
#define ERROR_INVALID_STAT_HANDLE	ISDM_ERROR_BASE + 6
#define ERROR_NO_SESSIONS			ISDM_ERROR_BASE + 7
#define ERROR_NO_STATS				ISDM_ERROR_BASE + 8
#define ERROR_SESSION_NOT_FOUND		ISDM_ERROR_BASE + 9
#define ERROR_MUTEX_WAIT_FAIL		ISDM_ERROR_BASE + 10
#define ERROR_TOKEN_NOT_UNIQUE		ISDM_ERROR_BASE + 11
#define ERROR_NO_FREE_SESSIONS		ISDM_ERROR_BASE + 12
#define ERROR_SESSION_GET_FAIL		ISDM_ERROR_BASE + 13
#define ERROR_BAD_STAT_ARRAY		ISDM_ERROR_BASE + 14
#define ERROR_BAD_STAT_TOKEN		ISDM_ERROR_BASE + 15
#define ERROR_BAD_SESSION_NAME		ISDM_ERROR_BASE + 16
#define ERROR_NO_FREE_STATS			ISDM_ERROR_BASE + 17
#define ERROR_BAD_MODULE_NAME		ISDM_ERROR_BASE + 18

//token defines
//RRCM
#define RRCM_LOCAL_STREAM				1
#define RRCM_REMOTE_STREAM				2

#define ISDM_TOKEN_BASE 0x0000

#define ISDM_CC_CODEC					ISDM_TOKEN_BASE + 1
#define ISDM_CC_REMOTE					ISDM_TOKEN_BASE + 2
#define ISDM_CC_LOCAL					ISDM_TOKEN_BASE + 3

#define ISDM_RRCM_BASE 0x1000

#define ISDM_SSRC						ISDM_RRCM_BASE + 1
#define ISDM_NUM_PCKT_SENT				ISDM_RRCM_BASE + 2
#define ISDM_NUM_BYTES_SENT				ISDM_RRCM_BASE + 3
#define ISDM_FRACTION_LOST				ISDM_RRCM_BASE + 4
#define ISDM_CUM_NUM_PCKT_LOST			ISDM_RRCM_BASE + 5
#define ISDM_XTEND_HIGHEST_SEQ_NUM		ISDM_RRCM_BASE + 6
#define ISDM_INTERARRIVAL_JITTER		ISDM_RRCM_BASE + 7
#define ISDM_LAST_SR					ISDM_RRCM_BASE + 8
#define ISDM_DLSR						ISDM_RRCM_BASE + 9
#define ISDM_NUM_BYTES_RCVD				ISDM_RRCM_BASE + 10
#define ISDM_NUM_PCKT_RCVD				ISDM_RRCM_BASE + 11
#define ISDM_NTP_FRAC					ISDM_RRCM_BASE + 12
#define ISDM_NTP_SEC					ISDM_RRCM_BASE + 13
#define ISDM_WHO_AM_I					ISDM_RRCM_BASE + 14
#define ISDM_FDBK_FRACTION_LOST			ISDM_RRCM_BASE + 15
#define ISDM_FDBK_CUM_NUM_PCKT_LOST		ISDM_RRCM_BASE + 16
#define ISDM_FDBK_LAST_SR				ISDM_RRCM_BASE + 17
#define ISDM_FDBK_DLSR					ISDM_RRCM_BASE + 18
#define ISDM_FDBK_INTERARRIVAL_JITTER	ISDM_RRCM_BASE + 19


//
//Supplier calls 
//

//registration call
//This call is made whenever a new session is desired. The session name passed in must be unique
//across all sessions.
extern DllExport HRESULT ISD_RegisterSession
(
	LPMODULENAME		pszModuleName,		// module who owns session
	LPSESSIONNAME		pszSessionName,		// string name of new session to register
	LPSESSIONIDENT		pszSessionIdent,	// further level identifier for session
	LPHSTATSESSION		phSession			// return; handle to new session
);

//stat creation call
//add 1+ stat item(s) to a session. 
extern DllExport HRESULT ISD_CreateStat
(
	HSTATSESSION		hSession,			// handle to session
	LPSTAT				pStatArray,		// array of structs holding new stats to create
	WORD				wNumItems			// size of array(number of new stats)
);

//unregistration call
//deletes a session and all associated stat structs
extern DllExport HRESULT ISD_UnregisterSession
(
	HSTATSESSION		hSession			// handle of session to remove
);

//stat deletion call
//delete 1+ stat item(s) from a session
extern DllExport HRESULT ISD_DeleteStat
(
	HSTATSESSION		hSession,			// handle to session
	LPSTAT				pStatArray,			// array of structs
	WORD				wNumItems			// size of array(number of stats to remove)
);

//set stat data call
extern DllExport HRESULT ISD_UpdateStat
(
	HSTATSESSION		hSession,			// handle of session with stat item(s)
	LPSTAT				pStatArray,			// array of structs holding items to update
	WORD				wNumItems			// size of array(number of stats to update)
);

//
//Consumer calls 
//

//query calls
//session query
extern DllExport HRESULT ISD_GetFirstSession
(
	LPMODULENAME		pszModuleName,		// module who owns session
	LPSESSIONNAME		pszSessionName,		// string name of new session to register
	LPSESSIONIDENT		pszSessionIdent,	// further level identifier for session
	LPHSTATSESSION		phSession			// return; the session handle or null if empty list
);

//GetNext uses hCurSession to determine the next item..returned in phNextSession
extern DllExport HRESULT ISD_GetNextSession
(
	HSTATSESSION		hCurSession,		// the current session handle
	LPMODULENAME		pszModuleName,		// module who owns session
	LPSESSIONNAME		pszSessionName,		// string name of new session to register
	LPSESSIONIDENT		pszSessionIdent,	// further level identifier for session
	LPHSTATSESSION		phNextSession		// return; the session handle or null if at the end
);

extern DllExport HRESULT ISD_GetNumSessions
(
	WORD				*wNumSessions		// return; number of sessions
);

//stat query..retreive structs for the first time(get unique ids..initial values..etc)
extern DllExport HRESULT ISD_GetFirstStat
(
	HSTATSESSION		hSession,			// handle to session containing stat
	LPSTAT				pStat				// return; filled struct for first stat item
);

//pCurrentStat and pNextStat can be identical for saving memory.
extern DllExport HRESULT ISD_GetNextStat
(
	HSTATSESSION		hSession,			// handle to session containing stat
	LPSTAT				pCurrentStat,		// pointer to current stat item(for determining next)
	LPSTAT				pNextStat			// return; filled struct for next stat item
);

extern DllExport HRESULT ISD_GetNumStats
(
	HSTATSESSION		hSession,			// what session we are interested in
	WORD				*wNumStats			// return; number of stats in session
);

//stat retreival 
extern DllExport HRESULT ISD_GetSessionStats
(
	HSTATSESSION		hSession,		// what session we are interested in
	LPSTAT				pStatArray,	// return; array of structs holding items 
	WORD				wNumStats		// return; number of items in session
);


#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#endif // ISDTAT.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rrcminc\isrg.h ===
/****************************************************************************

	INTEL CORPORATION PROPRIETARY INFORMATION
	Copyright (c) 1992 Intel Corporation
	All Rights Reserved

	This software is supplied under the terms of a license
	agreement or non-disclosure agreement with Intel Corporation
	and may not be copied or disclosed except in accordance
	with the terms of that agreement

    $Source: q:/prism/include/rcs/isrg.h $
  $Revision: 1 $
      $Date: 6/19/96 3:46p $
    $Author: Lscline $
    $Locker:  $

	Description
	-----------
	Interrupt Service Routine debug header file
	This module allows for a way of doing OutputDebugString()
	at interrupt time.

****************************************************************************/

#ifndef ISRG_H
#define ISRG_H

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus

// Use for Win16
//#define DllExport
//#define DllImport
//#define DLL_EXPORT	_export

// Use for Win32
#define DllExport		__declspec( dllexport )
#define DllImport		__declspec( dllimport )
#define DLL_EXPORT

//
//	directions
//		Pick a number (mod 100) and create a base for the next 
//		100 entries.  Do it this way so that your numbers can
//		be easily moved.  The string assigned to the base you select
//		will be displayed as the filter string in a list box when
//		viewing.  After defining your constants go to isrdsp.rc
//		and assign strings to them.  You will need to build the
//		isrdsp.exe but not the isrdbg.dll.  You only need to
//		inlude this h file and import the functions from this
//		file into your def file.  Happy debugging.


//------------------------------------------------------------------------------
#define kModSNameSize		16
#define kModLNameSize		32

//------------------------------------------------------------------------------
// defines for tISRModule.Flags
#define kCaptureOn			0x01

//------------------------------------------------------------------------------
typedef struct _tISRModule
{
	WORD	Flags;
	BYTE	CaptureFilter;
	BYTE	DisplayFilter;
	char	zSName[kModSNameSize];	// Short name of user registered debug module
	char	zLName[kModLNameSize];	// Long name of user registered debug module
} tISRModule, FAR *ptISRModule;

//------------------------------------------------------------------------------
#define kModuleBufSize		((DWORD) (16*1024L))
#define kMaxModules			((UINT) (kModuleBufSize/sizeof(tISRModule)))


//------------------------------------------------------------------------------
typedef struct _tISRItem
{
	WORD	hISRInst;		// Our handle to registered modules
	BYTE	DbgLevel;		// Caller determined debug level
	BYTE	Flags;
	UINT	IP;				// Callers Instruction Ptr address
	DWORD	Param1;
	DWORD	Param2;
} tISRItem, FAR *ptISRItem;

//------------------------------------------------------------------------------
#define kISRBufSize			((DWORD) (32*1024L))
#define kMaxISRItems		((UINT) (kISRBufSize/sizeof(tISRItem)))
#define kMaxStrTab			((UINT) (60*1024L))


//------------------------------------------------------------------------------
// defines for tISRItem.Flags
#define kParam1IsStr		0x01
#define kParam1IsRes		0x02
#define kParam1IsNum		0x04		// Use only if passed two numbers.


//------------------------------------------------------------------------------
// Supported DbgMsg state values.
//------------------------------------------------------------------------------

// REVIEW: We build with DBG=1
#undef DBG
#define DBG 				0
#define ERR 				1

#define kISRCritical		0x01	// Progammer errors that should never happen
#define kISRError			0x02	// Errors that need to be fixed
#define kISRWarning			0x04	// The user could have problems if not corrected
#define kISRNotify			0x08	// Status, events, settings...
#define kISRTrace			0x10	// Trace info that will not overrun the system
#define kISRTemp			0x20	// Trace info that may be reproduced in heavy loops
#define kISRReserved1		0x40	// Future use
#define kISRReserved2		0x80	// Future use
#define kISRDefault			kISRReserved2	// Historical use only

#define TT_CRITICAL			kISRCritical
#define TT_ERROR			kISRError
#define TT_WARNING			kISRWarning
#define TT_NOTIFY			kISRNotify
#define TT_TRACE			kISRTrace
#define TT_TEMP				kISRTemp


//------------------------------------------------------------------------------
// exports from isrdbg.dll
// Include these in your def file if you want to output at interrupt time.
// The ISR_Hook*() functions are the same as their counterparts.  The only
// difference is that these functions need the Instruction Pointer passed
// in.  If you are using an intermediate library to encapsulate the debug
// functions then you must be responsible for pulling the IP off the stack.

// Register the module and get a handle for making debug calls.  If a debug
// call is made with an invalid handle then the results are not defined.
// It is possible to drop the debug event or to place the event into the 
// compatibility module.  If no more module handles are available then
// the handle returned will be the compatibility handle.
DllExport void WINAPI DLL_EXPORT
ISR_RegisterModule (LPWORD phISRInst, LPSTR zShortName, LPSTR zLongName);


// Allow two strings to be concatenated togeter.
DllExport void WINAPI DLL_EXPORT
ISR_HookDbgStrStr (UINT IP, WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, LPSTR pzStr2);

// Use a resource to format a number.
DllExport void WINAPI DLL_EXPORT
ISR_HookDbgRes (UINT IP, WORD hISRInst, BYTE DbgLevel, UINT uResId, DWORD Param1);

// Use a str to format a number.
DllExport void WINAPI DLL_EXPORT
ISR_HookDbgStr (UINT IP, WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, DWORD Param1);

// Allow two strings to be concatenated togeter.
DllExport void WINAPI DLL_EXPORT
ISR_DbgStrStr (WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, LPSTR pzStr2);

// Use a resource to format a number.
DllExport void WINAPI DLL_EXPORT
ISR_DbgRes (WORD hISRInst, BYTE DbgLevel, UINT uResId, DWORD Param1);

// Use a str to format a number.
DllExport void WINAPI DLL_EXPORT
ISR_DbgStr (WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, DWORD Param1);


// WARNING: Call at task time only.  Not reentrant.
DllExport void FAR cdecl DLL_EXPORT
TTDbgMsg 
(
	WORD		hISRInst,	// Module's ISRDBG handle.
	BYTE		DbgLevel,	// Appropriate ISRDBG level.
	LPCSTR		zMsgFmt,	// Output format string (like printf).
	... 					// Optional parameter list.
);


// Old functions for compatibility only.
DllExport void WINAPI DLL_EXPORT
ISR_OutputDbgStr (LPSTR pzStr);

DllExport void WINAPI DLL_EXPORT
ISR_OutputStr (UINT uResId);

DllExport void WINAPI DLL_EXPORT
ISR_OutputNum (UINT uResId, DWORD Num);

// WARNING: Call at task time only.  Not reentrant.
DllExport void FAR cdecl DLL_EXPORT
DbgMsg
	(
	LPCSTR		module,
	int			state,
	LPCSTR		format_str,
	...
	);


//------------------------------------------------------------------------------
// exports from isrdbg.dll
// Include these in your def file if you need to know the state of isrdbg.dll.
// isrdsp.exe needs to do this to display the data at task time.

DllExport void WINAPI DLL_EXPORT
ISR_ClearItems (void);

DllExport UINT WINAPI DLL_EXPORT
ISR_GetNumItems (void);

DllExport ptISRItem WINAPI DLL_EXPORT
ISR_GetItem (UINT uItem,ptISRItem pItem);

DllExport ptISRModule WINAPI DLL_EXPORT
ISR_GetModule (UINT hISRInst);

DllExport int WINAPI DLL_EXPORT
ISR_SetCaptureFilter (WORD hISRInst, BYTE CaptureFilter,  BYTE DisplayFilter);


//------------------------------------------------------------------------------
//	The caller of ISR debug functions can call these Macros and then the
//	retail release will just drop all of the debug statement code.
//------------------------------------------------------------------------------
#if (DEBUG >= 1) || (_DEBUG >= 1)
#define ISRDEBUGINFO	1
extern WORD	ghISRInst;
#define ISRREGISTERMODULE(pghISRInst, ShortName, LongName)	ISR_RegisterModule(pghISRInst, ShortName, LongName)
#define ISRNOTIFY(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRNotify, Str, Num)
#define ISRCRITICAL(ghISRInst, Str, Num)	ISR_DbgStr(ghISRInst, kISRCritical, Str, Num)
#define ISRERROR(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRError, Str, Num)
#define ISRWARNING(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRWarning, Str, Num)
#define ISRTRACE(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRTrace, Str, Num)
#define ISRTEMP(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRTemp, Str, Num)
#define ISRRESERVED1(ghISRInst, Str, Num)	ISR_DbgStr(ghISRInst, kISRReserved1, Str, Num)
#define ISRRESERVED2(ghISRInst, Str, Num)	ISR_DbgStr(ghISRInst, kISRReserved2, Str, Num)

#define ISRSNOTIFY(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRNotify, Str, Str2)
#define ISRSCRITICAL(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRCritical, Str, Str2)
#define ISRSERROR(ghISRInst, Str, Str2)		ISR_DbgStrStr(ghISRInst, kISRError, Str, Str2)
#define ISRSWARNING(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRWarning, Str, Str2)
#define ISRSTRACE(ghISRInst, Str, Str2)		ISR_DbgStrStr(ghISRInst, kISRTrace, Str, Str2)
#define ISRSTEMP(ghISRInst, Str, Str2)		ISR_DbgStrStr(ghISRInst, kISRTemp, Str, Str2)
#define ISRSRESERVED1(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRReserved1, Str, Str2)
#define ISRSRESERVED2(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRReserved2, Str, Str2)

#define TTDBG			TTDbgMsg

#else

#define ISRNOTIFY(ghISRInst, Str, Num)
#define ISRREGISTERMODULE(pghISRInst, ShortName, LongName)
#define ISRCRITICAL(ghISRInst, Str, Num)
#define ISRERROR(ghISRInst, Str, Num)
#define ISRWARNING(ghISRInst, Str, Num)
#define ISRTRACE(ghISRInst, Str, Num)
#define ISRTEMP(ghISRInst, Str, Num)
#define ISRRESERVED1(ghISRInst, Str, Num)
#define ISRRESERVED2(ghISRInst, Str, Num)

#define ISRSNOTIFY(ghISRInst, Str, Str2)
#define ISRSCRITICAL(ghISRInst, Str, Str2)
#define ISRSERROR(ghISRInst, Str, Str2)
#define ISRSWARNING(ghISRInst, Str, Str2)
#define ISRSTRACE(ghISRInst, Str, Str2)
#define ISRSTEMP(ghISRInst, Str, Str2)
#define ISRSRESERVED1(ghISRInst, Str, Str2)
#define ISRSRESERVED2(ghISRInst, Str, Str2)

#define ghISRInst		0
#define TTDBG			1 ? (void)0 : TTDbgMsg

#endif


//------------------------------------------------------------------------------
// Local Functions
static void
InitModules (void);

static UINT
ValidCaptureMsg (WORD hISRInst, BYTE DbgLevel);

// Local function but thunk needs to get to it
DllExport void WINAPI
OutputRec
	(
	WORD	hISRInst,		// Our handle to registered modules
	BYTE	DbgLevel,		// Caller determined debug level
	BYTE	Flags,
	UINT	IP,				// Callers Instruction Ptr address
	DWORD	Param1,
	DWORD	Param2
	);

// Local function but thunk needs to get to it
DllExport void WINAPI
OutputRecStr
	(
	WORD	hISRInst,		// Our handle to registered modules
	BYTE	DbgLevel,		// Caller determined debug level
	BYTE	Flags,
	UINT	IP,				// Callers Instruction Ptr address
	LPSTR	pzStr1,
	LPSTR	pzStr2,
	DWORD	Param1
	);


//------------------------------------------------------------------------------
// do not use a base of 0.  Reserved for system use.
#define ID_SysBase			0
#define ID_SysStr			(ID_SysBase + 1)
#define ID_SysSInt			(ID_SysBase + 2)
#define ID_SysUInt			(ID_SysBase + 3)
#define ID_SysDWord			(ID_SysBase + 4)
#define ID_SysLong			(ID_SysBase + 5)
#define ID_SysHex			(ID_SysBase + 6)


//------------------------------------------------------------------------------
// IsrDbg.dll
#define ID_IsrDbgBase		100
#define ID_IsrDbgLibMain	(ID_IsrDbgBase + 1)
#define ID_IsrDbgWep		(ID_IsrDbgBase + 2)
#define ID_IsrDbgReentrant	(ID_IsrDbgBase + 3)


//------------------------------------------------------------------------------
// IsrDsp.exe
#define ID_IsrDspBase		200
#define ID_IsrDspInit		(ID_IsrDspBase + 1)
#define ID_IsrDspExit		(ID_IsrDspBase + 2)


//------------------------------------------------------------------------------
// stMem.dll
#define ID_stMemBase		300
#define ID_stMemLibMain		(ID_stMemBase + 1)
#define ID_stMemWep			(ID_stMemBase + 2)
#define ID_stMemPreAlloc	(ID_stMemBase + 3)
#define ID_stMemPageLock	(ID_stMemBase + 4)
#define ID_stMemNoPageLock	(ID_stMemBase + 5)
#define ID_stMemAlloc		(ID_stMemBase + 6)
#define ID_stMemTotMem		(ID_stMemBase + 7)
#define ID_stMemstFree		(ID_stMemBase + 8)

                                                      
//-------------------------------------------------------------------------------
// DLM.dll

// Errors
#define ID_DLMErrorBase		400
#define ID_DLMEnqError      (ID_DLMErrorBase + 1)
#define ID_DLMDeqError      (ID_DLMErrorBase + 2)
#define ID_DLMFreeError     (ID_DLMErrorBase + 3)
#define ID_DLMChanError     (ID_DLMErrorBase + 4)
#define ID_DLMChanNIUErr    (ID_DLMErrorBase + 5)
#define ID_DLMChanNumErr    (ID_DLMErrorBase + 6)
#define ID_DLMInConnErr     (ID_DLMErrorBase + 7)
#define ID_DLMInSessErr     (ID_DLMErrorBase + 8)
#define ID_DLMSessNIU       (ID_DLMErrorBase + 9)
#define ID_DLMSessNO        (ID_DLMErrorBase + 10)
#define ID_DLMConnNIU       (ID_DLMErrorBase + 11)
#define ID_DLMConnNO        (ID_DLMErrorBase + 12)
#define ID_DLMIDErr         (ID_DLMErrorBase + 13)
#define ID_DLMConnErr       (ID_DLMErrorBase + 14)
#define ID_DLMSessErr       (ID_DLMErrorBase + 15)
#define ID_DLMSessNF        (ID_DLMErrorBase + 16)
#define ID_DLMNoFreeConn    (ID_DLMErrorBase + 17)
#define ID_DLMConnCloseErr  (ID_DLMErrorBase + 18)
#define ID_DLMConnNF        (ID_DLMErrorBase + 19)
#define ID_DLMConnNC        (ID_DLMErrorBase + 20)
#define ID_DLMMDMError      (ID_DLMErrorBase + 21)
#define ID_DLMNoSess        (ID_DLMErrorBase + 22)
#define ID_DLMInvalidSess   (ID_DLMErrorBase + 23)
#define ID_DLMEventErr      (ID_DLMErrorBase + 24)
#define ID_DLMNoConn        (ID_DLMErrorBase + 25)
#define ID_DLMChanCloseErr  (ID_DLMErrorBase + 26) 
#define ID_DLMInvalidConn   (ID_DLMErrorBase + 27)
#define ID_DLMCorruptQueue  (ID_DLMErrorBase + 28)
#define ID_DLMInvChanID     (ID_DLMErrorBase + 29)
#define ID_DLMChanInUse     (ID_DLMErrorBase + 30)
#define ID_DLMInvalidChan   (ID_DLMErrorBase + 31)
#define ID_DLMNoBufHdr      (ID_DLMErrorBase + 32)
#define ID_DLMEnqueueErr    (ID_DLMErrorBase + 33)
#define ID_DLMNMBufInProg   (ID_DLMErrorBase + 34)
#define ID_DLMNoBuffer      (ID_DLMErrorBase + 35)
#define ID_DLMEnterDumping  (ID_DLMErrorBase + 36)
#define ID_DLMSizeError     (ID_DLMErrorBase + 37)
#define ID_DLMNoBuf         (ID_DLMErrorBase + 38)
#define ID_DLMInitAlready   (ID_DLMErrorBase + 39)
#define ID_DLMGDLError      (ID_DLMErrorBase + 40)
#define ID_DLMNoEntryPoint  (ID_DLMErrorBase + 41)
#define ID_DLMNoEvent       (ID_DLMErrorBase + 42)
#define ID_DLMNoPackets     (ID_DLMErrorBase + 43)

// Debug level 1 messages
#define ID_DLMDebug1Base         500
#define ID_DLMCloseAllEntered    (ID_DLMDebug1Base + 1)
#define ID_DLMEstabHEntered      (ID_DLMDebug1Base + 2)
#define ID_DLMEstabHExit         (ID_DLMDebug1Base + 3)
#define ID_DLMReqHEntered        (ID_DLMDebug1Base + 4)
#define ID_DLMReqHAlloc          (ID_DLMDebug1Base + 5)
#define ID_DLMReqHExit           (ID_DLMDebug1Base + 6)
#define ID_DLMRejHEntered        (ID_DLMDebug1Base + 7)
#define ID_DLMRejHExit           (ID_DLMDebug1Base + 8)
#define ID_DLMCNoteHEntered      (ID_DLMDebug1Base + 9)
#define ID_DLMCNoteHExit         (ID_DLMDebug1Base + 10)
#define ID_DLMCComHEntered       (ID_DLMDebug1Base + 11)
#define ID_DLMCComHExit          (ID_DLMDebug1Base + 12)
#define ID_DLMSessCloseHEntered  (ID_DLMDebug1Base + 13)
#define ID_DLMSessCloseHExit     (ID_DLMDebug1Base + 14)
#define ID_DLMSessHEntered       (ID_DLMDebug1Base + 15)
#define ID_DLMSessHExit          (ID_DLMDebug1Base + 16)
#define ID_DLMBegSessEntered     (ID_DLMDebug1Base + 17)
#define ID_DLMBegSessExit        (ID_DLMDebug1Base + 18)
#define ID_DLMEndSessEntered     (ID_DLMDebug1Base + 19)
#define ID_DLMEndSessExit        (ID_DLMDebug1Base + 20)
#define ID_DLMListenEntered      (ID_DLMDebug1Base + 21)
#define ID_DLMListenExit         (ID_DLMDebug1Base + 22)
#define ID_DLMDoCloseEntered     (ID_DLMDebug1Base + 23)
#define ID_DLMDoCloseExit        (ID_DLMDebug1Base + 24)
#define ID_DLMMakeConnEntered    (ID_DLMDebug1Base + 25)
#define ID_DLMMakeConnExit       (ID_DLMDebug1Base + 26)
#define ID_DLMRejEntered         (ID_DLMDebug1Base + 27)
#define ID_DLMRejExit            (ID_DLMDebug1Base + 28)
#define ID_DLMAccEntered         (ID_DLMDebug1Base + 29)
#define ID_DLMAccExit            (ID_DLMDebug1Base + 30)
#define ID_DLMCloseConnEntered   (ID_DLMDebug1Base + 31)
#define ID_DLMCloseConnExit      (ID_DLMDebug1Base + 32)
#define ID_DLMTryEntered         (ID_DLMDebug1Base + 33)
#define ID_DLMTryExit            (ID_DLMDebug1Base + 34)
#define ID_DLMOpenEntered        (ID_DLMDebug1Base + 35)
#define ID_DLMOpenExit           (ID_DLMDebug1Base + 36)
#define ID_DLMSendEntered        (ID_DLMDebug1Base + 37)
#define ID_DLMSendExit           (ID_DLMDebug1Base + 38)
#define ID_DLMSendComEntered     (ID_DLMDebug1Base + 39)
#define ID_DLMSendComExit        (ID_DLMDebug1Base + 40)
#define ID_DLMPostEntered        (ID_DLMDebug1Base + 41)
#define ID_DLMPostExit           (ID_DLMDebug1Base + 42)
#define ID_DLMNewMsgEntered      (ID_DLMDebug1Base + 43)
#define ID_DLMNewMsgExit         (ID_DLMDebug1Base + 44)
#define ID_DLMContMsgEntered     (ID_DLMDebug1Base + 45)
#define ID_DLMContMsgExit        (ID_DLMDebug1Base + 46)
#define ID_DLMRecEntered         (ID_DLMDebug1Base + 47)
#define ID_DLMRecExit            (ID_DLMDebug1Base + 48)
#define ID_DLMCloseEntered       (ID_DLMDebug1Base + 49)
#define ID_DLMCloseExit          (ID_DLMDebug1Base + 50)
#define ID_DLMGetCharEntered     (ID_DLMDebug1Base + 51)
#define ID_DLMGetCharExit        (ID_DLMDebug1Base + 52)
#define ID_DLMInitEntered        (ID_DLMDebug1Base + 53)
#define ID_DLMInitExit           (ID_DLMDebug1Base + 54)
#define ID_DLMDeInitEntered      (ID_DLMDebug1Base + 55)
#define ID_DLMDeInitExit         (ID_DLMDebug1Base + 56)
#define ID_DLMCloseAllExit       (ID_DLMDebug1Base + 57)
#define ID_DLMEnqEntered         (ID_DLMDebug1Base + 58)
#define ID_DLMEnqExit            (ID_DLMDebug1Base + 59)
#define ID_DLMDeqEntered         (ID_DLMDebug1Base + 60)
#define ID_DLMDeqExit            (ID_DLMDebug1Base + 61)
#define ID_DLMEnqPEntered        (ID_DLMDebug1Base + 62)
#define ID_DLMEnqPExit           (ID_DLMDebug1Base + 63)


// Debug level 2 messages
#define ID_DLMDebug2Base         600
#define ID_DLMCallback           (ID_DLMDebug2Base + 1)
#define ID_DLMConnection         (ID_DLMDebug2Base + 2)
#define ID_DLMBuffer             (ID_DLMDebug2Base + 3)
#define ID_DLMSize               (ID_DLMDebug2Base + 4)
#define ID_DLMRemaining          (ID_DLMDebug2Base + 5)
#define ID_DLMReceived           (ID_DLMDebug2Base + 6)
#define ID_DLMToken              (ID_DLMDebug2Base + 7)
#define ID_DLMOChannel           (ID_DLMDebug2Base + 8)
#define ID_DLMRChannel           (ID_DLMDebug2Base + 9)
#define ID_DLMStatus             (ID_DLMDebug2Base + 10)
#define ID_DLMEndSessClosing     (ID_DLMDebug2Base + 11)
#define ID_DLMBufferSize         (ID_DLMDebug2Base + 12)
#define ID_DLMLinkPacket         (ID_DLMDebug2Base + 13)
#define ID_DLMChannel            (ID_DLMDebug2Base + 14)
#define ID_DLMInDumping          (ID_DLMDebug2Base + 15)
#define ID_DLMByteCount          (ID_DLMDebug2Base + 16)
#define ID_DLMDeqNoBuf           (ID_DLMDebug2Base + 17)
#define ID_DLMEnqPSkip           (ID_DLMDebug2Base + 18)


//------------------------------------------------------------------------------
// MDM -> mdmnbios.dll

#define ID_mdmBase				700
#define ID_mdmLibMain			(ID_mdmBase + 1)
#define ID_mdmWep				(ID_mdmBase + 2)
#define ID_mdmBadhSesUser		(ID_mdmBase + 3)
#define ID_mdmBadhConUser		(ID_mdmBase + 4)
#define ID_mdmBadhSesFree		(ID_mdmBase + 5)
#define ID_mdmBadhConFree		(ID_mdmBase + 6)
#define ID_mdmBadhSesInt		(ID_mdmBase + 7)
#define ID_mdmBadhConInt		(ID_mdmBase + 8)
#define ID_mdmNoMorehSes		(ID_mdmBase + 9)
#define ID_mdmNoMorehCon		(ID_mdmBase + 10)
#define ID_mdmWepConFree		(ID_mdmBase + 11)
#define ID_mdmActiveCon			(ID_mdmBase + 12)
#define ID_mdmBBegSes			(ID_mdmBase + 13)
#define ID_mdmEBegSes			(ID_mdmBase + 14)
#define ID_mdmBEndSes			(ID_mdmBase + 15)
#define ID_mdmEEndSes			(ID_mdmBase + 16)
#define ID_mdmBListen			(ID_mdmBase + 17)
#define ID_mdmEListen			(ID_mdmBase + 18)
#define ID_mdmBMakeCon			(ID_mdmBase + 19)
#define ID_mdmEMakeCon			(ID_mdmBase + 20)
#define ID_mdmBAcceptCon		(ID_mdmBase + 21)
#define ID_mdmEAcceptCon		(ID_mdmBase + 22)
#define ID_mdmBRejectCon		(ID_mdmBase + 23)
#define ID_mdmERejectCon		(ID_mdmBase + 24)
#define ID_mdmBCloseCon			(ID_mdmBase + 25)
#define ID_mdmECloseCon			(ID_mdmBase + 26)
#define ID_mdmErrNetBios		(ID_mdmBase + 27)
#define ID_mdmNoSendNcb			(ID_mdmBase + 28)
#define ID_mdmNoFreeSndNcbSlot	(ID_mdmBase + 29)
#define ID_mdmInvalidConState	(ID_mdmBase + 30)
#define ID_mdmInvalidParams		(ID_mdmBase + 31)
#define ID_mdmToManyListens		(ID_mdmBase + 32)
#define ID_mdmKillTheListen		(ID_mdmBase + 33)
#define ID_mdmBListenCB			(ID_mdmBase + 34)
#define ID_mdmEListenCB			(ID_mdmBase + 35)
#define ID_mdmBConnectCB		(ID_mdmBase + 36)
#define ID_mdmEConnectCB		(ID_mdmBase + 37)
#define ID_mdmBCloseCB			(ID_mdmBase + 38)
#define ID_mdmECloseCB			(ID_mdmBase + 39)
#define ID_mdmBSndCB			(ID_mdmBase + 40)
#define ID_mdmESndCB			(ID_mdmBase + 41)
#define ID_mdmBRcvCB			(ID_mdmBase + 42)
#define ID_mdmERcvCB			(ID_mdmBase + 43)


//---------------------------------------------------------------------------------
// MDM -> MDM Teleos

// Errors
#define ID_MDMTEBASE               1000
#define ID_MDMTEDeqUnackNoHead     (ID_MDMTEBASE + 1)
#define ID_MDMTEDeqUnackNoNext     (ID_MDMTEBASE + 2)
#define ID_MDMTEDeqUnackNoPrev     (ID_MDMTEBASE + 3)
#define ID_MDMTEDeqArrNoTail       (ID_MDMTEBASE + 4)
#define ID_MDMTENullTCB            (ID_MDMTEBASE + 5)
#define ID_MDMTETCBRet             (ID_MDMTEBASE + 6)
#define ID_MDMTEWinSize            (ID_MDMTEBASE + 7)
#define ID_MDMTENoLinkPacket       (ID_MDMTEBASE + 8)
#define ID_MDMTETooLarge           (ID_MDMTEBASE + 9)
#define ID_MDMTELPNotFound         (ID_MDMTEBASE + 10)
#define ID_MDMTENoTCB              (ID_MDMTEBASE + 11)
#define ID_MDMTEInitAlready        (ID_MDMTEBASE + 12)
#define ID_MDMTETCBInitFail        (ID_MDMTEBASE + 13)
#define ID_MDMTELSNErr             (ID_MDMTEBASE + 14)
#define ID_MDMTESizeError          (ID_MDMTEBASE + 15)
#define ID_MDMTEReceived           (ID_MDMTEBASE + 16)
#define ID_MDMTEExpected           (ID_MDMTEBASE + 17)
#define ID_MDMTECorruptQ           (ID_MDMTEBASE + 18)
#define ID_MDMTENoInit             (ID_MDMTEBASE + 19)
#define ID_MDMTEAbanPack           (ID_MDMTEBASE + 20)
#define ID_MDMTESeqNum             (ID_MDMTEBASE + 21)
#define ID_MDMTESipPend            (ID_MDMTEBASE + 22)
#define ID_MDMTENoConn             (ID_MDMTEBASE + 23)
#define ID_MDMTEInvalidID          (ID_MDMTEBASE + 24)
#define ID_MDMTENoSess             (ID_MDMTEBASE + 25)
#define ID_MDMTENoLPM              (ID_MDMTEBASE + 26)
#define ID_MDMTESessID             (ID_MDMTEBASE + 27)
#define ID_MDMTESessNIU            (ID_MDMTEBASE + 28)
#define ID_MDMTESize               (ID_MDMTEBASE + 29)
#define ID_MDMTEState              (ID_MDMTEBASE + 30)
#define ID_MDMTEConnID             (ID_MDMTEBASE + 31)
#define ID_MDMTEConnNIU            (ID_MDMTEBASE + 32)
#define ID_MDMTETinyPacket         (ID_MDMTEBASE + 33)
#define ID_MDMTEPacketOOS          (ID_MDMTEBASE + 34)
#define ID_MDMTEECBNotFound        (ID_MDMTEBASE + 35)

// Trace Information
#define ID_MDMTTBASE               1100
#define ID_MDMTTB1CEnter         (ID_MDMTTBASE + 1)
#define ID_MDMTTB1CExit          (ID_MDMTTBASE + 2)
#define ID_MDMTTSB1Enter         (ID_MDMTTBASE + 3)
#define ID_MDMTTSB1Exit          (ID_MDMTTBASE + 4)
#define ID_MDMTTB2CEnter         (ID_MDMTTBASE + 5)
#define ID_MDMTTB2CExit          (ID_MDMTTBASE + 6)
#define ID_MDMTTSB2Enter         (ID_MDMTTBASE + 7)
#define ID_MDMTTSB2Exit          (ID_MDMTTBASE + 8)
#define ID_MDMTTSendEnter        (ID_MDMTTBASE + 9)
#define ID_MDMTTSendExit         (ID_MDMTTBASE + 10)
#define ID_MDMTTInitEnter        (ID_MDMTTBASE + 11)
#define ID_MDMTTInitExit         (ID_MDMTTBASE + 12)
#define ID_MDMTTDeInitEnter      (ID_MDMTTBASE + 13)
#define ID_MDMTTDeInitExit       (ID_MDMTTBASE + 14)
#define ID_MDMTTLB1Enter         (ID_MDMTTBASE + 15)
#define ID_MDMTTLB1Exit          (ID_MDMTTBASE + 16)
#define ID_MDMTTLB2Enter         (ID_MDMTTBASE + 17)
#define ID_MDMTTLB2Exit          (ID_MDMTTBASE + 18)
#define ID_MDMTTNBSEnter         (ID_MDMTTBASE + 19)
#define ID_MDMTTNBSExit          (ID_MDMTTBASE + 20)
#define ID_MDMTTRecEnter         (ID_MDMTTBASE + 21)
#define ID_MDMTTRecExit          (ID_MDMTTBASE + 22)
#define ID_MDMTTCTSEnter         (ID_MDMTTBASE + 23)
#define ID_MDMTTCTSExit          (ID_MDMTTBASE + 24)
#define ID_MDMTTGCEnter          (ID_MDMTTBASE + 25)
#define ID_MDMTTGCExit           (ID_MDMTTBASE + 26)
#define ID_MDMTTBegSessEnter     (ID_MDMTTBASE + 27)
#define ID_MDMTTBegSessExit      (ID_MDMTTBASE + 28)
#define ID_MDMTTEndSessEnter     (ID_MDMTTBASE + 29)
#define ID_MDMTTEndSessExit      (ID_MDMTTBASE + 30)
#define ID_MDMTTMakeConEnter     (ID_MDMTTBASE + 31)
#define ID_MDMTTMakeConExit      (ID_MDMTTBASE + 32)
#define ID_MDMTTCloseConEnter    (ID_MDMTTBASE + 33)
#define ID_MDMTTCloseConExit     (ID_MDMTTBASE + 34)
#define ID_MDMTTListEnter        (ID_MDMTTBASE + 35)
#define ID_MDMTTListExit         (ID_MDMTTBASE + 36)
#define ID_MDMTTAccEnter         (ID_MDMTTBASE + 37)
#define ID_MDMTTAccExit          (ID_MDMTTBASE + 38)
#define ID_MDMTTRejEnter         (ID_MDMTTBASE + 39)
#define ID_MDMTTRejExit          (ID_MDMTTBASE + 40)
#define ID_MDMTTRecLookEnter     (ID_MDMTTBASE + 41)
#define ID_MDMTTRecLookExit      (ID_MDMTTBASE + 42)

// Comment Information
#define ID_MDMTCBASE               1200
#define ID_MDMTCSeqNum             (ID_MDMTCBASE + 1)
#define ID_MDMTCFound              (ID_MDMTCBASE + 2)
#define ID_MDMTCWaiting            (ID_MDMTCBASE + 3)
#define ID_MDMTCCTSFail            (ID_MDMTCBASE + 4)
#define ID_MDMTCCTSPass            (ID_MDMTCBASE + 5)
#define ID_MDMTCCTSize             (ID_MDMTCBASE + 6)
#define ID_MDMTCCTSOut             (ID_MDMTCBASE + 7)
#define ID_MDMTCTCB                (ID_MDMTCBASE + 8)
#define ID_MDMTCECBPMAddr          (ID_MDMTCBASE + 9)
#define ID_MDMTCECBRMAddr          (ID_MDMTCBASE + 10)

#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#endif	// h file included already
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rrcminc\rrcm.h ===
/*-------------------------------------------------------------------------
// File : RRCM.H
//
// RRCM's include files .
//
//  INTEL Corporation Proprietary Information
// This listing is supplied under the terms of a license agreement with 
// Intel Corporation and may not be copied nor disclosed except in 
// accordance with the terms of that agreement.
// Copyright (c) 1995 Intel Corporation. 
//-----------------------------------------------------------------------*/


#ifndef __RRCM_H_
#define __RRCM_H_


#define INCL_WINSOCK_API_TYPEDEFS 1
#include <windows.h>
//#include <wsw.h>
#include <winsock2.h>
#include <stdio.h>
#include <io.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>  
#include <math.h>  
#include <process.h> 
#include <mmsystem.h>   
//#include <assert.h>
#include <confdbg.h>

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
#include "interop.h"
#include "rtpplog.h"
#endif

typedef CHAR	*PCHAR;

//#define ENABLE_ISDM2

#ifdef ENABLE_ISDM2
#include "isdmapi2.h"
#endif
#include "rrcm_dll.h"
#include "rrcmdata.h"
#include "rrcmprot.h"
#include "rtp.h"
#include "isrg.h"



//----------------------------------------------------------------------------
// RTP/RTCP: Registry information under:
//				HKEY_LOCAL_MACHINE\SOFTWARE\INTEL\RRCM
//----------------------------------------------------------------------------
#define szRegRRCMSubKey				TEXT("RRCM")
#define szRegRRCMSubKeyIntel		TEXT("iRRCM")
#define szRegRRCMKey				TEXT("SOFTWARE\\Microsoft\\Conferencing\\")
#define szRegRRCMWsLib				TEXT("WsLib")
#define szRegRRCMNumSessions		TEXT("NumSessions")
#define szRegRRCMNumFreeSSRC		TEXT("NumFreeSSRC")
#define szRegRRCMNumRTCPPostedBfr	TEXT("NumRTCPPostedBfr")
#define szRegRRCMRTCPrcvBfrSize		TEXT("RTCPrcvBfrSize")


//----------------------------------------------------------------------------
// RTP/RTCP: Dynamically loaded DLL
//----------------------------------------------------------------------------
#ifdef ENABLE_ISDM2
#define szISDMdll					TEXT("ISDM2")
#endif

#define szRRCMdefaultLib			TEXT("ws2_32")


#ifdef ENABLE_ISDM2
//----------------------------------------------------------------------------
// RTP/RTCP: ISDM module
//----------------------------------------------------------------------------
#define szSSRCtoken					TEXT("SSRC")
#define szPcktSentToken				TEXT("Number of packets send")
#define szByteSentToken				TEXT("Number of bytes send")
#define szPcktRcvdToken				TEXT("Number of packets received")
#define szByteRcvdToken				TEXT("Number of bytes received")
#define szFractionLostToken			TEXT("Fraction lost")
#define szCumNumPcktLostToken		TEXT("Cumulative number of packets lost")
#define szXntHighSeqNumToken		TEXT("Extended highest sequence number")
#define szInterarrivalJitterToken	TEXT("Interarrival jitter")
#define szLastSRtoken				TEXT("Last sender report")
#define szDSLRtoken					TEXT("Delay since last sender report")
#define szNTPfracToken				TEXT("NTP fraction")
#define szNTPsecToken				TEXT("NTP seconds")
#define szWhoAmItoken				TEXT("Who Am I")
#define szFdbkFractionLostToken		TEXT("Fraction lost feedback")
#define szFdbkCumNumPcktLostToken	\
	TEXT("Cumulative number of packets lost feedback")
#define szFdbkLastSRtoken			TEXT("Last sender report feedback")
#define szFdbkDSLRtoken				\
	TEXT("Delay since last sender report feedback")
#define szFdbkInterarrivalJitterToken	TEXT("Interarrival jitter feedback")
#endif


//----------------------------------------------------------------------------
// RTP: Bitmaps used to isolate errors detected for incoming received packets
//----------------------------------------------------------------------------
#define SSRC_LOOP_DETECTED			(1)
#define SSRC_COLLISION_DETECTED		(2)
#define INVALID_RTP_HEADER			(3)
#define MCAST_LOOPBACK_NOT_OFF		(4)
#define RTP_RUNT_PACKET				(5)

//----------------------------------------------------------------------------
// RTP: Default number of RTP sessions
//----------------------------------------------------------------------------
#define NUM_RRCM_SESS				50
#define MIN_NUM_RRCM_SESS			5
#define MAX_NUM_RRCM_SESS			100

//----------------------------------------------------------------------------
// RTP: Number of entries in the hash table
//----------------------------------------------------------------------------
#define NUM_RTP_HASH_SESS			65		

//---------------------------------------------------------------------------- 
//	RTP: DEFINES TO DETERMINE SEQUENCE NUMBER WRAP or STALENESS (per RFC)
//----------------------------------------------------------------------------
#define MAX_DROPOUT					3000
#define MAX_MISORDER				100
#define MIN_SEQUENTIAL				2

//----------------------------------------------------------------------------
//	RTCP: Defined
//----------------------------------------------------------------------------
#define	MAX_RR_ENTRIES				31			// Max # of Receiver Reports
#define TIMEOUT_CHK_FREQ			30000		// Timeout check freq. - 30s
#define RTCP_TIME_OUT_MINUTES		30			// 30 minutes timeout
#define	RTCP_XMT_MINTIME			2500
#define RTCP_TIMEOUT_WITHIN_RANGE	100
#define	ONE_K						1024

#define	NUM_FREE_SSRC				100
#define	MIN_NUM_FREE_SSRC			5
#define	MAX_NUM_FREE_SSRC			500

#define NUM_FREE_CONTEXT_CELLS			100
#define MAXNUM_CONTEXT_CELLS_REALLOC	10

#define	NUM_FREE_RCV_BFR			8
#define	NUM_FREE_XMT_BFR			2
#define NUM_RCV_BFR_POSTED			4
#define MIN_NUM_RCV_BFR_POSTED		1
#define MAX_NUM_RCV_BFR_POSTED		8
#define RRCM_RCV_BFR_SIZE			(8*ONE_K)
#define MIN_RRCM_RCV_BFR_SIZE		(1*ONE_K)
#define MAX_RRCM_RCV_BFR_SIZE		(8*ONE_K)
#define RRCM_XMT_BFR_SIZE			(8*ONE_K)
#define	RCV_BFR_LIST_HEAP_SIZE		(4*ONE_K)	// Rcv bfr list heap size
#define	XMT_BFR_LIST_HEAP_SIZE		(4*ONE_K)	// Xmt bfr list heap size
#define INITIAL_RTCP_BANDWIDTH		50			// BW in bytes/sec (~ G.723)
												//   5% of 6.3Kb/s = 35 bytes
#define	MAX_STREAMS_PER_SESSION		64			// Max number of active 
												//   streams per RTP session
#define MAX_NUM_SDES				9			// Number of SDES support


//----------------------------------------------------------------------------
//	RTP/RTCP Misc defined
//----------------------------------------------------------------------------
#define UNKNOWN_PAYLOAD_TYPE		0xFFFFFFFF
#define szDfltCname					TEXT("No Cname")


//----------------------------------------------------------------------------
//	RTP/RTCP: Debug Defined
//----------------------------------------------------------------------------
#define	DBG_STRING_LEN			200
#define	IO_CHECK				0
#define	FLUSH_RTP_PAYLOAD_TYPE	90

enum ISRBDG_CODE{
	DBG_NOTIFY = 1,
	DBG_CRITICAL,
	DBG_ERROR,
	DBG_WARNING,
	DBG_TRACE,
	DBG_TEMP
	};

#ifdef _DEBUG
//#define ASSERT(x)				assert(x)	// defined in confdbg.h
#define RRCM_DBG_MSG(x,e,f,l,t)	RRCMdebugMsg(x,e,f,l,t)
#else
//#define ASSERT(x)	defined in confdbg.h
#define RRCM_DBG_MSG(x,e,f,l,t)	{}	// DO NOT DELETE BRACKETS ...
#endif

#ifdef IN_OUT_CHK
#define	IN_OUT_STR(x)			OutputDebugString (x);
#else
#define	IN_OUT_STR(x)	
#endif


#endif /* __RRCM_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rrcminc\rrcmdata.h ===
/*---------------------------------------------------------------------------
 * File : RRCMDATA.H
 *
 * RRCM data structures information.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with
 * Intel Corporation and may not be copied nor disclosed except in
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation.
 *--------------------------------------------------------------------------*/

#ifndef	__RRCMDATA_H_
#define	__RRCMDATA_H_

// force 8 byte structure packing
#include <pshpack8.h>

#define MAX_DWORD					4294967295
#define	HASH_MODULO					255	
#define FILENAME_LENGTH				128
#define	RTCP_FEEDBACK_LIST			0


// RTP/RTCP collision data
typedef struct _rtp_collision
	{
	char				collideAddr[MAX_ADDR_LEN];
	int					addrLen;
	DWORD				dwCollideTime;
	DWORD				dwCurRecvRTCPrptNumber;
	DWORD				SSRC;
	} RTP_COLLISION, *PRTP_COLLISION;



//	RTCP Session Information data structure
typedef struct _RTCP_SESSION
	{
	LINK_LIST	RTCPList;					// Next/prev RTCP session ptrs
	
	// Synchronization elements
	CRITICAL_SECTION	critSect;			// Critical section
	HANDLE		hExitEvent;					// Exit RTCP event handle

#ifdef ENABLE_ISDM2
	// ISDM2 Handle
	KEY_HANDLE	hSessKey;					// Key to this sessions ISDM info
#endif

	// List of SSRC(s) on the transmit list, i.e., our own transmit SSRC's
	//  and list of SSRC(s) received
	HEAD_TAIL	RcvSSRCList;				// Rcv SSRC list head/tail ptrs
	HEAD_TAIL	XmtSSRCList;				// Xmt SSRC list head/tail ptrs

	// List of Rcv/Xmt data structure. The data resides in a heap
	//  in order to avoid page fault
	HEAD_TAIL	RTCPrcvBfrList;				// Rcv buffers head/tail ptrs
	HANDLE		hHeapRcvBfrList;			// Heap handle to Rcv bfrs list

	// Rcv/Xmt buffers have their own heap
	HANDLE		hHeapRcvBfr;				// Heap handle to Rcv Bfrs mem.	

	WSABUF		XmtBfr;						// RTCP send buffer descriptor
	// Application provided list of buffers where RRCM will copy the raw
	//  RTCP buffers
	HEAD_TAIL	appRtcpBfrList;				// Head/tail ptrs for app bfr list

	DWORD		dwInitNumFreeRcvBfr;		// Number of Free Rcv Buffers	
	DWORD		dwRcvBfrSize;				// Receive Buffer size			
	DWORD		dwXmtBfrSize;				// Transmit Buffer size			
				
	DWORD		dwSessionStatus;			// Entry status:				

	char		toBfr[MAX_ADDR_LEN];		// Destination address			
	int			toLen;						// Size of lpTo					

	int			avgRTCPpktSizeRcvd;			// Average RTCP pckt size		

	DWORD		dwNumStreamPerSes;			// Num of streams per Session
	DWORD		dwCurNumSSRCperSes;			// Num of SSRC per Session		

#ifdef MONITOR_STATS
	DWORD		dwHiNumSSRCperSes;			// High Num of SSRC per Session	
#endif

	// Receive information (shared by all streams of this session)
	HANDLE		hShutdownDone;				// Shutdown procedure done
	int			dwNumRcvIoPending;			// Number of receive I/O pending

	// Notification callback of RRCM events if desired by the application
	VOID		(*pRRCMcallback)(RRCM_EVENT_T, DWORD_PTR, DWORD_PTR, DWORD_PTR);

	// User information on callback
	DWORD_PTR	dwCallbackUserInfo;			

	// RTP Loop/Collision information
	RTP_COLLISION	collInfo[NUM_COLLISION_ENTRIES];

	} RTCP_SESSION, *PRTCP_SESSION;



// RTCP Xmt information
typedef struct _XMIT_INFO
	{
	DWORD		dwNumPcktSent;				// Number of packet sent 		
	DWORD		dwNumBytesSent;				// Number of bytes sent     	
	DWORD		dwNTPmsw;					// NTP most significant word	
	DWORD		dwNTPlsw;					// NTP least significant word	
	DWORD		dwRTPts;					// RTP timestamp				
	DWORD		dwCurXmtSeqNum;				// Current Xmt sequence number	
	DWORD		dwPrvXmtSeqNum;				// Previous Xmt sequence number
	DWORD		dwRtcpStreamMinBW;			// Minimal session's bandwidth
#ifdef DYNAMIC_RTCP_BW
	DWORD		dwCalculatedXmtBW;			// Session's calculated bandwidth
	DWORD		dwLastTimeBwCalculated;		// Last time BW was calculated
	DWORD		dwLastTimeNumBytesSent;		// Last time number of bytes send
	DWORD		dwLastTimeNumPcktSent;		// Last time number of bytes send
#endif
	DWORD		dwLastSR;					// Last sender report (RTP format)
	DWORD		dwLastSRLocalTime;			// Last sender report local time
	DWORD		dwLastSendRTPSystemTime;	// Last RTP packet send time
	DWORD		dwLastSendRTPTimeStamp;		// RTP timestamp of the last packet
	} XMIT_INFO, *PXMIT_INFO;



// RTCP receive information
typedef struct _RECV_INFO
	{
	DWORD		dwNumPcktRcvd;				// Number of packet received	
	DWORD		dwPrvNumPcktRcvd;			// Previous number of pckt rcvd	
	DWORD		dwExpectedPrior;			// Number previously expected	
	DWORD		dwNumBytesRcvd;				// Number of bytes rcvd     	
	DWORD		dwBaseRcvSeqNum;			// Initial sequence number rcvd
	DWORD		dwBadSeqNum;				// Potential new valid seq num
	DWORD		dwProbation;				// # consec pkts for validation
	RTP_SEQ_NUM	XtendedSeqNum;				// Xtnded highest seq. num rcvd	
	DWORD		dwPropagationTime;			// Last packet's transmit time
	DWORD		interJitter;				// Interarrival jitter 			
#ifdef DYNAMIC_RTCP_BW
	DWORD		dwCalculatedRcvBW;			// Session's calculated bandwidth
	DWORD		dwLastTimeBwCalculated;		// Last time BW was calculated
	DWORD		dwLastTimeNumBytesRcvd;		// Last time number of bytes rcvd
	DWORD		dwLastTimeNumPcktRcvd;		// Last time number of bytes rcvd
#endif
	} RECV_INFO, *PRECV_INFO;



//	RRCM statistics table entry data structure
typedef struct _SSRC_ENTRY
	{
	LINK_LIST	SSRCList;					// Next/prev SSRC entry	

	CRITICAL_SECTION	critSect;			// Critical section synch.		

	PRTCP_SESSION	pRTCPses;				// Point to the parent session	

	DWORD		SSRC;						// Source SSRC 					
	DWORD		PayLoadType;				// payload associated with this SSRC

	DWORD		dwSSRCStatus;				// Entry status 				
#define	NETWK_ADDR_UPDATED		0x80000000	// Network Address already done	
#define	SEQ_NUM_UPDATED			0x40000000	// XMT Sequence already done	
#define THIRD_PARTY_COLLISION	0x20000000	// Third party collsion detected
#define CLOSE_RTCP_SOCKET		0x10000000	// RTCP will close the RTCP socket
#define RTCP_XMT_USER_CTRL		0x08000000	// User's has RTCP timeout control

	// SSRC Transmit information
	// If on our transmit list, this is our SSRC information, and if on our
	// receive list, this is a SR feedback information.
	XMIT_INFO	xmtInfo;

	// SSRC Receive information
	// If on our transmit list, this is undefined information, and if on our
	// receive list, this is the SSRC's receive information, ie, this SSRC
	// is an active sender somewhere on the network. This information is
	// maintained by RTP, and used by RTCP to generate RR.
	RECV_INFO	rcvInfo;

	// Feedback information received about ourselve if we're an active source
	RTCP_FEEDBACK	rrFeedback;				// Feedback	information

	DWORD		dwLastReportRcvdTime;		// Time of last report received
	DWORD		dwNextReportSendTime;		// Next scheduled report time (ms)

#ifdef _DEBUG
	DWORD		dwPrvTime;					// Elapsed time between report	
#endif

	// SSRC SDES information
	SDES_DATA	cnameInfo;					// CNAME information
	SDES_DATA	nameInfo;					// NAME information
	SDES_DATA	emailInfo;					// EMAIL address information
	SDES_DATA	phoneInfo;					// PHONE number information
	SDES_DATA	locInfo;					// LOCation (users) information
	SDES_DATA	toolInfo;					// TOOL name information
	SDES_DATA	txtInfo;					// TEXT (NOTE) information
	SDES_DATA	privInfo;					// PRIVate information

	// SSRC network address information
	int			fromLen;					// From address length
	char		from[MAX_ADDR_LEN];			// From address						

	// !!! Not implemented (entries will grow exponentionally) !!!
	// List of SSRCs in RR received by this SSRC. It might be useful for a
	// sender or a controller to know how other active sources are received
	// by others.
	// The drawback is that the number of entries will grow exponentially
	// with the number of participants.
	// Currently not implemented.
#if RTCP_FEEDBACK_LIST
	HEAD_TAIL	rrFeedbackList;				// Head/Tail of feedback list
#endif

#ifdef ENABLE_ISDM2
	DWORD		hISDM;						// ISDM session handle
#endif

	// All variables below should be in an additional linked list one layer
	// up this one, under the RTCP session link list.
	// They have been moved here when we added multiple streams per session
	// !!! NOTE !!!: There is only 1 transmit thread per stream. It's ID is
	// found in this data structure which is on the Xmt list.
	SOCKET		RTPsd;						// RTP socket descriptor		
	SOCKET		RTCPsd;						// RTCP socket descriptor		
	HANDLE		hXmtThread;					// RTCP session thread handle	
	DWORD		dwXmtThreadID;				// RTCP session thread ID		
	HANDLE		hExitXmtEvent;				// Xmt thread Exit event -
											//  Used to terminate a session
											//  among multiple stream on the
											//  same session
	DWORD		dwNumRptSent;				// Number of RTCP report sent	
	DWORD		dwNumRptRcvd;				// Number of RTCP report rcvd	
	DWORD		dwNumXmtIoPending;			// Number of transmit I/O pending
	DWORD		dwStreamClock;				// Sampling frequency
	DWORD		dwUserXmtTimeoutCtrl;		// User's xmt timer control
											//		0x0		-> RRCM control
											//		0xFFFF	-> No RTCP send
											//		value	-> timer value
	// All the above variables should move in the intermediate layer for
	// multiple stream per session support

	} SSRC_ENTRY, *PSSRC_ENTRY;



//	RTP process data structure
typedef struct _RTP_SESSION
	{
	LINK_LIST		RTPList;				// Next/Prev RTP session

	CRITICAL_SECTION	critSect;			// Critical section

	PRTCP_SESSION	pRTCPSession;			// Pointer to my RTCP side
	} RTP_SESSION, *PRTP_SESSION;
	

#if 0
//	RTP Ordered buffer structure
typedef struct _RTP_BFR_LIST
	{
	LINK_LIST			RTPBufferLink;		// Next/prev					

	LPWSAOVERLAPPED_COMPLETION_ROUTINE	
				pfnCompletionNotification;	// Pointer to Rcv notif. func	
	WSAEVENT			hEvent;				// WSAOverlapped handle			
	LPWSABUF			pBuffer;			// Pointer to WSABuffers		
	PRTP_SESSION		pSession;			// This session's ID			
	DWORD				dwBufferCount;		// Number of bufs in LPWSABUF	
	DWORD				dwFlags;				// WSARecv flags				
	LPVOID				pFrom;				// Pointer to source address
	LPINT				pFromlen;			// Pointer to source address
	SOCKET				RTPsocket;			// Socket descriptor
	} RTP_BFR_LIST, *PRTP_BFR_LIST;



//	RTP Ordered buffer structure
typedef struct _RTP_HASH_LIST
	{
	LINK_LIST			RTPHashLink;		// Next/prev					

	PRTP_SESSION		pSession;			// This session's ID			
	SOCKET				RTPsocket;			// Socket descriptor
	} RTP_HASH_LIST, *PRTP_HASH_LIST;

#endif


//	RTP registry initialization
typedef struct _RRCM_REGISTRY
	{
	DWORD				NumSessions;		// RTP/RTCP sessions
	DWORD				NumFreeSSRC;		// Initial number of free SSRCs
	DWORD				NumRTCPPostedBfr;	// Number of RTCP recv bfr posted
	DWORD				RTCPrcvBfrSize;		// RTCP rcv bfr size

	// Dynamically loaded DLL & Send/Recv function name
	CHAR				WSdll[FILENAME_LENGTH];
	} RRCM_REGISTRY, *PRRCM_REGISTRY;



//	RTP Context Sensitive structure
typedef struct _RTP_CONTEXT
	{
	HEAD_TAIL		pRTPSession;			// Head/tail of RTP session(s)

	CRITICAL_SECTION	critSect;			
	HINSTANCE		hInst;					// DLL instance					


	RRCM_REGISTRY	registry;				// Registry initialization
	} RTP_CONTEXT, *PRTP_CONTEXT;



//	RTCP Context Sensitive structure
typedef struct _RTCP_CONTEXT
	{
	HEAD_TAIL		RTCPSession;			// RTCP sessions head/tail ptrs
	HANDLE			hHeapRTCPSes;			// Heap handle to RTCP sessions	

	CRITICAL_SECTION	critSect;			// Critical section synch.		

	HEAD_TAIL		RRCMFreeStat;			// RRCM entries	head/tail ptrs	
	HANDLE			hHeapRRCMStat;			// Heap handle to RRCM stats	
	DWORD			dwInitNumFreeRRCMStat;	// Number of Free SSRC entries	

	DWORD			dwRtcpThreadID;			// RTCP thread ID
	HANDLE			hRtcpThread;			// RTCP thread hdle
	HANDLE			hTerminateRtcpEvent;	// RTCP terminate thread event hdl
	HANDLE			hRtcpRptRequestEvent;	// RTCP report request event

#ifdef MONITOR_STATS
	DWORD			dwRTCPSesCurNum;		// Num of RTCP Session			
	DWORD			dwRTCPSesHiNum;			// High num RTCP per Session	

	DWORD			dwRRCMStatFreeLoNum;	// Low num of RRCM free Stat 	
	DWORD			dwRRCMStatFreeCurNum;	// Cur num of RRCM Free Stat	
	DWORD			dwRRCMStatFreeHiNum;	// High num of RRCM Free Stat	

	DWORD			dwCurNumRTCPThread;		// Current num of RTCP thread	
	DWORD			dwHiNumRTCPThread;		// High number of RTCP thread	

	DWORD			dwNumRTCPhdrErr;		// Num of RTCP pckt header err.	
	DWORD			dwNumRTCPlenErr;		// Num of RTCP pckt length err.	
#endif
	} RTCP_CONTEXT, *PRTCP_CONTEXT;



//	RTCP Free Buffers List
typedef struct _RTCP_BFR_LIST
	{
	LINK_LIST			bfrList;			// Next/prev buffer in list		

	WSAOVERLAPPED		overlapped;			// Overlapped I/O structure		
	WSABUF				bfr;				// WSABuffers					
	DWORD				dwBufferCount;		// Number of bufs in WSABUF		

	DWORD				dwNumBytesXfr;		// Number of bytes rcv/xmt		
	DWORD				dwFlags;			// Flags						
	char				addr[MAX_ADDR_LEN];	// Network Address
	int					addrLen;			// Address length   		

	PSSRC_ENTRY			pSSRC;				// Pointer to SSRC entry address
	} RTCP_BFR_LIST, *PRTCP_BFR_LIST;


// Dynamically loaded functions
typedef struct _RRCM_WS
	{
	HINSTANCE						hWSdll;
	LPFN_WSASENDTO					sendTo;
	LPFN_WSARECVFROM				recvFrom;
	LPFN_WSANTOHL					ntohl;
	LPFN_WSANTOHS					ntohs;
	LPFN_WSAHTONL					htonl;
	LPFN_WSAHTONS					htons;
	LPFN_GETSOCKNAME				getsockname;
	LPFN_GETHOSTNAME				gethostname;
	LPFN_GETHOSTBYNAME				gethostbyname;
	LPFN_CLOSESOCKET				closesocket;
	LPFN_WSASOCKET					WSASocket;
	LPFN_BIND						bind;
	LPFN_WSAENUMPROTOCOLS			WSAEnumProtocols;
	LPFN_WSAJOINLEAF				WSAJoinLeaf;
	LPFN_WSAIOCTL					WSAIoctl;
	LPFN_SETSOCKOPT 				setsockopt;
	WSAPROTOCOL_INFO 				RTPProtInfo;	// used to open RTP sockets

	} RRCM_WS, *PRRCM_WS;

extern RRCM_WS			RRCMws;

#define WS2Enabled (RRCMws.hWSdll != NULL)
#define WSQOSEnabled (RRCMws.RTPProtInfo.dwServiceFlags1 & XP1_QOS_SUPPORTED)


#ifdef ENABLE_ISDM2
// ISDM support
typedef struct _ISDM2
	{
	CRITICAL_SECTION	critSect;			// Critical section synch.		
	ISDM2API			ISDMEntry;			// DLL entry point
	HINSTANCE			hISDMdll;
	DWORD				hIsdmSession;		// ISDM Session's handle
	} ISDM2, *PISDM2;
#endif // #ifdef ENABLE_ISDM2


// restore structure packing
#include <poppack.h>

#endif // __RRCMDATA_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rrcminc\rtpplog.h ===
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1996:  Intel Corporation
// Confidential -- All proprietary rights reserved.
//
// AUTHOR       Stacy Bell
//
// DESCRIPTION
//              This file contains protocol logging definitions needed by RRCM
//              and the RTP PDU logging class.
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

// This define identifies the RTP and RTCP protocols as the ones to be logged.
// In the RRCM code, it is used only in the CPLInitialize() call.  
// For example:  RTPProtocolLogger = CPLInitialize( RTPLOG_PROTOCOL );
//
#define RTPLOG_PROTOCOL "RTP_PDU"

// PDU encoding type flags and PDU type flags.  These flags are passed from
// RRCM to the logging via user data.  Bit zero of the user data represents
// the Protocol type.  Bit 1 represents whether the PDU was sent or received.
//

#define RTCP_PDU                1UL
#define RTP_PDU                 0UL

#define RTPLOG_SENT_PDU		2UL
#define RTPLOG_RECEIVED_PDU	0UL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rrcminc\rtp.h ===
/*------------------------------------------------------------------------- 
 * Filename: RTP.H
 *
 * RTP related data structures.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/

#ifndef _RTP_H_
#define _RTP_H_

#define RTP_HDR_MIN_LEN	12
#define RTP_SEQ_MOD 	(1<<16)
#define RTP_TS_MOD  	(0xffffffff)

#define RTP_TYPE		2		/* Current version */
#define RTP_MAX_SDES	256		/* maximum text length for SDES */

#define RTCP_SIZE_GAIN	(1./16.)
#define NTWRK_HDR_SIZE	28

typedef enum {
	RTCP_SR   = 200,
	RTCP_RR   = 201,
	RTCP_SDES = 202,
	RTCP_BYE  = 203,
	RTCP_APP  = 204
	} RTCP_TYPE_T;

typedef struct {                             
	// !!! WARNING !!!
	// The following word doesn't need to be swapped for NtoH()
	WORD 			cc:4;       /* CSRC count */  
	WORD 			x:1;        /* header extension flag */  
	WORD 			p:1;        /* padding flag */  
	WORD 			type:2;     /* version type 1/2 */
	WORD		 	pt:7;       /* payload type */
	WORD			m:1;        /* marker bit */  

	WORD			seq;		/* sequence number */
	DWORD 			ts;         /* timestamp */
	DWORD 			ssrc;       /* synchronization source */
	DWORD 			csrc[1];    /* optional CSRC list */
	} RTP_HDR_T;

// macros to get various RTP header fields
#define RTP_TIMESTAMP(p) (((RTP_HDR_T *)p)->ts)
#define RTP_SEQNUM(p) (((RTP_HDR_T *)p)->seq)
#define RTP_MARKBIT(p) (((RTP_HDR_T *)p)->m)
#define RTP_SSRC(p) (((RTP_HDR_T *)p)->ssrc)

typedef struct {
	// !!! WARNING !!!
	// The following word doesn't need to be swapped for NtoH()
	WORD 			count:5;    /* varies by payload type */  
	WORD 			p:1;        /* padding flag */  
	WORD 			type:2;     /* protocol version */
	WORD		 	pt:8;       /* payload type */

    WORD			length;     /* packet length in words, without this word */
	} RTCP_COMMON_T;

/* reception report */
typedef struct {
	DWORD			ssrc;       /* data source being reported */
	DWORD			received;   /* cumulative number of packets received */
	DWORD			expected;   /* cumulative number of packets expected */
	DWORD			jitter;     /* interarrival jitter */
	DWORD			lsr;        /* last SR packet from this source */
	DWORD			dlsr;       /* delay since last SR packet */
	} RTCP_RR_T;

typedef struct {
	BYTE			dwSdesType;       /* type of SDES item (rtcp_sdes_type_t) */
	BYTE			dwSdesLength;     /* length of SDES item (in octets) */
	char 			sdesData[1];    /* text, not zero-terminated */
	} RTCP_SDES_ITEM_T;

typedef struct {
	DWORD 		ssrc;       /* source this RTCP packet refers to */
	DWORD 		ntp_sec;    /* NTP timestamp */
	DWORD 		ntp_frac;
	DWORD 		rtp_ts;     /* RTP timestamp */
	DWORD 		psent;      /* packets sent */
	DWORD 		osent;      /* octets sent */ 
		
	RTCP_RR_T 	rr[1];		/* variable-length list */
	} SENDER_RPT;

typedef struct {
	DWORD 		ssrc;        /* source this generating this report */
	RTCP_RR_T rr[1];		 /* variable-length list */
	} RECEIVER_RPT;

typedef struct {
	DWORD 		src[1];   	 /* list of sources */
		
	/* can't express trailing text */
	} BYE_PCKT;

typedef struct {
	DWORD 	src;              /* first SSRC/CSRC */
	RTCP_SDES_ITEM_T item[1]; /* list of SDES items */
	} RTCP_SDES_T;

/* one RTCP packet */
typedef struct {
	RTCP_COMMON_T	common;     /* common header */
	
	union 
		{
		SENDER_RPT		sr;		/* sender report (SR) */
		RECEIVER_RPT	rr;		/* reception report (RR) */
		BYE_PCKT		bye;	/* BYE */
		RTCP_SDES_T		sdes;	/* source description (SDES) */
		} r;
	} RTCP_T;


typedef DWORD MEMBER_T;


#endif /* ifndef _RTP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtcp\rtcpmem.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTCPMEM.C
 * Product:     RTP/RTCP implementation
 * Description: Provides memory operations functions for RTCP.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/

		
#include "rrcm.h"                                    
                                       

/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/            


/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/                                       
extern PRTP_CONTEXT	pRTPContext;
#ifdef _DEBUG
extern char		debug_string[];
#endif


/*----------------------------------------------------------------------------
 * Function   : allocateRTCPContextHeaps
 * Description: Allocates RTCP context heaps
 * 
 * Input :      pRTCPcntxt:	-> to the RTCP context information
 *
 * Return:		OK: RRCM_NoError
 *				!0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
 DWORD allocateRTCPContextHeaps (PRTCP_CONTEXT pRTCPcntxt)
	{
	IN_OUT_STR ("RTCP: Enter allocateRTCPContextHeaps()\n");

	pRTCPcntxt->hHeapRTCPSes = HeapCreate (
			0, 
			(pRTPContext->registry.NumSessions*sizeof(RTCP_SESSION)),
			0);
	if (pRTCPcntxt->hHeapRTCPSes == NULL)
		{
		IN_OUT_STR ("RTCP: Exit allocateRTCPContextHeaps()\n");
		return (RRCMError_RTCPResources);
		}

	pRTCPcntxt->hHeapRRCMStat = HeapCreate (
			0, 
			pRTCPcntxt->dwInitNumFreeRRCMStat*sizeof(SSRC_ENTRY), 
			0);
	if (pRTCPcntxt->hHeapRRCMStat == NULL)
		{
		IN_OUT_STR ("RTCP: Exit allocateRTCPContextHeaps()\n");
		return (RRCMError_RTCPResources);
		}

	IN_OUT_STR ("RTCP: Exit allocateRTCPContextHeaps()\n");
	return (RRCM_NoError);
	}

/*----------------------------------------------------------------------------
 * Function   : allocateRTCPSessionHeaps
 * Description: Allocates RTCP session heaps
 * 
 * Input :      *pRTCPses:		->(->) to the RTCP session's information
 *
 * Return:		OK: RRCM_NoError
 *				!0:	Erro code (see RRCM.H)
 ---------------------------------------------------------------------------*/
 DWORD allocateRTCPSessionHeaps (PRTCP_SESSION *pRTCPses)
	{
	DWORD	heapSize;
	DWORD	dwStatus = RRCM_NoError;

	IN_OUT_STR ("RTCP: Enter allocateRTCPSessionHeaps()\n");

	heapSize = NUM_FREE_RCV_BFR*pRTPContext->registry.RTCPrcvBfrSize;
	(*pRTCPses)->hHeapRcvBfr = HeapCreate (0, 
										   heapSize, 
										   0);
	if ((*pRTCPses)->hHeapRcvBfr == NULL)
		dwStatus = RRCMError_RTCPResources;

	if (dwStatus == RRCM_NoError)
		{
		(*pRTCPses)->hHeapRcvBfrList = HeapCreate (0, 
												   RCV_BFR_LIST_HEAP_SIZE, 
												   0);
		if ((*pRTCPses)->hHeapRcvBfrList == NULL)
			dwStatus = RRCMError_RTCPResources;
		}

	if (dwStatus != RRCM_NoError)
		{
		// destroy allocated heaps
		if ((*pRTCPses)->hHeapRcvBfr)
			{
			HeapDestroy ((*pRTCPses)->hHeapRcvBfr);
			(*pRTCPses)->hHeapRcvBfr = NULL;
			}
		if ((*pRTCPses)->hHeapRcvBfrList)
			{
			HeapDestroy ((*pRTCPses)->hHeapRcvBfrList);
			(*pRTCPses)->hHeapRcvBfrList = NULL;
			}
		}

	IN_OUT_STR ("RTCP: Exit allocateRTCPSessionHeaps()\n");
	return (dwStatus);
	}


/*----------------------------------------------------------------------------
 * Function   : allocateRTCPBfrList
 * Description: Allocates link list of buffers for RTCP (xmit/rcv/...).
 * 
 * Input :      ptr:		-> to the link list to add buffer to
 *				hHeapList:	Handle to the heap list
 *				hHeapBfr:	Handle to the heap buffer
 *				*numBfr:	-> to the number of buffers to allocate
 *				bfrSize:	Individual buffer size
 *
 * Return:		OK: RRCM_NoError
 *				!0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
 DWORD allocateRTCPBfrList (PLINK_LIST ptr, 
							HANDLE hHeapList, 
							HANDLE hHeapBfr,
 							DWORD *numBfr, 
							DWORD bfrSize,
							CRITICAL_SECTION *pCritSect)
	{
	PRTCP_BFR_LIST	bfrPtr;
	PLINK_LIST		tmpPtr;
	
#ifdef IN_OUT_CHK
	OutputDebugString ("RTCP: Enter allocateRTCPBfrList()\n");
#endif

	ASSERT (ptr);
	ASSERT (hHeapList);
	ASSERT (hHeapBfr);

	// make sure at least one buffer is requested 
	if (*numBfr == 0)
		return (RRCMError_RTCPInvalidRequest);

	// allocate link list on the data structure's heap 
	if (allocateLinkedList (ptr, hHeapList, numBfr, 
							sizeof(RTCP_BFR_LIST), pCritSect))
		return (RRCMError_RTCPResources);

	// allocate buffer pool resources starting from the tail 
	tmpPtr = ptr->prev;
    while (tmpPtr != NULL)
    	{
		// points to buffer structure 
		bfrPtr = (PRTCP_BFR_LIST)tmpPtr;
		ASSERT (bfrPtr);

    	// initialize the WSABUF structure on its own heap 
    	bfrPtr->bfr.buf = (char *)HeapAlloc (hHeapBfr, 
											 HEAP_ZERO_MEMORY, 
											 bfrSize);
		if (bfrPtr->bfr.buf == NULL)
			{
			RRCM_DBG_MSG ("RTCP: Error - Cannot Allocate Xmt/Rcv Bfr", 
							0, __FILE__, __LINE__, DBG_ERROR);

// !!! TODO !!!

			// update head/tail pointers 

			// delete remaining cells until end of list 

			break;
			}

		// buffer length 
		bfrPtr->bfr.len = bfrSize;

		// buffer attributes 
		bfrPtr->dwBufferCount = 1;

		// new head pointer 
		tmpPtr = bfrPtr->bfrList.next;
    	}
    
#ifdef IN_OUT_CHK
	OutputDebugString ("RTCP: Exit allocateRTCPBfrList()\n");
#endif
	return (RRCM_NoError);
	}


// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtcp\rtcpinit.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTCPINIT.C
 * Product:     RTP/RTCP implementation
 * Description: Provides RTCP initialization functions.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/

		
#include "rrcm.h"                                    


/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/            
PRTCP_CONTEXT	pRTCPContext = NULL;



/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/
extern PRTP_CONTEXT	pRTPContext;


/*----------------------------------------------------------------------------
 * Function   : initRTCP
 * Description: RTCP initialization procedures. Creates the initial RTCP 
 *				session and allocates all initial memory resources.
 * 
 * Input :      None.
 *
 * Return: 		OK: RRCM_NoError
 *         		!0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
 DWORD initRTCP (void)
	{
	DWORD		dwStatus = RRCM_NoError;  

	IN_OUT_STR ("RTCP: Enter initRTCP()\n");

	// If RTCP has already been initialized, exit and report the error 
	if (pRTCPContext != NULL) 
		{
		RRCM_DBG_MSG ("RTCP: ERROR - Multiple RTCP Instances", 0, 
					  __FILE__, __LINE__, DBG_CRITICAL);

		IN_OUT_STR ("RTCP: Exit initRTCP()\n");
		return (RRCMError_RTCPReInit);
		}

	// Obtain RTCP context 
	pRTCPContext = (PRTCP_CONTEXT)GlobalAlloc (GMEM_FIXED | GMEM_ZEROINIT, 
											   sizeof(RTCP_CONTEXT));
	if (pRTCPContext == NULL) 
		{
		RRCM_DBG_MSG ("RTCP: ERROR - Resource allocation failed", 0, 
					  __FILE__, __LINE__, DBG_CRITICAL);

		IN_OUT_STR ("RTCP: Exit initRTCP()\n");

		return RRCMError_RTCPResources;
		}

	// initialize the context critical section 
	InitializeCriticalSection(&pRTCPContext->critSect);

	// Initialize number of desired free cells 
	pRTCPContext->dwInitNumFreeRRCMStat = pRTPContext->registry.NumFreeSSRC;

	// allocate heaps 
	dwStatus = allocateRTCPContextHeaps (pRTCPContext);
 	if (dwStatus == RRCM_NoError)
		{
		// allocate free list of SSRCs statistic entries 
 		dwStatus = allocateLinkedList (&pRTCPContext->RRCMFreeStat,
									   pRTCPContext->hHeapRRCMStat,
 						 	 		   &pRTCPContext->dwInitNumFreeRRCMStat,
 						 	 		   sizeof(SSRC_ENTRY),
									   &pRTCPContext->critSect);
		}

	// initialize the pseudo-random number generator, for later MD5 use
	RRCMsrand ((unsigned int)timeGetTime());

	// If initialation failed return all resourses allocated 
	if (dwStatus != RRCM_NoError) 
		deleteRTCP ();

	IN_OUT_STR ("RTCP: Exit initRTCP()\n");

	return (dwStatus); 		
	}

                                                                              
                                                                              
/*----------------------------------------------------------------------------
 * Function   : deleteRTCP
 * Description: RTCP delete procedures. All RTCP sessions have been deleted 
 *				at this point, so just delete what's needed.
 * 
 * Input :      None.
 *
 * Return: 		FALSE	: OK.
 *         		TRUE  	: Error code. RTCP couldn't be initialized.
 ---------------------------------------------------------------------------*/
 DWORD deleteRTCP (void)
	{   
	IN_OUT_STR ("RTCP: Enter deleteRTCP()\n");

	ASSERT (pRTCPContext);

	// protect everything from the top 
	EnterCriticalSection (&pRTCPContext->critSect);

	// delete all heaps 
	if (pRTCPContext->hHeapRRCMStat) 
		{
		if (HeapDestroy (pRTCPContext->hHeapRRCMStat) == FALSE)
			{
			RRCM_DBG_MSG ("RTCP: ERROR - HeapDestroy", GetLastError(),
						  __FILE__, __LINE__, DBG_ERROR);
			}
		}

	if (pRTCPContext->hHeapRTCPSes) 
		{
		if (HeapDestroy (pRTCPContext->hHeapRTCPSes) == FALSE)
			{
			RRCM_DBG_MSG ("RTCP: ERROR - HeapDestroy", GetLastError(),
						  __FILE__, __LINE__, DBG_ERROR);
			}
		}

	// protect everything from the top 
	LeaveCriticalSection (&pRTCPContext->critSect);

	DeleteCriticalSection (&pRTCPContext->critSect);

	// Clean up our context resources 
	GlobalFree (pRTCPContext);

	IN_OUT_STR ("RTCP: Exit deleteRTCP()\n");
	return (TRUE);
	}


// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rrcminc\rrcmprot.h ===
/*
 * Filename: RRCMPROT.H
 *
 * Functions prototyping.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with
 * Intel Corporation and may not be copied nor disclosed except in
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation.
 *--------------------------------------------------------------------------*/

#ifndef _RRCMPROT_H_
#define _RRCMPROT_H_

#include "rrcm.h"
#include "rtp.h"

#if defined(__cplusplus)
extern "C"
{
#endif  // (__cplusplus)


/*
	RRCMqueu.CPP
*/
extern DWORD allocateLinkedList (PLINK_LIST,
								 HANDLE,
								 PDWORD,
								 DWORD,
								 CRITICAL_SECTION *);
extern void addToHeadOfList (PLINK_LIST,
							 PLINK_LIST,
							 CRITICAL_SECTION *);
extern void addToTailOfList (PLINK_LIST,
							 PLINK_LIST,
							 CRITICAL_SECTION *);
extern PLINK_LIST removePcktFromTail (PLINK_LIST,
									  CRITICAL_SECTION *);
extern PLINK_LIST removePcktFromHead (PLINK_LIST,
									  CRITICAL_SECTION *);


/*
	RTCPINIT.CPP
*/
extern DWORD initRTCP(void);
extern DWORD deleteRTCP(void);

/*
	RTCPSESS.CPP
*/
extern DWORD allocateRTCPContextHeaps (PRTCP_CONTEXT);
extern DWORD allocateRTCPSessionHeaps (PRTCP_SESSION *);
extern DWORD allocateRTCPsessionResources (PRTCP_SESSION *,
										   PSSRC_ENTRY *);
extern PRTCP_SESSION CreateRTCPSession (SOCKET,
										SOCKET,
										LPVOID,
										DWORD,
										PSDES_DATA,
										DWORD,
										PENCRYPT_INFO,
										DWORD,
										PRRCM_EVENT_CALLBACK,
										DWORD_PTR,
										DWORD,
										DWORD,
										PDWORD);
extern DWORD deleteRTCPSession (SOCKET,
								PCHAR);
extern DWORD buildSDESinfo (PSSRC_ENTRY,
						    PSDES_DATA);
extern DWORD frequencyToPckt (DWORD);
extern DWORD CreateRTCPthread (void);
extern void terminateRtcpThread (void);
extern DWORD RTCPflushIO (PSSRC_ENTRY);
extern DWORD flushIO (PSSRC_ENTRY);
extern void CALLBACK RTCPflushCallback (DWORD,
           			  					DWORD,
           			  					LPWSAOVERLAPPED,
           			  					DWORD);


/*
	RTCPSSRC.CPP
*/
extern PSSRC_ENTRY getOneSSRCentry (PLINK_LIST,
								    HANDLE,
									PDWORD,
									CRITICAL_SECTION *);
extern DWORD getSSRC (LINK_LIST,
					  LINK_LIST);
extern DWORD isSSRCunique (PSSRC_ENTRY,
						   PDWORD);
extern PSSRC_ENTRY createSSRCEntry (DWORD,
								    PRTCP_SESSION,
									PSOCKADDR,
									DWORD,
									DWORD);
extern DWORD RRCMChkCollisionTable (PSOCKADDR pFrom,
 							  		UINT fromlen,
									PSSRC_ENTRY);
extern DWORD RRCMAddEntryToCollisionTable (PSOCKADDR pFrom,
 							  			UINT fromlen,
										PSSRC_ENTRY);
extern void RRCMTimeOutCollisionTable (PRTCP_SESSION);
extern DWORD deleteSSRCEntry (DWORD,
							  PRTCP_SESSION);
extern void	 deleteSSRClist (PRTCP_SESSION,
							 PLINK_LIST,
							 PRTCP_CONTEXT);
void clearSSRCEntry (PSSRC_ENTRY);

/*
	RTCPMEM.CPP
*/
extern DWORD allocateRTCPBfrList (PLINK_LIST,
								  HANDLE,
								  HANDLE,
								  PDWORD,
								  DWORD,
								  CRITICAL_SECTION *);


/*
	RTCPTIME.CPP
*/
extern DWORD RTCPxmitInterval (DWORD,
							   DWORD,
							   DWORD,
							   DWORD,
							   DWORD,
							   int *,
							   DWORD);


/*
	RTCPRECV.CPP
*/
extern DWORD RTCPrcvInit (PSSRC_ENTRY);
extern void CALLBACK RTCPrcvCallback (DWORD,
									  DWORD,
           				  	  		  LPWSAOVERLAPPED,
									  DWORD);
extern DWORD parseRTCPsr (SOCKET,
						  RTCP_T *,
						  PRTCP_SESSION,
						  PRTCP_BFR_LIST);
extern DWORD parseRTCPrr (SOCKET,
						  RTCP_RR_T *,
						  PRTCP_SESSION,
						  PRTCP_BFR_LIST,
						  DWORD);
extern PCHAR parseRTCPsdes (SOCKET,
							PCHAR,
							PRTCP_SESSION,
							PRTCP_BFR_LIST);
extern DWORD parseRTCPbye (SOCKET,
						   DWORD,
						   PRTCP_SESSION,
						   PRTCP_BFR_LIST);
extern DWORD ownLoopback (SOCKET,
						  DWORD,
						  PRTCP_SESSION);
extern DWORD updateRRfeedback (SOCKET,
							   DWORD,
							   DWORD,
							   RTCP_RR_T *,
							   PSSRC_ENTRY);
extern void RTCPpostRecvBfr (PSSRC_ENTRY,
							 PRTCP_BFR_LIST);


/*
	RTCPSEND.CPP
*/
extern void CALLBACK RTCPxmtCallback (DWORD,
									  DWORD,
           			  		   		  LPWSAOVERLAPPED,
									  DWORD);
extern BOOL FormatRTCPReport (PRTCP_SESSION,
										PSSRC_ENTRY,
										DWORD);
extern DWORD getSSRCpcktLoss (PSSRC_ENTRY,
							  DWORD);
extern DWORD *RTCPbuildSDES (RTCP_COMMON_T *,
							 PSSRC_ENTRY,
							 SOCKET,
							 char *,
							 PSDES_DATA);
extern void RTCPcheckSDEStoXmit (PSSRC_ENTRY,
								 PSDES_DATA);
extern void	RTCPbuildSenderRpt (PSSRC_ENTRY,
								RTCP_COMMON_T *,
								SENDER_RPT	**,
								SOCKET);
extern  DWORD usec2ntp (DWORD);
extern	DWORD usec2ntpFrac (long);
extern void	RTCPbuildReceiverRpt (PSSRC_ENTRY,
								  RTCP_RR_T	*,
								  SOCKET);
extern void RTCPsendBYE (PSSRC_ENTRY,
						 PCHAR);
extern DWORD getDLSR (PSSRC_ENTRY);

#ifdef DYNAMIC_RTCP_BW
extern DWORD updateRtpXmtBW (PSSRC_ENTRY);
extern DWORD updateRtpRcvBW (PSSRC_ENTRY);
#endif


/*
	RTPINIT.CPP
*/
extern DWORD deleteRTP (HINSTANCE);
extern void addBuf (void);
extern DWORD initRTP (HINSTANCE);
extern void RRCMreadRegistry (PRTP_CONTEXT);
extern void RRCMgetRegistryValue (HKEY,
							      LPTSTR,
								  PDWORD,
								  DWORD,
								  DWORD);
extern DWORD RRCMgetDynamicLink (void);
extern DWORD deleteRTPSession(PRTP_CONTEXT,
							  PRTP_SESSION);


/*
	RTPSEND.CPP
*/
extern void CALLBACK RTPTransmitCallback (DWORD,
										  DWORD,
										  LPWSAOVERLAPPED,
										  DWORD);
extern DWORD CALLBACK  saveWinsockContext(LPWSAOVERLAPPED,
					   					  LPWSAOVERLAPPED_COMPLETION_ROUTINE,
						   				  PRTP_SESSION,
						   				  SOCKET);
#if 0
extern void updateNtpRtpTimeStampOffset (RTP_HDR_T *,
										 PSSRC_ENTRY);
#endif



/*
	RTPRECV.CPP
*/
extern DWORD  RTPReceiveCheck (
						HANDLE hRTPSession,
						SOCKET RTPsocket,
						char *pPacket,
           				DWORD cbTransferred,
           				PSOCKADDR pFrom,
           				UINT fromlen
           				 );
extern BOOL validateRTPHeader(RTP_HDR_T *);					


/*
	RTP_STAT.CPP
*/
extern DWORD calculateJitter (RTP_HDR_T *,
							  PSSRC_ENTRY);
extern DWORD updateRTPStats (RTP_HDR_T *,
							 PSSRC_ENTRY,
							 DWORD);

/*
	RTPMISC.CPP
*/
extern DWORD saveNetworkAddress (PSSRC_ENTRY,
								 PSOCKADDR,
								 int);
extern PSSRC_ENTRY searchforSSRCatHead(PSSRC_ENTRY,
									   DWORD);
extern PSSRC_ENTRY searchforSSRCatTail(PSSRC_ENTRY,
									   DWORD);
extern PSSRC_ENTRY searchForMySSRC(PSSRC_ENTRY,
								   SOCKET);

#ifdef ENABLE_ISDM2
extern void registerSessionToISDM (PSSRC_ENTRY,
								   PRTCP_SESSION,
								   PISDM2);
extern void	updateISDMstat (PSSRC_ENTRY,
							PISDM2,
							DWORD,
							BOOL);
#endif
extern void RRCMdebugMsg (PCHAR,
						  DWORD,
						  PCHAR,
						  DWORD,
						  DWORD);
extern void RRCMnotification (RRCM_EVENT_T,
							  PSSRC_ENTRY,
							  DWORD,
							  DWORD);




/*
	RRCMCRT.CPP
*/
extern void RRCMsrand (unsigned int);
extern int	RRCMrand (void);
extern char *RRCMitoa (int, char *, int);
extern char *RRCMultoa (unsigned long, char *, int);
extern char *RRCMltoa (long, char *, int);

/*
	RTCPTHRD.CPP
*/
extern void RTCPThread (PRTCP_CONTEXT);
extern PSSRC_ENTRY SSRCTimeoutCheck (PRTCP_SESSION,
									 DWORD);


#if defined(__cplusplus)
}
#endif  // (__cplusplus)


#endif /* ifndef _RRCMPROT_H_ */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtcp\rtcprecv.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTCPRECV.C
 * Product:     RTP/RTCP implementation
 * Description: Provides the RTCP receive network I/O.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with
 * Intel Corporation and may not be copied nor disclosed except in
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation.
 *--------------------------------------------------------------------------*/


#include "rrcm.h"


#define		MIN(a, b)	((a < b) ? a : b)


/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/
extern PRTCP_CONTEXT	pRTCPContext;
extern PRTP_CONTEXT		pRTPContext;
extern RRCM_WS			RRCMws;

#ifdef ENABLE_ISDM2
extern ISDM2			Isdm2;
#endif

#ifdef _DEBUG
extern char		debug_string[];
#endif

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
//INTEROP
extern LPInteropLogger RTPLogger;
#endif



/*----------------------------------------------------------------------------
 * Function   : RTCPrcvInit
 * Description: RTCP receive initialisation.
 *
 * Input :      pRTCP	: Pointer to the RTCP session information
 *
 * Return: 		TRUE/FALSE
 ---------------------------------------------------------------------------*/
DWORD RTCPrcvInit (PSSRC_ENTRY pSSRC)
	{
	PRTCP_BFR_LIST	pRcvStruct;
	PRTCP_SESSION	pRTCP;
	int				dwStatus;
	int				dwError;
	int				errorCnt = 0;
	int				bfrErrorCnt = 0;
	DWORD			idx;
	int				wsockSuccess = FALSE;

	// save a pointer to the corresponding RTCP session
	pRTCP = pSSRC->pRTCPses;

	// Post receive buffers for WS-2. As these buffers are posted per receive
	// thread, few of them should be plenty enough for RTCP.
	for (idx = 0; idx < pRTPContext->registry.NumRTCPPostedBfr; idx++)
		{
		// get a free RTCP buffer for a receive operation
		pRcvStruct =
			(PRTCP_BFR_LIST)removePcktFromTail(&pRTCP->RTCPrcvBfrList,
											   &pRTCP->critSect);

		// check buffer
		if (pRcvStruct == NULL)
			{
			RRCM_DBG_MSG ("RTCP: ERROR - Rcv Bfr Allocation Error", 0,
						  __FILE__, __LINE__, DBG_ERROR);

			// make sure we have at least one buffer
			ASSERT (pRcvStruct);
			break;
			}

		// SSRC entry address of our own session
		pRcvStruct->pSSRC = pSSRC;

		// received address length reset by the receive routine
		pRcvStruct->addrLen = sizeof(SOCKADDR);

		// use hEvent to recover the buffer's address
		pRcvStruct->overlapped.hEvent = (WSAEVENT)pRcvStruct;

		// post the receive buffer for this thread
		dwStatus = RRCMws.recvFrom (pSSRC->RTCPsd,
			   			  			&pRcvStruct->bfr,
				              		pRcvStruct->dwBufferCount,
				   			  		&pRcvStruct->dwNumBytesXfr,
				   			  		&pRcvStruct->dwFlags,
				   			  		(PSOCKADDR)pRcvStruct->addr,
				    		  		&pRcvStruct->addrLen,
				   			  		(LPWSAOVERLAPPED)&pRcvStruct->overlapped,
				   			  		RTCPrcvCallback);

		// Check Winsock status
		if (dwStatus != 0)
			{
			// error, the receive request won't proceed
			dwError = GetLastError();
			if ((dwError != WSA_IO_PENDING) && (dwError != WSAEMSGSIZE))
				{
				RRCM_DBG_MSG ("RTCP: ERROR WSARecvFrom()", GetLastError(),
							  __FILE__, __LINE__, DBG_ERROR);

				// notify application if interested
				RRCMnotification (RRCM_RTCP_WS_RCV_ERROR, pSSRC,
								  pSSRC->SSRC, dwError);

				// Return the buffer to the free queue
				addToHeadOfList (&pRTCP->RTCPrcvBfrList,
						 	  	 (PLINK_LIST)pRcvStruct,
								 &pRTCP->critSect);
				}
			else
				{
				wsockSuccess = TRUE;

				// increment number of I/O pending
				InterlockedIncrement ((long *)&pRTCP->dwNumRcvIoPending);
				}
			}
		else
			{
			wsockSuccess = TRUE;

			// increment number of I/O pending
			InterlockedIncrement ((long *)&pRTCP->dwNumRcvIoPending);
			}
		}

	// make sure we posted at least some buffers
	if (wsockSuccess == FALSE)
		{
		// release all resources and kill the receive thread
#ifdef _DEBUG
		wsprintf(debug_string,
			"RTCP: ERROR - Exit RCV init %s: Line:%d", __FILE__, __LINE__);
		RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif
		return(FALSE);
		}
	return (TRUE);
	}



/*----------------------------------------------------------------------------
 * Function   : RTCPrcvCallback
 * Description: Receive callback routine from Winsock2.
 *
 * Input :	dwError:		I/O completion status
 *			cbTransferred:	Number of bytes received
 *			lpOverlapped:	-> to overlapped structure
 *			dwFlags:		Flags
 *
 *
 * Return: None
 ---------------------------------------------------------------------------*/
void CALLBACK RTCPrcvCallback (DWORD dwError,
           			  		   DWORD cbTransferred,
           			  		   LPWSAOVERLAPPED lpOverlapped,
           			  		   DWORD dwFlags)
	{
	PRTCP_BFR_LIST	pRcvStruct;
	RTCP_T 			*pRTCPpckt;
	PRTCP_SESSION	pRTCPses;
	PSSRC_ENTRY		pSSRC;
	PAPP_RTCP_BFR	pAppBfr;
	DWORD			dwStatus = 0;
	DWORD			i;
	DWORD			pcktLen;
	DWORD			dwSSRC;
	USHORT			wHost;
	SOCKET			RTCPsd;
	unsigned char	*pEndPckt;
	unsigned char	*pEndBlock;
	int				tmpSize;
#if IO_CHECK
	DWORD			initTime = timeGetTime();
#endif

	IN_OUT_STR ("RTCP: Enter RTCPrcvCallback\n");

	// hEvent in the WSAOVERLAPPED struct points to our buffer's information
	pRcvStruct = (PRTCP_BFR_LIST)lpOverlapped->hEvent;

	// SSRC entry pointer
	pSSRC = pRcvStruct->pSSRC;

	// check Winsock callback error status
	if (dwError)
		{
		// 65534 is probably a temporary bug in WS2
		if ((dwError == 65534) || (dwError == WSA_OPERATION_ABORTED))
			{
			RRCM_DBG_MSG ("RTCP: I/O Aborted", dwError,
						  __FILE__, __LINE__, DBG_NOTIFY);
			}
		else
			{
			RRCM_DBG_MSG ("RTCP: ERROR - Rcv Callback", dwError,
						  __FILE__, __LINE__, DBG_ERROR);
			}

		// invalid RTCP packet header, re-queue the buffer
		RTCPpostRecvBfr (pSSRC, pRcvStruct);

		IN_OUT_STR ("RTCP: Exit RTCPrcvCallback\n");
		return;
		}

	// read the RTCP packet
    pRTCPpckt = (RTCP_T *)pRcvStruct->bfr.buf;

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
   //INTEROP
	if (RTPLogger)
		{
		InteropOutput (RTPLogger,
				       (BYTE FAR*)(pRcvStruct->bfr.buf),
					   cbTransferred,
					   RTPLOG_RECEIVED_PDU | RTCP_PDU);
		}
#endif

	// get the RTCP session ptr
	pRTCPses = pSSRC->pRTCPses;

	// Check RTCP header validity of first packet in report.
	// Filter out junk. First thing in RTCP packet must be
	// either SR, RR or BYE
	if ((pRTCPpckt->common.type != RTP_TYPE) ||
		((pRTCPpckt->common.pt != RTCP_SR) &&
		 (pRTCPpckt->common.pt != RTCP_RR) &&
		 (pRTCPpckt->common.pt != RTCP_BYE)))
		{
#ifdef MONITOR_STATS
		pRTCPses->dwNumRTCPhdrErr++;
#endif

		// invalid RTCP packet header, re-queue the buffer
		RTCPpostRecvBfr (pSSRC, pRcvStruct);

#if 0	// we could have shutdown so this code can fault
		if (pRTCPpckt->common.pt == FLUSH_RTP_PAYLOAD_TYPE)
			{
			RRCM_DBG_MSG ("RTCP: Flushing RCV I/O", 0, NULL, 0, DBG_NOTIFY);
			}
		else
			{
			wsprintf(debug_string,
				"RTCP: ERROR - Pckt Header Error. Type:%d / Payload:%d",
				pRTCPpckt->common.type, pRTCPpckt->common.pt);
			RRCM_DBG_MSG (debug_string, 0, __FILE__, __LINE__, DBG_TRACE);
			}
#endif

		IN_OUT_STR ("RTCP: Exit RTCPrcvCallback\n");
		return;
		}

	// get the socket descriptor
	RTCPsd = pSSRC->RTCPsd;

	// get the sender's SSRC
	RRCMws.ntohl (RTCPsd, pRTCPpckt->r.sr.ssrc, &dwSSRC);

	// skip our own loopback if we receive it
	if (ownLoopback (RTCPsd, dwSSRC, pRTCPses))
		{
		RTCPpostRecvBfr (pSSRC, pRcvStruct);
		return;
		}

	// at this point we think the RTCP packet's valid. Get the sender's
	//  address, if not already known
	if (!(pRTCPses->dwSessionStatus & RTCP_DEST_LEARNED))
		{
		pRTCPses->dwSessionStatus |= RTCP_DEST_LEARNED;
		pRTCPses->toLen = pRcvStruct->addrLen;
		memcpy (&pRTCPses->toBfr, &pRcvStruct->addr, pRcvStruct->addrLen);

#ifdef ENABLE_ISDM2
		// register our Xmt SSRC - Rcvd one will be found later
		if (Isdm2.hISDMdll)
			registerSessionToISDM (pSSRC, pRTCPses, &Isdm2);
#endif
		}
	
	// Update our RTCP average packet size estimator
 	EnterCriticalSection (&pRTCPses->critSect);
	tmpSize = (cbTransferred + NTWRK_HDR_SIZE) - pRTCPses->avgRTCPpktSizeRcvd;

#ifdef ENABLE_FLOATING_POINT
	// As per RFC
	tmpSize = (int)(tmpSize * RTCP_SIZE_GAIN);
#else
	// Need to remove floating point operation
	tmpSize = tmpSize / 16;
#endif

	pRTCPses->avgRTCPpktSizeRcvd += tmpSize;
	LeaveCriticalSection (&pRTCPses->critSect);

	// check if the raw RTCP packet needs to be copied into an application
	//  buffer - Mainly used by ActiveMovieRTP to propagate the reports up
	//  the filter graph to the Receive Payload Handler
	pAppBfr = (PAPP_RTCP_BFR)removePcktFromHead (&(pRTCPses->appRtcpBfrList),
												 &pRTCPses->critSect);
	if (pAppBfr && !(pAppBfr->dwBfrStatus & RTCP_SR_ONLY))
		{
		// copy the full RTCP packet
		memcpy (pAppBfr->bfr,
				pRTCPpckt,
				MIN(pAppBfr->dwBfrLen, cbTransferred));

		// number of bytes received
		pAppBfr->dwBytesRcvd = MIN(pAppBfr->dwBfrLen, cbTransferred);

		// set the event associated with this buffer
		SetEvent (pAppBfr->hBfrEvent);
		}

	// end of the received packet
	pEndPckt = (unsigned char *)pRTCPpckt + cbTransferred;

	while ((unsigned char *)pRTCPpckt < pEndPckt)
		{
		// get the length
		dwStatus = RRCMws.ntohs (RTCPsd, pRTCPpckt->common.length, &wHost);
		if (dwStatus)
			{
			RRCM_DBG_MSG ("RTCP: ERROR - WSANtohs()", GetLastError(),
						  __FILE__, __LINE__, DBG_ERROR);
			}

		// get this report block length
		pcktLen   = (wHost + 1) << 2;
		pEndBlock = (unsigned char *)pRTCPpckt + pcktLen;

		// sanity check
		if (pEndBlock > pEndPckt)
			{
			RRCM_DBG_MSG ("RTCP: ERROR - Rcv packet length error", 0,
						  __FILE__, __LINE__, DBG_ERROR);

#ifdef MONITOR_STATS
			pRTCPses->dwNumRTCPlenErr++;
#endif
			break;
			}

		// make sure the version is correct for all packets
		if (pRTCPpckt->common.type != RTP_TYPE)
			{
#ifdef MONITOR_STATS
			pRTCPses->dwNumRTCPhdrErr++;
#endif
			// invalid RTCP packet header, packet will be re-queued
			break;
			}

		switch (pRTCPpckt->common.pt)
			{
			case RTCP_SR:
				// check if only the SR needs to be propagated up to the app
				if (pAppBfr && (pAppBfr->dwBfrStatus & RTCP_SR_ONLY))
					{
					// copy the RTCP SR
					memcpy (pAppBfr->bfr,
							pRTCPpckt,
							MIN(pAppBfr->dwBfrLen, 24));

					// number of bytes received
					pAppBfr->dwBytesRcvd = MIN(pAppBfr->dwBfrLen, 24);

					// set the event associated with this buffer
					SetEvent (pAppBfr->hBfrEvent);
					}

				// get the sender's SSRC
				RRCMws.ntohl (RTCPsd, pRTCPpckt->r.sr.ssrc, &dwSSRC);

				// parse the sender report
				parseRTCPsr (RTCPsd, pRTCPpckt, pRTCPses, pRcvStruct);

				// parse additional receiver reports if any
				for (i = 0; i < pRTCPpckt->common.count; i++)
					{
					parseRTCPrr (RTCPsd, &pRTCPpckt->r.sr.rr[i],
								 pRTCPses, pRcvStruct,
								 dwSSRC);
					}

				// notify application if interested
				RRCMnotification (RRCM_RECV_RTCP_SNDR_REPORT_EVENT, pSSRC,
								  dwSSRC, 0);
				break;

			case RTCP_RR:
				// get the sender's SSRC
				RRCMws.ntohl (RTCPsd, pRTCPpckt->r.rr.ssrc, &dwSSRC);

				// parse receiver reports
				for (i = 0; i < pRTCPpckt->common.count; i++)
					{
					parseRTCPrr (RTCPsd, &pRTCPpckt->r.rr.rr[i],
								 pRTCPses, pRcvStruct,
								 dwSSRC);
					}

				// notify application if interested
				RRCMnotification (RRCM_RECV_RTCP_RECV_REPORT_EVENT, pSSRC,
								  dwSSRC, 0);
				break;

			case RTCP_SDES:
				{
				PCHAR	buf;

				buf = (PCHAR)&pRTCPpckt->r.sdes;

				for (i = 0; i < pRTCPpckt->common.count; i++)
					{
					buf = parseRTCPsdes (RTCPsd, buf, pRTCPses, pRcvStruct);
					if (buf == NULL)
						break;
					}
				}
				break;

			case RTCP_BYE:
				for (i = 0; i < pRTCPpckt->common.count; i++)
      				parseRTCPbye (RTCPsd, pRTCPpckt->r.bye.src[i],
								  pRTCPses, pRcvStruct);
				break;

			default:
				break;
			}

		// go to next report block
    	pRTCPpckt = (RTCP_T *)(pEndBlock);
		}

	// post back the buffer to WS-2
	RTCPpostRecvBfr (pSSRC, pRcvStruct);

#if IO_CHECK
	wsprintf(debug_string,
		"RTCP: Leaving Rcv Callback after: %ld msec\n",
		 timeGetTime() - initTime);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

	IN_OUT_STR ("RTCP: Exit RTCPrcvCallback\n");
	}



/*----------------------------------------------------------------------------
 * Function   : parseRTCPsr
 * Description: Parse an RTCP sender reports and update the corresponding
 *				statistics.
 *
 * Input :      sd:			RTCP Socket descriptor
 *				pRTCPpckt:	-> to the RTCP packet
 *				pRTCPses:	-> to the RTCP session information
 *				pRcvStruct:	-> to the receive structure information
 *
 * Return: 		OK: RRCM_NoError
 *				!0:	Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
 DWORD parseRTCPsr (SOCKET sd,
					RTCP_T *pRTCPpckt,
					PRTCP_SESSION pRTCPses,
 					PRTCP_BFR_LIST pRcvStruct)
 	{
	PSSRC_ENTRY	pSSRC;
	DWORD		dwSSRC;

	IN_OUT_STR ("RTCP: Enter parseRTCPsr\n");

	// get the sender's SSRC
	RRCMws.ntohl (sd, pRTCPpckt->r.sr.ssrc, &dwSSRC);

#ifdef _DEBUG
	wsprintf(debug_string, "RTCP: Receive SR from SSRC:x%lX", dwSSRC);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

	// look for the SSRC entry in the list for this RTCP session
	pSSRC = searchforSSRCatTail((PSSRC_ENTRY)pRTCPses->RcvSSRCList.prev,
								dwSSRC);
	if (pSSRC == NULL)
		{
		// new SSRC, create an entry in this RTCP session
		pSSRC = createSSRCEntry(dwSSRC,
							 	pRTCPses,
								(PSOCKADDR)pRcvStruct->addr,
								(DWORD)pRcvStruct->addrLen,
								FALSE);

		if (pSSRC == NULL)
			{
			// cannot create a new entry, out of resources
			RRCM_DBG_MSG ("RTCP: ERROR - Resource allocation", 0,
						  __FILE__, __LINE__, DBG_ERROR);

			IN_OUT_STR ("RTCP: Exit parseRTCPsr\n");

			return (RRCMError_RTCPResources);
			}

		// notify application if it desired so
		RRCMnotification (RRCM_NEW_SOURCE_EVENT, pSSRC, dwSSRC,
						  UNKNOWN_PAYLOAD_TYPE);
		}

	// get the RTP timestamp
	RRCMws.ntohl (sd, pRTCPpckt->r.sr.rtp_ts, &pSSRC->xmtInfo.dwRTPts);

	// number of packets send
	RRCMws.ntohl (sd, pRTCPpckt->r.sr.psent, &pSSRC->xmtInfo.dwNumPcktSent);

	// number of bytes sent
	RRCMws.ntohl (sd, pRTCPpckt->r.sr.osent, &pSSRC->xmtInfo.dwNumBytesSent);

	// get the NTP most significant word
	RRCMws.ntohl (sd, pRTCPpckt->r.sr.ntp_sec, &pSSRC->xmtInfo.dwNTPmsw);

	// get the NTP least significant word
	RRCMws.ntohl (sd, pRTCPpckt->r.sr.ntp_frac, &pSSRC->xmtInfo.dwNTPlsw);

	// last SR timestamp (middle 32 bits of the NTP timestamp)
	pSSRC->xmtInfo.dwLastSR = ((pSSRC->xmtInfo.dwNTPmsw & 0x0000FFFF) << 16);
	pSSRC->xmtInfo.dwLastSR |= ((pSSRC->xmtInfo.dwNTPlsw & 0xFFFF0000) >> 16);
	
	// last time this SSRC's heard
	pSSRC->dwLastReportRcvdTime = pSSRC->xmtInfo.dwLastSRLocalTime =
		timeGetTime();

	// get the source address information
	if (!(pSSRC->dwSSRCStatus & NETWK_ADDR_UPDATED))
		{
		saveNetworkAddress(pSSRC,
						   (PSOCKADDR)pRcvStruct->addr,
						   pRcvStruct->addrLen);
		}

	// increment the number of report received from this SSRC
	InterlockedIncrement ((long *)&pSSRC->dwNumRptRcvd);

#ifdef ENABLE_ISDM2
	// update ISDM
	if (Isdm2.hISDMdll && pRTCPses->hSessKey)
		{
		if (pSSRC->hISDM)
			updateISDMstat (pSSRC, &Isdm2, RECVR, FALSE);
		else
			registerSessionToISDM (pSSRC, pRTCPses, &Isdm2);
		}
#endif

	IN_OUT_STR ("RTCP: Exit parseRTCPsr\n");

	return (RRCM_NoError);
	}



/*----------------------------------------------------------------------------
 * Function   : parseRTCPrr
 * Description: Parse an RTCP receiver reports and update the corresponding
 *				statistics.
 *
 * Input :      sd:			RTCP socket descriptor
 *				pRR:		-> to receiver report buffer
 *				pRTCPses:	-> to the RTCP session information
 *				pRcvStruct:	-> to the receive structure information
 *				senderSSRC:	Sender's SSRC
 *
 * Return: 		OK: RRCM_NoError
 *				!0:	Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
 DWORD parseRTCPrr (SOCKET sd,
					RTCP_RR_T *pRR,
 					PRTCP_SESSION pRTCPses,
					PRTCP_BFR_LIST pRcvStruct,
					DWORD senderSSRC)
 	{
	PSSRC_ENTRY	pSSRC;
	DWORD		dwSSRC;
	DWORD		dwGetFeedback = FALSE;

	IN_OUT_STR ("RTCP: Enter parseRTCPrr\n");

#ifdef _DEBUG
	wsprintf(debug_string,
		"RTCP: Receive RR from sender SSRC:x%lX", senderSSRC);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

	// get the receiver report SSRC
	RRCMws.ntohl (sd, pRR->ssrc, &dwSSRC);

#ifdef _DEBUG
	wsprintf(debug_string, "RTCP: RR for SSRC:x%lX", dwSSRC);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

	//
	// NOTE:
	// For now we just keep track of feedback information about ourselve. Later
	// the link list can be used to keep track about everybody feedback
	// information.
	//
	// Check to see if we're interested in this report, ie, does this SSRC report
	// information about one of our active sender.
	dwGetFeedback =
		searchforSSRCatTail((PSSRC_ENTRY)pRTCPses->XmtSSRCList.prev,
						    dwSSRC) != NULL;

	// look for the sender SSRC entry in the list for this RTCP session
	pSSRC =
		searchforSSRCatTail((PSSRC_ENTRY)pRTCPses->RcvSSRCList.prev,
							senderSSRC);
	if (pSSRC == NULL)
		{
		// new SSRC, create an entry in this RTCP session
		pSSRC = createSSRCEntry(senderSSRC,
							 	pRTCPses,
								(PSOCKADDR)pRcvStruct->addr,
								(DWORD)pRcvStruct->addrLen,
								FALSE);

		if (pSSRC == NULL)
			{
			// cannot create a new entry, out of resources
			RRCM_DBG_MSG ("RTCP: ERROR - Resource allocation", 0,
						  __FILE__, __LINE__, DBG_ERROR);

			IN_OUT_STR ("RTCP: Exit parseRTCPrr\n");
			return (RRCMError_RTCPResources);
			}

		// notify application if it desired so
		RRCMnotification (RRCM_NEW_SOURCE_EVENT, pSSRC, senderSSRC,
						  UNKNOWN_PAYLOAD_TYPE);
		}

	// update RR feedback information
	if (dwGetFeedback)
		updateRRfeedback (sd, senderSSRC, dwSSRC, pRR, pSSRC);

	// last time this SSRC's heard
	pSSRC->dwLastReportRcvdTime = timeGetTime();

	// get the source address information
	if (!(pSSRC->dwSSRCStatus & NETWK_ADDR_UPDATED))
		{
		saveNetworkAddress(pSSRC,
						   (PSOCKADDR)pRcvStruct->addr,
						   pRcvStruct->addrLen);
		}

	// increment the number of report received from this SSRC
	InterlockedIncrement ((long *)&pSSRC->dwNumRptRcvd);

#ifdef ENABLE_ISDM2
	// update ISDM
	if (Isdm2.hISDMdll && pRTCPses->hSessKey)
		{
		if (pSSRC->hISDM)
			updateISDMstat (pSSRC, &Isdm2, RECVR, TRUE);
		else
			registerSessionToISDM (pSSRC, pRTCPses, &Isdm2);
		}
#endif

	IN_OUT_STR ("RTCP: Exit parseRTCPrr\n");

	return (RRCM_NoError);
	}



/*----------------------------------------------------------------------------
 * Function   : parseRTCPsdes
 * Description: Parse an RTCP SDES packet
 *
 * Input :      sd:			RTCP socket descriptor
 *				bfr:		-> to SDES buffer
 *				pRTCPses:	-> to the RTCP session information
 *				pRcvStruct:	-> to the receive structure information
 *
 * Return: 		OK: RRCM_NoError
 *				!0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
 PCHAR parseRTCPsdes (SOCKET sd,
					  PCHAR bfr,
					  PRTCP_SESSION pRTCPses,
 					  PRTCP_BFR_LIST pRcvStruct)
	{
	DWORD				dwHost;
	DWORD 				ssrc = *(DWORD *)bfr;
	RTCP_SDES_ITEM_T 	*pSdes;
	PSSRC_ENTRY			pSSRC;

	IN_OUT_STR ("RTCP: Enter parseRTCPsdes\n");

	// get the SSRC
	RRCMws.ntohl (sd, ssrc, &dwHost);

#ifdef _DEBUG
	wsprintf(debug_string, "RTCP: Receive SDES from SSRC: x%lX", dwHost);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

	// look for the SSRC entry in the list for this RTCP session
	pSSRC = searchforSSRCatTail ((PSSRC_ENTRY)pRTCPses->RcvSSRCList.prev,
								 dwHost);
	if (pSSRC == NULL)
		{
#ifdef _DEBUG
		wsprintf(debug_string,
			 "RTCP: SDES and SSRC (x%lX) not found for session (Addr x%lX)",
			 dwHost, pRTCPses);
		RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

		// new SSRC, create an entry in this RTCP session
		pSSRC = createSSRCEntry(dwHost,
							 	pRTCPses,
								(PSOCKADDR)pRcvStruct->addr,
								(DWORD)pRcvStruct->addrLen,
								FALSE);

		if (pSSRC == NULL)
			{
			// cannot create a new entry, out of resources
			RRCM_DBG_MSG ("RTCP: ERROR - Resource allocation", 0,
						  __FILE__, __LINE__, DBG_ERROR);

			IN_OUT_STR ("RTCP: Exit parseRTCPsdes\n");

			return (NULL);
			}

		// notify application if it desired so
		RRCMnotification (RRCM_NEW_SOURCE_EVENT, pSSRC, dwHost,
						  UNKNOWN_PAYLOAD_TYPE);
		}

	// read the SDES chunk
	pSdes = (RTCP_SDES_ITEM_T *)(bfr + sizeof(DWORD));

	// go through until a 'type = 0' is found
	for (; pSdes->dwSdesType;
		 pSdes = (RTCP_SDES_ITEM_T *)((char *)pSdes + pSdes->dwSdesLength + 2))
		{
		switch (pSdes->dwSdesType)
			{
			case RTCP_SDES_CNAME:
				if (pSSRC->cnameInfo.dwSdesLength == 0)
					{
					pSSRC->cnameInfo.dwSdesLength = pSdes->dwSdesLength;

					// get the Cname
					memcpy (pSSRC->cnameInfo.sdesBfr, pSdes->sdesData,
							min (pSdes->dwSdesLength, MAX_SDES_LEN-1));
					}
				else
					{
					// check to see for a loop/collision of the SSRC
					if (memcmp (pSdes->sdesData, pSSRC->cnameInfo.sdesBfr,
								min (pSdes->dwSdesLength, MAX_SDES_LEN-1)) != 0)
						{
						// loop/collision of a third-party detected
						pSSRC->dwSSRCStatus |= THIRD_PARTY_COLLISION;

						// notify application if interested
						RRCMnotification (RRCM_REMOTE_COLLISION_EVENT, pSSRC,
										  pSSRC->SSRC, 0);

						// RTP & RTCP packet from this SSRC will be rejected
						//  until the senders resolve the collision

						IN_OUT_STR ("RTCP: Exit parseRTCPsdes\n");

						return NULL;
						}
					}

				break;

			case RTCP_SDES_NAME:
				// the name can change, not like the Cname, so update it
				// every time.
				pSSRC->nameInfo.dwSdesLength = pSdes->dwSdesLength;

				// get the name
				memcpy (pSSRC->nameInfo.sdesBfr, pSdes->sdesData,
						min (pSdes->dwSdesLength, MAX_SDES_LEN-1));
				break;

			default:
				break;
			}
		}

	// last time this SSRC's heard
	pSSRC->dwLastReportRcvdTime = timeGetTime();

	// get the source address information
	if (!(pSSRC->dwSSRCStatus & NETWK_ADDR_UPDATED))
		{
		saveNetworkAddress(pSSRC,
						   (PSOCKADDR)pRcvStruct->addr,
						   pRcvStruct->addrLen);
		}

	// adjust pointer
	bfr = (char *)pSdes;

	IN_OUT_STR ("RTCP: Exit parseRTCPsdes\n");

	// go the next 32 bits boundary
	return bfr + ((4 - ((LONG_PTR)bfr & 0x3)) & 0x3);
	}




/*----------------------------------------------------------------------------
 * Function   : parseRTCPbye
 * Description: Parse an RTCP BYE packet
 *
 * Input :      sd:			RTCP socket descriptor
 *				ssrc:		SSRC
 *				pRTCPses:	-> to the RTCP session information
 *				pRcvStruct:	-> to the receive structure
 *
 * Return: 		OK: RRCM_NoError
 *				!0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
 DWORD parseRTCPbye (SOCKET sd,
					 DWORD ssrc,
					 PRTCP_SESSION pRTCPses,
					 PRTCP_BFR_LIST pRcvStruct)
	{
	DWORD		dwStatus;
	DWORD		dwHost;
	PSSRC_ENTRY	pSSRC;

	IN_OUT_STR ("RTCP: Enter parseRTCPbye\n");

	RRCMws.ntohl (sd, ssrc, &dwHost);

#ifdef _DEBUG
	wsprintf(debug_string, "RTCP: BYE from SSRC: x%lX", dwHost);
	RRCM_DBG_MSG (debug_string, 0, NULL, 0, DBG_TRACE);
#endif

	// find the SSRC entry
	pSSRC = searchforSSRCatTail((PSSRC_ENTRY)pRTCPses->RcvSSRCList.prev,
								dwHost);
	if (pSSRC == NULL)
		{
#ifdef _DEBUG
		wsprintf(debug_string,
			 "RTCP: SSRC: x%lX not found in session: x%lX",
			  dwHost, pRTCPses);
		RRCM_DBG_MSG (debug_string, 0, __FILE__, __LINE__, DBG_TRACE);

		IN_OUT_STR ("RTCP: Exit parseRTCPbye\n");
#endif
		return (RRCM_NoError);
		}

	// make sure the BYE is coming from the expected source and not intruder
	if ((pRcvStruct->addrLen != pSSRC->fromLen) ||
#if 0
// There is a bug NT's Winsock2 implememtation. The unused bytes of
// SOCKADDR are not reset to 0 as they should be. Work fine on W95
// Temporarily just check the first 8 bytes, i.e. address family, port
// and IP address.
		(memcmp (&pRcvStruct->addr, &pSSRC->from, pSSRC->fromLen)))
#else
		(memcmp (&pRcvStruct->addr, &pSSRC->from, 8)))
#endif
		return (RRCM_NoError);

	// notify application if interested
	RRCMnotification (RRCM_BYE_EVENT, pSSRC, dwHost, 0);

	// delete this SSRC from the list
	dwStatus = deleteSSRCEntry (dwHost, pRTCPses);
#ifdef _DEBUG
	if (dwStatus == FALSE)
		{
		wsprintf(debug_string,
			 "RTCP: SSRC: x%lX not found in session: x%lX",
			  dwHost, pRTCPses);
		RRCM_DBG_MSG (debug_string, 0, __FILE__, __LINE__, DBG_TRACE);
		}
#endif

	IN_OUT_STR ("RTCP: Exit parseRTCPbye\n");
	return (RRCM_NoError);
	}



/*----------------------------------------------------------------------------
 * Function   : ownLoopback
 * Description: Determine if we receive our own loopback. We don't want to
 *				create an entry for ourselve, as we're already in the list.
 *
 * Input :      sd:			RTCP socket descriptor
 *				ssrc:		SSRC
 *				pRTCPses:	-> to the RTCP session's information
 *
 * Return: 		TRUE:	Our loopback
 *				FALSE:	No loopback
 ---------------------------------------------------------------------------*/
 DWORD ownLoopback (SOCKET sd,
					DWORD ssrc,
					PRTCP_SESSION pRTCPses)
	{
	PSSRC_ENTRY	pSSRC;

	IN_OUT_STR ("RTCP: Enter ownLoopback\n");

	// don't create an entry if received our own xmit back
	pSSRC = searchforSSRCatTail((PSSRC_ENTRY)pRTCPses->XmtSSRCList.prev,
								ssrc);

	IN_OUT_STR ("RTCP: Exit ownLoopback\n");

	if (pSSRC)
		return TRUE;
	else
		return FALSE;
	}



/*----------------------------------------------------------------------------
 * Function   : updateRRfeedback
 * Description: Update the Receiver Report feedback for an active source
 *
 * Input :      sd:			RTCP socket descriptor
 *				dwSndSSRC:	Sender's SSRC
 *				pRR:		-> to receiver report entry
 *				pSSRC:		-> to the SSRC entry
 *
 * Return: 		TRUE
 ---------------------------------------------------------------------------*/
 DWORD 	updateRRfeedback (SOCKET sd,
						  DWORD dwSndSSRC,
						  DWORD dwSSRCfedback,
						  RTCP_RR_T *pRR,
						  PSSRC_ENTRY pSSRC)
	{
	DWORD	dwHost;

	IN_OUT_STR ("RTCP: Enter updateRRfeedback\n");

	// Note when we last heard from the receiver
	pSSRC->rrFeedback.dwLastRcvRpt = timeGetTime();
	
	// SSRC who's feedback is for (ourselve for now)
	pSSRC->rrFeedback.SSRC = dwSSRCfedback;

	// get delay since last SR
	RRCMws.ntohl (sd, pRR->dlsr, &pSSRC->rrFeedback.dwDelaySinceLastSR);

	// get last SR
	RRCMws.ntohl (sd, pRR->lsr, &pSSRC->rrFeedback.dwLastSR);

	// get the jitter
	RRCMws.ntohl (sd, pRR->jitter, &pSSRC->rrFeedback.dwInterJitter);

	// highest sequence number received
	RRCMws.ntohl (sd, pRR->expected,
		&pSSRC->rrFeedback.XtendedSeqNum.seq_union.dwXtndedHighSeqNumRcvd);

	// fraction lost
	pSSRC->rrFeedback.fractionLost = (pRR->received & 0xFF);

	// cumulative number of packet lost
	RRCMws.ntohl (sd, pRR->received, &dwHost);
	dwHost &= 0x00FFFFFF;
	pSSRC->rrFeedback.cumNumPcktLost = dwHost;

	IN_OUT_STR ("RTCP: Exit updateRRfeedback\n");

	return TRUE;
	}



/*----------------------------------------------------------------------------
 * Function   : RTCPpostRecvBfr
 * Description: RTCP post a receive buffer to Winsock-2
 *
 * Input :      sd:			RTCP socket descriptor
 *				pSSRC:		-> to the SSRC entry
 *
 * Return: 		TRUE
 ---------------------------------------------------------------------------*/
 void RTCPpostRecvBfr (PSSRC_ENTRY pSSRC,
					   PRTCP_BFR_LIST pRcvStruct)
	{
	DWORD	dwStatus;
	DWORD	dwError;

	IN_OUT_STR ("RTCP: Enter RTCPpostRecvBfr\n");

	// decrement number of I/O pending
	InterlockedDecrement ((long *)&pSSRC->pRTCPses->dwNumRcvIoPending);

	// don't repost any buffer if within the shutdown procedure
	if ((pSSRC->pRTCPses->dwSessionStatus & SHUTDOWN_IN_PROGRESS) &&
		(pSSRC->pRTCPses->dwNumRcvIoPending == 0))
		{
		// shutdown done - set event
		if (SetEvent (pSSRC->pRTCPses->hShutdownDone) == FALSE)
			{
			RRCM_DBG_MSG ("RTCP: SetEvent() Error\n", GetLastError(),
						  __FILE__, __LINE__, DBG_ERROR);
			}

		IN_OUT_STR ("RTCP: Exit RTCPpostRecvBfr\n");
		return;
		}
	else if (pSSRC->pRTCPses->dwSessionStatus & SHUTDOWN_IN_PROGRESS)
		{
		IN_OUT_STR ("RTCP: Exit RTCPpostRecvBfr\n");
		return;
		}

	// clear number of bytes transferred
	pRcvStruct->dwNumBytesXfr = 0;

	dwStatus = RRCMws.recvFrom (pSSRC->RTCPsd,
		   			  			&pRcvStruct->bfr,
			              		pRcvStruct->dwBufferCount,
			   			  		&pRcvStruct->dwNumBytesXfr,
		   				  		&pRcvStruct->dwFlags,
		   				  		(PSOCKADDR)pRcvStruct->addr,
		    			  		&pRcvStruct->addrLen,
			   			  		(LPWSAOVERLAPPED)&pRcvStruct->overlapped,
			   			  		RTCPrcvCallback);

	// Check Winsock status
	if (dwStatus != 0)
		{
		// error, the receive request won't proceed
		dwError = GetLastError();
		if ((dwError != WSA_IO_PENDING) && (dwError != WSAEMSGSIZE))
			{
			RRCM_DBG_MSG ("RTCP: ERROR - WSARecvFrom()", dwError,
						  __FILE__, __LINE__, DBG_ERROR);

			// notify application if interested
			RRCMnotification (RRCM_RTCP_WS_RCV_ERROR, pSSRC,
							  pSSRC->SSRC, dwError);

			// Return the buffer to the free queue
			addToHeadOfList (&pSSRC->pRTCPses->RTCPrcvBfrList,
					 	  	 (PLINK_LIST)pRcvStruct,
							 &pSSRC->pRTCPses->critSect);
			}
		else
			{
			// increment number of I/O pending
			InterlockedIncrement ((long *)&pSSRC->pRTCPses->dwNumRcvIoPending);
			}
		}
	else
		{
		// synchronous completion - callback has been scheduled
		// increment number of I/O pending
		InterlockedIncrement ((long *)&pSSRC->pRTCPses->dwNumRcvIoPending);
		}

	IN_OUT_STR ("RTCP: Exit RTCPpostRecvBfr\n");
	}


/*----------------------------------------------------------------------------
 * Function   : addApplicationRtcpBfr
 * Description: Add an application provided buffer for RTCP to copy the
 *				raw received reports to be used by the application if it
 *				desired so.
 *
 * Input :      RTPsession:	Handle to the RTP session
 *				pAppBfr:	-> an application buffer data structure
 *
 * Return: 		TRUE
 ---------------------------------------------------------------------------*/
 HRESULT WINAPI addApplicationRtcpBfr (DWORD_PTR	RTPsession,
									    PAPP_RTCP_BFR pAppBfr)
	{
	IN_OUT_STR ("RTCP : Enter addApplicationRtcpBfr()\n");

	PRTP_SESSION    pSession = (PRTP_SESSION)RTPsession;
	PRTCP_SESSION	pRTCPSess;

	if (pSession == NULL)
		{
		RRCM_DBG_MSG ("RTCP : ERROR - Invalid RTP session", 0,
					  __FILE__, __LINE__, DBG_ERROR);

		IN_OUT_STR ("RTCP : Exit addApplicationRtcpBfr()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTPSessResources));
		}

	pRTCPSess = (PRTCP_SESSION)pSession->pRTCPSession;
	if (pRTCPSess == NULL)
		{
		RRCM_DBG_MSG ("RTCP : ERROR - Invalid RTCP session", 0,
					  __FILE__, __LINE__, DBG_ERROR);

		IN_OUT_STR ("RTCP : Exit addApplicationRtcpBfr()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTCPInvalidSession));
		}

	// Let's add this buffer to our list
	addToTailOfList(&(pRTCPSess->appRtcpBfrList),
					(PLINK_LIST)pAppBfr,
					&pRTCPSess->critSect);

	IN_OUT_STR ("RTCP : Exit addApplicationRtcpBfr()\n");

	return NOERROR;
	}


/*----------------------------------------------------------------------------
 * Function   : removeApplicationRtcpBfr
 * Description: Remove an application provided buffer to this RTCP session.
 *
 * Input :      RTPsession:	RTP session handle
 *
 * Return: 		Application buffer address / NULL
 ---------------------------------------------------------------------------*/
 PAPP_RTCP_BFR WINAPI removeApplicationRtcpBfr (DWORD_PTR RTPsession)
	{
	PRTP_SESSION    pSession = (PRTP_SESSION)RTPsession;
	PRTCP_SESSION	pRTCPSess;
	PAPP_RTCP_BFR	pAppBfr;

	IN_OUT_STR ("RTCP : Enter removeApplicationRtcpBfr()\n");

	if (pSession == NULL)
		{
		RRCM_DBG_MSG ("RTCP : ERROR - Invalid RTP session", 0,
					  __FILE__, __LINE__, DBG_ERROR);

		IN_OUT_STR ("RTCP : Exit removeApplicationRtcpBfr()\n");

		return NULL;
		}

	pRTCPSess = (PRTCP_SESSION)pSession->pRTCPSession;
	if (pRTCPSess == NULL)
		{
		RRCM_DBG_MSG ("RTCP : ERROR - Invalid RTCP session", 0,
					  __FILE__, __LINE__, DBG_ERROR);

		IN_OUT_STR ("RTCP : Exit removeApplicationRtcpBfr()\n");

		return NULL;
		}

	pAppBfr = (PAPP_RTCP_BFR)removePcktFromHead (&(pRTCPSess->appRtcpBfrList),
												 &pRTCPSess->critSect);

	IN_OUT_STR ("RTCP : Exit removeApplicationRtcpBfr()\n");

	return pAppBfr;
	}


// [EOF]





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtcp\rtcprept.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTCPREPT.C
 * Product:     RTP/RTCP implementation
 * Description: Provides report functions for the RRCM implementation.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with
 * Intel Corporation and may not be copied nor disclosed except in
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation.
 *--------------------------------------------------------------------------*/

		
#include "rrcm.h"


/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/
extern PRTCP_CONTEXT	pRTCPContext;
extern RRCM_WS			RRCMws;



/*----------------------------------------------------------------------------
 * Function   : RTCPReportRequest
 * Description: The application request a report for a particular RTCP
 *				session, identified by the socket descriptor.
 *
 * Input :		RTCPsd:				RTCP socket descriptor
 *				offset:				Offset to start from in the list
 *				*status:			-> to the report status information
 *				*moreEntries:		-> to a flag
 *				numEntriesInBfr:	Number of entries in buffer
 *				pReportBfr:			-> to report buffer
 *				iFilterFlags		Bit flags specifying filter to apply
 *				pFilterPattern		-> to value of filter pattern to use
 *				dwFltrPtrnLen		Filter pattern length
 *
 * Return:		OK: RRCM_NoError
 *				!0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
HRESULT WINAPI RTCPReportRequest (SOCKET RTCPsd,
							       DWORD offset,
								   DWORD *status,
								   DWORD *moreEntries,
								   DWORD numEntriesInBfr,
								   PRTCP_REPORT pReportBfr,
								   DWORD dwFilterFlags,
								   LPVOID pFilterPattern,
								   DWORD dwFltrPtrnLen)
	{
	PLINK_LIST	pTmp;
	PSSRC_ENTRY pRRCM;
	DWORD		dwStatus = RRCM_NoError;
	DWORD		numEntryWritten = 0;
	DWORD		index;
	DWORD		dwLost;
	DWORD		dwTmp;
	BOOL		matched;
	
	IN_OUT_STR ("RTCP: Enter RTCPReportRequest()\n");

	ASSERT (pReportBfr);
	ASSERT (numEntriesInBfr);

	// look for the RTCP session
	pTmp  = pRTCPContext->RTCPSession.prev;
	if (pTmp == NULL)
		{
		RRCM_DBG_MSG ("RTCP: ERROR - Invalid RTCP session", 0,
					  __FILE__, __LINE__, DBG_ERROR);
		IN_OUT_STR ("RTCP: Exit RTCPReportRequest()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTCPInvalidSession));
		}

	pRRCM = (PSSRC_ENTRY)((PRTCP_SESSION)pTmp)->XmtSSRCList.prev;
	if (pRRCM == NULL)
		{
		RRCM_DBG_MSG ("RCTP : ERROR - No RTCP Xmt list", 0,
					  __FILE__, __LINE__, DBG_ERROR);
		IN_OUT_STR ("RTCP: Exit RTCPReportRequest()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTCPNoXmtList));
		}

	while (pTmp)
		{
		if (pRRCM->RTCPsd == RTCPsd)
			break;
		else
			{
			pTmp  = pTmp->next;

			if (pTmp)
				{
				pRRCM = (PSSRC_ENTRY)((PRTCP_SESSION)pTmp)->XmtSSRCList.prev;
				}

			continue;
			}
		}

	if (pTmp == NULL)
		{
		RRCM_DBG_MSG ("RTCP: ERROR - Invalid RTCP session", 0,
					  __FILE__, __LINE__, DBG_ERROR);
		IN_OUT_STR ("RTCP: Exit RTCPReportRequest()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTCPInvalidSession));
		}

	if (dwFilterFlags && (pFilterPattern == NULL))
		{
		RRCM_DBG_MSG ("RTCP: ERROR - Invalid RTCP FilterPattern is NULL", 0,
					  __FILE__, __LINE__, DBG_ERROR);
		IN_OUT_STR ("RTCP: Exit RTCPReportRequest()\n");

		return (MAKE_RRCM_ERROR(RRCMError_RTCPInvalidRequest));
		}

	// go through the list of transmitters for this RTCP session
	pRRCM = (PSSRC_ENTRY)((PRTCP_SESSION)pTmp)->XmtSSRCList.prev;

	index = 0;
	while (pRRCM && numEntriesInBfr)
		{
		// go to the desired offset
		if (offset)
			{
			offset--;
			pRRCM = (PSSRC_ENTRY)pRRCM->SSRCList.next;
			continue;
			}

		if (dwFilterFlags)
			{
			matched = FALSE;
			switch (dwFilterFlags)
				{
				case FLTR_SSRC:
					if(pRRCM->SSRC == *((DWORD *)pFilterPattern))
						matched=TRUE;
					break;
				case FLTR_CNAME:
					if((memcmp ((char *)pFilterPattern,
								pRRCM->cnameInfo.sdesBfr,
								dwFltrPtrnLen)) == 0)
						matched = TRUE;
					break;
				default:
					RRCM_DBG_MSG ("RTCP: ERROR - Invalid FilterFlag", 0,
								  __FILE__, __LINE__, DBG_ERROR);
					IN_OUT_STR ("RTCP: Exit RTCPReportRequest()\n");

					return (MAKE_RRCM_ERROR(RRCMError_RTCPNotImpl));
				}
			if (!matched)
				{
				pRRCM = (PSSRC_ENTRY)pRRCM->SSRCList.next;
				continue;
				}
			else
				numEntriesInBfr--;
			}
		else
			numEntriesInBfr--;

		// fill in the our active Sender report information
		pReportBfr[index].status  = LOCAL_SSRC_RPT;
		pReportBfr[index].ssrc    = pRRCM->SSRC;

		// lock-out bytes update
		EnterCriticalSection (&pRRCM->critSect);

		pReportBfr[index].dwSrcNumPcktRealTime = pRRCM->xmtInfo.dwNumPcktSent;
		pReportBfr[index].dwSrcNumByteRealTime = pRRCM->xmtInfo.dwNumBytesSent;

		// release lock
		LeaveCriticalSection (&pRRCM->critSect);

		// a source - It's supposed to know it's own payload type
		pReportBfr[index].PayLoadType  = UNKNOWN_PAYLOAD_TYPE;

		// our own sampling frequency
		pReportBfr[index].dwStreamClock = pRRCM->dwStreamClock;

		if (pRRCM->cnameInfo.dwSdesLength)
			{
			memcpy (pReportBfr[index].cname,
					pRRCM->cnameInfo.sdesBfr,
					pRRCM->cnameInfo.dwSdesLength);

			pReportBfr[index].dwCnameLen = pRRCM->cnameInfo.dwSdesLength;
			}

		if (pRRCM->nameInfo.dwSdesLength)
			{
			memcpy (pReportBfr[index].name,
					pRRCM->nameInfo.sdesBfr,
					pRRCM->nameInfo.dwSdesLength);

			pReportBfr[index].dwNameLen = pRRCM->nameInfo.dwSdesLength;
			}

		if (pRRCM->fromLen)
			{
			memcpy (&pReportBfr[index].fromAddr,
					&pRRCM->from,
					pRRCM->fromLen);

			pReportBfr[index].dwFromLen = pRRCM->fromLen;
			}

		numEntryWritten++;
		index++;

		// go to next entry
		pRRCM = (PSSRC_ENTRY)pRRCM->SSRCList.next;
		}

	// go through the list of receivers for this RTCP session
	pRRCM = (PSSRC_ENTRY)((PRTCP_SESSION)pTmp)->RcvSSRCList.prev;

	while (pRRCM && numEntriesInBfr)
		{
		// go to the desired offset
		if (offset)
			{
			offset--;
			pRRCM = (PSSRC_ENTRY)pRRCM->SSRCList.next;
			continue;
			}

		if (dwFilterFlags)
			{
			matched = FALSE;
			switch (dwFilterFlags)
				{
				case FLTR_SSRC:
					if(pRRCM->SSRC == *((DWORD *)pFilterPattern))
						matched=TRUE;
					break;
				case FLTR_CNAME:
					if((memcmp ((char *)pFilterPattern,
								pRRCM->cnameInfo.sdesBfr,
								dwFltrPtrnLen)) == 0)
						matched = TRUE;
					break;
				default:
					RRCM_DBG_MSG ("RTCP: ERROR - Invalid FilterFlag", 0,
								  __FILE__, __LINE__, DBG_ERROR);
					IN_OUT_STR ("RTCP: Exit RTCPReportRequest()\n");

					return (MAKE_RRCM_ERROR(RRCMError_RTCPNotImpl));
				}
			if (!matched)
				{
				pRRCM = (PSSRC_ENTRY)pRRCM->SSRCList.next;
				continue;
				}
			else
				numEntriesInBfr--;
			}
		else
			numEntriesInBfr--;

		// fill in the Receiver report information
		pReportBfr[index].ssrc   = pRRCM->SSRC;
		pReportBfr[index].status = REMOTE_SSRC_RPT;

		// lock-out counters update
		EnterCriticalSection (&pRRCM->critSect);

#ifdef ENABLE_FLOATING_POINT
		pReportBfr[index].SrcJitter     = pRRCM->rcvInfo.interJitter;
#else
		// Check RFC for details of the round off
		pReportBfr[index].SrcJitter     = pRRCM->rcvInfo.interJitter >> 4;
#endif
		pReportBfr[index].dwSrcXtndNum  =
			pRRCM->rcvInfo.XtendedSeqNum.seq_union.dwXtndedHighSeqNumRcvd;

		// real time receive information
		pReportBfr[index].dwSrcNumPcktRealTime  = pRRCM->rcvInfo.dwNumPcktRcvd;
		pReportBfr[index].dwSrcNumByteRealTime  = pRRCM->rcvInfo.dwNumBytesRcvd;

		// get sender information from Sender's RTCP report
		pReportBfr[index].dwSrcNumPckt  = pRRCM->xmtInfo.dwNumPcktSent;
		pReportBfr[index].dwSrcNumByte  = pRRCM->xmtInfo.dwNumBytesSent;
		pReportBfr[index].dwSrcLsr      = pRRCM->xmtInfo.dwLastSR;
		pReportBfr[index].dwSrcNtpMsw   = pRRCM->xmtInfo.dwNTPmsw;
		pReportBfr[index].dwSrcNtpLsw   = pRRCM->xmtInfo.dwNTPlsw;
		pReportBfr[index].dwSrcRtpTs    = pRRCM->xmtInfo.dwRTPts;

		dwLost = getSSRCpcktLoss (pRRCM, FALSE);

		// release lock
		LeaveCriticalSection (&pRRCM->critSect);

		// the last payload seen on this RTP stream
		pReportBfr[index].PayLoadType  = pRRCM->PayLoadType;

		// last report received time
		pReportBfr[index].dwLastReportRcvdTime  = pRRCM->dwLastReportRcvdTime;

		// fraction lost is in network byte order
		pReportBfr[index].SrcFraction = (dwLost & 0xFF);

		// cumulative lost is a 24 bits value in network byte order
		RRCMws.ntohl (pRRCM->RTPsd, dwLost, &dwTmp);
		dwTmp &= 0x00FFFFFF;
		pReportBfr[index].SrcNumLost = dwTmp;

		// get feedback information
		if (pRRCM->rrFeedback.SSRC)
			{
			pReportBfr[index].status |= FEEDBACK_FOR_LOCAL_SSRC_PRESENT;
			memcpy (&pReportBfr[index].feedback, &pRRCM->rrFeedback,
					sizeof(RTCP_FEEDBACK));
			}

		if (pRRCM->cnameInfo.dwSdesLength)
			{
			memcpy (pReportBfr[index].cname,
					pRRCM->cnameInfo.sdesBfr,
					pRRCM->cnameInfo.dwSdesLength);

			pReportBfr[index].dwCnameLen = pRRCM->cnameInfo.dwSdesLength;
			}

		if (pRRCM->nameInfo.dwSdesLength)
			{
			memcpy (pReportBfr[index].name,
					pRRCM->nameInfo.sdesBfr,
					pRRCM->nameInfo.dwSdesLength);

			pReportBfr[index].dwNameLen = pRRCM->nameInfo.dwSdesLength;
			}

		if (pRRCM->fromLen)
			{
			memcpy (&pReportBfr[index].fromAddr,
					&pRRCM->from,
					pRRCM->fromLen);

			pReportBfr[index].dwFromLen = pRRCM->fromLen;
			}

		numEntryWritten++;
		index++;

		// go to next entry
		pRRCM = (PSSRC_ENTRY)pRRCM->SSRCList.next;
		}

	// check to see if there are additional entries
	if (pRRCM != NULL)
		*moreEntries = TRUE;

	*status = numEntryWritten;

	IN_OUT_STR ("RTCP: Exit RTCPReportRequest()\n");
	return (dwStatus);	
	}



/*----------------------------------------------------------------------------
 * Function   : getRtcpSessionList
 * Description: Get a list of current RTCP session.
 *
 * Input :		pSockBfr:		-> to a socket buffer
 *				pNumEntries:	-> to number of allocated entries in buffers.
 *				pNumUpdated:	-> number of entries updated
 *
 * Return:		OK: RRCM_NoError
 *				!0: Error code (see RRCM.H)
 ---------------------------------------------------------------------------*/
HRESULT WINAPI getRtcpSessionList (PDWORD_PTR pSockBfr,
								    DWORD dwNumEntries,
								    PDWORD pNumUpdated)
	{
	DWORD			dwStatus = RRCM_NoError;
	PRTCP_SESSION	pRTCP;
	PSSRC_ENTRY		pSSRC;

	IN_OUT_STR ("RTCP: Enter getRtpSessionList()\n");

	// lock out session's access
	EnterCriticalSection (&pRTCPContext->critSect);

	*pNumUpdated = 0;

	// look for the RTCP session
	pRTCP  = (PRTCP_SESSION)pRTCPContext->RTCPSession.prev;
	if (pRTCP == NULL)
		{
		// Unlock out session's access
		LeaveCriticalSection (&pRTCPContext->critSect);

		IN_OUT_STR ("RTCP: Exit getRtpSessionList()\n");

		return (MAKE_RRCM_ERROR (RRCMError_RTPNoSession));
		}

	// loop through the session's list
	while (pRTCP)
		{
		pSSRC = (PSSRC_ENTRY)pRTCP->XmtSSRCList.prev;
		if (pSSRC == NULL)
			{
			// Unlock out session's access
			LeaveCriticalSection (&pRTCPContext->critSect);

			RRCM_DBG_MSG ("RCTP : ERROR - No RTCP Xmt list", 0,
						  __FILE__, __LINE__, DBG_ERROR);

			IN_OUT_STR ("RTCP: Exit getRtpSessionList()\n");

			return (MAKE_RRCM_ERROR (RRCMError_RTCPNoXmtList));
			}

		if (dwNumEntries)
			{
			pSockBfr[*pNumUpdated] = pSSRC->RTCPsd;

			*pNumUpdated += 1;
			dwNumEntries --;
			}

		if (dwNumEntries == 0)
			{
			break;
			}

		// next entry
		pRTCP = (PRTCP_SESSION)(pRTCP->RTCPList.next);
		}

	// Unlock out session's access
	LeaveCriticalSection (&pRTCPContext->critSect);

	IN_OUT_STR ("RTCP: Exit getRtpSessionList()\n");

	return dwStatus;
	}

// [EOF]


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtcp\rrcmqueu.cpp ===
/*----------------------------------------------------------------------------
 * File:        RRCMQUEU.C
 * Product:     RTP/RTCP implementation.
 * Description: Provides queue management function for RRCM.
 *
 * INTEL Corporation Proprietary Information
 * This listing is supplied under the terms of a license agreement with 
 * Intel Corporation and may not be copied nor disclosed except in 
 * accordance with the terms of that agreement.
 * Copyright (c) 1995 Intel Corporation. 
 *--------------------------------------------------------------------------*/


#include "rrcm.h"                                    


 
/*---------------------------------------------------------------------------
/							Global Variables
/--------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
/							External Variables
/--------------------------------------------------------------------------*/

                                                                     
                                                                             
/*---------------------------------------------------------------------------
 * Function   : allocateLinkedList
 * Description: Allocates all the necessary memory resource and link the 
 *              cells to the link list.
 * 
 * Input :      *listPtr		: Address of head pointer.
 *				hHeap			: Heap to allocate the data from.
 *              *numCells		: -> to the number of cells to allocate.
 *				elementSize		: Element size.
 *				pCritSect		: -> to critical section
 *
 * Return: 		TRUE  = Error Code, no queues allocated and linked
 *         		FALSE = OK
 --------------------------------------------------------------------------*/
 DWORD allocateLinkedList (PLINK_LIST pList, 
 						   HANDLE hHeap,
 						   DWORD *numCells,
						   DWORD elementSize,
						   CRITICAL_SECTION *pCritSect)
	{
	DWORD		cellsAllocated = *numCells;
	PLINK_LIST	pHead;                            
	PLINK_LIST	pTmp;

	IN_OUT_STR ("RTCP: Enter allocateLinkedList()\n");
	
	// allocate first cell 
	pHead = (PLINK_LIST)HeapAlloc (hHeap, HEAP_ZERO_MEMORY, elementSize);
	if (pHead == NULL)
		{
		RRCM_DBG_MSG ("RTCP: ERROR - Resource allocation failed", 0, 
					  __FILE__, __LINE__, DBG_CRITICAL);

		IN_OUT_STR ("RTCP: Exit allocateLinkedList()\n");
		return (RRCMError_RTCPResources);
		}

	// protect the pointers
	EnterCriticalSection (pCritSect);
	
	// initialize list tail pointer 
	pList->prev = pHead;
	
	// update number of cells allocated 
	cellsAllocated--;

	while (cellsAllocated)	
		{
		cellsAllocated--;

		pHead->next = (PLINK_LIST)HeapAlloc (hHeap, HEAP_ZERO_MEMORY, 
											 elementSize);
		if (pHead->next == NULL)
			break;
    
    	// save head pointer 
    	pTmp = pHead;
    	
		// update head ptr 
		pHead = pHead->next;
		pHead->prev = pTmp;
		}                            
		
	// set number of cells allocated 
	*numCells -= cellsAllocated;
	
	// set head/tail pointers 
	pList->next = pHead;

	// unprotect the pointers
	LeaveCriticalSection (pCritSect);

	IN_OUT_STR ("RTCP: Exit allocateLinkedList()\n");	

	return (RRCM_NoError);
	} 

  
/*--------------------------------------------------------------------------
** Function   : addToHeadOfList
** Description: Add a new cell to the specified queue. The queue acts as a
**              FIFO (cells enqueud on the next pointer and dequeued by the
**              starting address of the queue).
**
** Input :		pHead		= Address of head pointer of queue.
**				pNew		= Cell address to be added to the linked list.
**				pCritSect	= -> to critical section object.
**
** Return: None.
--------------------------------------------------------------------------*/
void addToHeadOfList (PLINK_LIST pHead,
				 	  PLINK_LIST pNew,
					  CRITICAL_SECTION *pCritSect)
	{
	ASSERT (pHead);
	ASSERT (pNew);

	IN_OUT_STR ("RTCP: Enter addToHeadOfList()\n");	

	// safe access to pointers
	EnterCriticalSection (pCritSect);
		
	if (pHead->next == NULL) 
		{
		// head is NULL for the first cell. Assign the address of 
		// the free cell
		pHead->next = pHead->prev = pNew;
		pNew->next  = pNew->prev  = NULL;
		}
	else
		// head ptr points to something 
		{
		pNew->prev    = pHead->next;
		(pHead->next)->next = pNew;
		pNew->next    = NULL;

		// update the head pointer now 
		pHead->next = pNew;
		}

	// unlock pointer access 
	LeaveCriticalSection (pCritSect);

	IN_OUT_STR ("RTCP: Exit addToHeadOfList()\n");	
	}


/*--------------------------------------------------------------------------
** Function   : addToTailOfList
** Description: Add a new cell to the specified queue. The queue acts as a
**              FIFO (cells enqueud on the next pointer and dequeued by the
**              starting address of the queue).
**
** Input :		pTail	= Address of tail pointer to enqueue in.
**				pNew	= New cell address to be added to the linked list.
**
** Return: None.
--------------------------------------------------------------------------*/
void addToTailOfList (PLINK_LIST pTail,
				 	  PLINK_LIST pNew,
  					  CRITICAL_SECTION *pCritSect)
	{
	ASSERT (pTail);
	ASSERT (pNew);

	IN_OUT_STR ("RTCP: Enter addToTailOfList()\n");	

	// safe access to pointers
	EnterCriticalSection (pCritSect);
		
	if (pTail->prev == NULL) 
		{
		// head is NULL for the first cell. Assign the address of 
		// the free cell
		pTail->next = pTail->prev = pNew;
		pNew->next  = pNew->prev  = NULL;
		}
	else
		// tail ptr points to something 
		{
		pNew->next    = pTail->prev;
		(pTail->prev)->prev = pNew;
		pNew->prev    = NULL;

		// update the parent tail pointer now 
		pTail->prev = pNew;
		}

	// unlock pointer access 
	LeaveCriticalSection (pCritSect);

	IN_OUT_STR ("RTCP: Exit addToTailOfList()\n");	
	}


/*--------------------------------------------------------------------------
** Function   : removePcktFromHead
** Description: Remove a cell from front of the specified queue.
**
** Input :		pQueue:	-> to the list to remove the packet from
**
** Return: NULL 			==> Empty queue.
**         Buffer Address 	==> OK, cell removed
--------------------------------------------------------------------------*/
PLINK_LIST removePcktFromHead (PLINK_LIST pQueue,
							   CRITICAL_SECTION *pCritSect)
	{
	PLINK_LIST	pReturnQ;

	IN_OUT_STR ("RTCP: Enter removePcktFromHead()\n");	

	// safe access to pointers
	EnterCriticalSection (pCritSect);
		
	if ((pReturnQ = pQueue->next) != NULL) 
		{
		// We have a buffer.  If this is the last buffer in the queue,
		//	mark it empty.	    
	    if (pReturnQ->prev == NULL) 
			{
	    	pQueue->prev = NULL;
	    	pQueue->next = NULL;
			}
	    else 
			{
	    	// Have the new head buffer point to NULL
		    (pReturnQ->prev)->next = NULL;
		    // Have the queue head point to the new head buffer
	    	pQueue->next = pReturnQ->prev;
			}
		}

	// unlock pointer access 
	LeaveCriticalSection (pCritSect);

	IN_OUT_STR ("RTCP: Exit removePcktFromHead()\n");	

	return (pReturnQ);
	}


/*--------------------------------------------------------------------------
** Function   : removePcktFromTail
** Description: Remove a cell from end of the specified queue.
**
** Input :		pQueue:		-> to the list to remove the packet from
**
** Return:		NULL 			==> Empty queue.
**				Buffer Address 	==> OK, cell removed
--------------------------------------------------------------------------*/
PLINK_LIST removePcktFromTail (PLINK_LIST pQueue,
							   CRITICAL_SECTION *pCritSect)
	{
	PLINK_LIST	pReturnQ;

	IN_OUT_STR ("RTCP: Enter removePcktFromTail()\n");	

	// safe access to pointers
	EnterCriticalSection (pCritSect);
	
	if ((pReturnQ = pQueue->prev) != NULL) 
		{
		// We have a buffer.  If this is the last buffer in the queue,
		//	mark it empty.	    
	    if (pReturnQ->next == NULL) 
			{
	    	pQueue->prev = NULL;
	    	pQueue->next = NULL;
			}
	    else 
			{
		    // In any event, the new prev pointer is NULL: end of list
		    (pReturnQ->next)->prev = NULL;
	    	// have the queue prev pointer point to the new 'last' element
	    	pQueue->prev = pReturnQ->next;
			}
		}

	// unlock pointer access 
	LeaveCriticalSection (pCritSect);

	IN_OUT_STR ("RTCP: Enter removePcktFromTail()\n");	

	return (pReturnQ);
	}



// [EOF]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\rrcm\rtcp\rtcpsend.cpp ===
/*----------------------------------------------------------------------------
 * File:        RTCPIO.C
 * Product:     RTP/RTCP implementation
 * D